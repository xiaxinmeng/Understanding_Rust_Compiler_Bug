{"sha": "ca246e573fb3f53fba5794f72b9245382eb46180", "node_id": "C_kwDOANBUbNoAKGNhMjQ2ZTU3M2ZiM2Y1M2ZiYTU3OTRmNzJiOTI0NTM4MmViNDYxODA", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-08-23T15:32:26Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:06Z"}, "message": "gccrs: Add privacy checks\n\nThis pass is responsible for resolving the privacy of items and verifying\nthat access to these items is performed within the limits of that privacy.\nBy default, items in Rust are private and only public to the current\nmodule and its submodules. However, the user can annotate an item with\nvarious qualifiers such as `pub` to publicly expose an item. Furthermore,\na module path can be given to `pub` to restrict an item's privacy to a\ncertain module: These paths need to be resolved and later on checked by\nthe privacy error reporter.\n\n\tgcc/rust/\n\t* checks/errors/privacy/rust-privacy-check.cc: New.\n\t* checks/errors/privacy/rust-privacy-check.h: New.\n\t* checks/errors/privacy/rust-privacy-common.h: New.\n\t* checks/errors/privacy/rust-privacy-ctx.cc: New.\n\t* checks/errors/privacy/rust-privacy-ctx.h: New.\n\t* checks/errors/privacy/rust-privacy-reporter.cc: New.\n\t* checks/errors/privacy/rust-privacy-reporter.h: New.\n\t* checks/errors/privacy/rust-pub-restricted-visitor.cc: New.\n\t* checks/errors/privacy/rust-pub-restricted-visitor.h: New.\n\t* checks/errors/privacy/rust-reachability.cc: New.\n\t* checks/errors/privacy/rust-reachability.h: New.\n\t* checks/errors/privacy/rust-visibility-resolver.cc: New.\n\t* checks/errors/privacy/rust-visibility-resolver.h: New.", "tree": {"sha": "106c5834069c035ac3799ea77014508a7b5dd475", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/106c5834069c035ac3799ea77014508a7b5dd475"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca246e573fb3f53fba5794f72b9245382eb46180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca246e573fb3f53fba5794f72b9245382eb46180", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca246e573fb3f53fba5794f72b9245382eb46180", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca246e573fb3f53fba5794f72b9245382eb46180/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5215235f01665062fbe182bb0c3c49539d882ad7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5215235f01665062fbe182bb0c3c49539d882ad7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5215235f01665062fbe182bb0c3c49539d882ad7"}], "stats": {"total": 2263, "additions": 2263, "deletions": 0}, "files": [{"sha": "9664d62f65c4fa2ebc8f5a38d832f431e203a13c", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-check.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-check.cc?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-privacy-check.h\"\n+#include \"rust-reachability.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-visibility-resolver.h\"\n+#include \"rust-pub-restricted-visitor.h\"\n+#include \"rust-privacy-reporter.h\"\n+\n+extern bool\n+saw_errors (void);\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+void\n+Resolver::resolve (HIR::Crate &crate)\n+{\n+  PrivacyContext ctx;\n+  auto mappings = Analysis::Mappings::get ();\n+  auto resolver = Rust::Resolver::Resolver::get ();\n+  auto ty_ctx = ::Rust::Resolver::TypeCheckContext::get ();\n+\n+  VisibilityResolver (*mappings, *resolver).go (crate);\n+  PubRestrictedVisitor (*mappings).go (crate);\n+  PrivacyReporter (*mappings, *resolver, *ty_ctx).go (crate);\n+\n+  auto visitor = ReachabilityVisitor (ctx, *ty_ctx);\n+\n+  const auto &items = crate.items;\n+\n+  for (auto &item : items)\n+    {\n+      if (item->get_hir_kind () == HIR::Node::VIS_ITEM)\n+\t{\n+\t  auto vis_item = static_cast<HIR::VisItem *> (item.get ());\n+\t  vis_item->accept_vis (visitor);\n+\t}\n+    }\n+\n+  if (saw_errors ())\n+    return;\n+}\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "290b5eacb6ce01cfc32ed88e98998081ab98857e", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-check.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-check.h?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,44 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_PRIVACY_CHECK_H\n+#define RUST_PRIVACY_CHECK_H\n+\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+class Resolver\n+{\n+public:\n+  /**\n+   * Perform the full privacy resolving pass on a crate.\n+   *\n+   * This resolver first computes the reachability of all items in a crate,\n+   * before checking for privacy violations.\n+   */\n+  static void resolve (HIR::Crate &crate);\n+};\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#endif // !RUST_PRIVACY_CHECK_H"}, {"sha": "ceafe91d8867e2cd2b88c22f3dd2ca68b35f2fc8", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-common.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-common.h?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-mapping-common.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+/**\n+ * Visibility class related specifically to DefIds. This class allows defining\n+ * the visibility of an item with regard to a specific module.\n+ *\n+ * Items are either public throughout a crate, or restricted to a specific\n+ * module. Private items are simply restricted to the current module.\n+ */\n+class ModuleVisibility\n+{\n+public:\n+  enum Type\n+  {\n+    Unknown,\n+    Public,\n+    Restricted,\n+  };\n+\n+  ModuleVisibility () : kind (Unknown), module_id (UNKNOWN_DEFID) {}\n+\n+  static ModuleVisibility create_restricted (DefId module_id)\n+  {\n+    return ModuleVisibility (Type::Restricted, module_id);\n+  }\n+\n+  static ModuleVisibility create_public ()\n+  {\n+    return ModuleVisibility (Type::Public, UNKNOWN_DEFID);\n+  }\n+\n+  Type get_kind () const { return kind; }\n+\n+  const DefId &get_module_id () const { return module_id; }\n+  DefId &get_module_id () { return module_id; }\n+\n+private:\n+  ModuleVisibility (Type kind, DefId module_id)\n+    : kind (kind), module_id (module_id)\n+  {}\n+\n+  Type kind;\n+  DefId module_id;\n+};\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "9ebc86988e9fa4b29560dd9a90d94afa8f17501d", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-ctx.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-ctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-ctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-ctx.cc?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,93 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-privacy-ctx.h\"\n+#include \"selftest.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+static ReachLevel\n+insert_if_higher (ReachLevel new_level,\n+\t\t  std::unordered_map<DefId, ReachLevel>::iterator &existing)\n+{\n+  if (new_level > existing->second)\n+    existing->second = new_level;\n+\n+  return existing->second;\n+}\n+\n+ReachLevel\n+PrivacyContext::update_reachability (const Analysis::NodeMapping &mapping,\n+\t\t\t\t     ReachLevel reach)\n+{\n+  auto def_id = mapping.get_defid ();\n+  auto existing_reach = reachability_map.find (def_id);\n+  if (existing_reach != reachability_map.end ())\n+    return insert_if_higher (reach, existing_reach);\n+\n+  reachability_map.insert ({def_id, reach});\n+  return reach;\n+}\n+\n+const ReachLevel *\n+PrivacyContext::lookup_reachability (const Analysis::NodeMapping &mapping)\n+{\n+  auto existing_reach = reachability_map.find (mapping.get_defid ());\n+  if (existing_reach == reachability_map.end ())\n+    return nullptr;\n+\n+  return &existing_reach->second;\n+}\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#if CHECKING_P\n+namespace selftest {\n+static void\n+update_reachability_test (void)\n+{\n+  auto ctx = Rust::Privacy::PrivacyContext ();\n+  // Bogus values for the mappings\n+  auto mapping = Rust::Analysis::NodeMapping (15, 15, 15, 15);\n+\n+  auto new_level\n+    = ctx.update_reachability (mapping, Rust::Privacy::ReachLevel::Unreachable);\n+\n+  ASSERT_EQ (new_level, Rust::Privacy::ReachLevel::Unreachable);\n+\n+  ASSERT_TRUE (ctx.lookup_reachability (mapping));\n+  ASSERT_EQ (*ctx.lookup_reachability (mapping),\n+\t     Rust::Privacy::ReachLevel::Unreachable);\n+\n+  new_level\n+    = ctx.update_reachability (mapping, Rust::Privacy::ReachLevel::Reachable);\n+\n+  ASSERT_EQ (new_level, Rust::Privacy::ReachLevel::Reachable);\n+  ASSERT_TRUE (ctx.lookup_reachability (mapping));\n+  ASSERT_EQ (*ctx.lookup_reachability (mapping),\n+\t     Rust::Privacy::ReachLevel::Reachable);\n+}\n+\n+void\n+rust_privacy_ctx_test (void)\n+{\n+  update_reachability_test ();\n+}\n+} // namespace selftest\n+#endif // !CHECKING_P"}, {"sha": "52d790edf63fd11fc693b3b98061f8bdc0242151", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-ctx.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-ctx.h?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_PRIVACY_CTX_H\n+#define RUST_PRIVACY_CTX_H\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-privacy-check.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+/**\n+ * Reachability levels of HIR nodes. These levels are computed through the\n+ * `ReachabilityVisitor` visitor.\n+ */\n+enum ReachLevel\n+{\n+  Unreachable,\n+  Reachable,\n+};\n+\n+class PrivacyContext\n+{\n+public:\n+  /**\n+   * Insert a new resolved visibility for a given node. If the node is already\n+   * present in the reachability map, then its visibility will only be updated\n+   * if the given visibility is higher.\n+   *\n+   * @param mappings Mappings of the node to store the reach level for\n+   * @param reach Level of reachability for the given node\n+   *\n+   * @return The new reachability level for this node. If this was the first\n+   * time inserting this node, then return `reach`. Otherwise, return `reach` or\n+   * the existing reach level if it was higher.\n+   */\n+  ReachLevel update_reachability (const Analysis::NodeMapping &mapping,\n+\t\t\t\t  ReachLevel reach);\n+\n+  /**\n+   * Lookup the visibility of an already declared Node\n+   *\n+   * @param mapping Mappings of the node to fetch the reach level of\n+   *\n+   * @return `nullptr` if the reach level for the current node has not been\n+   * added, a valid pointer otherwise\n+   */\n+  const ReachLevel *lookup_reachability (const Analysis::NodeMapping &mapping);\n+\n+private:\n+  std::unordered_map<DefId, ReachLevel> reachability_map;\n+};\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#if CHECKING_P\n+namespace selftest {\n+void\n+rust_privacy_ctx_test (void);\n+}\n+#endif // !CHECKING_P\n+\n+#endif // !RUST_PRIVACY_CTX_H"}, {"sha": "3c9380af73209ca3e8b49f74a34ce0c09bc00195", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-reporter.cc", "status": "added", "additions": 771, "deletions": 0, "changes": 771, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.cc?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,771 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-privacy-reporter.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+PrivacyReporter::PrivacyReporter (\n+  Analysis::Mappings &mappings, Resolver::Resolver &resolver,\n+  const Rust::Resolver::TypeCheckContext &ty_ctx)\n+  : mappings (mappings), resolver (resolver), ty_ctx (ty_ctx),\n+    current_module (Optional<NodeId>::none ())\n+{}\n+\n+void\n+PrivacyReporter::go (HIR::Crate &crate)\n+{\n+  for (auto &item : crate.items)\n+    item->accept_vis (*this);\n+}\n+\n+static bool\n+is_child_module (Analysis::Mappings &mappings, NodeId parent,\n+\t\t NodeId possible_child)\n+{\n+  auto children = mappings.lookup_module_children (parent);\n+\n+  if (!children)\n+    return false;\n+\n+  // Visit all toplevel children\n+  for (auto &child : *children)\n+    if (child == possible_child)\n+      return true;\n+\n+  // Now descend recursively in the child module tree\n+  for (auto &child : *children)\n+    if (is_child_module (mappings, child, possible_child))\n+      return true;\n+\n+  return false;\n+}\n+\n+// FIXME: This function needs a lot of refactoring\n+void\n+PrivacyReporter::check_for_privacy_violation (const NodeId &use_id,\n+\t\t\t\t\t      const Location &locus)\n+{\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+\n+  // FIXME: Don't assert here - we might be dealing with a type\n+  if (!resolver.lookup_resolved_name (use_id, &ref_node_id))\n+    resolver.lookup_resolved_type (use_id, &ref_node_id);\n+\n+  // FIXME: Assert here. For now, we return since this causes issues when\n+  // checking inferred types (#1260)\n+  // rust_assert (ref_node_id != UNKNOWN_NODEID);\n+  if (ref_node_id == UNKNOWN_NODEID)\n+    return;\n+\n+  ModuleVisibility vis;\n+\n+  // FIXME: Can we really return here if the item has no visibility?\n+  if (!mappings.lookup_visibility (ref_node_id, vis))\n+    return;\n+\n+  auto valid = true;\n+\n+  switch (vis.get_kind ())\n+    {\n+    case ModuleVisibility::Public:\n+      break;\n+      case ModuleVisibility::Restricted: {\n+\t// If we are in the crate, everything is restricted correctly, but we\n+\t// can't get a module for it\n+\tif (current_module.is_none ())\n+\t  return;\n+\n+\tauto module = mappings.lookup_defid (vis.get_module_id ());\n+\trust_assert (module != nullptr);\n+\n+\tauto mod_node_id = module->get_mappings ().get_nodeid ();\n+\n+\t// We are in the module referenced by the pub(restricted) visibility.\n+\t// This is valid\n+\tif (mod_node_id == current_module.get ())\n+\t  break;\n+\n+\t// FIXME: This needs a LOT of TLC: hinting about the definition, a\n+\t// string to say if it's a module, function, type, etc...\n+\tif (!is_child_module (mappings, mod_node_id, current_module.get ()))\n+\t  valid = false;\n+      }\n+      break;\n+    case ModuleVisibility::Unknown:\n+      rust_unreachable ();\n+      break;\n+    }\n+\n+  if (!valid)\n+    rust_error_at (locus, \"definition is private in this context\");\n+}\n+\n+void\n+PrivacyReporter::check_base_type_privacy (Analysis::NodeMapping &node_mappings,\n+\t\t\t\t\t  const TyTy::BaseType *ty,\n+\t\t\t\t\t  const Location &locus)\n+{\n+  // Avoids repeating commong argument such as `use_id` or `locus` since we're\n+  // doing a lot of recursive calls here\n+  auto recursive_check\n+    = [this, &node_mappings, &locus] (const TyTy::BaseType *ty) {\n+\treturn check_base_type_privacy (node_mappings, ty, locus);\n+      };\n+\n+  switch (ty->get_kind ())\n+    {\n+      // These \"simple\" types are our stop condition\n+    case TyTy::BOOL:\n+    case TyTy::CHAR:\n+    case TyTy::INT:\n+    case TyTy::UINT:\n+    case TyTy::FLOAT:\n+    case TyTy::USIZE:\n+    case TyTy::ISIZE:\n+    case TyTy::ADT:\n+      case TyTy::STR: {\n+\tauto ref_id = ty->get_ref ();\n+\tNodeId lookup_id;\n+\n+\tbool ok = mappings.lookup_hir_to_node (ref_id, &lookup_id);\n+\trust_assert (ok);\n+\n+\treturn check_for_privacy_violation (lookup_id, locus);\n+      }\n+    case TyTy::REF:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ReferenceType *> (ty)->get_base ());\n+    case TyTy::POINTER:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::PointerType *> (ty)->get_base ());\n+    case TyTy::ARRAY:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ArrayType *> (ty)->get_element_type ());\n+    case TyTy::SLICE:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::SliceType *> (ty)->get_element_type ());\n+    case TyTy::FNPTR:\n+      for (auto &param : static_cast<const TyTy::FnPtr *> (ty)->get_params ())\n+\trecursive_check (param.get_tyty ());\n+      return recursive_check (\n+\tstatic_cast<const TyTy::FnPtr *> (ty)->get_return_type ());\n+    case TyTy::TUPLE:\n+      for (auto &param :\n+\t   static_cast<const TyTy::TupleType *> (ty)->get_fields ())\n+\trecursive_check (param.get_tyty ());\n+      return;\n+    case TyTy::PLACEHOLDER:\n+      return recursive_check (\n+\t// FIXME: Can we use `resolve` here? Is that what we should do?\n+\tstatic_cast<const TyTy::PlaceholderType *> (ty)->resolve ());\n+    case TyTy::PROJECTION:\n+      return recursive_check (\n+\tstatic_cast<const TyTy::ProjectionType *> (ty)->get ());\n+    case TyTy::CLOSURE:\n+      rust_sorry_at (locus, \"privacy pass for closures is not handled yet\");\n+      break;\n+\n+      // If we're dealing with a generic param, there's nothing we should be\n+      // doing here\n+    case TyTy::PARAM:\n+      // We are dealing with a function definition that has been assigned\n+      // somewhere else. Nothing to resolve privacy-wise other than the actual\n+      // function, which is resolved as an expression\n+    case TyTy::FNDEF:\n+      // FIXME: Can we really not resolve Dynamic types here? Shouldn't we have\n+      // a look at the path and perform proper privacy analysis?\n+    case TyTy::DYNAMIC:\n+      // The never type is builtin and always available\n+    case TyTy::NEVER:\n+      // We shouldn't have inference types here, ever\n+    case TyTy::INFER:\n+      return;\n+    case TyTy::ERROR:\n+      rust_unreachable ();\n+    }\n+}\n+\n+void\n+PrivacyReporter::check_type_privacy (const HIR::Type *type)\n+{\n+  rust_assert (type);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  rust_assert (\n+    ty_ctx.lookup_type (type->get_mappings ().get_hirid (), &lookup));\n+\n+  auto node_mappings = type->get_mappings ();\n+  return check_base_type_privacy (node_mappings, lookup, type->get_locus ());\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::PathInExpression &path)\n+{\n+  check_for_privacy_violation (path.get_mappings ().get_nodeid (),\n+\t\t\t       path.get_locus ());\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TypePathSegmentFunction &segment)\n+{\n+  // FIXME: Do we need to do anything for this?\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TypePath &path)\n+{\n+  check_for_privacy_violation (path.get_mappings ().get_nodeid (),\n+\t\t\t       path.get_locus ());\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::QualifiedPathInExpression &path)\n+{\n+  check_for_privacy_violation (path.get_mappings ().get_nodeid (),\n+\t\t\t       path.get_locus ());\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::QualifiedPathInType &path)\n+{\n+  check_for_privacy_violation (path.get_mappings ().get_nodeid (),\n+\t\t\t       path.get_locus ());\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::LiteralExpr &expr)\n+{\n+  // Literals cannot contain any sort of privacy violation\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::BorrowExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::DereferenceExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ErrorPropagationExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::NegationExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ArithmeticOrLogicalExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ComparisonExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::LazyBooleanExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TypeCastExpr &expr)\n+{\n+  expr.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::AssignmentExpr &expr)\n+{\n+  expr.get_lhs ()->accept_vis (*this);\n+  expr.get_rhs ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::CompoundAssignmentExpr &expr)\n+{\n+  expr.get_left_expr ()->accept_vis (*this);\n+  expr.get_right_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::GroupedExpr &expr)\n+{\n+  expr.get_expr_in_parens ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ArrayExpr &expr)\n+{\n+  HIR::ArrayElems &elements = *expr.get_internal_elements ();\n+  switch (elements.get_array_expr_type ())\n+    {\n+      case HIR::ArrayElems::ArrayExprType::VALUES: {\n+\tHIR::ArrayElemsValues &elems\n+\t  = static_cast<HIR::ArrayElemsValues &> (elements);\n+\tfor (auto &value : elems.get_values ())\n+\t  value->accept_vis (*this);\n+      }\n+      return;\n+\n+    case HIR::ArrayElems::ArrayExprType::COPIED:\n+      HIR::ArrayElemsCopied &elems\n+\t= static_cast<HIR::ArrayElemsCopied &> (elements);\n+      elems.get_elem_to_copy ()->accept_vis (*this);\n+    }\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ArrayIndexExpr &expr)\n+{\n+  expr.get_array_expr ()->accept_vis (*this);\n+  expr.get_index_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleExpr &expr)\n+{\n+  for (auto &value : expr.get_tuple_elems ())\n+    value->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleIndexExpr &expr)\n+{\n+  expr.get_tuple_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprStruct &expr)\n+{\n+  // FIXME: We need to check the visibility of the type it refers to here\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprFieldIdentifier &field)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprFieldIdentifierValue &field)\n+{\n+  field.get_value ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprFieldIndexValue &field)\n+{\n+  field.get_value ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::StructExprStructFields &expr)\n+{\n+  for (auto &field : expr.get_fields ())\n+    field->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::CallExpr &expr)\n+{\n+  expr.get_fnexpr ()->accept_vis (*this);\n+\n+  for (auto &param : expr.get_arguments ())\n+    param->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::MethodCallExpr &expr)\n+{\n+  expr.get_receiver ()->accept_vis (*this);\n+\n+  for (auto &param : expr.get_arguments ())\n+    param->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::FieldAccessExpr &expr)\n+{\n+  expr.get_receiver_expr ()->accept_vis (*this);\n+\n+  // FIXME: We should also check if the field is public?\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ClosureExprInner &expr)\n+{\n+  // Not handled yet\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::BlockExpr &expr)\n+{\n+  for (auto &stmt : expr.get_statements ())\n+    stmt->accept_vis (*this);\n+\n+  auto &last_expr = expr.get_final_expr ();\n+  if (last_expr)\n+    last_expr->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ClosureExprInnerTyped &expr)\n+{\n+  // Not handled yet\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ContinueExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::BreakExpr &expr)\n+{\n+  auto &break_expr = expr.get_expr ();\n+  if (break_expr)\n+    break_expr->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeFromToExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeFromExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeToExpr &expr)\n+{\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeFullExpr &expr)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeFromToInclExpr &expr)\n+{\n+  expr.get_from_expr ()->accept_vis (*this);\n+  expr.get_to_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::RangeToInclExpr &expr)\n+{\n+  // Not handled yet\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ReturnExpr &expr)\n+{\n+  auto return_expr = expr.get_expr ();\n+  if (return_expr)\n+    return_expr->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::UnsafeBlockExpr &expr)\n+{\n+  expr.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::LoopExpr &expr)\n+{\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::WhileLoopExpr &expr)\n+{\n+  expr.get_predicate_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::WhileLetLoopExpr &expr)\n+{\n+  expr.get_cond ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ForLoopExpr &expr)\n+{\n+  expr.get_iterator_expr ()->accept_vis (*this);\n+  expr.get_loop_block ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IfExpr &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IfExprConseqElse &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_else_block ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IfExprConseqIf &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+  expr.get_conseq_if_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IfExprConseqIfLet &expr)\n+{\n+  expr.get_if_condition ()->accept_vis (*this);\n+  expr.get_if_block ()->accept_vis (*this);\n+\n+  // TODO: We need to visit the if_let_expr as well\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IfLetExpr &expr)\n+{\n+  // TODO: We need to visit the if_let_expr\n+  // TODO: We need to visit the block as well\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IfLetExprConseqElse &expr)\n+{\n+  // TODO: We need to visit the if_let_expr\n+  // TODO: We need to visit the if_block as well\n+  // TODO: We need to visit the else_block as well\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IfLetExprConseqIf &expr)\n+{\n+  // TODO: We need to visit the if_let_expr\n+  // TODO: We need to visit the if_block as well\n+  // TODO: We need to visit the else_block as well\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::IfLetExprConseqIfLet &expr)\n+{\n+  // TODO: We need to visit the if_let_expr\n+  // TODO: We need to visit the if_block as well\n+  // TODO: We need to visit the else_block as well\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::MatchExpr &expr)\n+{\n+  expr.get_scrutinee_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::AwaitExpr &expr)\n+{\n+  // Not handled yet\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::AsyncBlockExpr &expr)\n+{\n+  // Not handled yet\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::Module &module)\n+{\n+  // FIXME: We also need to think about module privacy\n+\n+  auto old_module = current_module;\n+  current_module\n+    = Optional<NodeId>::some (module.get_mappings ().get_nodeid ());\n+\n+  for (auto &item : module.get_items ())\n+    item->accept_vis (*this);\n+\n+  current_module = old_module;\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ExternCrate &crate)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::UseDeclaration &use_decl)\n+{\n+  // FIXME: Is there anything we need to do here?\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::Function &function)\n+{\n+  for (auto &param : function.get_function_params ())\n+    check_type_privacy (param.get_type ());\n+\n+  function.get_definition ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TypeAlias &type_alias)\n+{\n+  // TODO: Check the type here\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::StructStruct &struct_item)\n+{\n+  // TODO: Check the type of all fields\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::TupleStruct &tuple_struct)\n+{\n+  // TODO: Check the type of all fields\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::EnumItem &item)\n+{\n+  // TODO: Check the type of all variants\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::EnumItemTuple &item)\n+{\n+  // TODO: Check the type\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::EnumItemStruct &item)\n+{\n+  // TODO: Check the type\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::EnumItemDiscriminant &item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::Enum &enum_item)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::Union &union_item)\n+{\n+  // TODO: Check the type\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ConstantItem &const_item)\n+{\n+  // TODO: We need to visit the type\n+  const_item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::StaticItem &static_item)\n+{\n+  // TODO: We need to visit the type\n+  static_item.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::Trait &trait)\n+{\n+  // FIXME: We need to be an ItemVisitor as well\n+  // for (auto &item : trait.get_trait_items ())\n+  //   item->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ImplBlock &impl)\n+{\n+  for (auto &item : impl.get_impl_items ())\n+    item->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ExternBlock &block)\n+{\n+  // FIXME: We need to be an ItemVisitor as well\n+  // for (auto &item : block.get_extern_items ())\n+  //   item->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::EmptyStmt &stmt)\n+{}\n+\n+void\n+PrivacyReporter::visit (HIR::LetStmt &stmt)\n+{\n+  auto type = stmt.get_type ();\n+  if (type)\n+    check_type_privacy (type);\n+\n+  auto init_expr = stmt.get_init_expr ();\n+  if (init_expr)\n+    init_expr->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ExprStmtWithoutBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+void\n+PrivacyReporter::visit (HIR::ExprStmtWithBlock &stmt)\n+{\n+  stmt.get_expr ()->accept_vis (*this);\n+}\n+\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "546b108f36d800c9c4a328c5dd3cfda0ce9609b0", "filename": "gcc/rust/checks/errors/privacy/rust-privacy-reporter.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-privacy-reporter.h?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,173 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_PRIVACY_REPORTER_H\n+#define RUST_PRIVACY_REPORTER_H\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-mapping-common.h\"\n+#include \"rust-name-resolver.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+/**\n+ * This visitor visits all items and expressions of a crate and reports privacy\n+ * violations. It should be started after using the `VisibilityResolver` visitor\n+ * which resolves the visibilities of all items of a crate.\n+ */\n+class PrivacyReporter : public HIR::HIRExpressionVisitor,\n+\t\t\tpublic HIR::HIRStmtVisitor\n+{\n+public:\n+  PrivacyReporter (Analysis::Mappings &mappings,\n+\t\t   Rust::Resolver::Resolver &resolver,\n+\t\t   const Rust::Resolver::TypeCheckContext &ty_ctx);\n+\n+  /**\n+   * Perform privacy error reporting on an entire crate\n+   */\n+  void go (HIR::Crate &crate);\n+\n+private:\n+  /**\n+   * Check if a given item's visibility is accessible from the current module.\n+   *\n+   * This function reports the errors it finds.\n+   *\n+   * @param use_id NodeId of the expression/statement referencing an item with\n+   * \t\ta visibility\n+   * @param locus Location of said expression/statement\n+   */\n+  void check_for_privacy_violation (const NodeId &use_id,\n+\t\t\t\t    const Location &locus);\n+\n+  /**\n+   * Internal function used by `check_type_privacy` when dealing with complex\n+types\n+   * such as references or arrays\n+   */\n+  void check_base_type_privacy (Analysis::NodeMapping &node_mappings,\n+\t\t\t\tconst TyTy::BaseType *ty,\n+\t\t\t\tconst Location &locus);\n+\n+  /**\n+   * Check the privacy of an explicit type.\n+   *\n+   * This function reports the errors it finds.\n+   *\n+   * @param type Reference to an explicit type used in a statement, expression\n+   * \t\tor parameter\n+   */\n+  void check_type_privacy (const HIR::Type *type);\n+\n+  virtual void visit (HIR::StructExprFieldIdentifier &field);\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &field);\n+  virtual void visit (HIR::StructExprFieldIndexValue &field);\n+\n+  virtual void visit (HIR::QualifiedPathInExpression &expr);\n+  virtual void visit (HIR::PathInExpression &expr);\n+  virtual void visit (HIR::ClosureExprInnerTyped &);\n+  virtual void visit (HIR::ClosureExprInner &expr);\n+  virtual void visit (HIR::StructExprStructFields &);\n+  virtual void visit (HIR::StructExprStruct &);\n+  virtual void visit (HIR::LiteralExpr &expr);\n+  virtual void visit (HIR::BorrowExpr &expr);\n+  virtual void visit (HIR::DereferenceExpr &expr);\n+  virtual void visit (HIR::ErrorPropagationExpr &expr);\n+  virtual void visit (HIR::NegationExpr &expr);\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &expr);\n+  virtual void visit (HIR::ComparisonExpr &expr);\n+  virtual void visit (HIR::LazyBooleanExpr &expr);\n+  virtual void visit (HIR::TypeCastExpr &expr);\n+  virtual void visit (HIR::AssignmentExpr &expr);\n+  virtual void visit (HIR::CompoundAssignmentExpr &expr);\n+  virtual void visit (HIR::GroupedExpr &expr);\n+  virtual void visit (HIR::ArrayExpr &expr);\n+  virtual void visit (HIR::ArrayIndexExpr &expr);\n+  virtual void visit (HIR::TupleExpr &expr);\n+  virtual void visit (HIR::TupleIndexExpr &expr);\n+  virtual void visit (HIR::CallExpr &expr);\n+  virtual void visit (HIR::MethodCallExpr &expr);\n+  virtual void visit (HIR::FieldAccessExpr &expr);\n+  virtual void visit (HIR::BlockExpr &expr);\n+  virtual void visit (HIR::ContinueExpr &expr);\n+  virtual void visit (HIR::BreakExpr &expr);\n+  virtual void visit (HIR::RangeFromToExpr &expr);\n+  virtual void visit (HIR::RangeFromExpr &expr);\n+  virtual void visit (HIR::RangeToExpr &expr);\n+  virtual void visit (HIR::RangeFullExpr &expr);\n+  virtual void visit (HIR::RangeFromToInclExpr &expr);\n+  virtual void visit (HIR::RangeToInclExpr &expr);\n+  virtual void visit (HIR::ReturnExpr &expr);\n+  virtual void visit (HIR::UnsafeBlockExpr &expr);\n+  virtual void visit (HIR::LoopExpr &expr);\n+  virtual void visit (HIR::WhileLoopExpr &expr);\n+  virtual void visit (HIR::WhileLetLoopExpr &expr);\n+  virtual void visit (HIR::ForLoopExpr &expr);\n+  virtual void visit (HIR::IfExpr &expr);\n+  virtual void visit (HIR::IfExprConseqElse &expr);\n+  virtual void visit (HIR::IfExprConseqIf &expr);\n+  virtual void visit (HIR::IfExprConseqIfLet &expr);\n+  virtual void visit (HIR::IfLetExpr &expr);\n+  virtual void visit (HIR::IfLetExprConseqElse &expr);\n+  virtual void visit (HIR::IfLetExprConseqIf &expr);\n+  virtual void visit (HIR::IfLetExprConseqIfLet &expr);\n+  virtual void visit (HIR::MatchExpr &expr);\n+  virtual void visit (HIR::AwaitExpr &expr);\n+  virtual void visit (HIR::AsyncBlockExpr &expr);\n+\n+  virtual void visit (HIR::EnumItemTuple &);\n+  virtual void visit (HIR::EnumItemStruct &);\n+  virtual void visit (HIR::EnumItem &item);\n+  virtual void visit (HIR::TupleStruct &tuple_struct);\n+  virtual void visit (HIR::EnumItemDiscriminant &);\n+  virtual void visit (HIR::TypePathSegmentFunction &segment);\n+  virtual void visit (HIR::TypePath &path);\n+  virtual void visit (HIR::QualifiedPathInType &path);\n+  virtual void visit (HIR::Module &module);\n+  virtual void visit (HIR::ExternCrate &crate);\n+  virtual void visit (HIR::UseDeclaration &use_decl);\n+  virtual void visit (HIR::Function &function);\n+  virtual void visit (HIR::TypeAlias &type_alias);\n+  virtual void visit (HIR::StructStruct &struct_item);\n+  virtual void visit (HIR::Enum &enum_item);\n+  virtual void visit (HIR::Union &union_item);\n+  virtual void visit (HIR::ConstantItem &const_item);\n+  virtual void visit (HIR::StaticItem &static_item);\n+  virtual void visit (HIR::Trait &trait);\n+  virtual void visit (HIR::ImplBlock &impl);\n+  virtual void visit (HIR::ExternBlock &block);\n+  virtual void visit (HIR::EmptyStmt &stmt);\n+  virtual void visit (HIR::LetStmt &stmt);\n+  virtual void visit (HIR::ExprStmtWithoutBlock &stmt);\n+  virtual void visit (HIR::ExprStmtWithBlock &stmt);\n+\n+  Analysis::Mappings &mappings;\n+  Rust::Resolver::Resolver &resolver;\n+  const Rust::Resolver::TypeCheckContext &ty_ctx;\n+\n+  // `None` means we're in the root module - the crate\n+  Optional<NodeId> current_module;\n+};\n+\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#endif // !RUST_PRIVACY_REPORTER_H"}, {"sha": "e391653ea26f392daa19e5d52b88d7ac8ccb8a12", "filename": "gcc/rust/checks/errors/privacy/rust-pub-restricted-visitor.cc", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-pub-restricted-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-pub-restricted-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-pub-restricted-visitor.cc?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,182 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-pub-restricted-visitor.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-item.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+bool\n+PubRestrictedVisitor::is_restriction_valid (NodeId item_id,\n+\t\t\t\t\t    const Location &locus)\n+{\n+  ModuleVisibility visibility;\n+\n+  // If there is no visibility in the mappings, then the item is private and\n+  // does not contain any restriction\n+  // FIXME: Is that correct?\n+  if (!mappings.lookup_visibility (item_id, visibility))\n+    return true;\n+\n+  for (auto mod = module_stack.rbegin (); mod != module_stack.rend (); mod++)\n+    if (*mod == visibility.get_module_id ())\n+      return true;\n+\n+  rust_error_at (locus, \"restricted path is not an ancestor of the \"\n+\t\t\t\"current module\");\n+  return false;\n+}\n+\n+PubRestrictedVisitor::PubRestrictedVisitor (Analysis::Mappings &mappings)\n+  : mappings (mappings)\n+{}\n+\n+void\n+PubRestrictedVisitor::go (HIR::Crate &crate)\n+{\n+  // The `crate` module will always be present\n+  module_stack.emplace_back (crate.get_mappings ().get_defid ());\n+\n+  // FIXME: When do we insert `super`? `self`?\n+  // We need wrapper function for these\n+\n+  for (auto &item : crate.items)\n+    {\n+      if (item->get_hir_kind () == HIR::Node::VIS_ITEM)\n+\t{\n+\t  auto vis_item = static_cast<HIR::VisItem *> (item.get ());\n+\t  vis_item->accept_vis (*this);\n+\t}\n+    }\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::Module &mod)\n+{\n+  // FIXME: We need to update `super` and `self` here\n+  module_stack.push_back (mod.get_mappings ().get_defid ());\n+\n+  is_restriction_valid (mod.get_mappings ().get_nodeid (), mod.get_locus ());\n+\n+  for (auto &item : mod.get_items ())\n+    {\n+      if (item->get_hir_kind () == HIR::Node::VIS_ITEM)\n+\t{\n+\t  auto vis_item = static_cast<HIR::VisItem *> (item.get ());\n+\t  vis_item->accept_vis (*this);\n+\t}\n+    }\n+\n+  module_stack.pop_back ();\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::ExternCrate &crate)\n+{\n+  is_restriction_valid (crate.get_mappings ().get_nodeid (),\n+\t\t\tcrate.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::UseDeclaration &use_decl)\n+{\n+  is_restriction_valid (use_decl.get_mappings ().get_nodeid (),\n+\t\t\tuse_decl.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::Function &func)\n+{\n+  is_restriction_valid (func.get_mappings ().get_nodeid (), func.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::TypeAlias &type_alias)\n+{\n+  is_restriction_valid (type_alias.get_mappings ().get_nodeid (),\n+\t\t\ttype_alias.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::StructStruct &struct_item)\n+{\n+  is_restriction_valid (struct_item.get_mappings ().get_nodeid (),\n+\t\t\tstruct_item.get_locus ());\n+  // FIXME: Check fields here as well\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::TupleStruct &tuple_struct)\n+{\n+  is_restriction_valid (tuple_struct.get_mappings ().get_nodeid (),\n+\t\t\ttuple_struct.get_locus ());\n+  // FIXME: Check fields here as well\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::Enum &enum_item)\n+{\n+  is_restriction_valid (enum_item.get_mappings ().get_nodeid (),\n+\t\t\tenum_item.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::Union &union_item)\n+{\n+  is_restriction_valid (union_item.get_mappings ().get_nodeid (),\n+\t\t\tunion_item.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::ConstantItem &const_item)\n+{\n+  is_restriction_valid (const_item.get_mappings ().get_nodeid (),\n+\t\t\tconst_item.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::StaticItem &static_item)\n+{\n+  is_restriction_valid (static_item.get_mappings ().get_nodeid (),\n+\t\t\tstatic_item.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::Trait &trait)\n+{\n+  is_restriction_valid (trait.get_mappings ().get_nodeid (),\n+\t\t\ttrait.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::ImplBlock &impl)\n+{\n+  is_restriction_valid (impl.get_mappings ().get_nodeid (), impl.get_locus ());\n+}\n+\n+void\n+PubRestrictedVisitor::visit (HIR::ExternBlock &block)\n+{\n+  is_restriction_valid (block.get_mappings ().get_nodeid (),\n+\t\t\tblock.get_locus ());\n+}\n+\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "2685f3d1488a421c8fdf6a2029b5c3d517adaddb", "filename": "gcc/rust/checks/errors/privacy/rust-pub-restricted-visitor.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-pub-restricted-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-pub-restricted-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-pub-restricted-visitor.h?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,120 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_PUB_RESTRICTED_VISITOR_H\n+#define RUST_PUB_RESTRICTED_VISITOR_H\n+\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+/**\n+ * This visitor takes care of reporting `pub(restricted)` violations:\n+ * A `pub(restricted)` violation is defined as the usage of a path restriction\n+ * on an item which does not restrict the item's visibility to one of its parent\n+ * modules. What this means is that an user is allowed to specify that an item\n+ * should be public for any of its parent modules, going all the way to the\n+ * `crate` module, but not for any of its children module.\n+ *\n+ * ```rust\n+ * mod a {\n+ * \tmod b {\n+ * \t\tpub (in a) struct A0;\n+ *\n+ * \t\tmod c {\n+ * \t\t\tmod d {\n+ * \t\t\t\tpub (in a) struct A1;\n+ * \t\t\t}\n+ * \t\t}\n+ *\n+ * \t\tpub (in c::d) struct A2;\n+ * \t}\n+ * }\n+ * ```\n+ *\n+ * The above `A0`'s visibility is valid: It is restricted to a path, `a`,\n+ * which is a parent of the current module, `b`.\n+ * Likewise, `A1` is also defined properly: `a` is a parent of `d`, albeit\n+ * a great-great-great-grandparant of it.\n+ *\n+ * `A2` visibility, however, is invalid: Where the struct is defined, the\n+ * current module is `b`. `c::d` (which refers to the `d` module) is a child of\n+ * `b`, and not one of its ancestors.\n+ *\n+ * Note that these resolution rules are also the ones of the 2015 rust edition:\n+ * All the `pub(restricted)` visibilities above would be invalid in the 2018\n+ * edition, as the paths there must be absolute and not relative (`c::d` would\n+ * become `crate::a::b::c::d` etc). Nonetheless, the logic stays the same.\n+ */\n+class PubRestrictedVisitor : public HIR::HIRVisItemVisitor\n+{\n+public:\n+  PubRestrictedVisitor (Analysis::Mappings &mappings);\n+\n+  void go (HIR::Crate &crate);\n+\n+  /**\n+   * Check if an item's restricted visibility (`pub (crate)`, `pub (self)`,\n+   * `pub(super)`, `pub (in <path>)`) is valid in the current context.\n+   * `pub restricted` visibilities are only allowed when the restriction path\n+   * is a parent module of the item being visited.\n+   *\n+   * In case of error, this function will emit the errors and return.\n+   *\n+   * @param item_id NodeId of the item to check the restriction of\n+   * @param locus Location of the item being checked\n+   *\n+   * @return true if the visibility restriction is valid, false otherwise.\n+   */\n+  bool is_restriction_valid (NodeId item_id, const Location &locus);\n+\n+  virtual void visit (HIR::Module &mod);\n+  virtual void visit (HIR::ExternCrate &crate);\n+  virtual void visit (HIR::UseDeclaration &use_decl);\n+  virtual void visit (HIR::Function &func);\n+  virtual void visit (HIR::TypeAlias &type_alias);\n+  virtual void visit (HIR::StructStruct &struct_item);\n+  virtual void visit (HIR::TupleStruct &tuple_struct);\n+  virtual void visit (HIR::Enum &enum_item);\n+  virtual void visit (HIR::Union &union_item);\n+  virtual void visit (HIR::ConstantItem &const_item);\n+  virtual void visit (HIR::StaticItem &static_item);\n+  virtual void visit (HIR::Trait &trait);\n+  virtual void visit (HIR::ImplBlock &impl);\n+  virtual void visit (HIR::ExternBlock &block);\n+\n+private:\n+  /* Stack of ancestor modules visited by this visitor */\n+  std::vector<DefId> module_stack;\n+\n+  // FIXME: Do we have to handle `self` and `super` as part of the name\n+  // resolution pass?\n+\n+  Analysis::Mappings &mappings;\n+};\n+\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#endif // !RUST_PUB_RESTRICTED_VISITOR_H"}, {"sha": "b322e29bfc31ea9686844860ebe32c0151aaa1c6", "filename": "gcc/rust/checks/errors/privacy/rust-reachability.cc", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-reachability.cc?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,236 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-reachability.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+static HIR::VisItem *\n+maybe_get_vis_item (std::unique_ptr<HIR::Item> &item)\n+{\n+  if (item->get_hir_kind () != HIR::Node::VIS_ITEM)\n+    return nullptr;\n+\n+  return static_cast<HIR::VisItem *> (item.get ());\n+}\n+\n+ReachLevel\n+ReachabilityVisitor::get_reachability_level (\n+  const HIR::Visibility &item_visibility)\n+{\n+  return item_visibility.is_public () ? current_level : ReachLevel::Unreachable;\n+}\n+\n+void\n+ReachabilityVisitor::visit_generic_predicates (\n+  const std::vector<std::unique_ptr<HIR::GenericParam>> &generics,\n+  ReachLevel item_reach)\n+{\n+  if (item_reach == ReachLevel::Unreachable)\n+    return;\n+\n+  for (const auto &generic : generics)\n+    {\n+      if (generic->get_kind () == HIR::GenericParam::GenericKind::TYPE)\n+\t{\n+\t  TyTy::BaseType *generic_ty = nullptr;\n+\t  auto ok = ty_ctx.lookup_type (generic->get_mappings ().get_hirid (),\n+\t\t\t\t\t&generic_ty);\n+\t  rust_assert (ok);\n+\t  rust_assert (generic_ty->get_kind () == TyTy::PARAM);\n+\n+\t  auto generic_param = static_cast<TyTy::ParamType *> (generic_ty);\n+\t  for (const auto &bound : generic_param->get_specified_bounds ())\n+\t    {\n+\t      const auto trait = bound.get ()->get_hir_trait_ref ();\n+\t      ctx.update_reachability (trait->get_mappings (), item_reach);\n+\t    }\n+\t}\n+    }\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Module &mod)\n+{\n+  auto reach = get_reachability_level (mod.get_visibility ());\n+  reach = ctx.update_reachability (mod.get_mappings (), reach);\n+\n+  for (auto &item : mod.get_items ())\n+    {\n+      // FIXME: Is that what we want to do? Yes? Only visit the items with\n+      // visibility?\n+      //\n+      // Imagine if we had `maybe_get_vis_item(item)?->accept_vis(*this)` ;)\n+      auto vis_item = maybe_get_vis_item (item);\n+      if (vis_item)\n+\tvis_item->accept_vis (*this);\n+    }\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::ExternCrate &crate)\n+{\n+  auto reach = get_reachability_level (crate.get_visibility ());\n+  reach = ctx.update_reachability (crate.get_mappings (), reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::UseDeclaration &use_decl)\n+{\n+  auto reach = get_reachability_level (use_decl.get_visibility ());\n+  reach = ctx.update_reachability (use_decl.get_mappings (), reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Function &func)\n+{\n+  auto fn_reach = get_reachability_level (func.get_visibility ());\n+\n+  fn_reach = ctx.update_reachability (func.get_mappings (), fn_reach);\n+  visit_generic_predicates (func.get_generic_params (), fn_reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::TypeAlias &type_alias)\n+{\n+  auto type_reach = get_reachability_level (type_alias.get_visibility ());\n+\n+  visit_generic_predicates (type_alias.get_generic_params (), type_reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::StructStruct &struct_item)\n+{\n+  auto struct_reach = get_reachability_level (struct_item.get_visibility ());\n+\n+  struct_reach\n+    = ctx.update_reachability (struct_item.get_mappings (), struct_reach);\n+\n+  auto old_level = current_level;\n+  current_level = struct_reach;\n+\n+  visit_generic_predicates (struct_item.get_generic_params (), struct_reach);\n+\n+  if (struct_reach != ReachLevel::Unreachable)\n+    {\n+      for (auto &field : struct_item.get_fields ())\n+\tif (field.get_visibility ().is_public ())\n+\t  ctx.update_reachability (field.get_field_type ()->get_mappings (),\n+\t\t\t\t   struct_reach);\n+    }\n+\n+  current_level = old_level;\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::TupleStruct &tuple_struct)\n+{}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Enum &enum_item)\n+{\n+  auto enum_reach = get_reachability_level (enum_item.get_visibility ());\n+\n+  enum_reach = ctx.update_reachability (enum_item.get_mappings (), enum_reach);\n+  visit_generic_predicates (enum_item.get_generic_params (), enum_reach);\n+\n+  for (const auto &variant : enum_item.get_variants ())\n+    {\n+      auto variant_reach\n+\t= ctx.update_reachability (variant->get_mappings (), enum_reach);\n+\n+      switch (variant->get_enum_item_kind ())\n+\t{\n+\t  case HIR::EnumItem::Tuple: {\n+\t    // Should we update the fields only if they are public? Similarly to\n+\t    // what we do in the ReachabilityVisitor for HIR::TupleStruct?\n+\t    auto tuple_variant\n+\t      = static_cast<HIR::EnumItemTuple *> (variant.get ());\n+\t    for (const auto &field : tuple_variant->get_tuple_fields ())\n+\t      ctx.update_reachability (field.get_mappings (), variant_reach);\n+\t    break;\n+\t  }\n+\t  case HIR::EnumItem::Struct: {\n+\t    // Should we update the fields only if they are public? Similarly to\n+\t    // what we do in the ReachabilityVisitor for HIR::StructStruct?\n+\t    auto struct_variant\n+\t      = static_cast<HIR::EnumItemStruct *> (variant.get ());\n+\t    for (const auto &field : struct_variant->get_struct_fields ())\n+\t      ctx.update_reachability (field.get_mappings (), variant_reach);\n+\t    break;\n+\t  }\n+\t// Nothing nested to visit in that case\n+\tcase HIR::EnumItem::Named:\n+\tcase HIR::EnumItem::Discriminant:\n+\t  break;\n+\t}\n+    }\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Union &union_item)\n+{\n+  auto union_reach = get_reachability_level (union_item.get_visibility ());\n+\n+  union_reach\n+    = ctx.update_reachability (union_item.get_mappings (), union_reach);\n+  visit_generic_predicates (union_item.get_generic_params (), union_reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::ConstantItem &const_item)\n+{\n+  auto reach = get_reachability_level (const_item.get_visibility ());\n+  reach = ctx.update_reachability (const_item.get_mappings (), reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::StaticItem &static_item)\n+{\n+  auto reach = get_reachability_level (static_item.get_visibility ());\n+  reach = ctx.update_reachability (static_item.get_mappings (), reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::Trait &trait)\n+{\n+  auto trait_reach = get_reachability_level (trait.get_visibility ());\n+\n+  trait_reach = ctx.update_reachability (trait.get_mappings (), trait_reach);\n+  visit_generic_predicates (trait.get_generic_params (), trait_reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::ImplBlock &impl)\n+{\n+  auto impl_reach = get_reachability_level (impl.get_visibility ());\n+\n+  impl_reach = ctx.update_reachability (impl.get_mappings (), impl_reach);\n+  visit_generic_predicates (impl.get_generic_params (), impl_reach);\n+}\n+\n+void\n+ReachabilityVisitor::visit (HIR::ExternBlock &block)\n+{}\n+\n+// FIXME: How can we visit Blocks in the current configuration? Have a full\n+// visitor?\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "e0bc4f5f0b877c8e4de7df6a41616af0e57c27e6", "filename": "gcc/rust/checks/errors/privacy/rust-reachability.h", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-reachability.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-reachability.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-reachability.h?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,87 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_REACHABILITY_H\n+#define RUST_REACHABILITY_H\n+\n+#include \"rust-privacy-ctx.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+// FIXME: The EmbargoVisitor from rustc is a fixed-point visitor which tries\n+// to reach more and more nodes until nothing has changed anymore.\n+// Do we need to reproduce this behavior? How long does it take to do this?\n+\n+/**\n+ * The ReachabilityVisitor tries to reach all items possible in the crate,\n+ * according to their privacy level.\n+ */\n+class ReachabilityVisitor : public HIR::HIRVisItemVisitor\n+{\n+public:\n+  ReachabilityVisitor (PrivacyContext &ctx,\n+\t\t       const ::Rust::Resolver::TypeCheckContext &ty_ctx)\n+    : current_level (ReachLevel::Reachable), ctx (ctx), ty_ctx (ty_ctx)\n+  {}\n+\n+  // FIXME: Add `go` method which takes an `HIR::Crate &` as argument\n+\n+  /**\n+   * Visit all the predicates of all the generic types of a given item, marking\n+   * them as reachable or not.\n+   */\n+  void visit_generic_predicates (\n+    const std::vector<std::unique_ptr<HIR::GenericParam>> &generics,\n+    ReachLevel item_reach);\n+\n+  /**\n+   * Get the initial reach level for an item based on its visibility.\n+   */\n+  ReachLevel get_reachability_level (const HIR::Visibility &item_visibility);\n+\n+  virtual void visit (HIR::Module &mod);\n+  virtual void visit (HIR::ExternCrate &crate);\n+  virtual void visit (HIR::UseDeclaration &use_decl);\n+  virtual void visit (HIR::Function &func);\n+  virtual void visit (HIR::TypeAlias &type_alias);\n+  virtual void visit (HIR::StructStruct &struct_item);\n+  virtual void visit (HIR::TupleStruct &tuple_struct);\n+  virtual void visit (HIR::Enum &enum_item);\n+  virtual void visit (HIR::Union &union_item);\n+  virtual void visit (HIR::ConstantItem &const_item);\n+  virtual void visit (HIR::StaticItem &static_item);\n+  virtual void visit (HIR::Trait &trait);\n+  virtual void visit (HIR::ImplBlock &impl);\n+  virtual void visit (HIR::ExternBlock &block);\n+\n+private:\n+  ReachLevel current_level;\n+  PrivacyContext &ctx;\n+  const ::Rust::Resolver::TypeCheckContext &ty_ctx;\n+};\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#endif // !RUST_REACHABILITY_H"}, {"sha": "301182754a4be7a3a55a02fac9a90a6b8e429a15", "filename": "gcc/rust/checks/errors/privacy/rust-visibility-resolver.cc", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-visibility-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-visibility-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-visibility-resolver.cc?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,245 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-visibility-resolver.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-item.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+VisibilityResolver::VisibilityResolver (Analysis::Mappings &mappings,\n+\t\t\t\t\tResolver::Resolver &resolver)\n+  : mappings (mappings), resolver (resolver)\n+{}\n+\n+void\n+VisibilityResolver::go (HIR::Crate &crate)\n+{\n+  mappings.insert_visibility (crate.get_mappings ().get_nodeid (),\n+\t\t\t      ModuleVisibility::create_public ());\n+\n+  current_module = crate.get_mappings ().get_defid ();\n+\n+  for (auto &item : crate.items)\n+    {\n+      if (item->get_hir_kind () == HIR::Node::VIS_ITEM)\n+\t{\n+\t  auto vis_item = static_cast<HIR::VisItem *> (item.get ());\n+\t  vis_item->accept_vis (*this);\n+\t}\n+    }\n+}\n+\n+bool\n+VisibilityResolver::resolve_module_path (const HIR::SimplePath &restriction,\n+\t\t\t\t\t DefId &id)\n+{\n+  // We need, from the restriction, to figure out the actual Module it\n+  // belongs to.\n+\n+  NodeId ast_node_id = restriction.get_mappings ().get_nodeid ();\n+\n+  auto invalid_path\n+    = Error (restriction.get_locus (),\n+\t     \"cannot use non-module path as privacy restrictor\");\n+\n+  NodeId ref_node_id = UNKNOWN_NODEID;\n+  if (!resolver.lookup_resolved_name (ast_node_id, &ref_node_id))\n+    {\n+      invalid_path.emit_error ();\n+      return false;\n+    }\n+  // FIXME: Add a hint here if we can find the path in another scope, such as\n+  // a type or something else\n+  // TODO: For the hint, can we point to the original item's definition if\n+  // present?\n+\n+  HirId ref;\n+  rust_assert (mappings.lookup_node_to_hir (ref_node_id, &ref));\n+\n+  auto module = mappings.lookup_module (ref);\n+  if (!module)\n+    {\n+      invalid_path.emit_error ();\n+      return false;\n+    }\n+\n+  // Fill in the resolved `DefId`\n+  id = module->get_mappings ().get_defid ();\n+\n+  return true;\n+}\n+\n+bool\n+VisibilityResolver::resolve_visibility (const HIR::Visibility &visibility,\n+\t\t\t\t\tModuleVisibility &to_resolve)\n+{\n+  switch (visibility.get_vis_type ())\n+    {\n+    case HIR::Visibility::PRIVATE:\n+      to_resolve = ModuleVisibility::create_restricted (current_module);\n+      return true;\n+    case HIR::Visibility::PUBLIC:\n+      to_resolve = ModuleVisibility::create_public ();\n+      return true;\n+      case HIR::Visibility::RESTRICTED: {\n+\t// FIXME: We also need to handle 2015 vs 2018 edition conflicts\n+\tauto id = UNKNOWN_DEFID;\n+\tauto result = resolve_module_path (visibility.get_path (), id);\n+\tto_resolve = ModuleVisibility::create_restricted (id);\n+\treturn result;\n+      }\n+    default:\n+      gcc_unreachable ();\n+      return false;\n+    }\n+}\n+\n+void\n+VisibilityResolver::resolve_and_update (const HIR::VisItem *item)\n+{\n+  ModuleVisibility module_vis;\n+  if (!resolve_visibility (item->get_visibility (), module_vis))\n+    return; // we will already have emitted errors\n+\n+  mappings.insert_visibility (item->get_mappings ().get_nodeid (), module_vis);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::Module &mod)\n+{\n+  auto old_module = current_module;\n+  current_module = mod.get_mappings ().get_defid ();\n+\n+  for (auto &item : mod.get_items ())\n+    {\n+      if (item->get_hir_kind () == HIR::Node::VIS_ITEM)\n+\t{\n+\t  auto vis_item = static_cast<HIR::VisItem *> (item.get ());\n+\t  vis_item->accept_vis (*this);\n+\t}\n+    }\n+\n+  current_module = old_module;\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::ExternCrate &crate)\n+{}\n+\n+void\n+VisibilityResolver::visit (HIR::UseDeclaration &use_decl)\n+{}\n+\n+void\n+VisibilityResolver::visit (HIR::Function &func)\n+{\n+  resolve_and_update (&func);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::TypeAlias &type_alias)\n+{\n+  resolve_and_update (&type_alias);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::StructStruct &struct_item)\n+{\n+  resolve_and_update (&struct_item);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::TupleStruct &tuple_struct)\n+{\n+  resolve_and_update (&tuple_struct);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::Enum &enum_item)\n+{\n+  ModuleVisibility vis;\n+  if (!resolve_visibility (enum_item.get_visibility (), vis))\n+    return;\n+\n+  mappings.insert_visibility (enum_item.get_mappings ().get_nodeid (), vis);\n+  for (auto &variant : enum_item.get_variants ())\n+    mappings.insert_visibility (variant->get_mappings ().get_nodeid (), vis);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::Union &union_item)\n+{}\n+\n+void\n+VisibilityResolver::visit (HIR::ConstantItem &const_item)\n+{\n+  resolve_and_update (&const_item);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::StaticItem &static_item)\n+{\n+  resolve_and_update (&static_item);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::Trait &trait)\n+{\n+  ModuleVisibility vis;\n+  if (!resolve_visibility (trait.get_visibility (), vis))\n+    return;\n+\n+  mappings.insert_visibility (trait.get_mappings ().get_nodeid (), vis);\n+  for (auto &item : trait.get_trait_items ())\n+    mappings.insert_visibility (item->get_mappings ().get_nodeid (), vis);\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::ImplBlock &impl)\n+{\n+  for (auto &item : impl.get_impl_items ())\n+    {\n+      HIR::VisItem *vis_item;\n+      switch (item->get_impl_item_type ())\n+\t{\n+\tcase HIR::ImplItem::FUNCTION:\n+\t  vis_item = static_cast<HIR::Function *> (item.get ());\n+\t  break;\n+\tcase HIR::ImplItem::TYPE_ALIAS:\n+\t  vis_item = static_cast<HIR::TypeAlias *> (item.get ());\n+\t  break;\n+\tcase HIR::ImplItem::CONSTANT:\n+\t  vis_item = static_cast<HIR::ConstantItem *> (item.get ());\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  return;\n+\t}\n+      vis_item->accept_vis (*this);\n+    }\n+}\n+\n+void\n+VisibilityResolver::visit (HIR::ExternBlock &block)\n+{}\n+\n+} // namespace Privacy\n+} // namespace Rust"}, {"sha": "20a581c16d4a3a485e8917ddb3e2de2dd4dd920d", "filename": "gcc/rust/checks/errors/privacy/rust-visibility-resolver.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-visibility-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca246e573fb3f53fba5794f72b9245382eb46180/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-visibility-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Fprivacy%2Frust-visibility-resolver.h?ref=ca246e573fb3f53fba5794f72b9245382eb46180", "patch": "@@ -0,0 +1,103 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_VISIBILITY_H\n+#define RUST_VISIBILITY_H\n+\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-visitor.h\"\n+\n+namespace Rust {\n+namespace Privacy {\n+\n+class VisibilityResolver : public HIR::HIRVisItemVisitor\n+{\n+public:\n+  VisibilityResolver (Analysis::Mappings &mappings,\n+\t\t      Rust::Resolver::Resolver &resolver);\n+\n+  /**\n+   * Perform visibility resolving on an entire crate\n+   */\n+  void go (HIR::Crate &crate);\n+\n+  /**\n+   * Resolve a path to the module it refers\n+   */\n+  bool resolve_module_path (const HIR::SimplePath &restriction,\n+\t\t\t    DefId &to_resolve);\n+\n+  /**\n+   * Resolve the visibility of an item to its ModuleVisibility. This function\n+   * emits errors if necessary. The contents of the to_resolve parameter will be\n+   * overwritten on success.\n+   *\n+   * @param visibility Visibility of the item to resolve\n+   * @param to_resolve ModuleVisibility reference to fill on success.\n+   *\n+   * @return false on error, true if the resolving was successful.\n+   */\n+  bool resolve_visibility (const HIR::Visibility &visibility,\n+\t\t\t   ModuleVisibility &to_resolve);\n+\n+  /**\n+   * Resolve the visibility of an item and updates it. This is useful for\n+   * vis-items who need to be resolved but do not care about their module\n+   * visibility - const items, static items, etc. For items with an impact on\n+   * their children (enums, traits), this cannot be used\n+   */\n+  void resolve_and_update (const HIR::VisItem *item);\n+\n+  /**\n+   * Get the DefId of the parent module we are currently visiting.\n+   *\n+   * @return UNKNOWN_DEFID if the module stack is empty, a valid `DefId`\n+   * otherwise\n+   */\n+  DefId peek_module ();\n+\n+  virtual void visit (HIR::Module &mod);\n+  virtual void visit (HIR::ExternCrate &crate);\n+  virtual void visit (HIR::UseDeclaration &use_decl);\n+  virtual void visit (HIR::Function &func);\n+  virtual void visit (HIR::TypeAlias &type_alias);\n+  virtual void visit (HIR::StructStruct &struct_item);\n+  virtual void visit (HIR::TupleStruct &tuple_struct);\n+  virtual void visit (HIR::Enum &enum_item);\n+  virtual void visit (HIR::Union &union_item);\n+  virtual void visit (HIR::ConstantItem &const_item);\n+  virtual void visit (HIR::StaticItem &static_item);\n+  virtual void visit (HIR::Trait &trait);\n+  virtual void visit (HIR::ImplBlock &impl);\n+  virtual void visit (HIR::ExternBlock &block);\n+\n+private:\n+  Analysis::Mappings &mappings;\n+  Rust::Resolver::Resolver &resolver;\n+  DefId current_module;\n+};\n+\n+} // namespace Privacy\n+} // namespace Rust\n+\n+#endif // !RUST_VISIBILITY_H"}]}