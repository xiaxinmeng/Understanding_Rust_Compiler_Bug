{"sha": "1399eca1907b6fe3a191c586211bcfcc46f47b4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM5OWVjYTE5MDdiNmZlM2ExOTFjNTg2MjExYmNmY2M0NmY0N2I0ZA==", "commit": {"author": {"name": "Dhruv Matani", "email": "dhruvbird@gmx.net", "date": "2004-10-14T17:52:18Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-10-14T17:52:18Z"}, "message": "bitmap_allocator.h: Clean-up add/remove functions.\n\n2004-10-14  Dhruv Matani  <dhruvbird@gmx.net>\n\n\t* ext/bitmap_allocator.h: Clean-up add/remove functions.\n\t* src/bitmap_allocator.cc: New file. Contains the out-of-line\n\tfunction definitions, static initialization of variables, and\n\texplicit instantiations needed for the allocator.\n\t* src/Makefile.am: Add.\n\t* src/Makefile.in: Regenerate.\n\t* config/linker.map.gnu: Add the necessary symbols.\n\nFrom-SVN: r89042", "tree": {"sha": "52fc656274dd3ad9a50d564dc1d9d813ec3ff42c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52fc656274dd3ad9a50d564dc1d9d813ec3ff42c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1399eca1907b6fe3a191c586211bcfcc46f47b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1399eca1907b6fe3a191c586211bcfcc46f47b4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1399eca1907b6fe3a191c586211bcfcc46f47b4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1399eca1907b6fe3a191c586211bcfcc46f47b4d/comments", "author": null, "committer": null, "parents": [{"sha": "a023975e421f23fc2799a2c7fcc6e19ed68227f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a023975e421f23fc2799a2c7fcc6e19ed68227f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a023975e421f23fc2799a2c7fcc6e19ed68227f7"}], "stats": {"total": 1712, "additions": 1084, "deletions": 628}, "files": [{"sha": "50c1da51850a3060aef57507e3b7215613f8b9c0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1399eca1907b6fe3a191c586211bcfcc46f47b4d", "patch": "@@ -1,3 +1,13 @@\n+2004-10-14  Dhruv Matani  <dhruvbird@gmx.net>\n+\n+\t* ext/bitmap_allocator.h: Clean-up add/remove functions.\n+\t* src/bitmap_allocator.cc: New file. Contains the out-of-line\n+\tfunction definitions, static initialization of variables, and\n+\texplicit instantiations needed for the allocator.\n+\t* src/Makefile.am: Add.\n+\t* src/Makefile.in: Regenerate.\n+\t* config/linker.map.gnu: Add the necessary symbols.\n+\n 2004-10-13  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/basic_string.tcc (_S_create): Use consistently"}, {"sha": "dfc6f5e3469c0c7904b90ce041718d38a42fb3e5", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=1399eca1907b6fe3a191c586211bcfcc46f47b4d", "patch": "@@ -270,7 +270,12 @@ GLIBCXX_3.4.3 {\n     _ZN9__gnu_cxx6__poolILb[01]EE16_M_reserve_blockE[jm][jm];\n     _ZN9__gnu_cxx6__poolILb[01]EE16_M_reclaim_blockEPc[jm];\n     _ZN9__gnu_cxx6__poolILb[01]EE10_M_destroyEv;\n- \n+\n+    _ZN9__gnu_cxx9free_list12_S_free_listE;\n+    _ZN9__gnu_cxx9free_list12_S_bfl_mutexE;\n+    _ZN9__gnu_cxx9free_list6_M_getEj;\n+    _ZN9__gnu_cxx9free_list8_M_clearEv;\n+\n     # stub functions from libmath\n     acosf;\n     acosl;"}, {"sha": "5841c7f9fb47f30ba6934f9292fe172eb45a53ae", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 925, "deletions": 619, "changes": 1544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=1399eca1907b6fe3a191c586211bcfcc46f47b4d", "patch": "@@ -1,4 +1,4 @@\n-// Bitmapped Allocator. -*- C++ -*-\n+// Bitmap Allocator. -*- C++ -*-\n \n // Copyright (C) 2004 Free Software Foundation, Inc.\n //\n@@ -27,53 +27,67 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n+/** @file ext/bitmap_allocator.h\n+ *  This file is a GNU extension to the Standard C++ Library.\n+ *  You should only include this header if you are using GCC 3 or later.\n+ */\n \n-\n-#if !defined _BITMAP_ALLOCATOR_H\n+#ifndef _BITMAP_ALLOCATOR_H\n #define _BITMAP_ALLOCATOR_H 1\n \n+// For std::size_t, and ptrdiff_t.\n #include <cstddef>\n-//For std::size_t, and ptrdiff_t.\n+\n+// For std::pair.\n #include <utility>\n-//For std::pair.\n-#include <algorithm>\n-//std::find_if, and std::lower_bound.\n-#include <vector>\n-//For the free list of exponentially growing memory blocks. At max,\n-//size of the vector should be  not more than the number of bits in an\n-//integer or an unsigned integer.\n+\n+// For greater_equal, and less_equal.\n #include <functional>\n-//For greater_equal, and less_equal.\n+\n+// For operator new.\n #include <new>\n-//For operator new.\n+\n+// For __gthread_mutex_t, __gthread_mutex_lock and __gthread_mutex_unlock.\n #include <bits/gthr.h>\n-//For __gthread_mutex_t, __gthread_mutex_lock and __gthread_mutex_unlock.\n-#include <ext/new_allocator.h>\n-//For __gnu_cxx::new_allocator for std::vector.\n \n+// Define this to enable error checking withing the allocator\n+// itself(to debug the allocator itself).\n+//#define _BALLOC_SANITY_CHECK\n+\n+#if defined _BALLOC_SANITY_CHECK\n #include <cassert>\n-#define NDEBUG\n+#define _BALLOC_ASSERT(_EXPR) assert(_EXPR)\n+#else\n+#define _BALLOC_ASSERT(_EXPR)\n+#endif\n \n-//#define CHECK_FOR_ERRORS\n-//#define __CPU_HAS_BACKWARD_BRANCH_PREDICTION\n \n namespace __gnu_cxx\n {\n-  namespace {\n #if defined __GTHREADS\n+  namespace\n+  {\n+    // If true, then the application being compiled will be using\n+    // threads, so use mutexes as a synchronization primitive, else do\n+    // no use any synchronization primitives.\n     bool const __threads_enabled = __gthread_active_p();\n-#endif\n-\n   }\n+#endif\n \n #if defined __GTHREADS\n-  class _Mutex {\n+  // _Mutex is an OO-Wrapper for __gthread_mutex_t. It does not allow\n+  // you to copy or assign an already initialized mutex. This is used\n+  // merely as a convenience for the locking classes.\n+  class _Mutex \n+  {\n     __gthread_mutex_t _M_mut;\n-    //Prevent Copying and assignment.\n-    _Mutex (_Mutex const&);\n-    _Mutex& operator= (_Mutex const&);\n+\n+    // Prevent Copying and assignment.\n+    _Mutex(_Mutex const&);\n+    _Mutex& operator=(_Mutex const&);\n+\n   public:\n-    _Mutex ()\n+    _Mutex()\n     {\n       if (__threads_enabled)\n \t{\n@@ -85,32 +99,48 @@ namespace __gnu_cxx\n #endif\n \t}\n     }\n-    ~_Mutex ()\n+\n+    ~_Mutex()\n     {\n-      //Gthreads does not define a Mutex Destruction Function.\n+      // Gthreads does not define a Mutex Destruction Function.\n     }\n-    __gthread_mutex_t *_M_get() { return &_M_mut; }\n+\n+    __gthread_mutex_t*\n+    _M_get() { return &_M_mut; }\n   };\n \n-  class _Lock {\n+  // _Lock is a simple manual lokcing class which allows you to\n+  // manually lock and unlock a mutex associated with the lock. There\n+  // is not automatic locking or unlocking happening without the\n+  // programmer's explicit instructions. This class unlocks the mutex\n+  // ONLY if it has not been locked. However, this check does not\n+  // apply for lokcing, and wayward use may cause dead-locks.\n+  class _Lock \n+  {\n     _Mutex* _M_pmt;\n     bool _M_locked;\n-    //Prevent Copying and assignment.\n-    _Lock (_Lock const&);\n-    _Lock& operator= (_Lock const&);\n+\n+    // Prevent Copying and assignment.\n+    _Lock(_Lock const&);\n+    _Lock& operator=(_Lock const&);\n+\n   public:\n     _Lock(_Mutex* __mptr)\n-      : _M_pmt(__mptr), _M_locked(false)\n-    { this->_M_lock(); }\n-    void _M_lock()\n+    : _M_pmt(__mptr), _M_locked(false)\n+    { }\n+\n+    void\n+    _M_lock()\n     {\n       if (__threads_enabled)\n \t{\n \t  _M_locked = true;\n \t  __gthread_mutex_lock(_M_pmt->_M_get());\n \t}\n     }\n-    void _M_unlock()\n+\n+    void\n+    _M_unlock()\n     {\n       if (__threads_enabled)\n \t{\n@@ -121,739 +151,1015 @@ namespace __gnu_cxx\n \t    }\n \t}\n     }\n-    ~_Lock() { this->_M_unlock(); }\n+    \n+    ~_Lock() { }\n   };\n-#endif\n \n+  // _Auto_Lock locks the associated mutex on construction, and\n+  // unlocks on it's destruction. There are no checks performed, and\n+  // this calss follows the RAII principle.\n+  class _Auto_Lock \n+  {\n+    _Mutex* _M_pmt;\n+    // Prevent Copying and assignment.\n+    _Auto_Lock(_Auto_Lock const&);\n+    _Auto_Lock& operator=(_Auto_Lock const&);\n \n-\n-  namespace __aux_balloc {\n-    static const unsigned int _Bits_Per_Byte = 8;\n-    static const unsigned int _Bits_Per_Block = sizeof(unsigned int) * _Bits_Per_Byte;\n-\n-    template <typename _Addr_Pair_t>\n-    inline size_t __balloc_num_blocks (_Addr_Pair_t __ap)\n+    void\n+    _M_lock()\n     {\n-      return (__ap.second - __ap.first) + 1;\n+      if (__threads_enabled)\n+\t__gthread_mutex_lock(_M_pmt->_M_get());\n     }\n \n-    template <typename _Addr_Pair_t>\n-    inline size_t __balloc_num_bit_maps (_Addr_Pair_t __ap)\n+    void\n+    _M_unlock()\n     {\n-      return __balloc_num_blocks(__ap) / _Bits_Per_Block;\n+      if (__threads_enabled)\n+\t__gthread_mutex_unlock(_M_pmt->_M_get());\n     }\n \n-    //T should be a pointer type.\n-    template <typename _Tp>\n-    class _Inclusive_between : public std::unary_function<typename std::pair<_Tp, _Tp>, bool> {\n-      typedef _Tp pointer;\n-      pointer _M_ptr_value;\n-      typedef typename std::pair<_Tp, _Tp> _Block_pair;\n+  public:\n+    _Auto_Lock(_Mutex* __mptr) : _M_pmt(__mptr)\n+    { this->_M_lock(); }\n \n-    public:\n-      _Inclusive_between (pointer __ptr) : _M_ptr_value(__ptr) { }\n-      bool operator () (_Block_pair __bp) const throw ()\n+    ~_Auto_Lock() { this->_M_unlock(); }\n+  };\n+#endif \n+\n+  namespace balloc\n+  {\n+    // __mini_vector<> is to be used only for built-in types or\n+    // PODs. It is a stripped down version of the full-fledged\n+    // std::vector<>. Noteable differences are: \n+    // \n+    // 1. Not all accessor functions are present.\n+    // 2. Used ONLY for PODs.\n+    // 3. No Allocator template argument. Uses ::operator new() to get\n+    // memory, and ::operator delete() to free it.\n+    template<typename _Tp>\n+      class __mini_vector\n       {\n-\tif (std::less_equal<pointer> ()(_M_ptr_value, __bp.second) && \n-\t    std::greater_equal<pointer> ()(_M_ptr_value, __bp.first))\n-\t  return true;\n-\telse\n-\t  return false;\n-      }\n-    };\n-  \n-    //Used to pass a Functor to functions by reference.\n-    template <typename _Functor>\n-    class _Functor_Ref : \n-      public std::unary_function<typename _Functor::argument_type, typename _Functor::result_type> {\n-      _Functor& _M_fref;\n-    \n-    public:\n-      typedef typename _Functor::argument_type argument_type;\n-      typedef typename _Functor::result_type result_type;\n+\t__mini_vector(const __mini_vector&);\n+\t__mini_vector& operator=(const __mini_vector&);\n+\n+      public:\n+\ttypedef _Tp value_type;\n+\ttypedef _Tp* pointer;\n+\ttypedef _Tp& reference;\n+\ttypedef const _Tp& const_reference;\n+\ttypedef std::size_t size_type;\n+\ttypedef std::ptrdiff_t difference_type;\n+\ttypedef pointer iterator;\n+\n+      private:\n+\tpointer _M_start;\n+\tpointer _M_finish;\n+\tpointer _M_end_of_storage;\n+\n+\tsize_type\n+\t_M_space_left() const throw()\n+\t{ return _M_end_of_storage - _M_finish; }\n+\n+\tpointer\n+\tallocate(size_type __n)\n+\t{ return static_cast<pointer>(::operator new(__n * sizeof(_Tp))); }\n+\n+\tvoid\n+\tdeallocate(pointer __p, size_type)\n+\t{ ::operator delete(__p); }\n+\n+      public:\n+\t// Members used: size(), push_back(), pop_back(),\n+\t// insert(iterator, const_reference), erase(iterator),\n+\t// begin(), end(), back(), operator[].\n+\n+\t__mini_vector() : _M_start(0), _M_finish(0), \n+\t\t\t  _M_end_of_storage(0)\n+\t{ }\n+\n+\t~__mini_vector()\n+\t{\n+\t  if (this->_M_start)\n+\t    {\n+\t      this->deallocate(this->_M_start, this->_M_end_of_storage \n+\t\t\t       - this->_M_start);\n+\t    }\n+\t}\n \n-      _Functor_Ref (_Functor& __fref) : _M_fref(__fref) { }\n-      result_type operator() (argument_type __arg) { return _M_fref (__arg); }\n-    };\n+\tsize_type\n+\tsize() const throw()\n+\t{ return _M_finish - _M_start; }\n \n+\titerator\n+\tbegin() const throw()\n+\t{ return this->_M_start; }\n \n-    //T should be a pointer type, and A is the Allocator for the vector.\n-    template <typename _Tp, typename _Alloc>\n-    class _Ffit_finder \n-      : public std::unary_function<typename std::pair<_Tp, _Tp>, bool> {\n-      typedef typename std::vector<std::pair<_Tp, _Tp>, _Alloc> _BPVector;\n-      typedef typename _BPVector::difference_type _Counter_type;\n-      typedef typename std::pair<_Tp, _Tp> _Block_pair;\n+\titerator\n+\tend() const throw()\n+\t{ return this->_M_finish; }\n \n-      unsigned int *_M_pbitmap;\n-      unsigned int _M_data_offset;\n+\treference\n+\tback() const throw()\n+\t{ return *(this->end() - 1); }\n \n-    public:\n-      _Ffit_finder () \n-\t: _M_pbitmap (0), _M_data_offset (0)\n-      { }\n+\treference\n+\toperator[](const size_type __pos) const throw()\n+\t{ return this->_M_start[__pos]; }\n+\n+\tvoid\n+\tinsert(iterator __pos, const_reference __x);\n+\n+\tvoid\n+\tpush_back(const_reference __x)\n+\t{\n+\t  if (this->_M_space_left())\n+\t    {\n+\t      *this->end() = __x;\n+\t      ++this->_M_finish;\n+\t    }\n+\t  else\n+\t    this->insert(this->end(), __x);\n+\t}\n+\n+\tvoid\n+\tpop_back() throw()\n+\t{ --this->_M_finish; }\n+\n+\tvoid\n+\terase(iterator __pos) throw();\n \n-      bool operator() (_Block_pair __bp) throw()\n+\tvoid\n+\tclear() throw()\n+\t{ this->_M_finish = this->_M_start; }\n+      };\n+\n+    // Out of line function definitions.\n+    template<typename _Tp>\n+      void __mini_vector<_Tp>::\n+      insert(iterator __pos, const_reference __x)\n       {\n-\t//Set the _rover to the last unsigned integer, which is the\n-\t//bitmap to the first free block. Thus, the bitmaps are in exact\n-\t//reverse order of the actual memory layout. So, we count down\n-\t//the bimaps, which is the same as moving up the memory.\n-\n-\t//If the used count stored at the start of the Bit Map headers\n-\t//is equal to the number of Objects that the current Block can\n-\t//store, then there is definitely no space for another single\n-\t//object, so just return false.\n-\t_Counter_type __diff = __gnu_cxx::__aux_balloc::__balloc_num_bit_maps (__bp);\n-\n-\tassert (*(reinterpret_cast<unsigned int*>(__bp.first) - (__diff + 1)) <= \n-\t\t__gnu_cxx::__aux_balloc::__balloc_num_blocks (__bp));\n-\n-\tif (*(reinterpret_cast<unsigned int*>(__bp.first) - (__diff + 1)) == \n-\t    __gnu_cxx::__aux_balloc::__balloc_num_blocks (__bp))\n-\t  return false;\n+\tif (this->_M_space_left())\n+\t  {\n+\t    size_type __to_move = this->_M_finish - __pos;\n+\t    iterator __dest = this->end();\n+\t    iterator __src = this->end() - 1;\n \n-\tunsigned int *__rover = reinterpret_cast<unsigned int*>(__bp.first) - 1;\n-\tfor (_Counter_type __i = 0; __i < __diff; ++__i)\n+\t    ++this->_M_finish;\n+\t    while (__to_move)\n+\t      {\n+\t\t*__dest = *__src;\n+\t\t--__dest; --__src; --__to_move;\n+\t      }\n+\t    *__pos = __x;\n+\t  }\n+\telse\n \t  {\n-\t    _M_data_offset = __i;\n-\t    if (*__rover)\n+\t    size_type __new_size = this->size() ? this->size() * 2 : 1;\n+\t    iterator __new_start = this->allocate(__new_size);\n+\t    iterator __first = this->begin();\n+\t    iterator __start = __new_start;\n+\t    while (__first != __pos)\n \t      {\n-\t\t_M_pbitmap = __rover;\n-\t\treturn true;\n+\t\t*__start = *__first;\n+\t\t++__start; ++__first;\n \t      }\n-\t    --__rover;\n+\t    *__start = __x;\n+\t    ++__start;\n+\t    while (__first != this->end())\n+\t      {\n+\t\t*__start = *__first;\n+\t\t++__start; ++__first;\n+\t      }\n+\t    if (this->_M_start)\n+\t      this->deallocate(this->_M_start, this->size());\n+\n+\t    this->_M_start = __new_start;\n+\t    this->_M_finish = __start;\n+\t    this->_M_end_of_storage = this->_M_start + __new_size;\n \t  }\n-\treturn false;\n-      }\n-    \n-      unsigned int *_M_get () { return _M_pbitmap; }\n-      unsigned int _M_offset () { return _M_data_offset * _Bits_Per_Block; }\n-    };\n-  \n-    //T should be a pointer type.\n-    template <typename _Tp, typename _Alloc>\n-    class _Bit_map_counter {\n-    \n-      typedef typename std::vector<std::pair<_Tp, _Tp>, _Alloc> _BPVector;\n-      typedef typename _BPVector::size_type _Index_type;\n-      typedef _Tp pointer;\n-    \n-      _BPVector& _M_vbp;\n-      unsigned int *_M_curr_bmap;\n-      unsigned int *_M_last_bmap_in_block;\n-      _Index_type _M_curr_index;\n-    \n-    public:\n-      //Use the 2nd parameter with care. Make sure that such an entry\n-      //exists in the vector before passing that particular index to\n-      //this ctor.\n-      _Bit_map_counter (_BPVector& Rvbp, int __index = -1) \n-\t: _M_vbp(Rvbp)\n-      {\n-\tthis->_M_reset(__index);\n       }\n-    \n-      void _M_reset (int __index = -1) throw()\n+\n+    template<typename _Tp>\n+      void __mini_vector<_Tp>::\n+      erase(iterator __pos) throw()\n       {\n-\tif (__index == -1)\n+\twhile (__pos + 1 != this->end())\n \t  {\n-\t    _M_curr_bmap = 0;\n-\t    _M_curr_index = (_Index_type)-1;\n-\t    return;\n+\t    *__pos = __pos[1];\n+\t    ++__pos;\n \t  }\n+\t--this->_M_finish;\n+      }\n \n-\t_M_curr_index = __index;\n-\t_M_curr_bmap = reinterpret_cast<unsigned int*>(_M_vbp[_M_curr_index].first) - 1;\n \n-\tassert (__index <= (int)_M_vbp.size() - 1);\n-\t\n-\t_M_last_bmap_in_block = _M_curr_bmap - \n-\t  ((_M_vbp[_M_curr_index].second - _M_vbp[_M_curr_index].first + 1) / _Bits_Per_Block - 1);\n-      }\n-    \n-      //Dangerous Function! Use with extreme care. Pass to this\n-      //function ONLY those values that are known to be correct,\n-      //otherwise this will mess up big time.\n-      void _M_set_internal_bit_map (unsigned int *__new_internal_marker) throw()\n+    template<typename _Tp>\n+      struct __mv_iter_traits\n       {\n-\t_M_curr_bmap = __new_internal_marker;\n-      }\n-    \n-      bool _M_finished () const throw()\n+\ttypedef typename _Tp::value_type value_type;\n+\ttypedef typename _Tp::difference_type difference_type;\n+      };\n+\n+    template<typename _Tp>\n+      struct __mv_iter_traits<_Tp*>\n       {\n-\treturn (_M_curr_bmap == 0);\n-      }\n-    \n-      _Bit_map_counter& operator++ () throw()\n+\ttypedef _Tp value_type;\n+\ttypedef std::ptrdiff_t difference_type;\n+      };\n+\n+    enum \n+      { \n+\tbits_per_byte = 8, \n+\tbits_per_block = sizeof(unsigned int) * bits_per_byte \n+      };\n+\n+    template<typename _ForwardIterator, typename _Tp, typename _Compare>\n+      _ForwardIterator\n+      __lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t    const _Tp& __val, _Compare __comp)\n       {\n-\tif (_M_curr_bmap == _M_last_bmap_in_block)\n+\ttypedef typename __mv_iter_traits<_ForwardIterator>::value_type\n+\t  _ValueType;\n+\ttypedef typename __mv_iter_traits<_ForwardIterator>::difference_type\n+\t  _DistanceType;\n+\n+\t_DistanceType __len = __last - __first;\n+\t_DistanceType __half;\n+\t_ForwardIterator __middle;\n+\n+\twhile (__len > 0)\n \t  {\n-\t    if (++_M_curr_index == _M_vbp.size())\n+\t    __half = __len >> 1;\n+\t    __middle = __first;\n+\t    __middle += __half;\n+\t    if (__comp(*__middle, __val))\n \t      {\n-\t\t_M_curr_bmap = 0;\n+\t\t__first = __middle;\n+\t\t++__first;\n+\t\t__len = __len - __half - 1;\n \t      }\n \t    else\n-\t      {\n-\t\tthis->_M_reset (_M_curr_index);\n-\t      }\n+\t      __len = __half;\n \t  }\n-\telse\n-\t  {\n-\t    --_M_curr_bmap;\n-\t  }\n-\treturn *this;\n+\treturn __first;\n       }\n-    \n-      unsigned int *_M_get ()\n+\n+    template<typename _InputIterator, typename _Predicate>\n+      inline _InputIterator\n+      __find_if(_InputIterator __first, _InputIterator __last, _Predicate __p)\n       {\n-\treturn _M_curr_bmap;\n+\twhile (__first != __last && !__p(*__first))\n+\t  ++__first;\n+\treturn __first;\n       }\n+\n+    template<typename _AddrPair>\n+      inline size_t\n+      __num_blocks(_AddrPair __ap)\n+      { return (__ap.second - __ap.first) + 1; }\n+\n+    template<typename _AddrPair>\n+      inline size_t \n+      __num_bitmaps(_AddrPair __ap)\n+      { return __num_blocks(__ap) / bits_per_block; }\n+\n+    // _Tp should be a pointer type.\n+    template<typename _Tp>\n+      class _Inclusive_between \n+      : public std::unary_function<typename std::pair<_Tp, _Tp>, bool>\n+      {\n+\ttypedef _Tp pointer;\n+\tpointer _M_ptr_value;\n+\ttypedef typename std::pair<_Tp, _Tp> _Block_pair;\n+\t\n+      public:\n+\t_Inclusive_between(pointer __ptr) : _M_ptr_value(__ptr) \n+\t{ }\n+\t\n+\tbool \n+\toperator()(_Block_pair __bp) const throw()\n+\t{\n+\t  if (std::less_equal<pointer>()(_M_ptr_value, __bp.second) \n+\t      && std::greater_equal<pointer>()(_M_ptr_value, __bp.first))\n+\t    return true;\n+\t  else\n+\t    return false;\n+\t}\n+      };\n+  \n+    // Used to pass a Functor to functions by reference.\n+    template<typename _Functor>\n+      class _Functor_Ref \n+      : public std::unary_function<typename _Functor::argument_type, \n+\t\t\t\t   typename _Functor::result_type>\n+      {\n+\t_Functor& _M_fref;\n+\t\n+      public:\n+\ttypedef typename _Functor::argument_type argument_type;\n+\ttypedef typename _Functor::result_type result_type;\n+\n+\t_Functor_Ref(_Functor& __fref) : _M_fref(__fref) \n+\t{ }\n+\n+\tresult_type \n+\toperator()(argument_type __arg) \n+\t{ return _M_fref(__arg); }\n+      };\n+\n+    // _Tp should be a pointer type, and _Alloc is the Allocator for\n+    // the vector.\n+    template<typename _Tp>\n+      class _Ffit_finder \n+      : public std::unary_function<typename std::pair<_Tp, _Tp>, bool>\n+      {\n+\ttypedef typename std::pair<_Tp, _Tp> _Block_pair;\n+\ttypedef typename balloc::__mini_vector<_Block_pair> _BPVector;\n+\ttypedef typename _BPVector::difference_type _Counter_type;\n+\n+\tunsigned int* _M_pbitmap;\n+\tunsigned int _M_data_offset;\n+\n+      public:\n+\t_Ffit_finder() : _M_pbitmap(0), _M_data_offset(0)\n+\t{ }\n+\n+\tbool \n+\toperator()(_Block_pair __bp) throw()\n+\t{\n+\t  // Set the _rover to the last unsigned integer, which is the\n+\t  // bitmap to the first free block. Thus, the bitmaps are in exact\n+\t  // reverse order of the actual memory layout. So, we count down\n+\t  // the bimaps, which is the same as moving up the memory.\n+\n+\t  // If the used count stored at the start of the Bit Map headers\n+\t  // is equal to the number of Objects that the current Block can\n+\t  // store, then there is definitely no space for another single\n+\t  // object, so just return false.\n+\t  _Counter_type __diff = \n+\t    __gnu_cxx::balloc::__num_bitmaps(__bp);\n+\n+\t  if (*reinterpret_cast<unsigned int*>\n+\t      (reinterpret_cast<char*>(__bp.first) - (sizeof(unsigned int) * \n+\t\t\t\t\t\t      (__diff+1)))\n+\t      == __gnu_cxx::balloc::__num_blocks(__bp))\n+\t    return false;\n+\n+\t  unsigned int* __rover = reinterpret_cast<unsigned int*>(__bp.first) - 1;\n+\n+\t  for (_Counter_type __i = 0; __i < __diff; ++__i)\n+\t    {\n+\t      _M_data_offset = __i;\n+\t      if (*__rover)\n+\t\t{\n+\t\t  _M_pbitmap = __rover;\n+\t\t  return true;\n+\t\t}\n+\t      --__rover;\n+\t    }\n+\t  return false;\n+\t}\n+\n     \n-      pointer _M_base () { return _M_vbp[_M_curr_index].first; }\n-      unsigned int _M_offset ()\n+\tunsigned int*\n+\t_M_get() const throw()\n+\t{ return _M_pbitmap; }\n+\n+\tunsigned int\n+\t_M_offset() const throw()\n+\t{ return _M_data_offset * bits_per_block; }\n+      };\n+\n+\n+  \n+    // _Tp should be a pointer type.\n+    template<typename _Tp>\n+      class _Bitmap_counter\n       {\n-\treturn _Bits_Per_Block * ((reinterpret_cast<unsigned int*>(this->_M_base()) - _M_curr_bmap) - 1);\n-      }\n+\ttypedef typename balloc::__mini_vector<typename std::pair<_Tp, _Tp> > \n+\t_BPVector;\n+\ttypedef typename _BPVector::size_type _Index_type;\n+\ttypedef _Tp pointer;\n     \n-      unsigned int _M_where () { return _M_curr_index; }\n-    };\n-  }\n+\t_BPVector& _M_vbp;\n+\tunsigned int* _M_curr_bmap;\n+\tunsigned int* _M_last_bmap_in_block;\n+\t_Index_type _M_curr_index;\n+    \n+      public:\n+\t// Use the 2nd parameter with care. Make sure that such an\n+\t// entry exists in the vector before passing that particular\n+\t// index to this ctor.\n+\t_Bitmap_counter(_BPVector& Rvbp, int __index = -1) : _M_vbp(Rvbp)\n+\t{ this->_M_reset(__index); }\n+    \n+\tvoid \n+\t_M_reset(int __index = -1) throw()\n+\t{\n+\t  if (__index == -1)\n+\t    {\n+\t      _M_curr_bmap = 0;\n+\t      _M_curr_index = static_cast<_Index_type>(-1);\n+\t      return;\n+\t    }\n \n-  //Generic Version of the bsf instruction.\n-  typedef unsigned int _Bit_map_type;\n-  static inline unsigned int _Bit_scan_forward (register _Bit_map_type __num)\n-  {\n-    return static_cast<unsigned int>(__builtin_ctz(__num));\n-  }\n+\t  _M_curr_index = __index;\n+\t  _M_curr_bmap = reinterpret_cast<unsigned int*>\n+\t    (_M_vbp[_M_curr_index].first) - 1;\n \n-  struct _OOM_handler {\n-    static std::new_handler _S_old_handler;\n-    static bool _S_handled_oom;\n-    typedef void (*_FL_clear_proc)(void);\n-    static _FL_clear_proc _S_oom_fcp;\n+\t  _BALLOC_ASSERT(__index <= (int)_M_vbp.size() - 1);\n+\t\n+\t  _M_last_bmap_in_block = _M_curr_bmap\n+\t    - ((_M_vbp[_M_curr_index].second \n+\t\t- _M_vbp[_M_curr_index].first + 1) \n+\t       / bits_per_block - 1);\n+\t}\n     \n-    _OOM_handler (_FL_clear_proc __fcp)\n-    {\n-      _S_oom_fcp = __fcp;\n-      _S_old_handler = std::set_new_handler (_S_handle_oom_proc);\n-      _S_handled_oom = false;\n-    }\n+\t// Dangerous Function! Use with extreme care. Pass to this\n+\t// function ONLY those values that are known to be correct,\n+\t// otherwise this will mess up big time.\n+\tvoid\n+\t_M_set_internal_bitmap(unsigned int* __new_internal_marker) throw()\n+\t{ _M_curr_bmap = __new_internal_marker; }\n+    \n+\tbool\n+\t_M_finished() const throw()\n+\t{ return(_M_curr_bmap == 0); }\n+    \n+\t_Bitmap_counter&\n+\toperator++() throw()\n+\t{\n+\t  if (_M_curr_bmap == _M_last_bmap_in_block)\n+\t    {\n+\t      if (++_M_curr_index == _M_vbp.size())\n+\t\t_M_curr_bmap = 0;\n+\t      else\n+\t\tthis->_M_reset(_M_curr_index);\n+\t    }\n+\t  else\n+\t    --_M_curr_bmap;\n+\t  return *this;\n+\t}\n+    \n+\tunsigned int*\n+\t_M_get() const throw()\n+\t{ return _M_curr_bmap; }\n+    \n+\tpointer \n+\t_M_base() const throw()\n+\t{ return _M_vbp[_M_curr_index].first; }\n \n-    static void _S_handle_oom_proc()\n-    {\n-      _S_oom_fcp();\n-      std::set_new_handler (_S_old_handler);\n-      _S_handled_oom = true;\n-    }\n+\tunsigned int \n+\t_M_offset() const throw()\n+\t{\n+\t  return bits_per_block\n+\t    * ((reinterpret_cast<unsigned int*>(this->_M_base()) \n+\t\t- _M_curr_bmap) - 1);\n+\t}\n+    \n+\tunsigned int\n+\t_M_where() const throw()\n+\t{ return _M_curr_index; }\n+      };\n \n-    ~_OOM_handler ()\n+    inline void \n+    __bit_allocate(unsigned int* __pbmap, unsigned int __pos) throw()\n     {\n-      if (!_S_handled_oom)\n-\tstd::set_new_handler (_S_old_handler);\n+      unsigned int __mask = 1 << __pos;\n+      __mask = ~__mask;\n+      *__pbmap &= __mask;\n     }\n-  };\n-  \n-  std::new_handler _OOM_handler::_S_old_handler;\n-  bool _OOM_handler::_S_handled_oom = false;\n-  _OOM_handler::_FL_clear_proc _OOM_handler::_S_oom_fcp = 0;\n   \n+    inline void \n+    __bit_free(unsigned int* __pbmap, unsigned int __pos) throw()\n+    {\n+      unsigned int __mask = 1 << __pos;\n+      *__pbmap |= __mask;\n+    }\n+  } // namespace balloc\n \n-  class _BA_free_list_store {\n-    struct _LT_pointer_compare {\n-      template <typename _Tp>\n-      bool operator() (_Tp* __pt, _Tp const& __crt) const throw()\n-      {\n-\treturn *__pt < __crt;\n-      }\n+  // Generic Version of the bsf instruction.\n+  inline unsigned int \n+  _Bit_scan_forward(register unsigned int __num)\n+  { return static_cast<unsigned int>(__builtin_ctz(__num)); }\n+\n+  class free_list\n+  {\n+    typedef unsigned int* value_type;\n+    typedef balloc::__mini_vector<value_type> vector_type;\n+    typedef vector_type::iterator iterator;\n+\n+    struct _LT_pointer_compare\n+    {\n+      bool\n+      operator()(const unsigned int* __pui, const unsigned int __cui) const throw()\n+      { return *__pui < __cui; }\n     };\n \n-#if defined __GTHREADS\n+#if defined __GTHREADS \n     static _Mutex _S_bfl_mutex;\n #endif\n-    static std::vector<unsigned int*> _S_free_list;\n-    typedef std::vector<unsigned int*>::iterator _FLIter;\n-\n-    static void _S_validate_free_list(unsigned int *__addr) throw()\n+    static vector_type _S_free_list;\n+    \n+    void\n+    _M_validate(unsigned int* __addr) throw()\n     {\n       const unsigned int __max_size = 64;\n       if (_S_free_list.size() >= __max_size)\n \t{\n-\t  //Ok, the threshold value has been reached.\n-\t  //We determine which block to remove from the list of free\n-\t  //blocks.\n+\t  // Ok, the threshold value has been reached.  We determine\n+\t  // which block to remove from the list of free blocks.\n \t  if (*__addr >= *_S_free_list.back())\n \t    {\n-\t      //Ok, the new block is greater than or equal to the last\n-\t      //block in the list of free blocks. We just free the new\n-\t      //block.\n-\t      operator delete((void*)__addr);\n+\t      // Ok, the new block is greater than or equal to the\n+\t      // last block in the list of free blocks. We just free\n+\t      // the new block.\n+\t      operator delete(static_cast<void*>(__addr));\n \t      return;\n \t    }\n \t  else\n \t    {\n-\t      //Deallocate the last block in the list of free lists, and\n-\t      //insert the new one in it's correct position.\n-\t      operator delete((void*)_S_free_list.back());\n+\t      // Deallocate the last block in the list of free lists,\n+\t      // and insert the new one in it's correct position.\n+\t      operator delete(static_cast<void*>(_S_free_list.back()));\n \t      _S_free_list.pop_back();\n \t    }\n \t}\n \t  \n-      //Just add the block to the list of free lists\n-      //unconditionally.\n-      _FLIter __temp = std::lower_bound(_S_free_list.begin(), _S_free_list.end(), \n-\t\t\t\t\t*__addr, _LT_pointer_compare ());\n-      //We may insert the new free list before _temp;\n+      // Just add the block to the list of free lists unconditionally.\n+      iterator __temp = __gnu_cxx::balloc::__lower_bound\n+\t(_S_free_list.begin(), _S_free_list.end(), \n+\t *__addr, _LT_pointer_compare());\n+\n+      // We may insert the new free list before _temp;\n       _S_free_list.insert(__temp, __addr);\n     }\n \n-    static bool _S_should_i_give(unsigned int __block_size, unsigned int __required_size) throw()\n+    bool \n+    _M_should_i_give(unsigned int __block_size, \n+\t\t     unsigned int __required_size) throw()\n     {\n       const unsigned int __max_wastage_percentage = 36;\n       if (__block_size >= __required_size && \n-\t  (((__block_size - __required_size) * 100 / __block_size) < __max_wastage_percentage))\n+\t  (((__block_size - __required_size) * 100 / __block_size)\n+\t   < __max_wastage_percentage))\n \treturn true;\n       else\n \treturn false;\n     }\n \n   public:\n-    typedef _BA_free_list_store _BFL_type;\n-\n-    static inline void _S_insert_free_list(unsigned int *__addr) throw()\n+    inline void \n+    _M_insert(unsigned int* __addr) throw()\n     {\n #if defined __GTHREADS\n-      _Lock __bfl_lock(&_S_bfl_mutex);\n+      _Auto_Lock __bfl_lock(&_S_bfl_mutex);\n #endif\n-      //Call _S_validate_free_list to decide what should be done with this\n-      //particular free list.\n-      _S_validate_free_list(--__addr);\n+      // Call _M_validate to decide what should be done with\n+      // this particular free list.\n+      this->_M_validate(reinterpret_cast<unsigned int*>\n+\t\t\t(reinterpret_cast<char*>(__addr) \n+\t\t\t - sizeof(unsigned int)));\n     }\n     \n-    static unsigned int *_S_get_free_list(unsigned int __sz) throw (std::bad_alloc)\n-    {\n-#if defined __GTHREADS\n-      _Lock __bfl_lock(&_S_bfl_mutex);\n-#endif\n-      _FLIter __temp = std::lower_bound(_S_free_list.begin(), _S_free_list.end(), \n-\t\t\t\t\t__sz, _LT_pointer_compare());\n-      if (__temp == _S_free_list.end() || !_S_should_i_give (**__temp, __sz))\n-\t{\n-\t  //We hold the lock because the OOM_Handler is a stateless\n-\t  //entity.\n-\t  _OOM_handler __set_handler(_BFL_type::_S_clear);\n-\t  unsigned int *__ret_val = reinterpret_cast<unsigned int*>\n-\t    (operator new (__sz + sizeof(unsigned int)));\n-\t  *__ret_val = __sz;\n-\t  return ++__ret_val;\n-\t}\n-      else\n-\t{\n-\t  unsigned int* __ret_val = *__temp;\n-\t  _S_free_list.erase (__temp);\n-\t  return ++__ret_val;\n-\t}\n-    }\n-\n-    //This function just clears the internal Free List, and gives back\n-    //all the memory to the OS.\n-    static void _S_clear()\n-    {\n-#if defined __GTHREADS\n-      _Lock __bfl_lock(&_S_bfl_mutex);\n-#endif\n-      _FLIter __iter = _S_free_list.begin();\n-      while (__iter != _S_free_list.end())\n-\t{\n-\t  operator delete((void*)*__iter);\n-\t  ++__iter;\n-\t}\n-      _S_free_list.clear();\n-    }\n+    unsigned int*\n+    _M_get(unsigned int __sz) throw(std::bad_alloc);\n \n+    // This function just clears the internal Free List, and gives back\n+    // all the memory to the OS.\n+    void \n+    _M_clear();\n   };\n \n-#if defined __GTHREADS\n-  _Mutex _BA_free_list_store::_S_bfl_mutex;\n-#endif\n-  std::vector<unsigned int*> _BA_free_list_store::_S_free_list;\n \n-  template <typename _Tp> class bitmap_allocator;\n-  // specialize for void:\n-  template <> class bitmap_allocator<void> {\n-  public:\n-    typedef void*       pointer;\n-    typedef const void* const_pointer;\n-    //  reference-to-void members are impossible.\n-    typedef void  value_type;\n-    template <typename _Tp1> struct rebind { typedef bitmap_allocator<_Tp1> other; };\n-  };\n+  // Forward declare the class.\n+  template<typename _Tp> \n+    class bitmap_allocator;\n \n-  template <typename _Tp> class bitmap_allocator : private _BA_free_list_store {\n-  public:\n-    typedef size_t    size_type;\n-    typedef ptrdiff_t difference_type;\n-    typedef _Tp*        pointer;\n-    typedef const _Tp*  const_pointer;\n-    typedef _Tp&        reference;\n-    typedef const _Tp&  const_reference;\n-    typedef _Tp         value_type;\n-    template <typename _Tp1> struct rebind { typedef bitmap_allocator<_Tp1> other; };\n-\n-  private:\n-    static const unsigned int _Bits_Per_Byte = 8;\n-    static const unsigned int _Bits_Per_Block = sizeof(unsigned int) * _Bits_Per_Byte;\n-\n-    static inline void _S_bit_allocate(unsigned int *__pbmap, unsigned int __pos) throw()\n+  // Specialize for void:\n+  template<>\n+    class bitmap_allocator<void>\n     {\n-      unsigned int __mask = 1 << __pos;\n-      __mask = ~__mask;\n-      *__pbmap &= __mask;\n-    }\n-  \n-    static inline void _S_bit_free(unsigned int *__pbmap, unsigned int __pos) throw()\n-    {\n-      unsigned int __mask = 1 << __pos;\n-      *__pbmap |= __mask;\n-    }\n+    public:\n+      typedef void*       pointer;\n+      typedef const void* const_pointer;\n \n-    static inline void *_S_memory_get(size_t __sz) throw (std::bad_alloc)\n-    {\n-      return operator new(__sz);\n-    }\n+      // Reference-to-void members are impossible.\n+      typedef void  value_type;\n+      template<typename _Tp1>\n+        struct rebind\n+\t{\n+\t  typedef bitmap_allocator<_Tp1> other;\n+\t};\n+    };\n \n-    static inline void _S_memory_put(void *__vptr) throw ()\n+  template<typename _Tp>\n+    class bitmap_allocator : private free_list\n     {\n-      operator delete(__vptr);\n-    }\n+    public:\n+      typedef std::size_t    size_type;\n+      typedef std::ptrdiff_t difference_type;\n+      typedef _Tp*        pointer;\n+      typedef const _Tp*  const_pointer;\n+      typedef _Tp&        reference;\n+      typedef const _Tp&  const_reference;\n+      typedef _Tp         value_type;\n+      template<typename _Tp1>\n+        struct rebind\n+\t{\n+\t  typedef bitmap_allocator<_Tp1> other;\n+\t};\n \n-    typedef typename std::pair<pointer, pointer> _Block_pair;\n-    typedef typename __gnu_cxx::new_allocator<_Block_pair> _BPVec_allocator_type;\n-    typedef typename std::vector<_Block_pair, _BPVec_allocator_type> _BPVector;\n+    private:\n+      template<unsigned int _BSize, unsigned int _AlignSize>\n+        struct aligned_size\n+\t{\n+\t  enum\n+\t    { \n+\t      modulus = _BSize % _AlignSize,\n+\t      value = _BSize + (modulus ? _AlignSize - (modulus) : 0)\n+\t    };\n+\t};\n+\n+      struct _Alloc_block\n+      {\n+\tchar __unused[aligned_size<sizeof(value_type), 8>::value];\n+      };\n \n \n-#if defined CHECK_FOR_ERRORS\n-    //Complexity: O(lg(N)). Where, N is the number of block of size\n-    //sizeof(value_type).\n-    static void _S_check_for_free_blocks() throw()\n-    {\n-      typedef typename __gnu_cxx::__aux_balloc::_Ffit_finder<pointer, _BPVec_allocator_type> _FFF;\n-      _FFF __fff;\n-      typedef typename _BPVector::iterator _BPiter;\n-      _BPiter __bpi = std::find_if(_S_mem_blocks.begin(), _S_mem_blocks.end(), \n-\t\t\t\t   __gnu_cxx::__aux_balloc::_Functor_Ref<_FFF>(__fff));\n-      assert(__bpi == _S_mem_blocks.end());\n-    }\n-#endif\n+      typedef typename std::pair<_Alloc_block*, _Alloc_block*> _Block_pair;\n \n+      typedef typename \n+      balloc::__mini_vector<_Block_pair> _BPVector;\n \n-    //Complexity: O(1), but internally depends upon the complexity of\n-    //the function _BA_free_list_store::_S_get_free_list. The part\n-    //where the bitmap headers are written is of worst case complexity:\n-    //O(X),where X is the number of blocks of size sizeof(value_type)\n-    //within the newly acquired block. Having a tight bound.\n-    static void _S_refill_pool() throw (std::bad_alloc)\n-    {\n-#if defined CHECK_FOR_ERRORS\n-      _S_check_for_free_blocks();\n+#if defined _BALLOC_SANITY_CHECK\n+      // Complexity: O(lg(N)). Where, N is the number of block of size\n+      // sizeof(value_type).\n+      void \n+      _S_check_for_free_blocks() throw()\n+      {\n+\ttypedef typename \n+\t  __gnu_cxx::balloc::_Ffit_finder<_Alloc_block*> _FFF;\n+\t_FFF __fff;\n+\ttypedef typename _BPVector::iterator _BPiter;\n+\t_BPiter __bpi = \n+\t  __gnu_cxx::balloc::__find_if\n+\t  (_S_mem_blocks.begin(), _S_mem_blocks.end(), \n+\t   __gnu_cxx::balloc::_Functor_Ref<_FFF>(__fff));\n+\n+\t_BALLOC_ASSERT(__bpi == _S_mem_blocks.end());\n+      }\n #endif\n \n-      const unsigned int __num_bit_maps = _S_block_size / _Bits_Per_Block;\n-      const unsigned int __size_to_allocate = sizeof(unsigned int) + \n-\t_S_block_size * sizeof(value_type) + __num_bit_maps*sizeof(unsigned int);\n-\n-      unsigned int *__temp = \n-\treinterpret_cast<unsigned int*>(_BA_free_list_store::_S_get_free_list(__size_to_allocate));\n-      *__temp = 0;\n-      ++__temp;\n+      // Complexity: O(1), but internally depends upon the complexity\n+      // of the function free_list::_M_get. The\n+      // part where the bitmap headers are written is of worst case\n+      // complexity: O(X),where X is the number of blocks of size\n+      // sizeof(value_type) within the newly acquired block. Having a\n+      // tight bound.\n+      void \n+      _S_refill_pool() throw(std::bad_alloc)\n+      {\n+#if defined _BALLOC_SANITY_CHECK\n+\t_S_check_for_free_blocks();\n+#endif\n \n-      //The Header information goes at the Beginning of the Block.\n-      _Block_pair __bp = std::make_pair(reinterpret_cast<pointer>(__temp + __num_bit_maps), \n-\t\t\t\t       reinterpret_cast<pointer>(__temp + __num_bit_maps) \n-\t\t\t\t\t+ _S_block_size - 1);\n+\tconst unsigned int __num_bitmaps = _S_block_size / balloc::bits_per_block;\n+\tconst unsigned int __size_to_allocate = sizeof(unsigned int)\n+\t  + _S_block_size * sizeof(_Alloc_block) \n+\t  + __num_bitmaps * sizeof(unsigned int);\n+\n+\tunsigned int* __temp = \n+\t  reinterpret_cast<unsigned int*>(this->_M_get(__size_to_allocate));\n+\t*__temp = 0;\n+\t// ++__temp;\n+\t__temp = reinterpret_cast<unsigned int*>\n+\t  (reinterpret_cast<char*>(__temp) + sizeof(unsigned int));\n+\n+\t// The Header information goes at the Beginning of the Block.\n+\t_Block_pair __bp = \n+\t  std::make_pair(reinterpret_cast<_Alloc_block*>\n+\t\t\t (__temp + __num_bitmaps), \n+\t\t\t reinterpret_cast<_Alloc_block*>\n+\t\t\t (__temp + __num_bitmaps) \n+\t\t\t + _S_block_size - 1);\n+\t\n+\t// Fill the Vector with this information.\n+\t_S_mem_blocks.push_back(__bp);\n \n-      //Fill the Vector with this information.\n-      _S_mem_blocks.push_back(__bp);\n+\tunsigned int __bit_mask = 0; // 0 Indicates all Allocated.\n+\t__bit_mask = ~__bit_mask; // 1 Indicates all Free.\n \n-      unsigned int __bit_mask = 0; //0 Indicates all Allocated.\n-      __bit_mask = ~__bit_mask; //1 Indicates all Free.\n+\tfor (unsigned int __i = 0; __i < __num_bitmaps; ++__i)\n+\t  __temp[__i] = __bit_mask;\n \n-      for (unsigned int __i = 0; __i < __num_bit_maps; ++__i)\n-\t__temp[__i] = __bit_mask;\n+\t_S_block_size *= 2;\n+      }\n \n-      //On some implementations, operator new might throw bad_alloc, or\n-      //malloc might fail if the size passed is too large, therefore, we\n-      //limit the size passed to malloc or operator new.\n-      _S_block_size *= 2;\n-    }\n \n-    static _BPVector _S_mem_blocks;\n-    static unsigned int _S_block_size;\n-    static __gnu_cxx::__aux_balloc::_Bit_map_counter<pointer, _BPVec_allocator_type> _S_last_request;\n-    static typename _BPVector::size_type _S_last_dealloc_index;\n+      static _BPVector _S_mem_blocks;\n+      static unsigned int _S_block_size;\n+      static __gnu_cxx::balloc::\n+      _Bitmap_counter<_Alloc_block*> _S_last_request;\n+      static typename _BPVector::size_type _S_last_dealloc_index;\n #if defined __GTHREADS\n-    static _Mutex _S_mut;\n+      static _Mutex _S_mut;\n #endif\n \n-    //Complexity: Worst case complexity is O(N), but that is hardly ever\n-    //hit. if and when this particular case is encountered, the next few\n-    //cases are guaranteed to have a worst case complexity of O(1)!\n-    //That's why this function performs very well on the average. you\n-    //can consider this function to be having a complexity refrred to\n-    //commonly as: Amortized Constant time.\n-    static pointer _S_allocate_single_object()\n-    {\n+    public:\n+\n+      // Complexity: Worst case complexity is O(N), but that is hardly\n+      // ever hit. if and when this particular case is encountered,\n+      // the next few cases are guaranteed to have a worst case\n+      // complexity of O(1)!  That's why this function performs very\n+      // well on the average. you can consider this function to be\n+      // having a complexity referred to commonly as: Amortized\n+      // Constant time.\n+      pointer \n+      _M_allocate_single_object() throw(std::bad_alloc)\n+      {\n #if defined __GTHREADS\n-      _Lock __bit_lock(&_S_mut);\n+\t_Auto_Lock __bit_lock(&_S_mut);\n #endif\n \n-      //The algorithm is something like this: The last_requst variable\n-      //points to the last accessed Bit Map. When such a condition\n-      //occurs, we try to find a free block in the current bitmap, or\n-      //succeeding bitmaps until the last bitmap is reached. If no free\n-      //block turns up, we resort to First Fit method.\n-\n-      //WARNING: Do not re-order the condition in the while statement\n-      //below, because it relies on C++'s short-circuit\n-      //evaluation. The return from _S_last_request->_M_get() will NOT\n-      //be dereferenceable if _S_last_request->_M_finished() returns\n-      //true. This would inevitibly lead to a NULL pointer dereference\n-      //if tinkered with.\n-      while (_S_last_request._M_finished() == false && (*(_S_last_request._M_get()) == 0))\n-\t{\n-\t  _S_last_request.operator++();\n-\t}\n+\t// The algorithm is something like this: The last_request\n+\t// variable points to the last accessed Bit Map. When such a\n+\t// condition occurs, we try to find a free block in the\n+\t// current bitmap, or succeeding bitmaps until the last bitmap\n+\t// is reached. If no free block turns up, we resort to First\n+\t// Fit method.\n+\n+\t// WARNING: Do not re-order the condition in the while\n+\t// statement below, because it relies on C++'s short-circuit\n+\t// evaluation. The return from _S_last_request->_M_get() will\n+\t// NOT be dereference able if _S_last_request->_M_finished()\n+\t// returns true. This would inevitably lead to a NULL pointer\n+\t// dereference if tinkered with.\n+\twhile (_S_last_request._M_finished() == false\n+\t       && (*(_S_last_request._M_get()) == 0))\n+\t  {\n+\t    _S_last_request.operator++();\n+\t  }\n \n-      if (__builtin_expect(_S_last_request._M_finished() == true, false))\n-\t{\n-\t  //Fall Back to First Fit algorithm.\n-\t  typedef typename __gnu_cxx::__aux_balloc::_Ffit_finder<pointer, _BPVec_allocator_type> _FFF;\n-\t  _FFF __fff;\n-\t  typedef typename _BPVector::iterator _BPiter;\n-\t  _BPiter __bpi = std::find_if(_S_mem_blocks.begin(), _S_mem_blocks.end(), \n-\t\t\t\t      __gnu_cxx::__aux_balloc::_Functor_Ref<_FFF>(__fff));\n-\n-\t  if (__bpi != _S_mem_blocks.end())\n-\t    {\n-\t      //Search was successful. Ok, now mark the first bit from\n-\t      //the right as 0, meaning Allocated. This bit is obtained\n-\t      //by calling _M_get() on __fff.\n-\t      unsigned int __nz_bit = _Bit_scan_forward(*__fff._M_get());\n-\t      _S_bit_allocate(__fff._M_get(), __nz_bit);\n-\n-\t      _S_last_request._M_reset(__bpi - _S_mem_blocks.begin());\n-\n-\t      //Now, get the address of the bit we marked as allocated.\n-\t      pointer __ret_val = __bpi->first + __fff._M_offset() + __nz_bit;\n-\t      unsigned int *__puse_count = reinterpret_cast<unsigned int*>(__bpi->first) - \n-\t\t(__gnu_cxx::__aux_balloc::__balloc_num_bit_maps(*__bpi) + 1);\n-\t      ++(*__puse_count);\n-\t      return __ret_val;\n-\t    }\n-\t  else\n-\t    {\n-\t      //Search was unsuccessful. We Add more memory to the pool\n-\t      //by calling _S_refill_pool().\n-\t      _S_refill_pool();\n+\tif (__builtin_expect(_S_last_request._M_finished() == true, false))\n+\t  {\n+\t    // Fall Back to First Fit algorithm.\n+\t    typedef typename \n+\t      __gnu_cxx::balloc::_Ffit_finder<_Alloc_block*> _FFF;\n+\t    _FFF __fff;\n+\t    typedef typename _BPVector::iterator _BPiter;\n+\t    _BPiter __bpi = \n+\t      __gnu_cxx::balloc::__find_if\n+\t      (_S_mem_blocks.begin(), _S_mem_blocks.end(), \n+\t       __gnu_cxx::balloc::_Functor_Ref<_FFF>(__fff));\n+\n+\t    if (__bpi != _S_mem_blocks.end())\n+\t      {\n+\t\t// Search was successful. Ok, now mark the first bit from\n+\t\t// the right as 0, meaning Allocated. This bit is obtained\n+\t\t// by calling _M_get() on __fff.\n+\t\tunsigned int __nz_bit = _Bit_scan_forward(*__fff._M_get());\n+\t\tballoc::__bit_allocate(__fff._M_get(), __nz_bit);\n+\n+\t\t_S_last_request._M_reset(__bpi - _S_mem_blocks.begin());\n+\n+\t\t// Now, get the address of the bit we marked as allocated.\n+\t\tpointer __ret = reinterpret_cast<pointer>\n+\t\t  (__bpi->first + __fff._M_offset() + __nz_bit);\n+\t\tunsigned int* __puse_count = reinterpret_cast<unsigned int*>\n+\t\t  (reinterpret_cast<char*>\n+\t\t   (__bpi->first) - (sizeof(unsigned int) * \n+\t\t\t\t     (__gnu_cxx::balloc::__num_bitmaps(*__bpi)+1)));\n+\t\t\n+\t\t++(*__puse_count);\n+\t\treturn __ret;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// Search was unsuccessful. We Add more memory to the\n+\t\t// pool by calling _S_refill_pool().\n+\t\t_S_refill_pool();\n \n-\t      //_M_Reset the _S_last_request structure to the first free\n-\t      //block's bit map.\n-\t      _S_last_request._M_reset(_S_mem_blocks.size() - 1);\n+\t\t// _M_Reset the _S_last_request structure to the first\n+\t\t// free block's bit map.\n+\t\t_S_last_request._M_reset(_S_mem_blocks.size() - 1);\n \n-\t      //Now, mark that bit as allocated.\n-\t    }\n-\t}\n-      //_S_last_request holds a pointer to a valid bit map, that points\n-      //to a free block in memory.\n-      unsigned int __nz_bit = _Bit_scan_forward(*_S_last_request._M_get());\n-      _S_bit_allocate(_S_last_request._M_get(), __nz_bit);\n-\n-      pointer __ret_val = _S_last_request._M_base() + _S_last_request._M_offset() + __nz_bit;\n-\n-      unsigned int *__puse_count = reinterpret_cast<unsigned int*>\n-\t(_S_mem_blocks[_S_last_request._M_where()].first) - \n-\t(__gnu_cxx::__aux_balloc::__balloc_num_bit_maps(_S_mem_blocks[_S_last_request._M_where()]) + 1);\n-      ++(*__puse_count);\n-      return __ret_val;\n-    }\n+\t\t// Now, mark that bit as allocated.\n+\t      }\n+\t  }\n \n-    //Complexity: O(lg(N)), but the worst case is hit quite often! I\n-    //need to do something about this. I'll be able to work on it, only\n-    //when I have some solid figures from a few real apps.\n-    static void _S_deallocate_single_object(pointer __p) throw()\n-    {\n+\t// _S_last_request holds a pointer to a valid bit map, that\n+\t// points to a free block in memory.\n+\tunsigned int __nz_bit = _Bit_scan_forward(*_S_last_request._M_get());\n+\tballoc::__bit_allocate(_S_last_request._M_get(), __nz_bit);\n+\n+\tpointer __ret = reinterpret_cast<pointer>\n+\t  (_S_last_request._M_base() + _S_last_request._M_offset() + __nz_bit);\n+\n+\tunsigned int* __puse_count = reinterpret_cast<unsigned int*>\n+\t  (reinterpret_cast<char*>\n+\t   (_S_mem_blocks[_S_last_request._M_where()].first)\n+\t   - (sizeof(unsigned int) * \n+\t      (__gnu_cxx::balloc::\n+\t       __num_bitmaps(_S_mem_blocks[_S_last_request._M_where()])+1)));\n+\n+\t++(*__puse_count);\n+\treturn __ret;\n+      }\n+\n+      // Complexity: O(lg(N)), but the worst case is hit quite often!\n+      // I need to do something about this. I'll be able to work on\n+      // it, only when I have some solid figures from a few real apps.\n+      void \n+      _M_deallocate_single_object(pointer __p) throw()\n+      {\n #if defined __GTHREADS\n-      _Lock __bit_lock(&_S_mut);\n+\t_Auto_Lock __bit_lock(&_S_mut);\n #endif\n+\t_Alloc_block* __real_p = reinterpret_cast<_Alloc_block*>(__p);\n \n-      typedef typename _BPVector::iterator _Iterator;\n-      typedef typename _BPVector::difference_type _Difference_type;\n+\ttypedef typename _BPVector::iterator _Iterator;\n+\ttypedef typename _BPVector::difference_type _Difference_type;\n \n-      _Difference_type __diff;\n-      int __displacement;\n+\t_Difference_type __diff;\n+\tint __displacement;\n \n-      assert(_S_last_dealloc_index >= 0);\n-\n-      if (__gnu_cxx::__aux_balloc::_Inclusive_between<pointer>(__p)(_S_mem_blocks[_S_last_dealloc_index]))\n-\t{\n-\t  assert(_S_last_dealloc_index <= _S_mem_blocks.size() - 1);\n+\t_BALLOC_ASSERT(_S_last_dealloc_index >= 0);\n \n-\t  //Initial Assumption was correct!\n-\t  __diff = _S_last_dealloc_index;\n-\t  __displacement = __p - _S_mem_blocks[__diff].first;\n-\t}\n-      else\n-\t{\n-\t  _Iterator _iter = (std::find_if(_S_mem_blocks.begin(), _S_mem_blocks.end(), \n-\t\t\t\t\t  __gnu_cxx::__aux_balloc::_Inclusive_between<pointer>(__p)));\n-\t  assert(_iter != _S_mem_blocks.end());\n+\t\n+\tif (__gnu_cxx::balloc::_Inclusive_between<_Alloc_block*>\n+\t    (__real_p)\n+\t    (_S_mem_blocks[_S_last_dealloc_index]))\n+\t  {\n+\t    _BALLOC_ASSERT(_S_last_dealloc_index <= _S_mem_blocks.size() - 1);\n \n-\t  __diff = _iter - _S_mem_blocks.begin();\n-\t  __displacement = __p - _S_mem_blocks[__diff].first;\n-\t  _S_last_dealloc_index = __diff;\n-\t}\n+\t    // Initial Assumption was correct!\n+\t    __diff = _S_last_dealloc_index;\n+\t    __displacement = __real_p - _S_mem_blocks[__diff].first;\n+\t  }\n+\telse\n+\t  {\n+\t    _Iterator _iter = \n+\t      __gnu_cxx::balloc::__find_if(_S_mem_blocks.begin(), \n+\t\t\t\t\t   _S_mem_blocks.end(), \n+\t\t\t\t\t   __gnu_cxx::balloc::\n+\t\t\t\t\t   _Inclusive_between<_Alloc_block*>(__real_p));\n+\t    _BALLOC_ASSERT(_iter != _S_mem_blocks.end());\n+\n+\t    __diff = _iter - _S_mem_blocks.begin();\n+\t    __displacement = __real_p - _S_mem_blocks[__diff].first;\n+\t    _S_last_dealloc_index = __diff;\n+\t  }\n \n-      //Get the position of the iterator that has been found.\n-      const unsigned int __rotate = __displacement % _Bits_Per_Block;\n-      unsigned int *__bit_mapC = reinterpret_cast<unsigned int*>(_S_mem_blocks[__diff].first) - 1;\n-      __bit_mapC -= (__displacement / _Bits_Per_Block);\n+\t// Get the position of the iterator that has been found.\n+\tconst unsigned int __rotate = __displacement % balloc::bits_per_block;\n+\tunsigned int* __bitmapC = \n+\t  reinterpret_cast<unsigned int*>(_S_mem_blocks[__diff].first) - 1;\n+\t__bitmapC -= (__displacement / balloc::bits_per_block);\n       \n-      _S_bit_free(__bit_mapC, __rotate);\n-      unsigned int *__puse_count = reinterpret_cast<unsigned int*>\n-\t(_S_mem_blocks[__diff].first) - \n-\t(__gnu_cxx::__aux_balloc::__balloc_num_bit_maps(_S_mem_blocks[__diff]) + 1);\n-\n-      assert(*__puse_count != 0);\n+\tballoc::__bit_free(__bitmapC, __rotate);\n+\tunsigned int* __puse_count = reinterpret_cast<unsigned int*>\n+\t\t  (reinterpret_cast<char*>\n+\t\t   (_S_mem_blocks[__diff].first)\n+\t\t   - (sizeof(unsigned int) * \n+\t\t      (__gnu_cxx::balloc::__num_bitmaps(_S_mem_blocks[__diff])+1)));\n+\t\n+\t_BALLOC_ASSERT(*__puse_count != 0);\n \n-      --(*__puse_count);\n+\t--(*__puse_count);\n \n-      if (__builtin_expect(*__puse_count == 0, false))\n-\t{\n-\t  _S_block_size /= 2;\n+\tif (__builtin_expect(*__puse_count == 0, false))\n+\t  {\n+\t    _S_block_size /= 2;\n \t  \n-\t  //We may safely remove this block.\n-\t  _Block_pair __bp = _S_mem_blocks[__diff];\n-\t  _S_insert_free_list(__puse_count);\n-\t  _S_mem_blocks.erase(_S_mem_blocks.begin() + __diff);\n-\n-\t  //We reset the _S_last_request variable to reflect the erased\n-\t  //block. We do this to protect future requests after the last\n-\t  //block has been removed from a particular memory Chunk,\n-\t  //which in turn has been returned to the free list, and\n-\t  //hence had been erased from the vector, so the size of the\n-\t  //vector gets reduced by 1.\n-\t  if ((_Difference_type)_S_last_request._M_where() >= __diff--)\n-\t    {\n-\t      _S_last_request._M_reset(__diff);\n-\t      //\t      assert(__diff >= 0);\n-\t    }\n+\t    // We can safely remove this block.\n+\t    // _Block_pair __bp = _S_mem_blocks[__diff];\n+\t    this->_M_insert(__puse_count);\n+\t    _S_mem_blocks.erase(_S_mem_blocks.begin() + __diff);\n+\n+\t    // Reset the _S_last_request variable to reflect the\n+\t    // erased block. We do this to protect future requests\n+\t    // after the last block has been removed from a particular\n+\t    // memory Chunk, which in turn has been returned to the\n+\t    // free list, and hence had been erased from the vector,\n+\t    // so the size of the vector gets reduced by 1.\n+\t    if ((_Difference_type)_S_last_request._M_where() >= __diff--)\n+\t      _S_last_request._M_reset(__diff); \n+\n+\t    // If the Index into the vector of the region of memory\n+\t    // that might hold the next address that will be passed to\n+\t    // deallocated may have been invalidated due to the above\n+\t    // erase procedure being called on the vector, hence we\n+\t    // try to restore this invariant too.\n+\t    if (_S_last_dealloc_index >= _S_mem_blocks.size())\n+\t      {\n+\t\t_S_last_dealloc_index =(__diff != -1 ? __diff : 0);\n+\t\t_BALLOC_ASSERT(_S_last_dealloc_index >= 0);\n+\t      }\n+\t  }\n+      }\n \n-\t  //If the Index into the vector of the region of memory that\n-\t  //might hold the next address that will be passed to\n-\t  //deallocated may have been invalidated due to the above\n-\t  //erase procedure being called on the vector, hence we try\n-\t  //to restore this invariant too.\n-\t  if (_S_last_dealloc_index >= _S_mem_blocks.size())\n-\t    {\n-\t      _S_last_dealloc_index =(__diff != -1 ? __diff : 0);\n-\t      assert(_S_last_dealloc_index >= 0);\n-\t    }\n-\t}\n-    }\n+    public:\n+      bitmap_allocator() throw()\n+      { }\n \n-  public:\n-    bitmap_allocator() throw()\n-    { }\n+      bitmap_allocator(const bitmap_allocator&)\n+      { }\n \n-    bitmap_allocator(const bitmap_allocator&) { }\n+      template<typename _Tp1>\n+        bitmap_allocator(const bitmap_allocator<_Tp1>&) throw()\n+        { }\n \n-    template <typename _Tp1> bitmap_allocator(const bitmap_allocator<_Tp1>&) throw()\n-    { }\n+      ~bitmap_allocator() throw()\n+      { }\n \n-    ~bitmap_allocator() throw()\n-    { }\n+      // Complexity: O(1), but internally the complexity depends upon the\n+      // complexity of the function(s) _S_allocate_single_object and\n+      // operator new.\n+      pointer \n+      allocate(size_type __n)\n+      {\n+\tif (__builtin_expect(__n == 1, true))\n+\t  return this->_M_allocate_single_object();\n+\telse\n+\t  { \n+\t    const size_type __b = __n * sizeof(value_type);\n+\t    return reinterpret_cast<pointer>(::operator new(__b));\n+\t  }\n+      }\n \n-    //Complexity: O(1), but internally the complexity depends upon the\n-    //complexity of the function(s) _S_allocate_single_object and\n-    //_S_memory_get.\n-    pointer allocate(size_type __n)\n-    {\n-      if (__builtin_expect(__n == 1, true))\n-\treturn _S_allocate_single_object();\n-      else\n-\treturn reinterpret_cast<pointer>(_S_memory_get(__n * sizeof(value_type)));\n-    }\n+      pointer \n+      allocate(size_type __n, typename bitmap_allocator<void>::const_pointer)\n+      { return allocate(__n); }\n \n-    //Complexity: Worst case complexity is O(N) where N is the number of\n-    //blocks of size sizeof(value_type) within the free lists that the\n-    //allocator holds. However, this worst case is hit only when the\n-    //user supplies a bogus argument to hint. If the hint argument is\n-    //sensible, then the complexity drops to O(lg(N)), and in extreme\n-    //cases, even drops to as low as O(1). So, if the user supplied\n-    //argument is good, then this function performs very well.\n-    pointer allocate(size_type __n, typename bitmap_allocator<void>::const_pointer)\n-    {\n-      return allocate(__n);\n-    }\n+      void \n+      deallocate(pointer __p, size_type __n) throw()\n+      {\n+\tif (__builtin_expect(__n == 1, true))\n+\t  this->_M_deallocate_single_object(__p);\n+\telse\n+\t  ::operator delete(__p);\n+      }\n \n-    void deallocate(pointer __p, size_type __n) throw()\n-    {\n-      if (__builtin_expect(__n == 1, true))\n-\t_S_deallocate_single_object(__p);\n-      else\n-\t_S_memory_put(__p);\n-    }\n+      pointer \n+      address(reference __r) const\n+      { return &__r; }\n \n-    pointer address(reference r) const { return &r; }\n-    const_pointer address(const_reference r) const { return &r; }\n+      const_pointer \n+      address(const_reference __r) const\n+      { return &__r; }\n \n-    size_type max_size(void) const throw() { return (size_type()-1)/sizeof(value_type); }\n+      size_type \n+      max_size() const throw()\n+      { return (size_type()-1)/sizeof(value_type); }\n \n-    void construct (pointer p, const_reference __data)\n-    {\n-      ::new(p) value_type(__data);\n-    }\n+      void \n+      construct(pointer __p, const_reference __data)\n+      { ::new(__p) value_type(__data); }\n \n-    void destroy (pointer p)\n-    {\n-      p->~value_type();\n-    }\n+      void \n+      destroy(pointer __p)\n+      { __p->~value_type(); }\n+    };\n \n-  };\n+  template<typename _Tp1, typename _Tp2>\n+    bool \n+    operator==(const bitmap_allocator<_Tp1>&, \n+\t       const bitmap_allocator<_Tp2>&) throw()\n+    { return true; }\n+  \n+  template<typename _Tp1, typename _Tp2>\n+    bool \n+    operator!=(const bitmap_allocator<_Tp1>&, \n+\t       const bitmap_allocator<_Tp2>&) throw() \n+  { return false; }\n \n-  template <typename _Tp>\n-  typename bitmap_allocator<_Tp>::_BPVector bitmap_allocator<_Tp>::_S_mem_blocks;\n+  // Static member definitions.\n+  template<typename _Tp>\n+    typename bitmap_allocator<_Tp>::_BPVector\n+    bitmap_allocator<_Tp>::_S_mem_blocks;\n \n-  template <typename _Tp>\n-  unsigned int bitmap_allocator<_Tp>::_S_block_size = bitmap_allocator<_Tp>::_Bits_Per_Block;\n+  template<typename _Tp>\n+    unsigned int bitmap_allocator<_Tp>::_S_block_size = balloc::bits_per_block;\n \n-  template <typename _Tp>\n-  typename __gnu_cxx::bitmap_allocator<_Tp>::_BPVector::size_type \n-  bitmap_allocator<_Tp>::_S_last_dealloc_index = 0;\n+  template<typename _Tp>\n+    typename __gnu_cxx::bitmap_allocator<_Tp>::_BPVector::size_type \n+    bitmap_allocator<_Tp>::_S_last_dealloc_index = 0;\n \n-  template <typename _Tp>\n-  __gnu_cxx::__aux_balloc::_Bit_map_counter \n-  <typename bitmap_allocator<_Tp>::pointer, typename bitmap_allocator<_Tp>::_BPVec_allocator_type> \n-  bitmap_allocator<_Tp>::_S_last_request(_S_mem_blocks);\n+  template<typename _Tp>\n+    __gnu_cxx::balloc::_Bitmap_counter \n+  <typename bitmap_allocator<_Tp>::_Alloc_block*>\n+    bitmap_allocator<_Tp>::_S_last_request(_S_mem_blocks);\n \n #if defined __GTHREADS\n-  template <typename _Tp>\n-  __gnu_cxx::_Mutex\n-  bitmap_allocator<_Tp>::_S_mut;\n+  template<typename _Tp>\n+    __gnu_cxx::_Mutex\n+    bitmap_allocator<_Tp>::_S_mut;\n #endif\n \n-  template <typename _Tp1, typename _Tp2>\n-  bool operator== (const bitmap_allocator<_Tp1>&, const bitmap_allocator<_Tp2>&) throw()\n-  {\n-    return true;\n-  }\n-  \n-  template <typename _Tp1, typename _Tp2>\n-  bool operator!= (const bitmap_allocator<_Tp1>&, const bitmap_allocator<_Tp2>&) throw()\n-  {\n-    return false;\n-  }\n+\n }\n \n+#endif \n \n-#endif //_BITMAP_ALLOCATOR_H\n+//  LocalWords:  namespace GTHREADS bool const gthread endif Mutex mutex"}, {"sha": "b2ca5f6201d4d1f204663b7f9037485ed17c3630", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=1399eca1907b6fe3a191c586211bcfcc46f47b4d", "patch": "@@ -96,6 +96,7 @@ basic_file.cc: ${glibcxx_srcdir}/$(BASIC_FILE_CC)\n \n # Sources present in the src directory.\n sources = \\\n+\tbitmap_allocator.cc \\\n \tpool_allocator.cc \\\n \tmt_allocator.cc \\\n \tcodecvt.cc \\"}, {"sha": "eb0b0c68f5a1402ca679abe8792c32fdee7760a7", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=1399eca1907b6fe3a191c586211bcfcc46f47b4d", "patch": "@@ -64,14 +64,14 @@ am__objects_1 = atomicity.lo codecvt_members.lo collate_members.lo \\\n \tctype_members.lo messages_members.lo monetary_members.lo \\\n \tnumeric_members.lo time_members.lo\n am__objects_2 = basic_file.lo c++locale.lo\n-am__objects_3 = pool_allocator.lo mt_allocator.lo codecvt.lo \\\n-\tcomplex_io.lo ctype.lo debug.lo debug_list.lo functexcept.lo \\\n-\tglobals_locale.lo globals_io.lo ios.lo ios_failure.lo \\\n-\tios_init.lo ios_locale.lo limits.lo list.lo locale.lo \\\n-\tlocale_init.lo locale_facets.lo localename.lo stdexcept.lo \\\n-\tstrstream.lo tree.lo allocator-inst.lo concept-inst.lo \\\n-\tfstream-inst.lo ext-inst.lo io-inst.lo istream-inst.lo \\\n-\tlocale-inst.lo locale-misc-inst.lo misc-inst.lo \\\n+am__objects_3 = bitmap_allocator.lo pool_allocator.lo mt_allocator.lo \\\n+\tcodecvt.lo complex_io.lo ctype.lo debug.lo debug_list.lo \\\n+\tfunctexcept.lo globals_locale.lo globals_io.lo ios.lo \\\n+\tios_failure.lo ios_init.lo ios_locale.lo limits.lo list.lo \\\n+\tlocale.lo locale_init.lo locale_facets.lo localename.lo \\\n+\tstdexcept.lo strstream.lo tree.lo allocator-inst.lo \\\n+\tconcept-inst.lo fstream-inst.lo ext-inst.lo io-inst.lo \\\n+\tistream-inst.lo locale-inst.lo locale-misc-inst.lo misc-inst.lo \\\n \tostream-inst.lo sstream-inst.lo streambuf-inst.lo \\\n \tstring-inst.lo valarray-inst.lo wlocale-inst.lo \\\n \twstring-inst.lo $(am__objects_1) $(am__objects_2)\n@@ -306,6 +306,7 @@ host_sources_extra = \\\n \n # Sources present in the src directory.\n sources = \\\n+\tbitmap_allocator.cc \\\n \tpool_allocator.cc \\\n \tmt_allocator.cc \\\n \tcodecvt.cc \\"}, {"sha": "f37c5dca28b63736b0b6df95766d2bf9f44902c2", "filename": "libstdc++-v3/src/bitmap_allocator.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1399eca1907b6fe3a191c586211bcfcc46f47b4d/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc?ref=1399eca1907b6fe3a191c586211bcfcc46f47b4d", "patch": "@@ -0,0 +1,133 @@\n+// Bitmap Allocator. Out of line function definitions. -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <ext/bitmap_allocator.h>\n+\n+namespace __gnu_cxx\n+{\n+  namespace balloc\n+  {\n+    template class __mini_vector<std::pair\n+    <bitmap_allocator<char>::_Alloc_block*, \n+     bitmap_allocator<char>::_Alloc_block*> >;\n+\n+    template class __mini_vector<std::pair\n+    <bitmap_allocator<wchar_t>::_Alloc_block*, \n+     bitmap_allocator<wchar_t>::_Alloc_block*> >;\n+\n+    template class __mini_vector<unsigned int*>;\n+\n+    template unsigned int** __lower_bound\n+    (unsigned int**, unsigned int**, \n+     unsigned int const&, free_list::_LT_pointer_compare);\n+  }\n+\n+#if defined __GTHREADS\n+  _Mutex free_list::_S_bfl_mutex;\n+#endif\n+  free_list::vector_type free_list::_S_free_list;\n+\n+  unsigned int*\n+  free_list::\n+  _M_get(unsigned int __sz) throw(std::bad_alloc)\n+  {\n+#if defined __GTHREADS\n+    _Lock __bfl_lock(&_S_bfl_mutex);\n+    __bfl_lock._M_lock();\n+#endif\n+    iterator __temp = \n+      __gnu_cxx::balloc::__lower_bound\n+      (_S_free_list.begin(), _S_free_list.end(), \n+       __sz, _LT_pointer_compare());\n+\n+    if (__temp == _S_free_list.end() || !_M_should_i_give(**__temp, __sz))\n+      {\n+\t// We release the lock here, because operator new is\n+\t// guaranteed to be thread-safe by the underlying\n+\t// implementation.\n+#if defined __GTHREADS\n+\t__bfl_lock._M_unlock();\n+#endif\n+\t// Try twice to get the memory: once directly, and the 2nd\n+\t// time after clearing the free list. If both fail, then\n+\t// throw std::bad_alloc().\n+\tunsigned int __ctr = 2;\n+\twhile (__ctr)\n+\t  {\n+\t    unsigned int* __ret = 0;\n+\t    --__ctr;\n+\t    try\n+\t      {\n+\t\t__ret = reinterpret_cast<unsigned int*>\n+\t\t  (::operator new(__sz + sizeof(unsigned int)));\n+\t      }\n+\t    catch(...)\n+\t      {\n+\t\tthis->_M_clear();\n+\t      }\n+\t    if (!__ret)\n+\t      continue;\n+\t    *__ret = __sz;\n+\t    return reinterpret_cast<unsigned int*>\n+\t      (reinterpret_cast<char*>(__ret) + sizeof(unsigned int));\n+\t  }\n+\tthrow std::bad_alloc();\n+      }\n+    else\n+      {\n+\tunsigned int* __ret = *__temp;\n+\t_S_free_list.erase(__temp);\n+#if defined __GTHREADS\n+\t__bfl_lock._M_unlock();\n+#endif\n+\treturn reinterpret_cast<unsigned int*>\n+\t  (reinterpret_cast<char*>(__ret) + sizeof(unsigned int));\n+      }\n+  }\n+\n+  void \n+  free_list::\n+  _M_clear()\n+  {\n+#if defined __GTHREADS\n+    _Auto_Lock __bfl_lock(&_S_bfl_mutex);\n+#endif\n+    iterator __iter = _S_free_list.begin();\n+    while (__iter != _S_free_list.end())\n+      {\n+\toperator delete((void*)*__iter);\n+\t++__iter;\n+      }\n+    _S_free_list.clear();\n+  }\n+\n+  // Instantiations.\n+  template class bitmap_allocator<char>;\n+  template class bitmap_allocator<wchar_t>;\n+} // namespace __gnu_cxx"}]}