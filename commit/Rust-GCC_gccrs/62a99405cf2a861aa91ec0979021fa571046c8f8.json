{"sha": "62a99405cf2a861aa91ec0979021fa571046c8f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJhOTk0MDVjZjJhODYxYWE5MWVjMDk3OTAyMWZhNTcxMDQ2YzhmOA==", "commit": {"author": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2000-08-04T14:16:57Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2000-08-04T14:16:57Z"}, "message": "Implement, but leave disabled, MSDOS functionality\n\nFrom-SVN: r35479", "tree": {"sha": "1fd7f6c98ea1e81d067d68a49ff93779db1b0d34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fd7f6c98ea1e81d067d68a49ff93779db1b0d34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62a99405cf2a861aa91ec0979021fa571046c8f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a99405cf2a861aa91ec0979021fa571046c8f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62a99405cf2a861aa91ec0979021fa571046c8f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a99405cf2a861aa91ec0979021fa571046c8f8/comments", "author": null, "committer": null, "parents": [{"sha": "d677797245ad1aae20e79912bead56d9103a28c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d677797245ad1aae20e79912bead56d9103a28c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d677797245ad1aae20e79912bead56d9103a28c5"}], "stats": {"total": 594, "additions": 498, "deletions": 96}, "files": [{"sha": "2a7689cbff30cf8f662d14114131ccb20a6565c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62a99405cf2a861aa91ec0979021fa571046c8f8", "patch": "@@ -1,3 +1,55 @@\n+2000-08-04  Bruce Korb  <bkorb@gnu.org>\n+\n+\t* fixinc/:  Verified that the MSDOS patch does not break\n+\tthe UNIX functionality and applied the next three patches\n+\tfrom July:\n+\n+2000-07-28  Eli Zaretskii  <eliz@is.elta.co.il>\n+\n+\t* fixinc/fixfixes.c (main) [__MSDOS__]: Avoid overwriting the\n+\toutput file with the temporary one by appending \".X\" to generate\n+\tthe temporary fuile's name.  If the output file already has an\n+\textension, replace it with \".X\".\n+\n+\t* fixinc/fixincl.c (fix_with_system) [__MSDOS__]: Use $ORIGDIR,\n+\tnot $DESTDIR, to find applyfix.  Use sprintf instead of snprintf;\n+\treallocate the command buffer while copying the command-line\n+\targument.  Redirect the output directly to the temporary file,\n+\tinstead of going through another temporary file.\n+\t(process): Close the temporary file before unlinking it.\n+\t(machine_matches) [__MSDOS__]: If the machine doesn't match, set\n+\tthe FD_SKIP_TEST flag.  Pay attention to the FD_MACH_IFNOT flag.\n+\t(run_compiles): Pass p_fixd argument to machine_matches, as it\n+\texpects.\n+\n+\t* fixinc/fixincl.sh: Export ORIGDIR.  If $DJDIR is set in the\n+\tenvironment, assume there are no symlinks in the include\n+\tdirectory.  When cleaning up the DONE files, look for them\n+\tcase-insensitively.  Don't try to remove symlinks if they aren't\n+\tthere.\n+\n+\t* fixinc/fixlib.c (make_raw_shell_str): Accept new argument smax;\n+\tall callers changed.  Declare pz \"const char *\", to avoid compiler\n+\twarnings.\n+\n+\t* fixinc/fixlib.h (ENV_TABLE): Get ORIGDIR from the environment.\n+\tChange prototype of make_raw_shell_str.\n+\n+2000-07-27  Eli Zaretskii  <eliz@is.elta.co.il>\n+\n+\t* fixinc/fixincl.c [__MSDOS__]: Don't include \"server.h\".\n+\t(initialize) [__MSDOS__]: Use tempnam.\n+\t(initialize): Don't use SIGPIPE if it is not defined.\n+\n+\t* fixinc/fixfixes.c (main) [__MSDOS__]: freopen for stdout should\n+\treturn stdout.\n+\n+2000-07-25  Bruce Korb  <bkorb@gnu.org>\n+\n+\t* fixinc/fix*.[ch]: substantially reworked to make it possible\n+\tto run this program without using fork(2) or pipe(2) (i.e. in\n+\ta DOS environment).\n+\n 2000-08-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* cppdefault.h (WINT_TYPE): Define."}, {"sha": "89c46ab522c30c59119d69ab560805ab0143ceba", "filename": "gcc/fixinc/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2FREADME?ref=62a99405cf2a861aa91ec0979021fa571046c8f8", "patch": "@@ -67,7 +67,7 @@ Here are the rules for making fixes in the inclhack.def file:\n     It is nice if:\n \n     3.  The expression is as simple as possible to both\n-        process and uderstand by people.  :-)\n+        process and understand by people.  :-)\n \n         Please take advantage of the fact AutoGen will glue\n         together string fragments.  It helps.  Also take note"}, {"sha": "de4151108635d9c256be834ac65adde2b0c27b4d", "filename": "gcc/fixinc/check.tpl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Fcheck.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Fcheck.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fcheck.tpl?ref=62a99405cf2a861aa91ec0979021fa571046c8f8", "patch": "@@ -19,8 +19,9 @@ SRCDIR=`pwd`/inc\n FIND_BASE='.'\n VERBOSE=1\n INPUT=`pwd`\n+ORIGDIR=${INPUT}\n \n-export TARGET_MACHINE DESTDIR SRCDIR FIND_BASE VERBOSE INPUT\n+export TARGET_MACHINE DESTDIR SRCDIR FIND_BASE VERBOSE INPUT ORIGDIR\n \n rm -rf ${DESTDIR} ${SRCDIR}\n mkdir ${DESTDIR} ${SRCDIR}"}, {"sha": "4cb3e5874d6f1c2806e7026c7634e6c2dbf09298", "filename": "gcc/fixinc/fixfixes.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixfixes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixfixes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixfixes.c?ref=62a99405cf2a861aa91ec0979021fa571046c8f8", "patch": "@@ -60,6 +60,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"fixlib.h\"\n #define    GTYPE_SE_CT 1\n \n+#ifdef __MSDOS__\n+#include \"fixincl.x\"\n+#endif\n+\n tSCC zNeedsArg[] = \"fixincl error:  `%s' needs %s argument (c_fix_arg[%d])\\n\";\n \n typedef struct {\n@@ -725,3 +729,79 @@ apply_fix( p_fixd, filname )\n   buf = load_file_data (stdin);\n   (*pfe->fix_proc)( filname, buf, p_fixd );\n }\n+\n+#ifdef __MSDOS__\n+tSCC z_usage[] =\n+\"USAGE: applyfix <fix-name> <file-to-fix> <file-source> <file-destination>\\n\";\n+tSCC z_reopen[] =\n+\"FS error %d (%s) reopening %s as std%s\\n\";\n+\n+int\n+main( argc, argv )\n+  int     argc;\n+  char**  argv;\n+{\n+  tFixDesc* pFix;\n+  char* pz_tmptmp;\n+  char* pz_tmp_base;\n+  char* pz_tmp_dot;\n+\n+  if (argc != 5)\n+    {\n+    usage_failure:\n+      fputs( z_usage, stderr );\n+      return EXIT_FAILURE;\n+    }\n+\n+  {\n+    char* pz = argv[1];\n+    long  idx;\n+\n+    if (! isdigit( *pz ))\n+      goto usage_failure;\n+\n+    idx = strtol( pz, &pz, 10 );\n+    if ((*pz != NUL) || ((unsigned)idx >= FIX_COUNT))\n+      goto usage_failure;\n+    pFix = fixDescList + idx;\n+  }\n+\n+  if (freopen( argv[3], \"r\", stdin ) != stdin)\n+    {\n+      fprintf( stderr, z_reopen, errno, strerror( errno ), argv[3], \"in\" );\n+      return EXIT_FAILURE;\n+    }\n+\n+  pz_tmptmp = (char*)xmalloc( strlen( argv[4] ) + 5 );\n+  strcpy( pz_tmptmp, argv[4] );\n+\n+  /* Don't lose because \"12345678\" and \"12345678X\" map to the same\n+     file under DOS restricted 8+3 file namespace.  Note that DOS\n+     doesn't allow more than one dot in the trunk of a file name.  */\n+  pz_tmp_base = basename( pz_tmptmp );\n+  pz_tmp_dot = strchr( pz_tmp_base, '.' );\n+  if (pathconf( pz_tmptmp, _PC_NAME_MAX ) <= 12\t/* is this DOS or Windows9X? */\n+      && pz_tmp_dot != (char*)NULL)\n+    strcpy( pz_tmp_dot+1, \"X\" ); /* nuke the original extension */\n+  else\n+    strcat( pz_tmptmp, \".X\" );\n+  if (freopen( pz_tmptmp, \"w\", stdout ) != stdout)\n+    {\n+      fprintf( stderr, z_reopen, errno, strerror( errno ), pz_tmptmp, \"out\" );\n+      return EXIT_FAILURE;\n+    }\n+\n+  apply_fix( pFix, argv[1] );\n+  close( STDOUT_FILENO );\n+  close( STDIN_FILENO );\n+  unlink( argv[4] );\n+  if (rename( pz_tmptmp, argv[4] ) != 0)\n+    {\n+      fprintf( stderr, \"error %d (%s) renaming %s to %s\\n\", errno,\n+               strerror( errno ), pz_tmptmp, argv[4] );\n+      return EXIT_FAILURE;\n+    }\n+\n+  return EXIT_SUCCESS;\n+}\n+#endif"}, {"sha": "3b13d7046e204d7fca4a638992ca24e7faf111c7", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 277, "deletions": 79, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=62a99405cf2a861aa91ec0979021fa571046c8f8", "patch": "@@ -30,8 +30,9 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n #include <signal.h>\n-\n+#ifndef __MSDOS__\n #include \"server.h\"\n+#endif\n \n /*  The contents of this string are not very important.  It is mostly\n     just used as part of the \"I am alive and working\" test.  */\n@@ -74,6 +75,8 @@ pid_t process_chain_head = (pid_t) -1;\n \n char*  pz_curr_file;  /*  name of the current file under test/fix  */\n char*  pz_curr_data;  /*  original contents of that file  */\n+char*  pz_temp_file;  /*  for DOS, a place to stash the temporary\n+                          fixed data between system(3) calls  */\n t_bool curr_data_mapped;\n int    data_map_fd;\n size_t data_map_size;\n@@ -178,6 +181,10 @@ Altering  %5d of them\\n\";\n              fixed_ct, altered_ct);\n   }\n #endif /* DO_STATS */\n+\n+# ifdef __MSDOS__\n+  unlink( pz_temp_file );\n+# endif\n   return EXIT_SUCCESS;\n }\n \n@@ -195,8 +202,12 @@ do_version ()\n   */\n   run_compiles ();\n   sprintf (zBuf, zFmt, program_id);\n+#ifndef __MSDOS__\n   puts (zBuf + 5);\n   exit (strcmp (run_shell (zBuf), program_id));\n+#else\n+  exit (system (zBuf));\n+#endif\n }\n \n /* * * * * * * * * * * * */\n@@ -287,11 +298,19 @@ ENV_TABLE\n       */\n   run_compiles ();\n \n+# ifdef __MSDOS__\n+  /* NULL as the first argument to `tempnam' causes it to DTRT\n+     wrt the temporary directory where the file will be created.  */\n+  pz_temp_file = tempnam( NULL, \"fxinc\" );\n+# endif\n+\n   signal (SIGQUIT, SIG_IGN);\n #ifdef SIGIOT\n   signal (SIGIOT,  SIG_IGN);\n #endif\n+#ifdef SIGPIPE\n   signal (SIGPIPE, SIG_IGN);\n+#endif\n   signal (SIGALRM, SIG_IGN);\n   signal (SIGTERM, SIG_IGN);\n }\n@@ -348,54 +367,11 @@ load_file ( fname )\n   return res;\n }\n \n-\n-/* * * * * * * * * * * * *\n-\n-   run_compiles   run all the regexp compiles for all the fixes once.\n- */\n-void\n-run_compiles ()\n-{\n-  tFixDesc *p_fixd = fixDescList;\n-  int fix_ct = FIX_COUNT;\n-  tTestDesc *p_test;\n-  int test_ct;\n-  const char *pz_err;\n-  regex_t *p_re = (regex_t *) malloc (REGEX_COUNT * sizeof (regex_t));\n-\n-  if (p_re == (regex_t *) NULL)\n-    {\n-      fprintf (stderr, \"fixincl ERROR:  cannot allocate %d bytes for regex\\n\",\n-               REGEX_COUNT * sizeof (regex_t));\n-      exit (EXIT_FAILURE);\n-    }\n-\n-  /*  Make sure compile_re does not stumble across invalid data */\n-\n-  memset ( (void*)p_re, '\\0', REGEX_COUNT * sizeof (regex_t) );\n-  memset ( (void*)&incl_quote_re, '\\0', sizeof (regex_t) );\n-\n-  compile_re (incl_quote_pat, &incl_quote_re, 1,\n-              \"quoted include\", \"run_compiles\");\n-\n-  /*  Allow machine name tests to be ignored (testing, mainly) */\n-\n-  if (pz_machine && ((*pz_machine == '\\0') || (*pz_machine == '*')))\n-    pz_machine = (char*)NULL;\n-\n-  /* FOR every fixup, ...  */\n-  do\n-    {\n-      p_test = p_fixd->p_test_desc;\n-      test_ct = p_fixd->test_ct;\n-\n-      /*  IF the machine type pointer is not NULL (we are not in test mode)\n-             AND this test is for or not done on particular machines\n-          THEN ...   */\n-\n-      if (  (pz_machine != NULL)\n-         && (p_fixd->papz_machs != (const char**) NULL) )\n+int\n+machine_matches( p_fixd )\n+  tFixDesc *p_fixd;\n         {\n+# ifndef __MSDOS__\n           tSCC case_fmt[] = \"case %s in\\n\";     /*  9 bytes, plus string */\n           tSCC esac_fmt[] =\n                \" )\\n    echo %s ;;\\n* ) echo %s ;;\\nesac\";/*  4 bytes */\n@@ -457,10 +433,74 @@ run_compiles ()\n             if (skip)\n               {\n                 p_fixd->fd_flags |= FD_SKIP_TEST;\n-                continue;\n-              }\n-           }\n-        }\n+\t\treturn BOOL_FALSE;\n+\t      }\n+\t  }\n+\n+  return BOOL_TRUE;\n+# else /* is __MSDOS__ */\n+  const char **papz_machs = p_fixd->papz_machs;\n+  int invert = (p_fixd->fd_flags & FD_MACH_IFNOT) != 0;\n+  for (;;)\n+    {\n+      const char* pz_mach = *(papz_machs++);\n+\n+      if (pz_mach == (const char*) NULL)\n+        break;\n+      if (strstr (pz_mach, \"dos\") != NULL && !invert)\n+\treturn BOOL_TRUE;\n+    }\n+\n+  p_fixd->fd_flags |= FD_SKIP_TEST;\n+  return BOOL_FALSE;\n+# endif\n+}\n+\n+/* * * * * * * * * * * * *\n+\n+   run_compiles   run all the regexp compiles for all the fixes once.\n+   */\n+void\n+run_compiles ()\n+{\n+  tFixDesc *p_fixd = fixDescList;\n+  int fix_ct = FIX_COUNT;\n+  regex_t *p_re = (regex_t *) malloc (REGEX_COUNT * sizeof (regex_t));\n+\n+  if (p_re == (regex_t *) NULL)\n+    {\n+      fprintf (stderr, \"fixincl ERROR:  cannot allocate %d bytes for regex\\n\",\n+               REGEX_COUNT * sizeof (regex_t));\n+      exit (EXIT_FAILURE);\n+    }\n+\n+  /*  Make sure compile_re does not stumble across invalid data */\n+\n+  memset ( (void*)p_re, '\\0', REGEX_COUNT * sizeof (regex_t) );\n+  memset ( (void*)&incl_quote_re, '\\0', sizeof (regex_t) );\n+\n+  compile_re (incl_quote_pat, &incl_quote_re, 1,\n+              \"quoted include\", \"run_compiles\");\n+\n+  /*  Allow machine name tests to be ignored (testing, mainly) */\n+\n+  if (pz_machine && ((*pz_machine == '\\0') || (*pz_machine == '*')))\n+    pz_machine = (char*)NULL;\n+\n+  /* FOR every fixup, ...  */\n+  do\n+    {\n+      tTestDesc *p_test = p_fixd->p_test_desc;\n+      int test_ct = p_fixd->test_ct;\n+\n+      /*  IF the machine type pointer is not NULL (we are not in test mode)\n+             AND this test is for or not done on particular machines\n+          THEN ...   */\n+\n+      if (  (pz_machine != NULL)\n+         && (p_fixd->papz_machs != (const char**) NULL)\n+         && ! machine_matches (p_fixd) )\n+        continue;\n \n       /* FOR every test for the fixup, ...  */\n \n@@ -470,17 +510,6 @@ run_compiles ()\n             {\n             case TT_EGREP:\n             case TT_NEGREP:\n-#ifdef DEBUG\n-              {\n-                static int re_ct = REGEX_COUNT;\n-\n-                if (--re_ct < 0)\n-                  {\n-                    fputs (\"out of RE's\\n\", stderr);\n-                    exit (EXIT_FAILURE);\n-                  }\n-              }\n-#endif\n               p_test->p_test_regex = p_re++;\n               compile_re (p_test->pz_test_text, p_test->p_test_regex, 0,\n                           \"select test\", p_fixd->fix_name);\n@@ -578,7 +607,7 @@ create_file ()\n           the name of the file that we might want to fix\n   Result: APPLY_FIX or SKIP_FIX, depending on the result of the\n           shell script we run.  */\n-\n+#ifndef __MSDOS__\n int\n test_test (p_test, pz_test_file)\n      tTestDesc *p_test;\n@@ -616,7 +645,13 @@ fi\";\n   free ((void *) pz_res);\n   return res;\n }\n-\n+#else\n+/*\n+ *  IF we are in MS-DOS land, then whatever shell-type test is required\n+ *  will, by definition, fail\n+ */\n+#define test_test(t,tf)  SKIP_FIX\n+#endif\n \n /* * * * * * * * * * * * *\n \n@@ -728,7 +763,7 @@ extract_quoted_files (pz_data, pz_fixed_file, p_re_match)\n       /*  Skip forward to the included file name */\n       while (ISSPACE (*pz_incl_quot))\n         pz_incl_quot++;\n-      /* ISSPACE() may evaluate is argument more than once!  */\n+      /* ISSPACE() may evaluate its argument more than once!  */\n       while (++pz_incl_quot, ISSPACE (*pz_incl_quot))\n         ;\n       pz_incl_quot += sizeof (\"include\") - 1;\n@@ -767,7 +802,7 @@ extract_quoted_files (pz_data, pz_fixed_file, p_re_match)\n \n     Somebody wrote a *_fix subroutine that we must call.\n     */\n-\n+#ifndef __MSDOS__\n int\n internal_fix (read_fd, p_fixd)\n   int read_fd;\n@@ -833,7 +868,135 @@ internal_fix (read_fd, p_fixd)\n   apply_fix (p_fixd, pz_curr_file);\n   exit (0);\n }\n+#endif /* !__MSDOS__ */\n+\n+\n+#ifdef __MSDOS__\n+static void\n+fix_with_system (p_fixd, pz_fix_file, pz_file_source, pz_temp_file)\n+  tFixDesc* p_fixd;\n+  tCC* pz_fix_file;\n+  tCC* pz_file_source;\n+  tCC* pz_temp_file;\n+{\n+  char*  pz_cmd;\n+  char*  pz_scan;\n+  size_t argsize;\n+\n+  if (p_fixd->fd_flags & FD_SUBROUTINE)\n+    {\n+      tSCC z_applyfix_prog[] = \"/fixinc/applyfix\";\n+\n+      argsize = 32\n+              + strlen( pz_orig_dir )\n+              + sizeof( z_applyfix_prog )\n+              + strlen( pz_fix_file )\n+              + strlen( pz_file_source )\n+              + strlen( pz_temp_file );\n+\n+      pz_cmd = (char*)xmalloc( argsize );\n \n+      strcpy( pz_cmd, pz_orig_dir );\n+      pz_scan = pz_cmd + strlen( pz_orig_dir );\n+      strcpy( pz_scan, z_applyfix_prog );\n+      pz_scan += sizeof( z_applyfix_prog ) - 1;\n+      *(pz_scan++) = ' ';\n+\n+      /*\n+       *  Now add the fix number and file names that may be needed\n+       */\n+      sprintf (pz_scan, \"%ld %s %s %s\", p_fixd - fixDescList,\n+\t       pz_fix_file, pz_file_source, pz_temp_file);\n+    }\n+  else /* NOT an \"internal\" fix: */\n+    {\n+      size_t parg_size;\n+      /* Don't use the \"src > dstX; rm -f dst; mv -f dstX dst\" trick:\n+\t dst is a temporary file anyway, so we know there's no other\n+\t file by that name; and DOS's system(3) doesn't mind to\n+\t clobber existing file in redirection.  Besides, with DOS 8+3\n+\t limited file namespace, we can easily lose if dst already has\n+\t an extension that is 3 or more characters long.  */\n+      tSCC   z_cmd_fmt[] = \" %s > %s\";\n+      tCC**  ppArgs = p_fixd->patch_args;\n+\n+      argsize = sizeof( z_cmd_fmt ) + strlen( pz_temp_file )\n+              + strlen( pz_file_source );\n+      parg_size = argsize;\n+      \n+\n+      /*\n+       *  Compute the size of the command line.  Add lotsa extra space\n+       *  because some of the args to sed use lotsa single quotes.\n+       *  (This requires three extra bytes per quote.  Here we allow\n+       *  for up to 8 single quotes for each argument, including the\n+       *  command name \"sed\" itself.  Nobody will *ever* need more. :)\n+       */\n+      for (;;)\n+        {\n+          tCC* p_arg = *(ppArgs++);\n+          if (p_arg == NULL)\n+            break;\n+          argsize += 24 + strlen( p_arg );\n+        }\n+\n+      /* Estimated buffer size we will need.  */\n+      pz_scan = pz_cmd = (char*)xmalloc( argsize );\n+      /* How much of it do we allot to the program name and its\n+         arguments.  */\n+      parg_size = argsize - parg_size;\n+\n+      ppArgs = p_fixd->patch_args;\n+\n+      /*\n+       *  Copy the program name, unquoted\n+       */\n+      {\n+        tCC*   pArg = *(ppArgs++);\n+        for (;;)\n+          {\n+            char ch = *(pArg++);\n+            if (ch == NUL)\n+              break;\n+            *(pz_scan++) = ch;\n+          }\n+      }\n+\n+      /*\n+       *  Copy the program arguments, quoted\n+       */\n+      for (;;)\n+        {\n+          tCC*   pArg = *(ppArgs++);\n+\t  char*  pz_scan_save;\n+          if (pArg == NULL)\n+            break;\n+          *(pz_scan++) = ' ';\n+          pz_scan = make_raw_shell_str( pz_scan_save = pz_scan, pArg,\n+\t\t\t\t\tparg_size - (pz_scan - pz_cmd) );\n+\t  /*\n+\t   *  Make sure we don't overflow the buffer due to sloppy\n+\t   *  size estimation.\n+\t   */\n+\t  while (pz_scan == (char*)NULL)\n+\t    {\n+\t      size_t already_filled = pz_scan_save - pz_cmd;\n+\t      pz_cmd = (char*)xrealloc( pz_cmd, argsize += 100 );\n+\t      pz_scan_save = pz_scan = pz_cmd + already_filled;\n+\t      parg_size += 100;\n+\t      pz_scan = make_raw_shell_str( pz_scan, pArg,\n+\t\t\t\t\t    parg_size - (pz_scan - pz_cmd) );\n+\t    }\n+        }\n+\n+      /*\n+       *  add the file machinations.\n+       */\n+      sprintf( pz_scan, z_cmd_fmt, pz_file_source, pz_temp_file );\n+    }\n+  system( pz_cmd );\n+  free( (void*)pz_cmd );\n+}\n \n /* * * * * * * * * * * * *\n \n@@ -842,6 +1005,7 @@ internal_fix (read_fd, p_fixd)\n     its stdin and returns the new fd this process will use\n     for stdout.  */\n \n+#else /* is *NOT* __MSDOS__ */\n int\n start_fixer (read_fd, p_fixd, pz_fix_file)\n   int read_fd;\n@@ -912,6 +1076,7 @@ start_fixer (read_fd, p_fixd, pz_fix_file)\n \n   return read_fd;\n }\n+#endif\n \n \n /* * * * * * * * * * * * *\n@@ -924,17 +1089,23 @@ t_bool\n fix_applies (p_fixd)\n   tFixDesc *p_fixd;\n {\n-#ifdef DEBUG\n-  static const char z_failed[] = \"not applying %s %s to %s - \\\n-test %d failed\\n\";\n-#endif\n   const char *pz_fname = pz_curr_file;\n   const char *pz_scan = p_fixd->file_list;\n   int test_ct;\n   tTestDesc *p_test;\n \n+# ifdef __MSDOS__\n+  /*\n+   *  There is only one fix that uses a shell script as of this writing.\n+   *  I hope to nuke it anyway, it does not apply to DOS and it would\n+   *  be painful to implement.  Therefore, no \"shell\" fixes for DOS.\n+   */\n+  if (p_fixd->fd_flags & (FD_SHELL_SCRIPT | FD_SKIP_TEST))\n+    return BOOL_FALSE;\n+# else\n   if (p_fixd->fd_flags & FD_SKIP_TEST)\n     return BOOL_FALSE;\n+# endif\n \n   /*  IF there is a file name restriction,\n       THEN ensure the current file name matches one in the pattern  */\n@@ -952,14 +1123,8 @@ test %d failed\\n\";\n           pz_scan = strstr (pz_scan + 1, pz_fname);\n           /*  IF we can't match the string at all,\n               THEN bail  */\n-          if (pz_scan == (char *) NULL) {\n-#ifdef DEBUG\n-            if (VLEVEL( VERB_EVERYTHING ))\n-              fprintf (stderr, \"file %s not in list for %s\\n\",\n-                       pz_fname, p_fixd->fix_name );\n-#endif\n+          if (pz_scan == (char *) NULL)\n             return BOOL_FALSE;\n-          }\n \n           /*  IF the match is surrounded by the '|' markers,\n               THEN we found a full match -- time to run the tests  */\n@@ -1133,11 +1298,14 @@ test_for_changes (read_fd)\n void\n process ()\n {\n-  static char env_current_file[1024];\n   tFixDesc *p_fixd = fixDescList;\n   int todo_ct = FIX_COUNT;\n   int read_fd = -1;\n+# ifndef __MSDOS__\n   int num_children = 0;\n+# else /* is __MSDOS__ */\n+  char* pz_file_source = pz_curr_file;\n+# endif\n \n   if (access (pz_curr_file, R_OK) != 0)\n     {\n@@ -1158,6 +1326,7 @@ process ()\n   if (VLEVEL( VERB_PROGRESS ) && have_tty)\n     fprintf (stderr, \"%6d %-50s   \\r\", data_map_size, pz_curr_file );\n \n+# ifndef __MSDOS__\n   process_chain_head = NOPROCESS;\n \n   /* For every fix in our fix list, ...  */\n@@ -1218,5 +1387,34 @@ process ()\n       } while (--num_children > 0);\n     }\n \n+# else /* is __MSDOS__ */\n+\n+  for (; todo_ct > 0; p_fixd++, todo_ct--)\n+    {\n+      if (! fix_applies (p_fixd))\n+        continue;\n+\n+      if (VLEVEL( VERB_APPLIES ))\n+        fprintf (stderr, \"Applying %-24s to %s\\n\",\n+                 p_fixd->fix_name, pz_curr_file);\n+\n+      if (p_fixd->fd_flags & FD_REPLACEMENT)\n+        {\n+          write_replacement (p_fixd);\n+          UNLOAD_DATA();\n+          return;\n+        }\n+      fix_with_system (p_fixd, pz_curr_file, pz_file_source, pz_temp_file);\n+      pz_file_source = pz_temp_file;\n+    }\n+\n+  read_fd = open( pz_temp_file, O_RDONLY );\n+  test_for_changes( read_fd );\n+  /* Unlinking a file while it is still open is a Bad Idea on\n+     DOS/Windows.  */\n+  close( read_fd );\n+  unlink( pz_temp_file );\n+\n+# endif\n   UNLOAD_DATA();\n }"}, {"sha": "9a44cb8cc6815a52f75d1166f3c781c464c4563f", "filename": "gcc/fixinc/fixincl.sh", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixincl.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixincl.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.sh?ref=62a99405cf2a861aa91ec0979021fa571046c8f8", "patch": "@@ -95,6 +95,7 @@ esac\n \n # Original directory.\n ORIGDIR=`${PWDCMD}`\n+export ORIGDIR\n FIXINCL=${ORIGDIR}/fixinc/fixincl\n export FIXINCL\n \n@@ -111,7 +112,9 @@ if test $VERBOSE -gt 0\n then echo Fixing headers into ${LIB} for ${target_canonical} target ; fi\n \n # Determine whether this system has symbolic links.\n-if ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n+if test -n \"$DJDIR\"; then\n+  LINKS=false\n+elif ln -s X $LIB/ShouldNotExist 2>/dev/null; then\n   rm -f $LIB/ShouldNotExist\n   LINKS=true\n elif ln -s X /tmp/ShouldNotExist 2>/dev/null; then\n@@ -422,7 +425,9 @@ done\n if test $VERBOSE -gt 2\n then echo 'Cleaning up DONE files.' ; fi\n cd $LIB\n-find . -name DONE -exec rm -f '{}' ';'\n+# Look for files case-insensitively, for the benefit of\n+# DOS/Windows filesystems.\n+find . -name '[Dd][Oo][Nn][Ee]' -exec rm -f '{}' ';'\n \n if test $VERBOSE -gt 1\n then echo 'Cleaning up unneeded directories:' ; fi\n@@ -435,20 +440,25 @@ for file in $all_dirs; do\n   fi\n done 2> /dev/null\n \n-test $VERBOSE -gt 2 && echo \"Removing unused symlinks\"\n+# On systems which don't support symlinks, `find' may barf\n+# if called with \"-type l\" predicate.  So only use that if\n+# we know we should look for symlinks.\n+if $LINKS; then\n+  test $VERBOSE -gt 2 && echo \"Removing unused symlinks\"\n \n-all_dirs=`find . -type l -print`\n-for file in $all_dirs\n-do\n-  if ls -lLd $file > /dev/null\n-  then :\n-  else rm -f $file\n-       test $VERBOSE -gt 3 && echo \"  removed $file\"\n-       rmdir `dirname $file` > /dev/null && \\\n-         test $VERBOSE -gt 3 && \\\n-         echo \"  removed `dirname $file`\"\n-  fi\n-done 2> /dev/null\n+  all_dirs=`find . -type l -print`\n+  for file in $all_dirs\n+  do\n+    if ls -lLd $file > /dev/null\n+    then :\n+    else rm -f $file\n+         test $VERBOSE -gt 3 && echo \"  removed $file\"\n+         rmdir `dirname $file` > /dev/null && \\\n+           test $VERBOSE -gt 3 && \\\n+           echo \"  removed `dirname $file`\"\n+    fi\n+  done 2> /dev/null\n+fi\n \n if test $VERBOSE -gt 0\n then echo fixincludes is done ; fi"}, {"sha": "1b134eeb28205cb7289b76a3e714db2e94d675bb", "filename": "gcc/fixinc/fixlib.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixlib.c?ref=62a99405cf2a861aa91ec0979021fa571046c8f8", "patch": "@@ -245,3 +245,57 @@ mn_get_regexps( label_re, name_re, who )\n   *name_re = &mn_name_re;\n }\n #endif\n+\n+\n+#ifdef __MSDOS__\n+\n+char*\n+make_raw_shell_str( pz_d, pz_s, smax )\n+  char*       pz_d;\n+  tCC*        pz_s;\n+  size_t      smax;\n+{\n+  tSCC zQ[] = \"'\\\\''\";\n+  size_t     dtaSize;\n+  char*      pz_d_start = pz_d;\n+\n+  smax--; /* adjust for trailing NUL */\n+\n+  dtaSize = strlen( pz_s ) + 3;\n+\n+  {\n+    const char* pz = pz_s - 1;\n+\n+    for (;;) {\n+      pz = strchr( pz+1, '\\'' );\n+      if (pz == (char*)NULL)\n+        break;\n+      dtaSize += sizeof( zQ )-1;\n+    }\n+  }\n+  if (dtaSize > smax)\n+    return (char*)NULL;\n+\n+  *(pz_d++) = '\\'';\n+\n+  for (;;) {\n+    if (pz_d - pz_d_start >= smax)\n+      return (char*)NULL;\n+    switch (*(pz_d++) = *(pz_s++)) {\n+    case NUL:\n+      goto loopDone;\n+\n+    case '\\'':\n+      if (pz_d - pz_d_start >= smax - sizeof( zQ )-1)\n+\treturn (char*)NULL;\n+      strcpy( pz_d-1, zQ );\n+      pz_d += sizeof( zQ )-2;\n+    }\n+  } loopDone:;\n+  pz_d[-1] = '\\'';\n+  *pz_d    = NUL;\n+\n+  return pz_d;\n+}\n+\n+#endif"}, {"sha": "47229717c1ff40d3b9b7ee36a0a37c9c89c6cca6", "filename": "gcc/fixinc/fixlib.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62a99405cf2a861aa91ec0979021fa571046c8f8/gcc%2Ffixinc%2Ffixlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixlib.h?ref=62a99405cf2a861aa91ec0979021fa571046c8f8", "patch": "@@ -100,6 +100,9 @@ typedef int apply_fix_p_t;  /* Apply Fix Predicate Type */\n   _ENV_( pz_machine,   BOOL_TRUE, \"TARGET_MACHINE\",  \\\n          \"output from config.guess\" )                \\\n                                                      \\\n+  _ENV_( pz_orig_dir,  BOOL_TRUE, \"ORIGDIR\",         \\\n+         \"directory of fixincl and applyfix\" )       \\\n+                                                     \\\n   _ENV_( pz_src_dir,   BOOL_TRUE, \"SRCDIR\",          \\\n          \"directory of original files\" )             \\\n                                                      \\\n@@ -204,6 +207,10 @@ void   compile_re     _P_(( tCC* pat, regex_t* re, int match,\n void apply_fix _P_(( tFixDesc* p_fixd, tCC* filname ));\n apply_fix_p_t run_test _P_((tCC* t_name, tCC* f_name, tCC* text ));\n \n+#ifdef __MSDOS__\n+char* make_raw_shell_str _P_(( char* pz_d, tCC* pz_s, size_t smax ));\n+#endif\n+\n #ifdef MN_NAME_PAT\n void   mn_get_regexps _P_(( regex_t** label_re, regex_t** name_re,\n \t\t\t    tCC *who ));"}]}