{"sha": "2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU1ZWM2Y2YzYjEyNTZlMmRlZDdmOGY1ZjgzNzZiNWM3OWRiY2Q3NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-15T23:35:35Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-15T23:35:35Z"}, "message": "(do_jump_by_parts_greater_rtx): No longer static.\n\n(expand_expr): Delete code for plain `abs'.\n\nFrom-SVN: r8443", "tree": {"sha": "60e9dda0a4b3d64df079186ba22da43ede456651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60e9dda0a4b3d64df079186ba22da43ede456651"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74/comments", "author": null, "committer": null, "parents": [{"sha": "69f619018a585979500e0e80d3d106aaf3b62820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f619018a585979500e0e80d3d106aaf3b62820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f619018a585979500e0e80d3d106aaf3b62820"}], "stats": {"total": 70, "additions": 4, "deletions": 66}, "files": [{"sha": "0e2f3a36ae28433f4a8957c98630cda98d1962b8", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 66, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2e5ec6cf3b1256e2ded7f8f5f8376b5c79dbcd74", "patch": "@@ -180,7 +180,7 @@ void bc_load_localaddr\t\tPROTO((rtx));\n void bc_load_parmaddr\t\tPROTO((rtx));\n static void preexpand_calls\tPROTO((tree));\n static void do_jump_by_parts_greater PROTO((tree, int, rtx, rtx));\n-static void do_jump_by_parts_greater_rtx PROTO((enum machine_mode, int, rtx, rtx, rtx, rtx));\n+void do_jump_by_parts_greater_rtx PROTO((enum machine_mode, int, rtx, rtx, rtx, rtx));\n static void do_jump_by_parts_equality PROTO((tree, rtx, rtx));\n static void do_jump_by_parts_equality_rtx PROTO((rtx, rtx, rtx));\n static void do_jump_for_compare\tPROTO((rtx, rtx, rtx));\n@@ -5216,70 +5216,8 @@ expand_expr (exp, target, tmode, modifier)\n       if (TREE_UNSIGNED (type))\n \treturn op0;\n \n-      /* First try to do it with a special abs instruction.  */\n-      temp = expand_unop (mode, abs_optab, op0, target, 0);\n-      if (temp != 0)\n-\treturn temp;\n-\n-      /* If this machine has expensive jumps, we can do integer absolute\n-\t value of X as (((signed) x >> (W-1)) ^ x) - ((signed) x >> (W-1)),\n-\t where W is the width of MODE.  */\n-\n-      if (GET_MODE_CLASS (mode) == MODE_INT && BRANCH_COST >= 2)\n-\t{\n-\t  rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t\t\t       size_int (GET_MODE_BITSIZE (mode) - 1),\n-\t\t\t\t       NULL_RTX, 0);\n-\n-\t  temp = expand_binop (mode, xor_optab, extended, op0, target, 0,\n-\t\t\t       OPTAB_LIB_WIDEN);\n-\t  if (temp != 0)\n-\t    temp = expand_binop (mode, sub_optab, temp, extended, target, 0,\n-\t\t\t\t OPTAB_LIB_WIDEN);\n-\n-\t  if (temp != 0)\n-\t    return temp;\n-\t}\n-\n-      /* If that does not win, use conditional jump and negate.  */\n-      target = original_target;\n-      op1 = gen_label_rtx ();\n-      if (target == 0 || ! safe_from_p (target, TREE_OPERAND (exp, 0))\n-\t  || GET_MODE (target) != mode\n-\t  || (GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n-\t  || (GET_CODE (target) == REG\n-\t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n-\ttarget = gen_reg_rtx (mode);\n-\n-      emit_move_insn (target, op0);\n-      NO_DEFER_POP;\n-\n-      /* If this mode is an integer too wide to compare properly,\n-\t compare word by word.  Rely on CSE to optimize constant cases.  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode))\n-\tdo_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx, \n-\t\t\t\t      NULL_RTX, op1);\n-      else\n-\t{\n-\t  temp = compare_from_rtx (target, CONST0_RTX (mode), GE, 0, mode,\n-\t\t\t\t   NULL_RTX, 0);\n-\t  if (temp == const1_rtx)\n-\t    return target;\n-\t  else if (temp != const0_rtx)\n-\t    {\n-\t      if (bcc_gen_fctn[(int) GET_CODE (temp)] != 0)\n-\t\temit_jump_insn ((*bcc_gen_fctn[(int) GET_CODE (temp)]) (op1));\n-\t      else\n-\t\tabort ();\n-\t    }\n-\t}\n-\n-      op0 = expand_unop (mode, neg_optab, target, target, 0);\n-      if (op0 != target)\n-\temit_move_insn (target, op0);\n-      emit_label (op1);\n-      OK_DEFER_POP;\n-      return target;\n+      return expand_abs (mode, op0, target, unsignedp,\n+\t\t\t safe_from_p (target, TREE_OPERAND (exp, 0)));\n \n     case MAX_EXPR:\n     case MIN_EXPR:\n@@ -9026,7 +8964,7 @@ do_jump_by_parts_greater (exp, swap, if_false_label, if_true_label)\n    UNSIGNEDP says to do unsigned comparison.\n    Jump to IF_TRUE_LABEL if OP0 is greater, IF_FALSE_LABEL otherwise.  */\n \n-static void\n+void\n do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label, if_true_label)\n      enum machine_mode mode;\n      int unsignedp;"}]}