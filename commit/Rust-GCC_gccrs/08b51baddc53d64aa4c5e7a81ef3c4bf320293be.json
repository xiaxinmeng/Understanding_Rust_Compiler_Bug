{"sha": "08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "node_id": "C_kwDOANBUbNoAKDA4YjUxYmFkZGM1M2Q2NGFhNGM1ZTdhODFlZjNjNGJmMzIwMjkzYmU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-06T06:56:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-06T06:56:48Z"}, "message": "c++, c: Implement C++23 P1774R8 - Portable assumptions [PR106654]\n\nThe following patch implements C++23 P1774R8 - Portable assumptions\npaper, by introducing support for [[assume (cond)]]; attribute for C++.\nIn addition to that the patch adds [[gnu::assume (cond)]]; and\n__attribute__((assume (cond))); support to both C and C++.\nAs described in C++23, the attribute argument is conditional-expression\nrather than the usual assignment-expression for attribute arguments,\nthe condition is contextually converted to bool (for C truthvalue conversion\nis done on it) and is never evaluated at runtime.\nFor C++ constant expression evaluation, I only check the simplest conditions\nfor undefined behavior, because otherwise I'd need to undo changes to\n*ctx->global which happened during the evaluation (but I believe the spec\nallows that and we can further improve later).\nThe patch uses a new internal function, .ASSUME, to hold the condition\nin the FEs.  At gimplification time, if the condition is simple/without\nside-effects, it is gimplified as if (cond) ; else __builtin_unreachable ();\nand otherwise for now dropped on the floor.  The intent is to incrementally\noutline the conditions into separate artificial functions and use\n.ASSUME further to tell the ranger and perhaps other optimization passes\nabout the assumptions, as detailed in the PR.\n\nWhen implementing it, I found that assume entry hasn't been added to\nhttps://eel.is/c++draft/cpp.cond#6\nJonathan said he'll file a NB comment about it, this patch assumes it\nhas been added into the table as 202207L when the paper has been voted in.\n\nWith the attributes for both C/C++, I'd say we don't need to add\n__builtin_assume with similar purpose, especially when __builtin_assume\nin LLVM is just weird.  It is strange for side-effects in function call's\nargument not to be evaluated, and LLVM in that case (annoyingly) warns\nand ignores the side-effects (but doesn't do then anything with it),\nif there are no side-effects, it will work like our\nif (!cond) __builtin_unreachable ();\n\n2022-10-06  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/106654\ngcc/\n\t* internal-fn.def (ASSUME): New internal function.\n\t* internal-fn.h (expand_ASSUME): Declare.\n\t* internal-fn.cc (expand_ASSUME): Define.\n\t* gimplify.cc (gimplify_call_expr): Gimplify IFN_ASSUME.\n\t* fold-const.h (simple_condition_p): Declare.\n\t* fold-const.cc (simple_operand_p_2): Rename to ...\n\t(simple_condition_p): ... this.  Remove forward declaration.\n\tNo longer static.  Adjust function comment and fix a typo in it.\n\tAdjust recursive call.\n\t(simple_operand_p): Adjust function comment.\n\t(fold_truth_andor): Adjust simple_operand_p_2 callers to call\n\tsimple_condition_p.\n\t* doc/extend.texi: Document assume attribute.  Move fallthrough\n\tattribute example to its section.\ngcc/c-family/\n\t* c-attribs.cc (handle_assume_attribute): New function.\n\t(c_common_attribute_table): Add entry for assume attribute.\n\t* c-lex.cc (c_common_has_attribute): Handle\n\t__have_cpp_attribute (assume).\ngcc/c/\n\t* c-parser.cc (handle_assume_attribute): New function.\n\t(c_parser_declaration_or_fndef): Handle assume attribute.\n\t(c_parser_attribute_arguments): Add assume_attr argument,\n\tif true, parse first argument as conditional expression.\n\t(c_parser_gnu_attribute, c_parser_std_attribute): Adjust\n\tc_parser_attribute_arguments callers.\n\t(c_parser_statement_after_labels) <case RID_ATTRIBUTE>: Handle\n\tassume attribute.\ngcc/cp/\n\t* cp-tree.h (process_stmt_assume_attribute): Implement C++23\n\tP1774R8 - Portable assumptions.  Declare.\n\t(diagnose_failing_condition): Declare.\n\t(find_failing_clause): Likewise.\n\t* parser.cc (assume_attr): New enumerator.\n\t(cp_parser_parenthesized_expression_list): Handle assume_attr.\n\tRemove identifier variable, for id_attr push the identifier into\n\texpression_list right away instead of inserting it before all the\n\tothers at the end.\n\t(cp_parser_conditional_expression): New function.\n\t(cp_parser_constant_expression): Use it.\n\t(cp_parser_statement): Handle assume attribute.\n\t(cp_parser_expression_statement): Likewise.\n\t(cp_parser_gnu_attribute_list): Use assume_attr for assume\n\tattribute.\n\t(cp_parser_std_attribute): Likewise.  Handle standard assume\n\tattribute like gnu::assume.\n\t* cp-gimplify.cc (process_stmt_assume_attribute): New function.\n\t* constexpr.cc: Include fold-const.h.\n\t(find_failing_clause_r, find_failing_clause): New functions,\n\tmoved from semantics.cc with ctx argument added and if non-NULL,\n\tcall cxx_eval_constant_expression rather than fold_non_dependent_expr.\n\t(cxx_eval_internal_function): Handle IFN_ASSUME.\n\t(potential_constant_expression_1): Likewise.\n\t* pt.cc (tsubst_copy_and_build): Likewise.\n\t* semantics.cc (diagnose_failing_condition): New function.\n\t(find_failing_clause_r, find_failing_clause): Moved to constexpr.cc.\n\t(finish_static_assert): Use it.  Add auto_diagnostic_group.\ngcc/testsuite/\n\t* gcc.dg/attr-assume-1.c: New test.\n\t* gcc.dg/attr-assume-2.c: New test.\n\t* gcc.dg/attr-assume-3.c: New test.\n\t* g++.dg/cpp2a/feat-cxx2a.C: Add colon to C++20 features\n\tcomment, add C++20 attributes comment and move C++20\n\tnew features after the attributes before them.\n\t* g++.dg/cpp23/feat-cxx2b.C: Likewise.  Test\n\t__has_cpp_attribute(assume).\n\t* g++.dg/cpp23/attr-assume1.C: New test.\n\t* g++.dg/cpp23/attr-assume2.C: New test.\n\t* g++.dg/cpp23/attr-assume3.C: New test.\n\t* g++.dg/cpp23/attr-assume4.C: New test.", "tree": {"sha": "f6bdda9f6abdade347d75edeb8c2c5f8075f9cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6bdda9f6abdade347d75edeb8c2c5f8075f9cce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fc4d3e1837ea4850aac6460f563913f1d3fc5b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fc4d3e1837ea4850aac6460f563913f1d3fc5b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fc4d3e1837ea4850aac6460f563913f1d3fc5b8"}], "stats": {"total": 1521, "additions": 1319, "deletions": 202}, "files": [{"sha": "671ea38fd1baec0d95024567b7c59169ee3ed10b", "filename": "gcc/c-family/c-attribs.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fc-family%2Fc-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fc-family%2Fc-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -144,6 +144,7 @@ static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_align_attribute (tree *, tree, tree, int, bool *);\n static tree handle_assume_aligned_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_assume_attribute (tree *, tree, tree, int, bool *);\n static tree handle_target_attribute (tree *, tree, tree, int, bool *);\n static tree handle_target_clones_attribute (tree *, tree, tree, int, bool *);\n static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n@@ -530,6 +531,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_designated_init_attribute, NULL },\n   { \"fallthrough\",\t      0, 0, false, false, false, false,\n \t\t\t      handle_fallthrough_attribute, NULL },\n+  { \"assume\",\t\t      1, 1, false, false, false, false,\n+\t\t\t      handle_assume_attribute, NULL },\n   { \"patchable_function_entry\",\t1, 2, true, false, false, false,\n \t\t\t      handle_patchable_function_entry_attribute,\n \t\t\t      NULL },\n@@ -5741,6 +5744,18 @@ handle_fallthrough_attribute (tree *, tree name, tree, int,\n   return NULL_TREE;\n }\n \n+/* Handle a \"assume\" attribute; arguments as in struct\n+   attribute_spec.handler.  */\n+\n+tree\n+handle_assume_attribute (tree *, tree name, tree, int,\n+\t\t\t bool *no_add_attrs)\n+{\n+  pedwarn (input_location, OPT_Wattributes, \"%qE attribute ignored\", name);\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"patchable_function_entry\" attributes; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "050fa775a9586227548381ccc15c95ad8e0c8ba3", "filename": "gcc/c-family/c-lex.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fc-family%2Fc-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fc-family%2Fc-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -378,6 +378,8 @@ c_common_has_attribute (cpp_reader *pfile, bool std_syntax)\n \t\tresult = 201803;\n \t      else if (is_attribute_p (\"nodiscard\", attr_name))\n \t\tresult = 201907;\n+\t      else if (is_attribute_p (\"assume\", attr_name))\n+\t\tresult = 202207;\n \t    }\n \t  else\n \t    {"}, {"sha": "9b7663739dde508c2a633d4e5d4b94369b5a13af", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 104, "deletions": 9, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -1823,6 +1823,46 @@ add_debug_begin_stmt (location_t loc)\n   add_stmt (stmt);\n }\n \n+/* Helper function for c_parser_declaration_or_fndef and\n+   Handle assume attribute(s).  */\n+\n+static tree\n+handle_assume_attribute (location_t here, tree attrs, bool nested)\n+{\n+  if (nested)\n+    for (tree attr = lookup_attribute (\"gnu\", \"assume\", attrs); attr;\n+\t attr = lookup_attribute (\"gnu\", \"assume\", TREE_CHAIN (attr)))\n+      {\n+\ttree args = TREE_VALUE (attr);\n+\tint nargs = list_length (args);\n+\tif (nargs != 1)\n+\t  {\n+\t    error_at (here, \"wrong number of arguments specified \"\n+\t\t\t    \"for %qE attribute\",\n+\t\t      get_attribute_name (attr));\n+\t    inform (here, \"expected %i, found %i\", 1, nargs);\n+\t  }\n+\telse\n+\t  {\n+\t    tree arg = TREE_VALUE (args);\n+\t    arg = c_objc_common_truthvalue_conversion (here, arg);\n+\t    arg = c_fully_fold (arg, false, NULL);\n+\t    if (arg != error_mark_node)\n+\t      {\n+\t\ttree fn = build_call_expr_internal_loc (here, IFN_ASSUME,\n+\t\t\t\t\t\t\tvoid_type_node, 1,\n+\t\t\t\t\t\t\targ);\n+\t\tadd_stmt (fn);\n+\t      }\n+\t  }\n+      }\n+  else\n+    pedwarn (here, OPT_Wattributes,\n+\t     \"%<assume%> attribute at top level\");\n+\n+  return remove_attribute (\"gnu\", \"assume\", attrs);\n+}\n+\n /* Parse a declaration or function definition (C90 6.5, 6.7.1, C99\n    6.7, 6.9.1, C11 6.7, 6.9.1).  If FNDEF_OK is true, a function definition\n    is accepted; otherwise (old-style parameter declarations) only other\n@@ -2037,6 +2077,14 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n   bool auto_type_p = specs->typespec_word == cts_auto_type;\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n+      bool handled_assume = false;\n+      if (specs->typespec_kind == ctsk_none\n+\t  && lookup_attribute (\"gnu\", \"assume\", specs->attrs))\n+\t{\n+\t  handled_assume = true;\n+\t  specs->attrs\n+\t    = handle_assume_attribute (here, specs->attrs, nested);\n+\t}\n       if (auto_type_p)\n \terror_at (here, \"%<__auto_type%> in empty declaration\");\n       else if (specs->typespec_kind == ctsk_none\n@@ -2054,13 +2102,15 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    pedwarn (here, OPT_Wattributes,\n \t\t     \"%<fallthrough%> attribute at top level\");\n \t}\n-      else if (empty_ok && !(have_attrs\n-\t\t\t     && specs->non_std_attrs_seen_p))\n+      else if (empty_ok\n+\t       && !(have_attrs && specs->non_std_attrs_seen_p)\n+\t       && !handled_assume)\n \tshadow_tag (specs);\n       else\n \t{\n \t  shadow_tag_warned (specs, 1);\n-\t  pedwarn (here, 0, \"empty declaration\");\n+\t  if (!handled_assume)\n+\t    pedwarn (here, 0, \"empty declaration\");\n \t}\n       c_parser_consume_token (parser);\n       if (oacc_routine_data)\n@@ -2160,6 +2210,9 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n   else if (attribute_fallthrough_p (specs->attrs))\n     warning_at (here, OPT_Wattributes,\n \t\t\"%<fallthrough%> attribute not followed by %<;%>\");\n+  else if (lookup_attribute (\"gnu\", \"assume\", specs->attrs))\n+    warning_at (here, OPT_Wattributes,\n+\t\t\"%<assume%> attribute not followed by %<;%>\");\n \n   pending_xref_error ();\n   prefix_attrs = specs->attrs;\n@@ -4598,7 +4651,8 @@ c_parser_gnu_attribute_any_word (c_parser *parser)\n \n static tree\n c_parser_attribute_arguments (c_parser *parser, bool takes_identifier,\n-\t\t\t      bool require_string, bool allow_empty_args)\n+\t\t\t      bool require_string, bool assume_attr,\n+\t\t\t      bool allow_empty_args)\n {\n   vec<tree, va_gc> *expr_list;\n   tree attr_args;\n@@ -4617,6 +4671,7 @@ c_parser_attribute_arguments (c_parser *parser, bool takes_identifier,\n \t      == CPP_CLOSE_PAREN))\n       && (takes_identifier\n \t  || (c_dialect_objc ()\n+\t      && !assume_attr\n \t      && c_parser_peek_token (parser)->id_kind\n \t      == C_ID_CLASSNAME)))\n     {\n@@ -4653,6 +4708,23 @@ c_parser_attribute_arguments (c_parser *parser, bool takes_identifier,\n \t  tree string = c_parser_string_literal (parser, false, true).value;\n \t  attr_args = build_tree_list (NULL_TREE, string);\n \t}\n+      else if (assume_attr)\n+\t{\n+\t  tree cond\n+\t    = c_parser_conditional_expression (parser, NULL, NULL_TREE).value;\n+\t  if (!c_parser_next_token_is (parser, CPP_COMMA))\n+\t    attr_args = build_tree_list (NULL_TREE, cond);\n+\t  else\n+\t    {\n+\t      tree tree_list;\n+\t      c_parser_consume_token (parser);\n+\t      expr_list = c_parser_expr_list (parser, false, true,\n+\t\t\t\t\t      NULL, NULL, NULL, NULL);\n+\t      tree_list = build_tree_list_vec (expr_list);\n+\t      attr_args = tree_cons (NULL_TREE, cond, tree_list);\n+\t      release_tree_vector (expr_list);\n+\t    }\n+\t}\n       else\n \t{\n \t  expr_list = c_parser_expr_list (parser, false, true,\n@@ -4736,7 +4808,9 @@ c_parser_gnu_attribute (c_parser *parser, tree attrs,\n   tree attr_args\n     = c_parser_attribute_arguments (parser,\n \t\t\t\t    attribute_takes_identifier_p (attr_name),\n-\t\t\t\t    false, true);\n+\t\t\t\t    false,\n+\t\t\t\t    is_attribute_p (\"assume\", attr_name),\n+\t\t\t\t    true);\n \n   attr = build_tree_list (attr_name, attr_args);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -4982,9 +5056,13 @@ c_parser_std_attribute (c_parser *parser, bool for_tm)\n \t  = (ns == NULL_TREE\n \t     && (strcmp (IDENTIFIER_POINTER (name), \"deprecated\") == 0\n \t\t || strcmp (IDENTIFIER_POINTER (name), \"nodiscard\") == 0));\n+\tbool assume_attr\n+\t  = (ns != NULL_TREE\n+\t     && strcmp (IDENTIFIER_POINTER (ns), \"gnu\") == 0\n+\t     && strcmp (IDENTIFIER_POINTER (name), \"assume\") == 0);\n \tTREE_VALUE (attribute)\n \t  = c_parser_attribute_arguments (parser, takes_identifier,\n-\t\t\t\t\t  require_string, false);\n+\t\t\t\t\t  require_string, assume_attr, false);\n       }\n     else\n       c_parser_balanced_token_sequence (parser);\n@@ -6264,8 +6342,21 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t  break;\n \tcase RID_ATTRIBUTE:\n \t  {\n-\t    /* Allow '__attribute__((fallthrough));'.  */\n+\t    /* Allow '__attribute__((fallthrough));' or\n+\t       '__attribute__((assume(cond)));'.  */\n \t    tree attrs = c_parser_gnu_attributes (parser);\n+\t    bool has_assume = lookup_attribute (\"assume\", attrs);\n+\t    if (has_assume)\n+\t      {\n+\t\tif (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\t\t  attrs = handle_assume_attribute (loc, attrs, true);\n+\t\telse\n+\t\t  {\n+\t\t    warning_at (loc, OPT_Wattributes,\n+\t\t\t\t\"%<assume%> attribute not followed by %<;%>\");\n+\t\t    has_assume = false;\n+\t\t  }\n+\t      }\n \t    if (attribute_fallthrough_p (attrs))\n \t      {\n \t\tif (c_parser_next_token_is (parser, CPP_SEMICOLON))\n@@ -6282,9 +6373,13 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t\t\t      \"%<fallthrough%> attribute not followed \"\n \t\t\t      \"by %<;%>\");\n \t      }\n+\t    else if (has_assume)\n+\t      /* Eat the ';'.  */\n+\t      c_parser_consume_token (parser);\n \t    else if (attrs != NULL_TREE)\n-\t      warning_at (loc, OPT_Wattributes, \"only attribute %<fallthrough%>\"\n-\t\t\t  \" can be applied to a null statement\");\n+\t      warning_at (loc, OPT_Wattributes,\n+\t\t\t  \"only attribute %<fallthrough%> or %<assume%> can \"\n+\t\t\t  \"be applied to a null statement\");\n \t    break;\n \t  }\n \tdefault:"}, {"sha": "06dcd71c9263de18ced6b5f7d7bb6f6236f0d664", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"fold-const.h\"\n \n static bool verify_constant (tree, bool, bool *, bool *);\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n@@ -1818,6 +1819,52 @@ cx_error_context (void)\n   return r;\n }\n \n+/* If we have a condition in conjunctive normal form (CNF), find the first\n+   failing clause.  In other words, given an expression like\n+\n+     true && true && false && true && false\n+\n+   return the first 'false'.  EXPR is the expression.  */\n+\n+static tree\n+find_failing_clause_r (constexpr_ctx *ctx, tree expr)\n+{\n+  if (TREE_CODE (expr) == TRUTH_ANDIF_EXPR)\n+    {\n+      /* First check the left side...  */\n+      tree e = find_failing_clause_r (ctx, TREE_OPERAND (expr, 0));\n+      if (e == NULL_TREE)\n+\t/* ...if we didn't find a false clause, check the right side.  */\n+\te = find_failing_clause_r (ctx, TREE_OPERAND (expr, 1));\n+      return e;\n+    }\n+  tree e = contextual_conv_bool (expr, tf_none);\n+  if (ctx)\n+    {\n+      bool new_non_constant_p = false, new_overflow_p = false;\n+      e = cxx_eval_constant_expression (ctx, e, vc_prvalue,\n+\t\t\t\t\t&new_non_constant_p,\n+\t\t\t\t\t&new_overflow_p);\n+    }\n+  else\n+    e = fold_non_dependent_expr (e, tf_none, /*manifestly_const_eval=*/true);\n+  if (integer_zerop (e))\n+    /* This is the failing clause.  */\n+    return expr;\n+  return NULL_TREE;\n+}\n+\n+/* Wrapper for find_failing_clause_r.  */\n+\n+tree\n+find_failing_clause (constexpr_ctx *ctx, tree expr)\n+{\n+  if (TREE_CODE (expr) == TRUTH_ANDIF_EXPR)\n+    if (tree e = find_failing_clause_r (ctx, expr))\n+      expr = e;\n+  return expr;\n+}\n+\n /* Evaluate a call T to a GCC internal function when possible and return\n    the evaluated result or, under the control of CTX, give an error, set\n    NON_CONSTANT_P, and return the unevaluated call T otherwise.  */\n@@ -1837,6 +1884,48 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n     case IFN_FALLTHROUGH:\n       return void_node;\n \n+    case IFN_ASSUME:\n+      /* For now, restrict constexpr evaluation of [[assume (cond)]]\n+\t only to the cases which don't have side-effects.  Evaluating\n+\t it even when it does would mean we'd need to somehow undo\n+\t all the side-effects e.g. in ctx->global->values.  */\n+      if (!TREE_SIDE_EFFECTS (CALL_EXPR_ARG (t, 0))\n+\t  /* And it needs to be a potential constant expression.  */\n+\t  && potential_rvalue_constant_expression (CALL_EXPR_ARG (t, 0)))\n+\t{\n+\t  constexpr_ctx new_ctx = *ctx;\n+\t  new_ctx.quiet = true;\n+\t  tree arg = CALL_EXPR_ARG (t, 0);\n+\t  bool new_non_constant_p = false, new_overflow_p = false;\n+\t  arg = cxx_eval_constant_expression (&new_ctx, arg, vc_prvalue,\n+\t\t\t\t\t      &new_non_constant_p,\n+\t\t\t\t\t      &new_overflow_p);\n+\t  if (!new_non_constant_p && !new_overflow_p && integer_zerop (arg))\n+\t    {\n+\t      if (!*non_constant_p && !ctx->quiet)\n+\t\t{\n+\t\t  /* See if we can find which clause was failing\n+\t\t     (for logical AND).  */\n+\t\t  tree bad = find_failing_clause (&new_ctx,\n+\t\t\t\t\t\t  CALL_EXPR_ARG (t, 0));\n+\t\t  /* If not, or its location is unusable, fall back to the\n+\t\t     previous location.  */\n+\t\t  location_t cloc = cp_expr_loc_or_loc (bad, EXPR_LOCATION (t));\n+\n+\t\t  auto_diagnostic_group d;\n+\n+\t\t  /* Report the error. */\n+\t\t  error_at (cloc,\n+\t\t\t    \"failed %<assume%> attribute assumption\");\n+\t\t  diagnose_failing_condition (bad, cloc, false);\n+\t\t}\n+\n+\t      *non_constant_p = true;\n+\t      return t;\n+\t    }\n+\t}\n+      return void_node;\n+\n     case IFN_ADD_OVERFLOW:\n       opcode = PLUS_EXPR;\n       break;\n@@ -8706,6 +8795,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\tcase IFN_UBSAN_BOUNDS:\n \t\tcase IFN_UBSAN_VPTR:\n \t\tcase IFN_FALLTHROUGH:\n+\t\tcase IFN_ASSUME:\n \t\t  return true;\n \n \t\tcase IFN_ADD_OVERFLOW:"}, {"sha": "b4599fc34d85cd316c06df3810c4b8500b75c960", "filename": "gcc/cp/cp-gimplify.cc", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fcp-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fcp-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -3081,6 +3081,50 @@ process_stmt_hotness_attribute (tree std_attrs, location_t attrs_loc)\n   return std_attrs;\n }\n \n+/* If [[assume (cond)]] appears on this statement, handle it.  */\n+\n+tree\n+process_stmt_assume_attribute (tree std_attrs, tree statement,\n+\t\t\t       location_t attrs_loc)\n+{\n+  if (std_attrs == error_mark_node)\n+    return std_attrs;\n+  tree attr = lookup_attribute (\"gnu\", \"assume\", std_attrs);\n+  if (!attr)\n+    return std_attrs;\n+  /* The next token after the assume attribute is not ';'.  */\n+  if (statement)\n+    {\n+      warning_at (attrs_loc, OPT_Wattributes,\n+\t\t  \"%<assume%> attribute not followed by %<;%>\");\n+      attr = NULL_TREE;\n+    }\n+  for (; attr; attr = lookup_attribute (\"gnu\", \"assume\", TREE_CHAIN (attr)))\n+    {\n+      tree args = TREE_VALUE (attr);\n+      int nargs = list_length (args);\n+      if (nargs != 1)\n+\t{\n+\t  auto_diagnostic_group d;\n+\t  error_at (attrs_loc, \"wrong number of arguments specified for \"\n+\t\t\t       \"%qE attribute\", get_attribute_name (attr));\n+\t  inform (attrs_loc, \"expected %i, found %i\", 1, nargs);\n+\t}\n+      else\n+\t{\n+\t  tree arg = TREE_VALUE (args);\n+\t  if (!type_dependent_expression_p (arg))\n+\t    arg = contextual_conv_bool (arg, tf_warning_or_error);\n+\t  if (error_operand_p (arg))\n+\t    continue;\n+\t  statement = build_call_expr_internal_loc (attrs_loc, IFN_ASSUME,\n+\t\t\t\t\t\t    void_type_node, 1, arg);\n+\t  finish_expr_stmt (statement);\n+\t}\n+    }\n+  return remove_attribute (\"gnu\", \"assume\", std_attrs);\n+}\n+\n /* Helper of fold_builtin_source_location, return the\n    std::source_location::__impl type after performing verification\n    on it.  LOC is used for reporting any errors.  */"}, {"sha": "8bc1c2dc7fd6d8884c47a1b5f2cef3f30732558d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -7715,6 +7715,7 @@ extern tree build_transaction_expr\t\t(location_t, tree, int, tree);\n extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool,\n \t\t\t\t\t\t bool, bool);\n extern tree baselink_for_fns                    (tree);\n+extern void diagnose_failing_condition\t\t(tree, location_t, bool);\n extern void finish_static_assert                (tree, tree, location_t,\n \t\t\t\t\t\t bool, bool);\n extern tree finish_decltype_type                (tree, bool, tsubst_flags_t);\n@@ -8242,6 +8243,7 @@ extern tree predeclare_vla\t\t\t(tree);\n extern void clear_fold_cache\t\t\t(void);\n extern tree lookup_hotness_attribute\t\t(tree);\n extern tree process_stmt_hotness_attribute\t(tree, location_t);\n+extern tree process_stmt_assume_attribute\t(tree, tree, location_t);\n extern bool simple_empty_class_p\t\t(tree, tree, tree_code);\n extern tree fold_builtin_source_location\t(location_t);\n \n@@ -8447,6 +8449,8 @@ extern tree fold_sizeof_expr\t\t\t(tree);\n extern void clear_cv_and_fold_caches\t\t(void);\n extern tree unshare_constructor\t\t\t(tree CXX_MEM_STAT_INFO);\n extern bool decl_implicit_constexpr_p\t\t(tree);\n+struct constexpr_ctx;\n+extern tree find_failing_clause\t\t\t(constexpr_ctx *ctx, tree);\n extern bool replace_decl\t\t\t(tree *, tree, tree);\n \n /* An RAII sentinel used to restrict constexpr evaluation so that it"}, {"sha": "baa808a4634b15e0b28f793d5dd23136772f6133", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -2258,7 +2258,7 @@ static vec<tree, va_gc> *cp_parser_parenthesized_expression_list\n   (cp_parser *, int, bool, bool, bool *, location_t * = NULL,\n    bool = false);\n /* Values for the second parameter of cp_parser_parenthesized_expression_list.  */\n-enum { non_attr = 0, normal_attr = 1, id_attr = 2 };\n+enum { non_attr = 0, normal_attr = 1, id_attr = 2, assume_attr = 3 };\n static void cp_parser_pseudo_destructor_name\n   (cp_parser *, tree, tree *, tree *);\n static cp_expr cp_parser_unary_expression\n@@ -2287,6 +2287,7 @@ static cp_expr cp_parser_binary_expression\n   (cp_parser *, bool, bool, enum cp_parser_prec, cp_id_kind *);\n static tree cp_parser_question_colon_clause\n   (cp_parser *, cp_expr);\n+static cp_expr cp_parser_conditional_expression (cp_parser *);\n static cp_expr cp_parser_assignment_expression\n   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false);\n static enum tree_code cp_parser_assignment_operator_opt\n@@ -8480,7 +8481,6 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t bool wrap_locations_p)\n {\n   vec<tree, va_gc> *expression_list;\n-  tree identifier = NULL_TREE;\n   bool saved_greater_than_is_operator_p;\n \n   /* Assume all the expressions will be constant.  */\n@@ -8509,33 +8509,26 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t   next token is an identifier.  */\n \tif (is_attribute_list == id_attr\n \t    && cp_lexer_peek_token (parser->lexer)->type == CPP_NAME)\n-\t  {\n-\t    cp_token *token;\n-\n-\t    /* Consume the identifier.  */\n-\t    token = cp_lexer_consume_token (parser->lexer);\n-\t    /* Save the identifier.  */\n-\t    identifier = token->u.value;\n-\t  }\n+\t  expr = cp_lexer_consume_token (parser->lexer)->u.value;\n+\telse if (is_attribute_list == assume_attr)\n+\t  expr = cp_parser_conditional_expression (parser);\n \telse\n-\t  {\n-\t    expr\n-\t      = cp_parser_parenthesized_expression_list_elt (parser, cast_p,\n-\t\t\t\t\t\t\t     allow_expansion_p,\n-\t\t\t\t\t\t\t     non_constant_p);\n+\t  expr\n+\t    = cp_parser_parenthesized_expression_list_elt (parser, cast_p,\n+\t\t\t\t\t\t\t   allow_expansion_p,\n+\t\t\t\t\t\t\t   non_constant_p);\n \n-\t    if (wrap_locations_p)\n-\t      expr.maybe_add_location_wrapper ();\n+\tif (wrap_locations_p)\n+\t  expr.maybe_add_location_wrapper ();\n \n-\t     /* Add it to the list.  We add error_mark_node\n-\t\texpressions to the list, so that we can still tell if\n-\t\tthe correct form for a parenthesized expression-list\n-\t\tis found. That gives better errors.  */\n-\t    vec_safe_push (expression_list, expr.get_value ());\n+\t/* Add it to the list.  We add error_mark_node\n+\t   expressions to the list, so that we can still tell if\n+\t   the correct form for a parenthesized expression-list\n+\t   is found. That gives better errors.  */\n+\tvec_safe_push (expression_list, expr.get_value ());\n \n-\t    if (expr == error_mark_node)\n-\t      goto skip_comma;\n-\t  }\n+\tif (expr == error_mark_node)\n+\t  goto skip_comma;\n \n \t/* After the first item, attribute lists look the same as\n \t   expression lists.  */\n@@ -8577,9 +8570,6 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n   parser->greater_than_is_operator_p\n     = saved_greater_than_is_operator_p;\n \n-  if (identifier)\n-    vec_safe_insert (expression_list, 0, identifier);\n-\n   return expression_list;\n }\n \n@@ -10310,7 +10300,8 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n    logical-or-expression that started the conditional-expression.\n    Returns a representation of the entire conditional-expression.\n \n-   This routine is used by cp_parser_assignment_expression.\n+   This routine is used by cp_parser_assignment_expression\n+   and cp_parser_conditional_expression.\n \n      ? expression : assignment-expression\n \n@@ -10377,6 +10368,28 @@ cp_parser_question_colon_clause (cp_parser* parser, cp_expr logical_or_expr)\n                                    tf_warning_or_error);\n }\n \n+/* Parse a conditional-expression.\n+\n+   conditional-expression:\n+     logical-or-expression\n+     logical-or-expression ? expression : assignment-expression\n+\n+   GNU Extensions:\n+\n+     logical-or-expression ? : assignment-expression  */\n+\n+static cp_expr\n+cp_parser_conditional_expression (cp_parser *parser)\n+{\n+  cp_expr expr = cp_parser_binary_expression (parser, false, false, false,\n+\t\t\t\t\t      PREC_NOT_OPERATOR, NULL);\n+  /* If the next token is a `?' then we're actually looking at\n+     a conditional-expression; otherwise we're done.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n+    return cp_parser_question_colon_clause (parser, expr);\n+  return expr;\n+}\n+\n /* Parse an assignment-expression.\n \n    assignment-expression:\n@@ -10702,15 +10715,7 @@ cp_parser_constant_expression (cp_parser* parser,\n      determine whether a particular assignment-expression is in fact\n      constant.  */\n   if (strict_p)\n-    {\n-      /* Parse the binary expressions (logical-or-expression).  */\n-      expression = cp_parser_binary_expression (parser, false, false, false,\n-\t\t\t\t\t\tPREC_NOT_OPERATOR, NULL);\n-      /* If the next token is a `?' then we're actually looking at\n-\t a conditional-expression; otherwise we're done.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n-\texpression = cp_parser_question_colon_clause (parser, expression);\n-    }\n+    expression = cp_parser_conditional_expression (parser);\n   else\n     expression = cp_parser_assignment_expression (parser);\n   /* Restore the old settings.  */\n@@ -12503,6 +12508,9 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n       /* Look for an expression-statement instead.  */\n       statement = cp_parser_expression_statement (parser, in_statement_expr);\n \n+      std_attrs = process_stmt_assume_attribute (std_attrs, statement,\n+\t\t\t\t\t\t attrs_loc);\n+\n       /* Handle [[fallthrough]];.  */\n       if (attribute_fallthrough_p (std_attrs))\n \t{\n@@ -12526,7 +12534,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n   if (statement && STATEMENT_CODE_P (TREE_CODE (statement)))\n     SET_EXPR_LOCATION (statement, statement_location);\n \n-  /* Allow \"[[fallthrough]];\", but warn otherwise.  */\n+  /* Allow \"[[fallthrough]];\" or \"[[assume(cond)]];\", but warn otherwise.  */\n   if (std_attrs != NULL_TREE)\n     warning_at (attrs_loc,\n \t\tOPT_Wattributes,\n@@ -12718,6 +12726,8 @@ cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n \t}\n     }\n \n+  attr = process_stmt_assume_attribute (attr, statement, loc);\n+\n   /* Handle [[fallthrough]];.  */\n   if (attribute_fallthrough_p (attr))\n     {\n@@ -28876,6 +28886,8 @@ cp_parser_gnu_attribute_list (cp_parser* parser, bool exactly_one /* = false */)\n \t      vec<tree, va_gc> *vec;\n \t      int attr_flag = (attribute_takes_identifier_p (identifier)\n \t\t\t       ? id_attr : normal_attr);\n+\t      if (is_attribute_p (\"assume\", identifier))\n+\t\tattr_flag = assume_attr;\n \t      vec = cp_parser_parenthesized_expression_list\n \t\t    (parser, attr_flag, /*cast_p=*/false,\n \t\t    /*allow_expansion_p=*/false,\n@@ -29127,6 +29139,9 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n       /* C++17 fallthrough attribute is equivalent to GNU's.  */\n       else if (is_attribute_p (\"fallthrough\", attr_id))\n \tTREE_PURPOSE (TREE_PURPOSE (attribute)) = gnu_identifier;\n+      /* C++23 assume attribute is equivalent to GNU's.  */\n+      else if (is_attribute_p (\"assume\", attr_id))\n+\tTREE_PURPOSE (TREE_PURPOSE (attribute)) = gnu_identifier;\n       /* Transactional Memory TS optimize_for_synchronized attribute is\n \t equivalent to GNU transaction_callable.  */\n       else if (is_attribute_p (\"optimize_for_synchronized\", attr_id))\n@@ -29171,8 +29186,12 @@ cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n \treturn error_mark_node;\n       }\n \n-    if (attr_ns == gnu_identifier\n-\t&& attribute_takes_identifier_p (attr_id))\n+    if (is_attribute_p (\"assume\", attr_id)\n+\t&& (attr_ns == NULL_TREE || attr_ns == gnu_identifier))\n+      /* The assume attribute needs special handling of the argument.  */\n+      attr_flag = assume_attr;\n+    else if (attr_ns == gnu_identifier\n+\t     && attribute_takes_identifier_p (attr_id))\n       /* A GNU attribute that takes an identifier in parameter.  */\n       attr_flag = id_attr;\n "}, {"sha": "bf4ae028eb0158dfaf24e56b917302bc836d4220", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -21163,6 +21163,33 @@ tsubst_copy_and_build (tree t,\n \t\tbreak;\n \t      }\n \n+\t    case IFN_ASSUME:\n+\t      gcc_assert (nargs == 1);\n+\t      if (vec_safe_length (call_args) != 1)\n+\t\t{\n+\t\t  error_at (cp_expr_loc_or_input_loc (t),\n+\t\t\t    \"wrong number of arguments to \"\n+\t\t\t    \"%<assume%> attribute\");\n+\t\t  ret = error_mark_node;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tree &arg = (*call_args)[0];\n+\t\t  if (!type_dependent_expression_p (arg))\n+\t\t    arg = contextual_conv_bool (arg, tf_warning_or_error);\n+\t\t  if (error_operand_p (arg))\n+\t\t    {\n+\t\t      ret = error_mark_node;\n+\t\t      break;\n+\t\t    }\n+\t\t  ret = build_call_expr_internal_loc (EXPR_LOCATION (t),\n+\t\t\t\t\t\t      IFN_ASSUME,\n+\t\t\t\t\t\t      void_type_node, 1,\n+\t\t\t\t\t\t      arg);\n+\t\t  RETURN (ret);\n+\t\t}\n+\t      break;\n+\n \t    default:\n \t      /* Unsupported internal function with arguments.  */\n \t      gcc_unreachable ();"}, {"sha": "39b11eeab8ad60f899c205a55ad294f378778071", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 25, "deletions": 50, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -11172,42 +11172,31 @@ init_cp_semantics (void)\n }\n \f\n \n-/* If we have a condition in conjunctive normal form (CNF), find the first\n-   failing clause.  In other words, given an expression like\n+/* Emit additional diagnostics for failing condition BAD.\n+   Used by finish_static_assert and IFN_ASSUME constexpr diagnostics.\n+   If SHOW_EXPR_P is true, print the condition (because it was\n+   instantiation-dependent).  */\n \n-     true && true && false && true && false\n-\n-   return the first 'false'.  EXPR is the expression.  */\n-\n-static tree\n-find_failing_clause_r (tree expr)\n+void\n+diagnose_failing_condition (tree bad, location_t cloc, bool show_expr_p)\n {\n-  if (TREE_CODE (expr) == TRUTH_ANDIF_EXPR)\n+  /* Nobody wants to see the artificial (bool) cast.  */\n+  bad = tree_strip_nop_conversions (bad);\n+\n+  /* Actually explain the failure if this is a concept check or a\n+     requires-expression.  */\n+  if (concept_check_p (bad) || TREE_CODE (bad) == REQUIRES_EXPR)\n+    diagnose_constraints (cloc, bad, NULL_TREE);\n+  else if (COMPARISON_CLASS_P (bad)\n+\t   && ARITHMETIC_TYPE_P (TREE_TYPE (TREE_OPERAND (bad, 0))))\n     {\n-      /* First check the left side...  */\n-      tree e = find_failing_clause_r (TREE_OPERAND (expr, 0));\n-      if (e == NULL_TREE)\n-\t/* ...if we didn't find a false clause, check the right side.  */\n-\te = find_failing_clause_r (TREE_OPERAND (expr, 1));\n-      return e;\n+      tree op0 = fold_non_dependent_expr (TREE_OPERAND (bad, 0));\n+      tree op1 = fold_non_dependent_expr (TREE_OPERAND (bad, 1));\n+      tree cond = build2 (TREE_CODE (bad), boolean_type_node, op0, op1);\n+      inform (cloc, \"the comparison reduces to %qE\", cond);\n     }\n-  tree e = contextual_conv_bool (expr, tf_none);\n-  e = fold_non_dependent_expr (e, tf_none, /*manifestly_const_eval=*/true);\n-  if (integer_zerop (e))\n-    /* This is the failing clause.  */\n-    return expr;\n-  return NULL_TREE;\n-}\n-\n-/* Wrapper for find_failing_clause_r.  */\n-\n-static tree\n-find_failing_clause (tree expr)\n-{\n-  if (TREE_CODE (expr) == TRUTH_ANDIF_EXPR)\n-    if (tree e = find_failing_clause_r (expr))\n-      expr = e;\n-  return expr;\n+  else if (show_expr_p)\n+    inform (cloc, \"%qE evaluates to false\", bad);\n }\n \n /* Build a STATIC_ASSERT for a static assertion with the condition\n@@ -11274,12 +11263,12 @@ finish_static_assert (tree condition, tree message, location_t location,\n \t  int len = TREE_STRING_LENGTH (message) / sz - 1;\n \n \t  /* See if we can find which clause was failing (for logical AND).  */\n-\t  tree bad = find_failing_clause (orig_condition);\n+\t  tree bad = find_failing_clause (NULL, orig_condition);\n \t  /* If not, or its location is unusable, fall back to the previous\n \t     location.  */\n \t  location_t cloc = cp_expr_loc_or_loc (bad, location);\n-\t  /* Nobody wants to see the artificial (bool) cast.  */\n-\t  bad = tree_strip_nop_conversions (bad);\n+\n+\t  auto_diagnostic_group d;\n \n           /* Report the error. */\n \t  if (len == 0)\n@@ -11288,21 +11277,7 @@ finish_static_assert (tree condition, tree message, location_t location,\n \t    error_at (cloc, \"static assertion failed: %s\",\n \t\t      TREE_STRING_POINTER (message));\n \n-\t  /* Actually explain the failure if this is a concept check or a\n-\t     requires-expression.  */\n-\t  if (concept_check_p (bad)\n-\t      || TREE_CODE (bad) == REQUIRES_EXPR)\n-\t    diagnose_constraints (location, bad, NULL_TREE);\n-\t  else if (COMPARISON_CLASS_P (bad)\n-\t\t   && ARITHMETIC_TYPE_P (TREE_TYPE (TREE_OPERAND (bad, 0))))\n-\t    {\n-\t      tree op0 = fold_non_dependent_expr (TREE_OPERAND (bad, 0));\n-\t      tree op1 = fold_non_dependent_expr (TREE_OPERAND (bad, 1));\n-\t      tree cond = build2 (TREE_CODE (bad), boolean_type_node, op0, op1);\n-\t      inform (cloc, \"the comparison reduces to %qE\", cond);\n-\t    }\n-\t  else if (show_expr_p)\n-\t    inform (cloc, \"%qE evaluates to false\", bad);\n+\t  diagnose_failing_condition (bad, cloc, show_expr_p);\n \t}\n       else if (condition && condition != error_mark_node)\n \t{"}, {"sha": "9ddfcf77e7a102b5c8375d0fd85bac9de5bbd824", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -9187,6 +9187,20 @@ available for functions (@pxref{Function Attributes}), variables\n (@pxref{Variable Attributes}), labels (@pxref{Label Attributes}), enumerators\n (@pxref{Enumerator Attributes}), and for types (@pxref{Type Attributes}).\n \n+@table @code\n+@item fallthrough\n+@cindex @code{fallthrough} statement attribute\n+The @code{fallthrough} attribute with a null statement serves as a\n+fallthrough statement.  It hints to the compiler that a statement\n+that falls through to another case label, or user-defined label\n+in a switch statement is intentional and thus the\n+@option{-Wimplicit-fallthrough} warning must not trigger.  The\n+fallthrough attribute may appear at most once in each attribute\n+list, and may not be mixed with other attributes.  It can only\n+be used in a switch statement (the compiler will issue an error\n+otherwise), after a preceding statement and before a logically\n+succeeding case label, or user-defined label.\n+\n This example uses the @code{fallthrough} statement attribute to indicate that\n the @option{-Wimplicit-fallthrough} warning should not be emitted:\n \n@@ -9201,19 +9215,28 @@ switch (cond)\n   @}\n @end smallexample\n \n-@table @code\n-@item fallthrough\n-@cindex @code{fallthrough} statement attribute\n-The @code{fallthrough} attribute with a null statement serves as a\n-fallthrough statement.  It hints to the compiler that a statement\n-that falls through to another case label, or user-defined label\n-in a switch statement is intentional and thus the\n-@option{-Wimplicit-fallthrough} warning must not trigger.  The\n-fallthrough attribute may appear at most once in each attribute\n-list, and may not be mixed with other attributes.  It can only\n-be used in a switch statement (the compiler will issue an error\n-otherwise), after a preceding statement and before a logically\n-succeeding case label, or user-defined label.\n+@item assume\n+@cindex @code{assume} statement attribute\n+The @code{assume} attribute with a null statement serves as portable\n+assumption.  It should have a single argument, a conditional expression,\n+which is not evaluated.  If the argument would evaluate to true\n+at the point where it appears, it has no effect, otherwise there\n+is undefined behavior.  This is a GNU variant of the ISO C++23\n+standard @code{assume} attribute, but it can be used in any version of\n+both C and C++.\n+\n+@smallexample\n+int\n+foo (int x, int y)\n+@{\n+  __attribute__((assume(x == 42)));\n+  __attribute__((assume(++y == 43)));\n+  return x + y;\n+@}\n+@end smallexample\n+\n+@code{y} is not actually incremented and the compiler can but does not\n+have to optimize it to just @code{return 42 + 42;}.\n \n @end table\n "}, {"sha": "9f7beae14e504ae9837162faac796d4f8433c044", "filename": "gcc/fold-const.cc", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ffold-const.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ffold-const.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -130,7 +130,6 @@ static tree eval_subst (location_t, tree, tree, tree, tree, tree);\n static tree optimize_bit_field_compare (location_t, enum tree_code,\n \t\t\t\t\ttree, tree, tree);\n static bool simple_operand_p (const_tree);\n-static bool simple_operand_p_2 (tree);\n static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n static tree range_predecessor (tree);\n static tree range_successor (tree);\n@@ -4868,8 +4867,8 @@ sign_bit_p (tree exp, const_tree val)\n   return NULL_TREE;\n }\n \n-/* Subroutine for fold_truth_andor_1: determine if an operand is simple enough\n-   to be evaluated unconditionally.  */\n+/* Subroutine for fold_truth_andor_1 and simple_condition_p: determine if an\n+   operand is simple enough to be evaluated unconditionally.  */\n \n static bool\n simple_operand_p (const_tree exp)\n@@ -4897,13 +4896,12 @@ simple_operand_p (const_tree exp)\n \t      && (! TREE_STATIC (exp) || DECL_REGISTER (exp))));\n }\n \n-/* Subroutine for fold_truth_andor: determine if an operand is simple enough\n-   to be evaluated unconditionally.\n-   I addition to simple_operand_p, we assume that comparisons, conversions,\n+/* Determine if an operand is simple enough to be evaluated unconditionally.\n+   In addition to simple_operand_p, we assume that comparisons, conversions,\n    and logic-not operations are simple, if their operands are simple, too.  */\n \n-static bool\n-simple_operand_p_2 (tree exp)\n+bool\n+simple_condition_p (tree exp)\n {\n   enum tree_code code;\n \n@@ -4920,7 +4918,7 @@ simple_operand_p_2 (tree exp)\n \t    && simple_operand_p (TREE_OPERAND (exp, 1)));\n \n   if (code == TRUTH_NOT_EXPR)\n-      return simple_operand_p_2 (TREE_OPERAND (exp, 0));\n+    return simple_condition_p (TREE_OPERAND (exp, 0));\n \n   return simple_operand_p (exp);\n }\n@@ -9787,10 +9785,10 @@ fold_truth_andor (location_t loc, enum tree_code code, tree type,\n \t side-effects, or isn't simple, then we can't add to it,\n \t as otherwise we might destroy if-sequence.  */\n       if (TREE_CODE (arg0) == icode\n-\t  && simple_operand_p_2 (arg1)\n+\t  && simple_condition_p (arg1)\n \t  /* Needed for sequence points to handle trappings, and\n \t     side-effects.  */\n-\t  && simple_operand_p_2 (TREE_OPERAND (arg0, 1)))\n+\t  && simple_condition_p (TREE_OPERAND (arg0, 1)))\n \t{\n \t  tem = fold_build2_loc (loc, ncode, type, TREE_OPERAND (arg0, 1),\n \t\t\t\t arg1);\n@@ -9800,10 +9798,10 @@ fold_truth_andor (location_t loc, enum tree_code code, tree type,\n \t/* Same as above but for (A AND[-IF] (B AND-IF C)) -> ((A AND B) AND-IF C),\n \t   or (A OR[-IF] (B OR-IF C) -> ((A OR B) OR-IF C).  */\n       else if (TREE_CODE (arg1) == icode\n-\t  && simple_operand_p_2 (arg0)\n+\t  && simple_condition_p (arg0)\n \t  /* Needed for sequence points to handle trappings, and\n \t     side-effects.  */\n-\t  && simple_operand_p_2 (TREE_OPERAND (arg1, 0)))\n+\t  && simple_condition_p (TREE_OPERAND (arg1, 0)))\n \t{\n \t  tem = fold_build2_loc (loc, ncode, type, \n \t\t\t\t arg0, TREE_OPERAND (arg1, 0));\n@@ -9814,8 +9812,8 @@ fold_truth_andor (location_t loc, enum tree_code code, tree type,\n \t into (A OR B).\n \t For sequence point consistancy, we need to check for trapping,\n \t and side-effects.  */\n-      else if (code == icode && simple_operand_p_2 (arg0)\n-               && simple_operand_p_2 (arg1))\n+      else if (code == icode && simple_condition_p (arg0)\n+\t       && simple_condition_p (arg1))\n \treturn fold_build2_loc (loc, ncode, type, arg0, arg1);\n     }\n "}, {"sha": "fa284c712bfeb389573f20c9b464cffa3364bee5", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -215,6 +215,7 @@ extern tree build_range_check (location_t, tree, tree, int, tree, tree);\n extern bool merge_ranges (int *, tree *, tree *, int, tree, tree, int,\n \t\t\t  tree, tree);\n extern tree sign_bit_p (tree, const_tree);\n+extern bool simple_condition_p (tree);\n extern tree exact_inverse (tree, tree);\n extern bool expr_not_equal_to (tree t, const wide_int &);\n extern tree const_unop (enum tree_code, tree, tree);"}, {"sha": "95e16f600b5d49664e9abb6bfb4a39f89b4780b7", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -3554,6 +3554,25 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n       enum internal_fn ifn = CALL_EXPR_IFN (*expr_p);\n       auto_vec<tree> vargs (nargs);\n \n+      if (ifn == IFN_ASSUME)\n+\t{\n+\t  if (simple_condition_p (CALL_EXPR_ARG (*expr_p, 0)))\n+\t    {\n+\t      /* If the [[assume (cond)]]; condition is simple\n+\t\t enough and can be evaluated unconditionally\n+\t\t without side-effects, expand it as\n+\t\t if (!cond) __builtin_unreachable ();  */\n+\t      tree fndecl = builtin_decl_explicit (BUILT_IN_UNREACHABLE);\n+\t      *expr_p = build3 (COND_EXPR, void_type_node,\n+\t\t\t\tCALL_EXPR_ARG (*expr_p, 0), void_node,\n+\t\t\t\tbuild_call_expr_loc (EXPR_LOCATION (*expr_p),\n+\t\t\t\t\t\t     fndecl, 0));\n+\t      return GS_OK;\n+\t    }\n+\t  /* FIXME: Otherwise expand it specially.  */\n+\t  return GS_ALL_DONE;\n+\t}\n+\n       for (i = 0; i < nargs; i++)\n \t{\n \t  gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p,"}, {"sha": "de608bd4802873cc6556cda101cebaa08a539a65", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -4522,3 +4522,9 @@ expand_TRAP (internal_fn, gcall *)\n {\n   expand_builtin_trap ();\n }\n+\n+void\n+expand_ASSUME (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}"}, {"sha": "61516dab66dc90e016622c47e832b790db8ea867", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -462,6 +462,10 @@ DEF_INTERNAL_FN (TRAP, ECF_CONST | ECF_LEAF | ECF_NORETURN\n \t\t       | ECF_NOTHROW | ECF_COLD | ECF_LOOPING_CONST_OR_PURE,\n \t\t NULL)\n \n+/* [[assume (cond)]].  */\n+DEF_INTERNAL_FN (ASSUME, ECF_CONST | ECF_LEAF | ECF_NOTHROW\n+\t\t\t | ECF_LOOPING_CONST_OR_PURE, NULL)\n+\n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN\n #undef DEF_INTERNAL_FLT_FLOATN_FN"}, {"sha": "21b1ce43df6a926a59e4b9eaf9ce06d2440845e7", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -243,6 +243,7 @@ extern void expand_PHI (internal_fn, gcall *);\n extern void expand_SHUFFLEVECTOR (internal_fn, gcall *);\n extern void expand_SPACESHIP (internal_fn, gcall *);\n extern void expand_TRAP (internal_fn, gcall *);\n+extern void expand_ASSUME (internal_fn, gcall *);\n \n extern bool vectorized_internal_fn_supported_p (internal_fn, tree);\n "}, {"sha": "76b61e91f18b56350df4eeca3facb099468ddf36", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume1.C", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume1.C?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -0,0 +1,191 @@\n+// P1774R8 - Portable assumptions\n+// { dg-do run { target c++11 } }\n+\n+namespace std\n+{\n+  constexpr bool\n+  isfinite (float x)\n+  { return __builtin_isfinite (x); }\n+\n+  constexpr bool\n+  isfinite (double x)\n+  { return __builtin_isfinite (x); }\n+\n+  constexpr bool\n+  isfinite (long double x)\n+  { return __builtin_isfinite (x); }\n+\n+  constexpr float\n+  sqrt (float x)\n+  { return __builtin_sqrtf (x); }\n+\n+  constexpr double\n+  sqrt (double x)\n+  { return __builtin_sqrt (x); }\n+\n+  constexpr long double\n+  sqrt (long double x)\n+  { return __builtin_sqrtl (x); }\n+\n+  extern \"C\" void\n+  abort ();\n+}\n+\n+constexpr int\n+f1 (int i)\n+{\n+#if __cpp_constexpr >= 201603L\n+  auto f = [=] { [[assume (i == 0)]]; };\n+  return sizeof (f);\n+#else\n+  return sizeof (int);\n+#endif\n+}\n+\n+void\n+f2 ()\n+{\n+  static_assert (f1 (0) >= sizeof (int), \"\");\n+}\n+\n+int\n+f3 (int i)\n+{\n+  [[assume (i == 42)]];\n+  return i;\n+}\n+\n+int\n+f4 (int i)\n+{\n+  [[assume (++i == 44)]];\n+  return i;\n+}\n+\n+int a;\n+int *volatile c;\n+\n+bool\n+f5 ()\n+{\n+  ++a;\n+  return true;\n+}\n+\n+constexpr int\n+f6 ()\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[assume (f5 ())]];\n+#endif\n+  return 1;\n+}\n+\n+template <int ...args>\n+bool\n+f7 ()\n+{\n+#if __cpp_fold_expressions >= 201411L\n+  [[assume (((args >= 0) && ...))]];\n+  return ((args >= 0) && ...);\n+#else\n+  return true;\n+#endif\n+}\n+\n+bool\n+f8 (double x)\n+{\n+  [[assume (std::isfinite (x) && x >= 0.0)]];\n+  return std::isfinite (std::sqrt (x));\n+}\n+\n+double\n+f9 (double x)\n+{\n+  [[assume (std::isfinite (std::sqrt (x)))]];\n+  return std::sqrt (x);\n+}\n+\n+template <typename T, T N>\n+T\n+f10 (T x)\n+{\n+  [[assume (x == N)]];\n+  return x;\n+}\n+\n+int\n+f11 (int x)\n+{\n+  [[assume (x == 93 ? true : throw 1)]];\n+  return x;\n+}\n+\n+constexpr int\n+f12 (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[assume (++x == 43)]];\n+#endif\n+  return x;\n+}\n+\n+static_assert (f12 (42) == 42, \"\");\n+\n+struct S\n+{\n+  operator bool () { return true; }\n+};\n+\n+int\n+f13 ()\n+{\n+  S s;\n+  [[assume (s)]];\n+  return 0;\n+}\n+\n+template <typename T>\n+int\n+f14 ()\n+{\n+  T t;\n+  [[assume (t)]];\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  int b = 42;\n+  double d = 42.0, e = 43.0;\n+  c = &b;\n+  [[assume (f5 ())]];\n+  if (a)\n+    std::abort ();\n+  [[assume (++b == 43)]];\n+  if (b != 42 || *c != 42)\n+    std::abort ();\n+  static_assert (f6 () == 1, \"\");\n+  if (f6 () != 1)\n+    std::abort ();\n+  if (a)\n+    std::abort ();\n+  if (!f7 <0> () || !f7 <1, 2, 3, 4> ())\n+    std::abort ();\n+  [[assume (d < e)]];\n+  if (f10 <int, 45> (45) != 45\n+      || f10 <long long, 128LL> (128LL) != 128LL\n+#if __cpp_nontype_template_args >= 201911L\n+      || f10 <long double, -42.0L> (-42.0L) != -42.0L\n+#endif\n+      || false)\n+    std::abort ();\n+  int i = 90, j = 91, k = 92;\n+  [[assume (i == 90), assume (j <= 91)]] [[assume (k >= 92)]];\n+  if (f11 (93) != 93)\n+    std::abort ();\n+  if (f14 <S> () != 0)\n+    std::abort ();\n+}"}, {"sha": "9e54c14974f563e136eda8b8fd148cf32157fc08", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume2.C", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume2.C?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -0,0 +1,83 @@\n+// P1774R8 - Portable assumptions\n+// { dg-do compile { target c++11 } }\n+\n+[[assume (true)]] void f1 ();\t\t// { dg-error \"'assume' attribute ignored\" }\n+typedef int intx [[assume (true)]];\t// { dg-error \"'assume' attribute ignored\" }\n+[[assume (true)]];\t\t\t// { dg-warning \"attribute ignored\" }\n+\n+void\n+foo ()\n+{\n+  int i;\n+  [[assume]];\t\t\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-1 }\n+  [[assume ()]];\t\t\t// { dg-error \"parentheses must be omitted if 'assume' attribute argument list is empty\" }\n+\t\t\t\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t// { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-2 }\n+  [[assume (true, true)]];\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 2\" \"\" { target *-*-* } .-1 }\n+  [[assume (true)]] i = 1;\t\t// { dg-warning \"'assume' attribute not followed by ';'\" }\n+  [[assume (throw 1)]];\t\t\t// { dg-error \"expected primary-expression before 'throw'\" }\n+  [[assume (i = 1)]];\t\t\t// { dg-error \"expected '\\\\\\)' before '=' token\" }\n+}\n+\n+constexpr int\n+f2 (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[assume (x == 42)]];\t\t\t// { dg-error \"failed 'assume' attribute assumption\" \"\" { target c++14 } }\n+#endif\t\t\t\t\t// { dg-message \"the comparison reduces to '\\\\\\(x == 42\\\\\\)'\" \"\" { target c++14 } .-1 }\n+  return x;\n+}\n+\n+constexpr int a = f2 (44);\n+\n+int\n+f3 (int x)\n+{\n+  __asm (\"\" : \"+r\" (x));\n+  return x;\n+}\n+\n+constexpr int\n+f4 (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[assume (f3 (42) == 42)]];\n+#endif\n+  return x;\n+}\n+\n+static_assert (f4 (42) == 42, \"\");\n+\n+struct S {};\n+\n+int\n+f5 ()\n+{\n+  S s;\n+  [[assume (s)]];\t\t\t// { dg-error \"could not convert 's' from 'S' to 'bool'\" }\n+  return 0;\n+}\n+\n+template <typename T>\n+int\n+f6 ()\n+{\n+  T t;\n+  [[assume (t)]];\t\t\t// { dg-error \"could not convert 't' from 'S' to 'bool'\" }\n+  return 0;\n+}\n+\n+int z = f6 <S> ();\n+\n+constexpr int\n+f7 (int x, int y, int z, int w)\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[assume (x == 42 && y == 43 && z == 44 && w == 45)]];\t// { dg-error \"failed 'assume' attribute assumption\" \"\" { target c++14 } }\n+#endif\t\t\t\t\t// { dg-message \"the comparison reduces to '\\\\\\(z == 44\\\\\\)'\" \"\" { target c++14 } .-1 }\n+  return x;\n+}\n+\n+constexpr int w = f7 (42, 43, 45, 44);"}, {"sha": "0be28c7ac8333a404db8596af5cef589dff5283d", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume3.C", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume3.C?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -0,0 +1,198 @@\n+// P1774R8 - Portable assumptions\n+// { dg-do run { target c++11 } }\n+\n+namespace std\n+{\n+  constexpr bool\n+  isfinite (float x)\n+  { return __builtin_isfinite (x); }\n+\n+  constexpr bool\n+  isfinite (double x)\n+  { return __builtin_isfinite (x); }\n+\n+  constexpr bool\n+  isfinite (long double x)\n+  { return __builtin_isfinite (x); }\n+\n+  constexpr float\n+  sqrt (float x)\n+  { return __builtin_sqrtf (x); }\n+\n+  constexpr double\n+  sqrt (double x)\n+  { return __builtin_sqrt (x); }\n+\n+  constexpr long double\n+  sqrt (long double x)\n+  { return __builtin_sqrtl (x); }\n+\n+  extern \"C\" void\n+  abort ();\n+}\n+\n+constexpr int\n+f1 (int i)\n+{\n+#if __cpp_constexpr >= 201603L\n+  auto f = [=] { [[__assume__ (i == 0)]]; };\n+  return sizeof (f);\n+#else\n+  return sizeof (int);\n+#endif\n+}\n+\n+void\n+f2 ()\n+{\n+  static_assert (f1 (0) >= sizeof (int), \"\");\n+}\n+\n+int\n+f3 (int i)\n+{\n+  [[gnu::assume (i == 42)]];\n+  return i;\n+}\n+\n+int\n+f4 (int i)\n+{\n+  __attribute__ ((assume (++i == 44)));\n+  return i;\n+}\n+\n+int a;\n+int *volatile c;\n+\n+bool\n+f5 ()\n+{\n+  ++a;\n+  return true;\n+}\n+\n+constexpr int\n+f6 ()\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[__assume__ (f5 ())]];\n+#endif\n+  return 1;\n+}\n+\n+template <int ...args>\n+bool\n+f7 ()\n+{\n+#if __cpp_fold_expressions >= 201411L\n+  [[__gnu__::__assume__ (((args >= 0) && ...))]];\n+  return ((args >= 0) && ...);\n+#else\n+  return true;\n+#endif\n+}\n+\n+bool\n+f8 (double x)\n+{\n+  [[gnu::assume (std::isfinite (x) && x >= 0.0)]];\n+  return std::isfinite (std::sqrt (x));\n+}\n+\n+double\n+f9 (double x)\n+{\n+  __attribute__((assume (std::isfinite (std::sqrt (x)))));\n+  return std::sqrt (x);\n+}\n+\n+template <typename T, T N>\n+T\n+f10 (T x)\n+{\n+  [[__assume__ (x == N)]];\n+  return x;\n+}\n+\n+int\n+f11 (int x)\n+{\n+  [[gnu::assume (x == 93 ? true : throw 1)]];\n+  return x;\n+}\n+\n+constexpr int\n+f12 (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  __attribute__((assume (++x == 43)));\n+#endif\n+  return x;\n+}\n+\n+static_assert (f12 (42) == 42, \"\");\n+\n+struct S\n+{\n+  operator bool () { return true; }\n+};\n+\n+int\n+f13 ()\n+{\n+  S s;\n+  [[__gnu__::__assume__ (s)]];\n+  return 0;\n+}\n+\n+template <typename T>\n+int\n+f14 ()\n+{\n+  T t;\n+  __attribute__((assume (t)));\n+  return 0;\n+}\n+\n+int\n+main ()\n+{\n+  int b = 42;\n+  double d = 42.0, e = 43.0;\n+  c = &b;\n+  [[__assume__ (f5 ())]];\n+  if (a)\n+    std::abort ();\n+  [[gnu::assume (++b == 43)]];\n+  if (b != 42 || *c != 42)\n+    std::abort ();\n+  static_assert (f6 () == 1, \"\");\n+  if (f6 () != 1)\n+    std::abort ();\n+  if (a)\n+    std::abort ();\n+  if (!f7 <0> () || !f7 <1, 2, 3, 4> ())\n+    std::abort ();\n+  __attribute__((assume (d < e)));\n+  if (f10 <int, 45> (45) != 45\n+      || f10 <long long, 128LL> (128LL) != 128LL\n+#if __cpp_nontype_template_args >= 201911L\n+      || f10 <long double, -42.0L> (-42.0L) != -42.0L\n+#endif\n+      || false)\n+    std::abort ();\n+  int i = 90, j = 91, k = 92;\n+  [[__assume__ (i == 90), gnu::assume (j <= 91)]]\n+#if __cplusplus >= 201703L\n+  [[using gnu:assume (k >= 92)]]\n+#else\n+  [[gnu::assume (k >= 92)]]\n+#endif\n+  ;\n+  __attribute__((__assume__ (i == 90), assume (j <= 91))) __attribute__((assume (k >= 92)));\n+  if (f11 (93) != 93)\n+    std::abort ();\n+  if (f14 <S> () != 0)\n+    std::abort ();\n+}"}, {"sha": "059d47bbd92cfe237e46f74b7375c8e79714df34", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume4.C", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume4.C?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -0,0 +1,136 @@\n+// P1774R8 - Portable assumptions\n+// { dg-do compile { target c++11 } }\n+\n+[[__assume__ (true)]] void f1 ();\t\t// { dg-error \"'assume' attribute ignored\" }\n+typedef int intx [[__assume__ (true)]];\t\t// { dg-error \"'assume' attribute ignored\" }\n+[[__assume__ (true)]];\t\t\t\t// { dg-warning \"attribute ignored\" }\n+[[gnu::assume (true)]] void f1a ();\t\t// { dg-error \"'assume' attribute ignored\" }\n+typedef int inty [[gnu::__assume__ (true)]];\t// { dg-error \"'assume' attribute ignored\" }\n+[[__gnu__::assume (true)]];\t\t\t// { dg-warning \"attribute ignored\" }\n+__attribute__((assume (true))) void f1b ();\t// { dg-error \"'assume' attribute ignored\" }\n+typedef int intz __attribute__((assume (true)));// { dg-error \"'assume' attribute ignored\" }\n+\n+void\n+foo ()\n+{\n+  int i;\n+  [[__assume__]];\t\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-1 }\n+  [[__assume__ ()]];\t\t\t// { dg-error \"parentheses must be omitted if 'assume' attribute argument list is empty\" }\n+\t\t\t\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t// { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-2 }\n+  [[__assume__ (true, true)]];\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 2\" \"\" { target *-*-* } .-1 }\n+  [[__assume__ (true)]] i = 1;\t\t// { dg-warning \"'assume' attribute not followed by ';'\" }\n+  [[__assume__ (throw 1)]];\t\t// { dg-error \"expected primary-expression before 'throw'\" }\n+  [[__assume__ (i = 1)]];\t\t// { dg-error \"expected '\\\\\\)' before '=' token\" }\n+  [[gnu::assume]];\t\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-1 }\n+  [[gnu::assume ()]];\t\t\t// { dg-error \"parentheses must be omitted if 'assume' attribute argument list is empty\" }\n+\t\t\t\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" \"\" { target *-*-* } .-1 }\n+\t\t\t\t\t// { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-2 }\n+  [[gnu::assume (true, true)]];\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 2\" \"\" { target *-*-* } .-1 }\n+  [[gnu::assume (true)]] i = 1;\t\t// { dg-warning \"'assume' attribute not followed by ';'\" }\n+  [[gnu::assume (throw 1)]];\t\t// { dg-error \"expected primary-expression before 'throw'\" }\n+  [[gnu::assume (i = 1)]];\t\t// { dg-error \"expected '\\\\\\)' before '=' token\" }\n+  __attribute__((assume));\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-1 }\n+  __attribute__((assume ()));\t\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-1 }\n+  __attribute__((assume (true, true)));\t// { dg-error \"wrong number of arguments specified for 'assume' attribute\" }\n+\t\t\t\t\t// { dg-message \"expected 1, found 2\" \"\" { target *-*-* } .-1 }\n+  __attribute__((assume (true))) i = 1;\t// { dg-warning \"'assume' attribute not followed by ';'\" }\n+  __attribute__((assume (throw 1)));\t// { dg-error \"expected primary-expression before 'throw'\" }\n+  __attribute__((assume (i = 1)));\t// { dg-error \"expected '\\\\\\)' before '=' token\" }\n+}\n+\n+constexpr int\n+f2 (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[__assume__ (x == 42)]];\t\t// { dg-error \"failed 'assume' attribute assumption\" \"\" { target c++14 } }\n+#endif\n+  return x;\n+}\n+\n+constexpr int\n+f2a (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[gnu::__assume__ (x == 42)]];\t// { dg-error \"failed 'assume' attribute assumption\" \"\" { target c++14 } }\n+#endif\n+  return x;\n+}\n+\n+constexpr int\n+f2b (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  __attribute__((__assume__ (x == 42)));// { dg-error \"failed 'assume' attribute assumption\" \"\" { target c++14 } }\n+#endif\n+  return x;\n+}\n+\n+constexpr int a = f2 (44);\n+constexpr int aa = f2a (44);\n+constexpr int ab = f2b (44);\n+\n+int\n+f3 (int x)\n+{\n+  __asm (\"\" : \"+r\" (x));\n+  return x;\n+}\n+\n+constexpr int\n+f4 (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[__assume__ (f3 (42) == 42)]];\n+#endif\n+  return x;\n+}\n+\n+constexpr int\n+f4a (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  [[gnu::assume (f3 (42) == 42)]];\n+#endif\n+  return x;\n+}\n+\n+constexpr int\n+f4b (int x)\n+{\n+#if __cpp_constexpr >= 201304L\n+  __attribute__((assume (f3 (42) == 42)));\n+#endif\n+  return x;\n+}\n+\n+static_assert (f4 (42) == 42, \"\");\n+static_assert (f4a (42) == 42, \"\");\n+static_assert (f4b (42) == 42, \"\");\n+\n+struct S {};\n+\n+int\n+f5 ()\n+{\n+  S s;\n+  [[gnu::assume (s)]];\t\t\t// { dg-error \"could not convert 's' from 'S' to 'bool'\" }\n+  return 0;\n+}\n+\n+template <typename T>\n+int\n+f6 ()\n+{\n+  T t;\n+  __attribute__((assume (t)));\t\t// { dg-error \"could not convert 't' from 'S' to 'bool'\" }\n+  return 0;\n+}\n+\n+int z = f6 <S> ();"}, {"sha": "efe97703a98dcc6e535e27b9e046b5bd64626d66", "filename": "gcc/testsuite/g++.dg/cpp23/feat-cxx2b.C", "status": "modified", "additions": 51, "deletions": 37, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -422,7 +422,7 @@\n #  error \"__cpp_nontype_template_parameter_auto != 201606\"\n #endif\n \n-// C++20 features\n+// C++20 features:\n \n #ifndef __cpp_conditional_explicit\n #  error \"__cpp_conditional_explicit\"\n@@ -460,6 +460,44 @@\n #  error \"__cpp_aggregate_paren_init != 201902\"\n #endif\n \n+#ifndef __cpp_char8_t\n+#  error \"__cpp_char8_t\"\n+#elif __cpp_char8_t != 202207\n+#  error \"__cpp_char8_t != 202207\"\n+#endif\n+\n+#ifndef __cpp_designated_initializers\n+#  error \"__cpp_designated_initializers\"\n+#elif __cpp_designated_initializers != 201707\n+#  error \"__cpp_designated_initializers != 201707\"\n+#endif\n+\n+#ifndef __cpp_constexpr_in_decltype\n+#  error \"__cpp_constexpr_in_decltype\"\n+#elif __cpp_constexpr_in_decltype != 201711\n+#  error \"__cpp_constexpr_in_decltype != 201711\"\n+#endif\n+\n+#ifndef __cpp_consteval\n+#  error \"__cpp_consteval\"\n+#elif __cpp_consteval != 201811\n+#  error \"__cpp_consteval != 201811\"\n+#endif\n+\n+#ifndef __cpp_concepts\n+#  error \"__cpp_concepts\"\n+#elif __cpp_concepts != 202002\n+#  error \"__cpp_concepts != 202002\"\n+#endif\n+\n+#ifndef __cpp_using_enum\n+#  error \"__cpp_using_enum\"\n+#elif __cpp_using_enum != 201907\n+#  error \"__cpp_using_enum != 201907\"\n+#endif\n+\n+// C++20 attributes:\n+\n #ifdef __has_cpp_attribute\n \n #  if ! __has_cpp_attribute(maybe_unused)\n@@ -502,42 +540,6 @@\n #  error \"__has_cpp_attribute\"\n #endif\n \n-#ifndef __cpp_char8_t\n-#  error \"__cpp_char8_t\"\n-#elif __cpp_char8_t != 202207\n-#  error \"__cpp_char8_t != 202207\"\n-#endif\n-\n-#ifndef __cpp_designated_initializers\n-#  error \"__cpp_designated_initializers\"\n-#elif __cpp_designated_initializers != 201707\n-#  error \"__cpp_designated_initializers != 201707\"\n-#endif\n-\n-#ifndef __cpp_constexpr_in_decltype\n-#  error \"__cpp_constexpr_in_decltype\"\n-#elif __cpp_constexpr_in_decltype != 201711\n-#  error \"__cpp_constexpr_in_decltype != 201711\"\n-#endif\n-\n-#ifndef __cpp_consteval\n-#  error \"__cpp_consteval\"\n-#elif __cpp_consteval != 201811\n-#  error \"__cpp_consteval != 201811\"\n-#endif\n-\n-#ifndef __cpp_concepts\n-#  error \"__cpp_concepts\"\n-#elif __cpp_concepts != 202002\n-#  error \"__cpp_concepts != 202002\"\n-#endif\n-\n-#ifndef __cpp_using_enum\n-#  error \"__cpp_using_enum\"\n-#elif __cpp_using_enum != 201907\n-#  error \"__cpp_using_enum != 201907\"\n-#endif\n-\n // C++23 features:\n \n #ifndef __cpp_size_t_suffix\n@@ -575,3 +577,15 @@\n #elif __cpp_implicit_move != 202207\n #  error \"__cpp_implicit_move != 202207\"\n #endif\n+\n+//  C++23 attributes:\n+\n+#ifdef __has_cpp_attribute\n+#  if ! __has_cpp_attribute(assume)\n+#    error \"__has_cpp_attribute(assume)\"\n+#  elif __has_cpp_attribute(assume) != 202207\n+#    error \"__has_cpp_attribute(assume) != 202207\"\n+#  endif\n+#else\n+#  error \"__has_cpp_attribute\"\n+#endif"}, {"sha": "16bc0b853958d1a9a72f33be4a9deeeab20d65b4", "filename": "gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -422,7 +422,7 @@\n #  error \"__cpp_nontype_template_parameter_auto != 201606\"\n #endif\n \n-// C++20 features\n+// C++20 features:\n \n #ifndef __cpp_conditional_explicit\n #  error \"__cpp_conditional_explicit\"\n@@ -460,6 +460,44 @@\n #  error \"__cpp_aggregate_paren_init != 201902\"\n #endif\n \n+#ifndef __cpp_char8_t\n+#  error \"__cpp_char8_t\"\n+#elif __cpp_char8_t != 202207\n+#  error \"__cpp_char8_t != 202207\"\n+#endif\n+\n+#ifndef __cpp_designated_initializers\n+#  error \"__cpp_designated_initializers\"\n+#elif __cpp_designated_initializers != 201707\n+#  error \"__cpp_designated_initializers != 201707\"\n+#endif\n+\n+#ifndef __cpp_constexpr_in_decltype\n+#  error \"__cpp_constexpr_in_decltype\"\n+#elif __cpp_constexpr_in_decltype != 201711\n+#  error \"__cpp_constexpr_in_decltype != 201711\"\n+#endif\n+\n+#ifndef __cpp_consteval\n+#  error \"__cpp_consteval\"\n+#elif __cpp_consteval != 201811\n+#  error \"__cpp_consteval != 201811\"\n+#endif\n+\n+#ifndef __cpp_concepts\n+#  error \"__cpp_concepts\"\n+#elif __cpp_concepts != 202002\n+#  error \"__cpp_concepts != 202002\"\n+#endif\n+\n+#ifndef __cpp_using_enum\n+#  error \"__cpp_using_enum\"\n+#elif __cpp_using_enum != 201907\n+#  error \"__cpp_using_enum != 201907\"\n+#endif\n+\n+// C++20 attributes:\n+\n #ifdef __has_cpp_attribute\n \n #  if ! __has_cpp_attribute(maybe_unused)\n@@ -501,39 +539,3 @@\n #else\n #  error \"__has_cpp_attribute\"\n #endif\n-\n-#ifndef __cpp_char8_t\n-#  error \"__cpp_char8_t\"\n-#elif __cpp_char8_t != 202207\n-#  error \"__cpp_char8_t != 202207\"\n-#endif\n-\n-#ifndef __cpp_designated_initializers\n-#  error \"__cpp_designated_initializers\"\n-#elif __cpp_designated_initializers != 201707\n-#  error \"__cpp_designated_initializers != 201707\"\n-#endif\n-\n-#ifndef __cpp_constexpr_in_decltype\n-#  error \"__cpp_constexpr_in_decltype\"\n-#elif __cpp_constexpr_in_decltype != 201711\n-#  error \"__cpp_constexpr_in_decltype != 201711\"\n-#endif\n-\n-#ifndef __cpp_consteval\n-#  error \"__cpp_consteval\"\n-#elif __cpp_consteval != 201811\n-#  error \"__cpp_consteval != 201811\"\n-#endif\n-\n-#ifndef __cpp_concepts\n-#  error \"__cpp_concepts\"\n-#elif __cpp_concepts != 202002\n-#  error \"__cpp_concepts != 202002\"\n-#endif\n-\n-#ifndef __cpp_using_enum\n-#  error \"__cpp_using_enum\"\n-#elif __cpp_using_enum != 201907\n-#  error \"__cpp_using_enum != 201907\"\n-#endif"}, {"sha": "16e919ef7bc7de4843cf63709ee6a4dbd64ebe2a", "filename": "gcc/testsuite/gcc.dg/attr-assume-1.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-1.c?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -0,0 +1,69 @@\n+/* Portable assumptions */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c2x\" } */\n+\n+int\n+f1 (int i)\n+{\n+  [[gnu::assume (i == 42)]];\n+  return i;\n+}\n+\n+int\n+f2 (int i)\n+{\n+  __attribute__ ((assume (++i == 44)));\n+  return i;\n+}\n+\n+int a;\n+int *volatile c;\n+\n+int\n+f3 ()\n+{\n+  ++a;\n+  return 1;\n+}\n+\n+int\n+f4 (double x)\n+{\n+  [[gnu::assume (__builtin_isfinite (x) && x >= 0.0)]];\n+  return __builtin_isfinite (__builtin_sqrt (x));\n+}\n+\n+double\n+f5 (double x)\n+{\n+  __attribute__((assume (__builtin_isfinite (__builtin_sqrt (x)))));\n+  return __builtin_sqrt (x);\n+}\n+\n+int\n+f6 (int x)\n+{\n+  [[gnu::assume (x == 93 ? 1 : 0)]];\n+  return x;\n+}\n+\n+int\n+main ()\n+{\n+  int b = 42;\n+  double d = 42.0, e = 43.0;\n+  c = &b;\n+  [[__gnu__::__assume__ (f3 ())]];\n+  if (a)\n+    __builtin_abort ();\n+  [[gnu::assume (++b == 43)]];\n+  if (b != 42 || *c != 42)\n+    __builtin_abort ();\n+  __attribute__((assume (d < e)));\n+  int i = 90, j = 91, k = 92;\n+  [[gnu::__assume__ (i == 90), gnu::assume (j <= 91)]] [[gnu::assume (k >= 92)]]\n+  ;\n+  __attribute__((__assume__ (i == 90), assume (j <= 91))) __attribute__((assume (k >= 92)));\n+  if (f6 (93) != 93)\n+    __builtin_abort ();\n+}"}, {"sha": "aa782e737e3541f5284e0caf1f92aa24c5be99c7", "filename": "gcc/testsuite/gcc.dg/attr-assume-2.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-2.c?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -0,0 +1,66 @@\n+/* Portable assumptions */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x\" } */\n+\n+[[gnu::__assume__ (1)]] void f1 (void);\t/* { dg-warning \"'assume' attribute not followed by ';'\" } */\n+\t\t\t\t\t/* { dg-warning \"'assume' attribute ignored\" \"\" { target *-*-* } .-1 } */\n+typedef int intx [[gnu::assume (1)]];\t/* { dg-warning \"'assume' attribute ignored\" } */\n+[[__gnu__::assume (1)]];\t\t/* { dg-warning \"'assume' attribute at top level\" } */\n+__attribute__((assume (1))) void f1b ();/* { dg-warning \"'assume' attribute not followed by ';'\" } */\n+\t\t\t\t\t/* { dg-warning \"'assume' attribute ignored\" \"\" { target *-*-* } .-1 } */\n+typedef int inty __attribute__((assume (1)));\t/* { dg-warning \"'assume' attribute ignored\" } */\n+\n+void\n+foo ()\n+{\n+  int i;\n+  [[gnu::assume]];\t\t\t/* { dg-error \"wrong number of arguments specified for 'assume' attribute\" } */\n+\t\t\t\t\t/* { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-1 } */\n+  [[gnu::__assume__ ()]];\t\t/* { dg-error \"parentheses must be omitted if attribute argument list is empty\" } */\n+\t\t\t\t\t/* { dg-error \"wrong number of arguments specified for 'assume' attribute\" \"\" { target *-*-* } .-1 } */\n+\t\t\t\t\t/* { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-2 } */\n+  [[gnu::assume (1, 1)]];\t\t/* { dg-error \"wrong number of arguments specified for 'assume' attribute\" } */\n+\t\t\t\t\t/* { dg-message \"expected 1, found 2\" \"\" { target *-*-* } .-1 } */\n+  [[gnu::assume (1)]] i = 1;\t\t/* { dg-warning \"'assume' attribute ignored\" } */\n+  [[gnu::assume (i = 1)]];\t\t/* { dg-error \"expected\" } */\n+\t\t\t\t\t/* { dg-warning \"'assume' attribute ignored\" \"\" { target *-*-* } .-1 } */\n+  __attribute__((assume));\t\t/* { dg-error \"wrong number of arguments specified for 'assume' attribute\" } */\n+\t\t\t\t\t/* { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-1 } */\n+  __attribute__((assume ()));\t\t/* { dg-error \"wrong number of arguments specified for 'assume' attribute\" } */\n+\t\t\t\t\t/* { dg-message \"expected 1, found 0\" \"\" { target *-*-* } .-1 } */\n+  __attribute__((assume (1, 1)));\t/* { dg-error \"wrong number of arguments specified for 'assume' attribute\" } */\n+\t\t\t\t\t/* { dg-message \"expected 1, found 2\" \"\" { target *-*-* } .-1 } */\n+  __attribute__((assume (i = 1)));\t/* { dg-error \"expected\" } */\n+}\n+\n+int\n+f2 (int x)\n+{\n+  __asm (\"\" : \"+r\" (x));\n+  return x;\n+}\n+\n+int\n+f3 (int x)\n+{\n+  [[gnu::assume (f2 (42) == 42)]];\n+  return x;\n+}\n+\n+int\n+f3a (int x)\n+{\n+  __attribute__((assume (f2 (42) == 42)));\n+  return x;\n+}\n+\n+struct S {};\n+\n+int\n+f4 ()\n+{\n+  struct S s;\n+  [[gnu::assume (s)]];\t\t\t/* { dg-error \"used struct type value where scalar is required\" } */\n+  __attribute__((assume (s)));\t\t/* { dg-error \"used struct type value where scalar is required\" } */\n+  return 0;\n+}"}, {"sha": "c611a8f8e7409caa37c5697695d5874afcf4fac1", "filename": "gcc/testsuite/gcc.dg/attr-assume-3.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b51baddc53d64aa4c5e7a81ef3c4bf320293be/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume-3.c?ref=08b51baddc53d64aa4c5e7a81ef3c4bf320293be", "patch": "@@ -0,0 +1,35 @@\n+/* Portable assumptions */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x\" } */\n+\n+void\n+foo (int x)\n+{\n+  if (x == 1)\n+    goto l1;\t\t\t\t\t\t/* { dg-error \"jump into statement expression\" } */\n+  else if (x == 2)\n+    goto l2;\t\t\t\t\t\t/* { dg-error \"jump into statement expression\" } */\n+  else if (x == 3)\n+    goto l3;\t\t\t\t\t\t/* { dg-error \"jump into statement expression\" } */\n+  [[gnu::assume (({ l0:; if (x == 0) goto l0; 1; }))]];\n+  [[gnu::assume (({ if (x == 0) __builtin_abort (); 1; }))]];\n+  [[gnu::assume (({ l1:; 1; }))]];\t\t\t/* { dg-message \"label 'l1' defined here\" } */\n+  [[gnu::assume (({ l2:; 1; }))]];\t\t\t/* { dg-message \"label 'l2' defined here\" } */\n+  __attribute__((assume (({ l3:; 1; }))));\t\t/* { dg-message \"label 'l3' defined here\" } */\n+  [[gnu::assume (({ l4:; 1; }))]];\t\t\t/* { dg-message \"label 'l4' defined here\" } */\n+  [[gnu::assume (({ l5:; 1; }))]];\t\t\t/* { dg-message \"label 'l5' defined here\" } */\n+  __attribute__((assume (({ l6:; 1; }))));\t\t/* { dg-message \"label 'l6' defined here\" } */\n+  switch (x)\t\t\t\t\t\t/* { dg-message \"switch starts here\" } */\n+    {\n+    case 7:\n+      [[gnu::assume (({ case 8:; 1; }))]];\t\t/* { dg-error \"switch jumps into statement expression\" } */\n+      __attribute__((assume (({ default:; 1; }))));\t/* { dg-error \"switch jumps into statement expression\" } */\n+      break;\n+    }\n+  if (x == 4)\n+    goto l4;\t\t\t\t\t\t/* { dg-error \"jump into statement expression\" } */\n+  else if (x == 5)\n+    goto l5;\t\t\t\t\t\t/* { dg-error \"jump into statement expression\" } */\n+  else if (x == 6)\n+    goto l6;\t\t\t\t\t\t/* { dg-error \"jump into statement expression\" } */\n+}"}]}