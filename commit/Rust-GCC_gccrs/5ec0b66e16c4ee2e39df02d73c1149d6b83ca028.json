{"sha": "5ec0b66e16c4ee2e39df02d73c1149d6b83ca028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVjMGI2NmUxNmM0ZWUyZTM5ZGYwMmQ3M2MxMTQ5ZDZiODNjYTAyOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-12-04T23:45:42Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-12-04T23:45:42Z"}, "message": "* config/h8300/h8300.c: Update the comments related to shifts.\n\nFrom-SVN: r59836", "tree": {"sha": "f7dfbc14a201197f6c07b2efa9fdb24514473683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7dfbc14a201197f6c07b2efa9fdb24514473683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ec0b66e16c4ee2e39df02d73c1149d6b83ca028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec0b66e16c4ee2e39df02d73c1149d6b83ca028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ec0b66e16c4ee2e39df02d73c1149d6b83ca028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec0b66e16c4ee2e39df02d73c1149d6b83ca028/comments", "author": null, "committer": null, "parents": [{"sha": "7fa9ed65939e6cf45fec03a62c7868633135a783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fa9ed65939e6cf45fec03a62c7868633135a783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fa9ed65939e6cf45fec03a62c7868633135a783"}], "stats": {"total": 123, "additions": 23, "deletions": 100}, "files": [{"sha": "3d20349e774ce70f9d0d0d9e6a301242e7255d7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec0b66e16c4ee2e39df02d73c1149d6b83ca028/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec0b66e16c4ee2e39df02d73c1149d6b83ca028/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ec0b66e16c4ee2e39df02d73c1149d6b83ca028", "patch": "@@ -1,3 +1,7 @@\n+2002-12-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300.c: Update the comments related to shifts.\n+\n 2002-12-04  Chris Demetriou  <cgd@broadcom.com>\n \n \t* config/mips/mips.md (get_fnaddr): Correct length attribute."}, {"sha": "8451fecc2b11565d40727a21abb49075e2174235", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 19, "deletions": 100, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec0b66e16c4ee2e39df02d73c1149d6b83ca028/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec0b66e16c4ee2e39df02d73c1149d6b83ca028/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=5ec0b66e16c4ee2e39df02d73c1149d6b83ca028", "patch": "@@ -2148,96 +2148,16 @@ compute_logical_op_cc (mode, operands)\n \n    o SHIFT_LOOP: Emit a loop using one (or two on H8S) bit shifts.\n \n-   Here are some thoughts on what the absolutely positively best code\n-   is.  \"Best\" here means some rational trade-off between code size\n-   and speed, where speed is more preferred but not at the expense of\n-   generating 20 insns.\n-\n-   Below, a trailing '*' after the shift count indicates the \"best\"\n-   mode isn't implemented.  We only describe SHIFT_SPECIAL cases to\n-   simplify the table.  For other cases, refer to shift_alg_[qhs]i.\n-\n-   H8/300 QImode shifts\n-   7      - ASHIFTRT: shll, subx (propagate carry bit to all bits)\n-\n-   H8/300 HImode shifts\n-   7      - shift 2nd half other way into carry.\n-\t    copy 1st half into 2nd half\n-\t    rotate 2nd half other way with carry\n-\t    rotate 1st half other way (no carry)\n-\t    mask off bits in 1st half (ASHIFT | LSHIFTRT).\n-\t    sign extend 1st half (ASHIFTRT)\n-   8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n-   9-12   - do shift by 8, inline remaining shifts\n-   15     - ASHIFTRT: shll, subx, set other byte\n-\n-   H8/300 SImode shifts\n-   7*     - shift other way once, move bytes into place,\n-            move carry into place (possibly with sign extension)\n-   8      - move bytes into place, zero or sign extend other\n-   15*    - shift other way once, move word into place, move carry into place\n-   16     - move word, zero or sign extend other\n-   24*    - move bytes into place, zero or sign extend other\n-   31     - ASHIFTRT: shll top byte, subx, copy to other bytes\n-\n-   H8/300H QImode shifts (same as H8/300 QImode shifts)\n-   7      - ASHIFTRT: shll, subx (propagate carry bit to all bits)\n-\n-   H8/300H HImode shifts\n-   7      - shift 2nd half other way into carry.\n-\t    copy 1st half into 2nd half\n-\t    rotate entire word other way using carry\n-\t    mask off remaining bits  (ASHIFT | LSHIFTRT)\n-\t    sign extend remaining bits (ASHIFTRT)\n-   8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n-   9-12   - do shift by 8, inline remaining shifts\n-   15     - ASHIFTRT: shll, subx, set other byte\n-\n-   H8/300H SImode shifts\n-   (These are complicated by the fact that we don't have byte level access to\n-   the top word.)\n-   A word is: bytes 3,2,1,0 (msb -> lsb), word 1,0 (msw -> lsw)\n-   15*    - shift other way once, move word into place, move carry into place\n-            (with sign extension for ASHIFTRT)\n-   16     - move word into place, zero or sign extend other\n-   17-20  - do 16bit shift, then inline remaining shifts\n-   24*    - ASHIFT: move byte 0(msb) to byte 1, zero byte 0,\n-                    move word 0 to word 1, zero word 0\n-            LSHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n-                      zero word 1, zero byte 1\n-            ASHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n-                      sign extend byte 0, sign extend word 0\n-   25-27* - either loop, or\n-            do 24 bit shift, inline rest\n-   31     - shll, subx byte 0, sign extend byte 0, sign extend word 0\n-\n-   H8S QImode shifts\n-   7      - ASHIFTRT: shll, subx (propagate carry bit to all bits)\n-\n-   H8S HImode shifts\n-   8      - move byte, zero (ASHIFT | LSHIFTRT) or sign extend other (ASHIFTRT)\n-   9-12   - do shift by 8, inline remaining shifts\n-   15     - ASHIFTRT: shll, subx, set other byte\n-\n-   H8S SImode shifts\n-   (These are complicated by the fact that we don't have byte level access to\n-   the top word.)\n-   A word is: bytes 3,2,1,0 (msb -> lsb), word 1,0 (msw -> lsw)\n-   15*    - shift other way once, move word into place, move carry into place\n-            (with sign extension for ASHIFTRT)\n-   16     - move word into place, zero or sign extend other\n-   17-20  - do 16bit shift, then inline remaining shifts\n-   24*    - ASHIFT: move byte 0(msb) to byte 1, zero byte 0,\n-                    move word 0 to word 1, zero word 0\n-            LSHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n-                      zero word 1, zero byte 1\n-            ASHIFTRT: move word 1 to word 0, move byte 1 to byte 0,\n-                      sign extend byte 0, sign extend word 0\n-   25-27* - either loop, or\n-            do 24 bit shift, inline rest\n-   31     - shll, subx byte 0, sign extend byte 0, sign extend word 0\n-\n-   Panic!!!  */\n+   For each shift count, we try to use code that has no trade-off\n+   between code size and speed whenever possible.\n+\n+   If the trade-off is unavoidable, we try to be reasonable.\n+   Specifically, the fastest version is one instruction longer than\n+   the shortest version, we take the fastest version.  We also provide\n+   the use a way to switch back to the shortest version with -Os.\n+\n+   For the details of the shift algorithms for various shift counts,\n+   refer to shift_alg_[qhs]i.  */\n \n int\n nshift_operator (x, mode)\n@@ -2474,16 +2394,15 @@ static void get_shift_alg PARAMS ((enum shift_type,\n \n /* Given SHIFT_TYPE, SHIFT_MODE, and shift count COUNT, determine the\n    best algorithm for doing the shift.  The assembler code is stored\n-   in the pointers in INFO.  We don't achieve maximum efficiency in\n-   all cases, but the hooks are here to do so.\n-\n-   For now we just use lots of switch statements.  Since we don't even come\n-   close to supporting all the cases, this is simplest.  If this function ever\n-   gets too big, perhaps resort to a more table based lookup.  Of course,\n-   at this point you may just wish to do it all in rtl.\n-\n-   WARNING: The constraints on insns shiftbyn_QI/HI/SI assume shifts of\n-   1,2,3,4 will be inlined (1,2 for SI).  */\n+   in the pointers in INFO.  We achieve the maximum efficiency in most\n+   cases when !TARGET_H8300.  In case of TARGET_H8300, shifts in\n+   SImode in particular have a lot of room to optimize.\n+\n+   We first determine the strategy of the shift algorithm by a table\n+   lookup.  If that tells us to use a hand crafted assembly code, we\n+   go into the big switch statement to find what that is.  Otherwise,\n+   we resort to a generic way, such as inlining.  In either case, the\n+   result is returned through INFO.  */\n \n static void\n get_shift_alg (shift_type, shift_mode, count, info)"}]}