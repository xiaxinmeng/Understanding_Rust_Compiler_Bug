{"sha": "846428f11f50136baccab7c761e8f3e9793a4bda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ2NDI4ZjExZjUwMTM2YmFjY2FiN2M3NjFlOGYzZTk3OTNhNGJkYQ==", "commit": {"author": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2009-12-24T19:53:57Z"}, "committer": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2009-12-24T19:53:57Z"}, "message": "PR target/35013, 27192\n\n2009-12-24  Andy Hutchinson  <hutchinsonandy@gcc.gnu.org>\n\n\tPR target/35013, 27192\n\t* config/avr/avr.c (print_operand_address): Print correct program\n\tmemory address.\n\tAdd warning for large device offset addresses.\n\t(avr_assemble_integer): Ditto.\n\t(print_operand): Add warnings for incorrect addressing.\n\t(out_movqi_r_mr): Tag assembler with new address codes.\n\t(out_movhi_r_mr): Ditto.\n\t(out_movsi_r_mr): Ditto.\n\t(out_movqi_mr_r): Ditto.\n\t(out_movhi_mr_r): Ditto.\n\t(out_movsi_mr_r): Ditto.\n\t* config/avr/predicates.md (text_segment_operand): New predicate.\n\t* config/avr/avr.md (jump): Tag assembler with new address codes.\n\t(call_insn): Ditto.\n\t(call_value_insn): Ditto.\n\t(*tablejump_lib): Ditto.\n\t(*cbi): Ditto.\n\t(*sbi): Ditto.\n\t(indirect_jump): New define_expand.\n\t(jcindirect_jump): New pattern for constant expression jump.\n\t(njcindirect_jump): Renamed old indirect_jump.\n\nFrom-SVN: r155459", "tree": {"sha": "a541b901f2c02ec4f7faee44f3966ad8a1406b71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a541b901f2c02ec4f7faee44f3966ad8a1406b71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/846428f11f50136baccab7c761e8f3e9793a4bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/846428f11f50136baccab7c761e8f3e9793a4bda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/846428f11f50136baccab7c761e8f3e9793a4bda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/846428f11f50136baccab7c761e8f3e9793a4bda/comments", "author": null, "committer": null, "parents": [{"sha": "a1b418cb9ff3805dadc1b140f96ad545484618ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b418cb9ff3805dadc1b140f96ad545484618ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1b418cb9ff3805dadc1b140f96ad545484618ad"}], "stats": {"total": 198, "additions": 153, "deletions": 45}, "files": [{"sha": "786021818a6d434d92135fdcbaf655f84547ffe3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/846428f11f50136baccab7c761e8f3e9793a4bda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/846428f11f50136baccab7c761e8f3e9793a4bda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=846428f11f50136baccab7c761e8f3e9793a4bda", "patch": "@@ -1,3 +1,28 @@\n+2009-12-24  Andy Hutchinson  <hutchinsonandy@gcc.gnu.org>\n+\n+\tPR target/35013, 27192\n+\t* config/avr/avr.c (print_operand_address): Print correct program\n+\tmemory address.\n+\tAdd warning for large device offset addresses.\n+\t(avr_assemble_integer): Ditto.\n+\t(print_operand): Add warnings for incorrect addressing.\n+\t(out_movqi_r_mr): Tag assembler with new address codes.\n+\t(out_movhi_r_mr): Ditto.\n+\t(out_movsi_r_mr): Ditto.\n+\t(out_movqi_mr_r): Ditto.\n+\t(out_movhi_mr_r): Ditto.\n+\t(out_movsi_mr_r): Ditto.\n+\t* config/avr/predicates.md (text_segment_operand): New predicate.\n+\t* config/avr/avr.md (jump): Tag assembler with new address codes.\n+\t(call_insn): Ditto.\n+\t(call_value_insn): Ditto.\n+\t(*tablejump_lib): Ditto.\n+\t(*cbi): Ditto.\n+\t(*sbi): Ditto.\n+\t(indirect_jump): New define_expand.\n+\t(jcindirect_jump): New pattern for constant expression jump.\n+\t(njcindirect_jump): Renamed old indirect_jump.\n+\n 2009-12-24  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* store-motion.c (build_store_vectors): Clear regs_set_in_block at"}, {"sha": "eff2179b93d62b233d74fb0c37d3e973105bfe13", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 75, "deletions": 37, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/846428f11f50136baccab7c761e8f3e9793a4bda/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/846428f11f50136baccab7c761e8f3e9793a4bda/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=846428f11f50136baccab7c761e8f3e9793a4bda", "patch": "@@ -1176,12 +1176,33 @@ print_operand_address (FILE *file, rtx addr)\n \n     default:\n       if (CONSTANT_ADDRESS_P (addr)\n-\t  && ((GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (addr))\n-\t      || GET_CODE (addr) == LABEL_REF))\n+\t  && text_segment_operand (addr, VOIDmode))\n \t{\n-\t  fprintf (file, \"gs(\");\n-\t  output_addr_const (file,addr);\n-\t  fprintf (file ,\")\");\n+\t  rtx x = XEXP (addr,0);\n+\t  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x,1)) == CONST_INT)\n+\t    {\n+\t      /* Assembler gs() will implant word address. Make offset \n+\t\t a byte offset inside gs() for assembler. This is \n+\t\t needed because the more logical (constant+gs(sym)) is not \n+\t\t accepted by gas. For 128K and lower devices this is ok. For\n+\t\t large devices it will create a Trampoline to offset from symbol \n+\t\t which may not be what the user really wanted.  */\n+\t      fprintf (file, \"gs(\");\n+\t      output_addr_const (file, XEXP (x,0));\n+\t      fprintf (file,\"+\" HOST_WIDE_INT_PRINT_DEC \")\", 2 * INTVAL (XEXP (x,1)));\n+\t      if (AVR_3_BYTE_PC)\n+\t        if (warning ( 0, \"Pointer offset from symbol maybe incorrect.\"))\n+\t\t  {\n+\t\t    output_addr_const (stderr, addr);\n+\t\t    fprintf(stderr,\"\\n\");\n+\t\t  }\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (file, \"gs(\");\n+\t      output_addr_const (file, addr);\n+\t      fprintf (file, \")\");\n+\t    }\n \t}\n       else\n \toutput_addr_const (file, addr);\n@@ -1221,12 +1242,18 @@ print_operand (FILE *file, rtx x, int code)\n   else if (GET_CODE (x) == MEM)\n     {\n       rtx addr = XEXP (x,0);\n-\n-      if (CONSTANT_P (addr) && abcd)\n+      if (code == 'm')\n \t{\n-\t  fputc ('(', file);\n-\t  output_address (addr);\n-\t  fprintf (file, \")+%d\", abcd);\n+\t   if (!CONSTANT_P (addr))\n+\t    fatal_insn (\"bad address, not a constant):\", addr);\n+\t  /* Assembler template with m-code is data - not progmem section */\n+\t  if (text_segment_operand (addr, VOIDmode))\n+\t    if (warning ( 0, \"accessing data memory with program memory address\"))\n+\t      {\n+\t\toutput_addr_const (stderr, addr);\n+\t\tfprintf(stderr,\"\\n\");\n+\t      }\n+\t  output_addr_const (file, addr);\n \t}\n       else if (code == 'o')\n \t{\n@@ -1257,6 +1284,18 @@ print_operand (FILE *file, rtx x, int code)\n       else\n \tprint_operand_address (file, addr);\n     }\n+  else if (code == 'x')\n+    {\n+      /* Constant progmem address - like used in jmp or call */\n+      if (0 == text_segment_operand (x, VOIDmode))\n+\t    if (warning ( 0, \"accessing program  memory with data memory address\"))\n+\t  {\n+\t    output_addr_const (stderr, x);\n+\t    fprintf(stderr,\"\\n\");\n+\t  }\n+      /* Use normal symbol for direct address no linker trampoline needed */\n+      output_addr_const (file, x);\n+    }\n   else if (GET_CODE (x) == CONST_DOUBLE)\n     {\n       long val;\n@@ -1874,10 +1913,10 @@ out_movqi_r_mr (rtx insn, rtx op[], int *l)\n       if (optimize > 0 && io_address_operand (x, QImode))\n \t{\n \t  *l = 1;\n-\t  return AS2 (in,%0,%1-0x20);\n+\t  return AS2 (in,%0,%m1-0x20);\n \t}\n       *l = 2;\n-      return AS2 (lds,%0,%1);\n+      return AS2 (lds,%0,%m1);\n     }\n   /* memory access by reg+disp */\n   else if (GET_CODE (x) == PLUS\n@@ -2062,12 +2101,12 @@ out_movhi_r_mr (rtx insn, rtx op[], int *l)\n       if (optimize > 0 && io_address_operand (base, HImode))\n \t{\n \t  *l = 2;\n-\t  return (AS2 (in,%A0,%A1-0x20) CR_TAB\n-\t\t  AS2 (in,%B0,%B1-0x20));\n+\t  return (AS2 (in,%A0,%m1-0x20) CR_TAB\n+\t\t  AS2 (in,%B0,%m1+1-0x20));\n \t}\n       *l = 4;\n-      return (AS2 (lds,%A0,%A1) CR_TAB\n-\t      AS2 (lds,%B0,%B1));\n+      return (AS2 (lds,%A0,%m1) CR_TAB\n+\t      AS2 (lds,%B0,%m1+1));\n     }\n   \n   fatal_insn (\"unknown move insn:\",insn);\n@@ -2226,10 +2265,10 @@ out_movsi_r_mr (rtx insn, rtx op[], int *l)\n \t\t  AS2 (ld,%C0,%1) CR_TAB\n \t\t  AS2 (ld,%D0,%1));\n   else if (CONSTANT_ADDRESS_P (base))\n-      return *l=8, (AS2 (lds,%A0,%A1) CR_TAB\n-\t\t    AS2 (lds,%B0,%B1) CR_TAB\n-\t\t    AS2 (lds,%C0,%C1) CR_TAB\n-\t\t    AS2 (lds,%D0,%D1));\n+      return *l=8, (AS2 (lds,%A0,%m1) CR_TAB\n+\t\t    AS2 (lds,%B0,%m1+1) CR_TAB\n+\t\t    AS2 (lds,%C0,%m1+2) CR_TAB\n+\t\t    AS2 (lds,%D0,%m1+3));\n     \n   fatal_insn (\"unknown move insn:\",insn);\n   return \"\";\n@@ -2249,10 +2288,10 @@ out_movsi_mr_r (rtx insn, rtx op[], int *l)\n     l = &tmp;\n   \n   if (CONSTANT_ADDRESS_P (base))\n-    return *l=8,(AS2 (sts,%A0,%A1) CR_TAB\n-\t\t AS2 (sts,%B0,%B1) CR_TAB\n-\t\t AS2 (sts,%C0,%C1) CR_TAB\n-\t\t AS2 (sts,%D0,%D1));\n+    return *l=8,(AS2 (sts,%m0,%A1) CR_TAB\n+\t\t AS2 (sts,%m0+1,%B1) CR_TAB\n+\t\t AS2 (sts,%m0+2,%C1) CR_TAB\n+\t\t AS2 (sts,%m0+3,%D1));\n   if (reg_base > 0)                 /* (r) */\n     {\n       if (reg_base == REG_X)                /* (R26) */\n@@ -2562,10 +2601,10 @@ out_movqi_mr_r (rtx insn, rtx op[], int *l)\n       if (optimize > 0 && io_address_operand (x, QImode))\n \t{\n \t  *l = 1;\n-\t  return AS2 (out,%0-0x20,%1);\n+\t  return AS2 (out,%m0-0x20,%1);\n \t}\n       *l = 2;\n-      return AS2 (sts,%0,%1);\n+      return AS2 (sts,%m0,%1);\n     }\n   /* memory access by reg+disp */\n   else if (GET_CODE (x) == PLUS\t\n@@ -2641,11 +2680,11 @@ out_movhi_mr_r (rtx insn, rtx op[], int *l)\n       if (optimize > 0 && io_address_operand (base, HImode))\n \t{\n \t  *l = 2;\n-\t  return (AS2 (out,%B0-0x20,%B1) CR_TAB\n-\t\t  AS2 (out,%A0-0x20,%A1));\n+\t  return (AS2 (out,%m0+1-0x20,%B1) CR_TAB\n+\t\t  AS2 (out,%m0-0x20,%A1));\n \t}\n-      return *l = 4, (AS2 (sts,%B0,%B1) CR_TAB\n-\t\t      AS2 (sts,%A0,%A1));\n+      return *l = 4, (AS2 (sts,%m0+1,%B1) CR_TAB\n+\t\t      AS2 (sts,%m0,%A1));\n     }\n   if (reg_base > 0)\n     {\n@@ -4502,8 +4541,7 @@ static bool\n avr_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   if (size == POINTER_SIZE / BITS_PER_UNIT && aligned_p\n-      && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (x))\n-\t  || GET_CODE (x) == LABEL_REF))\n+      && text_segment_operand (x, VOIDmode) )\n     {\n       fputs (\"\\t.word\\tgs(\", asm_out_file);\n       output_addr_const (asm_out_file, x);\n@@ -5944,13 +5982,13 @@ avr_out_sbxx_branch (rtx insn, rtx operands[])\n       if (INTVAL (operands[1]) < 0x40)\n \t{\n \t  if (comp == EQ)\n-\t    output_asm_insn (AS2 (sbis,%1-0x20,%2), operands);\n+\t    output_asm_insn (AS2 (sbis,%m1-0x20,%2), operands);\n \t  else\n-\t    output_asm_insn (AS2 (sbic,%1-0x20,%2), operands);\n+\t    output_asm_insn (AS2 (sbic,%m1-0x20,%2), operands);\n \t}\n       else\n \t{\n-\t  output_asm_insn (AS2 (in,__tmp_reg__,%1-0x20), operands);\n+\t  output_asm_insn (AS2 (in,__tmp_reg__,%m1-0x20), operands);\n \t  if (comp == EQ)\n \t    output_asm_insn (AS2 (sbrs,__tmp_reg__,%2), operands);\n \t  else\n@@ -5979,9 +6017,9 @@ avr_out_sbxx_branch (rtx insn, rtx operands[])\n \n   if (long_jump)\n     return (AS1 (rjmp,.+4) CR_TAB\n-\t    AS1 (jmp,%3));\n+\t    AS1 (jmp,%x3));\n   if (!reverse)\n-    return AS1 (rjmp,%3);\n+    return AS1 (rjmp,%x3);\n   return \"\";\n }\n "}, {"sha": "f0e59eb6ef4651f60e9b95b8692a98ae1bca997e", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/846428f11f50136baccab7c761e8f3e9793a4bda/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/846428f11f50136baccab7c761e8f3e9793a4bda/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=846428f11f50136baccab7c761e8f3e9793a4bda", "patch": "@@ -28,9 +28,11 @@\n ;;  D  Add 3.\n ;;  j  Branch condition.\n ;;  k  Reverse branch condition.\n+;;..m..Constant Direct Data memory address.\n ;;  o  Displacement for (mem (plus (reg) (const_int))) operands.\n ;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)\n ;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)\n+;;..x..Constant Direct Program memory address.\n ;;  ~  Output 'r' if not AVR_HAVE_JMP_CALL.\n ;;  !  Output 'e' if AVR_HAVE_EIJMP_EICALL.\n \n@@ -2732,8 +2734,8 @@\n   \"\"\n   \"*{\n   if (AVR_HAVE_JMP_CALL && get_attr_length (insn) != 1)\n-    return AS1 (jmp,%0);\n-  return AS1 (rjmp,%0);\n+    return AS1 (jmp,%x0);\n+  return AS1 (rjmp,%x0);\n }\"\n   [(set (attr \"length\")\n \t(if_then_else (match_operand 0 \"symbol_ref_operand\" \"\")\t\n@@ -2785,7 +2787,7 @@\n \t\t\\\"%!icall\\\");\n     }\n   else if (which_alternative==2)\n-    return AS1(%~call,%c0);\n+    return AS1(%~call,%x0);\n   return (AS2 (ldi,r30,lo8(%0)) CR_TAB\n           AS2 (ldi,r31,hi8(%0)) CR_TAB\n           \\\"%!icall\\\");\n@@ -2822,7 +2824,7 @@\n \t\t\\\"%!icall\\\");\n     }\n   else if (which_alternative==2)\n-    return AS1(%~call,%c1);\n+    return AS1(%~call,%x1);\n   return (AS2 (ldi, r30, lo8(%1)) CR_TAB\n           AS2 (ldi, r31, hi8(%1)) CR_TAB\n           \\\"%!icall\\\");\n@@ -2846,7 +2848,27 @@\n    (set_attr \"length\" \"1\")])\n \n ; indirect jump\n-(define_insn \"indirect_jump\"\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand:HI 0 \"nonmemory_operand\" \"\"))]\n+  \"\"\n+  \" if ((!AVR_HAVE_JMP_CALL) && !register_operand(operand0, HImode))\n+    {\n+      operands[0] = copy_to_mode_reg(HImode, operand0);\n+    }\"\n+)\n+\n+; indirect jump\n+(define_insn \"*jcindirect_jump\"\n+  [(set (pc) (match_operand:HI 0 \"immediate_operand\" \"i\"))]\n+  \"\"\n+  \"@\n+  \t%~jmp %x0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n+;;\n+(define_insn \"*njcindirect_jump\"\n   [(set (pc) (match_operand:HI 0 \"register_operand\" \"!z,*r\"))]\n   \"!AVR_HAVE_EIJMP_EICALL\"\n   \"@\n@@ -2884,7 +2906,7 @@\n    (use (label_ref (match_operand 1 \"\" \"\")))\n    (clobber (match_dup 0))]\n   \"AVR_HAVE_JMP_CALL && TARGET_CALL_PROLOGUES\"\n-  \"jmp __tablejump2__\"\n+  \"%~jmp __tablejump2__\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"clobber\")])\n \n@@ -2967,7 +2989,7 @@\n   \"(optimize > 0)\"\n {\n   operands[2] = GEN_INT (exact_log2 (~INTVAL (operands[1]) & 0xff));\n-  return AS2 (cbi,%0-0x20,%2);\n+  return AS2 (cbi,%m0-0x20,%2);\n }\n   [(set_attr \"length\" \"1\")\n    (set_attr \"cc\" \"none\")])\n@@ -2979,7 +3001,7 @@\n   \"(optimize > 0)\"\n {\n   operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1]) & 0xff));\n-  return AS2 (sbi,%0-0x20,%2);\n+  return AS2 (sbi,%m0-0x20,%2);\n }\n   [(set_attr \"length\" \"1\")\n    (set_attr \"cc\" \"none\")])"}, {"sha": "9a3473bf88f549114ca8269bb551872e02eaee33", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/846428f11f50136baccab7c761e8f3e9793a4bda/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/846428f11f50136baccab7c761e8f3e9793a4bda/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=846428f11f50136baccab7c761e8f3e9793a4bda", "patch": "@@ -71,6 +71,29 @@\n (define_predicate \"symbol_ref_operand\"\n   (match_code \"symbol_ref\"))\n \n+;; Return true if OP is a text segment reference.\n+;; This is needed for program memory address expressions.\n+(define_predicate \"text_segment_operand\"\n+  (match_code \"code_label,label_ref,symbol_ref,plus,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CODE_LABEL:\n+      return true;\n+    case LABEL_REF :\n+      return true;\n+    case SYMBOL_REF :\n+      return SYMBOL_REF_FUNCTION_P (op);\n+    case PLUS :\n+      /* Assume canonical format of symbol + constant.\n+\t Fall through.  */\n+    case CONST :\n+      return text_segment_operand (XEXP (op, 0), VOIDmode);\n+    default :\n+      return false;\n+    }\n+})\n+\n ;; Return true if OP is a constant that contains only one 1 in its\n ;; binary representation.\n (define_predicate \"single_one_operand\""}]}