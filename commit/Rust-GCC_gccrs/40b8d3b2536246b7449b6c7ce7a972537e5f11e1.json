{"sha": "40b8d3b2536246b7449b6c7ce7a972537e5f11e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiOGQzYjI1MzYyNDZiNzQ0OWI2YzdjZTdhOTcyNTM3ZTVmMTFlMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2018-12-28T03:43:26Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2018-12-28T03:43:26Z"}, "message": "[libbacktrace] Fix memory leak in loop in build_address_map\n\nWhen failing in build_address_map, we free the unit that's currently being\nhandled in the loop, but the ones that already have been allocated are leaked.\n\nFix this by keeping track of allocated units in a vector, and releasing them\nupon failure.\n\nAlso, now that we have a vector of allocated units, move the freeing upon\nfailure of the abbrevs associated with each unit to build_address_map, and\nremove the now redundant call to free_unit_addrs_vector.\n\nBootstrapped and reg-tested on x86_64.\n\n2018-12-28  Ian Lance Taylor  <iant@golang.org>\n\t    Tom de Vries  <tdevries@suse.de>\n\n\tPR libbacktrace/88063\n\t* dwarf.c (free_unit_addrs_vector): Remove.\n\t(build_address_map): Keep track of allocated units in vector.  Free\n\tallocated units and corresponding abbrevs upon failure.  Remove now\n\tredundant call to free_unit_addrs_vector.  Free addrs vector upon\n\tfailure.  Free allocated unit vector.\n\nCo-Authored-By: Tom de Vries <tdevries@suse.de>\n\nFrom-SVN: r267443", "tree": {"sha": "cc1452c21352d3d57cf000f1eb44f626d7a9f40e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc1452c21352d3d57cf000f1eb44f626d7a9f40e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40b8d3b2536246b7449b6c7ce7a972537e5f11e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b8d3b2536246b7449b6c7ce7a972537e5f11e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b8d3b2536246b7449b6c7ce7a972537e5f11e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b8d3b2536246b7449b6c7ce7a972537e5f11e1/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53a52133a5fc74d63ce17b328774706bf1e79e02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53a52133a5fc74d63ce17b328774706bf1e79e02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53a52133a5fc74d63ce17b328774706bf1e79e02"}], "stats": {"total": 70, "additions": 44, "deletions": 26}, "files": [{"sha": "27a0f429331f0b05af3cfc7e2eaddc27a9fbb3c6", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b8d3b2536246b7449b6c7ce7a972537e5f11e1/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b8d3b2536246b7449b6c7ce7a972537e5f11e1/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=40b8d3b2536246b7449b6c7ce7a972537e5f11e1", "patch": "@@ -1,3 +1,13 @@\n+2018-12-28  Ian Lance Taylor  <iant@golang.org>\n+\t    Tom de Vries  <tdevries@suse.de>\n+\n+\tPR libbacktrace/88063\n+\t* dwarf.c (free_unit_addrs_vector): Remove.\n+\t(build_address_map): Keep track of allocated units in vector.  Free\n+\tallocated units and corresponding abbrevs upon failure.  Remove now\n+\tredundant call to free_unit_addrs_vector.  Free addrs vector upon\n+\tfailure.  Free allocated unit vector.\n+\n 2018-12-28  Tom de Vries  <tdevries@suse.de>\n \n \t* dwarf.c (build_address_map): Free addrs vector upon failure."}, {"sha": "f3499a9f45a6021c39cfce9696aa6846a1aa0b08", "filename": "libbacktrace/dwarf.c", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b8d3b2536246b7449b6c7ce7a972537e5f11e1/libbacktrace%2Fdwarf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b8d3b2536246b7449b6c7ce7a972537e5f11e1/libbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fdwarf.c?ref=40b8d3b2536246b7449b6c7ce7a972537e5f11e1", "patch": "@@ -923,21 +923,6 @@ add_unit_addr (struct backtrace_state *state, uintptr_t base_address,\n   return 1;\n }\n \n-/* Free a unit address vector.  */\n-\n-static void\n-free_unit_addrs_vector (struct backtrace_state *state,\n-\t\t\tstruct unit_addrs_vector *vec,\n-\t\t\tbacktrace_error_callback error_callback, void *data)\n-{\n-  struct unit_addrs *addrs;\n-  size_t i;\n-\n-  addrs = (struct unit_addrs *) vec->vec.base;\n-  for (i = 0; i < vec->count; ++i)\n-    free_abbrevs (state, &addrs[i].u->abbrevs, error_callback, data);\n-}\n-\n /* Compare unit_addrs for qsort.  When ranges are nested, make the\n    smallest one sort last.  */\n \n@@ -1448,6 +1433,10 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n {\n   struct dwarf_buf info;\n   struct abbrevs abbrevs;\n+  struct backtrace_vector units;\n+  size_t units_count;\n+  size_t i;\n+  struct unit **pu;\n \n   memset (&addrs->vec, 0, sizeof addrs->vec);\n   addrs->count = 0;\n@@ -1465,6 +1454,9 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n   info.data = data;\n   info.reported_underflow = 0;\n \n+  memset (&units, 0, sizeof units);\n+  units_count = 0;\n+\n   memset (&abbrevs, 0, sizeof abbrevs);\n   while (info.left > 0)\n     {\n@@ -1503,10 +1495,20 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \n       addrsize = read_byte (&unit_buf);\n \n+      pu = ((struct unit **)\n+\t    backtrace_vector_grow (state, sizeof (struct unit *),\n+\t\t\t\t   error_callback, data, &units));\n+      if (pu == NULL)\n+\t  goto fail;\n+\n       u = ((struct unit *)\n \t   backtrace_alloc (state, sizeof *u, error_callback, data));\n       if (u == NULL)\n \tgoto fail;\n+\n+      *pu = u;\n+      ++units_count;\n+\n       u->unit_data = unit_buf.buf;\n       u->unit_data_len = unit_buf.left;\n       u->unit_data_offset = unit_buf.buf - unit_data_start;\n@@ -1531,27 +1533,33 @@ build_address_map (struct backtrace_state *state, uintptr_t base_address,\n \t\t\t\tdwarf_ranges, dwarf_ranges_size,\n \t\t\t\tis_bigendian, error_callback, data,\n \t\t\t\tu, addrs))\n-\t{\n-\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n-\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n-\t  goto fail;\n-\t}\n+\tgoto fail;\n \n       if (unit_buf.reported_underflow)\n-\t{\n-\t  free_abbrevs (state, &u->abbrevs, error_callback, data);\n-\t  backtrace_free (state, u, sizeof *u, error_callback, data);\n-\t  goto fail;\n-\t}\n+\tgoto fail;\n     }\n   if (info.reported_underflow)\n     goto fail;\n \n+  // We only kept the list of units to free them on failure.  On\n+  // success the units are retained, pointed to by the entries in\n+  // addrs.\n+  backtrace_vector_free (state, &units, error_callback, data);\n+\n   return 1;\n \n  fail:\n+  if (units_count > 0)\n+    {\n+      pu = (struct unit **) units.base;\n+      for (i = 0; i < units_count; i++)\n+\t{\n+\t  free_abbrevs (state, &pu[i]->abbrevs, error_callback, data);\n+\t  backtrace_free (state, pu[i], sizeof **pu, error_callback, data);\n+\t}\n+      backtrace_vector_free (state, &units, error_callback, data);\n+    }\n   free_abbrevs (state, &abbrevs, error_callback, data);\n-  free_unit_addrs_vector (state, addrs, error_callback, data);\n   if (addrs->count > 0)\n     {\n       backtrace_vector_free (state, &addrs->vec, error_callback, data);"}]}