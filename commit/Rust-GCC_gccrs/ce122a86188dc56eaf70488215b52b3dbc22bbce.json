{"sha": "ce122a86188dc56eaf70488215b52b3dbc22bbce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxMjJhODYxODhkYzU2ZWFmNzA0ODgyMTViNTJiM2RiYzIyYmJjZQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-17T17:08:27Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-17T17:08:27Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r12008", "tree": {"sha": "59ea69ac1a94bb1aa0024e358f2e3c91cc814c5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59ea69ac1a94bb1aa0024e358f2e3c91cc814c5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce122a86188dc56eaf70488215b52b3dbc22bbce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce122a86188dc56eaf70488215b52b3dbc22bbce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce122a86188dc56eaf70488215b52b3dbc22bbce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce122a86188dc56eaf70488215b52b3dbc22bbce/comments", "author": null, "committer": null, "parents": [{"sha": "5f2d9b40eb904ff871e398356fd949a7fd06ade7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2d9b40eb904ff871e398356fd949a7fd06ade7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2d9b40eb904ff871e398356fd949a7fd06ade7"}], "stats": {"total": 159, "additions": 85, "deletions": 74}, "files": [{"sha": "f0dd601c72a8bce96639c2d528f0d3522475c64e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ce122a86188dc56eaf70488215b52b3dbc22bbce", "patch": "@@ -3,6 +3,31 @@ Sat May 11 04:33:50 1996  Doug Evans  <dje@canuck.cygnus.com>\n \t* decl2.c (finish_vtable_vardecl): Surround DECL_ONE_ONLY with ifdef.\n \t(finish_file): Likewise.\n \n+Thu May 16 15:29:33 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* expr.c (do_case): Don't try to dereference null TREE_TYPEs\n+\twhen checking for pointer types.\n+\n+Thu May 16 13:38:58 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_class_template): Remove obsolete check for\n+ \taccess declarations.\n+\n+Thu May 16 13:34:15 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (build_overload_call): Simplify calls to\n+\tbuild_overload_call by removing last parameter.\n+\t(build_method_call): Ditto.\n+\t* cp-tree.h: Ditto.\n+\t* method.c (build_opfncall): Ditto.\n+\t* typeck.c (build_x_function_call): Ditto.\n+\n+Thu May 16 13:15:43 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (default_parm_conversions): Factor out common code.\n+\t(build_method_call): Use it.\n+\t(build_overload_call_real): Use it.\n+\n Wed May 15 14:46:14 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* call.c (build_method_call): Allow implicit & on METHOD_TYPEs,"}, {"sha": "6e2132de058dda402d27465a0d7edc684c6070e1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 51, "deletions": 62, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ce122a86188dc56eaf70488215b52b3dbc22bbce", "patch": "@@ -1584,6 +1584,36 @@ build_call (function, result_type, parms)\n   return function;\n }\n \n+static tree\n+default_parm_conversions (parms, last)\n+     tree parms, *last;\n+{\n+  tree parm, parmtypes = NULL_TREE;\n+\n+  *last = NULL_TREE;\n+\n+  for (parm = parms; parm; parm = TREE_CHAIN (parm))\n+    {\n+      tree t = TREE_TYPE (TREE_VALUE (parm));\n+\n+      if (TREE_CODE (t) == OFFSET_TYPE\n+\t  || TREE_CODE (t) == METHOD_TYPE\n+\t  || TREE_CODE (t) == FUNCTION_TYPE)\n+\t{\n+\t  TREE_VALUE (parm) = default_conversion (TREE_VALUE (parm));\n+\t  t = TREE_TYPE (TREE_VALUE (parm));\n+\t}\n+\n+      if (t == error_mark_node)\n+\t  return error_mark_node;\n+\n+      *last = build_tree_list (NULL_TREE, t);\n+      parmtypes = chainon (parmtypes, *last);\n+    }\n+\n+  return parmtypes;\n+}\n+\n \n /* Build something of the form ptr->method (args)\n    or object.method (args).  This can also build\n@@ -1988,35 +2018,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n   save_basetype = TYPE_MAIN_VARIANT (basetype);\n \n-  last = NULL_TREE;\n-  for (parmtypes = NULL_TREE, parm = parms; parm; parm = TREE_CHAIN (parm))\n+  parmtypes = default_parm_conversions (parms, &last);\n+  if (parmtypes == error_mark_node)\n     {\n-      tree t = TREE_TYPE (TREE_VALUE (parm));\n-      if (TREE_CODE (t) == OFFSET_TYPE)\n-\t{\n-\t  /* Convert OFFSET_TYPE entities to their normal selves.  */\n-\t  TREE_VALUE (parm) = resolve_offset_ref (TREE_VALUE (parm));\n-\t  t = TREE_TYPE (TREE_VALUE (parm));\n-\t}\n-      if (TREE_CODE (t) == METHOD_TYPE)\n-\t{\n-\t  cp_pedwarn (\"assuming & on `%E'\", TREE_VALUE (parm));\n-\t  TREE_VALUE (parm) = build_unary_op (ADDR_EXPR, TREE_VALUE (parm), 0);\n-\t}\n-#if 0\n-      /* This breaks reference-to-array parameters.  */\n-      if (TREE_CODE (t) == ARRAY_TYPE)\n-\t{\n-\t  /* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place.\n-\t     This eliminates needless calls to `compute_conversion_costs'.  */\n-\t  TREE_VALUE (parm) = default_conversion (TREE_VALUE (parm));\n-\t  t = TREE_TYPE (TREE_VALUE (parm));\n-\t}\n-#endif\n-      if (t == error_mark_node)\n-\treturn error_mark_node;\n-      last = build_tree_list (NULL_TREE, t);\n-      parmtypes = chainon (parmtypes, last);\n+      return error_mark_node;\n     }\n \n   if (instance && IS_SIGNATURE (basetype))\n@@ -2146,7 +2151,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      cp->harshness = (struct harshness_code *)\n \t\talloca ((len + 1) * sizeof (struct harshness_code));\n \n-\t      result = build_overload_call (name, friend_parms, 0, cp);\n+\t      result = build_overload_call_real (name, friend_parms, 0, cp, 1);\n \n \t      /* If it turns out to be the one we were actually looking for\n \t\t (it was probably a friend function), the return the\n@@ -2429,14 +2434,16 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       && value_member (function, get_abstract_virtuals (basetype)))\n     cp_error (\"abstract virtual `%#D' called from constructor\", function);\n \n-  if (IS_SIGNATURE (basetype) && static_call_context)\n+  if (IS_SIGNATURE (basetype))\n     {\n-      cp_error (\"cannot call signature member function `%T::%D' without signature pointer/reference\",\n-\t\tbasetype, save_name);\n-      return error_mark_node;\n+      if (static_call_context)\n+\t{\n+\t  cp_error (\"cannot call signature member function `%T::%D' without signature pointer/reference\",\n+\t\t    basetype, save_name);\n+\t  return error_mark_node;\n \t}\n-  else if (IS_SIGNATURE (basetype))\n-    return build_signature_method_call (basetype, instance, function, parms);\n+      return build_signature_method_call (basetype, instance, function, parms);\n+    }\n \n   function = DECL_MAIN_VARIANT (function);\n   mark_used (function);\n@@ -2632,7 +2639,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n {\n   /* must check for overloading here */\n   tree functions, function, parm;\n-  tree parmtypes = NULL_TREE, last = NULL_TREE;\n+  tree parmtypes, last;\n   register tree outer;\n   int length;\n   int parmlength = list_length (parms);\n@@ -2648,31 +2655,14 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n       final_cp[1].h.code = EVIL_CODE;\n     }\n \n-  for (parm = parms; parm; parm = TREE_CHAIN (parm))\n+  parmtypes = default_parm_conversions (parms, &last);\n+  if (parmtypes == error_mark_node)\n     {\n-      register tree t = TREE_TYPE (TREE_VALUE (parm));\n-\n-      if (t == error_mark_node)\n-\t{\n-\t  if (final_cp)\n-\t    final_cp->h.code = EVIL_CODE;\n-\t  return error_mark_node;\n-\t}\n-      if (TREE_CODE (t) == OFFSET_TYPE)\n-#if 0\n-      /* This breaks reference-to-array parameters.  */\n-\t  || TREE_CODE (t) == ARRAY_TYPE\n-#endif\n-\t{\n-\t  /* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place.\n-\t     Also convert OFFSET_TYPE entities to their normal selves.\n-\t     This eliminates needless calls to `compute_conversion_costs'.  */\n-\t  TREE_VALUE (parm) = default_conversion (TREE_VALUE (parm));\n-\t  t = TREE_TYPE (TREE_VALUE (parm));\n-\t}\n-      last = build_tree_list (NULL_TREE, t);\n-      parmtypes = chainon (parmtypes, last);\n+      if (final_cp)\n+\tfinal_cp->h.code = EVIL_CODE;\n+      return error_mark_node;\n     }\n+\n   if (last)\n     TREE_CHAIN (last) = void_list_node;\n   else\n@@ -2891,10 +2881,9 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n \n /* This requires a complete type on the result of the call.  */\n tree\n-build_overload_call (fnname, parms, flags, final_cp)\n+build_overload_call (fnname, parms, flags)\n      tree fnname, parms;\n      int flags;\n-     struct candidate *final_cp;\n {\n-  return build_overload_call_real (fnname, parms, flags, final_cp, 1);\n+  return build_overload_call_real (fnname, parms, flags, (struct candidate *)0, 1);\n }"}, {"sha": "a1d59d68299e27bb627515a1bc4bc2ce5e60587e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ce122a86188dc56eaf70488215b52b3dbc22bbce", "patch": "@@ -1944,7 +1944,7 @@ extern tree build_addr_func\t\t\tPROTO((tree));\n extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *, int));\n-extern tree build_overload_call\t\t\tPROTO((tree, tree, int, struct candidate *));\n+extern tree build_overload_call\t\t\tPROTO((tree, tree, int));\n \n /* in class.c */\n extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));"}, {"sha": "343246f26e8065ef2284cfce15775d4e3646164c", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=ce122a86188dc56eaf70488215b52b3dbc22bbce", "patch": "@@ -374,7 +374,8 @@ do_case (start, end)\n {\n   tree value1 = NULL_TREE, value2 = NULL_TREE, label;\n \n-  if (start && POINTER_TYPE_P (TREE_TYPE (start)))\n+  if (start != NULL_TREE && TREE_TYPE (start) != NULL_TREE \n+      && POINTER_TYPE_P (TREE_TYPE (start)))\n     error (\"pointers are not permitted as case values\");\n \n   if (end && pedantic)"}, {"sha": "321492370ea143001c500464d3454a0f2008a5e7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ce122a86188dc56eaf70488215b52b3dbc22bbce", "patch": "@@ -1233,8 +1233,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \ttree args = tree_cons (NULL_TREE, xarg2, arg3);\n \tfnname = ansi_opname[(int) code];\n \tif (flags & LOOKUP_GLOBAL)\n-\t  return build_overload_call (fnname, args, flags & LOOKUP_COMPLAIN,\n-\t\t\t\t      (struct candidate *)0);\n+\t  return build_overload_call (fnname, args, flags & LOOKUP_COMPLAIN);\n \n \trval = build_method_call\n \t  (build_indirect_ref (build1 (NOP_EXPR, xarg1, error_mark_node),\n@@ -1258,8 +1257,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \tif (flags & LOOKUP_GLOBAL)\n \t  return build_overload_call (fnname,\n \t\t\t\t      build_tree_list (NULL_TREE, xarg1),\n-\t\t\t\t      flags & LOOKUP_COMPLAIN,\n-\t\t\t\t      (struct candidate *)0);\n+\t\t\t\t      flags & LOOKUP_COMPLAIN);\n \targ1 = TREE_TYPE (xarg1);\n \n \t/* This handles the case where we're trying to delete\n@@ -1481,8 +1479,7 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n     {\n       parms = tree_cons (NULL_TREE, xarg1,\n \t\t\t build_tree_list (NULL_TREE, xarg2));\n-      rval = build_overload_call (fnname, parms, flags,\n-\t\t\t\t  (struct candidate *)0);\n+      rval = build_overload_call (fnname, parms, flags);\n     }\n \n   return rval;"}, {"sha": "536e6c6be561b3dec798e7fc912df69aa18a715a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ce122a86188dc56eaf70488215b52b3dbc22bbce", "patch": "@@ -1182,8 +1182,7 @@ instantiate_class_template (type)\n     {\n       tree tmp;\n       for (tmp = TYPE_FIELDS (type); tmp; tmp = TREE_CHAIN (tmp))\n-\tif (TREE_CODE (tmp) == FIELD_DECL\n-\t    && TREE_CODE (DECL_NAME (tmp)) != SCOPE_REF)\n+\tif (TREE_CODE (tmp) == FIELD_DECL)\n \t  require_complete_type (tmp);\n \n       /* XXX handle attributes */"}, {"sha": "e1fac0d9341fc9e90bb817296010427199e8668c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce122a86188dc56eaf70488215b52b3dbc22bbce/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ce122a86188dc56eaf70488215b52b3dbc22bbce", "patch": "@@ -1430,7 +1430,7 @@ decay_conversion (exp)\n   register tree type = TREE_TYPE (exp);\n   register enum tree_code code = TREE_CODE (type);\n \n-  if (code == OFFSET_TYPE /* || TREE_CODE (exp) == OFFSET_REF */ )\n+  if (code == OFFSET_TYPE)\n     {\n       if (TREE_CODE (exp) == OFFSET_REF)\n \treturn decay_conversion (resolve_offset_ref (exp));\n@@ -2370,7 +2370,7 @@ build_x_function_call (function, params, decl)\n \t      (function, params, LOOKUP_COMPLAIN, (struct candidate *)0, 0);\n \t  else if (DECL_CHAIN (val) != NULL_TREE)\n \t    return build_overload_call\n-\t      (function, params, LOOKUP_COMPLAIN, (struct candidate *)0);\n+\t      (function, params, LOOKUP_COMPLAIN);\n \t  else\n \t    my_friendly_abort (360);\n \t}"}]}