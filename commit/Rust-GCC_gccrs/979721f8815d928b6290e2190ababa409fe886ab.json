{"sha": "979721f8815d928b6290e2190ababa409fe886ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc5NzIxZjg4MTVkOTI4YjYyOTBlMjE5MGFiYWJhNDA5ZmU4ODZhYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-02-13T19:19:40Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-02-13T19:19:40Z"}, "message": "Cygwin32 support; Make eabi update stack first before doing stores in prolog\n\nFrom-SVN: r11259", "tree": {"sha": "e50b22d985c9826b2e7f690463524030216c1427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e50b22d985c9826b2e7f690463524030216c1427"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/979721f8815d928b6290e2190ababa409fe886ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/979721f8815d928b6290e2190ababa409fe886ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/979721f8815d928b6290e2190ababa409fe886ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/979721f8815d928b6290e2190ababa409fe886ab/comments", "author": null, "committer": null, "parents": [{"sha": "126e5b0d250c6955ae27a0f8c65e1f0e254215df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/126e5b0d250c6955ae27a0f8c65e1f0e254215df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/126e5b0d250c6955ae27a0f8c65e1f0e254215df"}], "stats": {"total": 268, "additions": 230, "deletions": 38}, "files": [{"sha": "2230848a333f69111eaf12b6d1538c579ec0a5ea", "filename": "gcc/config/rs6000/cygwin32.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fcygwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fcygwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fcygwin32.h?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -35,7 +35,7 @@ Boston, MA 02111-1307, USA. */\n \n #define\tCPP_PREDEFINES \"-DWIN32 -D__WIN32__ -D__WINNT__ \\\n   -D__CYGWIN32__ -DPOSIX \\\n-  -D_POWER -DPPC -Asystem(winnt) -Acpu(powerpc) -Amachine(powerpc)\"\n+  -D_POWER -D_ARCH_PPC -D__PPC__ -Asystem(winnt) -Acpu(powerpc) -Amachine(powerpc)\"\n \n /* We have to dynamic link to get to the system dlls,\n    and I've put all of libc and libm and the unix stuff into\n@@ -49,10 +49,6 @@ Boston, MA 02111-1307, USA. */\n #define\tLINK_SPEC \"%{v:-V}\"\n \n \n-/* No need for libgcc, it's in the shared library. */\n-#undef LIBGCC_SPEC\n-#define LIBGCC_SPEC \"\"\n-\n #undef STARTFILE_SPEC\n #define STARTFILE_SPEC \"%{!:crt0%O%s}\"\n \n@@ -62,3 +58,7 @@ Boston, MA 02111-1307, USA. */\n #define WCHAR_TYPE \"short unsigned int\"\n \n /* XXX set up stack probing */\n+\n+#define DBX_DEBUGGING_INFO \n+#undef SDB_DEBUGGING_INFO \n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG"}, {"sha": "71a251a599981f5d699f95849f12d3d0924d9873", "filename": "gcc/config/rs6000/ntstack.asm", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fntstack.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fntstack.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fntstack.asm?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -0,0 +1,42 @@\n+# CYGNUS LOCAL -- NT/WRS development, meissner\n+# Allocate stack for NT, inserting stack probes every 4k pages\n+\n+\t.file\t\"ntstack.asm\"\n+\n+#\tSetup MS Structured-Exception-Handling\n+\t.pdata\n+\t.align 2\n+\t.ualong ..__allocate_stack,__allocate_stack.e,0,0,__allocate_stack.b\n+\n+#\tSwitch to the relocation section\n+\t.reldata\n+\t.globl __allocate_stack\n+\t.globl ..__allocate_stack\n+__allocate_stack:\n+\t.ualong ..__allocate_stack,.toc\n+\n+\t.text\n+\t.align 2\n+..__allocate_stack:\n+\t.function\t..__allocate_stack\n+__allocate_stack.b:\n+\tlwz\t0,0(1)\t\t\t# old stack link\n+\tsrawi.\t4,3,12\t\t\t# get # of pages to check\n+\tneg\t3,3\t\t\t# negate so we can use stwux\n+\tbgt-\t0,.Lcheck\n+\tstwux\t0,1,3\t\t\t# small request, just decrement and return\n+\tblr\n+\n+.Lcheck:\n+\tmtctr\t4\t\t\t# number of pages to check\n+\tmr\t5,1\t\t\t# tmp pointer\n+.Lloop:\n+\tlwzu\t6,-4096(5)\t\t# touch the page\n+\tbdnz+\t.Lloop\t\t\t# and loop back\n+\n+\tstwux\t0,1,3\t\t\t# update stack pointer\n+\tblr\n+\n+__allocate_stack.e:\n+FE_MOT_RESVD..__allocate_stack:\n+# END CYGNUS LOCAL -- NT/WRS development, meissner"}, {"sha": "0c0eae6c16fd3029dce1c6fc16c9962091772ee7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 133, "deletions": 24, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -2899,6 +2899,8 @@ output_prolog (file, size)\n   int reg_size = info->reg_size;\n   char *store_reg;\n   char *load_reg;\n+  int sp_reg = 1;\n+  int sp_offset = 0;\n \n   if (TARGET_32BIT)\n     {\n@@ -2941,12 +2943,36 @@ output_prolog (file, size)\n       common_mode_defined = 1;\n     }\n \n+  /* For V.4, update stack before we do any saving and set back pointer.  */\n+  if (info->push_p && DEFAULT_ABI == ABI_V4)\n+    {\n+      if (info->total_size < 32767)\n+\t{\n+\t  asm_fprintf (file,\n+\t\t       (TARGET_32BIT) ? \"\\t{stu|stwu} %s,%d(%s)\\n\" : \"\\tstdu %s,%d(%s)\\n\",\n+\t\t       reg_names[1], - info->total_size, reg_names[1]);\n+\t  sp_offset = info->total_size;\n+\t}\n+      else\n+\t{\n+\t  int neg_size = - info->total_size;\n+\t  sp_reg = 12;\n+\t  asm_fprintf (file, \"\\tmr %s,%s\\n\", reg_names[12], reg_names[1]);\n+\t  asm_fprintf (file, \"\\t{liu|lis} %s,%d\\n\\t{oril|ori} %s,%s,%d\\n\",\n+\t\t       reg_names[0], (neg_size >> 16) & 0xffff,\n+\t\t       reg_names[0], reg_names[0], neg_size & 0xffff);\n+\t  asm_fprintf (file,\n+\t\t       (TARGET_32BIT) ? \"\\t{stux|stwux} %s,%s,%s\\n\" : \"\\tstdux %s,%s,%s\\n\",\n+\t\t       reg_names[1], reg_names[1], reg_names[0]);\n+\t}\n+    }\n+\n   /* If we use the link register, get it into r0.  */\n   if (info->lr_save_p)\n     asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n \n   /* If we need to save CR, put it into r12.  */\n-  if (info->cr_save_p)\n+  if (info->cr_save_p && sp_reg != 12)\n     asm_fprintf (file, \"\\tmfcr %s\\n\", reg_names[12]);\n \n   /* Do any required saving of fpr's.  If only one or two to save, do it\n@@ -2955,10 +2981,10 @@ output_prolog (file, size)\n   if (FP_SAVE_INLINE (info->first_fp_reg_save))\n     {\n       int regno = info->first_fp_reg_save;\n-      int loc   = info->fp_save_offset;\n+      int loc   = info->fp_save_offset + sp_offset;\n \n       for ( ; regno < 64; regno++, loc += 8)\n-\tasm_fprintf (file, \"\\tstfd %s,%d(%s)\\n\", reg_names[regno], loc, reg_names[1]);\n+\tasm_fprintf (file, \"\\tstfd %s,%d(%s)\\n\", reg_names[regno], loc, reg_names[sp_reg]);\n     }\n   else if (info->first_fp_reg_save != 64)\n     asm_fprintf (file, \"\\tbl %s%d%s\\n\", SAVE_FP_PREFIX,\n@@ -2968,17 +2994,17 @@ output_prolog (file, size)\n   if (! TARGET_MULTIPLE || info->first_gp_reg_save == 31 || TARGET_64BIT)\n     {\n       int regno    = info->first_gp_reg_save;\n-      int loc      = info->gp_save_offset;\n+      int loc      = info->gp_save_offset + sp_offset;\n \n       for ( ; regno < 32; regno++, loc += reg_size)\n-\tasm_fprintf (file, store_reg, reg_names[regno], loc, reg_names[1]);\n+\tasm_fprintf (file, store_reg, reg_names[regno], loc, reg_names[sp_reg]);\n     }\n \n   else if (info->first_gp_reg_save != 32)\n     asm_fprintf (file, \"\\t{stm|stmw} %s,%d(%s)\\n\",\n \t\t reg_names[info->first_gp_reg_save],\n-\t\t info->gp_save_offset,\n-\t\t reg_names[1]);\n+\t\t info->gp_save_offset + sp_offset,\n+\t\t reg_names[sp_reg]);\n \n   /* Save main's arguments if we need to call a function */\n #ifdef NAME__MAIN\n@@ -2989,23 +3015,75 @@ output_prolog (file, size)\n       int size = info->main_size;\n \n       for (regno = 3; size > 0; regno++, loc -= reg_size, size -= reg_size)\n-\tasm_fprintf (file, store_reg, reg_names[regno], loc, reg_names[1]);\n+\tasm_fprintf (file, store_reg, reg_names[regno], loc, reg_names[sp_reg]);\n     }\n #endif\n \n   /* Save lr if we used it.  */\n   if (info->lr_save_p)\n-    asm_fprintf (file, store_reg, reg_names[0], info->lr_save_offset, reg_names[1]);\n+    asm_fprintf (file, store_reg, reg_names[0], info->lr_save_offset + sp_offset,\n+\t\t reg_names[sp_reg]);\n \n   /* Save CR if we use any that must be preserved.  */\n   if (info->cr_save_p)\n-    asm_fprintf (file, store_reg, reg_names[12], info->cr_save_offset, reg_names[1]);\n+    {\n+      if (sp_reg == 12)\t/* If r12 is used to hold the original sp, copy cr now */\n+\t{\n+\t  asm_fprintf (file, \"\\tmfcr %s\\n\", reg_names[0]);\n+\t  asm_fprintf (file, store_reg, reg_names[0],\n+\t\t       info->cr_save_offset + sp_offset,\n+\t\t       reg_names[sp_reg]);\n+\t}\n+      else\n+\tasm_fprintf (file, store_reg, reg_names[12], info->cr_save_offset + sp_offset,\n+\t\t     reg_names[sp_reg]);\n+    }\n \n   if (info->toc_save_p)\n-    asm_fprintf (file, store_reg, reg_names[2], info->toc_save_offset, reg_names[1]);\n+    asm_fprintf (file, store_reg, reg_names[2], info->toc_save_offset + sp_offset,\n+\t\t reg_names[sp_reg]);\n \n-  /* Update stack and set back pointer.  */\n-  if (info->push_p)\n+  /* NT needs us to probe the stack frame every 4k pages for large frames, so\n+     do it here.  */\n+  if (DEFAULT_ABI == ABI_NT && info->total_size > 4096)\n+    {\n+      if (info->total_size < 32768)\n+\t{\n+\t  int probe_offset = 4096;\n+\t  while (probe_offset < info->total_size)\n+\t    {\n+\t      asm_fprintf (file, \"\\t{l|lwz} %s,%d(%s)\\n\", reg_names[0], -probe_offset, reg_names[1]);\n+\t      probe_offset += 4096;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  int probe_iterations = info->total_size / 4096;\n+\t  static int probe_labelno = 0;\n+\t  char buf[256];\n+\n+\t  if (probe_iterations < 32768)\n+\t    asm_fprintf (file, \"\\tli %s,%d\\n\", reg_names[12], probe_iterations);\n+\t  else\n+\t    {\n+\t      asm_fprintf (file, \"\\tlis %s,%d\\n\", reg_names[12], probe_iterations >> 16);\n+\t      if (probe_iterations & 0xffff)\n+\t\tasm_fprintf (file, \"\\tori %s,%s,%d\\n\", reg_names[12], reg_names[12],\n+\t\t\t     probe_iterations & 0xffff);\n+\t    }\n+\t  asm_fprintf (file, \"\\tmtctr %s\\n\", reg_names[12]);\n+\t  asm_fprintf (file, \"\\tmr %s,%s\\n\", reg_names[12], reg_names[1]);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (file, \"LCprobe\", probe_labelno);\n+\t  asm_fprintf (file, \"\\t{lu|lwzu} %s,-4096(%s)\\n\", reg_names[0], reg_names[12]);\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCprobe\", probe_labelno);\n+\t  fputs (\"\\tbdnz \", file);\n+\t  assemble_name (file, buf);\n+\t  fputs (\"\\n\", file);\n+\t}\n+    }\n+\n+  /* Update stack and set back pointer and we have already done so for V.4.  */\n+  if (info->push_p && DEFAULT_ABI != ABI_V4)\n     {\n       if (info->total_size < 32767)\n \tasm_fprintf (file,\n@@ -3063,8 +3141,17 @@ output_prolog (file, size)\n \t\tasm_fprintf (file, load_reg, reg_names[regno], loc, reg_names[1]);\n \t    }\n \t  else\n-\t    {\t\t\t/* for large frames, reg 0 above contains -frame size */\n+\t    {\t\t\t/* for large AIX/NT frames, reg 0 above contains -frame size */\n+\t\t\t\t/* for V.4, we need to reload -frame size */\n \t      loc = info->main_save_offset;\n+\t      if (DEFAULT_ABI == ABI_V4 && info->total_size > 32767)\n+\t\t{\n+\t\t  int neg_size = - info->total_size;\n+\t\t  asm_fprintf (file, \"\\t{liu|lis} %s,%d\\n\\t{oril|ori} %s,%s,%d\\n\",\n+\t\t\t       reg_names[0], (neg_size >> 16) & 0xffff,\n+\t\t\t       reg_names[0], reg_names[0], neg_size & 0xffff);\n+\t\t}\n+\n \t      asm_fprintf (file, \"\\t{sf|subf} %s,%s,%s\\n\", reg_names[0], reg_names[0],\n \t\t\t   reg_names[1]);\n \n@@ -3163,6 +3250,8 @@ output_epilog (file, size)\n   rs6000_stack_t *info = rs6000_stack_info ();\n   char *load_reg = (TARGET_32BIT) ? \"\\t{l|lwz} %s,%d(%s)\\n\" : \"\\tld %s,%d(%s)\\n\";\n   rtx insn = get_last_insn ();\n+  int sp_reg = 1;\n+  int sp_offset = 0;\n   int i;\n \n   /* Forget about any temporaries created */\n@@ -3180,22 +3269,31 @@ output_epilog (file, size)\n \t we know what size to update it with.  */\n       if (frame_pointer_needed || current_function_calls_alloca\n \t  || info->total_size > 32767)\n-\tasm_fprintf (file, load_reg, reg_names[1], 0, reg_names[1]);\n+\t{\n+\t  /* Under V.4, don't reset the stack pointer until after we're done\n+\t     loading the saved registers.  */\n+\t  if (DEFAULT_ABI == ABI_V4)\n+\t    sp_reg = 11;\n+\n+\t  asm_fprintf (file, load_reg, reg_names[sp_reg], 0, reg_names[1]);\n+\t}\n       else if (info->push_p)\n \t{\n-\t  if (TARGET_NEW_MNEMONICS)\n+\t  if (DEFAULT_ABI == ABI_V4)\n+\t    sp_offset = info->total_size;\n+\t  else if (TARGET_NEW_MNEMONICS)\n \t    asm_fprintf (file, \"\\taddi %s,%s,%d\\n\", reg_names[1], reg_names[1], info->total_size);\n \t  else\n \t    asm_fprintf (file, \"\\tcal %s,%d(%s)\\n\", reg_names[1], info->total_size, reg_names[1]);\n \t}\n \n       /* Get the old lr if we saved it.  */\n       if (info->lr_save_p)\n-\tasm_fprintf (file, load_reg, reg_names[0], info->lr_save_offset, reg_names[1]);\n+\tasm_fprintf (file, load_reg, reg_names[0], info->lr_save_offset + sp_offset, reg_names[sp_reg]);\n \n       /* Get the old cr if we saved it.  */\n       if (info->cr_save_p)\n-\tasm_fprintf (file, load_reg, reg_names[12], info->cr_save_offset, reg_names[1]);\n+\tasm_fprintf (file, load_reg, reg_names[12], info->cr_save_offset + sp_offset, reg_names[sp_reg]);\n \n       /* Set LR here to try to overlap restores below.  */\n       if (info->lr_save_p)\n@@ -3205,27 +3303,27 @@ output_epilog (file, size)\n       if (! TARGET_MULTIPLE || info->first_gp_reg_save == 31 || TARGET_64BIT)\n \t{\n \t  int regno    = info->first_gp_reg_save;\n-\t  int loc      = info->gp_save_offset;\n+\t  int loc      = info->gp_save_offset + sp_offset;\n \t  int reg_size = (TARGET_32BIT) ? 4 : 8;\n \n \t  for ( ; regno < 32; regno++, loc += reg_size)\n-\t    asm_fprintf (file, load_reg, reg_names[regno], loc, reg_names[1]);\n+\t    asm_fprintf (file, load_reg, reg_names[regno], loc, reg_names[sp_reg]);\n \t}\n \n       else if (info->first_gp_reg_save != 32)\n \tasm_fprintf (file, \"\\t{lm|lmw} %s,%d(%s)\\n\",\n \t\t     reg_names[info->first_gp_reg_save],\n-\t\t     info->gp_save_offset,\n-\t\t     reg_names[1]);\n+\t\t     info->gp_save_offset + sp_offset,\n+\t\t     reg_names[sp_reg]);\n \n       /* Restore fpr's if we can do it without calling a function.  */\n       if (FP_SAVE_INLINE (info->first_fp_reg_save))\n \t{\n \t  int regno = info->first_fp_reg_save;\n-\t  int loc   = info->fp_save_offset;\n+\t  int loc   = info->fp_save_offset + sp_offset;\n \n \t  for ( ; regno < 64; regno++, loc += 8)\n-\t    asm_fprintf (file, \"\\tlfd %s,%d(%s)\\n\", reg_names[regno], loc, reg_names[1]);\n+\t    asm_fprintf (file, \"\\tlfd %s,%d(%s)\\n\", reg_names[regno], loc, reg_names[sp_reg]);\n \t}\n \n       /* If we saved cr, restore it here.  Just those of cr2, cr3, and cr4\n@@ -3236,6 +3334,17 @@ output_epilog (file, size)\n \t\t     + (regs_ever_live[71] != 0) * 0x10\n \t\t     + (regs_ever_live[72] != 0) * 0x8, reg_names[12]);\n \n+      /* If this is V.4, unwind the stack pointer after all of the loads have been done */\n+      if (sp_offset)\n+\t{\n+\t  if (TARGET_NEW_MNEMONICS)\n+\t    asm_fprintf (file, \"\\taddi %s,%s,%d\\n\", reg_names[1], reg_names[1], sp_offset);\n+\t  else\n+\t    asm_fprintf (file, \"\\tcal %s,%d(%s)\\n\", reg_names[1], sp_offset, reg_names[1]);\n+\t}\n+      else if (sp_reg != 1)\n+\tasm_fprintf (file, \"\\tmr %s,%s\\n\", reg_names[1], reg_names[sp_reg]);\n+\n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */\n       if (info->first_fp_reg_save != 64 && !FP_SAVE_INLINE (info->first_fp_reg_save))"}, {"sha": "89b9cba6201b56604e23234a84bb9fce817b124c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -6327,6 +6327,18 @@\n \n   emit_move_insn (chain, stack_bot);\n \n+  /* Under Windows NT, we need to add stack probes for large/variable allocations,\n+     so do it via a call to the external function alloca, instead of doing it\n+     inline.  */\n+  if (DEFAULT_ABI == ABI_NT\n+      && (GET_CODE (operands[0]) != CONST_INT || INTVAL (operands[0]) > 4096))\n+    {\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \\\"__allocate_stack\\\"), 0,\n+\t\t\t VOIDmode, 1,\n+\t\t\t operands[0], Pmode);\n+      DONE;\n+    }\n+\n   if (GET_CODE (operands[0]) != CONST_INT\n       || INTVAL (operands[0]) < -32767\n       || INTVAL (operands[0]) > 32768)"}, {"sha": "847e6ac376a644abdd56b60712a1a8dc3e97945e", "filename": "gcc/config/rs6000/t-winnt", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Ft-winnt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Ft-winnt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-winnt?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -9,7 +9,7 @@ LIBGCC1_TEST =\n \n # These are really part of libgcc1, but this will cause them to be\n # built correctly, so... [taken from t-sparclite]\n-LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c ntstack.s\n \n dp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n@@ -18,10 +18,5 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#define FLOAT' > fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n-# Build the libraries for both hard and soft floating point\n-\n-MULTILIB_OPTIONS = msoft-float\n-MULTILIB_DIRNAMES = soft-float\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n+ntstack.s: $(srcdir)/config/rs6000/ntstack.asm\n+\tcat $(srcdir)/config/rs6000/ntstack.asm > ntstack.s"}, {"sha": "b0c99f9c07f6d8b2b111ac71f7edd050f9203e7b", "filename": "gcc/config/rs6000/win-nt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fwin-nt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fwin-nt.h?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -36,7 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #undef\tCPP_PREDEFINES\n #define\tCPP_PREDEFINES \"-DWIN32 -D_WIN32 \\\n   -DWINNT -D__STDC__=0 -DALMOST_STDC \\\n-  -D_POWER -DPPC -Asystem(winnt) -Acpu(powerpc) -Amachine(powerpc)\"\n+  -D_POWER -D_ARCH_PPC -D__PPC__ -Asystem(winnt) -Acpu(powerpc) -Amachine(powerpc)\"\n \n #if 0\n #include \"winnt/win-nt.h\""}, {"sha": "0a397ebd5bd6355e5d1796410a7fe9e939dddf48", "filename": "gcc/config/rs6000/x-cygwin32", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fx-cygwin32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fx-cygwin32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fx-cygwin32?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -0,0 +1 @@\n+USE_COLLECT2 ="}, {"sha": "a917d07d8767eea0205ce1eecbb8b4f98338a726", "filename": "gcc/config/rs6000/xm-cygwin32.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fxm-cygwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Fconfig%2Frs6000%2Fxm-cygwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxm-cygwin32.h?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -0,0 +1,30 @@\n+/* Configuration for GNU C-compiler for hosting on Windows NT.\n+   using a unix style C library.\n+   Copyright (C) 1995 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#define NO_STAB_H\n+\n+#include \"rs6000/xm-rs6000.h\"\n+\n+#define HAVE_STRERROR\n+#define HAVE_RUSAGE\n+#define HAVE_FILE_H\n+\n+"}, {"sha": "977b9c761886ba03006ee8a931e7a150ec0d8f35", "filename": "gcc/libgcc1-test.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Flibgcc1-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/979721f8815d928b6290e2190ababa409fe886ab/gcc%2Flibgcc1-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc1-test.c?ref=979721f8815d928b6290e2190ababa409fe886ab", "patch": "@@ -95,6 +95,9 @@ dfoo ()\n    message saying the start address is defaulted.  */\n extern void start() __asm__(\"start\");\n extern void _start() __asm__(\"_start\");\n+extern void __start() __asm__(\"__start\");\n \n void start() {}\n void _start() {}\n+void __start() {}\n+void mainCRTStartup() {}"}]}