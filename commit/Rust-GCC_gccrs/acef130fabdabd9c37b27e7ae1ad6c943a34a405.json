{"sha": "acef130fabdabd9c37b27e7ae1ad6c943a34a405", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNlZjEzMGZhYmRhYmQ5YzM3YjI3ZTdhZTFhZDZjOTQzYTM0YTQwNQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-04-10T21:01:19Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-04-10T21:01:19Z"}, "message": "i386.c (ix86_expand_vector_init_one_nonzero): Renamed from ix86_expand_vector_init_low_nonzero.\n\n\n\t* config/i386/i386.c (ix86_expand_vector_init_one_nonzero): Renamed\n\tfrom ix86_expand_vector_init_low_nonzero.  Take an additional\n\tone_var argument indicating which element is non-zero.  Support\n\tone_var != 0 for V4SFmode and V4SImode by permuting the result.\n\t(ix86_expand_vector_init): Call ix86_expand_vector_init_one_nonzero\n\twith one_var instead of ix86_expand_vector_init_low_nonzero.\n\n\t* gcc.target/i386/vecinit-1.c: New test case.\n\t* gcc.target/i386/vecinit-2.c: Likewise.\n\nFrom-SVN: r112832", "tree": {"sha": "1c365032f326e9e550ddea7a0e0045d195fac037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c365032f326e9e550ddea7a0e0045d195fac037"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acef130fabdabd9c37b27e7ae1ad6c943a34a405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acef130fabdabd9c37b27e7ae1ad6c943a34a405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acef130fabdabd9c37b27e7ae1ad6c943a34a405", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acef130fabdabd9c37b27e7ae1ad6c943a34a405/comments", "author": null, "committer": null, "parents": [{"sha": "e3df376d22bdd92e4cc62e2b290f76d39ddebcca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3df376d22bdd92e4cc62e2b290f76d39ddebcca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3df376d22bdd92e4cc62e2b290f76d39ddebcca"}], "stats": {"total": 107, "additions": 98, "deletions": 9}, "files": [{"sha": "a50a06ed84678c226edd21c1731daecfa2d58a57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acef130fabdabd9c37b27e7ae1ad6c943a34a405", "patch": "@@ -1,3 +1,12 @@\n+2006-04-10  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* config/i386/i386.c (ix86_expand_vector_init_one_nonzero): Renamed\n+\tfrom ix86_expand_vector_init_low_nonzero.  Take an additional\n+\tone_var argument indicating which element is non-zero.  Support\n+\tone_var != 0 for V4SFmode and V4SImode by permuting the result.\n+\t(ix86_expand_vector_init): Call ix86_expand_vector_init_one_nonzero\n+\twith one_var instead of ix86_expand_vector_init_low_nonzero.\n+\n 2006-04-10  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* Makefile.in (tree-into-ssa.o, tree-outof-ssa.o,"}, {"sha": "656268567961673e68c5812ec567c94bd9ab4c47", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 62, "deletions": 9, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=acef130fabdabd9c37b27e7ae1ad6c943a34a405", "patch": "@@ -17880,15 +17880,16 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, enum machine_mode mode,\n }\n \n /* A subroutine of ix86_expand_vector_init.  Store into TARGET a vector\n-   whose low element is VAR, and other elements are zero.  Return true\n+   whose ONE_VAR element is VAR, and other elements are zero.  Return true\n    if successful.  */\n \n static bool\n-ix86_expand_vector_init_low_nonzero (bool mmx_ok, enum machine_mode mode,\n-\t\t\t\t     rtx target, rtx var)\n+ix86_expand_vector_init_one_nonzero (bool mmx_ok, enum machine_mode mode,\n+\t\t\t\t     rtx target, rtx var, int one_var)\n {\n   enum machine_mode vsimode;\n-  rtx x;\n+  rtx new_target;\n+  rtx x, tmp;\n \n   switch (mode)\n     {\n@@ -17900,17 +17901,64 @@ ix86_expand_vector_init_low_nonzero (bool mmx_ok, enum machine_mode mode,\n \n     case V2DFmode:\n     case V2DImode:\n+      if (one_var != 0)\n+\treturn false;\n       var = force_reg (GET_MODE_INNER (mode), var);\n       x = gen_rtx_VEC_CONCAT (mode, var, CONST0_RTX (GET_MODE_INNER (mode)));\n       emit_insn (gen_rtx_SET (VOIDmode, target, x));\n       return true;\n \n     case V4SFmode:\n     case V4SImode:\n+      if (!REG_P (target) || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+\tnew_target = gen_reg_rtx (mode);\n+      else\n+\tnew_target = target;\n       var = force_reg (GET_MODE_INNER (mode), var);\n       x = gen_rtx_VEC_DUPLICATE (mode, var);\n       x = gen_rtx_VEC_MERGE (mode, x, CONST0_RTX (mode), const1_rtx);\n-      emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+      emit_insn (gen_rtx_SET (VOIDmode, new_target, x));\n+      if (one_var != 0)\n+\t{\n+\t  /* We need to shuffle the value to the correct position, so\n+\t     create a new pseudo to store the intermediate result.  */\n+\n+\t  /* With SSE2, we can use the integer shuffle insns.  */\n+\t  if (mode != V4SFmode && TARGET_SSE2)\n+\t    {\n+\t      emit_insn (gen_sse2_pshufd_1 (new_target, new_target,\n+\t\t\t\t\t    GEN_INT (1),\n+\t\t\t\t\t    GEN_INT (one_var == 1 ? 0 : 1),\n+\t\t\t\t\t    GEN_INT (one_var == 2 ? 0 : 1),\n+\t\t\t\t\t    GEN_INT (one_var == 3 ? 0 : 1)));\n+\t      if (target != new_target)\n+\t\temit_move_insn (target, new_target);\n+\t      return true;\n+\t    }\n+\n+\t  /* Otherwise convert the intermediate result to V4SFmode and\n+\t     use the SSE1 shuffle instructions.  */\n+\t  if (mode != V4SFmode)\n+\t    {\n+\t      tmp = gen_reg_rtx (V4SFmode);\n+\t      emit_move_insn (tmp, gen_lowpart (V4SFmode, new_target));\n+\t    }\n+\t  else\n+\t    tmp = new_target;\n+\n+\t  emit_insn (gen_sse_shufps_1 (tmp, tmp, tmp,\n+\t\t\t\t       GEN_INT (1),\n+\t\t\t\t       GEN_INT (one_var == 1 ? 0 : 1),\n+\t\t\t\t       GEN_INT (one_var == 2 ? 0+4 : 1+4),\n+\t\t\t\t       GEN_INT (one_var == 3 ? 0+4 : 1+4)));\n+\n+\t  if (mode != V4SFmode)\n+\t    emit_move_insn (target, gen_lowpart (V4SImode, tmp));\n+\t  else if (tmp != target)\n+\t    emit_move_insn (target, tmp);\n+\t}\n+      else if (target != new_target)\n+\temit_move_insn (target, new_target);\n       return true;\n \n     case V8HImode:\n@@ -17924,11 +17972,15 @@ ix86_expand_vector_init_low_nonzero (bool mmx_ok, enum machine_mode mode,\n       vsimode = V2SImode;\n       goto widen;\n     widen:\n+      if (one_var != 0)\n+\treturn false;\n+\n       /* Zero extend the variable element to SImode and recurse.  */\n       var = convert_modes (SImode, GET_MODE_INNER (mode), var, true);\n \n       x = gen_reg_rtx (vsimode);\n-      if (!ix86_expand_vector_init_low_nonzero (mmx_ok, vsimode, x, var))\n+      if (!ix86_expand_vector_init_one_nonzero (mmx_ok, vsimode, x,\n+\t\t\t\t\t\tvar, one_var))\n \tgcc_unreachable ();\n \n       emit_move_insn (target, gen_lowpart (mode, x));\n@@ -18185,9 +18237,10 @@ ix86_expand_vector_init (bool mmx_ok, rtx target, rtx vals)\n      the pool and overwritten via move later.  */\n   if (n_var == 1)\n     {\n-      if (all_const_zero && one_var == 0\n-\t  && ix86_expand_vector_init_low_nonzero (mmx_ok, mode, target,\n-\t\t\t\t\t\t  XVECEXP (vals, 0, 0)))\n+      if (all_const_zero\n+\t  && ix86_expand_vector_init_one_nonzero (mmx_ok, mode, target,\n+\t\t\t\t\t\t  XVECEXP (vals, 0, one_var),\n+\t\t\t\t\t\t  one_var))\n \treturn;\n \n       if (ix86_expand_vector_init_one_var (mmx_ok, mode, target, vals, one_var))"}, {"sha": "7cf2a77e0aa2258e4d59f3a5ecb1bfa68220cd6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=acef130fabdabd9c37b27e7ae1ad6c943a34a405", "patch": "@@ -1,3 +1,8 @@\n+2006-04-10  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.target/i386/vecinit-1.c: New test case.\n+\t* gcc.target/i386/vecinit-2.c: Likewise.\n+\n 2006-04-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/27057"}, {"sha": "86cad897669a186d23e445649c32246bb61d8075", "filename": "gcc/testsuite/gcc.target/i386/vecinit-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvecinit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvecinit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvecinit-1.c?ref=acef130fabdabd9c37b27e7ae1ad6c943a34a405", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2\" } */\n+#define vector __attribute__((vector_size(16)))\n+\n+float a;\n+vector float f1(void) { return (vector float){ a, 0.0, 0.0, 0.0}; }\n+vector float f2(void) { return (vector float){ 0.0, a, 0.0, 0.0}; }\n+vector float f3(void) { return (vector float){ 0.0, 0.0, a, 0.0}; }\n+vector float f4(void) { return (vector float){ 0.0, 0.0, 0.0, a}; }\n+/* { dg-final { scan-assembler-not \"movaps\" } } */\n+/* { dg-final { scan-assembler-not \"xor\" } } */"}, {"sha": "41e502711a7c63697169efc9014a8daff9f164d7", "filename": "gcc/testsuite/gcc.target/i386/vecinit-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvecinit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acef130fabdabd9c37b27e7ae1ad6c943a34a405/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvecinit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvecinit-2.c?ref=acef130fabdabd9c37b27e7ae1ad6c943a34a405", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2\" } */\n+#define vector __attribute__((vector_size(16)))\n+\n+int a;\n+vector int f1(void) { return (vector int){ a, 0, 0, 0}; }\n+vector int f2(void) { return (vector int){ 0, a, 0, 0}; }\n+vector int f3(void) { return (vector int){ 0, 0, a, 0}; }\n+vector int f4(void) { return (vector int){ 0, 0, 0, a}; }\n+/* { dg-final { scan-assembler-not \"movaps\" } } */\n+/* { dg-final { scan-assembler-not \"xor\" } } */"}]}