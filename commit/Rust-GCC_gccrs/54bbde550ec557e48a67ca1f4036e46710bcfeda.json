{"sha": "54bbde550ec557e48a67ca1f4036e46710bcfeda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRiYmRlNTUwZWM1NTdlNDhhNjdjYTFmNDAzNmU0NjcxMGJjZmVkYQ==", "commit": {"author": {"name": "Sudakshina Das", "email": "sudi.das@arm.com", "date": "2020-11-13T10:48:27Z"}, "committer": {"name": "Sudakshina Das", "email": "sudi.das@arm.com", "date": "2020-11-13T10:48:27Z"}, "message": "aarch64: Add backend support for expanding __builtin_memset\n\nThis patch implements aarch64 backend expansion for __builtin_memset. Most of\nthe implementation is based on the expansion of __builtin_memcpy. We change the\nvalues of SET_RATIO and MOVE_RATIO for cases where we do not have to strictly\nalign and where we can benefit from NEON instructions in the backend.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-protos.h (aarch64_expand_setmem): New\n\tdeclaration.\n\t* config/aarch64/aarch64.c (aarch64_gen_store_pair): Add case for\n\tE_V16QImode.\n\t(aarch64_set_one_block_and_progress_pointer): New helper for\n\taarch64_expand_setmem.\n\t(aarch64_expand_setmem): Define the expansion for memset.\n\t* config/aarch64/aarch64.h (CLEAR_RATIO): Tweak to favor\n\taarch64_expand_setmem when allowed and profitable.\n\t(SET_RATIO): Likewise.\n\t* config/aarch64/aarch64.md: Define pattern for setmemdi.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/tree-ssa/pr90883.C: Remove xfail for aarch64.\n\t* gcc.dg/tree-prof/stringop-2.c: Add xfail for aarch64.\n\t* gcc.target/aarch64/memset-corner-cases.c: New test.\n\t* gcc.target/aarch64/memset-q-reg.c: New test.", "tree": {"sha": "8aa3b8ab436d1a1720cbe8d2ab0b1a18d851668b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aa3b8ab436d1a1720cbe8d2ab0b1a18d851668b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54bbde550ec557e48a67ca1f4036e46710bcfeda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54bbde550ec557e48a67ca1f4036e46710bcfeda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54bbde550ec557e48a67ca1f4036e46710bcfeda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54bbde550ec557e48a67ca1f4036e46710bcfeda/comments", "author": {"login": "sudakshina-das-arm", "id": 28538945, "node_id": "MDQ6VXNlcjI4NTM4OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/28538945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sudakshina-das-arm", "html_url": "https://github.com/sudakshina-das-arm", "followers_url": "https://api.github.com/users/sudakshina-das-arm/followers", "following_url": "https://api.github.com/users/sudakshina-das-arm/following{/other_user}", "gists_url": "https://api.github.com/users/sudakshina-das-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/sudakshina-das-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sudakshina-das-arm/subscriptions", "organizations_url": "https://api.github.com/users/sudakshina-das-arm/orgs", "repos_url": "https://api.github.com/users/sudakshina-das-arm/repos", "events_url": "https://api.github.com/users/sudakshina-das-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/sudakshina-das-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sudakshina-das-arm", "id": 28538945, "node_id": "MDQ6VXNlcjI4NTM4OTQ1", "avatar_url": "https://avatars.githubusercontent.com/u/28538945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sudakshina-das-arm", "html_url": "https://github.com/sudakshina-das-arm", "followers_url": "https://api.github.com/users/sudakshina-das-arm/followers", "following_url": "https://api.github.com/users/sudakshina-das-arm/following{/other_user}", "gists_url": "https://api.github.com/users/sudakshina-das-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/sudakshina-das-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sudakshina-das-arm/subscriptions", "organizations_url": "https://api.github.com/users/sudakshina-das-arm/orgs", "repos_url": "https://api.github.com/users/sudakshina-das-arm/repos", "events_url": "https://api.github.com/users/sudakshina-das-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/sudakshina-das-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e28fca09c9c72bf5631efd0f0b06d52b0ebdb4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e28fca09c9c72bf5631efd0f0b06d52b0ebdb4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e28fca09c9c72bf5631efd0f0b06d52b0ebdb4d"}], "stats": {"total": 345, "additions": 334, "deletions": 11}, "files": [{"sha": "2aa3f1fddaafae58f0bfb26e5b33fe6a94e85e06", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=54bbde550ec557e48a67ca1f4036e46710bcfeda", "patch": "@@ -510,6 +510,7 @@ bool aarch64_emit_approx_div (rtx, rtx, rtx);\n bool aarch64_emit_approx_sqrt (rtx, rtx, bool);\n void aarch64_expand_call (rtx, rtx, rtx, bool);\n bool aarch64_expand_cpymem (rtx *);\n+bool aarch64_expand_setmem (rtx *);\n bool aarch64_float_const_zero_rtx_p (rtx);\n bool aarch64_float_const_rtx_p (rtx);\n bool aarch64_function_arg_regno_p (unsigned);"}, {"sha": "0e572bac94d1a496c7878561694248ba35315e8f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=54bbde550ec557e48a67ca1f4036e46710bcfeda", "patch": "@@ -7030,6 +7030,9 @@ aarch64_gen_store_pair (machine_mode mode, rtx mem1, rtx reg1, rtx mem2,\n     case E_V4SImode:\n       return gen_vec_store_pairv4siv4si (mem1, reg1, mem2, reg2);\n \n+    case E_V16QImode:\n+      return gen_vec_store_pairv16qiv16qi (mem1, reg1, mem2, reg2);\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -21276,6 +21279,135 @@ aarch64_expand_cpymem (rtx *operands)\n   return true;\n }\n \n+/* Like aarch64_copy_one_block_and_progress_pointers, except for memset where\n+   SRC is a register we have created with the duplicated value to be set.  */\n+static void\n+aarch64_set_one_block_and_progress_pointer (rtx src, rtx *dst,\n+\t\t\t\t\t    machine_mode mode)\n+{\n+  /* If we are copying 128bits or 256bits, we can do that straight from\n+     the SIMD register we prepared.  */\n+  if (known_eq (GET_MODE_BITSIZE (mode), 256))\n+    {\n+      mode = GET_MODE (src);\n+      /* \"Cast\" the *dst to the correct mode.  */\n+      *dst = adjust_address (*dst, mode, 0);\n+      /* Emit the memset.  */\n+      emit_insn (aarch64_gen_store_pair (mode, *dst, src,\n+\t\t\t\t\t aarch64_progress_pointer (*dst), src));\n+\n+      /* Move the pointers forward.  */\n+      *dst = aarch64_move_pointer (*dst, 32);\n+      return;\n+    }\n+  if (known_eq (GET_MODE_BITSIZE (mode), 128))\n+    {\n+      /* \"Cast\" the *dst to the correct mode.  */\n+      *dst = adjust_address (*dst, GET_MODE (src), 0);\n+      /* Emit the memset.  */\n+      emit_move_insn (*dst, src);\n+      /* Move the pointers forward.  */\n+      *dst = aarch64_move_pointer (*dst, 16);\n+      return;\n+    }\n+  /* For copying less, we have to extract the right amount from src.  */\n+  rtx reg = lowpart_subreg (mode, src, GET_MODE (src));\n+\n+  /* \"Cast\" the *dst to the correct mode.  */\n+  *dst = adjust_address (*dst, mode, 0);\n+  /* Emit the memset.  */\n+  emit_move_insn (*dst, reg);\n+  /* Move the pointer forward.  */\n+  *dst = aarch64_progress_pointer (*dst);\n+}\n+\n+/* Expand setmem, as if from a __builtin_memset.  Return true if\n+   we succeed, otherwise return false.  */\n+\n+bool\n+aarch64_expand_setmem (rtx *operands)\n+{\n+  int n, mode_bits;\n+  unsigned HOST_WIDE_INT len;\n+  rtx dst = operands[0];\n+  rtx val = operands[2], src;\n+  rtx base;\n+  machine_mode cur_mode = BLKmode, next_mode;\n+\n+  /* We can't do anything smart if the amount to copy is not constant.  */\n+  if (!CONST_INT_P (operands[1]))\n+    return false;\n+\n+  bool speed_p = !optimize_function_for_size_p (cfun);\n+\n+  /* Default the maximum to 256-bytes.  */\n+  unsigned max_set_size = 256;\n+\n+  /* In case we are optimizing for size or if the core does not\n+     want to use STP Q regs, lower the max_set_size.  */\n+  max_set_size = (!speed_p\n+\t\t  || (aarch64_tune_params.extra_tuning_flags\n+\t\t      & AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS))\n+\t\t  ? max_set_size / 2 : max_set_size;\n+\n+  len = INTVAL (operands[1]);\n+\n+  /* Upper bound check.  */\n+  if (len > max_set_size)\n+    return false;\n+\n+  base = copy_to_mode_reg (Pmode, XEXP (dst, 0));\n+  dst = adjust_automodify_address (dst, VOIDmode, base, 0);\n+\n+  /* Prepare the val using a DUP/MOVI v0.16B, val.  */\n+  src = expand_vector_broadcast (V16QImode, val);\n+  src = force_reg (V16QImode, src);\n+\n+  /* Convert len to bits to make the rest of the code simpler.  */\n+  n = len * BITS_PER_UNIT;\n+\n+  /* Maximum amount to copy in one go.  We allow 256-bit chunks based on the\n+     AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS tuning parameter.  setmem expand\n+     pattern is only turned on for TARGET_SIMD.  */\n+  const int copy_limit = (speed_p\n+\t\t\t  && (aarch64_tune_params.extra_tuning_flags\n+\t\t\t      & AARCH64_EXTRA_TUNE_NO_LDP_STP_QREGS))\n+\t\t\t  ? GET_MODE_BITSIZE (TImode) : 256;\n+\n+  while (n > 0)\n+    {\n+      /* Find the largest mode in which to do the copy without\n+\t over writing.  */\n+      opt_scalar_int_mode mode_iter;\n+      FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n+\tif (GET_MODE_BITSIZE (mode_iter.require ()) <= MIN (n, copy_limit))\n+\t  cur_mode = mode_iter.require ();\n+\n+      gcc_assert (cur_mode != BLKmode);\n+\n+      mode_bits = GET_MODE_BITSIZE (cur_mode).to_constant ();\n+      aarch64_set_one_block_and_progress_pointer (src, &dst, cur_mode);\n+\n+      n -= mode_bits;\n+\n+      /* Do certain trailing copies as overlapping if it's going to be\n+\t cheaper.  i.e. less instructions to do so.  For instance doing a 15\n+\t byte copy it's more efficient to do two overlapping 8 byte copies than\n+\t 8 + 4 + 2 + 1.  */\n+      if (n > 0 && n < copy_limit / 2)\n+\t{\n+\t  next_mode = smallest_mode_for_size (n, MODE_INT);\n+\t  int n_bits = GET_MODE_BITSIZE (next_mode).to_constant ();\n+\t  gcc_assert (n_bits <= mode_bits);\n+\t  dst = aarch64_move_pointer (dst, (n - n_bits) / BITS_PER_UNIT);\n+\t  n = n_bits;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+\n /* Split a DImode store of a CONST_INT SRC to MEM DST as two\n    SImode stores.  Handle the case when the constant has identical\n    bottom and top halves.  This is beneficial when the two stores can be"}, {"sha": "d241c5b873dd97dfc9bff141614e6405392a97b0", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=54bbde550ec557e48a67ca1f4036e46710bcfeda", "patch": "@@ -1024,16 +1024,19 @@ typedef struct\n #define MOVE_RATIO(speed) \\\n   (!STRICT_ALIGNMENT ? 2 : (((speed) ? 15 : AARCH64_CALL_RATIO) / 2))\n \n-/* For CLEAR_RATIO, when optimizing for size, give a better estimate\n-   of the length of a memset call, but use the default otherwise.  */\n+/* Like MOVE_RATIO, without -mstrict-align, make decisions in \"setmem\" when\n+   we would use more than 3 scalar instructions.\n+   Otherwise follow a sensible default: when optimizing for size, give a better\n+   estimate of the length of a memset call, but use the default otherwise.  */\n #define CLEAR_RATIO(speed) \\\n-  ((speed) ? 15 : AARCH64_CALL_RATIO)\n+  (!STRICT_ALIGNMENT ? 4 : (speed) ? 15 : AARCH64_CALL_RATIO)\n \n-/* SET_RATIO is similar to CLEAR_RATIO, but for a non-zero constant, so when\n-   optimizing for size adjust the ratio to account for the overhead of loading\n-   the constant.  */\n+/* SET_RATIO is similar to CLEAR_RATIO, but for a non-zero constant.  Without\n+   -mstrict-align, make decisions in \"setmem\".  Otherwise follow a sensible\n+   default: when optimizing for size adjust the ratio to account for the\n+   overhead of loading the constant.  */\n #define SET_RATIO(speed) \\\n-  ((speed) ? 15 : AARCH64_CALL_RATIO - 2)\n+  (!STRICT_ALIGNMENT ? 0 : (speed) ? 15 : AARCH64_CALL_RATIO - 2)\n \n /* Disable auto-increment in move_by_pieces et al.  Use of auto-increment is\n    rarely a good idea in straight-line code since it adds an extra address"}, {"sha": "eed06de3240b32b753c05fd876aa1f48f5029f5c", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=54bbde550ec557e48a67ca1f4036e46710bcfeda", "patch": "@@ -1571,6 +1571,24 @@\n }\n )\n \n+;; 0 is dst\n+;; 1 is val\n+;; 2 is size of copy in bytes\n+;; 3 is alignment\n+\n+(define_expand \"setmemdi\"\n+  [(set (match_operand:BLK 0 \"memory_operand\")     ;; Dest\n+        (match_operand:QI  2 \"nonmemory_operand\")) ;; Value\n+   (use (match_operand:DI  1 \"immediate_operand\")) ;; Length\n+   (match_operand          3 \"immediate_operand\")] ;; Align\n+  \"TARGET_SIMD\"\n+{\n+  if (aarch64_expand_setmem (operands))\n+    DONE;\n+\n+  FAIL;\n+})\n+\n ;; Operands 1 and 3 are tied together by the final condition; so we allow\n ;; fairly lax checking on the second memory operation.\n (define_insn \"load_pair_sw_<SX:mode><SX2:mode>\""}, {"sha": "37df17d0b1668d8b0410f7c28b5291147c7d2ad2", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr90883.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90883.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90883.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr90883.C?ref=54bbde550ec557e48a67ca1f4036e46710bcfeda", "patch": "@@ -15,6 +15,6 @@\n \n // We want to match enough here to capture that we deleted an empty\n // constructor store\n-// aarch64 and mips will expand to loop to clear because CLEAR_RATIO.\n-// { dg-final { scan-tree-dump \"Deleted redundant store: .*\\.a = {}\" \"dse1\" { xfail { aarch64-*-* mips*-*-* } } } }\n+// mips will expand to loop to clear because CLEAR_RATIO.\n+// { dg-final { scan-tree-dump \"Deleted redundant store: .*\\.a = {}\" \"dse1\" { xfail { mips*-*-* } } } }\n "}, {"sha": "e8b1644e2ba83a9da8bb9281158a3cfb5f04c2db", "filename": "gcc/testsuite/gcc.dg/tree-prof/stringop-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c?ref=54bbde550ec557e48a67ca1f4036e46710bcfeda", "patch": "@@ -20,6 +20,6 @@ main()\n    return 0;\n }\n /* autofdo doesn't support value profiling for now: */\n-/* { dg-final-use-not-autofdo { scan-ipa-dump \"Transformation done: single value 4 stringop\" \"profile\"} } */\n+/* { dg-final-use-not-autofdo { scan-ipa-dump \"Transformation done: single value 4 stringop\" \"profile\" { target { ! aarch64*-*-* } } } } */\n /* The versioned memset of size 4 should be optimized to an assignment.\n-   { dg-final-use-not-autofdo { scan-tree-dump \"MEM <\\[a-z \\]+> \\\\\\[\\\\(void .\\\\)&a\\\\\\] = 168430090\" \"optimized\" } } */\n+   { dg-final-use-not-autofdo { scan-tree-dump \"MEM <\\[a-z \\]+> \\\\\\[\\\\(void .\\\\)&a\\\\\\] = 168430090\" \"optimized\" { target { ! aarch64*-*-* } } } } */"}, {"sha": "c43f0199adcd348370edabf045a532e9abb436e7", "filename": "gcc/testsuite/gcc.target/aarch64/memset-corner-cases.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-corner-cases.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-corner-cases.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-corner-cases.c?ref=54bbde550ec557e48a67ca1f4036e46710bcfeda", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include <stdint.h>\n+\n+/* One byte variable set should be scalar\n+**set1byte:\n+**\tstrb\tw1, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set1byte (int64_t *src, char c)\n+{\n+  __builtin_memset (src, c, 1);\n+}\n+\n+/* Special cases for setting 0.  */\n+/* 1-byte should be STRB with wzr\n+**set0byte:\n+**\tstrb\twzr, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set0byte (int64_t *src)\n+{\n+  __builtin_memset (src, 0, 1);\n+}\n+\n+/* 35bytes would become 4 scalar instructions.  So favour NEON.\n+**set0neon:\n+**\tmovi\tv0.4s, 0\n+**\tstp\tq0, q0, \\[x0\\]\n+**\tstr\twzr, \\[x0, 31\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set0neon (int64_t *src)\n+{\n+  __builtin_memset (src, 0, 35);\n+}\n+\n+/* 36bytes should be scalar however.\n+**set0scalar:\n+**\tstp\txzr, xzr, \\[x0\\]\n+**\tstp\txzr, xzr, \\[x0, 16\\]\n+**\tstr\twzr, \\[x0, 32\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set0scalar (int64_t *src)\n+{\n+  __builtin_memset (src, 0, 36);\n+}\n+\n+\n+/* 256-bytes expanded\n+**set256byte:\n+**\tdup\tv0.16b, w1\n+**\tstp\tq0, q0, \\[x0\\]\n+**\tstp\tq0, q0, \\[x0, 32\\]\n+**\tstp\tq0, q0, \\[x0, 64\\]\n+**\tstp\tq0, q0, \\[x0, 96\\]\n+**\tstp\tq0, q0, \\[x0, 128\\]\n+**\tstp\tq0, q0, \\[x0, 160\\]\n+**\tstp\tq0, q0, \\[x0, 192\\]\n+**\tstp\tq0, q0, \\[x0, 224\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set256byte (int64_t *src, char c)\n+{\n+  __builtin_memset (src, c, 256);\n+}\n+\n+/* More than 256 bytes goes to memset\n+**set257byte:\n+**\tmov\tx2, 257\n+**\tmov\tw1, 99\n+**\tb\tmemset\n+*/\n+void __attribute__((__noinline__))\n+set257byte (int64_t *src)\n+{\n+  __builtin_memset (src, 'c', 257);\n+}\n+\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */"}, {"sha": "156146badbcd98e63d873a4a1c7657f19c027973", "filename": "gcc/testsuite/gcc.target/aarch64/memset-q-reg.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-q-reg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bbde550ec557e48a67ca1f4036e46710bcfeda/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-q-reg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fmemset-q-reg.c?ref=54bbde550ec557e48a67ca1f4036e46710bcfeda", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include <stdint.h>\n+\n+/*\n+**set128bits:\n+**\tdup\tv0.16b, w1\n+**\tstr\tq0, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set128bits (int64_t *src, char c)\n+{\n+  __builtin_memset (src, c, 2*sizeof(int64_t));\n+}\n+\n+/*\n+**set128bitszero:\n+**\tstp\txzr, xzr, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set128bitszero (int64_t *src)\n+{\n+  __builtin_memset (src, 0, 2*sizeof(int64_t));\n+}\n+\n+/*\n+** set128bitsplus:\n+**\tdup\tv0.16b, w1\n+**\tstr\tq0, \\[x0\\]\n+**\tstr\tq0, \\[x0, 12\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set128bitsplus (int64_t *src, char c)\n+{\n+  __builtin_memset (src, c, 7*sizeof(int32_t));\n+}\n+\n+/*\n+** set256bits:\n+**\tmovi\tv0.16b, 0x63\n+**\tstp\tq0, q0, \\[x0\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set256bits (int64_t *src)\n+{\n+  __builtin_memset (src, 'c', 4*sizeof(int64_t));\n+}\n+\n+/*\n+**set256bitszero:\n+**\tstp\txzr, xzr, \\[x0\\]\n+**\tstp\txzr, xzr, \\[x0, 16\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set256bitszero (int64_t *src)\n+{\n+  __builtin_memset (src, 0, 4*sizeof(int64_t));\n+}\n+\n+/*\n+** set256bitsplus:\n+**\tmovi\tv0.16b, 0x63\n+**\tstp\tq0, q0, \\[x0\\]\n+**\tstr\tq0, \\[x0, 32\\]\n+**\tstr\td0, \\[x0, 48\\]\n+**\tret\n+*/\n+void __attribute__((__noinline__))\n+set256bitsplus (int64_t *src)\n+{\n+  __builtin_memset (src, 'c', 7*sizeof(int64_t));\n+}\n+\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" } } */"}]}