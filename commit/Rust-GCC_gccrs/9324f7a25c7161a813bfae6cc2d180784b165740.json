{"sha": "9324f7a25c7161a813bfae6cc2d180784b165740", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMyNGY3YTI1YzcxNjFhODEzYmZhZTZjYzJkMTgwNzg0YjE2NTc0MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-12-11T19:37:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-12-11T20:41:02Z"}, "message": "c++: Avoid considering some conversion ops [PR97600]\n\nPatrick's earlier patch to check convertibility before constraints for\nconversion ops wasn't suitable because checking convertibility can also lead\nto unwanted instantiations, but it occurs to me that there's a smaller check\nwe can do to avoid doing normal consideration of the conversion ops in this\ncase: since we're in the middle of a user-defined conversion, we can exclude\nfrom consideration any conversion ops that return a type that would need an\nadditional user-defined conversion to reach the desired type: namely, a type\nthat differs in class-ness from the desired type.\n\n[temp.inst]/9 allows optimizations like this: \"If the function selected by\noverload resolution can be determined without instantiating a class template\ndefinition, it is unspecified whether that instantiation actually takes\nplace.\"\n\ngcc/cp/ChangeLog:\n\n\tPR libstdc++/97600\n\t* call.c (build_user_type_conversion_1): Avoid considering\n\tconversion functions that return a clearly unsuitable type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-conv3.C: New test.", "tree": {"sha": "4301375bb12ac00dd881ca8429bf08be4a112a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4301375bb12ac00dd881ca8429bf08be4a112a6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9324f7a25c7161a813bfae6cc2d180784b165740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9324f7a25c7161a813bfae6cc2d180784b165740", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9324f7a25c7161a813bfae6cc2d180784b165740", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9324f7a25c7161a813bfae6cc2d180784b165740/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bab7dce62e321e722346ba2db2d381bdf3fbe4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bab7dce62e321e722346ba2db2d381bdf3fbe4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bab7dce62e321e722346ba2db2d381bdf3fbe4b"}], "stats": {"total": 60, "additions": 59, "deletions": 1}, "files": [{"sha": "c2d62e582bf9e4b930e58af4dfdc4732e348367b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9324f7a25c7161a813bfae6cc2d180784b165740/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9324f7a25c7161a813bfae6cc2d180784b165740/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9324f7a25c7161a813bfae6cc2d180784b165740", "patch": "@@ -4025,9 +4025,9 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n        creating a garbage BASELINK; constructors can't be inherited.  */\n     ctors = get_class_binding (totype, complete_ctor_identifier);\n \n+  tree to_nonref = non_reference (totype);\n   if (MAYBE_CLASS_TYPE_P (fromtype))\n     {\n-      tree to_nonref = non_reference (totype);\n       if (same_type_ignoring_top_level_qualifiers_p (to_nonref, fromtype) ||\n \t  (CLASS_TYPE_P (to_nonref) && CLASS_TYPE_P (fromtype)\n \t   && DERIVED_FROM_P (to_nonref, fromtype)))\n@@ -4111,6 +4111,22 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n       tree conversion_path = TREE_PURPOSE (conv_fns);\n       struct z_candidate *old_candidates;\n \n+      /* If LOOKUP_NO_CONVERSION, don't consider a conversion function that\n+\t would need an addional user-defined conversion, i.e. if the return\n+\t type differs in class-ness from the desired type.  So we avoid\n+\t considering operator bool when calling a copy constructor.\n+\n+\t This optimization avoids the failure in PR97600, and is allowed by\n+\t [temp.inst]/9: \"If the function selected by overload resolution can be\n+\t determined without instantiating a class template definition, it is\n+\t unspecified whether that instantiation actually takes place.\"\t*/\n+      tree convtype = non_reference (TREE_TYPE (conv_fns));\n+      if ((flags & LOOKUP_NO_CONVERSION)\n+\t  && !WILDCARD_TYPE_P (convtype)\n+\t  && (CLASS_TYPE_P (to_nonref)\n+\t      != CLASS_TYPE_P (convtype)))\n+\tcontinue;\n+\n       /* If we are called to convert to a reference type, we are trying to\n \t find a direct binding, so don't even consider temporaries.  If\n \t we don't find a direct binding, the caller will try again to"}, {"sha": "d53f37c10e67bda806e1fd91187a0f642308ac48", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-conv3.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9324f7a25c7161a813bfae6cc2d180784b165740/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-conv3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9324f7a25c7161a813bfae6cc2d180784b165740/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-conv3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-conv3.C?ref=9324f7a25c7161a813bfae6cc2d180784b165740", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile { target c++20 } }\n+\n+// Here, normal overload resolution would consider B::operator bool when\n+// evaluating A(b), leading to a hard error instantiating Error<int>, but we\n+// avoid considering it by noticing that converting bool (a scalar) to A (a\n+// class) would require a user-defined conversion, which is not allowed when\n+// we're already dealing with the user-defined conversion to A.\n+\n+// This seems to be allowed by [temp.inst]/9: \"If the function selected by\n+// overload resolution (12.4) can be determined without instantiating a class\n+// template definition, it is unspecified whether that instantiation actually\n+// takes place.\"\n+\n+template <class T>\n+struct Error { static constexpr auto value = T::value; };\n+\n+struct A { A(const A&); };\n+\n+template <class T>\n+struct B { operator bool() requires Error<T>::value; };\n+\n+template <class T>\n+concept C = requires (B<T> b) { A(b); };\n+\n+static_assert(!C<int>);"}, {"sha": "7e9e28474d9471169f6a0c89c60075d877b6a172", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-conv3a.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9324f7a25c7161a813bfae6cc2d180784b165740/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-conv3a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9324f7a25c7161a813bfae6cc2d180784b165740/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-conv3a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-conv3a.C?ref=9324f7a25c7161a813bfae6cc2d180784b165740", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++20 } }\n+\n+// But make sure we do consider template conversions that could produce the\n+// right type.\n+\n+template <class T>\n+struct Error { static constexpr auto value = T::value; }; // { dg-error \"not a member\" }\n+\n+struct A { A(const A&); };\n+\n+template <class T>\n+struct B { template <class U> operator U() requires Error<T>::value; };\n+\n+template <class T>\n+concept C = requires (B<T> b) { A(b); }; // { dg-message \"required from here\" }\n+\n+static_assert(!C<int>);"}]}