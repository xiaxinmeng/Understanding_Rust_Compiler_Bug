{"sha": "33c25e5c5a69b096d8aafef5599bf93672dd3659", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNjMjVlNWM1YTY5YjA5NmQ4YWFmZWY1NTk5YmY5MzY3MmRkMzY1OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-10-19T23:24:20Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-10-19T23:24:20Z"}, "message": "call.c (struct conversion): Add base_p.\n\n\t* call.c (struct conversion): Add base_p.\n\t(convert_like): Add c_cast_p argument.\n\t(convert_like_with_conversion): Likewise.\n\t(build_conv): Clear base_p.\n\t(standard_conversion): Set it, for derived-to-base conversions.\n\t(convert_like_real): Add c_cast_p parameter.  Handle pointer\n\tconversions directly rather than relying on ocp_convert.\n\t(perform_direct_initialization_if_possible): Add c_cast_p\n\tparameter.\n\t* cp-tree.h (perform_direct_initialization_if_possible): Change\n\tprototype.\n\t(convert_member_func_to_ptr): New function.\n\t* typeck.c (check_for_casting_away_constness): Add diag_fn\n\tparameter.\n\t(build_static_cast_1): New function, split out from ...\n\t(build_static_cast): ... here.  Use build_static_cast_1.\n\t(build_reinterpret_cast_1): New function, split out from ...\n\t(build_reinterpret_cast): ... here.  Use build_reinterpret_cast_1.\n\t(build_const_cast_1): New function, split out from ...\n\t(build_const_cast): ... here.  Use build_const_cast_1.\n\t(build_c_cast): Rewrite to use build_const_cast_1,\n\tbuild_static_cast_1, and build_reinterpret_cast_1.\n\t(convert_member_func_to_ptr): New function.\n\n\t* g++.dg/conversion/reinterpret1.C: Adjust error markers.\n\t* g++.dg/conversion/const2.C: New test.\n\t* g++.dg/expr/reinterpret2.C: New test.\n\t* g++.dg/expr/reinterpret3.C: New test.\n\t* g++.dg/expr/cast2.C: New test.\n\t* g++.dg/expr/copy1.C: New test.\n\t* g++.dg/other/conversion1.C: Change error message.\n\t* g++.dg/parse/comma1.C: Use __extension__ to allow casts from\n\tfunction pointers to void *.\n\t* g++.old-deja/g++.mike/p10148.C: Likewise.\n\nFrom-SVN: r89300", "tree": {"sha": "d0037995674537cc4efa3c0fd0c2f61cfe82efed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0037995674537cc4efa3c0fd0c2f61cfe82efed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33c25e5c5a69b096d8aafef5599bf93672dd3659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c25e5c5a69b096d8aafef5599bf93672dd3659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33c25e5c5a69b096d8aafef5599bf93672dd3659", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33c25e5c5a69b096d8aafef5599bf93672dd3659/comments", "author": null, "committer": null, "parents": [{"sha": "b55d57460298a5e0f675b1e7a2af84690cb14f4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55d57460298a5e0f675b1e7a2af84690cb14f4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b55d57460298a5e0f675b1e7a2af84690cb14f4d"}], "stats": {"total": 799, "additions": 542, "deletions": 257}, "files": [{"sha": "0247ca5df93f9cfdfa8510619d2a56d9ef51065c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -1,3 +1,30 @@\n+2004-10-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14035\n+\t* call.c (struct conversion): Add base_p.\n+\t(convert_like): Add c_cast_p argument.\n+\t(convert_like_with_conversion): Likewise.\n+\t(build_conv): Clear base_p.\n+\t(standard_conversion): Set it, for derived-to-base conversions.\n+\t(convert_like_real): Add c_cast_p parameter.  Handle pointer\n+\tconversions directly rather than relying on ocp_convert.\n+\t(perform_direct_initialization_if_possible): Add c_cast_p\n+\tparameter.\n+\t* cp-tree.h (perform_direct_initialization_if_possible): Change\n+\tprototype.\n+\t(convert_member_func_to_ptr): New function.\n+\t* typeck.c (check_for_casting_away_constness): Add diag_fn\n+\tparameter.\n+\t(build_static_cast_1): New function, split out from ...\n+\t(build_static_cast): ... here.  Use build_static_cast_1.\n+\t(build_reinterpret_cast_1): New function, split out from ...\n+\t(build_reinterpret_cast): ... here.  Use build_reinterpret_cast_1.\n+\t(build_const_cast_1): New function, split out from ...\n+\t(build_const_cast): ... here.  Use build_const_cast_1.\n+\t(build_c_cast): Rewrite to use build_const_cast_1,\n+\tbuild_static_cast_1, and build_reinterpret_cast_1.\n+\t(convert_member_func_to_ptr): New function.\n+\n 2004-10-19  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR c++/18047"}, {"sha": "c535cbacca5a210a58ccef750643cf25989f4b4e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -92,6 +92,9 @@ struct conversion {\n      copy constructor must be accessible, even though it is not being\n      used.  */\n   BOOL_BITFIELD check_copy_constructor_p : 1;\n+  /* If KIND is ck_ptr, true to indicate that a conversion from a\n+     pointer-to-derived to pointer-to-base is being performed.  */\n+  BOOL_BITFIELD base_p : 1;\n   /* The type of the expression resulting from the conversion.  */\n   tree type;\n   union {\n@@ -125,12 +128,15 @@ static int compare_ics (conversion *, conversion *);\n static tree build_over_call (struct z_candidate *, int);\n static tree build_java_interface_fn_ref (tree, tree);\n #define convert_like(CONV, EXPR)\t\t\t\t\\\n-  convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0, \t\t\\\n-\t\t     /*issue_conversion_warnings=*/true)\n+  convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0,\t\t\\\n+\t\t     /*issue_conversion_warnings=*/true,\t\\\n+\t\t     /*c_cast_p=*/false)\n #define convert_like_with_context(CONV, EXPR, FN, ARGNO)\t\\\n-  convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0, \t\t\\\n-\t\t     /*issue_conversion_warnings=*/true)\n-static tree convert_like_real (conversion *, tree, tree, int, int, bool);\n+  convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0,\t\t\\\n+\t\t     /*issue_conversion_warnings=*/true,\t\\\n+                     /*c_cast_p=*/false)\n+static tree convert_like_real (conversion *, tree, tree, int, int, bool,\n+\t\t\t       bool);\n static void op_error (enum tree_code, enum tree_code, tree, tree,\n \t\t\t    tree, const char *);\n static tree build_object_call (tree, tree);\n@@ -528,6 +534,7 @@ build_conv (conversion_kind code, tree type, conversion *from)\n   t->rank = rank;\n   t->user_conv_p = (code == ck_user || from->user_conv_p);\n   t->bad_p = from->bad_p;\n+  t->base_p = false;\n   return t;\n }\n \n@@ -721,6 +728,7 @@ standard_conversion (tree to, tree from, tree expr)\n \t\t\t\t     cp_type_quals (TREE_TYPE (from)));\n \t  from = build_pointer_type (from);\n \t  conv = build_conv (ck_ptr, from, conv);\n+\t  conv->base_p = true;\n \t}\n \n       if (tcode == POINTER_TYPE)\n@@ -4113,11 +4121,14 @@ build_temp (tree expr, tree type, int flags,\n    being called to continue a conversion chain. It is negative when a\n    reference binding will be applied, positive otherwise.  If\n    ISSUE_CONVERSION_WARNINGS is true, warnings about suspicious\n-   conversions will be emitted if appropriate.  */\n+   conversions will be emitted if appropriate.  If C_CAST_P is true,\n+   this conversion is coming from a C-style cast; in that case,\n+   conversions to inaccessible bases are permitted.  */\n \n static tree\n convert_like_real (conversion *convs, tree expr, tree fn, int argnum, \n-\t\t   int inner, bool issue_conversion_warnings)\n+\t\t   int inner, bool issue_conversion_warnings,\n+\t\t   bool c_cast_p)\n {\n   tree totype = convs->type;\n   void (*diagnostic_fn)(const char *, ...);\n@@ -4133,12 +4144,14 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  if (t->kind == ck_user || !t->bad_p)\n \t    {\n \t      expr = convert_like_real (t, expr, fn, argnum, 1,\n-\t\t\t\t\t/*issue_conversion_warnings=*/false);\n+\t\t\t\t\t/*issue_conversion_warnings=*/false,\n+\t\t\t\t\t/*c_cast_p=*/false);\n \t      break;\n \t    }\n \t  else if (t->kind == ck_ambig)\n \t    return convert_like_real (t, expr, fn, argnum, 1,\n-\t\t\t\t      /*issue_conversion_warnings=*/false);\n+\t\t\t\t      /*issue_conversion_warnings=*/false,\n+\t\t\t\t      /*c_cast_p=*/false);\n \t  else if (t->kind == ck_identity)\n \t    break;\n \t}\n@@ -4237,7 +4250,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \n   expr = convert_like_real (convs->u.next, expr, fn, argnum,\n \t\t\t    convs->kind == ck_ref_bind ? -1 : 1,\n-\t\t\t    /*issue_conversion_warnings=*/false);\n+\t\t\t    /*issue_conversion_warnings=*/false,\n+\t\t\t    c_cast_p);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n@@ -4321,7 +4335,22 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       /* Warn about deprecated conversion if appropriate.  */\n       string_conv_p (totype, expr, 1);\n       break;\n-      \n+\n+    case ck_ptr:\n+      if (convs->base_p)\n+\t{\n+\t  tree binfo;\n+\n+\t  binfo = lookup_base (TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t       TREE_TYPE (totype), \n+\t\t\t       c_cast_p ? ba_unique : ba_check,\n+\t\t\t       NULL);\n+\t  if (binfo == error_mark_node)\n+\t    return error_mark_node;\n+\t  expr = build_base_path (PLUS_EXPR, expr, binfo, /*nonnull=*/0);\n+\t}\n+      return build_nop (totype, expr);\n+\n     default:\n       break;\n     }\n@@ -6273,10 +6302,15 @@ perform_implicit_conversion (tree type, tree expr)\n /* Convert EXPR to TYPE (as a direct-initialization) if that is\n    permitted.  If the conversion is valid, the converted expression is\n    returned.  Otherwise, NULL_TREE is returned, except in the case\n-   that TYPE is a class type; in that case, an error is issued.  */\n+   that TYPE is a class type; in that case, an error is issued.  If\n+   C_CAST_P is ttrue, then this direction initialization is taking\n+   place as part of a static_cast being attempted as part of a C-style\n+   cast.  */\n \n tree\n-perform_direct_initialization_if_possible (tree type, tree expr)\n+perform_direct_initialization_if_possible (tree type, \n+\t\t\t\t\t   tree expr,\n+\t\t\t\t\t   bool c_cast_p)\n {\n   conversion *conv;\n   void *p;\n@@ -6308,7 +6342,8 @@ perform_direct_initialization_if_possible (tree type, tree expr)\n     expr = NULL_TREE;\n   else\n     expr = convert_like_real (conv, expr, NULL_TREE, 0, 0, \n-\t\t\t      /*issue_conversion_warnings=*/false);\n+\t\t\t      /*issue_conversion_warnings=*/false,\n+\t\t\t      c_cast_p);\n \n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n@@ -6449,7 +6484,8 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n       expr = convert_like_real (conv, expr,\n \t\t\t\t/*fn=*/NULL_TREE, /*argnum=*/0,\n \t\t\t\t/*inner=*/-1,\n-\t\t\t\t/*issue_conversion_warnings=*/true);\n+\t\t\t\t/*issue_conversion_warnings=*/true,\n+\t\t\t\t/*c_cast_p=*/false);\n       if (!real_lvalue_p (expr))\n \t{\n \t  tree init;"}, {"sha": "6534170392ef205834b0ece64b4d79fe6c2a2505", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -3585,7 +3585,7 @@ extern tree initialize_reference (tree, tree, tree, tree *);\n extern tree make_temporary_var_for_ref_to_temp (tree, tree);\n extern tree strip_top_quals (tree);\n extern tree perform_implicit_conversion (tree, tree);\n-extern tree perform_direct_initialization_if_possible (tree, tree);\n+extern tree perform_direct_initialization_if_possible (tree, tree, bool);\n extern tree in_charge_arg_for_name (tree);\n extern tree build_cxx_call (tree, tree);\n #ifdef ENABLE_CHECKING\n@@ -4290,6 +4290,7 @@ extern tree build_nop                           (tree, tree);\n extern tree non_reference                       (tree);\n extern tree lookup_anon_field                   (tree, tree);\n extern bool invalid_nonstatic_memfn_p           (tree);\n+extern tree convert_member_func_to_ptr          (tree, tree);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);"}, {"sha": "02230301117164058a4da2feb0ed20f40a1e71b2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -107,28 +107,9 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n       && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t  || VOID_TYPE_P (TREE_TYPE (type))))\n     {\n-      /* Allow an implicit this pointer for pointer to member\n-\t functions.  */\n-      if (TYPE_PTRMEMFUNC_P (intype))\n-\t{\n-\t  if (pedantic || warn_pmf2ptr)\n-\t    pedwarn (\"converting from `%T' to `%T'\", intype, type);\n-\t  if (TREE_CODE (expr) == PTRMEM_CST)\n-\t    expr = build_address (PTRMEM_CST_MEMBER (expr));\n-\t  else\n-\t    {\n-\t      tree decl = maybe_dummy_object (TYPE_PTRMEM_CLASS_TYPE (intype), \n-\t\t\t\t\t      0);\n-\t      decl = build_address (decl);\n-\t      expr = get_member_function_from_ptrfunc (&decl, expr);\n-\t    }\n-\t}\n-      else if (TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n-\t{\n-\t  if (pedantic || warn_pmf2ptr)\n-\t    pedwarn (\"converting from `%T' to `%T'\", intype, type);\n-\t  expr = build_addr_func (expr);\n-\t}\n+      if (TYPE_PTRMEMFUNC_P (intype)\n+\t  || TREE_CODE (intype) == METHOD_TYPE)\n+\treturn convert_member_func_to_ptr (type, expr);\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \treturn build_nop (type, expr);\n       intype = TREE_TYPE (expr);"}, {"sha": "bff5c348e8d418116822adc7e9b9ceba2a44756a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 386, "deletions": 217, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -4468,47 +4468,58 @@ build_compound_expr (tree lhs, tree rhs)\n   return build2 (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);\n }\n \n-/* Issue an error message if casting from SRC_TYPE to DEST_TYPE casts\n-   away constness.  DESCRIPTION explains what operation is taking\n-   place.  */\n+/* Issue a diagnostic message if casting from SRC_TYPE to DEST_TYPE\n+   casts away constness.  DIAG_FN gives the function to call if we\n+   need to issue a diagnostic; if it is NULL, no diagnostic will be\n+   issued.  DESCRIPTION explains what operation is taking place.  */\n \n static void\n check_for_casting_away_constness (tree src_type, tree dest_type,\n+\t\t\t\t  void (*diag_fn)(const char *, ...),\n \t\t\t\t  const char *description)\n {\n-  if (casts_away_constness (src_type, dest_type))\n+  if (diag_fn && casts_away_constness (src_type, dest_type))\n     error (\"%s from type %qT to type %qT casts away constness\",\n \t   description, src_type, dest_type);\n }\n \n-/* Return an expression representing static_cast<TYPE>(EXPR).  */\n+/* Perform a static_cast from EXPR to TYPE.  When C_CAST_P is true,\n+   this static_cast is being attempted as one of the possible casts\n+   allowed by a C-style cast.  (In that case, accessibility of base\n+   classes is not considered, and it is OK to cast away\n+   constness.)  Return the result of the cast.  *VALID_P is set to\n+   indicate whether or not the cast was valid.  */\n \n-tree\n-build_static_cast (tree type, tree expr)\n+static tree\n+build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n+\t\t     bool *valid_p)\n {\n   tree intype;\n   tree result;\n+  tree orig;\n+  void (*diag_fn)(const char*, ...);\n+  const char *desc;\n \n-  if (type == error_mark_node || expr == error_mark_node)\n-    return error_mark_node;\n-\n-  if (processing_template_decl)\n-    {\n-      expr = build_min (STATIC_CAST_EXPR, type, expr);\n-      /* We don't know if it will or will not have side effects.  */\n-      TREE_SIDE_EFFECTS (expr) = 1;\n-      return expr;\n-    }\n-\n-  /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n-     Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n-  if (TREE_CODE (type) != REFERENCE_TYPE\n-      && TREE_CODE (expr) == NOP_EXPR\n-      && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n-    expr = TREE_OPERAND (expr, 0);\n+  /* Assume the cast is valid.  */\n+  *valid_p = true;\n \n   intype = TREE_TYPE (expr);\n \n+  /* Determine what to do when casting away constness.  */\n+  if (c_cast_p)\n+    {\n+      /* C-style casts are allowed to cast away constness.  With\n+\t WARN_CAST_QUAL, we still want to issue a warning.  */ \n+      diag_fn = warn_cast_qual ? warning : NULL;\n+      desc = \"cast\";\n+    }\n+  else\n+    {\n+      /* A static_cast may not cast away constness.  */\n+      diag_fn = error;\n+      desc = \"static_cast\";\n+    }\n+      \n   /* [expr.static.cast]\n \n      An lvalue of type \"cv1 B\", where B is a class type, can be cast\n@@ -4536,12 +4547,20 @@ build_static_cast (tree type, tree expr)\n       && can_convert (build_pointer_type (TYPE_MAIN_VARIANT (intype)),\n \t\t      build_pointer_type (TYPE_MAIN_VARIANT \n \t\t\t\t\t  (TREE_TYPE (type))))\n-      && at_least_as_qualified_p (TREE_TYPE (type), intype))\n+      && (c_cast_p\n+\t  || at_least_as_qualified_p (TREE_TYPE (type), intype)))\n     {\n+      tree base;\n+\n       /* There is a standard conversion from \"D*\" to \"B*\" even if \"B\"\n-\t is ambiguous or inaccessible.  Therefore, we ask lookup_base\n-\t to check these conditions.  */\n-      tree base = lookup_base (TREE_TYPE (type), intype, ba_check, NULL);\n+\t is ambiguous or inaccessible.  If this is really a\n+\t static_cast, then we check both for inaccessibility and\n+\t ambiguity.  However, if this is a static_cast being performed\n+\t because the user wrote a C-style cast, then accessibility is\n+\t not considered.  */\n+      base = lookup_base (TREE_TYPE (type), intype, \n+\t\t\t  c_cast_p ? ba_unique : ba_check, \n+\t\t\t  NULL);\n \n       /* Convert from \"B*\" to \"D*\".  This function will check that \"B\"\n \t is not a virtual base of \"D\".  */\n@@ -4552,16 +4571,28 @@ build_static_cast (tree type, tree expr)\n       return convert_from_reference (build_nop (type, expr));\n     }\n \n+  orig = expr;\n+\n   /* [expr.static.cast]\n \n      An expression e can be explicitly converted to a type T using a\n      static_cast of the form static_cast<T>(e) if the declaration T\n      t(e);\" is well-formed, for some invented temporary variable\n      t.  */\n-  result = perform_direct_initialization_if_possible (type, expr);\n+  result = perform_direct_initialization_if_possible (type, expr,\n+\t\t\t\t\t\t      c_cast_p);\n   if (result)\n     {\n       result = convert_from_reference (result);\n+\n+      /* Ignore any integer overflow caused by the cast.  */\n+      if (TREE_CODE (result) == INTEGER_CST\n+\t  && CONSTANT_CLASS_P (orig))\n+\t{\n+\t  TREE_OVERFLOW (result) = TREE_OVERFLOW (orig);\n+\t  TREE_CONSTANT_OVERFLOW (result)\n+\t    = TREE_CONSTANT_OVERFLOW (orig);\n+\t}\n       /* [expr.static.cast]\n \n          If T is a reference type, the result is an lvalue; otherwise,\n@@ -4598,10 +4629,20 @@ build_static_cast (tree type, tree expr)\n \t converted to an enumeration type.  */\n       || (INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n \t  && INTEGRAL_OR_ENUMERATION_TYPE_P (intype)))\n-    /* Really, build_c_cast should defer to this function rather\n-       than the other way around.  */\n-    return build_c_cast (type, expr);\n-  \n+    {\n+      expr = decl_constant_value (expr);\n+      expr = ocp_convert (type, expr, CONV_C_CAST, LOOKUP_NORMAL);\n+\n+      /* Ignore any integer overflow caused by the cast.  */\n+      if (TREE_CODE (expr) == INTEGER_CST\n+\t  && CONSTANT_CLASS_P (orig))\n+\t{\n+\t  TREE_OVERFLOW (expr) = TREE_OVERFLOW (orig);\n+\t  TREE_CONSTANT_OVERFLOW (expr) = TREE_CONSTANT_OVERFLOW (orig);\n+\t}\n+      return expr;\n+    }\n+\n   if (TYPE_PTR_P (type) && TYPE_PTR_P (intype)\n       && CLASS_TYPE_P (TREE_TYPE (type))\n       && CLASS_TYPE_P (TREE_TYPE (intype))\n@@ -4612,8 +4653,10 @@ build_static_cast (tree type, tree expr)\n     {\n       tree base;\n \n-      check_for_casting_away_constness (intype, type, \"static_cast\");\n-      base = lookup_base (TREE_TYPE (type), TREE_TYPE (intype), ba_check, \n+      if (!c_cast_p)\n+\tcheck_for_casting_away_constness (intype, type, diag_fn, desc);\n+      base = lookup_base (TREE_TYPE (type), TREE_TYPE (intype), \n+\t\t\t  c_cast_p ? ba_unique : ba_check, \n \t\t\t  NULL);\n       return build_base_path (MINUS_EXPR, expr, base, /*nonnull=*/false);\n     }\n@@ -4645,7 +4688,8 @@ build_static_cast (tree type, tree expr)\n \t}\n       if (can_convert (t1, t2))\n \t{\n-\t  check_for_casting_away_constness (intype, type, \"static_cast\");\n+\t  if (!c_cast_p)\n+\t    check_for_casting_away_constness (intype, type, diag_fn, desc);\n \t  if (TYPE_PTRMEM_P (type))\n \t    {\n \t      tree delta;\n@@ -4675,77 +4719,180 @@ build_static_cast (tree type, tree expr)\n       && VOID_TYPE_P (TREE_TYPE (intype))\n       && TYPE_PTROB_P (type))\n     {\n-      check_for_casting_away_constness (intype, type, \"static_cast\");\n+      if (!c_cast_p)\n+\tcheck_for_casting_away_constness (intype, type, diag_fn, desc);\n       return build_nop (type, expr);\n     }\n \n-  error (\"invalid static_cast from type %qT to type %qT\", intype, type);\n+  *valid_p = false;\n   return error_mark_node;\n }\n \n+/* Return an expression representing static_cast<TYPE>(EXPR).  */\n+\n tree\n-build_reinterpret_cast (tree type, tree expr)\n+build_static_cast (tree type, tree expr)\n {\n-  tree intype;\n+  tree result;\n+  bool valid_p;\n \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n   if (processing_template_decl)\n     {\n-      tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n-      \n-      if (!TREE_SIDE_EFFECTS (t)\n-\t  && type_dependent_expression_p (expr))\n-\t/* There might turn out to be side effects inside expr.  */\n-\tTREE_SIDE_EFFECTS (t) = 1;\n-      return t;\n+      expr = build_min (STATIC_CAST_EXPR, type, expr);\n+      /* We don't know if it will or will not have side effects.  */\n+      TREE_SIDE_EFFECTS (expr) = 1;\n+      return expr;\n     }\n \n-  if (TREE_CODE (type) != REFERENCE_TYPE)\n-    {\n-      expr = decay_conversion (expr);\n+  /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n+     Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n+  if (TREE_CODE (type) != REFERENCE_TYPE\n+      && TREE_CODE (expr) == NOP_EXPR\n+      && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n+    expr = TREE_OPERAND (expr, 0);\n \n-      /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n-\t Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n-      if (TREE_CODE (expr) == NOP_EXPR\n-\t  && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n-\texpr = TREE_OPERAND (expr, 0);\n-    }\n+  result = build_static_cast_1 (type, expr, /*c_cast_p=*/false, &valid_p);\n+  if (valid_p)\n+    return result;\n+\n+  error (\"invalid static_cast from type %qT to type %qT\", \n+\t TREE_TYPE (expr), type);\n+  return error_mark_node;\n+}\n+\n+/* EXPR is an expression with member function or pointer-to-member\n+   function type.  TYPE is a pointer type.  Converting EXPR to TYPE is\n+   not permitted by ISO C++, but we accept it in some modes.  If we\n+   are not in one of those modes, issue a diagnostic.  Return the\n+   converted expression.  */\n+\n+tree\n+convert_member_func_to_ptr (tree type, tree expr)\n+{\n+  tree intype;\n+  tree decl;\n \n   intype = TREE_TYPE (expr);\n+  gcc_assert (TYPE_PTRMEMFUNC_P (intype)\n+\t      || TREE_CODE (intype) == METHOD_TYPE);\n \n-  if (intype == error_mark_node)\n+  if (pedantic || warn_pmf2ptr)\n+    pedwarn (\"converting from `%T' to `%T'\", intype, type);\n+    \n+  if (TREE_CODE (intype) == METHOD_TYPE)\n+    expr = build_addr_func (expr);\n+  else if (TREE_CODE (expr) == PTRMEM_CST)\n+    expr = build_address (PTRMEM_CST_MEMBER (expr));\n+  else\n+    {\n+      decl = maybe_dummy_object (TYPE_PTRMEM_CLASS_TYPE (intype), 0);\n+      decl = build_address (decl);\n+      expr = get_member_function_from_ptrfunc (&decl, expr);\n+    }\n+\n+  return build_nop (type, expr);\n+}\n+\n+/* Return a representation for a reinterpret_cast from EXPR to TYPE.\n+   If C_CAST_P is true, this reinterpret cast is being done as part of\n+   a C-style cast.  If VALID_P is non-NULL, *VALID_P is set to\n+   indicate whether or not reinterpret_cast was valid.  */\n+\n+static tree\n+build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n+\t\t\t  bool *valid_p)\n+{\n+  tree intype;\n+\n+  /* Assume the cast is invalid.  */\n+  if (valid_p)\n+    *valid_p = true;\n+\n+  if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;\n \n+  intype = TREE_TYPE (expr);\n+\n+  /* [expr.reinterpret.cast]\n+     An lvalue expression of type T1 can be cast to the type\n+     \"reference to T2\" if an expression of type \"pointer to T1\" can be\n+     explicitly converted to the type \"pointer to T2\" using a\n+     reinterpret_cast.  */\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  error (\"invalid reinterpret_cast of an rvalue expression of type \"\n-                 \"%qT to type %qT\", intype, type);\n+\t  error (\"invalid cast of an rvalue expression of type \"\n+                 \"%qT to type %qT\", \n+\t\t intype, type);\n \t  return error_mark_node;\n \t}\n+\n+      /* Warn about a reinterpret_cast from \"A*\" to \"B&\" if \"A\" and\n+\t \"B\" are related class types; the reinterpret_cast does not\n+\t adjust the pointer.  */\n+      if (TYPE_PTR_P (intype)\n+\t  && (comptypes (TREE_TYPE (intype), TREE_TYPE (type),\n+\t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n+\twarning (\"casting `%T' to `%T' does not dereference pointer\",\n+\t\t intype, type);\n+\n       expr = build_unary_op (ADDR_EXPR, expr, 0);\n       if (expr != error_mark_node)\n-\texpr = build_reinterpret_cast\n-\t  (build_pointer_type (TREE_TYPE (type)), expr);\n+\texpr = build_reinterpret_cast_1\n+\t  (build_pointer_type (TREE_TYPE (type)), expr, c_cast_p,\n+\t   valid_p);\n       if (expr != error_mark_node)\n \texpr = build_indirect_ref (expr, 0);\n       return expr;\n     }\n-  else if (same_type_ignoring_top_level_qualifiers_p (intype, type))\n-    return build_static_cast (type, expr);\n \n-  if (TYPE_PTR_P (type) && (TREE_CODE (intype) == INTEGER_TYPE\n-\t\t\t    || TREE_CODE (intype) == ENUMERAL_TYPE))\n-    /* OK */;\n-  else if (TREE_CODE (type) == INTEGER_TYPE && TYPE_PTR_P (intype))\n+  /* As a G++ extension, we consider conversions from member\n+     functions, and pointers to member functions to\n+     pointer-to-function and pointer-to-void types.  If\n+     -Wno-pmf-conversions has not been specified,\n+     convert_member_func_to_ptr will issue an error message.  */\n+  if ((TYPE_PTRMEMFUNC_P (intype) \n+       || TREE_CODE (intype) == METHOD_TYPE)\n+      && TYPE_PTR_P (type)\n+      && (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n+\t  || VOID_TYPE_P (TREE_TYPE (type))))\n+    return convert_member_func_to_ptr (type, expr);\n+\n+  /* If the cast is not to a reference type, the lvalue-to-rvale,\n+     array-to-pointer, and function-to-pointer conversions are\n+     performed.  */\n+  expr = decay_conversion (expr);\n+  \n+  /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n+     Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n+  if (TREE_CODE (expr) == NOP_EXPR\n+      && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  if (error_operand_p (expr))\n+    return error_mark_node;\n+\n+  intype = TREE_TYPE (expr);\n+\n+  /* [expr.reinterpret.cast]\n+     A pointer can be converted to any integral type large enough to\n+     hold it.  */\n+  if (CP_INTEGRAL_TYPE_P (type) && TYPE_PTR_P (intype))\n     {\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n-\tpedwarn (\"reinterpret_cast from %qT to %qT loses precision\",\n+\tpedwarn (\"cast from %qT to %qT loses precision\",\n                  intype, type);\n     }\n+  /* [expr.reinterpret.cast]\n+     A value of integral or enumeration type can be explicitly\n+     converted to a pointer.  */\n+  else if (TYPE_PTR_P (type) && INTEGRAL_OR_ENUMERATION_TYPE_P (intype))\n+    /* OK */\n+    ;\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n \t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n     {\n@@ -4755,38 +4902,50 @@ build_reinterpret_cast (tree type, tree expr)\n   else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n-      check_for_casting_away_constness (intype, type, \"reinterpret_cast\");\n+      if (!c_cast_p)\n+\tcheck_for_casting_away_constness (intype, type, error, \n+\t\t\t\t\t  \"reinterpret_cast\");\n+      /* Warn about possible alignment problems.  */\n+      if (STRICT_ALIGNMENT && warn_cast_align\n+\t  && !VOID_TYPE_P (type)\n+\t  && TREE_CODE (TREE_TYPE (intype)) != FUNCTION_TYPE\n+\t  && COMPLETE_TYPE_P (TREE_TYPE (type))\n+\t  && COMPLETE_TYPE_P (TREE_TYPE (intype))\n+\t  && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (intype)))\n+\twarning (\"cast from %qT to %qT increases required alignment of \"\n+\t\t \"target type\",\n+\t\t intype, type);\n       expr = decl_constant_value (expr);\n       return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype))\n \t   || (TYPE_PTRFN_P (intype) && TYPE_PTROBV_P (type)))\n     {\n-      pedwarn (\"ISO C++ forbids casting between pointer-to-function and pointer-to-object\");\n+      if (pedantic || !c_cast_p)\n+\tpedwarn (\"ISO C++ forbids casting between pointer-to-function and pointer-to-object\");\n       expr = decl_constant_value (expr);\n       return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else\n     {\n-      error (\"invalid reinterpret_cast from type %qT to type %qT\",\n-             intype, type);\n+      if (valid_p)\n+\t*valid_p = false;\n+      error (\"invalid cast from type %qT to type %qT\", intype, type);\n       return error_mark_node;\n     }\n       \n   return cp_convert (type, expr);\n }\n \n tree\n-build_const_cast (tree type, tree expr)\n+build_reinterpret_cast (tree type, tree expr)\n {\n-  tree intype;\n-\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n   if (processing_template_decl)\n     {\n-      tree t = build_min (CONST_CAST_EXPR, type, expr);\n+      tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n       \n       if (!TREE_SIDE_EFFECTS (t)\n \t  && type_dependent_expression_p (expr))\n@@ -4795,69 +4954,149 @@ build_const_cast (tree type, tree expr)\n       return t;\n     }\n \n-  if (!POINTER_TYPE_P (type) && !TYPE_PTRMEM_P (type))\n-    error (\"invalid use of const_cast with type %qT, which is not a pointer, \"\n-           \"reference, nor a pointer-to-data-member type\", type);\n-  else if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-    {\n-      error (\"invalid use of const_cast with type %qT, which is a pointer \"\n-             \"or reference to a function type\", type);\n+  return build_reinterpret_cast_1 (type, expr, /*c_cast_p=*/false,\n+\t\t\t\t   /*valid_p=*/NULL);\n+}\n+\n+/* Perform a const_cast from EXPR to TYPE.  If the cast is valid,\n+   return an appropriate expression.  Otherwise, return\n+   error_mark_node.  If the cast is not valid, and COMPLAIN is true,\n+   then a diagnostic will be issued.  If VALID_P is non-NULL, its\n+   value upon return will indicate whether or not the conversion\n+   succeeded.  */\n+\n+static tree\n+build_const_cast_1 (tree dst_type, tree expr, bool complain,\n+\t\t    bool *valid_p)\n+{\n+  tree src_type;\n+  tree reference_type;\n+\n+  /* Callers are responsible for handling error_mark_node as a\n+     destination type.  */\n+  gcc_assert (dst_type != error_mark_node);\n+  /* In a template, callers should be building syntactic\n+     representations of casts, not using this machinery.  */\n+  gcc_assert (!processing_template_decl);\n+\n+  /* Assume the conversion is invalid.  */\n+  if (valid_p)\n+    *valid_p = false;\n+\n+  if (!POINTER_TYPE_P (dst_type) && !TYPE_PTRMEM_P (dst_type))\n+    {\n+      if (complain)\n+\terror (\"invalid use of const_cast with type %qT, \"\n+\t       \"which is not a pointer, \"\n+\t       \"reference, nor a pointer-to-data-member type\", dst_type);\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (type) != REFERENCE_TYPE)\n+  if (TREE_CODE (TREE_TYPE (dst_type)) == FUNCTION_TYPE)\n     {\n-      expr = decay_conversion (expr);\n-\n-      /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n-\t Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n-      if (TREE_CODE (expr) == NOP_EXPR\n-\t  && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n-\texpr = TREE_OPERAND (expr, 0);\n+      if (complain)\n+\terror (\"invalid use of const_cast with type %qT, which is a pointer \"\n+\t       \"or reference to a function type\", dst_type);\n+      return error_mark_node;\n     }\n \n-  intype = TREE_TYPE (expr);\n-  \n-  if (same_type_ignoring_top_level_qualifiers_p (intype, type))\n-    return build_static_cast (type, expr);\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n+  src_type = TREE_TYPE (expr);\n+  /* Expressions do not really have reference types.  */\n+  if (TREE_CODE (src_type) == REFERENCE_TYPE)\n+    src_type = TREE_TYPE (src_type);\n+\n+  /* [expr.const.cast]\n+\n+     An lvalue of type T1 can be explicitly converted to an lvalue of\n+     type T2 using the cast const_cast<T2&> (where T1 and T2 are object\n+     types) if a pointer to T1 can be explicitly converted to the type\n+     pointer to T2 using a const_cast.  */\n+  if (TREE_CODE (dst_type) == REFERENCE_TYPE)\n     {\n+      reference_type = dst_type;\n       if (! real_lvalue_p (expr))\n \t{\n-\t  error (\"invalid const_cast of an rvalue of type %qT to type %qT\",\n-                 intype, type);\n+\t  if (complain)\n+\t    error (\"invalid const_cast of an rvalue of type %qT to type %qT\",\n+\t\t   src_type, dst_type);\n \t  return error_mark_node;\n \t}\n+      dst_type = build_pointer_type (TREE_TYPE (dst_type));\n+      src_type = build_pointer_type (src_type);\n+    }\n+  else\n+    {\n+      reference_type = NULL_TREE;\n+      /* If the destination type is not a reference type, the\n+\t lvalue-to-rvalue, array-to-pointer, and function-to-pointer\n+\t conversions are performed.  */\n+      src_type = type_decays_to (src_type);\n+      if (src_type == error_mark_node)\n+\treturn error_mark_node;\n+    }\n \n-      if (comp_ptr_ttypes_const (TREE_TYPE (type), intype))\n+  if ((TYPE_PTR_P (src_type) || TYPE_PTRMEM_P (src_type))\n+      && comp_ptr_ttypes_const (dst_type, src_type))\n+    {\n+      if (valid_p)\n+\t*valid_p = true;\n+      if (reference_type)\n \t{\n \t  expr = build_unary_op (ADDR_EXPR, expr, 0);\n-\t  expr = build1 (NOP_EXPR, type, expr);\n+\t  expr = build_nop (reference_type, expr);\n \t  return convert_from_reference (expr);\n \t}\n+      else\n+\t{\n+\t  expr = decay_conversion (expr);\n+\t  /* build_c_cast puts on a NOP_EXPR to make the result not an\n+\t     lvalue.  Strip such NOP_EXPRs if VALUE is being used in\n+\t     non-lvalue context.  */\n+\t  if (TREE_CODE (expr) == NOP_EXPR\n+\t      && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n+\t    expr = TREE_OPERAND (expr, 0);\n+\t  return build_nop (dst_type, expr);\n+\t}\n     }\n-  else if (((TREE_CODE (type) == POINTER_TYPE\n-\t     && TREE_CODE (intype) == POINTER_TYPE)\n-\t    || (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype)))\n-\t   && comp_ptr_ttypes_const (TREE_TYPE (type), TREE_TYPE (intype)))\n-    return cp_convert (type, expr);\n \n-  error (\"invalid const_cast from type %qT to type %qT\", intype, type);\n+  if (complain)\n+    error (\"invalid const_cast from type %qT to type %qT\", \n+\t   src_type, dst_type);\n   return error_mark_node;\n }\n \n-/* Build an expression representing a cast to type TYPE of expression EXPR.\n+tree\n+build_const_cast (tree type, tree expr)\n+{\n+  if (type == error_mark_node || expr == error_mark_node)\n+    return error_mark_node;\n \n-   ALLOW_NONCONVERTING is true if we should allow non-converting constructors\n-   when doing the cast.  */\n+  if (processing_template_decl)\n+    {\n+      tree t = build_min (CONST_CAST_EXPR, type, expr);\n+      \n+      if (!TREE_SIDE_EFFECTS (t)\n+\t  && type_dependent_expression_p (expr))\n+\t/* There might turn out to be side effects inside expr.  */\n+\tTREE_SIDE_EFFECTS (t) = 1;\n+      return t;\n+    }\n+\n+  return build_const_cast_1 (type, expr, /*complain=*/true,\n+\t\t\t     /*valid_p=*/NULL);\n+}\n+\n+/* Build an expression representing an explicit C-style cast to type\n+   TYPE of expression EXPR.  */\n \n tree\n build_c_cast (tree type, tree expr)\n {\n   tree value = expr;\n-  tree otype;\n+  tree result;\n+  bool valid_p;\n \n-  if (type == error_mark_node || expr == error_mark_node)\n+  if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;\n \n   if (processing_template_decl)\n@@ -4906,118 +5145,48 @@ build_c_cast (tree type, tree expr)\n       return error_mark_node;\n     }\n \n-  if (TREE_CODE (type) == VOID_TYPE)\n-    {\n-      /* Conversion to void does not cause any of the normal function to\n-       * pointer, array to pointer and lvalue to rvalue decays.  */\n-      \n-      value = convert_to_void (value, /*implicit=*/NULL);\n-      return value;\n-    }\n-\n-  if (!complete_type_or_else (type, NULL_TREE))\n-    return error_mark_node;\n-\n-  /* Convert functions and arrays to pointers and\n-     convert references to their expanded types,\n-     but don't convert any other types.  If, however, we are\n-     casting to a class type, there's no reason to do this: the\n-     cast will only succeed if there is a converting constructor,\n-     and the default conversions will be done at that point.  In\n-     fact, doing the default conversion here is actually harmful\n-     in cases like this:\n-\n-     typedef int A[2];\n-     struct S { S(const A&); };\n-\n-     since we don't want the array-to-pointer conversion done.  */\n-  if (!IS_AGGR_TYPE (type))\n-    {\n-      if (TREE_CODE (TREE_TYPE (value)) == FUNCTION_TYPE\n-\t  || (TREE_CODE (TREE_TYPE (value)) == METHOD_TYPE\n-\t      /* Don't do the default conversion on a ->* expression.  */\n-\t      && ! (TREE_CODE (type) == POINTER_TYPE\n-\t\t    && bound_pmf_p (value)))\n-\t  || TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE\n-\t  || TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n-\tvalue = decay_conversion (value);\n-    }\n-  else if (TREE_CODE (TREE_TYPE (value)) == REFERENCE_TYPE)\n-    /* However, even for class types, we still need to strip away\n-       the reference type, since the call to convert_force below\n-       does not expect the input expression to be of reference\n-       type.  */\n-    value = convert_from_reference (value);\n-\t\n-  otype = TREE_TYPE (value);\n-\n-  /* Optionally warn about potentially worrisome casts.  */\n-\n-  if (warn_cast_qual\n-      && TREE_CODE (type) == POINTER_TYPE\n-      && TREE_CODE (otype) == POINTER_TYPE\n-      && !at_least_as_qualified_p (TREE_TYPE (type),\n-\t\t\t\t   TREE_TYPE (otype)))\n-    warning (\"cast from %qT to %qT discards qualifiers from pointer \"\n-             \"target type\",\n-             otype, type);\n-\n-  if (TREE_CODE (type) == INTEGER_TYPE\n-      && TYPE_PTR_P (otype)\n-      && TYPE_PRECISION (type) != TYPE_PRECISION (otype))\n-    warning (\"cast from pointer to integer of different size\");\n-\n-  if (TYPE_PTR_P (type)\n-      && TREE_CODE (otype) == INTEGER_TYPE\n-      && TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n-      /* Don't warn about converting any constant.  */\n-      && !TREE_CONSTANT (value))\n-    warning (\"cast to pointer from integer of different size\");\n+  /* A C-style cast can be a const_cast.  */\n+  result = build_const_cast_1 (type, value, /*complain=*/false,\n+\t\t\t       &valid_p);\n+  if (valid_p)\n+    return result;\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    value = (convert_from_reference\n-\t     (convert_to_reference (type, value, CONV_C_CAST,\n-\t\t\t\t    LOOKUP_COMPLAIN, NULL_TREE)));\n-  else\n+  /* Or a static cast.  */\n+  result = build_static_cast_1 (type, value, /*c_cast_p=*/true,\n+\t\t\t\t&valid_p);\n+  /* Or a reinterpret_cast.  */\n+  if (!valid_p)\n+    result = build_reinterpret_cast_1 (type, value, /*c_cast_p=*/true,\n+\t\t\t\t       &valid_p);\n+  /* The static_cast or reinterpret_cast may be followed by a\n+     const_cast.  */\n+  if (valid_p \n+      /* A valid cast may result in errors if, for example, a\n+\t conversion to am ambiguous base class is required.  */\n+      && !error_operand_p (result))\n     {\n-      tree ovalue;\n-\n-      value = decl_constant_value (value);\n-\n-      ovalue = value;\n-      value = convert_force (type, value, CONV_C_CAST);\n+      tree result_type;\n \n-      /* Ignore any integer overflow caused by the cast.  */\n-      if (TREE_CODE (value) == INTEGER_CST)\n+      /* Non-class rvalues always have cv-unqualified type.  */\n+      if (!CLASS_TYPE_P (type))\n+\ttype = TYPE_MAIN_VARIANT (type);\n+      result_type = TREE_TYPE (result);\n+      if (!CLASS_TYPE_P (result_type))\n+\tresult_type = TYPE_MAIN_VARIANT (result_type);\n+      /* If the type of RESULT does not match TYPE, perform a\n+\t const_cast to make it match.  If the static_cast or\n+\t reinterpret_cast succeeded, we will differ by at most\n+\t cv-qualification, so the follow-on const_cast is guaranteed\n+\t to succeed.  */\n+      if (!same_type_p (non_reference (type), non_reference (result_type)))\n \t{\n-\t  TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n-\n-\t  if (CONSTANT_CLASS_P (ovalue))\n-\t    TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n+\t  result = build_const_cast_1 (type, result, false, &valid_p);\n+\t  gcc_assert (valid_p);\n \t}\n+      return result;\n     }\n \n-  /* Warn about possible alignment problems.  Do this here when we will have\n-     instantiated any necessary template types.  */\n-  if (STRICT_ALIGNMENT && warn_cast_align\n-      && TREE_CODE (type) == POINTER_TYPE\n-      && TREE_CODE (otype) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (otype)) != VOID_TYPE\n-      && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n-      && COMPLETE_TYPE_P (TREE_TYPE (otype))\n-      && COMPLETE_TYPE_P (TREE_TYPE (type))\n-      && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n-    warning (\"cast from %qT to %qT increases required alignment of \"\n-             \"target type\",\n-             otype, type);\n-\n-    /* Always produce some operator for an explicit cast,\n-       so we can tell (for -pedantic) that the cast is no lvalue.  */\n-  if (TREE_CODE (type) != REFERENCE_TYPE && value == expr\n-      && real_lvalue_p (value))\n-    value = non_lvalue (value);\n-\n-  return value;\n+  return error_mark_node;\n }\n \f\n /* Build an assignment expression of lvalue LHS from value RHS.\n@@ -6260,7 +6429,7 @@ cp_has_mutable_p (tree type)\n }\n \n /* Subroutine of casts_away_constness.  Make T1 and T2 point at\n-   exemplar types such that casting T1 to T2 is casting away castness\n+   exemplar types such that casting T1 to T2 is casting away constness\n    if and only if there is no implicit conversion from T1 to T2.  */\n \n static void"}, {"sha": "7b8fc4840f33cb453aacc6cafa6b7e6f2d8949b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -1,3 +1,17 @@\n+2004-10-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14035\n+\t* g++.dg/conversion/reinterpret1.C: Adjust error markers.\n+\t* g++.dg/conversion/const2.C: New test.\n+\t* g++.dg/expr/reinterpret2.C: New test.\n+\t* g++.dg/expr/reinterpret3.C: New test.\n+\t* g++.dg/expr/cast2.C: New test.\n+\t* g++.dg/expr/copy1.C: New test.\n+\t* g++.dg/other/conversion1.C: Change error message.\n+\t* g++.dg/parse/comma1.C: Use __extension__ to allow casts from\n+\tfunction pointers to void *.\n+\t* g++.old-deja/g++.mike/p10148.C: Likewise.\n+\n 2004-10-19  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.dg/smod-1.c: Pass -mtune=i486 only on x86."}, {"sha": "fd2be1f44448d1098ee9d89de8b7ab61794d22ab", "filename": "gcc/testsuite/g++.dg/conversion/const2.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fconst2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fconst2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fconst2.C?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -0,0 +1,11 @@\n+struct B {};\n+struct D : public B {};\n+\n+typedef int B::*bm;\n+typedef int D::*dm;\n+\n+bm bp;\n+\n+void f() {\n+  const_cast<dm>(bp); // { dg-error \"\" }\n+}"}, {"sha": "d4567822e2a0b81b5b99e50dffcd0bac82be40a5", "filename": "gcc/testsuite/g++.dg/conversion/reinterpret1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret1.C?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -1,6 +1,6 @@\n // PR c++/15076\n \n-struct Y { Y(int &); }; // { dg-error \"\" }\n+struct Y { Y(int &); };\n \n int v;\n Y y1(reinterpret_cast<int>(v));  // { dg-error \"\" }"}, {"sha": "e9b2328b74d07e3f2f13093f51ae2ac3601eb2d8", "filename": "gcc/testsuite/g++.dg/conversion/reinterpret2.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret2.C?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -0,0 +1,5 @@\n+bool b;\n+\n+void f() {\n+  reinterpret_cast<void*>(b);\n+}"}, {"sha": "62fb91444d403ddb72e6c18b9e875799a6fb7f09", "filename": "gcc/testsuite/g++.dg/conversion/reinterpret3.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Freinterpret3.C?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -0,0 +1,7 @@\n+struct S {};\n+\n+S s;\n+\n+void f() {\n+  reinterpret_cast<const S>(s); // { dg-error \"\" }\n+}"}, {"sha": "fbc2a2ccca44c8ec1e4e085906b1995c19b2bc5e", "filename": "gcc/testsuite/g++.dg/expr/cast2.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast2.C?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -0,0 +1,5 @@\n+void (*p)();\n+\n+void f() {\n+  (void *)p; // { dg-error \"\" }\n+}"}, {"sha": "57036d3f0aecc9a6c82bf85b72a38d8e13fde6ef", "filename": "gcc/testsuite/g++.dg/expr/copy1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcopy1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcopy1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcopy1.C?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/14035\n+// { dg-do run }\n+\n+extern \"C\" void abort();\n+\n+struct Blob {\n+  int x, y;\n+  Blob() { }\n+  Blob(const Blob &b) { abort (); }\n+};\n+struct Blobby : public Blob { };\n+\n+struct Wooly {\n+  operator const Blobby & ()\n+  {\n+    return myBlobby;\n+  }\n+  Blobby myBlobby;\n+};\n+\n+void catcher(const Blob &blo)\n+{ }\n+\n+int main()\n+{\n+  Wooly wooly;\n+  catcher((const Blob &)wooly);\n+}"}, {"sha": "6573ef15ba87bf4f1202081453e51fcd00518948", "filename": "gcc/testsuite/g++.dg/other/conversion1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fconversion1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fconversion1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fconversion1.C?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -13,5 +13,5 @@ int main()\n {\n   long long m;\n   \n-  (void (QObject::*)()) m;    // { dg-error \"invalid conversion\" \"\" }\n+  (void (QObject::*)()) m;    // { dg-error \"invalid cast\" \"\" }\n }"}, {"sha": "4983535a58779bf6c687afe7b3e2403487e382de", "filename": "gcc/testsuite/g++.dg/parse/comma1.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcomma1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33c25e5c5a69b096d8aafef5599bf93672dd3659/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcomma1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcomma1.C?ref=33c25e5c5a69b096d8aafef5599bf93672dd3659", "patch": "@@ -1,4 +1,5 @@\n // PR c++/14278\n+// { dg-options \"\" }\n \n struct X { \n   X (int p);"}]}