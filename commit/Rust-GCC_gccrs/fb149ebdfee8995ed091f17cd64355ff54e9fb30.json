{"sha": "fb149ebdfee8995ed091f17cd64355ff54e9fb30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIxNDllYmRmZWU4OTk1ZWQwOTFmMTdjZDY0MzU1ZmY1NGU5ZmIzMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-15T17:42:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-15T17:54:01Z"}, "message": "Fix ICE in verify_sra_access_forest\n\nThis fixes an issue with reverse storage order in SRA, which is caught\nby the built-in verifier in verify_sra_access_forest.  The problem is\nthat propagate_subaccesses_from_rhs changes the type of an access\nfrom aggregate to scalar and, as discussed elsewhere, this must be\ndone with extra care in the presence of reverse storage order.\n\ngcc/ChangeLog\n\t* tree-sra.c (propagate_subaccesses_from_rhs): When a non-scalar\n\taccess on the LHS is replaced with a scalar access, propagate the\n\tTYPE_REVERSE_STORAGE_ORDER flag of the type of the original access.\n\ngcc/testsuite/ChangeLog\n\t* gnat.dg/opt85.ads, gnat.dg/opt85.adb: New test.", "tree": {"sha": "4e4998067c3c8211f0e44cc3138318e98ad4bcdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e4998067c3c8211f0e44cc3138318e98ad4bcdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb149ebdfee8995ed091f17cd64355ff54e9fb30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb149ebdfee8995ed091f17cd64355ff54e9fb30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb149ebdfee8995ed091f17cd64355ff54e9fb30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb149ebdfee8995ed091f17cd64355ff54e9fb30/comments", "author": null, "committer": null, "parents": [{"sha": "b6ab9ecd550227684643b41e9e33a4d3466724d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ab9ecd550227684643b41e9e33a4d3466724d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6ab9ecd550227684643b41e9e33a4d3466724d8"}], "stats": {"total": 53, "additions": 53, "deletions": 0}, "files": [{"sha": "94213a458193c6a49b5bdf0aa8229f51352b54b3", "filename": "gcc/testsuite/gnat.dg/opt85.adb", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb149ebdfee8995ed091f17cd64355ff54e9fb30/gcc%2Ftestsuite%2Fgnat.dg%2Fopt85.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb149ebdfee8995ed091f17cd64355ff54e9fb30/gcc%2Ftestsuite%2Fgnat.dg%2Fopt85.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt85.adb?ref=fb149ebdfee8995ed091f17cd64355ff54e9fb30", "patch": "@@ -0,0 +1,20 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O\" }\n+\n+package body Opt85 is\n+\n+   function Conversion_Of (Value : Integer) return Data_Type is\n+   begin\n+      return (Value => Interfaces.Integer_16 (Value));\n+   end;\n+\n+   function Create (Value : Integer) return Record_Type is\n+      Rec : constant Record_Type :=\n+        (Ada.Finalization.Controlled with\n+         Header => (others => False),\n+         Data   => Conversion_Of (Value));\n+   begin\n+      return Rec;\n+   end;\n+\n+end Opt85;"}, {"sha": "00b5c284da8342c5d1b7fa355651bfb2f932aba4", "filename": "gcc/testsuite/gnat.dg/opt85.ads", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb149ebdfee8995ed091f17cd64355ff54e9fb30/gcc%2Ftestsuite%2Fgnat.dg%2Fopt85.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb149ebdfee8995ed091f17cd64355ff54e9fb30/gcc%2Ftestsuite%2Fgnat.dg%2Fopt85.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt85.ads?ref=fb149ebdfee8995ed091f17cd64355ff54e9fb30", "patch": "@@ -0,0 +1,27 @@\n+with Ada.Finalization;\n+with Interfaces;\n+with System;\n+\n+package Opt85 is\n+\n+   type Data_Type is record\n+      Value : Interfaces.Integer_16;\n+   end record;\n+   for Data_Type use record\n+      Value at 0 range 0 .. 15;\n+   end record;\n+   for Data_Type'Alignment use 1;\n+   for Data_Type'Size use 2 * System.Storage_Unit;\n+   for Data_Type'Bit_Order use System.High_Order_First;\n+   for Data_Type'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Header_Type is array (1 .. 1) of Boolean;\n+\n+   type Record_Type is new Ada.Finalization.Controlled with record\n+      Header : Header_Type;\n+      Data   : Data_Type;\n+   end record;\n+\n+   function Create (Value : Integer) return Record_Type;\n+\n+end Opt85;"}, {"sha": "fcba7fbdd31339a6b90c7c82da7cd6706fbd6f2c", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb149ebdfee8995ed091f17cd64355ff54e9fb30/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb149ebdfee8995ed091f17cd64355ff54e9fb30/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fb149ebdfee8995ed091f17cd64355ff54e9fb30", "patch": "@@ -2758,6 +2758,9 @@ propagate_subaccesses_from_rhs (struct access *lacc, struct access *racc)\n \t}\n       if (!lacc->first_child && !racc->first_child)\n \t{\n+\t  /* We are about to change the access type from aggregate to scalar,\n+\t     so we need to put the reverse flag onto the access, if any.  */\n+\t  const bool reverse = TYPE_REVERSE_STORAGE_ORDER (lacc->type);\n \t  tree t = lacc->base;\n \n \t  lacc->type = racc->type;\n@@ -2772,9 +2775,12 @@ propagate_subaccesses_from_rhs (struct access *lacc, struct access *racc)\n \t      lacc->expr = build_ref_for_model (EXPR_LOCATION (lacc->base),\n \t\t\t\t\t\tlacc->base, lacc->offset,\n \t\t\t\t\t\tracc, NULL, false);\n+\t      if (TREE_CODE (lacc->expr) == MEM_REF)\n+\t\tREF_REVERSE_STORAGE_ORDER (lacc->expr) = reverse;\n \t      lacc->grp_no_warning = true;\n \t      lacc->grp_same_access_path = false;\n \t    }\n+\t  lacc->reverse = reverse;\n \t}\n       return ret;\n     }"}]}