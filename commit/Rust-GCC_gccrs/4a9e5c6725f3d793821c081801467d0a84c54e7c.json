{"sha": "4a9e5c6725f3d793821c081801467d0a84c54e7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE5ZTVjNjcyNWYzZDc5MzgyMWMwODE4MDE0NjdkMGE4NGM1NGU3Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-09-21T14:40:13Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-09-21T14:40:13Z"}, "message": "Reimplement dynamic cast and catch matching.\n\n\t* cp-tree.h (get_dynamic_cast_base_type): Prototype new function\n\t* search.c (dynamic_cast_base_recurse): New function.\n\t(get_dynamic_cast_base_type): New function for dynamic cast.\n\t* rtti.c (build_dynamic_cast_1): Determine source and target\n\tclass relationship. Call __dynamic_cast_2.\n\t* tinfo.h (__user_type_info::upcast): New catch dispatcher.\n\t(__user_type_info::dyncast): New dynamic cast dispatcher.\n\t(__user_type_info::sub_kind): New nested enumeration.\n\t(__user_type_info::contained_p): sub_kind predicate.\n\t(__user_type_info::contained_public_p): Likewise.\n\t(__user_type_info::contained_nonpublic_p): Likewise.\n\t(__user_type_info::contained_nonvirtual_p: Likewise.\n\t(__user_type_info::upcast_result): New nested struct.\n\t(__user_type_info::dyncast_result): New nested struct.\n\t(*::do_upcast): New catch function.\n\t(*::do_dyncast): New dynamic cast function.\n\t(__user_type_info::find_public_subobj): New dynamic cast\n\thelper dispatcher.\n\t(*::do_find_public_subobj): New dynamic cast helper function.\n\t* tinfo.cc (__user_type_info::upcast): Define catch dispatcher.\n\t(__user_type_info::dyncast): Define dynamic cast dispatcher.\n\t(*::do_upcast): Define catch function.\n\t(*::do_dyncast): Define dynamic cast function.\n\t(*::do_find_public_subobj): Define dynamic cast helper function.\n\t* tinfo2.cc (__throw_type_match_rtti_2): Use upcast.\n\t(__dynamic_cast): Backwards compatibility wrapper. Use dyncast.\n\t(__dynamic_cast_2): New dynamic cast runtime.\n\nFrom-SVN: r29544", "tree": {"sha": "1b463c3798cfb2f7d8d92e4357594ad6134f5466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b463c3798cfb2f7d8d92e4357594ad6134f5466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a9e5c6725f3d793821c081801467d0a84c54e7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a9e5c6725f3d793821c081801467d0a84c54e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a9e5c6725f3d793821c081801467d0a84c54e7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a9e5c6725f3d793821c081801467d0a84c54e7c/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e36e6e0261a68862828fdd27abde3dd41191ddc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e36e6e0261a68862828fdd27abde3dd41191ddc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e36e6e0261a68862828fdd27abde3dd41191ddc0"}], "stats": {"total": 820, "additions": 713, "deletions": 107}, "files": [{"sha": "2feaf83ae72298890e6f5b62313989c3986634d3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4a9e5c6725f3d793821c081801467d0a84c54e7c", "patch": "@@ -1,3 +1,34 @@\n+1999-09-21  Nathan Sidwell  <nathan@acm.org>\n+\n+\tReimplement dynamic cast and catch matching.\n+\t* cp-tree.h (get_dynamic_cast_base_type): Prototype new function\n+\t* search.c (dynamic_cast_base_recurse): New function.\n+\t(get_dynamic_cast_base_type): New function for dynamic cast.\n+\t* rtti.c (build_dynamic_cast_1): Determine source and target\n+\tclass relationship. Call __dynamic_cast_2.\n+\t* tinfo.h (__user_type_info::upcast): New catch dispatcher.\n+\t(__user_type_info::dyncast): New dynamic cast dispatcher.\n+\t(__user_type_info::sub_kind): New nested enumeration.\n+\t(__user_type_info::contained_p): sub_kind predicate.\n+\t(__user_type_info::contained_public_p): Likewise.\n+\t(__user_type_info::contained_nonpublic_p): Likewise.\n+\t(__user_type_info::contained_nonvirtual_p: Likewise.\n+\t(__user_type_info::upcast_result): New nested struct.\n+\t(__user_type_info::dyncast_result): New nested struct.\n+\t(*::do_upcast): New catch function.\n+\t(*::do_dyncast): New dynamic cast function.\n+\t(__user_type_info::find_public_subobj): New dynamic cast\n+\thelper dispatcher.\n+\t(*::do_find_public_subobj): New dynamic cast helper function.\n+\t* tinfo.cc (__user_type_info::upcast): Define catch dispatcher.\n+\t(__user_type_info::dyncast): Define dynamic cast dispatcher.\n+\t(*::do_upcast): Define catch function.\n+\t(*::do_dyncast): Define dynamic cast function.\n+\t(*::do_find_public_subobj): Define dynamic cast helper function.\n+\t* tinfo2.cc (__throw_type_match_rtti_2): Use upcast.\n+\t(__dynamic_cast): Backwards compatibility wrapper. Use dyncast.\n+\t(__dynamic_cast_2): New dynamic cast runtime.\n+\n 1999-09-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (finish_stmt_expr): Change prototype."}, {"sha": "78ec70e13144ed5275b8151dc587fb122298d90e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4a9e5c6725f3d793821c081801467d0a84c54e7c", "patch": "@@ -3596,6 +3596,7 @@ extern int types_overlap_p\t\t\tPROTO((tree, tree));\n extern tree get_vbase\t\t\t\tPROTO((tree, tree));\n extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n+extern tree get_dynamic_cast_base_type          PROTO((tree, tree));\n extern int accessible_p                         PROTO((tree, tree));\n extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n extern int lookup_fnfields_1                    PROTO((tree, tree));"}, {"sha": "8ce5102e6fc0204f76224fd2945f660b8c23d71f", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4a9e5c6725f3d793821c081801467d0a84c54e7c", "patch": "@@ -588,6 +588,7 @@ build_dynamic_cast_1 (type, expr)\n \t{\n \t  tree retval;\n           tree result, td1, td2, td3, elems, expr2;\n+          tree static_type, target_type, boff;\n \n  \t  /* If we got here, we can't convert statically.  Therefore,\n \t     dynamic_cast<D&>(b) (b an object) cannot succeed.  */\n@@ -632,20 +633,23 @@ build_dynamic_cast_1 (type, expr)\n \t    td1 = get_tinfo_fn_dynamic (expr);\n \t  td1 = decay_conversion (td1);\n \t  \n-\t  td2 = decay_conversion\n-\t    (get_tinfo_fn (TYPE_MAIN_VARIANT (TREE_TYPE (type))));\n-\t  td3 = decay_conversion\n-\t    (get_tinfo_fn (TYPE_MAIN_VARIANT (TREE_TYPE (exprtype))));\n+\t  target_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+\t  static_type = TYPE_MAIN_VARIANT (TREE_TYPE (exprtype));\n+\t  td2 = decay_conversion (get_tinfo_fn (target_type));\n+\t  td3 = decay_conversion (get_tinfo_fn (static_type));\n+\n+          /* Determine how T and V are related.  */\n+          boff = get_dynamic_cast_base_type (static_type, target_type);\n \n           elems = tree_cons\n \t    (NULL_TREE, td1, tree_cons\n \t     (NULL_TREE, td2, tree_cons\n-\t      (NULL_TREE, build_int_2 (1, 0), tree_cons\n+\t      (NULL_TREE, boff, tree_cons\n \t       (NULL_TREE, expr2, tree_cons\n-\t\t(NULL_TREE, td3, tree_cons\n+\t        (NULL_TREE, td3, tree_cons\n \t\t (NULL_TREE, expr1, NULL_TREE))))));\n \n-\t  dcast_fn = get_identifier (\"__dynamic_cast\");\n+\t  dcast_fn = get_identifier (\"__dynamic_cast_2\");\n \t  if (IDENTIFIER_GLOBAL_VALUE (dcast_fn))\n \t    dcast_fn = IDENTIFIER_GLOBAL_VALUE (dcast_fn);\n \t  else\n@@ -656,7 +660,7 @@ build_dynamic_cast_1 (type, expr)\n \t      tmp = tree_cons\n \t\t(NULL_TREE, TREE_TYPE (td1), tree_cons\n \t\t (NULL_TREE, TREE_TYPE (td1), tree_cons\n-\t\t  (NULL_TREE, integer_type_node, tree_cons\n+\t          (NULL_TREE, integer_type_node, tree_cons\n \t\t   (NULL_TREE, ptr_type_node, tree_cons\n \t\t    (NULL_TREE, TREE_TYPE (td1), tree_cons\n \t\t     (NULL_TREE, ptr_type_node, void_list_node))))));"}, {"sha": "b14871f7fcd3a2eb87c1fe0875206b0b121768cc", "filename": "gcc/cp/search.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=4a9e5c6725f3d793821c081801467d0a84c54e7c", "patch": "@@ -90,6 +90,7 @@ static tree dfs_no_overlap_yet PROTO((tree, void *));\n static int get_base_distance_recursive\n \tPROTO((tree, int, int, int, int *, tree *, tree,\n \t       int, int *, int, int));\n+static int dynamic_cast_base_recurse PROTO((tree, tree, int, tree *));\n static void expand_upcast_fixups \n \tPROTO((tree, tree, tree, tree, tree, tree, tree *));\n static void fixup_virtual_upcast_offsets\n@@ -494,6 +495,77 @@ get_base_distance (parent, binfo, protect, path_ptr)\n   return rval;\n }\n \n+/* Worker function for get_dynamic_cast_base_type.  */\n+\n+static int\n+dynamic_cast_base_recurse (subtype, binfo, via_virtual, offset_ptr)\n+     tree subtype;\n+     tree binfo;\n+     int via_virtual;\n+     tree *offset_ptr;\n+{\n+  tree binfos;\n+  int i, n_baselinks;\n+  int worst = -3;\n+  \n+  if (BINFO_TYPE (binfo) == subtype)\n+    {\n+      if (via_virtual)\n+        return -2;\n+      else\n+        {\n+          *offset_ptr = BINFO_OFFSET (binfo);\n+          return 0;\n+        }\n+    }\n+  \n+  binfos = BINFO_BASETYPES (binfo);\n+  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int rval;\n+      \n+      if (!TREE_VIA_PUBLIC (base_binfo))\n+        continue;\n+      rval = dynamic_cast_base_recurse\n+             (subtype, base_binfo,\n+              via_virtual || TREE_VIA_VIRTUAL (base_binfo), offset_ptr);\n+      if (worst == -3)\n+        worst = rval;\n+      else if (rval >= 0)\n+        worst = worst >= 0 ? -1 : worst;\n+      else if (rval > -3)\n+        worst = worst < rval ? worst : rval;\n+    }\n+  return worst;\n+}\n+\n+/* The dynamic cast runtime needs a hint about how the static SUBTYPE type started\n+   from is related to the required TARGET type, in order to optimize the\n+   inheritance graph search. This information is independant of the\n+   current context, and ignores private paths, hence get_base_distance is\n+   inappropriate. Return a TREE specifying the base offset, BOFF.\n+   BOFF >= 0, there is only one public non-virtual SUBTYPE base at offset BOFF,\n+      and there are no public virtual SUBTYPE bases.\n+   BOFF == -1, SUBTYPE occurs as multiple public non-virtual bases.\n+   BOFF == -2, SUBTYPE occurs as multiple public virtual or non-virtual bases.\n+   BOFF == -3, SUBTYPE is not a public base.  */\n+\n+tree\n+get_dynamic_cast_base_type (subtype, target)\n+     tree subtype;\n+     tree target;\n+{\n+  tree offset = NULL_TREE;\n+  int boff = dynamic_cast_base_recurse (subtype, TYPE_BINFO (target),\n+                                        0, &offset);\n+  \n+  if (!boff)\n+    return offset;\n+  return build_int_2 (boff, -1);\n+}\n+\n /* Search for a member with name NAME in a multiple inheritance lattice\n    specified by TYPE.  If it does not exist, return NULL_TREE.\n    If the member is ambiguously referenced, return `error_mark_node'."}, {"sha": "1d4885c926460ba7b3aa2728d80fca9c5a5d0dae", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 430, "deletions": 77, "changes": 507, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=4a9e5c6725f3d793821c081801467d0a84c54e7c", "patch": "@@ -62,100 +62,453 @@ extern \"C\" void\n __rtti_user (void *addr, const char *name)\n { new (addr) __user_type_info (name); }\n \n-// dynamic_cast helper methods.\n-// Returns 1 if the cast succeeds, 0 otherwise.  Stores the adjusted value\n-// in VALP.\n-\n+// Upcast for catch checking. OBJPTR points to the thrown object and might be\n+// NULL. Return 0 on failure, non-zero on success. Set *ADJPTR to adjusted\n+// object pointer.\n int __user_type_info::\n-dcast (const type_info& to, int, void *addr, void **valp,\n-       const type_info *, void *) const\n+upcast (const type_info &target, void *objptr,\n+        void **adjptr) const\n+{\n+  upcast_result result;\n+  \n+  if (do_upcast (contained_public, target, objptr, result))\n+    return 0;\n+  *adjptr = result.target_obj;\n+  return contained_public_p (result.whole2target);\n+}\n+\n+// Down or cross cast for dynamic_cast. OBJPTR points to the most derrived\n+// object, SUBPTR points to the static base object. Both must not be NULL.\n+// TARGET specifies the desired target type, SUBTYPE specifies the static\n+// type. Both must be defined. Returns adjusted object pointer on success,\n+// NULL on failure. [expr.dynamic.cast]/8 says 'unambiguous public base'. This\n+// itself is an ambiguous statement. We choose it to mean the base must be\n+// separately unambiguous and public, rather than unambiguous considering only\n+// public bases.\n+void *__user_type_info::\n+dyncast (int boff,\n+         const type_info &target, void *objptr,\n+         const type_info &subtype, void *subptr) const\n {\n-  *valp = addr;\n-  return (*this == to);\n+  dyncast_result result;\n+  \n+  do_dyncast (boff, contained_public,\n+              target, objptr, subtype, subptr, result);\n+  if (!result.target_obj)\n+    return NULL;\n+  if (contained_public_p (result.target2sub))\n+    return result.target_obj;\n+  if (contained_public_p (sub_kind (result.whole2sub & result.whole2target)))\n+    // Found a valid cross cast\n+    return result.target_obj;\n+  if (contained_nonvirtual_p (result.whole2sub))\n+    // Found an invalid cross cast, which cannot also be a down cast\n+    return NULL;\n+  if (result.target2sub == unknown)\n+    result.target2sub = static_cast <const __user_type_info &> (target)\n+                        .find_public_subobj (boff, subtype,\n+                                             result.target_obj, subptr);\n+  if (contained_public_p (result.target2sub))\n+    // Found a valid down cast\n+    return result.target_obj;\n+  // Must be an invalid down cast, or the cross cast wasn't bettered\n+  return NULL;\n }\n \n-int __si_type_info::\n-dcast (const type_info& to, int require_public, void *addr, void **valp,\n-       const type_info *sub, void *subptr) const\n+// Catch cast helper. ACCESS_PATH is the access from the complete thrown\n+// object to this base. TARGET is the desired type we want to catch. OBJPTR\n+// points to this base within the throw object, it might be NULL. Fill in\n+// RESULT with what we find. Return true, should we determine catch must fail.\n+bool __user_type_info::\n+do_upcast (sub_kind access_path,\n+           const type_info &target, void *objptr,\n+           upcast_result &__restrict result) const\n {\n-  if (*this == to)\n+  if (*this == target)\n     {\n-      *valp = addr;\n-      return 1;\n+      result.target_obj = objptr;\n+      result.base_type = nonvirtual_base_type;\n+      result.whole2target = access_path;\n+      return contained_nonpublic_p (access_path);\n     }\n-  return base.dcast (to, require_public, addr, valp, sub, subptr);\n+  return false;\n }\n \n-int __class_type_info::\n-dcast (const type_info& desired, int is_public, void *objptr, void **valp,\n-       const type_info *sub, void *subptr) const\n+// dynamic cast helper. ACCESS_PATH gives the access from the most derived\n+// object to this base. TARGET indicates the desired type we want. OBJPTR\n+// points to this base within the object. SUBTYPE indicates the static type\n+// started from and SUBPTR points to that base within the most derived object.\n+// Fill in RESULT with what we find. Return true if we have located an\n+// ambiguous match.\n+bool __user_type_info::\n+do_dyncast (int, sub_kind access_path,\n+            const type_info &target, void *objptr,\n+            const type_info &subtype, void *subptr,\n+            dyncast_result &__restrict result) const\n {\n-  *valp = objptr;\n+  if (objptr == subptr && *this == subtype)\n+    {\n+      // The subobject we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2sub = access_path;\n+      return false;\n+    }\n+  if (*this == target)\n+    {\n+      result.target_obj = objptr;\n+      result.whole2target = access_path;\n+      result.target2sub = not_contained;\n+      return false;\n+    }\n+  return false;\n+}\n \n-  if (*this == desired)\n-    return 1;\n+// find_public_subobj helper. Return contained_public if we are the desired\n+// subtype. OBJPTR points to this base type, SUBPTR points to the desired base\n+// object.\n+__user_type_info::sub_kind __user_type_info::\n+do_find_public_subobj (int, const type_info &, void *objptr, void *subptr) const\n+{\n+  if (subptr == objptr)\n+    // Must be our type, as the pointers match.\n+    return contained_public;\n+  return not_contained;\n+}\n \n-  int match_found = 0;\n-  void *match = 0;\n+// catch helper for single public inheritance types. See\n+// __user_type_info::do_upcast for semantics.\n+bool __si_type_info::\n+do_upcast (sub_kind access_path,\n+           const type_info &target, void *objptr,\n+           upcast_result &__restrict result) const\n+{\n+  if (*this == target)\n+    {\n+      result.target_obj = objptr;\n+      result.base_type = nonvirtual_base_type;\n+      result.whole2target = access_path;\n+      return contained_nonpublic_p (access_path);\n+    }\n+  return base.do_upcast (access_path, target, objptr, result);\n+}\n \n-  for (size_t i = 0; i < n_bases; i++)\n+// dynamic cast helper for single public inheritance types. See\n+// __user_type_info::do_dyncast for semantics. BOFF indicates how SUBTYPE\n+// types are inherited by TARGET types.\n+bool __si_type_info::\n+do_dyncast (int boff, sub_kind access_path,\n+            const type_info &target, void *objptr,\n+            const type_info &subtype, void *subptr,\n+            dyncast_result &__restrict result) const\n+{\n+  if (objptr == subptr && *this == subtype)\n     {\n-      if (is_public && base_list[i].access != PUBLIC)\n-\tcontinue;\n+      // The subobject we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2sub = access_path;\n+      return false;\n+    }\n+  if (*this == target)\n+    {\n+      result.target_obj = objptr;\n+      result.whole2target = access_path;\n+      if (boff >= 0)\n+        result.target2sub = ((char *)subptr - (char *)objptr) == boff\n+              ? contained_public : not_contained;\n+      else if (boff == -3)\n+        result.target2sub = not_contained;\n+      return false;\n+    }\n+  return base.do_dyncast (boff, access_path,\n+                          target, objptr, subtype, subptr, result);\n+}\n+\n+// find_public_subobj helper. See __user_type_info::do_find_public_subobj or\n+// semantics. BOFF indicates how SUBTYPE types are inherited by the original\n+// target object.\n+__user_type_info::sub_kind __si_type_info::\n+do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *subptr) const\n+{\n+  if (subptr == objptr && subtype == *this)\n+    return contained_public;\n+  return base.do_find_public_subobj (boff, subtype, objptr, subptr);\n+}\n \n-      void *p;\n+// catch helper for multiple or non-public inheritance types. See\n+// __user_type_info::do_upcast for semantics.\n+bool __class_type_info::\n+do_upcast (sub_kind access_path,\n+           const type_info &target, void *objptr,\n+           upcast_result &__restrict result) const\n+{\n+  if (*this == target)\n+    {\n+      result.target_obj = objptr;\n+      result.base_type = nonvirtual_base_type;\n+      result.whole2target = access_path;\n+      return contained_nonpublic_p (access_path);\n+    }\n+  \n+  for (size_t i = n_bases; i--;)\n+    {\n+      upcast_result result2;\n+      void *p = objptr;\n+      sub_kind sub_access = access_path;\n+      if (p)\n+        p = (char *)p + base_list[i].offset;\n+      if (base_list[i].is_virtual)\n+        {\n+          if (p)\n+            p = *(void **)p;\n+\t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n+        }\n+      if (base_list[i].access != PUBLIC)\n+        sub_access = sub_kind (sub_access & ~contained_public_mask);\n+      if (base_list[i].base->do_upcast (sub_access, target, p, result2))\n+        return true; // must fail\n+      if (result2.base_type)\n+        {\n+          if (result2.base_type == nonvirtual_base_type\n+              && base_list[i].is_virtual)\n+            result2.base_type = base_list[i].base;\n+          if (!result.base_type)\n+            result = result2;\n+          else if (result.target_obj != result2.target_obj)\n+            {\n+              // Found an ambiguity.\n+\t      result.target_obj = NULL;\n+\t      result.whole2target = contained_ambig;\n+\t      return true;\n+            }\n+          else if (result.target_obj)\n+            {\n+              // Ok, found real object via a virtual path.\n+              result.whole2target\n+                  = sub_kind (result.whole2target | result2.whole2target);\n+            }\n+          else\n+            {\n+              // Dealing with a null pointer, need to check vbase\n+              // containing each of the two choices.\n+              if (result2.base_type == nonvirtual_base_type\n+                  || result.base_type == nonvirtual_base_type\n+                  || !(*result2.base_type == *result.base_type))\n+                {\n+                  // Already ambiguous, not virtual or via different virtuals.\n+                  // Cannot match.\n+                  result.whole2target = contained_ambig;\n+                  return true;\n+                }\n+            }\n+        }\n+    }\n+  return false;\n+}\n \n-      if (objptr)\n-\t{\n-\t  p = (char *)objptr + base_list[i].offset;\n-\t  if (base_list[i].is_virtual)\n-\t    p = *(void **)p;\n-\t}\n-      else\n-\t/* Preserve null pointer.  */\n-\tp = objptr;\n-\n-      if (base_list[i].base->dcast (desired, is_public, p, &p, sub, subptr))\n-\t{\n-\t  if (! match_found)\n-\t    {\n-\t      match_found = 1;\n-\t      match = p;\n-\t    }\n-\t  else if (match != p)\n-\t    {\n-\t      if (sub)\n-\t\t{\n-\t\t  // Perhaps we're downcasting from *sub to desired; see if\n-\t\t  // subptr is a subobject of exactly one of {match_found,p}.\n-\n-\t\t  const __user_type_info &d =\n-\t\t    static_cast <const __user_type_info &> (desired);\n-\n-\t\t  void *os;\n-\t\t  d.dcast (*sub, 1, match, &os);\n-\t\t  void *ns;\n-\t\t  d.dcast (*sub, 1, p, &ns);\n-\n-\t\t  if (os == ns)\n-\t\t    // Both have the same subobject, so we can't disambiguate;\n-\t\t    // i.e. subptr is a virtual base.\n-\t\t    return 0;\n-\t\t  else if (os == subptr)\n-\t\t    continue;\n-\t\t  else if (ns == subptr)\n-\t\t    {\n-\t\t      match = p;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t// We're not downcasting, so we can't disambiguate.\n-\t\treturn 0;\n-\t    }\n+// dynamic cast helper for non-public or multiple inheritance types. See\n+// __user_type_info::do_dyncast for overall semantics.\n+// This is a big hairy function. Although the run-time behaviour of\n+// dynamic_cast is simple to describe, it gives rise to some non-obvious\n+// behaviour. We also desire to determine as early as possible any definite\n+// answer we can get. Because it is unknown what the run-time ratio of\n+// succeeding to failing dynamic casts is, we do not know in which direction\n+// to bias any optimizations. To that end we make no particular effort towards\n+// early fail answers or early success answers. Instead we try to minimize\n+// work by filling in things lazily (when we know we need the information),\n+// and opportunisticly take early success or failure results.\n+bool __class_type_info::\n+do_dyncast (int boff, sub_kind access_path,\n+            const type_info &target, void *objptr,\n+            const type_info &subtype, void *subptr,\n+            dyncast_result &__restrict result) const\n+{\n+  if (objptr == subptr && *this == subtype)\n+    {\n+      // The subobject we started from. Indicate how we are accessible from\n+      // the most derived object.\n+      result.whole2sub = access_path;\n+      return false;\n+    }\n+  if (*this == target)\n+    {\n+      result.target_obj = objptr;\n+      result.whole2target = access_path;\n+      if (boff >= 0)\n+        result.target2sub = ((char *)subptr - (char *)objptr) == boff\n+              ? contained_public : not_contained;\n+      else if (boff == -3)\n+        result.target2sub = not_contained;\n+      return false;\n+    }\n+  bool result_ambig = false;\n+  for (size_t i = n_bases; i--;)\n+    {\n+      dyncast_result result2;\n+      void *p = (char *)objptr + base_list[i].offset;\n+      sub_kind sub_access = access_path;\n+      if (base_list[i].is_virtual)\n+        {\n+\t  p = *(void **)p;\n+\t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n \t}\n+      if (base_list[i].access != PUBLIC)\n+        sub_access = sub_kind (sub_access & ~contained_public_mask);\n+      \n+      bool result2_ambig\n+          = base_list[i].base->do_dyncast (boff, sub_access,\n+                                           target, p, subtype, subptr, result2);\n+      result.whole2sub = sub_kind (result.whole2sub | result2.whole2sub);\n+      if (result2.target2sub == contained_public\n+          || result2.target2sub == contained_ambig)\n+        {\n+          result.target_obj = result2.target_obj;\n+          result.whole2target = result2.whole2target;\n+          result.target2sub = result2.target2sub;\n+          // Found a downcast which can't be bettered or an ambiguous downcast\n+          // which can't be disambiguated\n+          return result2_ambig;\n+        }\n+      \n+      if (!result_ambig && !result.target_obj)\n+        {\n+          // Not found anything yet.\n+          result.target_obj = result2.target_obj;\n+          result.whole2target = result2.whole2target;\n+          result_ambig = result2_ambig;\n+        }\n+      else if (result.target_obj && result.target_obj == result2.target_obj)\n+        {\n+          // Found at same address, must be via virtual.  Pick the most\n+          // accessible path.\n+          result.whole2target =\n+              sub_kind (result.whole2target | result2.whole2target);\n+        }\n+      else if ((result.target_obj && result2.target_obj)\n+               || (result_ambig && result2.target_obj)\n+               || (result2_ambig && result.target_obj))\n+        {\n+          // Found two different TARGET bases, or a valid one and a set of\n+          // ambiguous ones, must disambiguate. See whether SUBOBJ is\n+          // contained publicly within one of the non-ambiguous choices.\n+          // If it is in only one, then that's the choice. If it is in\n+          // both, then we're ambiguous and fail. If it is in neither,\n+          // we're ambiguous, but don't yet fail as we might later find a\n+          // third base which does contain SUBPTR.\n+        \n+          sub_kind new_sub_kind = result2.target2sub;\n+          sub_kind old_sub_kind = result.target2sub;\n+          \n+          if (contained_nonvirtual_p (result.whole2sub))\n+            {\n+              // We already found SUBOBJ as a non-virtual base of most\n+              // derived. Therefore if it is in either choice, it can only be\n+              // in one of them, and we will already know.\n+              if (old_sub_kind == unknown)\n+                old_sub_kind = not_contained;\n+              if (new_sub_kind == unknown)\n+                new_sub_kind = not_contained;\n+            }\n+          else\n+            {\n+              const __user_type_info &t =\n+                  static_cast <const __user_type_info &> (target);\n+              \n+              if (old_sub_kind >= not_contained)\n+                ;// already calculated\n+              else if (contained_nonvirtual_p (new_sub_kind))\n+                // Already found non-virtually inside the other choice,\n+                // cannot be in this.\n+                old_sub_kind = not_contained;\n+              else\n+                old_sub_kind = t.find_public_subobj (boff, subtype,\n+                                                     result.target_obj, subptr);\n+          \n+              if (new_sub_kind >= not_contained)\n+                ;// already calculated\n+              else if (contained_nonvirtual_p (old_sub_kind))\n+                // Already found non-virtually inside the other choice,\n+                // cannot be in this.\n+                new_sub_kind = not_contained;\n+              else\n+                new_sub_kind = t.find_public_subobj (boff, subtype,\n+                                                     result2.target_obj, subptr);\n+            }\n+          \n+          // Neither sub_kind can be contained_ambig -- we bail out early\n+          // when we find those.\n+          if (contained_p (sub_kind (new_sub_kind ^ old_sub_kind)))\n+            {\n+              // Only on one choice, not ambiguous.\n+              if (contained_p (new_sub_kind))\n+                {\n+                  // Only in new.\n+                  result.target_obj = result2.target_obj;\n+                  result.whole2target = result2.whole2target;\n+                  result_ambig = false;\n+                  old_sub_kind = new_sub_kind;\n+                }\n+              result.target2sub = old_sub_kind;\n+              if (result.target2sub == contained_public)\n+                return false; // Can't be an ambiguating downcast for later discovery.\n+            }\n+          else if (contained_p (sub_kind (new_sub_kind & old_sub_kind)))\n+            {\n+              // In both.\n+              result.target_obj = NULL;\n+              result.target2sub = contained_ambig;\n+              return true;  // Fail.\n+            }\n+          else\n+            {\n+              // In neither publicly, ambiguous for the moment, but keep\n+              // looking. It is possible that it was private in one or\n+              // both and therefore we should fail, but that's just tough.\n+              result.target_obj = NULL;\n+              result.target2sub = not_contained;\n+              result_ambig = true;\n+            }\n+        }\n+      \n+      if (result.whole2sub == contained_private)\n+        // We found SUBOBJ as a private non-virtual base, therefore all\n+        // cross casts will fail. We have already found a down cast, if\n+        // there is one.\n+        return result_ambig;\n     }\n \n-  *valp = match;\n-  return match_found;\n+  return result_ambig;\n+}\n+\n+// find_public_subobj helper for non-public or multiple inheritance types. See\n+// __user_type_info::do_find_public_subobj for semantics. We make use of BOFF\n+// to prune the base class walk.\n+__user_type_info::sub_kind __class_type_info::\n+do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *subptr) const\n+{\n+  if (objptr == subptr && subtype == *this)\n+    return contained_public;\n+  \n+  for (size_t i = n_bases; i--;)\n+    {\n+      if (base_list[i].access != PUBLIC)\n+        continue; // Not public, can't be here.\n+      void *p = (char *)objptr + base_list[i].offset;\n+      if (base_list[i].is_virtual)\n+        {\n+          if (boff == -1)\n+            continue; // Not a virtual base, so can't be here.\n+          p = *(void **)p;\n+        }\n+\n+      sub_kind base_kind = base_list[i].base->do_find_public_subobj\n+                              (boff, subtype, p, subptr);\n+      if (contained_p (base_kind))\n+        {\n+          if (base_list[i].is_virtual)\n+            base_kind = sub_kind (base_kind | contained_virtual_mask);\n+          return base_kind;\n+        }\n+    }\n+  \n+  return not_contained;\n }"}, {"sha": "39be84edde500232bb03d9ff3f9f203256d0c342", "filename": "gcc/cp/tinfo.h", "status": "modified", "additions": 152, "deletions": 9, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.h?ref=4a9e5c6725f3d793821c081801467d0a84c54e7c", "patch": "@@ -10,10 +10,138 @@\n struct __user_type_info : public std::type_info {\n   __user_type_info (const char *n) : type_info (n) {}\n \n-  // If our type can be converted to the desired type, \n-  // return the pointer, adjusted accordingly; else return 0.\n-  virtual int dcast (const type_info &, int, void *, void **,\n-\t\t     const type_info * = 0, void * = 0) const;\n+  // If our type can be upcast to a public and unambiguous base, then return\n+  // non-zero and set RES to point to the base object. OBJ points to the throw\n+  // object and can be NULL, if there is no object to adjust.\n+  int upcast (const type_info &target, void *obj, void **res) const;\n+  \n+  // If our type can be dynamicly cast to the target type, then return\n+  // pointer to the target object. OBJ is the pointer to the most derived\n+  // type and cannot be NULL. SUBTYPE and SUBOBJ indicate the static type\n+  // base object from whence we came, it cannot be NULL. SUBTYPE cannot be\n+  // the same as TARGET. TARGET cannot be a base of SUBTYPE.\n+  // BOFF indicates how SUBTYPE is related to TARGET.\n+  // BOFF >= 0, there is only one public non-virtual SUBTYPE base at offset\n+  //    BOFF, and there are no public virtual SUBTYPE bases.\n+  //    Therefore check if SUBOBJ is at offset BOFF when we find a target\n+  // BOFF == -1, SUBTYPE occurs as multiple public non-virtual bases.\n+  //    Lazily search the non-virtual bases of TARGET.\n+  // BOFF == -2, SUBTYPE occurs as multiple public virtual or non-virtual bases.\n+  //    Lazily search all the bases of TARGET.\n+  // BOFF == -3, SUBTYPE is not a public base.\n+  // For backwards compatibility set BOFF to -2, that is the safe `don't know'\n+  // value. We don't care about SUBTYPES as private bases of TARGET, as they\n+  // can never succeed as downcasts, only as crosscasts -- and then only if\n+  // they are virtual. This is more complicated that it might seem.\n+  void *dyncast (int boff,\n+                 const type_info &target, void *obj,\n+                 const type_info &subtype, void *subobj) const;\n+  \n+  // non_virtual_base_type is used to indicate that a base class is via a\n+  // non-virtual access path.\n+  static const type_info *const nonvirtual_base_type\n+      = static_cast <const type_info *> (0) + 1;\n+  \n+  // sub_kind tells us about how a base object is contained within a derived\n+  // object. We often do this lazily, hence the UNKNOWN value. At other times\n+  // we may use NOT_CONTAINED to mean not publicly contained.\n+  enum sub_kind\n+  {\n+    unknown = 0,              // we have no idea\n+    not_contained,            // not contained within us (in some\n+                              // circumstances this might mean not contained\n+                              // publicly)\n+    contained_ambig,          // contained ambiguously\n+    contained_mask = 4,       // contained within us\n+    contained_virtual_mask = 1, // via a virtual path\n+    contained_public_mask = 2,  // via a public path\n+    contained_private = contained_mask,\n+    contained_public = contained_mask | contained_public_mask\n+  };\n+  // some predicate functions for sub_kind\n+  static inline bool contained_p (sub_kind access_path)\n+  {\n+    return access_path >= contained_mask;\n+  }\n+  static inline bool contained_public_p (sub_kind access_path)\n+  {\n+    return access_path >= contained_public;\n+  }\n+  static inline bool contained_nonpublic_p (sub_kind access_path)\n+  {\n+    return (access_path & contained_public) == contained_mask;\n+  }\n+  static inline bool contained_nonvirtual_p (sub_kind access_path)\n+  {\n+    return (access_path & (contained_mask | contained_virtual_mask))\n+           == contained_mask;\n+  }\n+  \n+  struct upcast_result\n+  {\n+    void *target_obj;   // pointer to target object or NULL (init NULL)\n+    sub_kind whole2target;      // path from most derived object to target\n+    const type_info *base_type; // where we found the target, (init NULL)\n+                                // if in vbase the __user_type_info of vbase)\n+                                // if a non-virtual base then 1\n+                                // else NULL\n+    public:\n+    upcast_result ()\n+      :target_obj (NULL), whole2target (unknown), base_type (NULL)\n+      {}\n+  };\n+  struct dyncast_result\n+  {\n+    void *target_obj;   // pointer to target object or NULL (init NULL)\n+    sub_kind whole2target;      // path from most derived object to target\n+    sub_kind whole2sub;         // path from most derived object to sub object\n+    sub_kind target2sub;        // path from target to sub object\n+    \n+    public:\n+    dyncast_result ()\n+      :target_obj (NULL), whole2target (unknown),\n+       whole2sub (unknown), target2sub (unknown)\n+      {}\n+  };\n+  \n+  public:\n+  // Helper for upcast. See if TARGET is us, or one of our bases. ACCESS_PATH\n+  // gives the access from the start object. Return TRUE if we know the catch\n+  // fails.\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const type_info &target, void *obj,\n+                          upcast_result &__restrict result) const;\n+  // Helper for dyncast. BOFF indicates how the SUBTYPE is related to TARGET.\n+  // ACCESS_PATH indicates the access from the most derived object.  It is\n+  // used to prune the DAG walk. All information about what we find is put\n+  // into RESULT. Return true, if the match we have found is ambiguous.\n+  virtual bool do_dyncast (int boff, sub_kind access_path,\n+                           const type_info &target, void *obj,\n+                           const type_info &subtype, void *subptr,\n+                           dyncast_result &__restrict result) const;\n+  public:\n+  // Indicate whether SUBPTR of type SUBTYPE is contained publicly within\n+  // OBJPTR. OBJPTR points to this base object. BOFF indicates how SUBTYPE\n+  // objects might be contained within this type.  If SUBPTR is one of our\n+  // SUBTYPE bases, indicate virtuality. Returns not_contained for non\n+  // containment or private containment.\n+  sub_kind find_public_subobj (int boff, const type_info &subtype,\n+                               void *objptr, void *subptr) const\n+  {\n+    if (boff >= 0)\n+      return ((char *)subptr - (char *)objptr) == boff\n+              ? contained_public : not_contained;\n+    if (boff == -3)\n+      return not_contained;\n+    return do_find_public_subobj (boff, subtype, objptr, subptr);\n+  }\n+  \n+  public:\n+  // Helper for find_subobj. BOFF indicates how SUBTYPE bases are inherited by\n+  // the type started from -- which is not necessarily the current type.\n+  // OBJPTR points to the current base.\n+  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n+                                          void *objptr, void *subptr) const;\n };\n \n // type_info for a class with one public, nonvirtual base class.\n@@ -25,8 +153,16 @@ class __si_type_info : public __user_type_info {\n   __si_type_info (const char *n, const __user_type_info &b)\n     : __user_type_info (n), base (b) { }\n \n-  virtual int dcast (const type_info &, int, void *, void **,\n-\t\t     const type_info * = 0, void * = 0) const;\n+  private:\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const type_info &target, void *obj,\n+                          upcast_result &__restrict result) const;\n+  virtual bool do_dyncast (int boff, sub_kind access_path,\n+                           const type_info &target, void *obj,\n+                           const type_info &subtype, void *subptr,\n+                           dyncast_result &__restrict result) const;\n+  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n+                                          void *objptr, void *subptr) const;\n };\n \n // type_info for a general class.\n@@ -49,7 +185,14 @@ struct __class_type_info : public __user_type_info {\n   __class_type_info (const char *name, const base_info *bl, size_t bn)\n     : __user_type_info (name), base_list (bl), n_bases (bn) {}\n \n-  // This is a little complex.\n-  virtual int dcast (const type_info &, int, void *, void **,\n-\t\t     const type_info * = 0, void * = 0) const;\n+  public:\n+  virtual bool do_upcast (sub_kind access_path,\n+                          const type_info &target, void *obj,\n+                          upcast_result &__restrict result) const;\n+  virtual bool do_dyncast (int boff, sub_kind access_path,\n+                           const type_info &target, void *obj,\n+                           const type_info &subtype, void *subptr,\n+                           dyncast_result &__restrict result) const;\n+  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,\n+                                          void *objptr, void *subptr) const;\n };"}, {"sha": "f24b59bd4ed82582c77db2e9e1f3b3ab1b3f83be", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a9e5c6725f3d793821c081801467d0a84c54e7c/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=4a9e5c6725f3d793821c081801467d0a84c54e7c", "patch": "@@ -108,8 +108,7 @@ __throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n   if (const __user_type_info *p\n       = dynamic_cast <const __user_type_info *> (&throw_type))\n     {\n-      /* The 1 skips conversions to private bases. */\n-      return p->dcast (catch_type, 1, objptr, valp);\n+      return p->upcast (catch_type, objptr, valp);\n     }\n   else if (const __pointer_type_info *fr =\n \t   dynamic_cast <const __pointer_type_info *> (&throw_type))\n@@ -154,10 +153,7 @@ __throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n \treturn 1;\n       else if (const __user_type_info *p\n \t       = dynamic_cast <const __user_type_info *> (subfr))\n-\t{\n-\t  /* The 1 skips conversions to private bases. */\n-\t  return p->dcast (*subto, 1, objptr, valp);\n-\t}\n+\treturn p->upcast (*subto, objptr, valp);\n       else if (const __pointer_type_info *pfr\n \t       = dynamic_cast <const __pointer_type_info *> (subfr))\n \t{\n@@ -274,14 +270,20 @@ __rtti_array (void *addr, const char *name)\n \n extern \"C\" void *\n __dynamic_cast (const type_info& (*from)(void), const type_info& (*to)(void),\n-\t\tint require_public, void *address,\n-\t\tconst type_info & (*sub)(void), void *subptr)\n+\t\tint require_public, void *address, const type_info & (*sub)(void), void *subptr)\n {\n-  void *ret;\n-  if (static_cast <const __user_type_info &> (from ()).dcast\n-      (to (), require_public, address, &ret, &(sub ()), subptr))\n-    return ret;\n-  return 0;\n+  if (!require_public) abort();\n+  return static_cast <__user_type_info const &> (from ()).dyncast\n+      (/*boff=*/-2, to (), address, sub (), subptr);\n+}\n+\n+extern \"C\" void *\n+__dynamic_cast_2 (const type_info& (*from)(void), const type_info& (*to)(void),\n+                  int boff,\n+\t\t  void *address, const type_info & (*sub)(void), void *subptr)\n+{\n+  return static_cast <__user_type_info const &> (from ()).dyncast\n+      (boff, to (), address, sub (), subptr);\n }\n \n // type_info nodes and functions for the builtin types.  The mangling here"}]}