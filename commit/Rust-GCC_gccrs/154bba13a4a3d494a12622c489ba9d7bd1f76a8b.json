{"sha": "154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU0YmJhMTNhNGEzZDQ5NGExMjYyMmM0ODliYTlkN2JkMWY3NmE4Yg==", "commit": {"author": {"name": "Teemu Torma", "email": "tot@trema.com", "date": "1997-12-12T04:53:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-12T04:53:20Z"}, "message": "[multiple changes]\n\nThu Dec 11 20:42:18 1997  Teemu Torma  <tot@trema.com>\n\n\tThread-safe EH support for pthreads, DCE threads and Solaris threads.\n\n\t* integrate.c (expand_inline_function): If the inline fn uses eh\n\tcontext, make sure that the current fn has one.\n\t* toplev.c (rest_of_compilation): Call emit_eh_context.\n\t* except.c (use_eh_context): New fn.\n\t(get_eh_context_once): New fn.\n\t(call_get_eh_context): New fn.\n\t(emit_eh_context): New fn.\n\t(get_eh_context): Call either get_eh_context_once or\n\tcall_get_eh_context, depending on what we have.\n\t(get_dynamic_handler_chain): Call get_eh_context_once.\n\t* except.h: Prototypes for fns above.\n\t* optabs.c (get_eh_context_libfunc): Removed.\n\t(init_optabs): Don't initialize it.\n\t* expr.h (get_eh_context_libfunc): Removed.\n\t* rtl.h, rtl.c: New reg_note REG_EH_CONTEXT.\n\t* config/pa/pa.h (CPP_SPEC): Support for -threads.\n\t* config/pa/pa-hpux10.h (LIB_SPEC): Ditto.\n\t* config/pa/t-pa (MULTILIB_OPTIONS, MULTILIB_DIRNAMES):\n\tNew multilib for -threads.\n\t* config/sparc/t-sol2: Added multilibs for -threads and\n\tmade -pthreads alias to it.\n\t* config/sparc/sol2.h (CPP_SPEC, LIB_SPEC):\n\tAdded -threads and -pthreads options.\n\t* libgcc-thr.h: New file.\n\t* libgcc2.c: (__get_cpp_eh_context): Removed.\n\t(struct cpp_eh_context): Removed.\n\t(struct eh_context): Replaced cpp_eh_context with generic language\n\tspecific pointer.\n\t(__get_eh_info): New function.\n\t(__throw): Check eh_context::info.\n\t(__sjthrow): Ditto.\n\t* libgcc2.c: Include libgcc-thr.h.\n\t(new_eh_context, __get_eh_context,\n\teh_pthread_initialize, eh_context_initialize, eh_context_static,\n\teh_context_specific, eh_context_free): New functions.\n\t(get_eh_context, eh_context_key): New variables.\n\t(__sjthrow, __sjpopnthrow, __eh_pcnthrow, __throw): Use\n\tget_eh_context to get the context.\n\t(longjmp): Move the declaration inside\n\t#ifdef DONT_USE_BUILTIN_SETJMP.\n\t* frame.c: Include libgcc-thr.h.\n\t(object_mutex): Mutex to protect the object list.\n\t(find_fde, __register_frame, __register_frame_table,\n\t__deregister_frame): Hold the lock while accessing objects.\n\t* except.h (get_eh_context): Declare.\n\t* except.c (current_function_ehc): Define.\n\t(current_function_dhc, current_function_dcc): Removed.\n\t(get_eh_context): New function.\n\t(get_dynamic_handler_chain): Use get_eh_context.\n\t(get_saved_pc_ref): Ditto.\n\t(get_dynamic_cleanup_chain): Removed references to\n\tcurrent_function_dcc.\n\t(save_eh_status, restore_eh_status): Save and restore\n\tcurrent_function_ehc instead.\n\t* optabs.c (get_eh_context_libfunc): New variable.\n\t(init_optabs): Initialize it.\n\t* expr.h: Declare get_eh_context_libfunc.\n\t* function.h (struct function): Replaced dhc and dcc with ehc.\n\t* except.c (get_saved_pc_ref): New functions.\n\t(eh_saved_pc_rtx, eh_saved_pc): Deleted.\n\t(expand_internal_throw_indirect): Use get_saved_pc_ref() instead\n\tof eh_saved_pc.\n\t(end_eh_unwinder): Likewise.\n\t(init_eh): Remove initialization of eh_saved_pc.\n\t* optabs.c (get_saved_pc_libfunc): New variable.\n\t(init_optabs): Initialize it.\n\t* expr.h: Declare get_saved_pc_libfunc.\n\t* except.h (eh_saved_pc_rtx): Deleted.\n\t(get_saved_pc_ref): Declared.\n\n\tFrom Scott Snyder <snyder@d0sgif.fnal.gov>:\n\t* libgcc2.c (__get_saved_pc): New.\n\t(__eh_type, __eh_pc): Deleted.\n\t(__eh_pcnthrow): Use __get_saved_pc() instead of __eh_pc.\n\t(__get_dynamic_handler_chain): Move __dynamic_handler_chain inside\n\tthis fcn.\n\ncp/:\nThu Dec 11 20:43:33 1997  Teemu Torma  <tot@trema.com>\n\n\t* decl.c (ptr_ptr_type_node): Define.\n\t(init_decl_processing): Initialize it.\n\t* cp-tree.h: Declare it.\n\t* exception.cc (__cp_exception_info): Use __get_eh_info.\n\t(__cp_push_exception): Ditto.\n\t(__cp_pop_exception): Ditto.\n\n\tFrom Scott Snyder <snyder@d0sgif.fnal.gov>:\n        * except.c (expand_builtin_throw): Use get_saved_pc_ref instead of\n\tsaved_pc.\n\t(init_exception_processing): Removed saved_pc initialization.\n\nFrom-SVN: r17052", "tree": {"sha": "b1e33498c494a6a7e60f2adbf6b766688bf20d7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1e33498c494a6a7e60f2adbf6b766688bf20d7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/comments", "author": null, "committer": null, "parents": [{"sha": "24a184c9e7ea966a7a55088b0ac426136316ec5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24a184c9e7ea966a7a55088b0ac426136316ec5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24a184c9e7ea966a7a55088b0ac426136316ec5f"}], "stats": {"total": 701, "additions": 567, "deletions": 134}, "files": [{"sha": "8d36284cf57c88e3819e934a0be32b223f52147b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -1,3 +1,84 @@\n+Thu Dec 11 20:42:18 1997  Teemu Torma  <tot@trema.com>\n+\n+\tThread-safe EH support for pthreads, DCE threads and Solaris threads.\n+\t\n+\t* integrate.c (expand_inline_function): If the inline fn uses eh\n+\tcontext, make sure that the current fn has one.\n+\t* toplev.c (rest_of_compilation): Call emit_eh_context.\n+\t* except.c (use_eh_context): New fn.\n+\t(get_eh_context_once): New fn.\n+\t(call_get_eh_context): New fn.\n+\t(emit_eh_context): New fn.\n+\t(get_eh_context): Call either get_eh_context_once or\n+\tcall_get_eh_context, depending on what we have.\n+\t(get_dynamic_handler_chain): Call get_eh_context_once.\n+\t* except.h: Prototypes for fns above.\n+\t* optabs.c (get_eh_context_libfunc): Removed.\n+\t(init_optabs): Don't initialize it.\n+\t* expr.h (get_eh_context_libfunc): Removed.\n+\t* rtl.h, rtl.c: New reg_note REG_EH_CONTEXT.\n+\t* config/pa/pa.h (CPP_SPEC): Support for -threads.\n+\t* config/pa/pa-hpux10.h (LIB_SPEC): Ditto.\n+\t* config/pa/t-pa (MULTILIB_OPTIONS, MULTILIB_DIRNAMES):\n+\tNew multilib for -threads.\n+\t* config/sparc/t-sol2: Added multilibs for -threads and\n+\tmade -pthreads alias to it.\n+\t* config/sparc/sol2.h (CPP_SPEC, LIB_SPEC):\n+\tAdded -threads and -pthreads options.\n+\t* libgcc-thr.h: New file.\n+\t* libgcc2.c: (__get_cpp_eh_context): Removed.\n+\t(struct cpp_eh_context): Removed.\n+\t(struct eh_context): Replaced cpp_eh_context with generic language\n+\tspecific pointer. \n+\t(__get_eh_info): New function.\n+\t(__throw): Check eh_context::info.\n+\t(__sjthrow): Ditto.\n+\t* libgcc2.c: Include libgcc-thr.h.\n+\t(new_eh_context, __get_eh_context,\n+\teh_pthread_initialize, eh_context_initialize, eh_context_static,\n+\teh_context_specific, eh_context_free): New functions.\n+\t(get_eh_context, eh_context_key): New variables.\n+\t(__sjthrow, __sjpopnthrow, __eh_pcnthrow, __throw): Use\n+\tget_eh_context to get the context.\n+\t(longjmp): Move the declaration inside\n+\t#ifdef DONT_USE_BUILTIN_SETJMP.\n+\t* frame.c: Include libgcc-thr.h.\n+\t(object_mutex): Mutex to protect the object list.\n+\t(find_fde, __register_frame, __register_frame_table,\n+\t__deregister_frame): Hold the lock while accessing objects.\n+\t* except.h (get_eh_context): Declare.\n+\t* except.c (current_function_ehc): Define.\n+\t(current_function_dhc, current_function_dcc): Removed.\n+\t(get_eh_context): New function.\n+\t(get_dynamic_handler_chain): Use get_eh_context.\n+\t(get_saved_pc_ref): Ditto.\n+\t(get_dynamic_cleanup_chain): Removed references to\n+\tcurrent_function_dcc.\n+\t(save_eh_status, restore_eh_status): Save and restore\n+\tcurrent_function_ehc instead.\n+\t* optabs.c (get_eh_context_libfunc): New variable.\n+\t(init_optabs): Initialize it.\n+\t* expr.h: Declare get_eh_context_libfunc.\n+\t* function.h (struct function): Replaced dhc and dcc with ehc.\n+\t* except.c (get_saved_pc_ref): New functions.\n+\t(eh_saved_pc_rtx, eh_saved_pc): Deleted.\n+\t(expand_internal_throw_indirect): Use get_saved_pc_ref() instead\n+\tof eh_saved_pc.\n+\t(end_eh_unwinder): Likewise.\n+\t(init_eh): Remove initialization of eh_saved_pc.\n+\t* optabs.c (get_saved_pc_libfunc): New variable.\n+\t(init_optabs): Initialize it.\n+\t* expr.h: Declare get_saved_pc_libfunc.\n+\t* except.h (eh_saved_pc_rtx): Deleted.\n+\t(get_saved_pc_ref): Declared.\n+\n+\tFrom Scott Snyder <snyder@d0sgif.fnal.gov>:\n+\t* libgcc2.c (__get_saved_pc): New.\n+\t(__eh_type, __eh_pc): Deleted.\n+\t(__eh_pcnthrow): Use __get_saved_pc() instead of __eh_pc.\n+\t(__get_dynamic_handler_chain): Move __dynamic_handler_chain inside\n+\tthis fcn.\n+\n Thu Dec 11 17:23:48 1997  John F. Carr  <jfc@mit.edu>\n \n \t* sparc/sol2.h: Use 64 bit multiply and divide functions in"}, {"sha": "0cd59127f682ab4b12d512992ce036ded4016393", "filename": "gcc/config/pa/pa-hpux10.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fpa%2Fpa-hpux10.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fpa%2Fpa-hpux10.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux10.h?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -30,6 +30,17 @@ Boston, MA 02111-1307, USA.  */\n   \"-z %{mlinker-opt:-O} %{!shared:-u main} %{static:-a archive} %{shared:-b}\"\n #endif\n \n+/* Like the default, except no -lg.  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+  \"%{!shared:\\\n+     %{!p:\\\n+       %{!pg:\\\n+         %{!threads:-lc}\\\n+         %{threads:-lcma -lc_r}}\\\n+       %{p: -L/lib/libp/ -lc}\\\n+       %{pg: -L/lib/libp/ -lc}}}\"\n+\n /* The hpux10 assembler requires a .LEVEL pseudo-op at the start of\n    the assembly file.  */\n #undef ASM_FILE_START"}, {"sha": "a127c84673d6e43c01c41891942f8441dc2de1eb", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -241,9 +241,12 @@ extern int target_flags;\n #if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & 1) == 0\n #define CPP_SPEC \"%{msnake:-D__hp9000s700 -D_PA_RISC1_1}\\\n  %{mpa-risc-1-1:-D__hp9000s700 -D_PA_RISC1_1}\\\n- %{!ansi: -D_HPUX_SOURCE -D_HIUX_SOURCE}\"\n+ %{!ansi: -D_HPUX_SOURCE -D_HIUX_SOURCE}\\\n+ %{threads:-D_REENTRANT -D_DCE_THREADS}\"\n #else\n-#define CPP_SPEC \"%{!mpa-risc-1-0:%{!mnosnake:%{!msoft-float:-D__hp9000s700 -D_PA_RISC1_1}}} %{!ansi: -D_HPUX_SOURCE -D_HIUX_SOURCE}\"\n+#define CPP_SPEC \"%{!mpa-risc-1-0:%{!mnosnake:%{!msoft-float:-D__hp9000s700 -D_PA_RISC1_1}}} \\\n+ %{!ansi: -D_HPUX_SOURCE -D_HIUX_SOURCE}\\\n+ %{threads:-D_REENTRANT -D_DCE_THREADS}\"\n #endif\n \n /* Defines for a K&R CC */"}, {"sha": "b6dcec1212ea8191d67dd2fe2c81176a8c15103b", "filename": "gcc/config/pa/t-pa", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fpa%2Ft-pa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fpa%2Ft-pa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Ft-pa?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -16,3 +16,9 @@ ee_fp.asm: $(srcdir)/config/pa/ee_fp.asm\n \tcp $(srcdir)/config/pa/ee_fp.asm .\n \n TARGET_LIBGCC2_CFLAGS = -fPIC\n+\n+MULTILIB_OPTIONS = threads\n+MULTILIB_DIRNAMES = threads\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "76cade44d9e0368f77f99572367358221aefe9d0", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -30,6 +30,8 @@ Boston, MA 02111-1307, USA.  */\n \n #undef CPP_SUBTARGET_SPEC\n #define CPP_SUBTARGET_SPEC \"\\\n+%{pthreads:-D_REENTRANT -D_PTHREADS} \\\n+%{!pthreads:%{threads:-D_REENTRANT -D_SOLARIS_THREADS}} \\\n %{compat-bsd:-iwithprefixbefore ucbinclude -I/usr/ucbinclude} \\\n \"\n \n@@ -131,7 +133,12 @@ Boston, MA 02111-1307, USA.  */\n \n #undef LIB_SPEC\n #define LIB_SPEC \\\n-  \"%{compat-bsd:-lucb -lsocket -lnsl -lelf -laio} %{!shared:%{!symbolic:-lc}}\"\n+  \"%{compat-bsd:-lucb -lsocket -lnsl -lelf -laio} \\\n+   %{!shared:\\\n+     %{!symbolic:\\\n+       %{pthreads:-lpthread} \\\n+       %{!pthreads:%{threads:-lthread}} \\\n+       -lc}}\"\n \n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \"crtend.o%s crtn.o%s\""}, {"sha": "309aedfd9f9b1ad9af4f462620c9ce4a0e0fc1a3", "filename": "gcc/config/sparc/t-sol2", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fsparc%2Ft-sol2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fconfig%2Fsparc%2Ft-sol2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-sol2?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -5,6 +5,13 @@ LIBGCC1 =\n CROSS_LIBGCC1 =\n LIBGCC1_TEST =\n \n+MULTILIB_OPTIONS = threads\n+MULTILIB_DIRNAMES = threads\n+MULTILIB_MATCHES = threads=pthreads\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n # gmon build rule:\n gmon.o:\t$(srcdir)/config/sparc/gmon-sol2.c $(GCC_PASSES) $(CONFIG_H) stmp-int-hdrs\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\"}, {"sha": "d2070090997dd60df5570fcba0c15c4c625e50a4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -1,3 +1,17 @@\n+Thu Dec 11 20:43:33 1997  Teemu Torma  <tot@trema.com>\n+\t\n+\t* decl.c (ptr_ptr_type_node): Define.\n+\t(init_decl_processing): Initialize it.\n+\t* cp-tree.h: Declare it.\n+\t* exception.cc (__cp_exception_info): Use __get_eh_info.\n+\t(__cp_push_exception): Ditto.\n+\t(__cp_pop_exception): Ditto.\n+\n+\tFrom Scott Snyder <snyder@d0sgif.fnal.gov>:\n+        * except.c (expand_builtin_throw): Use get_saved_pc_ref instead of\n+\tsaved_pc.\n+\t(init_exception_processing): Removed saved_pc initialization.\n+\n Wed Dec 10 11:04:45 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (instantiate_decl): Defer all templates but inline functions."}, {"sha": "48740a5e3cb0bc3a18eeb1f012a4c9efd1fcc36a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -1511,7 +1511,7 @@ extern tree vt_off_identifier;\n /* A node that is a list (length 1) of error_mark_nodes.  */\n extern tree error_mark_list;\n \n-extern tree ptr_type_node;\n+extern tree ptr_type_node, ptr_ptr_type_node;\n extern tree class_type_node, record_type_node, union_type_node, enum_type_node;\n extern tree unknown_type_node;\n extern tree opaque_type_node, signature_type_node;"}, {"sha": "fd753d8ad79dbf7344bfdc3bee95a4e27878ca2a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -241,6 +241,10 @@ tree void_zero_node;\n tree ptr_type_node;\n tree const_ptr_type_node;\n \n+/* Node for type `void **'. */\n+\n+tree ptr_ptr_type_node;\n+\n /* Nodes for types `char *' and `const char *'.  */\n \n tree string_type_node, const_string_type_node;\n@@ -5065,6 +5069,7 @@ init_decl_processing ()\n   ptr_type_node = build_pointer_type (void_type_node);\n   const_ptr_type_node\n     = build_pointer_type (build_type_variant (void_type_node, 1, 0));\n+  ptr_ptr_type_node = build_pointer_type (ptr_type_node);\n #if 0\n   record_builtin_type (RID_MAX, NULL_PTR, ptr_type_node);\n #endif"}, {"sha": "0fa5c2425a8f502514c3786f27fdac68ab321c43", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -186,9 +186,6 @@ static tree Unwind;\n    ========================================================================= */\n \n #ifndef DWARF2_UNWIND_INFO\n-/* Holds the pc for doing \"throw\" */\n-static tree saved_pc;\n-\n extern int throw_used;\n #endif\n \n@@ -258,15 +255,6 @@ init_exception_processing ()\n \n   pop_lang_context ();\n \n-#ifndef DWARF2_UNWIND_INFO\n-  d = build_decl (VAR_DECL, get_identifier (\"__eh_pc\"), ptr_type_node);\n-  TREE_PUBLIC (d) = 1;\n-  DECL_EXTERNAL (d) = 1;\n-  DECL_ARTIFICIAL (d) = 1;\n-  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n-  saved_pc = d;\n-#endif\n-\n   /* If we use setjmp/longjmp EH, arrange for all cleanup actions to\n      be protected with __terminate.  */\n   protect_cleanup_actions_with_terminate = 1;\n@@ -812,8 +800,10 @@ expand_builtin_throw ()\n \n   /* search for an exception handler for the saved_pc */\n   handler = do_function_call (FirstExceptionMatch,\n-\t\t\t      expr_tree_cons (NULL_TREE, saved_pc,\n-\t\t\t\t\t NULL_TREE),\n+\t\t\t      expr_tree_cons (NULL_TREE,\n+\t\t\t\t\t      make_tree (ptr_ptr_type_node,\n+\t\t\t\t\t\t\t get_saved_pc_ref ()),\n+\t\t\t\t\t      NULL_TREE),\n \t\t\t      ptr_type_node);\n \n   /* did we find one? */\n@@ -892,7 +882,7 @@ expand_builtin_throw ()\n     }\n   else\n #endif\n-    emit_move_insn (eh_saved_pc_rtx, next_pc);\n+    emit_move_insn (get_saved_pc_ref (), next_pc);\n \n   after_unwind = gen_label_rtx ();\n   do_unwind (gen_rtx (LABEL_REF, Pmode, after_unwind));"}, {"sha": "399d2c60dbcc3b82a90a4b9e31ac09359329e988", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -91,9 +91,9 @@ struct cp_eh_info\n   long handlers;\n };\n \n-/* Language-specific EH info pointer, defined in libgcc2.  */\n+/* Language-specific EH info pointer, defined in libgcc2. */\n \n-extern cp_eh_info *__eh_info;  // actually void*\n+extern \"C\" cp_eh_info **__get_eh_info (); \t// actually void **\n \n /* Is P the type_info node for a pointer of some kind?  */\n \n@@ -105,7 +105,7 @@ extern bool __is_pointer (void *);\n extern \"C\" cp_eh_info *\n __cp_exception_info (void)\n {\n-  return __eh_info;\n+  return *__get_eh_info ();\n }\n \n /* Compiler hook to push a new exception onto the stack.\n@@ -120,8 +120,11 @@ __cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n   p->cleanup = cleanup;\n   p->handlers = 0;\n   p->caught = false;\n-  p->next = __eh_info;\n-  __eh_info = p;\n+\n+  cp_eh_info **q = __get_eh_info ();\n+\n+  p->next = *q;\n+  *q = p;\n }\n \n /* Compiler hook to pop an exception that has been finalized.  Used by\n@@ -131,7 +134,7 @@ __cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n extern \"C\" void\n __cp_pop_exception (cp_eh_info *p)\n {\n-  cp_eh_info **q = &__eh_info;\n+  cp_eh_info **q = __get_eh_info ();\n \n   --p->handlers;\n "}, {"sha": "11c3be87fc57eb240ab52840ddb504af7cc93ca8", "filename": "gcc/except.c", "status": "modified", "additions": 167, "deletions": 66, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -431,17 +431,10 @@ rtx exception_handler_labels;\n \n int throw_used;\n \n-/* The dynamic handler chain.  Nonzero if the function has already\n-   fetched a pointer to the dynamic handler chain for exception\n-   handling.  */\n-\n-rtx current_function_dhc;\n-\n-/* The dynamic cleanup chain.  Nonzero if the function has already\n-   fetched a pointer to the dynamic cleanup chain for exception\n-   handling.  */\n+/* The EH context.  Nonzero if the function has already\n+   fetched a pointer to the EH context  for exception handling.  */\n \n-rtx current_function_dcc;\n+rtx current_function_ehc;\n \n /* A stack used for keeping track of the currently active exception\n    handling region.  As each exception region is started, an entry\n@@ -496,13 +489,6 @@ struct label_node *outer_context_label_stack = NULL;\n \n struct label_node *false_label_stack = NULL;\n \n-#ifndef DWARF2_UNWIND_INFO\n-/* The rtx and the tree for the saved PC value.  */\n-\n-rtx eh_saved_pc_rtx;\n-tree eh_saved_pc;\n-#endif\n-\n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n static void expand_rethrow\tPROTO((rtx));\n \n@@ -721,37 +707,20 @@ add_partial_entry (handler)\n   pop_obstacks ();\n }\n \n-/* Get a reference to the dynamic handler chain.  It points to the\n-   pointer to the next element in the dynamic handler chain.  It ends\n-   when there are no more elements in the dynamic handler chain, when\n-   the value is &top_elt from libgcc2.c.  Immediately after the\n-   pointer, is an area suitable for setjmp/longjmp when\n-   DONT_USE_BUILTIN_SETJMP is defined, and an area suitable for\n-   __builtin_setjmp/__builtin_longjmp when DONT_USE_BUILTIN_SETJMP\n-   isn't defined.\n+/* Emit code to get EH context to current function. */\n \n-   This routine is here to facilitate the porting of this code to\n-   systems with threads.  One can either replace the routine we emit a\n-   call for here in libgcc2.c, or one can modify this routine to work\n-   with their thread system.\n-\n-   Ideally, we really only want one per real function, not one\n-   per inlined function.  */\n-\n-rtx\n-get_dynamic_handler_chain ()\n+static rtx\n+call_get_eh_context (before)\n+     rtx before;\n {\n   static tree fn;\n   tree expr;\n-  rtx insns;\n-\n-  if (current_function_dhc)\n-    return current_function_dhc;\n+  rtx ehc, reg, insns;\n \n   if (fn == NULL_TREE)\n     {\n       tree fntype;\n-      fn = get_identifier (\"__get_dynamic_handler_chain\");\n+      fn = get_identifier (\"__get_eh_context\");\n       push_obstacks_nochange ();\n       end_temporary_allocation ();\n       fntype = build_pointer_type (build_pointer_type\n@@ -771,15 +740,105 @@ get_dynamic_handler_chain ()\n   expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n \t\texpr, NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (expr) = 1;\n-  expr = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (expr)), expr);\n \n   start_sequence ();\n-  current_function_dhc = expand_expr (expr, NULL_RTX, VOIDmode, 0);\n+  ehc = expand_expr (expr, NULL_RTX, VOIDmode, 0);\n+  reg = copy_to_reg (ehc);\n+\n   insns = get_insns ();\n   end_sequence ();\n-  emit_insns_before (insns, get_first_nonparm_insn ());\n \n-  return current_function_dhc;\n+  if (before != 0)\n+    emit_insns_before (insns, before);\n+  else\n+    emit_insns (insns);\n+\n+  return reg;\n+}\n+\n+/* Get a reference to the EH context.\n+   We will only generate a register for the current function EH context here,\n+   and emit a USE insn to mark that this is a EH context register.\n+\n+   Later, emit_eh_context will emit needed call to __get_eh_context\n+   in libgcc2, and copy the value to the register we have generated. */\n+\n+rtx\n+use_eh_context ()\n+{\n+  if (current_function_ehc == 0)\n+    {\n+      rtx insn;\n+\n+      current_function_ehc = gen_reg_rtx (Pmode);\n+      \n+      insn = gen_rtx (USE,\n+\t\t      GET_MODE (current_function_ehc),\n+\t\t      copy_rtx (current_function_ehc));\n+      insn = emit_insn_before (insn, get_first_nonparm_insn ());\n+\n+      REG_NOTES (insn)\n+\t= gen_rtx (EXPR_LIST, \n+\t\t   REG_EH_CONTEXT, copy_rtx (current_function_ehc),\n+\t\t   REG_NOTES (insn));\n+    }\n+  return current_function_ehc;\n+}\n+     \n+/* Get reference to EH context only once per fn. */\n+\n+rtx\n+get_eh_context_once ()\n+{\n+  rtx ehc;\n+\n+  if (current_function_ehc == 0)\n+    use_eh_context ();\n+  \n+  ehc = gen_reg_rtx (Pmode);\n+  emit_move_insn (ehc, current_function_ehc);\n+\n+  return ehc;\n+}\n+\n+/* Get reference to EH context by calling __get_eh_context. */\n+\n+rtx\n+get_eh_context ()\n+{\n+  rtx ehc;\n+\n+  /* If we already have an EH context in the current function,\n+     use it. */\n+  if (current_function_ehc)\n+    ehc = get_eh_context_once ();\n+  else\n+    ehc = call_get_eh_context (0);\n+\n+  return ehc;\n+}\n+\n+/* Get a reference to the dynamic handler chain.  It points to the\n+   pointer to the next element in the dynamic handler chain.  It ends\n+   when there are no more elements in the dynamic handler chain, when\n+   the value is &top_elt from libgcc2.c.  Immediately after the\n+   pointer, is an area suitable for setjmp/longjmp when\n+   DONT_USE_BUILTIN_SETJMP is defined, and an area suitable for\n+   __builtin_setjmp/__builtin_longjmp when DONT_USE_BUILTIN_SETJMP\n+   isn't defined. */\n+\n+rtx\n+get_dynamic_handler_chain ()\n+{\n+  rtx ehc, dhc, result;\n+\n+  ehc = get_eh_context_once ();\n+  dhc = ehc;\n+\n+  result = copy_to_reg (dhc);\n+\n+  /* We don't want a copy of the dcc, but rather, the single dcc.  */\n+  return gen_rtx (MEM, Pmode, result);\n }\n \n /* Get a reference to the dynamic cleanup chain.  It points to the\n@@ -791,15 +850,31 @@ get_dynamic_handler_chain ()\n rtx\n get_dynamic_cleanup_chain ()\n {\n-  rtx dhc, dcc;\n+  rtx dhc, dcc, result;\n \n   dhc = get_dynamic_handler_chain ();\n   dcc = plus_constant (dhc, GET_MODE_SIZE (Pmode));\n \n-  current_function_dcc = copy_to_reg (dcc);\n+  result = copy_to_reg (dcc);\n \n   /* We don't want a copy of the dcc, but rather, the single dcc.  */\n-  return gen_rtx (MEM, Pmode, current_function_dcc);\n+  return gen_rtx (MEM, Pmode, result);\n+}\n+\n+/* Get a reference to the saved_pc variable. */\n+\n+rtx\n+get_saved_pc_ref ()\n+{\n+  rtx ehc, ehpc, result;\n+\n+  /* Saved PC is the second word into the returned structure. */\n+  ehc = get_eh_context ();\n+  ehpc = plus_constant (ehc, GET_MODE_SIZE (Pmode));\n+  result = copy_to_reg (ehpc);\n+\n+  /* We don't want a copy of the ehpc, but rather, the single ehpc.  */\n+  return gen_rtx (MEM, Pmode, result);\n }\n \n /* Generate code to evaluate X and jump to LABEL if the value is nonzero.\n@@ -1220,8 +1295,7 @@ expand_internal_throw ()\n       rtx label = gen_label_rtx ();\n       emit_label (label);\n       label = gen_rtx (LABEL_REF, Pmode, label);\n-      assemble_external (eh_saved_pc);\n-      emit_move_insn (eh_saved_pc_rtx, label);\n+      emit_move_insn (get_saved_pc_ref (), label);\n     }\n #endif\n   emit_throw ();\n@@ -1698,8 +1772,6 @@ end_eh_unwinder ()\n   return;\n #else /* DWARF2_UNWIND_INFO */\n \n-  assemble_external (eh_saved_pc);\n-\n   expr = make_node (RTL_EXPR);\n   TREE_TYPE (expr) = void_type_node;\n   RTL_EXPR_RTL (expr) = const0_rtx;\n@@ -1717,7 +1789,7 @@ end_eh_unwinder ()\n   return_val_rtx = eh_outer_context (return_val_rtx);\n   return_val_rtx = expand_binop (Pmode, sub_optab, return_val_rtx, GEN_INT (1),\n \t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-  emit_move_insn (eh_saved_pc_rtx, return_val_rtx);\n+  emit_move_insn (get_saved_pc_ref (), return_val_rtx);\n   \n   /* Either set things up so we do a return directly to __throw, or\n      we return here instead.  */\n@@ -1828,6 +1900,46 @@ emit_unwinder ()\n   emit_insns_after (insns, insn);\n }\n \n+/* Emit code to get EH context.\n+   \n+   We have to scan thru the code to find possible EH context registers.\n+   Inlined functions may use it too, and thus we'll have to be able\n+   to change them too.\n+\n+   This is done only if using exceptions_via_longjmp. */\n+\n+void\n+emit_eh_context ()\n+{\n+  rtx insn;\n+  rtx ehc = 0;\n+\n+  if (! doing_eh (0))\n+    return;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == INSN\n+\t&& GET_CODE (PATTERN (insn)) == USE)\n+      {\n+\trtx reg = find_reg_note (insn, REG_EH_CONTEXT, 0);\n+\tif (reg)\n+\t  {\n+\t    rtx insns;\n+\t    \n+\t    /* If this is the first use insn, emit the call here. */\n+\t    if (ehc == 0)\n+\t      ehc = call_get_eh_context (insn);\n+\n+\t    start_sequence ();\n+\t    emit_move_insn (XEXP (reg, 0), ehc);\n+\t    insns = get_insns ();\n+\t    end_sequence ();\n+\n+\t    emit_insns_before (insns, insn);\n+\t  }\n+      }\n+}\n+\n /* Scan the current insns and build a list of handler labels. The\n    resulting list is placed in the global variable exception_handler_labels.\n \n@@ -1977,14 +2089,6 @@ init_eh ()\n   /* Generate rtl to reference the variable in which the PC of the\n      current context is saved.  */\n   tree type = build_pointer_type (make_node (VOID_TYPE));\n-\n-#ifndef DWARF2_UNWIND_INFO\n-  eh_saved_pc = build_decl (VAR_DECL, get_identifier (\"__eh_pc\"), type);\n-  DECL_EXTERNAL (eh_saved_pc) = 1;\n-  TREE_PUBLIC (eh_saved_pc) = 1;\n-  make_decl_rtl (eh_saved_pc, NULL_PTR, 1);\n-  eh_saved_pc_rtx = DECL_RTL (eh_saved_pc);\n-#endif\n }\n \n /* Initialize the per-function EH information.  */\n@@ -1998,8 +2102,7 @@ init_eh_for_function ()\n   false_label_stack = 0;\n   caught_return_label_stack = 0;\n   protect_list = NULL_TREE;\n-  current_function_dhc = NULL_RTX;\n-  current_function_dcc = NULL_RTX;\n+  current_function_ehc = NULL_RTX;\n }\n \n /* Save some of the per-function EH info into the save area denoted by\n@@ -2020,8 +2123,7 @@ save_eh_status (p)\n   p->false_label_stack = false_label_stack;\n   p->caught_return_label_stack = caught_return_label_stack;\n   p->protect_list = protect_list;\n-  p->dhc = current_function_dhc;\n-  p->dcc = current_function_dcc;\n+  p->ehc = current_function_ehc;\n \n   init_eh ();\n }\n@@ -2043,8 +2145,7 @@ restore_eh_status (p)\n   catch_clauses\t= p->catch_clauses;\n   ehqueue = p->ehqueue;\n   ehstack = p->ehstack;\n-  current_function_dhc = p->dhc;\n-  current_function_dcc = p->dcc;\n+  current_function_ehc = p->ehc;\n }\n \f\n /* This section is for the exception handling specific optimization"}, {"sha": "abfeb478ea6cc1bd340d911be8d1bd6f2c728c2f", "filename": "gcc/except.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -201,6 +201,11 @@ extern void expand_internal_throw\t\tPROTO((void));\n \n extern void expand_leftover_cleanups\t\tPROTO((void));\n \n+/* If necessary, emit insns to get EH context for the current\n+   function. */\n+\n+extern void emit_eh_context\t\t\tPROTO((void));\n+\n /* If necessary, emit insns for the start of per-function unwinder for\n    the current function.  */\n \n@@ -240,21 +245,29 @@ extern struct label_node *false_label_stack;\n \n extern rtx exception_handler_labels;\n \n-/* The rtx for the saved PC value.  */\n-\n-extern rtx eh_saved_pc_rtx;\n-\n /* Performs optimizations for exception handling, such as removing\n    unnecessary exception regions. Invoked from jump_optimize ().  */\n \n extern void exception_optimize\t\t\tPROTO((void));\n \n+/* Use EH context once per fn.  */\n+extern rtx use_eh_context\t\t\tPROTO((void));\n+\n+/* Get the EH contex only once per fn.  */\n+extern rtx get_eh_context_once\t\t\tPROTO((void));\n+\n+/* Get the EH contex.  */\n+extern rtx get_eh_context\t\t\tPROTO((void));\n+\n /* Get the dynamic handler chain.  */\n extern rtx get_dynamic_handler_chain\t\tPROTO((void));\n \n /* Get the dynamic cleanup chain.  */\n extern rtx get_dynamic_cleanup_chain\t\tPROTO((void));\n \n+/* Get the saved PC variable. */\n+extern rtx get_saved_pc_ref\t\t\tPROTO((void));\n+\n /* Throw an exception.  */\n \n extern void emit_throw\t\t\t\tPROTO((void));"}, {"sha": "296e6a9456d190528425543a7e520a1bddeb4284", "filename": "gcc/frame.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fframe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fframe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.c?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -39,6 +39,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"dwarf2.h\"\n #include <stddef.h>\n #include \"frame.h\"\n+#include \"libgcc-thr.h\"\n+\n+#ifdef __GTHREAD_MUTEX_INIT\n+static __gthread_mutex_t object_mutex = __GTHREAD_MUTEX_INIT;\n+#else\n+static __gthread_mutex_t object_mutex;\n+#endif\n \n /* Don't use `fancy_abort' here even if config.h says to use it.  */\n #ifdef abort\n@@ -296,6 +303,8 @@ find_fde (void *pc)\n   struct object *ob;\n   size_t lo, hi;\n \n+  __gthread_mutex_lock (&object_mutex);\n+\n   for (ob = objects; ob; ob = ob->next)\n     {\n       if (ob->pc_begin == 0)\n@@ -304,6 +313,8 @@ find_fde (void *pc)\n \tbreak;\n     }\n \n+  __gthread_mutex_unlock (&object_mutex);\n+\n   if (ob == 0)\n     return 0;\n \n@@ -509,8 +520,12 @@ __register_frame (void *begin, struct object *ob)\n   ob->fde_array = 0;\n   ob->count = 0;\n \n+  __gthread_mutex_lock (&object_mutex);\n+\n   ob->next = objects;\n   objects = ob;\n+\n+  __gthread_mutex_unlock (&object_mutex);\n }\n \n /* Similar, but BEGIN is actually a pointer to a table of unwind entries\n@@ -526,17 +541,24 @@ __register_frame_table (void *begin, struct object *ob)\n   ob->pc_begin = ob->pc_end = 0;\n   ob->count = 0;\n \n+  __gthread_mutex_lock (&object_mutex);\n+\n   ob->next = objects;\n   objects = ob;\n+\n+  __gthread_mutex_unlock (&object_mutex);\n }\n \n /* Called from crtend.o to deregister the unwind info for an object.  */\n \n void\n __deregister_frame (void *begin)\n {\n-  struct object **p = &objects;\n+  struct object **p;\n \n+  __gthread_mutex_lock (&object_mutex);\n+\n+  p = &objects;\n   while (*p)\n     {\n       if ((*p)->fde_begin == begin)\n@@ -548,10 +570,13 @@ __deregister_frame (void *begin)\n \t  if (ob->pc_begin)\n \t    free (ob->fde_array);\n \n+\t  __gthread_mutex_unlock (&object_mutex);\n \t  return;\n \t}\n       p = &((*p)->next);\n     }\n+\n+  __gthread_mutex_unlock (&object_mutex);\n   abort ();\n }\n "}, {"sha": "a0a37467ab5911c8491aa00b31d5e07107a29d4e", "filename": "gcc/function.h", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -136,8 +136,7 @@ struct function\n   struct label_node *false_label_stack;\n   struct label_node *caught_return_label_stack;\n   tree protect_list;\n-  rtx dhc;\n-  rtx dcc;\n+  rtx ehc;\n \n   /* For expr.c.  */\n   int pending_stack_adjust;\n@@ -200,6 +199,7 @@ struct function\n   struct pool_sym **const_rtx_sym_hash_table;\n   struct pool_constant *first_pool, *last_pool;\n   int pool_offset;\n+  rtx const_double_chain;\n };\n \n /* The FUNCTION_DECL for an inline function currently being expanded.  */\n@@ -234,12 +234,24 @@ extern HOST_WIDE_INT get_frame_size PROTO((void));\n /* These variables hold pointers to functions to\n    save and restore machine-specific data,\n    in push_function_context and pop_function_context.  */\n-extern void (*save_machine_status) ();\n-extern void (*restore_machine_status) ();\n+extern void (*save_machine_status) PROTO((struct function *));\n+extern void (*restore_machine_status) PROTO((struct function *));\n \n-/* Save and restore varasm.c status for a nested function.  */\n-extern void save_varasm_status\t\tPROTO((struct function *));\n+/* Save and restore status information for a nested function.  */\n+extern void save_tree_status\t\tPROTO((struct function *, tree));\n+extern void restore_tree_status\t\tPROTO((struct function *, tree));\n+extern void save_varasm_status\t\tPROTO((struct function *, tree));\n extern void restore_varasm_status\tPROTO((struct function *));\n+extern void save_eh_status\t\tPROTO((struct function *));\n+extern void restore_eh_status\t\tPROTO((struct function *));\n+extern void save_stmt_status\t\tPROTO((struct function *));\n+extern void restore_stmt_status\t\tPROTO((struct function *));\n+extern void save_expr_status\t\tPROTO((struct function *));\n+extern void restore_expr_status\t\tPROTO((struct function *));\n+extern void save_emit_status\t\tPROTO((struct function *));\n+extern void restore_emit_status\t\tPROTO((struct function *));\n+extern void save_storage_status\t\tPROTO((struct function *));\n+extern void restore_storage_status\tPROTO((struct function *));\n \n #ifdef rtx\n #undef rtx"}, {"sha": "f69adb11485f6e9364fdd986eeb8c770fb7ab802", "filename": "gcc/integrate.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -1805,6 +1805,12 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t       inline_target.  */\n \t    break;\n \n+\t  /* If the inline fn needs eh context, make sure that\n+\t     the current fn has one. */\n+\t  if (GET_CODE (pattern) == USE\n+\t      && find_reg_note (insn, REG_EH_CONTEXT, 0) != 0)\n+\t    use_eh_context ();\n+\n \t  /* Ignore setting a function value that we don't want to use.  */\n \t  if (map->inline_target == 0\n \t      && set != 0"}, {"sha": "1ad63013a15010185cfcc0ceb8ce10bd6920b2d7", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 176, "deletions": 30, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -2962,11 +2962,9 @@ int _exit_dummy_decl = 0;\t/* prevent compiler & linker warnings */\n \f\n #ifdef L_eh\n \n-/* Shared exception handling support routines.  */\n+#include \"libgcc-thr.h\"\n \n-/* Language-specific information about the active exception(s).  If there\n-   are no active exceptions, it is set to 0.  */\n-void *__eh_info;\n+/* Shared exception handling support routines.  */\n \n void\n __default_terminate ()\n@@ -2999,41 +2997,190 @@ __empty ()\n {\n }\n \f\n+/* EH context structure. */\n+\n+struct eh_context\n+{\n+  void **dynamic_handler_chain;\n+  void *saved_pc;\n+#ifndef DWARF2_UNWIND_INFO\n+  void *buf[2];\n+#endif\n+  /* This is language dependent part of the eh context. */\n+  void *info;\n+};\n+\n+/* This is a safeguard for dynamic handler chain. */\n+\n+static void *top_elt[2];\n+\n+/* Allocate and return a new EH context structure. */\n+\n+extern void __throw ();\n+\n+static void *\n+new_eh_context ()\n+{\n+  struct eh_context *eh = (struct eh_context *) malloc (sizeof *eh);\n+  if (! eh)\n+    __terminate ();\n+\n+  memset (eh, 0, sizeof *eh);\n+\n+  eh->dynamic_handler_chain = top_elt;\n+#ifndef DWARF2_UNWIND_INFO\n+  eh->buf[0] = &eh->saved_pc;\n+  eh->buf[1] = &__throw;\n+#endif  \n+\n+  return eh;\n+}\n+\n+#if __GTHREADS\n+static __gthread_key_t eh_context_key;\n+\n+/* Destructor for struct eh_context. */\n+static void\n+eh_context_free (void *ptr)\n+{\n+  if (ptr)\n+    free (ptr);\n+}\n+#endif\n+\n+/* Pointer to function to return EH context. */\n+\n+static struct eh_context *eh_context_initialize ();\n+static struct eh_context *eh_context_static ();\n+#if __GTHREADS\n+static struct eh_context *eh_context_specific ();\n+#endif\n+\n+static struct eh_context *(*get_eh_context) () = &eh_context_initialize;\n+\n+/* Routine to get EH context.\n+   This one will simply call the function pointer. */\n+\n+void *\n+__get_eh_context ()\n+{\n+  return (void *) (*get_eh_context) ();\n+}\n+\n+/* Get and set the language specific info pointer. */\n+\n+void **\n+__get_eh_info ()\n+{\n+  struct eh_context *eh = (*get_eh_context) ();\n+  return (void **) &eh->info;\n+}\n+\f\n+#if __GTHREADS\n+static void\n+eh_threads_initialize ()\n+{\n+  /* Try to create the key.  If it fails, revert to static method,\n+     otherwise start using thread specific EH contexts. */\n+  if (__gthread_key_create (&eh_context_key, &eh_context_free) == 0)\n+    get_eh_context = &eh_context_specific;\n+  else\n+    get_eh_context = &eh_context_static;\n+}\n+#endif /* no __GTHREADS */\n+\n+/* Initialize EH context.\n+   This will be called only once, since we change GET_EH_CONTEXT\n+   pointer to another routine. */\n+\n+static struct eh_context *\n+eh_context_initialize ()\n+{\n+#if __GTHREADS\n+\n+  static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+  __gthread_once (&once, eh_threads_initialize);\n+\n+#else /* no __GTHREADS */\n+\n+  /* Use static version of EH context. */\n+  get_eh_context = &eh_context_static;\n+\n+#endif /* no __GTHREADS */\n+\n+  return (*get_eh_context) ();\n+}\n+\n+/* Return a static EH context. */\n+\n+static struct eh_context *\n+eh_context_static ()\n+{\n+  static struct eh_context *eh;\n+  if (! eh)\n+    eh = new_eh_context ();\n+  return eh;\n+}\n+\n+#if __GTHREADS\n+/* Return a thread specific EH context. */\n+\n+static struct eh_context *\n+eh_context_specific ()\n+{\n+  struct eh_context *eh;\n+  eh = (struct eh_context *) __gthread_getspecific (eh_context_key);\n+  if (! eh)\n+    {\n+      eh = new_eh_context ();\n+      if (__gthread_setspecific (eh_context_key, (void *) eh) != 0)\n+\t__terminate ();\n+    }\n+\n+  return eh;\n+}\n+#endif __GTHREADS\n+\f\n /* Support routines for setjmp/longjmp exception handling.  */\n \n /* Calls to __sjthrow are generated by the compiler when an exception\n    is raised when using the setjmp/longjmp exception handling codegen\n    method.  */\n \n+#ifdef DONT_USE_BUILTIN_SETJMP\n extern void longjmp (void *, int);\n-\n-static void *top_elt[2];\n-void **__dynamic_handler_chain = top_elt;\n+#endif\n \n /* Routine to get the head of the current thread's dynamic handler chain\n-   use for exception handling.\n-\n-   TODO: make thread safe.  */\n+   use for exception handling. */\n \n void ***\n __get_dynamic_handler_chain ()\n {\n-  return &__dynamic_handler_chain;\n+  struct eh_context *eh = (*get_eh_context) ();\n+  return (void ***) &eh->dynamic_handler_chain;\n+}\n+\n+void **\n+__get_saved_pc ()\n+{\n+  struct eh_context *eh = (*get_eh_context) ();\n+  return (void **) &eh->saved_pc;\n }\n \n /* This is used to throw an exception when the setjmp/longjmp codegen\n    method is used for exception handling.\n \n-   We call __terminate if there are no handlers left (we know this\n-   when the dynamic handler chain is top_elt).  Otherwise we run the\n-   cleanup actions off the dynamic cleanup stack, and pop the top of\n-   the dynamic handler chain, and use longjmp to transfer back to the\n-   associated handler.  */\n+   We call __terminate if there are no handlers left.  Otherwise we run the\n+   cleanup actions off the dynamic cleanup stack, and pop the top of the\n+   dynamic handler chain, and use longjmp to transfer back to the associated\n+   handler.  */\n \n void\n __sjthrow ()\n {\n-  void ***dhc = __get_dynamic_handler_chain ();\n+  struct eh_context *eh = (*get_eh_context) ();\n+  void ***dhc = &eh->dynamic_handler_chain;\n   void *jmpbuf;\n   void (*func)(void *, int);\n   void *arg;\n@@ -3081,7 +3228,7 @@ __sjthrow ()\n   /* We must call terminate if we try and rethrow an exception, when\n      there is no exception currently active and when there are no\n      handlers left.  */\n-  if (! __eh_info || (*dhc) == top_elt)\n+  if (! eh->info || (*dhc) == top_elt)\n     __terminate ();\n     \n   /* Find the jmpbuf associated with the top element of the dynamic\n@@ -3108,7 +3255,8 @@ __sjthrow ()\n void\n __sjpopnthrow ()\n {\n-  void ***dhc = __get_dynamic_handler_chain ();\n+  struct eh_context *eh = (*get_eh_context) ();\n+  void ***dhc = &eh->dynamic_handler_chain;\n   void *jmpbuf;\n   void (*func)(void *, int);\n   void *arg;\n@@ -3288,11 +3436,8 @@ __throw ()\n /* See expand_builtin_throw for details.  */\n \n void **__eh_pcnthrow () {\n-  static void *buf[2] = {\n-    &__eh_pc,\n-    &__throw\n-  };\n-  return buf;\n+  struct eh_context *eh = (*get_eh_context) ();\n+  return &eh->buf[0];\n }\n \n #if #machine(i386)\n@@ -3499,7 +3644,8 @@ in_reg_window (int reg, frame_state *udata)\n void\n __throw ()\n {\n-  void *pc, *handler, *retaddr, *__eh_pc;\n+  struct eh_context *eh = (*get_eh_context) ();\n+  void *saved_pc, *pc, *handler, *retaddr;\n   frame_state ustruct, ustruct2;\n   frame_state *udata = &ustruct;\n   frame_state *sub_udata = &ustruct2;\n@@ -3509,7 +3655,7 @@ __throw ()\n   /* This is required for C++ semantics.  We must call terminate if we\n      try and rethrow an exception, when there is no exception currently\n      active.  */\n-  if (! __eh_info)\n+  if (! eh->info)\n     __terminate ();\n     \n   /* Start at our stack frame.  */\n@@ -3534,8 +3680,8 @@ __throw ()\n   __builtin_unwind_init ();\n \n   /* Now reset pc to the right throw point.  */\n-  __eh_pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n-  pc = __eh_pc;\n+  pc = __builtin_extract_return_addr (__builtin_return_address (0)) - 1;\n+  saved_pc = pc;\n \n   handler = 0;\n   for (;;)\n@@ -3567,7 +3713,7 @@ __throw ()\n   if (! handler)\n     __terminate ();\n \n-  if (pc == __eh_pc)\n+  if (pc == saved_pc)\n     /* We found a handler in the throw context, no need to unwind.  */\n     udata = my_udata;\n   else\n@@ -3582,7 +3728,7 @@ __throw ()\n       void *handler_pc = pc;\n \n       /* Start from the throw context again.  */\n-      pc = __eh_pc;\n+      pc = saved_pc;\n       memcpy (udata, my_udata, sizeof (*udata));\n \n       while (pc != handler_pc)"}, {"sha": "69e517143db840087832aa3f0f6641a2b817a4c6", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -182,7 +182,7 @@ char *reg_note_name[] = { \"\", \"REG_DEAD\", \"REG_INC\", \"REG_EQUIV\", \"REG_WAS_0\",\n \t\t\t  \"REG_CC_SETTER\", \"REG_CC_USER\", \"REG_LABEL\",\n \t\t\t  \"REG_DEP_ANTI\", \"REG_DEP_OUTPUT\", \"REG_BR_PROB\",\n \t\t\t  \"REG_EXEC_COUNT\", \"REG_NOALIAS\", \"REG_SAVE_AREA\",\n-\t\t\t  \"REG_BR_PRED\" };\n+\t\t\t  \"REG_BR_PRED\", \"REG_EH_CONTEXT\" };\n \n static void dump_and_abort\tPROTO((int, int, FILE *));\n static void read_name\t\tPROTO((char *, FILE *));"}, {"sha": "62b1342768747f36c3d4141d3d01468e78e31096", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -325,7 +325,7 @@ enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n \t\tREG_CC_SETTER = 11, REG_CC_USER = 12, REG_LABEL = 13,\n \t\tREG_DEP_ANTI = 14, REG_DEP_OUTPUT = 15, REG_BR_PROB = 16,\n \t\tREG_EXEC_COUNT = 17, REG_NOALIAS = 18, REG_SAVE_AREA = 19,\n-\t\tREG_BR_PRED = 20 };\n+\t\tREG_BR_PRED = 20, REG_EH_CONTEXT = 21 };\n /* The base value for branch probability notes.  */\n #define REG_BR_PROB_BASE  10000\n "}, {"sha": "9cbd513fca2faf874f4b4f9d07a9be2ccee6cc28", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/154bba13a4a3d494a12622c489ba9d7bd1f76a8b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=154bba13a4a3d494a12622c489ba9d7bd1f76a8b", "patch": "@@ -3201,6 +3201,9 @@ rest_of_compilation (decl)\n       goto exit_rest_of_compilation;\n     }\n \n+  /* Emit code to get eh context, if needed. */\n+  emit_eh_context ();\n+\n   /* Add an unwinder for exception handling, if needed.\n      This must be done before we finalize PIC code.  */\n   emit_unwinder ();"}]}