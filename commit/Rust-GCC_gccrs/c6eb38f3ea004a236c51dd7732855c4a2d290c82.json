{"sha": "c6eb38f3ea004a236c51dd7732855c4a2d290c82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZlYjM4ZjNlYTAwNGEyMzZjNTFkZDc3MzI4NTVjNGEyZDI5MGM4Mg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-01-31T13:38:35Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-01-31T13:38:35Z"}, "message": "re PR target/78597 (test case gcc.dg/torture/fp-int-convert-float128-ieee.c (and others) fail starting with r242780)\n\n2017-01-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/78597\n\tPR target/79038\n\t* config/rs6000/rs6000-protos.h (convert_float128_to_int): Delete,\n\tno longer used.\n\t(convert_int_to_float128): Likewise.\n\t* config/rs6000/rs6000.c (convert_float128_to_int): Likewise.\n\t(convert_int_to_float128): Likewise.\n\t* config/rs6000/rs6000.md (UNSPEC_IEEE128_MOVE): Likewise.\n\t(UNSPEC_IEEE128_CONVERT): Likewise.\n\t(floatsi<mode>2, FLOAT128 iterator): Bypass calling\n\trs6000_expand_float128_convert if we have IEEE 128-bit hardware.\n\tUse local variables for IBM extended format.\n\t(fix_trunc<mode>si2, FLOAT128 iterator): Likewise.\n\t(fix_trunc<mode>si2_fprs): Likewise.\n\t(fixuns_trunc<IEEE128:mode><SDI:mode>2): Likewise.\n\t(floatuns<IEEE128:mode>2, IEEE128 iterator): Likewise.\n\t(fix<uns>_<mode>si2_hw): Rework the IEEE 128-bt hardware support\n\tto know that we can now have integers of all sizes in vector\n\tregisters.\n\t(fix<uns>_<mode>di2_hw): Likewise.\n\t(float<uns>_<mode>si2_hw): Likewise.\n\t(fix_<mode>si2_hw): Likewise.\n\t(fixuns_<mode>si2_hw): Likewise.\n\t(float<uns>_<mode>di2_hw): Likewise.\n\t(float_<mode>di2_hw): Likewise.\n\t(float_<mode>si2_hw): Likewise.\n\t(floatuns_<mode>di2_hw): Likewise.\n\t(floatuns_<mode>si2_hw): Likewise.\n\t(xscvqp<su>wz_<mode>): Delete, no longer used.\n\t(xscvqp<su>dz_<mode>): Likewise.\n\t(xscv<su>dqp_<mode>): Likewise.\n\t(ieee128_mfvsrd_64bit): Likewise.\n\t(ieee128_mfvsrd_32bit): Likewise.\n\t(ieee128_mfvsrwz): Likewise.\n\t(ieee128_mtvsrw): Likewise.\n\t(ieee128_mtvsrd_64bit): Likewise.\n\t(ieee128_mtvsrd_32bit): Likewise.\n\nFrom-SVN: r245059", "tree": {"sha": "c5387ccd68d8b1fc94a087acec5480d9c122b30b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5387ccd68d8b1fc94a087acec5480d9c122b30b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6eb38f3ea004a236c51dd7732855c4a2d290c82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6eb38f3ea004a236c51dd7732855c4a2d290c82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6eb38f3ea004a236c51dd7732855c4a2d290c82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6eb38f3ea004a236c51dd7732855c4a2d290c82/comments", "author": null, "committer": null, "parents": [{"sha": "a0a348b1670721eb5dff2b88a3cc0f12509fd69b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a348b1670721eb5dff2b88a3cc0f12509fd69b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a348b1670721eb5dff2b88a3cc0f12509fd69b"}], "stats": {"total": 441, "additions": 182, "deletions": 259}, "files": [{"sha": "772a2f4bad3eaf43748688b6436cbd4e080f6135", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6eb38f3ea004a236c51dd7732855c4a2d290c82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6eb38f3ea004a236c51dd7732855c4a2d290c82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6eb38f3ea004a236c51dd7732855c4a2d290c82", "patch": "@@ -1,3 +1,43 @@\n+2017-01-31  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/78597\n+\tPR target/79038\n+\t* config/rs6000/rs6000-protos.h (convert_float128_to_int): Delete,\n+\tno longer used.\n+\t(convert_int_to_float128): Likewise.\n+\t* config/rs6000/rs6000.c (convert_float128_to_int): Likewise.\n+\t(convert_int_to_float128): Likewise.\n+\t* config/rs6000/rs6000.md (UNSPEC_IEEE128_MOVE): Likewise.\n+\t(UNSPEC_IEEE128_CONVERT): Likewise.\n+\t(floatsi<mode>2, FLOAT128 iterator): Bypass calling\n+\trs6000_expand_float128_convert if we have IEEE 128-bit hardware.\n+\tUse local variables for IBM extended format.\n+\t(fix_trunc<mode>si2, FLOAT128 iterator): Likewise.\n+\t(fix_trunc<mode>si2_fprs): Likewise.\n+\t(fixuns_trunc<IEEE128:mode><SDI:mode>2): Likewise.\n+\t(floatuns<IEEE128:mode>2, IEEE128 iterator): Likewise.\n+\t(fix<uns>_<mode>si2_hw): Rework the IEEE 128-bt hardware support\n+\tto know that we can now have integers of all sizes in vector\n+\tregisters.\n+\t(fix<uns>_<mode>di2_hw): Likewise.\n+\t(float<uns>_<mode>si2_hw): Likewise.\n+\t(fix_<mode>si2_hw): Likewise.\n+\t(fixuns_<mode>si2_hw): Likewise.\n+\t(float<uns>_<mode>di2_hw): Likewise.\n+\t(float_<mode>di2_hw): Likewise.\n+\t(float_<mode>si2_hw): Likewise.\n+\t(floatuns_<mode>di2_hw): Likewise.\n+\t(floatuns_<mode>si2_hw): Likewise.\n+\t(xscvqp<su>wz_<mode>): Delete, no longer used.\n+\t(xscvqp<su>dz_<mode>): Likewise.\n+\t(xscv<su>dqp_<mode>): Likewise.\n+\t(ieee128_mfvsrd_64bit): Likewise.\n+\t(ieee128_mfvsrd_32bit): Likewise.\n+\t(ieee128_mfvsrwz): Likewise.\n+\t(ieee128_mtvsrw): Likewise.\n+\t(ieee128_mtvsrd_64bit): Likewise.\n+\t(ieee128_mtvsrd_32bit): Likewise.\n+\n 2017-01-31  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/79285"}, {"sha": "74ad733d1b905f822c07e73146b39925b5c6444d", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6eb38f3ea004a236c51dd7732855c4a2d290c82/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6eb38f3ea004a236c51dd7732855c4a2d290c82/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=c6eb38f3ea004a236c51dd7732855c4a2d290c82", "patch": "@@ -57,8 +57,6 @@ extern const char *rs6000_output_move_128bit (rtx *);\n extern bool rs6000_move_128bit_ok_p (rtx []);\n extern bool rs6000_split_128bit_ok_p (rtx []);\n extern void rs6000_expand_float128_convert (rtx, rtx, bool);\n-extern void convert_float128_to_int (rtx *, enum rtx_code);\n-extern void convert_int_to_float128 (rtx *, enum rtx_code);\n extern void rs6000_expand_vector_init (rtx, rtx);\n extern void paired_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);"}, {"sha": "e44664124466418d730e16d69047cc11dc65cd7f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6eb38f3ea004a236c51dd7732855c4a2d290c82/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6eb38f3ea004a236c51dd7732855c4a2d290c82/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c6eb38f3ea004a236c51dd7732855c4a2d290c82", "patch": "@@ -24686,92 +24686,6 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n   return;\n }\n \n-/* Split a conversion from __float128 to an integer type into separate insns.\n-   OPERANDS points to the destination, source, and V2DI temporary\n-   register. CODE is either FIX or UNSIGNED_FIX.  */\n-\n-void\n-convert_float128_to_int (rtx *operands, enum rtx_code code)\n-{\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-  rtx tmp = operands[2];\n-  rtx cvt;\n-  rtvec cvt_vec;\n-  rtx cvt_unspec;\n-  rtvec move_vec;\n-  rtx move_unspec;\n-\n-  if (GET_CODE (tmp) == SCRATCH)\n-    tmp = gen_reg_rtx (V2DImode);\n-\n-  if (MEM_P (dest))\n-    dest = rs6000_address_for_fpconvert (dest);\n-\n-  /* Generate the actual convert insn of the form:\n-     (set (tmp) (unspec:V2DI [(fix:SI (reg:KF))] UNSPEC_IEEE128_CONVERT)).  */\n-  cvt = gen_rtx_fmt_e (code, GET_MODE (dest), src);\n-  cvt_vec = gen_rtvec (1, cvt);\n-  cvt_unspec = gen_rtx_UNSPEC (V2DImode, cvt_vec, UNSPEC_IEEE128_CONVERT);\n-  emit_insn (gen_rtx_SET (tmp, cvt_unspec));\n-\n-  /* Generate the move insn of the form:\n-     (set (dest:SI) (unspec:SI [(tmp:V2DI))] UNSPEC_IEEE128_MOVE)).  */\n-  move_vec = gen_rtvec (1, tmp);\n-  move_unspec = gen_rtx_UNSPEC (GET_MODE (dest), move_vec, UNSPEC_IEEE128_MOVE);\n-  emit_insn (gen_rtx_SET (dest, move_unspec));\n-}\n-\n-/* Split a conversion from an integer type to __float128 into separate insns.\n-   OPERANDS points to the destination, source, and V2DI temporary\n-   register. CODE is either FLOAT or UNSIGNED_FLOAT.  */\n-\n-void\n-convert_int_to_float128 (rtx *operands, enum rtx_code code)\n-{\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-  rtx tmp = operands[2];\n-  rtx cvt;\n-  rtvec cvt_vec;\n-  rtx cvt_unspec;\n-  rtvec move_vec;\n-  rtx move_unspec;\n-  rtx unsigned_flag;\n-\n-  if (GET_CODE (tmp) == SCRATCH)\n-    tmp = gen_reg_rtx (V2DImode);\n-\n-  if (MEM_P (src))\n-    src = rs6000_address_for_fpconvert (src);\n-\n-  /* Generate the move of the integer into the Altivec register of the form:\n-     (set (tmp:V2DI) (unspec:V2DI [(src:SI)\n-\t\t\t\t   (const_int 0)] UNSPEC_IEEE128_MOVE)).\n-\n-     or:\n-     (set (tmp:V2DI) (unspec:V2DI [(src:DI)] UNSPEC_IEEE128_MOVE)).  */\n-\n-  if (GET_MODE (src) == SImode)\n-    {\n-      unsigned_flag = (code == UNSIGNED_FLOAT) ? const1_rtx : const0_rtx;\n-      move_vec = gen_rtvec (2, src, unsigned_flag);\n-    }\n-  else\n-    move_vec = gen_rtvec (1, src);\n-\n-  move_unspec = gen_rtx_UNSPEC (V2DImode, move_vec, UNSPEC_IEEE128_MOVE);\n-  emit_insn (gen_rtx_SET (tmp, move_unspec));\n-\n-  /* Generate the actual convert insn of the form:\n-     (set (dest:KF) (float:KF (unspec:DI [(tmp:V2DI)]\n-\t\t\t\t\t UNSPEC_IEEE128_CONVERT))).  */\n-  cvt_vec = gen_rtvec (1, tmp);\n-  cvt_unspec = gen_rtx_UNSPEC (DImode, cvt_vec, UNSPEC_IEEE128_CONVERT);\n-  cvt = gen_rtx_fmt_e (code, GET_MODE (dest), cvt_unspec);\n-  emit_insn (gen_rtx_SET (dest, cvt));\n-}\n-\n \f\n /* Emit the RTL for an sISEL pattern.  */\n "}, {"sha": "7a908acb88ee6c8c48f94704dd33b53924a42d34", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 142, "deletions": 171, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6eb38f3ea004a236c51dd7732855c4a2d290c82/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6eb38f3ea004a236c51dd7732855c4a2d290c82/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c6eb38f3ea004a236c51dd7732855c4a2d290c82", "patch": "@@ -146,8 +146,6 @@\n    UNSPEC_FUSION_P9\n    UNSPEC_FUSION_ADDIS\n    UNSPEC_ROUND_TO_ODD\n-   UNSPEC_IEEE128_MOVE\n-   UNSPEC_IEEE128_CONVERT\n    UNSPEC_SIGNBIT\n    UNSPEC_SF_FROM_SI\n    UNSPEC_SI_FROM_SF\n@@ -7690,26 +7688,35 @@\n   \"\")\n \n (define_expand \"floatsi<mode>2\"\n-  [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\" \"\")\n-        (float:FLOAT128 (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n+  [(parallel [(set (match_operand:FLOAT128 0 \"gpc_reg_operand\")\n+\t\t   (float:FLOAT128 (match_operand:SI 1 \"gpc_reg_operand\")))\n+\t      (clobber (match_scratch:DI 2))])]\n   \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE)\n    && TARGET_LONG_DOUBLE_128\"\n {\n-  if (FLOAT128_IEEE_P (<MODE>mode))\n-    rs6000_expand_float128_convert (operands[0], operands[1], false);\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  if (TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode))\n+    ;\n+  else if (FLOAT128_IEEE_P (<MODE>mode))\n+    {\n+      rs6000_expand_float128_convert (op0, op1, false);\n+      DONE;\n+    }\n   else\n     {\n       rtx tmp = gen_reg_rtx (DFmode);\n-      expand_float (tmp, operands[1], false);\n+      expand_float (tmp, op1, false);\n       if (<MODE>mode == TFmode)\n-\temit_insn (gen_extenddftf2 (operands[0], tmp));\n+\temit_insn (gen_extenddftf2 (op0, tmp));\n       else if (<MODE>mode == IFmode)\n-\temit_insn (gen_extenddfif2 (operands[0], tmp));\n+\temit_insn (gen_extenddfif2 (op0, tmp));\n       else\n \tgcc_unreachable ();\n+      DONE;\n     }\n-  DONE;\n })\n \n ; fadd, but rounding towards zero.\n@@ -7731,17 +7738,25 @@\n   \"TARGET_HARD_FLOAT\n    && (TARGET_FPRS || TARGET_E500_DOUBLE) && TARGET_LONG_DOUBLE_128\"\n {\n-  if (FLOAT128_IEEE_P (<MODE>mode))\n-    rs6000_expand_float128_convert (operands[0], operands[1], false);\n-  else if (TARGET_E500_DOUBLE && <MODE>mode == TFmode)\n-    emit_insn (gen_spe_fix_trunctfsi2 (operands[0], operands[1]));\n-  else if (<MODE>mode == TFmode)\n-    emit_insn (gen_fix_trunctfsi2_fprs (operands[0], operands[1]));\n-  else if (<MODE>mode == IFmode)\n-    emit_insn (gen_fix_truncifsi2_fprs (operands[0], operands[1]));\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  if (TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode))\n+    ;\n   else\n-    gcc_unreachable ();\n-  DONE;\n+    {\n+      if (FLOAT128_IEEE_P (<MODE>mode))\n+\trs6000_expand_float128_convert (op0, op1, false);\n+      else if (TARGET_E500_DOUBLE && <MODE>mode == TFmode)\n+\temit_insn (gen_spe_fix_trunctfsi2 (op0, op1));\n+      else if (<MODE>mode == TFmode)\n+\temit_insn (gen_fix_trunctfsi2_fprs (op0, op1));\n+      else if (<MODE>mode == IFmode)\n+\temit_insn (gen_fix_truncifsi2_fprs (op0, op1));\n+      else\n+\tgcc_unreachable ();\n+      DONE;\n+    }\n })\n \n (define_expand \"fix_trunc<mode>si2_fprs\"\n@@ -7789,8 +7804,11 @@\n \t(fix:DI (match_operand:IEEE128 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128_TYPE\"\n {\n-  rs6000_expand_float128_convert (operands[0], operands[1], false);\n-  DONE;\n+  if (!TARGET_FLOAT128_HW)\n+    {\n+      rs6000_expand_float128_convert (operands[0], operands[1], false);\n+      DONE;\n+    }\n })\n \n (define_expand \"fixuns_trunc<IEEE128:mode><SDI:mode>2\"\n@@ -7807,16 +7825,37 @@\n \t(float:IEEE128 (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128_TYPE\"\n {\n-  rs6000_expand_float128_convert (operands[0], operands[1], false);\n-  DONE;\n+  if (!TARGET_FLOAT128_HW)\n+    {\n+      rs6000_expand_float128_convert (operands[0], operands[1], false);\n+      DONE;\n+    }\n })\n \n-(define_expand \"floatuns<SDI:mode><IEEE128:mode>2\"\n+(define_expand \"floatunsdi<IEEE128:mode>2\"\n   [(set (match_operand:IEEE128 0 \"gpc_reg_operand\" \"\")\n-\t(unsigned_float:IEEE128 (match_operand:SDI 1 \"gpc_reg_operand\" \"\")))]\n+\t(unsigned_float:IEEE128 (match_operand:DI 1 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_FLOAT128_TYPE\"\n {\n-  rs6000_expand_float128_convert (operands[0], operands[1], true);\n+  if (!TARGET_FLOAT128_HW)\n+    {\n+      rs6000_expand_float128_convert (operands[0], operands[1], true);\n+      DONE;\n+    }\n+})\n+\n+(define_expand \"floatuns<IEEE128:mode>2\"\n+  [(set (match_operand:IEEE128 0 \"gpc_reg_operand\" \"\")\n+\t(unsigned_float:IEEE128 (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_FLOAT128_TYPE\"\n+{\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+\n+  if (TARGET_FLOAT128_HW)\n+    emit_insn (gen_floatuns_<IEEE128:mode>si2_hw (op0, op1));\n+  else\n+    rs6000_expand_float128_convert (op0, op1, true);\n   DONE;\n })\n \n@@ -14350,170 +14389,102 @@\n   [(set_attr \"type\" \"vecfloat\")\n    (set_attr \"length\" \"8\")])\n \n-;; At present SImode is not allowed in VSX registers at all, and DImode is only\n-;; allowed in the traditional floating point registers. Use V2DImode so that\n-;; we can get a value in an Altivec register.\n+;; Conversion between IEEE 128-bit and integer types\n+(define_insn \"fix_<mode>di2_hw\"\n+  [(set (match_operand:DI 0 \"altivec_register_operand\" \"=v\")\n+\t(fix:DI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xscvqpsdz %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")\n+   (set_attr \"size\" \"128\")])\n \n-(define_insn_and_split \"fix<uns>_<mode>si2_hw\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,Z\")\n-\t(any_fix:SI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v,v\")))\n-   (clobber (match_scratch:V2DI 2 \"=v,v\"))]\n+(define_insn \"fixuns_<mode>di2_hw\"\n+  [(set (match_operand:DI 0 \"altivec_register_operand\" \"=v\")\n+\t(unsigned_fix:DI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n   \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"#\"\n-  \"&& 1\"\n-  [(pc)]\n-{\n-  convert_float128_to_int (operands, <CODE>);\n-  DONE;\n-}\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"mftgpr,fpstore\")])\n+  \"xscvqpudz %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")\n+   (set_attr \"size\" \"128\")])\n \n-(define_insn_and_split \"fix<uns>_<mode>di2_hw\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=wr,wi,Z\")\n-\t(any_fix:DI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v,v,v\")))\n-   (clobber (match_scratch:V2DI 2 \"=v,v,v\"))]\n+(define_insn \"fix_<mode>si2_hw\"\n+  [(set (match_operand:SI 0 \"altivec_register_operand\" \"=v\")\n+\t(fix:SI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n   \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"#\"\n-  \"&& 1\"\n-  [(pc)]\n-{\n-  convert_float128_to_int (operands, <CODE>);\n-  DONE;\n-}\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"mftgpr,vecsimple,fpstore\")])\n+  \"xscvqpswz %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")\n+   (set_attr \"size\" \"128\")])\n \n-(define_insn_and_split \"float<uns>_<mode>si2_hw\"\n-  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v,v\")\n-\t(any_float:IEEE128 (match_operand:SI 1 \"nonimmediate_operand\" \"r,Z\")))\n-   (clobber (match_scratch:V2DI 2 \"=v,v\"))]\n+(define_insn \"fixuns_<mode>si2_hw\"\n+  [(set (match_operand:SI 0 \"altivec_register_operand\" \"=v\")\n+\t(unsigned_fix:SI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n   \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"#\"\n-  \"&& 1\"\n-  [(pc)]\n-{\n-  convert_int_to_float128 (operands, <CODE>);\n-  DONE;\n-}\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"vecfloat\")])\n+  \"xscvqpuwz %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")\n+   (set_attr \"size\" \"128\")])\n \n-(define_insn_and_split \"float<uns>_<mode>di2_hw\"\n-  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v,v,v\")\n-\t(any_float:IEEE128 (match_operand:DI 1 \"nonimmediate_operand\" \"wi,wr,Z\")))\n-   (clobber (match_scratch:V2DI 2 \"=v,v,v\"))]\n+;; Combiner pattern to prevent moving the result of converting an IEEE 128-bit\n+;; floating point value to 32-bit integer to GPR in order to save it.\n+(define_insn_and_split \"*fix<uns>_<mode>_mem\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n+\t(any_fix:SI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))\n+   (clobber (match_scratch:SI 2 \"=v\"))]\n   \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n   \"#\"\n-  \"&& 1\"\n-  [(pc)]\n-{\n-  convert_int_to_float128 (operands, <CODE>);\n-  DONE;\n-}\n-  [(set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"vecfloat\")])\n-\n-;; Integer conversion instructions, using V2DImode to get an Altivec register\n-(define_insn \"*xscvqp<su>wz_<mode>\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n-\t(unspec:V2DI\n-\t [(any_fix:SI\n-\t   (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\"))]\n-\t UNSPEC_IEEE128_CONVERT))]\n+  \"&& reload_completed\"\n+  [(set (match_dup 2)\n+\t(any_fix:SI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(match_dup 2))])\n+\n+(define_insn \"float_<mode>di2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(float:IEEE128 (match_operand:DI 1 \"altivec_register_operand\" \"v\")))]\n   \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"xscvqp<su>wz %0,%1\"\n+  \"xscvsdqp %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")\n    (set_attr \"size\" \"128\")])\n \n-(define_insn \"*xscvqp<su>dz_<mode>\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n-\t(unspec:V2DI\n-\t [(any_fix:DI\n-\t   (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\"))]\n-\t UNSPEC_IEEE128_CONVERT))]\n+(define_insn_and_split \"float_<mode>si2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(float:IEEE128 (match_operand:SI 1 \"nonimmediate_operand\" \"vrZ\")))\n+   (clobber (match_scratch:DI 2 \"=v\"))]\n   \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"xscvqp<su>dz %0,%1\"\n-  [(set_attr \"type\" \"vecfloat\")\n-   (set_attr \"size\" \"128\")])\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 2)\n+\t(sign_extend:DI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(float:IEEE128 (match_dup 2)))]\n+{\n+  if (GET_CODE (operands[2]) == SCRATCH)\n+    operands[2] = gen_reg_rtx (DImode);\n+})\n \n-(define_insn \"*xscv<su>dqp_<mode>\"\n+(define_insn \"floatuns_<mode>di2_hw\"\n   [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n-\t(any_float:IEEE128\n-\t (unspec:DI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v\")]\n-\t\t    UNSPEC_IEEE128_CONVERT)))]\n+\t(unsigned_float:IEEE128\n+\t (match_operand:DI 1 \"altivec_register_operand\" \"v\")))]\n   \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"xscv<su>dqp %0,%1\"\n+  \"xscvudqp %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")\n    (set_attr \"size\" \"128\")])\n \n-(define_insn \"*ieee128_mfvsrd_64bit\"\n-  [(set (match_operand:DI 0 \"reg_or_indexed_operand\" \"=wr,Z,wi\")\n-\t(unspec:DI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v,v,v\")]\n-\t\t   UNSPEC_IEEE128_MOVE))]\n-  \"TARGET_FLOAT128_HW && TARGET_POWERPC64\"\n-  \"@\n-   mfvsrd %0,%x1\n-   stxsdx %x1,%y0\n-   xxlor %x0,%x1,%x1\"\n-  [(set_attr \"type\" \"mftgpr,fpstore,veclogical\")])\n-\n-\n-(define_insn \"*ieee128_mfvsrd_32bit\"\n-  [(set (match_operand:DI 0 \"reg_or_indexed_operand\" \"=Z,wi\")\n-\t(unspec:DI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v,v\")]\n-\t\t   UNSPEC_IEEE128_MOVE))]\n-  \"TARGET_FLOAT128_HW && !TARGET_POWERPC64\"\n-  \"@\n-   stxsdx %x1,%y0\n-   xxlor %x0,%x1,%x1\"\n-  [(set_attr \"type\" \"fpstore,veclogical\")])\n-\n-(define_insn \"*ieee128_mfvsrwz\"\n-  [(set (match_operand:SI 0 \"reg_or_indexed_operand\" \"=r,Z\")\n-\t(unspec:SI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v,v\")]\n-\t\t   UNSPEC_IEEE128_MOVE))]\n-  \"TARGET_FLOAT128_HW\"\n-  \"@\n-   mfvsrwz %0,%x1\n-   stxsiwx %x1,%y0\"\n-  [(set_attr \"type\" \"mftgpr,fpstore\")])\n-\n-;; 0 says do sign-extension, 1 says zero-extension\n-(define_insn \"*ieee128_mtvsrw\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v,v,v,v\")\n-\t(unspec:V2DI [(match_operand:SI 1 \"nonimmediate_operand\" \"r,Z,r,Z\")\n-\t\t      (match_operand:SI 2 \"const_0_to_1_operand\" \"O,O,n,n\")]\n-\t\t     UNSPEC_IEEE128_MOVE))]\n-  \"TARGET_FLOAT128_HW\"\n-  \"@\n-   mtvsrwa %x0,%1\n-   lxsiwax %x0,%y1\n-   mtvsrwz %x0,%1\n-   lxsiwzx %x0,%y1\"\n-  [(set_attr \"type\" \"mffgpr,fpload,mffgpr,fpload\")])\n-\n-\n-(define_insn \"*ieee128_mtvsrd_64bit\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v,v,v\")\n-\t(unspec:V2DI [(match_operand:DI 1 \"nonimmediate_operand\" \"wr,Z,wi\")]\n-\t\t     UNSPEC_IEEE128_MOVE))]\n-  \"TARGET_FLOAT128_HW && TARGET_POWERPC64\"\n-  \"@\n-   mtvsrd %x0,%1\n-   lxsdx %x0,%y1\n-   xxlor %x0,%x1,%x1\"\n-  [(set_attr \"type\" \"mffgpr,fpload,veclogical\")])\n-\n-(define_insn \"*ieee128_mtvsrd_32bit\"\n-  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v,v\")\n-\t(unspec:V2DI [(match_operand:DI 1 \"nonimmediate_operand\" \"Z,wi\")]\n-\t\t     UNSPEC_IEEE128_MOVE))]\n-  \"TARGET_FLOAT128_HW && !TARGET_POWERPC64\"\n-  \"@\n-   lxsdx %x0,%y1\n-   xxlor %x0,%x1,%x1\"\n-  [(set_attr \"type\" \"fpload,veclogical\")])\n+(define_insn_and_split \"floatuns_<mode>si2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(unsigned_float:IEEE128\n+\t (match_operand:SI 1 \"nonimmediate_operand\" \"vrZ\")))\n+   (clobber (match_scratch:DI 2 \"=v\"))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 2)\n+\t(zero_extend:DI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(float:IEEE128 (match_dup 2)))]\n+{\n+  if (GET_CODE (operands[2]) == SCRATCH)\n+    operands[2] = gen_reg_rtx (DImode);\n+})\n \n ;; IEEE 128-bit instructions with round to odd semantics\n (define_insn \"*trunc<mode>df2_odd\""}]}