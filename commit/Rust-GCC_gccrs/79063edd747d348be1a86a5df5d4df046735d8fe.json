{"sha": "79063edd747d348be1a86a5df5d4df046735d8fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkwNjNlZGQ3NDdkMzQ4YmUxYTg2YTVkZjVkNGRmMDQ2NzM1ZDhmZQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-05-20T22:23:10Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-05-20T22:23:10Z"}, "message": "PR c/71115 - [4.9/5/6/7 Regression] Missing warning: excess elements\n\nPR c/71115 - [4.9/5/6/7 Regression] Missing warning: excess elements\nin struct initializer\n\ngcc/c/ChangeLog:\n2016-05-20  Martin Sebor  <msebor@redhat.com>\n\n\tPR c/71115\n\t* c-typeck.c (error_init): Use\n\texpansion_point_location_if_in_system_header.\n\t(warning_init): Same.\n\ngcc/testsuite/ChangeLog:\n2016-05-20  Martin Sebor  <msebor@redhat.com>\n\n\tPR c/71115\n\t* gcc.dg/init-excess-2.c: New test.\n\nFrom-SVN: r236549", "tree": {"sha": "ac73cfdeb4c5483ac27c5fdb146e58e30f7020d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac73cfdeb4c5483ac27c5fdb146e58e30f7020d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79063edd747d348be1a86a5df5d4df046735d8fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79063edd747d348be1a86a5df5d4df046735d8fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79063edd747d348be1a86a5df5d4df046735d8fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79063edd747d348be1a86a5df5d4df046735d8fe/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55c8849f5d8ca231dba2e4ed2c40c4d435c84ae3"}], "stats": {"total": 386, "additions": 371, "deletions": 15}, "files": [{"sha": "c65f2e9e5e04ceb8f8319629e363c27ece7b31a8", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=79063edd747d348be1a86a5df5d4df046735d8fe", "patch": "@@ -1,3 +1,10 @@\n+2016-05-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/71115\n+\t* c-typeck.c (error_init): Use\n+\texpansion_point_location_if_in_system_header.\n+\t(warning_init): Same.\n+\n 2016-05-19  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/71171"}, {"sha": "7c9b078ed1b04dbb4d2b9778aa762f60e5c50084", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=79063edd747d348be1a86a5df5d4df046735d8fe", "patch": "@@ -5879,16 +5879,21 @@ error_init (location_t loc, const char *gmsgid)\n    component name is taken from the spelling stack.  */\n \n static void\n-pedwarn_init (location_t location, int opt, const char *gmsgid)\n+pedwarn_init (location_t loc, int opt, const char *gmsgid)\n {\n   char *ofwhat;\n   bool warned;\n \n+  /* Use the location where a macro was expanded rather than where\n+     it was defined to make sure macros defined in system headers\n+     but used incorrectly elsewhere are diagnosed.  */\n+  source_location exploc = expansion_point_location_if_in_system_header (loc);\n+\n   /* The gmsgid may be a format string with %< and %>. */\n-  warned = pedwarn (location, opt, gmsgid);\n+  warned = pedwarn (exploc, opt, gmsgid);\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat && warned)\n-    inform (location, \"(near initialization for %qs)\", ofwhat);\n+    inform (exploc, \"(near initialization for %qs)\", ofwhat);\n }\n \n /* Issue a warning for a bad initializer component.\n@@ -5903,11 +5908,16 @@ warning_init (location_t loc, int opt, const char *gmsgid)\n   char *ofwhat;\n   bool warned;\n \n+  /* Use the location where a macro was expanded rather than where\n+     it was defined to make sure macros defined in system headers\n+     but used incorrectly elsewhere are diagnosed.  */\n+  source_location exploc = expansion_point_location_if_in_system_header (loc);\n+\n   /* The gmsgid may be a format string with %< and %>. */\n-  warned = warning_at (loc, opt, gmsgid);\n+  warned = warning_at (exploc, opt, gmsgid);\n   ofwhat = print_spelling ((char *) alloca (spelling_length () + 1));\n   if (*ofwhat && warned)\n-    inform (loc, \"(near initialization for %qs)\", ofwhat);\n+    inform (exploc, \"(near initialization for %qs)\", ofwhat);\n }\n \f\n /* If TYPE is an array type and EXPR is a parenthesized string"}, {"sha": "70354d4e4be523bc1c7dc744f69129363aacda7f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79063edd747d348be1a86a5df5d4df046735d8fe", "patch": "@@ -1,3 +1,8 @@\n+2016-05-20  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/71115\n+\t* gcc.dg/init-excess-2.c: New test.\n+\n 2016-05-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt53.adb: New test."}, {"sha": "a83d7f4e1decb4f278056ca6c31e09956490a735", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-sfinae.C", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-sfinae.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-sfinae.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-sfinae.C?ref=79063edd747d348be1a86a5df5d4df046735d8fe", "patch": "@@ -0,0 +1,287 @@\n+// Test exercising SFINAE depending on the well-definedness of constexpr\n+// functions.\n+// { dg-do compile { target c++14 } }\n+\n+#define Assert(e) static_assert ((e), #e)\n+\n+// Exercise SFINAE based on the absence of integer division by zero.\n+namespace DivByZero {\n+\n+// Define a pair of functions that have undefined and well-defined\n+// behavior, respectively, due to division by zero, depending on\n+// their arguments.\n+\n+// The following function is undefined when I is zero, well defined\n+// otherwise.\n+constexpr bool div_zero_0 (int i, int j) { return 1 + j / (i == 0); }\n+\n+// The following function is undefined when I is non-zero, and well\n+// defined otherwise.\n+constexpr bool div_zero_1 (int i, int j) { return 1 + j / (i != 0); }\n+\n+// Define a pair of overfloads each of which is viable when the constexpr\n+// function it invokes has well-defined semantics and not otherwise.\n+template <int I>\n+constexpr int f (int (*)[div_zero_0 (I, 0)] = 0) { return 0; }\n+\n+template <int I>\n+constexpr int f (int (*)[div_zero_1 (I, 0)] = 0) { return 1; }\n+\n+// Verify that the correct overload is selected based on the template\n+// argument and without triggering a compilation error for the undefined\n+// behavior in the non-viable constexpr function above.\n+Assert (f<0>() == 0);\n+Assert (f<1>() == 1);\n+\n+}\n+\n+// Exercise SFINAE based on the absence of signed integer overflow\n+// in addition.\n+namespace IntAddOverflow {\n+\n+constexpr int a [] = { 1234, __INT_MAX__ / 2 };\n+\n+constexpr int vflow_0 (int i) { return a [!i] * 7; }\n+constexpr int vflow_1 (int i) { return a [i] * 11; }\n+\n+template <int I>\n+constexpr int f (int (*)[vflow_0 (I)] = 0) { return 1; }\n+\n+template <int I>\n+constexpr int f (int (*)[vflow_1 (I)] = 0) { return 0; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 0);\n+Assert (n1 == 1);\n+\n+}\n+\n+// Exercise SFINAE based on the absence of signed integer overflow\n+// in multiplication.\n+namespace IntMulOverflow {\n+\n+constexpr long a [] = { 1234, __LONG_MAX__ / 2 };\n+\n+constexpr long vflow_0 (int i) { return a [!i] * 3; }\n+constexpr long vflow_1 (int i) { return a [i] * 7; }\n+\n+template <int I>\n+constexpr int f (int (*)[vflow_0 (I)] = 0) { return 1; }\n+\n+template <int I>\n+constexpr int f (int (*)[vflow_1 (I)] = 0) { return 0; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 0);\n+Assert (n1 == 1);\n+\n+}\n+\n+// Exercise SFINAE based on the absence of undefined pointer arithmetic\n+// involving null pointers.  Subtracting one null pointer from another\n+// is well-defined, but subtracting a null pointer from a non-null one\n+// is not.\n+namespace NullPointerArithmetic {\n+\n+constexpr int i = 0;\n+constexpr const int* a[] = { 0, &i };\n+\n+// Well-defined core constant expressoons involving null pointers.\n+constexpr __PTRDIFF_TYPE__ d00 = a [0] - a [0];\n+constexpr __PTRDIFF_TYPE__ d11 = a [1] - a [1];\n+\n+// Undefined core constant expressoons involving null pointers.\n+// constexpr __PTRDIFF_TYPE__ d01 = a [0] - a [1];\n+// constexpr __PTRDIFF_TYPE__ d10 = a [1] - a [0];\n+\n+constexpr bool nullptr_sub_0 (int i, int j) { return 1 + a [i != 0] - a [j]; }\n+\n+constexpr bool nullptr_sub_1 (int i, int j) { return 1 + a [i == 0] - a [j]; }\n+\n+template <int I>\n+constexpr int f (int (*)[nullptr_sub_0 (I, 0)] = 0) { return 0; }\n+\n+template <int I>\n+constexpr int f (int (*)[nullptr_sub_1 (I, 0)] = 0) { return 1; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 0);\n+Assert (n1 == 1);\n+\n+}\n+\n+// Exercise SFINAE based on the absence of undefined pointer arithmetic\n+// involving null poiinters.  Subtracting one null pointer from another\n+// is well-defined, but subtracting a null pointer from a non-null one\n+// is not.\n+namespace NullPointerDereference {\n+\n+struct S { int a, b; };\n+\n+constexpr S s = { };\n+constexpr const S* a[] = { 0, &s };\n+\n+constexpr bool nullptr_ref_0 (int i) { return &a [i != 0]->b == &s.b; }\n+constexpr bool nullptr_ref_1 (int i) { return &a [i == 0]->b == &s.b; }\n+\n+template <int I>\n+constexpr int f (int (*)[nullptr_ref_0 (I)] = 0) { return 1; }\n+\n+template <int I>\n+constexpr int f (int (*)[nullptr_ref_1 (I)] = 0) { return 0; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 0);\n+Assert (n1 == 1);\n+\n+}\n+\n+// Exercise SFINAE based on whether or not two constexpr function\n+// calls have a circular depency on one another such that a call\n+// to one would not terminate.\n+namespace CircularDependency {\n+\n+constexpr bool call_me (int i, bool (*f)(int)) { return f (i); }\n+\n+constexpr bool undefined_if_0 (int i) {\n+    return i ? 1 : call_me (i, undefined_if_0);\n+}\n+\n+constexpr bool undefined_if_1 (int i) {\n+    return i ? call_me (i, undefined_if_1) : 1;\n+}\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_0 (I)] = 0) { return 0; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_1 (I)] = 0) { return 1; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 1);\n+Assert (n1 == 0);\n+\n+}\n+\n+// Exercise SFINAE based on whether constexpr functions flow off\n+// the end without returning a value.\n+namespace FlowOffTheEnd {\n+\n+constexpr bool undefined_if_0 (int i) { switch (i) case 1: return 1; }\n+constexpr bool undefined_if_1 (int i) { switch (i) case 0: return 1; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_0 (I)] = 0) { return 1; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_1 (I)] = 0) { return 0; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 0);\n+Assert (n1 == 1);\n+\n+}\n+\n+// Exercise SFINAE based on the presence and absence of a left shift\n+// expression with a negative second operand.\n+namespace NegativeLeftShift {\n+\n+constexpr int a [] = { -1, 1 };\n+\n+constexpr int undefined_if_0 (int i) { return 1 << a [i]; }\n+constexpr int undefined_if_1 (int i) { return 1 << a [!i]; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_0 (I)] = 0) { return 0; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_1 (I)] = 0) { return 1; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 1);\n+Assert (n1 == 0);\n+\n+}\n+\n+// Exercise SFINAE based on the presence and absence of a right shift\n+// expression with a negative second operand.\n+namespace NegativeRightShift {\n+\n+constexpr int a [] = { -1, 1 };\n+\n+constexpr int undefined_if_0 (int i) { return 2 >> a [i]; }\n+constexpr int undefined_if_1 (int i) { return 2 >> a [!i]; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_0 (I)] = 0) { return 0; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_1 (I)] = 0) { return 1; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 1);\n+Assert (n1 == 0);\n+\n+}\n+\n+// Exercise SFINAE based on the absence of signed integer overflow\n+// in a signed left shift expression.\n+namespace LeftShiftOverflow {\n+\n+constexpr int a[] = { 1234, 1 };\n+\n+constexpr int undefined_if_0 (int i) { return 1 << a [i]; }\n+constexpr int undefined_if_1 (int i) { return 1 << a [!i]; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_0 (I)] = 0) { return 0; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_1 (I)] = 0) { return 1; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 1);\n+Assert (n1 == 0);\n+\n+}\n+\n+// Exercise SFINAE based on the absence of using a negative array\n+// index.\n+namespace NegativeArrayIndex {\n+\n+constexpr int a [] = { -1, 1 };\n+\n+constexpr int undefined_if_0 (int i) { return 2 + a [a [i]]; }\n+constexpr int undefined_if_1 (int i) { return 2 + a [a [!i]]; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_0 (I)] = 0) { return 0; }\n+\n+template <int I>\n+constexpr int f (int (*)[undefined_if_1 (I)] = 0) { return 1; }\n+\n+constexpr int n0 = f<0>();\n+constexpr int n1 = f<1>();\n+\n+Assert (n0 == 1);\n+Assert (n1 == 0);\n+\n+}"}, {"sha": "b01d8a29dcccc5e6a3fd2cf44cbc2aa78ac26459", "filename": "gcc/testsuite/gcc.dg/Woverride-init-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2Fgcc.dg%2FWoverride-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2Fgcc.dg%2FWoverride-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWoverride-init-1.c?ref=79063edd747d348be1a86a5df5d4df046735d8fe", "patch": "@@ -10,19 +10,19 @@ union u { char a; long long b; };\n struct s s0 = {\n   .a = 1,\n   .b = 2,\n-  .a = 3, /* { dg-warning \"initialized field overwritten|near init\" } */\n-  4, /* { dg-warning \"initialized field overwritten|near init\" } */\n+  .a = 3, /* { dg-warning \"initialized field overwritten\" } */\n+  4, /* { dg-warning \"initialized field overwritten\" } */\n   5\n };\n \n union u u0 = {\n   .a = 1,\n-  .b = 2, /* { dg-warning \"initialized field overwritten|near init\" } */\n-  .a = 3 }; /* { dg-warning \"initialized field overwritten|near init\" } */\n+  .b = 2, /* { dg-warning \"initialized field overwritten\" } */\n+  .a = 3 }; /* { dg-warning \"initialized field overwritten\" } */\n \n int a[5] = {\n   [0] = 1,\n   [1] = 2,\n-  [0] = 3, /* { dg-warning \"initialized field overwritten|near init\" } */\n+  [0] = 3, /* { dg-warning \"initialized field overwritten\" } */\n   [2] = 4\n };"}, {"sha": "d0ece89eb6d71f68beb300aa8b246df9571c1855", "filename": "gcc/testsuite/gcc.dg/Woverride-init-2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2Fgcc.dg%2FWoverride-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2Fgcc.dg%2FWoverride-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWoverride-init-2.c?ref=79063edd747d348be1a86a5df5d4df046735d8fe", "patch": "@@ -10,19 +10,19 @@ union u { char a; long long b; };\n struct s s0 = {\n   .a = 1,\n   .b = 2,\n-  .a = 3, /* { dg-warning \"initialized field overwritten|near init\" } */\n-  4, /* { dg-warning \"initialized field overwritten|near init\" } */\n+  .a = 3, /* { dg-warning \"initialized field overwritten\" } */\n+  4, /* { dg-warning \"initialized field overwritten\" } */\n   5\n };\n \n union u u0 = {\n   .a = 1,\n-  .b = 2, /* { dg-warning \"initialized field overwritten|near init\" } */\n-  .a = 3 }; /* { dg-warning \"initialized field overwritten|near init\" } */\n+  .b = 2, /* { dg-warning \"initialized field overwritten\" } */\n+  .a = 3 }; /* { dg-warning \"initialized field overwritten\" } */\n \n int a[5] = {\n   [0] = 1,\n   [1] = 2,\n-  [0] = 3, /* { dg-warning \"initialized field overwritten|near init\" } */\n+  [0] = 3, /* { dg-warning \"initialized field overwritten\" } */\n   [2] = 4\n };"}, {"sha": "1bf0a96a880f263ffce6bd00788f80fd8f607bec", "filename": "gcc/testsuite/gcc.dg/init-excess-2.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2Fgcc.dg%2Finit-excess-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79063edd747d348be1a86a5df5d4df046735d8fe/gcc%2Ftestsuite%2Fgcc.dg%2Finit-excess-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finit-excess-2.c?ref=79063edd747d348be1a86a5df5d4df046735d8fe", "patch": "@@ -0,0 +1,47 @@\n+/* Test for diagnostics about excess initializers when using a macro\n+   defined in a system header:\n+   c/71115 - Missing warning: excess elements in struct initializer.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+#include <stddef.h>\n+\n+int* a[1] = {\n+  0,\n+  NULL              /* { dg-warning \"excess elements|near init\" } */\n+};\n+\n+const char str[1] = {\n+  0,\n+  NULL              /* { dg-warning \"excess elements|near init\" } */\n+};\n+\n+struct S {\n+  int *a;\n+} s = {\n+  0,\n+  NULL              /* { dg-warning \"excess elements|near init\" } */\n+};\n+\n+struct __attribute__ ((designated_init)) S2 {\n+  int *a;\n+} s2 = {\n+  NULL              /* { dg-warning \"positional initialization|near init\" } */\n+};\n+\n+union U {\n+  int *a;\n+} u = {\n+  0,\n+  NULL              /* { dg-warning \"excess elements|near init\" } */\n+};\n+\n+int __attribute__ ((vector_size (16))) ivec = {\n+  0, 0, 0, 0,\n+  NULL              /* { dg-warning \"excess elements|near init\" } */\n+};\n+\n+int* scal = {\n+  0,\n+  NULL              /* { dg-warning \"excess elements|near init\" } */\n+};"}]}