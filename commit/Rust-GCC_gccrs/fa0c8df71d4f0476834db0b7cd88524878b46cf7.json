{"sha": "fa0c8df71d4f0476834db0b7cd88524878b46cf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEwYzhkZjcxZDRmMDQ3NjgzNGRiMGI3Y2Q4ODUyNDg3OGI0NmNmNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-20T12:58:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-20T12:58:22Z"}, "message": "Avoid recomputing data references in BB SLP\n\nIf the first attempt at applying BB SLP to a region fails, the main loop\nin vect_slp_bb recomputes the region's bounds and datarefs for the next\nvector size.  AFAICT this isn't needed any more; we should be able\nto reuse the datarefs from the first attempt instead.\n\n2019-10-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Call save_datarefs\n\twhen processing the given datarefs for the first time and\n\tcheck_datarefs subsequently.\n\t(vect_slp_bb_region): New function, split out of...\n\t(vect_slp_bb): ...here.  Don't recompute the region bounds and\n\tdataref sets when retrying with a different vector size.\n\nFrom-SVN: r277210", "tree": {"sha": "1308c01dcb8bc9938758c3c6bab4f813000992fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1308c01dcb8bc9938758c3c6bab4f813000992fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa0c8df71d4f0476834db0b7cd88524878b46cf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa0c8df71d4f0476834db0b7cd88524878b46cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa0c8df71d4f0476834db0b7cd88524878b46cf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa0c8df71d4f0476834db0b7cd88524878b46cf7/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4edf5c524fd0d8fef50f991ce876c6eb5ed3a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4edf5c524fd0d8fef50f991ce876c6eb5ed3a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4edf5c524fd0d8fef50f991ce876c6eb5ed3a28"}], "stats": {"total": 145, "additions": 81, "deletions": 64}, "files": [{"sha": "42cba4b99957936d5607d689e74a8bcf9ec642a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0c8df71d4f0476834db0b7cd88524878b46cf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0c8df71d4f0476834db0b7cd88524878b46cf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa0c8df71d4f0476834db0b7cd88524878b46cf7", "patch": "@@ -1,3 +1,12 @@\n+2019-10-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Call save_datarefs\n+\twhen processing the given datarefs for the first time and\n+\tcheck_datarefs subsequently.\n+\t(vect_slp_bb_region): New function, split out of...\n+\t(vect_slp_bb): ...here.  Don't recompute the region bounds and\n+\tdataref sets when retrying with a different vector size.\n+\n 2019-10-19  Jakub Jelinek  <jakub@redhat.com>\n \t    Uro\u0161 Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "d21d18f0cc255c9726a6830c7cd423550cf97336", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 72, "deletions": 64, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0c8df71d4f0476834db0b7cd88524878b46cf7/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0c8df71d4f0476834db0b7cd88524878b46cf7/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=fa0c8df71d4f0476834db0b7cd88524878b46cf7", "patch": "@@ -2852,6 +2852,7 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n   slp_instance instance;\n   int i;\n   poly_uint64 min_vf = 2;\n+  bool first_time_p = shared->datarefs.is_empty ();\n \n   /* The first group of checks is independent of the vector size.  */\n   fatal = true;\n@@ -2871,7 +2872,10 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n     return NULL;\n \n   BB_VINFO_DATAREFS (bb_vinfo) = datarefs;\n-  bb_vinfo->shared->save_datarefs ();\n+  if (first_time_p)\n+    bb_vinfo->shared->save_datarefs ();\n+  else\n+    bb_vinfo->shared->check_datarefs ();\n \n   /* Analyze the data references.  */\n \n@@ -3007,63 +3011,34 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n   return bb_vinfo;\n }\n \n+/* Subroutine of vect_slp_bb.  Try to vectorize the statements between\n+   REGION_BEGIN (inclusive) and REGION_END (exclusive), returning true\n+   on success.  The region has N_STMTS statements and has the datarefs\n+   given by DATAREFS.  */\n \n-/* Main entry for the BB vectorizer.  Analyze and transform BB, returns\n-   true if anything in the basic-block was vectorized.  */\n-\n-bool\n-vect_slp_bb (basic_block bb)\n+static bool\n+vect_slp_bb_region (gimple_stmt_iterator region_begin,\n+\t\t    gimple_stmt_iterator region_end,\n+\t\t    vec<data_reference_p> datarefs,\n+\t\t    unsigned int n_stmts)\n {\n   bb_vec_info bb_vinfo;\n-  gimple_stmt_iterator gsi;\n-  bool any_vectorized = false;\n   auto_vector_sizes vector_sizes;\n \n   /* Autodetect first vector size we try.  */\n   current_vector_size = 0;\n   targetm.vectorize.autovectorize_vector_sizes (&vector_sizes, false);\n   unsigned int next_size = 0;\n \n-  gsi = gsi_start_bb (bb);\n+  vec_info_shared shared;\n \n   poly_uint64 autodetected_vector_size = 0;\n   while (1)\n     {\n-      if (gsi_end_p (gsi))\n-\tbreak;\n-\n-      gimple_stmt_iterator region_begin = gsi;\n-      vec<data_reference_p> datarefs = vNULL;\n-      int insns = 0;\n-\n-      for (; !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_debug (stmt))\n-\t    continue;\n-\t  insns++;\n-\n-\t  if (gimple_location (stmt) != UNKNOWN_LOCATION)\n-\t    vect_location = stmt;\n-\n-\t  if (!vect_find_stmt_data_reference (NULL, stmt, &datarefs))\n-\t    break;\n-\t}\n-\n-      /* Skip leading unhandled stmts.  */\n-      if (gsi_stmt (region_begin) == gsi_stmt (gsi))\n-\t{\n-\t  gsi_next (&gsi);\n-\t  continue;\n-\t}\n-\n-      gimple_stmt_iterator region_end = gsi;\n-\n       bool vectorized = false;\n       bool fatal = false;\n-      vec_info_shared shared;\n       bb_vinfo = vect_slp_analyze_bb_1 (region_begin, region_end,\n-\t\t\t\t\tdatarefs, insns, fatal, &shared);\n+\t\t\t\t\tdatarefs, n_stmts, fatal, &shared);\n       if (bb_vinfo\n \t  && dbg_cnt (vect_slp))\n \t{\n@@ -3090,8 +3065,6 @@ vect_slp_bb (basic_block bb)\n \t}\n       delete bb_vinfo;\n \n-      any_vectorized |= vectorized;\n-\n       if (next_size == 0)\n \tautodetected_vector_size = current_vector_size;\n \n@@ -3105,33 +3078,68 @@ vect_slp_bb (basic_block bb)\n \t  /* If vect_slp_analyze_bb_1 signaled that analysis for all\n \t     vector sizes will fail do not bother iterating.  */\n \t  || fatal)\n+\treturn vectorized;\n+\n+      /* Try the next biggest vector size.  */\n+      current_vector_size = vector_sizes[next_size++];\n+      if (dump_enabled_p ())\n \t{\n-\t  if (gsi_end_p (region_end))\n-\t    break;\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"***** Re-trying analysis with \"\n+\t\t\t   \"vector size \");\n+\t  dump_dec (MSG_NOTE, current_vector_size);\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n+    }\n+}\n \n-\t  /* Skip the unhandled stmt.  */\n-\t  gsi_next (&gsi);\n+/* Main entry for the BB vectorizer.  Analyze and transform BB, returns\n+   true if anything in the basic-block was vectorized.  */\n \n-\t  /* And reset vector sizes.  */\n-\t  current_vector_size = 0;\n-\t  next_size = 0;\n-\t}\n-      else\n+bool\n+vect_slp_bb (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+  bool any_vectorized = false;\n+\n+  gsi = gsi_start_bb (bb);\n+  while (!gsi_end_p (gsi))\n+    {\n+      gimple_stmt_iterator region_begin = gsi;\n+      vec<data_reference_p> datarefs = vNULL;\n+      int insns = 0;\n+\n+      for (; !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  /* Try the next biggest vector size.  */\n-\t  current_vector_size = vector_sizes[next_size++];\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"***** Re-trying analysis with \"\n-\t\t\t       \"vector size \");\n-\t      dump_dec (MSG_NOTE, current_vector_size);\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  if (is_gimple_debug (stmt))\n+\t    continue;\n+\t  insns++;\n+\n+\t  if (gimple_location (stmt) != UNKNOWN_LOCATION)\n+\t    vect_location = stmt;\n+\n+\t  if (!vect_find_stmt_data_reference (NULL, stmt, &datarefs))\n+\t    break;\n+\t}\n \n-\t  /* Start over.  */\n-\t  gsi = region_begin;\n+      /* Skip leading unhandled stmts.  */\n+      if (gsi_stmt (region_begin) == gsi_stmt (gsi))\n+\t{\n+\t  gsi_next (&gsi);\n+\t  continue;\n \t}\n+\n+      gimple_stmt_iterator region_end = gsi;\n+\n+      if (vect_slp_bb_region (region_begin, region_end, datarefs, insns))\n+\tany_vectorized = true;\n+\n+      if (gsi_end_p (region_end))\n+\tbreak;\n+\n+      /* Skip the unhandled stmt.  */\n+      gsi_next (&gsi);\n     }\n \n   return any_vectorized;"}]}