{"sha": "ac01eace31d7c08ffb77c1f732258c1a93eb972f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMwMWVhY2UzMWQ3YzA4ZmZiNzdjMWY3MzIyNThjMWE5M2ViOTcyZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-05T03:03:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-01-05T03:03:27Z"}, "message": "(expand_expr, case COND_EXPR): Add additional cases to \"singleton\"\ncases.\n\nFrom-SVN: r13372", "tree": {"sha": "813f12518ac96dab91bcded680f7177860932261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/813f12518ac96dab91bcded680f7177860932261"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac01eace31d7c08ffb77c1f732258c1a93eb972f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac01eace31d7c08ffb77c1f732258c1a93eb972f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac01eace31d7c08ffb77c1f732258c1a93eb972f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac01eace31d7c08ffb77c1f732258c1a93eb972f/comments", "author": null, "committer": null, "parents": [{"sha": "c7554b2898aae6a067dc37a37556f3b70fb3db78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7554b2898aae6a067dc37a37556f3b70fb3db78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7554b2898aae6a067dc37a37556f3b70fb3db78"}], "stats": {"total": 57, "additions": 46, "deletions": 11}, "files": [{"sha": "cbd813b5f7baab4335e43b8f8dd6e7e42f5ecda6", "filename": "gcc/expr.c", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac01eace31d7c08ffb77c1f732258c1a93eb972f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac01eace31d7c08ffb77c1f732258c1a93eb972f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ac01eace31d7c08ffb77c1f732258c1a93eb972f", "patch": "@@ -1,5 +1,5 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n-   Copyright (C) 1988, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -6459,6 +6459,31 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t  VOIDmode, 0);\n \n     case COND_EXPR:\n+      /* If we would have a \"singleton\" (see below) were it not for a\n+\t conversion in each arm, bring that conversion back out.  */\n+      if (TREE_CODE (TREE_OPERAND (exp, 1)) == NOP_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (exp, 2)) == NOP_EXPR\n+\t  && (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 1), 0))\n+\t      == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 2), 0))))\n+\t{\n+\t  tree true = TREE_OPERAND (TREE_OPERAND (exp, 1), 0);\n+\t  tree false = TREE_OPERAND (TREE_OPERAND (exp, 2), 0);\n+\n+\t  if ((TREE_CODE_CLASS (TREE_CODE (true)) == '2'\n+\t       && operand_equal_p (false, TREE_OPERAND (true, 0), 0))\n+\t      || (TREE_CODE_CLASS (TREE_CODE (false)) == '2'\n+\t\t  && operand_equal_p (true, TREE_OPERAND (false, 0), 0))\n+\t      || (TREE_CODE_CLASS (TREE_CODE (true)) == '1'\n+\t\t  && operand_equal_p (false, TREE_OPERAND (true, 0), 0))\n+\t      || (TREE_CODE_CLASS (TREE_CODE (false)) == '1'\n+\t\t  && operand_equal_p (true, TREE_OPERAND (false, 0), 0)))\n+\t    return expand_expr (build1 (NOP_EXPR, type,\n+\t\t\t\t\tbuild (COND_EXPR, TREE_TYPE (true),\n+\t\t\t\t\t       TREE_OPERAND (exp, 0),\n+\t\t\t\t\t       true, false)),\n+\t\t\t\ttarget, tmode, modifier);\n+\t}\n+\n       {\n \trtx flag = NULL_RTX;\n \ttree left_cleanups = NULL_TREE;\n@@ -6506,11 +6531,11 @@ expand_expr (exp, target, tmode, modifier)\n \t    return target;\n \t  }\n \n-\t/* Check for X ? A + B : A.  If we have this, we can copy\n-\t   A to the output and conditionally add B.  Similarly for unary\n-\t   operations.  Don't do this if X has side-effects because\n-\t   those side effects might affect A or B and the \"?\" operation is\n-\t   a sequence point in ANSI.  (We test for side effects later.)  */\n+\t/* Check for X ? A + B : A.  If we have this, we can copy A to the\n+\t   output and conditionally add B.  Similarly for unary operations.\n+\t   Don't do this if X has side-effects because those side effects\n+\t   might affect A or B and the \"?\" operation is a sequence point in\n+\t   ANSI.  (operand_equal_p tests for side effects.)  */\n \n \tif (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 1))) == '2'\n \t    && operand_equal_p (TREE_OPERAND (exp, 2),\n@@ -6550,16 +6575,17 @@ expand_expr (exp, target, tmode, modifier)\n \telse\n \t  temp = assign_temp (type, 0, 0, 1);\n \n-\t/* If we had X ? A + 1 : A and we can do the test of X as a store-flag\n-\t   operation, do this as A + (X != 0).  Similarly for other simple\n-\t   binary operators.  */\n+\t/* If we had X ? A + C : A, with C a constant power of 2, and we can\n+\t   do the test of X as a store-flag operation, do this as\n+\t   A + ((X != 0) << log C).  Similarly for other simple binary\n+\t   operators.  Only do for C == 1 if BRANCH_COST is low.  */\n \tif (temp && singleton && binary_op\n-\t    && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0))\n \t    && (TREE_CODE (binary_op) == PLUS_EXPR\n \t\t|| TREE_CODE (binary_op) == MINUS_EXPR\n \t\t|| TREE_CODE (binary_op) == BIT_IOR_EXPR\n \t\t|| TREE_CODE (binary_op) == BIT_XOR_EXPR)\n-\t    && integer_onep (TREE_OPERAND (binary_op, 1))\n+\t    && (BRANCH_COST >= 3 ? integer_pow2p (TREE_OPERAND (binary_op, 1))\n+\t\t: integer_onep (TREE_OPERAND (binary_op, 1)))\n \t    && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<')\n \t  {\n \t    rtx result;\n@@ -6584,6 +6610,15 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t     ? temp : NULL_RTX),\n \t\t\t\t    mode, BRANCH_COST <= 1);\n \n+\t    if (result != 0 && ! integer_onep (TREE_OPERAND (binary_op, 1)))\n+\t      result = expand_shift (LSHIFT_EXPR, mode, result,\n+\t\t\t\t     build_int_2 (tree_log2\n+\t\t\t\t\t\t  (TREE_OPERAND\n+\t\t\t\t\t\t   (binary_op, 1)),\n+\t\t\t\t\t\t  0),\n+\t\t\t\t     (safe_from_p (temp, singleton)\n+\t\t\t\t      ? temp : NULL_RTX), 0);\n+\n \t    if (result)\n \t      {\n \t\top1 = expand_expr (singleton, NULL_RTX, VOIDmode, 0);"}]}