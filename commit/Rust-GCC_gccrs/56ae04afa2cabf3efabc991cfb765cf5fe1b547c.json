{"sha": "56ae04afa2cabf3efabc991cfb765cf5fe1b547c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZhZTA0YWZhMmNhYmYzZWZhYmM5OTFjZmI3NjVjZjVmZTFiNTQ3Yw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-08T19:45:46Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-08T19:45:46Z"}, "message": "c-objc-common.c (): Fix a typo in a warning.\n\n\t* c-objc-common.c (): Fix a typo in a warning.\n\t* cse.c (preferrable): Change to preferable. Update all of its\n\tcallers.\n\t* genautomata.c (ainsn): Change\n\tfirst_ainsn_with_given_equialence_num to\n\tfirst_ainsn_with_given_equivalence_num.  Update all of its\n\treferences.\n\nFrom-SVN: r77497", "tree": {"sha": "58b5a04791caa6399cc359067aa74452ffa12d6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58b5a04791caa6399cc359067aa74452ffa12d6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56ae04afa2cabf3efabc991cfb765cf5fe1b547c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ae04afa2cabf3efabc991cfb765cf5fe1b547c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56ae04afa2cabf3efabc991cfb765cf5fe1b547c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/comments", "author": null, "committer": null, "parents": [{"sha": "517b3f9f2553799462429beb36993e0ce79af0be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517b3f9f2553799462429beb36993e0ce79af0be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/517b3f9f2553799462429beb36993e0ce79af0be"}], "stats": {"total": 72, "additions": 41, "deletions": 31}, "files": [{"sha": "0b35c432740fc66661e063b1bda1a1f78f3252b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56ae04afa2cabf3efabc991cfb765cf5fe1b547c", "patch": "@@ -1,3 +1,13 @@\n+2004-02-08  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-objc-common.c (): Fix a typo in a warning.\n+\t* cse.c (preferrable): Change to preferable. Update all of its\n+\tcallers.\n+\t* genautomata.c (ainsn): Change\n+\tfirst_ainsn_with_given_equialence_num to\n+\tfirst_ainsn_with_given_equivalence_num.  Update all of its\n+\treferences.\n+\n 2004-02-08  Jan Hubicka  <jh@suse.cz>\n \n \t* schedule-ebb.c (schedule_ebbs): Do not allocate reg life data."}, {"sha": "d044ba9cb65e76717ed73d1109eadb5de6570433", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=56ae04afa2cabf3efabc991cfb765cf5fe1b547c", "patch": "@@ -80,7 +80,7 @@ c_cannot_inline_tree_fn (tree *fnp)\n     {\n       if (do_warning)\n \twarning (\"%Jfunction '%F' can never be inlined because it \"\n-\t\t \"is supressed using -fno-inline\", fn, fn);\n+\t\t \"is suppressed using -fno-inline\", fn, fn);\n       goto cannot_inline;\n     }\n "}, {"sha": "55fe072105d3432cbdd0a330ed0c5bc7520f0f39", "filename": "gcc/cse.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=56ae04afa2cabf3efabc991cfb765cf5fe1b547c", "patch": "@@ -601,7 +601,7 @@ static bool fixed_base_plus_p (rtx x);\n static int notreg_cost (rtx, enum rtx_code);\n static int approx_reg_cost_1 (rtx *, void *);\n static int approx_reg_cost (rtx);\n-static int preferrable (int, int, int, int);\n+static int preferable (int, int, int, int);\n static void new_basic_block (void);\n static void make_new_qty (unsigned int, enum machine_mode);\n static void make_regs_eqv (unsigned int, unsigned int);\n@@ -761,7 +761,7 @@ approx_reg_cost (rtx x)\n    Return a positive value if A is less desirable, or 0 if the two are\n    equally good.  */\n static int\n-preferrable (int cost_a, int regcost_a, int cost_b, int regcost_b)\n+preferable (int cost_a, int regcost_a, int cost_b, int regcost_b)\n {\n   /* First, get rid of cases involving expressions that are entirely\n      unwanted.  */\n@@ -1513,7 +1513,7 @@ lookup_as_function (rtx x, enum rtx_code code)\n    If necessary, update table showing constant values of quantities.  */\n \n #define CHEAPER(X, Y) \\\n- (preferrable ((X)->cost, (X)->regcost, (Y)->cost, (Y)->regcost) < 0)\n+ (preferable ((X)->cost, (X)->regcost, (Y)->cost, (Y)->regcost) < 0)\n \n static struct table_elt *\n insert (rtx x, struct table_elt *classp, unsigned int hash, enum machine_mode mode)\n@@ -5424,14 +5424,14 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t     of equal cost, use this order:\n \t     src_folded, src, src_eqv, src_related and hash table entry.  */\n \t  if (src_folded\n-\t      && preferrable (src_folded_cost, src_folded_regcost,\n-\t\t\t      src_cost, src_regcost) <= 0\n-\t      && preferrable (src_folded_cost, src_folded_regcost,\n-\t\t\t      src_eqv_cost, src_eqv_regcost) <= 0\n-\t      && preferrable (src_folded_cost, src_folded_regcost,\n-\t\t\t      src_related_cost, src_related_regcost) <= 0\n-\t      && preferrable (src_folded_cost, src_folded_regcost,\n-\t\t\t      src_elt_cost, src_elt_regcost) <= 0)\n+\t      && preferable (src_folded_cost, src_folded_regcost,\n+\t\t\t     src_cost, src_regcost) <= 0\n+\t      && preferable (src_folded_cost, src_folded_regcost,\n+\t\t\t     src_eqv_cost, src_eqv_regcost) <= 0\n+\t      && preferable (src_folded_cost, src_folded_regcost,\n+\t\t\t     src_related_cost, src_related_regcost) <= 0\n+\t      && preferable (src_folded_cost, src_folded_regcost,\n+\t\t\t     src_elt_cost, src_elt_regcost) <= 0)\n \t    {\n \t      trial = src_folded, src_folded_cost = MAX_COST;\n \t      if (src_folded_force_flag)\n@@ -5442,22 +5442,22 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t\t}\n \t    }\n \t  else if (src\n-\t\t   && preferrable (src_cost, src_regcost,\n-\t\t\t\t   src_eqv_cost, src_eqv_regcost) <= 0\n-\t\t   && preferrable (src_cost, src_regcost,\n-\t\t\t\t   src_related_cost, src_related_regcost) <= 0\n-\t\t   && preferrable (src_cost, src_regcost,\n-\t\t\t\t   src_elt_cost, src_elt_regcost) <= 0)\n+\t\t   && preferable (src_cost, src_regcost,\n+\t\t\t\t  src_eqv_cost, src_eqv_regcost) <= 0\n+\t\t   && preferable (src_cost, src_regcost,\n+\t\t\t\t  src_related_cost, src_related_regcost) <= 0\n+\t\t   && preferable (src_cost, src_regcost,\n+\t\t\t\t  src_elt_cost, src_elt_regcost) <= 0)\n \t    trial = src, src_cost = MAX_COST;\n \t  else if (src_eqv_here\n-\t\t   && preferrable (src_eqv_cost, src_eqv_regcost,\n-\t\t\t\t   src_related_cost, src_related_regcost) <= 0\n-\t\t   && preferrable (src_eqv_cost, src_eqv_regcost,\n-\t\t\t\t   src_elt_cost, src_elt_regcost) <= 0)\n+\t\t   && preferable (src_eqv_cost, src_eqv_regcost,\n+\t\t\t\t  src_related_cost, src_related_regcost) <= 0\n+\t\t   && preferable (src_eqv_cost, src_eqv_regcost,\n+\t\t\t\t  src_elt_cost, src_elt_regcost) <= 0)\n \t    trial = copy_rtx (src_eqv_here), src_eqv_cost = MAX_COST;\n \t  else if (src_related\n-\t\t   && preferrable (src_related_cost, src_related_regcost,\n-\t\t\t\t   src_elt_cost, src_elt_regcost) <= 0)\n+\t\t   && preferable (src_related_cost, src_related_regcost,\n+\t\t\t\t  src_elt_cost, src_elt_regcost) <= 0)\n \t    trial = copy_rtx (src_related), src_related_cost = MAX_COST;\n \t  else\n \t    {"}, {"sha": "88f7a91c3cc1a27309d22f897fb9ce8eca0fa928", "filename": "gcc/genautomata.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56ae04afa2cabf3efabc991cfb765cf5fe1b547c/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=56ae04afa2cabf3efabc991cfb765cf5fe1b547c", "patch": "@@ -1209,7 +1209,7 @@ struct ainsn\n   ainsn_t next_equiv_class_insn;\n   /* The following field value is nonzero if the insn declaration is\n      the first insn declaration with given equivalence number.  */\n-  char first_ainsn_with_given_equialence_num;\n+  char first_ainsn_with_given_equivalence_num;\n   /* The following field is number of class of equivalence of insns.\n      It is necessary because many insns may be equivalent with the\n      point of view of pipeline hazards.  */\n@@ -6610,7 +6610,7 @@ set_insn_equiv_classes (automaton_t automaton)\n         first_insn = ainsn;\n         if (!first_insn->first_insn_with_same_reservs)\n \t  abort ();\n-        first_insn->first_ainsn_with_given_equialence_num = 1;\n+        first_insn->first_ainsn_with_given_equivalence_num = 1;\n         curr_insn = first_insn;\n         do\n           {\n@@ -7673,7 +7673,7 @@ out_state_arcs_num (state_t state)\n     {\n       if (arc->insn == NULL)\n \tabort ();\n-      if (arc->insn->first_ainsn_with_given_equialence_num)\n+      if (arc->insn->first_ainsn_with_given_equivalence_num)\n         result++;\n     }\n   return result;\n@@ -7756,7 +7756,7 @@ output_trans_table (automaton_t automaton)\n         {\n           if (arc->insn == NULL)\n \t    abort ();\n-          if (arc->insn->first_ainsn_with_given_equialence_num)\n+          if (arc->insn->first_ainsn_with_given_equivalence_num)\n             add_vect_el (&transition_vect, arc->insn,\n                          arc->to_state->order_state_num);\n         }\n@@ -7805,7 +7805,7 @@ output_state_alts_table (automaton_t automaton)\n         {\n           if (arc->insn == NULL)\n \t    abort ();\n-          if (arc->insn->first_ainsn_with_given_equialence_num)\n+          if (arc->insn->first_ainsn_with_given_equivalence_num)\n             add_vect_el (&state_alts_vect, arc->insn, arc->state_alts);\n         }\n       add_vect (automaton->state_alts_table, (*state_ptr)->order_state_num,\n@@ -7914,7 +7914,7 @@ output_min_issue_delay_table (automaton_t automaton)\n     VLA_HWINT (min_issue_delay_vect, i) = 0;\n   automaton->max_min_delay = 0;\n   for (ainsn = automaton->ainsn_list; ainsn != NULL; ainsn = ainsn->next_ainsn)\n-    if (ainsn->first_ainsn_with_given_equialence_num)\n+    if (ainsn->first_ainsn_with_given_equivalence_num)\n       {\n \tfor (state_ptr = VLA_PTR_BEGIN (output_states_vect);\n \t     state_ptr <= (state_t *) VLA_PTR_LAST (output_states_vect);\n@@ -9117,7 +9117,7 @@ output_automaton_units (automaton_t automaton)\n   int there_is_an_automaton_unit;\n   int i;\n \n-  fprintf (output_description_file, \"\\n  Coresponding units:\\n\");\n+  fprintf (output_description_file, \"\\n  Corresponding units:\\n\");\n   fprintf (output_description_file, \"    \");\n   curr_line_length = 4;\n   there_is_an_automaton_unit = 0;"}]}