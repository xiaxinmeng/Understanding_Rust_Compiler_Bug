{"sha": "929f36717e0b3aadec72370f359fc661487696fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI5ZjM2NzE3ZTBiM2FhZGVjNzIzNzBmMzU5ZmM2NjE0ODc2OTZmYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-23T02:07:53Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-23T02:07:53Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r572", "tree": {"sha": "9494332a28df97aa5ed1bd5007ee0488b362024d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9494332a28df97aa5ed1bd5007ee0488b362024d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/929f36717e0b3aadec72370f359fc661487696fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929f36717e0b3aadec72370f359fc661487696fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/929f36717e0b3aadec72370f359fc661487696fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929f36717e0b3aadec72370f359fc661487696fc/comments", "author": null, "committer": null, "parents": [{"sha": "c160c628f1b04c6f185bb72ab357837658bbf882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c160c628f1b04c6f185bb72ab357837658bbf882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c160c628f1b04c6f185bb72ab357837658bbf882"}], "stats": {"total": 73, "additions": 45, "deletions": 28}, "files": [{"sha": "9a54f50b6f978cfffdb85243a6b81fad4607ef83", "filename": "gcc/c-decl.c", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/929f36717e0b3aadec72370f359fc661487696fc/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/929f36717e0b3aadec72370f359fc661487696fc/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=929f36717e0b3aadec72370f359fc661487696fc", "patch": "@@ -256,7 +256,7 @@ int current_function_returns_null;\n \n static int warn_about_return_type;\n \n-/* Nonzero when starting a function delcared `extern inline'.  */\n+/* Nonzero when starting a function declared `extern inline'.  */\n \n static int current_extern_inline;\n \f\n@@ -376,7 +376,7 @@ static struct binding_level *label_level_chain;\n \n static tree grokparms (), grokdeclarator ();\n tree pushdecl ();\n-static tree builtin_function ();\n+tree builtin_function ();\n \n static tree lookup_tag ();\n static tree lookup_tag_reverse ();\n@@ -476,7 +476,7 @@ int warn_conversion;\n \n /* Warn if adding () is suggested.  */\n \n-int warn_parentheses = 1;\n+int warn_parentheses;\n \n /* Nonzero means `$' can be in an identifier.\n    See cccp.c for reasons why this breaks some obscure ANSI C programs.  */\n@@ -622,6 +622,7 @@ c_decode_option (p)\n       warn_switch = 1;\n       warn_format = 1;\n       warn_char_subscripts = 1;\n+      warn_parentheses = 1;\n     }\n   else\n     return 0;\n@@ -1127,7 +1128,7 @@ duplicate_decls (newdecl, olddecl)\n \t\twarning_with_decl (newdecl, \"shadowing built-in function `%s'\");\n \t    }\n \t  /* Likewise, if the built-in is not ansi, then programs can\n-\t     overide it even globally without an error.  */\n+\t     override it even globally without an error.  */\n \t  else if (DECL_BUILT_IN_NONANSI (olddecl))\n \t    warning_with_decl (newdecl,\n \t\t\t       \"built-in function `%s' declared as non-function\");\n@@ -1610,7 +1611,8 @@ pushdecl (x)\n \t\t\t  TREE_TYPE (IDENTIFIER_IMPLICIT_DECL (name))))\n \t{\n \t  warning_with_decl (x, \"type mismatch with previous implicit declaration\");\n-\t  warning_with_decl (x, \"previous implicit declaration of `%s'\");\n+\t  warning_with_decl (IDENTIFIER_IMPLICIT_DECL (name),\n+\t\t\t     \"previous implicit declaration of `%s'\");\n \t}\n \n       /* In PCC-compatibility mode, extern decls of vars with no current decl\n@@ -1682,7 +1684,14 @@ pushdecl (x)\n \t  if (TREE_PUBLIC (name)\n \t      && ! TREE_PUBLIC (x) && ! TREE_EXTERNAL (x))\n \t    {\n-\t      if (IDENTIFIER_IMPLICIT_DECL (name))\n+\t      /* Okay to declare an ANSI built-in as inline static.  */\n+\t      if (t != 0 && DECL_BUILT_IN (t)\n+\t\t  && TREE_INLINE (x))\n+\t\t;\n+\t      /* Okay to declare a non-ANSI built-in as anything.  */\n+\t      else if (t != 0 && DECL_BUILT_IN_NONANSI (t))\n+\t\t;\n+\t      else if (IDENTIFIER_IMPLICIT_DECL (name))\n \t\tpedwarn (\"`%s' was declared implicitly `extern' and later `static'\",\n \t\t\t IDENTIFIER_POINTER (name));\n \t      else\n@@ -2439,7 +2448,7 @@ init_decl_processing ()\n \t\t\t\t\t\t\t    sizetype,\n \t\t\t\t\t\t\t    endlink))));\n \n-  /* ``integer_tpe_node'' mispelling corrected: North-Keys 30 Mar 91 */\n+  /* ``integer_tpe_node'' misspelling corrected: North-Keys 30 Mar 91 */\n   builtin_function (\"__builtin_constant_p\",\n \t\t    build_function_type (integer_type_node, endlink),\n \t\t    BUILT_IN_CONSTANT_P, 0);\n@@ -2537,6 +2546,8 @@ init_decl_processing ()\n \t\t    BUILT_IN_STRCPY, \"strcpy\");\n   builtin_function (\"__builtin_strlen\", sizet_ftype_string,\n \t\t    BUILT_IN_STRLEN, \"strlen\");\n+  builtin_function (\"__builtin_fsqrt\", double_ftype_double, \n+\t\t    BUILT_IN_FSQRT, \"sqrt\");\n   /* In an ANSI C program, it is okay to supply built-in meanings\n      for these functions, since applications cannot validly use them\n      with any other meaning.\n@@ -2551,6 +2562,10 @@ init_decl_processing ()\n       builtin_function (\"strcmp\", int_ftype_string_string, BUILT_IN_STRCMP, 0);\n       builtin_function (\"strcpy\", string_ftype_ptr_ptr, BUILT_IN_STRCPY, 0);\n       builtin_function (\"strlen\", sizet_ftype_string, BUILT_IN_STRLEN, 0);\n+#if 0 /* No good, since open-coded implementation fails to set errno.\n+\t The ANSI committee made a real mistake in specifying math fns.  */\n+      builtin_function (\"sqrt\", double_ftype_double, BUILT_IN_FSQRT, 0);\n+#endif\n     }\n \n #if 0\n@@ -2563,7 +2578,6 @@ init_decl_processing ()\n   builtin_function (\"__builtin_fmod\", double_ftype_double_double, BUILT_IN_FMOD, 0);\n   builtin_function (\"__builtin_frem\", double_ftype_double_double, BUILT_IN_FREM, 0);\n   builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int, BUILT_IN_MEMSET, 0);\n-  builtin_function (\"__builtin_fsqrt\", double_ftype_double, BUILT_IN_FSQRT, 0);\n   builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP, 0);\n   builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN, 0);\n #endif\n@@ -2581,7 +2595,7 @@ init_decl_processing ()\n    If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,\n    the name to be called if we can't opencode the function.  */\n \n-static tree\n+tree\n builtin_function (name, type, function_code, library_name)\n      char *name;\n      tree type;\n@@ -3049,13 +3063,18 @@ push_parm_decl (parm)\n      tree parm;\n {\n   tree decl;\n+  int old_immediate_size_expand = immediate_size_expand;\n+  /* Don't try computing parm sizes now -- wait till fn is called.  */\n+  immediate_size_expand = 0;\n \n   /* The corresponding pop_obstacks is in finish_decl.  */\n   push_obstacks_nochange ();\n \n   decl = grokdeclarator (TREE_VALUE (parm), TREE_PURPOSE (parm), PARM, 0);\n   decl = pushdecl (decl);\n \n+  immediate_size_expand = old_immediate_size_expand;\n+\n   current_binding_level->parm_order\n     = tree_cons (NULL_TREE, decl, current_binding_level->parm_order);\n \n@@ -3074,7 +3093,7 @@ clear_parm_order ()\n }\n \f\n /* Make TYPE a complete type based on INITIAL_VALUE.\n-   Return 0 if successful, 1 if INITIAL_VALUE can't be decyphered,\n+   Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,\n    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */\n \n int\n@@ -3161,7 +3180,7 @@ complete_array_type (type, initial_value, do_default)\n    argument type is specified but not the name.\n \n    This function is where the complicated C meanings of `static'\n-   and `extern' are intrepreted.  */\n+   and `extern' are interpreted.  */\n \n static tree\n grokdeclarator (declarator, declspecs, decl_context, initialized)\n@@ -3185,7 +3204,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n   int funcdef_flag = 0;\n   enum tree_code innermost_code = ERROR_MARK;\n   int bitfield = 0;\n-  int variable_size = 0;\n+  int size_varies = 0;\n \n   if (decl_context == BITFIELD)\n     bitfield = 1, decl_context = FIELD;\n@@ -3318,7 +3337,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n   typedef_type = type;\n   if (type)\n-    variable_size = C_TYPE_VARIABLE_SIZE (type);\n+    size_varies = C_TYPE_VARIABLE_SIZE (type);\n \n   /* No type at all: default to `int', and set EXPLICIT_INT\n      because it was not a user-defined typedef.  */\n@@ -3592,8 +3611,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t\t\t\t   1);\n \t\t  /* Make sure the array size remains visibly nonconstant\n \t\t     even if it is (eg) a const variable with known value.  */\n-\t\t  variable_size = 1;\n-\t\t  itype = build_index_type (save_expr (itype));\n+\t\t  size_varies = 1;\n+\t\t  itype = variable_size (itype);\n+\t\t  itype = build_index_type (itype);\n \t\t}\n \t    }\n \n@@ -3628,7 +3648,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n #endif\n \n \t  type = build_array_type (type, itype);\n-\t  if (variable_size)\n+\t  if (size_varies)\n \t    C_TYPE_VARIABLE_SIZE (type) = 1;\n \t}\n       else if (TREE_CODE (declarator) == CALL_EXPR)\n@@ -3640,7 +3660,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  if (type == error_mark_node)\n \t    continue;\n \n-\t  variable_size = 0;\n+\t  size_varies = 0;\n \n \t  /* Warn about some types functions can't return.  */\n \n@@ -3708,7 +3728,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    type = c_build_type_variant (type, constp, volatilep);\n \t  constp = 0;\n \t  volatilep = 0;\n-\t  variable_size = 0;\n+\t  size_varies = 0;\n \n \t  type = build_pointer_type (type);\n \n@@ -3778,7 +3798,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       && TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type) == 0)\n     {\n       type = build_array_type (TREE_TYPE (type), 0);\n-      if (variable_size)\n+      if (size_varies)\n \tC_TYPE_VARIABLE_SIZE (type) = 1;\n     }\n \n@@ -3829,7 +3849,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t    type = build_pointer_type\n \t\t    (c_build_type_variant (TREE_TYPE (type), constp, volatilep));\n \t    volatilep = constp = 0;\n-\t    variable_size = 0;\n+\t    size_varies = 0;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n@@ -3843,7 +3863,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  error (\"parameter `%s' is initialized\", name);\n \n \tdecl = build_decl (PARM_DECL, declarator, type);\n-\tif (variable_size)\n+\tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \t/* Compute the type actually passed in the parmlist,\n@@ -3887,7 +3907,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n #endif\n \t  }\n \tdecl = build_decl (FIELD_DECL, declarator, type);\n-\tif (variable_size)\n+\tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n       }\n     else if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -3956,7 +3976,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t  }\n \n \tdecl = build_decl (VAR_DECL, declarator, type);\n-\tif (variable_size)\n+\tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \tif (inlinep)\n@@ -4267,7 +4287,7 @@ xref_tag (code, name)\n   /* Even if this is the wrong type of tag, return what we found.\n      There will be an error message anyway, from pending_xref_error.\n      If we create an empty xref just for an invalid use of the type,\n-     the main result is to create lots of superflous error messages.  */\n+     the main result is to create lots of superfluous error messages.  */\n   if (ref)\n     return ref;\n \n@@ -5325,10 +5345,7 @@ store_parm_decls ()\n \t     will be a variant of the main variant of the original function\n \t     type.  */\n \n-\t  TREE_TYPE (fndecl)\n-\t    = build_type_copy (TYPE_MAIN_VARIANT (TREE_TYPE (fndecl)),\n-\t\t\t       TYPE_READONLY (TREE_TYPE (fndecl)),\n-\t\t\t       TYPE_VOLATILE (TREE_TYPE (fndecl)));\n+\t  TREE_TYPE (fndecl) = build_type_copy (TREE_TYPE (fndecl));\n \n \t  TYPE_ACTUAL_ARG_TYPES (TREE_TYPE (fndecl)) = actual;\n \t}"}]}