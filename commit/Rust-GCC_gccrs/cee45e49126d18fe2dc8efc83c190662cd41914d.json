{"sha": "cee45e49126d18fe2dc8efc83c190662cd41914d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlNDVlNDkxMjZkMThmZTJkYzhlZmM4M2MxOTA2NjJjZDQxOTE0ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-03T16:45:15Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-03T16:49:27Z"}, "message": "c++: Directly fixup deferred eh-specs\n\neh-specifiers in a class definition are complete-definition contexts,\nand we sometimes need to deferr their parsing.  We create a deferred\neh specifier, which can end up persisting in the type system due to\nvariants being created before the deferred parse.  This causes\nproblems in modules handling.\n\nThis patch adds fixup_deferred_exception_variants, which directly\nmodifies the variants of such an eh spec once parsed.  As commented,\nthe general case is quite hard, so it doesn't deal with everything.\nBut I do catch the cases I encountered (from the std library).\n\n\tgcc/cp/\n\t* cp-tree.h (fixup_deferred_exception_variants): Declare.\n\t* parser.c (cp_parser_class_specifier_1): Call it when\n\tcompleting deferred parses rather than creating a variant.\n\t(cp_parser_member_declaration): Move comment from ...\n\t(cp_parser_noexcept_specification_opt): ... here.  Refactor the\n\tdeferred parse.\n\t* tree.c (fixup_deferred_exception_variants): New.", "tree": {"sha": "055b8c78ad9ddd204792b60acb51dbfabc52a6a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/055b8c78ad9ddd204792b60acb51dbfabc52a6a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cee45e49126d18fe2dc8efc83c190662cd41914d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee45e49126d18fe2dc8efc83c190662cd41914d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cee45e49126d18fe2dc8efc83c190662cd41914d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cee45e49126d18fe2dc8efc83c190662cd41914d/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c8b8efa5becb70e04216a60021b835387ffea4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c8b8efa5becb70e04216a60021b835387ffea4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c8b8efa5becb70e04216a60021b835387ffea4e"}], "stats": {"total": 73, "additions": 61, "deletions": 12}, "files": [{"sha": "26852f6f2e3601e84224bdff94cacef2e5960b70", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee45e49126d18fe2dc8efc83c190662cd41914d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee45e49126d18fe2dc8efc83c190662cd41914d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cee45e49126d18fe2dc8efc83c190662cd41914d", "patch": "@@ -7360,6 +7360,7 @@ extern const char *cxx_printable_name_translate\t(tree, int);\n extern tree canonical_eh_spec\t\t\t(tree);\n extern tree build_cp_fntype_variant\t\t(tree, cp_ref_qualifier, tree, bool);\n extern tree build_exception_variant\t\t(tree, tree);\n+extern void fixup_deferred_exception_variants   (tree, tree);\n extern tree bind_template_template_parm\t\t(tree, tree);\n extern tree array_type_nelts_total\t\t(tree);\n extern tree array_type_nelts_top\t\t(tree);"}, {"sha": "274797f1879ea2b3a1732ae985d789b277cb7fa6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee45e49126d18fe2dc8efc83c190662cd41914d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee45e49126d18fe2dc8efc83c190662cd41914d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cee45e49126d18fe2dc8efc83c190662cd41914d", "patch": "@@ -24334,8 +24334,12 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n \t  /* Now we can parse the noexcept-specifier.  */\n \t  spec = cp_parser_late_noexcept_specifier (parser, spec);\n \n-\t  if (spec != error_mark_node)\n-\t    TREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl), spec);\n+\t  if (spec == error_mark_node)\n+\t    spec = NULL_TREE;\n+\n+\t  /* Update the fn's type directly -- it might have escaped\n+\t     beyond this decl :(  */\n+\t  fixup_deferred_exception_variants (TREE_TYPE (decl), spec);\n \n \t  /* Restore the state of local_variables_forbidden_p.  */\n \t  parser->local_variables_forbidden_p = local_variables_forbidden_p;\n@@ -25371,6 +25375,9 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      int ctor_dtor_or_conv_p;\n \t      bool static_p = (decl_specifiers.storage_class == sc_static);\n \t      cp_parser_flags flags = CP_PARSER_FLAGS_TYPENAME_OPTIONAL;\n+\t      /* We can't delay parsing for friends,\n+\t\t alias-declarations, and typedefs, even though the\n+\t\t standard seems to require it.  */\n \t      if (!friend_p\n \t\t  && !decl_spec_seq_has_spec_p (&decl_specifiers, ds_typedef))\n \t\tflags |= CP_PARSER_FLAGS_DELAY_NOEXCEPT;\n@@ -26059,19 +26066,14 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n \t a class.  So, if the noexcept-specifier has the optional expression,\n \t just save the tokens, and reparse this after we're done with the\n \t class.  */\n-      const bool literal_p\n-\t= ((cp_lexer_nth_token_is (parser->lexer, 3, CPP_NUMBER)\n-\t    || cp_lexer_nth_token_is (parser->lexer, 3, CPP_KEYWORD))\n-\t   && cp_lexer_nth_token_is (parser->lexer, 4, CPP_CLOSE_PAREN));\n \n-      if (cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN)\n+      if ((flags & CP_PARSER_FLAGS_DELAY_NOEXCEPT)\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_OPEN_PAREN)\n \t  /* No need to delay parsing for a number literal or true/false.  */\n-\t  && !literal_p\n+\t  && !((cp_lexer_nth_token_is (parser->lexer, 3, CPP_NUMBER)\n+\t\t|| cp_lexer_nth_token_is (parser->lexer, 3, CPP_KEYWORD))\n+\t       && cp_lexer_nth_token_is (parser->lexer, 4, CPP_CLOSE_PAREN))\n \t  && at_class_scope_p ()\n-\t  /* We don't delay parsing for friend member functions,\n-\t     alias-declarations, and typedefs, even though the standard seems\n-\t     to require it.  */\n-\t  && (flags & CP_PARSER_FLAGS_DELAY_NOEXCEPT)\n \t  && TYPE_BEING_DEFINED (current_class_type)\n \t  && !LAMBDA_TYPE_P (current_class_type))\n \treturn cp_parser_save_noexcept (parser);"}, {"sha": "7e763479f7a9248423b5c4bc9b7020171d548605", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cee45e49126d18fe2dc8efc83c190662cd41914d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cee45e49126d18fe2dc8efc83c190662cd41914d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=cee45e49126d18fe2dc8efc83c190662cd41914d", "patch": "@@ -2676,6 +2676,52 @@ build_cp_fntype_variant (tree type, cp_ref_qualifier rqual,\n   return v;\n }\n \n+/* TYPE is a function or method type with a deferred exception\n+   specification that has been parsed to RAISES.  Fixup all the type\n+   variants that are affected in place.  Via decltype &| noexcept\n+   tricks, the unparsed spec could have escaped into the type system.\n+   The general case is hard to fixup canonical types for.  */\n+\n+void\n+fixup_deferred_exception_variants (tree type, tree raises)\n+{\n+  tree original = TYPE_RAISES_EXCEPTIONS (type);\n+  tree cr = flag_noexcept_type ? canonical_eh_spec (raises) : NULL_TREE;\n+\n+  gcc_checking_assert (TREE_CODE (TREE_PURPOSE (original))\n+\t\t       == DEFERRED_PARSE);\n+\n+  /* Though sucky, this walk will process the canonical variants\n+     first.  */\n+  for (tree variant = TYPE_MAIN_VARIANT (type);\n+       variant; variant = TYPE_NEXT_VARIANT (variant))\n+    if (TYPE_RAISES_EXCEPTIONS (variant) == original)\n+      {\n+\tgcc_checking_assert (variant != TYPE_MAIN_VARIANT (type));\n+\n+\tif (!TYPE_STRUCTURAL_EQUALITY_P (variant))\n+\t  {\n+\t    cp_cv_quals var_quals = TYPE_QUALS (variant);\n+\t    cp_ref_qualifier rqual = type_memfn_rqual (variant);\n+\n+\t    tree v = TYPE_MAIN_VARIANT (type);\n+\t    for (; v; v = TYPE_NEXT_VARIANT (v))\n+\t      if (TYPE_CANONICAL (v) == v\n+\t\t  && cp_check_qualified_type (v, variant, var_quals,\n+\t\t\t\t\t      rqual, cr, false))\n+\t\tbreak;\n+\t    TYPE_RAISES_EXCEPTIONS (variant) = raises;\n+\n+\t    if (!v)\n+\t      v = build_cp_fntype_variant (TYPE_CANONICAL (variant),\n+\t\t\t\t\t   rqual, cr, false);\n+\t    TYPE_CANONICAL (variant) = v;\n+\t  }\n+\telse\n+\t  TYPE_RAISES_EXCEPTIONS (variant) = raises;\n+      }\n+}\n+\n /* Build the FUNCTION_TYPE or METHOD_TYPE which may throw exceptions\n    listed in RAISES.  */\n "}]}