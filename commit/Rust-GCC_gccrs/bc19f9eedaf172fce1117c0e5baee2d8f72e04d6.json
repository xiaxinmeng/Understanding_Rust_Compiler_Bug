{"sha": "bc19f9eedaf172fce1117c0e5baee2d8f72e04d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMxOWY5ZWVkYWYxNzJmY2UxMTE3YzBlNWJhZWUyZDhmNzJlMDRkNg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2006-08-06T21:52:04Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2006-08-06T21:52:04Z"}, "message": "re PR libgcj/28576 (PlainDatagramSocketImpl::connect: not implemented yet)\n\n\tPR libgcj/28576:\n\t* gnu/java/net/natPlainDatagramSocketImplPosix.cc (connect):\n\tImplemented.\n\t(disconnect): Likewise.\n\t(send): Handle already-connected case.\n\nFrom-SVN: r115976", "tree": {"sha": "a892abb88f447596d5e38893906e41f83661a10c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a892abb88f447596d5e38893906e41f83661a10c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc19f9eedaf172fce1117c0e5baee2d8f72e04d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc19f9eedaf172fce1117c0e5baee2d8f72e04d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc19f9eedaf172fce1117c0e5baee2d8f72e04d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc19f9eedaf172fce1117c0e5baee2d8f72e04d6/comments", "author": null, "committer": null, "parents": [{"sha": "01b2459cd21b31f3a0328ac6ac951a3b53870493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b2459cd21b31f3a0328ac6ac951a3b53870493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b2459cd21b31f3a0328ac6ac951a3b53870493"}], "stats": {"total": 117, "additions": 85, "deletions": 32}, "files": [{"sha": "39006c655830ee017bfe1d8a0eaad337fc98a6c5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc19f9eedaf172fce1117c0e5baee2d8f72e04d6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc19f9eedaf172fce1117c0e5baee2d8f72e04d6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=bc19f9eedaf172fce1117c0e5baee2d8f72e04d6", "patch": "@@ -1,3 +1,11 @@\n+2006-08-06  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/28576:\n+\t* gnu/java/net/natPlainDatagramSocketImplPosix.cc (connect):\n+\tImplemented.\n+\t(disconnect): Likewise.\n+\t(send): Handle already-connected case.\n+\n 2006-08-04  Mark Wielaard  <mark@klomp.org>\n \n \t* jvmti.cc: Include gcj/method.h."}, {"sha": "0a744c5781e8ff8ef3b14617defe6cd21f3d10be", "filename": "libjava/gnu/java/net/natPlainDatagramSocketImplPosix.cc", "status": "modified", "additions": 77, "deletions": 32, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc19f9eedaf172fce1117c0e5baee2d8f72e04d6/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc19f9eedaf172fce1117c0e5baee2d8f72e04d6/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainDatagramSocketImplPosix.cc?ref=bc19f9eedaf172fce1117c0e5baee2d8f72e04d6", "patch": "@@ -39,6 +39,8 @@ details.  */\n #include <java/lang/Boolean.h>\n #include <java/lang/Integer.h>\n #include <java/net/UnknownHostException.h>\n+#include <java/net/ConnectException.h>\n+#include <java/lang/NullPointerException.h>\n \n union SockAddr\n {\n@@ -149,17 +151,49 @@ gnu::java::net::PlainDatagramSocketImpl::bind (jint lport,\n }\n \n void\n-gnu::java::net::PlainDatagramSocketImpl::connect (::java::net::InetAddress *, jint)\n+gnu::java::net::PlainDatagramSocketImpl::connect (::java::net::InetAddress *host,\n+\t\t\t\t\t\t  jint rport)\n { \n-  throw new ::java::lang::InternalError (JvNewStringLatin1 (\n-\t    \"PlainDatagramSocketImpl::connect: not implemented yet\"));\n+  if (! host)\n+    throw new ::java::lang::NullPointerException;\n+\n+  union SockAddr u;\n+  jbyteArray haddress = host->addr;\n+  jbyte *bytes = elements (haddress);\n+  int len = haddress->length;\n+  struct sockaddr *ptr = (struct sockaddr *) &u.address;\n+  if (len == 4)\n+    {\n+      u.address.sin_family = AF_INET;\n+      memcpy (&u.address.sin_addr, bytes, len);\n+      len = sizeof (struct sockaddr_in);\n+      u.address.sin_port = htons (rport);\n+    }\n+#ifdef HAVE_INET6\n+  else if (len == 16)\n+    {\n+      u.address6.sin6_family = AF_INET6;\n+      memcpy (&u.address6.sin6_addr, bytes, len);\n+      len = sizeof (struct sockaddr_in6);\n+      u.address6.sin6_port = htons (rport);\n+    }\n+#endif\n+  else\n+    throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n+  \n+  if (_Jv_connect (native_fd, ptr, len) == 0)\n+    return;\n+  char* strerr = strerror (errno);\n+  throw new ::java::net::ConnectException (JvNewStringUTF (strerr));\n }\n \n void\n gnu::java::net::PlainDatagramSocketImpl::disconnect ()\n {\n-  throw new ::java::lang::InternalError (JvNewStringLatin1 (\n-\t    \"PlainDatagramSocketImpl::disconnect: not implemented yet\"));\n+  struct sockaddr addr;\n+  addr.sa_family = AF_UNSPEC;\n+  // Ignore errors.  This is lame but apparently required.\n+  _Jv_connect (native_fd, &addr, sizeof (addr));\n }\n \n jint\n@@ -289,39 +323,50 @@ gnu::java::net::PlainDatagramSocketImpl::send (::java::net::DatagramPacket *p)\n {\n   JvSynchronize lock (SEND_LOCK);\n   \n-  // FIXME: Deal with Multicast and if the socket is connected.\n-  jint rport = p->getPort();\n-  union SockAddr u;\n-  ::java::net::InetAddress *host = p->getAddress();\n-  if (! host)\n-    throw new ::java::net::UnknownHostException(p->toString());\n+  // FIXME: Deal with Multicast.\n \n-  jbyteArray haddress = host->addr;\n-  jbyte *bytes = elements (haddress);\n-  int len = haddress->length;\n-  struct sockaddr *ptr = (struct sockaddr *) &u.address;\n-  jbyte *dbytes = elements (p->getData()) + p->getOffset();\n-  if (len == 4)\n+  ::java::net::InetAddress *host = p->getAddress();\n+  if (host == NULL)\n     {\n-      u.address.sin_family = AF_INET;\n-      memcpy (&u.address.sin_addr, bytes, len);\n-      len = sizeof (struct sockaddr_in);\n-      u.address.sin_port = htons (rport);\n+      // If there is no host, maybe this socket was connected, in\n+      // which case we try a plain send().\n+      jbyte *dbytes = elements (p->getData()) + p->getOffset();\n+      if (::send (native_fd, (char *) dbytes, p->getLength(), 0) >= 0)\n+\treturn;\n     }\n-#ifdef HAVE_INET6\n-  else if (len == 16)\n+  else\n     {\n-      u.address6.sin6_family = AF_INET6;\n-      memcpy (&u.address6.sin6_addr, bytes, len);\n-      len = sizeof (struct sockaddr_in6);\n-      u.address6.sin6_port = htons (rport);\n-    }\n+      jint rport = p->getPort();\n+      union SockAddr u;\n+\n+      jbyteArray haddress = host->addr;\n+      jbyte *bytes = elements (haddress);\n+      int len = haddress->length;\n+      struct sockaddr *ptr = (struct sockaddr *) &u.address;\n+      jbyte *dbytes = elements (p->getData()) + p->getOffset();\n+      if (len == 4)\n+\t{\n+\t  u.address.sin_family = AF_INET;\n+\t  memcpy (&u.address.sin_addr, bytes, len);\n+\t  len = sizeof (struct sockaddr_in);\n+\t  u.address.sin_port = htons (rport);\n+\t}\n+#ifdef HAVE_INET6\n+      else if (len == 16)\n+\t{\n+\t  u.address6.sin6_family = AF_INET6;\n+\t  memcpy (&u.address6.sin6_addr, bytes, len);\n+\t  len = sizeof (struct sockaddr_in6);\n+\t  u.address6.sin6_port = htons (rport);\n+\t}\n #endif\n-  else\n-    throw new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n+      else\n+\tthrow new ::java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (::sendto (native_fd, (char *) dbytes, p->getLength(), 0, ptr, len) >= 0)\n-    return;\n+      if (::sendto (native_fd, (char *) dbytes, p->getLength(), 0, ptr, len)\n+\t  >= 0)\n+\treturn;\n+    }\n \n   char* strerr = strerror (errno);\n "}]}