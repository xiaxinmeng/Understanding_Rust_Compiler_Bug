{"sha": "4ed43ff85a14916fd33bdf838f9c40b923e312ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVkNDNmZjg1YTE0OTE2ZmQzM2JkZjgzOGY5YzQwYjkyM2UzMTJhYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-04-04T13:54:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-04-04T13:54:32Z"}, "message": "haifa-sched.c (split_block_insns): Don't supress insn splitting on subsequent passes.\n\n* haifa-sched.c (split_block_insns): Don't supress insn splitting\non subsequent passes.\n* alpha.c (hard_fp_register_operand): New function.\n* alpha.h (PREDICATE_CODES): Add it.\n* alpha.md (extendsidi2): Kill bogus f<-f cvtql+cvtlq case.  Add an\nf<-m case and accompanying define_split.\n(trapb): Use a unique unspec_volatile number.\n\nFrom-SVN: r18992", "tree": {"sha": "fccd367314057d62ee9a166712156cd219f140ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fccd367314057d62ee9a166712156cd219f140ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ed43ff85a14916fd33bdf838f9c40b923e312ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed43ff85a14916fd33bdf838f9c40b923e312ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ed43ff85a14916fd33bdf838f9c40b923e312ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed43ff85a14916fd33bdf838f9c40b923e312ab/comments", "author": null, "committer": null, "parents": [{"sha": "55a9eb72632155cf329d5307050e5b07087cd8ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a9eb72632155cf329d5307050e5b07087cd8ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a9eb72632155cf329d5307050e5b07087cd8ff"}], "stats": {"total": 127, "additions": 90, "deletions": 37}, "files": [{"sha": "6f36affcdc08233392577571c6b17fceb025b33c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ed43ff85a14916fd33bdf838f9c40b923e312ab", "patch": "@@ -1,3 +1,14 @@\n+Sat Apr  4 13:50:01 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* haifa-sched.c (split_block_insns): Don't supress insn splitting\n+\ton subsequent passes.\n+\n+\t* alpha.c (hard_fp_register_operand): New function.\n+\t* alpha.h (PREDICATE_CODES): Add it.\n+\t* alpha.md (extendsidi2): Kill bogus f<-f cvtql+cvtlq case.  Add an\n+\tf<-m case and accompanying define_split.\n+\t(trapb): Use a unique unspec_volatile number.\n+\n Sat Apr  4 13:32:08 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* configure.in (alpha-*-linux-gnu*): Undo Feb 3 change brought in"}, {"sha": "3888b984ccd56f93fdfa7eceb9d8ca5528488de6", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4ed43ff85a14916fd33bdf838f9c40b923e312ab", "patch": "@@ -519,6 +519,18 @@ reg_or_fp0_operand (op, mode)\n   return fp0_operand (op, mode) || register_operand (op, mode);\n }\n \n+/* Return 1 if OP is a hard floating-point register.  */\n+\n+int\n+hard_fp_register_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return ((GET_CODE (op) == REG && REGNO_REG_CLASS (REGNO (op)) == FLOAT_REGS)\n+\t  || (GET_CODE (op) == SUBREG\n+\t      && hard_fp_register_operand (SUBREG_REG (op), mode)));\n+}\n+\n /* Return 1 if OP is a register or a constant integer.  */\n \n "}, {"sha": "da8f6968159dbdbba0f311941da681c2cfa6ff69", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=4ed43ff85a14916fd33bdf838f9c40b923e312ab", "patch": "@@ -2211,7 +2211,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"aligned_memory_operand\", {MEM}},\t\t\t\\\n   {\"unaligned_memory_operand\", {MEM}},\t\t\t\\\n   {\"reg_or_unaligned_mem_operand\", {SUBREG, REG, MEM}},\t\\\n-  {\"any_memory_operand\", {MEM}},\n+  {\"any_memory_operand\", {MEM}},\t\t\t\\\n+  {\"hard_fp_register_operand\", {SUBREG, REG}},\n \f\n /* Tell collect that the object format is ECOFF.  */\n #define OBJECT_FORMAT_COFF"}, {"sha": "93f7e5f3bad4da410159c04d04ceaa6e548ef92b", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=4ed43ff85a14916fd33bdf838f9c40b923e312ab", "patch": "@@ -20,6 +20,23 @@\n ;; Boston, MA 02111-1307, USA.\n \n ;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; Uses of UNSPEC in this file:\n+;;\n+;;\t0\targ_home\n+;;\t1\tcttz\n+;;\t2\tinsxh\n+;;\t3\tmskxh\n+;;\t4\tcvtlq\n+;;\t\n+;; UNSPEC_VOLATILE:\n+;;\n+;;\t0\timb\n+;;\t1\tblockage\n+;;\t2\tbuiltin_setjmp_receiver\n+;;\t3\tbuiltin_longjmp\n+;;\t4\ttrapb\n+\n \f\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in alpha.h.\n@@ -343,27 +360,47 @@\n ; ??? The FPU communicates with memory and the integer register file\n ; via two fp store units.  We need a slot in the fst immediately, and\n ; a slot in LOW after the operand data is ready.  At which point the\n-; data may be movedeither to the store queue or the integer register\n+; data may be moved either to the store queue or the integer register\n ; file and the insn retired.\n \n \f\n ;; First define the arithmetic insns.  Note that the 32-bit forms also\n ;; sign-extend.\n \n-;; Note that we can do sign extensions in both FP and integer registers.\n-;; However, the result must be in the same type of register as the input.\n-;; The register preferencing code can't handle this case very well, so, for\n-;; now, don't let the FP case show up here for preferencing.  Also,\n-;; sign-extends in FP registers take two instructions.\n+;; Handle 32-64 bit extension from memory to a floating point register\n+;; specially, since this ocurrs frequently in int->double conversions.\n+;; This is done with a define_split after reload converting the plain\n+;; sign-extension into a load+unspec, which of course results in lds+cvtlq.\n+;;\n+;; Note that while we must retain the =f case in the insn for reload's\n+;; benefit, it should be eliminated after reload, so we should never emit\n+;; code for that case.  But we don't reject the possibility.\n+\n (define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,*f\")\n-\t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"r,m,*f\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,?f\")\n+\t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"r,m,m\")))]\n   \"\"\n   \"@\n    addl %1,$31,%0\n    ldl %0,%1\n-   cvtql %1,%0\\;cvtlq %0,%0\"\n-  [(set_attr \"type\" \"iadd,ild,fadd\")])\n+   lds %0,%1\\;cvtlq %0,%0\"\n+  [(set_attr \"type\" \"iadd,ild,fld\")])\n+\n+;; Due to issues with CLASS_CANNOT_CHANGE_SIZE, we cannot use a subreg here.\n+(define_split\n+  [(set (match_operand:DI 0 \"hard_fp_register_operand\" \"\")\n+\t(sign_extend:DI (match_operand:SI 1 \"memory_operand\" \"\")))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (unspec:DI [(match_dup 2)] 4))]\n+  \"operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]));\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(unspec:DI [(match_operand:SI 1 \"register_operand\" \"f\")] 4))]\n+  \"\"\n+  \"cvtlq %1,%0\"\n+  [(set_attr \"type\" \"fadd\")])\n \n ;; Do addsi3 the way expand_binop would do if we didn't have one.  This\n ;; generates better code.  We have the anonymous addsi3 pattern below in\n@@ -5122,7 +5159,7 @@\n ;; by alpha_reorg.\n \n (define_insn \"trapb\"\n-  [(unspec_volatile [(const_int 0)] 3)]\n+  [(unspec_volatile [(const_int 0)] 4)]\n   \"\"\n   \"trapb\"\n   [(set_attr \"type\" \"misc\")])"}, {"sha": "43e5264d0848bff2d6d11c8790a573aebd08af5e", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed43ff85a14916fd33bdf838f9c40b923e312ab/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4ed43ff85a14916fd33bdf838f9c40b923e312ab", "patch": "@@ -8234,8 +8234,7 @@ split_block_insns (b)\n \n   for (insn = basic_block_head[b];; insn = next)\n     {\n-      rtx prev;\n-      rtx set;\n+      rtx set, last, first, notes;\n \n       /* Can't use `next_real_insn' because that\n          might go across CODE_LABELS and short-out basic blocks.  */\n@@ -8272,31 +8271,24 @@ split_block_insns (b)\n \t}\n \n       /* Split insns here to get max fine-grain parallelism.  */\n-      prev = PREV_INSN (insn);\n-      /* It is probably not worthwhile to try to split again in\n-\t the second pass.  However, if flag_schedule_insns is not set,\n-\t the first and only (if any) scheduling pass is after reload.  */\n-      if (reload_completed == 0 || ! flag_schedule_insns)\n+      first = PREV_INSN (insn);\n+      notes = REG_NOTES (insn);\n+      last = try_split (PATTERN (insn), insn, 1);\n+      if (last != insn)\n \t{\n-\t  rtx last, first = PREV_INSN (insn);\n-\t  rtx notes = REG_NOTES (insn);\n-\t  last = try_split (PATTERN (insn), insn, 1);\n-\t  if (last != insn)\n+\t  /* try_split returns the NOTE that INSN became.  */\n+\t  first = NEXT_INSN (first);\n+\t  update_flow_info (notes, first, last, insn);\n+\n+\t  PUT_CODE (insn, NOTE);\n+\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t  if (insn == basic_block_head[b])\n+\t    basic_block_head[b] = first;\n+\t  if (insn == basic_block_end[b])\n \t    {\n-\t      /* try_split returns the NOTE that INSN became.  */\n-\t      first = NEXT_INSN (first);\n-\t      update_flow_info (notes, first, last, insn);\n-\n-\t      PUT_CODE (insn, NOTE);\n-\t      NOTE_SOURCE_FILE (insn) = 0;\n-\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t      if (insn == basic_block_head[b])\n-\t\tbasic_block_head[b] = first;\n-\t      if (insn == basic_block_end[b])\n-\t\t{\n-\t\t  basic_block_end[b] = last;\n-\t\t  break;\n-\t\t}\n+\t      basic_block_end[b] = last;\n+\t      break;\n \t    }\n \t}\n "}]}