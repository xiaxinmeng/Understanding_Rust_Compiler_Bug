{"sha": "5297e08564adcb6d396d0870df9c1df1d2c6aab9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI5N2UwODU2NGFkY2I2ZDM5NmQwODcwZGY5YzFkZjFkMmM2YWFiOQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2001-10-21T19:44:08Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2001-10-21T19:44:08Z"}, "message": "arm.h (FUNCTION_ARG_REGNO_P): Use IN_RANGE.\n\n\t* arm.h (FUNCTION_ARG_REGNO_P): Use IN_RANGE.\n\n\t* system.h (IN_RANGE): New macro.\n\nFrom-SVN: r46395", "tree": {"sha": "50a7ccac927ff3fce5b7e2bad6d5a896b3c10f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50a7ccac927ff3fce5b7e2bad6d5a896b3c10f83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5297e08564adcb6d396d0870df9c1df1d2c6aab9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5297e08564adcb6d396d0870df9c1df1d2c6aab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5297e08564adcb6d396d0870df9c1df1d2c6aab9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5297e08564adcb6d396d0870df9c1df1d2c6aab9/comments", "author": null, "committer": null, "parents": [{"sha": "77c068446e143cc8f95e276eadee7528f3142105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77c068446e143cc8f95e276eadee7528f3142105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77c068446e143cc8f95e276eadee7528f3142105"}], "stats": {"total": 19, "additions": 17, "deletions": 2}, "files": [{"sha": "9e8abcc450563eae96dc8e04208cfe0bf40ad9b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5297e08564adcb6d396d0870df9c1df1d2c6aab9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5297e08564adcb6d396d0870df9c1df1d2c6aab9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5297e08564adcb6d396d0870df9c1df1d2c6aab9", "patch": "@@ -1,3 +1,9 @@\n+2001-10-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* arm.h (FUNCTION_ARG_REGNO_P): Use IN_RANGE.\n+\n+\t* system.h (IN_RANGE): New macro.\n+\n 2001-10-21  Zack Weinberg  <zack@codesourcery.com>\n \n \t* aclocal.m4 (AM_WITH_NLS): Also create and substitute"}, {"sha": "7347298772f90e0d84c5aad03599f8c94af96bc6", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5297e08564adcb6d396d0870df9c1df1d2c6aab9/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5297e08564adcb6d396d0870df9c1df1d2c6aab9/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=5297e08564adcb6d396d0870df9c1df1d2c6aab9", "patch": "@@ -1505,8 +1505,7 @@ typedef struct\n \n /* 1 if N is a possible register number for function argument passing.\n    On the ARM, r0-r3 are used to pass args.  */\n-#define FUNCTION_ARG_REGNO_P(REGNO)  \\\n-  ((REGNO) >= 0 && (REGNO) <= 3)\n+#define FUNCTION_ARG_REGNO_P(REGNO)\t(IN_RANGE ((REGNO), 0, 3))\n \n \f\n /* Tail calling.  */"}, {"sha": "7cf3b5fe8bf79cd6ca3a08da2ee5d1e3e856af0d", "filename": "gcc/system.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5297e08564adcb6d396d0870df9c1df1d2c6aab9/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5297e08564adcb6d396d0870df9c1df1d2c6aab9/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=5297e08564adcb6d396d0870df9c1df1d2c6aab9", "patch": "@@ -168,6 +168,16 @@ extern int errno;\n /* Get definitions of HOST_WIDE_INT and HOST_WIDEST_INT.  */\n #include \"hwint.h\"\n \n+/* A macro to determine whether a VALUE lies inclusively within a\n+   certain range without evaluating the VALUE more than once.  This\n+   macro won't warn if the VALUE is unsigned and the LOWER bound is\n+   zero, as it would e.g. with \"VALUE >= 0 && ...\".  Note the LOWER\n+   bound *is* evaluated twice, and LOWER must not be greater than\n+   UPPER.  However the bounds themselves can be either positive or\n+   negative.  */\n+#define IN_RANGE(VALUE, LOWER, UPPER) \\\n+  ((unsigned HOST_WIDE_INT)((VALUE) - (LOWER)) <= ((UPPER) - (LOWER)))\n+\n /* Infrastructure for defining missing _MAX and _MIN macros.  Note that\n    macros defined with these cannot be used in #if.  */\n "}]}