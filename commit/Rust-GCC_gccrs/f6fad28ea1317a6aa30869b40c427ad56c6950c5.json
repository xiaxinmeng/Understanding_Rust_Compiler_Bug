{"sha": "f6fad28ea1317a6aa30869b40c427ad56c6950c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZmYWQyOGVhMTMxN2E2YWEzMDg2OWI0MGM0MjdhZDU2YzY5NTBjNQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-08-08T18:19:46Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-08-08T18:19:46Z"}, "message": "gfortran.h (gfc_finalizer): Replaced member `procedure' by two new members `proc_sym' and `proc_tree' to...\n\n2008-08-08  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (gfc_finalizer):  Replaced member `procedure' by two\n\tnew members `proc_sym' and `proc_tree' to store the symtree after\n\tresolution.\n\t(gfc_find_sym_in_symtree):  Made public.\n\t* decl.c (gfc_match_final_decl):  Adapted for new member name.\n\t* interface.c (gfc_find_sym_in_symtree):  Made public.\n\t(gfc_extend_expr), (gfc_extend_assign):  Changed call accordingly.\n\t* module.c (mio_finalizer), (mio_f2k_derived), (mio_full_f2k_derived):\n\tNew methods for module-file IO of f2k_derived.\n\t(mio_symbol):  Do IO of f2k_derived namespace.\n\t* resolve.c (gfc_resolve_finalizers):  Adapted for new member name and\n\tfinding the symtree for the symbol here.\n\t* symbol.c (gfc_free_finalizer):  Adapted for new members.\n\n2008-08-08  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/finalize_9.f03:  New test.\n\t* gfortran.dg/module_md5_1.f90:  Adapted MD5-sum for changed module\n\tfile format.\n\nFrom-SVN: r138884", "tree": {"sha": "678252b637e4e677cc46910a5305aa008a9af981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/678252b637e4e677cc46910a5305aa008a9af981"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6fad28ea1317a6aa30869b40c427ad56c6950c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6fad28ea1317a6aa30869b40c427ad56c6950c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6fad28ea1317a6aa30869b40c427ad56c6950c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6fad28ea1317a6aa30869b40c427ad56c6950c5/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174ef36d7223171145b3d3eed56b6ebb9a5d63d9"}], "stats": {"total": 173, "additions": 153, "deletions": 20}, "files": [{"sha": "9b51d994826e44475baa1e312f24743ce56e321a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -1,3 +1,19 @@\n+2008-08-08  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (gfc_finalizer):  Replaced member `procedure' by two\n+\tnew members `proc_sym' and `proc_tree' to store the symtree after\n+\tresolution.\n+\t(gfc_find_sym_in_symtree):  Made public.\n+\t* decl.c (gfc_match_final_decl):  Adapted for new member name.\n+\t* interface.c (gfc_find_sym_in_symtree):  Made public.\n+\t(gfc_extend_expr), (gfc_extend_assign):  Changed call accordingly.\n+\t* module.c (mio_finalizer), (mio_f2k_derived), (mio_full_f2k_derived):\n+\tNew methods for module-file IO of f2k_derived.\n+\t(mio_symbol):  Do IO of f2k_derived namespace.\n+\t* resolve.c (gfc_resolve_finalizers):  Adapted for new member name and\n+\tfinding the symtree for the symbol here.\n+\t* symbol.c (gfc_free_finalizer):  Adapted for new members.\n+\n 2008-07-30  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* gfc-internals.texi: Update to GFDL 1.2.  Do not list GPL as"}, {"sha": "2b4bda1fa7ff29e8409dcc8d4f8293d77d9e59ab", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -6682,6 +6682,7 @@ gfc_match_enumerator_def (void)\n \n }\n \n+\n /* Match a FINAL declaration inside a derived type.  */\n \n match\n@@ -6762,7 +6763,7 @@ gfc_match_final_decl (void)\n \n       /* Check if we already have this symbol in the list, this is an error.  */\n       for (f = gfc_current_block ()->f2k_derived->finalizers; f; f = f->next)\n-\tif (f->procedure == sym)\n+\tif (f->proc_sym == sym)\n \t  {\n \t    gfc_error (\"'%s' at %C is already defined as FINAL procedure!\",\n \t\t       name);\n@@ -6773,7 +6774,8 @@ gfc_match_final_decl (void)\n       gcc_assert (gfc_current_block ()->f2k_derived);\n       ++sym->refs;\n       f = XCNEW (gfc_finalizer);\n-      f->procedure = sym;\n+      f->proc_sym = sym;\n+      f->proc_tree = NULL;\n       f->where = gfc_current_locus;\n       f->next = gfc_current_block ()->f2k_derived->finalizers;\n       gfc_current_block ()->f2k_derived->finalizers = f;"}, {"sha": "e315cdece82b3b5678667f7f7cb980fa04431ae6", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -1958,10 +1958,20 @@ extern iterator_stack *iter_stack;\n typedef struct gfc_finalizer\n {\n   struct gfc_finalizer* next;\n-  gfc_symbol* procedure;\n   locus where; /* Where the FINAL declaration occurred.  */\n+\n+  /* Up to resolution, we want the gfc_symbol, there we lookup the corresponding\n+     symtree and later need only that.  This way, we can access and call the\n+     finalizers from every context as they should be \"always accessible\".  I\n+     don't make this a union because we need the information whether proc_sym is\n+     still referenced or not for dereferencing it on deleting a gfc_finalizer\n+     structure.  */\n+  gfc_symbol*  proc_sym;\n+  gfc_symtree* proc_tree; \n }\n gfc_finalizer;\n+#define gfc_get_finalizer() XCNEW (gfc_finalizer)\n+\n \n /************************ Function prototypes *************************/\n \n@@ -2399,6 +2409,7 @@ gfc_try gfc_extend_assign (gfc_code *, gfc_namespace *);\n gfc_try gfc_add_interface (gfc_symbol *);\n gfc_interface *gfc_current_interface_head (void);\n void gfc_set_current_interface_head (gfc_interface *);\n+gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "ba384013032f1d7e215d4af6982cfcbe4d17ef80", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -2513,8 +2513,8 @@ find_symtree0 (gfc_symtree *root, gfc_symbol *sym)\n \n /* Find a symtree for a symbol.  */\n \n-static gfc_symtree *\n-find_sym_in_symtree (gfc_symbol *sym)\n+gfc_symtree *\n+gfc_find_sym_in_symtree (gfc_symbol *sym)\n {\n   gfc_symtree *st;\n   gfc_namespace *ns;\n@@ -2652,7 +2652,7 @@ gfc_extend_expr (gfc_expr *e)\n \n   /* Change the expression node to a function call.  */\n   e->expr_type = EXPR_FUNCTION;\n-  e->symtree = find_sym_in_symtree (sym);\n+  e->symtree = gfc_find_sym_in_symtree (sym);\n   e->value.function.actual = actual;\n   e->value.function.esym = NULL;\n   e->value.function.isym = NULL;\n@@ -2718,7 +2718,7 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n \n   /* Replace the assignment with the call.  */\n   c->op = EXEC_ASSIGN_CALL;\n-  c->symtree = find_sym_in_symtree (sym);\n+  c->symtree = gfc_find_sym_in_symtree (sym);\n   c->expr = NULL;\n   c->expr2 = NULL;\n   c->ext.actual = actual;"}, {"sha": "7da5be16b56168fe55c101951d0e73fb07c219be", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -3168,6 +3168,78 @@ mio_namespace_ref (gfc_namespace **nsp)\n }\n \n \n+/* Save/restore the f2k_derived namespace of a derived-type symbol.  */\n+\n+static void\n+mio_finalizer (gfc_finalizer **f)\n+{\n+  if (iomode == IO_OUTPUT)\n+    {\n+      gcc_assert (*f);\n+      gcc_assert ((*f)->proc_tree); /* Should already be resolved.  */\n+      mio_symtree_ref (&(*f)->proc_tree);\n+    }\n+  else\n+    {\n+      *f = gfc_get_finalizer ();\n+      (*f)->where = gfc_current_locus; /* Value should not matter.  */\n+      (*f)->next = NULL;\n+\n+      mio_symtree_ref (&(*f)->proc_tree);\n+      (*f)->proc_sym = NULL;\n+    }\n+}\n+\n+static void\n+mio_f2k_derived (gfc_namespace *f2k)\n+{\n+  /* Handle the list of finalizer procedures.  */\n+  mio_lparen ();\n+  if (iomode == IO_OUTPUT)\n+    {\n+      gfc_finalizer *f;\n+      for (f = f2k->finalizers; f; f = f->next)\n+\tmio_finalizer (&f);\n+    }\n+  else\n+    {\n+      f2k->finalizers = NULL;\n+      while (peek_atom () != ATOM_RPAREN)\n+\t{\n+\t  gfc_finalizer *cur;\n+\t  mio_finalizer (&cur);\n+\t  cur->next = f2k->finalizers;\n+\t  f2k->finalizers = cur;\n+\t}\n+    }\n+  mio_rparen ();\n+}\n+\n+static void\n+mio_full_f2k_derived (gfc_symbol *sym)\n+{\n+  mio_lparen ();\n+  \n+  if (iomode == IO_OUTPUT)\n+    {\n+      if (sym->f2k_derived)\n+\tmio_f2k_derived (sym->f2k_derived);\n+    }\n+  else\n+    {\n+      if (peek_atom () != ATOM_RPAREN)\n+\t{\n+\t  sym->f2k_derived = gfc_get_namespace (NULL, 0);\n+\t  mio_f2k_derived (sym->f2k_derived);\n+\t}\n+      else\n+\tgcc_assert (!sym->f2k_derived);\n+    }\n+\n+  mio_rparen ();\n+}\n+\n+\n /* Unlike most other routines, the address of the symbol node is already\n    fixed on input and the name/module has already been filled in.  */\n \n@@ -3230,6 +3302,9 @@ mio_symbol (gfc_symbol *sym)\n     sym->component_access\n       = MIO_NAME (gfc_access) (sym->component_access, access_types);\n \n+  /* Load/save the f2k_derived namespace of a derived-type symbol.  */\n+  mio_full_f2k_derived (sym);\n+\n   mio_namelist (sym);\n \n   /* Add the fields that say whether this is from an intrinsic module,"}, {"sha": "c6a241a85458e5cfb1307fa2947f23dcddfbc582", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -7472,22 +7472,29 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n       gfc_finalizer* i;\n       int my_rank;\n \n+      /* Skip this finalizer if we already resolved it.  */\n+      if (list->proc_tree)\n+\t{\n+\t  prev_link = &(list->next);\n+\t  continue;\n+\t}\n+\n       /* Check this exists and is a SUBROUTINE.  */\n-      if (!list->procedure->attr.subroutine)\n+      if (!list->proc_sym->attr.subroutine)\n \t{\n \t  gfc_error (\"FINAL procedure '%s' at %L is not a SUBROUTINE\",\n-\t\t     list->procedure->name, &list->where);\n+\t\t     list->proc_sym->name, &list->where);\n \t  goto error;\n \t}\n \n       /* We should have exactly one argument.  */\n-      if (!list->procedure->formal || list->procedure->formal->next)\n+      if (!list->proc_sym->formal || list->proc_sym->formal->next)\n \t{\n \t  gfc_error (\"FINAL procedure at %L must have exactly one argument\",\n \t\t     &list->where);\n \t  goto error;\n \t}\n-      arg = list->procedure->formal->sym;\n+      arg = list->proc_sym->formal->sym;\n \n       /* This argument must be of our type.  */\n       if (arg->ts.type != BT_DERIVED || arg->ts.derived != derived)\n@@ -7541,16 +7548,16 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n \t{\n \t  /* Argument list might be empty; that is an error signalled earlier,\n \t     but we nevertheless continued resolving.  */\n-\t  if (i->procedure->formal)\n+\t  if (i->proc_sym->formal)\n \t    {\n-\t      gfc_symbol* i_arg = i->procedure->formal->sym;\n+\t      gfc_symbol* i_arg = i->proc_sym->formal->sym;\n \t      const int i_rank = (i_arg->as ? i_arg->as->rank : 0);\n \t      if (i_rank == my_rank)\n \t\t{\n \t\t  gfc_error (\"FINAL procedure '%s' declared at %L has the same\"\n \t\t\t     \" rank (%d) as '%s'\",\n-\t\t\t     list->procedure->name, &list->where, my_rank, \n-\t\t\t     i->procedure->name);\n+\t\t\t     list->proc_sym->name, &list->where, my_rank, \n+\t\t\t     i->proc_sym->name);\n \t\t  goto error;\n \t\t}\n \t    }\n@@ -7560,6 +7567,10 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n \tif (!arg->as || arg->as->rank == 0)\n \t  seen_scalar = true;\n \n+\t/* Find the symtree for this procedure.  */\n+\tgcc_assert (!list->proc_tree);\n+\tlist->proc_tree = gfc_find_sym_in_symtree (list->proc_sym);\n+\n \tprev_link = &list->next;\n \tcontinue;\n \n@@ -7581,7 +7592,8 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n \t\t derived->name, &derived->declared_at);\n \n   /* TODO:  Remove this error when finalization is finished.  */\n-  gfc_error (\"Finalization at %L is not yet implemented\", &derived->declared_at);\n+  gfc_error (\"Finalization at %L is not yet implemented\",\n+\t     &derived->declared_at);\n \n   return result;\n }"}, {"sha": "bf709fae5c4073ee54b6de91bdc12925e5db33fc", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -2965,9 +2965,12 @@ gfc_free_finalizer (gfc_finalizer* el)\n {\n   if (el)\n     {\n-      --el->procedure->refs;\n-      if (!el->procedure->refs)\n-\tgfc_free_symbol (el->procedure);\n+      if (el->proc_sym)\n+\t{\n+\t  --el->proc_sym->refs;\n+\t  if (!el->proc_sym->refs)\n+\t    gfc_free_symbol (el->proc_sym);\n+\t}\n \n       gfc_free (el);\n     }"}, {"sha": "4ff5fd85533cce702d957c90091b9f3dd2d58011", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -1,3 +1,9 @@\n+2008-08-08  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/finalize_9.f03:  New test.\n+\t* gfortran.dg/module_md5_1.f90:  Adapted MD5-sum for changed module\n+\tfile format.\n+\n 2008-08-08  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/ssa-ccp-20.c: New testcase."}, {"sha": "464036efc388532a0cf75349031a5667b9a5e0c2", "filename": "gcc/testsuite/gfortran.dg/finalize_9.f03", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_9.f03?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do compile }\n+\n+! Parsing of finalizer procedure definitions.\n+! While ALLOCATABLE scalars are not implemented, this even used to ICE.\n+! Thanks Tobias Burnus for the test!\n+\n+integer, allocatable :: x ! { dg-error \"may not be ALLOCATABLE\" }\n+end"}, {"sha": "f52426fbd002a893451246bc24fb3c7ceb1b8e63", "filename": "gcc/testsuite/gfortran.dg/module_md5_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6fad28ea1317a6aa30869b40c427ad56c6950c5/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_md5_1.f90?ref=f6fad28ea1317a6aa30869b40c427ad56c6950c5", "patch": "@@ -10,5 +10,5 @@ program test\n   use foo\n   print *, pi\n end program test\n-! { dg-final { scan-module \"foo\" \"MD5:2350094d1d87eb25ab22af5f8e96e011\" } }\n+! { dg-final { scan-module \"foo\" \"MD5:596df8f39d3ddc0b847771cadcb26274\" } }\n ! { dg-final { cleanup-modules \"foo\" } }"}]}