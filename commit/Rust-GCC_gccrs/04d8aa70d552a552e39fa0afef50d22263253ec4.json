{"sha": "04d8aa70d552a552e39fa0afef50d22263253ec4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRkOGFhNzBkNTUyYTU1MmUzOWZhMGFmZWY1MGQyMjI2MzI1M2VjNA==", "commit": {"author": {"name": "Alan Matsuoka", "email": "alanm@gcc.gnu.org", "date": "2001-11-14T20:17:08Z"}, "committer": {"name": "Alan Matsuoka", "email": "alanm@gcc.gnu.org", "date": "2001-11-14T20:17:08Z"}, "message": "rtl.def (INCLUDE): Define.\n\n\n2001-11-05  Alan Matsuoka  <alanm@redhat.com>\n\n\t* rtl.def (INCLUDE) : Define.\n\t* gensupport.c  (init_include_reader, process_include,\n\tsave_string) :  New functions to implement an include facility\n\tin .md files.\n\t* gensupport.h : Add prototype for init_md_reader_args.  *\n\tgenattr.c genattrtab.c gencodes.c genconfig.c genemit.c\n\tgenextract.c genflags.c genopinit.c genoutput.c\n\tgenpeep.c genrecog.c: Change call to init_md_reader to\n\tinit_md_reader_args.\n\t* md.texi: Document (include \"path\") and -I directives for RTL\n\tgeneration tools.\n\nFrom-SVN: r47020", "tree": {"sha": "7e7026a3d373191f37d9ff6e97e059f2d8c5096d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e7026a3d373191f37d9ff6e97e059f2d8c5096d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04d8aa70d552a552e39fa0afef50d22263253ec4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04d8aa70d552a552e39fa0afef50d22263253ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04d8aa70d552a552e39fa0afef50d22263253ec4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04d8aa70d552a552e39fa0afef50d22263253ec4/comments", "author": null, "committer": null, "parents": [{"sha": "497786446ba35ea6814862bcd76851e1379653ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497786446ba35ea6814862bcd76851e1379653ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497786446ba35ea6814862bcd76851e1379653ab"}], "stats": {"total": 346, "additions": 334, "deletions": 12}, "files": [{"sha": "f8ecb2a1b6dd9f22682f89238bce0b0e209a5ae8", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -38,6 +38,7 @@ See the next chapter for information on the C header file.\n * Expander Definitions::Generating a sequence of several RTL insns\n                           for a standard operation.\n * Insn Splitting::      Splitting Instructions into Multiple Instructions.\n+* Including Patterns::      Including Patterns in Machine Descriptions.\n * Peephole Definitions::Defining machine-specific peephole optimizations.\n * Insn Attributes::     Specifying the value of attributes for generated insns.\n * Conditional Execution::Generating @code{define_insn} patterns for\n@@ -3910,6 +3911,80 @@ functionality as two separate @code{define_insn} and @code{define_split}\n patterns.  It exists for compactness, and as a maintenance tool to prevent\n having to ensure the two patterns' templates match.\n \n+@node Including Patterns\n+@section Including Patterns in Machine Descriptions.\n+@cindex insn includes\n+\n+@findex include\n+The @code{include} pattern tells the compiler tools where to\n+look for patterns that are in files other than in the file\n+@file{.md}. This is used only at build time and there is no preprocessing allowed.\n+\n+It looks like:\n+\n+@smallexample\n+\n+(include\n+  @var{pathname})\n+@end smallexample\n+\n+For example:\n+\n+@smallexample\n+\n+(include \"filestuff\") \n+\n+@end smallexample\n+\n+Where @var{pathname} is a string that specifies the the location of the file,\n+specifies the include file to be in @file{gcc/config/target/filestuff}. The\n+directory @file{gcc/config/target} is regarded as the default directory.\n+\n+\n+Machine descriptions may be split up into smaller more manageable subsections \n+and placed into subdirectories. \n+\n+By specifying:\n+\n+@smallexample\n+\n+(include \"BOGUS/filestuff\") \n+\n+@end smallexample\n+\n+the include file is specified to be in @file{gcc/config/@var{target}/BOGUS/filestuff}.\n+\n+Specifying an absolute path for the include file such as;\n+@smallexample\n+\n+(include \"/u2/BOGUS/filestuff\") \n+\n+@end smallexample\n+is permitted but is not encouraged. \n+\n+@subsection RTL Generation Tool Options for Directory Search\n+@cindex directory options .md\n+@cindex options, directory search\n+@cindex search options\n+\n+The @option{-I@var{dir}} option specifies directories to search for machine descriptions.\n+For example:\n+\n+@smallexample\n+\n+genrecog -I/p1/abc/proc1 -I/p2/abcd/pro2 target.md\n+\n+@end smallexample\n+\n+\n+Add the directory @var{dir} to the head of the list of directories to be\n+searched for header files.  This can be used to override a system machine definition\n+file, substituting your own version, since these directories are\n+searched before the default machine description file directories.  If you use more than\n+one @option{-I} option, the directories are scanned in left-to-right\n+order; the standard default directory come after.\n+\n+\n @node Peephole Definitions\n @section Machine-Specific Peephole Optimizers\n @cindex peephole optimizer definitions"}, {"sha": "4f9c712b6091100d0e1215be29a507217888a24d", "filename": "gcc/genattr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -210,7 +210,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   puts (\"/* Generated automatically by the program `genattr'\");"}, {"sha": "8b65fc80fa0a525f0012668db72d97089023e4a6", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -6075,7 +6075,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   obstack_init (hash_obstack);"}, {"sha": "89d4b75ef19d00fdc0dc18f1e10fd0e683b2872f", "filename": "gcc/gencodes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -56,7 +56,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   puts (\"\\"}, {"sha": "01107ff7eb3789a0d468f8d56b604c40dcbb7c60", "filename": "gcc/genconfig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -277,7 +277,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   puts (\"/* Generated automatically by the program `genconfig'\");"}, {"sha": "751071949ac9d6ebf106523b21b616c15dde4f43", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -789,7 +789,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   /* Assign sequential codes to all entries in the machine description"}, {"sha": "7c111368c03e3e7cee19760792deeebb17224bba", "filename": "gcc/genextract.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -362,7 +362,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   /* Assign sequential codes to all entries in the machine description"}, {"sha": "4bf05111b371bad92fef0bfd69713d8d4de0cc10", "filename": "gcc/genflags.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -230,7 +230,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n   \n   puts (\"/* Generated automatically by the program `genflags'\");"}, {"sha": "85fa6433f35e204a00f3f22b1dabf6ae5e335905", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -316,7 +316,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   printf (\"/* Generated automatically by the program `genopinit'\\n\\"}, {"sha": "73911aeec0f992ec0b0e5e08bfdde6c5ad9aac09", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -953,7 +953,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   output_prologue ();"}, {"sha": "05c156a2f853f1bf0d9d813deebcd2452a5bd6d4", "filename": "gcc/genpeep.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -385,7 +385,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   printf (\"/* Generated automatically by the program `genpeep'\\n\\"}, {"sha": "0e7356bdab4edca2f1b903f1faa8982b43d60b25", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -2689,7 +2689,7 @@ main (argc, argv)\n   if (argc <= 1)\n     fatal (\"No input file name.\");\n \n-  if (init_md_reader (argv[1]) != SUCCESS_EXIT_CODE)\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n   next_insn_code = 0;"}, {"sha": "3660378d7cf4ba3e5e87e79a2df96deddc1f4480", "filename": "gcc/gensupport.c", "status": "modified", "additions": 242, "deletions": 1, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -42,6 +42,8 @@ static int predicable_default;\n static const char *predicable_true;\n static const char *predicable_false;\n \n+static char *base_dir = NULL;\n+\n /* We initially queue all patterns, process the define_insn and\n    define_cond_exec patterns, then return them one at a time.  */\n \n@@ -62,6 +64,23 @@ static struct queue_elem *other_queue;\n static struct queue_elem **other_tail = &other_queue;\n \n static void queue_pattern PARAMS ((rtx, struct queue_elem ***, int));\n+\n+/* Current maximum length of directory names in the search path\n+   for include files.  (Altered as we get more of them.)  */\n+\n+size_t max_include_len;\n+\n+struct file_name_list\n+  {\n+    struct file_name_list *next;\n+    const char *fname;\n+  };\n+\n+struct file_name_list *include = 0;     /* First dir to search */\n+        /* First dir to search for <file> */\n+struct file_name_list *first_bracket_include = 0;\n+struct file_name_list *last_include = 0;        /* Last in chain */\n+\n static void remove_constraints PARAMS ((rtx));\n static void process_rtx PARAMS ((rtx, int));\n \n@@ -78,6 +97,9 @@ static const char *alter_output_for_insn PARAMS ((struct queue_elem *,\n \t\t\t\t\t\t  int, int));\n static void process_one_cond_exec PARAMS ((struct queue_elem *));\n static void process_define_cond_exec PARAMS ((void));\n+static int process_include PARAMS ((rtx, int));\n+static char *save_string PARAMS ((const char *, int));\n+static int init_include_reader PARAMS ((FILE  *));\n \f\n void\n message_with_line VPARAMS ((int lineno, const char *msg, ...))\n@@ -157,13 +179,151 @@ remove_constraints (part)\n       }\n }\n \n+/* The entry point for initializing the reader.  */\n+\n+static int\n+init_include_reader (inf)\n+     FILE *inf;\n+{\n+  int c;\n+\n+  errors = 0;\n+\n+  /* Read the entire file.  */\n+  while (1)\n+    {\n+      rtx desc;\n+      int lineno;\n+\n+      c = read_skip_spaces (inf);\n+      if (c == EOF)\n+\tbreak;\n+\n+      ungetc (c, inf);\n+      lineno = read_rtx_lineno;\n+      desc = read_rtx (inf);\n+      process_rtx (desc, lineno);\n+    }\n+  fclose (inf);\n+\n+  /* Process define_cond_exec patterns.  */\n+  if (define_cond_exec_queue != NULL)\n+    process_define_cond_exec ();\n+\n+  return errors ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n+}\n+\n+/* Process an include file assuming that it lives in gcc/config/{target}/ \n+   if the include looks line (include \"file\" )  */\n+static int\n+process_include (desc, lineno)\n+     rtx desc;\n+     int lineno;\n+{\n+  const char *filename = XSTR (desc, 0);\n+  char *pathname = NULL;\n+  FILE *input_file;\n+  char *fname;\n+  struct file_name_list *stackp;\n+  int flen;\n+\n+  stackp = include;\n+\n+  /* If specified file name is absolute, just open it.  */\n+  if (IS_ABSOLUTE_PATHNAME (filename) || !stackp)\n+    {\n+      if (base_dir)\n+        {\n+          pathname = xmalloc (strlen (base_dir) + strlen (filename) + 1);\n+          pathname = strcpy (pathname, base_dir);\n+          strcat (pathname, filename);\n+          strcat (pathname, \"\\0\");\n+\t}\n+      else\n+        {\n+\t  pathname = xstrdup (filename);\n+        }\n+      read_rtx_filename = pathname;\n+      input_file = fopen (pathname, \"r\");\n+\n+      if (input_file == 0)\n+\t{\n+\t  perror (pathname);\n+\t  return FATAL_EXIT_CODE;\n+\t}\n+    }\n+  else if (stackp)\n+    {\n+\n+      flen = strlen (filename);\n+\n+      fname = (char *) alloca (max_include_len + flen + 2);\n+\n+      /* + 2 above for slash and terminating null.  */\n+\n+      /* Search directory path, trying to open the file.\n+         Copy each filename tried into FNAME.  */\n+\n+      for (; stackp; stackp = stackp->next)\n+\t{\n+\t  if (stackp->fname)\n+\t    {\n+\t      strcpy (fname, stackp->fname);\n+\t      strcat (fname, \"/\");\n+\t      fname[strlen (fname) + flen] = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      fname[0] = 0;\n+\t    }\n+\t  strncat (fname, (const char *) filename, flen);\n+\t  read_rtx_filename = fname;\n+\t  input_file = fopen (fname, \"r\");\n+\t  if (input_file != NULL) \n+\t    break;\n+\t}\n+      if (stackp == NULL)\n+\t{\n+\t  if (strchr (fname, '/') == NULL || strchr (fname, '\\\\' ) || base_dir)\n+\t    {\n+\t      if (base_dir)\n+\t\t{\n+\t\t  pathname =\n+\t\t    xmalloc (strlen (base_dir) + strlen (filename) + 1);\n+\t\t  pathname = strcpy (pathname, base_dir);\n+\t\t  strcat (pathname, filename);\n+\t\t  strcat (pathname, \"\\0\");\n+\t\t}\n+\t      else\n+\t\tpathname = xstrdup (filename);\n+\t    }\n+\t  read_rtx_filename = pathname;\n+\t  input_file = fopen (pathname, \"r\");\n+\n+\t  if (input_file == 0)\n+\t    {\n+\t      perror (filename);\n+\t      return FATAL_EXIT_CODE;\n+\t    }\n+\t}\n+\n+    }\n+\n+  if (init_include_reader (input_file) == FATAL_EXIT_CODE)\n+    message_with_line (lineno, \"read errors found in include file  %s\\n\", pathname);\n+\n+  return SUCCESS_EXIT_CODE;\n+}\n+\n /* Process a top level rtx in some way, queueing as appropriate.  */\n \n static void\n process_rtx (desc, lineno)\n      rtx desc;\n      int lineno;\n {\n+  const char *filename = XSTR (desc, 0);\n+\n   switch (GET_CODE (desc))\n     {\n     case DEFINE_INSN:\n@@ -178,6 +338,11 @@ process_rtx (desc, lineno)\n       queue_pattern (desc, &define_attr_tail, lineno);\n       break;\n \n+    case INCLUDE:\n+      if (process_include (desc, lineno) == FATAL_EXIT_CODE)\n+        message_with_line (lineno, \"include file at  %s not found\\n\", filename);\n+      break;\n+\n     case DEFINE_INSN_AND_SPLIT:\n       {\n \tconst char *split_cond;\n@@ -767,6 +932,74 @@ process_define_cond_exec ()\n   for (elem = define_cond_exec_queue; elem ; elem = elem->next)\n     process_one_cond_exec (elem);\n }\n+\n+static char *\n+save_string (s, len)\n+     const char *s;\n+     int len;\n+{\n+  register char *result = xmalloc (len + 1);\n+\n+  memcpy (result, s, len);\n+  result[len] = 0;\n+  return result;\n+}\n+\n+\f\n+/* The entry point for initializing the reader.  */\n+\n+int\n+init_md_reader_args (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  int i;\n+  const char *in_fname;\n+\n+  max_include_len = 0;\n+  in_fname = NULL;\n+  for (i = 1; i < argc; i++)\n+    {\n+      if (argv[i][0] != '-')\n+\t{\n+\t  if (in_fname == NULL)\n+\t    in_fname = argv[i];\n+\t}\n+      else\n+\t{\n+\t  int c = argv[i][1];\n+\t  switch (c)\n+\t    {\n+\t    case 'I':\t\t/* Add directory to path for includes.  */\n+\t      {\n+\t\tstruct file_name_list *dirtmp;\n+\n+\t\tdirtmp = (struct file_name_list *)\n+\t\t  xmalloc (sizeof (struct file_name_list));\n+\t\tdirtmp->next = 0;\t/* New one goes on the end */\n+\t\tif (include == 0)\n+\t\t  include = dirtmp;\n+\t\telse\n+\t\t  last_include->next = dirtmp;\n+\t\tlast_include = dirtmp;\t/* Tail follows the last one */\n+\t\tif (argv[i][1] == 'I' && argv[i][2] != 0)\n+\t\t  dirtmp->fname = argv[i] + 2;\n+\t\telse if (i + 1 == argc)\n+\t\t  fatal (\"Directory name missing after -I option\");\n+\t\telse\n+\t\t  dirtmp->fname = argv[++i];\n+\t\tif (strlen (dirtmp->fname) > max_include_len)\n+\t\t  max_include_len = strlen (dirtmp->fname);\n+\t      }\n+\t      break;\n+\t    default:\n+\t      fatal (\"Invalid option `%s'\", argv[i]);\n+\n+\t    }\n+\t}\n+    }\n+    return init_md_reader (in_fname);\n+}\n \f\n /* The entry point for initializing the reader.  */\n \n@@ -776,6 +1009,14 @@ init_md_reader (filename)\n {\n   FILE *input_file;\n   int c;\n+  char *lastsl;\n+\n+  if (!IS_ABSOLUTE_PATHNAME (filename))\n+    {\n+      lastsl = strrchr (filename, '/');\n+      if (lastsl != NULL) \n+\tbase_dir = save_string (filename, lastsl - filename + 1 );\n+    }\n \n   read_rtx_filename = filename;\n   input_file = fopen (filename, \"r\");\n@@ -797,7 +1038,7 @@ init_md_reader (filename)\n \n       c = read_skip_spaces (input_file);\n       if (c == EOF)\n-\tbreak;\n+        break;\n \n       ungetc (c, input_file);\n       lineno = read_rtx_lineno;"}, {"sha": "96c8c87ba25c7b01195f0ae24cd9760295a38b72", "filename": "gcc/gensupport.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -21,6 +21,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n struct obstack;\n extern struct obstack *rtl_obstack;\n \n+extern int init_md_reader_args\tPARAMS ((int, char **));\n extern int init_md_reader\tPARAMS ((const char *));\n extern rtx read_md_rtx\t\tPARAMS ((int *, int *));\n "}, {"sha": "6c887bce15c547cab34daa9fb916ca4760be190f", "filename": "gcc/rtl.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04d8aa70d552a552e39fa0afef50d22263253ec4/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=04d8aa70d552a552e39fa0afef50d22263253ec4", "patch": "@@ -73,6 +73,11 @@ DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", 'x')\n \n DEF_RTL_EXPR(NIL, \"nil\", \"*\", 'x')\n \n+\n+/* include a file */\n+\n+DEF_RTL_EXPR(INCLUDE, \"include\", \"s\", 'x')\n+\n /* ---------------------------------------------------------------------\n    Expressions used in constructing lists.\n    --------------------------------------------------------------------- */"}]}