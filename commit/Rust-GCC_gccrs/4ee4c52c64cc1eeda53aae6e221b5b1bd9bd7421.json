{"sha": "4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVlNGM1MmM2NGNjMWVlZGE1M2FhZTZlMjIxYjViMWJkOWJkNzQyMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-06-28T11:38:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-06-28T11:38:01Z"}, "message": "re PR tree-optimization/53645 (Missed optimization for vector integer division lowering)\n\n\tPR tree-optimization/53645\n\t* tree-vect-generic.c (add_rshift): New function.\n\t(expand_vector_divmod): New function.\n\t(expand_vector_operation): Use it for vector integer\n\tTRUNC_{DIV,MOD}_EXPR by VECTOR_CST.\n\t* tree-vect-patterns.c (vect_recog_divmod_pattern): Replace\n\tunused lguup variable with dummy_int.\n\n\t* gcc.c-torture/execute/pr53645.c: New test.\n\nFrom-SVN: r189043", "tree": {"sha": "97380392fe18b29c5f40a143b8e216c0fc48ab9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97380392fe18b29c5f40a143b8e216c0fc48ab9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "304b6b3edab5c727400849a9e88fbd47fde5d296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/304b6b3edab5c727400849a9e88fbd47fde5d296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/304b6b3edab5c727400849a9e88fbd47fde5d296"}], "stats": {"total": 643, "additions": 641, "deletions": 2}, "files": [{"sha": "73157d8ee2f8480eaa39099c7aeb2274f1e23dc0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "patch": "@@ -1,3 +1,13 @@\n+2012-06-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/53645\n+\t* tree-vect-generic.c (add_rshift): New function.\n+\t(expand_vector_divmod): New function.\n+\t(expand_vector_operation): Use it for vector integer\n+\tTRUNC_{DIV,MOD}_EXPR by VECTOR_CST.\n+\t* tree-vect-patterns.c (vect_recog_divmod_pattern): Replace\n+\tunused lguup variable with dummy_int.\n+\n 2012-06-28  OLivier Hainque  <hainque@adacore.com>\n \n \t* expr.c (convert_move): Latch mem integer inputs into a"}, {"sha": "f7ca83089cc7cba3fbed23fae464d429b0b71bd6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "patch": "@@ -1,3 +1,8 @@\n+2012-06-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/53645\n+\t* gcc.c-torture/execute/pr53645.c: New test.\n+\n 2012-06-28  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat.dg/deep_old.adb, gnat.dg/old_errors.adb: Removed, obsolete."}, {"sha": "1e70d9e7635d4d8d65ecd29c7f8d889f9d5eae17", "filename": "gcc/testsuite/gcc.c-torture/execute/pr53645.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr53645.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr53645.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr53645.c?ref=4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "patch": "@@ -0,0 +1,96 @@\n+/* PR tree-optimization/53645 */\n+\n+typedef unsigned int UV __attribute__((vector_size (16)));\n+typedef int SV __attribute__((vector_size (16)));\n+extern void abort (void);\n+\n+#define TEST(a, b, c, d) \\\n+__attribute__((noinline)) void\t\t\\\n+uq##a##b##c##d (UV *x, UV *y) \t\t\\\n+{\t\t\t\t\t\\\n+  *x = *y / ((UV) { a, b, c, d });\t\\\n+}\t\t\t\t\t\\\n+\t\t\t\t\t\\\n+__attribute__((noinline)) void\t\t\\\n+ur##a##b##c##d (UV *x, UV *y) \t\t\\\n+{\t\t\t\t\t\\\n+  *x = *y % ((UV) { a, b, c, d });\t\\\n+}\t\t\t\t\t\\\n+\t\t\t\t\t\\\n+__attribute__((noinline)) void\t\t\\\n+sq##a##b##c##d (SV *x, SV *y) \t\t\\\n+{\t\t\t\t\t\\\n+  *x = *y / ((SV) { a, b, c, d });\t\\\n+}\t\t\t\t\t\\\n+\t\t\t\t\t\\\n+__attribute__((noinline)) void\t\t\\\n+sr##a##b##c##d (SV *x, SV *y) \t\t\\\n+{\t\t\t\t\t\\\n+  *x = *y % ((SV) { a, b, c, d });\t\\\n+}\n+\n+#define TESTS \\\n+TEST (4, 4, 4, 4)\t\t\t\\\n+TEST (1, 4, 2, 8)\t\t\t\\\n+TEST (3, 3, 3, 3)\t\t\t\\\n+TEST (6, 5, 6, 5)\t\t\t\\\n+TEST (14, 14, 14, 6)\t\t\t\\\n+TEST (7, 7, 7, 7)\t\t\t\\\n+\n+TESTS\n+\n+UV u[] =\n+  { ((UV) { 73U, 65531U, 0U, 174U }),\n+    ((UV) { 1U, 8173U, ~0U, ~0U - 63 }) };\n+SV s[] =\n+  { ((SV) { 73, -9123, 32761, 8191 }),\n+    ((SV) { 9903, -1, -7323, 0 }) };\n+\n+int\n+main ()\n+{\n+  UV ur, ur2;\n+  SV sr, sr2;\n+  int i;\n+#undef TEST\n+#define TEST(a, b, c, d)\t\t\t\t\\\n+    uq##a##b##c##d (&ur, u + i);\t\t\t\\\n+    if (ur[0] != u[i][0] / a || ur[3] != u[i][3] / d)\t\\\n+     abort ();\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"r\" (&ur) : \"memory\");\t\t\\\n+    if (ur[2] != u[i][2] / c || ur[1] != u[i][1] / b)\t\\\n+     abort ();\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"r\" (&ur) : \"memory\");\t\t\\\n+    ur##a##b##c##d (&ur, u + i);\t\t\t\\\n+    if (ur[0] != u[i][0] % a || ur[3] != u[i][3] % d)\t\\\n+     abort ();\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"r\" (&ur) : \"memory\");\t\t\\\n+    if (ur[2] != u[i][2] % c || ur[1] != u[i][1] % b)\t\\\n+     abort ();\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"r\" (&ur) : \"memory\");\n+  for (i = 0; i < sizeof (u) / sizeof (u[0]); i++)\n+    {\n+      TESTS\n+    }\n+#undef TEST\n+#define TEST(a, b, c, d)\t\t\t\t\\\n+    sq##a##b##c##d (&sr, s + i);\t\t\t\\\n+    if (sr[0] != s[i][0] / a || sr[3] != s[i][3] / d)\t\\\n+     abort ();\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"r\" (&sr) : \"memory\");\t\t\\\n+    if (sr[2] != s[i][2] / c || sr[1] != s[i][1] / b)\t\\\n+     abort ();\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"r\" (&sr) : \"memory\");\t\t\\\n+    sr##a##b##c##d (&sr, s + i);\t\t\t\\\n+    if (sr[0] != s[i][0] % a || sr[3] != s[i][3] % d)\t\\\n+     abort ();\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"r\" (&sr) : \"memory\");\t\t\\\n+    if (sr[2] != s[i][2] % c || sr[1] != s[i][1] % b)\t\\\n+     abort ();\t\t\t\t\t\t\\\n+    asm volatile (\"\" : : \"r\" (&sr) : \"memory\");\n+  for (i = 0; i < sizeof (s) / sizeof (s[0]); i++)\n+    {\n+      TESTS\n+    }\n+  return 0;\n+}"}, {"sha": "1b3ff274fd03c6e660ad6bb5b351fb912ef6d1c4", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "patch": "@@ -391,6 +391,515 @@ expand_vector_comparison (gimple_stmt_iterator *gsi, tree type, tree op0,\n   return t;\n }\n \n+/* Helper function of expand_vector_divmod.  Gimplify a RSHIFT_EXPR in type\n+   of OP0 with shift counts in SHIFTCNTS array and return the temporary holding\n+   the result if successful, otherwise return NULL_TREE.  */\n+static tree\n+add_rshift (gimple_stmt_iterator *gsi, tree type, tree op0, int *shiftcnts)\n+{\n+  optab op;\n+  unsigned int i, nunits = TYPE_VECTOR_SUBPARTS (type);\n+  bool scalar_shift = true;\n+\n+  for (i = 1; i < nunits; i++)\n+    {\n+      if (shiftcnts[i] != shiftcnts[0])\n+\tscalar_shift = false;\n+    }\n+\n+  if (scalar_shift && shiftcnts[0] == 0)\n+    return op0;\n+\n+  if (scalar_shift)\n+    {\n+      op = optab_for_tree_code (RSHIFT_EXPR, type, optab_scalar);\n+      if (op != NULL\n+\t  && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n+\treturn gimplify_build2 (gsi, RSHIFT_EXPR, type, op0,\n+\t\t\t\tbuild_int_cst (NULL_TREE, shiftcnts[0]));\n+    }\n+\n+  op = optab_for_tree_code (RSHIFT_EXPR, type, optab_vector);\n+  if (op != NULL\n+      && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n+    {\n+      tree *vec = XALLOCAVEC (tree, nunits);\n+      for (i = 0; i < nunits; i++)\n+\tvec[i] = build_int_cst (TREE_TYPE (type), shiftcnts[i]);\n+      return gimplify_build2 (gsi, RSHIFT_EXPR, type, op0,\n+\t\t\t      build_vector (type, vec));\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Try to expand integer vector division by constant using\n+   widening multiply, shifts and additions.  */\n+static tree\n+expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n+\t\t      tree op1, enum tree_code code)\n+{\n+  bool use_pow2 = true;\n+  bool has_vector_shift = true;\n+  int mode = -1, this_mode;\n+  int pre_shift = -1, post_shift;\n+  unsigned int nunits = TYPE_VECTOR_SUBPARTS (type);\n+  int *shifts = XALLOCAVEC (int, nunits * 4);\n+  int *pre_shifts = shifts + nunits;\n+  int *post_shifts = pre_shifts + nunits;\n+  int *shift_temps = post_shifts + nunits;\n+  unsigned HOST_WIDE_INT *mulc = XALLOCAVEC (unsigned HOST_WIDE_INT, nunits);\n+  int prec = TYPE_PRECISION (TREE_TYPE (type));\n+  int dummy_int;\n+  unsigned int i, unsignedp = TYPE_UNSIGNED (TREE_TYPE (type));\n+  unsigned HOST_WIDE_INT mask = GET_MODE_MASK (TYPE_MODE (TREE_TYPE (type)));\n+  optab op;\n+  tree *vec;\n+  unsigned char *sel;\n+  tree cur_op, mhi, mlo, mulcst, perm_mask, wider_type, tem;\n+\n+  if (prec > HOST_BITS_PER_WIDE_INT)\n+    return NULL_TREE;\n+\n+  op = optab_for_tree_code (RSHIFT_EXPR, type, optab_vector);\n+  if (op == NULL\n+      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+    has_vector_shift = false;\n+\n+  /* Analysis phase.  Determine if all op1 elements are either power\n+     of two and it is possible to expand it using shifts (or for remainder\n+     using masking).  Additionally compute the multiplicative constants\n+     and pre and post shifts if the division is to be expanded using\n+     widening or high part multiplication plus shifts.  */\n+  for (i = 0; i < nunits; i++)\n+    {\n+      tree cst = VECTOR_CST_ELT (op1, i);\n+      unsigned HOST_WIDE_INT ml;\n+\n+      if (!host_integerp (cst, unsignedp) || integer_zerop (cst))\n+\treturn NULL_TREE;\n+      pre_shifts[i] = 0;\n+      post_shifts[i] = 0;\n+      mulc[i] = 0;\n+      if (use_pow2\n+\t  && (!integer_pow2p (cst) || tree_int_cst_sgn (cst) != 1))\n+\tuse_pow2 = false;\n+      if (use_pow2)\n+\t{\n+\t  shifts[i] = tree_log2 (cst);\n+\t  if (shifts[i] != shifts[0]\n+\t      && code == TRUNC_DIV_EXPR\n+\t      && !has_vector_shift)\n+\t    use_pow2 = false;\n+\t}\n+      if (mode == -2)\n+\tcontinue;\n+      if (unsignedp)\n+\t{\n+\t  unsigned HOST_WIDE_INT mh;\n+\t  unsigned HOST_WIDE_INT d = tree_low_cst (cst, 1) & mask;\n+\n+\t  if (d >= ((unsigned HOST_WIDE_INT) 1 << (prec - 1)))\n+\t    /* FIXME: Can transform this into op0 >= op1 ? 1 : 0.  */\n+\t    return NULL_TREE;\n+\n+\t  if (d <= 1)\n+\t    {\n+\t      mode = -2;\n+\t      continue;\n+\t    }\n+\n+\t  /* Find a suitable multiplier and right shift count\n+\t     instead of multiplying with D.  */\n+\t  mh = choose_multiplier (d, prec, prec, &ml, &post_shift, &dummy_int);\n+\n+\t  /* If the suggested multiplier is more than SIZE bits, we can\n+\t     do better for even divisors, using an initial right shift.  */\n+\t  if ((mh != 0 && (d & 1) == 0)\n+\t      || (!has_vector_shift && pre_shift != -1))\n+\t    {\n+\t      if (has_vector_shift)\n+\t\tpre_shift = floor_log2 (d & -d);\n+\t      else if (pre_shift == -1)\n+\t\t{\n+\t\t  unsigned int j;\n+\t\t  for (j = 0; j < nunits; j++)\n+\t\t    {\n+\t\t      tree cst2 = VECTOR_CST_ELT (op1, j);\n+\t\t      unsigned HOST_WIDE_INT d2;\n+\t\t      int this_pre_shift;\n+\n+\t\t      if (!host_integerp (cst2, 1))\n+\t\t\treturn NULL_TREE;\n+\t\t      d2 = tree_low_cst (cst2, 1) & mask;\n+\t\t      if (d2 == 0)\n+\t\t\treturn NULL_TREE;\n+\t\t      this_pre_shift = floor_log2 (d2 & -d2);\n+\t\t      if (pre_shift == -1 || this_pre_shift < pre_shift)\n+\t\t\tpre_shift = this_pre_shift;\n+\t\t    }\n+\t\t  if (i != 0 && pre_shift != 0)\n+\t\t    {\n+\t\t      /* Restart.  */\n+\t\t      i = -1U;\n+\t\t      mode = -1;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      if (pre_shift != 0)\n+\t\t{\n+\t\t  if ((d >> pre_shift) <= 1)\n+\t\t    {\n+\t\t      mode = -2;\n+\t\t      continue;\n+\t\t    }\n+\t\t  mh = choose_multiplier (d >> pre_shift, prec,\n+\t\t\t\t\t  prec - pre_shift,\n+\t\t\t\t\t  &ml, &post_shift, &dummy_int);\n+\t\t  gcc_assert (!mh);\n+\t\t  pre_shifts[i] = pre_shift;\n+\t\t}\n+\t    }\n+\t  if (!mh)\n+\t    this_mode = 0;\n+\t  else\n+\t    this_mode = 1;\n+\t}\n+      else\n+\t{\n+\t  HOST_WIDE_INT d = tree_low_cst (cst, 0);\n+\t  unsigned HOST_WIDE_INT abs_d;\n+\n+\t  if (d == -1)\n+\t    return NULL_TREE;\n+\n+\t  /* Since d might be INT_MIN, we have to cast to\n+\t     unsigned HOST_WIDE_INT before negating to avoid\n+\t     undefined signed overflow.  */\n+\t  abs_d = (d >= 0\n+\t\t  ? (unsigned HOST_WIDE_INT) d\n+\t\t  : - (unsigned HOST_WIDE_INT) d);\n+\n+\t  /* n rem d = n rem -d */\n+\t  if (code == TRUNC_MOD_EXPR && d < 0)\n+\t    d = abs_d;\n+\t  else if (abs_d == (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n+\t    {\n+\t      /* This case is not handled correctly below.  */\n+\t      mode = -2;\n+\t      continue;\n+\t    }\n+\t  if (abs_d <= 1)\n+\t    {\n+\t      mode = -2;\n+\t      continue;\n+\t    }\n+\n+\t  choose_multiplier (abs_d, prec, prec - 1, &ml,\n+\t\t\t     &post_shift, &dummy_int);\n+\t  if (ml >= (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n+\t    {\n+\t      this_mode = 4 + (d < 0);\n+\t      ml |= (~(unsigned HOST_WIDE_INT) 0) << (prec - 1);\n+\t    }\n+\t  else\n+\t    this_mode = 2 + (d < 0);\n+\t}\n+      mulc[i] = ml;\n+      post_shifts[i] = post_shift;\n+      if ((i && !has_vector_shift && post_shifts[0] != post_shift)\n+\t  || post_shift >= prec\n+\t  || pre_shifts[i] >= prec)\n+\tthis_mode = -2;\n+\n+      if (i == 0)\n+\tmode = this_mode;\n+      else if (mode != this_mode)\n+\tmode = -2;\n+    }\n+\n+  vec = XALLOCAVEC (tree, nunits);\n+\n+  if (use_pow2)\n+    {\n+      tree addend = NULL_TREE;\n+      if (!unsignedp)\n+\t{\n+\t  tree uns_type;\n+\n+\t  /* Both division and remainder sequences need\n+\t     op0 < 0 ? mask : 0 computed.  It can be either computed as\n+\t     (type) (((uns_type) (op0 >> (prec - 1))) >> (prec - shifts[i]))\n+\t     if none of the shifts is 0, or as the conditional.  */\n+\t  for (i = 0; i < nunits; i++)\n+\t    if (shifts[i] == 0)\n+\t      break;\n+\t  uns_type\n+\t    = build_vector_type (build_nonstandard_integer_type (prec, 1),\n+\t\t\t\t nunits);\n+\t  if (i == nunits && TYPE_MODE (uns_type) == TYPE_MODE (type))\n+\t    {\n+\t      for (i = 0; i < nunits; i++)\n+\t\tshift_temps[i] = prec - 1;\n+\t      cur_op = add_rshift (gsi, type, op0, shift_temps);\n+\t      if (cur_op != NULL_TREE)\n+\t\t{\n+\t\t  cur_op = gimplify_build1 (gsi, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t    uns_type, cur_op);\n+\t\t  for (i = 0; i < nunits; i++)\n+\t\t    shift_temps[i] = prec - shifts[i];\n+\t\t  cur_op = add_rshift (gsi, uns_type, cur_op, shift_temps);\n+\t\t  if (cur_op != NULL_TREE)\n+\t\t    addend = gimplify_build1 (gsi, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t      type, cur_op);\n+\t\t}\n+\t    }\n+\t  if (addend == NULL_TREE\n+\t      && expand_vec_cond_expr_p (type, type))\n+\t    {\n+\t      tree zero, cst, cond;\n+\t      gimple stmt;\n+\n+\t      zero = build_zero_cst (type);\n+\t      cond = build2 (LT_EXPR, type, op0, zero);\n+\t      for (i = 0; i < nunits; i++)\n+\t\tvec[i] = build_int_cst (TREE_TYPE (type),\n+\t\t\t\t\t((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t\t << shifts[i]) - 1);\n+\t      cst = build_vector (type, vec);\n+\t      addend = create_tmp_reg (type, NULL);\n+\t      add_referenced_var (addend);\n+\t      addend = make_ssa_name (addend, NULL);\n+\t      stmt = gimple_build_assign_with_ops3 (VEC_COND_EXPR, addend,\n+\t\t\t\t\t\t    cond, cst, zero);\n+\t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+\t    }\n+\t}\n+      if (code == TRUNC_DIV_EXPR)\n+\t{\n+\t  if (unsignedp)\n+\t    {\n+\t      /* q = op0 >> shift;  */\n+\t      cur_op = add_rshift (gsi, type, op0, shifts);\n+\t      if (cur_op != NULL_TREE)\n+\t\treturn cur_op;\n+\t    }\n+\t  else if (addend != NULL_TREE)\n+\t    {\n+\t      /* t1 = op0 + addend;\n+\t\t q = t1 >> shift;  */\n+\t      op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n+\t      if (op != NULL\n+\t\t  && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n+\t\t{\n+\t\t  cur_op = gimplify_build2 (gsi, PLUS_EXPR, type, op0, addend);\n+\t\t  cur_op = add_rshift (gsi, type, cur_op, shifts);\n+\t\t  if (cur_op != NULL_TREE)\n+\t\t    return cur_op;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tree mask;\n+\t  for (i = 0; i < nunits; i++)\n+\t    vec[i] = build_int_cst (TREE_TYPE (type),\n+\t\t\t\t    ((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t     << shifts[i]) - 1);\n+\t  mask = build_vector (type, vec);\n+\t  op = optab_for_tree_code (BIT_AND_EXPR, type, optab_default);\n+\t  if (op != NULL\n+\t      && optab_handler (op, TYPE_MODE (type)) != CODE_FOR_nothing)\n+\t    {\n+\t      if (unsignedp)\n+\t\t/* r = op0 & mask;  */\n+\t\treturn gimplify_build2 (gsi, BIT_AND_EXPR, type, op0, mask);\n+\t      else if (addend != NULL_TREE)\n+\t\t{\n+\t\t  /* t1 = op0 + addend;\n+\t\t     t2 = t1 & mask;\n+\t\t     r = t2 - addend;  */\n+\t\t  op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n+\t\t  if (op != NULL\n+\t\t      && optab_handler (op, TYPE_MODE (type))\n+\t\t\t != CODE_FOR_nothing)\n+\t\t    {\n+\t\t      cur_op = gimplify_build2 (gsi, PLUS_EXPR, type, op0,\n+\t\t\t\t\t\taddend);\n+\t\t      cur_op = gimplify_build2 (gsi, BIT_AND_EXPR, type,\n+\t\t\t\t\t\tcur_op, mask);\n+\t\t      op = optab_for_tree_code (MINUS_EXPR, type,\n+\t\t\t\t\t\toptab_default);\n+\t\t      if (op != NULL\n+\t\t\t  && optab_handler (op, TYPE_MODE (type))\n+\t\t\t     != CODE_FOR_nothing)\n+\t\t\treturn gimplify_build2 (gsi, MINUS_EXPR, type,\n+\t\t\t\t\t\tcur_op, addend);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (mode == -2 || BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n+    return NULL_TREE;\n+\n+  op = optab_for_tree_code (VEC_WIDEN_MULT_LO_EXPR, type, optab_default);\n+  if (op == NULL\n+      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+    return NULL_TREE;\n+  op = optab_for_tree_code (VEC_WIDEN_MULT_HI_EXPR, type, optab_default);\n+  if (op == NULL\n+      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+    return NULL_TREE;\n+  sel = XALLOCAVEC (unsigned char, nunits);\n+  for (i = 0; i < nunits; i++)\n+    sel[i] = 2 * i + (BYTES_BIG_ENDIAN ? 0 : 1);\n+  if (!can_vec_perm_p (TYPE_MODE (type), false, sel))\n+    return NULL_TREE;\n+  wider_type\n+    = build_vector_type (build_nonstandard_integer_type (prec * 2, unsignedp),\n+\t\t\t nunits / 2);\n+  if (GET_MODE_CLASS (TYPE_MODE (wider_type)) != MODE_VECTOR_INT\n+      || GET_MODE_BITSIZE (TYPE_MODE (wider_type))\n+\t != GET_MODE_BITSIZE (TYPE_MODE (type)))\n+    return NULL_TREE;\n+\n+  cur_op = op0;\n+\n+  switch (mode)\n+    {\n+    case 0:\n+      gcc_assert (unsignedp);\n+      /* t1 = oprnd0 >> pre_shift;\n+\t t2 = (type) (t1 w* ml >> prec);\n+\t q = t2 >> post_shift;  */\n+      cur_op = add_rshift (gsi, type, cur_op, pre_shifts);\n+      if (cur_op == NULL_TREE)\n+\treturn NULL_TREE;\n+      break;\n+    case 1:\n+      gcc_assert (unsignedp);\n+      for (i = 0; i < nunits; i++)\n+\t{\n+\t  shift_temps[i] = 1;\n+\t  post_shifts[i]--;\n+\t}\n+      break;\n+    case 2:\n+    case 3:\n+    case 4:\n+    case 5:\n+      gcc_assert (!unsignedp);\n+      for (i = 0; i < nunits; i++)\n+\tshift_temps[i] = prec - 1;\n+      break;\n+    default:\n+      return NULL_TREE;\n+    }\n+\n+  for (i = 0; i < nunits; i++)\n+    vec[i] = build_int_cst (TREE_TYPE (type), mulc[i]);\n+  mulcst = build_vector (type, vec);\n+  for (i = 0; i < nunits; i++)\n+    vec[i] = build_int_cst (TREE_TYPE (type), sel[i]);\n+  perm_mask = build_vector (type, vec);\n+  mhi = gimplify_build2 (gsi, VEC_WIDEN_MULT_HI_EXPR, wider_type,\n+\t\t\t cur_op, mulcst);\n+  mhi = gimplify_build1 (gsi, VIEW_CONVERT_EXPR, type, mhi);\n+  mlo = gimplify_build2 (gsi, VEC_WIDEN_MULT_LO_EXPR, wider_type,\n+\t\t\t cur_op, mulcst);\n+  mlo = gimplify_build1 (gsi, VIEW_CONVERT_EXPR, type, mlo);\n+  if (BYTES_BIG_ENDIAN)\n+    cur_op = gimplify_build3 (gsi, VEC_PERM_EXPR, type, mhi, mlo, perm_mask);\n+  else\n+    cur_op = gimplify_build3 (gsi, VEC_PERM_EXPR, type, mlo, mhi, perm_mask);\n+\n+  switch (mode)\n+    {\n+    case 0:\n+      /* t1 = oprnd0 >> pre_shift;\n+\t t2 = (type) (t1 w* ml >> prec);\n+\t q = t2 >> post_shift;  */\n+      cur_op = add_rshift (gsi, type, cur_op, post_shifts);\n+      break;\n+    case 1:\n+      /* t1 = (type) (oprnd0 w* ml >> prec);\n+\t t2 = oprnd0 - t1;\n+\t t3 = t2 >> 1;\n+\t t4 = t1 + t3;\n+\t q = t4 >> (post_shift - 1);  */\n+      op = optab_for_tree_code (MINUS_EXPR, type, optab_default);\n+      if (op == NULL\n+\t  || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+\treturn NULL_TREE;\n+      tem = gimplify_build2 (gsi, MINUS_EXPR, type, op0, cur_op);\n+      tem = add_rshift (gsi, type, tem, shift_temps);\n+      op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n+      if (op == NULL\n+\t  || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+\treturn NULL_TREE;\n+      tem = gimplify_build2 (gsi, PLUS_EXPR, type, cur_op, tem);\n+      cur_op = add_rshift (gsi, type, tem, post_shifts);\n+      if (cur_op == NULL_TREE)\n+\treturn NULL_TREE;\n+      break;\n+    case 2:\n+    case 3:\n+    case 4:\n+    case 5:\n+      /* t1 = (type) (oprnd0 w* ml >> prec);\n+\t t2 = t1; [ iff (mode & 2) != 0 ]\n+\t t2 = t1 + oprnd0; [ iff (mode & 2) == 0 ]\n+\t t3 = t2 >> post_shift;\n+\t t4 = oprnd0 >> (prec - 1);\n+\t q = t3 - t4; [ iff (mode & 1) == 0 ]\n+\t q = t4 - t3; [ iff (mode & 1) != 0 ]  */\n+      if ((mode & 2) == 0)\n+\t{\n+\t  op = optab_for_tree_code (PLUS_EXPR, type, optab_default);\n+\t  if (op == NULL\n+\t      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+\t    return NULL_TREE;\n+\t  cur_op = gimplify_build2 (gsi, PLUS_EXPR, type, cur_op, op0);\n+\t}\n+      cur_op = add_rshift (gsi, type, cur_op, post_shifts);\n+      if (cur_op == NULL_TREE)\n+\treturn NULL_TREE;\n+      tem = add_rshift (gsi, type, op0, shift_temps);\n+      if (tem == NULL_TREE)\n+\treturn NULL_TREE;\n+      op = optab_for_tree_code (MINUS_EXPR, type, optab_default);\n+      if (op == NULL\n+\t  || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+\treturn NULL_TREE;\n+      if ((mode & 1) == 0)\n+\tcur_op = gimplify_build2 (gsi, MINUS_EXPR, type, cur_op, tem);\n+      else\n+\tcur_op = gimplify_build2 (gsi, MINUS_EXPR, type, tem, cur_op);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (code == TRUNC_DIV_EXPR)\n+    return cur_op;\n+\n+  /* We divided.  Now finish by:\n+     t1 = q * oprnd1;\n+     r = oprnd0 - t1;  */\n+  op = optab_for_tree_code (MULT_EXPR, type, optab_default);\n+  if (op == NULL\n+      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+    return NULL_TREE;\n+  tem = gimplify_build2 (gsi, MULT_EXPR, type, cur_op, op1);\n+  op = optab_for_tree_code (MINUS_EXPR, type, optab_default);\n+  if (op == NULL\n+      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n+    return NULL_TREE;\n+  return gimplify_build2 (gsi, MINUS_EXPR, type, op0, tem);\n+}\n+\n static tree\n expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type,\n \t\t\t gimple assign, enum tree_code code)\n@@ -454,6 +963,25 @@ expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type\n \n \t  return expand_vector_comparison (gsi, type, rhs1, rhs2, code);\n \t}\n+\n+      case TRUNC_DIV_EXPR:\n+      case TRUNC_MOD_EXPR:\n+\t{\n+\t  tree rhs1 = gimple_assign_rhs1 (assign);\n+\t  tree rhs2 = gimple_assign_rhs2 (assign);\n+\t  tree ret;\n+\n+\t  if (!optimize\n+\t      || !VECTOR_INTEGER_TYPE_P (type)\n+\t      || TREE_CODE (rhs2) != VECTOR_CST)\n+\t    break;\n+\n+\t  ret = expand_vector_divmod (gsi, type, rhs1, rhs2, code);\n+\t  if (ret != NULL_TREE)\n+\t    return ret;\n+\t  break;\n+\t}\n+\n       default:\n \tbreak;\n       }"}, {"sha": "ff9f8e4ea825c50e4d8b8a38ae4cf55d6231bc4c", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=4ee4c52c64cc1eeda53aae6e221b5b1bd9bd7421", "patch": "@@ -1971,7 +1971,7 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n   else\n     {\n       unsigned HOST_WIDE_INT ml;\n-      int lgup, post_shift;\n+      int post_shift;\n       HOST_WIDE_INT d = tree_low_cst (oprnd1, 0);\n       unsigned HOST_WIDE_INT abs_d;\n       bool add = false;\n@@ -2008,7 +2008,7 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \t/* This case is not handled correctly below.  */\n \treturn NULL;\n \n-      choose_multiplier (abs_d, prec, prec - 1, &ml, &post_shift, &lgup);\n+      choose_multiplier (abs_d, prec, prec - 1, &ml, &post_shift, &dummy_int);\n       if (ml >= (unsigned HOST_WIDE_INT) 1 << (prec - 1))\n \t{\n \t  add = true;"}]}