{"sha": "22609cbf24b0f0477cb11803b3421d9854a6ab00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI2MDljYmYyNGIwZjA0NzdjYjExODAzYjM0MjFkOTg1NGE2YWIwMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-21T00:05:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-21T00:05:40Z"}, "message": "(try_combine): Always call set_significant on new patterns, so don't call\njust in split case.\n\n(subst): Move sign extension inside arithmetic when we have a constant\ncomputation inside another computation.\n\nFrom-SVN: r2194", "tree": {"sha": "a68ffb40e0da8cc55c29d7113f3e0edd8c49cfa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a68ffb40e0da8cc55c29d7113f3e0edd8c49cfa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22609cbf24b0f0477cb11803b3421d9854a6ab00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22609cbf24b0f0477cb11803b3421d9854a6ab00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22609cbf24b0f0477cb11803b3421d9854a6ab00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22609cbf24b0f0477cb11803b3421d9854a6ab00/comments", "author": null, "committer": null, "parents": [{"sha": "80b0e34e580ae4b0598cb2029b1529b5b69752a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80b0e34e580ae4b0598cb2029b1529b5b69752a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80b0e34e580ae4b0598cb2029b1529b5b69752a6"}], "stats": {"total": 57, "additions": 50, "deletions": 7}, "files": [{"sha": "6654e17078d9b74ac94c9742491a3a1c748497e3", "filename": "gcc/combine.c", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22609cbf24b0f0477cb11803b3421d9854a6ab00/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22609cbf24b0f0477cb11803b3421d9854a6ab00/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=22609cbf24b0f0477cb11803b3421d9854a6ab00", "patch": "@@ -1585,17 +1585,12 @@ try_combine (i3, i2, i1)\n \t    newpat = newi3pat;\n \n \t  /* It is possible that both insns now set the destination of I3.\n-\t     If so, we must show an extra use of it and update\n-\t     reg_significant.  */\n+\t     If so, we must show an extra use of it.  */\n \n \t  if (insn_code_number >= 0 && GET_CODE (SET_DEST (i3set)) == REG\n \t      && GET_CODE (SET_DEST (i2set)) == REG\n \t      && REGNO (SET_DEST (i3set)) == REGNO (SET_DEST (i2set)))\n-\t    {\n-\t      reg_n_sets[REGNO (SET_DEST (i2set))]++;\n-\t      set_significant (SET_DEST (i2set), i2set);\n-\t      set_significant (SET_DEST (i3set), i3set);\n-\t    }\n+\t    reg_n_sets[REGNO (SET_DEST (i2set))]++;\n \t}\n \n       /* If we can split it and use I2DEST, go ahead and see if that\n@@ -2073,6 +2068,13 @@ try_combine (i3, i2, i1)\n \t  }\n       }\n \n+    /* Update reg_significant et al for any changes that may have been made\n+       to this insn.  */\n+\n+    note_stores (newpat, set_significant);\n+    if (newi2pat)\n+      note_stores (newi2pat, set_significant);\n+\n     /* If I3 is now an unconditional jump, ensure that it has a \n        BARRIER following it since it may have initially been a\n        conditional jump.  */\n@@ -2670,6 +2672,47 @@ subst (x, from, to, in_dest, unique_copy)\n       SUBST (XEXP (x, 1), temp);\n     }\n \n+  /* If this is a PLUS, MINUS, or MULT, and the first operand is the\n+     sign extension of a PLUS with a constant, reverse the order of the sign\n+     extension and the addition. Note that this not the same as the original\n+     code, but overflow is undefined for signed values.  Also note that the\n+     PLUS will have been partially moved \"inside\" the sign-extension, so that\n+     the first operand of X will really look like:\n+         (ashiftrt (plus (ashift A C4) C5) C4).\n+     We convert this to\n+         (plus (ashiftrt (ashift A C4) C2) C4)\n+     and replace the first operand of X with that expression.  Later parts\n+     of this function may simplify the expression further.\n+\n+     For example, if we start with (mult (sign_extend (plus A C1)) C2),\n+     we swap the SIGN_EXTEND and PLUS.  Later code will apply the\n+     distributive law to produce (plus (mult (sign_extend X) C1) C3).\n+\n+     We do this to simplify address expressions.  */\n+\n+  if ((code == PLUS || code == MINUS || code == MULT)\n+      && GET_CODE (XEXP (x, 0)) == ASHIFTRT\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == ASHIFT\n+      && GET_CODE (XEXP (XEXP (XEXP (XEXP (x, 0), 0), 0), 1)) == CONST_INT\n+      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+      && XEXP (XEXP (XEXP (XEXP (x, 0), 0), 0), 1) == XEXP (XEXP (x, 0), 1)\n+      && GET_CODE (XEXP (XEXP (XEXP (x, 0), 0), 1)) == CONST_INT\n+      && (temp = simplify_binary_operation (ASHIFTRT, mode,\n+\t\t\t\t\t    XEXP (XEXP (XEXP (x, 0), 0), 1),\n+\t\t\t\t\t    XEXP (XEXP (x, 0), 1))) != 0)\n+    {\n+      rtx new\n+\t= simplify_shift_const (NULL_RTX, ASHIFT, mode,\n+\t\t\t\tXEXP (XEXP (XEXP (XEXP (x, 0), 0), 0), 0),\n+\t\t\t\tINTVAL (XEXP (XEXP (x, 0), 1)));\n+\n+      new = simplify_shift_const (NULL_RTX, ASHIFTRT, mode, new,\n+\t\t\t\t  INTVAL (XEXP (XEXP (x, 0), 1)));\n+\n+      SUBST (XEXP (x, 0), gen_binary (PLUS, mode, new, temp));\n+    }\n+\n   /* If this is a simple operation applied to an IF_THEN_ELSE, try \n      applying it to the arms of the IF_THEN_ELSE.  This often simplifies\n      things.  Don't deal with operations that change modes here.  */"}]}