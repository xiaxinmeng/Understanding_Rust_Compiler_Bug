{"sha": "1eede195fc02f5198b48d75b3fb7705c4c1493dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVlZGUxOTVmYzAyZjUxOThiNDhkNzViM2ZiNzcwNWM0YzE0OTNkZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:22:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:22:13Z"}, "message": "[14/46] Make STMT_VINFO_VEC_STMT a stmt_vec_info\n\nThis patch changes STMT_VINFO_VEC_STMT from a gimple stmt to a\nstmt_vec_info and makes the vectorizable_* routines pass back\na stmt_vec_info to vect_transform_stmt.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (_stmt_vec_info::vectorized_stmt): Change from\n\ta gimple stmt to a stmt_vec_info.\n\t(vectorizable_condition, vectorizable_live_operation)\n\t(vectorizable_reduction, vectorizable_induction): Pass back the\n\tvectorized statement as a stmt_vec_info.\n\t* tree-vect-data-refs.c (vect_record_grouped_load_vectors): Update\n\tuse of STMT_VINFO_VEC_STMT.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Likewise,\n\taccumulating the inner phis that feed the STMT_VINFO_VEC_STMT\n\tas stmt_vec_infos rather than gimple stmts.\n\t(vectorize_fold_left_reduction): Change vec_stmt from a gimple stmt\n\tto a stmt_vec_info.\n\t(vectorizable_live_operation): Likewise.\n\t(vectorizable_reduction, vectorizable_induction): Likewise,\n\tupdating use of STMT_VINFO_VEC_STMT.\n\t* tree-vect-stmts.c (vect_get_vec_def_for_operand_1): Update use\n\tof STMT_VINFO_VEC_STMT.\n\t(vect_build_gather_load_calls, vectorizable_bswap, vectorizable_call)\n\t(vectorizable_simd_clone_call, vectorizable_conversion)\n\t(vectorizable_assignment, vectorizable_shift, vectorizable_operation)\n\t(vectorizable_store, vectorizable_load, vectorizable_condition)\n\t(vectorizable_comparison, can_vectorize_live_stmts): Change vec_stmt\n\tfrom a gimple stmt to a stmt_vec_info.\n\t(vect_transform_stmt): Update use of STMT_VINFO_VEC_STMT.  Pass a\n\tpointer to a stmt_vec_info to the vectorizable_* routines.\n\nFrom-SVN: r263129", "tree": {"sha": "d3d4cd7ab08f675d716be4fc022bc6683665a1e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3d4cd7ab08f675d716be4fc022bc6683665a1e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eede195fc02f5198b48d75b3fb7705c4c1493dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eede195fc02f5198b48d75b3fb7705c4c1493dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eede195fc02f5198b48d75b3fb7705c4c1493dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eede195fc02f5198b48d75b3fb7705c4c1493dd/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e"}], "stats": {"total": 179, "additions": 106, "deletions": 73}, "files": [{"sha": "d89186b0f0f87ddc8d15d7d00f34ab363b43fec0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eede195fc02f5198b48d75b3fb7705c4c1493dd", "patch": "@@ -1,3 +1,31 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info::vectorized_stmt): Change from\n+\ta gimple stmt to a stmt_vec_info.\n+\t(vectorizable_condition, vectorizable_live_operation)\n+\t(vectorizable_reduction, vectorizable_induction): Pass back the\n+\tvectorized statement as a stmt_vec_info.\n+\t* tree-vect-data-refs.c (vect_record_grouped_load_vectors): Update\n+\tuse of STMT_VINFO_VEC_STMT.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Likewise,\n+\taccumulating the inner phis that feed the STMT_VINFO_VEC_STMT\n+\tas stmt_vec_infos rather than gimple stmts.\n+\t(vectorize_fold_left_reduction): Change vec_stmt from a gimple stmt\n+\tto a stmt_vec_info.\n+\t(vectorizable_live_operation): Likewise.\n+\t(vectorizable_reduction, vectorizable_induction): Likewise,\n+\tupdating use of STMT_VINFO_VEC_STMT.\n+\t* tree-vect-stmts.c (vect_get_vec_def_for_operand_1): Update use\n+\tof STMT_VINFO_VEC_STMT.\n+\t(vect_build_gather_load_calls, vectorizable_bswap, vectorizable_call)\n+\t(vectorizable_simd_clone_call, vectorizable_conversion)\n+\t(vectorizable_assignment, vectorizable_shift, vectorizable_operation)\n+\t(vectorizable_store, vectorizable_load, vectorizable_condition)\n+\t(vectorizable_comparison, can_vectorize_live_stmts): Change vec_stmt\n+\tfrom a gimple stmt to a stmt_vec_info.\n+\t(vect_transform_stmt): Update use of STMT_VINFO_VEC_STMT.  Pass a\n+\tpointer to a stmt_vec_info to the vectorizable_* routines.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (_stmt_vec_info::related_stmt): Change from"}, {"sha": "476ca5d3a3f6bab4ab03fda69e5080926c3a40d3", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=1eede195fc02f5198b48d75b3fb7705c4c1493dd", "patch": "@@ -6401,18 +6401,17 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n             {\n               if (!DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n                 {\n-\t\t  gimple *prev_stmt =\n-\t\t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt));\n+\t\t  stmt_vec_info prev_stmt_info\n+\t\t    = STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt));\n \t\t  stmt_vec_info rel_stmt_info\n-\t\t    = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (prev_stmt));\n+\t\t    = STMT_VINFO_RELATED_STMT (prev_stmt_info);\n \t\t  while (rel_stmt_info)\n \t\t    {\n-\t\t      prev_stmt = rel_stmt_info;\n+\t\t      prev_stmt_info = rel_stmt_info;\n \t\t      rel_stmt_info = STMT_VINFO_RELATED_STMT (rel_stmt_info);\n \t\t    }\n \n-\t\t  STMT_VINFO_RELATED_STMT (vinfo_for_stmt (prev_stmt))\n-\t\t    = new_stmt_info;\n+\t\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt_info;\n                 }\n             }\n "}, {"sha": "a115fd15c010bd9f70d618b0bb23297689ce04cd", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=1eede195fc02f5198b48d75b3fb7705c4c1493dd", "patch": "@@ -4445,7 +4445,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   gimple *use_stmt, *reduction_phi = NULL;\n   bool nested_in_vect_loop = false;\n   auto_vec<gimple *> new_phis;\n-  auto_vec<gimple *> inner_phis;\n+  auto_vec<stmt_vec_info> inner_phis;\n   enum vect_def_type dt = vect_unknown_def_type;\n   int j, i;\n   auto_vec<tree> scalar_results;\n@@ -4455,7 +4455,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   bool slp_reduc = false;\n   bool direct_slp_reduc;\n   tree new_phi_result;\n-  gimple *inner_phi = NULL;\n+  stmt_vec_info inner_phi = NULL;\n   tree induction_index = NULL_TREE;\n \n   if (slp_node)\n@@ -4605,7 +4605,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       tree indx_before_incr, indx_after_incr;\n       poly_uint64 nunits_out = TYPE_VECTOR_SUBPARTS (vectype);\n \n-      gimple *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+      gimple *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info)->stmt;\n       gcc_assert (gimple_assign_rhs_code (vec_stmt) == VEC_COND_EXPR);\n \n       int scalar_precision\n@@ -4738,20 +4738,21 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       inner_phis.create (vect_defs.length ());\n       FOR_EACH_VEC_ELT (new_phis, i, phi)\n \t{\n+\t  stmt_vec_info phi_info = loop_vinfo->lookup_stmt (phi);\n \t  tree new_result = copy_ssa_name (PHI_RESULT (phi));\n \t  gphi *outer_phi = create_phi_node (new_result, exit_bb);\n \t  SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n \t\t\t   PHI_RESULT (phi));\n \t  prev_phi_info = loop_vinfo->add_stmt (outer_phi);\n-\t  inner_phis.quick_push (phi);\n+\t  inner_phis.quick_push (phi_info);\n \t  new_phis[i] = outer_phi;\n-          while (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi)))\n+\t  while (STMT_VINFO_RELATED_STMT (phi_info))\n             {\n-\t      phi = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi));\n-\t      new_result = copy_ssa_name (PHI_RESULT (phi));\n+\t      phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n+\t      new_result = copy_ssa_name (PHI_RESULT (phi_info->stmt));\n \t      outer_phi = create_phi_node (new_result, exit_bb);\n \t      SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n-\t\t\t       PHI_RESULT (phi));\n+\t\t\t       PHI_RESULT (phi_info->stmt));\n \t      stmt_vec_info outer_phi_info = loop_vinfo->add_stmt (outer_phi);\n \t      STMT_VINFO_RELATED_STMT (prev_phi_info) = outer_phi_info;\n \t      prev_phi_info = outer_phi_info;\n@@ -5644,7 +5645,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t      if (double_reduc)\n \t\tSTMT_VINFO_VEC_STMT (exit_phi_vinfo) = inner_phi;\n \t      else\n-\t\tSTMT_VINFO_VEC_STMT (exit_phi_vinfo) = epilog_stmt;\n+\t\tSTMT_VINFO_VEC_STMT (exit_phi_vinfo)\n+\t\t  = vinfo_for_stmt (epilog_stmt);\n               if (!double_reduc\n                   || STMT_VINFO_DEF_TYPE (exit_phi_vinfo)\n                       != vect_double_reduction_def)\n@@ -5706,8 +5708,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                   add_phi_arg (vect_phi, vect_phi_init,\n                                loop_preheader_edge (outer_loop),\n                                UNKNOWN_LOCATION);\n-                  add_phi_arg (vect_phi, PHI_RESULT (inner_phi),\n-                               loop_latch_edge (outer_loop), UNKNOWN_LOCATION);\n+\t\t  add_phi_arg (vect_phi, PHI_RESULT (inner_phi->stmt),\n+\t\t\t       loop_latch_edge (outer_loop), UNKNOWN_LOCATION);\n                   if (dump_enabled_p ())\n                     {\n                       dump_printf_loc (MSG_NOTE, vect_location,\n@@ -5846,7 +5848,7 @@ vect_expand_fold_left (gimple_stmt_iterator *gsi, tree scalar_dest,\n \n static bool\n vectorize_fold_left_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t       gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t       stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\t       gimple *reduc_def_stmt,\n \t\t\t       tree_code code, internal_fn reduc_fn,\n \t\t\t       tree ops[3], tree vectype_in,\n@@ -6070,7 +6072,7 @@ is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n \n bool\n vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\tgimple **vec_stmt, slp_tree slp_node,\n+\t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\tslp_instance slp_node_instance,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n@@ -6220,7 +6222,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  else\n \t\t    {\n \t\t      if (j == 0)\n-\t\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_phi;\n+\t\t\tSTMT_VINFO_VEC_STMT (stmt_info)\n+\t\t\t  = *vec_stmt = new_phi_info;\n \t\t      else\n \t\t\tSTMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi_info;\n \t\t      prev_phi_info = new_phi_info;\n@@ -7201,7 +7204,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   /* Finalize the reduction-phi (set its arguments) and create the\n      epilog reduction code.  */\n   if ((!single_defuse_cycle || code == COND_EXPR) && !slp_node)\n-    vect_defs[0] = gimple_get_lhs (*vec_stmt);\n+    vect_defs[0] = gimple_get_lhs ((*vec_stmt)->stmt);\n \n   vect_create_epilog_for_reduction (vect_defs, stmt, reduc_def_stmt,\n \t\t\t\t    epilog_copies, reduc_fn, phis,\n@@ -7262,7 +7265,7 @@ vect_worthwhile_without_simd_p (vec_info *vinfo, tree_code code)\n bool\n vectorizable_induction (gimple *phi,\n \t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t\tgimple **vec_stmt, slp_tree slp_node,\n+\t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n@@ -7700,7 +7703,7 @@ vectorizable_induction (gimple *phi,\n   add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n \t       UNKNOWN_LOCATION);\n \n-  STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = induction_phi;\n+  STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = induction_phi_info;\n \n   /* In case that vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -7779,7 +7782,7 @@ vectorizable_induction (gimple *phi,\n \t  gcc_assert (STMT_VINFO_RELEVANT_P (stmt_vinfo)\n \t\t      && !STMT_VINFO_LIVE_P (stmt_vinfo));\n \n-\t  STMT_VINFO_VEC_STMT (stmt_vinfo) = new_stmt;\n+\t  STMT_VINFO_VEC_STMT (stmt_vinfo) = new_stmt_info;\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n@@ -7811,7 +7814,7 @@ bool\n vectorizable_live_operation (gimple *stmt,\n \t\t\t     gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \t\t\t     slp_tree slp_node, int slp_index,\n-\t\t\t     gimple **vec_stmt,\n+\t\t\t     stmt_vec_info *vec_stmt,\n \t\t\t     stmt_vector_for_cost *)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);"}, {"sha": "8890b10de58df23f77e171985608f7900296135a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=1eede195fc02f5198b48d75b3fb7705c4c1493dd", "patch": "@@ -1465,7 +1465,7 @@ tree\n vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n {\n   tree vec_oprnd;\n-  gimple *vec_stmt;\n+  stmt_vec_info vec_stmt_info;\n   stmt_vec_info def_stmt_info = NULL;\n \n   switch (dt)\n@@ -1482,21 +1482,19 @@ vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n         /* Get the def from the vectorized stmt.  */\n         def_stmt_info = vinfo_for_stmt (def_stmt);\n \n-        vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n-        /* Get vectorized pattern statement.  */\n-        if (!vec_stmt\n-            && STMT_VINFO_IN_PATTERN_P (def_stmt_info)\n-            && !STMT_VINFO_RELEVANT (def_stmt_info))\n-\t  vec_stmt = (STMT_VINFO_VEC_STMT\n-\t\t      (STMT_VINFO_RELATED_STMT (def_stmt_info)));\n-        gcc_assert (vec_stmt);\n-\tif (gimple_code (vec_stmt) == GIMPLE_PHI)\n-\t  vec_oprnd = PHI_RESULT (vec_stmt);\n-\telse if (is_gimple_call (vec_stmt))\n-\t  vec_oprnd = gimple_call_lhs (vec_stmt);\n+\tvec_stmt_info = STMT_VINFO_VEC_STMT (def_stmt_info);\n+\t/* Get vectorized pattern statement.  */\n+\tif (!vec_stmt_info\n+\t    && STMT_VINFO_IN_PATTERN_P (def_stmt_info)\n+\t    && !STMT_VINFO_RELEVANT (def_stmt_info))\n+\t  vec_stmt_info = (STMT_VINFO_VEC_STMT\n+\t\t\t   (STMT_VINFO_RELATED_STMT (def_stmt_info)));\n+\tgcc_assert (vec_stmt_info);\n+\tif (gphi *phi = dyn_cast <gphi *> (vec_stmt_info->stmt))\n+\t  vec_oprnd = PHI_RESULT (phi);\n \telse\n-\t  vec_oprnd = gimple_assign_lhs (vec_stmt);\n-        return vec_oprnd;\n+\t  vec_oprnd = gimple_get_lhs (vec_stmt_info->stmt);\n+\treturn vec_oprnd;\n       }\n \n     /* operand is defined by a loop header phi.  */\n@@ -1507,14 +1505,14 @@ vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n       {\n \tgcc_assert (gimple_code (def_stmt) == GIMPLE_PHI);\n \n-        /* Get the def from the vectorized stmt.  */\n-        def_stmt_info = vinfo_for_stmt (def_stmt);\n-        vec_stmt = STMT_VINFO_VEC_STMT (def_stmt_info);\n-\tif (gimple_code (vec_stmt) == GIMPLE_PHI)\n-\t  vec_oprnd = PHI_RESULT (vec_stmt);\n+\t/* Get the def from the vectorized stmt.  */\n+\tdef_stmt_info = vinfo_for_stmt (def_stmt);\n+\tvec_stmt_info = STMT_VINFO_VEC_STMT (def_stmt_info);\n+\tif (gphi *phi = dyn_cast <gphi *> (vec_stmt_info->stmt))\n+\t  vec_oprnd = PHI_RESULT (phi);\n \telse\n-\t  vec_oprnd = gimple_get_lhs (vec_stmt);\n-        return vec_oprnd;\n+\t  vec_oprnd = gimple_get_lhs (vec_stmt_info->stmt);\n+\treturn vec_oprnd;\n       }\n \n     default:\n@@ -2674,8 +2672,9 @@ vect_build_zero_merge_argument (gimple *stmt, tree vectype)\n \n static void\n vect_build_gather_load_calls (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t      gimple **vec_stmt, gather_scatter_info *gs_info,\n-\t\t\t      tree mask, vect_def_type mask_dt)\n+\t\t\t      stmt_vec_info *vec_stmt,\n+\t\t\t      gather_scatter_info *gs_info, tree mask,\n+\t\t\t      vect_def_type mask_dt)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -2960,7 +2959,7 @@ vect_get_data_ptr_increment (data_reference *dr, tree aggr_type,\n \n static bool\n vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t    gimple **vec_stmt, slp_tree slp_node,\n+\t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t    tree vectype_in, enum vect_def_type *dt,\n \t\t    stmt_vector_for_cost *cost_vec)\n {\n@@ -3104,8 +3103,9 @@ simple_integer_narrowing (tree vectype_out, tree vectype_in,\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n static bool\n-vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n-\t\t   slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n+vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi,\n+\t\t   stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t   stmt_vector_for_cost *cost_vec)\n {\n   gcall *stmt;\n   tree vec_dest;\n@@ -3745,7 +3745,7 @@ simd_clone_subparts (tree vectype)\n \n static bool\n vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t      gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t      stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\t      stmt_vector_for_cost *)\n {\n   tree vec_dest;\n@@ -4596,7 +4596,7 @@ vect_create_vectorized_promotion_stmts (vec<tree> *vec_oprnds0,\n \n static bool\n vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\t stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n@@ -5204,7 +5204,7 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \n static bool\n vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\t stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n@@ -5405,7 +5405,7 @@ vect_supportable_shift (enum tree_code code, tree scalar_type)\n \n static bool\n vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n-                    gimple **vec_stmt, slp_tree slp_node,\n+\t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n@@ -5769,7 +5769,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n \n static bool\n vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\tgimple **vec_stmt, slp_tree slp_node,\n+\t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n@@ -6222,8 +6222,9 @@ get_group_alias_ptr_type (gimple *first_stmt)\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n static bool\n-vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n-                    slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n+vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n+\t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree data_ref;\n   tree op;\n@@ -7385,8 +7386,9 @@ hoist_defs_of_uses (gimple *stmt, struct loop *loop)\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n \n static bool\n-vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n-                   slp_tree slp_node, slp_instance slp_node_instance,\n+vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n+\t\t   stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t   slp_instance slp_node_instance,\n \t\t   stmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest;\n@@ -8710,8 +8712,9 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n \n bool\n vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\tgimple **vec_stmt, tree reduc_def, int reduc_index,\n-\t\t\tslp_tree slp_node, stmt_vector_for_cost *cost_vec)\n+\t\t\tstmt_vec_info *vec_stmt, tree reduc_def,\n+\t\t\tint reduc_index, slp_tree slp_node,\n+\t\t\tstmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest = NULL_TREE;\n   tree vec_dest = NULL_TREE;\n@@ -9111,7 +9114,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \n static bool\n vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t gimple **vec_stmt, tree reduc_def,\n+\t\t\t stmt_vec_info *vec_stmt, tree reduc_def,\n \t\t\t slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   tree lhs, rhs1, rhs2;\n@@ -9383,7 +9386,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n \n static bool\n can_vectorize_live_stmts (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t\t  slp_tree slp_node, gimple **vec_stmt,\n+\t\t\t  slp_tree slp_node, stmt_vec_info *vec_stmt,\n \t\t\t  stmt_vector_for_cost *cost_vec)\n {\n   if (slp_node)\n@@ -9647,11 +9650,11 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n   bool is_store = false;\n-  gimple *vec_stmt = NULL;\n+  stmt_vec_info vec_stmt = NULL;\n   bool done;\n \n   gcc_assert (slp_node || !PURE_SLP_STMT (stmt_info));\n-  gimple *old_vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+  stmt_vec_info old_vec_stmt_info = STMT_VINFO_VEC_STMT (stmt_info);\n \n   bool nested_p = (STMT_VINFO_LOOP_VINFO (stmt_info)\n \t\t   && nested_in_vect_loop_p\n@@ -9752,7 +9755,7 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n      This would break hybrid SLP vectorization.  */\n   if (slp_node)\n     gcc_assert (!vec_stmt\n-\t\t&& STMT_VINFO_VEC_STMT (stmt_info) == old_vec_stmt);\n+\t\t&& STMT_VINFO_VEC_STMT (stmt_info) == old_vec_stmt_info);\n \n   /* Handle inner-loop stmts whose DEF is used in the loop-nest that\n      is being vectorized, but outside the immediately enclosing loop.  */"}, {"sha": "1fb2513ed751e57370e95a949ded5807cf1e7740", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eede195fc02f5198b48d75b3fb7705c4c1493dd/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1eede195fc02f5198b48d75b3fb7705c4c1493dd", "patch": "@@ -812,7 +812,7 @@ struct _stmt_vec_info {\n   tree vectype;\n \n   /* The vectorized version of the stmt.  */\n-  gimple *vectorized_stmt;\n+  stmt_vec_info vectorized_stmt;\n \n \n   /* The following is relevant only for stmts that contain a non-scalar\n@@ -1560,7 +1560,7 @@ extern void vect_remove_stores (gimple *);\n extern bool vect_analyze_stmt (gimple *, bool *, slp_tree, slp_instance,\n \t\t\t       stmt_vector_for_cost *);\n extern bool vectorizable_condition (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t    gimple **, tree, int, slp_tree,\n+\t\t\t\t    stmt_vec_info *, tree, int, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n extern void vect_get_load_cost (stmt_vec_info, int, bool,\n \t\t\t\tunsigned int *, unsigned int *,\n@@ -1649,13 +1649,13 @@ extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n extern struct loop *vect_transform_loop (loop_vec_info);\n extern loop_vec_info vect_analyze_loop_form (struct loop *, vec_info_shared *);\n extern bool vectorizable_live_operation (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t\t slp_tree, int, gimple **,\n+\t\t\t\t\t slp_tree, int, stmt_vec_info *,\n \t\t\t\t\t stmt_vector_for_cost *);\n extern bool vectorizable_reduction (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t    gimple **, slp_tree, slp_instance,\n+\t\t\t\t    stmt_vec_info *, slp_tree, slp_instance,\n \t\t\t\t    stmt_vector_for_cost *);\n extern bool vectorizable_induction (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t    gimple **, slp_tree,\n+\t\t\t\t    stmt_vec_info *, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n extern tree get_initial_def_for_reduction (gimple *, tree, tree *);\n extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);"}]}