{"sha": "e576ddb5eb9a9101eef5ddf09666bc56274c350a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU3NmRkYjVlYjlhOTEwMWVlZjVkZGYwOTY2NmJjNTYyNzRjMzUwYQ==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@gmail.com", "date": "2018-03-03T16:38:14Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-03-03T16:38:14Z"}, "message": "[NDS32] Add intrinsic functions for unalignment memory access.\n\ngcc/\n\t* config/nds32/constants.md (unspec_element): New enum.\n\t* config/nds32/constraints.md (Umw): New constraint.\n\t* config/nds32/nds32-intrinsic.c: Add more builtin functions.\n\t* config/nds32/nds32-intrinsic.md: Likewise.\n\t* config/nds32/nds32-md-auxiliary.c (nds32_regno_to_enable4): New.\n\t(nds32_valid_smw_lwm_base_p): New.\n\t(nds32_output_smw_single_word): New.\n\t(nds32_output_lmw_single_word): New.\n\t(nds32_expand_unaligned_load): New.\n\t(nds32_expand_unaligned_store): New.\n\t* config/nds32/nds32-protos.h (nds32_valid_smw_lwm_base_p): Declare.\n\t(nds32_output_smw_single_word): Declare.\n\t(nds32_output_lmw_single_word): Declare.\n\t(nds32_expand_unaligned_load): Declare.\n\t(nds32_expand_unaligned_store): Declare.\n\t* config/nds32/nds32.h (nds32_builtins): Add NDS32_BUILTIN_UALOAD_HW,\n\tNDS32_BUILTIN_UALOAD_W, NDS32_BUILTIN_UALOAD_DW,\n\tNDS32_BUILTIN_UASTORE_HW, NDS32_BUILTIN_UASTORE_W,\n\tNDS32_BUILTIN_UASTORE_DW.\n\t* config/nds32/predicates.md (nds32_lmw_smw_base_operand): New\n\tpredicate.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r258214", "tree": {"sha": "df8092ad7e195b624e1685e1962fc9d8b6cbf9d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df8092ad7e195b624e1685e1962fc9d8b6cbf9d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e576ddb5eb9a9101eef5ddf09666bc56274c350a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e576ddb5eb9a9101eef5ddf09666bc56274c350a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e576ddb5eb9a9101eef5ddf09666bc56274c350a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e576ddb5eb9a9101eef5ddf09666bc56274c350a/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1"}], "stats": {"total": 529, "additions": 529, "deletions": 0}, "files": [{"sha": "cfb1b16b672762da5ab4b1b2dddc5a73dd7dbab0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -1,3 +1,29 @@\n+2018-03-03  Kito Cheng  <kito.cheng@gmail.com>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/constants.md (unspec_element): New enum.\n+\t* config/nds32/constraints.md (Umw): New constraint.\n+\t* config/nds32/nds32-intrinsic.c: Add more builtin functions.\n+\t* config/nds32/nds32-intrinsic.md: Likewise.\n+\t* config/nds32/nds32-md-auxiliary.c (nds32_regno_to_enable4): New.\n+\t(nds32_valid_smw_lwm_base_p): New.\n+\t(nds32_output_smw_single_word): New.\n+\t(nds32_output_lmw_single_word): New.\n+\t(nds32_expand_unaligned_load): New.\n+\t(nds32_expand_unaligned_store): New.\n+\t* config/nds32/nds32-protos.h (nds32_valid_smw_lwm_base_p): Declare.\n+\t(nds32_output_smw_single_word): Declare.\n+\t(nds32_output_lmw_single_word): Declare.\n+\t(nds32_expand_unaligned_load): Declare.\n+\t(nds32_expand_unaligned_store): Declare.\n+\t* config/nds32/nds32.h (nds32_builtins): Add NDS32_BUILTIN_UALOAD_HW,\n+\tNDS32_BUILTIN_UALOAD_W, NDS32_BUILTIN_UALOAD_DW,\n+\tNDS32_BUILTIN_UASTORE_HW, NDS32_BUILTIN_UASTORE_W,\n+\tNDS32_BUILTIN_UASTORE_DW.\n+\t* config/nds32/predicates.md (nds32_lmw_smw_base_operand): New\n+\tpredicate.\n+\n 2018-03-03  Monk Chiang  <sh.chiang04@gmail.com>\n \t    Kito Cheng  <kito.cheng@gmail.com>\n \t    Chung-Ju Wu  <jasonwucj@gmail.com>"}, {"sha": "803534bb4ad8b8cf2af9ad1abe55b64d3f998215", "filename": "gcc/config/nds32/constants.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fconstants.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fconstants.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fconstants.md?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -30,6 +30,16 @@\n   ])\n \n \n+;; The unpec operation index.\n+(define_c_enum \"unspec_element\" [\n+  UNSPEC_UALOAD_HW\n+  UNSPEC_UALOAD_W\n+  UNSPEC_UALOAD_DW\n+  UNSPEC_UASTORE_HW\n+  UNSPEC_UASTORE_W\n+  UNSPEC_UASTORE_DW\n+])\n+\n ;; The unspec_volatile operation index.\n (define_c_enum \"unspec_volatile_element\" [\n   UNSPEC_VOLATILE_ISYNC"}, {"sha": "a66c80332300dfe8f0f670b01022b8248ce814d7", "filename": "gcc/config/nds32/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fconstraints.md?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -303,4 +303,10 @@\n \t\t    || nds32_mem_format (op) == ADDRESS_FP_IMM7U)\n \t\t    && (GET_MODE (op) == SImode)\")))\n \n+\n+(define_memory_constraint \"Umw\"\n+  \"Memory constraint for lwm/smw\"\n+  (and (match_code \"mem\")\n+       (match_test \"nds32_valid_smw_lwm_base_p (op)\")))\n+\n ;; ------------------------------------------------------------------------"}, {"sha": "bf51154c8ca10248f1c2517ed143240bb0a7603d", "filename": "gcc/config/nds32/nds32-intrinsic.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -241,6 +241,9 @@ struct builtin_description\n /* Intrinsics that take just one argument.  */\n static struct builtin_description bdesc_1arg[] =\n {\n+  NDS32_BUILTIN(unaligned_load_hw, \"unaligned_load_hw\", UALOAD_HW)\n+  NDS32_BUILTIN(unaligned_loadsi, \"unaligned_load_w\", UALOAD_W)\n+  NDS32_BUILTIN(unaligned_loaddi, \"unaligned_load_dw\", UALOAD_DW)\n   NDS32_NO_TARGET_BUILTIN(unspec_volatile_isync, \"isync\", ISYNC)\n };\n \n@@ -256,6 +259,10 @@ static struct builtin_description bdesc_2arg[] =\n {\n   NDS32_NO_TARGET_BUILTIN(unspec_volatile_mtsr, \"mtsr\", MTSR)\n   NDS32_NO_TARGET_BUILTIN(unspec_volatile_mtusr, \"mtusr\", MTUSR)\n+  NDS32_NO_TARGET_BUILTIN(unaligned_store_hw, \"unaligned_store_hw\", UASTORE_HW)\n+  NDS32_NO_TARGET_BUILTIN(unaligned_storesi, \"unaligned_store_hw\", UASTORE_W)\n+  NDS32_NO_TARGET_BUILTIN(unaligned_storedi, \"unaligned_store_hw\", UASTORE_DW)\n+\n };\n \n rtx\n@@ -355,7 +362,9 @@ nds32_init_builtins_impl (void)\n \t\t\tNDS32_BUILTIN_ ## CODE, BUILT_IN_MD, NULL, NULL_TREE)\n \n   /* Looking for return type and argument can be found in tree.h file.  */\n+  tree ptr_ushort_type_node = build_pointer_type (short_unsigned_type_node);\n   tree ptr_uint_type_node = build_pointer_type (unsigned_type_node);\n+  tree ptr_ulong_type_node = build_pointer_type (long_long_unsigned_type_node);\n \n   /* Cache.  */\n   ADD_NDS32_BUILTIN1 (\"isync\", void, ptr_uint, ISYNC);\n@@ -370,4 +379,17 @@ nds32_init_builtins_impl (void)\n   /* Interrupt.  */\n   ADD_NDS32_BUILTIN0 (\"setgie_en\", void, SETGIE_EN);\n   ADD_NDS32_BUILTIN0 (\"setgie_dis\", void, SETGIE_DIS);\n+\n+  /* Unaligned Load/Store  */\n+  ADD_NDS32_BUILTIN1 (\"unaligned_load_hw\", short_unsigned, ptr_ushort,\n+\t\t      UALOAD_HW);\n+  ADD_NDS32_BUILTIN1 (\"unaligned_load_w\", unsigned, ptr_uint, UALOAD_W);\n+  ADD_NDS32_BUILTIN1 (\"unaligned_load_dw\", long_long_unsigned, ptr_ulong,\n+\t\t      UALOAD_DW);\n+  ADD_NDS32_BUILTIN2 (\"unaligned_store_hw\", void, ptr_ushort, short_unsigned,\n+\t\t      UASTORE_HW);\n+  ADD_NDS32_BUILTIN2 (\"unaligned_store_w\", void, ptr_uint, unsigned, UASTORE_W);\n+  ADD_NDS32_BUILTIN2 (\"unaligned_store_dw\", void, ptr_ulong, long_long_unsigned,\n+\t\t      UASTORE_DW);\n+\n }"}, {"sha": "a4a32ceea95437266b6eb66e8d017b5d0a267dc1", "filename": "gcc/config/nds32/nds32-intrinsic.md", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.md?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -94,4 +94,150 @@\n   [(set_attr \"type\" \"misc\")]\n )\n \n+;;Unaligned Load/Store\n+\n+(define_expand \"unaligned_load_hw\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(unspec:HI [(mem:HI (match_operand:SI 1 \"register_operand\" \"\"))] UNSPEC_UALOAD_HW))]\n+  \"\"\n+{\n+  operands[0] = simplify_gen_subreg (SImode, operands[0],\n+\t\t\t\t     GET_MODE (operands[0]), 0);\n+  if (TARGET_ISA_V3M)\n+    {\n+      nds32_expand_unaligned_load (operands, HImode);\n+    }\n+  else\n+    {\n+      emit_insn (gen_unaligned_load_w (operands[0],\n+\t\t\t\t       gen_rtx_MEM (SImode, operands[1])));\n+\n+      if (WORDS_BIG_ENDIAN)\n+\temit_insn (gen_lshrsi3 (operands[0], operands[0], GEN_INT(16)));\n+      else\n+\temit_insn (gen_andsi3 (operands[0], operands[0], GEN_INT (0xffff)));\n+    }\n+\n+  DONE;\n+})\n+\n+(define_expand \"unaligned_loadsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))] UNSPEC_UALOAD_W))]\n+  \"\"\n+{\n+  if (TARGET_ISA_V3M)\n+    nds32_expand_unaligned_load (operands, SImode);\n+  else\n+    emit_insn (gen_unaligned_load_w (operands[0],\n+\t\t\t\t     gen_rtx_MEM (SImode, (operands[1]))));\n+  DONE;\n+})\n+\n+(define_insn \"unaligned_load_w\"\n+  [(set (match_operand:SI 0 \"register_operand\"                       \"=  r\")\n+\t(unspec:SI [(match_operand:SI 1 \"nds32_lmw_smw_base_operand\" \" Umw\")] UNSPEC_UALOAD_W))]\n+  \"\"\n+{\n+  return nds32_output_lmw_single_word (operands);\n+}\n+  [(set_attr \"type\"   \"load\")\n+   (set_attr \"length\"    \"4\")]\n+)\n+\n+(define_expand \"unaligned_loaddi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(mem:DI (match_operand:SI 1 \"register_operand\" \"r\"))] UNSPEC_UALOAD_DW))]\n+  \"\"\n+{\n+  if (TARGET_ISA_V3M)\n+    {\n+      nds32_expand_unaligned_load (operands, DImode);\n+    }\n+  else\n+    emit_insn (gen_unaligned_load_dw (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"unaligned_load_dw\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(mem:DI (match_operand:SI 1 \"register_operand\" \"r\"))] UNSPEC_UALOAD_DW))]\n+  \"\"\n+{\n+  rtx otherops[3];\n+  otherops[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n+  otherops[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+  otherops[2] = operands[1];\n+\n+  output_asm_insn (\"lmw.bi\\t%0, [%2], %1, 0\", otherops);\n+  return \"\";\n+}\n+  [(set_attr \"type\"   \"load\")\n+   (set_attr \"length\"    \"4\")]\n+)\n+\n+(define_expand \"unaligned_store_hw\"\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"\"))\n+\t(unspec:HI [(match_operand:HI 1 \"register_operand\" \"\")] UNSPEC_UASTORE_HW))]\n+  \"\"\n+{\n+  operands[1] = simplify_gen_subreg (SImode, operands[1],\n+\t\t\t\t     GET_MODE (operands[1]), 0);\n+  nds32_expand_unaligned_store (operands, HImode);\n+  DONE;\n+})\n+\n+(define_expand \"unaligned_storesi\"\n+  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")] UNSPEC_UASTORE_W))]\n+  \"\"\n+{\n+  if (TARGET_ISA_V3M)\n+    nds32_expand_unaligned_store (operands, SImode);\n+  else\n+    emit_insn (gen_unaligned_store_w (gen_rtx_MEM (SImode, operands[0]),\n+\t\t\t\t      operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"unaligned_store_w\"\n+  [(set (match_operand:SI 0 \"nds32_lmw_smw_base_operand\"   \"=Umw\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"   r\")] UNSPEC_UASTORE_W))]\n+  \"\"\n+{\n+  return nds32_output_smw_single_word (operands);\n+}\n+  [(set_attr \"type\"   \"store\")\n+   (set_attr \"length\"     \"4\")]\n+)\n+\n+(define_expand \"unaligned_storedi\"\n+  [(set (mem:DI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")] UNSPEC_UASTORE_DW))]\n+  \"\"\n+{\n+  if (TARGET_ISA_V3M)\n+    nds32_expand_unaligned_store (operands, DImode);\n+  else\n+    emit_insn (gen_unaligned_store_dw (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"unaligned_store_dw\"\n+  [(set (mem:DI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")] UNSPEC_UASTORE_DW))]\n+  \"\"\n+{\n+  rtx otherops[3];\n+  otherops[0] = gen_rtx_REG (SImode, REGNO (operands[1]));\n+  otherops[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n+  otherops[2] = operands[0];\n+\n+  output_asm_insn (\"smw.bi\\t%0, [%2], %1, 0\", otherops);\n+  return \"\";\n+}\n+  [(set_attr \"type\"   \"store\")\n+   (set_attr \"length\"     \"4\")]\n+)\n+\n ;; ------------------------------------------------------------------------"}, {"sha": "755945f5f2a9e0bc39206c6be1f7a1c050579b28", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -36,9 +36,28 @@\n #include \"recog.h\"\n #include \"output.h\"\n #include \"tm-constrs.h\"\n+#include \"expr.h\"\n \n /* ------------------------------------------------------------------------ */\n \n+static int\n+nds32_regno_to_enable4 (unsigned regno)\n+{\n+  switch (regno)\n+    {\n+    case 28: /* $r28/fp */\n+      return 0x8;\n+    case 29: /* $r29/gp */\n+      return 0x4;\n+    case 30: /* $r30/lp */\n+      return 0x2;\n+    case 31: /* $r31/sp */\n+      return 0x1;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* A helper function to return character based on byte size.  */\n static char\n nds32_byte_to_size (int byte)\n@@ -849,4 +868,280 @@ nds32_output_casesi (rtx *operands)\n     return \"jr\\t%2\";\n }\n \n+/* Auxiliary functions for lwm/smw.  */\n+bool\n+nds32_valid_smw_lwm_base_p (rtx op)\n+{\n+  rtx base_addr;\n+\n+  if (!MEM_P (op))\n+    return false;\n+\n+  base_addr = XEXP (op, 0);\n+\n+  if (REG_P (base_addr))\n+    return true;\n+  else\n+    {\n+      if (GET_CODE (base_addr) == POST_INC\n+\t  && REG_P (XEXP (base_addr, 0)))\n+        return true;\n+    }\n+\n+  return false;\n+}\n+\n /* ------------------------------------------------------------------------ */\n+const char *\n+nds32_output_smw_single_word (rtx *operands)\n+{\n+  char buff[100];\n+  unsigned regno;\n+  int enable4;\n+  bool update_base_p;\n+  rtx base_addr = operands[0];\n+  rtx base_reg;\n+  rtx otherops[2];\n+\n+  if (REG_P (XEXP (base_addr, 0)))\n+    {\n+      update_base_p = false;\n+      base_reg = XEXP (base_addr, 0);\n+    }\n+  else\n+    {\n+      update_base_p = true;\n+      base_reg = XEXP (XEXP (base_addr, 0), 0);\n+    }\n+\n+  const char *update_base = update_base_p ? \"m\" : \"\";\n+\n+  regno = REGNO (operands[1]);\n+\n+  otherops[0] = base_reg;\n+  otherops[1] = operands[1];\n+\n+  if (regno >= 28)\n+    {\n+      enable4 = nds32_regno_to_enable4 (regno);\n+      sprintf (buff, \"smw.bi%s\\t$sp, [%%0], $sp, %x\", update_base, enable4);\n+    }\n+  else\n+    {\n+      sprintf (buff, \"smw.bi%s\\t%%1, [%%0], %%1\", update_base);\n+    }\n+  output_asm_insn (buff, otherops);\n+  return \"\";\n+}\n+\n+const char *\n+nds32_output_lmw_single_word (rtx *operands)\n+{\n+  char buff[100];\n+  unsigned regno;\n+  bool update_base_p;\n+  int enable4;\n+  rtx base_addr = operands[1];\n+  rtx base_reg;\n+  rtx otherops[2];\n+\n+  if (REG_P (XEXP (base_addr, 0)))\n+    {\n+      update_base_p = false;\n+      base_reg = XEXP (base_addr, 0);\n+    }\n+  else\n+    {\n+      update_base_p = true;\n+      base_reg = XEXP (XEXP (base_addr, 0), 0);\n+    }\n+\n+  const char *update_base = update_base_p ? \"m\" : \"\";\n+\n+  regno = REGNO (operands[0]);\n+\n+  otherops[0] = operands[0];\n+  otherops[1] = base_reg;\n+\n+  if (regno >= 28)\n+    {\n+      enable4 = nds32_regno_to_enable4 (regno);\n+      sprintf (buff, \"lmw.bi%s\\t$sp, [%%1], $sp, %x\", update_base, enable4);\n+    }\n+  else\n+    {\n+      sprintf (buff, \"lmw.bi%s\\t%%0, [%%1], %%0\", update_base);\n+    }\n+  output_asm_insn (buff, otherops);\n+  return \"\";\n+}\n+\n+void\n+nds32_expand_unaligned_load (rtx *operands, enum machine_mode mode)\n+{\n+  /* Initial memory offset.  */\n+  int offset = WORDS_BIG_ENDIAN ? GET_MODE_SIZE (mode) - 1 : 0;\n+  int offset_adj = WORDS_BIG_ENDIAN ? -1 : 1;\n+  /* Initial register shift byte.  */\n+  int shift = 0;\n+  /* The first load byte instruction is not the same. */\n+  int width = GET_MODE_SIZE (mode) - 1;\n+  rtx mem[2];\n+  rtx reg[2];\n+  rtx sub_reg;\n+  rtx temp_reg, temp_sub_reg;\n+  int num_reg;\n+\n+  /* Generating a series of load byte instructions.\n+     The first load byte instructions and other\n+     load byte instructions are not the same. like:\n+     First:\n+       lbi reg0, [mem]\n+       zeh reg0, reg0\n+     Second:\n+       lbi temp_reg, [mem + offset]\n+       sll temp_reg, (8 * shift)\n+       ior reg0, temp_reg\n+\n+       lbi temp_reg, [mem + (offset + 1)]\n+       sll temp_reg, (8 * (shift + 1))\n+       ior reg0, temp_reg  */\n+\n+  temp_reg = gen_reg_rtx (SImode);\n+  temp_sub_reg = gen_lowpart (QImode, temp_reg);\n+\n+  if (mode == DImode)\n+    {\n+      /* Load doubleword, we need two registers to access.  */\n+      reg[0] = simplify_gen_subreg (SImode, operands[0],\n+\t\t\t\t    GET_MODE (operands[0]), 0);\n+      reg[1] = simplify_gen_subreg (SImode, operands[0],\n+\t\t\t\t    GET_MODE (operands[0]), 4);\n+      /* A register only store 4 byte.  */\n+      width = GET_MODE_SIZE (SImode) - 1;\n+    }\n+  else\n+    {\n+      reg[0] = operands[0];\n+    }\n+\n+  for (num_reg = (mode == DImode) ? 2 : 1; num_reg > 0; num_reg--)\n+    {\n+      sub_reg = gen_lowpart (QImode, reg[0]);\n+      mem[0] = gen_rtx_MEM (QImode, plus_constant (Pmode, operands[1], offset));\n+\n+      /* Generating the first part instructions.\n+\t   lbi reg0, [mem]\n+\t   zeh reg0, reg0 */\n+      emit_move_insn (sub_reg, mem[0]);\n+      emit_insn (gen_zero_extendqisi2 (reg[0], sub_reg));\n+\n+      while (width > 0)\n+\t{\n+\t  offset = offset + offset_adj;\n+\t  shift++;\n+\t  width--;\n+\n+\t  mem[1] = gen_rtx_MEM (QImode, plus_constant (Pmode,\n+\t\t\t\t\t\t       operands[1],\n+\t\t\t\t\t\t       offset));\n+\t  /* Generating the second part instructions.\n+\t       lbi temp_reg, [mem + offset]\n+\t       sll temp_reg, (8 * shift)\n+\t       ior reg0, temp_reg  */\n+\t  emit_move_insn (temp_sub_reg, mem[1]);\n+\t  emit_insn (gen_ashlsi3 (temp_reg, temp_reg,\n+\t\t\t\t  GEN_INT (shift * 8)));\n+\t  emit_insn (gen_iorsi3 (reg[0], reg[0], temp_reg));\n+\t}\n+\n+      if (mode == DImode)\n+\t{\n+\t  /* Using the second register to load memory information. */\n+\t  reg[0] = reg[1];\n+\t  shift = 0;\n+\t  width = GET_MODE_SIZE (SImode) - 1;\n+\t  offset = offset + offset_adj;\n+\t}\n+    }\n+}\n+\n+void\n+nds32_expand_unaligned_store (rtx *operands, enum machine_mode mode)\n+{\n+  /* Initial memory offset.  */\n+  int offset = WORDS_BIG_ENDIAN ? GET_MODE_SIZE (mode) - 1 : 0;\n+  int offset_adj = WORDS_BIG_ENDIAN ? -1 : 1;\n+  /* Initial register shift byte.  */\n+  int shift = 0;\n+  /* The first load byte instruction is not the same. */\n+  int width = GET_MODE_SIZE (mode) - 1;\n+  rtx mem[2];\n+  rtx reg[2];\n+  rtx sub_reg;\n+  rtx temp_reg, temp_sub_reg;\n+  int num_reg;\n+\n+  /* Generating a series of store byte instructions.\n+     The first store byte instructions and other\n+     load byte instructions are not the same. like:\n+     First:\n+\tsbi  reg0, [mem + 0]\n+     Second:\n+\tsrli    temp_reg, reg0, (8 * shift)\n+\tsbi\ttemp_reg, [mem + offset]  */\n+\n+  temp_reg = gen_reg_rtx (SImode);\n+  temp_sub_reg = gen_lowpart (QImode, temp_reg);\n+\n+  if (mode == DImode)\n+    {\n+      /* Load doubleword, we need two registers to access.  */\n+      reg[0] = simplify_gen_subreg (SImode, operands[1],\n+\t\t\t\t    GET_MODE (operands[1]), 0);\n+      reg[1] = simplify_gen_subreg (SImode, operands[1],\n+\t\t\t\t    GET_MODE (operands[1]), 4);\n+      /* A register only store 4 byte.  */\n+      width = GET_MODE_SIZE (SImode) - 1;\n+    }\n+  else\n+    {\n+      reg[0] = operands[1];\n+    }\n+\n+  for (num_reg = (mode == DImode) ? 2 : 1; num_reg > 0; num_reg--)\n+    {\n+      sub_reg = gen_lowpart (QImode, reg[0]);\n+      mem[0] = gen_rtx_MEM (QImode, plus_constant (Pmode, operands[0], offset));\n+\n+      /* Generating the first part instructions.\n+\t   sbi reg0, [mem + 0] */\n+      emit_move_insn (mem[0], sub_reg);\n+\n+      while (width > 0)\n+\t{\n+\t  offset = offset + offset_adj;\n+\t  shift++;\n+\t  width--;\n+\n+\t  mem[1] = gen_rtx_MEM (QImode, plus_constant (Pmode,\n+\t\t\t\t\t\t       operands[0],\n+\t\t\t\t\t\t       offset));\n+\t  /* Generating the second part instructions.\n+\t       srli  temp_reg, reg0, (8 * shift)\n+\t       sbi   temp_reg, [mem + offset]  */\n+\t  emit_insn (gen_lshrsi3 (temp_reg, reg[0],\n+\t\t\t\t  GEN_INT (shift * 8)));\n+\t  emit_move_insn (mem[1], temp_sub_reg);\n+\t}\n+\n+      if (mode == DImode)\n+\t{\n+\t  /* Using the second register to load memory information. */\n+\t  reg[0] = reg[1];\n+\t  shift = 0;\n+\t  width = GET_MODE_SIZE (SImode) - 1;\n+\t  offset = offset + offset_adj;\n+\t}\n+    }\n+}"}, {"sha": "a8ffb8c97703040534b6442daf4da6784e304594", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -60,12 +60,24 @@ extern void nds32_expand_epilogue_v3pop (bool);\n \n extern bool nds32_ls_333_p (rtx, rtx, rtx, machine_mode);\n \n+/* Auxiliary functions for lwm/smw.  */\n+\n+extern bool nds32_valid_smw_lwm_base_p (rtx);\n+\n /* Auxiliary functions for expanding rtl used in nds32-multiple.md.  */\n \n extern rtx nds32_expand_load_multiple (int, int, rtx, rtx);\n extern rtx nds32_expand_store_multiple (int, int, rtx, rtx);\n extern int nds32_expand_movmemqi (rtx, rtx, rtx, rtx);\n \n+/* Auxiliary functions for expand unalign load instruction.  */\n+\n+extern void nds32_expand_unaligned_load (rtx *, enum machine_mode);\n+\n+/* Auxiliary functions for expand unalign store instruction.  */\n+\n+extern void nds32_expand_unaligned_store (rtx *, enum machine_mode);\n+\n /* Auxiliary functions for multiple load/store predicate checking.  */\n \n extern bool nds32_valid_multiple_load_store (rtx, bool);\n@@ -106,6 +118,8 @@ extern const char *nds32_output_16bit_load (rtx *, int);\n extern const char *nds32_output_32bit_store (rtx *, int);\n extern const char *nds32_output_32bit_load (rtx *, int);\n extern const char *nds32_output_32bit_load_s (rtx *, int);\n+extern const char *nds32_output_smw_single_word (rtx *);\n+extern const char *nds32_output_lmw_single_word (rtx *);\n \n /* Auxiliary functions to output stack push/pop instruction.  */\n "}, {"sha": "6e67165ae11f7f3d99e1192821ca21344475d06b", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -346,6 +346,12 @@ enum nds32_builtins\n   NDS32_BUILTIN_MTUSR,\n   NDS32_BUILTIN_SETGIE_EN,\n   NDS32_BUILTIN_SETGIE_DIS,\n+  NDS32_BUILTIN_UALOAD_HW,\n+  NDS32_BUILTIN_UALOAD_W,\n+  NDS32_BUILTIN_UALOAD_DW,\n+  NDS32_BUILTIN_UASTORE_HW,\n+  NDS32_BUILTIN_UASTORE_W,\n+  NDS32_BUILTIN_UASTORE_DW,\n   NDS32_BUILTIN_COUNT\n };\n "}, {"sha": "98db74a8e62309317c715596d9e0cd0f95f35b84", "filename": "gcc/config/nds32/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e576ddb5eb9a9101eef5ddf09666bc56274c350a/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpredicates.md?ref=e576ddb5eb9a9101eef5ddf09666bc56274c350a", "patch": "@@ -57,6 +57,10 @@\n   return true;\n })\n \n+(define_predicate \"nds32_lmw_smw_base_operand\"\n+  (and (match_code \"mem\")\n+       (match_test \"nds32_valid_smw_lwm_base_p (op)\")))\n+\n (define_special_predicate \"nds32_load_multiple_operation\"\n   (match_code \"parallel\")\n {"}]}