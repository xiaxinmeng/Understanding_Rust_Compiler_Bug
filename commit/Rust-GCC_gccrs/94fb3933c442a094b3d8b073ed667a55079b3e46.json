{"sha": "94fb3933c442a094b3d8b073ed667a55079b3e46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRmYjM5MzNjNDQyYTA5NGIzZDhiMDczZWQ2NjdhNTUwNzliM2U0Ng==", "commit": {"author": {"name": "Klaus Kaempf", "email": "kkaempf@progis.de", "date": "1998-06-19T01:34:11Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-19T01:34:11Z"}, "message": "cccp.c (hack_vms_include_specification): rewrite to handle '#include <dir/file.h>' correctly.\n\n        * cccp.c (hack_vms_include_specification): rewrite to handle\n        '#include <dir/file.h>' correctly.\n\nFrom-SVN: r20577", "tree": {"sha": "a1bfd4cb2906fdc982f7c85922f53309e3b05466", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1bfd4cb2906fdc982f7c85922f53309e3b05466"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94fb3933c442a094b3d8b073ed667a55079b3e46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fb3933c442a094b3d8b073ed667a55079b3e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94fb3933c442a094b3d8b073ed667a55079b3e46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fb3933c442a094b3d8b073ed667a55079b3e46/comments", "author": null, "committer": null, "parents": [{"sha": "de3eb7b70b55c20942941887ddb89b488a21b122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de3eb7b70b55c20942941887ddb89b488a21b122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de3eb7b70b55c20942941887ddb89b488a21b122"}], "stats": {"total": 418, "additions": 302, "deletions": 116}, "files": [{"sha": "5afe85f9894906543cd67227b69757ce3840224c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fb3933c442a094b3d8b073ed667a55079b3e46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fb3933c442a094b3d8b073ed667a55079b3e46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94fb3933c442a094b3d8b073ed667a55079b3e46", "patch": "@@ -1,3 +1,8 @@\n+Fri Jun 19 02:31:16 1998  Klaus Kaempf (kkaempf@progis.de)\n+\n+\t* cccp.c (hack_vms_include_specification): rewrite to handle\n+\t'#include <dir/file.h>' correctly.\n+\n Fri Jun 19 02:24:11 1998  H.J. Lu  (hjl@gnu.org)\n \n \t* config/i386/linux.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Defined."}, {"sha": "59799de313da8081c091ef6ec9159b8a825b60a4", "filename": "gcc/cccp.c", "status": "modified", "additions": 297, "deletions": 116, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fb3933c442a094b3d8b073ed667a55079b3e46/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fb3933c442a094b3d8b073ed667a55079b3e46/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=94fb3933c442a094b3d8b073ed667a55079b3e46", "patch": "@@ -78,7 +78,7 @@ static int VMS_fstat (), VMS_stat ();\n static int VMS_open ();\n static FILE *VMS_fopen ();\n static FILE *VMS_freopen ();\n-static void hack_vms_include_specification ();\n+static int hack_vms_include_specification ();\n #define INO_T_EQ(a, b) (!bcmp((char *) &(a), (char *) &(b), sizeof (a)))\n #define INO_T_HASH(a) 0\n #define INCLUDE_LEN_FUDGE 12\t/* leave room for VMS syntax conversion */\n@@ -4327,6 +4327,16 @@ do_include (buf, limit, op, keyword)\n \t    simplify_filename (dsp->fname);\n \t    nam = base_name (dsp->fname);\n \t    *nam = 0;\n+#ifdef VMS\n+\t    /* for hack_vms_include_specification(), a local\n+\t       dir specification must start with \"./\" on VMS.  */\n+\t    if (nam == dsp->fname)\n+\t      {    \n+\t\t*nam++ = '.';\n+\t\t*nam++ = '/';\n+\t\t*nam = 0;\n+\t      }\n+#endif\n \t    /* But for efficiency's sake, do not insert the dir\n \t       if it matches the search list's first dir.  */\n \t    dsp->next = search_start;\n@@ -4485,22 +4495,37 @@ do_include (buf, limit, op, keyword)\n \t  }\n       }\n \n-      strcpy (fname, searchptr->fname);\n-      strcat (fname, fbeg);\n #ifdef VMS\n       /* Change this 1/2 Unix 1/2 VMS file specification into a\n          full VMS file specification */\n-      if (searchptr->fname[0]) {\n-\t/* Fix up the filename */\n-\thack_vms_include_specification (fname, vaxc_include);\n-      } else {\n-\t/* This is a normal VMS filespec, so use it unchanged.  */\n-\tstrcpy (fname, fbeg);\n-\t/* if it's '#include filename', add the missing .h */\n-\tif (vaxc_include && index(fname,'.')==NULL) {\n-\t  strcat (fname, \".h\");\n+      if (searchptr->fname[0])\n+\t{\n+\t  strcpy (fname, searchptr->fname);\n+\t  if (fname[strlen (fname) - 1] == ':')\n+\t    {\n+\t      char *slashp;\n+\t      slashp = strchr (fbeg, '/');\n+\n+\t      /* start at root-dir of logical device if no path given.  */\n+\t      if (slashp == 0)\n+\t\tstrcat (fname, \"[000000]\");\n+\t    }\n+\t  strcat (fname, fbeg);\n+\n+\t  /* Fix up the filename */\n+\t  hack_vms_include_specification (fname, vaxc_include);\n \t}\n-      }\n+      else\n+\t{\n+\t  /* This is a normal VMS filespec, so use it unchanged.  */\n+\t  strcpy (fname, fbeg);\n+\t  /* if it's '#include filename', add the missing .h */\n+\t  if (vaxc_include && index(fname,'.')==NULL)\n+\t    strcat (fname, \".h\");\n+\t}\n+#else\n+      strcpy (fname, searchptr->fname);\n+      strcat (fname, fbeg);\n #endif /* VMS */\n       f = open_include_file (fname, searchptr, importing, &inc);\n       if (f != -1) {\n@@ -4687,6 +4712,9 @@ absolute_filename (filename)\n #if defined (__CYGWIN32__)\n   /* At present, any path that begins with a drive spec is absolute.  */\n   if (ISALPHA (filename[0]) && filename[1] == ':') return 1;\n+#endif\n+#ifdef VMS\n+  if (index (filename, ':') != 0) return 1;\n #endif\n   if (filename[0] == '/') return 1;\n #ifdef DIR_SEPARATOR\n@@ -4737,9 +4765,12 @@ simplify_filename (filename)\n   to0 = to;\n \n   for (;;) {\n+#ifndef VMS\n     if (from[0] == '.' && from[1] == '/')\n       from += 2;\n-    else {\n+    else\n+#endif\n+      {\n       /* Copy this component and trailing /, if any.  */\n       while ((*to++ = *from++) != '/') {\n \tif (!to[-1]) {\n@@ -4937,7 +4968,16 @@ open_include_file (filename, searchptr, importing, pinc)\n     fd = open (fname, O_RDONLY, 0);\n \n     if (fd < 0)\n-      return fd;\n+      {\n+#ifdef VMS\n+\t/* if #include <dir/file> fails, try again with hacked spec.  */\n+\tif (!hack_vms_include_specification (fname, 0))\n+\t  return fd;\n+\tfd = open (fname, O_RDONLY, 0);\n+\tif (fd < 0)\n+#endif\n+\t  return fd;\n+      }\n \n     if (!inc) {\n       /* FNAME was not in include_hashtab; insert a new entry.  */\n@@ -9976,7 +10016,12 @@ new_include_prefix (prev_file_name, component, prefix, name)\n       if (len == 1 && dir->fname[len - 1] == '.')\n \tlen = 0;\n       else\n+#ifdef VMS\n+\t/* must be '/', hack_vms_include_specification triggers on it.  */\n+\tdir->fname[len++] = '/';\n+#else\n \tdir->fname[len++] = DIR_SEPARATOR;\n+#endif\n       dir->fname[len] = 0;\n     }\n \n@@ -10281,31 +10326,84 @@ savestring (input)\n \f\n #ifdef VMS\n \n-/* Under VMS we need to fix up the \"include\" specification filename so\n-   that everything following the 1st slash is changed into its correct\n-   VMS file specification.  */\n+/* Under VMS we need to fix up the \"include\" specification filename.\n \n-static void\n-hack_vms_include_specification (fname, vaxc_include)\n-     char *fname;\n+   Rules for possible conversions\n+\n+\tfullname\t\ttried paths\n+\n+\tname\t\t\tname\n+\t./dir/name\t\t[.dir]name\n+\t/dir/name\t\tdir:name\n+\t/name\t\t\t[000000]name, name\n+\tdir/name\t\tdir:[000000]name, dir:name, dir/name\n+\tdir1/dir2/name\t\tdir1:[dir2]name, dir1:[000000.dir2]name\n+\tpath:/name\t\tpath:[000000]name, path:name\n+\tpath:/dir/name\t\tpath:[000000.dir]name, path:[dir]name\n+\tpath:dir/name\t\tpath:[dir]name\n+\t[path]:[dir]name\t[path.dir]name\n+\tpath/[dir]name\t\t[path.dir]name\n+\n+   The path:/name input is constructed when expanding <> includes.\n+\n+   return 1 if name was changed, 0 else.  */\n+\n+static int\n+hack_vms_include_specification (fullname, vaxc_include)\n+     char *fullname;\n      int vaxc_include;\n {\n-  register char *cp, *cp1, *cp2;\n-  int f, check_filename_before_returning;\n+  register char *basename, *unixname, *local_ptr, *first_slash;\n+  int f, check_filename_before_returning, must_revert;\n   char Local[512];\n \n   check_filename_before_returning = 0;\n+  must_revert = 0;\n+  /* See if we can find a 1st slash. If not, there's no path information.  */\n+  first_slash = index (fullname, '/');\n+  if (first_slash == 0)\n+    return 0;\t\t\t\t/* Nothing to do!!! */\n+\n+  /* construct device spec if none given.  */\n+\n+  if (index (fullname, ':') == 0)\n+    {\n \n-  cp = base_name (fname);\n+      /* If fullname has a slash, take it as device spec.  */\n+\n+      if (first_slash == fullname)\n+\t{\n+\t  first_slash = index (fullname+1, '/');\t/* 2nd slash ? */\n+\t  if (first_slash)\n+\t    *first_slash = ':';\t\t\t\t/* make device spec  */\n+\t  for (basename = fullname; *basename != 0; basename++)\n+\t    *basename = *(basename+1);\t\t\t/* remove leading slash  */\n+\t}\n+      else if ((first_slash[-1] != '.')\t\t/* keep ':/', './' */\n+\t    && (first_slash[-1] != ':')\n+\t    && (first_slash[-1] != ']'))\t/* or a vms path  */\n+\t{\n+\t  *first_slash = ':';\n+\t}\n+      else if ((first_slash[1] == '[')\t\t/* skip './' in './[dir'  */\n+\t    && (first_slash[-1] == '.'))\n+\tfullname += 2;\n+    }\n+\n+  /* Get part after first ':' (basename[-1] == ':')\n+     or last '/' (basename[-1] == '/').  */\n+\n+  basename = base_name (fullname);\n \n   /*\n    * Check if we have a vax-c style '#include filename'\n    * and add the missing .h\n    */\n-  if (vaxc_include && !index (cp,'.'))\n-    strcat (cp, \".h\");\n \n-  cp2 = Local;\t\t\t/* initialize */\n+  if (vaxc_include && !index (basename,'.'))\n+    strcat (basename, \".h\");\n+\n+  local_ptr = Local;\t\t\t/* initialize */\n \n   /* We are trying to do a number of things here.  First of all, we are\n      trying to hammer the filenames into a standard format, such that later\n@@ -10318,112 +10416,195 @@ hack_vms_include_specification (fname, vaxc_include)\n      If no device is specified, then the first directory name is taken to be\n      a device name (or a rooted logical).  */\n \n-  /* See if we found that 1st slash */\n-  if (cp == 0) return;\t\t/* Nothing to do!!! */\n-  if (*cp != '/') return;\t/* Nothing to do!!! */\n-  /* Point to the UNIX filename part (which needs to be fixed!) */\n-  cp1 = cp+1;\n+  /* Point to the UNIX filename part (which needs to be fixed!)\n+     but skip vms path information.\n+     [basename != fullname since first_slash != 0].  */\n+\n+  if ((basename[-1] == ':')\t\t/* vms path spec.  */\n+      || (basename[-1] == ']')\n+      || (basename[-1] == '>'))\n+    unixname = basename;\n+  else\n+    unixname = fullname;\n+\n+  if (*unixname == '/')\n+    unixname++;\n+\n   /* If the directory spec is not rooted, we can just copy\n-     the UNIX filename part and we are done */\n-  if (((cp - fname) > 1) && ((cp[-1] == ']') || (cp[-1] == '>'))) {\n-    if (cp[-2] != '.') {\n-      /*\n-       * The VMS part ends in a `]', and the preceding character is not a `.'.\n-       * We strip the `]', and then splice the two parts of the name in the\n-       * usual way.  Given the default locations for include files in cccp.c,\n-       * we will only use this code if the user specifies alternate locations\n-       * with the /include (-I) switch on the command line.  */\n-      cp -= 1;\t\t\t/* Strip \"]\" */\n-      cp1--;\t\t\t/* backspace */\n-    } else {\n-      /*\n-       * The VMS part has a \".]\" at the end, and this will not do.  Later\n-       * processing will add a second directory spec, and this would be a syntax\n-       * error.  Thus we strip the \".]\", and thus merge the directory specs.\n-       * We also backspace cp1, so that it points to a '/'.  This inhibits the\n-       * generation of the 000000 root directory spec (which does not belong here\n-       * in this case).\n-       */\n-      cp -= 2;\t\t\t/* Strip \".]\" */\n-      cp1--; };\t\t\t/* backspace */\n-  } else {\n+     the UNIX filename part and we are done.  */\n \n-    /* We drop in here if there is no VMS style directory specification yet.\n-     * If there is no device specification either, we make the first dir a\n-     * device and try that.  If we do not do this, then we will be essentially\n-     * searching the users default directory (as if they did a #include \"asdf.h\").\n-     *\n-     * Then all we need to do is to push a '[' into the output string. Later\n-     * processing will fill this in, and close the bracket.\n-     */\n-    if (cp[-1] != ':') *cp2++ = ':'; /* dev not in spec.  take first dir */\n-    *cp2++ = '[';\t\t/* Open the directory specification */\n-  }\n+  if (((basename - fullname) > 1)\n+     && (  (basename[-1] == ']')\n+        || (basename[-1] == '>')))\n+    {\n+      if (basename[-2] != '.')\n+\t{\n+\n+\t/* The VMS part ends in a `]', and the preceding character is not a `.'.\n+\t   -> PATH]:/name (basename = '/name', unixname = 'name')\n+\t   We strip the `]', and then splice the two parts of the name in the\n+\t   usual way.  Given the default locations for include files in cccp.c,\n+\t   we will only use this code if the user specifies alternate locations\n+\t   with the /include (-I) switch on the command line.  */\n+\n+\t  basename -= 1;\t/* Strip \"]\" */\n+\t  unixname--;\t\t/* backspace */\n+\t}\n+      else\n+\t{\n+\n+\t/* The VMS part has a \".]\" at the end, and this will not do.  Later\n+\t   processing will add a second directory spec, and this would be a syntax\n+\t   error.  Thus we strip the \".]\", and thus merge the directory specs.\n+\t   We also backspace unixname, so that it points to a '/'.  This inhibits the\n+\t   generation of the 000000 root directory spec (which does not belong here\n+\t   in this case).  */\n+\n+\t  basename -= 2;\t/* Strip \".]\" */\n+\t  unixname--;\t\t/* backspace */\n+\t}\n+    }\n+\n+  else\n+\n+    {\n+\n+      /* We drop in here if there is no VMS style directory specification yet.\n+         If there is no device specification either, we make the first dir a\n+         device and try that.  If we do not do this, then we will be essentially\n+         searching the users default directory (as if they did a #include \"asdf.h\").\n+        \n+         Then all we need to do is to push a '[' into the output string. Later\n+         processing will fill this in, and close the bracket.  */\n+\n+      if ((unixname != fullname)\t/* vms path spec found.  */\n+\t && (basename[-1] != ':'))\n+\t*local_ptr++ = ':';\t\t/* dev not in spec.  take first dir */\n+\n+      *local_ptr++ = '[';\t\t/* Open the directory specification */\n+    }\n+\n+    if (unixname == fullname)\t\t/* no vms dir spec.  */\n+      {\n+\tmust_revert = 1;\n+\tif ((first_slash != 0)\t\t/* unix dir spec.  */\n+\t    && (*unixname != '/')\t/* not beginning with '/'  */\n+\t    && (*unixname != '.'))\t/* or './' or '../'  */\n+\t  *local_ptr++ = '.';\t\t/* dir is local !  */\n+      }\n \n   /* at this point we assume that we have the device spec, and (at least\n      the opening \"[\" for a directory specification.  We may have directories\n-     specified already */\n+     specified already.\n \n-  /* If there are no other slashes then the filename will be\n+     If there are no other slashes then the filename will be\n      in the \"root\" directory.  Otherwise, we need to add\n      directory specifications.  */\n-  if (index (cp1, '/') == 0) {\n-    /* Just add \"000000]\" as the directory string */\n-    strcpy (cp2, \"000000]\");\n-    cp2 += strlen (cp2);\n-    check_filename_before_returning = 1; /* we might need to fool with this later */\n-  } else {\n-    /* As long as there are still subdirectories to add, do them.  */\n-    while (index (cp1, '/') != 0) {\n-      /* If this token is \".\" we can ignore it */\n-      if ((cp1[0] == '.') && (cp1[1] == '/')) {\n-\tcp1 += 2;\n-\tcontinue;\n-      }\n-      /* Add a subdirectory spec. Do not duplicate \".\" */\n-      if (cp2[-1] != '.' && cp2[-1] != '[' && cp2[-1] != '<')\n-\t*cp2++ = '.';\n-      /* If this is \"..\" then the spec becomes \"-\" */\n-      if ((cp1[0] == '.') && (cp1[1] == '.') && (cp[2] == '/')) {\n-\t/* Add \"-\" and skip the \"..\" */\n-\t*cp2++ = '-';\n-\tcp1 += 3;\n-\tcontinue;\n-      }\n-      /* Copy the subdirectory */\n-      while (*cp1 != '/') *cp2++= *cp1++;\n-      cp1++;\t\t\t/* Skip the \"/\" */\n+\n+  if (index (unixname, '/') == 0)\n+    {\n+      /* if no directories specified yet and none are following.  */\n+      if (local_ptr[-1] == '[')\n+\t{\n+\t  /* Just add \"000000]\" as the directory string */\n+\t  strcpy (local_ptr, \"000000]\");\n+\t  local_ptr += strlen (local_ptr);\n+\t  check_filename_before_returning = 1; /* we might need to fool with this later */\n+\t}\n+    }\n+  else\n+    {\n+\n+      /* As long as there are still subdirectories to add, do them.  */\n+      while (index (unixname, '/') != 0)\n+\t{\n+\t  /* If this token is \".\" we can ignore it\n+\t       if it's not at the beginning of a path.  */\n+\t  if ((unixname[0] == '.') && (unixname[1] == '/'))\n+\t    {\n+\t      /* remove it at beginning of path.  */\n+\t      if (  ((unixname == fullname)\t\t/* no device spec  */\n+\t\t    && (fullname+2 != basename))\t/* starts with ./ */\n+\t\t\t\t\t\t\t/* or  */\n+\t\t || ((basename[-1] == ':')\t\t/* device spec  */\n+\t\t    && (unixname-1 == basename)))\t/* and ./ afterwards  */\n+\t\t*local_ptr++ = '.';\t\t \t/* make '[.' start of path.  */\n+\t      unixname += 2;\n+\t      continue;\n+\t    }\n+\n+\t  /* Add a subdirectory spec. Do not duplicate \".\" */\n+\t  if (  local_ptr[-1] != '.'\n+\t     && local_ptr[-1] != '['\n+\t     && local_ptr[-1] != '<')\n+\t    *local_ptr++ = '.';\n+\n+\t  /* If this is \"..\" then the spec becomes \"-\" */\n+\t  if (  (unixname[0] == '.')\n+\t     && (unixname[1] == '.')\n+\t     && (unixname[2] == '/'))\n+\t    {\n+\t      /* Add \"-\" and skip the \"..\" */\n+\t      if ((local_ptr[-1] == '.')\n+\t\t  && (local_ptr[-2] == '['))\n+\t\tlocal_ptr--;\t\t\t/* prevent [.-  */\n+\t      *local_ptr++ = '-';\n+\t      unixname += 3;\n+\t      continue;\n+\t    }\n+\n+\t  /* Copy the subdirectory */\n+\t  while (*unixname != '/')\n+\t    *local_ptr++= *unixname++;\n+\n+\t  unixname++;\t\t\t/* Skip the \"/\" */\n+\t}\n+\n+      /* Close the directory specification */\n+      if (local_ptr[-1] == '.')\t\t/* no trailing periods */\n+\tlocal_ptr--;\n+\n+      if (local_ptr[-1] == '[')\t\t/* no dir needed */\n+\tlocal_ptr--;\n+      else\n+\t*local_ptr++ = ']';\n     }\n-    /* Close the directory specification */\n-    if (cp2[-1] == '.')\t\t/* no trailing periods */\n-      cp2--;\n-    *cp2++ = ']';\n-  }\n-  /* Now add the filename */\n-  while (*cp1) *cp2++ = *cp1++;\n-  *cp2 = 0;\n+\n+  /* Now add the filename.  */\n+\n+  while (*unixname)\n+    *local_ptr++ = *unixname++;\n+  *local_ptr = 0;\n+\n   /* Now append it to the original VMS spec.  */\n-  strcpy (cp, Local);\n+\n+  strcpy ((must_revert==1)?fullname:basename, Local);\n \n   /* If we put a [000000] in the filename, try to open it first. If this fails,\n      remove the [000000], and return that name.  This provides flexibility\n      to the user in that they can use both rooted and non-rooted logical names\n      to point to the location of the file.  */\n \n-  if (check_filename_before_returning) {\n-    f = open (fname, O_RDONLY, 0666);\n-    if (f >= 0) {\n-      /* The file name is OK as it is, so return it as is.  */\n-      close (f);\n-      return;\n+  if (check_filename_before_returning)\n+    {\n+      f = open (fullname, O_RDONLY, 0666);\n+      if (f >= 0)\n+\t{\n+\t  /* The file name is OK as it is, so return it as is.  */\n+\t  close (f);\n+\t  return 1;\n+\t}\n+\n+      /* The filename did not work.  Try to remove the [000000] from the name,\n+\t and return it.  */\n+\n+      basename = index (fullname, '[');\n+      local_ptr = index (fullname, ']') + 1;\n+      strcpy (basename, local_ptr);\t\t/* this gets rid of it */\n+\n     }\n-    /* The filename did not work.  Try to remove the [000000] from the name,\n-       and return it.  */\n-    cp = index (fname, '[');\n-    cp2 = index (fname, ']') + 1;\n-    strcpy (cp, cp2);\t\t/* this gets rid of it */\n-  }\n-  return;\n+\n+  return 1;\n }\n #endif\t/* VMS */\n \f"}]}