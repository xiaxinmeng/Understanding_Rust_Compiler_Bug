{"sha": "5f520819620642ecd2b070f96efa3007ac1f15a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY1MjA4MTk2MjA2NDJlY2QyYjA3MGY5NmVmYTMwMDdhYzFmMTVhMQ==", "commit": {"author": {"name": "Kirill Yukhin", "email": "kirill.yukhin@intel.com", "date": "2014-11-13T14:03:17Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-11-13T14:03:17Z"}, "message": "[PATCH 2/4] OpenMP 4.0 offloading to Intel MIC: liboffloadmic.\n\n\t* Makefile.def: Add liboffloadmic to target_modules.  Make\n\tliboffloadmic depend on libgomp's configure, libstdc++ and libgcc.\n\t* Makefile.in: Regenerate.\n\t* configure: Regenerate.\n\t* configure.ac: Add liboffloadmic to target binaries.\n\tRestrict liboffloadmic for POSIX and i*86, and x86_64 architectures.\n\tAdd liboffloadmic to noconfig list when C++ is not supported.\n\nconfig/\n\t* target-posix: New file.\n\nlibcilkrts/\n\t* configure.tgt: Use config/target-posix.\n\nliboffloadmic/\n\tInitial commit.  Imported from upstream:\n\thttps://www.openmprtl.org/sites/default/files/liboffload_oss.tgz\n\t* Makefile.am: New file.\n\t* Makefile.in: New file, generated by automake.\n\t* aclocal.m4: New file, generated by aclocal.\n\t* configure: New file, generated by autoconf.\n\t* configure.ac: New file.\n\t* configure.tgt: Ditto.\n\t* doc/doxygen/config: Ditto.\n\t* doc/doxygen/header.tex: Ditto.\n\t* include/coi/common/COIEngine_common.h: Ditto.\n\t* include/coi/common/COIMacros_common.h: Ditto.\n\t* include/coi/common/COIPerf_common.h : Ditto.\n\t* include/coi/common/COIResult_common.h : Ditto.\n\t* include/coi/common/COITypes_common.h: Ditto.\n\t* include/coi/sink/COIBuffer_sink.h: Ditto.\n\t* include/coi/sink/COIPipeline_sink.h: Ditto.\n\t* include/coi/sink/COIProcess_sink.h: Ditto.\n\t* include/coi/source/COIBuffer_source.h: Ditto.\n\t* include/coi/source/COIEngine_source.h: Ditto.\n\t* include/coi/source/COIEvent_source.h: Ditto.\n\t* include/coi/source/COIPipeline_source.h: Ditto.\n\t* include/coi/source/COIProcess_source.h: Ditto.\n\t* include/myo/myo.h: Ditto.\n\t* include/myo/myoimpl.h: Ditto.\n\t* include/myo/myotypes.h: Ditto.\n\t* liboffloadmic_host.spec.in: Ditto.\n\t* liboffloadmic_target.spec.in: Ditto.\n\t* runtime/cean_util.cpp: Ditto.\n\t* runtime/cean_util.h: Ditto.\n\t* runtime/coi/coi_client.cpp: Ditto.\n\t* runtime/coi/coi_client.h: Ditto.\n\t* runtime/coi/coi_server.cpp: Ditto.\n\t* runtime/coi/coi_server.h: Ditto.\n\t* runtime/compiler_if_host.cpp: Ditto.\n\t* runtime/compiler_if_host.h: Ditto.\n\t* runtime/compiler_if_target.cpp: Ditto.\n\t* runtime/compiler_if_target.h: Ditto.\n\t* runtime/dv_util.cpp: Ditto.\n\t* runtime/dv_util.h: Ditto.\n\t* runtime/emulator/coi_common.h: Ditto.\n\t* runtime/emulator/coi_device.cpp: Ditto.\n\t* runtime/emulator/coi_device.h: Ditto.\n\t* runtime/emulator/coi_host.cpp: Ditto.\n\t* runtime/emulator/coi_host.h: Ditto.\n\t* runtime/emulator/coi_version_asm.h: Ditto.\n\t* runtime/emulator/coi_version_linker_script.map: Ditto.\n\t* runtime/emulator/myo_client.cpp: Ditto.\n\t* runtime/emulator/myo_service.cpp: Ditto.\n\t* runtime/emulator/myo_service.h: Ditto.\n\t* runtime/emulator/myo_version_asm.h: Ditto.\n\t* runtime/emulator/myo_version_linker_script.map: Ditto.\n\t* runtime/liboffload_error.c: Ditto.\n\t* runtime/liboffload_error_codes.h: Ditto.\n\t* runtime/liboffload_msg.c: Ditto.\n\t* runtime/liboffload_msg.h: Ditto.\n\t* runtime/mic_lib.f90: Ditto.\n\t* runtime/offload.h: Ditto.\n\t* runtime/offload_common.cpp: Ditto.\n\t* runtime/offload_common.h: Ditto.\n\t* runtime/offload_engine.cpp: Ditto.\n\t* runtime/offload_engine.h: Ditto.\n\t* runtime/offload_env.cpp: Ditto.\n\t* runtime/offload_env.h: Ditto.\n\t* runtime/offload_host.cpp: Ditto.\n\t* runtime/offload_host.h: Ditto.\n\t* runtime/offload_myo_host.cpp: Ditto.\n\t* runtime/offload_myo_host.h: Ditto.\n\t* runtime/offload_myo_target.cpp: Ditto.\n\t* runtime/offload_myo_target.h: Ditto.\n\t* runtime/offload_omp_host.cpp: Ditto.\n\t* runtime/offload_omp_target.cpp: Ditto.\n\t* runtime/offload_orsl.cpp: Ditto.\n\t* runtime/offload_orsl.h: Ditto.\n\t* runtime/offload_table.cpp: Ditto.\n\t* runtime/offload_table.h: Ditto.\n\t* runtime/offload_target.cpp: Ditto.\n\t* runtime/offload_target.h: Ditto.\n\t* runtime/offload_target_main.cpp: Ditto.\n\t* runtime/offload_timer.h: Ditto.\n\t* runtime/offload_timer_host.cpp: Ditto.\n\t* runtime/offload_timer_target.cpp: Ditto.\n\t* runtime/offload_trace.cpp: Ditto.\n\t* runtime/offload_trace.h: Ditto.\n\t* runtime/offload_util.cpp: Ditto.\n\t* runtime/offload_util.h: Ditto.\n\t* runtime/ofldbegin.cpp: Ditto.\n\t* runtime/ofldend.cpp: Ditto.\n\t* runtime/orsl-lite/include/orsl-lite.h: Ditto.\n\t* runtime/orsl-lite/lib/orsl-lite.c: Ditto.\n\t* runtime/orsl-lite/version.txt: Ditto.\n\t* runtime/use_mpss2.txt: Ditto.\n\nFrom-SVN: r217498", "tree": {"sha": "55be4bcc0740fab528054e3f28398e4513f34e4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55be4bcc0740fab528054e3f28398e4513f34e4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f520819620642ecd2b070f96efa3007ac1f15a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f520819620642ecd2b070f96efa3007ac1f15a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f520819620642ecd2b070f96efa3007ac1f15a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f520819620642ecd2b070f96efa3007ac1f15a1/comments", "author": null, "committer": null, "parents": [{"sha": "f84e7fd6cb5091fa4eba373782f2a87dd449521f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84e7fd6cb5091fa4eba373782f2a87dd449521f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84e7fd6cb5091fa4eba373782f2a87dd449521f"}], "stats": {"total": 47554, "additions": 47533, "deletions": 21}, "files": [{"sha": "f83fa5a1a5ddc21fe799268dd74426a7e40b0d83", "filename": "ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -1,3 +1,13 @@\n+2014-11-13  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\t* Makefile.def: Add liboffloadmic to target_modules.  Make\n+\tliboffloadmic depend on libgomp's configure, libstdc++ and libgcc.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* configure.ac: Add liboffloadmic to target binaries.\n+\tRestrict liboffloadmic for POSIX and i*86, and x86_64 architectures.\n+\tAdd liboffloadmic to noconfig list when C++ is not supported.\n+\n 2014-11-13  Bernd Schmidt  <bernds@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n \t    Ilya Verbin  <ilya.verbin@intel.com>"}, {"sha": "40bbca9c3a9742fc073c6c4bcc8f6a5b073fb5cf", "filename": "Makefile.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -134,6 +134,9 @@ target_modules = { module= libvtv;\n \t\t   raw_cxx=true; };\n target_modules = { module= libcilkrts;\n \t\t   lib_path=.libs; };\n+target_modules = { module= liboffloadmic;\n+\t\t   lib_path=.libs;\n+\t\t   extra_configure_flags='@extra_liboffloadmic_configure_flags@'; };\n target_modules = { module= libssp; lib_path=.libs; };\n target_modules = { module= newlib; };\n target_modules = { module= libgcc; bootstrap=true; no_check=true; };\n@@ -509,6 +512,7 @@ dependencies = { module=all-m4; on=all-build-texinfo; };\n lang_env_dependencies = { module=libjava; cxx=true; };\n lang_env_dependencies = { module=libitm; cxx=true; };\n lang_env_dependencies = { module=libcilkrts; cxx=true; };\n+lang_env_dependencies = { module=liboffloadmic; cxx=true; };\n lang_env_dependencies = { module=newlib; no_c=true; };\n lang_env_dependencies = { module=libgloss; no_c=true; };\n lang_env_dependencies = { module=libgcc; no_gcc=true; no_c=true; };\n@@ -535,12 +539,14 @@ dependencies = { module=all-target-libjava; on=all-target-libffi; };\n dependencies = { module=configure-target-libobjc; on=configure-target-boehm-gc; };\n dependencies = { module=all-target-libobjc; on=all-target-boehm-gc; };\n dependencies = { module=configure-target-libstdc++-v3; on=configure-target-libgomp; };\n+dependencies = { module=configure-target-liboffloadmic; on=configure-target-libgomp; };\n dependencies = { module=configure-target-libsanitizer; on=all-target-libstdc++-v3; };\n dependencies = { module=configure-target-libvtv; on=all-target-libstdc++-v3; };\n // parallel_list.o and parallel_settings.o depend on omp.h, which is\n // generated by the libgomp configure.  Unfortunately, due to the use of\n //  recursive make, we can't be that specific.\n dependencies = { module=all-target-libstdc++-v3; on=configure-target-libgomp; };\n+dependencies = { module=all-target-liboffloadmic; on=configure-target-libgomp; };\n \n dependencies = { module=install-target-libgo; on=install-target-libatomic; };\n dependencies = { module=install-target-libgfortran; on=install-target-libquadmath; };\n@@ -551,6 +557,8 @@ dependencies = { module=install-target-libvtv; on=install-target-libstdc++-v3; }\n dependencies = { module=install-target-libvtv; on=install-target-libgcc; };\n dependencies = { module=install-target-libcilkrts; on=install-target-libstdc++-v3; };\n dependencies = { module=install-target-libcilkrts; on=install-target-libgcc; };\n+dependencies = { module=install-target-liboffloadmic; on=install-target-libstdc++-v3; };\n+dependencies = { module=install-target-liboffloadmic; on=install-target-libgcc; };\n dependencies = { module=install-target-libjava; on=install-target-libgcc; };\n dependencies = { module=install-target-libitm; on=install-target-libgcc; };\n dependencies = { module=install-target-libobjc; on=install-target-libgcc; };"}, {"sha": "f1ff972c1f52598133755217639b3527a227101c", "filename": "Makefile.in", "status": "modified", "additions": 496, "deletions": 1, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -574,7 +574,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libcilkrts)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libcilkrts)$(TARGET_LIB_PATH_liboffloadmic)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n@@ -592,6 +592,10 @@ TARGET_LIB_PATH_libvtv = $$r/$(TARGET_SUBDIR)/libvtv/.libs:\n TARGET_LIB_PATH_libcilkrts = $$r/$(TARGET_SUBDIR)/libcilkrts/.libs:\n @endif target-libcilkrts\n \n+@if target-liboffloadmic\n+TARGET_LIB_PATH_liboffloadmic = $$r/$(TARGET_SUBDIR)/liboffloadmic/.libs:\n+@endif target-liboffloadmic\n+\n @if target-libssp\n TARGET_LIB_PATH_libssp = $$r/$(TARGET_SUBDIR)/libssp/.libs:\n @endif target-libssp\n@@ -926,6 +930,7 @@ configure-target:  \\\n     maybe-configure-target-libsanitizer \\\n     maybe-configure-target-libvtv \\\n     maybe-configure-target-libcilkrts \\\n+    maybe-configure-target-liboffloadmic \\\n     maybe-configure-target-libssp \\\n     maybe-configure-target-newlib \\\n     maybe-configure-target-libgcc \\\n@@ -1084,6 +1089,7 @@ all-target: maybe-all-target-libsanitizer\n all-target: maybe-all-target-libvtv\n @endif target-libvtv-no-bootstrap\n all-target: maybe-all-target-libcilkrts\n+all-target: maybe-all-target-liboffloadmic\n all-target: maybe-all-target-libssp\n all-target: maybe-all-target-newlib\n @if target-libgcc-no-bootstrap\n@@ -1177,6 +1183,7 @@ info-target: maybe-info-target-libstdc++-v3\n info-target: maybe-info-target-libsanitizer\n info-target: maybe-info-target-libvtv\n info-target: maybe-info-target-libcilkrts\n+info-target: maybe-info-target-liboffloadmic\n info-target: maybe-info-target-libssp\n info-target: maybe-info-target-newlib\n info-target: maybe-info-target-libgcc\n@@ -1261,6 +1268,7 @@ dvi-target: maybe-dvi-target-libstdc++-v3\n dvi-target: maybe-dvi-target-libsanitizer\n dvi-target: maybe-dvi-target-libvtv\n dvi-target: maybe-dvi-target-libcilkrts\n+dvi-target: maybe-dvi-target-liboffloadmic\n dvi-target: maybe-dvi-target-libssp\n dvi-target: maybe-dvi-target-newlib\n dvi-target: maybe-dvi-target-libgcc\n@@ -1345,6 +1353,7 @@ pdf-target: maybe-pdf-target-libstdc++-v3\n pdf-target: maybe-pdf-target-libsanitizer\n pdf-target: maybe-pdf-target-libvtv\n pdf-target: maybe-pdf-target-libcilkrts\n+pdf-target: maybe-pdf-target-liboffloadmic\n pdf-target: maybe-pdf-target-libssp\n pdf-target: maybe-pdf-target-newlib\n pdf-target: maybe-pdf-target-libgcc\n@@ -1429,6 +1438,7 @@ html-target: maybe-html-target-libstdc++-v3\n html-target: maybe-html-target-libsanitizer\n html-target: maybe-html-target-libvtv\n html-target: maybe-html-target-libcilkrts\n+html-target: maybe-html-target-liboffloadmic\n html-target: maybe-html-target-libssp\n html-target: maybe-html-target-newlib\n html-target: maybe-html-target-libgcc\n@@ -1513,6 +1523,7 @@ TAGS-target: maybe-TAGS-target-libstdc++-v3\n TAGS-target: maybe-TAGS-target-libsanitizer\n TAGS-target: maybe-TAGS-target-libvtv\n TAGS-target: maybe-TAGS-target-libcilkrts\n+TAGS-target: maybe-TAGS-target-liboffloadmic\n TAGS-target: maybe-TAGS-target-libssp\n TAGS-target: maybe-TAGS-target-newlib\n TAGS-target: maybe-TAGS-target-libgcc\n@@ -1597,6 +1608,7 @@ install-info-target: maybe-install-info-target-libstdc++-v3\n install-info-target: maybe-install-info-target-libsanitizer\n install-info-target: maybe-install-info-target-libvtv\n install-info-target: maybe-install-info-target-libcilkrts\n+install-info-target: maybe-install-info-target-liboffloadmic\n install-info-target: maybe-install-info-target-libssp\n install-info-target: maybe-install-info-target-newlib\n install-info-target: maybe-install-info-target-libgcc\n@@ -1681,6 +1693,7 @@ install-pdf-target: maybe-install-pdf-target-libstdc++-v3\n install-pdf-target: maybe-install-pdf-target-libsanitizer\n install-pdf-target: maybe-install-pdf-target-libvtv\n install-pdf-target: maybe-install-pdf-target-libcilkrts\n+install-pdf-target: maybe-install-pdf-target-liboffloadmic\n install-pdf-target: maybe-install-pdf-target-libssp\n install-pdf-target: maybe-install-pdf-target-newlib\n install-pdf-target: maybe-install-pdf-target-libgcc\n@@ -1765,6 +1778,7 @@ install-html-target: maybe-install-html-target-libstdc++-v3\n install-html-target: maybe-install-html-target-libsanitizer\n install-html-target: maybe-install-html-target-libvtv\n install-html-target: maybe-install-html-target-libcilkrts\n+install-html-target: maybe-install-html-target-liboffloadmic\n install-html-target: maybe-install-html-target-libssp\n install-html-target: maybe-install-html-target-newlib\n install-html-target: maybe-install-html-target-libgcc\n@@ -1849,6 +1863,7 @@ installcheck-target: maybe-installcheck-target-libstdc++-v3\n installcheck-target: maybe-installcheck-target-libsanitizer\n installcheck-target: maybe-installcheck-target-libvtv\n installcheck-target: maybe-installcheck-target-libcilkrts\n+installcheck-target: maybe-installcheck-target-liboffloadmic\n installcheck-target: maybe-installcheck-target-libssp\n installcheck-target: maybe-installcheck-target-newlib\n installcheck-target: maybe-installcheck-target-libgcc\n@@ -1933,6 +1948,7 @@ mostlyclean-target: maybe-mostlyclean-target-libstdc++-v3\n mostlyclean-target: maybe-mostlyclean-target-libsanitizer\n mostlyclean-target: maybe-mostlyclean-target-libvtv\n mostlyclean-target: maybe-mostlyclean-target-libcilkrts\n+mostlyclean-target: maybe-mostlyclean-target-liboffloadmic\n mostlyclean-target: maybe-mostlyclean-target-libssp\n mostlyclean-target: maybe-mostlyclean-target-newlib\n mostlyclean-target: maybe-mostlyclean-target-libgcc\n@@ -2017,6 +2033,7 @@ clean-target: maybe-clean-target-libstdc++-v3\n clean-target: maybe-clean-target-libsanitizer\n clean-target: maybe-clean-target-libvtv\n clean-target: maybe-clean-target-libcilkrts\n+clean-target: maybe-clean-target-liboffloadmic\n clean-target: maybe-clean-target-libssp\n clean-target: maybe-clean-target-newlib\n clean-target: maybe-clean-target-libgcc\n@@ -2101,6 +2118,7 @@ distclean-target: maybe-distclean-target-libstdc++-v3\n distclean-target: maybe-distclean-target-libsanitizer\n distclean-target: maybe-distclean-target-libvtv\n distclean-target: maybe-distclean-target-libcilkrts\n+distclean-target: maybe-distclean-target-liboffloadmic\n distclean-target: maybe-distclean-target-libssp\n distclean-target: maybe-distclean-target-newlib\n distclean-target: maybe-distclean-target-libgcc\n@@ -2185,6 +2203,7 @@ maintainer-clean-target: maybe-maintainer-clean-target-libstdc++-v3\n maintainer-clean-target: maybe-maintainer-clean-target-libsanitizer\n maintainer-clean-target: maybe-maintainer-clean-target-libvtv\n maintainer-clean-target: maybe-maintainer-clean-target-libcilkrts\n+maintainer-clean-target: maybe-maintainer-clean-target-liboffloadmic\n maintainer-clean-target: maybe-maintainer-clean-target-libssp\n maintainer-clean-target: maybe-maintainer-clean-target-newlib\n maintainer-clean-target: maybe-maintainer-clean-target-libgcc\n@@ -2324,6 +2343,7 @@ check-target:  \\\n     maybe-check-target-libsanitizer \\\n     maybe-check-target-libvtv \\\n     maybe-check-target-libcilkrts \\\n+    maybe-check-target-liboffloadmic \\\n     maybe-check-target-libssp \\\n     maybe-check-target-newlib \\\n     maybe-check-target-libgcc \\\n@@ -2482,6 +2502,7 @@ install-target:  \\\n     maybe-install-target-libsanitizer \\\n     maybe-install-target-libvtv \\\n     maybe-install-target-libcilkrts \\\n+    maybe-install-target-liboffloadmic \\\n     maybe-install-target-libssp \\\n     maybe-install-target-newlib \\\n     maybe-install-target-libgcc \\\n@@ -2586,6 +2607,7 @@ install-strip-target:  \\\n     maybe-install-strip-target-libsanitizer \\\n     maybe-install-strip-target-libvtv \\\n     maybe-install-strip-target-libcilkrts \\\n+    maybe-install-strip-target-liboffloadmic \\\n     maybe-install-strip-target-libssp \\\n     maybe-install-strip-target-newlib \\\n     maybe-install-strip-target-libgcc \\\n@@ -35188,6 +35210,469 @@ maintainer-clean-target-libcilkrts:\n \n \n \n+.PHONY: configure-target-liboffloadmic maybe-configure-target-liboffloadmic\n+maybe-configure-target-liboffloadmic:\n+@if gcc-bootstrap\n+configure-target-liboffloadmic: stage_current\n+@endif gcc-bootstrap\n+@if target-liboffloadmic\n+maybe-configure-target-liboffloadmic: configure-target-liboffloadmic\n+configure-target-liboffloadmic: \n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for liboffloadmic...\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/liboffloadmic ; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/liboffloadmic/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp $(TARGET_SUBDIR)/liboffloadmic/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/liboffloadmic/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp $(TARGET_SUBDIR)/liboffloadmic/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/liboffloadmic/multilib.tmp $(TARGET_SUBDIR)/liboffloadmic/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/liboffloadmic/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/liboffloadmic ; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\techo Configuring in $(TARGET_SUBDIR)/liboffloadmic; \\\n+\t \\\n+\tthis_target=\"${target_alias}\"; \\\n+\t \\\n+\tcd \"$(TARGET_SUBDIR)/liboffloadmic\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/liboffloadmic/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tmodule_srcdir=liboffloadmic; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/liboffloadmic\"; \\\n+\tlibsrcdir=\"$$s/liboffloadmic\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) \\\n+\t  $$s/$$module_srcdir/configure \\\n+\t  --srcdir=$${topdir}/$$module_srcdir \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=$${this_target} $${srcdiroption} @extra_liboffloadmic_configure_flags@ \\\n+\t  || exit 1\n+@endif target-liboffloadmic\n+\n+\n+\n+\n+\n+.PHONY: all-target-liboffloadmic maybe-all-target-liboffloadmic\n+maybe-all-target-liboffloadmic:\n+@if gcc-bootstrap\n+all-target-liboffloadmic: stage_current\n+@endif gcc-bootstrap\n+@if target-liboffloadmic\n+TARGET-target-liboffloadmic=all\n+maybe-all-target-liboffloadmic: all-target-liboffloadmic\n+all-target-liboffloadmic: configure-target-liboffloadmic\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)   \\\n+\t\t$(TARGET-target-liboffloadmic))\n+@endif target-liboffloadmic\n+\n+\n+\n+\n+\n+.PHONY: check-target-liboffloadmic maybe-check-target-liboffloadmic\n+maybe-check-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-check-target-liboffloadmic: check-target-liboffloadmic\n+\n+check-target-liboffloadmic:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: install-target-liboffloadmic maybe-install-target-liboffloadmic\n+maybe-install-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-install-target-liboffloadmic: install-target-liboffloadmic\n+\n+install-target-liboffloadmic: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: install-strip-target-liboffloadmic maybe-install-strip-target-liboffloadmic\n+maybe-install-strip-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-install-strip-target-liboffloadmic: install-strip-target-liboffloadmic\n+\n+install-strip-target-liboffloadmic: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n+\n+@endif target-liboffloadmic\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-target-liboffloadmic info-target-liboffloadmic\n+maybe-info-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-info-target-liboffloadmic: info-target-liboffloadmic\n+\n+info-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-dvi-target-liboffloadmic dvi-target-liboffloadmic\n+maybe-dvi-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-dvi-target-liboffloadmic: dvi-target-liboffloadmic\n+\n+dvi-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-pdf-target-liboffloadmic pdf-target-liboffloadmic\n+maybe-pdf-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-pdf-target-liboffloadmic: pdf-target-liboffloadmic\n+\n+pdf-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing pdf in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           pdf) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-html-target-liboffloadmic html-target-liboffloadmic\n+maybe-html-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-html-target-liboffloadmic: html-target-liboffloadmic\n+\n+html-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-TAGS-target-liboffloadmic TAGS-target-liboffloadmic\n+maybe-TAGS-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-TAGS-target-liboffloadmic: TAGS-target-liboffloadmic\n+\n+TAGS-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-install-info-target-liboffloadmic install-info-target-liboffloadmic\n+maybe-install-info-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-install-info-target-liboffloadmic: install-info-target-liboffloadmic\n+\n+install-info-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \\\n+    info-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-install-pdf-target-liboffloadmic install-pdf-target-liboffloadmic\n+maybe-install-pdf-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-install-pdf-target-liboffloadmic: install-pdf-target-liboffloadmic\n+\n+install-pdf-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \\\n+    pdf-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-pdf in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-pdf) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-install-html-target-liboffloadmic install-html-target-liboffloadmic\n+maybe-install-html-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-install-html-target-liboffloadmic: install-html-target-liboffloadmic\n+\n+install-html-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \\\n+    html-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-html in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-html) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-installcheck-target-liboffloadmic installcheck-target-liboffloadmic\n+maybe-installcheck-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-installcheck-target-liboffloadmic: installcheck-target-liboffloadmic\n+\n+installcheck-target-liboffloadmic: \\\n+    configure-target-liboffloadmic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-mostlyclean-target-liboffloadmic mostlyclean-target-liboffloadmic\n+maybe-mostlyclean-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-mostlyclean-target-liboffloadmic: mostlyclean-target-liboffloadmic\n+\n+mostlyclean-target-liboffloadmic: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-clean-target-liboffloadmic clean-target-liboffloadmic\n+maybe-clean-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-clean-target-liboffloadmic: clean-target-liboffloadmic\n+\n+clean-target-liboffloadmic: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-distclean-target-liboffloadmic distclean-target-liboffloadmic\n+maybe-distclean-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-distclean-target-liboffloadmic: distclean-target-liboffloadmic\n+\n+distclean-target-liboffloadmic: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+.PHONY: maybe-maintainer-clean-target-liboffloadmic maintainer-clean-target-liboffloadmic\n+maybe-maintainer-clean-target-liboffloadmic:\n+@if target-liboffloadmic\n+maybe-maintainer-clean-target-liboffloadmic: maintainer-clean-target-liboffloadmic\n+\n+maintainer-clean-target-liboffloadmic: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/liboffloadmic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/liboffloadmic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/liboffloadmic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-liboffloadmic\n+\n+\n+\n+\n+\n .PHONY: configure-target-libssp maybe-configure-target-libssp\n maybe-configure-target-libssp:\n @if gcc-bootstrap\n@@ -47511,6 +47996,7 @@ configure-stage4-target-libvtv: maybe-all-stage4-gcc\n configure-stageprofile-target-libvtv: maybe-all-stageprofile-gcc\n configure-stagefeedback-target-libvtv: maybe-all-stagefeedback-gcc\n configure-target-libcilkrts: stage_last\n+configure-target-liboffloadmic: stage_last\n configure-target-libssp: stage_last\n configure-target-newlib: stage_last\n configure-stage1-target-libgcc: maybe-all-stage1-gcc\n@@ -47548,6 +48034,7 @@ configure-target-libstdc++-v3: maybe-all-gcc\n configure-target-libsanitizer: maybe-all-gcc\n configure-target-libvtv: maybe-all-gcc\n configure-target-libcilkrts: maybe-all-gcc\n+configure-target-liboffloadmic: maybe-all-gcc\n configure-target-libssp: maybe-all-gcc\n configure-target-newlib: maybe-all-gcc\n configure-target-libgcc: maybe-all-gcc\n@@ -48341,6 +48828,7 @@ configure-stage3-target-libstdc++-v3: maybe-configure-stage3-target-libgomp\n configure-stage4-target-libstdc++-v3: maybe-configure-stage4-target-libgomp\n configure-stageprofile-target-libstdc++-v3: maybe-configure-stageprofile-target-libgomp\n configure-stagefeedback-target-libstdc++-v3: maybe-configure-stagefeedback-target-libgomp\n+configure-target-liboffloadmic: maybe-configure-target-libgomp\n configure-target-libsanitizer: maybe-all-target-libstdc++-v3\n \n configure-stage1-target-libsanitizer: maybe-all-stage1-target-libstdc++-v3\n@@ -48365,6 +48853,7 @@ all-stage3-target-libstdc++-v3: maybe-configure-stage3-target-libgomp\n all-stage4-target-libstdc++-v3: maybe-configure-stage4-target-libgomp\n all-stageprofile-target-libstdc++-v3: maybe-configure-stageprofile-target-libgomp\n all-stagefeedback-target-libstdc++-v3: maybe-configure-stagefeedback-target-libgomp\n+all-target-liboffloadmic: maybe-configure-target-libgomp\n install-target-libgo: maybe-install-target-libatomic\n install-target-libgfortran: maybe-install-target-libquadmath\n install-target-libgfortran: maybe-install-target-libgcc\n@@ -48374,6 +48863,8 @@ install-target-libvtv: maybe-install-target-libstdc++-v3\n install-target-libvtv: maybe-install-target-libgcc\n install-target-libcilkrts: maybe-install-target-libstdc++-v3\n install-target-libcilkrts: maybe-install-target-libgcc\n+install-target-liboffloadmic: maybe-install-target-libstdc++-v3\n+install-target-liboffloadmic: maybe-install-target-libgcc\n install-target-libjava: maybe-install-target-libgcc\n install-target-libitm: maybe-install-target-libgcc\n install-target-libobjc: maybe-install-target-libgcc\n@@ -48422,6 +48913,7 @@ configure-target-libstdc++-v3: maybe-all-target-libgcc\n configure-target-libsanitizer: maybe-all-target-libgcc\n configure-target-libvtv: maybe-all-target-libgcc\n configure-target-libcilkrts: maybe-all-target-libgcc\n+configure-target-liboffloadmic: maybe-all-target-libgcc\n configure-target-libssp: maybe-all-target-libgcc\n configure-target-newlib: maybe-all-target-libgcc\n configure-target-libbacktrace: maybe-all-target-libgcc\n@@ -48453,6 +48945,9 @@ configure-target-libvtv: maybe-all-target-newlib maybe-all-target-libgloss\n configure-target-libcilkrts: maybe-all-target-newlib maybe-all-target-libgloss\n configure-target-libcilkrts: maybe-all-target-libstdc++-v3\n \n+configure-target-liboffloadmic: maybe-all-target-newlib maybe-all-target-libgloss\n+configure-target-liboffloadmic: maybe-all-target-libstdc++-v3\n+\n configure-target-libssp: maybe-all-target-newlib maybe-all-target-libgloss\n \n "}, {"sha": "793e4d263b9e4b501bbc7cdeb7398375c0515b5f", "filename": "config/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -1,3 +1,7 @@\n+2014-11-13  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\t* target-posix: New file.\n+\n 2014-10-27  Tom Tromey  <tromey@redhat.com>\n \n \t* gcc-plugin.m4: New file."}, {"sha": "2fba066c615257a000fee3fd419fe0da4d4e4ef0", "filename": "config/target-posix", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/config%2Ftarget-posix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/config%2Ftarget-posix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Ftarget-posix?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,12 @@\n+case \"${target}\" in\n+  *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)\n+      ;;\n+  *-*-netbsd* | *-*-freebsd* | *-*-openbsd* | *-*-dragonfly*)\n+      ;;\n+  *-*-solaris2* | *-*-hpux11*)\n+      ;;\n+  *-*-darwin* | *-*-aix*)\n+      ;;\n+  *)\n+      UNSUPPORTED=1 ;;\n+  esac"}, {"sha": "96225b570ddb245daa99c0c0682e7c4efeb7f0c6", "filename": "configure", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -672,6 +672,7 @@ LDFLAGS\n CFLAGS\n CC\n EXTRA_CONFIGARGS_LIBJAVA\n+extra_liboffloadmic_configure_flags\n target_subdir\n host_subdir\n build_subdir\n@@ -754,6 +755,7 @@ enable_libquadmath_support\n enable_libada\n enable_libssp\n enable_libstdcxx\n+enable_liboffloadmic\n enable_static_libjava\n enable_bootstrap\n with_mpc\n@@ -1477,6 +1479,8 @@ Optional Features:\n   --enable-libada         build libada directory\n   --enable-libssp         build libssp directory\n   --disable-libstdcxx     do not build libstdc++-v3 directory\n+  --enable-liboffloadmic=ARG\n+                          build liboffloadmic [ARG={no,host,target}]\n   --enable-static-libjava[=ARG]\n                           build static libjava [default=no]\n   --enable-bootstrap      enable bootstrapping [yes if native build]\n@@ -2737,6 +2741,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n \t\ttarget-libcilkrts \\\n+\t\ttarget-liboffloadmic \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n@@ -3076,6 +3081,44 @@ if test \"${ENABLE_LIBSTDCXX}\" = \"no\" ; then\n   noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n fi\n \n+# If this is accelerator compiler and its target is intelmic we enable\n+# target liboffloadmic by default.  If this is compiler with offloading\n+# for intelmic we enable host liboffloadmic by default.  Otherwise\n+# liboffloadmic is disabled by default.\n+# Check whether --enable-liboffloadmic was given.\n+if test \"${enable_liboffloadmic+set}\" = set; then :\n+  enableval=$enable_liboffloadmic; case \"$enableval\" in\n+  no | host | target)\n+    enable_liboffloadmic=$enableval ;;\n+  *)\n+    as_fn_error \"--enable-liboffloadmic=no/host/target\" \"$LINENO\" 5 ;;\n+esac\n+else\n+  if test \"${ENABLE_AS_ACCELERATOR_FOR}\" != \"no\"; then\n+  case \"${target}\" in\n+    *-intelmic-* | *-intelmicemul-*)\n+      enable_liboffloadmic=target\n+      extra_liboffloadmic_configure_flags=\"--enable-liboffloadmic=target\"\n+      ;;\n+    *)\n+      enable_liboffloadmic=no\n+      ;;\n+  esac\n+else\n+  case \"${enable_offload_targets}\" in\n+    *-intelmic-* | *-intelmicemul-*)\n+      enable_liboffloadmic=host\n+      extra_liboffloadmic_configure_flags=\"--enable-liboffloadmic=host\"\n+      ;;\n+    *)\n+      enable_liboffloadmic=no\n+      ;;\n+    esac\n+fi\n+fi\n+\n+\n+\n # Save it here so that, even in case of --enable-libgcj, if the Java\n # front-end isn't enabled, we still get libgcj disabled.\n libgcj_saved=$libgcj\n@@ -3169,6 +3212,25 @@ $as_echo \"yes\" >&6; }\n     fi\n fi\n \n+# Disable liboffloadmic on unsupported systems.\n+if test -d ${srcdir}/liboffloadmic; then\n+    if test x$enable_liboffloadmic != xno; then\n+\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for liboffloadmic support\" >&5\n+$as_echo_n \"checking for liboffloadmic support... \" >&6; }\n+\tif (srcdir=${srcdir}/liboffloadmic; \\\n+\t\t. ${srcdir}/configure.tgt; \\\n+\t\ttest -n \"$UNSUPPORTED\")\n+\tthen\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+\t    noconfigdirs=\"$noconfigdirs target-liboffloadmic\"\n+\telse\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n+$as_echo \"yes\" >&6; }\n+\tfi\n+    fi\n+fi\n+\n # Disable libitm on unsupported systems.\n if test -d ${srcdir}/libitm; then\n     if test x$enable_libitm = x; then\n@@ -6350,7 +6412,7 @@ case ,${enable_languages},:${enable_objc_gc} in\n     ;;\n esac\n \n-# Disable libcilkrts, libitm, libsanitizer, libvtv if we're not building C++\n+# Disable libcilkrts, libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++\n case ,${enable_languages}, in\n   *,c++,*)\n     # Disable libcilkrts, libitm, libsanitizer if we're not building libstdc++\n@@ -6362,7 +6424,7 @@ case ,${enable_languages}, in\n     esac\n     ;;\n   *)\n-    noconfigdirs=\"$noconfigdirs target-libcilkrts target-libitm target-libsanitizer target-libvtv\"\n+    noconfigdirs=\"$noconfigdirs target-libcilkrts target-liboffloadmic target-libitm target-libsanitizer target-libvtv\"\n     ;;\n esac\n "}, {"sha": "b27fb1dfdea62d958efe13c29fb1c02b4b6bcb5e", "filename": "configure.ac", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -156,6 +156,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n \t\ttarget-libcilkrts \\\n+\t\ttarget-liboffloadmic \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n@@ -456,6 +457,42 @@ ENABLE_LIBSTDCXX=default)\n   noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n fi]\n \n+# If this is accelerator compiler and its target is intelmic we enable\n+# target liboffloadmic by default.  If this is compiler with offloading\n+# for intelmic we enable host liboffloadmic by default.  Otherwise\n+# liboffloadmic is disabled by default.\n+AC_ARG_ENABLE([liboffloadmic],\n+AC_HELP_STRING([[--enable-liboffloadmic[=ARG]]],\n+\t       [build liboffloadmic @<:@ARG={no,host,target}@:>@]),\n+[case \"$enableval\" in\n+  no | host | target)\n+    enable_liboffloadmic=$enableval ;;\n+  *)\n+    AC_MSG_ERROR([--enable-liboffloadmic=no/host/target]) ;;\n+esac],\n+[if test \"${ENABLE_AS_ACCELERATOR_FOR}\" != \"no\"; then\n+  case \"${target}\" in\n+    *-intelmic-* | *-intelmicemul-*)\n+      enable_liboffloadmic=target\n+      extra_liboffloadmic_configure_flags=\"--enable-liboffloadmic=target\"\n+      ;;\n+    *)\n+      enable_liboffloadmic=no\n+      ;;\n+  esac\n+else\n+  case \"${enable_offload_targets}\" in\n+    *-intelmic-* | *-intelmicemul-*)\n+      enable_liboffloadmic=host\n+      extra_liboffloadmic_configure_flags=\"--enable-liboffloadmic=host\"\n+      ;;\n+    *)\n+      enable_liboffloadmic=no\n+      ;;\n+    esac\n+fi])\n+AC_SUBST(extra_liboffloadmic_configure_flags)\n+\n # Save it here so that, even in case of --enable-libgcj, if the Java\n # front-end isn't enabled, we still get libgcj disabled.\n libgcj_saved=$libgcj\n@@ -541,6 +578,22 @@ if test -d ${srcdir}/libcilkrts; then\n     fi\n fi\n \n+# Disable liboffloadmic on unsupported systems.\n+if test -d ${srcdir}/liboffloadmic; then\n+    if test x$enable_liboffloadmic != xno; then\n+\tAC_MSG_CHECKING([for liboffloadmic support])\n+\tif (srcdir=${srcdir}/liboffloadmic; \\\n+\t\t. ${srcdir}/configure.tgt; \\\n+\t\ttest -n \"$UNSUPPORTED\")\n+\tthen\n+\t    AC_MSG_RESULT([no])\n+\t    noconfigdirs=\"$noconfigdirs target-liboffloadmic\"\n+\telse\n+\t    AC_MSG_RESULT([yes])\n+\tfi\n+    fi\n+fi\n+\n # Disable libitm on unsupported systems.\n if test -d ${srcdir}/libitm; then\n     if test x$enable_libitm = x; then\n@@ -2063,7 +2116,7 @@ case ,${enable_languages},:${enable_objc_gc} in\n     ;;\n esac\n \n-# Disable libcilkrts, libitm, libsanitizer, libvtv if we're not building C++\n+# Disable libcilkrts, libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++\n case ,${enable_languages}, in\n   *,c++,*)\n     # Disable libcilkrts, libitm, libsanitizer if we're not building libstdc++\n@@ -2075,7 +2128,7 @@ case ,${enable_languages}, in\n     esac\n     ;;\n   *)\n-    noconfigdirs=\"$noconfigdirs target-libcilkrts target-libitm target-libsanitizer target-libvtv\"\n+    noconfigdirs=\"$noconfigdirs target-libcilkrts target-liboffloadmic target-libitm target-libsanitizer target-libvtv\"\n     ;;\n esac\n "}, {"sha": "a4a535380694099ebb16f99ed4d613b37a6d2688", "filename": "libcilkrts/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/libcilkrts%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/libcilkrts%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FChangeLog?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -1,3 +1,7 @@\n+2014-11-13  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\t* configure.tgt: Use config/target-posix.\n+\n 2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR target/63610"}, {"sha": "fcda70fb68f837c3069960f68bd268f15beed987", "filename": "libcilkrts/configure.tgt", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/libcilkrts%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/libcilkrts%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fconfigure.tgt?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -43,19 +43,4 @@ case \"${target}\" in\n esac\n \n # Disable libcilkrts on non POSIX hosted systems.\n-if test x$enable_libcilkrts = x ; then\n-    # Enable libcilkrts by default on hosted POSIX systems.\n-    case \"${target}\" in\n-    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)\n-        ;;\n-    *-*-netbsd* | *-*-freebsd* | *-*-openbsd* | *-*-dragonfly*)\n-        ;;\n-    *-*-solaris2* | *-*-hpux11*)\n-        ;;\n-    *-*-darwin* | *-*-aix*)\n-        ;;\n-    *)\n-        UNSUPPORTED=1\n-        ;;\n-    esac\n-fi\n+. ${srcdir}/../config/target-posix"}, {"sha": "ced55ff94fca47e3ae845ac893df14808e706978", "filename": "liboffloadmic/ChangeLog", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,94 @@\n+2014-11-13  Kirill Yukhin  <kirill.yukhin@intel.com>\n+\n+\tInitial commit.  Imported from upstream:\n+\thttps://www.openmprtl.org/sites/default/files/liboffload_oss.tgz\n+\t* Makefile.am: New file.\n+\t* Makefile.in: New file, generated by automake.\n+\t* aclocal.m4: New file, generated by aclocal.\n+\t* configure: New file, generated by autoconf.\n+\t* configure.ac: New file.\n+\t* configure.tgt: Ditto.\n+\t* doc/doxygen/config: Ditto.\n+\t* doc/doxygen/header.tex: Ditto.\n+\t* include/coi/common/COIEngine_common.h: Ditto.\n+\t* include/coi/common/COIMacros_common.h: Ditto.\n+\t* include/coi/common/COIPerf_common.h : Ditto.\n+\t* include/coi/common/COIResult_common.h : Ditto.\n+\t* include/coi/common/COITypes_common.h: Ditto.\n+\t* include/coi/sink/COIBuffer_sink.h: Ditto.\n+\t* include/coi/sink/COIPipeline_sink.h: Ditto.\n+\t* include/coi/sink/COIProcess_sink.h: Ditto.\n+\t* include/coi/source/COIBuffer_source.h: Ditto.\n+\t* include/coi/source/COIEngine_source.h: Ditto.\n+\t* include/coi/source/COIEvent_source.h: Ditto.\n+\t* include/coi/source/COIPipeline_source.h: Ditto.\n+\t* include/coi/source/COIProcess_source.h: Ditto.\n+\t* include/myo/myo.h: Ditto.\n+\t* include/myo/myoimpl.h: Ditto.\n+\t* include/myo/myotypes.h: Ditto.\n+\t* liboffloadmic_host.spec.in: Ditto.\n+\t* liboffloadmic_target.spec.in: Ditto.\n+\t* runtime/cean_util.cpp: Ditto.\n+\t* runtime/cean_util.h: Ditto.\n+\t* runtime/coi/coi_client.cpp: Ditto.\n+\t* runtime/coi/coi_client.h: Ditto.\n+\t* runtime/coi/coi_server.cpp: Ditto.\n+\t* runtime/coi/coi_server.h: Ditto.\n+\t* runtime/compiler_if_host.cpp: Ditto.\n+\t* runtime/compiler_if_host.h: Ditto.\n+\t* runtime/compiler_if_target.cpp: Ditto.\n+\t* runtime/compiler_if_target.h: Ditto.\n+\t* runtime/dv_util.cpp: Ditto.\n+\t* runtime/dv_util.h: Ditto.\n+\t* runtime/emulator/coi_common.h: Ditto.\n+\t* runtime/emulator/coi_device.cpp: Ditto.\n+\t* runtime/emulator/coi_device.h: Ditto.\n+\t* runtime/emulator/coi_host.cpp: Ditto.\n+\t* runtime/emulator/coi_host.h: Ditto.\n+\t* runtime/emulator/coi_version_asm.h: Ditto.\n+\t* runtime/emulator/coi_version_linker_script.map: Ditto.\n+\t* runtime/emulator/myo_client.cpp: Ditto.\n+\t* runtime/emulator/myo_service.cpp: Ditto.\n+\t* runtime/emulator/myo_service.h: Ditto.\n+\t* runtime/emulator/myo_version_asm.h: Ditto.\n+\t* runtime/emulator/myo_version_linker_script.map: Ditto.\n+\t* runtime/liboffload_error.c: Ditto.\n+\t* runtime/liboffload_error_codes.h: Ditto.\n+\t* runtime/liboffload_msg.c: Ditto.\n+\t* runtime/liboffload_msg.h: Ditto.\n+\t* runtime/mic_lib.f90: Ditto.\n+\t* runtime/offload.h: Ditto.\n+\t* runtime/offload_common.cpp: Ditto.\n+\t* runtime/offload_common.h: Ditto.\n+\t* runtime/offload_engine.cpp: Ditto.\n+\t* runtime/offload_engine.h: Ditto.\n+\t* runtime/offload_env.cpp: Ditto.\n+\t* runtime/offload_env.h: Ditto.\n+\t* runtime/offload_host.cpp: Ditto.\n+\t* runtime/offload_host.h: Ditto.\n+\t* runtime/offload_myo_host.cpp: Ditto.\n+\t* runtime/offload_myo_host.h: Ditto.\n+\t* runtime/offload_myo_target.cpp: Ditto.\n+\t* runtime/offload_myo_target.h: Ditto.\n+\t* runtime/offload_omp_host.cpp: Ditto.\n+\t* runtime/offload_omp_target.cpp: Ditto.\n+\t* runtime/offload_orsl.cpp: Ditto.\n+\t* runtime/offload_orsl.h: Ditto.\n+\t* runtime/offload_table.cpp: Ditto.\n+\t* runtime/offload_table.h: Ditto.\n+\t* runtime/offload_target.cpp: Ditto.\n+\t* runtime/offload_target.h: Ditto.\n+\t* runtime/offload_target_main.cpp: Ditto.\n+\t* runtime/offload_timer.h: Ditto.\n+\t* runtime/offload_timer_host.cpp: Ditto.\n+\t* runtime/offload_timer_target.cpp: Ditto.\n+\t* runtime/offload_trace.cpp: Ditto.\n+\t* runtime/offload_trace.h: Ditto.\n+\t* runtime/offload_util.cpp: Ditto.\n+\t* runtime/offload_util.h: Ditto.\n+\t* runtime/ofldbegin.cpp: Ditto.\n+\t* runtime/ofldend.cpp: Ditto.\n+\t* runtime/orsl-lite/include/orsl-lite.h: Ditto.\n+\t* runtime/orsl-lite/lib/orsl-lite.c: Ditto.\n+\t* runtime/orsl-lite/version.txt: Ditto.\n+\t* runtime/use_mpss2.txt: Ditto."}, {"sha": "adc7c4cf55a601f3f4d2b912e8c1916cded06b85", "filename": "liboffloadmic/Makefile.am", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FMakefile.am?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,172 @@\n+#\n+#    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+#\n+#    Redistribution and use in source and binary forms, with or without\n+#    modification, are permitted provided that the following conditions\n+#    are met:\n+#\n+#      * Redistributions of source code must retain the above copyright\n+#        notice, this list of conditions and the following disclaimer.\n+#      * Redistributions in binary form must reproduce the above copyright\n+#        notice, this list of conditions and the following disclaimer in the\n+#        documentation and/or other materials provided with the distribution.\n+#      * Neither the name of Intel Corporation nor the names of its\n+#        contributors may be used to endorse or promote products derived\n+#        from this software without specific prior written permission.\n+#\n+#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+\n+\n+AUTOMAKE_OPTIONS = foreign\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+# Build plugin for Intel MIC\n+SUBDIRS = . plugin\n+\n+# Directories.\n+build_dir = $(top_builddir)\n+coi_inc_dir = $(top_srcdir)/include/coi\n+myo_inc_dir = $(top_srcdir)/include/myo\n+libgomp_dir = $(build_dir)/../libgomp\n+source_dir = $(top_srcdir)/runtime\n+\n+# May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n+\n+# Target list.\n+if LIBOFFLOADMIC_HOST\n+  nodist_toolexeclib_HEADERS = liboffloadmic_host.spec\n+  toolexeclib_LTLIBRARIES = libcoi_host.la libmyo-client.la liboffloadmic_host.la\n+  nodist_libsubinclude_HEADERS = runtime/compiler_if_host.h\n+  ofld_obj =\n+else # LIBOFFLOADMIC_TARGET\n+  nodist_toolexeclib_HEADERS = liboffloadmic_target.spec\n+  toolexeclib_LTLIBRARIES = libcoi_device.la libmyo-service.la liboffloadmic_target.la\n+  nodist_libsubinclude_HEADERS = runtime/compiler_if_target.h\n+  ofld_obj = ofldbegin.o ofldend.o\n+endif\n+\n+# Liboffloadmic.\n+liboffloadmic_sources = runtime/dv_util.cpp \\\n+\t\t\truntime/liboffload_error.c \\\n+\t\t\truntime/liboffload_msg.c \\\n+\t\t\truntime/offload_common.cpp \\\n+\t\t\truntime/offload_table.cpp \\\n+\t\t\truntime/offload_trace.cpp \\\n+\t\t\truntime/offload_util.cpp\n+\n+liboffloadmic_cppflags = -DLINUX -DCOI_LIBRARY_VERSION=2 -DMYO_SUPPORT -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -I$(coi_inc_dir) -I$(myo_inc_dir) -I$(source_dir) -I$(libgomp_dir)\n+\n+liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n+\t\t\t\truntime/cean_util.cpp \\\n+\t\t\t\truntime/coi/coi_client.cpp \\\n+\t\t\t\truntime/compiler_if_host.cpp \\\n+\t\t\t\truntime/offload_engine.cpp \\\n+\t\t\t\truntime/offload_env.cpp \\\n+\t\t\t\truntime/offload_host.cpp \\\n+\t\t\t\truntime/offload_myo_host.cpp \\\n+\t\t\t\truntime/offload_omp_host.cpp \\\n+\t\t\t\truntime/offload_orsl.cpp \\\n+\t\t\t\truntime/offload_timer_host.cpp \\\n+\t\t\t\truntime/orsl-lite/lib/orsl-lite.c\n+\n+liboffloadmic_host_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=1\n+liboffloadmic_host_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n+liboffloadmic_host_la_LIBADD = libcoi_host.la libmyo-client.la\n+liboffloadmic_host_la_DEPENDENCIES = $(liboffloadmic_host_la_LIBADD)\n+\n+liboffloadmic_target_la_SOURCES = $(liboffloadmic_sources) \\\n+\t\t\t\t  runtime/coi/coi_server.cpp \\\n+\t\t\t\t  runtime/compiler_if_target.cpp \\\n+\t\t\t\t  runtime/offload_myo_target.cpp \\\n+\t\t\t\t  runtime/offload_omp_target.cpp \\\n+\t\t\t\t  runtime/offload_target.cpp \\\n+\t\t\t\t  runtime/offload_timer_target.cpp\n+\n+liboffloadmic_target_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=0\n+liboffloadmic_target_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n+liboffloadmic_target_la_LIBADD = libcoi_device.la libmyo-service.la\n+liboffloadmic_target_la_DEPENDENCIES = $(liboffloadmic_target_la_LIBADD)\n+\n+# Emulator.\n+libcoi_host_la_SOURCES = runtime/emulator/coi_host.cpp\n+libcoi_device_la_SOURCES = runtime/emulator/coi_device.cpp\n+libmyo_client_la_SOURCES = runtime/emulator/myo_client.cpp\n+libmyo_service_la_SOURCES = runtime/emulator/myo_service.cpp\n+\n+libcoi_host_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n+libcoi_device_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n+libmyo_client_la_DEPENDENCIES = runtime/emulator/myo_version_linker_script.map\n+libmyo_service_la_DEPENDENCIES = runtime/emulator/myo_version_linker_script.map\n+\n+libcoi_host_la_CPPFLAGS = -I$(coi_inc_dir)\n+libcoi_device_la_CPPFLAGS = -I$(coi_inc_dir)\n+libmyo_client_la_CPPFLAGS = -I$(myo_inc_dir)\n+libmyo_service_la_CPPFLAGS = -I$(myo_inc_dir)\n+\n+libcoi_host_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n+libcoi_device_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n+libmyo_client_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/myo_version_linker_script.map\n+libmyo_service_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/myo_version_linker_script.map\n+\n+# ofldbegin, ofldend\n+all-local: $(ofld_obj)\n+\n+ofldbegin.o: runtime/ofldbegin.cpp\n+\t$(CXXCOMPILE) $(liboffloadmic_target_la_CPPFLAGS) -c $< -o $@\n+\n+ofldend.o: runtime/ofldend.cpp\n+\t$(CXXCOMPILE) $(liboffloadmic_target_la_CPPFLAGS) -c $< -o $@\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+       \"AR_FLAGS=$(AR_FLAGS)\" \\\n+       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+       \"CFLAGS=$(CFLAGS)\" \\\n+       \"CXXFLAGS=$(CXXFLAGS)\" \\\n+       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+       \"INSTALL=$(INSTALL)\" \\\n+       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+       \"JC1FLAGS=$(JC1FLAGS)\" \\\n+       \"LDFLAGS=$(LDFLAGS)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+       \"MAKE=$(MAKE)\" \\\n+       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+       \"SHELL=$(SHELL)\" \\\n+       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+       \"exec_prefix=$(exec_prefix)\" \\\n+       \"infodir=$(infodir)\" \\\n+       \"libdir=$(libdir)\" \\\n+       \"prefix=$(prefix)\" \\\n+       \"includedir=$(includedir)\" \\\n+       \"AR=$(AR)\" \\\n+       \"AS=$(AS)\" \\\n+       \"LD=$(LD)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"NM=$(NM)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"RANLIB=$(RANLIB)\" \\\n+       \"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES =\n+"}, {"sha": "8a5280308a5e4fbb2a204cdaa361e35b52ad44cb", "filename": "liboffloadmic/Makefile.in", "status": "added", "additions": 1254, "deletions": 0, "changes": 1254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FMakefile.in?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,1254 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+#\n+#    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+#\n+#    Redistribution and use in source and binary forms, with or without\n+#    modification, are permitted provided that the following conditions\n+#    are met:\n+#\n+#      * Redistributions of source code must retain the above copyright\n+#        notice, this list of conditions and the following disclaimer.\n+#      * Redistributions in binary form must reproduce the above copyright\n+#        notice, this list of conditions and the following disclaimer in the\n+#        documentation and/or other materials provided with the distribution.\n+#      * Neither the name of Intel Corporation nor the names of its\n+#        contributors may be used to endorse or promote products derived\n+#        from this software without specific prior written permission.\n+#\n+#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+subdir = .\n+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n+\t$(top_srcdir)/configure $(am__configure_deps) \\\n+\t$(srcdir)/../mkinstalldirs \\\n+\t$(srcdir)/liboffloadmic_host.spec.in \\\n+\t$(srcdir)/liboffloadmic_target.spec.in $(srcdir)/../depcomp\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n+\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n+\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_CLEAN_FILES = liboffloadmic_host.spec liboffloadmic_target.spec\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n+\t\"$(DESTDIR)$(libsubincludedir)\" \"$(DESTDIR)$(toolexeclibdir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libcoi_device_la_LIBADD =\n+am_libcoi_device_la_OBJECTS = libcoi_device_la-coi_device.lo\n+libcoi_device_la_OBJECTS = $(am_libcoi_device_la_OBJECTS)\n+libcoi_device_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libcoi_device_la_LDFLAGS) $(LDFLAGS) -o $@\n+@LIBOFFLOADMIC_HOST_FALSE@am_libcoi_device_la_rpath = -rpath \\\n+@LIBOFFLOADMIC_HOST_FALSE@\t$(toolexeclibdir)\n+libcoi_host_la_LIBADD =\n+am_libcoi_host_la_OBJECTS = libcoi_host_la-coi_host.lo\n+libcoi_host_la_OBJECTS = $(am_libcoi_host_la_OBJECTS)\n+libcoi_host_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libcoi_host_la_LDFLAGS) $(LDFLAGS) -o $@\n+@LIBOFFLOADMIC_HOST_TRUE@am_libcoi_host_la_rpath = -rpath \\\n+@LIBOFFLOADMIC_HOST_TRUE@\t$(toolexeclibdir)\n+libmyo_client_la_LIBADD =\n+am_libmyo_client_la_OBJECTS = libmyo_client_la-myo_client.lo\n+libmyo_client_la_OBJECTS = $(am_libmyo_client_la_OBJECTS)\n+libmyo_client_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libmyo_client_la_LDFLAGS) $(LDFLAGS) -o $@\n+@LIBOFFLOADMIC_HOST_TRUE@am_libmyo_client_la_rpath = -rpath \\\n+@LIBOFFLOADMIC_HOST_TRUE@\t$(toolexeclibdir)\n+libmyo_service_la_LIBADD =\n+am_libmyo_service_la_OBJECTS = libmyo_service_la-myo_service.lo\n+libmyo_service_la_OBJECTS = $(am_libmyo_service_la_OBJECTS)\n+libmyo_service_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libmyo_service_la_LDFLAGS) $(LDFLAGS) -o $@\n+@LIBOFFLOADMIC_HOST_FALSE@am_libmyo_service_la_rpath = -rpath \\\n+@LIBOFFLOADMIC_HOST_FALSE@\t$(toolexeclibdir)\n+am__objects_1 = liboffloadmic_host_la-dv_util.lo \\\n+\tliboffloadmic_host_la-liboffload_error.lo \\\n+\tliboffloadmic_host_la-liboffload_msg.lo \\\n+\tliboffloadmic_host_la-offload_common.lo \\\n+\tliboffloadmic_host_la-offload_table.lo \\\n+\tliboffloadmic_host_la-offload_trace.lo \\\n+\tliboffloadmic_host_la-offload_util.lo\n+am_liboffloadmic_host_la_OBJECTS = $(am__objects_1) \\\n+\tliboffloadmic_host_la-cean_util.lo \\\n+\tliboffloadmic_host_la-coi_client.lo \\\n+\tliboffloadmic_host_la-compiler_if_host.lo \\\n+\tliboffloadmic_host_la-offload_engine.lo \\\n+\tliboffloadmic_host_la-offload_env.lo \\\n+\tliboffloadmic_host_la-offload_host.lo \\\n+\tliboffloadmic_host_la-offload_myo_host.lo \\\n+\tliboffloadmic_host_la-offload_omp_host.lo \\\n+\tliboffloadmic_host_la-offload_orsl.lo \\\n+\tliboffloadmic_host_la-offload_timer_host.lo \\\n+\tliboffloadmic_host_la-orsl-lite.lo\n+liboffloadmic_host_la_OBJECTS = $(am_liboffloadmic_host_la_OBJECTS)\n+liboffloadmic_host_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(liboffloadmic_host_la_LDFLAGS) $(LDFLAGS) -o $@\n+@LIBOFFLOADMIC_HOST_TRUE@am_liboffloadmic_host_la_rpath = -rpath \\\n+@LIBOFFLOADMIC_HOST_TRUE@\t$(toolexeclibdir)\n+am__objects_2 = liboffloadmic_target_la-dv_util.lo \\\n+\tliboffloadmic_target_la-liboffload_error.lo \\\n+\tliboffloadmic_target_la-liboffload_msg.lo \\\n+\tliboffloadmic_target_la-offload_common.lo \\\n+\tliboffloadmic_target_la-offload_table.lo \\\n+\tliboffloadmic_target_la-offload_trace.lo \\\n+\tliboffloadmic_target_la-offload_util.lo\n+am_liboffloadmic_target_la_OBJECTS = $(am__objects_2) \\\n+\tliboffloadmic_target_la-coi_server.lo \\\n+\tliboffloadmic_target_la-compiler_if_target.lo \\\n+\tliboffloadmic_target_la-offload_myo_target.lo \\\n+\tliboffloadmic_target_la-offload_omp_target.lo \\\n+\tliboffloadmic_target_la-offload_target.lo \\\n+\tliboffloadmic_target_la-offload_timer_target.lo\n+liboffloadmic_target_la_OBJECTS =  \\\n+\t$(am_liboffloadmic_target_la_OBJECTS)\n+liboffloadmic_target_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(liboffloadmic_target_la_LDFLAGS) $(LDFLAGS) -o \\\n+\t$@\n+@LIBOFFLOADMIC_HOST_FALSE@am_liboffloadmic_target_la_rpath = -rpath \\\n+@LIBOFFLOADMIC_HOST_FALSE@\t$(toolexeclibdir)\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libcoi_device_la_SOURCES) $(libcoi_host_la_SOURCES) \\\n+\t$(libmyo_client_la_SOURCES) $(libmyo_service_la_SOURCES) \\\n+\t$(liboffloadmic_host_la_SOURCES) \\\n+\t$(liboffloadmic_target_la_SOURCES)\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n+\thtml-recursive info-recursive install-data-recursive \\\n+\tinstall-dvi-recursive install-exec-recursive \\\n+\tinstall-html-recursive install-info-recursive \\\n+\tinstall-pdf-recursive install-ps-recursive install-recursive \\\n+\tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n+\tps-recursive uninstall-recursive\n+HEADERS = $(nodist_libsubinclude_HEADERS) \\\n+\t$(nodist_toolexeclib_HEADERS)\n+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n+  distclean-recursive maintainer-clean-recursive\n+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n+\t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS\n+ETAGS = etags\n+CTAGS = ctags\n+DIST_SUBDIRS = $(SUBDIRS)\n+ACLOCAL = @ACLOCAL@\n+ALLOCA = @ALLOCA@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+link_offloadmic_host = @link_offloadmic_host@\n+link_offloadmic_target = @link_offloadmic_target@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+lt_cv_dlopen_libs = @lt_cv_dlopen_libs@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AUTOMAKE_OPTIONS = foreign\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+# Build plugin for Intel MIC\n+SUBDIRS = . plugin\n+\n+# Directories.\n+build_dir = $(top_builddir)\n+coi_inc_dir = $(top_srcdir)/include/coi\n+myo_inc_dir = $(top_srcdir)/include/myo\n+libgomp_dir = $(build_dir)/../libgomp\n+source_dir = $(top_srcdir)/runtime\n+\n+# May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n+@LIBOFFLOADMIC_HOST_FALSE@nodist_toolexeclib_HEADERS = liboffloadmic_target.spec\n+\n+# Target list.\n+@LIBOFFLOADMIC_HOST_TRUE@nodist_toolexeclib_HEADERS = liboffloadmic_host.spec\n+@LIBOFFLOADMIC_HOST_FALSE@toolexeclib_LTLIBRARIES = libcoi_device.la libmyo-service.la liboffloadmic_target.la\n+@LIBOFFLOADMIC_HOST_TRUE@toolexeclib_LTLIBRARIES = libcoi_host.la libmyo-client.la liboffloadmic_host.la\n+@LIBOFFLOADMIC_HOST_FALSE@nodist_libsubinclude_HEADERS = runtime/compiler_if_target.h\n+@LIBOFFLOADMIC_HOST_TRUE@nodist_libsubinclude_HEADERS = runtime/compiler_if_host.h\n+@LIBOFFLOADMIC_HOST_FALSE@ofld_obj = ofldbegin.o ofldend.o\n+@LIBOFFLOADMIC_HOST_TRUE@ofld_obj = \n+\n+# Liboffloadmic.\n+liboffloadmic_sources = runtime/dv_util.cpp \\\n+\t\t\truntime/liboffload_error.c \\\n+\t\t\truntime/liboffload_msg.c \\\n+\t\t\truntime/offload_common.cpp \\\n+\t\t\truntime/offload_table.cpp \\\n+\t\t\truntime/offload_trace.cpp \\\n+\t\t\truntime/offload_util.cpp\n+\n+liboffloadmic_cppflags = -DLINUX -DCOI_LIBRARY_VERSION=2 -DMYO_SUPPORT -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -I$(coi_inc_dir) -I$(myo_inc_dir) -I$(source_dir) -I$(libgomp_dir)\n+liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n+\t\t\t\truntime/cean_util.cpp \\\n+\t\t\t\truntime/coi/coi_client.cpp \\\n+\t\t\t\truntime/compiler_if_host.cpp \\\n+\t\t\t\truntime/offload_engine.cpp \\\n+\t\t\t\truntime/offload_env.cpp \\\n+\t\t\t\truntime/offload_host.cpp \\\n+\t\t\t\truntime/offload_myo_host.cpp \\\n+\t\t\t\truntime/offload_omp_host.cpp \\\n+\t\t\t\truntime/offload_orsl.cpp \\\n+\t\t\t\truntime/offload_timer_host.cpp \\\n+\t\t\t\truntime/orsl-lite/lib/orsl-lite.c\n+\n+liboffloadmic_host_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=1\n+liboffloadmic_host_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n+liboffloadmic_host_la_LIBADD = libcoi_host.la libmyo-client.la\n+liboffloadmic_host_la_DEPENDENCIES = $(liboffloadmic_host_la_LIBADD)\n+liboffloadmic_target_la_SOURCES = $(liboffloadmic_sources) \\\n+\t\t\t\t  runtime/coi/coi_server.cpp \\\n+\t\t\t\t  runtime/compiler_if_target.cpp \\\n+\t\t\t\t  runtime/offload_myo_target.cpp \\\n+\t\t\t\t  runtime/offload_omp_target.cpp \\\n+\t\t\t\t  runtime/offload_target.cpp \\\n+\t\t\t\t  runtime/offload_timer_target.cpp\n+\n+liboffloadmic_target_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=0\n+liboffloadmic_target_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n+liboffloadmic_target_la_LIBADD = libcoi_device.la libmyo-service.la\n+liboffloadmic_target_la_DEPENDENCIES = $(liboffloadmic_target_la_LIBADD)\n+\n+# Emulator.\n+libcoi_host_la_SOURCES = runtime/emulator/coi_host.cpp\n+libcoi_device_la_SOURCES = runtime/emulator/coi_device.cpp\n+libmyo_client_la_SOURCES = runtime/emulator/myo_client.cpp\n+libmyo_service_la_SOURCES = runtime/emulator/myo_service.cpp\n+libcoi_host_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n+libcoi_device_la_DEPENDENCIES = runtime/emulator/coi_version_linker_script.map\n+libmyo_client_la_DEPENDENCIES = runtime/emulator/myo_version_linker_script.map\n+libmyo_service_la_DEPENDENCIES = runtime/emulator/myo_version_linker_script.map\n+libcoi_host_la_CPPFLAGS = -I$(coi_inc_dir)\n+libcoi_device_la_CPPFLAGS = -I$(coi_inc_dir)\n+libmyo_client_la_CPPFLAGS = -I$(myo_inc_dir)\n+libmyo_service_la_CPPFLAGS = -I$(myo_inc_dir)\n+libcoi_host_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n+libcoi_device_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/coi_version_linker_script.map\n+libmyo_client_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/myo_version_linker_script.map\n+libmyo_service_la_LDFLAGS = -lrt -Wl,--version-script=$(source_dir)/emulator/myo_version_linker_script.map\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+       \"AR_FLAGS=$(AR_FLAGS)\" \\\n+       \"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+       \"CFLAGS=$(CFLAGS)\" \\\n+       \"CXXFLAGS=$(CXXFLAGS)\" \\\n+       \"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+       \"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+       \"INSTALL=$(INSTALL)\" \\\n+       \"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+       \"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+       \"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+       \"JC1FLAGS=$(JC1FLAGS)\" \\\n+       \"LDFLAGS=$(LDFLAGS)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+       \"MAKE=$(MAKE)\" \\\n+       \"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+       \"SHELL=$(SHELL)\" \\\n+       \"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+       \"exec_prefix=$(exec_prefix)\" \\\n+       \"infodir=$(infodir)\" \\\n+       \"libdir=$(libdir)\" \\\n+       \"prefix=$(prefix)\" \\\n+       \"includedir=$(includedir)\" \\\n+       \"AR=$(AR)\" \\\n+       \"AS=$(AS)\" \\\n+       \"LD=$(LD)\" \\\n+       \"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+       \"NM=$(NM)\" \\\n+       \"PICFLAG=$(PICFLAG)\" \\\n+       \"RANLIB=$(RANLIB)\" \\\n+       \"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-recursive\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .cpp .lo .o .obj\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+liboffloadmic_host.spec: $(top_builddir)/config.status $(srcdir)/liboffloadmic_host.spec.in\n+\tcd $(top_builddir) && $(SHELL) ./config.status $@\n+liboffloadmic_target.spec: $(top_builddir)/config.status $(srcdir)/liboffloadmic_target.spec.in\n+\tcd $(top_builddir) && $(SHELL) ./config.status $@\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libcoi_device.la: $(libcoi_device_la_OBJECTS) $(libcoi_device_la_DEPENDENCIES) \n+\t$(libcoi_device_la_LINK) $(am_libcoi_device_la_rpath) $(libcoi_device_la_OBJECTS) $(libcoi_device_la_LIBADD) $(LIBS)\n+libcoi_host.la: $(libcoi_host_la_OBJECTS) $(libcoi_host_la_DEPENDENCIES) \n+\t$(libcoi_host_la_LINK) $(am_libcoi_host_la_rpath) $(libcoi_host_la_OBJECTS) $(libcoi_host_la_LIBADD) $(LIBS)\n+libmyo-client.la: $(libmyo_client_la_OBJECTS) $(libmyo_client_la_DEPENDENCIES) \n+\t$(libmyo_client_la_LINK) $(am_libmyo_client_la_rpath) $(libmyo_client_la_OBJECTS) $(libmyo_client_la_LIBADD) $(LIBS)\n+libmyo-service.la: $(libmyo_service_la_OBJECTS) $(libmyo_service_la_DEPENDENCIES) \n+\t$(libmyo_service_la_LINK) $(am_libmyo_service_la_rpath) $(libmyo_service_la_OBJECTS) $(libmyo_service_la_LIBADD) $(LIBS)\n+liboffloadmic_host.la: $(liboffloadmic_host_la_OBJECTS) $(liboffloadmic_host_la_DEPENDENCIES) \n+\t$(liboffloadmic_host_la_LINK) $(am_liboffloadmic_host_la_rpath) $(liboffloadmic_host_la_OBJECTS) $(liboffloadmic_host_la_LIBADD) $(LIBS)\n+liboffloadmic_target.la: $(liboffloadmic_target_la_OBJECTS) $(liboffloadmic_target_la_DEPENDENCIES) \n+\t$(liboffloadmic_target_la_LINK) $(am_liboffloadmic_target_la_rpath) $(liboffloadmic_target_la_OBJECTS) $(liboffloadmic_target_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcoi_device_la-coi_device.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcoi_host_la-coi_host.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmyo_client_la-myo_client.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmyo_service_la-myo_service.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-cean_util.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-coi_client.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-dv_util.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-liboffload_error.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-liboffload_msg.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_common.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_engine.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_env.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_host.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_myo_host.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_orsl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_table.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_timer_host.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_trace.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-offload_util.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_host_la-orsl-lite.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-coi_server.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-compiler_if_target.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-dv_util.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-liboffload_error.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_common.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_myo_target.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_table.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_target.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_timer_target.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_trace.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/liboffloadmic_target_la-offload_util.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+liboffloadmic_host_la-liboffload_error.lo: runtime/liboffload_error.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_host_la-liboffload_error.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-liboffload_error.Tpo -c -o liboffloadmic_host_la-liboffload_error.lo `test -f 'runtime/liboffload_error.c' || echo '$(srcdir)/'`runtime/liboffload_error.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-liboffload_error.Tpo $(DEPDIR)/liboffloadmic_host_la-liboffload_error.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/liboffload_error.c' object='liboffloadmic_host_la-liboffload_error.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_host_la-liboffload_error.lo `test -f 'runtime/liboffload_error.c' || echo '$(srcdir)/'`runtime/liboffload_error.c\n+\n+liboffloadmic_host_la-liboffload_msg.lo: runtime/liboffload_msg.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_host_la-liboffload_msg.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-liboffload_msg.Tpo -c -o liboffloadmic_host_la-liboffload_msg.lo `test -f 'runtime/liboffload_msg.c' || echo '$(srcdir)/'`runtime/liboffload_msg.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-liboffload_msg.Tpo $(DEPDIR)/liboffloadmic_host_la-liboffload_msg.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/liboffload_msg.c' object='liboffloadmic_host_la-liboffload_msg.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_host_la-liboffload_msg.lo `test -f 'runtime/liboffload_msg.c' || echo '$(srcdir)/'`runtime/liboffload_msg.c\n+\n+liboffloadmic_host_la-orsl-lite.lo: runtime/orsl-lite/lib/orsl-lite.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_host_la-orsl-lite.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-orsl-lite.Tpo -c -o liboffloadmic_host_la-orsl-lite.lo `test -f 'runtime/orsl-lite/lib/orsl-lite.c' || echo '$(srcdir)/'`runtime/orsl-lite/lib/orsl-lite.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-orsl-lite.Tpo $(DEPDIR)/liboffloadmic_host_la-orsl-lite.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/orsl-lite/lib/orsl-lite.c' object='liboffloadmic_host_la-orsl-lite.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_host_la-orsl-lite.lo `test -f 'runtime/orsl-lite/lib/orsl-lite.c' || echo '$(srcdir)/'`runtime/orsl-lite/lib/orsl-lite.c\n+\n+liboffloadmic_target_la-liboffload_error.lo: runtime/liboffload_error.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_target_la-liboffload_error.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-liboffload_error.Tpo -c -o liboffloadmic_target_la-liboffload_error.lo `test -f 'runtime/liboffload_error.c' || echo '$(srcdir)/'`runtime/liboffload_error.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-liboffload_error.Tpo $(DEPDIR)/liboffloadmic_target_la-liboffload_error.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/liboffload_error.c' object='liboffloadmic_target_la-liboffload_error.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_target_la-liboffload_error.lo `test -f 'runtime/liboffload_error.c' || echo '$(srcdir)/'`runtime/liboffload_error.c\n+\n+liboffloadmic_target_la-liboffload_msg.lo: runtime/liboffload_msg.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT liboffloadmic_target_la-liboffload_msg.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Tpo -c -o liboffloadmic_target_la-liboffload_msg.lo `test -f 'runtime/liboffload_msg.c' || echo '$(srcdir)/'`runtime/liboffload_msg.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Tpo $(DEPDIR)/liboffloadmic_target_la-liboffload_msg.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/liboffload_msg.c' object='liboffloadmic_target_la-liboffload_msg.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o liboffloadmic_target_la-liboffload_msg.lo `test -f 'runtime/liboffload_msg.c' || echo '$(srcdir)/'`runtime/liboffload_msg.c\n+\n+.cpp.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cpp.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cpp.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+libcoi_device_la-coi_device.lo: runtime/emulator/coi_device.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_device_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libcoi_device_la-coi_device.lo -MD -MP -MF $(DEPDIR)/libcoi_device_la-coi_device.Tpo -c -o libcoi_device_la-coi_device.lo `test -f 'runtime/emulator/coi_device.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_device.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/libcoi_device_la-coi_device.Tpo $(DEPDIR)/libcoi_device_la-coi_device.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/emulator/coi_device.cpp' object='libcoi_device_la-coi_device.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_device_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libcoi_device_la-coi_device.lo `test -f 'runtime/emulator/coi_device.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_device.cpp\n+\n+libcoi_host_la-coi_host.lo: runtime/emulator/coi_host.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libcoi_host_la-coi_host.lo -MD -MP -MF $(DEPDIR)/libcoi_host_la-coi_host.Tpo -c -o libcoi_host_la-coi_host.lo `test -f 'runtime/emulator/coi_host.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_host.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/libcoi_host_la-coi_host.Tpo $(DEPDIR)/libcoi_host_la-coi_host.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/emulator/coi_host.cpp' object='libcoi_host_la-coi_host.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libcoi_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libcoi_host_la-coi_host.lo `test -f 'runtime/emulator/coi_host.cpp' || echo '$(srcdir)/'`runtime/emulator/coi_host.cpp\n+\n+libmyo_client_la-myo_client.lo: runtime/emulator/myo_client.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libmyo_client_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libmyo_client_la-myo_client.lo -MD -MP -MF $(DEPDIR)/libmyo_client_la-myo_client.Tpo -c -o libmyo_client_la-myo_client.lo `test -f 'runtime/emulator/myo_client.cpp' || echo '$(srcdir)/'`runtime/emulator/myo_client.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/libmyo_client_la-myo_client.Tpo $(DEPDIR)/libmyo_client_la-myo_client.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/emulator/myo_client.cpp' object='libmyo_client_la-myo_client.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libmyo_client_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libmyo_client_la-myo_client.lo `test -f 'runtime/emulator/myo_client.cpp' || echo '$(srcdir)/'`runtime/emulator/myo_client.cpp\n+\n+libmyo_service_la-myo_service.lo: runtime/emulator/myo_service.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libmyo_service_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT libmyo_service_la-myo_service.lo -MD -MP -MF $(DEPDIR)/libmyo_service_la-myo_service.Tpo -c -o libmyo_service_la-myo_service.lo `test -f 'runtime/emulator/myo_service.cpp' || echo '$(srcdir)/'`runtime/emulator/myo_service.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/libmyo_service_la-myo_service.Tpo $(DEPDIR)/libmyo_service_la-myo_service.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/emulator/myo_service.cpp' object='libmyo_service_la-myo_service.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libmyo_service_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o libmyo_service_la-myo_service.lo `test -f 'runtime/emulator/myo_service.cpp' || echo '$(srcdir)/'`runtime/emulator/myo_service.cpp\n+\n+liboffloadmic_host_la-dv_util.lo: runtime/dv_util.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-dv_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-dv_util.Tpo -c -o liboffloadmic_host_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-dv_util.Tpo $(DEPDIR)/liboffloadmic_host_la-dv_util.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/dv_util.cpp' object='liboffloadmic_host_la-dv_util.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n+\n+liboffloadmic_host_la-offload_common.lo: runtime/offload_common.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_common.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_common.Tpo -c -o liboffloadmic_host_la-offload_common.lo `test -f 'runtime/offload_common.cpp' || echo '$(srcdir)/'`runtime/offload_common.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_common.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_common.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_common.cpp' object='liboffloadmic_host_la-offload_common.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_common.lo `test -f 'runtime/offload_common.cpp' || echo '$(srcdir)/'`runtime/offload_common.cpp\n+\n+liboffloadmic_host_la-offload_table.lo: runtime/offload_table.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_table.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_table.Tpo -c -o liboffloadmic_host_la-offload_table.lo `test -f 'runtime/offload_table.cpp' || echo '$(srcdir)/'`runtime/offload_table.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_table.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_table.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_table.cpp' object='liboffloadmic_host_la-offload_table.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_table.lo `test -f 'runtime/offload_table.cpp' || echo '$(srcdir)/'`runtime/offload_table.cpp\n+\n+liboffloadmic_host_la-offload_trace.lo: runtime/offload_trace.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_trace.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_trace.Tpo -c -o liboffloadmic_host_la-offload_trace.lo `test -f 'runtime/offload_trace.cpp' || echo '$(srcdir)/'`runtime/offload_trace.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_trace.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_trace.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_trace.cpp' object='liboffloadmic_host_la-offload_trace.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_trace.lo `test -f 'runtime/offload_trace.cpp' || echo '$(srcdir)/'`runtime/offload_trace.cpp\n+\n+liboffloadmic_host_la-offload_util.lo: runtime/offload_util.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_util.Tpo -c -o liboffloadmic_host_la-offload_util.lo `test -f 'runtime/offload_util.cpp' || echo '$(srcdir)/'`runtime/offload_util.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_util.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_util.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_util.cpp' object='liboffloadmic_host_la-offload_util.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_util.lo `test -f 'runtime/offload_util.cpp' || echo '$(srcdir)/'`runtime/offload_util.cpp\n+\n+liboffloadmic_host_la-cean_util.lo: runtime/cean_util.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-cean_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-cean_util.Tpo -c -o liboffloadmic_host_la-cean_util.lo `test -f 'runtime/cean_util.cpp' || echo '$(srcdir)/'`runtime/cean_util.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-cean_util.Tpo $(DEPDIR)/liboffloadmic_host_la-cean_util.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/cean_util.cpp' object='liboffloadmic_host_la-cean_util.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-cean_util.lo `test -f 'runtime/cean_util.cpp' || echo '$(srcdir)/'`runtime/cean_util.cpp\n+\n+liboffloadmic_host_la-coi_client.lo: runtime/coi/coi_client.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-coi_client.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-coi_client.Tpo -c -o liboffloadmic_host_la-coi_client.lo `test -f 'runtime/coi/coi_client.cpp' || echo '$(srcdir)/'`runtime/coi/coi_client.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-coi_client.Tpo $(DEPDIR)/liboffloadmic_host_la-coi_client.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/coi/coi_client.cpp' object='liboffloadmic_host_la-coi_client.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-coi_client.lo `test -f 'runtime/coi/coi_client.cpp' || echo '$(srcdir)/'`runtime/coi/coi_client.cpp\n+\n+liboffloadmic_host_la-compiler_if_host.lo: runtime/compiler_if_host.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-compiler_if_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Tpo -c -o liboffloadmic_host_la-compiler_if_host.lo `test -f 'runtime/compiler_if_host.cpp' || echo '$(srcdir)/'`runtime/compiler_if_host.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Tpo $(DEPDIR)/liboffloadmic_host_la-compiler_if_host.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/compiler_if_host.cpp' object='liboffloadmic_host_la-compiler_if_host.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-compiler_if_host.lo `test -f 'runtime/compiler_if_host.cpp' || echo '$(srcdir)/'`runtime/compiler_if_host.cpp\n+\n+liboffloadmic_host_la-offload_engine.lo: runtime/offload_engine.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_engine.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_engine.Tpo -c -o liboffloadmic_host_la-offload_engine.lo `test -f 'runtime/offload_engine.cpp' || echo '$(srcdir)/'`runtime/offload_engine.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_engine.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_engine.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_engine.cpp' object='liboffloadmic_host_la-offload_engine.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_engine.lo `test -f 'runtime/offload_engine.cpp' || echo '$(srcdir)/'`runtime/offload_engine.cpp\n+\n+liboffloadmic_host_la-offload_env.lo: runtime/offload_env.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_env.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_env.Tpo -c -o liboffloadmic_host_la-offload_env.lo `test -f 'runtime/offload_env.cpp' || echo '$(srcdir)/'`runtime/offload_env.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_env.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_env.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_env.cpp' object='liboffloadmic_host_la-offload_env.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_env.lo `test -f 'runtime/offload_env.cpp' || echo '$(srcdir)/'`runtime/offload_env.cpp\n+\n+liboffloadmic_host_la-offload_host.lo: runtime/offload_host.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_host.Tpo -c -o liboffloadmic_host_la-offload_host.lo `test -f 'runtime/offload_host.cpp' || echo '$(srcdir)/'`runtime/offload_host.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_host.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_host.cpp' object='liboffloadmic_host_la-offload_host.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_host.lo `test -f 'runtime/offload_host.cpp' || echo '$(srcdir)/'`runtime/offload_host.cpp\n+\n+liboffloadmic_host_la-offload_myo_host.lo: runtime/offload_myo_host.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_myo_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_myo_host.Tpo -c -o liboffloadmic_host_la-offload_myo_host.lo `test -f 'runtime/offload_myo_host.cpp' || echo '$(srcdir)/'`runtime/offload_myo_host.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_myo_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_myo_host.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_myo_host.cpp' object='liboffloadmic_host_la-offload_myo_host.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_myo_host.lo `test -f 'runtime/offload_myo_host.cpp' || echo '$(srcdir)/'`runtime/offload_myo_host.cpp\n+\n+liboffloadmic_host_la-offload_omp_host.lo: runtime/offload_omp_host.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_omp_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Tpo -c -o liboffloadmic_host_la-offload_omp_host.lo `test -f 'runtime/offload_omp_host.cpp' || echo '$(srcdir)/'`runtime/offload_omp_host.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_omp_host.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_omp_host.cpp' object='liboffloadmic_host_la-offload_omp_host.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_omp_host.lo `test -f 'runtime/offload_omp_host.cpp' || echo '$(srcdir)/'`runtime/offload_omp_host.cpp\n+\n+liboffloadmic_host_la-offload_orsl.lo: runtime/offload_orsl.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_orsl.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_orsl.Tpo -c -o liboffloadmic_host_la-offload_orsl.lo `test -f 'runtime/offload_orsl.cpp' || echo '$(srcdir)/'`runtime/offload_orsl.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_orsl.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_orsl.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_orsl.cpp' object='liboffloadmic_host_la-offload_orsl.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_orsl.lo `test -f 'runtime/offload_orsl.cpp' || echo '$(srcdir)/'`runtime/offload_orsl.cpp\n+\n+liboffloadmic_host_la-offload_timer_host.lo: runtime/offload_timer_host.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_host_la-offload_timer_host.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_host_la-offload_timer_host.Tpo -c -o liboffloadmic_host_la-offload_timer_host.lo `test -f 'runtime/offload_timer_host.cpp' || echo '$(srcdir)/'`runtime/offload_timer_host.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_host_la-offload_timer_host.Tpo $(DEPDIR)/liboffloadmic_host_la-offload_timer_host.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_timer_host.cpp' object='liboffloadmic_host_la-offload_timer_host.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_host_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_host_la-offload_timer_host.lo `test -f 'runtime/offload_timer_host.cpp' || echo '$(srcdir)/'`runtime/offload_timer_host.cpp\n+\n+liboffloadmic_target_la-dv_util.lo: runtime/dv_util.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-dv_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-dv_util.Tpo -c -o liboffloadmic_target_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-dv_util.Tpo $(DEPDIR)/liboffloadmic_target_la-dv_util.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/dv_util.cpp' object='liboffloadmic_target_la-dv_util.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-dv_util.lo `test -f 'runtime/dv_util.cpp' || echo '$(srcdir)/'`runtime/dv_util.cpp\n+\n+liboffloadmic_target_la-offload_common.lo: runtime/offload_common.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_common.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_common.Tpo -c -o liboffloadmic_target_la-offload_common.lo `test -f 'runtime/offload_common.cpp' || echo '$(srcdir)/'`runtime/offload_common.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_common.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_common.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_common.cpp' object='liboffloadmic_target_la-offload_common.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_common.lo `test -f 'runtime/offload_common.cpp' || echo '$(srcdir)/'`runtime/offload_common.cpp\n+\n+liboffloadmic_target_la-offload_table.lo: runtime/offload_table.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_table.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_table.Tpo -c -o liboffloadmic_target_la-offload_table.lo `test -f 'runtime/offload_table.cpp' || echo '$(srcdir)/'`runtime/offload_table.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_table.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_table.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_table.cpp' object='liboffloadmic_target_la-offload_table.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_table.lo `test -f 'runtime/offload_table.cpp' || echo '$(srcdir)/'`runtime/offload_table.cpp\n+\n+liboffloadmic_target_la-offload_trace.lo: runtime/offload_trace.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_trace.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_trace.Tpo -c -o liboffloadmic_target_la-offload_trace.lo `test -f 'runtime/offload_trace.cpp' || echo '$(srcdir)/'`runtime/offload_trace.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_trace.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_trace.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_trace.cpp' object='liboffloadmic_target_la-offload_trace.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_trace.lo `test -f 'runtime/offload_trace.cpp' || echo '$(srcdir)/'`runtime/offload_trace.cpp\n+\n+liboffloadmic_target_la-offload_util.lo: runtime/offload_util.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_util.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_util.Tpo -c -o liboffloadmic_target_la-offload_util.lo `test -f 'runtime/offload_util.cpp' || echo '$(srcdir)/'`runtime/offload_util.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_util.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_util.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_util.cpp' object='liboffloadmic_target_la-offload_util.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_util.lo `test -f 'runtime/offload_util.cpp' || echo '$(srcdir)/'`runtime/offload_util.cpp\n+\n+liboffloadmic_target_la-coi_server.lo: runtime/coi/coi_server.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-coi_server.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-coi_server.Tpo -c -o liboffloadmic_target_la-coi_server.lo `test -f 'runtime/coi/coi_server.cpp' || echo '$(srcdir)/'`runtime/coi/coi_server.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-coi_server.Tpo $(DEPDIR)/liboffloadmic_target_la-coi_server.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/coi/coi_server.cpp' object='liboffloadmic_target_la-coi_server.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-coi_server.lo `test -f 'runtime/coi/coi_server.cpp' || echo '$(srcdir)/'`runtime/coi/coi_server.cpp\n+\n+liboffloadmic_target_la-compiler_if_target.lo: runtime/compiler_if_target.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-compiler_if_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-compiler_if_target.Tpo -c -o liboffloadmic_target_la-compiler_if_target.lo `test -f 'runtime/compiler_if_target.cpp' || echo '$(srcdir)/'`runtime/compiler_if_target.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-compiler_if_target.Tpo $(DEPDIR)/liboffloadmic_target_la-compiler_if_target.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/compiler_if_target.cpp' object='liboffloadmic_target_la-compiler_if_target.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-compiler_if_target.lo `test -f 'runtime/compiler_if_target.cpp' || echo '$(srcdir)/'`runtime/compiler_if_target.cpp\n+\n+liboffloadmic_target_la-offload_myo_target.lo: runtime/offload_myo_target.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_myo_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_myo_target.Tpo -c -o liboffloadmic_target_la-offload_myo_target.lo `test -f 'runtime/offload_myo_target.cpp' || echo '$(srcdir)/'`runtime/offload_myo_target.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_myo_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_myo_target.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_myo_target.cpp' object='liboffloadmic_target_la-offload_myo_target.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_myo_target.lo `test -f 'runtime/offload_myo_target.cpp' || echo '$(srcdir)/'`runtime/offload_myo_target.cpp\n+\n+liboffloadmic_target_la-offload_omp_target.lo: runtime/offload_omp_target.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_omp_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Tpo -c -o liboffloadmic_target_la-offload_omp_target.lo `test -f 'runtime/offload_omp_target.cpp' || echo '$(srcdir)/'`runtime/offload_omp_target.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_omp_target.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_omp_target.cpp' object='liboffloadmic_target_la-offload_omp_target.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_omp_target.lo `test -f 'runtime/offload_omp_target.cpp' || echo '$(srcdir)/'`runtime/offload_omp_target.cpp\n+\n+liboffloadmic_target_la-offload_target.lo: runtime/offload_target.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_target.Tpo -c -o liboffloadmic_target_la-offload_target.lo `test -f 'runtime/offload_target.cpp' || echo '$(srcdir)/'`runtime/offload_target.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_target.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_target.cpp' object='liboffloadmic_target_la-offload_target.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_target.lo `test -f 'runtime/offload_target.cpp' || echo '$(srcdir)/'`runtime/offload_target.cpp\n+\n+liboffloadmic_target_la-offload_timer_target.lo: runtime/offload_timer_target.cpp\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT liboffloadmic_target_la-offload_timer_target.lo -MD -MP -MF $(DEPDIR)/liboffloadmic_target_la-offload_timer_target.Tpo -c -o liboffloadmic_target_la-offload_timer_target.lo `test -f 'runtime/offload_timer_target.cpp' || echo '$(srcdir)/'`runtime/offload_timer_target.cpp\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/liboffloadmic_target_la-offload_timer_target.Tpo $(DEPDIR)/liboffloadmic_target_la-offload_timer_target.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='runtime/offload_timer_target.cpp' object='liboffloadmic_target_la-offload_timer_target.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(liboffloadmic_target_la_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o liboffloadmic_target_la-offload_timer_target.lo `test -f 'runtime/offload_timer_target.cpp' || echo '$(srcdir)/'`runtime/offload_timer_target.cpp\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n+\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+install-nodist_libsubincludeHEADERS: $(nodist_libsubinclude_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(libsubincludedir)\" || $(MKDIR_P) \"$(DESTDIR)$(libsubincludedir)\"\n+\t@list='$(nodist_libsubinclude_HEADERS)'; test -n \"$(libsubincludedir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(libsubincludedir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(libsubincludedir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-nodist_libsubincludeHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(nodist_libsubinclude_HEADERS)'; test -n \"$(libsubincludedir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(libsubincludedir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(libsubincludedir)\" && rm -f $$files\n+install-nodist_toolexeclibHEADERS: $(nodist_toolexeclib_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(toolexeclibdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-nodist_toolexeclibHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibdir)\" && rm -f $$files\n+\n+# This directory's subdirectories are mostly independent; you can cd\n+# into them and run `make' without going through this Makefile.\n+# To change the values of `make' variables: instead of editing Makefiles,\n+# (1) if the variable is set in `config.status', edit `config.status'\n+#     (which will cause the Makefiles to be regenerated when you run `make');\n+# (2) otherwise, pass the desired values on the `make' command line.\n+$(RECURSIVE_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    dot_seen=yes; \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone; \\\n+\tif test \"$$dot_seen\" = \"no\"; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n+\tfi; test -z \"$$fail\"\n+\n+$(RECURSIVE_CLEAN_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\tcase \"$@\" in \\\n+\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n+\t  *) list='$(SUBDIRS)' ;; \\\n+\tesac; \\\n+\trev=''; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = \".\"; then :; else \\\n+\t    rev=\"$$subdir $$rev\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\trev=\"$$rev .\"; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tfor subdir in $$rev; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone && test -z \"$$fail\"\n+tags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n+\tdone\n+ctags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n+\tdone\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n+\t  include_option=--etags-include; \\\n+\t  empty_fix=.; \\\n+\telse \\\n+\t  include_option=--include; \\\n+\t  empty_fix=; \\\n+\tfi; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test ! -f $$subdir/TAGS || \\\n+\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+check-am: all-am\n+check: check-recursive\n+all-am: Makefile $(LTLIBRARIES) all-multi $(HEADERS) all-local\n+installdirs: installdirs-recursive\n+installdirs-am:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(libsubincludedir)\" \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-recursive\n+install-exec: install-exec-recursive\n+install-data: install-data-recursive\n+uninstall: uninstall-recursive\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-recursive\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-multi clean-recursive\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-multi distclean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-libtool distclean-tags\n+\n+dvi: dvi-recursive\n+\n+dvi-am:\n+\n+html: html-recursive\n+\n+html-am:\n+\n+info: info-recursive\n+\n+info-am:\n+\n+install-data-am: install-nodist_libsubincludeHEADERS\n+\n+install-dvi: install-dvi-recursive\n+\n+install-dvi-am:\n+\n+install-exec-am: install-multi install-nodist_toolexeclibHEADERS \\\n+\tinstall-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-recursive\n+\n+install-html-am:\n+\n+install-info: install-info-recursive\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-recursive\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-recursive\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-multi mostlyclean-recursive\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-recursive\n+\n+pdf-am:\n+\n+ps: ps-recursive\n+\n+ps-am:\n+\n+uninstall-am: uninstall-nodist_libsubincludeHEADERS \\\n+\tuninstall-nodist_toolexeclibHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all-multi \\\n+\tclean-multi ctags-recursive distclean-multi install-am \\\n+\tinstall-multi install-strip maintainer-clean-multi \\\n+\tmostlyclean-multi tags-recursive\n+\n+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \\\n+\tall all-am all-local all-multi am--refresh check check-am \\\n+\tclean clean-generic clean-libtool clean-multi \\\n+\tclean-toolexeclibLTLIBRARIES ctags ctags-recursive distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-multi distclean-tags dvi dvi-am html html-am info \\\n+\tinfo-am install install-am install-data install-data-am \\\n+\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n+\tinstall-html install-html-am install-info install-info-am \\\n+\tinstall-man install-multi install-nodist_libsubincludeHEADERS \\\n+\tinstall-nodist_toolexeclibHEADERS install-pdf install-pdf-am \\\n+\tinstall-ps install-ps-am install-strip \\\n+\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n+\tinstalldirs installdirs-am maintainer-clean \\\n+\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tmostlyclean-multi pdf pdf-am ps ps-am tags tags-recursive \\\n+\tuninstall uninstall-am uninstall-nodist_libsubincludeHEADERS \\\n+\tuninstall-nodist_toolexeclibHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+\n+# ofldbegin, ofldend\n+all-local: $(ofld_obj)\n+\n+ofldbegin.o: runtime/ofldbegin.cpp\n+\t$(CXXCOMPILE) $(liboffloadmic_target_la_CPPFLAGS) -c $< -o $@\n+\n+ofldend.o: runtime/ofldend.cpp\n+\t$(CXXCOMPILE) $(liboffloadmic_target_la_CPPFLAGS) -c $< -o $@\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "68107caffa075b0a8a198f60a0e1ee574eb6d58d", "filename": "liboffloadmic/aclocal.m4", "status": "added", "additions": 979, "deletions": 0, "changes": 979, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Faclocal.m4?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,979 @@\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n+[m4_warning([this file was generated for autoconf 2.64.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically `autoreconf'.])])\n+\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.11'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.11.1], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.11.1])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 9\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 10\n+\n+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n+# written in clear, in which case automake, when reading aclocal.m4,\n+# will think it sees a *use*, and therefore will trigger all it's\n+# C support machinery.  Also note that it means that autoscan, seeing\n+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n+\n+\n+# _AM_DEPENDENCIES(NAME)\n+# ----------------------\n+# See how the compiler implements dependency checking.\n+# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n+# We try a few techniques and use that to set a single cache variable.\n+#\n+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n+# dependency, and given that the user is not expected to run this macro,\n+# just rely on AC_PROG_CC.\n+AC_DEFUN([_AM_DEPENDENCIES],\n+[AC_REQUIRE([AM_SET_DEPDIR])dnl\n+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n+AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n+AC_REQUIRE([AM_DEP_TRACK])dnl\n+\n+ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n+       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n+       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n+       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n+       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n+                   [depcc=\"$$1\"   am_compiler_list=])\n+\n+AC_CACHE_CHECK([dependency style of $depcc],\n+               [am_cv_$1_dependencies_compiler_type],\n+[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n+  # We make a subdir and do the tests there.  Otherwise we can end up\n+  # making bogus files that we don't know about and never remove.  For\n+  # instance it was reported that on HP-UX the gcc test will end up\n+  # making a dummy file named `D' -- because `-MD' means `put the output\n+  # in D'.\n+  mkdir conftest.dir\n+  # Copy depcomp to subdir because otherwise we won't find it if we're\n+  # using a relative directory.\n+  cp \"$am_depcomp\" conftest.dir\n+  cd conftest.dir\n+  # We will build objects and dependencies in a subdirectory because\n+  # it helps to detect inapplicable dependency modes.  For instance\n+  # both Tru64's cc and ICC support -MD to output dependencies as a\n+  # side effect of compilation, but ICC will put the dependencies in\n+  # the current directory while Tru64 will put them in the object\n+  # directory.\n+  mkdir sub\n+\n+  am_cv_$1_dependencies_compiler_type=none\n+  if test \"$am_compiler_list\" = \"\"; then\n+     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n+  fi\n+  am__universal=false\n+  m4_case([$1], [CC],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac],\n+    [CXX],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac])\n+\n+  for depmode in $am_compiler_list; do\n+    # Setup a source with many dependencies, because some compilers\n+    # like to wrap large dependency lists on column 80 (with \\), and\n+    # we should not choose a depcomp mode which is confused by this.\n+    #\n+    # We need to recreate these files for each test, as the compiler may\n+    # overwrite some of them when testing with obscure command lines.\n+    # This happens at least with the AIX C compiler.\n+    : > sub/conftest.c\n+    for i in 1 2 3 4 5 6; do\n+      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n+      # Solaris 8's {/usr,}/bin/sh.\n+      touch sub/conftst$i.h\n+    done\n+    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n+\n+    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n+    # mode.  It turns out that the SunPro C++ compiler does not properly\n+    # handle `-M -o', and we need to detect this.  Also, some Intel\n+    # versions had trouble with output in subdirs\n+    am__obj=sub/conftest.${OBJEXT-o}\n+    am__minus_obj=\"-o $am__obj\"\n+    case $depmode in\n+    gcc)\n+      # This depmode causes a compiler race in universal mode.\n+      test \"$am__universal\" = false || continue\n+      ;;\n+    nosideeffect)\n+      # after this tag, mechanisms are not by side-effect, so they'll\n+      # only be used when explicitly requested\n+      if test \"x$enable_dependency_tracking\" = xyes; then\n+\tcontinue\n+      else\n+\tbreak\n+      fi\n+      ;;\n+    msvisualcpp | msvcmsys)\n+      # This compiler won't grok `-c -o', but also, the minuso test has\n+      # not run yet.  These depmodes are late enough in the game, and\n+      # so weak that their functioning should not be impacted.\n+      am__obj=conftest.${OBJEXT-o}\n+      am__minus_obj=\n+      ;;\n+    none) break ;;\n+    esac\n+    if depmode=$depmode \\\n+       source=sub/conftest.c object=$am__obj \\\n+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n+         >/dev/null 2>conftest.err &&\n+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n+      # icc doesn't choke on unknown options, it will just issue warnings\n+      # or remarks (even with -Werror).  So we grep stderr for any message\n+      # that says an option was ignored or not supported.\n+      # When given -MP, icc 7.0 and 7.1 complain thusly:\n+      #   icc: Command line warning: ignoring option '-M'; no argument required\n+      # The diagnosis changed in icc 8.0:\n+      #   icc: Command line remark: option '-MP' not supported\n+      if (grep 'ignoring option' conftest.err ||\n+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n+        am_cv_$1_dependencies_compiler_type=$depmode\n+        break\n+      fi\n+    fi\n+  done\n+\n+  cd ..\n+  rm -rf conftest.dir\n+else\n+  am_cv_$1_dependencies_compiler_type=none\n+fi\n+])\n+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n+AM_CONDITIONAL([am__fastdep$1], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n+])\n+\n+\n+# AM_SET_DEPDIR\n+# -------------\n+# Choose a directory name for dependency files.\n+# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n+AC_DEFUN([AM_SET_DEPDIR],\n+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n+])\n+\n+\n+# AM_DEP_TRACK\n+# ------------\n+AC_DEFUN([AM_DEP_TRACK],\n+[AC_ARG_ENABLE(dependency-tracking,\n+[  --disable-dependency-tracking  speeds up one-time build\n+  --enable-dependency-tracking   do not reject slow dependency extractors])\n+if test \"x$enable_dependency_tracking\" != xno; then\n+  am_depcomp=\"$ac_aux_dir/depcomp\"\n+  AMDEPBACKSLASH='\\'\n+fi\n+AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+AC_SUBST([AMDEPBACKSLASH])dnl\n+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n+])\n+\n+# Generate code to set up dependency tracking.              -*- Autoconf -*-\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+#serial 5\n+\n+# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+# ------------------------------\n+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[{\n+  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n+  # are listed without --file.  Let's play safe and only enable the eval\n+  # if we detect the quoting.\n+  case $CONFIG_FILES in\n+  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n+  *)   set x $CONFIG_FILES ;;\n+  esac\n+  shift\n+  for mf\n+  do\n+    # Strip MF so we end up with the name of the file.\n+    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile or not.\n+    # We used to match only the files named `Makefile.in', but\n+    # some people rename them; so instead we look at the file content.\n+    # Grep'ing the first line is not enough: some people post-process\n+    # each Makefile.in and add a new line on top of each file to say so.\n+    # Grep'ing the whole file is not good either: AIX grep has a line\n+    # limit of 2048, but all sed's we know have understand at least 4000.\n+    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n+      dirpart=`AS_DIRNAME(\"$mf\")`\n+    else\n+      continue\n+    fi\n+    # Extract the definition of DEPDIR, am__include, and am__quote\n+    # from the Makefile without running `make'.\n+    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n+    test -z \"$DEPDIR\" && continue\n+    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+    test -z \"am__include\" && continue\n+    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n+    # When using ansi2knr, U may be empty or an underscore; expand it\n+    U=`sed -n 's/^U = //p' < \"$mf\"`\n+    # Find all dependency output files, they are included files with\n+    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+    # simplest approach to changing $(DEPDIR) to its actual value in the\n+    # expansion.\n+    for file in `sed -n \"\n+      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n+\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n+      # Make sure the directory exists.\n+      test -f \"$dirpart/$file\" && continue\n+      fdir=`AS_DIRNAME([\"$file\"])`\n+      AS_MKDIR_P([$dirpart/$fdir])\n+      # echo \"creating $dirpart/$file\"\n+      echo '# dummy' > \"$dirpart/$file\"\n+    done\n+  done\n+}\n+])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+\n+\n+# AM_OUTPUT_DEPENDENCY_COMMANDS\n+# -----------------------------\n+# This macro should only be invoked once -- use via AC_REQUIRE.\n+#\n+# This code is only required when automatic dependency tracking\n+# is enabled.  FIXME.  This creates each `.P' file that we will\n+# need in order to bootstrap the dependency handling code.\n+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[AC_CONFIG_COMMANDS([depfiles],\n+     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n+])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 16\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.62])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES(CC)],\n+\t\t  [define([AC_PROG_CC],\n+\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES(CXX)],\n+\t\t  [define([AC_PROG_CXX],\n+\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES(OBJC)],\n+\t\t  [define([AC_PROG_OBJC],\n+\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n+])\n+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+])\n+\n+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST(install_sh)])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless `enable' is passed literally.\n+# For symmetry, `disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n+\t\t\t  (and sometimes confusing) to the casual installer],\n+      [USE_MAINTAINER_MODE=$enableval],\n+      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n+\n+# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_MAKE_INCLUDE()\n+# -----------------\n+# Check to see how make treats includes.\n+AC_DEFUN([AM_MAKE_INCLUDE],\n+[am_make=${MAKE-make}\n+cat > confinc << 'END'\n+am__doit:\n+\t@echo this is the am__doit target\n+.PHONY: am__doit\n+END\n+# If we don't find an include directive, just comment out the code.\n+AC_MSG_CHECKING([for style of include used by $am_make])\n+am__include=\"#\"\n+am__quote=\n+_am_result=none\n+# First try GNU make style include.\n+echo \"include confinc\" > confmf\n+# Ignore all kinds of additional output from `make'.\n+case `$am_make -s -f confmf 2> /dev/null` in #(\n+*the\\ am__doit\\ target*)\n+  am__include=include\n+  am__quote=\n+  _am_result=GNU\n+  ;;\n+esac\n+# Now try BSD make style include.\n+if test \"$am__include\" = \"#\"; then\n+   echo '.include \"confinc\"' > confmf\n+   case `$am_make -s -f confmf 2> /dev/null` in #(\n+   *the\\ am__doit\\ target*)\n+     am__include=.include\n+     am__quote=\"\\\"\"\n+     _am_result=BSD\n+     ;;\n+   esac\n+fi\n+AC_SUBST([am__include])\n+AC_SUBST([am__quote])\n+AC_MSG_RESULT([$_am_result])\n+rm -f confinc confmf\n+])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check for `mkdir -p'.\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[AC_PREREQ([2.60])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n+dnl while keeping a definition of mkdir_p for backward compatibility.\n+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n+dnl Makefile.ins that do not define MKDIR_P, so we do our own\n+dnl adjustment using top_builddir (which is defined more often than\n+dnl MKDIR_P).\n+AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n+case $mkdir_p in\n+  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n+  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n+esac\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n+esac\n+\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t \"$srcdir/configure\" conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/depstand.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../config/override.m4])\n+m4_include([../libtool.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])"}, {"sha": "e16c766a126da57824c477492981f001dfc1f26a", "filename": "liboffloadmic/configure", "status": "added", "additions": 16957, "deletions": 0, "changes": 16957, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fconfigure?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "fb575b35c5c6b523043a72d776b13a21e2cf5d39", "filename": "liboffloadmic/configure.ac", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fconfigure.ac?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,131 @@\n+#    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+#\n+#    Redistribution and use in source and binary forms, with or without\n+#    modification, are permitted provided that the following conditions\n+#    are met:\n+#\n+#      * Redistributions of source code must retain the above copyright\n+#        notice, this list of conditions and the following disclaimer.\n+#      * Redistributions in binary form must reproduce the above copyright\n+#        notice, this list of conditions and the following disclaimer in the\n+#        documentation and/or other materials provided with the distribution.\n+#      * Neither the name of Intel Corporation nor the names of its\n+#        contributors may be used to endorse or promote products derived\n+#        from this software without specific prior written permission.\n+#\n+#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+# Process this file with autoconf to produce a configure script, like so:\n+# aclocal -I .. -I ../config && autoconf && automake\n+\n+AC_PREREQ([2.64])\n+AC_INIT([MIC Offload Runtime Library], [1.0], ,[liboffloadmic])\n+\n+AC_CANONICAL_SYSTEM\n+target_alias=${target_alias-$host_alias}\n+AC_SUBST(target_alias)\n+\n+AM_INIT_AUTOMAKE(foreign no-dist)\n+AM_MAINTAINER_MODE\n+\n+AC_PROG_CC\n+AC_PROG_CXX\n+AC_CONFIG_FILES([Makefile liboffloadmic_host.spec liboffloadmic_target.spec])\n+AM_ENABLE_MULTILIB(, ..)\n+AC_FUNC_ALLOCA\n+AC_CHECK_HEADERS([mm_malloc.h], [], [AC_MSG_ERROR([\"Couldn't find mm_malloc.h\"])])\n+AC_CHECK_FUNCS([__secure_getenv secure_getenv])\n+\n+# Get target configure.\n+. ${srcdir}/configure.tgt\n+if test -n \"$UNSUPPORTED\"; then\n+  AC_MSG_ERROR([Configuration ${target} is unsupported])\n+fi\n+\n+if test \"${multilib}\" = \"yes\"; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n+AC_ARG_ENABLE([version-specific-runtime-libs],\n+  AC_HELP_STRING([--enable-version-specific-runtime-libs],\n+\t\t [Specify that runtime libraries should be installed in a compiler-specific directory]),\n+  [case \"$enableval\" in\n+    yes) enable_version_specific_runtime_libs=yes ;;\n+    no)  enable_version_specific_runtime_libs=no ;;\n+    *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;\n+   esac],\n+  [enable_version_specific_runtime_libs=no])\n+AC_MSG_RESULT($enable_version_specific_runtime_libs)\n+\n+# Make sure liboffloadmic is enabled\n+case \"$enable_liboffloadmic\" in\n+  host | target)\n+    ;;\n+  *)\n+    AC_MSG_ERROR([Liboffloadmic is disabled]) ;;\n+esac\n+AM_CONDITIONAL(LIBOFFLOADMIC_HOST, [test x\"$enable_liboffloadmic\" = xhost])\n+\n+# Calculate toolexeclibdir.\n+# Also toolexecdir, though it's only used in toolexeclibdir.\n+case ${enable_version_specific_runtime_libs} in\n+  yes)\n+    # Need the gcc compiler version to know where to install libraries\n+    # and header files if --enable-version-specific-runtime-libs option\n+    # is selected.\n+    toolexecdir='$(libdir)/gcc/$(target_alias)'\n+    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n+    ;;\n+  no)\n+    if test -n \"$with_cross_host\" &&\n+       test x\"$with_cross_host\" != x\"no\"; then\n+      # Install a library built with a cross compiler in tooldir, not libdir.\n+      toolexecdir='$(exec_prefix)/$(target_alias)'\n+      toolexeclibdir='$(toolexecdir)/lib'\n+    else\n+      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n+      toolexeclibdir='$(libdir)'\n+    fi\n+    multi_os_directory=`$CC -print-multi-os-directory`\n+    case $multi_os_directory in\n+      .) ;; # Avoid trailing /.\n+      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n+    esac\n+    ;;\n+esac\n+\n+AC_LIBTOOL_DLOPEN\n+AM_PROG_LIBTOOL\n+# Forbid libtool to hardcode RPATH, because we want to be able to specify\n+# library search directory using LD_LIBRARY_PATH\n+hardcode_into_libs=no\n+AC_SUBST(toolexecdir)\n+AC_SUBST(toolexeclibdir)\n+\n+AC_SUBST(lt_cv_dlopen_libs)\n+\n+if test $enable_shared = yes; then\n+  link_offloadmic_host=\"-loffloadmic_host %{static: $LIBS}\"\n+  link_offloadmic_target=\"-loffloadmic_target %{static: $LIBS}\"\n+else\n+  link_offloadmic_host=\"-loffloadmic_host $LIBS\"\n+  link_offloadmic_target=\"-loffloadmic_target $LIBS\"\n+fi\n+AC_SUBST(link_offloadmic_host)\n+AC_SUBST(link_offloadmic_target)\n+\n+# Must be last\n+AC_OUTPUT"}, {"sha": "3c0310cb4777b87d6befdedaa6d36b0674e33df7", "filename": "liboffloadmic/configure.tgt", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fconfigure.tgt?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,39 @@\n+#    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+#\n+#    Redistribution and use in source and binary forms, with or without\n+#    modification, are permitted provided that the following conditions\n+#    are met:\n+#\n+#      * Redistributions of source code must retain the above copyright\n+#        notice, this list of conditions and the following disclaimer.\n+#      * Redistributions in binary form must reproduce the above copyright\n+#        notice, this list of conditions and the following disclaimer in the\n+#        documentation and/or other materials provided with the distribution.\n+#      * Neither the name of Intel Corporation nor the names of its\n+#        contributors may be used to endorse or promote products derived\n+#        from this software without specific prior written permission.\n+#\n+#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+#    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+# Disable Offload Runtime library for non x86 architecture.\n+case \"${target}\" in\n+  x86_64-*-linux*)\n+    ;;\n+  i?86-*-linux*)\n+    ;;\n+  *-*-*)\n+    UNSUPPORTED=1 ;;\n+esac\n+\n+# Disable liboffloadmic on non POSIX hosted systems.\n+. ${srcdir}/../config/target-posix"}, {"sha": "3ef1019b5ce1b9ed6361657c3017ec6b1563a981", "filename": "liboffloadmic/doc/doxygen/config", "status": "added", "additions": 2328, "deletions": 0, "changes": 2328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fdoc%2Fdoxygen%2Fconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fdoc%2Fdoxygen%2Fconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fdoc%2Fdoxygen%2Fconfig?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "b64a4636b9a96ad768a40eabb2dad8cb8397377b", "filename": "liboffloadmic/doc/doxygen/header.tex", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,90 @@\n+% Latex header for doxygen 1.8.3.1\n+\\documentclass{book}\n+\\usepackage[a4paper,top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm]{geometry}\n+\\usepackage{makeidx}\n+\\usepackage{natbib}\n+\\usepackage{graphicx}\n+\\usepackage{multicol}\n+\\usepackage{float}\n+\\usepackage{listings}\n+\\usepackage{color}\n+\\usepackage{ifthen}\n+\\usepackage[table]{xcolor}\n+\\usepackage{textcomp}\n+\\usepackage{alltt}\n+\\usepackage{ifpdf}\n+\\ifpdf\n+\\usepackage[pdftex,\n+            pagebackref=true,\n+            colorlinks=true,\n+            linkcolor=blue,\n+            unicode\n+           ]{hyperref}\n+\\else\n+\\usepackage[ps2pdf,\n+            pagebackref=true,\n+            colorlinks=true,\n+            linkcolor=blue,\n+            unicode\n+           ]{hyperref}\n+\\usepackage{pspicture}\n+\\fi\n+\\usepackage[utf8]{inputenc}\n+\\usepackage{mathptmx}\n+\\usepackage[scaled=.90]{helvet}\n+\\usepackage{courier}\n+\\usepackage{sectsty}\n+\\usepackage{amssymb}\n+\\usepackage[titles]{tocloft}\n+\\usepackage{doxygen}\n+\\usepackage{fancyhdr}\n+\\pagestyle{fancy}\n+\\lstset{language=C++,inputencoding=utf8,basicstyle=\\footnotesize,breaklines=true,breakatwhitespace=true,tabsize=4,numbers=left }\n+\\makeindex\n+\\setcounter{tocdepth}{3}\n+\\renewcommand{\\footrulewidth}{0.4pt}\n+\\renewcommand{\\familydefault}{\\sfdefault}\n+\\hfuzz=15pt\n+\\setlength{\\emergencystretch}{15pt}\n+\\hbadness=750\n+\\tolerance=750\n+\\begin{document}\n+\\hypersetup{pageanchor=false,citecolor=blue}\n+\\begin{titlepage}\n+\\vspace*{7cm}\n+\\begin{center}\n+{\\Large Intel\\textsuperscript{\\textregistered} Offload Runtime Library }\\\\\n+\\vspace*{1cm}\n+{\\large Generated by Doxygen $doxygenversion }\\\\\n+\\vspace*{0.5cm}\n+{\\small $datetime }\\\\\n+\\end{center}\n+\\end{titlepage}\n+\n+{\\bf FTC Optimization Notice}\n+\n+Intel's compilers may or may not optimize to the same degree for non-Intel microprocessors for\n+optimizations that are not unique to Intel microprocessors. These optimizations include SSE2,\n+SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the\n+availability, functionality, or effectiveness of any optimization on microprocessors not\n+manufactured by Intel.\n+\n+Microprocessor-dependent optimizations in this product are intended for use with Intel\n+microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for\n+Intel microprocessors. Please refer to the applicable product User and Reference Guides for\n+more information regarding the specific instruction sets covered by this notice.\n+\n+Notice revision \\#20110804\n+\n+\\vspace*{0.5cm}\n+\n+{\\bf Trademarks}\n+\n+Intel, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in the U.S. and/or other countries.\n+\n+This document is Copyright \\textcopyright 2014, Intel Corporation. All rights reserved. \n+\n+\\pagenumbering{roman}\n+\\tableofcontents\n+\\pagenumbering{arabic}\n+\\hypersetup{pageanchor=true,citecolor=blue}"}, {"sha": "87123128cf9d758c0ebc2b0d677333f0b9fefaac", "filename": "liboffloadmic/include/coi/common/COIEngine_common.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIENGINE_COMMON_H\n+#define _COIENGINE_COMMON_H\n+\n+/** @ingroup COIEngine\n+ *  @addtogroup COIEnginecommon\n+@{\n+* @file common/COIEngine_common.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+#define COI_MAX_ISA_x86_64_DEVICES 1\n+#define COI_MAX_ISA_MIC_DEVICES 128\n+#define COI_MAX_ISA_KNF_DEVICES COI_MAX_ISA_MIC_DEVICES\n+#define COI_MAX_ISA_KNC_DEVICES COI_MAX_ISA_MIC_DEVICES\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+///  List of ISA types of supported engines.\n+///\n+typedef enum\n+{\n+    COI_ISA_INVALID = 0,        ///< Represents an invalid ISA.\n+    COI_ISA_x86_64,             ///< The ISA for an x86_64 host engine.\n+    COI_ISA_MIC,                ///< Special value used to represent any device\n+                                ///< in the Intel(R) Many Integrated Core\n+                                ///< architecture family.\n+    COI_ISA_KNF,                ///< ISA for L1OM devices.\n+    COI_ISA_KNC                 ///< ISA for K1OM devices.\n+} COI_ISA_TYPE;\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Get the information about the COIEngine executing this function call.\n+///\n+/// @param  out_pType\n+///         [out] The COI_ISA_TYPE of the engine.\n+///\n+/// @param  out_pIndex\n+///         [out] The zero-based index of this engine in the collection of\n+///         engines of the ISA returned in out_pType.\n+///\n+/// @return COI_INVALID_POINTER if the any of the parameters are NULL.\n+///\n+/// @return COI_SUCCESS\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEngineGetIndex(\n+            COI_ISA_TYPE*       out_pType,\n+            uint32_t*           out_pIndex);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIENGINE_COMMON_H */\n+\n+/*! @} */"}, {"sha": "6abddfedaf3d73ecad808622c968544e89f3b8dc", "filename": "liboffloadmic/include/coi/common/COIMacros_common.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIMACROS_COMMON_H\n+#define _COIMACROS_COMMON_H\n+\n+/// @file common/COIMacros_common.h\n+/// Commonly used macros\n+\n+// Note that UNUSUED_ATTR means that it is \"possibly\" unused, not \"definitely\".\n+// This should compile out in release mode if indeed it is unused.\n+    #define UNUSED_ATTR __attribute__((unused))\n+#ifndef UNREFERENCED_CONST_PARAM\n+#define UNREFERENCED_CONST_PARAM(P)     { void* x UNUSED_ATTR = \\\n+                                                 (void*)(uint64_t)P; \\\n+                                        }\n+#endif\n+\n+// This seems to work on everything. \n+#ifndef UNREFERENCED_PARAM\n+#define UNREFERENCED_PARAM(P)          (P = P)\n+#endif\n+\n+#ifndef SYMBOL_VERSION\n+\n+/* Linux support: */\n+\n+    #define SYMBOL_VERSION( SYMBOL , VERSION ) SYMBOL ## VERSION\n+\n+#endif\n+\n+#endif /* _COIMACROS_COMMON_H */"}, {"sha": "b81756f1cc1ed42de1b7a395784718ad99d86e7d", "filename": "liboffloadmic/include/coi/common/COIPerf_common.h", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIPERF_COMMON_H\n+#define _COIPERF_COMMON_H\n+\n+/** @ingroup COIPerf\n+ *  @addtogroup COIPerfCommon\n+@{\n+\n+* @file common/COIPerf_common.h\n+* Performance Analysis API */\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+#include \"../common/COITypes_common.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Returns a performance counter value\n+///\n+/// This function returns a performance counter value that increments\n+/// at a constant rate for all time and is coherent across all cores.\n+///\n+/// @return Current performance counter value or 0 if no performance counter\n+/////         is available\n+///\n+///\n+COIACCESSAPI\n+uint64_t COIPerfGetCycleCounter(void);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Returns the calculated system frequency in hertz.\n+///\n+/// @return Current system frequency in hertz.\n+///\n+COIACCESSAPI\n+uint64_t COIPerfGetCycleFrequency(void);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+/*! @} */\n+\n+#endif /* _COIPERF_COMMON_H */"}, {"sha": "df8a4f681499e35c73c24ba72114598475e03218", "filename": "liboffloadmic/include/coi/common/COIResult_common.h", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIRESULT_COMMON_H\n+#define _COIRESULT_COMMON_H\n+\n+/** @ingroup COIResult\n+ *  @addtogroup COIResultCommon\n+@{\n+\n+* @file common/COIResult_common.h\n+* Result codes and definitions. */\n+\n+#include \"../common/COITypes_common.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef enum COIRESULT\n+{\n+    COI_SUCCESS = 0,                  ///< The function succeeded without error.\n+    COI_ERROR,                        ///< Unspecified error.\n+    COI_NOT_INITIALIZED,              ///< The function was called before the\n+                                      ///< system was initialized.\n+    COI_ALREADY_INITIALIZED,          ///< The function was called after the\n+                                      ///< system was initialized.\n+    COI_ALREADY_EXISTS,               ///< Cannot complete the request due to\n+                                      ///< the existence of a similar object.\n+    COI_DOES_NOT_EXIST,               ///< The specified object was not found.\n+    COI_INVALID_POINTER,              ///< One of the provided addresses was not\n+                                      ///< valid.\n+    COI_OUT_OF_RANGE,                 ///< One of the arguments contains a value\n+                                      ///< that is invalid.\n+    COI_NOT_SUPPORTED,                ///< This function is not currently\n+                                      ///< supported as used.\n+    COI_TIME_OUT_REACHED,             ///< The specified time out caused the\n+                                      ///< function to abort.\n+    COI_MEMORY_OVERLAP,               ///< The source and destination range\n+                                      ///< specified overlaps for the same\n+                                      ///< buffer.\n+    COI_ARGUMENT_MISMATCH,            ///< The specified arguments are not\n+                                      ///< compatible.\n+    COI_SIZE_MISMATCH,                ///< The specified size does not match the\n+                                      ///< expected size.\n+    COI_OUT_OF_MEMORY,                ///< The function was unable to allocate\n+                                      ///< the required memory.\n+    COI_INVALID_HANDLE,               ///< One of the provided handles was not\n+                                      ///< valid.\n+    COI_RETRY,                        ///< This function currently can't\n+                                      ///< complete, but might be able to later.\n+    COI_RESOURCE_EXHAUSTED,           ///< The resource was not large enough.\n+    COI_ALREADY_LOCKED,               ///< The object was expected to be\n+                                      ///< unlocked, but was locked.\n+    COI_NOT_LOCKED,                   ///< The object was expected to be locked,\n+                                      ///< but was unlocked.\n+    COI_MISSING_DEPENDENCY,           ///< One or more dependent components\n+                                      ///< could not be found.\n+    COI_UNDEFINED_SYMBOL,             ///< One or more symbols the component\n+                                      ///< required was not defined in any\n+                                      ///< library.\n+    COI_PENDING,                      ///< Operation is not finished\n+    COI_BINARY_AND_HARDWARE_MISMATCH, ///< A specified binary will not run on\n+                                      ///< the specified hardware.\n+    COI_PROCESS_DIED,\n+    COI_INVALID_FILE,                 ///< The file is invalid for its intended\n+                                      ///< usage in the function.\n+    COI_EVENT_CANCELED,               ///< Event wait on a user event that\n+                                      ///< was unregistered or is being\n+                                      ///< unregistered returns\n+                                      ///< COI_EVENT_CANCELED.\n+    COI_VERSION_MISMATCH,             ///< The version of Intel(R) Coprocessor\n+                                      ///< Offload Infrastructure on the host\n+                                      ///< is not compatible with the version\n+                                      ///< on the device.\n+    COI_BAD_PORT,                     ///< The port that the host is set to \n+                                      ///< connect to is invalid.\n+    COI_AUTHENTICATION_FAILURE,       ///< The daemon was unable to authenticate\n+                                      ///< the user that requested an engine.\n+                                      ///< Only reported if daemon is set up for\n+                                      ///< authorization.\n+    COI_NUM_RESULTS                   ///< Reserved, do not use.\n+}\n+COIRESULT;\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Returns the string version of the passed in COIRESULT. Thus if\n+/// COI_RETRY is passed in, this function returns the string \"COI_RETRY\". If\n+/// the error code passed ins is not valid then \"COI_ERROR\" will be returned.\n+///\n+/// @param in_ResultCode\n+///        [in] COIRESULT code to return the string version of.\n+///\n+/// @return String version of the passed in COIRESULT code.\n+///\n+COIACCESSAPI\n+const char*\n+COIResultGetName(\n+            COIRESULT       in_ResultCode);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIRESULT_COMMON_H */\n+\n+/*! @} */"}, {"sha": "78180dce81b40ac834c92dcfe33c39ccdd0d8da9", "filename": "liboffloadmic/include/coi/common/COITypes_common.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COITYPES_COMMON_H\n+#define _COITYPES_COMMON_H\n+\n+/** @ingroup COITypes\n+ *  @addtogroup COITypesSource\n+@{\n+\n+* @file common/COITypes_common.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+    #include <stdint.h>\n+    #include <wchar.h>\n+    #define COIACCESSAPI /* nothing */\n+    #define COIACCESSAPI2 /* nothing */\n+#endif /* DOXYGEN_SHOULD_SKIP_THIS */\n+\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+struct coievent  { uint64_t opaque[2]; };\n+\n+typedef struct coiprocess  * COIPROCESS;\n+typedef struct coipipeline * COIPIPELINE;\n+typedef struct coifunction * COIFUNCTION;\n+typedef struct coiengine   * COIENGINE;\n+typedef struct coievent      COIEVENT;\n+typedef struct coibuffer   * COIBUFFER;\n+typedef struct coilibrary  * COILIBRARY;\n+typedef struct coimapinst  * COIMAPINSTANCE;\n+\n+typedef uint64_t COI_CPU_MASK[16];\n+\n+/** \n+ *  On Windows, coi_wchar_t is a uint32_t. On Windows, wchar_t is 16 bits wide, and on Linux it is 32 bits wide, so uint32_t is used for portability.\n+ */\n+typedef wchar_t  coi_wchar_t;\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COITYPES_COMMON_H */"}, {"sha": "66d0549010d86fdc5e2a93b7580f5bf9f8a778ac", "filename": "liboffloadmic/include/coi/sink/COIBuffer_sink.h", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIBUFFER_SINK_H\n+#define _COIBUFFER_SINK_H\n+\n+/** @ingroup COIBuffer\n+ *  @addtogroup COIBufferSink\n+@{\n+\n+* @file sink\\COIBuffer_sink.h \n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Adds a reference to the memory of a buffer.  The memory of the buffer\n+/// will remain on the device until both a corresponding COIBufferReleaseRef() \n+/// call is made and the run function that delivered the buffer returns.\n+///\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  streaming buffers should not be AddRef'd. Doing so may result in\n+/// unpredictable results or may cause the sink process to crash.\n+///\n+/// @warning 1.It is possible for enqueued run functions to be unable to \n+///            execute due to all card memory being occupied by addref'ed\n+///            buffers. As such, it is important that whenever a buffer is\n+///            addref'd that there be no dependencies on future run functions\n+///            for progress to be made towards releasing the buffer.\n+///          2.It is important that AddRef is called within the scope of \n+///            run function that carries the buffer to be addref'ed.\n+///\n+/// @param  in_pBuffer\n+///         [in] Pointer to the start of a buffer being addref'ed, that was\n+///         passed in at the start of the run function.\n+/// \n+/// @return COI_SUCCESS if the buffer ref count was successfully incremented.\n+///\n+/// @return COI_INVALID_POINTER if the buffer pointer is NULL.\n+///\n+/// @return COI_INVALID_HANDLE if the buffer pointer is invalid.\n+///\n+COIRESULT\n+COIBufferAddRef(\n+            void*           in_pBuffer);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Removes a reference to the memory of a buffer.  The memory of the buffer\n+/// will be eligible for being freed on the device when the following\n+/// conditions are met: the run function that delivered the buffer\n+/// returns, and the number of calls to COIBufferReleaseRef() matches the \n+/// number of calls to COIBufferAddRef().\n+///\n+/// @warning When a buffer is addref'ed it is assumed that it is in use and all\n+///          other operations on that buffer waits for ReleaseRef() to happen.\n+///          So you cannot pass the addref'ed buffer's handle to RunFunction \n+///          that calls ReleaseRef(). This is a circular dependency and will \n+///          cause a deadlock. Buffer's pointer (buffer's sink side \n+///          address/pointer which is different than source side BUFFER handle)\n+///          needs to be stored somewhere to retrieve it later to use in \n+///          ReleaseRef.\n+///\n+/// @param  in_pBuffer\n+///         [in] Pointer to the start of a buffer previously addref'ed, that\n+///         was passed in at the start of the run function.\n+/// \n+/// @return COI_SUCCESS if the buffer refcount was successfully decremented.\n+///\n+/// @return COI_INVALID_POINTER if the buffer pointer was invalid.\n+///\n+/// @return COI_INVALID_HANDLE if the buffer did not have COIBufferAddRef() \n+///         previously called on it.\n+///\n+COIRESULT\n+COIBufferReleaseRef(\n+            void*           in_pBuffer);\n+\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif \n+\n+#endif /* _COIBUFFER_SINK_H */\n+\n+/*! @} */"}, {"sha": "ccfde205dea0d69462fa6b402cbb2e208c83828d", "filename": "liboffloadmic/include/coi/sink/COIPipeline_sink.h", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIPIPELINE_SINK_H\n+#define _COIPIPELINE_SINK_H\n+\n+/** @ingroup COIPipeline\n+ *  @addtogroup COIPipelineSink\n+@{\n+* @file sink/COIPipeline_sink.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+\n+#ifdef __FreeBSD__\n+#define COINATIVELIBEXPORT_VISIBILITY \"extern\"\n+#else\n+#define COINATIVELIBEXPORT_VISIBILITY \"default\"\n+#endif\n+\n+#ifdef __cplusplus\n+#define COINATIVELIBEXPORT \\\n+    extern \"C\" __attribute__ ((visibility(COINATIVELIBEXPORT_VISIBILITY)))\n+#else\n+#define COINATIVELIBEXPORT \\\n+    __attribute__ ((visibility(COINATIVELIBEXPORT_VISIBILITY)))\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// This is the prototype that run functions should follow.\n+///\n+/// @param   in_BufferCount\n+///          The number of buffers passed to the run function.\n+///\n+/// @param   in_ppBufferPointers\n+///          An array that is in_BufferCount in length that contains the\n+///          sink side virtual addresses for each buffer passed in to\n+///          the run function.\n+///\n+/// @param   in_pBufferLengths\n+///          An array that is in_BufferCount in length of uint32_t integers\n+///          describing the length of each passed in buffer in bytes.\n+///\n+/// @param   in_pMiscData\n+///          Pointer to the MiscData passed in when the run function\n+///          was enqueued on the source.\n+///\n+/// @param   in_MiscDataLen\n+///          Length in bytes of the MiscData passed in when the run function\n+///          was enqueued on the source.\n+///\n+/// @param   in_pReturnValue\n+///          Pointer to the location where the return value from this run\n+///          function will be stored.\n+///\n+/// @param   in_ReturnValueLength\n+///          Length in bytes of the user-allocated ReturnValue pointer.\n+///\n+/// @return  A uint64_t that can be retrieved in the out_UserData parameter\n+///          from the COIPipelineWaitForEvent function.\n+///\n+typedef void\n+(*RunFunctionPtr_t)(\n+            uint32_t        in_BufferCount,\n+            void**          in_ppBufferPointers,\n+            uint64_t*       in_pBufferLengths,\n+            void*           in_pMiscData,\n+            uint16_t        in_MiscDataLength,\n+            void*           in_pReturnValue,\n+            uint16_t        in_ReturnValueLength);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Start processing pipelines on the Sink. This should be done after any\n+/// required initialization in the Sink's application has finished. No\n+/// run functions will actually be executed (although they may be queued)\n+/// until this function is called.\n+///\n+///\n+/// @return COI_SUCCESS if the pipelines were successfully started.\n+///\n+COIRESULT\n+COIPipelineStartExecutingRunFunctions();\n+\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIPIPELINE_SINK_H */\n+\n+/*! @} */"}, {"sha": "90603262c8b62c308875568a4a1ee1591225b5e1", "filename": "liboffloadmic/include/coi/sink/COIProcess_sink.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIPROCESS_SINK_H\n+#define _COIPROCESS_SINK_H\n+\n+/** @ingroup COIProcess\n+ *  @addtogroup COIProcessSink\n+@{\n+* @file sink/COIProcess_sink.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// This call will block while waiting for the source to send a process destroy\n+/// message. This provides the sink side application with an event to keep the\n+/// main() function from exiting until it is directed to by the source. When\n+/// the shutdown message is received this function will stop any future run\n+/// functions from executing but will wait for any current run functions to\n+/// complete. All Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  resources will be cleaned up and no additional Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  APIs\n+/// should be called after this function returns.  This function does not\n+/// invoke exit() so the application can perform any of its own cleanup once\n+/// this call returns.\n+///\n+/// @return COI_SUCCESS once the process receives the shutdown message.\n+///\n+COIRESULT\n+COIProcessWaitForShutdown();\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// This call will block until all stdout and stderr output has been proxied\n+/// to and written by the source. This call guarantees that any output in a\n+/// run function is transmitted to the source before the run function signals\n+/// its completion event back to the source.\n+///\n+/// Note that having an additional thread printing forever while another\n+/// calls COIProxyFlush may lead to a hang because the process will be forced\n+/// to wait until all that output can be flushed to the source before returning\n+/// from this call.\n+///\n+/// @return COI_SUCCESS once the proxy output has been flushed to and written\n+///         written by the host. Note that Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  on the source writes to stdout\n+///         and stderr, but does not flush this output.\n+/// @return COI_SUCCESS if the process was created without enabling\n+///         proxy IO this function.\n+///\n+COIRESULT\n+COIProcessProxyFlush();\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIPROCESS_SINK_H */\n+\n+/*! @} */"}, {"sha": "4a08856f5d16b7b295fdb645f9ca9b1147a70d58", "filename": "liboffloadmic/include/coi/source/COIBuffer_source.h", "status": "added", "additions": 1311, "deletions": 0, "changes": 1311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,1311 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIBUFFER_SOURCE_H\n+#define _COIBUFFER_SOURCE_H\n+\n+/** @ingroup COIBuffer\n+ *  @addtogroup COIBufferSource\n+@{\n+\n+* @file source\\COIBuffer_source.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+/// The valid buffer types that may be created using COIBufferCreate.\n+/// Please see the COI_VALID_BUFFER_TYPES_AND_FLAGS matrix\n+/// below which describes the valid combinations of buffer types and flags.\n+///\n+typedef enum COI_BUFFER_TYPE\n+{\n+    /// Normal buffers exist as a single physical buffer in either Source or\n+    /// Sink physical memory. Mapping the buffer may stall the pipelines.\n+    COI_BUFFER_NORMAL = 1,\n+\n+    /// A streaming buffer creates new versions each time it is passed to\n+    /// Runfunction. These new versions are consumed by run functions.\n+\n+    ///  To_SINK buffers are used to send data from SOURCE to SINK\n+    ///  These buffers are SOURCE write only buffers. If read, won't\n+    ///  get Data written by SINK\n+    COI_BUFFER_STREAMING_TO_SINK,\n+\n+    ///  To_SOURCE buffers are used to get data from SINK to SOURCE\n+    ///  These buffers are SOURCE Read only buffers. If written, data\n+    ///  won't get reflected on SINK side.\n+    COI_BUFFER_STREAMING_TO_SOURCE,\n+\n+    /// A pinned buffer exists in a shared memory region and is always\n+    /// available for read or write operations.\n+    COI_BUFFER_PINNED,\n+\n+    /// OpenCL buffers are similar to Normal buffers except they don't\n+    /// stall pipelines and don't follow any read write dependencies.\n+    COI_BUFFER_OPENCL\n+\n+} COI_BUFFER_TYPE;\n+\n+\n+/// @name COIBUFFER creation flags.\n+/// Please see the COI_VALID_BUFFER_TYPES_AND_FLAGS matrix\n+/// below which describes the valid combinations of buffer types and flags.\n+//@{\n+\n+/// Create the buffer such that it has the same virtual address on all of the\n+/// sink processes with which it is associated.\n+#define COI_SAME_ADDRESS_SINKS             0x00000001\n+\n+/// Create the buffer such that it has the same virtual address on all of the\n+/// sink processes with which it is associated and in the source process.\n+#define COI_SAME_ADDRESS_SINKS_AND_SOURCE  0x00000002\n+\n+/// Hint to the runtime that the source will frequently read the buffer\n+#define COI_OPTIMIZE_SOURCE_READ           0x00000004\n+\n+/// Hint to the runtime that the source will frequently write the buffer\n+#define COI_OPTIMIZE_SOURCE_WRITE          0x00000008\n+\n+/// Hint to the runtime that the sink will frequently read the buffer\n+#define COI_OPTIMIZE_SINK_READ             0x00000010\n+\n+/// Hint to the runtime that the sink will frequently write the buffer\n+#define COI_OPTIMIZE_SINK_WRITE            0x00000020\n+\n+/// Used to delay the pinning of memory into physical pages, until required\n+/// for DMA. This can be used to delay the cost of time spent pinning memory\n+/// until absolutely necessary. Might speed up the execution of COIBufferCreate\n+/// calls, but slow down the first access of the buffer in\n+/// COIPipelineRunFunction(s) or other COIBuffer access API's.\n+/// Also of important note, that with this flag enabled COI will not be able to\n+/// check to see if this memory is read only. Ordinarily this is checked\n+/// and an error is thrown upon buffer creation. With this flag, the error\n+/// might occur later, and cause undetermined behavior. Be sure to always\n+/// use writeable memory for COIBuffers.\n+#define COI_OPTIMIZE_NO_DMA                0x00000040\n+\n+/// Hint to the runtime to try to use huge page sizes for backing store on the\n+/// sink.  Is currently not compatible with PINNED buffers or the SAME_ADDRESS\n+/// flags or the SINK_MEMORY flag.\n+#define COI_OPTIMIZE_HUGE_PAGE_SIZE        0x00000080\n+\n+/// Used to tell Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n+/// to create a buffer using memory that has already been\n+/// allocated on the sink. This flag is only valid when passed in to the\n+/// COIBufferCreateFromMemory API.\n+#define COI_SINK_MEMORY                    0x00000100\n+\n+//@}\n+\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+// Make the flag mask\n+#ifdef F\n+#undef F\n+#endif\n+#define F 0\n+#ifdef T\n+#undef T\n+#endif\n+#define T 1\n+#define MTM(_BUFFER, B1, B2, B3, B4, B5, B6, B7, B8, B9) \\\n+(B1 | B2<<1 | B3<<2 | B4<<3 | B5<<4 | B6<<5 | B7<<6 | B8<<7 | B9<<8)\n+#endif\n+\n+/// \\enum COI_BUFFER_TYPE\n+/// This matrix shows the valid combinations of buffer types and buffer flags\n+/// that may be passed in to COIBufferCreate and COIBufferCreateFromMemory.\n+/// \\code\n+static const uint64_t\n+COI_VALID_BUFFER_TYPES_AND_FLAGS[COI_BUFFER_OPENCL+1] = {\n+/*           |       | SAME |      |       |      |       |     |      |      |\n+             | SAME  | ADDR | OPT  | OPT   | OPT  | OPT   | OPT | HUGE | COI  |\n+             | ADDR  | SINK | SRC  | SRC   | SINK | SINK  | NO  | PAGE | SINK |\n+             | SINKS | SRC  | READ | WRITE | READ | WRITE | DMA | SIZE | MEM  |\n+             +-------+------+------+-------+------+-------+-----+------+-----*/\n+MTM(INVALID  ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F  ),\n+MTM(NORMAL   ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  T  ),\n+MTM(TO_SINK  ,   F   ,   F  ,   F  ,   T   ,   T  ,   T   ,  F  ,   F  ,  F  ),\n+MTM(TO_SOURCE,   F   ,   F  ,   T  ,   F   ,   F  ,   T   ,  F  ,   F  ,  F  ),\n+MTM(PINNED   ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  F  ,   F  ,  F  ),\n+MTM(OPENCL   ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  F  ),\n+};\n+///\\endcode\n+#undef MTM\n+\n+//////////////////////////////////////////////////////////////////////////////\n+/// These flags control how the buffer will be accessed on the source after\n+/// it is mapped.\n+/// Please see the COI_VALID_BUFFER_TYPES_AND_MAP matrix below for the\n+/// valid buffer type and map operation combinations.\n+typedef enum COI_MAP_TYPE\n+{\n+    /// Allows the application to read and write the contents of the buffer\n+    /// after it is mapped.\n+    COI_MAP_READ_WRITE = 1,\n+\n+    /// If this flag is set then the application must only read from the\n+    /// buffer after it is mapped. If the application writes to the buffer\n+    /// the contents will not be reflected back to the sink or stored for\n+    /// the next time the buffer is mapped on the source.\n+    /// This allows the runtime to make significant performance optimizations\n+    /// in buffer handling.\n+    COI_MAP_READ_ONLY,\n+\n+    /// Setting this flag means that the source will overwrite the entire\n+    /// buffer once it is mapped. The app must not read from the buffer and\n+    /// must not expect the contents of the buffer to be synchronized from\n+    /// the sink side during the map operation.\n+    /// This allows the runtime to make significant performance optimizations\n+    /// in buffer handling.\n+    COI_MAP_WRITE_ENTIRE_BUFFER\n+} COI_MAP_TYPE;\n+\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+// Make the flag mask\n+#define MMM(_BUFFER, B1, B2, B3) \\\n+  {  F  , B1, B2, B3}\n+#endif\n+/// \\enum COI_MAP_TYPE\n+/// This matrix shows the valid combinations of buffer types and map\n+/// operations that may be passed in to COIBufferMap.\n+/// \\code\n+static const uint64_t\n+COI_VALID_BUFFER_TYPES_AND_MAP\n+[COI_BUFFER_OPENCL+1][COI_MAP_WRITE_ENTIRE_BUFFER+1] = {\n+/*                      | MAP   | MAP   | MAP   |\n+                        | READ  | READ  | WRITE |\n+                        | WRITE | ONLY  | ENTIRE|\n+                        +-------+-------+-------+*/\n+MMM(INVALID             ,   F   ,   F   ,   F   ),\n+MMM(NORMAL              ,   T   ,   T   ,   T   ),\n+MMM(STREAMING_TO_SINK   ,   F   ,   F   ,   T   ),\n+MMM(STREAMING_TO_SOURCE ,   F   ,   T   ,   F   ),\n+MMM(PINNED              ,   T   ,   T   ,   T   ),\n+MMM(OPENCL              ,   T   ,   T   ,   T   ),\n+};\n+///\\endcode\n+#undef MMM\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+#undef F\n+#undef T\n+#endif\n+\n+//////////////////////////////////////////////////////////////////////////////\n+/// The valid copy operation types for the COIBufferWrite, COIBufferRead,\n+/// and COIBufferCopy APIs.\n+///\n+typedef enum COI_COPY_TYPE\n+{\n+    /// The runtime can pick the best suitable way to copy the data.\n+    COI_COPY_UNSPECIFIED = 0,\n+\n+    /// The runtime should use DMA to copy the data.\n+    COI_COPY_USE_DMA,\n+\n+    /// The runtime should use a CPU copy to copy the data.\n+    /// CPU copy is a synchronous copy. So the resulting operations are always\n+    /// blocking (even though a out_pCompletion event is specified).\n+    COI_COPY_USE_CPU\n+\n+} COI_COPY_TYPE;\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+/// The buffer states are used to indicate whether a buffer is available for\n+/// access in a COIPROCESS. This is used with COIBufferSetState.\n+///\n+/// Buffer state holds only for NORMAL Buffers and OPENCL buffers. Pinned\n+/// buffers are always valid everywhere they get created. Streaming buffers\n+/// do not follow the state transition rules, as a new version of the\n+/// buffer is created every time it is Mapped or you issue a RunFunction.\n+///\n+/// Rules on State Transition of the buffer:\n+/// -. When a Buffer is created by default it is valid only on the source,\n+///    except for buffers created with COI_SINK_MEMORY flag which are valid\n+///    only on the sink where the memory lies when created.\n+/// -. Apart from SetState following APIs also alters the state of the buffer\n+///    internally:\n+///\n+///    - COIBufferMap alters state of buffer depending on the COI_MAP_TYPE.\n+///      COI_MAP_READ_ONLY: Makes Valid on the Source. Doesn't affect the state\n+///                         of the buffer on the other devices.\n+///      COI_MAP_READ_WRITE: Makes it Valid only the Source and Invalid\n+///                         everywhere else. OPENCL buffers are invalidated\n+///                         only if it is not in use.\n+///      COI_MAP_WRITE_ENTIRE_BUFFER: Makes it valid only on the Source. OPENCL\n+///                         buffers are invalidated only if not in use.\n+///\n+///    - COIPipelineRunfunction alters the state of the buffer depending on the\n+///      COI_ACCESS_FLAGS\n+///      COI_SINK_READ: Makes it valid on the sink where RunFunction is being\n+///                     issued. Doesn't affect the state of the buffer on other\n+///                     devices.\n+///      COI_SINK_WRITE: Makes it valid only on the sink where Runfunction is\n+///                     being issued and invalid everywhere else. OPENCL\n+///                     buffers are invalidated only if the buffer is not in\n+///                     use.\n+///      COI_SINK_WRITE_ENTIRE: Makes it valid only on the sink where\n+///                     Runfunction is being issued and invalid everywhere else\n+///                     OPENCL buffers are invalidated only if the buffer is\n+///                     not in use.\n+///\n+///    - COIBufferWrite makes the buffer exclusively valid where the write\n+///      happens. Write gives preference to Source over Sink. In other words\n+///      if a buffer is valid on the Source and multiple Sinks, Write will \n+///      happen on the Source and will Invalidate all other Sinks. If the \n+///      buffer is valid on multiple Sinks ( and not on the Source) then \n+///      Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) \n+///      selects process handle with the lowest numerical value to do the \n+///      exclusive write Again, OPENCL buffers are invalidated only if the\n+///      buffer is not in use on that SINK/SOURCE.\n+///\n+///      The preference rule mentioned above holds true even for SetState API,\n+///      when data needs to be moved from a valid location. The selection of\n+///      valid location happens as stated above.\n+///\n+/// - It is possible to alter only parts of the buffer and change it state \n+///   In other words it is possible for different parts of the buffer to have \n+///   different states on different devices. A byte is the minimum size at \n+///   which state can be maintained internally. Granularity level is completely\n+///   determined by how the buffer gets fragmented.\n+///\n+/// Note: Buffer is considered 'in use' if is \n+///         - Being used in RunFunction : In use on a Sink\n+///         - Mapped: In use on a Source\n+///         - AddRef'd: In use on Sink\n+///\n+\n+//////////////////////////////////////////////////////////////////////////////\n+/// The buffer states used with COIBufferSetState call to indicate the new \n+/// state of the buffer on a given process\n+///\n+typedef enum {\n+    COI_BUFFER_VALID = 0,      // Buffer is valid and up-to-date on the process\n+    COI_BUFFER_INVALID ,       // Buffer is not valid, need valid data\n+    COI_BUFFER_VALID_MAY_DROP, // Same as valid but will drop the content when\n+                               // evicted to avoid overwriting the shadow \n+                               // memory\n+    COI_BUFFER_RESERVED        // Reserved for internal use\n+} COI_BUFFER_STATE;\n+///\n+/// Note: A VALID_MAY_DROP declares a buffer's copy as secondary on a given\n+/// process. This means that there needs to be at least one primary copy of the\n+/// the buffer somewhere in order to mark the buffer as VALID_MAY_DROP on a \n+/// process. In other words to make a buffer VALID_MAY_DROP on a given process\n+/// it needs to be in COI_BUFFER_VALID state somewhere else. The operation gets\n+/// ignored (or is a nop) if there is no primary copy of the buffer. The nature\n+/// of this state to \"drop the content\" when evicted is a side effect of \n+/// marking the buffer as secondary copy. So when a buffer marked \n+/// VALID_MAY_DROP is evicted Intel\u00ae Coprocessor Offload Infrastructure\n+/// (Intel\u00ae COI)  doesn't back it up as it is assumed that \n+/// there is a primary copy somewhere.\n+\n+//////////////////////////////////////////////////////////////////////////////\n+/// The buffer move flags are used to indicate when a buffer should be moved\n+/// when it's state is changed. This is used with COIBufferSetState.\n+typedef enum {\n+    COI_BUFFER_MOVE = 0,// Dirty data is moved if state change requires it\n+    COI_BUFFER_NO_MOVE  // Change state without moving data\n+} COI_BUFFER_MOVE_FLAG;\n+\n+// A process handle for COIBufferSetState call to indicate all the sink\n+// processes where the given buffer is valid\n+#define COI_SINK_OWNERS  ((COIPROCESS)-2)\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Creates a buffer that can be used in RunFunctions that are queued in\n+/// pipelines. The address space for the buffer is reserved when it is\n+/// created although the memory may not be committed until the buffer is\n+/// used for the first time. Please note that the Intel\u00ae Coprocessor Offload\n+/// Infrastructure (Intel\u00ae COI)  runtime may also\n+/// allocate space for the source process to use as shadow memory for\n+/// certain types of buffers. If Intel\u00ae Coprocessor Offload Infrastructure\n+/// (Intel\u00ae COI)  does allocate this memory it will not\n+/// be released or reallocated until the COIBuffer is destroyed.\n+///\n+/// @param  in_Size\n+///         [in] The number of bytes to allocate for the buffer. If in_Size\n+///         is not page aligned, it will be rounded up.\n+///\n+/// @param  in_Type\n+///         [in] The type of the buffer to create.\n+///\n+/// @param  in_Flags\n+///         [in] A bitmask of attributes for the newly created buffer.\n+///         Some of these flags are required for correctness while others\n+///         are provided as hints to the runtime system so it can make\n+///         certain performance optimizations.\n+///\n+/// @param  in_pInitData\n+///         [in] If non-NULL the buffer will be initialized with the data\n+///         pointed to by pInitData. The memory at in_pInitData must hold\n+///         at least in_Size bytes.\n+///\n+/// @param  in_NumProcesses\n+///         [in] The number of processes with which this buffer might be used.\n+///\n+/// @param  in_pProcesses\n+///         [in] An array of COIPROCESS handles identifying the processes with\n+///         which this buffer might be used.\n+///\n+/// @param  out_pBuffer\n+///         [out] Pointer to a buffer handle. The handle will be filled in\n+///         with a value that uniquely identifies the newly created buffer.\n+///         This handle should be disposed of via COIBufferDestroy()\n+///         once it is no longer needed.\n+///\n+/// @return COI_SUCCESS if the buffer was created\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_Type and in_Flags parameters\n+///         are not compatible with one another. Please see the\n+///         COI_VALID_BUFFER_TYPES_AND_FLAGS map above for information about\n+///         which flags and types are compatible.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Size is zero, if the bits set in\n+///         the in_Flags parameter are not recognized flags, or if\n+///         in_NumProcesses is zero.\n+///\n+/// @return COI_INVALID_POINTER if the in_pProcesses or out_pBuffer parameter\n+///         is NULL.\n+///\n+/// @return COI_NOT_SUPPORTED if one of the in_Flags is COI_SINK_MEMORY.\n+///\n+/// @return COI_NOT_SUPPORTED if the flags include either\n+///         COI_SAME_ADDRESS_SINKS or COI_SAME_ADDRESS_SINKS_AND_SOURCE and\n+///         COI_OPTIMIZE_HUGE_PAGE_SIZE.\n+///\n+/// @return COI_INVALID_HANDLE if one of the COIPROCESS handles in the\n+///         in_pProcesses array does not identify a valid process.\n+///\n+/// @return COI_OUT_OF_MEMORY if allocating the buffer fails.\n+///\n+/// @return COI_RESOURCE_EXHAUSTED if the sink is out of buffer memory.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferCreate(\n+            uint64_t            in_Size,\n+            COI_BUFFER_TYPE     in_Type,\n+            uint32_t            in_Flags,\n+    const   void*               in_pInitData,\n+            uint32_t            in_NumProcesses,\n+    const   COIPROCESS*         in_pProcesses,\n+            COIBUFFER*          out_pBuffer);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Creates a buffer from some existing memory that can be used in\n+/// RunFunctions that are queued in pipelines. If the flag COI_SINK_MEMORY\n+/// is specified then Intel\u00ae Coprocessor Offload I\n+/// nfrastructure (Intel\u00ae COI)  will use that memory for the buffer on the sink.\n+/// If that flag isn't set then the memory provided is used as backing store \n+/// for the buffer on the source. In either case the memory must not be freed\n+/// before the buffer is destroyed.\n+/// While the user still owns the memory passed in they must use the \n+/// appropriate access flags when accessing the buffer in COIPipelinRunFunction\n+/// or COIBufferMap calls so that the runtime knows when the\n+/// memory has been modified. If the user just writes directly to the memory\n+/// location then those changes may not be visible when the corresponding \n+/// buffer is accessed.\n+/// Whatever values are already present in the memory location when this call\n+/// is made are preserved. The memory values are also preserved when\n+/// COIBufferDestroy is called.\n+///\n+/// @warning: Use of this function is highly discouraged if the calling program\n+/// program forks at all (including calls to system(3), popen(3), or similar\n+/// functions) during the life of this buffer. See the discussion around the\n+/// in_Memory parameter below regarding this.\n+///\n+/// @param  in_Size\n+///         [in] The size of in_Memory in bytes. If in_Size\n+///         is not page aligned, it will be rounded up.\n+///\n+/// @param  in_Type\n+///         [in] The type of the buffer to create. Note that streaming buffers\n+///         can not be created from user memory. Only COI_BUFFER_NORMAL and\n+///         COI_BUFFER_PINNED buffer types are supported.\n+///\n+/// @param  in_Flags\n+///         [in] A bitmask of attributes for the newly created buffer.\n+///         Some of these flags are required for correctness while others\n+///         are provided as hints to the runtime system so it can make\n+///         certain performance optimizations. Note that the flag\n+///         COI_SAME_ADDRESS_SINKS_AND_SOURCE is still valid but may fail\n+///         if the same address as in_Memory can not be allocated on the sink.\n+///\n+/// @param  in_Memory\n+///         [in] A pointer to an already allocated memory region\n+///         that should be turned into a COIBUFFER. Although the user still\n+///         owns this memory they should not free it before calling\n+///         COIBufferDestroy. They must also only access the memory using\n+///         COIBUFFER semantics, for example using COIBufferMap/COIBufferUnmap\n+///         when they wish to read or write the data. There are no alignment\n+///         or size requirements for this memory region.\n+///\n+///         WARNING:\n+///         Since the backing memory passed in can be the target of a DMA\n+///         the caller must ensure that there is no call to clone(2) (without\n+///         the CLONE_VM argument) during the life of this buffer. This\n+///         includes higher level functions that call clone such as fork(2),\n+///         system(3), popen(3), among others).\n+///\n+///         For forked processes, Linux uses copy-on-write semantics for\n+///         performances reasons. Conseqeuently, if the parent forks and then\n+///         writes to this memory, the physical page mapping changes causing\n+///         the DMA to fail (and thus data corruption).\n+///\n+///         In Linux you can mark a set of pages to not be copied across\n+///         across the clone by calling madvise(2) with an argument of\n+///         MADV_DONTFORK and then safely use that memory in this scenario.\n+///         Alternately, if the memory is from a region marked MAP_SHARED,\n+///         this will work.\n+///\n+/// @param  in_NumProcesses\n+///         [in] The number of processes with which this buffer might be used.\n+///         If the flag COI_SINK_MEMORY is specified then this must be 1.\n+///\n+/// @param  in_pProcesses\n+///         [in] An array of COIPROCESS handles identifying the processes with\n+///         which this buffer might be used.\n+///\n+/// @param  out_pBuffer\n+///         [out] Pointer to a buffer handle. The handle will be filled in\n+///         with a value that uniquely identifies the newly created buffer.\n+///         This handle should be disposed of via COIBufferDestroy()\n+///         once it is no longer needed.\n+///\n+/// @return COI_SUCCESS if the buffer was created\n+///\n+/// @return COI_NOT_SUPPORTED if the in_Type value is not COI_BUFFER_NORMAL or\n+///         COI_BUFFER_PINNED.\n+///\n+/// @return COI_NOT_SUPPORTED if in_Memory is read-only memory\n+///\n+/// @return COI_NOT_SUPPORTED if one of the in_Flags is COI_SINK_MEMORY and\n+///         in_Type is not COI_BUFFER_NORMAL\n+///\n+/// @return COI_NOT_SUPPORTED if the flag COI_SAME_ADDRESS_SINKS is set\n+///\n+/// @return COI_NOT_SUPPORTED if the flag COI_SAME_ADDRESS_SINKS_AND_SOURCE is\n+///         set\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_Type and in_Flags parameters\n+///         are not compatible with one another. Please see the\n+///         COI_VALID_BUFFER_TYPES_AND_FLAGS map above for information about\n+///         which flags and types are compatible.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the flag COI_SINK_MEMORY is specified and\n+///         in_NumProcesses > 1.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the flags COI_SINK_MEMORY and\n+///         COI_OPTIMIZE_HUGE_PAGE_SIZE are both set.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Size is zero, if the bits set in\n+///         the in_Flags parameter are not recognized flags, or if\n+///         in_NumProcesses is zero.\n+///\n+/// @return COI_INVALID_POINTER if in_Memory, in_pProcesses or\n+///         out_pBuffer parameter is NULL.\n+///\n+/// @return COI_INVALID_HANDLE if one of the COIPROCESS handles in the\n+///         in_pProcesses array does not identify a valid process.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferCreateFromMemory(\n+            uint64_t            in_Size,\n+           COI_BUFFER_TYPE     in_Type,\n+            uint32_t            in_Flags,\n+            void*               in_Memory,\n+            uint32_t            in_NumProcesses,\n+    const   COIPROCESS*         in_pProcesses,\n+            COIBUFFER*          out_pBuffer);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Destroys a buffer.  Will block on completion of any operations on the\n+/// buffer, such as COIPipelineRunFunction or COIBufferCopy.  Will block until\n+/// all COIBufferAddRef calls have had a matching COIBufferReleaseRef call\n+/// made.  Will not block on an outstanding COIBufferUnmap but will instead\n+/// return COI_RETRY.\n+///\n+/// @param  in_Buffer\n+///         [in] Handle of the buffer to destroy.\n+///\n+/// @return COI_SUCCESS if the buffer was destroyed.\n+///\n+/// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n+///\n+/// @return COI_RETRY if the buffer is currently mapped. The buffer must\n+///         first be unmapped before it can be destroyed.\n+///\n+/// @return COI_RETRY if the sub-buffers created from this buffer are not yet\n+///         destroyed\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferDestroy(\n+            COIBUFFER           in_Buffer);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// This call initiates a request to access a region of a buffer. Multiple\n+/// overlapping (or non overlapping) regions can be mapped simultaneously for\n+/// any given buffer.  If a completion event is specified this call will\n+/// queue a request for the data which will be satisfied when the buffer is\n+/// available.  Once all conditions are met the completion event will be\n+/// signaled and the user can access the data at out_ppData.  The user can call\n+/// COIEventWait with out_pCompletion to find out when the map operation has\n+/// completed. If the user accesses the data before the map operation is\n+/// complete the results are undefined.  If out_pCompletion is NULL then this\n+/// call blocks until the map operation completes and when this call returns\n+/// out_ppData can be safely accessed.  This call returns a map instance handle\n+/// in an out parameter which must be passed into COIBufferUnmap when the user\n+/// no longer needs access to that region of the buffer.\n+///\n+/// The address returned from COIBufferMap may point to memory that\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// manages on behalf of the user. The user must not free or reallocate this\n+/// memory, Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// will perform any necessary cleanup when the buffer is\n+/// destroyed.\n+///\n+/// Note that different types of buffers behave differently when mapped.\n+/// For instance, mapping a COI_BUFFER_NORMAL for write must stall if the\n+/// buffer is currently being written to by a run function. Mapping a\n+/// COI_BUFFER_STREAMING_TO_SINK will create a new physical copy of the buffer\n+/// and make it available immediately.  Mapping a COI_BUFFER_PINNED buffer will\n+/// not affect other functions that use that buffer since a COI_BUFFER_PINNED\n+/// buffer can be mapped at any time.\n+/// The asynchronous operation of COIBufferMap will likely be most useful when\n+/// paired with a COI_BUFFER_NORMAL.\n+///\n+/// @param  in_Buffer\n+///         [in] Handle for the buffer to map.\n+///\n+/// @param  in_Offset\n+///         [in] Offset into the buffer that a pointer should be returned\n+///         for.  The value 0 can be passed in to signify that the mapped\n+///         region should start at the beginning of the buffer.\n+///\n+/// @param  in_Length\n+///         [in] Length of the buffer area to map. This parameter, in\n+///         combination with in_Offset, allows the caller to specify\n+///         that only a subset of an entire buffer need be mapped.  A\n+///         value of 0 can be passed in only if in_Offset is 0, to signify \n+///         that the mapped region is the entire buffer.  \n+///\n+/// @param  in_Type\n+///         [in] The access type that is needed by the application. This will\n+///         affect how the data can be accessed once the map operation\n+///         completes. See the COI_MAP_TYPE enum for more details.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the map\n+///         call initiation to wait for any events to be signaled before\n+///         starting the map operations.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this map operation will wait for before starting.\n+///         This allows the user to create dependencies between asynchronous\n+///         map calls and other operations such as run functions or other\n+///         asynchronous map calls. The user may pass in NULL if they do not\n+///         wish to wait for any dependencies to complete before initiating map\n+///         operations.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional pointer to a COIEVENT object\n+///         that will be signaled when a map call with the passed in buffer\n+///         would complete immediately, that is, the buffer memory has been\n+///         allocated on the source and its contents updated. The user may pass\n+///         in NULL if the user wants COIBufferMap to perform a blocking map\n+///         operation.\n+///\n+/// @param  out_pMapInstance\n+///         [out] A pointer to a COIMAPINSTANCE which represents this mapping\n+///         of the buffer and must be passed in to COIBufferUnmap when access\n+///         to this region of the buffer data is no longer needed.\n+///\n+/// @param  out_ppData\n+///         [out] Pointer to the buffer data. The data will only be valid\n+///         when the completion object is signaled, or for a synchronous\n+///         map operation with the call to map returns.\n+///\n+///\n+/// @return COI_SUCCESS if the map request succeeds.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset of (in_Offset + in_Length) exceeds\n+///         the size of the buffer.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Length is 0, but in_Offset is not 0.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Type is not a valid COI_MAP_TYPE.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_NumDependencies is non-zero while\n+///         in_pDependencies was passed in as NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is non-NULL but\n+///         in_NumDependencies is zero.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_Type of map is not a valid type\n+///         for in_Buffer's type of buffer.\n+///\n+/// @return COI_RESOURCE_EXHAUSTED if could not create a version for TO_SINK\n+///         streaming buffer. It can fail if enough memory is not available to\n+///         register. This call will succeed eventually when the registered\n+///         memory becomes available.\n+///\n+/// @return COI_INVALID_HANDLE if in_Buffer is not a valid buffer handle.\n+///\n+/// @return COI_INVALID_POINTER if out_pMapInstance or out_ppData is NULL.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferMap(\n+            COIBUFFER           in_Buffer,\n+            uint64_t            in_Offset,\n+            uint64_t            in_Length,\n+            COI_MAP_TYPE        in_Type,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+            COIEVENT*           out_pCompletion,\n+            COIMAPINSTANCE*     out_pMapInstance,\n+            void**              out_ppData);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Disables Source access to the region of the buffer that was provided\n+/// through the corresponding call to COIBufferMap.  The number of calls to\n+/// COIBufferUnmap() should always match the number of calls made to\n+/// COIBufferMap().  The data pointer returned from the COIBufferMap() call\n+/// will be invalid after this call.\n+///\n+/// @param  in_MapInstance\n+///         [in] buffer map instance handle to unmap.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the unmap call to\n+///         wait for any events to be signaled before performing the unmap\n+///         operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this unmap operation will wait for before starting.\n+///         This allows the user to create dependencies between asynchronous\n+///         unmap calls and other operations such as run functions or other\n+///         asynchronous unmap calls. The user may pass in NULL if they do not\n+///         wish to wait for any dependencies to complete before initiating\n+///         unmap operations.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional pointer to a COIEVENT object that will be\n+///         signaled when the unmap is complete.  The user may pass in NULL if\n+///         the user wants COIBufferUnmap to perform a blocking unmap\n+///         operation.\n+///\n+/// @return COI_SUCCESS upon successful unmapping of the buffer instance.\n+///\n+/// @return COI_INVALID_HANDLE if the passed in map instance handle was NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n+///         in_NumDependencies is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n+///         in_NumDependencies is not 0.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferUnmap(\n+            COIMAPINSTANCE      in_MapInstance,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+            COIEVENT*           out_pCompletion);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Gets the Sink's virtual address of the buffer.  This is the same\n+/// address that is passed to the run function on the Sink. The virtual\n+/// address assigned to the buffer for use on the sink is fixed;\n+/// the buffer will always be present at that virtual address on the sink\n+/// and will not get a different virtual address across different \n+/// RunFunctions.\n+/// This address is only valid on the Sink and should not be dereferenced on\n+/// the Source (except for the special case of buffers created with the\n+/// COI_SAME_ADDRESS flag).\n+///\n+/// @param  in_Buffer\n+///         [in] Buffer handle\n+///\n+/// @param  out_pAddress\n+///         [out] pointer to a uint64_t* that will be filled with the address.\n+///\n+/// @return COI_SUCCESS upon successful return of the buffer's address.\n+///\n+/// @return COI_INVALID_HANDLE if the passed in buffer handle was invalid.\n+///\n+/// @return COI_INVALID_POINTER if the out_pAddress parameter was invalid.\n+///\n+/// @return COI_NOT_SUPPORTED if the buffer passed in is of type\n+///         COI_BUFFER_STREAMING_TO_SOURCE or COI_BUFFER_STREAMING_TO_SINK.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferGetSinkAddress(\n+            COIBUFFER           in_Buffer,\n+            uint64_t*           out_pAddress);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Copy data from a normal virtual address into an existing COIBUFFER.\n+/// Note that it is not possible to use this API with any type of\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Streaming Buffers.\n+/// Please note that COIBufferWrite does not follow implicit buffer\n+/// dependencies. If a buffer is in use in a run function or has been added\n+/// to a process using COIBufferAddRef the call to COIBufferWrite will not\n+/// wait, it will still copy data immediately.\n+/// This is to facilitate a usage model where a buffer is being used outside\n+/// of a run function, for example in a spawned thread, but data still needs\n+/// to be transferred to or from the buffer.\n+///\n+/// @param  in_DestBuffer\n+///         [in] Buffer to write into.\n+///\n+#ifdef COI_PROTOTYPE_TARGET_PROCESS\n+/// @param  in_DestProcess\n+///         [in] A pointer to the processes which are used as hints\n+///         to to COI. Buffers are updated upon these processes first.\n+///         Can be left NULL and default behavior will be chosen, which\n+///         chooses the lowest SCIF node with an active regions first. Others\n+///         buffer regions are invalidated in both cases. Will only update a single\n+///         process at this time.\n+#endif\n+///\n+/// @param  in_Offset\n+///         [in] Location in the buffer to start writing to.\n+///\n+/// @param  in_pSourceData\n+///         [in] A pointer to local memory that should be copied into the\n+///         provided buffer.\n+///\n+/// @param  in_Length\n+///         [in] The number of bytes to write from in_pSourceData into\n+///         in_DestBuffer. Must not be larger than the size of in_DestBuffer\n+///         and must not over run in_DestBuffer if an in_Offset is provided.\n+///\n+/// @param  in_Type\n+///         [in] The type of copy operation to use, one of either\n+///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the write call to\n+///         wait for any additional events to be signaled before starting the\n+///         write operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this write operation will wait for before starting.\n+///         This allows the user to create dependencies between buffer write\n+///         calls and other operations such as run functions and map calls. The\n+///         user may pass in NULL if they do not wish to wait for any\n+///         additional dependencies to complete before doing the write.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional event to be signaled when the write has\n+///         completed. This event can be used as a dependency to order\n+///         the write with regard to future operations.\n+///         If no completion event is passed in then the write is\n+///         synchronous and will block until the transfer is complete.\n+///\n+///\n+/// @return COI_SUCCESS if the buffer was copied successfully.\n+///\n+/// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n+///         in_NumDependencies is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n+///         in_NumDependencies is not 0.\n+///\n+/// @return COI_NOT_SUPPORTED if the source buffer is of type\n+///         COI_BUFFER_STREAMING_TO_SINK or COI_BUFFER_STREAMING_TO_SOURCE.\n+///\n+/// @return COI_INVALID_POINTER if the in_pSourceData pointer is NULL.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset + in_Length exceeds the size of\n+///         the buffer.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Length is 0.\n+///\n+/// @return COI_RETRY if in_DestBuffer is mapped and is not a COI_BUFFER_PINNED\n+///         buffer or COI_BUFFER_OPENCL buffer.\n+///\n+#ifdef COI_PROTOTYPE_TARGET_PROCESS\n+COIACCESSAPI\n+COIRESULT\n+COIBufferWrite(\n+            COIBUFFER           in_DestBuffer,\n+    const   COIPROCESS          in_DestProcess,\n+            uint64_t            in_Offset,\n+    const   void*               in_pSourceData,\n+            uint64_t            in_Length,\n+            COI_COPY_TYPE       in_Type,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+            COIEVENT*           out_pCompletion);\n+__asm__(\".symver COIBufferWrite,COIBufferWrite@COI_2.0\");\n+#else\n+COIACCESSAPI\n+COIRESULT\n+COIBufferWrite(\n+            COIBUFFER           in_DestBuffer,\n+            uint64_t            in_Offset,\n+    const   void*               in_pSourceData,\n+            uint64_t            in_Length,\n+            COI_COPY_TYPE       in_Type,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+            COIEVENT*           out_pCompletion);\n+__asm__(\".symver COIBufferWrite,COIBufferWrite@COI_1.0\");\n+#endif\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Copy data from a buffer into local memory.\n+/// Note that it is not possible to use this API with any type of\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Streaming Buffers.\n+/// Please note that COIBufferRead does not follow implicit buffer\n+/// dependencies. If a buffer is in use in a run function or has been added\n+/// to a process using COIBufferAddRef the call to COIBufferRead will not\n+/// wait, it will still copy data immediately.\n+/// This is to facilitate a usage model where a buffer is being used outside\n+/// of a run function, for example in a spawned thread, but data still needs\n+/// to be transferred to or from the buffer.\n+///\n+///\n+/// @param  in_SourceBuffer\n+///         [in] Buffer to read from.\n+///\n+/// @param  in_Offset\n+///         [in] Location in the buffer to start reading from.\n+///\n+/// @param  in_pDestData\n+///         [in] A pointer to local memory that should be written into from\n+///         the provided buffer.\n+///\n+/// @param  in_Length\n+///         [in] The number of bytes to write from in_SourceBuffer into\n+///         in_pDestData. Must not be larger than the size of in_SourceBuffer\n+///         and must not over run in_SourceBuffer if an in_Offset is provided.\n+///\n+/// @param  in_Type\n+///         [in] The type of copy operation to use, one of either\n+///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the read call to\n+///         wait for any additional events to be signaled before starting the\n+///         read operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this read operation will wait for before starting.\n+///         This allows the user to create dependencies between buffer read\n+///         calls and other operations such as run functions and map calls. The\n+///         user may pass in NULL if they do not wish to wait for any\n+///         additional dependencies to complete before doing the read.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional event to be signaled when the read has\n+///         completed. This event can be used as a dependency to order\n+///         the read with regard to future operations.\n+///         If no completion event is passed in then the read is\n+///         synchronous and will block until the transfer is complete.\n+///\n+/// @return COI_SUCCESS if the buffer was copied successfully.\n+///\n+/// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n+///         in_NumDependencies is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n+///         in_NumDependencies is not 0.\n+///\n+/// @return COI_NOT_SUPPORTED if the source buffer is of type\n+///         COI_BUFFER_STREAMING_TO_SINK or COI_BUFFER_STREAMING_TO_SOURCE.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset + in_Length exceeds the size of\n+///         the buffer.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Length is 0.\n+///\n+/// @return COI_INVALID_POINTER if the in_pDestData pointer is NULL.\n+///\n+/// @return COI_RETRY if in_SourceBuffer is mapped and is not a\n+///         COI_BUFFER_PINNED buffer or COI_BUFFER_OPENCL buffer.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferRead(\n+            COIBUFFER           in_SourceBuffer,\n+            uint64_t            in_Offset,\n+            void*               in_pDestData,\n+            uint64_t            in_Length,\n+            COI_COPY_TYPE       in_Type,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+            COIEVENT*           out_pCompletion);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Copy data between two buffers. It also allows copying within the same\n+/// buffer. For copy within the same buffer, if source and destination regions\n+/// overlap then this API returns error.\n+/// Note that it is not possible to use this API with any type of\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Streaming Buffers.\n+/// Please note that COIBufferCopy does not follow implicit buffer\n+/// dependencies. If a buffer is in use in a run function or has been added\n+/// to a process using COIBufferAddRef the call to COIBufferCopy will not\n+/// wait, it will still copy data immediately.\n+/// This is to facilitate a usage model where a buffer is being used outside\n+/// of a run function, for example in a spawned thread, but data still needs\n+/// to be transferred to or from the buffer.\n+///\n+/// @param  in_DestBuffer\n+///         [in] Buffer to copy into.\n+#ifdef COI_PROTOTYPE_TARGET_PROCESS\n+/// @param  in_DestProcess\n+///         [in] A pointer to the processes which are used as hints\n+///         to to COI. Buffers are updated upon these processes first.\n+///         Can be left NULL and default behavior will be chosen, which\n+///         chooses the lowest SCIF node with an active regions first. Others\n+///         buffer regions are invalidated in both cases. Will only update a single\n+///         process at this time.\n+#endif\n+///\n+/// @param  in_SourceBuffer\n+///         [in] Buffer to copy from.\n+///\n+/// @param  in_DestOffset\n+///         [in] Location in the destination buffer to start writing to.\n+///\n+/// @param  in_SourceOffset\n+///         [in] Location in the source buffer to start reading from.\n+///\n+/// @param  in_Length\n+///         [in] The number of bytes to copy from in_SourceBuffer into\n+///         in_DestinationBuffer.\n+///         If the length is specified as zero then length to be copied\n+//          is entire destination buffer's length.\n+///         Must not be larger than the size of in_SourceBuffer or\n+///         in_DestBuffer and must not over run in_SourceBuffer or\n+///         in_DestBuffer if offsets are specified.\n+///\n+/// @param  in_Type\n+///         [in] The type of copy operation to use, one of either\n+///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the copy call to\n+///         wait for any additional events to be signaled before starting the\n+///         copy operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this copy operation will wait for before starting.\n+///         This allows the user to create dependencies between buffer copy\n+///         calls and other operations such as run functions and map calls. The\n+///         user may pass in NULL if they do not wish to wait for any\n+///         additional dependencies to complete before doing the copy.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional event to be signaled when the copy has\n+///         completed. This event can be used as a dependency to order\n+///         the copy with regard to future operations.\n+///         If no completion event is passed in then the copy is\n+///         synchronous and will block until the transfer is complete.\n+///\n+/// @return COI_SUCCESS if the buffer was copied successfully.\n+///\n+/// @return COI_INVALID_HANDLE if either buffer handle was invalid.\n+///\n+/// @return COI_MEMORY_OVERLAP if in_SourceBuffer and in_DestBuffer are the\n+///         same buffer(or have the same parent buffer) and the source and \n+///         destination regions overlap\n+///\n+/// @return COI_OUT_OF_RANGE if in_DestOffset is is beyond the end of\n+///         in_DestBuffer\n+///\n+/// @return COI_OUT_OF_RANGE if in_SourceOffset is beyond the end of\n+///         in_SourceBuffer.\n+///\n+/// @return COI_OUT_OF_RANGE if in_DestOffset + in_Length exceeds the size of\n+///         the in_DestBuffer\n+///\n+/// @return COI_OUT_OF_RANGE if in_SourceOffset + in_Length exceeds\n+///         the size of in_SourceBuffer.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n+///         in_NumDependencies is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n+///         in_NumDependencies is not 0.\n+///\n+/// @return COI_NOT_SUPPORTED if the source or destination buffers are of type\n+///         COI_BUFFER_STREAMING_TO_SINK or COI_BUFFER_STREAMING_TO_SOURCE.\n+///\n+/// @return COI_NOT_SUPPORTED if either buffer is of type\n+///         COI_BUFFER_STREAMING_TO_SINK or COI_BUFFER_STREAMING_TO_SOURCE.\n+///\n+/// @return COI_RETRY if in_DestBuffer or in_SourceBuffer are mapped and not\n+///         COI_BUFFER_PINNED buffers or COI_BUFFER_OPENCL buffers.\n+///\n+#ifdef COI_PROTOTYPE_TARGET_PROCESS\n+COIACCESSAPI\n+COIRESULT\n+COIBufferCopy(\n+            COIBUFFER           in_DestBuffer,\n+    const   COIPROCESS          in_DestProcess,\n+            COIBUFFER           in_SourceBuffer,\n+            uint64_t            in_DestOffset,\n+            uint64_t            in_SourceOffset,\n+            uint64_t            in_Length,\n+            COI_COPY_TYPE       in_Type,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+            COIEVENT*           out_pCompletion);\n+__asm__(\".symver COIBufferCopy,COIBufferCopy@COI_2.0\");\n+#else\n+COIACCESSAPI\n+COIRESULT\n+COIBufferCopy(\n+            COIBUFFER           in_DestBuffer,\n+            COIBUFFER           in_SourceBuffer,\n+            uint64_t            in_DestOffset,\n+            uint64_t            in_SourceOffset,\n+            uint64_t            in_Length,\n+            COI_COPY_TYPE       in_Type,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+            COIEVENT*           out_pCompletion);\n+__asm__(\".symver COIBufferCopy,COIBufferCopy@COI_1.0\");\n+#endif\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// This API allows an experienced Intel\u00ae Coprocessor Offload Infrastructure\n+/// (Intel\u00ae COI)  developer to set where a COIBUFFER is\n+/// located and when the COIBUFFER's data is moved. This functionality is\n+/// useful when the developer knows when and where a buffer is going to be\n+/// accessed. It allows the data movement to happen sooner than if the\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// runtime tried to manage the buffer placement itself. The advantage of\n+/// this API is that the developer knows much more about their own\n+/// application's data access patterns and can therefore optimize the data\n+/// access to be much more efficient than the Intel\u00ae Coprocessor Offload\n+/// Infrastructure (Intel\u00ae COI) runtime. Using this API may yield better \n+/// memory utilization, lower latency and overall improved workload\n+/// throughput.\n+/// This API does respect implicit dependencies for buffer read/write hazards.\n+/// For example, if the buffer is being written in one COIPROCESS and the user\n+/// requests the buffer be placed in another COIPROCESS then this API will wait\n+/// for the first access to complete before moving the buffer.\n+/// This API is not required for program correctness. It is intended solely\n+/// for advanced Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// developers who wish to fine tune their application performance\n+/// Cases where \"a change in state\" is an error condition the change just gets\n+/// ignored without any error. This is because the SetState can be a \n+/// nonblocking call and in such cases we can't rely on the state of the buffer\n+/// at the time of the call. We can do the transition checks only at the time\n+/// when the actual state change happens (which is something in future).\n+/// Currently there is no way to report an error from something that happens in\n+/// future and that is why such state transitions are nop. One example is using\n+/// VALID_MAY_DROP with COI_SINK_OWNERS when buffer is not valid at source. \n+/// This operation will be a nop if at the time of actual state change the \n+/// buffer is not valid at source.\n+///\n+/// @param  in_Buffer\n+///         [in] The buffer to modify.\n+///\n+/// @param  in_Process\n+///         [in] The process where the state is being modified for this\n+///         buffer. To modify buffer's state on source process use\n+///         COI_PROCESS_SOURCE as process handle. To modify buffer's \n+///         state on all processes where buffer is valid use COI_SINK_OWNERS\n+///         as the process handle.\n+///\n+/// @param  in_State\n+///         [in] The new state for the buffer. The buffer's state could be\n+///         set to invalid on one of the sink processes where it is being\n+///         used.\n+///\n+/// @param  in_DataMove\n+///         [in] A flag to indicate if the buffer's data should be moved\n+///         when the state is changed. For instance, a buffer's state may\n+///         be set to valid on a process and the data move flag may be set to\n+///         COI_BUFFER_MOVE which would cause the buffer contents to be\n+///         copied to the process where it is now valid.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the SetState call\n+///         to wait for any additional events to be signaled before starting\n+///         this operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this SetState operation will wait for before starting\n+///         This allows the user to create dependencies between buffer\n+///         SetState calls and other operations such as run functions and map\n+///         calls. The user may pass in NULL if they do not wish to wait for\n+///         any additional dependencies to complete before doing the SetState\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional event to be signaled when the SetState has\n+///         completed. This event can be used as a dependency to order\n+///         the SetState with regard to future operations.\n+///         If no completion event is passed in then the  is\n+///         synchronous and will block until the SetState and dma transfers\n+///         related to this operation are complete.\n+///\n+/// @return COI_SUCCESS if the buffer's state was changed successfully.\n+///\n+/// @return COI_INVALID_HANDLE if in_Buffer or in_Process is invalid.\n+///\n+/// @return COI_NOT_SUPPORTED if the in_Buffer is of any type other than\n+///         COI_BUFFER_NORMAL or COI_BUFFER_OPENCL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_State is COI_BUFFER_VALID_MAY_DROP\n+///         and the in_Process is COI_PROCESS_SOURCE.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_Process is COI_SINK_OWNERS and the\n+///         COI_BUFFER_MOVE is passed as move flag.\n+///\n+/// @return COI_MISSING_DEPENDENCY if buffer was not created on the process \n+///         handle that was passed in.\n+///\n+\n+COIACCESSAPI\n+COIRESULT\n+COIBufferSetState(\n+            COIBUFFER               in_Buffer,\n+            COIPROCESS              in_Process,\n+            COI_BUFFER_STATE        in_State,\n+            COI_BUFFER_MOVE_FLAG    in_DataMove,\n+            uint32_t                in_NumDependencies,\n+    const   COIEVENT*               in_pDependencies,\n+            COIEVENT*               out_pCompletion);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Creates a sub-buffer that is a reference to a portion of an existing\n+/// buffer.  The returned buffer handle can be used in all API calls that the\n+/// original buffer handle could be used in except COIBufferCreateSubBuffer.\n+/// Sub buffers out of Huge Page Buffer are also supported but the original \n+/// buffer needs to be a OPENCL buffer created with COI_OPTIMIZE_HUGE_PAGE_SIZE\n+/// flag.\n+///\n+/// When the sub-buffer is used only the corresponding sub-section of the\n+/// original buffer is used or affected.\n+///\n+/// @param  in_Buffer\n+///         [in] The original buffer that this new sub-buffer is a reference\n+///         to.\n+///\n+/// @param  in_Length\n+///         [in] The length of the sub-buffer in number of bytes.\n+///\n+/// @param  in_Offset\n+///         [in] Where in the original buffer to start this sub-buffer.\n+///\n+/// @param  out_pSubBuffer\n+///         [out] Pointer to a buffer handle that is filled in with the newly\n+///         created sub-buffer.\n+/// \n+/// @return COI_SUCCESS if the sub-buffer was created\n+///\n+/// @return COI_INVALID_HANDLE if in_Buffer is not a valid buffer handle.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Length is zero, or if in_Offset + in_Length\n+///         is greater than the size of the original buffer.\n+///\n+/// @return COI_OUT_OF_MEMORY if allocating the buffer fails.\n+///\n+/// @return COI_INVALID_POINTER if the out_pSubBuffer pointer is NULL.\n+///\n+/// @return COI_NOT_SUPPORTED if the in_Buffer is of any type other than\n+///         COI_BUFFER_OPENCL\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferCreateSubBuffer(\n+            COIBUFFER   in_Buffer,\n+            uint64_t    in_Length,\n+            uint64_t    in_Offset,\n+            COIBUFFER*  out_pSubBuffer);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIBUFFER_SOURCE_H */\n+\n+/*! @} */"}, {"sha": "19a63e4340947ccfc7c3d16929b1bcf5878e7c8c", "filename": "liboffloadmic/include/coi/source/COIEngine_source.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIENGINE_SOURCE_H\n+#define _COIENGINE_SOURCE_H\n+\n+/** @ingroup COIEngine\n+ *  @addtogroup COIEngineSource\n+@{\n+\n+* @file source\\COIEngine_source.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+#include <wchar.h>\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+#include \"../common/COIEngine_common.h\"\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define COI_MAX_DRIVER_VERSION_STR_LEN 255\n+\n+#define COI_MAX_HW_THREADS 1024\n+\n+///////////////////////////////////////////////////////////////////////////////\n+/// This enum defines miscellaneous information returned from the\n+/// COIGetEngineInfo() function.\n+///\n+typedef enum\n+{\n+    COI_ENG_ECC_DISABLED = 0,            //ECC is not enabled on this engine\n+    COI_ENG_ECC_ENABLED = 0x00000001,    //ECC is enabled on this engine\n+    COI_ENG_ECC_UNKNOWN = 0x00000002     //ECC is mode is unknown\n+} coi_eng_misc;\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+/// This structure returns information about an Intel(r) Xeon Phi(tm)\n+/// coprocessor.\n+/// A pointer to this structure is passed into the COIGetEngineInfo() function,\n+/// which fills in the data before returning to the caller.\n+///\n+typedef struct COI_ENGINE_INFO\n+{\n+    /// The version string identifying the driver.\n+    coi_wchar_t  DriverVersion[COI_MAX_DRIVER_VERSION_STR_LEN];\n+\n+    /// The ISA supported by the engine.\n+    COI_ISA_TYPE ISA;\n+\n+    /// The number of cores on the engine.\n+    uint32_t     NumCores;\n+\n+    /// Miscellaneous fields\n+    coi_eng_misc MiscFlags;\n+\n+    /// The number of hardware threads on the engine.\n+    uint32_t     NumThreads;\n+\n+    /// The maximum frequency (in MHz) of the cores on the engine.\n+    uint32_t     CoreMaxFrequency;\n+\n+    /// The load percentage for each of the hardware threads on the engine.\n+    uint32_t     Load[COI_MAX_HW_THREADS];\n+\n+    /// The amount of physical memory managed by the OS.\n+    uint64_t     PhysicalMemory;\n+\n+    /// The amount of free physical memory in the OS.\n+    uint64_t     PhysicalMemoryFree;\n+\n+    /// The amount of swap memory managed by the OS.\n+    uint64_t     SwapMemory;\n+\n+    /// The amount of free swap memory in the OS.\n+    uint64_t     SwapMemoryFree;\n+\n+    /// The pci config vendor id\n+    uint16_t     VendorId;\n+\n+    /// The pci config device id\n+    uint16_t     DeviceId;\n+\n+    /// The pci config subsystem id\n+    uint16_t     SubSystemId;\n+\n+    /// The stepping of the board, A0, A1, C0, D0 etc.\n+    uint16_t     BoardStepping;\n+\n+    /// The SKU of the stepping, EB, ED, etc.\n+    uint16_t     BoardSKU;\n+} COI_ENGINE_INFO;\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Returns information related to a specified engine. Note that if Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  is\n+/// unable to query a value it will be returned as zero but the call will\n+/// still succeed.\n+///\n+///\n+/// @param  in_EngineHandle\n+///         [in] The COIENGINE structure as provided from COIEngineGetHandle()\n+///         which to query for device level information.\n+///\n+/// @param  in_EngineInfoSize\n+///         [in] The size of the structure that out_pEngineInfo points to.\n+///         Used for version safety of the function call.\n+///\n+/// @param  out_pEngineInfo\n+///         [out] The address of a user allocated COI_ENGINE_INFO structure.\n+///         Upon success, the contents of the structure will be updated\n+///         to contain information related to the specified engine.\n+///\n+///\n+/// @return  COI_SUCCESS if the function completed without error.\n+///\n+/// @return  COI_INVALID_HANDLE if the in_EngineHandle handle is not valid.\n+///\n+/// @return  COI_SIZE_MISMATCH if in_EngineInfoSize does not match any current\n+///          or previous COI_ENGINE_INFO structure sizes.\n+///\n+/// @return  COI_INVALID_POINTER if the out_pEngineInfo pointer is NULL.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEngineGetInfo(\n+            COIENGINE           in_EngineHandle,\n+            uint32_t            in_EngineInfoSize,\n+            COI_ENGINE_INFO*    out_pEngineInfo);\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Returns the number of engines in the system that match the provided ISA.\n+///\n+/// Note that while it is possible to enumerate different types of Intel(r)\n+/// Xeon Phi(tm) coprocessors on a single host this is not currently \n+/// supported. Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  makes an assumption that all Intel(r) Xeon Phi(tm) \n+/// coprocessors found in the system are the same architecture as the first \n+/// coprocessor device.\n+///\n+/// Also, note that this function returns the number of engines that Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) \n+/// is able to detect. Not all of them may be online.\n+///\n+/// @param  in_ISA\n+///         [in] Specifies the ISA type of the engine requested.\n+///\n+/// @param  out_pNumEngines\n+///         [out] The number of engines available. This can be used to index\n+///         into the engines using COIEngineGetHandle().\n+///\n+/// @return COI_SUCCESS if the function completed without error.\n+///\n+/// @return COI_DOES_NOT_EXIST if the in_ISA parameter is not valid.\n+///\n+/// @return COI_INVALID_POINTER if the out_pNumEngines parameter is NULL.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEngineGetCount(\n+            COI_ISA_TYPE    in_ISA,\n+            uint32_t*       out_pNumEngines);\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Returns the handle of a user specified engine.\n+///\n+/// @param  in_ISA\n+///         [in] Specifies the ISA type of the engine requested.\n+///\n+/// @param  in_EngineIndex\n+///         [in] A unsigned integer which specifies the zero-based position of\n+///         the engine in a collection of engines.  The makeup of this\n+///         collection is defined by the in_ISA parameter.\n+///\n+/// @param  out_pEngineHandle\n+///         [out] The address of an COIENGINE handle.\n+///\n+/// @return COI_SUCCESS if the function completed without error.\n+///\n+/// @return COI_DOES_NOT_EXIST if the in_ISA parameter is not valid.\n+///\n+/// @return COI_OUT_OF_RANGE if in_EngineIndex is greater than or equal to\n+///         the number of engines that match the in_ISA parameter.\n+///\n+/// @return COI_INVALID_POINTER if the out_pEngineHandle parameter is NULL.\n+///\n+/// @return COI_VERSION_MISMATCH if the version of Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  on the host is not\n+///         compatible with the version on the device.\n+///\n+/// @return COI_NOT_INITIALIZED if the engine requested exists but is offline.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEngineGetHandle(\n+            COI_ISA_TYPE    in_ISA,\n+            uint32_t        in_EngineIndex,\n+            COIENGINE*      out_pEngineHandle);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIENGINE_SOURCE_H */\n+\n+/*! @} */"}, {"sha": "99fa00d6a27d5389a58ed64af7a8cf23236790b9", "filename": "liboffloadmic/include/coi/source/COIEvent_source.h", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIEVENT_SOURCE_H\n+#define _COIEVENT_SOURCE_H\n+\n+/** @ingroup COIEvent\n+ *  @addtogroup COIEventSource\n+@{\n+* @file source/COIEvent_source.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Special case event values which can be passed in to APIs to specify\n+/// how the API should behave. In COIBuffer APIs passing in NULL for the\n+/// completion event is the equivalent of passing COI_EVENT_SYNC. For\n+/// COIPipelineRunFunction passing in NULL is the equivalent of\n+/// COI_EVENT_ASYNC.\n+/// Note that passing COI_EVENT_ASYNC can be used when the caller wishes the\n+/// operation to be performed asynchronously but does not care when the\n+/// operation completes. This can be useful for opertions that by definition\n+/// must complete in order (DMAs, run functions on a single pipeline). If\n+/// the caller does care when the operation completes then they should pass\n+/// in a valid completion event which they can later wait on.\n+///\n+#define COI_EVENT_ASYNC ((COIEVENT*)1)\n+#define COI_EVENT_SYNC  ((COIEVENT*)2)\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Wait for an arbitrary number of COIEVENTs to be signaled as completed,\n+/// eg when the run function or asynchronous map call associated with an event\n+/// has finished execution.\n+/// If the user sets in_WaitForAll = True and not all of the events are\n+/// signaled when the timeout period is reached then COI_TIME_OUT_REACHED will\n+/// be returned.\n+/// If the user sets in_WaitForAll = False then if at least one event is\n+/// signaled when the timeout is reached then COI_SUCCESS is returned.\n+///\n+/// @param  in_NumEvents\n+///         [in] The number of events to wait for.\n+///\n+/// @param  in_pEvents\n+///         [in] The array of COIEVENT handles to wait for.\n+///\n+/// @param  in_Timeout\n+///         [in] The time in milliseconds to wait for the event. 0 polls\n+///         and returns immediately, -1 blocks indefinitely.\n+///\n+/// @param  in_WaitForAll\n+///         [in] Boolean value specifying behavior.  If true, wait for all\n+///         events to be signaled, or for timeout, whichever happens first.\n+///         If false, return when any event is signaled, or at timeout.\n+///\n+/// @param  out_pNumSignaled\n+///         [out] The number of events that were signaled.  If in_NumEvents\n+///         is 1 or in_WaitForAll = True, this parameter is optional.\n+///\n+/// @param  out_pSignaledIndices\n+///         [out] Pointer to an array of indicies into the original event\n+///         array.  Those denoted have been signaled.  The user must provide an\n+///         array that is no smaller than the in_Events array. If in_NumEvents\n+///         is 1 or in_WaitForAll = True, this parameter is optional.\n+///\n+/// @return COI_SUCCESS once an event has been signaled completed.\n+///\n+/// @return COI_TIME_OUT_REACHED if the events are still in use when the\n+///         timeout is reached or timeout is zero (a poll).\n+///\n+/// @return COI_OUT_OF_RANGE if a negative value other than -1 is passed in to\n+///         the in_Timeout parameter.\n+///\n+/// @return COI_OUT_OF_RANGE if in_NumEvents is 0.\n+///\n+/// @return COI_INVALID_POINTER if in_pEvents is NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_NumEvents > 1 and if in_WaitForAll\n+///         is not true and out_pSignaled or out_pSignaledIndicies are NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if out_pNumSignaled is not NULL\n+///         and out_pSignaledIndices is NULL (or vice versa).\n+///\n+/// @return COI_EVENT_CANCELED if while waiting on a user event, it gets\n+///         unregistered this returns COI_EVENT_CANCELED\n+///\n+/// @return COI_PROCESS_DIED if the remote process died. See COIProcessDestroy\n+///         for more details.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEventWait(\n+            uint16_t        in_NumEvents,\n+    const   COIEVENT*       in_pEvents,\n+            int32_t         in_TimeoutMilliseconds,\n+            uint8_t         in_WaitForAll,\n+            uint32_t*       out_pNumSignaled,\n+            uint32_t*       out_pSignaledIndices);\n+\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Register a User COIEVENT so that it can be fired. Registered event is\n+/// a one shot User event; in other words once signaled it cannot be used\n+/// again for signaling. You have to unregister and register again to enable\n+/// signaling. An event will be reset if it is re-registered without\n+/// unregistering, resulting in loss of all outstanding signals.\n+///\n+/// @param  out_pEvent\n+///         [out] Pointer to COIEVENT handle being Registered\n+///\n+/// @return COI_SUCCESS an event is successfully registered\n+///\n+/// @return COI_INVALID_POINTER if out_pEvent is NULL\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEventRegisterUserEvent(\n+            COIEVENT* out_pEvent);\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Unregister a User COIEVENT. Unregistering a unsignaled event is similar\n+/// to firing an event. Except Calling COIEventWait on an event that is\n+/// being unregistered returns COI_EVENT_CANCELED\n+///\n+/// @param  in_Event\n+///         [in] Event Handle to be unregistered.\n+///\n+/// @return COI_INVALID_HANDLE if in_Event is not a UserEvent\n+///\n+/// @return COI_SUCCESS an event is successfully registered\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEventUnregisterUserEvent(\n+            COIEVENT in_Event);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIEVENT_SOURCE_H */\n+\n+/*! @} */"}, {"sha": "d210a1f5025f776a80b1ac329227d648b40e752b", "filename": "liboffloadmic/include/coi/source/COIPipeline_source.h", "status": "added", "additions": 426, "deletions": 0, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIPIPELINE_SOURCE_H\n+#define _COIPIPELINE_SOURCE_H\n+\n+/** @ingroup COIPipeline\n+ *  @addtogroup COIPipelineSource\n+@{\n+* @file source/COIPipeline_source.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+/// These flags specify how a buffer will be used within a run function.  They\n+/// allow Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  to make optimizations in how it moves data around the system.\n+/// These flags can affect the correctness of an application, so they must be\n+/// set properly.  For example, if a buffer is used in a run function with the\n+/// COI_SINK_READ flag and then mapped on the source, Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  may use a previously\n+/// cached version of the buffer instead of retrieving data from the sink.\n+typedef enum COI_ACCESS_FLAGS\n+{\n+    /// Specifies that the run function will only read the associated buffer.\n+    COI_SINK_READ = 1,\n+\n+    /// Specifies that the run function will write to the associated buffer.\n+    COI_SINK_WRITE,\n+\n+    /// Specifies that the run function will overwrite the entire associated\n+    /// buffer and therefore the buffer will not be synchronized with the\n+    /// source before execution.\n+    COI_SINK_WRITE_ENTIRE\n+} COI_ACCESS_FLAGS;\n+\n+#define COI_PIPELINE_MAX_PIPELINES 512\n+#define COI_PIPELINE_MAX_IN_BUFFERS 16384\n+#define COI_PIPELINE_MAX_IN_MISC_DATA_LEN 32768\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Create a pipeline assoiated with a remote process. This pipeline can\n+/// then be used to execute remote functions and to share data using\n+/// COIBuffers.\n+///\n+/// @param  in_Process\n+///         [in] A handle to an already existing process that the pipeline\n+///         will be associated with.\n+///\n+/// @param  in_Mask\n+///         [in] An optional mask of the set of hardware threads on which the\n+///         sink pipeline command processing thread could run.\n+///\n+/// @param  in_StackSize\n+///         [in] An optional value that will be used when the pipeline\n+///         processing thread is created on the sink. If the user passes in\n+///         0 the OS default stack size will be used. Otherwise the value\n+///         must be PTHREAD_STACK_MIN (16384) bytes or larger and must be\n+///         a multiple of a page (4096 bytes).\n+///\n+/// @param  out_pPipeline\n+///         [out] Handle returned to uniquely identify the pipeline that was\n+///         created for use in later API calls.\n+///\n+///\n+/// @return COI_SUCCESS if the pipeline was successfully created.\n+///\n+/// @return COI_INVALID_HANDLE if the in_Process handle passed in was invalid.\n+///\n+/// @return COI_INVALID_POINTER if the out_pPipeline pointer was NULL.\n+///\n+/// @return COI_RESOURCE_EXHAUSTED if no more COIPipelines can be created. The\n+///         maximum number of pipelines allowed is COI_PIPELINE_MAX_PIPELINES.\n+///         It is recommended in most cases to not exceed the number of CPU's\n+///         that are reported on the offload device, performance will suffer.\n+///\n+///\n+/// @return COI_OUT_OF_RANGE if the in_StackSize > 0 &&\n+///         in_StackSize < PTHREAD_STACK_MIN or if in_StackSize is not a\n+///         multiple of a page (4096 bytes).\n+///\n+/// @return COI_OUT_OF_RANGE if the in_Mask is set to all zeroes. If no mask\n+///         is desired then the in_Mask should be passed as NULL, otherwise\n+///         at least one thread must be set.\n+///\n+/// @return COI_TIME_OUT_REACHED if establishing the communication channel with\n+///         the remote pipeline timed out.\n+///\n+/// @return COI_RETRY  if the pipeline cannot be created due to the number of\n+///         source-to-sink connections in use. A subsequent call to \n+///         COIPipelineCreate may succeed if resources are freed up.\n+///\n+/// @return COI_PROCESS_DIED if in_Process died.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIPipelineCreate(\n+            COIPROCESS          in_Process,\n+            COI_CPU_MASK        in_Mask,\n+            uint32_t            in_StackSize,\n+            COIPIPELINE*        out_pPipeline);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Destroys the inidicated pipeline, releasing its resources.\n+///\n+/// @param  in_Pipeline\n+///         [in] Pipeline to destroy.\n+///\n+///\n+/// @return COI_SUCCESS if the pipeline was destroyed\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIPipelineDestroy(\n+            COIPIPELINE         in_Pipeline);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Enqueues a function in the remote process binary to be executed. The\n+/// function execution is asynchronous in regards to the Source and all\n+/// run functions enqueued on a pipeline are executed in-order. The run\n+/// function will only execute when all of the required buffers are present\n+/// in the Sink's memory.\n+///\n+/// Potential Hazards while using Runfunctions:\n+///\n+/// 1. Proper care has to be taken while setting the input dependencies for\n+///    RunFunctions. Setting it incorrectly can lead to cyclic dependencies\n+///    and can cause the respective pipeline (as a result Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Runtime) to\n+///    stall.\n+/// 2. RunFunctions can also segfault if enough memory space is not available\n+///    on the sink for the buffers passed in. Pinned buffers and buffers that\n+///    are AddRef'd need to be accounted for available memory space. In other\n+///    words, this memory is not available for use until it is freed up.\n+/// 3. Unexpected segmentation faults or erroneous behaviour can occur if \n+///    handles or data passed in to Runfunction gets destroyed before the \n+///    RunFunction finishes.\n+///    For example, if a variable passed in as Misc data or the buffer gets\n+///    destroyed before the Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  runtime receives the completion notification \n+///    of the Runfunction, it can cause unexpected behaviour. So it is always\n+///    recommended to wait for RunFunction completion event before any related\n+///    destroy event occurs.\n+///\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Runtime expects users to handle such scenarios. COIPipelineRunFunction\n+/// returns COI_SUCCESS for above cases because it was queued up successfully.\n+/// Also if you try to destroy a pipeline with a stalled function then the\n+/// destroy call will hang. COIPipelineDestroy waits until all the functions\n+/// enqueued are finished executing.\n+///\n+/// @param  in_Pipeline\n+///         [in] Handle to a previously created pipeline that this run\n+///         function should be enqueued to.\n+///\n+/// @param  in_Function\n+///         [in] Previously returned handle from a call to\n+///         COIPipelineGetFunctionHandle() that represents a function in the\n+///         application running on the Sink process.\n+///\n+/// @param  in_NumBuffers\n+///         [in] The number of buffers that are being passed to the run\n+///         function. This number must match the number of buffers in the\n+///         in_pBuffers and in_pBufferAccessFlags arrays. Must be less than\n+///         COI_PIPELINE_MAX_IN_BUFFERS.\n+///\n+/// @param  in_pBuffers\n+///         [in] An array of COIBUFFER handles that the function is expected\n+///         to use during its execution. Each buffer when it arrives at the\n+///         Sink process will be at least 4k page aligned, thus, using a very\n+///         large number of small buffers is memory inefficient and should be\n+///         avoided.\n+///\n+/// @param  in_pBufferAccessFlags\n+///         [in] An array of flag values which correspond to the buffers\n+///         passed in the in_pBuffers parameter. These flags are used to\n+///         track dependencies between different run functions being\n+///         executed from different pipelines.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the run function\n+///         to wait for any dependencies.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of COIEVENT objects that this run\n+///         function will wait for before executing. This allows the user to\n+///         create dependencies between run functions in different pipelines.\n+///         The user may pass in NULL if they do not wish to wait for any\n+///         dependencies to complete.\n+///\n+/// @param  in_pMiscData\n+///         [in] Pointer to user defined data, typically used to pass\n+///         parameters to Sink side functions. Should only be used for small\n+///         amounts data since the data will be placed directly in the\n+///         Driver's command buffer.  COIBuffers should be used to pass large\n+///         amounts of data.\n+///\n+/// @param  in_MiscDataLen\n+///         [in] Size of the in_pMiscData in bytes. Must be less than\n+///         COI_PIPELINE_MAX_IN_MISC_DATA_LEN, and should usually be much\n+///         smaller, see documentation for the parameter in_pMiscData.\n+///\n+/// @param  out_pAsyncReturnValue\n+///         [out] Pointer to user-allocated memory where the return value from\n+///         the run function will be placed.  This memory should not be read\n+///         until out_pCompletion has been signalled.\n+///\n+/// @param  in_AsyncReturnValueLen\n+///         [in] Size of the out_pAsyncReturnValue in bytes.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional pointer to a COIEVENT object\n+///         that will be signaled when this run function has completed\n+///         execution. The user may pass in NULL if they do not wish to signal\n+///         any COIEVENTs when this run function completes.\n+///\n+/// @return COI_SUCCESS if the function was successfully placed in a\n+///         pipeline for future execution.  Note that the actual\n+///         execution of the function will occur in the future.\n+///\n+/// @return COI_OUT_OF_RANGE if in_NumBuffers is greater than\n+///         COI_PIPELINE_MAX_IN_BUFFERS or if in_MiscDataLen is greater than\n+///         COI_PIPELINE_MAX_IN_MISC_DATA_LEN.\n+///\n+/// @return COI_INVALID_HANDLE if the pipeline handle passed in was invalid.\n+///\n+/// @return COI_INVALID_HANDLE if the function handle passed in was invalid.\n+///\n+/// @return COI_INVALID_HANDLE if any of the buffers passed in are invalid.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_NumDependencies is non-zero while\n+///         in_pDependencies was passed in as NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is non-NULL but\n+///         in_NumDependencies is zero.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_MiscDataLen is non-zero while\n+///         in_pMiscData was passed in as NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pMiscData is non-NULL but\n+///         in_MiscDataLen is zero.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_NumBuffers is non-zero and in_pBuffers\n+///         or in_pBufferAccessFlags are NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pBuffers is non-NULL but\n+///         in_NumBuffers is zero.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pBufferAccessFlags is non-NULL but\n+///         in_NumBuffers is zero.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_ReturnValueLen is non-zero while\n+///         in_pReturnValue was passed in as NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pReturnValue is non-NULL but\n+///         in_ReturnValueLen is zero.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if a COI_BUFFER_STREAMING_TO_SOURCE buffer\n+///         is not passed with COI_SINK_WRITE_ENTIRE access flag.\n+///\n+/// @return COI_RESOURCE_EXHAUSTED if could not create a version for TO_SOURCE\n+///         streaming buffer. It can fail if enough memory is not available to\n+///         register. This call will succeed eventually when the registered\n+///         memory becomes available.\n+///\n+/// @return COI_RETRY if any input buffers, which are not pinned buffers,\n+///         are still mapped when passed to the run function.\n+///\n+/// @return COI_MISSING_DEPENDENCY if buffer was not created on the process \n+///         associated with the pipeline that was passed in.\n+///\n+/// @return COI_OUT_OF_RANGE if any of the access flags in\n+///         in_pBufferAccessFlags is not a valid COI_ACCESS_FLAGS.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIPipelineRunFunction(\n+            COIPIPELINE         in_Pipeline,\n+            COIFUNCTION         in_Function,\n+            uint32_t            in_NumBuffers,\n+    const   COIBUFFER*          in_pBuffers,\n+    const   COI_ACCESS_FLAGS*   in_pBufferAccessFlags,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+    const   void*               in_pMiscData,\n+            uint16_t            in_MiscDataLen,\n+            void*               out_pAsyncReturnValue,\n+            uint16_t            in_AsyncReturnValueLen,\n+            COIEVENT*           out_pCompletion);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Retrieve the engine that the pipeline is associated with.\n+///\n+/// @param  in_Pipeline\n+///         [in] Pipeline to query.\n+///\n+/// @param  out_pEngine\n+///         [out] The handle of the Engine.\n+///\n+/// @return COI_SUCCESS if the engine was retrieved.\n+///\n+/// @return COI_INVALID_HANDLE if the pipeline handle passed in was invalid.\n+///\n+/// @return COI_INVALID_POINTER if the out_pEngine parameter is NULL.\n+///\n+/// @return COI_PROCESS_DIED if the process associated with this engine died.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIPipelineGetEngine(\n+            COIPIPELINE         in_Pipeline,\n+            COIENGINE*          out_pEngine);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Add a particular core:thread pair to a COI_CPU_MASK.\n+///\n+/// @param  in_Process\n+///         [in] A handle to an already existing process that the pipeline\n+///         will be associated with.\n+///\n+/// @param  in_CoreID\n+///         [in] Core to affinitize to; must be less than the number of cores\n+///         on the device.\n+///\n+/// @param  in_ThreadID\n+///         [in] Thread on the core to affinitize to (0 - 3).\n+///\n+/// @param  out_pMask\n+///         [out] Pointer to the mask to set.\n+///\n+/// @warning Unless it is explicitly done, the contents of the mask may not\n+///          be zero when creating or declaring a COI_CPU_MASK variable.\n+///\n+/// @return COI_SUCCESS if the mask was set.\n+///\n+/// @return COI_OUT_OF_RANGE if the in_CoreID or in_ThreadID is out of range.\n+///\n+/// @return COI_INVALID_POINTER if out_pMask is invalid.\n+///\n+/// @return COI_INVALID_HANDLE if in_Process is invalid.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIPipelineSetCPUMask(\n+            COIPROCESS          in_Process,\n+            uint32_t            in_CoreID,\n+            uint8_t             in_ThreadID,\n+            COI_CPU_MASK*       out_pMask);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Clears a given mask. Note that the memory contents of COI_CPU_MASK are not\n+/// guaranteed to be zero when declaring a COI_CPU_MASK variable. Thus, prior\n+/// to setting a specific affinity to in_Mask it is important to call this\n+/// function first.\n+///\n+/// @param  in_Mask\n+///         [in] Pointer to the mask to clear.\n+///\n+/// @return COI_SUCCESS if the mask was cleared.\n+///\n+/// @return COI_INVALID_POINTER if in_Mask is invalid.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIPipelineClearCPUMask(\n+            COI_CPU_MASK*       in_Mask);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIPIPELINE_SOURCE_H */\n+\n+/*! @} */"}, {"sha": "b60e55225157687e0f13d177249698d8d06a9688", "filename": "liboffloadmic/include/coi/source/COIProcess_source.h", "status": "added", "additions": 971, "deletions": 0, "changes": 971, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,971 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIPROCESS_SOURCE_H\n+#define _COIPROCESS_SOURCE_H\n+\n+/** @ingroup COIProcess\n+ *  @addtogroup COIProcessSource\n+@{\n+* @file source/COIProcess_source.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+/// This is a special COIPROCESS handle that can be used to indicate that\n+/// the source process should be used for an operation.\n+///\n+#define COI_PROCESS_SOURCE  ((COIPROCESS)-1)\n+\n+#define COI_MAX_FILE_NAME_LENGTH 256\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Create a remote process on the Sink and start executing its main()\n+/// function.\n+///\n+/// For more details about creating a process see COIProcessCreateFromMemory.\n+///\n+/// @param  in_Engine\n+///         [in] A handle retrieved via a call to COIEngineGetHandle() that\n+///         indicates which device to create the process on.  This is\n+///         necessary because there can be more than one device\n+///         within the system.\n+///\n+/// @param  in_pBinaryName\n+///         [in] Pointer to a null-terminated string that contains the\n+///         path to the program binary to be instantiated as a process on\n+///         the sink device.  The file name will be accessed via\n+///         fopen and fread, as such, the passed in binary name must\n+///         be locatable via these commands. Also, the file name (without\n+///         directory information) will be used automatically by the system\n+///         to create the argv[0] of the new process.\n+///\n+/// @param  in_Argc\n+///         [in] The number of arguments being passed in to the process in the\n+///         in_ppArgv parameter.\n+///\n+/// @param  in_ppArgv\n+///         [in] An array of strings that represent the arguments being passed\n+///         in. The system will auto-generate argv[0] using in_pBinaryName and\n+///         thus that parameter cannot be passed in using in_ppArgv. Instead,\n+///         in_ppArgv contains the rest of the parameters being passed in.\n+///\n+/// @param  in_DupEnv\n+///         [in] A boolean that indicates whether the process that is being\n+///         created should inherit the environment of the caller.\n+///\n+/// @param  in_ppAdditionalEnv\n+///         [in] An array of strings that represent additional environment\n+///         variables. This parameter must terminate the array with a NULL\n+///         string. For convenience it is also allowed to be NULL if there are\n+///         no additional environment variables that need adding. Note that\n+///         any environment variables specified here will be in addition to\n+///         but override those that were inherited via in_DupEnv.\n+///\n+/// @param  in_ProxyActive\n+///         [in] A boolean that specifies whether the process that is to be\n+///         created wants I/O proxy support. If this flag is enabled, then\n+///         stdout and stderr are forwarded back to the calling process's\n+///         output and error streams.\n+///\n+/// @param  in_Reserved\n+///         Reserved for future use, best set at NULL.\n+///\n+/// @param  in_InitialBufferSpace\n+///         [in] The initial memory (in bytes) that will be pre-allocated at\n+///         process creation for use by buffers associated with this remote\n+///         process. In addition to allocating, Intel\u00ae Coprocessor Offload\n+///         Infrastructure (Intel\u00ae COI)  will also fault in the\n+///         memory during process creation. If the total size of the buffers\n+///         in use by this process exceed this initial size, memory on the\n+///         sink may continue to be allocated on demand, as needed, subject\n+///         to the system constraints on the sink.\n+///\n+///@param   in_LibrarySearchPath\n+///         [in] a path to locate dynamic libraries dependencies for the sink\n+///         application. If not NULL, this path will override the environment\n+///         variable SINK_LD_LIBRARY_PATH. If NULL it will use\n+///         SINK_LD_LIBRARY_PATH to locate dependencies.\n+///\n+/// @param  out_pProcess\n+///         [out] Handle returned to uniquely identify the process that was\n+///         created for use in later API calls.\n+///\n+/// @return COI_SUCCESS if the remote process was successfully created.\n+///\n+/// @return COI_INVALID_POINTER if in_pBinaryName was NULL.\n+///\n+/// @return COI_INVALID_FILE if in_pBinaryName is not a \"regular file\" as\n+///         determined by stat or if its size is 0.\n+///\n+/// @return COI_DOES_NOT_EXIST if in_pBinaryName cannot be found.\n+///\n+/// @return See COIProcessCreateFromMemory for additional errors.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIProcessCreateFromFile(\n+            COIENGINE           in_Engine,\n+    const   char*               in_pBinaryName,\n+            int                 in_Argc,\n+    const   char**              in_ppArgv,\n+            uint8_t             in_DupEnv,\n+    const   char**              in_ppAdditionalEnv,\n+            uint8_t             in_ProxyActive,\n+    const   char*               in_Reserved,\n+            uint64_t            in_InitialBufferSpace,\n+    const   char*               in_LibrarySearchPath,\n+            COIPROCESS*         out_pProcess);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Create a remote process on the Sink and start executing its main()\n+/// function. This will also automatically load any dependent shared objects\n+/// on to the device. Once the process is created, remote calls can be\n+/// initiated by using the RunFunction mechanism found in the COIPipeline APIs.\n+///\n+/// If instead of creating a process you only wish to check for dynamic\n+/// library dependencies set the environment variable\n+/// SINK_LD_TRACE_LOADED_OBJECTS to be non empty before making this call.\n+///\n+/// If there are dynamic link libraries on the source file system that need to\n+/// be preloaded when the process is created on the device, callers of this\n+/// API can set the environment variable SINK_LD_PRELOAD to a colon separated\n+/// list of libraries that need to be copied to the sink and preloaded as part\n+/// of process creation.\n+///\n+/// For more information on how dependencies are loaded, see\n+/// COIProcessLoadLibraryFromMemory.\n+///\n+/// @param  in_Engine\n+///         [in] A handle retrieved via a call to COIEngineGetHandle() that\n+///         indicates which device to create the process on.  This is\n+///         necessary because there can be more than one device\n+///         within the system.\n+///\n+/// @param  in_pBinaryName\n+///         [in] Pointer to a null-terminated string that contains the name to\n+///         give the process that will be created. Note that the final name\n+///         will strip out any directory information from in_pBinaryName and\n+///         use the file information to generate an argv[0] for the new\n+///         process.\n+///\n+/// @param  in_pBinaryBuffer\n+///         [in] Pointer to a buffer whose contents represent the sink-side\n+///         process that we want to create.\n+///\n+/// @param  in_BinaryBufferLength\n+///         [in] Number of bytes in in_pBinaryBuffer.\n+///\n+/// @param  in_Argc\n+///         [in] The number of arguments being passed in to the process in the\n+///         in_ppArgv parameter.\n+///\n+/// @param  in_ppArgv\n+///         [in] An array of strings that represent the arguments being passed\n+///         in. The system will auto-generate argv[0] using in_pBinaryName and\n+///         thus that parameter cannot be passed in using in_ppArgv. Instead,\n+///         in_ppArgv contains the rest of the parameters being passed in.\n+///\n+/// @param  in_DupEnv\n+///         [in] A boolean that indicates whether the process that is being\n+///         created should inherit the environment of the caller.\n+///\n+/// @param  in_ppAdditionalEnv\n+///         [in] An array of strings that represent additional environment\n+///         variables. This parameter must terminate the array with a NULL\n+///         string. For convenience it is also allowed to be NULL if there are\n+///         no additional environment variables that need adding. Note that\n+///         any environment variables specified here will be in addition to\n+///         but override those that were inherited via in_DupEnv.\n+///\n+/// @param  in_ProxyActive\n+///         [in] A boolean that specifies whether the process that is to be\n+///         created wants I/O proxy support.\n+///\n+/// @param  in_Reserved\n+///         Reserved for future use, best set to NULL.\n+///\n+/// @param  in_InitialBufferSpace\n+///         [in] The initial memory (in bytes) that will be pre-allocated at\n+///         process creation for use by buffers associated with this remote\n+///         process. In addition to allocating, Intel\u00ae Coprocessor\n+///         Offload Infrastructure (Intel\u00ae COI)  will also fault in the\n+///         memory during process creation. If the total size of the buffers\n+///         in use by this process exceed this initial size, memory on the\n+///         sink may continue to be allocated on demand, as needed, subject\n+///         to the system constraints on the sink.\n+///\n+/// @param  in_LibrarySearchPath\n+///         [in] A path to locate dynamic libraries dependencies for the sink\n+///         application. If not NULL, this path will override the environment\n+///         variable SINK_LD_LIBRARY_PATH. If NULL it will use\n+///         SINK_LD_LIBRARY_PATH to locate dependencies.\n+///\n+/// @param  in_FileOfOrigin\n+///         [in] If not NULL, this parameter indicates the file from which the\n+///         in_pBinaryBuffer was obtained. This parameter is optional.\n+///\n+/// @param  in_FileOfOriginOffset\n+///         [in] If in_FileOfOrigin is not NULL, this parameter indicates the\n+///         offset within that file where in_pBinaryBuffer begins.\n+///\n+/// @param  out_pProcess\n+///         [out] Handle returned to uniquely identify the process that was\n+///         created for use in later API calls.\n+///\n+/// @return COI_SUCCESS if the remote process was successfully created.\n+///\n+/// @return COI_INVALID_HANDLE if the in_Engine handle passed in was invalid.\n+///\n+/// @return COI_INVALID_POINTER if out_pProcess was NULL.\n+///\n+/// @return COI_INVALID_POINTER if in_pBinaryName or in_pBinaryBuffer was NULL.\n+///\n+/// @return COI_MISSING_DEPENDENCY if a dependent library is missing from\n+///         either SINK_LD_LIBRARY_PATH or the in_LibrarySearchPath parameter.\n+///\n+/// @return COI_BINARY_AND_HARDWARE_MISMATCH if in_pBinaryName or any of its\n+///         recursive dependencies were built for a target machine that does\n+///         not match the engine specified.\n+///\n+/// @return COI_RESOURCE_EXHAUSTED if no more COIProcesses can be created,\n+///         possibly, but not necessarily because in_InitialBufferSpace is too\n+///         large.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_Argc is 0 and in_ppArgv is not NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_Argc is greater than 0 and in_ppArgv is\n+///         NULL.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Argc is less than 0.\n+///\n+/// @return COI_OUT_OF_RANGE if the length of in_pBinaryName is greater than or\n+///         equal to COI_MAX_FILE_NAME_LENGTH.\n+///\n+/// @return COI_OUT_OF_RANGE if in_BinaryBufferLength is 0.\n+///\n+/// @return COI_TIME_OUT_REACHED if establishing the communication channel with\n+///         the remote process timed out.\n+///\n+/// @return COI_DOES_NOT_EXIST if in_FileOfOrigin is not NULL and does not\n+///         exist.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_FileOfOrigin is NULL and\n+///         in_FileOfOriginOffset is not 0.\n+///\n+/// @return COI_INVALID_FILE if in_FileOfOrigin is not a \"regular file\" as\n+///         determined by stat or if its size is 0.\n+///\n+/// @return COI_OUT_OF_RANGE if in_FileOfOrigin exists but its size is\n+///         less than in_FileOfOriginOffset + in_BinaryBufferLength.\n+///\n+/// @return COI_NOT_INITIALIZED if the environment variable\n+///         SINK_LD_TRACE_LOADED_OBJECTS is set to a non empty string and there\n+///         are no errors locating the shared library dependencies.\n+///\n+/// @return COI_PROCESS_DIED if at some point during the loading of the remote\n+///         process the remote process terminated abnormally.\n+///\n+/// @return COI_VERSION_MISMATCH if the version of Intel\u00ae Coprocessor\n+///         Offload Infrastructure (Intel\u00ae COI)  on the host is not\n+///         compatible with the version on the device.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIProcessCreateFromMemory(\n+            COIENGINE           in_Engine,\n+    const   char*               in_pBinaryName,\n+    const   void*               in_pBinaryBuffer,\n+            uint64_t            in_BinaryBufferLength,\n+            int                 in_Argc,\n+    const   char**              in_ppArgv,\n+            uint8_t             in_DupEnv,\n+    const   char**              in_ppAdditionalEnv,\n+            uint8_t             in_ProxyActive,\n+    const   char*               in_Reserved,\n+            uint64_t            in_InitialBufferSpace,\n+    const   char*               in_LibrarySearchPath,\n+    const   char*               in_FileOfOrigin,\n+            uint64_t            in_FileOfOriginOffset,\n+            COIPROCESS*         out_pProcess);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Destroys the indicated process, releasing its resources. Note, this\n+/// will destroy any outstanding pipelines created in this process as well.\n+///\n+/// @param  in_Process\n+///         [in] Process to destroy.\n+///\n+/// @param  in_WaitForMainTimeout\n+///         [in] The number of milliseconds to wait for the main() function\n+///         to return in the sink process before timing out. -1 means to wait\n+///         indefinitely.\n+///\n+/// @param  in_ForceDestroy\n+///         [in] If this flag is set to true, then the sink process will be\n+///         forcibly terminated after the timeout has been reached. A timeout\n+///         value of 0 will kill the process immediately, while a timeout of\n+///         -1 is invalid.  If the flag is set to false then a message will\n+///         be sent to the sink process requesting a clean shutdown. A value\n+///         of false along with a timeout of 0 does not send a shutdown\n+///         message, instead simply polls the process to see if it is alive.\n+///         In most cases this flag should be set to false. If a sink process\n+///         is not responding then it may be necessary to set this flag to\n+///         true.\n+///\n+/// @param  out_pProcessReturn\n+///         [out] The value returned from the main() function executing in\n+///         the sink process. This is an optional parameter. If the caller\n+///         is not interested in the return value from the remote process\n+///         they may pass in NULL for this parameter. The output value of\n+///         this pointer is only meaningful if COI_SUCCESS is returned.\n+///\n+/// @param  out_pTerminationCode\n+///         [out] This parameter specifies the termination code. This will\n+///         be 0 if the remote process exited cleanly. If the remote process\n+///         exited abnormally this will contain the termination code given\n+///         by the operating system of the remote process. This is an optional\n+///         parameter and the caller may pass in NULL if they are not \n+///         interested in the termination code. The output value of this \n+///         pointer is only meaningful if COI_SUCCESS is returned.\n+///\n+/// @return COI_SUCCESS if the process was destroyed.\n+///\n+/// @return COI_INVALID_HANDLE if the process handle passed in was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE for any negative in_WaitForMainTimeout value\n+///         except -1.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_WaitForMainTimeout is -1 and\n+///         in_ForceDestroy is true.\n+///\n+/// @return COI_TIME_OUT_REACHED if the sink process is still running after\n+///         waiting in_WaitForMainTimeout milliseconds and in_ForceDestroy\n+///         is false.  This is true even if in_WaitForMainTimeout was 0.\n+///         In this case, out_pProcessReturn and out_pTerminationCode \n+///         are undefined.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIProcessDestroy(\n+            COIPROCESS              in_Process,\n+            int32_t                 in_WaitForMainTimeout,\n+            uint8_t                 in_ForceDestroy,\n+            int8_t*                 out_pProcessReturn,\n+            uint32_t*               out_pTerminationCode);\n+\n+\n+#define COI_MAX_FUNCTION_NAME_LENGTH 256\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Given a loaded native process, gets an array of function handles that can\n+/// be used to schedule run functions on a pipeline associated with that\n+/// process.  See the documentation for COIPipelineRunFunction() for\n+/// additional information.  All functions that are to be retrieved in this\n+/// fashion must have the define COINATIVEPROCESSEXPORT preceeding their type\n+/// specification.  For functions that are written in C++, either the entries\n+/// in in_pFunctionNameArray in must be pre-mangled, or the functions must be\n+/// declared as extern \"C\". It is also necessary to link the binary containing\n+/// the exported functions with the -rdynamic linker flag.\n+/// It is possible for this call to successfully find function handles for\n+/// some of the names passed in but not all of them. If this occurs\n+/// COI_DOES_NOT_EXIST will return and any handles not found will be returned\n+/// as NULL.\n+///\n+/// @param  in_Process\n+///         [in] Process handle previously returned via COIProcessCreate().\n+///\n+/// @param  in_NumFunctions\n+///         [in] Number of function names passed in to the in_pFunctionNames\n+///         array.\n+///\n+/// @param  in_ppFunctionNameArray\n+///         [in] Pointer to an array of null-terminated strings that match\n+///         the name of functions present in the code of the binary\n+///         previously loaded via COIProcessCreate().  Note that if a C++\n+///         function is used, then the string passed in must already be\n+///         properly name-mangled, or extern \"C\" must be used for where\n+///         the function is declared.\n+///\n+/// @param  out_pFunctionHandleArray\n+///         [in out] Pointer to a location created by the caller large\n+///         enough to hold an array of COIFUNCTION sized elements that has\n+///         in_numFunctions entries in the array.\n+///\n+/// @return COI_SUCCESS if all function names indicated were found.\n+///\n+/// @return COI_INVALID_HANDLE if the in_Process handle passed in was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE if in_NumFunctions is zero.\n+///\n+/// @return COI_INVALID_POINTER if the in_ppFunctionNameArray or\n+///         out_pFunctionHandleArray pointers was NULL.\n+///\n+/// @return COI_DOES_NOT_EXIST if one or more function names were not\n+///         found. To determine the function names that were not found,\n+///         check which elements in the out_pFunctionHandleArray\n+///         are set to NULL.\n+///\n+/// @return COI_OUT_OF_RANGE if any of the null-terminated strings passed in\n+///         via in_ppFunctionNameArray were more than\n+///         COI_MAX_FUNCTION_NAME_LENGTH characters in length including\n+///         the null.\n+///\n+/// @warning This operation can take several milliseconds so it is recommended\n+///          that it only be be done at load time.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIProcessGetFunctionHandles(\n+            COIPROCESS          in_Process,\n+            uint32_t            in_NumFunctions,\n+    const   char**              in_ppFunctionNameArray,\n+            COIFUNCTION*        out_pFunctionHandleArray);\n+\n+#if COI_LIBRARY_VERSION >= 2\n+/// @name COIProcessLoadLibrary* flags, named after the corresponding\n+/// RTLD flags that are passed into dlopen().\n+/// Please consult a Linux manual for more information about these flags.\n+//@{\n+#define COI_LOADLIBRARY_LOCAL      0x00000\n+#define COI_LOADLIBRARY_GLOBAL     0x00100\n+\n+#define COI_LOADLIBRARY_LAZY       0x00001\n+#define COI_LOADLIBRARY_NOW        0x00002\n+#define COI_LOADLIBRARY_NOLOAD     0x00004\n+#define COI_LOADLIBRARY_DEEPBIND   0x00008\n+#define COI_LOADLIBRARY_NODELETE   0x01000\n+\n+/// Flags to replicate the behavior of the original version of\n+/// COIProcessLoadLibrary* APIs.\n+#define COI_LOADLIBRARY_V1_FLAGS   (COI_LOADLIBRARY_GLOBAL|COI_LOADLIBRARY_NOW)\n+\n+//@}\n+\n+#endif\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Loads a shared library into the specified remote process, akin to using\n+/// dlopen() on a local process in Linux or LoadLibrary() in Windows.\n+/// Dependencies for this library that are not listed with absolute paths\n+/// are searched for first in current working directory, then in the\n+/// colon-delimited paths in the environment variable SINK_LD_LIBRARY_PATH,\n+/// and finally on the sink in the standard search paths as defined by the\n+/// sink's operating system / dynamic loader.\n+///\n+/// @param  in_Process\n+///         [in] Process to load the library into.\n+///\n+/// @param  in_pLibraryBuffer\n+///         [in] The memory buffer containing the shared library to load.\n+///\n+/// @param  in_LibraryBufferLength\n+///         [in] The number of bytes in the memory buffer in_pLibraryBuffer.\n+///\n+/// @param  in_pLibraryName\n+///         [in] Name for the shared library. This optional parameter can\n+///         be specified in case the dynamic library doesn't have an\n+///         SO_NAME field. If specified, it will take precedence over\n+///         the SO_NAME if it exists. If it is not specified then\n+///         the library must have a valid SO_NAME field.\n+///\n+///@param   in_LibrarySearchPath\n+///         [in] A path to locate dynamic libraries dependencies for the\n+///         library being loaded. If not NULL, this path will override the\n+///         environment variable SINK_LD_LIBRARY_PATH. If NULL it will use\n+///         SINK_LD_LIBRARY_PATH to locate dependencies.\n+///\n+///@param   in_LibrarySearchPath\n+///         [in] A path to locate dynamic libraries dependencies for the sink\n+///         application. If not NULL, this path will override the environment\n+///         variable SINK_LD_LIBRARY_PATH. If NULL it will use\n+///         SINK_LD_LIBRARY_PATH to locate dependencies.\n+///\n+/// @param  in_FileOfOrigin\n+///         [in] If not NULL, this parameter indicates the file from which the\n+///         in_pBinaryBuffer was obtained. This parameter is optional.\n+///\n+/// @param  in_FileOfOriginOffset\n+///         [in] If in_FileOfOrigin is not NULL, this parameter indicates the\n+///         offset within that file where in_pBinaryBuffer begins.\n+///\n+#if COI_LIBRARY_VERSION >= 2\n+/// @param  in_Flags\n+///         [in] Bitmask of the flags that will be passed in as the dlopen()\n+///         \"flag\" parameter on the sink.\n+///\n+#endif\n+///\n+/// @param  out_pLibrary\n+///         [out] If COI_SUCCESS or COI_ALREADY_EXISTS is returned, the handle\n+///         that uniquely identifies the loaded library.\n+///\n+/// @return COI_SUCCESS if the library was successfully loaded.\n+///\n+/// @return COI_INVALID_HANDLE if the process handle passed in was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE if in_LibraryBufferLength is 0.\n+///\n+/// @return COI_INVALID_FILE if in_pLibraryBuffer does not represent a valid\n+///         shared library file.\n+///\n+/// @return COI_MISSING_DEPENDENCY if a dependent library is missing from\n+///         either SINK_LD_LIBRARY_PATH or the in_LibrarySearchPath parameter.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the shared library is missing an SONAME\n+///         and in_pLibraryName is NULL.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pLibraryName is the same as that of\n+///         any of the dependencies (recursive) of the library being loaded.\n+///\n+/// @return COI_ALREADY_EXISTS if there is an existing COILIBRARY handle\n+///         that identifies this library, and this COILIBRARY hasn't been\n+///         unloaded yet.\n+///\n+/// @return COI_BINARY_AND_HARDWARE_MISMATCH if the target machine of the\n+///         binary or any of its recursive dependencies does not match the\n+///         engine associated with in_Process.\n+///\n+/// @return COI_UNDEFINED_SYMBOL if we are unable to load the library due to\n+///         an undefined symbol.\n+///\n+/// @return COI_PROCESS_DIED if loading the library on the device caused\n+///         the remote process to terminate.\n+///\n+/// @return COI_DOES_NOT_EXIST if in_FileOfOrigin is not NULL and does not\n+///         exist.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_FileOfOrigin is NULL and\n+///         in_FileOfOriginOffset is not 0.\n+///\n+/// @return COI_INVALID_FILE if in_FileOfOrigin is not a \"regular file\" as\n+///         determined by stat or if its size is 0.\n+///\n+/// @return COI_OUT_OF_RANGE if in_FileOfOrigin exists but its size is\n+///         less than in_FileOfOriginOffset + in_BinaryBufferLength.\n+///\n+/// @return COI_INVALID_POINTER if out_pLibrary or in_pLibraryBuffer are NULL.\n+///\n+#if COI_LIBRARY_VERSION >= 2\n+COIACCESSAPI\n+COIRESULT\n+COIProcessLoadLibraryFromMemory(\n+            COIPROCESS          in_Process,\n+    const   void*               in_pLibraryBuffer,\n+            uint64_t            in_LibraryBufferLength,\n+    const   char*               in_pLibraryName,\n+    const   char*               in_LibrarySearchPath,\n+    const   char*               in_FileOfOrigin,\n+            uint64_t            in_FileOfOriginOffset,\n+            uint32_t            in_Flags,\n+            COILIBRARY*         out_pLibrary);\n+__asm__(\".symver COIProcessLoadLibraryFromMemory,\"\n+        \"COIProcessLoadLibraryFromMemory@COI_2.0\");\n+#else\n+\n+COIRESULT\n+COIProcessLoadLibraryFromMemory(\n+COIPROCESS          in_Process,\n+    const   void*               in_pLibraryBuffer,\n+            uint64_t            in_LibraryBufferLength,\n+    const   char*               in_pLibraryName,\n+    const   char*               in_LibrarySearchPath,\n+    const   char*               in_FileOfOrigin,\n+            uint64_t            in_FileOfOriginOffset,\n+            COILIBRARY*         out_pLibrary);\n+__asm__(\".symver COIProcessLoadLibraryFromMemory,\"\n+        \"COIProcessLoadLibraryFromMemory@COI_1.0\");\n+#endif\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Loads a shared library into the specified remote process, akin to using\n+/// dlopen() on a local process in Linux or LoadLibrary() in Windows.\n+///\n+/// For more details, see COIProcessLoadLibraryFromMemory.\n+///\n+/// @param  in_Process\n+///         [in] Process to load the library into.\n+///\n+/// @param  in_pFileName\n+///         [in] The name of the shared library file on the source's file\n+///         system that is being loaded. If the file name is not an absolute\n+///         path, the file is searched for in the same manner as dependencies.\n+///\n+/// @param  in_pLibraryName\n+///         [in] Name for the shared library. This optional parameter can\n+///         be specified in case the dynamic library doesn't have an\n+///         SO_NAME field. If specified, it will take precedence over\n+///         the SO_NAME if it exists. If it is not specified then\n+///         the library must have a valid SO_NAME field.\n+///\n+///@param   in_LibrarySearchPath\n+///         [in] a path to locate dynamic libraries dependencies for the\n+///         library being loaded. If not NULL, this path will override the\n+///         environment variable SINK_LD_LIBRARY_PATH. If NULL it will use\n+///         SINK_LD_LIBRARY_PATH to locate dependencies.\n+///\n+#if COI_LIBRARY_VERSION >= 2\n+/// @param  in_Flags\n+///         [in] Bitmask of the flags that will be passed in as the dlopen()\n+///         \"flag\" parameter on the sink.\n+///\n+#endif\n+///\n+/// @param  out_pLibrary\n+///         [out] If COI_SUCCESS or COI_ALREADY_EXISTS is returned, the handle\n+///         that uniquely identifies the loaded library.\n+///\n+/// @return COI_SUCCESS if the library was successfully loaded.\n+///\n+/// @return COI_INVALID_POINTER if in_pFileName is NULL.\n+///\n+/// @return COI_DOES_NOT_EXIST if in_pFileName cannot be found.\n+///\n+/// @return COI_INVALID_FILE if the file is not a valid shared library.\n+///\n+/// @return See COIProcessLoadLibraryFromMemory for additional errors.\n+///\n+#if COI_LIBRARY_VERSION >= 2\n+\n+COIACCESSAPI\n+COIRESULT\n+COIProcessLoadLibraryFromFile(\n+            COIPROCESS          in_Process,\n+    const   char*               in_pFileName,\n+    const   char*               in_pLibraryName,\n+    const   char*               in_LibrarySearchPath,\n+            uint32_t            in_Flags,\n+            COILIBRARY*         out_pLibrary);\n+__asm__(\".symver COIProcessLoadLibraryFromFile,\"\n+        \"COIProcessLoadLibraryFromFile@COI_2.0\");\n+#else\n+\n+COIRESULT\n+COIProcessLoadLibraryFromFile(\n+            COIPROCESS          in_Process,\n+    const   char*               in_pFileName,\n+    const   char*               in_pLibraryName,\n+    const   char*               in_LibrarySearchPath,\n+            COILIBRARY*         out_pLibrary);\n+__asm__(\".symver COIProcessLoadLibraryFromFile,\"\n+        \"COIProcessLoadLibraryFromFile@COI_1.0\");\n+#endif\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Unloads a a previously loaded shared library from the specified\n+/// remote process.\n+///\n+/// @param  in_Process\n+///         [in] Process that we are unloading a library from.\n+///\n+/// @param  in_Library\n+///         [in] Library that we want to unload.\n+///\n+/// @return COI_SUCCESS if the library was successfully loaded.\n+///\n+/// @return COI_INVALID_HANDLE if the process or library handle were invalid.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIProcessUnloadLibrary(\n+            COIPROCESS          in_Process,\n+            COILIBRARY          in_Library);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Registers shared libraries that are already in the host process's memory\n+/// to be used during the shared library dependency resolution steps that take\n+/// place during subsequent calls to COIProcessCreate* and\n+/// COIProcessLoadLibrary*. If listed as a dependency, the registered library\n+/// will be used to satisfy the dependency, even if there is another library\n+/// on disk that also satisfies that dependency.\n+///\n+/// Addresses registered must remain valid during subsequent calls to\n+/// COIProcessCreate* and COIProcessLoadLibrary*.\n+///\n+/// If the Sink is Linux, the shared libraries must have a library name\n+/// (DT_SONAME field). On most compilers this means built with -soname.\n+///\n+/// If successful, this API registers all the libraries. Otherwise none\n+/// are registered.\n+///\n+/// @param  in_NumLibraries\n+///         [in] The number of libraries that are being registered.\n+///\n+/// @param  in_ppLibraryArray\n+///         [in] An array of pointers that point to the starting addresses\n+///         of the libraries.\n+///\n+/// @param  in_pLibrarySizeArray\n+///         [in] An array of pointers that point to the number of bytes in\n+///         each of the libraries.\n+///\n+/// @param  in_ppFileOfOriginArray\n+///         [in] An array of strings indicating the file from which the\n+///         library was obtained. This parameter is optional. Elements\n+///         in the array may be set to NULL.\n+///\n+/// @param  in_pFileOfOriginOffSetArray\n+///         [in] If the corresponding entry in in_ppFileOfOriginArray is not\n+///         NULL, this parameter indicates the offsets within those files\n+///         where the corresponding libraries begin.\n+///\n+/// @return COI_SUCCESS if the libraries were registered successfully.\n+///\n+/// @return COI_OUT_OF_RANGE if in_NumLibraries is 0.\n+///\n+/// @return COI_INVALID_POINTER if in_ppLibraryArray or in_pLibrarySizeArray\n+///         are NULL.\n+///\n+/// @return COI_INVALID_POINTER if any of the pointers in in_ppLibraryArray\n+///         are NULL.\n+///\n+/// @return COI_OUT_OF_RANGE if any of the values in in_pLibrarySizeArray is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if either one of in_ppFileOfOriginArray\n+///         and in_pFileOfOriginOffSetArray is NULL and the other is not.\n+///\n+/// @return COI_OUT_OF_RANGE if one of the addresses being registered does not\n+///         represent a valid library.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIProcessRegisterLibraries(\n+            uint32_t            in_NumLibraries,\n+    const   void**              in_ppLibraryArray,\n+    const   uint64_t*           in_pLibrarySizeArray,\n+    const   char**              in_ppFileOfOriginArray,\n+    const   uint64_t*           in_pFileOfOriginOffSetArray);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+/// The user can choose to have notifications for these internal events\n+/// so that they can build their own profiling and performance layer on\n+/// top of Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) . \n+///\n+typedef enum COI_NOTIFICATIONS\n+{\n+    /// This event occurs when all explicit and implicit dependencies are\n+    /// satisified and Intel\u00ae Coprocessor Offload Infrastructure\n+    /// (Intel\u00ae COI)  schedules the run function to begin execution.\n+    RUN_FUNCTION_READY = 0,\n+\n+    /// This event occurs just before the run function actually starts\n+    /// executing. There may be some latency between the ready and start\n+    /// events if other run functions are already queued and ready to run.\n+    RUN_FUNCTION_START,\n+\n+    /// This event occurs when the run function finishes. This is when the\n+    /// completion event for that run function would be signaled.\n+    RUN_FUNCTION_COMPLETE,\n+\n+    /// This event occurs when all explicit and implicit dependencies are\n+    /// met for the pending buffer operation. Assuming buffer needs to be\n+    /// moved, copied, read, etc... Will not be invoked if no actual memory\n+    /// is moved, copied, read, etc. This means that COIBufferUnmap will\n+    /// never result in a callback as it simply updates the status of the\n+    /// buffer but doesn't initiate any data movement. COIBufferMap,\n+    /// COIBufferSetState, COIBufferWrite, COIBufferRead and COIBufferCopy\n+    /// do initiate data movement and therefore will invoke the callback.\n+    BUFFER_OPERATION_READY,\n+\n+    /// This event occurs when the buffer operation is completed.\n+    BUFFER_OPERATION_COMPLETE,\n+\n+    /// This event occurs when a user event is signaled from the remotely\n+    /// a sink process. Local (source triggered) events do not trigger this.\n+    USER_EVENT_SIGNALED\n+} COI_NOTIFICATIONS;\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// A callback that will be invoked to notify the user of an internal\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) \n+/// event. Note that the callback is registered per process so any of the\n+/// above notifications that happen on the registered process will receive\n+/// the callback.\n+/// As with any callback mechanism it is up to the user to make sure that\n+/// there are no possible deadlocks due to reentrancy (ie the callback being\n+/// invoked in the same context that triggered the notification) and also\n+/// that the callback does not slow down overall processing. If the user\n+/// performs too much work within the callback it could delay further\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) \n+/// processing.\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  \n+/// promises to invoke the callback for an internal event prior to\n+/// signaling the corresponding COIEvent. For example, if a user is waiting\n+/// for a COIEvent associated with a run function completing they will\n+/// receive the callback before the COIEvent is marked as signaled.\n+///\n+///\n+/// @param  in_Type\n+///         [in] The type of internal event that has occurred.\n+///\n+/// @param  in_Process\n+///         [in] The process associated with the operation.\n+///\n+/// @param  in_Event\n+///         [in] The completion event that is associated with the\n+///         operation that is being notified.\n+///\n+/// @param  in_UserData\n+///         [in] Opaque data that was provided when the callback was\n+///         registered. Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  simply passes this back to the user so that\n+///         they can interpret it as they choose.\n+///\n+typedef void (*COI_NOTIFICATION_CALLBACK)(\n+            COI_NOTIFICATIONS   in_Type, \n+            COIPROCESS          in_Process,\n+            COIEVENT            in_Event,\n+    const   void*               in_UserData);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Register a callback to be invoked to notify that an internal\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  event\n+/// has occured on the process that is associated with the callback.\n+/// Note that it is legal to have more than one callback registered with\n+/// a given process but those must all be unique callback pointers.\n+/// Note that setting a UserData value with COINotificationCallbackSetContext\n+/// will override a value set when registering the callback.\n+///\n+/// @param  in_Process\n+///         [in] Process that the callback is associated with. The callback\n+///         will only be invoked to notify an event for this specific process.\n+///\n+/// @param  in_Callback\n+///         [in] Pointer to a user function used to signal a notification.\n+///\n+/// @param  in_UserData\n+///         [in] Opaque data to pass to the callback when it is invoked.\n+///\n+/// @return COI_SUCCESS if the callback was registered successfully.\n+///\n+/// @return COI_INVALID_HANDLE if the in_Process parameter does not identify\n+///         a valid process.\n+///\n+/// @return COI_INVALID_POINTER if the in_Callback parameter is NULL.\n+///\n+/// @return COI_ALREADY_EXISTS if the user attempts to reregister the same\n+///         callback for a process.\n+///\n+COIACCESSAPI\n+COIRESULT COIRegisterNotificationCallback(\n+            COIPROCESS                  in_Process,\n+            COI_NOTIFICATION_CALLBACK   in_Callback,\n+            const   void*               in_UserData);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Unregisters a callback, notifications will no longer be signaled.\n+///\n+/// @param  in_Process\n+///         [in] Process that we are unregistering.\n+///\n+/// @param  in_Callback\n+///         [in] The specific callback to unregister.\n+///\n+/// @return COI_SUCCESS if the callback was unregistered.\n+///\n+/// @return COI_INVALID_HANDLE if the in_Process parameter does not identify\n+///         a valid process.\n+///\n+/// @return COI_INVALID_POINTER if the in_Callback parameter is NULL.\n+///\n+/// @return COI_DOES_NOT_EXIST if in_Callback was not previously registered\n+///         for in_Process.\n+///\n+COIACCESSAPI\n+COIRESULT COIUnregisterNotificationCallback(\n+            COIPROCESS                  in_Process,\n+            COI_NOTIFICATION_CALLBACK   in_Callback);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Set the user data that will be returned in the notification callback.\n+/// This data is sticky and per thread so must be set prior to the\n+/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) //\n+/// operation being invoked. If you wish to set the context to be returned\n+/// for a specific instance of a user event notification then the context\n+/// must be set using this API prior to registering that user event with\n+/// COIEventRegisterUserEvent.\n+/// The value may be set prior to each Intel\u00ae Coprocessor Offload\n+/// Infrastructure (Intel\u00ae COI)  operation being called to \n+/// effectively have a unique UserData per callback.\n+/// Setting this value overrides any value that was set when the\n+/// callback was registered and will also override any future registrations\n+/// that occur.\n+///\n+/// @param  in_UserData\n+///         [in] Opaque data to pass to the callback when it is invoked.\n+///         Note that this data is set per thread.\n+///\n+COIACCESSAPI\n+void COINotificationCallbackSetContext(\n+    const   void*                       in_UserData);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIPROCESS_SOURCE_H */\n+\n+/*! @} */"}, {"sha": "c6e5f56ede219c4a99d6e43a3ccb0044486f0e4c", "filename": "liboffloadmic/include/myo/myo.h", "status": "added", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,619 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+/**\n+ * Description:\n+ *   External APIs of MYO runtime (MYO stands for Mine, Yours and Ours).\n+ **/\n+\n+#ifndef _MYO_H_\n+#define _MYO_H_\n+\n+#include \"myotypes.h\"\n+#include \"myoimpl.h\"\n+\n+/** @ingroup MYO\n+ *  @addtogroup MYO_API\n+@{\n+* @file myo.h \n+*/\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/****************************************************************************\n+    Arena-based APIs\n+ ***************************************************************************/\n+\n+/* \n+ * Arena is a set of memory pages with the same ownership type. The ownership\n+ * type of all the memory pages inside the same arena can only be changed as\n+ * a whole. For \"OURS\", it is also the minimal unit of sync operations to\n+ * implement \"release consistency\".\n+ */\n+\n+/** @fn extern MyoError myoArenaCreate(MyoOwnershipType in_Type, \n+ * int in_Property, MyoArena *out_pArena)\n+ * @brief Create an arena with specified ownership type and property.\n+ * \n+ * @param in_Type Specified ownership type (MYO_ARENA_OURS or \n+ * MYO_ARENA_MINE).\n+ * @param in_Property Specified properties of the arena. Set it \n+ * to 0 to use default properties.\n+ *\n+ *      MYO_RELEASE_CONSISTENCY or MYO_STRONG_RELEASE_CONSISTENCY\n+ *      or MYO_STRONG_CONSISTENCY: \n+ *\n+ *          Consistency modes for \"OURS\" arenas. For MYO_RELEASE_CONSISTENCY,\n+ *          there are 2 functions, \"Acquire\" and \"Release\", which are \n+ *          used for memory ordering. \"Release\" makes all local stores \n+ *          prior to the release globally visible; \"Acquire\" syncs up the \n+ *          local memory with all stores that have been made globally \n+ *          visible. However, there is no definite answer as to whether \n+ *          local stores can be globally visible before reaching a release \n+ *          point, nor whether the newest globally visible stores can be \n+ *          updated to local before reaching an acquire point. By using \n+ *          MYO_STRONG_RELEASE_CONSISTENCY, the answer to these questions\n+ *          is \"no\". A sequential consistency model is maintained to the \n+ *          arena when using MYO_STRONG_CONSISTENCY. \n+ *          MYO_RELEASE_CONSISTENCY is the default property.\n+ *\n+ *      MYO_UPDATE_ON_DEMAND or MYO_UPDATE_ON_ACQUIRE: \n+ *\n+ *          Only apply to \"OURS\" arenas with \"Release Consistency\".\n+ *          MYO_UPDATE_ON_ACQUIRE means that the shared pages of this \n+ *          arena will be updated on acquire point; MYO_UPDATE_ON_DEMAND\n+ *          means that the shared pages will not be updated until they \n+ *          are accessed. MYO_UPDATE_ON_DEMAND is the default property.\n+ *\n+ *      MYO_RECORD_DIRTY or MYO_NOT_RECORD_DIRTY:\n+ *\n+ *          This property controls whether to record dirty pages. \n+ *          There will be runtime overhead when recording dirty pages, \n+ *          as it can reduce the communication data. It is a trade-off \n+ *          for performance. Also when MYO_NOT_RECORD_DIRTY is set for \n+ *          \"OURS\" arena, the runtime cannot guarantee the correctness \n+ *          when the host and card modify the same shared page between \n+ *          the same sync segment. MYO_RECORD_DIRTY is the default \n+ *          property.\n+ *\n+ *      MYO_ONE_VERSION or MYO_MULTI_VERSION: \n+ *\n+ *          Only apply to \"OURS\" arenas with \"Release Consistency\". When\n+ *          MYO_MULTI_VERSION is set, this arena can only be \"release\" on \n+ *          HOST side and \"acquire\" on CARD side. Releasing the arena on \n+ *          HOST will create a new versioned data and put it into a FIFO; \n+ *          acquiring the arena on CARD will get the versioned data \n+ *          from the FIFO one by one. MYO_ONE_VERSION is the default \n+ *          property.\n+ *\n+ *      MYO_CONSISTENCY or MYO_NO_CONSISTENCY: \n+ *\n+ *          Only apply to \"OURS\" arenas with \"Release Consistency\". When \n+ *          MYO_NO_CONSISTENCY is set, the consistency of the arena will\n+ *          not be maintained. That is, it is a no-op operation when \n+ *          calling acquire/release for such arenas. MYO_CONSISTENCY is \n+ *          the default property.\n+ *\n+ *      MYO_HOST_TO_DEVICE and MYO_DEVICE_TO_HOST: \n+ *\n+ *          When it is certain that there is only one communication\n+ *          direction for this arena, it can be created with only\n+ *          MYO_HOST_TO_DEVICE or MYO_DEVICE_TO_HOST so the runtime \n+ *          can perform optimizations. The default property is \n+ *          MYO_HOST_TO_DEVICE | MYO_DEVICE_TO_HOST.\n+ *\n+ * @param out_pArena Used to store the handle of the created arena.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+CILK_SHARED MyoError myoArenaCreate(MyoOwnershipType in_Type, int in_Property, MyoArena *out_pArena);\n+\n+/** @fn extern MyoError myoArenaDestroy(MyoArena in_Arena)\n+ * @brief Destroy an arena. As a result, the arena can not be \n+ * referred any more.\n+ *\n+ * @param in_Arena Arena handle returned by previous call to \n+ * myoArenaCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+CILK_SHARED MyoError myoArenaDestroy(MyoArena in_Arena);\n+\n+/** @fn extern void *myoArenaMalloc(MyoArena in_Arena, size_t in_Size)\n+ * @brief Allocates size bytes from the specified arena, and returns \n+ * the start address of the allocated memory. The memory is not \n+ * cleared.\n+ *\n+ * @param in_Arena Arena handle returned by previous call to \n+ * myoArenaCreate.\n+ * @param in_Size Size (bytes) of the required memory space.\n+ * @return\n+ *      The start address of the allocated memory space.\n+ *      NULL: Failed.\n+ **/\n+MYOACCESSAPI\n+void *myoArenaMalloc(MyoArena in_Arena, size_t in_Size);\n+\n+/** @fn extern void myoArenaFree(MyoArena in_Arena, void *in_pPtr)\n+ * @brief Frees the memory space allocated by myoArenaMalloc to the \n+ * specified arena.\n+ *\n+ * @param in_Arena Arena handle returned by previous call to \n+ * myoArenaCreate.\n+ * @param in_pPtr The start address of the specified memory \n+ * space, which must be retured by myoArenaMalloc.\n+ * @return\n+ **/\n+MYOACCESSAPI\n+void myoArenaFree(MyoArena in_Arena, void *in_pPtr);\n+\n+/** @fn extern void *myoArenaAlignedMalloc(MyoArena in_Arena, \n+ *                     size_t in_Size, size_t in_Alignment)\n+ * @brief Allocates size bytes from the specified arena. The \n+ * start address of the allocated memory will be a multiple of the \n+ * alignment, which must be a power of two.\n+ *\n+ * @param in_Arena Arena handle returned by previous call to \n+ * myoArenaCreate.\n+ * @param in_Size Size (bytes) of the required memory space.\n+ * @param in_Alignment The alignment value (must be a power \n+ * of two).\n+ * @return\n+ *      The start address of the allocated memory space.\n+ *      NULL: Failed.\n+ **/\n+MYOACCESSAPI\n+void *myoArenaAlignedMalloc(MyoArena in_Arena, size_t in_Size, size_t in_Alignment);\n+\n+/** @fn extern void myoArenaAlignedFree(MyoArena in_Arena, void *in_pPtr)\n+ * @brief Frees the memory space allocated by myoArenaAlignedMalloc \n+ * to the specified arena.\n+ *\n+ * @param in_Arena Arena handle returned by previous call to\n+ * myoArenaCreate.\n+ * @param in_pPtr The start address of the specified memory space,\n+ * which must be returned by myoArenaAlignedMalloc.\n+ * @return\n+ **/\n+MYOACCESSAPI\n+void myoArenaAlignedFree(MyoArena in_Arena, void *in_pPtr);\n+\n+/** @fn extern MyoError myoArenaAcquire(MyoArena in_Arena)\n+ * @brief myoArenaAcquire is the sync point for \"OURS\" arena with\n+ * \"Release Consistency\". myoArenaAcquire is used to obtain all\n+ * stores of \"OURS\" arena that have been made globally visible prior\n+ * to this point. \n+ *\n+ * @param in_Arena Arena handle returned by previous call to \n+ * myoArenaCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+CILK_SHARED MyoError myoArenaAcquire(MyoArena in_Arena);\n+\n+/** @fn extern MyoError myoArenaRelease(MyoArena in_Arena)\n+ * @brief myoArenaRelease is the sync point for \"OURS\" arena with\n+ * \"Release Consistency\". myoArenaRelease is used to flush all prior\n+ * stores of \"OURS\" arena to be globally visible.\n+ *\n+ * @param in_Arena Arena handle returned by previous call to \n+ * myoArenaCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+CILK_SHARED MyoError myoArenaRelease(MyoArena in_Arena);\n+\n+/** @fn extern MyoError myoArenaAcquireOwnership(MyoArena in_Arena)\n+ * @brief Changes the ownership type of the arena to MYO_ARENA_MINE.\n+ *\n+ * @param in_Arena Arena handle returned by previous call to \n+ * myoArenaCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoArenaAcquireOwnership(MyoArena in_Arena);\n+\n+/** @fn extern MyoError myoArenaReleaseOwnership(MyoArena in_Arena)\n+ * @brief Change the ownership type of the arena to MYO_ARENA_OURS.\n+ *\n+ * @param in_Arena Arena handle returned by previous call to \n+ * myoArenaCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoArenaReleaseOwnership(MyoArena in_Arena);\n+\n+/** @fn extern MyoError myoArenaGetHandle(void *in_pPtr, \n+ * MyoArena *out_pArena)\n+ * @brief Gets the arena handle of the arena that contains the memory\n+ * space pointed to by \"in_pPtr\". This API can be used when it is \n+ * not clear which arena handle should be used for other arena \n+ * related APIs.\n+ * \n+ * @param in_pPtr The start address of a chunk of memory space.\n+ * @param out_pArena Handle of the arena.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+CILK_SHARED MyoError myoArenaGetHandle(void *in_pPtr, MyoArena *out_pArena);\n+\n+/********************************************************************************\n+    APIs for the default arena\n+ *******************************************************************************/\n+\n+/**\n+ * There will be a default arena inside MYO runtime, which will be used when\n+ * there is no specified arena.\n+ **/\n+\n+/** @fn extern void* myoSharedMalloc(size_t in_Size)\n+ * @brief Allocates size bytes from the default arena, and returns the\n+ * start address of the allocated memory. The memory is not cleared.\n+ *\n+ @param in_Size Size (bytes) of the required memory space.\n+ * @return \n+ *      The start address of the allocated memory space.\n+ *      NULL: Failed.\n+ **/\n+MYOACCESSAPI\n+void* myoSharedMalloc(size_t in_Size);\n+\n+/** @fn extern void  myoSharedFree(void *in_pPtr)\n+ * @brief Frees the memory space allocated by myoArenaMalloc to the\n+ * default arena.\n+ *\n+ * @param in_pPtr The start address of the specified memory space,\n+ * which must be retured by myoSharedMalloc.\n+ * @return\n+ **/\n+MYOACCESSAPI\n+void  myoSharedFree(void *in_pPtr);\n+\n+/** @fn extern void* myoSharedAlignedMalloc(size_t in_Size, \n+ * size_t in_Alignment)\n+ * @brief Allocates size bytes from the default arena. The start \n+ * address of the allocated memory will be a multiple of alignment, \n+ * which must be a power of two.\n+ *\n+ * @param in_Size Size (bytes) of the required memory space.\n+ * @param in_Alignment The alignment value, which must be an power of two.\n+ * @return\n+ *      The start address of the allocated memory space.\n+ *      NULL: Failed.\n+ **/\n+MYOACCESSAPI\n+void* myoSharedAlignedMalloc(size_t in_Size, size_t in_Alignment);\n+\n+/** @fn extern void  myoSharedAlignedFree(void *in_pPtr)\n+ * @brief Frees the memory space allocated by myoArenaAlignedMalloc \n+ * to the default arena.\n+ *\n+ * @param in_pPtr The start address of the specified memory space,\n+ *      which must be returned by myoArenaAlignedMalloc.\n+ * @return\n+ **/\n+MYOACCESSAPI\n+void  myoSharedAlignedFree(void *in_pPtr);\n+\n+/** @fn extern MyoError myoAcquire()\n+ * @brief myoAcquire is the sync point for the default arena with\n+ * \"Release Consistency\". myoAcquire is used to obtain all stores of\n+ * the default arena that have been made globally visible prior to \n+ * this point.\n+ *\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoAcquire();\n+\n+/** @fn extern MyoError myoRelease()\n+ * @brief myoRelease is the sync point for the default arena with\n+ * \"Release Consistency\". myoRelease is used to flush all prior stores\n+ * of the default arena to be globally visible.\n+ *\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoRelease();\n+\n+/** @fn extern MyoError myoAcquireOwnership()\n+ * @brief Changes the ownership type of the default arena to \n+ * MYO_ARENA_MINE.\n+ *\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoAcquireOwnership();\n+\n+/** @fn extern MyoError myoReleaseOwnership()\n+ * @brief Change the ownership type of the default arena to \n+ * MYO_ARENA_OURS.\n+ *\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoReleaseOwnership();\n+\n+/*****************************************************************************\n+    APIs for global sync operations.\n+ *****************************************************************************/\n+\n+/** @fn extern MyoError myoMutexCreate(MyoMutex *out_pMutex)\n+ * @brief Create a mutex and return the mutex handle.\n+ *\n+ * @param out_pMutex Used to store the handle of the created mutex.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoMutexCreate(MyoMutex *out_pMutex);\n+\n+/** @fn extern MyoError myoMutexLock(MyoMutex in_Mutex)\n+ * @brief Lock the mutex. If the mutex is already locked by other peers,\n+ * the call blocks until the mutex becomes available. Currently, \n+ * attempting to re-acquire the mutex will cause a deadlock.\n+ *\n+ * @param in_Mutex the mutex handle returned by myoMutexCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoMutexLock(MyoMutex in_Mutex);\n+\n+/** @fn extern MyoError myoMutexUnlock(MyoMutex in_Mutex)\n+ * @brief Release the locked mutex.\n+ * Currently, attempting to release an unlocked mutex will cause\n+ * undefined results.\n+ *\n+ * @param in_Mutex the mutex handle returned by myoMutexCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoMutexUnlock(MyoMutex in_Mutex);\n+\n+/** @fn extern MyoError myoMutexTryLock(MyoMutex in_Mutex)\n+ * @brief Try to lock the mutex. myoMutexTryLock is equivalent to \n+ * myoMutexLock, except that myoMutexLock will return immediately if \n+ * the mutex is already locked.\n+ *\n+ * @param in_Mutex the mutex handle returned by myoMutexCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoMutexTryLock(MyoMutex in_Mutex);\n+\n+/** @fn extern MyoError myoMutexDestroy(MyoMutex in_Mutex)\n+ * @brief Destroy the mutex.\n+ *\n+ * @param in_Mutex the mutex handle returned by myoMutexCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoMutexDestroy(MyoMutex in_Mutex);\n+\n+/** @fn extern MyoError myoSemCreate(int in_Value, MyoSem *out_pSem)\n+ * @brief Create a semaphore and return the semaphore handle.\n+ *\n+ * @param in_Value the initial value for the semaphore.\n+ * @param out_pSem Used to store the handle of the created semaphore.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoSemCreate(int in_Value, MyoSem *out_pSem);\n+\n+/** @fn extern MyoError myoSemWait(MyoSem in_Sem)\n+ * @brief Decrements (locks) the semaphore. If the semaphore value is\n+ * greater than zero, then the decrement proceeds and the function\n+ * returns immediately, or else the call blocks until the semaphore\n+ * value rises above zero.\n+ *\n+ * @param in_Sem the semaphore handle returned by myoSemCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoSemWait(MyoSem in_Sem);\n+\n+/** @fn extern MyoError myoSemPost(MyoSem in_Sem)\n+ * @brief Increments (unlocks) the semaphore. If the semaphore value\n+ * becomes greater than zero, one blocked myoSemWait call will be \n+ * notified to return.\n+ *\n+ * @param in_Sem the semaphore handle returned by myoSemCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoSemPost(MyoSem in_Sem);\n+\n+/** @fn extern MyoError myoSemTryWait(MyoSem in_Sem)\n+ * @brief Try to lock semaphore. myoSemTryWait is the same as \n+ * myoSemAcquire, except that if the decrement cannot be immediately \n+ * performed, then the call returns instead of blocking.\n+ *\n+ * @param in_Sem the semaphore handle returned by myoSemCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoSemTryWait(MyoSem in_Sem);\n+\n+/** @fn extern MyoError myoSemDestroy(MyoSem in_Sem)\n+ * @brief Destroy the semaphore.\n+ *\n+ * @param in_Sem the semaphore handle returned by myoSemCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoSemDestroy(MyoSem in_Sem);\n+\n+/** @fn extern MyoError myoBarrierCreate(int in_Count, MyoBarrier *out_pBarrier) \n+ * @brief Create a barrier and return the barrier handle.\n+ *\n+ * @param in_Count the number of threads that must call\n+ * myoBarrierWait before any of them successfully return.\n+ * @param out_pBarrier Used to store the handle of the created \n+ * barrier.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoBarrierCreate(int in_Count, MyoBarrier *out_pBarrier);\n+\n+/** @fn extern MyoError myoBarrierWait(MyoBarrier in_Barrier)\n+ * @brief The caller will block until the required number of threads \n+ * have called myoBarrierWait with the same barrier handle.\n+ *\n+ * @param in_Barrier the barrier handle returned by myoBarrierCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoBarrierWait(MyoBarrier in_Barrier);\n+\n+/** @fn extern MyoError myoBarrierDestroy(MyoBarrier in_Barrier)\n+ * @brief Destroy the barrier.\n+ *\n+ * @param in_Barrier the barrier handle returned by myoBarrierCreate.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoBarrierDestroy(MyoBarrier in_Barrier);\n+\n+/*****************************************************************************\n+    MISC APIs.\n+ *****************************************************************************/\n+\n+/**\n+ * @cond INCLUDE_MYO_INTERNAL_DOCUMENTATION\n+ **/\n+\n+MYOACCESSAPI\n+int myoMyId();\n+/* int myoNumNodes() returns the number of peers, minus one, to\n+   equal the number of cards in the system. */\n+MYOACCESSAPI\n+int myoNumNodes();\n+\n+MYOACCESSAPI\n+unsigned long long myoTicks();\n+MYOACCESSAPI\n+unsigned long long myoWallTime();\n+MYOACCESSAPI\n+void myoStatOn();\n+MYOACCESSAPI\n+void myoStatOff();\n+\n+/** @fn extern MyoError myoGetMemUsage(uint64 *out_memUsedMB) \n+ * @brief Retrieves the amount of shared memory currently used.\n+ * myoGetMemUsage() fills in out_memUsedMB when the pointer is not NULL.\n+ *\n+ * @param out_memUsedBytes, pointer to the current size shared memory used.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoGetMemUsage(unsigned int *out_memUsedMB);\n+\n+/** @fn extern MyoError myoHTimeOn(int in_On) \n+ * @brief Toggle MYO HTime report feature on/off.\n+ *\n+ * @param in_On: 1 turn on MYO HTime report\n+ *               0 turn off MYO HTime report\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+extern MyoError myoHTimeOn(int in_On);\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+\n+ /**\n+ * @endcond\n+ **/\n+\n+/*! @} */"}, {"sha": "d998ef3feb607e876a85e35387bdb3a2fc590cfc", "filename": "liboffloadmic/include/myo/myoimpl.h", "status": "added", "additions": 538, "deletions": 0, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+/**\n+ Description:\n+    Define APIs of MYO for compiler or pre-processor to transfer original programs.\n+ */\n+\n+#ifndef _MYO_IMPL_H_\n+#define _MYO_IMPL_H_\n+\n+/** @ingroup MYO\n+ *  @addtogroup MYOIMPL_API\n+@{\n+* @file myoimpl.h \n+*/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#define EXTERN_C extern \"C\"\n+#else\n+#define EXTERN_C /* nothing */\n+#endif\n+\n+#       define MYOACCESSAPI /* nothing */\n+\n+#ifdef DEFINE_ARENA_API_CILK_SHARED\n+#define CILK_SHARED _Cilk_shared\n+#else\n+#define CILK_SHARED /* nothing */\n+#endif\n+\n+/* **************************************************************************** *\\\n+    APIs to enable functions being remotely called\n+\\* **************************************************************************** */\n+\n+typedef void *(*MyoiRemoteFuncType)(void *);\n+\n+/** @fn extern MyoError myoiRemoteFuncRegister(MyoiRemoteFuncType in_pFuncAddr,\n+ * const char *in_pFuncName)\n+ * @brief Register a function so that it can be remotely called. This should be\n+ * done in myoiUserInit or before calling myoiLibInit. After myoiLibInit,\n+ * there will be a table on all peers, which contains the information for\n+ * all remotely callable functions.\n+ *\n+ * @param in_pWrapFuncAddr address of the wrapper function.\n+ * @param in_pFuncName name of the function.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+\n+MYOACCESSAPI\n+MyoError myoiRemoteFuncRegister(MyoiRemoteFuncType in_pFuncAddr,\n+        const char *in_pFuncName);\n+/** @fn extern MyoError myoiRemoteFuncLookupByName(char *in_pFuncName, \n+ * MyoiRemoteFuncType *out_pWrapFuncAddr)\n+ * @brief Get the address of the wrapper function by looking up the table\n+ * by name. This API can be used when assigning a function pointer to\n+ * remotely callable functions.\n+ *\n+ * @param in_pFuncName name of the function.\n+ * @param out_pWrapFuncAddr address of the wrapper function.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI MyoError myoiRemoteFuncLookupByName(char *in_pFuncName,\n+        MyoiRemoteFuncType *out_pWrapFuncAddr);\n+\n+/** @fn extern MyoError myoiRemoteFuncLookupByAddr(MyoiRemoteFuncType \n+ * in_pWrapFuncAddr,char **out_pFuncName)\n+ * @brief Get the name of a remote function by looking up the table by\n+ * the address. This API can be used when calling a remotely callable \n+ * function by a function pointer.\n+ *\n+ * @param in_pWrapFuncAddr address of the function.\n+ * @param out_pFuncName name of the function.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI MyoError myoiRemoteFuncLookupByAddr(MyoiRemoteFuncType in_pWrapFuncAddr,\n+        char **out_pFuncName);\n+\n+//! Host Side Shared Function Pointer Entry Struct\n+typedef struct {\n+    //! Function Name\n+    const char *funcName;\n+    //! Function Address\n+    void *funcAddr;\n+    //! Local Thunk Address\n+    void *localThunkAddr;\n+} MyoiHostSharedFptrEntry;\n+\n+//! Target Side Shared Function Pointer Entry Struct\n+typedef struct {\n+    //! Function Name\n+    const char *funcName;\n+    //! Function Address\n+    void *funcAddr;\n+    //! Wrap Function Address\n+    void *wrapFuncAddr;\n+    //! Locak Thunk Address\n+    void *localThunkAddr;\n+} MyoiTargetSharedFptrEntry;\n+\n+/**\n+ * @cond INCLUDE_MYO_INTERNAL_DOCUMENTATION\n+ * @fn extern MyoError myoiHostFptrTableRegister(void *in_pAddrOfFptrTable, \n+ * int in_NumEntry, int in_Ordered)\n+ * @brief Register shared functions on host side. A 16 byte thunk will be \n+ * allocated for each function entry in non-coherent shared memory. The \n+ * thunk will contain a jump instruction to the local version of the \n+ * shared function, which is provided by the second item of the function \n+ * entry. Also, the address of the thunk will be stored to the 3rd item \n+ * of the function entry for Compiler usage.\n+ *\n+ * @param in_pAddrOfFptrTable start address of the shared function \n+ * table, assuming it follows the format of MyoiHostSharedFptrEntry.\n+ * @param in_NumEntry number of entry in the table.\n+ * @param in_Ordered whether the table is ordered by function name.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoiHostFptrTableRegister(\n+        void *in_pAddrOfFptrTable, int in_NumEntry, int in_Ordered);\n+\n+/** @fn extern MyoError myoiTargetFptrTableRegister(void *in_pAddrOfFptrTable,\n+ * int in_NumEntry, int in_Ordered)\n+ * @brief Register shared functions on target side. This function is the \n+ * same as myoiHostFptrTableRegister, except it does not need to allocate \n+ * thunks from non-coherent shared memory for each function entry, but \n+ * instead looks up this information from a table retrieved from the \n+ * Host side.\n+ *\n+ * @param in_pAddrOfFptrTable start address of the shared function \n+ * table, assuming it follows the format of MyoiTargetSharedFptrEntry.\n+ * @param in_NumEntry number of entry in the table.\n+ * @param in_Ordered whether the table is ordered by function name.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+extern MyoError myoiTargetFptrTableRegister(\n+        void *in_pAddrOfFptrTable, int in_NumEntry, int in_Ordered);\n+/**\n+ * @endcond\n+ **/\n+\n+/* *************************************************************************** *\\\n+    APIs for remote function calls\n+\\* *************************************************************************** */\n+\n+typedef void * MyoiRFuncCallHandle;\n+\n+/** @fn extern MyoiRFuncCallHandle myoiRemoteCall(char *in_pFuncName, \n+ * void *in_pArgs, int in_deviceNum)\n+ * @brief Call a remote callable function. If there are multiple arguments \n+ * for the function, pack them to a shared buffer beforehand and take the\n+ * address of the shared buffer as this function. After receiving the call \n+ * requests from other peers, the arguments should be unpacked from the \n+ * shared buffer before calling the target function. The shared buffer \n+ * can also be used to store the return value of the function.\n+ *\n+ * @param in_pFuncName name of the function.\n+ * @param in_pArgs address of the shared buffer.\n+ * @return\n+ *      Handle used to check the result.\n+ **/\n+MYOACCESSAPI\n+MyoiRFuncCallHandle myoiRemoteCall(const char *in_pFuncName, void *in_pArgs, int in_deviceNum);\n+\n+/**\n+ * @cond INCLUDE_MYO_INTERNAL_DOCUMENTATION\n+ * @fn extern MyoError myoiRemoteThunkCall(void *in_funcThunkAddr, void *in_pArgs, int in_deviceNum)\n+ * @brief Call a remote callable function. If there are multiple arguments for \n+ * the function, pack them to a shared buffer beforehand and take the address\n+ * of the shared buffer as this function. After receiving the call requests\n+ * from other peers, the arguments should be unpacked from the shared buffer\n+ * before calling the target function. The shared buffer can also be used to \n+ * store the return value of the function.\n+ *\n+ * @param in_funcThunkAddr pointer to function thunk in the non-coherent\n+ * shared memory.\n+ * @param in_pArgs address of the shared buffer.\n+ * @PARAM in_deviceNum: device ID (0-N-1) for the MIC device to run \n+ * function call.  -1 request causes MYO to schedule an available device.  \n+ * For RPC from device to host, in_deviceNum should always be -1.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoiRemoteThunkCall(void *in_funcThunkAddr, void *in_pArgs, int in_deviceNum);\n+/**\n+ * @endcond\n+ **/\n+\n+/** @fn extern MyoError myoiCheckResult(MyoiRFuncCallHandle in_Handle)\n+ * @brief Check whether the remote call is done.\n+ *\n+ * @param in_Handle handle of the remote call.\n+ * @return\n+ *      MYO_SUCCESS (done); or\n+ *      an error number to indicate the error.\n+ **/\n+extern MyoError myoiCheckResult(MyoiRFuncCallHandle in_Handle);\n+\n+/** @fn extern MyoError myoiGetResult(MyoiRFuncCallHandle in_Handle)\n+ * @brief Wait till the remote call is done.\n+ *\n+ * @param in_Handle handle of the remote call.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoiGetResult(MyoiRFuncCallHandle in_Handle);\n+\n+/* **************************************************************************** *\\\n+    APIs related with shared variables.\n+\\* **************************************************************************** */\n+\n+/* \n+ * It is Compiler's responsibility to make sure all shared variables\n+ * located in shared memory space and have the same address in all sides.\n+ * However, it is hard for Compiler to do this. So we propose a solution\n+ * which is changing the definition of all shared variables and accessing\n+ * them indirectly, and making sure all shared variables pointing\n+ * to the same shared space on all sides. For example,\n+ *\n+ * \"shared int a;\" is changed to \"shared int *a\";\n+ * Also all the accesses to \"a\" is change to \"*a\".\n+ *\n+ * We suppose the shared memory for each shared variable is allocated on\n+ * host side by Compiler. For the upper example, Compiler can call:\n+ *\n+ * a = (shared int *) myoSharedMalloc(sizeof(shared int));\n+ *\n+ * Now the issue is how to make \"a\" on other sides also pointing to the\n+ * same shared memory on other sides. We provide two methods to do this.\n+ * They can be used in a hybrid way.\n+ */\n+\n+/* \n+ * The first method is calling myoiVarRegister for each shared variable\n+ * on all sides in myoiUserInit. On host side, we will get a table containing\n+ * a table containing the shared address and name of each shared variable.\n+ * After calling myoiUserInit, we will propagate the table to other sides.\n+ * On card side, after getting the table from host, myoiUserInit is called.\n+ * When calling myoiVarRegister in myoiUserInit, we will make local pointer\n+ * of each shared variable pointing to the same shared memory with the local\n+ * pointer on host side of the same shared variable pointing to.\n+ */\n+\n+/* \n+ * The second method suppose that Compiler already have a table on all sides.\n+ * On host side, the table contains the name and the shared address of each\n+ * shared variable. On card side, the table contains the name of each shared\n+ * variable and the address of the local pointer which will pointing to shared\n+ * memory space.\n+ *\n+ * On host side, Compiler generates a call to myoiHostVarTablePropagate\n+ * after initializing MYO runtime and making the host side table ready.\n+ * On card side, Compiler uses myoiMicVarTableRegister to tell\n+ * the runtime where the card side table is.\n+ *\n+ * Since there may be multiple libraries on card side for the same application,\n+ * myoiHostVarTablePropagate and myoiMicVarTableRegister can be called multiple\n+ * times and called simultaneously.\n+ *\n+ * Inside runtime, the local pointer of the same shared variable on all sides\n+ * will be make sure pointing to the same shared space by using the information\n+ * of the Compiler provided tables.\n+ */\n+\n+/* \n+ * Comipler knows the following two structures to make sure the var table\n+ * has the following format.\n+ */\n+\n+/* \n+ * This is structure of the Shared var table entry. This table contains \n+ * the shared address and name of each shared variable\n+ */\n+\n+/** @fn extern MyoError myoiVarRegister(void *in_pAddrOfLocalPtrToShared, char *in_pSVarName)\n+ * @brief Register shared variables. Call it on all sides in myoiUserInit. \n+ * On host side, make sure calling it after allocating shared memory for \n+ * the shared variables by calling myoSharedMalloc.\n+ *\n+ * @param in_pAddrOfLocalPtrToShared the address assigned by the compiler \n+ * for the shared variable, which is the address of a local pointer, \n+ * pointing to shared memory space.\n+ * @param in_pSVarName name of shared variable.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoiVarRegister(\n+        void *in_pAddrOfLocalPtrToShared, const char *in_pSVarName);\n+\n+/*\n+ * Compiler knows the following two structures to make sure the var table\n+ * has the following format.\n+ */\n+\n+/**\n+ * This is structure of the Shared var table entry. This table contains \n+ * the shared address and name of each shared variable\n+ **/\n+typedef struct {\n+    //! Variable Name\n+    const char *varName;\n+    //! Shared Address\n+    void *sharedAddr;\n+} MyoiSharedVarEntry;\n+\n+//! Structure of the var table entry on host\n+typedef struct {\n+    //! Variable Name\n+    const char *varName;\n+    //! Variable Size\n+    int size;\n+    //! Local pointer to Shared var\n+    void *ptrToLocalPtrToShared;\n+} MyoiHostSharedVarEntry;\n+\n+//! Structure of the var table entry on card \n+typedef struct {\n+    //! Variable Name\n+    const char *varName;\n+    //! Local pointer to Shared var\n+    void *ptrToLocalPtrToShared;\n+} MyoiMicSharedVarEntry;\n+\n+/** @fn extern MyoError myoiHostVarTablePropagate(void *in_pAddrOfSVarTable, int in_NumEntry)\n+ * @brief Send the host side var table to the card side. Card side will also \n+ * have a copy of the host side var table after this propagation, although it \n+ * is in an internal format different than the original host side var table, \n+ * due to implementation convenience.\n+ *\n+ * @param in_pAddrOfSVarTable start address of the host side var table,\n+ * assuming it follows the format of MyoiSharedVarEntry.\n+ * @param in_NumEntry number of entry in the table.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI MyoError myoiHostVarTablePropagate(\n+        void *in_pAddrOfSVarTable, int in_NumEntry);\n+\n+/**\n+ * @cond INCLUDE_MYO_INTERNAL_DOCUMENTATION\n+ * @fn extern MyoError myoiMicVarTableRegister(void *in_pAddrOfSVarTable, int in_NumEntry)\n+ * @brief Tell the runtime where the card side table is.\n+ *\n+ * @param in_pAddrOfSVarTable start address of the card side var\n+ * table, assuming it follows the format of MyoiMicSharedVarEntry.\n+ * @param in_NumEntry number of entry in the table.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+extern MyoError myoiMicVarTableRegister(\n+        void *in_pAddrOfSVarTable, int in_NumEntry);\n+/**\n+ * @endcond\n+ **/\n+\n+/** @fn MyoError myoiHostSharedMallocTableRegister(void *in_pAddrOfSVarTable, int in_NumEntry, int in_Ordered)\n+ * @brief Allocate shared memory for all shared variables in the table. \n+ * Also update local address of the shared variable with new shared address.\n+ *\n+ * @param in_pAddrOfSVarTable start address of the shared variable table,\n+ * assuming it follows the format of MyoiHostSharedVarEntry.\n+ * @param in_NumEntry number of entry in the table.\n+ * @param in_Ordered whether the table ordered by name.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoiHostSharedMallocTableRegister(\n+        void *in_pAddrOfSVarTable, int in_NumEntry, int in_Ordered);\n+\n+/** @fn extern MyoError myoiTargetSharedMallocTableRegister(void *in_pAddrOfSVarTable, int in_NumEntry, int in_Ordered)\n+ * @brief Register the shared variables on the target side.\n+ *\n+ * @param in_pAddrOfSVarTable start address of the shared varaible table,\n+ * assuming it follows the format of MyoiMicSharedVarEntry.\n+ * @param in_NumEntry number of entry in the table.\n+ * @param in_Ordered whether the table ordered by name.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+extern MyoError myoiTargetSharedMallocTableRegister(\n+        void *in_pAddrOfSVarTable, int in_NumEntry, int in_Ordered);\n+\n+/** @fn MyoError myoiLibInit(void * in_args, void (*userInitFunc))\n+ * @brief Init entry of the MYO library responsible for initializing \n+ * the runtime.\n+ *\n+ * @param in_args mechanism to pass arguments to the Initialization \n+ * routine. The default value of NULL would mean the host is blocked \n+ * on the completion of myoiLibInit() on all nodes. A subset of the \n+ * installed cards can be intialized by passing an array of \n+ * MyoiUserParams. For example, in a system with two cards, to run a\n+ * MYO application only on the second card, intialize the array as \n+ * follows:\n+ *      @code \n+ *      MyoiUserParams UserParas[64];\n+ *      UserParas[0].type = MYOI_USERPARAMS_DEVID; \n+ *      UserParas[0].nodeid = 2;\n+ *      UserParas[1].type = MYOI_USERPARAMS_LAST_MSG;\n+ *      if(MYO_SUCCESS != myoiLibInit(&UserParas, (void*)&myoiUserInit)) {\n+ *          printf(\"Failed to initialize MYO runtime\\n\");\n+ *          return -1;\n+ *      }\n+ *      @endcode\n+ *      This intialization is required only in the client/host side \n+ *      of the application. The server/card side executable should be \n+ *      executed only on the second card in this case.\n+ *\n+ * @param userInitFunc Shared variables and remote funtions are \n+ * registered in this routine, which is called by the runtime during\n+ * library initialization. \n+ * @return\n+ *      MYO_SUCCESS;\n+ *      MYO_ERROR;\n+ **/\n+MYOACCESSAPI\n+MyoError myoiLibInit(void * in_args, void *userInitFunc /*userInitFunc must be: MyoError (*userInitFunc)(void) */);\n+\n+/** @fn void myoiLibFini()\n+ * @brief Finalize the MYO library, all resources held by the runtime are \n+ * released by this routine.\n+ *\n+ * @return\n+ **/\n+MYOACCESSAPI\n+void myoiLibFini();\n+\n+/* *************************************************************************** *\\\n+    APIs to set shared memory space consistent/non-consistent.\n+\\* *************************************************************************** */\n+\n+/** @fn extern MyoError myoiSetMemNonConsistent(void *in_pAddr, size_t in_Size)\n+ * @brief Set part of the shared memory space to be non-consistent, which\n+ * means that the consistency of this part of shared memory space does not \n+ * need to be maintained between HOST and cards.\n+ *\n+ * @param in_pAddr The start address of the specified shared memory space;\n+ * @param in_Size The size of the specified shared memory space;\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoiSetMemNonConsistent(void *in_pAddr, size_t in_Size);\n+\n+/** @fn extern MyoError myoiSetMemConsistent(void *in_pAddr, size_t in_Size)\n+ * @brief Set part of the shared memory space to be consistent, which \n+ * means that the consistency of this part of shared memory space needs \n+ * to be maintained between HOST and cards.\n+ *\n+ * @param in_pAddr The start address of the specified shared \n+ * memory space.\n+ * @param in_size The size of the specified shared memory space.\n+ * @return\n+ *      MYO_SUCCESS; or\n+ *      an error number to indicate the error.\n+ **/\n+MYOACCESSAPI\n+MyoError myoiSetMemConsistent(void *in_pAddr, size_t in_Size);\n+\n+/* A collection of external data symbols */\n+EXTERN_C MYOACCESSAPI unsigned int myoiMyId; /* MYO_MYID if on accelerators */\n+EXTERN_C MYOACCESSAPI volatile int myoiInitFlag;\n+\n+\n+ //! Structure of the array element that is passed to myoiLibInit() to initialize a subset of the available cards.\n+typedef struct{\n+    //!type = MYOI_USERPARAMS_DEVID for each element in the array except the last element ; type = MYOI_USERPARAMS_LAST_MSG for the last element in the array.\n+    int type;\n+    //!nodeid refers to the card index.\n+    int nodeid;\n+}MyoiUserParams;\n+\n+#define MYOI_USERPARAMS_DEVID    1\n+#define MYOI_USERPARAMS_LAST_MSG  -1\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif // _MYO_IMPL_H_\n+/*! @} */"}, {"sha": "81464d1666f0066826b714b83e5907c1a6afc758", "filename": "liboffloadmic/include/myo/myotypes.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+/**\n+ Description: Define the types used by APIs of MYO programming.\n+ */\n+\n+#ifndef _MYO_TYPES_H_\n+#define _MYO_TYPES_H_\n+\n+#include <string.h> /* For size_t */\n+\n+/** @ingroup MYO\n+ *  @addtogroup MYOTYPES\n+@{\n+* @file myotypes.h\n+*/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*! MYO Status\n+ */\n+typedef enum {\n+    MYO_SUCCESS = 0,      /*!< Success */\n+    MYO_ERROR,            /*!< Error */\n+\n+    MYO_INVALID_ENV,      /*!< Invalid Env */\n+    MYO_INVALID_ARGUMENT, /*!< Invalid Argument */\n+\n+    MYO_NOT_INITIALIZED,  /*!< Not Initialized */\n+    MYO_ALREADY_FINALIZED,/*!< Already Finalized */\n+\n+    MYO_BUF_ERROR,        /*!< Buffer Error */\n+    MYO_OUT_OF_RANGE,     /*!< Out of Range */\n+    MYO_OUT_OF_MEMORY,    /*!< Out of Memory */ \n+\n+    MYO_ALREADY_EXISTS,   /*!< Already Exists */\n+\n+    MYO_EOF,               /*!< EOF */\n+} MyoError;\n+\n+\n+/*! Arena  Ownership */\n+typedef enum {\n+    MYO_ARENA_MINE = 1, /*!< Arena MINE Ownership */ \n+    MYO_ARENA_OURS,     /*!< Arena OURS Ownership */\n+} MyoOwnershipType;\n+\n+/*************************************************************\n+ *  define the property of MYO Arena \n+ ***********************************************************/\n+#define MYO_CONSISTENCY_MODE            0x3\n+#define MYO_RELEASE_CONSISTENCY         0x1\n+#define MYO_STRONG_RELEASE_CONSISTENCY  0x2\n+#define MYO_STRONG_CONSISTENCY          0x3\n+#define MYO_UPDATE_ON_DEMAND            0x8\n+#define MYO_UPDATE_ON_ACQUIRE           0x10\n+#define MYO_RECORD_DIRTY                0x20\n+#define MYO_NOT_RECORD_DIRTY            0x40\n+#define MYO_ONE_VERSION                 0x80\n+#define MYO_MULTI_VERSIONS              0x100\n+#define MYO_CONSISTENCY                 0x200\n+#define MYO_NO_CONSISTENCY              0x400\n+#define MYO_HOST_TO_DEVICE              0x800\n+#define MYO_DEVICE_TO_HOST              0x1000\n+#define MYO_HYBRID_UPDATE               0x2000\n+typedef unsigned int MyoArena;\n+\n+typedef void * MyoMutex;\n+typedef void * MyoSem;\n+typedef void * MyoBarrier;\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+#endif // _MYO_TYPES_H_\n+/*! @} */"}, {"sha": "3fd12e4d7d676698d2c79c6b0d80e8447f328bec", "filename": "liboffloadmic/liboffloadmic_host.spec.in", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fliboffloadmic_host.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fliboffloadmic_host.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fliboffloadmic_host.spec.in?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,3 @@\n+# This spec file is read by gcc when linking.  It is used to specify the\n+# standard libraries we need in order to link with liboffloadmic_host.\n+*link_offloadmic_host: @link_offloadmic_host@"}, {"sha": "d679686684aa785179e075e345dc4e9fc4581c0d", "filename": "liboffloadmic/liboffloadmic_target.spec.in", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fliboffloadmic_target.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fliboffloadmic_target.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fliboffloadmic_target.spec.in?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,3 @@\n+# This spec file is read by gcc when linking.  It is used to specify the\n+# standard libraries we need in order to link with liboffloadmic_target.\n+*link_offloadmic_target: @link_offloadmic_target@"}, {"sha": "3258d7f3ade7d310b268ae2ed58ebd5cefba830e", "filename": "liboffloadmic/runtime/cean_util.cpp", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcean_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcean_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcean_util.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,366 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#include \"cean_util.h\"\n+#include \"offload_common.h\"\n+\n+// 1. allocate element of CeanReadRanges type\n+// 2. initialized it for reading consequently contiguous ranges\n+//    described by \"ap\" argument\n+CeanReadRanges * init_read_ranges_arr_desc(const arr_desc *ap)\n+{\n+    CeanReadRanges * res;\n+\n+    // find the max contiguous range\n+    int64_t rank = ap->rank - 1;\n+    int64_t length = ap->dim[rank].size;\n+    for (; rank >= 0; rank--) {\n+        if (ap->dim[rank].stride == 1) {\n+            length *= (ap->dim[rank].upper - ap->dim[rank].lower + 1);\n+            if (rank > 0 && length != ap->dim[rank - 1].size) {\n+                break;\n+            }\n+        }\n+        else {\n+            break;\n+        }\n+    }\n+\n+    res =(CeanReadRanges *)malloc(sizeof(CeanReadRanges) +\n+                                  (ap->rank - rank) * sizeof(CeanReadDim));\n+    if (res == NULL)\n+      LIBOFFLOAD_ERROR(c_malloc);\n+    res->current_number = 0;\n+    res->range_size = length;\n+    res->last_noncont_ind = rank;\n+\n+    // calculate number of contiguous ranges inside noncontiguous dimensions\n+    int count = 1;\n+    bool prev_is_cont = true;\n+    int64_t offset = 0;\n+\n+    for (; rank >= 0; rank--) {\n+        res->Dim[rank].count = count;\n+        res->Dim[rank].size = ap->dim[rank].stride * ap->dim[rank].size;\n+        count *= (prev_is_cont && ap->dim[rank].stride == 1? 1 :\n+            (ap->dim[rank].upper - ap->dim[rank].lower +\n+            ap->dim[rank].stride) / ap->dim[rank].stride);\n+        prev_is_cont = false;\n+        offset +=(ap->dim[rank].lower - ap->dim[rank].lindex) *\n+                 ap->dim[rank].size;\n+    }\n+    res->range_max_number = count;\n+    res -> ptr = (void*)ap->base;\n+    res -> init_offset = offset;\n+    return res;\n+}\n+\n+// check if ranges described by 1 argument could be transfered into ranges\n+// described by 2-nd one\n+bool cean_ranges_match(\n+    CeanReadRanges * read_rng1,\n+    CeanReadRanges * read_rng2\n+)\n+{\n+    return ( read_rng1 == NULL || read_rng2 == NULL ||\n+            (read_rng1->range_size % read_rng2->range_size == 0 ||\n+            read_rng2->range_size % read_rng1->range_size == 0));\n+}\n+\n+// Set next offset and length and returns true for next range.\n+// Returns false if the ranges are over.\n+bool get_next_range(\n+    CeanReadRanges * read_rng,\n+    int64_t *offset\n+)\n+{\n+    if (++read_rng->current_number > read_rng->range_max_number) {\n+        read_rng->current_number = 0;\n+        return false;\n+    }\n+    int rank = 0;\n+    int num = read_rng->current_number - 1;\n+    int64_t cur_offset = 0;\n+    int num_loc;\n+    for (; rank <= read_rng->last_noncont_ind; rank++) {\n+        num_loc = num / read_rng->Dim[rank].count;\n+        cur_offset += num_loc * read_rng->Dim[rank].size;\n+        num = num % read_rng->Dim[rank].count;\n+    }\n+    *offset = cur_offset + read_rng->init_offset;\n+    return true;\n+}\n+\n+bool is_arr_desc_contiguous(const arr_desc *ap)\n+{\n+    int64_t rank = ap->rank - 1;\n+    int64_t length = ap->dim[rank].size;\n+    for (; rank >= 0; rank--) {\n+        if (ap->dim[rank].stride > 1 &&\n+            ap->dim[rank].upper - ap->dim[rank].lower != 0) {\n+                return false;\n+        }\n+        else if (length != ap->dim[rank].size) {\n+            for (; rank >= 0; rank--) {\n+                if (ap->dim[rank].upper - ap->dim[rank].lower != 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        length *= (ap->dim[rank].upper - ap->dim[rank].lower + 1);\n+    }\n+    return true;\n+}\n+\n+int64_t cean_get_transf_size(CeanReadRanges * read_rng)\n+{\n+    return(read_rng->range_max_number * read_rng->range_size);\n+}\n+\n+static uint64_t last_left, last_right;\n+typedef void (*fpp)(const char *spaces, uint64_t low, uint64_t high, int esize);\n+\n+static void generate_one_range(\n+    const char *spaces,\n+    uint64_t lrange,\n+    uint64_t rrange,\n+    fpp fp,\n+    int esize\n+)\n+{\n+    OFFLOAD_TRACE(3,\n+        \"%s    generate_one_range(lrange=%p, rrange=%p, esize=%d)\\n\",\n+        spaces, (void*)lrange, (void*)rrange, esize);\n+    if (last_left == -1) {\n+        // First range\n+        last_left = lrange;\n+    }\n+    else {\n+        if (lrange == last_right+1) {\n+            // Extend previous range, don't print\n+        }\n+        else {\n+            (*fp)(spaces, last_left, last_right, esize);\n+            last_left = lrange;\n+        }\n+    }\n+    last_right = rrange;\n+}\n+\n+static void generate_mem_ranges_one_rank(\n+    const char *spaces,\n+    uint64_t base,\n+    uint64_t rank,\n+    const struct dim_desc *ddp,\n+    fpp fp,\n+    int esize\n+)\n+{\n+    uint64_t lindex = ddp->lindex;\n+    uint64_t lower = ddp->lower;\n+    uint64_t upper = ddp->upper;\n+    uint64_t stride = ddp->stride;\n+    uint64_t size = ddp->size;\n+    OFFLOAD_TRACE(3,\n+        \"%s    \"\n+        \"generate_mem_ranges_one_rank(base=%p, rank=%lld, lindex=%lld, \"\n+        \"lower=%lld, upper=%lld, stride=%lld, size=%lld, esize=%d)\\n\",\n+        spaces, (void*)base, rank, lindex, lower, upper, stride, size, esize);\n+    if (rank == 1) {\n+        uint64_t lrange, rrange;\n+        if (stride == 1) {\n+            lrange = base + (lower-lindex)*size;\n+            rrange = lrange + (upper-lower+1)*size - 1;\n+            generate_one_range(spaces, lrange, rrange, fp, esize);\n+        }\n+        else {\n+            for (int i=lower-lindex; i<=upper-lindex; i+=stride) {\n+                lrange = base + i*size;\n+                rrange = lrange + size - 1;\n+                generate_one_range(spaces, lrange, rrange, fp, esize);\n+            }\n+        }\n+    }\n+    else {\n+        for (int i=lower-lindex; i<=upper-lindex; i+=stride) {\n+            generate_mem_ranges_one_rank(\n+                spaces, base+i*size, rank-1, ddp+1, fp, esize);\n+\n+        }\n+    }\n+}\n+\n+static void generate_mem_ranges(\n+    const char *spaces,\n+    const arr_desc *adp,\n+    bool deref,\n+    fpp fp\n+)\n+{\n+    uint64_t esize;\n+\n+    OFFLOAD_TRACE(3,\n+        \"%s    \"\n+        \"generate_mem_ranges(adp=%p, deref=%d, fp)\\n\",\n+        spaces, adp, deref);\n+    last_left = -1;\n+    last_right = -2;\n+\n+    // Element size is derived from last dimension\n+    esize = adp->dim[adp->rank-1].size;\n+\n+    generate_mem_ranges_one_rank(\n+        // For c_cean_var the base addr is the address of the data\n+        // For c_cean_var_ptr the base addr is dereferenced to get to the data\n+        spaces, deref ? *((uint64_t*)(adp->base)) : adp->base,\n+        adp->rank, &adp->dim[0], fp, esize);\n+    (*fp)(spaces, last_left, last_right, esize);\n+}\n+\n+// returns offset and length of the data to be transferred\n+void __arr_data_offset_and_length(\n+    const arr_desc *adp,\n+    int64_t &offset,\n+    int64_t &length\n+)\n+{\n+    int64_t rank = adp->rank - 1;\n+    int64_t size = adp->dim[rank].size;\n+    int64_t r_off = 0; // offset from right boundary\n+\n+    // find the rightmost dimension which takes just part of its\n+    // range. We define it if the size of left rank is not equal\n+    // the range's length between upper and lower boungaries\n+    while (rank > 0) {\n+        size *= (adp->dim[rank].upper - adp->dim[rank].lower + 1);\n+        if (size != adp->dim[rank - 1].size) {\n+            break;\n+        }\n+        rank--;\n+    }\n+\n+    offset = (adp->dim[rank].lower - adp->dim[rank].lindex) *\n+             adp->dim[rank].size;\n+\n+    // find gaps both from the left - offset and from the right - r_off\n+    for (rank--; rank >= 0; rank--) {\n+        offset += (adp->dim[rank].lower - adp->dim[rank].lindex) *\n+                  adp->dim[rank].size;\n+        r_off += adp->dim[rank].size -\n+                 (adp->dim[rank + 1].upper - adp->dim[rank + 1].lindex + 1) *\n+                 adp->dim[rank + 1].size;\n+    }\n+    length = (adp->dim[0].upper - adp->dim[0].lindex + 1) *\n+             adp->dim[0].size - offset - r_off;\n+}\n+\n+#if OFFLOAD_DEBUG > 0\n+\n+void print_range(\n+    const char *spaces,\n+    uint64_t low,\n+    uint64_t high,\n+    int esize\n+)\n+{\n+    char buffer[1024];\n+    char number[32];\n+\n+    OFFLOAD_TRACE(3, \"%s        print_range(low=%p, high=%p, esize=%d)\\n\",\n+        spaces, (void*)low, (void*)high, esize);\n+\n+    if (console_enabled < 4) {\n+        return;\n+    }\n+    OFFLOAD_TRACE(4, \"%s            values:\\n\", spaces);\n+    int count = 0;\n+    buffer[0] = '\\0';\n+    while (low <= high)\n+    {\n+        switch (esize)\n+        {\n+        case 1:\n+            sprintf(number, \"%d \", *((char *)low));\n+            low += 1;\n+            break;\n+        case 2:\n+            sprintf(number, \"%d \", *((short *)low));\n+            low += 2;\n+            break;\n+        case 4:\n+            sprintf(number, \"%d \", *((int *)low));\n+            low += 4;\n+            break;\n+        default:\n+            sprintf(number, \"0x%016x \", *((uint64_t *)low));\n+            low += 8;\n+            break;\n+        }\n+        strcat(buffer, number);\n+        count++;\n+        if (count == 10) {\n+            OFFLOAD_TRACE(4, \"%s            %s\\n\", spaces, buffer);\n+            count = 0;\n+            buffer[0] = '\\0';\n+        }\n+    }\n+    if (count != 0) {\n+        OFFLOAD_TRACE(4, \"%s            %s\\n\", spaces, buffer);\n+    }\n+}\n+\n+void __arr_desc_dump(\n+    const char *spaces,\n+    const char *name,\n+    const arr_desc *adp,\n+    bool deref\n+)\n+{\n+    OFFLOAD_TRACE(2, \"%s%s CEAN expression %p\\n\", spaces, name, adp);\n+\n+    if (adp != 0) {\n+        OFFLOAD_TRACE(2, \"%s    base=%llx, rank=%lld\\n\",\n+            spaces, adp->base, adp->rank);\n+\n+        for (int i = 0; i < adp->rank; i++) {\n+            OFFLOAD_TRACE(2,\n+                          \"%s    dimension %d: size=%lld, lindex=%lld, \"\n+                          \"lower=%lld, upper=%lld, stride=%lld\\n\",\n+                          spaces, i, adp->dim[i].size, adp->dim[i].lindex,\n+                          adp->dim[i].lower, adp->dim[i].upper,\n+                          adp->dim[i].stride);\n+        }\n+        // For c_cean_var the base addr is the address of the data\n+        // For c_cean_var_ptr the base addr is dereferenced to get to the data\n+        generate_mem_ranges(spaces, adp, deref, &print_range);\n+    }\n+}\n+#endif // OFFLOAD_DEBUG"}, {"sha": "83140479269b75cd47e5617ec6a0810e285b584c", "filename": "liboffloadmic/runtime/cean_util.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcean_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcean_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcean_util.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,116 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#ifndef CEAN_UTIL_H_INCLUDED\n+#define CEAN_UTIL_H_INCLUDED\n+\n+#include <stdint.h>\n+\n+// CEAN expression representation\n+struct dim_desc {\n+    int64_t size;       // Length of data type\n+    int64_t lindex;     // Lower index\n+    int64_t lower;      // Lower section bound\n+    int64_t upper;      // Upper section bound\n+    int64_t stride;     // Stride\n+};\n+\n+struct arr_desc {\n+    int64_t base;       // Base address\n+    int64_t rank;       // Rank of array\n+    dim_desc dim[1];\n+};\n+\n+struct CeanReadDim {\n+    int64_t count; // The number of elements in this dimension\n+    int64_t size;  // The number of bytes between successive\n+                   // elements in this dimension.\n+};\n+\n+struct CeanReadRanges {\n+    void *  ptr;\n+    int64_t current_number;   // the number of ranges read\n+    int64_t range_max_number; // number of contiguous ranges\n+    int64_t range_size;       // size of max contiguous range\n+    int     last_noncont_ind; // size of Dim array\n+    int64_t init_offset;      // offset of 1-st element from array left bound\n+    CeanReadDim Dim[1];\n+};\n+\n+// array descriptor length\n+#define __arr_desc_length(rank) \\\n+    (sizeof(int64_t) + sizeof(dim_desc) * (rank))\n+\n+// returns offset and length of the data to be transferred\n+void __arr_data_offset_and_length(const arr_desc *adp,\n+                                  int64_t &offset,\n+                                  int64_t &length);\n+\n+// define if data array described by argument is contiguous one\n+bool is_arr_desc_contiguous(const arr_desc *ap);\n+\n+// allocate element of CeanReadRanges type initialized\n+// to read consequently contiguous ranges described by \"ap\" argument\n+CeanReadRanges * init_read_ranges_arr_desc(const arr_desc *ap);\n+\n+// check if ranges described by 1 argument could be transfered into ranges\n+// described by 2-nd one\n+bool cean_ranges_match(\n+    CeanReadRanges * read_rng1,\n+    CeanReadRanges * read_rng2\n+);\n+\n+// first argument - returned value by call to init_read_ranges_arr_desc.\n+// returns true if offset and length of next range is set successfuly.\n+// returns false if the ranges is over.\n+bool get_next_range(\n+    CeanReadRanges * read_rng,\n+    int64_t *offset\n+);\n+\n+// returns number of transfered bytes\n+int64_t cean_get_transf_size(CeanReadRanges * read_rng);\n+\n+#if OFFLOAD_DEBUG > 0\n+// prints array descriptor contents to stderr\n+void    __arr_desc_dump(\n+    const char *spaces,\n+    const char *name,\n+    const arr_desc *adp,\n+    bool dereference);\n+#else\n+#define __arr_desc_dump(\n+    spaces,\n+    name,\n+    adp,\n+    dereference)\n+#endif // OFFLOAD_DEBUG\n+\n+#endif // CEAN_UTIL_H_INCLUDED"}, {"sha": "0fb2c398855ab4710ef5555f145d1525b358edc8", "filename": "liboffloadmic/runtime/coi/coi_client.cpp", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,370 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+// The COI host interface\n+\n+#include \"coi_client.h\"\n+#include \"../offload_common.h\"\n+\n+namespace COI {\n+\n+#define COI_VERSION1    \"COI_1.0\"\n+#define COI_VERSION2    \"COI_2.0\"\n+\n+bool            is_available;\n+static void*    lib_handle;\n+\n+// pointers to functions from COI library\n+COIRESULT (*EngineGetCount)(COI_ISA_TYPE, uint32_t*);\n+COIRESULT (*EngineGetHandle)(COI_ISA_TYPE, uint32_t, COIENGINE*);\n+\n+COIRESULT (*ProcessCreateFromMemory)(COIENGINE, const char*, const void*,\n+                                     uint64_t, int, const char**, uint8_t,\n+                                     const char**, uint8_t, const char*,\n+                                     uint64_t, const char*, const char*,\n+                                     uint64_t, COIPROCESS*);\n+COIRESULT (*ProcessDestroy)(COIPROCESS, int32_t, uint8_t, int8_t*, uint32_t*);\n+COIRESULT (*ProcessGetFunctionHandles)(COIPROCESS, uint32_t, const char**,\n+                                       COIFUNCTION*);\n+COIRESULT (*ProcessLoadLibraryFromMemory)(COIPROCESS, const void*, uint64_t,\n+                                          const char*, const char*,\n+                                          const char*, uint64_t, uint32_t,\n+                                          COILIBRARY*);\n+COIRESULT (*ProcessRegisterLibraries)(uint32_t, const void**, const uint64_t*,\n+                                      const char**, const uint64_t*);\n+\n+COIRESULT (*PipelineCreate)(COIPROCESS, COI_CPU_MASK, uint32_t, COIPIPELINE*);\n+COIRESULT (*PipelineDestroy)(COIPIPELINE);\n+COIRESULT (*PipelineRunFunction)(COIPIPELINE, COIFUNCTION, uint32_t,\n+                                 const COIBUFFER*, const COI_ACCESS_FLAGS*,\n+                                 uint32_t, const COIEVENT*, const void*,\n+                                 uint16_t, void*, uint16_t, COIEVENT*);\n+\n+COIRESULT (*BufferCreate)(uint64_t, COI_BUFFER_TYPE, uint32_t, const void*,\n+                          uint32_t, const COIPROCESS*, COIBUFFER*);\n+COIRESULT (*BufferCreateFromMemory)(uint64_t, COI_BUFFER_TYPE, uint32_t,\n+                                    void*, uint32_t, const COIPROCESS*,\n+                                    COIBUFFER*);\n+COIRESULT (*BufferDestroy)(COIBUFFER);\n+COIRESULT (*BufferMap)(COIBUFFER, uint64_t, uint64_t, COI_MAP_TYPE, uint32_t,\n+                       const COIEVENT*, COIEVENT*, COIMAPINSTANCE*, void**);\n+COIRESULT (*BufferUnmap)(COIMAPINSTANCE, uint32_t, const COIEVENT*, COIEVENT*);\n+COIRESULT (*BufferWrite)(COIBUFFER, uint64_t, const void*, uint64_t,\n+                         COI_COPY_TYPE, uint32_t, const COIEVENT*, COIEVENT*);\n+COIRESULT (*BufferRead)(COIBUFFER, uint64_t, void*, uint64_t, COI_COPY_TYPE,\n+                        uint32_t, const COIEVENT*, COIEVENT*);\n+COIRESULT (*BufferCopy)(COIBUFFER, COIBUFFER, uint64_t, uint64_t, uint64_t,\n+                        COI_COPY_TYPE, uint32_t, const COIEVENT*, COIEVENT*);\n+COIRESULT (*BufferGetSinkAddress)(COIBUFFER, uint64_t*);\n+COIRESULT (*BufferSetState)(COIBUFFER, COIPROCESS, COI_BUFFER_STATE,\n+                            COI_BUFFER_MOVE_FLAG, uint32_t,\n+                            const   COIEVENT*, COIEVENT*);\n+\n+COIRESULT (*EventWait)(uint16_t, const COIEVENT*, int32_t, uint8_t, uint32_t*,\n+                       uint32_t*);\n+\n+uint64_t  (*PerfGetCycleFrequency)(void);\n+\n+bool init(void)\n+{\n+#ifndef TARGET_WINNT\n+    const char *lib_name = \"libcoi_host.so.0\";\n+#else // TARGET_WINNT\n+    const char *lib_name = \"coi_host.dll\";\n+#endif // TARGET_WINNT\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Loading COI library %s ...\\n\", lib_name);\n+    lib_handle = DL_open(lib_name);\n+    if (lib_handle == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to load the library\\n\");\n+        return false;\n+    }\n+\n+    EngineGetCount =\n+        (COIRESULT (*)(COI_ISA_TYPE, uint32_t*))\n+            DL_sym(lib_handle, \"COIEngineGetCount\", COI_VERSION1);\n+    if (EngineGetCount == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIEngineGetCount\");\n+        fini();\n+        return false;\n+    }\n+\n+    EngineGetHandle =\n+        (COIRESULT (*)(COI_ISA_TYPE, uint32_t, COIENGINE*))\n+            DL_sym(lib_handle, \"COIEngineGetHandle\", COI_VERSION1);\n+    if (EngineGetHandle == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIEngineGetHandle\");\n+        fini();\n+        return false;\n+    }\n+\n+    ProcessCreateFromMemory =\n+        (COIRESULT (*)(COIENGINE, const char*, const void*, uint64_t, int,\n+                       const char**, uint8_t, const char**, uint8_t,\n+                       const char*, uint64_t, const char*, const char*,\n+                       uint64_t, COIPROCESS*))\n+            DL_sym(lib_handle, \"COIProcessCreateFromMemory\", COI_VERSION1);\n+    if (ProcessCreateFromMemory == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIProcessCreateFromMemory\");\n+        fini();\n+        return false;\n+    }\n+\n+    ProcessDestroy =\n+        (COIRESULT (*)(COIPROCESS, int32_t, uint8_t, int8_t*,\n+                       uint32_t*))\n+            DL_sym(lib_handle, \"COIProcessDestroy\", COI_VERSION1);\n+    if (ProcessDestroy == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIProcessDestroy\");\n+        fini();\n+        return false;\n+    }\n+\n+    ProcessGetFunctionHandles =\n+        (COIRESULT (*)(COIPROCESS, uint32_t, const char**, COIFUNCTION*))\n+            DL_sym(lib_handle, \"COIProcessGetFunctionHandles\", COI_VERSION1);\n+    if (ProcessGetFunctionHandles == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIProcessGetFunctionHandles\");\n+        fini();\n+        return false;\n+    }\n+\n+    ProcessLoadLibraryFromMemory =\n+        (COIRESULT (*)(COIPROCESS, const void*, uint64_t, const char*,\n+                       const char*, const char*, uint64_t, uint32_t,\n+                       COILIBRARY*))\n+            DL_sym(lib_handle, \"COIProcessLoadLibraryFromMemory\", COI_VERSION2);\n+    if (ProcessLoadLibraryFromMemory == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIProcessLoadLibraryFromMemory\");\n+        fini();\n+        return false;\n+    }\n+\n+    ProcessRegisterLibraries =\n+        (COIRESULT (*)(uint32_t, const void**, const uint64_t*, const char**,\n+                       const uint64_t*))\n+            DL_sym(lib_handle, \"COIProcessRegisterLibraries\", COI_VERSION1);\n+    if (ProcessRegisterLibraries == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIProcessRegisterLibraries\");\n+        fini();\n+        return false;\n+    }\n+\n+    PipelineCreate =\n+        (COIRESULT (*)(COIPROCESS, COI_CPU_MASK, uint32_t, COIPIPELINE*))\n+            DL_sym(lib_handle, \"COIPipelineCreate\", COI_VERSION1);\n+    if (PipelineCreate == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIPipelineCreate\");\n+        fini();\n+        return false;\n+    }\n+\n+    PipelineDestroy =\n+        (COIRESULT (*)(COIPIPELINE))\n+            DL_sym(lib_handle, \"COIPipelineDestroy\", COI_VERSION1);\n+    if (PipelineDestroy == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIPipelineDestroy\");\n+        fini();\n+        return false;\n+    }\n+\n+    PipelineRunFunction =\n+        (COIRESULT (*)(COIPIPELINE, COIFUNCTION, uint32_t, const COIBUFFER*,\n+                       const COI_ACCESS_FLAGS*, uint32_t, const COIEVENT*,\n+                       const void*, uint16_t, void*, uint16_t, COIEVENT*))\n+            DL_sym(lib_handle, \"COIPipelineRunFunction\", COI_VERSION1);\n+    if (PipelineRunFunction == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIPipelineRunFunction\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferCreate =\n+        (COIRESULT (*)(uint64_t, COI_BUFFER_TYPE, uint32_t, const void*,\n+                       uint32_t, const COIPROCESS*, COIBUFFER*))\n+            DL_sym(lib_handle, \"COIBufferCreate\", COI_VERSION1);\n+    if (BufferCreate == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferCreate\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferCreateFromMemory =\n+        (COIRESULT (*)(uint64_t, COI_BUFFER_TYPE, uint32_t, void*,\n+                       uint32_t, const COIPROCESS*, COIBUFFER*))\n+            DL_sym(lib_handle, \"COIBufferCreateFromMemory\", COI_VERSION1);\n+    if (BufferCreateFromMemory == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferCreateFromMemory\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferDestroy =\n+        (COIRESULT (*)(COIBUFFER))\n+            DL_sym(lib_handle, \"COIBufferDestroy\", COI_VERSION1);\n+    if (BufferDestroy == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferDestroy\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferMap =\n+        (COIRESULT (*)(COIBUFFER, uint64_t, uint64_t, COI_MAP_TYPE, uint32_t,\n+                       const COIEVENT*, COIEVENT*, COIMAPINSTANCE*,\n+                       void**))\n+            DL_sym(lib_handle, \"COIBufferMap\", COI_VERSION1);\n+    if (BufferMap == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferMap\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferUnmap =\n+        (COIRESULT (*)(COIMAPINSTANCE, uint32_t, const COIEVENT*,\n+                       COIEVENT*))\n+            DL_sym(lib_handle, \"COIBufferUnmap\", COI_VERSION1);\n+    if (BufferUnmap == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferUnmap\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferWrite =\n+        (COIRESULT (*)(COIBUFFER, uint64_t, const void*, uint64_t,\n+                       COI_COPY_TYPE, uint32_t, const COIEVENT*,\n+                       COIEVENT*))\n+            DL_sym(lib_handle, \"COIBufferWrite\", COI_VERSION1);\n+    if (BufferWrite == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferWrite\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferRead =\n+        (COIRESULT (*)(COIBUFFER, uint64_t, void*, uint64_t,\n+                                     COI_COPY_TYPE, uint32_t,\n+                                     const COIEVENT*, COIEVENT*))\n+            DL_sym(lib_handle, \"COIBufferRead\", COI_VERSION1);\n+    if (BufferRead == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferRead\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferCopy =\n+        (COIRESULT (*)(COIBUFFER, COIBUFFER, uint64_t, uint64_t, uint64_t,\n+                       COI_COPY_TYPE, uint32_t, const COIEVENT*,\n+                       COIEVENT*))\n+            DL_sym(lib_handle, \"COIBufferCopy\", COI_VERSION1);\n+    if (BufferCopy == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferCopy\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferGetSinkAddress =\n+        (COIRESULT (*)(COIBUFFER, uint64_t*))\n+            DL_sym(lib_handle, \"COIBufferGetSinkAddress\", COI_VERSION1);\n+    if (BufferGetSinkAddress == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferGetSinkAddress\");\n+        fini();\n+        return false;\n+    }\n+\n+    BufferSetState =\n+        (COIRESULT(*)(COIBUFFER, COIPROCESS, COI_BUFFER_STATE,\n+                      COI_BUFFER_MOVE_FLAG, uint32_t, const COIEVENT*,\n+                      COIEVENT*))\n+            DL_sym(lib_handle, \"COIBufferSetState\", COI_VERSION1);\n+    if (BufferSetState == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIBufferSetState\");\n+        fini();\n+        return false;\n+    }\n+\n+    EventWait =\n+        (COIRESULT (*)(uint16_t, const COIEVENT*, int32_t, uint8_t,\n+                       uint32_t*, uint32_t*))\n+            DL_sym(lib_handle, \"COIEventWait\", COI_VERSION1);\n+    if (EventWait == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIEventWait\");\n+        fini();\n+        return false;\n+    }\n+\n+    PerfGetCycleFrequency =\n+        (uint64_t (*)(void))\n+            DL_sym(lib_handle, \"COIPerfGetCycleFrequency\", COI_VERSION1);\n+    if (PerfGetCycleFrequency == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIPerfGetCycleFrequency\");\n+        fini();\n+        return false;\n+    }\n+\n+    is_available = true;\n+\n+    return true;\n+}\n+\n+void fini(void)\n+{\n+    is_available = false;\n+\n+    if (lib_handle != 0) {\n+#ifndef TARGET_WINNT\n+        DL_close(lib_handle);\n+#endif // TARGET_WINNT\n+        lib_handle = 0;\n+    }\n+}\n+\n+} // namespace COI"}, {"sha": "54b83a9d96507c34487f95566bff4512f066e9c9", "filename": "liboffloadmic/runtime/coi/coi_client.h", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,138 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+// The interface betwen offload library and the COI API on the host\n+\n+#ifndef COI_CLIENT_H_INCLUDED\n+#define COI_CLIENT_H_INCLUDED\n+\n+#include <common/COIPerf_common.h>\n+#include <source/COIEngine_source.h>\n+#include <source/COIProcess_source.h>\n+#include <source/COIPipeline_source.h>\n+#include <source/COIBuffer_source.h>\n+#include <source/COIEvent_source.h>\n+\n+#include <string.h>\n+\n+#include \"../liboffload_error_codes.h\"\n+#include \"../offload_util.h\"\n+\n+#define MIC_ENGINES_MAX     128\n+\n+#if MIC_ENGINES_MAX < COI_MAX_ISA_MIC_DEVICES\n+#error MIC_ENGINES_MAX need to be increased\n+#endif\n+\n+// COI library interface\n+namespace COI {\n+\n+extern bool init(void);\n+extern void fini(void);\n+\n+extern bool is_available;\n+\n+// pointers to functions from COI library\n+extern COIRESULT (*EngineGetCount)(COI_ISA_TYPE, uint32_t*);\n+extern COIRESULT (*EngineGetHandle)(COI_ISA_TYPE, uint32_t, COIENGINE*);\n+\n+extern COIRESULT (*ProcessCreateFromMemory)(COIENGINE, const char*,\n+                                           const void*, uint64_t, int,\n+                                           const char**, uint8_t,\n+                                           const char**, uint8_t,\n+                                           const char*, uint64_t,\n+                                           const char*,\n+                                           const char*, uint64_t,\n+                                           COIPROCESS*);\n+extern COIRESULT (*ProcessDestroy)(COIPROCESS, int32_t, uint8_t,\n+                                  int8_t*, uint32_t*);\n+extern COIRESULT (*ProcessGetFunctionHandles)(COIPROCESS, uint32_t,\n+                                             const char**,\n+                                             COIFUNCTION*);\n+extern COIRESULT (*ProcessLoadLibraryFromMemory)(COIPROCESS,\n+                                                const void*,\n+                                                uint64_t,\n+                                                const char*,\n+                                                const char*,\n+                                                const char*,\n+                                                uint64_t,\n+                                                uint32_t,\n+                                                COILIBRARY*);\n+extern COIRESULT (*ProcessRegisterLibraries)(uint32_t,\n+                                            const void**,\n+                                            const uint64_t*,\n+                                            const char**,\n+                                            const uint64_t*);\n+\n+extern COIRESULT (*PipelineCreate)(COIPROCESS, COI_CPU_MASK, uint32_t,\n+                                  COIPIPELINE*);\n+extern COIRESULT (*PipelineDestroy)(COIPIPELINE);\n+extern COIRESULT (*PipelineRunFunction)(COIPIPELINE, COIFUNCTION,\n+                                       uint32_t, const COIBUFFER*,\n+                                       const COI_ACCESS_FLAGS*,\n+                                       uint32_t, const COIEVENT*,\n+                                       const void*, uint16_t, void*,\n+                                       uint16_t, COIEVENT*);\n+\n+extern COIRESULT (*BufferCreate)(uint64_t, COI_BUFFER_TYPE, uint32_t,\n+                                const void*, uint32_t,\n+                                const COIPROCESS*, COIBUFFER*);\n+extern COIRESULT (*BufferCreateFromMemory)(uint64_t, COI_BUFFER_TYPE,\n+                                          uint32_t, void*,\n+                                          uint32_t, const COIPROCESS*,\n+                                          COIBUFFER*);\n+extern COIRESULT (*BufferDestroy)(COIBUFFER);\n+extern COIRESULT (*BufferMap)(COIBUFFER, uint64_t, uint64_t,\n+                             COI_MAP_TYPE, uint32_t, const COIEVENT*,\n+                             COIEVENT*, COIMAPINSTANCE*, void**);\n+extern COIRESULT (*BufferUnmap)(COIMAPINSTANCE, uint32_t,\n+                               const COIEVENT*, COIEVENT*);\n+extern COIRESULT (*BufferWrite)(COIBUFFER, uint64_t, const void*,\n+                               uint64_t, COI_COPY_TYPE, uint32_t,\n+                               const COIEVENT*, COIEVENT*);\n+extern COIRESULT (*BufferRead)(COIBUFFER, uint64_t, void*, uint64_t,\n+                              COI_COPY_TYPE, uint32_t,\n+                              const COIEVENT*, COIEVENT*);\n+extern COIRESULT (*BufferCopy)(COIBUFFER, COIBUFFER, uint64_t, uint64_t,\n+                              uint64_t, COI_COPY_TYPE, uint32_t,\n+                              const COIEVENT*, COIEVENT*);\n+extern COIRESULT (*BufferGetSinkAddress)(COIBUFFER, uint64_t*);\n+extern COIRESULT (*BufferSetState)(COIBUFFER, COIPROCESS, COI_BUFFER_STATE,\n+                                   COI_BUFFER_MOVE_FLAG, uint32_t,\n+                                   const   COIEVENT*, COIEVENT*);\n+\n+extern COIRESULT (*EventWait)(uint16_t, const COIEVENT*, int32_t,\n+                           uint8_t, uint32_t*, uint32_t*);\n+\n+extern uint64_t  (*PerfGetCycleFrequency)(void);\n+\n+} // namespace COI\n+\n+#endif // COI_CLIENT_H_INCLUDED"}, {"sha": "7eebf5a306e6a0c626eea21c8fdb186c1300494d", "filename": "liboffloadmic/runtime/coi/coi_server.cpp", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,150 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+// The COI interface on the target\n+\n+#include \"coi_server.h\"\n+\n+#include \"../offload_target.h\"\n+#include \"../offload_timer.h\"\n+#ifdef MYO_SUPPORT\n+#include \"../offload_myo_target.h\"      // for __offload_myoLibInit/Fini\n+#endif // MYO_SUPPORT\n+\n+COINATIVELIBEXPORT\n+void server_compute(\n+    uint32_t  buffer_count,\n+    void**    buffers,\n+    uint64_t* buffers_len,\n+    void*     misc_data,\n+    uint16_t  misc_data_len,\n+    void*     return_data,\n+    uint16_t  return_data_len\n+)\n+{\n+    OffloadDescriptor::offload(buffer_count, buffers,\n+                               misc_data, misc_data_len,\n+                               return_data, return_data_len);\n+}\n+\n+COINATIVELIBEXPORT\n+void server_init(\n+    uint32_t  buffer_count,\n+    void**    buffers,\n+    uint64_t* buffers_len,\n+    void*     misc_data,\n+    uint16_t  misc_data_len,\n+    void*     return_data,\n+    uint16_t  return_data_len\n+)\n+{\n+    struct init_data {\n+        int  device_index;\n+        int  devices_total;\n+        int  console_level;\n+        int  offload_report_level;\n+    } *data = (struct init_data*) misc_data;\n+\n+    // set device index and number of total devices\n+    mic_index = data->device_index;\n+    mic_engines_total = data->devices_total;\n+\n+    // initialize trace level\n+    console_enabled = data->console_level;\n+    offload_report_level = data->offload_report_level;\n+\n+    // return back the process id\n+    *((pid_t*) return_data) = getpid();\n+}\n+\n+COINATIVELIBEXPORT\n+void server_var_table_size(\n+    uint32_t  buffer_count,\n+    void**    buffers,\n+    uint64_t* buffers_len,\n+    void*     misc_data,\n+    uint16_t  misc_data_len,\n+    void*     return_data,\n+    uint16_t  return_data_len\n+)\n+{\n+    struct Params {\n+        int64_t nelems;\n+        int64_t length;\n+    } *params;\n+\n+    params = static_cast<Params*>(return_data);\n+    params->length = __offload_vars.table_size(params->nelems);\n+}\n+\n+COINATIVELIBEXPORT\n+void server_var_table_copy(\n+    uint32_t  buffer_count,\n+    void**    buffers,\n+    uint64_t* buffers_len,\n+    void*     misc_data,\n+    uint16_t  misc_data_len,\n+    void*     return_data,\n+    uint16_t  return_data_len\n+)\n+{\n+    __offload_vars.table_copy(buffers[0], *static_cast<int64_t*>(misc_data));\n+}\n+\n+#ifdef MYO_SUPPORT\n+// temporary workaround for blocking behavior of myoiLibInit/Fini calls\n+COINATIVELIBEXPORT\n+void server_myoinit(\n+    uint32_t  buffer_count,\n+    void**    buffers,\n+    uint64_t* buffers_len,\n+    void*     misc_data,\n+    uint16_t  misc_data_len,\n+    void*     return_data,\n+    uint16_t  return_data_len\n+)\n+{\n+    __offload_myoLibInit();\n+}\n+\n+COINATIVELIBEXPORT\n+void server_myofini(\n+    uint32_t  buffer_count,\n+    void**    buffers,\n+    uint64_t* buffers_len,\n+    void*     misc_data,\n+    uint16_t  misc_data_len,\n+    void*     return_data,\n+    uint16_t  return_data_len\n+)\n+{\n+    __offload_myoLibFini();\n+}\n+#endif // MYO_SUPPORT"}, {"sha": "14376108e9dc5e433335f6b41a16bcba95d1db34", "filename": "liboffloadmic/runtime/coi/coi_server.h", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,94 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+//The interface betwen offload library and the COI API on the target.\n+\n+#ifndef COI_SERVER_H_INCLUDED\n+#define COI_SERVER_H_INCLUDED\n+\n+#include <common/COIEngine_common.h>\n+#include <common/COIPerf_common.h>\n+#include <sink/COIProcess_sink.h>\n+#include <sink/COIPipeline_sink.h>\n+#include <sink/COIBuffer_sink.h>\n+#include <list>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include \"../liboffload_error_codes.h\"\n+\n+// wrappers for COI API\n+#define PipelineStartExecutingRunFunctions() \\\n+    { \\\n+        COIRESULT res = COIPipelineStartExecutingRunFunctions(); \\\n+        if (res != COI_SUCCESS) { \\\n+            LIBOFFLOAD_ERROR(c_pipeline_start_run_funcs, mic_index, res); \\\n+            exit(1); \\\n+        } \\\n+    }\n+\n+#define ProcessWaitForShutdown() \\\n+    { \\\n+        COIRESULT res = COIProcessWaitForShutdown(); \\\n+        if (res != COI_SUCCESS) { \\\n+            LIBOFFLOAD_ERROR(c_process_wait_shutdown, mic_index, res); \\\n+            exit(1); \\\n+        } \\\n+    }\n+\n+#define BufferAddRef(buf) \\\n+    { \\\n+        COIRESULT res = COIBufferAddRef(buf); \\\n+        if (res != COI_SUCCESS) { \\\n+            LIBOFFLOAD_ERROR(c_buf_add_ref, mic_index, res); \\\n+            exit(1); \\\n+        } \\\n+    }\n+\n+#define BufferReleaseRef(buf) \\\n+    { \\\n+        COIRESULT res = COIBufferReleaseRef(buf); \\\n+        if (res != COI_SUCCESS) { \\\n+            LIBOFFLOAD_ERROR(c_buf_release_ref, mic_index, res); \\\n+            exit(1); \\\n+        } \\\n+    }\n+\n+#define EngineGetIndex(index) \\\n+    { \\\n+        COI_ISA_TYPE isa_type; \\\n+        COIRESULT res = COIEngineGetIndex(&isa_type, index); \\\n+        if (res != COI_SUCCESS) { \\\n+            LIBOFFLOAD_ERROR(c_get_engine_index, mic_index, res); \\\n+            exit(1); \\\n+        } \\\n+    }\n+\n+#endif // COI_SERVER_H_INCLUDED"}, {"sha": "c4e2a15633f7182037d7852fbc190a56f11c7283", "filename": "liboffloadmic/runtime/compiler_if_host.cpp", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,343 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#include \"compiler_if_host.h\"\n+\n+#include <malloc.h>\n+#ifndef TARGET_WINNT\n+#include <alloca.h>\n+#endif // TARGET_WINNT\n+\n+// Global counter on host. \n+// This variable is used if P2OPT_offload_do_data_persistence == 2.\n+// The variable used to identify offload constructs contained in one procedure.\n+// Increment of OFFLOAD_CALL_COUNT is inserted at entries of HOST routines with\n+// offload constructs.\n+static int offload_call_count = 0;\n+\n+extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE(\n+    TARGET_TYPE      target_type,\n+    int              target_number,\n+    int              is_optional,\n+    _Offload_status* status,\n+    const char*      file,\n+    uint64_t         line\n+)\n+{\n+    bool retval;\n+    OFFLOAD ofld;\n+\n+    // initialize status\n+    if (status != 0) {\n+        status->result = OFFLOAD_UNAVAILABLE;\n+        status->device_number = -1;\n+        status->data_sent = 0;\n+        status->data_received = 0;\n+    }\n+\n+    // make sure libray is initialized\n+    retval = __offload_init_library();\n+\n+    // OFFLOAD_TIMER_INIT must follow call to __offload_init_library\n+    OffloadHostTimerData * timer_data = OFFLOAD_TIMER_INIT(file, line);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_total_offload);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n+\n+    // initalize all devices is init_type is on_offload_all\n+    if (retval && __offload_init_type == c_init_on_offload_all) {\n+        for (int i = 0; i < mic_engines_total; i++) {\n+             mic_engines[i].init();\n+        }\n+    }\n+    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_target_acquire);\n+\n+    if (target_type == TARGET_HOST) {\n+        // Host always available\n+        retval = true;\n+    }\n+    else if (target_type == TARGET_MIC) {\n+        if (target_number >= -1) {\n+            if (retval) {\n+                if (target_number >= 0) {\n+                    // User provided the device number\n+                    target_number = target_number % mic_engines_total;\n+                }\n+                else {\n+                    // use device 0\n+                    target_number = 0;\n+                }\n+\n+                // reserve device in ORSL\n+                if (is_optional) {\n+                    if (!ORSL::try_reserve(target_number)) {\n+                        target_number = -1;\n+                    }\n+                }\n+                else {\n+                    if (!ORSL::reserve(target_number)) {\n+                        target_number = -1;\n+                    }\n+                }\n+\n+                // initialize device\n+                if (target_number >= 0 &&\n+                    __offload_init_type == c_init_on_offload) {\n+                    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n+                    mic_engines[target_number].init();\n+                    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n+                }\n+            }\n+            else {\n+                // fallback to CPU\n+                target_number = -1;\n+            }\n+\n+            if (target_number < 0 || !retval) {\n+                if (!is_optional && status == 0) {\n+                    LIBOFFLOAD_ERROR(c_device_is_not_available);\n+                    exit(1);\n+                }\n+\n+                retval = false;\n+            }\n+        }\n+        else {\n+            LIBOFFLOAD_ERROR(c_invalid_device_number);\n+            exit(1);\n+        }\n+    }\n+\n+    if (retval) {\n+        ofld = new OffloadDescriptor(target_number, status,\n+                                     !is_optional, false, timer_data);\n+        OFFLOAD_TIMER_HOST_MIC_NUM(timer_data, target_number);\n+        Offload_Report_Prolog(timer_data);\n+        OFFLOAD_DEBUG_TRACE_1(2, timer_data->offload_number, c_offload_start,\n+                              \"Starting offload: target_type = %d, \"\n+                              \"number = %d, is_optional = %d\\n\",\n+                              target_type, target_number, is_optional);\n+\n+        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n+    }\n+    else {\n+        ofld = NULL;\n+\n+        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n+        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_total_offload);\n+        offload_report_free_data(timer_data);\n+    }\n+\n+    return ofld;\n+}\n+\n+extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE1(\n+    const int*  device_num,\n+    const char* file,\n+    uint64_t    line\n+)\n+{\n+    int target_number;\n+\n+    // make sure libray is initialized and at least one device is available\n+    if (!__offload_init_library()) {\n+        LIBOFFLOAD_ERROR(c_device_is_not_available);\n+        exit(1);\n+    }\n+\n+    // OFFLOAD_TIMER_INIT must follow call to __offload_init_library\n+\n+    OffloadHostTimerData * timer_data = OFFLOAD_TIMER_INIT(file, line);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_total_offload);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n+\n+    if (__offload_init_type == c_init_on_offload_all) {\n+        for (int i = 0; i < mic_engines_total; i++) {\n+             mic_engines[i].init();\n+        }\n+    }\n+\n+    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_target_acquire);\n+\n+    // use default device number if it is not provided\n+    if (device_num != 0) {\n+        target_number = *device_num;\n+    }\n+    else {\n+        target_number = __omp_device_num;\n+    }\n+\n+    // device number should be a non-negative integer value\n+    if (target_number < 0) {\n+        LIBOFFLOAD_ERROR(c_omp_invalid_device_num);\n+        exit(1);\n+    }\n+\n+    // should we do this for OpenMP?\n+    target_number %= mic_engines_total;\n+\n+    // reserve device in ORSL\n+    if (!ORSL::reserve(target_number)) {\n+        LIBOFFLOAD_ERROR(c_device_is_not_available);\n+        exit(1);\n+    }\n+\n+    // initialize device(s)\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n+\n+    if (__offload_init_type == c_init_on_offload) {\n+        mic_engines[target_number].init();\n+    }\n+\n+    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n+\n+    OFFLOAD ofld =\n+        new OffloadDescriptor(target_number, 0, true, true, timer_data);\n+\n+    OFFLOAD_TIMER_HOST_MIC_NUM(timer_data, target_number);\n+\n+    Offload_Report_Prolog(timer_data);\n+\n+    OFFLOAD_DEBUG_TRACE_1(2, timer_data->offload_number, c_offload_start,\n+                          \"Starting OpenMP offload, device = %d\\n\",\n+                          target_number);\n+\n+    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n+\n+    return ofld;\n+}\n+\n+int offload_offload_wrap(\n+    OFFLOAD ofld,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void **waits,\n+    const void **signal,\n+    int entry_id,\n+    const void *stack_addr\n+)\n+{\n+    bool ret = ofld->offload(name, is_empty, vars, vars2, num_vars,\n+                             waits, num_waits, signal, entry_id, stack_addr);\n+    if (!ret || signal == 0) {\n+        delete ofld;\n+    }\n+    return ret;\n+}\n+\n+extern \"C\" int OFFLOAD_OFFLOAD1(\n+    OFFLOAD ofld,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void **waits,\n+    const void **signal\n+)\n+{\n+    return offload_offload_wrap(ofld, name, is_empty,\n+                            num_vars, vars, vars2,\n+                            num_waits, waits,\n+                            signal, NULL, NULL);\n+}\n+\n+extern \"C\" int OFFLOAD_OFFLOAD2(\n+    OFFLOAD ofld,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void** waits,\n+    const void** signal,\n+    int entry_id,\n+    const void *stack_addr\n+)\n+{\n+    return offload_offload_wrap(ofld, name, is_empty,\n+                            num_vars, vars, vars2,\n+                            num_waits, waits,\n+                            signal, entry_id, stack_addr);\n+}\n+\n+extern \"C\" int OFFLOAD_OFFLOAD(\n+    OFFLOAD ofld,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void **waits,\n+    const void *signal,\n+    int entry_id,\n+    const void *stack_addr\n+)\n+{\n+    // signal is passed by reference now\n+    const void **signal_new = (signal != 0) ? &signal : 0;\n+    const void **waits_new = 0;\n+    int num_waits_new = 0;\n+\n+    // remove NULL values from the list of signals to wait for\n+    if (num_waits > 0) {\n+        waits_new = (const void**) alloca(sizeof(void*) * num_waits);\n+        for (int i = 0; i < num_waits; i++) {\n+            if (waits[i] != 0) {\n+                waits_new[num_waits_new++] = waits[i];\n+            }\n+        }\n+    }\n+\n+    return OFFLOAD_OFFLOAD1(ofld, name, is_empty,\n+                            num_vars, vars, vars2,\n+                            num_waits_new, waits_new,\n+                            signal_new);\n+}\n+\n+extern \"C\" int OFFLOAD_CALL_COUNT()\n+{\n+    offload_call_count++;\n+    return offload_call_count;\n+}"}, {"sha": "1a7135088f622847da33b3c73ff0d907e6f5f884", "filename": "liboffloadmic/runtime/compiler_if_host.h", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcompiler_if_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcompiler_if_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_host.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,153 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+/*! \\file\n+    \\brief The interface between compiler-generated host code and runtime library\n+*/\n+\n+#ifndef COMPILER_IF_HOST_H_INCLUDED\n+#define COMPILER_IF_HOST_H_INCLUDED\n+\n+#include \"offload_host.h\"\n+\n+#define OFFLOAD_TARGET_ACQUIRE          OFFLOAD_PREFIX(target_acquire)\n+#define OFFLOAD_TARGET_ACQUIRE1         OFFLOAD_PREFIX(target_acquire1)\n+#define OFFLOAD_OFFLOAD                 OFFLOAD_PREFIX(offload)\n+#define OFFLOAD_OFFLOAD1                OFFLOAD_PREFIX(offload1)\n+#define OFFLOAD_OFFLOAD2                OFFLOAD_PREFIX(offload2)\n+#define OFFLOAD_CALL_COUNT              OFFLOAD_PREFIX(offload_call_count)\n+\n+\n+/*! \\fn OFFLOAD_TARGET_ACQUIRE\n+    \\brief Attempt to acquire the target.\n+    \\param target_type   The type of target.\n+    \\param target_number The device number.\n+    \\param is_optional   Whether CPU fall-back is allowed.\n+    \\param status        Address of variable to hold offload status.\n+    \\param file          Filename in which this offload occurred.\n+    \\param line          Line number in the file where this offload occurred.\n+*/\n+extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE(\n+    TARGET_TYPE      target_type,\n+    int              target_number,\n+    int              is_optional,\n+    _Offload_status* status,\n+    const char*      file,\n+    uint64_t         line\n+);\n+\n+/*! \\fn OFFLOAD_TARGET_ACQUIRE1\n+    \\brief Acquire the target for offload (OpenMP).\n+    \\param device_number Device number or null if not specified.\n+    \\param file          Filename in which this offload occurred\n+    \\param line          Line number in the file where this offload occurred.\n+*/\n+extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE1(\n+    const int*      device_number,\n+    const char*     file,\n+    uint64_t        line\n+);\n+\n+/*! \\fn OFFLOAD_OFFLOAD1\n+    \\brief Run function on target using interface for old data persistence.\n+    \\param o Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n+    \\param name Name of offload entry point.\n+    \\param is_empty If no code to execute (e.g. offload_transfer)\n+    \\param num_vars Number of variable descriptors.\n+    \\param vars Pointer to VarDesc array.\n+    \\param vars2 Pointer to VarDesc2 array.\n+    \\param num_waits Number of \"wait\" values.\n+    \\param waits Pointer to array of wait values.\n+    \\param signal Pointer to signal value or NULL.\n+*/\n+extern \"C\" int OFFLOAD_OFFLOAD1(\n+    OFFLOAD o,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void** waits,\n+    const void** signal\n+);\n+\n+/*! \\fn OFFLOAD_OFFLOAD2\n+    \\brief Run function on target using interface for new data persistence.\n+    \\param o Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n+    \\param name Name of offload entry point.\n+    \\param is_empty If no code to execute (e.g. offload_transfer)\n+    \\param num_vars Number of variable descriptors.\n+    \\param vars Pointer to VarDesc array.\n+    \\param vars2 Pointer to VarDesc2 array.\n+    \\param num_waits Number of \"wait\" values.\n+    \\param waits Pointer to array of wait values.\n+    \\param signal Pointer to signal value or NULL.\n+    \\param entry_id A signature for the function doing the offload.\n+    \\param stack_addr The stack frame address of the function doing offload.\n+*/\n+extern \"C\" int OFFLOAD_OFFLOAD2(\n+    OFFLOAD o,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void** waits,\n+    const void** signal,\n+    int entry_id,\n+    const void *stack_addr\n+);\n+\n+// Run function on target (obsolete).\n+// @param o    OFFLOAD object\n+// @param name function name\n+extern \"C\" int OFFLOAD_OFFLOAD(\n+    OFFLOAD o,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void** waits,\n+    const void* signal,\n+    int entry_id = 0,\n+    const void *stack_addr = NULL\n+);\n+\n+// Global counter on host.\n+// This variable is used if P2OPT_offload_do_data_persistence == 2.\n+// The variable used to identify offload constructs contained in one procedure.\n+// Call to OFFLOAD_CALL_COUNT() is inserted at HOST on entry of the routine.\n+extern \"C\" int  OFFLOAD_CALL_COUNT();\n+\n+#endif // COMPILER_IF_HOST_H_INCLUDED"}, {"sha": "839ef14ed63b75245f741ddba06721286a7ffc02", "filename": "liboffloadmic/runtime/compiler_if_target.cpp", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,64 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#include \"compiler_if_target.h\"\n+\n+extern \"C\" void OFFLOAD_TARGET_ENTER(\n+    OFFLOAD ofld,\n+    int vars_total,\n+    VarDesc *vars,\n+    VarDesc2 *vars2\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%p, %d, %p, %p)\\n\", __func__, ofld,\n+                        vars_total, vars, vars2);\n+    ofld->merge_var_descs(vars, vars2, vars_total);\n+    ofld->scatter_copyin_data();\n+}\n+\n+extern \"C\" void OFFLOAD_TARGET_LEAVE(\n+    OFFLOAD ofld\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, ofld);\n+    ofld->gather_copyout_data();\n+}\n+\n+extern \"C\" void OFFLOAD_TARGET_MAIN(void)\n+{\n+    // initialize target part\n+    __offload_target_init();\n+\n+    // pass control to COI\n+    PipelineStartExecutingRunFunctions();\n+    ProcessWaitForShutdown();\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Exiting main...\\n\");\n+}"}, {"sha": "c4de1260d3461201f413fd789d62b1890cc6830b", "filename": "liboffloadmic/runtime/compiler_if_target.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcompiler_if_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fcompiler_if_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_target.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,70 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+/*! \\file\n+    \\brief The interface between compiler-generated target code and runtime library\n+*/\n+\n+#ifndef COMPILER_IF_TARGET_H_INCLUDED\n+#define COMPILER_IF_TARGET_H_INCLUDED\n+\n+#include \"offload_target.h\"\n+\n+#define OFFLOAD_TARGET_ENTER            OFFLOAD_PREFIX(target_enter)\n+#define OFFLOAD_TARGET_LEAVE            OFFLOAD_PREFIX(target_leave)\n+#define OFFLOAD_TARGET_MAIN             OFFLOAD_PREFIX(target_main)\n+\n+/*! \\fn OFFLOAD_TARGET_ENTER\n+    \\brief Fill in variable addresses using VarDesc array.\n+    \\brief Then call back the runtime library to fetch data.\n+    \\param ofld         Offload descriptor created by runtime.\n+    \\param var_desc_num Number of variable descriptors.\n+    \\param var_desc     Pointer to VarDesc array.\n+    \\param var_desc2    Pointer to VarDesc2 array.\n+*/\n+extern \"C\" void OFFLOAD_TARGET_ENTER(\n+    OFFLOAD ofld,\n+    int var_desc_num,\n+    VarDesc *var_desc,\n+    VarDesc2 *var_desc2\n+);\n+\n+/*! \\fn OFFLOAD_TARGET_LEAVE\n+    \\brief Call back the runtime library to gather outputs using VarDesc array.\n+    \\param ofld Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n+*/\n+extern \"C\" void OFFLOAD_TARGET_LEAVE(\n+    OFFLOAD ofld\n+);\n+\n+// Entry point for the target application.\n+extern \"C\" void OFFLOAD_TARGET_MAIN(void);\n+\n+#endif // COMPILER_IF_TARGET_H_INCLUDED"}, {"sha": "63f50592e009b05a7891ddb59c69affa173e0ffa", "filename": "liboffloadmic/runtime/dv_util.cpp", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fdv_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fdv_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fdv_util.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,153 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#include \"offload_common.h\"\n+\n+bool __dv_is_contiguous(const ArrDesc *dvp)\n+{\n+    if (dvp->Flags & ArrDescFlagsContiguous) {\n+        return true;\n+    }\n+\n+    if (dvp->Rank != 0) {\n+        if (dvp->Dim[0].Mult != dvp->Len) {\n+            return false;\n+        }\n+        for (int i = 1; i < dvp->Rank; i++) {\n+            if (dvp->Dim[i].Mult !=\n+                dvp->Dim[i-1].Extent * dvp->Dim[i-1].Mult) {\n+                return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n+bool __dv_is_allocated(const ArrDesc *dvp)\n+{\n+    return (dvp->Flags & ArrDescFlagsDefined);\n+}\n+\n+uint64_t __dv_data_length(const ArrDesc *dvp)\n+{\n+    uint64_t size;\n+\n+    if (dvp->Rank == 0) {\n+        size = dvp->Len;\n+        return size;\n+    }\n+\n+    size = dvp->Len;\n+    for (int i = 0; i < dvp->Rank; ++i) {\n+        size += (dvp->Dim[i].Extent-1) * dvp->Dim[i].Mult;\n+    }\n+    return size;\n+}\n+\n+uint64_t __dv_data_length(const ArrDesc *dvp, int64_t count)\n+{\n+    if (dvp->Rank == 0) {\n+        return count;\n+    }\n+\n+    return count * dvp->Dim[0].Mult;\n+}\n+\n+// Create CeanReadRanges data for reading contiguous ranges of\n+// noncontiguous array defined by the argument\n+CeanReadRanges * init_read_ranges_dv(const ArrDesc *dvp)\n+{\n+    int64_t         len;\n+    int             count;\n+    int             rank = dvp->Rank;\n+    CeanReadRanges *res = NULL;\n+\n+    if (rank != 0) {\n+        int i = 0;\n+        len = dvp->Len;\n+        if (dvp->Dim[0].Mult == len) {\n+            for (i = 1; i < rank; i++) {\n+                len *= dvp->Dim[i-1].Extent;\n+                if (dvp->Dim[i].Mult != len) {\n+                    break;\n+                }\n+            }\n+        }\n+        res = (CeanReadRanges *)malloc(\n+            sizeof(CeanReadRanges) + (rank - i) * sizeof(CeanReadDim));\n+\tif (res == NULL)\n+          LIBOFFLOAD_ERROR(c_malloc);\n+        res -> last_noncont_ind = rank - i - 1;\n+        count = 1;\n+        for (; i < rank; i++) {\n+            res->Dim[rank - i - 1].count = count;\n+            res->Dim[rank - i - 1].size = dvp->Dim[i].Mult;\n+            count *= dvp->Dim[i].Extent;\n+        }\n+        res -> range_max_number = count;\n+        res -> range_size = len;\n+        res -> ptr = (void*)dvp->Base;\n+        res -> current_number = 0;\n+        res -> init_offset = 0;\n+    }\n+    return res;\n+}\n+\n+#if OFFLOAD_DEBUG > 0\n+void __dv_desc_dump(const char *name, const ArrDesc *dvp)\n+{\n+    OFFLOAD_TRACE(3, \"%s DV %p\\n\", name, dvp);\n+\n+    if (dvp != 0) {\n+        OFFLOAD_TRACE(3,\n+                      \"    dv->Base   = 0x%lx\\n\"\n+                      \"    dv->Len    = 0x%lx\\n\"\n+                      \"    dv->Offset = 0x%lx\\n\"\n+                      \"    dv->Flags  = 0x%lx\\n\"\n+                      \"    dv->Rank   = 0x%lx\\n\"\n+                      \"    dv->Resrvd = 0x%lx\\n\",\n+                      dvp->Base,\n+                      dvp->Len,\n+                      dvp->Offset,\n+                      dvp->Flags,\n+                      dvp->Rank,\n+                      dvp->Reserved);\n+\n+        for (int i = 0 ; i < dvp->Rank; i++) {\n+            OFFLOAD_TRACE(3,\n+                          \"    (%d) Extent=%ld, Multiplier=%ld, LowerBound=%ld\\n\",\n+                          i,\n+                          dvp->Dim[i].Extent,\n+                          dvp->Dim[i].Mult,\n+                          dvp->Dim[i].LowerBound);\n+        }\n+    }\n+}\n+#endif // OFFLOAD_DEBUG > 0"}, {"sha": "d62cecc6aa1344db2626da8ab22ed2edaf5488d4", "filename": "liboffloadmic/runtime/dv_util.h", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fdv_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fdv_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fdv_util.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,83 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#ifndef DV_UTIL_H_INCLUDED\n+#define DV_UTIL_H_INCLUDED\n+\n+#include <stdint.h>\n+\n+// Dope vector declarations\n+#define ArrDescMaxArrayRank         31\n+\n+// Dope vector flags\n+#define ArrDescFlagsDefined         1\n+#define ArrDescFlagsNodealloc       2\n+#define ArrDescFlagsContiguous      4\n+\n+typedef int64_t dv_size;\n+\n+typedef struct DimDesc {\n+    dv_size        Extent;      // Number of elements in this dimension\n+    dv_size        Mult;        // Multiplier for this dimension.\n+                                // The number of bytes between successive\n+                                // elements in this dimension.\n+    dv_size        LowerBound;  // LowerBound of this dimension\n+} DimDesc ;\n+\n+typedef struct ArrDesc {\n+    dv_size        Base;        // Base address\n+    dv_size        Len;         // Length of data type, used only for\n+                                // character strings.\n+    dv_size        Offset;\n+    dv_size        Flags;       // Flags\n+    dv_size        Rank;        // Rank of pointer\n+    dv_size        Reserved;    // reserved for openmp requests\n+    DimDesc Dim[ArrDescMaxArrayRank];\n+} ArrDesc ;\n+\n+typedef ArrDesc* pArrDesc;\n+\n+bool __dv_is_contiguous(const ArrDesc *dvp);\n+\n+bool __dv_is_allocated(const ArrDesc *dvp);\n+\n+uint64_t __dv_data_length(const ArrDesc *dvp);\n+\n+uint64_t __dv_data_length(const ArrDesc *dvp, int64_t nelems);\n+\n+CeanReadRanges * init_read_ranges_dv(const ArrDesc *dvp);\n+\n+#if OFFLOAD_DEBUG > 0\n+void    __dv_desc_dump(const char *name, const ArrDesc *dvp);\n+#else // OFFLOAD_DEBUG\n+#define __dv_desc_dump(name, dvp)\n+#endif // OFFLOAD_DEBUG\n+\n+#endif // DV_UTIL_H_INCLUDED"}, {"sha": "482c88854378da84ca7878f24f47779df00d71f5", "filename": "liboffloadmic/runtime/emulator/coi_common.h", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,140 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+#ifndef COI_COMMON_H_INCLUDED\n+#define COI_COMMON_H_INCLUDED\n+\n+#include <common/COIMacros_common.h>\n+#include <common/COIPerf_common.h>\n+#include <source/COIEngine_source.h>\n+#include <source/COIProcess_source.h>\n+#include <source/COIPipeline_source.h>\n+#include <source/COIBuffer_source.h>\n+#include <source/COIEvent_source.h>\n+\n+#include <assert.h>\n+#include <dirent.h>\n+#include <dlfcn.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <pthread.h>\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/mman.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+\n+\n+/* Environment variable for path to 'target' files.  */\n+#define MIC_DIR_ENV\t\t  \"OFFLOAD_MIC_DIR\"\n+\n+/* Environment variable for engine index.  */\n+#define MIC_INDEX_ENV\t\t  \"OFFLOAD_MIC_INDEX\"\n+\n+/* Environment variable for target executable run command.  */\n+#define OFFLOAD_EMUL_RUN_ENV      \"OFFLOAD_EMUL_RUN\"\n+\n+/* Environment variable for number ok KNC devices.  */\n+#define OFFLOAD_EMUL_KNC_NUM_ENV  \"OFFLOAD_EMUL_KNC_NUM\"\n+\n+\n+/* Path to engine directory.  */\n+#define ENGINE_PATH\t\t  \"/tmp/offload_XXXXXX\"\n+\n+/* Relative path to directory with pipes.  */\n+#define PIPES_PATH\t\t  \"/pipes\"\n+\n+/* Relative path to target-to-host pipe.  */\n+#define PIPE_HOST_PATH\t\t  PIPES_PATH\"/host\"\n+\n+/* Relative path to host-to-target pipe.  */\n+#define PIPE_TARGET_PATH\t  PIPES_PATH\"/target\"\n+\n+/* Non-numerical part of shared memory file name.  */\n+#define SHM_NAME\t\t  \"/offload_shm_\"\n+\n+\n+/* Use secure getenv if it's supported.  */\n+#ifdef HAVE_SECURE_GETENV\n+  #define getenv(x)\t      secure_getenv(x)\n+#elif HAVE___SECURE_GETENV\n+  #define getenv(x)\t      __secure_getenv(x)\n+#endif\n+\n+\n+/* Wrapper for malloc.  */\n+#define MALLOC(type, ptr, size)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  type p = (type) malloc (size);\t\t\\\n+  if (p == NULL)\t\t\t\t\\\n+    COIERROR (\"Cannot allocate memory.\");\t\\\n+  ptr = p;\t\t\t\t\t\\\n+}\n+\n+/* Wrapper for strdup.  */\n+#define STRDUP(ptr, str)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  char *p = strdup (str);\t\t\t\\\n+  if (p == NULL)\t\t\t\t\\\n+    COIERROR (\"Cannot allocate memory.\");\t\\\n+  ptr = p;\t\t\t\t\t\\\n+}\n+\n+/* Wrapper for pipe reading.  */\n+#define READ(pipe, ptr, size)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  int s = (int) size;\t\t\t\t\\\n+  if (read (pipe, ptr, s) != s)\t\t\t\\\n+    COIERROR (\"Cannot read from pipe.\");\t\\\n+}\n+\n+/* Wrapper for pipe writing.  */\n+#define WRITE(pipe, ptr, size)\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  int s = (int) size;\t\t\t\t\\\n+  if (write (pipe, ptr, s) != s)\t\t\\\n+    COIERROR (\"Cannot write in pipe.\");\t\t\\\n+}\n+\n+\n+/* Command codes enum.  */\n+typedef enum\n+{\n+  CMD_BUFFER_COPY,\n+  CMD_BUFFER_MAP,\n+  CMD_BUFFER_UNMAP,\n+  CMD_GET_FUNCTION_HANDLE,\n+  CMD_OPEN_LIBRARY,\n+  CMD_RUN_FUNCTION,\n+  CMD_SHUTDOWN\n+} cmd_t;\n+\n+#endif // COI_COMMON_H_INCLUDED"}, {"sha": "1a89a3f55df840418253ff2234bcbddcd2fa8a70", "filename": "liboffloadmic/runtime/emulator/coi_device.cpp", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,330 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+#include \"coi_device.h\"\n+\n+#include \"coi_version_asm.h\"\n+\n+#define CYCLE_FREQUENCY     1000000000\n+\n+\n+static uint32_t engine_index;\n+\n+\n+extern \"C\"\n+{\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferAddRef, 1) (void *ptr)\n+{\n+  COITRACE (\"COIBufferAddRef\");\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferReleaseRef, 1) (void *ptr)\n+{\n+  COITRACE (\"COIBufferReleaseRef\");\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIEngineGetIndex, 1) (COI_ISA_TYPE *type,\n+\t\t\t\t       uint32_t *index)\n+{\n+  COITRACE (\"COIEngineGetIndex\");\n+\n+  /* type is not used in liboffload.  */\n+  *index = engine_index;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIPipelineStartExecutingRunFunctions, 1) ()\n+{\n+  COITRACE (\"COIPipelineStartExecutingRunFunctions\");\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n+{\n+  COITRACE (\"COIProcessWaitForShutdown\");\n+\n+  char *mic_dir = getenv (MIC_DIR_ENV);\n+  char *mic_index = getenv (MIC_INDEX_ENV);\n+  char *pipe_host_path, *pipe_target_path;\n+  int pipe_host, pipe_target;\n+  int cmd_len;\n+  pid_t ppid = getppid ();\n+  cmd_t cmd;\n+\n+  assert (mic_dir != NULL && mic_index != NULL);\n+\n+  /* Get engine index.  */\n+  engine_index = atoi (mic_index);\n+\n+  /* Open pipes.  */\n+  MALLOC (char *, pipe_host_path,\n+\t  strlen (PIPE_HOST_PATH) + strlen (mic_dir) + 1);\n+  MALLOC (char *, pipe_target_path,\n+\t  strlen (PIPE_TARGET_PATH) + strlen (mic_dir) + 1);\n+  sprintf (pipe_host_path, \"%s\"PIPE_HOST_PATH, mic_dir);\n+  sprintf (pipe_target_path, \"%s\"PIPE_TARGET_PATH, mic_dir);\n+  pipe_host = open (pipe_host_path, O_CLOEXEC | O_WRONLY);\n+  if (pipe_host < 0)\n+    COIERROR (\"Cannot open target-to-host pipe.\");\n+  pipe_target = open (pipe_target_path, O_CLOEXEC | O_RDONLY);\n+  if (pipe_target < 0)\n+    COIERROR (\"Cannot open host-to-target pipe.\");\n+\n+  /* Clean up.  */\n+  free (pipe_host_path);\n+  free (pipe_target_path);\n+\n+  /* Handler.  */\n+  while (1)\n+    {\n+      /* Read and execute command.  */\n+      cmd = CMD_SHUTDOWN;\n+      cmd_len = read (pipe_target, &cmd, sizeof (cmd_t));\n+      if (cmd_len != sizeof (cmd_t) && cmd_len != 0)\n+\tCOIERROR (\"Cannot read from pipe.\");\n+\n+      switch (cmd)\n+\t{\n+\tcase CMD_BUFFER_COPY:\n+\t  {\n+\t    uint64_t len;\n+\t    void *dest, *source;\n+\n+\t    /* Receive data from host.  */\n+\t    READ (pipe_target, &dest, sizeof (void *));\n+\t    READ (pipe_target, &source, sizeof (void *));\n+\t    READ (pipe_target, &len, sizeof (uint64_t));\n+\n+\t    /* Copy.  */\n+\t    memcpy (dest, source, len);\n+\n+\t    /* Notify host about completion.  */\n+\t    WRITE (pipe_host, &cmd, sizeof (cmd_t));\n+\n+\t    break;\n+\t  }\n+\tcase CMD_BUFFER_MAP:\n+\t  {\n+\t    char *name;\n+\t    int fd;\n+\t    size_t len;\n+\t    uint64_t buffer_len;\n+\t    void *buffer;\n+\n+\t    /* Receive data from host.  */\n+\t    READ (pipe_target, &len, sizeof (size_t));\n+\t    MALLOC (char *, name, len);\n+\t    READ (pipe_target, name, len);\n+\t    READ (pipe_target, &buffer_len, sizeof (uint64_t));\n+\n+\t    /* Open shared memory.  */\n+\t    fd = shm_open (name, O_CLOEXEC | O_RDWR, S_IRUSR | S_IWUSR);\n+\t    if (fd < 0)\n+\t      COIERROR (\"Cannot open shared memory.\");\n+\n+\t    /* Map shared memory.  */\n+\t    buffer = mmap (NULL, buffer_len, PROT_READ | PROT_WRITE,\n+\t\t\t   MAP_SHARED, fd, 0);\n+\t    if (buffer == NULL)\n+\t      COIERROR (\"Cannot map shared memory.\");\n+\n+\t    /* Send data to host.  */\n+\t    WRITE (pipe_host, &fd, sizeof (int));\n+\t    WRITE (pipe_host, &buffer, sizeof (void *));\n+\n+\t    /* Clean up.  */\n+\t    free (name);\n+\n+\t    break;\n+\t  }\n+\tcase CMD_BUFFER_UNMAP:\n+\t  {\n+\t    int fd;\n+\t    uint64_t buffer_len;\n+\t    void *buffer;\n+\n+\t    /* Receive data from host.  */\n+\t    READ (pipe_target, &fd, sizeof (int));\n+\t    READ (pipe_target, &buffer, sizeof (void *));\n+\t    READ (pipe_target, &buffer_len, sizeof (uint64_t));\n+\n+\t    /* Unmap buffer.  */\n+\t    if (munmap (buffer, buffer_len) < 0)\n+\t      COIERROR (\"Cannot unmap shared memory.\");\n+\n+\t    /* Close shared memory.  */\n+\t    if (close (fd) < 0)\n+\t      COIERROR (\"Cannot close shared memory file.\");\n+\n+\t    /* Notify host about completion.  */\n+\t    WRITE (pipe_host, &cmd, sizeof (cmd_t));\n+\n+\t    break;\n+\t  }\n+\tcase CMD_GET_FUNCTION_HANDLE:\n+\t  {\n+\t    char *name;\n+\t    size_t len;\n+\t    void *ptr;\n+\n+\t    /* Receive data from host.  */\n+\t    READ (pipe_target, &len, sizeof (size_t));\n+\t    MALLOC (char *, name, len);\n+\t    READ (pipe_target, name, len);\n+\n+\t    /* Find function.  */\n+\t    ptr = dlsym (RTLD_DEFAULT, name);\n+\t    if (ptr == NULL)\n+\t      COIERROR (\"Cannot find symbol %s.\", name);\n+\n+\t    /* Send data to host.  */\n+\t    WRITE (pipe_host, &ptr, sizeof (void *));\n+\n+\t    /* Clean up.  */\n+\t    free (name);\n+\n+\t    break;\n+\t  }\n+\tcase CMD_OPEN_LIBRARY:\n+\t  {\n+\t    char *lib_path;\n+\t    size_t len;\n+\n+\t    /* Receive data from host.  */\n+\t    READ (pipe_target, &len, sizeof (size_t));\n+\t    MALLOC (char *, lib_path, len);\n+\t    READ (pipe_target, lib_path, len);\n+\n+\t    /* Open library.  */\n+\t    if (dlopen (lib_path, RTLD_LAZY | RTLD_GLOBAL) == 0)\n+\t      COIERROR (\"Cannot load %s: %s\", lib_path, dlerror ());\n+\n+\t    /* Clean up.  */\n+\t    free (lib_path);\n+\n+\t    break;\n+\t  }\n+\tcase CMD_RUN_FUNCTION:\n+\t  {\n+\t    uint16_t misc_data_len, return_data_len;\n+\t    uint32_t buffer_count, i;\n+\t    uint64_t *buffers_len, size;\n+\t    void *ptr;\n+\t    void **buffers, *misc_data, *return_data;\n+\n+\t    void (*func) (uint32_t, void **, uint64_t *,\n+\t\t\t  void *, uint16_t, void*, uint16_t);\n+\n+\t    /* Receive data from host.  */\n+\t    READ (pipe_target, &func, sizeof (void *));\n+\t    READ (pipe_target, &buffer_count, sizeof (uint32_t));\n+\t    MALLOC (void **, buffers, buffer_count * sizeof (void *));\n+\t    MALLOC (uint64_t *, buffers_len, buffer_count * sizeof (uint64_t));\n+\n+\t    for (i = 0; i < buffer_count; i++)\n+\t      {\n+\t\tREAD (pipe_target, &(buffers_len[i]), sizeof (uint64_t));\n+\t\tREAD (pipe_target, &(buffers[i]), sizeof (void *));\n+\t      }\n+\t    READ (pipe_target, &misc_data_len, sizeof (uint16_t));\n+\t    if (misc_data_len > 0)\n+\t      {\n+\t\tMALLOC (void *, misc_data, misc_data_len);\n+\t\tREAD (pipe_target, misc_data, misc_data_len);\n+\t      }\n+\t    READ (pipe_target, &return_data_len, sizeof (uint16_t));\n+\t    if (return_data_len > 0)\n+\t      MALLOC (void *, return_data, return_data_len);\n+\n+\t    /* Run function.  */\n+\t    func (buffer_count, buffers, buffers_len, misc_data,\n+\t\t  misc_data_len, return_data, return_data_len);\n+\n+\t    /* Send data to host if any or just send notification.  */\n+\t    WRITE (pipe_host, return_data_len > 0 ? return_data : &cmd,\n+\t\t   return_data_len > 0 ? return_data_len : sizeof (cmd_t));\n+\n+\t    /* Clean up.  */\n+\t    free (buffers);\n+\t    free (buffers_len);\n+\t    if (misc_data_len > 0)\n+\t      free (misc_data);\n+\t    if (return_data_len > 0)\n+\t      free (return_data);\n+\n+\t    break;\n+\t  }\n+\tcase CMD_SHUTDOWN:\n+\t  if (close (pipe_host) < 0)\n+\t    COIERROR (\"Cannot close target-to-host pipe.\");\n+\t  if (close (pipe_target) < 0)\n+\t    COIERROR (\"Cannot close host-to-target pipe.\");\n+\t  return COI_SUCCESS;\n+\tdefault:\n+\t  COIERROR (\"Unrecognizable command from host.\");\n+\t}\n+    }\n+\n+  return COI_ERROR;\n+}\n+\n+\n+\n+uint64_t\n+SYMBOL_VERSION (COIPerfGetCycleFrequency, 1) ()\n+{\n+  COITRACE (\"COIPerfGetCycleFrequency\");\n+\n+  return (uint64_t) CYCLE_FREQUENCY;\n+}\n+\n+} // extern \"C\"\n+"}, {"sha": "779fdae69e73ece66a7448ef69044a2130b6c277", "filename": "liboffloadmic/runtime/emulator/coi_device.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,56 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+#ifndef COI_DEVICE_H_INCLUDED\n+#define COI_DEVICE_H_INCLUDED\n+\n+#include \"coi_common.h\"\n+\n+#define COIERROR(...)\t\t\t    \\\n+{\t\t\t\t\t    \\\n+  fprintf (stderr, \"COI ERROR - TARGET: \"); \\\n+  fprintf (stderr, __VA_ARGS__);\t    \\\n+  fprintf (stderr, \"\\n\");\t\t    \\\n+  perror (NULL);\t\t\t    \\\n+  return COI_ERROR;\t\t\t    \\\n+}\n+\n+#ifdef DEBUG\n+  #define COITRACE(...)\t\t\t      \\\n+  {\t\t\t\t\t      \\\n+    fprintf (stderr, \"COI TRACE - TARGET: \"); \\\n+    fprintf (stderr, __VA_ARGS__);\t      \\\n+    fprintf (stderr, \"\\n\");\t\t      \\\n+  }\n+#else\n+  #define COITRACE(...) {}\n+#endif\n+\n+\n+#endif // COI_DEVICE_H_INCLUDED"}, {"sha": "3425920a4a1232bca2ef4cbd6efa48f0253df7a7", "filename": "liboffloadmic/runtime/emulator/coi_host.cpp", "status": "added", "additions": 1214, "deletions": 0, "changes": 1214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,1214 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+#include \"coi_host.h\"\n+\n+#include \"coi_version_asm.h\"\n+\n+#define CYCLE_FREQUENCY     1000000000\n+\n+/* Environment variables.  */\n+extern char **environ;\n+\n+/* List of directories for removing on exit.  */\n+char **tmp_dirs;\n+unsigned tmp_dirs_num = 0;\n+\n+/* Number of KNC engines.  */\n+long knc_engines_num;\n+\n+/* Mutex to sync parallel execution.  */\n+pthread_mutex_t mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n+\n+\n+typedef enum\n+{\n+  BUFFER_NORMAL,\n+  BUFFER_MEMORY\n+} buffer_t;\n+\n+typedef struct\n+{\n+  COI_ISA_TYPE type;\n+  uint32_t index;\n+  char *dir;\n+} Engine;\n+\n+typedef struct\n+{\n+  char *name;\n+  void *ptr;\n+} Function;\n+\n+typedef struct\n+{\n+  int pipe_host;\n+  int pipe_target;\n+} Pipeline;\n+\n+typedef struct\n+{\n+  pid_t pid;\n+  Engine *engine;\n+  Function **functions;\n+  Pipeline *pipeline;\n+} Process;\n+\n+typedef struct\n+{\n+  buffer_t type;\n+  char *name;\n+  int fd;\n+  int fd_target;\n+  uint64_t size;\n+  void *data;\n+  void *data_target;\n+  Process *process;\n+} Buffer;\n+\n+\n+static COIRESULT\n+read_long_env (const char *env_name, long *var, long var_default)\n+{\n+  char *str = getenv (env_name);\n+  char *s;\n+\n+  if (!str || *str == '\\0')\n+    *var = var_default;\n+  else\n+    {\n+      errno = 0;\n+      *var = strtol (str, &s, 0);\n+      if (errno != 0 || s == str || *s != '\\0')\n+\tCOIERROR (\"Variable %s has invalid value.\", env_name);\n+    }\n+\n+  return COI_SUCCESS;\n+}\n+\n+__attribute__((constructor))\n+static void\n+init ()\n+{\n+  if (read_long_env (OFFLOAD_EMUL_KNC_NUM_ENV, &knc_engines_num, 1)\n+      == COI_ERROR)\n+    exit (0);\n+}\n+\n+\n+/* Helper function for directory removing.  */\n+static COIRESULT remove_directory (char *path)\n+{\n+  char *file;\n+  struct dirent *entry;\n+  struct stat statfile;\n+  DIR *dir = opendir (path);\n+  if (dir == NULL)\n+    COIERROR (\"Cannot open directory %s.\", dir);\n+\n+  while (entry = readdir (dir))\n+    {\n+      if (!strcmp (entry->d_name, \".\") || !strcmp (entry->d_name, \"..\"))\n+\tcontinue;\n+\n+      MALLOC (char *, file, strlen (path) + strlen (entry->d_name) + 2);\n+      sprintf (file, \"%s/%s\", path, entry->d_name);\n+\n+      if (stat (file, &statfile) < 0)\n+\tCOIERROR (\"Cannot retrieve information about file %s.\", file);\n+\n+      if (S_ISDIR (statfile.st_mode))\n+\t{\n+\t  if (remove_directory (file) == COI_ERROR)\n+\t    return COI_ERROR;\n+\t}\n+      else\n+\t{\n+\t  if (unlink (file) < 0)\n+\t    COIERROR (\"Cannot unlink file %s.\", file);\n+\t}\n+\n+      free (file);\n+    }\n+\n+  if (closedir (dir) < 0)\n+    COIERROR (\"Cannot close directory %s.\", path);\n+  if (rmdir (path) < 0)\n+    COIERROR (\"Cannot remove directory %s.\", path);\n+\n+  return COI_SUCCESS;\n+}\n+\n+__attribute__((destructor))\n+static void\n+cleanup ()\n+{\n+  unsigned i;\n+  for (i = 0; i < tmp_dirs_num; i++)\n+    {\n+      remove_directory (tmp_dirs[i]);\n+      free (tmp_dirs[i]);\n+    }\n+  if (tmp_dirs)\n+    free (tmp_dirs);\n+}\n+\n+\n+extern \"C\"\n+{\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferCopy, 1) (COIBUFFER dest_buffer,\n+\t\t\t\t   COIBUFFER source_buffer,\n+\t\t\t\t   uint64_t dest_offset,\n+\t\t\t\t   uint64_t source_offset,\n+\t\t\t\t   uint64_t length,\n+\t\t\t\t   COI_COPY_TYPE type,\n+\t\t\t\t   uint32_t dependencies_num,     // Ignored\n+\t\t\t\t   const COIEVENT *dependencies,  // Ignored\n+\t\t\t\t   COIEVENT *completion)\t  // Ignored\n+{\n+  COITRACE (\"COIBufferCopy\");\n+\n+  /* Convert input arguments.  */\n+  Buffer *dest = (Buffer *) dest_buffer;\n+  Buffer *source = (Buffer *) source_buffer;\n+\n+  /* Features of liboffload.  */\n+  assert (type == COI_COPY_UNSPECIFIED);\n+\n+  /* Start critical section.  */\n+  if (pthread_mutex_lock (&mutex) != 0)\n+    COIERROR (\"Cannot lock mutex.\");\n+\n+  /* Map buffers if needed.  */\n+  if (dest->data == 0 && dest->type == BUFFER_NORMAL)\n+    if (COIBufferMap (dest_buffer, 0, dest->size, (COI_MAP_TYPE) 0,\n+\t\t      0, 0, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+  if (source->data == 0 && source->type == BUFFER_NORMAL)\n+    if (COIBufferMap (source_buffer, 0, source->size, (COI_MAP_TYPE) 0,\n+\t\t      0, 0, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+\n+  /* Copy data.  */\n+  if (source->data != 0 && dest->data != 0)\n+    memcpy ((void *) ((uintptr_t) dest->data+dest_offset),\n+\t    (void *) ((uintptr_t) source->data+source_offset), length);\n+  else\n+    {\n+      assert (dest->process == source->process);\n+\n+      Buffer *buffer;\n+      cmd_t cmd = CMD_BUFFER_COPY;\n+      Pipeline *pipeline = dest->process->pipeline;\n+\n+      /* Create intermediary buffer.  */\n+      if (COIBufferCreate (length, COI_BUFFER_NORMAL, 0, 0, 1,\n+\t\t\t   (COIPROCESS*) &dest->process,\n+\t\t\t   (COIBUFFER *) &buffer) == COI_ERROR)\n+\treturn COI_ERROR;\n+\n+      /* Copy from source to intermediary buffer.  */\n+      if (source->data == 0)\n+\t{\n+\t  assert (source->data_target != 0);\n+\n+\t  /* Send data to target.  */\n+\t  WRITE (pipeline->pipe_target, &cmd, sizeof (cmd_t));\n+\t  WRITE (pipeline->pipe_target, &(buffer->data_target), sizeof (void *));\n+\t  WRITE (pipeline->pipe_target, &(source->data_target), sizeof (void *));\n+\t  WRITE (pipeline->pipe_target, &(buffer->size), sizeof (uint64_t));\n+\n+\t  /* Receive data from  target.  */\n+\t  READ (pipeline->pipe_host, &cmd, sizeof (cmd_t));\n+\t}\n+      else\n+\t{\n+\t  if (COIBufferCopy ((COIBUFFER) buffer, source_buffer, 0, source_offset,\n+\t\t\t     length, type, 0, 0, 0) == COI_ERROR)\n+\t    return COI_ERROR;\n+\t}\n+\n+      /* Copy from intermediary buffer to dest.  */\n+      if (dest->data == 0)\n+\t{\n+\t  assert (dest->data_target != 0);\n+\n+\t  /* Send data to target.  */\n+\t  WRITE (pipeline->pipe_target, &cmd, sizeof (cmd_t));\n+\t  WRITE (pipeline->pipe_target, &(dest->data_target), sizeof (void *));\n+\t  WRITE (pipeline->pipe_target, &(buffer->data_target), sizeof (void *));\n+\t  WRITE (pipeline->pipe_target, &(buffer->size), sizeof (uint64_t));\n+\n+\t  /* Receive data from  target.  */\n+\t  READ (pipeline->pipe_host, &cmd, sizeof (cmd_t));\n+\t}\n+      else\n+\t{\n+\t  if (COIBufferCopy (dest_buffer, (COIBUFFER) buffer, dest_offset,\n+\t\t\t     0, length, type, 0, 0, 0) == COI_ERROR)\n+\t    return COI_ERROR;\n+\t}\n+\n+      /* Unmap on target and destroy intermediary buffer.  */\n+      if (COIBufferDestroy ((COIBUFFER) buffer) == COI_ERROR)\n+\treturn COI_ERROR;\n+    }\n+\n+  /* Unmap buffers if needed.  */\n+  if (dest->type == BUFFER_NORMAL)\n+    if (COIBufferUnmap ((COIMAPINSTANCE) dest, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+  if (source->type == BUFFER_NORMAL)\n+    if (COIBufferUnmap ((COIMAPINSTANCE) source, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+\n+  /* Finish critical section.  */\n+  if (pthread_mutex_unlock (&mutex) != 0)\n+    COIERROR (\"Cannot unlock mutex.\");\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferCreate, 1) (uint64_t size,\n+\t\t\t\t     COI_BUFFER_TYPE type,\n+\t\t\t\t     uint32_t flags,\n+\t\t\t\t     const void *init_data,\n+\t\t\t\t     uint32_t processes_num,\n+\t\t\t\t     const COIPROCESS *processes,\n+\t\t\t\t     COIBUFFER *buffer)\n+{\n+  COITRACE (\"COIBufferCreate\");\n+\n+  char *shm_name;\n+  cmd_t cmd = CMD_BUFFER_MAP;\n+  int shm_fd;\n+  const int ullong_max_len = 20;\n+  size_t len;\n+  unsigned long long i;\n+\n+  Buffer *buf;\n+  Pipeline *pipeline;\n+\n+  /* Features of liboffload.  */\n+  assert (type == COI_BUFFER_NORMAL);\n+  assert ((flags & COI_SINK_MEMORY) == 0);\n+  assert ((flags & COI_SAME_ADDRESS_SINKS) == 0);\n+  assert ((flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n+  assert (init_data == 0);\n+  assert (processes_num == 1);\n+\n+  /* Create shared memory with an unique name.  */\n+  MALLOC (char *, shm_name, strlen (SHM_NAME) + ullong_max_len + 1);\n+  for (i = 0; i >= 0; i++)\n+    {\n+      sprintf (shm_name, SHM_NAME\"%lu\", i);\n+      shm_fd = shm_open (shm_name, O_CLOEXEC | O_CREAT | O_EXCL | O_RDWR,\n+\t\t\t S_IRUSR | S_IWUSR);\n+      if (shm_fd > 0)\n+\tbreak;\n+    }\n+  if (ftruncate (shm_fd, size) < 0)\n+    COIERROR (\"Cannot truncate shared memory file.\");\n+\n+  /* Create buffer.  */\n+  MALLOC (Buffer *, buf, sizeof (Buffer));\n+  buf->data = 0;\n+  buf->fd = shm_fd;\n+  buf->process = (Process *) processes[0];\n+  buf->size = size;\n+  buf->type = BUFFER_NORMAL;\n+  STRDUP (buf->name, shm_name);\n+\n+  /* Map buffer on target.  */\n+  len = strlen (buf->name) + 1;\n+  pipeline = buf->process->pipeline;\n+\n+  /* Start critical section.  */\n+  if (pthread_mutex_lock (&mutex) != 0)\n+    COIERROR (\"Cannot lock mutex.\");\n+\n+  /* Send data to target.  */\n+  WRITE (pipeline->pipe_target, &cmd, sizeof (cmd_t));\n+  WRITE (pipeline->pipe_target, &len, sizeof (size_t));\n+  WRITE (pipeline->pipe_target, buf->name, len);\n+  WRITE (pipeline->pipe_target, &(buf->size), sizeof (uint64_t));\n+\n+  /* Receive data from  target.  */\n+  READ (pipeline->pipe_host, &(buf->fd_target), sizeof (int));\n+  READ (pipeline->pipe_host, &(buf->data_target), sizeof (void *));\n+\n+  /* Finish critical section.  */\n+  if (pthread_mutex_unlock (&mutex) != 0)\n+    COIERROR (\"Cannot unlock mutex.\");\n+\n+  /* Prepare output arguments.  */\n+  *buffer = (COIBUFFER) buf;\n+\n+  /* Clean up.  */\n+  free (shm_name);\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferCreateFromMemory, 1) (uint64_t size,\n+\t\t\t\t\t       COI_BUFFER_TYPE type,\n+\t\t\t\t\t       uint32_t flags,\n+\t\t\t\t\t       void *memory,\n+\t\t\t\t\t       uint32_t processes_num,\n+\t\t\t\t\t       const COIPROCESS *processes,\n+\t\t\t\t\t       COIBUFFER *buffer)\n+{\n+  COITRACE (\"COIBufferCreateFromMemory\");\n+\n+  Buffer *buf;\n+\n+  /* Features of liboffload.  */\n+  assert (type == COI_BUFFER_NORMAL);\n+  assert ((flags & COI_SAME_ADDRESS_SINKS) == 0);\n+  assert ((flags & COI_SAME_ADDRESS_SINKS_AND_SOURCE) == 0);\n+  assert (processes_num == 1);\n+\n+  /* Create buffer.  */\n+  MALLOC (Buffer *, buf, sizeof (Buffer));\n+  buf->data = (flags & COI_SINK_MEMORY) == 0 ? memory : 0;\n+  buf->data_target = (flags & COI_SINK_MEMORY) != 0 ? memory : 0;\n+  buf->process = (Process *) processes[0];\n+  buf->size = size;\n+  buf->type = BUFFER_MEMORY;\n+\n+  /* Prepare output argument.  */\n+  *buffer = (COIBUFFER) buf;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferDestroy, 1) (COIBUFFER buffer)\n+{\n+  COITRACE (\"COIBufferDestroy\");\n+\n+  cmd_t cmd = CMD_BUFFER_UNMAP;\n+\n+  /* Convert input arguments.  */\n+  Buffer *buf = (Buffer *) buffer;\n+  Pipeline *pipeline = buf->process->pipeline;\n+\n+  /* Unmap buffer on host.  */\n+  if (buf->data != 0 && buf->type == BUFFER_NORMAL)\n+    if (COIBufferUnmap ((COIMAPINSTANCE) buffer, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+\n+  /* Unmap buffer on target.  */\n+  if (buf->data_target != 0)\n+    {\n+      /* Start critical section.  */\n+      if (pthread_mutex_lock (&mutex) != 0)\n+\tCOIERROR (\"Cannot lock mutex.\");\n+\n+      /* Send data to target.  */\n+      WRITE (pipeline->pipe_target, &cmd, sizeof (cmd_t));\n+      WRITE (pipeline->pipe_target, &(buf->fd_target), sizeof (int));\n+      WRITE (pipeline->pipe_target, &(buf->data_target), sizeof (void *));\n+      WRITE (pipeline->pipe_target, &(buf->size), sizeof (uint64_t));\n+\n+      /* Receive data from  target.  */\n+      READ (pipeline->pipe_host, &cmd, sizeof (cmd_t));\n+\n+      /* Finish critical section.  */\n+      if (pthread_mutex_unlock (&mutex) != 0)\n+\tCOIERROR (\"Cannot unlock mutex.\");\n+    }\n+\n+  /* Unlink shared memory.  */\n+  if (buf->type == BUFFER_NORMAL)\n+    {\n+      if (close (buf->fd) < 0)\n+\tCOIERROR (\"Cannot close shared memory file.\");\n+      if (shm_unlink (buf->name) < 0)\n+\tCOIERROR (\"Cannot unlink shared memory.\");\n+      free (buf->name);\n+    }\n+\n+  /* Clean up.  */\n+  free (buf);\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferGetSinkAddress, 1) (COIBUFFER buffer,\n+\t\t\t\t\t     uint64_t *data)\n+{\n+  COITRACE (\"COIBufferGetSinkAddress\");\n+\n+  /* Convert input arguments.  */\n+  Buffer *buf = (Buffer *) buffer;\n+\n+  /* Here should come BUFFER_NORMAL buffer.  */\n+  assert (buf->type == BUFFER_NORMAL);\n+\n+  /* Prepare output argument.  */\n+  *data = (uint64_t) buf->data_target;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferMap, 1) (COIBUFFER buffer,\n+\t\t\t\t  uint64_t offset,\n+\t\t\t\t  uint64_t length,\n+\t\t\t\t  COI_MAP_TYPE type,\t\t    // Ignored\n+\t\t\t\t  uint32_t dependencies_num,\t    // Ignored\n+\t\t\t\t  const COIEVENT *dependencies,     // Ignored\n+\t\t\t\t  COIEVENT *completion,\t\t    // Ignored\n+\t\t\t\t  COIMAPINSTANCE *map_instance,\n+\t\t\t\t  void **data)\n+{\n+  COITRACE (\"COIBufferMap\");\n+\n+  /* Features of liboffload.  */\n+  assert (offset == 0);\n+\n+  /* Convert input arguments.  */\n+  Buffer *buf = (Buffer *) buffer;\n+\n+  /* Only BUFFER_NORMAL buffers should come here.  */\n+  assert (buf->type == BUFFER_NORMAL);\n+\n+  /* Map shared memory.  */\n+  buf->data = mmap (NULL, buf->size, PROT_READ | PROT_WRITE,\n+\t\t    MAP_SHARED, buf->fd, 0);\n+  if (buf->data == NULL)\n+    COIERROR (\"Cannot map shared memory.\");\n+\n+  /* Prepare output arguments.  */\n+  if (map_instance != 0)\n+    *map_instance = (COIMAPINSTANCE) buf;\n+  if (data != 0)\n+    *data = buf->data;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferRead, 1) (COIBUFFER buffer,\n+\t\t\t\t   uint64_t offset,\n+\t\t\t\t   void *data,\n+\t\t\t\t   uint64_t length,\n+\t\t\t\t   COI_COPY_TYPE type,\n+\t\t\t\t   uint32_t dependencies_num,     // Ignored\n+\t\t\t\t   const COIEVENT *dependencies,  // Ignored\n+\t\t\t\t   COIEVENT *completion)\t  // Ignored\n+{\n+  COITRACE (\"COIBufferRead\");\n+\n+  /* Convert input arguments.  */\n+  Buffer *buf = (Buffer *) buffer;\n+\n+  /* Features of liboffload.  */\n+  assert (type == COI_COPY_UNSPECIFIED);\n+\n+  /* Start critical section.  */\n+  if (pthread_mutex_lock (&mutex) != 0)\n+    COIERROR (\"Cannot lock mutex.\");\n+\n+  /* Map buffers if needed.  */\n+  if (buf->data == 0 && buf->type == BUFFER_NORMAL)\n+    if (COIBufferMap (buffer, 0, buf->size, (COI_MAP_TYPE) 0,\n+\t\t      0, 0, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+\n+  /* Copy data.  */\n+  memcpy (data, (void *) ((uintptr_t) buf->data+offset), length);\n+\n+  /* Unmap buffers if needed.  */\n+  if (buf->type == BUFFER_NORMAL)\n+    if (COIBufferUnmap ((COIMAPINSTANCE) buf, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+\n+  /* Finish critical section.  */\n+  if (pthread_mutex_unlock (&mutex) != 0)\n+    COIERROR (\"Cannot unlock mutex.\");\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferSetState, 1) (COIBUFFER buffer,\n+\t\t\t\t       COIPROCESS process,\n+\t\t\t\t       COI_BUFFER_STATE state,\n+\t\t\t\t       COI_BUFFER_MOVE_FLAG flag,\n+\t\t\t\t       uint32_t dependencies_num,     // Ignored\n+\t\t\t\t       const COIEVENT *dependencies,  // Ignored\n+\t\t\t\t       COIEVENT *completion)\t      // Ignored\n+{\n+  COITRACE (\"COIBufferSetState\");\n+\n+  /* Features of liboffload.  */\n+  assert (flag == COI_BUFFER_NO_MOVE);\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferUnmap, 1) (COIMAPINSTANCE map_instance,\n+\t\t\t\t    uint32_t dependencies_num,      // Ignored\n+\t\t\t\t    const COIEVENT *dependencies,   // Ignored\n+\t\t\t\t    COIEVENT *completion)\t    // Ignored\n+{\n+  COITRACE (\"COIBufferUnmap\");\n+\n+  /* Convert input arguments.  */\n+  Buffer *buffer = (Buffer *) map_instance;\n+\n+  /* Only BUFFER_NORMAL buffers should come here.  */\n+  assert (buffer->type == BUFFER_NORMAL);\n+\n+  /* Unmap shared memory.  */\n+  if (munmap (buffer->data, buffer->size) < 0)\n+    COIERROR (\"Cannot unmap shared memory.\");\n+\n+  buffer->data = 0;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIBufferWrite, 1) (COIBUFFER buffer,\n+\t\t\t\t    uint64_t offset,\n+\t\t\t\t    const void *data,\n+\t\t\t\t    uint64_t length,\n+\t\t\t\t    COI_COPY_TYPE type,\n+\t\t\t\t    uint32_t dependencies_num,    // Ignored\n+\t\t\t\t    const COIEVENT *dependencies, // Ignored\n+\t\t\t\t    COIEVENT *completion)\t  // Ignored\n+{\n+  COITRACE (\"COIBufferWrite\");\n+\n+  /* Convert input arguments.  */\n+  Buffer *buf = (Buffer *) buffer;\n+\n+  /* Features of liboffload.  */\n+  assert (type == COI_COPY_UNSPECIFIED);\n+\n+  /* Start critical section.  */\n+  if (pthread_mutex_lock (&mutex) != 0)\n+    COIERROR (\"Cannot lock mutex.\");\n+\n+  /* Map buffers if needed.  */\n+  if (buf->data == 0 && buf->type == BUFFER_NORMAL)\n+    if (COIBufferMap (buffer, 0, buf->size, (COI_MAP_TYPE) 0,\n+\t\t      0, 0, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+\n+  /* Copy data.  */\n+  memcpy ((void *) ((uintptr_t) buf->data+offset), data, length);\n+\n+  /* Unmap buffers if needed.  */\n+  if (buf->type == BUFFER_NORMAL)\n+    if (COIBufferUnmap ((COIMAPINSTANCE) buf, 0, 0, 0) == COI_ERROR)\n+      return COI_ERROR;\n+\n+  /* Finish critical section.  */\n+  if (pthread_mutex_unlock (&mutex) != 0)\n+    COIERROR (\"Cannot unlock mutex.\");\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIEngineGetCount, 1) (COI_ISA_TYPE isa,\n+\t\t\t\t       uint32_t *count)\n+{\n+  COITRACE (\"COIEngineGetCount\");\n+\n+  /* Features of liboffload.  */\n+  assert (isa == COI_ISA_KNC);\n+\n+  /* Prepare output arguments.  */\n+  *count = knc_engines_num;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIEngineGetHandle, 1) (COI_ISA_TYPE isa,\n+\t\t\t\t\tuint32_t index,\n+\t\t\t\t\tCOIENGINE *handle)\n+{\n+  COITRACE (\"COIEngineGetHandle\");\n+\n+  Engine *engine;\n+\n+  /* Features of liboffload.  */\n+  assert (isa == COI_ISA_KNC);\n+\n+  /* Check engine index.  */\n+  if (index >= knc_engines_num)\n+    COIERROR (\"Wrong engine index.\");\n+\n+  /* Create engine handle.  */\n+  MALLOC (Engine *, engine, sizeof (Engine));\n+  engine->dir = NULL;\n+  engine->index = index;\n+  engine->type = isa;\n+\n+  /* Prepare output argument.  */\n+  *handle = (COIENGINE) engine;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIEventWait, 1) (uint16_t events_num,    // Ignored\n+\t\t\t\t  const COIEVENT *events, // Ignored\n+\t\t\t\t  int32_t timeout,\t  // Ignored\n+\t\t\t\t  uint8_t wait_all,\n+\t\t\t\t  uint32_t *signaled_num,\n+\t\t\t\t  uint32_t *signaled_indices)\n+{\n+  COITRACE (\"COIEventWait\");\n+\n+  /* Features of liboffload.  */\n+  assert (wait_all == 1);\n+  assert (signaled_num == 0);\n+  assert (signaled_indices == 0);\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIPipelineCreate, 1) (COIPROCESS process,\n+\t\t\t\t       COI_CPU_MASK mask,\n+\t\t\t\t       uint32_t stack_size,       // Ignored\n+\t\t\t\t       COIPIPELINE *pipeline)\n+{\n+  COITRACE (\"COIPipelineCreate\");\n+\n+  /* Features of liboffload.  */\n+  assert (mask == 0);\n+\n+  /* Prepare output arguments.  */\n+  *pipeline = (COIPIPELINE) ((Process *) process)->pipeline;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIPipelineDestroy, 1) (COIPIPELINE pipeline)\n+{\n+  COITRACE (\"COIPipelineDestroy\");\n+\n+  /* Do nothing here. Pipeline will be closed during COIProcessDestroy.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIPipelineRunFunction, 1) (COIPIPELINE pipeline,\n+\t\t\t\t\t    COIFUNCTION function,\n+\t\t\t\t\t    uint32_t buffers_num,\n+\t\t\t\t\t    const COIBUFFER *buffers,\n+\t\t\t\t\t    const COI_ACCESS_FLAGS *access_flags, // Ignored\n+\t\t\t\t\t    uint32_t dependencies_num,\t\t  // Ignored\n+\t\t\t\t\t    const COIEVENT *dependencies,\t  // Ignored\n+\t\t\t\t\t    const void *misc_data,\n+\t\t\t\t\t    uint16_t misc_data_len,\n+\t\t\t\t\t    void *return_data,\n+\t\t\t\t\t    uint16_t return_data_len,\n+\t\t\t\t\t    COIEVENT *completion)\t\t  // Ignored\n+{\n+  COITRACE (\"COIPipelineRunFunction\");\n+\n+  cmd_t cmd = CMD_RUN_FUNCTION;\n+  int ret_len;\n+  uint32_t i;\n+  uint64_t size;\n+  void *ptr;\n+\n+  /* Convert input arguments.  */\n+  Buffer **bufs = (Buffer **) buffers;\n+  Function *func = (Function *) function;\n+  Pipeline *pipe = (Pipeline *) pipeline;\n+\n+  /* Start critical section.  */\n+  if (pthread_mutex_lock (&mutex) != 0)\n+    COIERROR (\"Cannot lock mutex.\");\n+\n+  /* Send data to target.  */\n+  WRITE (pipe->pipe_target, &cmd, sizeof (cmd_t));\n+  WRITE (pipe->pipe_target, &(func->ptr), sizeof (void *));\n+  WRITE (pipe->pipe_target, &buffers_num, sizeof (uint32_t));\n+  for (i = 0; i < buffers_num; i++)\n+    {\n+      WRITE (pipe->pipe_target, &(bufs[i]->size), sizeof (uint64_t));\n+      WRITE (pipe->pipe_target, &(bufs[i]->data_target), sizeof (void *));\n+    }\n+  WRITE (pipe->pipe_target, &misc_data_len, sizeof (uint16_t));\n+  if (misc_data_len > 0)\n+    WRITE (pipe->pipe_target, misc_data, misc_data_len);\n+  WRITE (pipe->pipe_target, &return_data_len, sizeof (uint16_t));\n+\n+  /* Receive data from target.  In emulator we don't need any asynchronous data\n+     transfer, so we wait for target process whether it has any data or not.  */\n+  ret_len = read (pipe->pipe_host, return_data_len > 0 ? return_data : &cmd,\n+\treturn_data_len > 0 ? return_data_len : sizeof (cmd_t));\n+  if (ret_len == 0)\n+    return COI_PROCESS_DIED;\n+  else if (ret_len != (return_data_len > 0 ? return_data_len : sizeof (cmd_t)))\n+    COIERROR (\"Cannot read from pipe.\");\n+\n+  /* Finish critical section.  */\n+  if (pthread_mutex_unlock (&mutex) != 0)\n+    COIERROR (\"Cannot unlock mutex.\");\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n+\t\t\t\t\t\tconst char *bin_name,\n+\t\t\t\t\t\tconst void *bin_buffer,\n+\t\t\t\t\t\tuint64_t bin_buffer_len,\n+\t\t\t\t\t\tint argc,\n+\t\t\t\t\t\tconst char **argv,\n+\t\t\t\t\t\tuint8_t inherit_env,\n+\t\t\t\t\t\tconst char **additional_env,\n+\t\t\t\t\t\tuint8_t proxy_active,\t\t  // Ignored\n+\t\t\t\t\t\tconst char *proxyfs_root,\t  // Ignored\n+\t\t\t\t\t\tuint64_t buffer_space,\t\t  // Ignored\n+\t\t\t\t\t\tconst char *lib_search_path,\n+\t\t\t\t\t\tconst char *file_of_origin,       // Ignored\n+\t\t\t\t\t\tuint64_t file_of_origin_offset,   // Ignored\n+\t\t\t\t\t\tCOIPROCESS *process)\n+{\n+  COITRACE (\"COIProcessCreateFromMemory\");\n+\n+  const int run_max_args_num = 128;\n+  char **envp;\n+  char *run_argv[run_max_args_num];\n+  char *emul_run = getenv (OFFLOAD_EMUL_RUN_ENV);\n+  char *env_name, *tok;\n+  char *pipe_host_path, *pipe_target_path, *pipes_path, *target_exe;\n+  FILE *file;\n+  int fd;\n+  int i, j, env_i, env_num;\n+  int pipe_host, pipe_target;\n+  const int uint_max_len = 11;\n+  pid_t pid;\n+  Pipeline *pipeline;\n+  Process *proc;\n+\n+  /* Features of liboffload.  */\n+  assert (argc == 0);\n+  assert (argv == 0);\n+\n+  /* Convert input arguments.  */\n+  Engine *eng = (Engine *) engine;\n+\n+  /* Create temporary directory for engine files.  */\n+  assert (eng->dir == NULL);\n+  STRDUP (eng->dir, ENGINE_PATH);\n+  if (mkdtemp (eng->dir) == NULL)\n+    COIERROR (\"Cannot create temporary directory %s.\", eng->dir);\n+\n+  /* Save path to engine directory for clean up on exit.  */\n+  tmp_dirs_num++;\n+  tmp_dirs = (char **) realloc (tmp_dirs, tmp_dirs_num * sizeof (char *));\n+  if (!tmp_dirs)\n+    COIERROR (\"Cannot allocate memory.\");\n+  STRDUP (tmp_dirs[tmp_dirs_num - 1], eng->dir);\n+\n+  /* Create target executable file.  */\n+  MALLOC (char *, target_exe, strlen (eng->dir) + strlen (bin_name) + 2);\n+  sprintf (target_exe, \"%s/%s\", eng->dir, bin_name);\n+  fd = open (target_exe, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n+  if (fd < 0)\n+    COIERROR (\"Cannot create file %s.\", target_exe);\n+  file = fdopen (fd, \"wb\");\n+  if (file == NULL)\n+    COIERROR (\"Cannot associate stream with file descriptor.\");\n+  if (fwrite (bin_buffer, 1, bin_buffer_len, file) != bin_buffer_len)\n+    COIERROR (\"Cannot write in file %s.\", target_exe);\n+  if (fclose (file) != 0)\n+    COIERROR (\"Cannot close file %s.\", target_exe);\n+\n+  /* Fix file permissions.  */\n+  if (chmod (target_exe, S_IRWXU) < 0)\n+    COIERROR (\"Cannot change permissions for file %s.\", target_exe);\n+\n+  /* Create directory for pipes to prevent names collision.  */\n+  MALLOC (char *, pipes_path, strlen (PIPES_PATH) + strlen (eng->dir) + 1);\n+  sprintf (pipes_path, \"%s\"PIPES_PATH, eng->dir);\n+  if (mkdir (pipes_path, S_IRWXU) < 0)\n+    COIERROR (\"Cannot create folder %s.\", pipes_path);\n+\n+  /* Create pipes.  */\n+  MALLOC (char *, pipe_host_path,\n+\t  strlen (PIPE_HOST_PATH) + strlen (eng->dir) + 1);\n+  MALLOC (char *, pipe_target_path,\n+\t  strlen (PIPE_TARGET_PATH) + strlen (eng->dir) + 1);\n+  if (pipe_target_path == NULL)\n+    COIERROR (\"Cannot allocate memory.\");\n+  sprintf (pipe_host_path, \"%s\"PIPE_HOST_PATH, eng->dir);\n+  sprintf (pipe_target_path, \"%s\"PIPE_TARGET_PATH, eng->dir);\n+  if (mkfifo (pipe_host_path, S_IRUSR | S_IWUSR) < 0)\n+    COIERROR (\"Cannot create pipe %s.\", pipe_host_path);\n+  if (mkfifo (pipe_target_path, S_IRUSR | S_IWUSR) < 0)\n+    COIERROR (\"Cannot create pipe %s.\", pipe_target_path);\n+\n+  /* Prepare argv.  */\n+  if (emul_run == NULL || strcmp (emul_run, \"\") == 0)\n+    {\n+      STRDUP (run_argv[0], target_exe);\n+      run_argv[1] = (char *) NULL;\n+    }\n+  else\n+    {\n+      char *ptr, *tmp;\n+      i = 0;\n+      STRDUP (tmp, emul_run);\n+      tok = strtok_r (tmp, \" \", &ptr);\n+      while (tok != NULL)\n+\t{\n+\t  if (i >= run_max_args_num)\n+\t    COIERROR (\"Run command has too many arguments.\");\n+\t  STRDUP (run_argv[i++], tok);\n+\t  tok = strtok_r (NULL, \" \", &ptr);\n+\t}\n+      STRDUP (run_argv[i], target_exe);\n+      run_argv[i+1] = (char *) NULL;\n+      free (tmp);\n+    }\n+\n+  /* Prepare envp.  */\n+  /* FIXME: take into account additional_env.  */\n+  assert (additional_env == NULL);\n+\n+  env_num = 0;\n+  if (inherit_env == true)\n+    while (environ[env_num++]);\n+  env_num += 4; // LD_LIBRARY_PATH, MIC_DIR, MIC_INDEX, NULL\n+\n+  MALLOC (char **, envp, env_num * sizeof (char *));\n+\n+  env_i = 0;\n+  if (inherit_env == true)\n+    for (i = 0; environ[i] != NULL; i++)\n+      {\n+\tSTRDUP (env_name, environ[i]);\n+\tfor (j = 0; env_name[j] != '=' && env_name[j] != '\\0'; j++);\n+\tenv_name[j] = '\\0';\n+\tif (strcmp (env_name, \"LD_LIBRARY_PATH\") != 0\n+\t    && strcmp (env_name, MIC_DIR_ENV) != 0\n+\t    && strcmp (env_name, MIC_INDEX_ENV) != 0)\n+\t  STRDUP (envp[env_i++], environ[i]);\n+\tfree (env_name);\n+      }\n+\n+  MALLOC (char *, envp[env_i], strlen (MIC_DIR_ENV) + strlen (eng->dir) + 2);\n+  sprintf (envp[env_i], \"%s=%s\", MIC_DIR_ENV, eng->dir);\n+\n+  MALLOC (char *, envp[env_i+1], strlen (MIC_INDEX_ENV) + uint_max_len + 1);\n+  sprintf (envp[env_i+1], \"%s=%u\", MIC_INDEX_ENV, eng->index);\n+\n+  MALLOC (char *, envp[env_i+2],\n+\t  strlen (\"LD_LIBRARY_PATH=\") + strlen (lib_search_path) + 1);\n+  sprintf (envp[env_i+2], \"LD_LIBRARY_PATH=%s\", lib_search_path);\n+\n+  envp[env_i+3] = (char *) NULL;\n+\n+  /* Create target process.  */\n+  pid = vfork ();\n+  if (pid < 0)\n+    COIERROR (\"Cannot create child process.\");\n+\n+  if (pid == 0)\n+    {\n+      /* Run target executable.  */\n+      if (execvpe (run_argv[0], run_argv, envp) == -1)\n+\tCOIERROR (\"Cannot execute file %s.\", target_exe);\n+    }\n+\n+  /* Open pipes.  */\n+  pipe_host = open (pipe_host_path, O_CLOEXEC | O_RDONLY);\n+  if (pipe_host < 0)\n+    COIERROR (\"Cannot open target-to-host pipe.\");\n+  pipe_target = open (pipe_target_path, O_CLOEXEC | O_WRONLY);\n+  if (pipe_target < 0)\n+    COIERROR (\"Cannot open host-to-target pipe.\");\n+\n+  /* Create pipeline handle.  */\n+  MALLOC (Pipeline *, pipeline, sizeof (Pipeline));\n+  pipeline->pipe_host = pipe_host;\n+  pipeline->pipe_target = pipe_target;\n+\n+  /* Create process handle.  */\n+  MALLOC (Process *, proc, sizeof (Process));\n+  proc->pid = pid;\n+  proc->engine = eng;\n+  proc->functions = 0;\n+  proc->pipeline = pipeline;\n+\n+  /* Prepare output arguments.  */\n+  *process = (COIPROCESS) proc;\n+\n+  /* Clean up.  */\n+  for (i = 0; run_argv[i] != NULL; i++)\n+    free (run_argv[i]);\n+  for (i = 0; envp[i] != NULL; i++)\n+    free (envp[i]);\n+  free (envp);\n+  free (pipe_host_path);\n+  free (pipe_target_path);\n+  free (pipes_path);\n+  free (target_exe);\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIProcessDestroy, 1) (COIPROCESS process,\n+\t\t\t\t       int32_t wait_timeout,      // Ignored\n+\t\t\t\t       uint8_t force,\n+\t\t\t\t       int8_t *proc_return,\n+\t\t\t\t       uint32_t *reason)\n+{\n+  COITRACE (\"COIProcessDestroy\");\n+\n+  int i;\n+\n+  /* Convert input arguments.  */\n+  Process *proc = (Process *) process;\n+\n+  /* Close pipeline.  */\n+  if (close (proc->pipeline->pipe_host) < 0)\n+    COIERROR (\"Cannot close target-to-host pipe.\");\n+  if (close (proc->pipeline->pipe_target) < 0)\n+    COIERROR (\"Cannot close host-to-target pipe.\");\n+  free (proc->pipeline);\n+\n+  /* Shutdown target process by force.  */\n+  if (force)\n+    kill (proc->pid, SIGTERM);\n+\n+  /* Clean up.  */\n+  for (i = 0; proc->functions[i] != 0; i++)\n+    {\n+      free (proc->functions[i]->name);\n+      free (proc->functions[i]);\n+    }\n+  free (proc->engine->dir);\n+  free (proc->engine);\n+  free (proc->functions);\n+  free (proc);\n+\n+  /* Prepare output arguments.  */\n+  *proc_return = 0;\n+  *reason = 0;\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIProcessGetFunctionHandles, 1) (COIPROCESS process,\n+\t\t\t\t\t\t  uint32_t functions_num,\n+\t\t\t\t\t\t  const char **function_names,\n+\t\t\t\t\t\t  COIFUNCTION *function_handles)\n+{\n+  COITRACE (\"COIProcessGetFunctionHandles\");\n+\n+  cmd_t cmd = CMD_GET_FUNCTION_HANDLE;\n+  Function *function;\n+  size_t len;\n+  void *ptr;\n+  uint32_t i;\n+\n+  /* Convert input arguments.  */\n+  Process *proc = (Process *) process;\n+\n+  /* This function should be called once for the process.  */\n+  assert (proc->functions == 0);\n+\n+  /* Create array of function pointers.  Last element is 0, what shows\n+     the end of the array.  This array is used to free memory when process\n+     is destroyed.  */\n+  proc->functions = (Function **) calloc (functions_num + 1,\n+\t\t\t\t\t  sizeof (Function *));\n+  if (proc->functions == NULL)\n+    COIERROR (\"Cannot allocate memory.\");\n+\n+  /* Get handles for functions.  */\n+  for (i = 0; i < functions_num; i++)\n+    {\n+      MALLOC (Function *, function, sizeof (Function));\n+\n+      len = strlen (function_names[i]) + 1;\n+\n+      /* Start critical section.  */\n+      if (pthread_mutex_lock (&mutex) != 0)\n+\tCOIERROR (\"Cannot lock mutex.\");\n+\n+      /* Send data to target.  */\n+      WRITE (proc->pipeline->pipe_target, &cmd, sizeof (cmd_t));\n+      WRITE (proc->pipeline->pipe_target, &len, sizeof (size_t));\n+      WRITE (proc->pipeline->pipe_target, function_names[i], len);\n+\n+      /* Receive data from  target.  */\n+      READ (proc->pipeline->pipe_host, &ptr, sizeof (void *));\n+\n+      /* Finish critical section.  */\n+      if (pthread_mutex_unlock (&mutex) != 0)\n+\tCOIERROR (\"Cannot unlock mutex.\");\n+\n+      /* Prepare output arguments.  */\n+      STRDUP (function->name, function_names[i]);\n+      if (function->name == NULL)\n+\tCOIERROR (\"Cannot allocate memory.\");\n+      function->ptr = ptr;\n+      function_handles[i] = (COIFUNCTION) function;\n+\n+      /* Save function pointer.  */\n+      proc->functions[i] = function;\n+    }\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIProcessLoadLibraryFromMemory, 2) (COIPROCESS process,\n+\t\t\t\t\t\t     const void *lib_buffer,\n+\t\t\t\t\t\t     uint64_t lib_buffer_len,\n+\t\t\t\t\t\t     const char *lib_name,\n+\t\t\t\t\t\t     const char *lib_search_path,\n+\t\t\t\t\t\t     const char *file_of_origin,\t// Ignored\n+\t\t\t\t\t\t     uint64_t file_from_origin_offset,  // Ignored\n+\t\t\t\t\t\t     uint32_t flags,\t\t\t// Ignored\n+\t\t\t\t\t\t     COILIBRARY *library)\t\t// Ignored\n+{\n+  COITRACE (\"COIProcessLoadLibraryFromMemory\");\n+\n+  char *lib_path;\n+  cmd_t cmd = CMD_OPEN_LIBRARY;\n+  int fd;\n+  FILE *file;\n+  size_t len;\n+\n+  /* Convert input arguments.  */\n+  Process *proc = (Process *) process;\n+\n+  /* Create target library file.  */\n+  MALLOC (char *, lib_path,\n+\t  strlen (proc->engine->dir) + strlen (lib_name) + 2);\n+  sprintf (lib_path, \"%s/%s\", proc->engine->dir, lib_name);\n+  fd = open (lib_path, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n+  if (fd < 0)\n+    COIERROR (\"Cannot create file %s.\", lib_path);\n+  file = fdopen (fd, \"wb\");\n+  if (file == NULL)\n+    COIERROR (\"Cannot associate stream with file descriptor.\");\n+  if (fwrite (lib_buffer, 1, lib_buffer_len, file) != lib_buffer_len)\n+    COIERROR (\"Cannot write in file %s.\", lib_path);\n+  if (fclose (file) != 0)\n+    COIERROR (\"Cannot close file %s.\", lib_path);\n+\n+  len = strlen (lib_path) + 1;\n+\n+  /* Start critical section.  */\n+  if (pthread_mutex_lock (&mutex) != 0)\n+    COIERROR (\"Cannot lock mutex.\");\n+\n+  /* Make target open library.  */\n+  WRITE (proc->pipeline->pipe_target, &cmd, sizeof (cmd_t));\n+  WRITE (proc->pipeline->pipe_target, &len, sizeof (size_t));\n+  WRITE (proc->pipeline->pipe_target, lib_path, len);\n+\n+  /* Finish critical section.  */\n+  if (pthread_mutex_unlock (&mutex) != 0)\n+    COIERROR (\"Cannot unlock mutex.\");\n+\n+  /* Clean up.  */\n+  free (lib_path);\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIProcessRegisterLibraries, 1) (uint32_t libraries_num,\n+\t\t\t\t\t\t const void **libraries,\n+\t\t\t\t\t\t const uint64_t *library_sizes,\n+\t\t\t\t\t\t const char **files_of_origin,\n+\t\t\t\t\t\t const uint64_t *file_of_origin_offsets)\n+{\n+  COITRACE (\"COIProcessRegisterLibraries\");\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+uint64_t\n+SYMBOL_VERSION (COIPerfGetCycleFrequency, 1) ()\n+{\n+  COITRACE (\"COIPerfGetCycleFrequency\");\n+\n+  return (uint64_t) CYCLE_FREQUENCY;\n+}\n+\n+} // extern \"C\"\n+"}, {"sha": "58ebd97ed7ec2b0d432e0a10dd25b637e25762a4", "filename": "liboffloadmic/runtime/emulator/coi_host.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,55 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+#ifndef COI_HOST_H_INCLUDED\n+#define COI_HOST_H_INCLUDED\n+\n+#include \"coi_common.h\"\n+\n+#define COIERROR(...)\t\t\t  \\\n+{\t\t\t\t\t  \\\n+  fprintf (stderr, \"COI ERROR - HOST: \"); \\\n+  fprintf (stderr, __VA_ARGS__);\t  \\\n+  fprintf (stderr, \"\\n\");\t\t  \\\n+  perror (NULL);\t\t\t  \\\n+  return COI_ERROR;\t\t\t  \\\n+}\n+\n+#ifdef DEBUG\n+  #define COITRACE(...)\t\t\t    \\\n+  {\t\t\t\t\t    \\\n+    fprintf (stderr, \"COI TRACE - HOST: \"); \\\n+    fprintf (stderr, __VA_ARGS__);\t    \\\n+    fprintf (stderr, \"\\n\");\t\t    \\\n+  }\n+#else\n+  #define COITRACE(...) {}\n+#endif\n+\n+#endif // COI_HOST_H_INCLUDED"}, {"sha": "672d062d72f0f86986cfdb52d1f99fd159b95119", "filename": "liboffloadmic/runtime/emulator/coi_version_asm.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+__asm__ (\".symver COIBufferAddRef1,COIBufferAddRef@@COI_1.0\");\n+__asm__ (\".symver COIBufferCopy1,COIBufferCopy@@COI_1.0\");\n+__asm__ (\".symver COIBufferCreate1,COIBufferCreate@@COI_1.0\");\n+__asm__ (\".symver COIBufferCreateFromMemory1,COIBufferCreateFromMemory@@COI_1.0\");\n+__asm__ (\".symver COIBufferDestroy1,COIBufferDestroy@@COI_1.0\");\n+__asm__ (\".symver COIBufferGetSinkAddress1,COIBufferGetSinkAddress@@COI_1.0\");\n+__asm__ (\".symver COIBufferMap1,COIBufferMap@@COI_1.0\");\n+__asm__ (\".symver COIBufferRead1,COIBufferRead@@COI_1.0\");\n+__asm__ (\".symver COIBufferReleaseRef1,COIBufferReleaseRef@@COI_1.0\");\n+__asm__ (\".symver COIBufferSetState1,COIBufferSetState@@COI_1.0\");\n+__asm__ (\".symver COIBufferUnmap1,COIBufferUnmap@@COI_1.0\");\n+__asm__ (\".symver COIBufferWrite1,COIBufferWrite@@COI_1.0\");\n+__asm__ (\".symver COIEngineGetCount1,COIEngineGetCount@@COI_1.0\");\n+__asm__ (\".symver COIEngineGetHandle1,COIEngineGetHandle@@COI_1.0\");\n+__asm__ (\".symver COIEngineGetIndex1,COIEngineGetIndex@@COI_1.0\");\n+__asm__ (\".symver COIEventWait1,COIEventWait@@COI_1.0\");\n+__asm__ (\".symver COIPerfGetCycleFrequency1,COIPerfGetCycleFrequency@@COI_1.0\");\n+__asm__ (\".symver COIPipelineCreate1,COIPipelineCreate@@COI_1.0\");\n+__asm__ (\".symver COIPipelineDestroy1,COIPipelineDestroy@@COI_1.0\");\n+__asm__ (\".symver COIPipelineRunFunction1,COIPipelineRunFunction@@COI_1.0\");\n+__asm__ (\".symver COIPipelineStartExecutingRunFunctions1,COIPipelineStartExecutingRunFunctions@@COI_1.0\");\n+__asm__ (\".symver COIProcessCreateFromMemory1,COIProcessCreateFromMemory@@COI_1.0\");\n+__asm__ (\".symver COIProcessDestroy1,COIProcessDestroy@@COI_1.0\");\n+__asm__ (\".symver COIProcessGetFunctionHandles1,COIProcessGetFunctionHandles@@COI_1.0\");\n+__asm__ (\".symver COIProcessLoadLibraryFromMemory2,COIProcessLoadLibraryFromMemory@COI_2.0\");\n+__asm__ (\".symver COIProcessRegisterLibraries1,COIProcessRegisterLibraries@@COI_1.0\");\n+__asm__ (\".symver COIProcessWaitForShutdown1,COIProcessWaitForShutdown@@COI_1.0\");\n+"}, {"sha": "496713fb4f7d1a815ec42770d6399f6b52442516", "filename": "liboffloadmic/runtime/emulator/coi_version_linker_script.map", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+COI_1.0\n+{\n+  global:\n+    COIBufferAddRef;\n+    COIBufferCopy;\n+    COIBufferCreate;\n+    COIBufferCreateFromMemory;\n+    COIBufferDestroy;\n+    COIBufferGetSinkAddress;\n+    COIBufferMap;\n+    COIBufferRead;\n+    COIBufferReleaseRef;\n+    COIBufferSetState;\n+    COIBufferUnmap;\n+    COIBufferWrite;\n+    COIEngineGetCount;\n+    COIEngineGetHandle;\n+    COIEngineGetIndex;\n+    COIEventWait;\n+    COIPerfGetCycleFrequency;\n+    COIPipelineCreate;\n+    COIPipelineDestroy;\n+    COIPipelineRunFunction;\n+    COIPipelineStartExecutingRunFunctions;\n+    COIProcessCreateFromMemory;\n+    COIProcessDestroy;\n+    COIProcessGetFunctionHandles;\n+    COIProcessLoadLibraryFromMemory;\n+    COIProcessRegisterLibraries;\n+    COIProcessWaitForShutdown;\n+  local:\n+    *;\n+};\n+\n+COI_2.0\n+{\n+\n+} COI_1.0;\n+"}, {"sha": "bee59f0e1131437cb9ed8458f8a8b044cda1aef8", "filename": "liboffloadmic/runtime/emulator/myo_client.cpp", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,31 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+/* We don't need to implement any MYO client functions.  */\n+"}, {"sha": "e18abecd05cdc2a44e5e31c1160ce680ca302f2e", "filename": "liboffloadmic/runtime/emulator/myo_service.cpp", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,159 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+#include \"myo_service.h\"\n+\n+#include \"myo_version_asm.h\"\n+\n+\n+extern \"C\"\n+{\n+\n+MYOACCESSAPI MyoError\n+SYMBOL_VERSION (myoAcquire, 1) ()\n+{\n+  MYOTRACE (\"myoAcquire\");\n+\n+  assert (false);\n+\n+  return MYO_ERROR;\n+}\n+\n+\n+MYOACCESSAPI MyoError\n+SYMBOL_VERSION (myoRelease, 1) ()\n+{\n+  MYOTRACE (\"myoRelease\");\n+\n+  assert (false);\n+\n+  return MYO_ERROR;\n+}\n+\n+\n+MYOACCESSAPI void\n+SYMBOL_VERSION (myoSharedAlignedFree, 1) (void *ptr)\n+{\n+  MYOTRACE (\"myoSharedAlignedFree\");\n+\n+  assert (false);\n+}\n+\n+\n+MYOACCESSAPI void*\n+SYMBOL_VERSION (myoSharedAlignedMalloc, 1) (size_t size,\n+\t\t\t\t\t    size_t alignment)\n+{\n+  MYOTRACE (\"myoSharedAlignedMalloc\");\n+\n+  assert (false);\n+\n+  return 0;\n+}\n+\n+\n+MYOACCESSAPI void\n+SYMBOL_VERSION (myoSharedFree, 1) (void *ptr)\n+{\n+  MYOTRACE (\"myoSharedFree\");\n+ \n+  assert (false);\n+}\n+\n+\n+MYOACCESSAPI void*\n+SYMBOL_VERSION (myoSharedMalloc, 1) (size_t size)\n+{\n+  MYOTRACE (\"myoSharedMalloc\");\n+\n+  assert (false);\n+\n+  return 0;\n+}\n+\n+\n+MYOACCESSAPI MyoError\n+SYMBOL_VERSION (myoiLibInit, 1) (void *args,\n+\t\t\t\t void *init_func)\n+{\n+  MYOTRACE (\"myoiLibInit\");\n+\n+  assert (false);\n+\n+  return MYO_ERROR;\n+}\n+\n+\n+MYOACCESSAPI void\n+SYMBOL_VERSION (myoiLibFini, 1) ()\n+{\n+  MYOTRACE (\"myoiLibFini\");\n+\n+  assert (false);\n+}\n+\n+\n+MyoError\n+SYMBOL_VERSION (myoiMicVarTableRegister, 1) (void *table,\n+\t\t\t\t\t     int num)\n+{\n+  MYOTRACE (\"myoiMicVarTableRegister\");\n+\n+  assert (false);\n+\n+  return MYO_ERROR;\n+}\n+\n+\n+MYOACCESSAPI MyoError\n+SYMBOL_VERSION (myoiRemoteFuncRegister, 1) (MyoiRemoteFuncType type,\n+\t\t\t\t\t    const char *name)\n+{\n+  MYOTRACE (\"myoiRemoteFuncRegister\");\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return MYO_SUCCESS;\n+}\n+\n+\n+MyoError\n+SYMBOL_VERSION (myoiTargetFptrTableRegister, 1) (void *table,\n+\t\t\t\t\t\t int num,\n+\t\t\t\t\t\t int ordered)\n+{\n+  MYOTRACE (\"myoiTargetFptrTableRegister\");\n+\n+  assert (false);\n+\n+  return MYO_ERROR;\n+}\n+\n+} // extern \"C\"\n+"}, {"sha": "776e8c2c40d7a0681b1d0bc45f40f1d6dd250536", "filename": "liboffloadmic/runtime/emulator/myo_service.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,63 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+#ifndef MYO_SERVICE_H_INCLUDED\n+#define MYO_SERVICE_H_INCLUDED\n+\n+#include <myo.h>\n+#include <myoimpl.h>\n+#include <myotypes.h>\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#define SYMBOL_VERSION(SYMBOL,VERSION) SYMBOL ## VERSION\n+\n+#define MYOERROR(...)\t\t\t    \\\n+{\t\t\t\t\t    \\\n+  fprintf (stderr, \"MYO ERROR - TARGET: \"); \\\n+  fprintf (stderr, __VA_ARGS__);\t    \\\n+  fprintf (stderr, \"\\n\");\t\t    \\\n+  perror (NULL);\t\t\t    \\\n+  return MYO_ERROR;\t\t\t    \\\n+}\n+\n+#ifdef DEBUG\n+  #define MYOTRACE(...)\t\t\t      \\\n+  {\t\t\t\t\t      \\\n+    fprintf (stderr, \"MYO TRACE - TARGET: \"); \\\n+    fprintf (stderr, __VA_ARGS__);\t      \\\n+    fprintf (stderr, \"\\n\");\t\t      \\\n+  }\n+#else\n+  #define MYOTRACE(...) {}\n+#endif\n+\n+#endif // MYO_SERVICE_H_INCLUDED"}, {"sha": "2bd8302ab6a77b0960553a636d7dc9c53b6352aa", "filename": "liboffloadmic/runtime/emulator/myo_version_asm.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+__asm__ (\".symver myoAcquire1,myoAcquire@@MYO_1.0\");\n+__asm__ (\".symver myoRelease1,myoRelease@@MYO_1.0\");\n+__asm__ (\".symver myoSharedAlignedFree1,myoSharedAlignedFree@@MYO_1.0\");\n+__asm__ (\".symver myoSharedAlignedMalloc1,myoSharedAlignedMalloc@@MYO_1.0\");\n+__asm__ (\".symver myoSharedFree1,myoSharedFree@@MYO_1.0\");\n+__asm__ (\".symver myoSharedMalloc1,myoSharedMalloc@@MYO_1.0\");\n+\n+__asm__ (\".symver myoiLibInit1,myoiLibInit@@MYO_1.0\");\n+__asm__ (\".symver myoiLibFini1,myoiLibFini@@MYO_1.0\");\n+__asm__ (\".symver myoiMicVarTableRegister1,myoiMicVarTableRegister@@MYO_1.0\");\n+__asm__ (\".symver myoiRemoteFuncRegister1,myoiRemoteFuncRegister@@MYO_1.0\");\n+__asm__ (\".symver myoiTargetFptrTableRegister1,myoiTargetFptrTableRegister@@MYO_1.0\");\n+"}, {"sha": "361b289d1b65e3bf894a5e6e1e95e8c3e5e56905", "filename": "liboffloadmic/runtime/emulator/myo_version_linker_script.map", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2010-2013 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+ * 02110-1301 USA.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+MYO_1.0\n+{\n+  global:\n+    myoAcquire;\n+    myoRelease;\n+    myoSharedAlignedFree;\n+    myoSharedAlignedMalloc;\n+    myoSharedFree;\n+    myoSharedMalloc;\n+\n+    myoiLibInit;\n+    myoiLibFini;\n+    myoiMicVarTableRegister;\n+    myoiRemoteFuncRegister;\n+    myoiTargetFptrTableRegister;\n+\n+  local:\n+    *;\n+};\n+"}, {"sha": "eb5699d3c5cc7e19c72fb848eeecafa2deab329d", "filename": "liboffloadmic/runtime/liboffload_error.c", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fliboffload_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fliboffload_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_error.c?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,475 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+#ifndef va_copy\n+#define va_copy(dst, src) ((dst) = (src))\n+#endif\n+\n+#include \"liboffload_msg.h\"\n+\n+#include \"liboffload_error_codes.h\"\n+\n+/***********************************************/\n+/* error-handling function, liboffload_error_support */\n+/***********************************************/\n+\n+void __liboffload_error_support(error_types input_tag, ...)\n+{\n+    va_list args;\n+    va_start(args, input_tag);\n+\n+    switch (input_tag) {\n+        case c_device_is_not_available:\n+            write_message(stderr, msg_c_device_is_not_available, args);\n+            break;\n+        case c_invalid_device_number:\n+            write_message(stderr, msg_c_invalid_device_number, args);\n+            break;\n+        case c_send_func_ptr:\n+            write_message(stderr, msg_c_send_func_ptr, args);\n+            break;\n+        case c_receive_func_ptr:\n+            write_message(stderr, msg_c_receive_func_ptr, args);\n+            break;\n+        case c_malloc:\n+            write_message(stderr, msg_c_malloc, args);\n+            break;\n+        case c_offload_malloc:\n+            write_message(stderr, msg_c_offload_malloc, args);\n+            break;\n+        case c_offload1:\n+            write_message(stderr, msg_c_offload1, args);\n+            break;\n+        case c_unknown_var_type:\n+            write_message(stderr, c_unknown_var_type, args);\n+            break;\n+        case c_invalid_env_var_value:\n+            write_message(stderr, msg_c_invalid_env_var_value, args);\n+            break;\n+        case c_invalid_env_var_int_value:\n+            write_message(stderr, msg_c_invalid_env_var_int_value, args);\n+            break;\n+        case c_invalid_env_report_value:\n+            write_message(stderr, msg_c_invalid_env_report_value, args);\n+            break;\n+        case c_offload_signaled1:\n+            write_message(stderr, msg_c_offload_signaled1, args);\n+            break;\n+        case c_offload_signaled2:\n+            write_message(stderr, msg_c_offload_signaled2, args);\n+            break;\n+        case c_myowrapper_checkresult:\n+            write_message(stderr, msg_c_myowrapper_checkresult, args);\n+            break;\n+        case c_myotarget_checkresult:\n+            write_message(stderr, msg_c_myotarget_checkresult, args);\n+            break;\n+        case c_offload_descriptor_offload:\n+            write_message(stderr, msg_c_offload_descriptor_offload, args);\n+            break;\n+        case c_merge_var_descs1:\n+            write_message(stderr, msg_c_merge_var_descs1, args);\n+            break;\n+        case c_merge_var_descs2:\n+            write_message(stderr, msg_c_merge_var_descs2, args);\n+            break;\n+        case c_mic_parse_env_var_list1:\n+            write_message(stderr, msg_c_mic_parse_env_var_list1, args);\n+            break;\n+        case c_mic_parse_env_var_list2:\n+            write_message(stderr, msg_c_mic_parse_env_var_list2, args);\n+            break;\n+        case c_mic_process_exit_ret:\n+            write_message(stderr, msg_c_mic_process_exit_ret, args);\n+            break;\n+        case c_mic_process_exit_sig:\n+            write_message(stderr, msg_c_mic_process_exit_sig, args);\n+            break;\n+        case c_mic_process_exit:\n+            write_message(stderr, msg_c_mic_process_exit, args);\n+            break;\n+        case c_mic_init3:\n+            write_message(stderr, msg_c_mic_init3, args);\n+            break;\n+        case c_mic_init4:\n+            write_message(stderr, msg_c_mic_init4, args);\n+            break;\n+        case c_mic_init5:\n+            write_message(stderr, msg_c_mic_init5, args);\n+            break;\n+        case c_mic_init6:\n+            write_message(stderr, msg_c_mic_init6, args);\n+            break;\n+        case c_no_static_var_data:\n+            write_message(stderr, msg_c_no_static_var_data, args);\n+            break;\n+        case c_no_ptr_data:\n+            write_message(stderr, msg_c_no_ptr_data, args);\n+            break;\n+        case c_get_engine_handle:\n+            write_message(stderr, msg_c_get_engine_handle, args);\n+            break;\n+        case c_get_engine_index:\n+            write_message(stderr, msg_c_get_engine_index, args);\n+            break;\n+        case c_process_create:\n+            write_message(stderr, msg_c_process_create, args);\n+            break;\n+        case c_process_wait_shutdown:\n+            write_message(stderr, msg_c_process_wait_shutdown, args);\n+            break;\n+        case c_process_proxy_flush:\n+            write_message(stderr, msg_c_process_proxy_flush, args);\n+            break;\n+        case c_process_get_func_handles:\n+            write_message(stderr, msg_c_process_get_func_handles, args);\n+            break;\n+        case c_load_library:\n+            write_message(stderr, msg_c_load_library, args);\n+            break;\n+        case c_coipipe_max_number:\n+            write_message(stderr, msg_c_coi_pipeline_max_number, args);\n+            break;\n+        case c_pipeline_create:\n+            write_message(stderr, msg_c_pipeline_create, args);\n+            break;\n+        case c_pipeline_run_func:\n+            write_message(stderr, msg_c_pipeline_run_func, args);\n+            break;\n+        case c_pipeline_start_run_funcs:\n+            write_message(stderr, msg_c_pipeline_start_run_funcs, args);\n+            break;\n+        case c_buf_create:\n+            write_message(stderr, msg_c_buf_create, args);\n+            break;\n+        case c_buf_create_out_of_mem:\n+            write_message(stderr, msg_c_buf_create_out_of_mem, args);\n+            break;\n+        case c_buf_create_from_mem:\n+            write_message(stderr, msg_c_buf_create_from_mem, args);\n+            break;\n+        case c_buf_destroy:\n+            write_message(stderr, msg_c_buf_destroy, args);\n+            break;\n+        case c_buf_map:\n+            write_message(stderr, msg_c_buf_map, args);\n+            break;\n+        case c_buf_unmap:\n+            write_message(stderr, msg_c_buf_unmap, args);\n+            break;\n+        case c_buf_read:\n+            write_message(stderr, msg_c_buf_read, args);\n+            break;\n+        case c_buf_write:\n+            write_message(stderr, msg_c_buf_write, args);\n+            break;\n+        case c_buf_copy:\n+            write_message(stderr, msg_c_buf_copy, args);\n+            break;\n+        case c_buf_get_address:\n+            write_message(stderr, msg_c_buf_get_address, args);\n+            break;\n+        case c_buf_add_ref:\n+            write_message(stderr, msg_c_buf_add_ref, args);\n+            break;\n+        case c_buf_release_ref:\n+            write_message(stderr, msg_c_buf_release_ref, args);\n+            break;\n+        case c_buf_set_state:\n+            write_message(stderr, msg_c_buf_set_state, args);\n+            break;\n+        case c_event_wait:\n+            write_message(stderr, msg_c_event_wait, args);\n+            break;\n+        case c_zero_or_neg_ptr_len:\n+            write_message(stderr, msg_c_zero_or_neg_ptr_len, args);\n+            break;\n+        case c_zero_or_neg_transfer_size:\n+            write_message(stderr, msg_c_zero_or_neg_transfer_size, args);\n+            break;\n+        case c_bad_ptr_mem_range:\n+            write_message(stderr, msg_c_bad_ptr_mem_range, args);\n+            break;\n+        case c_different_src_and_dstn_sizes:\n+            write_message(stderr, msg_c_different_src_and_dstn_sizes, args);\n+            break;\n+        case c_ranges_dont_match:\n+            write_message(stderr, msg_c_ranges_dont_match, args);\n+            break;\n+        case c_destination_is_over:\n+            write_message(stderr, msg_c_destination_is_over, args);\n+            break;\n+        case c_slice_of_noncont_array:\n+            write_message(stderr, msg_c_slice_of_noncont_array, args);\n+            break;\n+        case c_non_contiguous_dope_vector:\n+            write_message(stderr, msg_c_non_contiguous_dope_vector, args);\n+            break;\n+        case c_pointer_array_mismatch:\n+            write_message(stderr, msg_c_pointer_array_mismatch, args);\n+            break;\n+        case c_omp_invalid_device_num_env:\n+            write_message(stderr, msg_c_omp_invalid_device_num_env, args);\n+            break;\n+        case c_omp_invalid_device_num:\n+            write_message(stderr, msg_c_omp_invalid_device_num, args);\n+            break;\n+        case c_unknown_binary_type:\n+            write_message(stderr, msg_c_unknown_binary_type, args);\n+            break;\n+        case c_multiple_target_exes:\n+            write_message(stderr, msg_c_multiple_target_exes, args);\n+            break;\n+        case c_no_target_exe:\n+            write_message(stderr, msg_c_no_target_exe, args);\n+            break;\n+        case c_report_unknown_timer_node:\n+            write_message(stderr, msg_c_report_unknown_timer_node, args);\n+            break;\n+        case c_report_unknown_trace_node:\n+            write_message(stderr, msg_c_report_unknown_trace_node, args);\n+            break;\n+    }\n+    va_end(args);\n+}\n+\n+char const * report_get_message_str(error_types input_tag)\n+{\n+    switch (input_tag) {\n+        case c_report_title:\n+            return (offload_get_message_str(msg_c_report_title));\n+        case c_report_from_file:\n+            return (offload_get_message_str(msg_c_report_from_file));\n+        case c_report_offload:\n+            return (offload_get_message_str(msg_c_report_offload));\n+        case c_report_mic:\n+            return (offload_get_message_str(msg_c_report_mic));\n+        case c_report_file:\n+            return (offload_get_message_str(msg_c_report_file));\n+        case c_report_line:\n+            return (offload_get_message_str(msg_c_report_line));\n+        case c_report_host:\n+            return (offload_get_message_str(msg_c_report_host));\n+        case c_report_tag:\n+            return (offload_get_message_str(msg_c_report_tag));\n+        case c_report_cpu_time:\n+            return (offload_get_message_str(msg_c_report_cpu_time));\n+        case c_report_seconds:\n+            return (offload_get_message_str(msg_c_report_seconds));\n+        case c_report_cpu_to_mic_data:\n+            return (offload_get_message_str(msg_c_report_cpu_to_mic_data));\n+        case c_report_bytes:\n+            return (offload_get_message_str(msg_c_report_bytes));\n+        case c_report_mic_time:\n+            return (offload_get_message_str(msg_c_report_mic_time));\n+        case c_report_mic_to_cpu_data:\n+            return (offload_get_message_str(msg_c_report_mic_to_cpu_data));\n+        case c_report_compute:\n+            return (offload_get_message_str(msg_c_report_compute));\n+        case c_report_copyin_data:\n+            return (offload_get_message_str(msg_c_report_copyin_data));\n+        case c_report_copyout_data:\n+            return (offload_get_message_str(msg_c_report_copyout_data));\n+        case c_report_create_buf_host:\n+            return (offload_get_message_str(c_report_create_buf_host));\n+        case c_report_create_buf_mic:\n+            return (offload_get_message_str(msg_c_report_create_buf_mic));\n+        case c_report_destroy:\n+            return (offload_get_message_str(msg_c_report_destroy));\n+        case c_report_gather_copyin_data:\n+            return (offload_get_message_str(msg_c_report_gather_copyin_data));\n+        case c_report_gather_copyout_data:\n+            return (offload_get_message_str(msg_c_report_gather_copyout_data));\n+        case c_report_state_signal:\n+            return (offload_get_message_str(msg_c_report_state_signal));\n+        case c_report_signal:\n+            return (offload_get_message_str(msg_c_report_signal));\n+        case c_report_wait:\n+            return (offload_get_message_str(msg_c_report_wait));\n+        case c_report_init:\n+            return (offload_get_message_str(msg_c_report_init));\n+        case c_report_init_func:\n+            return (offload_get_message_str(msg_c_report_init_func));\n+        case c_report_logical_card:\n+            return (offload_get_message_str(msg_c_report_logical_card));\n+        case c_report_mic_myo_fptr:\n+            return (offload_get_message_str(msg_c_report_mic_myo_fptr));\n+        case c_report_mic_myo_shared:\n+            return (offload_get_message_str(msg_c_report_mic_myo_shared));\n+        case c_report_myoacquire:\n+            return (offload_get_message_str(msg_c_report_myoacquire));\n+        case c_report_myofini:\n+            return (offload_get_message_str(msg_c_report_myofini));\n+        case c_report_myoinit:\n+            return (offload_get_message_str(msg_c_report_myoinit));\n+        case c_report_myoregister:\n+            return (offload_get_message_str(msg_c_report_myoregister));\n+        case c_report_myorelease:\n+            return (offload_get_message_str(msg_c_report_myorelease));\n+        case c_report_myosharedalignedfree:\n+            return (\n+                offload_get_message_str(msg_c_report_myosharedalignedfree));\n+        case c_report_myosharedalignedmalloc:\n+            return (\n+                offload_get_message_str(msg_c_report_myosharedalignedmalloc));\n+        case c_report_myosharedfree:\n+            return (offload_get_message_str(msg_c_report_myosharedfree));\n+        case c_report_myosharedmalloc:\n+            return (offload_get_message_str(msg_c_report_myosharedmalloc));\n+        case c_report_physical_card:\n+            return (offload_get_message_str(msg_c_report_physical_card));\n+        case c_report_receive_pointer_data:\n+            return (\n+                offload_get_message_str(msg_c_report_receive_pointer_data));\n+        case c_report_received_pointer_data:\n+            return (\n+                offload_get_message_str(msg_c_report_received_pointer_data));\n+        case c_report_register:\n+            return (offload_get_message_str(msg_c_report_register));\n+        case c_report_scatter_copyin_data:\n+            return (offload_get_message_str(msg_c_report_scatter_copyin_data));\n+        case c_report_scatter_copyout_data:\n+            return (\n+                offload_get_message_str(msg_c_report_scatter_copyout_data));\n+        case c_report_send_pointer_data:\n+            return (offload_get_message_str(msg_c_report_send_pointer_data));\n+        case c_report_sent_pointer_data:\n+            return (offload_get_message_str(msg_c_report_sent_pointer_data));\n+        case c_report_start:\n+            return (offload_get_message_str(msg_c_report_start));\n+        case c_report_start_target_func:\n+            return (offload_get_message_str(msg_c_report_start_target_func));\n+        case c_report_state:\n+            return (offload_get_message_str(msg_c_report_state));\n+        case c_report_unregister:\n+            return (offload_get_message_str(msg_c_report_unregister));\n+        case c_report_var:\n+            return (offload_get_message_str(msg_c_report_var));\n+\n+        default:\n+            LIBOFFLOAD_ERROR(c_report_unknown_trace_node);\n+            abort();\n+    }\n+}\n+\n+char const * report_get_host_stage_str(int i)\n+{\n+    switch (i) {\n+        case c_offload_host_total_offload:\n+            return (\n+               offload_get_message_str(msg_c_report_host_total_offload_time));\n+        case c_offload_host_initialize:\n+            return (offload_get_message_str(msg_c_report_host_initialize));\n+        case c_offload_host_target_acquire:\n+            return (\n+                offload_get_message_str(msg_c_report_host_target_acquire));\n+        case c_offload_host_wait_deps:\n+            return (offload_get_message_str(msg_c_report_host_wait_deps));\n+        case c_offload_host_setup_buffers:\n+            return (offload_get_message_str(msg_c_report_host_setup_buffers));\n+        case c_offload_host_alloc_buffers:\n+            return (offload_get_message_str(msg_c_report_host_alloc_buffers));\n+        case c_offload_host_setup_misc_data:\n+            return (\n+                offload_get_message_str(msg_c_report_host_setup_misc_data));\n+        case c_offload_host_alloc_data_buffer:\n+            return (\n+                offload_get_message_str(msg_c_report_host_alloc_data_buffer));\n+        case c_offload_host_send_pointers:\n+            return (offload_get_message_str(msg_c_report_host_send_pointers));\n+        case c_offload_host_gather_inputs:\n+            return (offload_get_message_str(msg_c_report_host_gather_inputs));\n+        case c_offload_host_map_in_data_buffer:\n+            return (\n+                offload_get_message_str(msg_c_report_host_map_in_data_buffer));\n+        case c_offload_host_unmap_in_data_buffer:\n+            return (offload_get_message_str(\n+                msg_c_report_host_unmap_in_data_buffer));\n+        case c_offload_host_start_compute:\n+            return (offload_get_message_str(msg_c_report_host_start_compute));\n+        case c_offload_host_wait_compute:\n+            return (offload_get_message_str(msg_c_report_host_wait_compute));\n+        case c_offload_host_start_buffers_reads:\n+            return (offload_get_message_str(\n+                msg_c_report_host_start_buffers_reads));\n+        case c_offload_host_scatter_outputs:\n+            return (\n+                offload_get_message_str(msg_c_report_host_scatter_outputs));\n+        case c_offload_host_map_out_data_buffer:\n+            return (offload_get_message_str(\n+                msg_c_report_host_map_out_data_buffer));\n+        case c_offload_host_unmap_out_data_buffer:\n+            return (offload_get_message_str(\n+                msg_c_report_host_unmap_out_data_buffer));\n+        case c_offload_host_wait_buffers_reads:\n+            return (\n+                offload_get_message_str(msg_c_report_host_wait_buffers_reads));\n+        case c_offload_host_destroy_buffers:\n+            return (\n+                offload_get_message_str(msg_c_report_host_destroy_buffers));\n+        default:\n+            LIBOFFLOAD_ERROR(c_report_unknown_timer_node);\n+            abort();\n+    }\n+}\n+\n+char const * report_get_target_stage_str(int i)\n+{\n+    switch (i) {\n+        case c_offload_target_total_time:\n+            return (offload_get_message_str(msg_c_report_target_total_time));\n+        case c_offload_target_descriptor_setup:\n+            return (\n+                offload_get_message_str(msg_c_report_target_descriptor_setup));\n+        case c_offload_target_func_lookup:\n+            return (offload_get_message_str(msg_c_report_target_func_lookup));\n+        case c_offload_target_func_time:\n+            return (offload_get_message_str(msg_c_report_target_func_time));\n+        case c_offload_target_scatter_inputs:\n+            return (\n+                offload_get_message_str(msg_c_report_target_scatter_inputs));\n+        case c_offload_target_add_buffer_refs:\n+            return (\n+                offload_get_message_str(msg_c_report_target_add_buffer_refs));\n+        case c_offload_target_compute:\n+            return (offload_get_message_str(msg_c_report_target_compute));\n+        case c_offload_target_gather_outputs:\n+            return (offload_get_message_str\n+                (msg_c_report_target_gather_outputs));\n+        case c_offload_target_release_buffer_refs:\n+            return (offload_get_message_str(\n+                msg_c_report_target_release_buffer_refs));\n+        default:\n+            LIBOFFLOAD_ERROR(c_report_unknown_timer_node);\n+            abort();\n+    }\n+}"}, {"sha": "c33bef562365dec812cb5ccb973adbd74367a8a1", "filename": "liboffloadmic/runtime/liboffload_error_codes.h", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,297 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#if !defined(LIBOFFLOAD_ERROR_CODES_H)\n+#define LIBOFFLOAD_ERROR_CODES_H\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+typedef enum\n+{\n+    c_device_is_not_available = 0,\n+    c_invalid_device_number,\n+    c_offload1,\n+    c_unknown_var_type,\n+    c_send_func_ptr,\n+    c_receive_func_ptr,\n+    c_malloc,\n+    c_offload_malloc,\n+    c_invalid_env_var_value,\n+    c_invalid_env_var_int_value,\n+    c_invalid_env_report_value,\n+    c_offload_signaled1,\n+    c_offload_signaled2,\n+    c_myotarget_checkresult,\n+    c_myowrapper_checkresult,\n+    c_offload_descriptor_offload,\n+    c_merge_var_descs1,\n+    c_merge_var_descs2,\n+    c_mic_parse_env_var_list1,\n+    c_mic_parse_env_var_list2,\n+    c_mic_process_exit_ret,\n+    c_mic_process_exit_sig,\n+    c_mic_process_exit,\n+    c_mic_init3,\n+    c_mic_init4,\n+    c_mic_init5,\n+    c_mic_init6,\n+    c_no_static_var_data,\n+    c_no_ptr_data,\n+    c_get_engine_handle,\n+    c_get_engine_index,\n+    c_process_create,\n+    c_process_get_func_handles,\n+    c_process_wait_shutdown,\n+    c_process_proxy_flush,\n+    c_load_library,\n+    c_pipeline_create,\n+    c_pipeline_run_func,\n+    c_pipeline_start_run_funcs,\n+    c_buf_create,\n+    c_buf_create_out_of_mem,\n+    c_buf_create_from_mem,\n+    c_buf_destroy,\n+    c_buf_map,\n+    c_buf_unmap,\n+    c_buf_read,\n+    c_buf_write,\n+    c_buf_copy,\n+    c_buf_get_address,\n+    c_buf_add_ref,\n+    c_buf_release_ref,\n+    c_buf_set_state,\n+    c_event_wait,\n+    c_zero_or_neg_ptr_len,\n+    c_zero_or_neg_transfer_size,\n+    c_bad_ptr_mem_range,\n+    c_different_src_and_dstn_sizes,\n+    c_ranges_dont_match,\n+    c_destination_is_over,\n+    c_slice_of_noncont_array,\n+    c_non_contiguous_dope_vector,\n+    c_pointer_array_mismatch,\n+    c_omp_invalid_device_num_env,\n+    c_omp_invalid_device_num,\n+    c_unknown_binary_type,\n+    c_multiple_target_exes,\n+    c_no_target_exe,\n+    c_report_host,\n+    c_report_target,\n+    c_report_title,\n+    c_report_from_file,\n+    c_report_file,\n+    c_report_line,\n+    c_report_tag,\n+    c_report_seconds,\n+    c_report_bytes,\n+    c_report_mic,\n+    c_report_cpu_time,\n+    c_report_cpu_to_mic_data,\n+    c_report_mic_time,\n+    c_report_mic_to_cpu_data,\n+    c_report_unknown_timer_node,\n+    c_report_unknown_trace_node,\n+    c_report_offload,\n+    c_report_w_tag,\n+    c_report_state,\n+    c_report_start,\n+    c_report_init,\n+    c_report_logical_card,\n+    c_report_physical_card,\n+    c_report_register,\n+    c_report_init_func,\n+    c_report_create_buf_host,\n+    c_report_create_buf_mic,\n+    c_report_send_pointer_data,\n+    c_report_sent_pointer_data,\n+    c_report_gather_copyin_data,\n+    c_report_copyin_data,\n+    c_report_state_signal,\n+    c_report_signal,\n+    c_report_wait,\n+    c_report_compute,\n+    c_report_receive_pointer_data,\n+    c_report_received_pointer_data,\n+    c_report_start_target_func,\n+    c_report_var,\n+    c_report_scatter_copyin_data,\n+    c_report_gather_copyout_data,\n+    c_report_scatter_copyout_data,\n+    c_report_copyout_data,\n+    c_report_unregister,\n+    c_report_destroy,\n+    c_report_myoinit,\n+    c_report_myoregister,\n+    c_report_myofini,\n+    c_report_mic_myo_shared,\n+    c_report_mic_myo_fptr,\n+    c_report_myosharedmalloc,\n+    c_report_myosharedfree,\n+    c_report_myosharedalignedmalloc,\n+    c_report_myosharedalignedfree,\n+    c_report_myoacquire,\n+    c_report_myorelease,\n+    c_coipipe_max_number\n+} error_types;\n+\n+enum OffloadHostPhase {\n+    // Total time on host for entire offload\n+    c_offload_host_total_offload = 0,\n+\n+    // Time to load target binary\n+    c_offload_host_initialize,\n+\n+    // Time to acquire lrb availability dynamically\n+    c_offload_host_target_acquire,\n+\n+    // Time to wait for dependencies\n+    c_offload_host_wait_deps,\n+\n+    // Time to allocate pointer buffers, initiate writes for pointers\n+    // and calculate size of copyin/copyout buffer\n+    c_offload_host_setup_buffers,\n+\n+    // Time to allocate pointer buffers\n+    c_offload_host_alloc_buffers,\n+\n+    // Time to initialize misc data\n+    c_offload_host_setup_misc_data,\n+\n+    // Time to allocate copyin/copyout buffer\n+    c_offload_host_alloc_data_buffer,\n+\n+    // Time to initiate writes from host pointers to buffers\n+    c_offload_host_send_pointers,\n+\n+    // Time to Gather IN data of offload into buffer\n+    c_offload_host_gather_inputs,\n+\n+    // Time to map buffer\n+    c_offload_host_map_in_data_buffer,\n+\n+    // Time to unmap buffer\n+    c_offload_host_unmap_in_data_buffer,\n+\n+    // Time to start remote function call that does computation on lrb\n+    c_offload_host_start_compute,\n+\n+    // Time to wait for compute to finish\n+    c_offload_host_wait_compute,\n+\n+    // Time to initiate reads from pointer buffers\n+    c_offload_host_start_buffers_reads,\n+\n+    // Time to update host variabels with OUT data from buffer\n+    c_offload_host_scatter_outputs,\n+\n+    // Time to map buffer\n+    c_offload_host_map_out_data_buffer,\n+\n+    // Time to unmap buffer\n+    c_offload_host_unmap_out_data_buffer,\n+\n+    // Time to wait reads from buffers to finish\n+    c_offload_host_wait_buffers_reads,\n+\n+    // Time to destroy buffers that are no longer needed\n+    c_offload_host_destroy_buffers,\n+\n+    // LAST TIME MONITOR\n+    c_offload_host_max_phase\n+};\n+\n+enum OffloadTargetPhase {\n+    // Total time spent on the target\n+    c_offload_target_total_time = 0,\n+\n+    // Time to initialize offload descriptor\n+    c_offload_target_descriptor_setup,\n+\n+    // Time to find target entry point in lookup table\n+    c_offload_target_func_lookup,\n+\n+    // Total time spend executing offload entry\n+    c_offload_target_func_time,\n+\n+    // Time to initialize target variables with IN values from buffer\n+    c_offload_target_scatter_inputs,\n+\n+    // Time to add buffer reference for pointer buffers\n+    c_offload_target_add_buffer_refs,\n+\n+    // Total time on lrb for computation\n+    c_offload_target_compute,\n+\n+    // On lrb, time to copy OUT into buffer\n+    c_offload_target_gather_outputs,\n+\n+    // Time to release buffer references\n+    c_offload_target_release_buffer_refs,\n+\n+    // LAST TIME MONITOR\n+    c_offload_target_max_phase\n+};\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+void __liboffload_error_support(error_types input_tag, ...);\n+void __liboffload_report_support(error_types input_tag, ...);\n+char const *offload_get_message_str(int msgCode);\n+char const * report_get_message_str(error_types input_tag);\n+char const * report_get_host_stage_str(int i);\n+char const * report_get_target_stage_str(int i);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#define test_msg_cat(nm, msg) \\\n+    fprintf(stderr, \"\\t TEST for %s \\n \\t\", nm); \\\n+    __liboffload_error_support(msg);\n+\n+#define test_msg_cat1(nm, msg, ...) \\\n+    fprintf(stderr, \"\\t TEST for %s \\n \\t\", nm); \\\n+    __liboffload_error_support(msg, __VA_ARGS__);\n+\n+void write_message(FILE * file, int msgCode, va_list args_p);\n+\n+#define LIBOFFLOAD_ERROR __liboffload_error_support\n+\n+#ifdef TARGET_WINNT\n+#define LIBOFFLOAD_ABORT \\\n+         _set_abort_behavior(0, _WRITE_ABORT_MSG); \\\n+         abort()\n+#else\n+#define LIBOFFLOAD_ABORT \\\n+         abort()\n+#endif\n+\n+#endif // !defined(LIBOFFLOAD_ERROR_CODES_H)"}, {"sha": "c6d9fa7db1e4bd2ffbe5da68b45b9d39c199cabf", "filename": "liboffloadmic/runtime/liboffload_msg.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fliboffload_msg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fliboffload_msg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_msg.c?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,67 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+// ===========================================================================\n+// Bring in the static string table and the enumerations for indexing into\n+// it.\n+// ===========================================================================\n+\n+#include \"liboffload_msg.h\"\n+\n+# define DYNART_STDERR_PUTS(__message_text__) fputs((__message_text__),stderr)\n+\n+// ===========================================================================\n+// Now the code for accessing the message catalogs\n+// ===========================================================================\n+\n+\n+    void write_message(FILE * file, int msgCode, va_list args_p) {\n+        va_list args;\n+        char buf[1024];\n+\n+        va_copy(args, args_p);\n+        buf[0] = '\\n';\n+        vsnprintf(buf + 1, sizeof(buf) - 2,\n+                  MESSAGE_TABLE_NAME[ msgCode ], args);\n+        strcat(buf, \"\\n\");\n+        va_end(args);\n+        fputs(buf, file);\n+        fflush(file);\n+    }\n+\n+    char const *offload_get_message_str(int msgCode) {\n+        return MESSAGE_TABLE_NAME[ msgCode ];\n+    }"}, {"sha": "e43b6b63551ba7cc323852c3383688fd3d3d7184", "filename": "liboffloadmic/runtime/liboffload_msg.h", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fliboffload_msg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fliboffload_msg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_msg.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,348 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+// file: liboffload_msg.h\n+enum {\n+\t__dummy__ = 0,\n+\tmsg_c_device_is_not_available,\n+\tmsg_c_invalid_device_number,\n+\tmsg_c_send_func_ptr,\n+\tmsg_c_receive_func_ptr,\n+\tmsg_c_malloc,\n+\tmsg_c_offload_malloc,\n+\tmsg_c_offload1,\n+\tmsg_c_unknown_var_type,\n+\tmsg_c_invalid_env_var_value,\n+\tmsg_c_invalid_env_var_int_value,\n+\tmsg_c_invalid_env_report_value,\n+\tmsg_c_offload_signaled1,\n+\tmsg_c_offload_signaled2,\n+\tmsg_c_myowrapper_checkresult,\n+\tmsg_c_myotarget_checkresult,\n+\tmsg_c_offload_descriptor_offload,\n+\tmsg_c_merge_var_descs1,\n+\tmsg_c_merge_var_descs2,\n+\tmsg_c_mic_parse_env_var_list1,\n+\tmsg_c_mic_parse_env_var_list2,\n+\tmsg_c_mic_process_exit_ret,\n+\tmsg_c_mic_process_exit_sig,\n+\tmsg_c_mic_process_exit,\n+\tmsg_c_mic_init3,\n+\tmsg_c_mic_init4,\n+\tmsg_c_mic_init5,\n+\tmsg_c_mic_init6,\n+\tmsg_c_no_static_var_data,\n+\tmsg_c_no_ptr_data,\n+\tmsg_c_get_engine_handle,\n+\tmsg_c_get_engine_index,\n+\tmsg_c_process_create,\n+\tmsg_c_process_get_func_handles,\n+\tmsg_c_process_wait_shutdown,\n+\tmsg_c_process_proxy_flush,\n+\tmsg_c_load_library,\n+\tmsg_c_pipeline_create,\n+\tmsg_c_pipeline_run_func,\n+\tmsg_c_pipeline_start_run_funcs,\n+\tmsg_c_buf_create,\n+\tmsg_c_buf_create_out_of_mem,\n+\tmsg_c_buf_create_from_mem,\n+\tmsg_c_buf_destroy,\n+\tmsg_c_buf_map,\n+\tmsg_c_buf_unmap,\n+\tmsg_c_buf_read,\n+\tmsg_c_buf_write,\n+\tmsg_c_buf_copy,\n+\tmsg_c_buf_get_address,\n+\tmsg_c_buf_add_ref,\n+\tmsg_c_buf_release_ref,\n+\tmsg_c_buf_set_state,\n+\tmsg_c_event_wait,\n+\tmsg_c_zero_or_neg_ptr_len,\n+\tmsg_c_zero_or_neg_transfer_size,\n+\tmsg_c_bad_ptr_mem_range,\n+\tmsg_c_different_src_and_dstn_sizes,\n+\tmsg_c_non_contiguous_dope_vector,\n+\tmsg_c_omp_invalid_device_num_env,\n+\tmsg_c_omp_invalid_device_num,\n+\tmsg_c_unknown_binary_type,\n+\tmsg_c_multiple_target_exes,\n+\tmsg_c_no_target_exe,\n+\tmsg_c_report_unknown_timer_node,\n+\tmsg_c_report_unknown_trace_node,\n+\tmsg_c_report_host,\n+\tmsg_c_report_mic,\n+\tmsg_c_report_title,\n+\tmsg_c_report_seconds,\n+\tmsg_c_report_bytes,\n+\tmsg_c_report_cpu_time,\n+\tmsg_c_report_mic_time,\n+\tmsg_c_report_tag,\n+\tmsg_c_report_from_file,\n+\tmsg_c_report_file,\n+\tmsg_c_report_line,\n+\tmsg_c_report_cpu_to_mic_data,\n+\tmsg_c_report_mic_to_cpu_data,\n+\tmsg_c_report_offload,\n+\tmsg_c_report_w_tag,\n+\tmsg_c_report_state,\n+\tmsg_c_report_start,\n+\tmsg_c_report_init,\n+\tmsg_c_report_logical_card,\n+\tmsg_c_report_physical_card,\n+\tmsg_c_report_register,\n+\tmsg_c_report_init_func,\n+\tmsg_c_report_create_buf_host,\n+\tmsg_c_report_create_buf_mic,\n+\tmsg_c_report_send_pointer_data,\n+\tmsg_c_report_sent_pointer_data,\n+\tmsg_c_report_gather_copyin_data,\n+\tmsg_c_report_copyin_data,\n+\tmsg_c_report_state_signal,\n+\tmsg_c_report_signal,\n+\tmsg_c_report_wait,\n+\tmsg_c_report_compute,\n+\tmsg_c_report_receive_pointer_data,\n+\tmsg_c_report_received_pointer_data,\n+\tmsg_c_report_start_target_func,\n+\tmsg_c_report_var,\n+\tmsg_c_report_scatter_copyin_data,\n+\tmsg_c_report_gather_copyout_data,\n+\tmsg_c_report_scatter_copyout_data,\n+\tmsg_c_report_copyout_data,\n+\tmsg_c_report_unregister,\n+\tmsg_c_report_destroy,\n+\tmsg_c_report_myoinit,\n+\tmsg_c_report_myoregister,\n+\tmsg_c_report_myofini,\n+\tmsg_c_report_mic_myo_shared,\n+\tmsg_c_report_mic_myo_fptr,\n+\tmsg_c_report_myosharedmalloc,\n+\tmsg_c_report_myosharedfree,\n+\tmsg_c_report_myosharedalignedmalloc,\n+\tmsg_c_report_myosharedalignedfree,\n+\tmsg_c_report_myoacquire,\n+\tmsg_c_report_myorelease,\n+\tmsg_c_report_host_total_offload_time,\n+\tmsg_c_report_host_initialize,\n+\tmsg_c_report_host_target_acquire,\n+\tmsg_c_report_host_wait_deps,\n+\tmsg_c_report_host_setup_buffers,\n+\tmsg_c_report_host_alloc_buffers,\n+\tmsg_c_report_host_setup_misc_data,\n+\tmsg_c_report_host_alloc_data_buffer,\n+\tmsg_c_report_host_send_pointers,\n+\tmsg_c_report_host_gather_inputs,\n+\tmsg_c_report_host_map_in_data_buffer,\n+\tmsg_c_report_host_unmap_in_data_buffer,\n+\tmsg_c_report_host_start_compute,\n+\tmsg_c_report_host_wait_compute,\n+\tmsg_c_report_host_start_buffers_reads,\n+\tmsg_c_report_host_scatter_outputs,\n+\tmsg_c_report_host_map_out_data_buffer,\n+\tmsg_c_report_host_unmap_out_data_buffer,\n+\tmsg_c_report_host_wait_buffers_reads,\n+\tmsg_c_report_host_destroy_buffers,\n+\tmsg_c_report_target_total_time,\n+\tmsg_c_report_target_descriptor_setup,\n+\tmsg_c_report_target_func_lookup,\n+\tmsg_c_report_target_func_time,\n+\tmsg_c_report_target_scatter_inputs,\n+\tmsg_c_report_target_add_buffer_refs,\n+\tmsg_c_report_target_compute,\n+\tmsg_c_report_target_gather_outputs,\n+\tmsg_c_report_target_release_buffer_refs,\n+\tmsg_c_coi_pipeline_max_number,\n+\tmsg_c_ranges_dont_match,\n+\tmsg_c_destination_is_over,\n+\tmsg_c_slice_of_noncont_array,\n+\tmsg_c_pointer_array_mismatch,\n+\tlastMsg = 153,\n+\tfirstMsg = 1\n+};\n+\n+\n+#if !defined(MESSAGE_TABLE_NAME)\n+#    define MESSAGE_TABLE_NAME __liboffload_message_table\n+#endif\n+\n+static char const * MESSAGE_TABLE_NAME[] = {\n+\t/*   0 __dummy__                               */ \"Un-used message\",\n+\t/*   1 msg_c_device_is_not_available           */ \"offload error: cannot offload to MIC - device is not available\",\n+\t/*   2 msg_c_invalid_device_number             */ \"offload error: expected a number greater than or equal to -1\",\n+\t/*   3 msg_c_send_func_ptr                     */ \"offload error: cannot find function name for address %p\",\n+\t/*   4 msg_c_receive_func_ptr                  */ \"offload error: cannot find address of function %s\",\n+\t/*   5 msg_c_malloc                            */ \"offload error: memory allocation failed\",\n+\t/*   6 msg_c_offload_malloc                    */ \"offload error: memory allocation failed (requested=%lld bytes, align %lld)\",\n+\t/*   7 msg_c_offload1                          */ \"offload error: device %d does not have a pending signal for wait(%p)\",\n+\t/*   8 msg_c_unknown_var_type                  */ \"offload error: unknown variable type %d\",\n+\t/*   9 msg_c_invalid_env_var_value             */ \"offload warning: ignoring invalid value specified for %s\",\n+\t/*  10 msg_c_invalid_env_var_int_value         */ \"offload warning: specify an integer value for %s\",\n+\t/*  11 msg_c_invalid_env_report_value          */ \"offload warning: ignoring %s setting; use a value in range 1-3\",\n+\t/*  12 msg_c_offload_signaled1                 */ \"offload error: invalid device number %d specified in _Offload_signaled\",\n+\t/*  13 msg_c_offload_signaled2                 */ \"offload error: invalid signal %p specified for _Offload_signaled\",\n+\t/*  14 msg_c_myowrapper_checkresult            */ \"offload error: %s failed with error %d\",\n+\t/*  15 msg_c_myotarget_checkresult             */ \"offload error: %s failed with error %d\",\n+\t/*  16 msg_c_offload_descriptor_offload        */ \"offload error: cannot find offload entry %s\",\n+\t/*  17 msg_c_merge_var_descs1                  */ \"offload error: unexpected number of variable descriptors\",\n+\t/*  18 msg_c_merge_var_descs2                  */ \"offload error: unexpected variable type\",\n+\t/*  19 msg_c_mic_parse_env_var_list1           */ \"offload_error: MIC environment variable must begin with an alpabetic character\",\n+\t/*  20 msg_c_mic_parse_env_var_list2           */ \"offload_error: MIC environment variable value must be specified with \\'=\\'\",\n+\t/*  21 msg_c_mic_process_exit_ret              */ \"offload error: process on the device %d unexpectedly exited with code %d\",\n+\t/*  22 msg_c_mic_process_exit_sig              */ \"offload error: process on the device %d was terminated by signal %d (%s)\",\n+\t/*  23 msg_c_mic_process_exit                  */ \"offload error: process on the device %d was unexpectedly terminated\",\n+\t/*  24 msg_c_mic_init3                         */ \"offload warning: ignoring MIC_STACKSIZE setting; use a value >= 16K and a multiple of 4K\",\n+\t/*  25 msg_c_mic_init4                         */ \"offload error: thread key create failed with error %d\",\n+\t/*  26 msg_c_mic_init5                         */ \"offload warning: specify OFFLOAD_DEVICES as comma-separated physical device numbers or 'none'\",\n+\t/*  27 msg_c_mic_init6                         */ \"offload warning: OFFLOAD_DEVICES device number %d does not correspond to a physical device\",\n+\t/*  28 msg_c_no_static_var_data                */ \"offload error: cannot find data associated with statically allocated variable %p\",\n+\t/*  29 msg_c_no_ptr_data                       */ \"offload error: cannot find data associated with pointer variable %p\",\n+\t/*  30 msg_c_get_engine_handle                 */ \"offload error: cannot get device %d handle (error code %d)\",\n+\t/*  31 msg_c_get_engine_index                  */ \"offload error: cannot get physical index for logical device %d (error code %d)\",\n+\t/*  32 msg_c_process_create                    */ \"offload error: cannot start process on the device %d (error code %d)\",\n+\t/*  33 msg_c_process_get_func_handles          */ \"offload error: cannot get function handles on the device %d (error code %d)\",\n+\t/*  34 msg_c_process_wait_shutdown             */ \"offload error: wait for process shutdown failed on device %d (error code %d)\",\n+\t/*  35 msg_c_process_proxy_flush               */ \"offload error: cannot flush process output on device %d (error code %d)\",\n+\t/*  36 msg_c_load_library                      */ \"offload error: cannot load library to the device %d (error code %d)\",\n+\t/*  37 msg_c_pipeline_create                   */ \"offload error: cannot create pipeline on the device %d (error code %d)\",\n+\t/*  38 msg_c_pipeline_run_func                 */ \"offload error: cannot execute function on the device %d (error code %d)\",\n+\t/*  39 msg_c_pipeline_start_run_funcs          */ \"offload error: cannot start executing pipeline function on the device %d (error code %d)\",\n+\t/*  40 msg_c_buf_create                        */ \"offload error: cannot create buffer on device %d (error code %d)\",\n+\t/*  41 msg_c_buf_create_out_of_mem             */ \"offload error: cannot create buffer on device %d, out of memory\",\n+\t/*  42 msg_c_buf_create_from_mem               */ \"offload error: cannot create buffer from memory on device %d (error code %d)\",\n+\t/*  43 msg_c_buf_destroy                       */ \"offload error: buffer destroy failed (error code %d)\",\n+\t/*  44 msg_c_buf_map                           */ \"offload error: buffer map failed (error code %d)\",\n+\t/*  45 msg_c_buf_unmap                         */ \"offload error: buffer unmap failed (error code %d)\",\n+\t/*  46 msg_c_buf_read                          */ \"offload error: buffer read failed (error code %d)\",\n+\t/*  47 msg_c_buf_write                         */ \"offload error: buffer write failed (error code %d)\",\n+\t/*  48 msg_c_buf_copy                          */ \"offload error: buffer copy failed (error code %d)\",\n+\t/*  49 msg_c_buf_get_address                   */ \"offload error: cannot get buffer address on device %d (error code %d)\",\n+\t/*  50 msg_c_buf_add_ref                       */ \"offload error: cannot reuse buffer memory on device %d (error code %d)\",\n+\t/*  51 msg_c_buf_release_ref                   */ \"offload error: cannot release buffer memory on device %d (error code %d)\",\n+\t/*  52 msg_c_buf_set_state                     */ \"offload error: buffer set state failed (error code %d)\",\n+\t/*  53 msg_c_event_wait                        */ \"offload error: wait for event to become signaled failed (error code %d)\",\n+\t/*  54 msg_c_zero_or_neg_ptr_len               */ \"offload error: memory allocation of negative length is not supported\",\n+\t/*  55 msg_c_zero_or_neg_transfer_size         */ \"offload error: data transfer of zero or negative size is not supported\",\n+\t/*  56 msg_c_bad_ptr_mem_range                 */ \"offload error: address range partially overlaps with existing allocation\",\n+\t/*  57 msg_c_different_src_and_dstn_sizes      */ \"offload error: size of the source %d differs from size of the destination %d\",\n+\t/*  58 msg_c_non_contiguous_dope_vector        */ \"offload error: offload data transfer supports only a single contiguous memory range per variable\",\n+\t/*  59 msg_c_omp_invalid_device_num_env        */ \"offload warning: ignoring %s setting; use a non-negative integer value\",\n+\t/*  60 msg_c_omp_invalid_device_num            */ \"offload error: device number should be a non-negative integer value\",\n+\t/*  61 msg_c_unknown_binary_type               */ \"offload error: unexpected embedded target binary type, expected either an executable or shared library\",\n+\t/*  62 msg_c_multiple_target_exes              */ \"offload error: more that one target executable found\",\n+\t/*  63 msg_c_no_target_exe                     */ \"offload error: target executable is not available\",\n+\t/*  64 msg_c_report_unknown_timer_node         */ \"offload error: unknown timer node\",\n+\t/*  65 msg_c_report_unknown_trace_node         */ \"offload error: unknown trace node\",\n+\t/*  66 msg_c_report_host                       */ \"HOST\",\n+\t/*  67 msg_c_report_mic                        */ \"MIC\",\n+\t/*  68 msg_c_report_title                      */ \"timer data       (sec)\",\n+\t/*  69 msg_c_report_seconds                    */ \"(seconds)\",\n+\t/*  70 msg_c_report_bytes                      */ \"(bytes)\",\n+\t/*  71 msg_c_report_cpu_time                   */ \"CPU Time\",\n+\t/*  72 msg_c_report_mic_time                   */ \"MIC Time\",\n+\t/*  73 msg_c_report_tag                        */ \"Tag\",\n+\t/*  74 msg_c_report_from_file                  */ \"Offload from file\",\n+\t/*  75 msg_c_report_file                       */ \"File\",\n+\t/*  76 msg_c_report_line                       */ \"Line\",\n+\t/*  77 msg_c_report_cpu_to_mic_data            */ \"CPU->MIC Data\",\n+\t/*  78 msg_c_report_mic_to_cpu_data            */ \"MIC->CPU Data\",\n+\t/*  79 msg_c_report_offload                    */ \"Offload\",\n+\t/*  80 msg_c_report_w_tag                      */ \"Tag %d\",\n+\t/*  81 msg_c_report_state                      */ \"State\",\n+\t/*  82 msg_c_report_start                      */ \"Start target\",\n+\t/*  83 msg_c_report_init                       */ \"Initialize\",\n+\t/*  84 msg_c_report_logical_card               */ \"logical card\",\n+\t/*  85 msg_c_report_physical_card              */ \"physical card\",\n+\t/*  86 msg_c_report_register                   */ \"Register static data tables\",\n+\t/*  87 msg_c_report_init_func                  */ \"Setup target entry\",\n+\t/*  88 msg_c_report_create_buf_host            */ \"Create host buffer\",\n+\t/*  89 msg_c_report_create_buf_mic             */ \"Create target buffer\",\n+\t/*  90 msg_c_report_send_pointer_data          */ \"Send pointer data\",\n+\t/*  91 msg_c_report_sent_pointer_data          */ \"Host->target pointer data\",\n+\t/*  92 msg_c_report_gather_copyin_data         */ \"Gather copyin data\",\n+\t/*  93 msg_c_report_copyin_data                */ \"Host->target copyin data\",\n+\t/*  94 msg_c_report_state_signal               */ \"Signal\",\n+\t/*  95 msg_c_report_signal                     */ \"signal :\",\n+\t/*  96 msg_c_report_wait                       */ \"waits  :\",\n+\t/*  97 msg_c_report_compute                    */ \"Execute task on target\",\n+\t/*  98 msg_c_report_receive_pointer_data       */ \"Receive pointer data\",\n+\t/*  99 msg_c_report_received_pointer_data      */ \"Target->host pointer data\",\n+\t/* 100 msg_c_report_start_target_func          */ \"Start target entry\",\n+\t/* 101 msg_c_report_var                        */ \"Var\",\n+\t/* 102 msg_c_report_scatter_copyin_data        */ \"Scatter copyin data\",\n+\t/* 103 msg_c_report_gather_copyout_data        */ \"Gather copyout data\",\n+\t/* 104 msg_c_report_scatter_copyout_data       */ \"Scatter copyout data\",\n+\t/* 105 msg_c_report_copyout_data               */ \"Target->host copyout data\",\n+\t/* 106 msg_c_report_unregister                 */ \"Unregister data tables\",\n+\t/* 107 msg_c_report_destroy                    */ \"Destroy\",\n+\t/* 108 msg_c_report_myoinit                    */ \"Initialize MYO\",\n+\t/* 109 msg_c_report_myoregister                */ \"Register MYO tables\",\n+\t/* 110 msg_c_report_myofini                    */ \"Finalize MYO\",\n+\t/* 111 msg_c_report_mic_myo_shared             */ \"MIC MYO shared table register\",\n+\t/* 112 msg_c_report_mic_myo_fptr               */ \"MIC MYO fptr table register\",\n+\t/* 113 msg_c_report_myosharedmalloc            */ \"MYO shared malloc\",\n+\t/* 114 msg_c_report_myosharedfree              */ \"MYO shared free\",\n+\t/* 115 msg_c_report_myosharedalignedmalloc     */ \"MYO shared aligned malloc\",\n+\t/* 116 msg_c_report_myosharedalignedfree       */ \"MYO shared aligned free\",\n+\t/* 117 msg_c_report_myoacquire                 */ \"MYO acquire\",\n+\t/* 118 msg_c_report_myorelease                 */ \"MYO release\",\n+\t/* 119 msg_c_report_host_total_offload_time    */ \"host: total offload time\",\n+\t/* 120 msg_c_report_host_initialize            */ \"host: initialize target\",\n+\t/* 121 msg_c_report_host_target_acquire        */ \"host: acquire target\",\n+\t/* 122 msg_c_report_host_wait_deps             */ \"host: wait dependencies\",\n+\t/* 123 msg_c_report_host_setup_buffers         */ \"host: setup buffers\",\n+\t/* 124 msg_c_report_host_alloc_buffers         */ \"host: allocate buffers\",\n+\t/* 125 msg_c_report_host_setup_misc_data       */ \"host: setup misc_data\",\n+\t/* 126 msg_c_report_host_alloc_data_buffer     */ \"host: allocate buffer\",\n+\t/* 127 msg_c_report_host_send_pointers         */ \"host: send pointers\",\n+\t/* 128 msg_c_report_host_gather_inputs         */ \"host: gather inputs\",\n+\t/* 129 msg_c_report_host_map_in_data_buffer    */ \"host: map IN data buffer\",\n+\t/* 130 msg_c_report_host_unmap_in_data_buffer  */ \"host: unmap IN data buffer\",\n+\t/* 131 msg_c_report_host_start_compute         */ \"host: initiate compute\",\n+\t/* 132 msg_c_report_host_wait_compute          */ \"host: wait compute\",\n+\t/* 133 msg_c_report_host_start_buffers_reads   */ \"host: initiate pointer reads\",\n+\t/* 134 msg_c_report_host_scatter_outputs       */ \"host: scatter outputs\",\n+\t/* 135 msg_c_report_host_map_out_data_buffer   */ \"host: map OUT data buffer\",\n+\t/* 136 msg_c_report_host_unmap_out_data_buffer */ \"host: unmap OUT data buffer\",\n+\t/* 137 msg_c_report_host_wait_buffers_reads    */ \"host: wait pointer reads\",\n+\t/* 138 msg_c_report_host_destroy_buffers       */ \"host: destroy buffers\",\n+\t/* 139 msg_c_report_target_total_time          */ \"target: total time\",\n+\t/* 140 msg_c_report_target_descriptor_setup    */ \"target: setup offload descriptor\",\n+\t/* 141 msg_c_report_target_func_lookup         */ \"target: entry lookup\",\n+\t/* 142 msg_c_report_target_func_time           */ \"target: entry time\",\n+\t/* 143 msg_c_report_target_scatter_inputs      */ \"target: scatter inputs\",\n+\t/* 144 msg_c_report_target_add_buffer_refs     */ \"target: add buffer reference\",\n+\t/* 145 msg_c_report_target_compute             */ \"target: compute\",\n+\t/* 146 msg_c_report_target_gather_outputs      */ \"target: gather outputs\",\n+\t/* 147 msg_c_report_target_release_buffer_refs */ \"target: remove buffer reference\",\n+\t/* 148 msg_c_coi_pipeline_max_number           */ \"number of host threads doing offload exceeds maximum of %d\",\n+\t/* 149 msg_c_ranges_dont_match                 */ \"ranges of source and destination don't match together\",\n+\t/* 150 msg_c_destination_is_over               */ \"insufficient destination memory to transfer source\",\n+\t/* 151 msg_c_slice_of_noncont_array            */ \"a non-contiguous slice may be taken of contiguous arrays only\",\n+\t/* 152 msg_c_pointer_array_mismatch            */ \"number of %s elements is less than described by the source\",\n+};"}, {"sha": "c68e059aa19ae73cc935c7cfc678304f617242e0", "filename": "liboffloadmic/runtime/mic_lib.f90", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fmic_lib.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fmic_lib.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fmic_lib.f90?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,282 @@\n+!\n+!    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+!\n+!    Redistribution and use in source and binary forms, with or without\n+!    modification, are permitted provided that the following conditions\n+!    are met:\n+!\n+!      * Redistributions of source code must retain the above copyright\n+!        notice, this list of conditions and the following disclaimer.\n+!      * Redistributions in binary form must reproduce the above copyright\n+!        notice, this list of conditions and the following disclaimer in the\n+!        documentation and/or other materials provided with the distribution.\n+!      * Neither the name of Intel Corporation nor the names of its\n+!        contributors may be used to endorse or promote products derived\n+!        from this software without specific prior written permission.\n+!\n+!    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+!    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+!    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+!    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+!    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+!    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+!    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+!    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+!    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+!    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+!    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+!\n+\n+\n+! **********************************************************************************\n+! * This file is intended to support the Intel(r) Many Integrated Core Architecture.\n+! **********************************************************************************\n+! free form Fortran source - should be named .f90\n+! lines are longer than 72 characters\n+\n+module mic_lib\n+use, intrinsic :: iso_c_binding\n+\n+integer, parameter:: target_mic=2\n+integer, parameter:: default_target_type=target_mic\n+integer, parameter:: default_target_number=0\n+\n+enum, bind(C)\n+    enumerator :: OFFLOAD_SUCCESS  = 0\n+    enumerator :: OFFLOAD_DISABLED          ! offload is disabled\n+    enumerator :: OFFLOAD_UNAVAILABLE       ! card is not available\n+    enumerator :: OFFLOAD_OUT_OF_MEMORY     ! not enough memory on device\n+    enumerator :: OFFLOAD_PROCESS_DIED      ! target process has died\n+    enumerator :: OFFLOAD_ERROR             ! unspecified error\n+end enum\n+\n+type, bind (C) :: offload_status\n+    integer(kind=c_int)    ::  result          = OFFLOAD_DISABLED\n+    integer(kind=c_int)    ::  device_number   = -1\n+    integer(kind=c_size_t) ::  data_sent       = 0\n+    integer(kind=c_size_t) ::  data_received   = 0\n+end type offload_status\n+\n+interface\n+function offload_number_of_devices ()                                  &\n+           bind (C, name = \"_Offload_number_of_devices\")\n+!dec$ attributes default :: offload_number_of_devices\n+  import :: c_int\n+  integer (kind=c_int)        :: offload_number_of_devices\n+!dec$ attributes offload:mic :: offload_number_of_devices\n+!dir$ attributes known_intrinsic ::  offload_number_of_devices\n+end function offload_number_of_devices\n+\n+function offload_signaled(target_number, signal)                       &\n+           bind (C, name = \"_Offload_signaled\")\n+!dec$ attributes default :: offload_signaled\n+  import :: c_int, c_int64_t\n+  integer (kind=c_int) :: offload_signaled\n+  integer (kind=c_int), value :: target_number\n+  integer (kind=c_int64_t), value :: signal\n+!dec$ attributes offload:mic :: offload_signaled\n+end function offload_signaled\n+\n+subroutine offload_report(val)                                         &\n+           bind (C, name = \"_Offload_report\")\n+!dec$ attributes default :: offload_report\n+  import :: c_int\n+  integer (kind=c_int), value :: val\n+!dec$ attributes offload:mic :: offload_report\n+end subroutine offload_report\n+\n+function offload_get_device_number()                                   &\n+           bind (C, name = \"_Offload_get_device_number\")\n+!dec$ attributes default :: offload_get_device_number\n+  import :: c_int\n+  integer (kind=c_int)        :: offload_get_device_number\n+!dec$ attributes offload:mic :: offload_get_device_number\n+end function offload_get_device_number\n+\n+function offload_get_physical_device_number()                          &\n+           bind (C, name = \"_Offload_get_physical_device_number\")\n+!dec$ attributes default :: offload_get_physical_device_number\n+  import :: c_int\n+  integer (kind=c_int)        :: offload_get_physical_device_number\n+!dec$ attributes offload:mic :: offload_get_physical_device_number\n+end function offload_get_physical_device_number\n+\n+! OpenMP API wrappers\n+\n+subroutine omp_set_num_threads_target (target_type,                    &\n+                                       target_number,                  &\n+                                       num_threads)                    &\n+           bind (C, name = \"omp_set_num_threads_target\")\n+  import :: c_int\n+  integer (kind=c_int), value :: target_type, target_number, num_threads\n+end subroutine omp_set_num_threads_target\n+\n+function omp_get_max_threads_target (target_type,                      &\n+                                     target_number)                    &\n+         bind (C, name = \"omp_get_max_threads_target\")\n+  import :: c_int\n+  integer (kind=c_int)        :: omp_get_max_threads_target\n+  integer (kind=c_int), value :: target_type, target_number\n+end function omp_get_max_threads_target\n+\n+function omp_get_num_procs_target (target_type,                        &\n+                                   target_number)                      &\n+         bind (C, name = \"omp_get_num_procs_target\")\n+  import :: c_int\n+  integer (kind=c_int)        :: omp_get_num_procs_target\n+  integer (kind=c_int), value :: target_type, target_number\n+end function omp_get_num_procs_target\n+\n+subroutine omp_set_dynamic_target (target_type,                        &\n+                                   target_number,                      &\n+                                   num_threads)                        &\n+           bind (C, name = \"omp_set_dynamic_target\")\n+  import :: c_int\n+  integer (kind=c_int), value :: target_type, target_number, num_threads\n+end subroutine omp_set_dynamic_target\n+\n+function omp_get_dynamic_target (target_type,                          &\n+                                 target_number)                        &\n+         bind (C, name = \"omp_get_dynamic_target\")\n+  import :: c_int\n+  integer (kind=c_int)        :: omp_get_dynamic_target\n+  integer (kind=c_int), value :: target_type, target_number\n+end function omp_get_dynamic_target\n+\n+subroutine omp_set_nested_target (target_type,                         &\n+                                  target_number,                       &\n+                                  nested)                              &\n+           bind (C, name = \"omp_set_nested_target\")\n+  import :: c_int\n+  integer (kind=c_int), value :: target_type, target_number, nested\n+end subroutine omp_set_nested_target\n+\n+function omp_get_nested_target (target_type,                           &\n+                                target_number)                         &\n+         bind (C, name = \"omp_get_nested_target\")\n+  import :: c_int\n+  integer (kind=c_int)        :: omp_get_nested_target\n+  integer (kind=c_int), value :: target_type, target_number\n+end function omp_get_nested_target\n+\n+subroutine omp_set_schedule_target (target_type,                       &\n+                                    target_number,                     &\n+                                    kind,                              &\n+                                    modifier)                          &\n+           bind (C, name = \"omp_set_schedule_target\")\n+  import :: c_int\n+  integer (kind=c_int), value :: target_type, target_number, kind, modifier\n+end subroutine omp_set_schedule_target\n+\n+subroutine omp_get_schedule_target (target_type,                       &\n+                                    target_number,                     &\n+                                    kind,                              &\n+                                    modifier)                          &\n+           bind (C, name = \"omp_get_schedule_target\")\n+  import :: c_int, c_intptr_t\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: kind, modifier\n+end subroutine omp_get_schedule_target\n+\n+! lock API functions\n+\n+subroutine omp_init_lock_target (target_type,                          &\n+                                 target_number,                        &\n+                                 lock)                                 &\n+           bind (C, name = \"omp_init_lock_target\")\n+  import :: c_int, c_intptr_t\n+  !dir$ attributes known_intrinsic ::  omp_init_lock_target\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end subroutine omp_init_lock_target\n+\n+subroutine omp_destroy_lock_target (target_type,                       &\n+                                    target_number,                     &\n+                                    lock)                              &\n+           bind (C, name = \"omp_destroy_lock_target\")\n+  import :: c_int, c_intptr_t\n+  !dir$ attributes known_intrinsic ::  omp_destroy_lock_target\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end subroutine omp_destroy_lock_target\n+\n+subroutine omp_set_lock_target (target_type,                           &\n+                                target_number,                         &\n+                                lock)                                  &\n+           bind (C, name = \"omp_set_lock_target\")\n+  import :: c_int, c_intptr_t\n+  !dir$ attributes known_intrinsic ::  omp_set_lock_target\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end subroutine omp_set_lock_target\n+\n+subroutine omp_unset_lock_target (target_type,                         &\n+                                  target_number,                       &\n+                                  lock)                                &\n+           bind (C, name = \"omp_unset_lock_target\")\n+  import :: c_int, c_intptr_t\n+  !dir$ attributes known_intrinsic ::  omp_unset_lock_target\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end subroutine omp_unset_lock_target\n+\n+function omp_test_lock_target (target_type,                            &\n+                               target_number,                          &\n+                               lock)                                   &\n+           bind (C, name = \"omp_test_lock_target\")\n+  import :: c_int, c_intptr_t\n+  integer (kind=c_int)        :: omp_test_lock_target\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end function omp_test_lock_target\n+\n+! nested lock API functions\n+\n+subroutine omp_init_nest_lock_target (target_type,                     &\n+                                      target_number,                   &\n+                                      lock)                            &\n+           bind (C, name = \"omp_init_nest_lock_target\")\n+  import :: c_int, c_intptr_t\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end subroutine omp_init_nest_lock_target\n+\n+subroutine omp_destroy_nest_lock_target (target_type,                  &\n+                                         target_number,                &\n+                                         lock)                         &\n+           bind (C, name = \"omp_destroy_nest_lock_target\")\n+  import :: c_int, c_intptr_t\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end subroutine omp_destroy_nest_lock_target\n+\n+subroutine omp_set_nest_lock_target (target_type,                      &\n+                                     target_number,                    &\n+                                     lock)                             &\n+           bind (C, name = \"omp_set_nest_lock_target\")\n+  import :: c_int, c_intptr_t\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end subroutine omp_set_nest_lock_target\n+\n+subroutine omp_unset_nest_lock_target (target_type,                    &\n+                                       target_number,                  &\n+                                       lock)                           &\n+           bind (C, name = \"omp_unset_nest_lock_target\")\n+  import :: c_int, c_intptr_t\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end subroutine omp_unset_nest_lock_target\n+\n+function omp_test_nest_lock_target (target_type,                       &\n+                                    target_number,                     &\n+                                    lock)                              &\n+           bind (C, name = \"omp_test_nest_lock_target\")\n+  import :: c_int, c_intptr_t\n+  integer (kind=c_int)        :: omp_test_nest_lock_target\n+  integer (kind=c_int), value :: target_type, target_number\n+  integer (kind=c_intptr_t), value :: lock\n+end function omp_test_nest_lock_target\n+\n+end interface\n+end module mic_lib"}, {"sha": "9234b0011f9dd452d0bb7ca6fec5936168e314c0", "filename": "liboffloadmic/runtime/offload.h", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,371 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+/*\n+ * Include file for Offload API.\n+ */\n+\n+#ifndef OFFLOAD_H_INCLUDED\n+#define OFFLOAD_H_INCLUDED\n+\n+#if defined(LINUX) || defined(FREEBSD)\n+#include <bits/functexcept.h>\n+#endif\n+\n+#include <stddef.h>\n+#include <omp.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define TARGET_ATTRIBUTE __declspec(target(mic))\n+\n+/*\n+ *  The target architecture.\n+ */\n+typedef enum TARGET_TYPE {\n+    TARGET_NONE,    /* Undefine target */\n+    TARGET_HOST,    /* Host used as target */\n+    TARGET_MIC      /* MIC target */\n+} TARGET_TYPE;\n+\n+/*\n+ *  The default target type.\n+ */\n+#define DEFAULT_TARGET_TYPE TARGET_MIC\n+\n+/*\n+ *  The default target number.\n+ */\n+#define DEFAULT_TARGET_NUMBER 0\n+\n+/*\n+ *  Offload status.\n+ */\n+typedef enum {\n+    OFFLOAD_SUCCESS = 0,\n+    OFFLOAD_DISABLED,               /* offload is disabled */\n+    OFFLOAD_UNAVAILABLE,            /* card is not available */\n+    OFFLOAD_OUT_OF_MEMORY,          /* not enough memory on device */\n+    OFFLOAD_PROCESS_DIED,           /* target process has died */\n+    OFFLOAD_ERROR                   /* unspecified error */\n+} _Offload_result;\n+\n+typedef struct {\n+    _Offload_result result;         /* result, see above */\n+    int             device_number;  /* device number */\n+    size_t          data_sent;      /* number of bytes sent to the target */\n+    size_t          data_received;  /* number of bytes received by host */\n+} _Offload_status;\n+\n+#define OFFLOAD_STATUS_INIT(x) \\\n+    ((x).result = OFFLOAD_DISABLED)\n+\n+#define OFFLOAD_STATUS_INITIALIZER \\\n+    { OFFLOAD_DISABLED, -1, 0, 0 }\n+\n+/* Offload runtime interfaces */\n+\n+extern int _Offload_number_of_devices(void);\n+extern int _Offload_get_device_number(void);\n+extern int _Offload_get_physical_device_number(void);\n+\n+extern void* _Offload_shared_malloc(size_t size);\n+extern void  _Offload_shared_free(void *ptr);\n+\n+extern void* _Offload_shared_aligned_malloc(size_t size, size_t align);\n+extern void  _Offload_shared_aligned_free(void *ptr);\n+\n+extern int _Offload_signaled(int index, void *signal);\n+extern void _Offload_report(int val);\n+\n+/* OpenMP API */\n+\n+extern void omp_set_default_device(int num) __GOMP_NOTHROW;\n+extern int  omp_get_default_device(void) __GOMP_NOTHROW;\n+extern int  omp_get_num_devices(void) __GOMP_NOTHROW;\n+\n+/* OpenMP API wrappers */\n+\n+/* Set num_threads on target */\n+extern void omp_set_num_threads_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    int num_threads\n+);\n+\n+/* Get max_threads from target */\n+extern int omp_get_max_threads_target(\n+    TARGET_TYPE target_type,\n+    int target_number\n+);\n+\n+/* Get num_procs from target */\n+extern int omp_get_num_procs_target(\n+    TARGET_TYPE target_type,\n+    int target_number\n+);\n+\n+/* Set dynamic on target */\n+extern void omp_set_dynamic_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    int num_threads\n+);\n+\n+/* Get dynamic from target */\n+extern int omp_get_dynamic_target(\n+    TARGET_TYPE target_type,\n+    int target_number\n+);\n+\n+/* Set nested on target */\n+extern void omp_set_nested_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    int nested\n+);\n+\n+/* Get nested from target */\n+extern int omp_get_nested_target(\n+    TARGET_TYPE target_type,\n+    int target_number\n+);\n+\n+extern void omp_set_num_threads_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    int num_threads\n+);\n+\n+extern int omp_get_max_threads_target(\n+    TARGET_TYPE target_type,\n+    int target_number\n+);\n+\n+extern int omp_get_num_procs_target(\n+    TARGET_TYPE target_type,\n+    int target_number\n+);\n+\n+extern void omp_set_dynamic_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    int num_threads\n+);\n+\n+extern int omp_get_dynamic_target(\n+    TARGET_TYPE target_type,\n+    int target_number\n+);\n+\n+extern void omp_set_nested_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    int num_threads\n+);\n+\n+extern int omp_get_nested_target(\n+    TARGET_TYPE target_type,\n+    int target_number\n+);\n+\n+extern void omp_set_schedule_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_sched_t kind,\n+    int modifier\n+);\n+\n+extern void omp_get_schedule_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_sched_t *kind,\n+    int *modifier\n+);\n+\n+/* lock API functions */\n+\n+typedef struct {\n+    omp_lock_t lock;\n+} omp_lock_target_t;\n+\n+extern void omp_init_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_lock_target_t *lock\n+);\n+\n+extern void omp_destroy_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_lock_target_t *lock\n+);\n+\n+extern void omp_set_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_lock_target_t *lock\n+);\n+\n+extern void omp_unset_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_lock_target_t *lock\n+);\n+\n+extern int omp_test_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_lock_target_t *lock\n+);\n+\n+/* nested lock API functions */\n+\n+typedef struct {\n+    omp_nest_lock_t lock;\n+} omp_nest_lock_target_t;\n+\n+extern void omp_init_nest_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_nest_lock_target_t *lock\n+);\n+\n+extern void omp_destroy_nest_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_nest_lock_target_t *lock\n+);\n+\n+extern void omp_set_nest_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_nest_lock_target_t *lock\n+);\n+\n+extern void omp_unset_nest_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_nest_lock_target_t *lock\n+);\n+\n+extern int omp_test_nest_lock_target(\n+    TARGET_TYPE target_type,\n+    int target_number,\n+    omp_nest_lock_target_t *lock\n+);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+\n+/* Namespace for the shared_allocator. */\n+namespace __offload {\n+  /* This follows the specification for std::allocator. */\n+  /* Forward declaration of the class template. */\n+  template <typename T>\n+  class shared_allocator;\n+\n+  /* Specialization for shared_allocator<void>. */\n+  template <>\n+  class shared_allocator<void> {\n+  public:\n+    typedef void       *pointer;\n+    typedef const void *const_pointer;\n+    typedef void        value_type;\n+    template <class U> struct rebind { typedef shared_allocator<U> other; };\n+  };\n+\n+  /* Definition of shared_allocator<T>. */\n+  template <class T>\n+  class shared_allocator {\n+  public:\n+    typedef size_t     size_type;\n+    typedef ptrdiff_t  difference_type;\n+    typedef T         *pointer;\n+    typedef const T   *const_pointer;\n+    typedef T         &reference;\n+    typedef const T   &const_reference;\n+    typedef T          value_type;\n+    template <class U> struct rebind { typedef shared_allocator<U> other; };\n+    shared_allocator() throw() { }\n+    shared_allocator(const shared_allocator&) throw() { }\n+    template <class U> shared_allocator(const shared_allocator<U>&) throw() { }\n+    ~shared_allocator() throw() { }\n+    pointer address(reference x) const { return &x; }\n+    const_pointer address(const_reference x) const { return &x; }\n+    pointer allocate(\n+      size_type, shared_allocator<void>::const_pointer hint = 0);\n+    void deallocate(pointer p, size_type n);\n+    size_type max_size() const throw() {\n+      return size_type(-1)/sizeof(T);\n+    } /* max_size */\n+    void construct(pointer p, const T& arg) {\n+      ::new (p) T(arg);\n+    } /* construct */\n+    void destroy(pointer p) {\n+      p->~T();\n+    } /* destroy */\n+  };\n+\n+  /* Definition for allocate. */\n+  template <class T>\n+  typename shared_allocator<T>::pointer\n+  shared_allocator<T>::allocate(shared_allocator<T>::size_type s,\n+                                shared_allocator<void>::const_pointer) {\n+    /* Allocate from shared memory. */\n+    void *ptr = _Offload_shared_malloc(s*sizeof(T));\n+    if (ptr == 0) std::__throw_bad_alloc();\n+    return static_cast<pointer>(ptr);\n+  } /* allocate */\n+\n+  template <class T>\n+  void shared_allocator<T>::deallocate(pointer p,\n+                                       shared_allocator<T>::size_type) {\n+    /* Free the shared memory. */\n+    _Offload_shared_free(p);\n+  } /* deallocate */\n+\n+  template <typename _T1, typename _T2>\n+  inline bool operator==(const shared_allocator<_T1> &, \n+                         const shared_allocator<_T2> &) throw() {\n+    return true;\n+  }  /* operator== */\n+\n+  template <typename _T1, typename _T2>\n+  inline bool operator!=(const shared_allocator<_T1> &, \n+                         const shared_allocator<_T2> &) throw() {\n+    return false;\n+  }  /* operator!= */\n+}  /* __offload */\n+#endif /* __cplusplus */\n+\n+#endif /* OFFLOAD_H_INCLUDED */"}, {"sha": "72c355f6f1830488e6137a1bc216c1ef50a222c7", "filename": "liboffloadmic/runtime/offload_common.cpp", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_common.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,190 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#if defined(LINUX) || defined(FREEBSD)\n+#include <mm_malloc.h>\n+#endif\n+\n+#include \"offload_common.h\"\n+\n+// The debug routines\n+\n+#if OFFLOAD_DEBUG > 0\n+\n+void __dump_bytes(\n+    int trace_level,\n+    const void *data,\n+    int len\n+)\n+{\n+    if (console_enabled > trace_level) {\n+        const uint8_t *arr = (const uint8_t*) data;\n+        char buffer[4096];\n+        char *bufferp;\n+        int count = 0;\n+\n+        bufferp = buffer;\n+        while (len--) {\n+            sprintf(bufferp, \"%02x\", *arr++);\n+            bufferp += 2;\n+            count++;\n+            if ((count&3) == 0) {\n+                sprintf(bufferp, \" \");\n+                bufferp++;\n+            }\n+            if ((count&63) == 0) {\n+                OFFLOAD_DEBUG_TRACE(trace_level, \"%s\\n\", buffer);\n+                bufferp = buffer;\n+                count = 0;\n+            }\n+        }\n+        if (count) {\n+            OFFLOAD_DEBUG_TRACE(trace_level, \"%s\\n\", buffer);\n+        }\n+    }\n+}\n+#endif // OFFLOAD_DEBUG\n+\n+// The Marshaller and associated routines\n+\n+void Marshaller::send_data(\n+    const void *data,\n+    int64_t length\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"send_data(%p, %lld)\\n\",\n+                        data, length);\n+    memcpy(buffer_ptr, data, (size_t)length);\n+    buffer_ptr += length;\n+    tfr_size += length;\n+}\n+\n+void Marshaller::receive_data(\n+    void *data,\n+    int64_t length\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"receive_data(%p, %lld)\\n\",\n+                        data, length);\n+    memcpy(data, buffer_ptr, (size_t)length);\n+    buffer_ptr += length;\n+    tfr_size += length;\n+}\n+\n+// Send function pointer\n+void Marshaller::send_func_ptr(\n+    const void* data\n+)\n+{\n+    const char* name;\n+    size_t      length;\n+\n+    if (data != 0) {\n+        name = __offload_funcs.find_name(data);\n+        if (name == 0) {\n+#if OFFLOAD_DEBUG > 0\n+            if (console_enabled > 2) {\n+                __offload_funcs.dump();\n+            }\n+#endif // OFFLOAD_DEBUG > 0\n+\n+            LIBOFFLOAD_ERROR(c_send_func_ptr, data);\n+            exit(1);\n+        }\n+        length = strlen(name) + 1;\n+    }\n+    else {\n+        name = \"\";\n+        length = 1;\n+    }\n+\n+    memcpy(buffer_ptr, name, length);\n+    buffer_ptr += length;\n+    tfr_size += length;\n+}\n+\n+// Receive function pointer\n+void Marshaller::receive_func_ptr(\n+    const void** data\n+)\n+{\n+    const char* name;\n+    size_t      length;\n+\n+    name = (const char*) buffer_ptr;\n+    if (name[0] != '\\0') {\n+        *data = __offload_funcs.find_addr(name);\n+        if (*data == 0) {\n+#if OFFLOAD_DEBUG > 0\n+            if (console_enabled > 2) {\n+                __offload_funcs.dump();\n+            }\n+#endif // OFFLOAD_DEBUG > 0\n+\n+            LIBOFFLOAD_ERROR(c_receive_func_ptr, name);\n+            exit(1);\n+        }\n+        length = strlen(name) + 1;\n+    }\n+    else {\n+        *data = 0;\n+        length = 1;\n+    }\n+\n+    buffer_ptr += length;\n+    tfr_size += length;\n+}\n+\n+// End of the Marshaller and associated routines\n+\n+extern void *OFFLOAD_MALLOC(\n+    size_t size,\n+    size_t align\n+)\n+{\n+    void *ptr;\n+    int   err;\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"%s(%lld, %lld)\\n\", __func__, size, align);\n+\n+    if (align < sizeof(void*)) {\n+        align = sizeof(void*);\n+    }\n+\n+    ptr = _mm_malloc(size, align);\n+    if (ptr == NULL) {\n+        LIBOFFLOAD_ERROR(c_offload_malloc, size, align);\n+        exit(1);\n+    }\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"%s returned %p\\n\", __func__, ptr);\n+\n+    return ptr;\n+}"}, {"sha": "60b5045b9b560b24dbf71210cc3cb7abf43f4302", "filename": "liboffloadmic/runtime/offload_common.h", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_common.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,475 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+/*! \\file\n+    \\brief The parts of the runtime library common to host and target\n+*/\n+\n+#ifndef OFFLOAD_COMMON_H_INCLUDED\n+#define OFFLOAD_COMMON_H_INCLUDED\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <memory.h>\n+\n+#if (defined(LINUX) || defined(FREEBSD)) && !defined(__INTEL_COMPILER)\n+#include <mm_malloc.h>\n+#endif\n+\n+#include \"offload.h\"\n+#include \"offload_table.h\"\n+#include \"offload_trace.h\"\n+#include \"offload_timer.h\"\n+#include \"offload_util.h\"\n+#include \"cean_util.h\"\n+#include \"dv_util.h\"\n+#include \"liboffload_error_codes.h\"\n+\n+#include <stdarg.h>\n+\n+// Use secure getenv if it's supported\n+#ifdef HAVE_SECURE_GETENV\n+  #define getenv(x)\t    secure_getenv(x)\n+#elif HAVE___SECURE_GETENV\n+  #define getenv(x)\t    __secure_getenv(x)\n+#endif\n+\n+// The debug routines\n+\n+// Host console and file logging\n+extern int console_enabled;\n+extern int offload_report_level;\n+\n+#define OFFLOAD_DO_TRACE (offload_report_level == 3)\n+\n+extern const char *prefix;\n+extern int offload_number;\n+#if !HOST_LIBRARY\n+extern int mic_index;\n+#endif\n+\n+#if HOST_LIBRARY\n+void Offload_Report_Prolog(OffloadHostTimerData* timer_data);\n+void Offload_Report_Epilog(OffloadHostTimerData* timer_data);\n+void offload_report_free_data(OffloadHostTimerData * timer_data);\n+void Offload_Timer_Print(void);\n+\n+#ifndef TARGET_WINNT\n+#define OFFLOAD_DEBUG_INCR_OFLD_NUM() \\\n+        __sync_add_and_fetch(&offload_number, 1)\n+#else\n+#define OFFLOAD_DEBUG_INCR_OFLD_NUM() \\\n+        _InterlockedIncrement(reinterpret_cast<long*>(&offload_number))\n+#endif\n+\n+#define OFFLOAD_DEBUG_PRINT_TAG_PREFIX() \\\n+        printf(\"%s:  \", prefix);\n+\n+#define OFFLOAD_DEBUG_PRINT_PREFIX() \\\n+        printf(\"%s:  \", prefix);\n+#else\n+#define OFFLOAD_DEBUG_PRINT_PREFIX() \\\n+        printf(\"%s%d:  \", prefix, mic_index);\n+#endif // HOST_LIBRARY\n+\n+#define OFFLOAD_TRACE(trace_level, ...)  \\\n+    if (console_enabled >= trace_level) { \\\n+        OFFLOAD_DEBUG_PRINT_PREFIX(); \\\n+        printf(__VA_ARGS__); \\\n+        fflush(NULL); \\\n+    }\n+\n+#if OFFLOAD_DEBUG > 0\n+\n+#define OFFLOAD_DEBUG_TRACE(level, ...) \\\n+    OFFLOAD_TRACE(level, __VA_ARGS__)\n+\n+#define OFFLOAD_REPORT(level, offload_number, stage, ...) \\\n+    if (OFFLOAD_DO_TRACE) { \\\n+        offload_stage_print(stage, offload_number, __VA_ARGS__); \\\n+        fflush(NULL); \\\n+    }\n+\n+#define OFFLOAD_DEBUG_TRACE_1(level, offload_number, stage, ...) \\\n+    if (OFFLOAD_DO_TRACE) { \\\n+        offload_stage_print(stage, offload_number, __VA_ARGS__); \\\n+        fflush(NULL); \\\n+    } \\\n+    if (!OFFLOAD_DO_TRACE) { \\\n+        OFFLOAD_TRACE(level, __VA_ARGS__) \\\n+    }\n+\n+#define OFFLOAD_DEBUG_DUMP_BYTES(level, a, b) \\\n+    __dump_bytes(level, a, b)\n+\n+extern void __dump_bytes(\n+    int level,\n+    const void *data,\n+    int len\n+);\n+\n+#else\n+\n+#define OFFLOAD_DEBUG_LOG(level, ...)\n+#define OFFLOAD_DEBUG_DUMP_BYTES(level, a, b)\n+\n+#endif\n+\n+// Runtime interface\n+\n+#define OFFLOAD_PREFIX(a) __offload_##a\n+\n+#define OFFLOAD_MALLOC            OFFLOAD_PREFIX(malloc)\n+#define OFFLOAD_FREE(a)           _mm_free(a)\n+\n+// Forward functions\n+\n+extern void *OFFLOAD_MALLOC(size_t size, size_t align);\n+\n+// The Marshaller\n+\n+//! \\enum Indicator for the type of entry on an offload item list.\n+enum OffloadItemType {\n+    c_data =   1,       //!< Plain data\n+    c_data_ptr,         //!< Pointer data\n+    c_func_ptr,         //!< Function pointer\n+    c_void_ptr,         //!< void*\n+    c_string_ptr,       //!< C string\n+    c_dv,               //!< Dope vector variable\n+    c_dv_data,          //!< Dope-vector data\n+    c_dv_data_slice,    //!< Dope-vector data's slice\n+    c_dv_ptr,           //!< Dope-vector variable pointer\n+    c_dv_ptr_data,      //!< Dope-vector pointer data\n+    c_dv_ptr_data_slice,//!< Dope-vector pointer data's slice\n+    c_cean_var,         //!< CEAN variable\n+    c_cean_var_ptr,     //!< Pointer to CEAN variable\n+    c_data_ptr_array,   //!< Pointer to data pointer array\n+    c_func_ptr_array,   //!< Pointer to function pointer array\n+    c_void_ptr_array,   //!< Pointer to void* pointer array\n+    c_string_ptr_array  //!< Pointer to char* pointer array\n+};\n+\n+#define VAR_TYPE_IS_PTR(t) ((t) == c_string_ptr || \\\n+                            (t) == c_data_ptr || \\\n+                            (t) == c_cean_var_ptr || \\\n+                            (t) == c_dv_ptr)\n+\n+#define VAR_TYPE_IS_SCALAR(t) ((t) == c_data || \\\n+                               (t) == c_void_ptr || \\\n+                               (t) == c_cean_var || \\\n+                               (t) == c_dv)\n+\n+#define VAR_TYPE_IS_DV_DATA(t) ((t) == c_dv_data || \\\n+                                (t) == c_dv_ptr_data)\n+\n+#define VAR_TYPE_IS_DV_DATA_SLICE(t) ((t) == c_dv_data_slice || \\\n+                                      (t) == c_dv_ptr_data_slice)\n+\n+\n+//! \\enum Specify direction to copy offloaded variable.\n+enum OffloadParameterType {\n+    c_parameter_unknown = -1, //!< Unknown clause\n+    c_parameter_nocopy,       //!< Variable listed in \"nocopy\" clause\n+    c_parameter_in,           //!< Variable listed in \"in\" clause\n+    c_parameter_out,          //!< Variable listed in \"out\" clause\n+    c_parameter_inout         //!< Variable listed in \"inout\" clause\n+};\n+\n+//! An Offload Variable descriptor\n+struct VarDesc {\n+    //! OffloadItemTypes of source and destination\n+    union {\n+        struct {\n+            uint8_t dst : 4; //!< OffloadItemType of destination\n+            uint8_t src : 4; //!< OffloadItemType of source\n+        };\n+        uint8_t bits;\n+    } type;\n+\n+    //! OffloadParameterType that describes direction of data transfer\n+    union {\n+        struct {\n+            uint8_t in  : 1; //!< Set if IN or INOUT\n+            uint8_t out : 1; //!< Set if OUT or INOUT\n+        };\n+        uint8_t bits;\n+    } direction;\n+\n+    uint8_t alloc_if;        //!< alloc_if modifier value\n+    uint8_t free_if;         //!< free_if modifier value\n+    uint32_t align;          //!< MIC alignment requested for pointer data\n+    //! Not used by compiler; set to 0\n+    /*! Used by runtime as offset to data from start of MIC buffer */\n+    uint32_t mic_offset;\n+    //! Flags describing this variable\n+    union {\n+        struct {\n+            //! source variable has persistent storage\n+            uint32_t is_static : 1;\n+            //! destination variable has persistent storage\n+            uint32_t is_static_dstn : 1;\n+            //! has length for c_dv && c_dv_ptr\n+            uint32_t has_length : 1;\n+            //! persisted local scalar is in stack buffer\n+            uint32_t is_stack_buf : 1;\n+            //! buffer address is sent in data\n+            uint32_t sink_addr : 1;\n+            //! alloc displacement is sent in data\n+            uint32_t alloc_disp : 1;\n+            //! source data is noncontiguous\n+            uint32_t is_noncont_src : 1;\n+            //! destination data is noncontiguous\n+            uint32_t is_noncont_dst : 1;\n+        };\n+        uint32_t bits;\n+    } flags;\n+    //! Not used by compiler; set to 0\n+    /*! Used by runtime as offset to base from data stored in a buffer */\n+    int64_t offset;\n+    //! Element byte-size of data to be transferred\n+    /*! For dope-vector, the size of the dope-vector      */\n+    int64_t size;\n+    union {\n+        //! Set to 0 for array expressions and dope-vectors\n+        /*! Set to 1 for scalars                          */\n+        /*! Set to value of length modifier for pointers  */\n+        int64_t count;\n+        //! Displacement not used by compiler\n+        int64_t disp;\n+    };\n+\n+    //! This field not used by OpenMP 4.0\n+    /*! The alloc section expression in #pragma offload   */\n+    union {\n+       void *alloc;\n+       int64_t ptr_arr_offset;\n+    };\n+\n+    //! This field not used by OpenMP 4.0\n+    /*! The into section expression in #pragma offload    */\n+    /*! For c_data_ptr_array this is the into ptr array   */\n+    void *into;\n+\n+    //! For an ordinary variable, address of the variable\n+    /*! For c_cean_var (C/C++ array expression),\n+        pointer to arr_desc, which is an array descriptor. */\n+    /*! For c_data_ptr_array (array of data pointers),\n+        pointer to ptr_array_descriptor,\n+        which is a descriptor for pointer array transfers. */\n+    void *ptr;\n+};\n+\n+//! Auxiliary struct used when -g is enabled that holds variable names\n+struct VarDesc2 {\n+    const char *sname; //!< Source name\n+    const char *dname; //!< Destination name (when \"into\" is used)\n+};\n+\n+/*! When the OffloadItemType is c_data_ptr_array\n+    the ptr field of the main descriptor points to this struct.          */\n+/*! The type in VarDesc1 merely says c_cean_data_ptr, but the pointer\n+    type can be c_data_ptr, c_func_ptr, c_void_ptr, or c_string_ptr.\n+    Therefore the actual pointer type is in the flags field of VarDesc3. */\n+/*! If flag_align_is_array/flag_alloc_if_is_array/flag_free_if_is_array\n+    is 0 then alignment/alloc_if/free_if are specified in VarDesc1.      */\n+/*! If flag_align_is_array/flag_alloc_if_is_array/flag_free_if_is_array\n+    is 1 then align_array/alloc_if_array/free_if_array specify\n+    the set of alignment/alloc_if/free_if values.                        */\n+/*! For the other fields, if neither the scalar nor the array flag\n+    is set, then that modifier was not specified. If the bits are set\n+    they specify which modifier was set and whether it was a\n+    scalar or an array expression.                                       */\n+struct VarDesc3\n+{\n+    void *ptr_array;        //!< Pointer to arr_desc of array of pointers\n+    void *align_array;      //!< Scalar value or pointer to arr_desc\n+    void *alloc_if_array;   //!< Scalar value or pointer to arr_desc\n+    void *free_if_array;    //!< Scalar value or pointer to arr_desc\n+    void *extent_start;     //!< Scalar value or pointer to arr_desc\n+    void *extent_elements;  //!< Scalar value or pointer to arr_desc\n+    void *into_start;       //!< Scalar value or pointer to arr_desc\n+    void *into_elements;    //!< Scalar value or pointer to arr_desc\n+    void *alloc_start;      //!< Scalar value or pointer to arr_desc\n+    void *alloc_elements;   //!< Scalar value or pointer to arr_desc\n+    /*! Flags that describe the pointer type and whether each field\n+        is a scalar value or an array expression.        */\n+    /*! First 6 bits are pointer array element type:\n+        c_data_ptr, c_func_ptr, c_void_ptr, c_string_ptr */\n+    /*! Then single bits specify:                        */\n+    /*!     align_array is an array                      */\n+    /*!     alloc_if_array is an array                   */\n+    /*!     free_if_array is an array                    */\n+    /*!     extent_start is a scalar expression          */\n+    /*!     extent_start is an array expression          */\n+    /*!     extent_elements is a scalar expression       */\n+    /*!     extent_elements is an array expression       */\n+    /*!     into_start is a scalar expression            */\n+    /*!     into_start is an array expression            */\n+    /*!     into_elements is a scalar expression         */\n+    /*!     into_elements is an array expression         */\n+    /*!     alloc_start is a scalar expression           */\n+    /*!     alloc_start is an array expression           */\n+    /*!     alloc_elements is a scalar expression        */\n+    /*!     alloc_elements is an array expression        */\n+    uint32_t array_fields;\n+};\n+const int flag_align_is_array = 6;\n+const int flag_alloc_if_is_array = 7;\n+const int flag_free_if_is_array = 8;\n+const int flag_extent_start_is_scalar = 9;\n+const int flag_extent_start_is_array = 10;\n+const int flag_extent_elements_is_scalar = 11;\n+const int flag_extent_elements_is_array = 12;\n+const int flag_into_start_is_scalar = 13;\n+const int flag_into_start_is_array = 14;\n+const int flag_into_elements_is_scalar = 15;\n+const int flag_into_elements_is_array = 16;\n+const int flag_alloc_start_is_scalar = 17;\n+const int flag_alloc_start_is_array = 18;\n+const int flag_alloc_elements_is_scalar = 19;\n+const int flag_alloc_elements_is_array = 20;\n+\n+// The Marshaller\n+class Marshaller\n+{\n+private:\n+    // Start address of buffer\n+    char *buffer_start;\n+\n+    // Current pointer within buffer\n+    char *buffer_ptr;\n+\n+    // Physical size of data sent (including flags)\n+    long long buffer_size;\n+\n+    // User data sent/received\n+    long long tfr_size;\n+\n+public:\n+    // Constructor\n+    Marshaller() :\n+        buffer_start(0), buffer_ptr(0),\n+        buffer_size(0), tfr_size(0)\n+    {\n+    }\n+\n+    // Return count of user data sent/received\n+    long long get_tfr_size() const\n+    {\n+        return tfr_size;\n+    }\n+\n+    // Return pointer to buffer\n+    char *get_buffer_start() const\n+    {\n+        return buffer_start;\n+    }\n+\n+    // Return current size of data in buffer\n+    long long get_buffer_size() const\n+    {\n+        return buffer_size;\n+    }\n+\n+    // Set buffer pointer\n+    void init_buffer(\n+        char *d,\n+        long long s\n+    )\n+    {\n+        buffer_start = buffer_ptr = d;\n+        buffer_size = s;\n+    }\n+\n+    // Send data\n+    void send_data(\n+        const void *data,\n+        int64_t length\n+    );\n+\n+    // Receive data\n+    void receive_data(\n+        void *data,\n+        int64_t length\n+    );\n+\n+    // Send function pointer\n+    void send_func_ptr(\n+        const void* data\n+    );\n+\n+    // Receive function pointer\n+    void receive_func_ptr(\n+        const void** data\n+    );\n+};\n+\n+// End of the Marshaller\n+\n+// The offloaded function descriptor.\n+// Sent from host to target to specify which function to run.\n+// Also, sets console and file tracing levels.\n+struct FunctionDescriptor\n+{\n+    // Input data size.\n+    long long in_datalen;\n+\n+    // Output data size.\n+    long long out_datalen;\n+\n+    // Whether trace is requested on console.\n+    // A value of 1 produces only function name and data sent/received.\n+    // Values > 1 produce copious trace information.\n+    uint8_t console_enabled;\n+\n+    // Flag controlling timing on the target side.\n+    // Values > 0 enable timing on sink.\n+    uint8_t timer_enabled;\n+\n+    int offload_report_level;\n+    int offload_number;\n+\n+    // number of variable descriptors\n+    int vars_num;\n+\n+    // inout data offset if data is passed as misc/return data\n+    // otherwise it should be zero.\n+    int data_offset;\n+\n+    // The name of the offloaded function\n+    char data[];\n+};\n+\n+// typedef OFFLOAD.\n+// Pointer to OffloadDescriptor.\n+typedef struct OffloadDescriptor *OFFLOAD;\n+\n+#endif // OFFLOAD_COMMON_H_INCLUDED"}, {"sha": "2fe0d24430c112d03d172a3999de290496a6bf84", "filename": "liboffloadmic/runtime/offload_engine.cpp", "status": "added", "additions": 551, "deletions": 0, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_engine.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_engine.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_engine.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,551 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#include \"offload_engine.h\"\n+#include <signal.h>\n+#include <errno.h>\n+\n+#include <algorithm>\n+#include <vector>\n+\n+#include \"offload_host.h\"\n+#include \"offload_table.h\"\n+\n+const char* Engine::m_func_names[Engine::c_funcs_total] =\n+{\n+    \"server_compute\",\n+#ifdef MYO_SUPPORT\n+    \"server_myoinit\",\n+    \"server_myofini\",\n+#endif // MYO_SUPPORT\n+    \"server_init\",\n+    \"server_var_table_size\",\n+    \"server_var_table_copy\"\n+};\n+\n+// Symbolic representation of system signals. Fix for CQ233593\n+const char* Engine::c_signal_names[Engine::c_signal_max] =\n+{\n+    \"Unknown SIGNAL\",\n+    \"SIGHUP\",    /*  1, Hangup (POSIX).  */\n+    \"SIGINT\",    /*  2, Interrupt (ANSI).  */\n+    \"SIGQUIT\",   /*  3, Quit (POSIX).  */\n+    \"SIGILL\",    /*  4, Illegal instruction (ANSI).  */\n+    \"SIGTRAP\",   /*  5, Trace trap (POSIX).  */\n+    \"SIGABRT\",   /*  6, Abort (ANSI).  */\n+    \"SIGBUS\",    /*  7, BUS error (4.2 BSD).  */\n+    \"SIGFPE\",    /*  8, Floating-point exception (ANSI).  */\n+    \"SIGKILL\",   /*  9, Kill, unblockable (POSIX).  */\n+    \"SIGUSR1\",   /* 10, User-defined signal 1 (POSIX).  */\n+    \"SIGSEGV\",   /* 11, Segmentation violation (ANSI).  */\n+    \"SIGUSR2\",   /* 12, User-defined signal 2 (POSIX).  */\n+    \"SIGPIPE\",   /* 13, Broken pipe (POSIX).  */\n+    \"SIGALRM\",   /* 14, Alarm clock (POSIX).  */\n+    \"SIGTERM\",   /* 15, Termination (ANSI).  */\n+    \"SIGSTKFLT\", /* 16, Stack fault.  */\n+    \"SIGCHLD\",   /* 17, Child status has changed (POSIX).  */\n+    \"SIGCONT\",   /* 18, Continue (POSIX).  */\n+    \"SIGSTOP\",   /* 19, Stop, unblockable (POSIX).  */\n+    \"SIGTSTP\",   /* 20, Keyboard stop (POSIX).  */\n+    \"SIGTTIN\",   /* 21, Background read from tty (POSIX).  */\n+    \"SIGTTOU\",   /* 22, Background write to tty (POSIX).  */\n+    \"SIGURG\",    /* 23, Urgent condition on socket (4.2 BSD).  */\n+    \"SIGXCPU\",   /* 24, CPU limit exceeded (4.2 BSD).  */\n+    \"SIGXFSZ\",   /* 25, File size limit exceeded (4.2 BSD).  */\n+    \"SIGVTALRM\", /* 26, Virtual alarm clock (4.2 BSD).  */\n+    \"SIGPROF\",   /* 27, Profiling alarm clock (4.2 BSD).  */\n+    \"SIGWINCH\",  /* 28, Window size change (4.3 BSD, Sun).  */\n+    \"SIGIO\",     /* 29, I/O now possible (4.2 BSD).  */\n+    \"SIGPWR\",    /* 30, Power failure restart (System V).  */\n+    \"SIGSYS\"     /* 31, Bad system call.  */\n+};\n+\n+void Engine::init(void)\n+{\n+    if (!m_ready) {\n+        mutex_locker_t locker(m_lock);\n+\n+        if (!m_ready) {\n+            // start process if not done yet\n+            if (m_process == 0) {\n+                init_process();\n+            }\n+\n+            // load penging images\n+            load_libraries();\n+\n+            // and (re)build pointer table\n+            init_ptr_data();\n+\n+            // it is ready now\n+            m_ready = true;\n+        }\n+    }\n+}\n+\n+void Engine::init_process(void)\n+{\n+    COIENGINE engine;\n+    COIRESULT res;\n+    const char **environ;\n+\n+    // create environment for the target process\n+    environ = (const char**) mic_env_vars.create_environ_for_card(m_index);\n+    if (environ != 0) {\n+        for (const char **p = environ; *p != 0; p++) {\n+            OFFLOAD_DEBUG_TRACE(3, \"Env Var for card %d: %s\\n\", m_index, *p);\n+        }\n+    }\n+\n+    // Create execution context in the specified device\n+    OFFLOAD_DEBUG_TRACE(2, \"Getting device %d (engine %d) handle\\n\", m_index,\n+                        m_physical_index);\n+    res = COI::EngineGetHandle(COI_ISA_KNC, m_physical_index, &engine);\n+    check_result(res, c_get_engine_handle, m_index, res);\n+\n+    // Target executable should be available by the time when we\n+    // attempt to initialize the device\n+    if (__target_exe == 0) {\n+        LIBOFFLOAD_ERROR(c_no_target_exe);\n+        exit(1);\n+    }\n+\n+    OFFLOAD_DEBUG_TRACE(2,\n+        \"Loading target executable \\\"%s\\\" from %p, size %lld\\n\",\n+        __target_exe->name, __target_exe->data, __target_exe->size);\n+\n+    res = COI::ProcessCreateFromMemory(\n+        engine,                 // in_Engine\n+        __target_exe->name,     // in_pBinaryName\n+        __target_exe->data,     // in_pBinaryBuffer\n+        __target_exe->size,     // in_BinaryBufferLength,\n+        0,                      // in_Argc\n+        0,                      // in_ppArgv\n+        environ == 0,           // in_DupEnv\n+        environ,                // in_ppAdditionalEnv\n+        mic_proxy_io,           // in_ProxyActive\n+        mic_proxy_fs_root,      // in_ProxyfsRoot\n+        mic_buffer_size,        // in_BufferSpace\n+        mic_library_path,       // in_LibrarySearchPath\n+        __target_exe->origin,   // in_FileOfOrigin\n+        __target_exe->offset,   // in_FileOfOriginOffset\n+        &m_process              // out_pProcess\n+    );\n+    check_result(res, c_process_create, m_index, res);\n+\n+    // get function handles\n+    res = COI::ProcessGetFunctionHandles(m_process, c_funcs_total,\n+                                         m_func_names, m_funcs);\n+    check_result(res, c_process_get_func_handles, m_index, res);\n+\n+    // initialize device side\n+    pid_t pid = init_device();\n+\n+    // For IDB\n+    if (__dbg_is_attached) {\n+        // TODO: we have in-memory executable now.\n+        // Check with IDB team what should we provide them now?\n+        if (strlen(__target_exe->name) < MAX_TARGET_NAME) {\n+            strcpy(__dbg_target_exe_name, __target_exe->name);\n+        }\n+        __dbg_target_so_pid = pid;\n+        __dbg_target_id = m_physical_index;\n+        __dbg_target_so_loaded();\n+    }\n+}\n+\n+void Engine::fini_process(bool verbose)\n+{\n+    if (m_process != 0) {\n+        uint32_t sig;\n+        int8_t ret;\n+\n+        // destroy target process\n+        OFFLOAD_DEBUG_TRACE(2, \"Destroying process on the device %d\\n\",\n+                            m_index);\n+\n+        COIRESULT res = COI::ProcessDestroy(m_process, -1, 0, &ret, &sig);\n+        m_process = 0;\n+\n+        if (res == COI_SUCCESS) {\n+            OFFLOAD_DEBUG_TRACE(3, \"Device process: signal %d, exit code %d\\n\",\n+                                sig, ret);\n+            if (verbose) {\n+                if (sig != 0) {\n+                    LIBOFFLOAD_ERROR(\n+                        c_mic_process_exit_sig, m_index, sig,\n+                        c_signal_names[sig >= c_signal_max ? 0 : sig]);\n+                }\n+                else {\n+                    LIBOFFLOAD_ERROR(c_mic_process_exit_ret, m_index, ret);\n+                }\n+            }\n+\n+            // for idb\n+            if (__dbg_is_attached) {\n+                __dbg_target_so_unloaded();\n+            }\n+        }\n+        else {\n+            if (verbose) {\n+                LIBOFFLOAD_ERROR(c_mic_process_exit, m_index);\n+            }\n+        }\n+    }\n+}\n+\n+void Engine::load_libraries()\n+{\n+    // load libraries collected so far\n+    for (TargetImageList::iterator it = m_images.begin();\n+         it != m_images.end(); it++) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Loading library \\\"%s\\\" from %p, size %llu\\n\",\n+                            it->name, it->data, it->size);\n+\n+        // load library to the device\n+        COILIBRARY lib;\n+        COIRESULT res;\n+        res = COI::ProcessLoadLibraryFromMemory(m_process,\n+                                                it->data,\n+                                                it->size,\n+                                                it->name,\n+                                                mic_library_path,\n+                                                it->origin,\n+                                                it->offset,\n+                                                COI_LOADLIBRARY_V1_FLAGS,\n+                                                &lib);\n+\n+        if (res != COI_SUCCESS && res != COI_ALREADY_EXISTS) {\n+            check_result(res, c_load_library, m_index, res);\n+        }\n+    }\n+    m_images.clear();\n+}\n+\n+static bool target_entry_cmp(\n+    const VarList::BufEntry &l,\n+    const VarList::BufEntry &r\n+)\n+{\n+    const char *l_name = reinterpret_cast<const char*>(l.name);\n+    const char *r_name = reinterpret_cast<const char*>(r.name);\n+    return strcmp(l_name, r_name) < 0;\n+}\n+\n+static bool host_entry_cmp(\n+    const VarTable::Entry *l,\n+    const VarTable::Entry *r\n+)\n+{\n+    return strcmp(l->name, r->name) < 0;\n+}\n+\n+void Engine::init_ptr_data(void)\n+{\n+    COIRESULT res;\n+    COIEVENT event;\n+\n+    // Prepare table of host entries\n+    std::vector<const VarTable::Entry*> host_table(__offload_vars.begin(),\n+                                                   __offload_vars.end());\n+\n+    // no need to do anything further is host table is empty\n+    if (host_table.size() <= 0) {\n+        return;\n+    }\n+\n+    // Get var table entries from the target.\n+    // First we need to get size for the buffer to copy data\n+    struct {\n+        int64_t nelems;\n+        int64_t length;\n+    } params;\n+\n+    res = COI::PipelineRunFunction(get_pipeline(),\n+                                   m_funcs[c_func_var_table_size],\n+                                   0, 0, 0,\n+                                   0, 0,\n+                                   0, 0,\n+                                   &params, sizeof(params),\n+                                   &event);\n+    check_result(res, c_pipeline_run_func, m_index, res);\n+\n+    res = COI::EventWait(1, &event, -1, 1, 0, 0);\n+    check_result(res, c_event_wait, res);\n+\n+    if (params.length == 0) {\n+        return;\n+    }\n+\n+    // create buffer for target entries and copy data to host\n+    COIBUFFER buffer;\n+    res = COI::BufferCreate(params.length, COI_BUFFER_NORMAL, 0, 0, 1,\n+                            &m_process, &buffer);\n+    check_result(res, c_buf_create, m_index, res);\n+\n+    COI_ACCESS_FLAGS flags = COI_SINK_WRITE;\n+    res = COI::PipelineRunFunction(get_pipeline(),\n+                                   m_funcs[c_func_var_table_copy],\n+                                   1, &buffer, &flags,\n+                                   0, 0,\n+                                   &params.nelems, sizeof(params.nelems),\n+                                   0, 0,\n+                                   &event);\n+    check_result(res, c_pipeline_run_func, m_index, res);\n+\n+    res = COI::EventWait(1, &event, -1, 1, 0, 0);\n+    check_result(res, c_event_wait, res);\n+\n+    // patch names in target data\n+    VarList::BufEntry *target_table;\n+    COIMAPINSTANCE map_inst;\n+    res = COI::BufferMap(buffer, 0, params.length, COI_MAP_READ_ONLY, 0, 0,\n+                         0, &map_inst,\n+                         reinterpret_cast<void**>(&target_table));\n+    check_result(res, c_buf_map, res);\n+\n+    VarList::table_patch_names(target_table, params.nelems);\n+\n+    // and sort entries\n+    std::sort(target_table, target_table + params.nelems, target_entry_cmp);\n+    std::sort(host_table.begin(), host_table.end(), host_entry_cmp);\n+\n+    // merge host and target entries and enter matching vars map\n+    std::vector<const VarTable::Entry*>::const_iterator hi =\n+        host_table.begin();\n+    std::vector<const VarTable::Entry*>::const_iterator he =\n+        host_table.end();\n+    const VarList::BufEntry *ti = target_table;\n+    const VarList::BufEntry *te = target_table + params.nelems;\n+\n+    while (hi != he && ti != te) {\n+        int res = strcmp((*hi)->name, reinterpret_cast<const char*>(ti->name));\n+        if (res == 0) {\n+            // add matching entry to var map\n+            std::pair<PtrSet::iterator, bool> res =\n+                m_ptr_set.insert(PtrData((*hi)->addr, (*hi)->size));\n+\n+            // store address for new entries\n+            if (res.second) {\n+                PtrData *ptr = const_cast<PtrData*>(res.first.operator->());\n+                ptr->mic_addr = ti->addr;\n+                ptr->is_static = true;\n+            }\n+\n+            hi++;\n+            ti++;\n+        }\n+        else if (res < 0) {\n+            hi++;\n+        }\n+        else {\n+            ti++;\n+        }\n+    }\n+\n+    // cleanup\n+    res = COI::BufferUnmap(map_inst, 0, 0, 0);\n+    check_result(res, c_buf_unmap, res);\n+\n+    res = COI::BufferDestroy(buffer);\n+    check_result(res, c_buf_destroy, res);\n+}\n+\n+COIRESULT Engine::compute(\n+    const std::list<COIBUFFER> &buffers,\n+    const void*         data,\n+    uint16_t            data_size,\n+    void*               ret,\n+    uint16_t            ret_size,\n+    uint32_t            num_deps,\n+    const COIEVENT*     deps,\n+    COIEVENT*           event\n+) /* const */\n+{\n+    COIBUFFER *bufs;\n+    COI_ACCESS_FLAGS *flags;\n+    COIRESULT res;\n+\n+    // convert buffers list to array\n+    int num_bufs = buffers.size();\n+    if (num_bufs > 0) {\n+        bufs = (COIBUFFER*) alloca(num_bufs * sizeof(COIBUFFER));\n+        flags = (COI_ACCESS_FLAGS*) alloca(num_bufs *\n+                                           sizeof(COI_ACCESS_FLAGS));\n+\n+        int i = 0;\n+        for (std::list<COIBUFFER>::const_iterator it = buffers.begin();\n+             it != buffers.end(); it++) {\n+            bufs[i] = *it;\n+\n+            // TODO: this should be fixed\n+            flags[i++] = COI_SINK_WRITE;\n+        }\n+    }\n+    else {\n+        bufs = 0;\n+        flags = 0;\n+    }\n+\n+    // start computation\n+    res = COI::PipelineRunFunction(get_pipeline(),\n+                                   m_funcs[c_func_compute],\n+                                   num_bufs, bufs, flags,\n+                                   num_deps, deps,\n+                                   data, data_size,\n+                                   ret, ret_size,\n+                                   event);\n+    return res;\n+}\n+\n+pid_t Engine::init_device(void)\n+{\n+    struct init_data {\n+        int  device_index;\n+        int  devices_total;\n+        int  console_level;\n+        int  offload_report_level;\n+    } data;\n+    COIRESULT res;\n+    COIEVENT event;\n+    pid_t pid;\n+\n+    OFFLOAD_DEBUG_TRACE_1(2, 0, c_offload_init,\n+                          \"Initializing device with logical index %d \"\n+                          \"and physical index %d\\n\",\n+                           m_index, m_physical_index);\n+\n+    // setup misc data\n+    data.device_index = m_index;\n+    data.devices_total = mic_engines_total;\n+    data.console_level = console_enabled;\n+    data.offload_report_level = offload_report_level;\n+\n+    res = COI::PipelineRunFunction(get_pipeline(),\n+                                   m_funcs[c_func_init],\n+                                   0, 0, 0, 0, 0,\n+                                   &data, sizeof(data),\n+                                   &pid, sizeof(pid),\n+                                   &event);\n+    check_result(res, c_pipeline_run_func, m_index, res);\n+\n+    res = COI::EventWait(1, &event, -1, 1, 0, 0);\n+    check_result(res, c_event_wait, res);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Device process pid is %d\\n\", pid);\n+\n+    return pid;\n+}\n+\n+// data associated with each thread\n+struct Thread {\n+    Thread(long* addr_coipipe_counter) {\n+        m_addr_coipipe_counter = addr_coipipe_counter;\n+        memset(m_pipelines, 0, sizeof(m_pipelines));\n+    }\n+\n+    ~Thread() {\n+#ifndef TARGET_WINNT\n+        __sync_sub_and_fetch(m_addr_coipipe_counter, 1);\n+#else // TARGET_WINNT\n+        _InterlockedDecrement(m_addr_coipipe_counter);\n+#endif // TARGET_WINNT\n+        for (int i = 0; i < mic_engines_total; i++) {\n+            if (m_pipelines[i] != 0) {\n+                COI::PipelineDestroy(m_pipelines[i]);\n+            }\n+        }\n+    }\n+\n+    COIPIPELINE get_pipeline(int index) const {\n+        return m_pipelines[index];\n+    }\n+\n+    void set_pipeline(int index, COIPIPELINE pipeline) {\n+        m_pipelines[index] = pipeline;\n+    }\n+\n+    AutoSet& get_auto_vars() {\n+        return m_auto_vars;\n+    }\n+\n+private:\n+    long*       m_addr_coipipe_counter;\n+    AutoSet     m_auto_vars;\n+    COIPIPELINE m_pipelines[MIC_ENGINES_MAX];\n+};\n+\n+COIPIPELINE Engine::get_pipeline(void)\n+{\n+    Thread* thread = (Thread*) thread_getspecific(mic_thread_key);\n+    if (thread == 0) {\n+        thread = new Thread(&m_proc_number);\n+        thread_setspecific(mic_thread_key, thread);\n+    }\n+\n+    COIPIPELINE pipeline = thread->get_pipeline(m_index);\n+    if (pipeline == 0) {\n+        COIRESULT res;\n+        int proc_num;\n+\n+#ifndef TARGET_WINNT\n+        proc_num = __sync_fetch_and_add(&m_proc_number, 1);\n+#else // TARGET_WINNT\n+        proc_num = _InterlockedIncrement(&m_proc_number);\n+#endif // TARGET_WINNT\n+\n+        if (proc_num > COI_PIPELINE_MAX_PIPELINES) {\n+            LIBOFFLOAD_ERROR(c_coipipe_max_number, COI_PIPELINE_MAX_PIPELINES);\n+            LIBOFFLOAD_ABORT;\n+        }\n+        // create pipeline for this thread\n+        res = COI::PipelineCreate(m_process, 0, mic_stack_size, &pipeline);\n+        check_result(res, c_pipeline_create, m_index, res);\n+\n+        thread->set_pipeline(m_index, pipeline);\n+    }\n+    return pipeline;\n+}\n+\n+AutoSet& Engine::get_auto_vars(void)\n+{\n+    Thread* thread = (Thread*) thread_getspecific(mic_thread_key);\n+    if (thread == 0) {\n+        thread = new Thread(&m_proc_number);\n+        thread_setspecific(mic_thread_key, thread);\n+    }\n+\n+    return thread->get_auto_vars();\n+}\n+\n+void Engine::destroy_thread_data(void *data)\n+{\n+    delete static_cast<Thread*>(data);\n+}"}, {"sha": "501890c583428a4f21f9ed6806f458def2cf3575", "filename": "liboffloadmic/runtime/offload_engine.h", "status": "added", "additions": 502, "deletions": 0, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_engine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_engine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_engine.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,502 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#ifndef OFFLOAD_ENGINE_H_INCLUDED\n+#define OFFLOAD_ENGINE_H_INCLUDED\n+\n+#include <limits.h>\n+\n+#include <list>\n+#include <set>\n+#include <map>\n+#include \"offload_common.h\"\n+#include \"coi/coi_client.h\"\n+\n+// Address range\n+class MemRange {\n+public:\n+    MemRange() : m_start(0), m_length(0) {}\n+    MemRange(const void *addr, uint64_t len) : m_start(addr), m_length(len) {}\n+\n+    const void* start() const {\n+        return m_start;\n+    }\n+\n+    const void* end() const {\n+        return static_cast<const char*>(m_start) + m_length;\n+    }\n+\n+    uint64_t length() const {\n+        return m_length;\n+    }\n+\n+    // returns true if given range overlaps with another one\n+    bool overlaps(const MemRange &o) const {\n+        // Two address ranges A[start, end) and B[start,end) overlap\n+        // if A.start < B.end and A.end > B.start.\n+        return start() < o.end() && end() > o.start();\n+    }\n+\n+    // returns true if given range contains the other range\n+    bool contains(const MemRange &o) const {\n+        return start() <= o.start() && o.end() <= end();\n+    }\n+\n+private:\n+    const void* m_start;\n+    uint64_t    m_length;\n+};\n+\n+// Data associated with a pointer variable\n+class PtrData {\n+public:\n+    PtrData(const void *addr, uint64_t len) :\n+        cpu_addr(addr, len), cpu_buf(0),\n+        mic_addr(0), alloc_disp(0), mic_buf(0), mic_offset(0),\n+        ref_count(0), is_static(false)\n+    {}\n+\n+    //\n+    // Copy constructor\n+    //\n+    PtrData(const PtrData& ptr):\n+        cpu_addr(ptr.cpu_addr), cpu_buf(ptr.cpu_buf),\n+        mic_addr(ptr.mic_addr), alloc_disp(ptr.alloc_disp),\n+        mic_buf(ptr.mic_buf), mic_offset(ptr.mic_offset),\n+        ref_count(ptr.ref_count), is_static(ptr.is_static)\n+    {}\n+\n+    bool operator<(const PtrData &o) const {\n+        // Variables are sorted by the CPU start address.\n+        // Overlapping memory ranges are considered equal.\n+        return (cpu_addr.start() < o.cpu_addr.start()) &&\n+               !cpu_addr.overlaps(o.cpu_addr);\n+    }\n+\n+    long add_reference() {\n+        if (is_static) {\n+            return LONG_MAX;\n+        }\n+#ifndef TARGET_WINNT\n+        return __sync_fetch_and_add(&ref_count, 1);\n+#else // TARGET_WINNT\n+        return _InterlockedIncrement(&ref_count) - 1;\n+#endif // TARGET_WINNT\n+    }\n+\n+    long remove_reference() {\n+        if (is_static) {\n+            return LONG_MAX;\n+        }\n+#ifndef TARGET_WINNT\n+        return __sync_sub_and_fetch(&ref_count, 1);\n+#else // TARGET_WINNT\n+        return _InterlockedDecrement(&ref_count);\n+#endif // TARGET_WINNT\n+    }\n+\n+    long get_reference() const {\n+        if (is_static) {\n+            return LONG_MAX;\n+        }\n+        return ref_count;\n+    }\n+\n+public:\n+    // CPU address range\n+    const MemRange  cpu_addr;\n+\n+    // CPU and MIC buffers\n+    COIBUFFER       cpu_buf;\n+    COIBUFFER       mic_buf;\n+\n+    // placeholder for buffer address on mic\n+    uint64_t        mic_addr;\n+\n+    uint64_t        alloc_disp;\n+\n+    // additional offset to pointer data on MIC for improving bandwidth for\n+    // data which is not 4K aligned\n+    uint32_t        mic_offset;\n+\n+    // if true buffers are created from static memory\n+    bool            is_static;\n+    mutex_t         alloc_ptr_data_lock;\n+\n+private:\n+    // reference count for the entry\n+    long            ref_count;\n+};\n+\n+typedef std::list<PtrData*> PtrDataList;\n+\n+// Data associated with automatic variable\n+class AutoData {\n+public:\n+    AutoData(const void *addr, uint64_t len) :\n+        cpu_addr(addr, len), ref_count(0)\n+    {}\n+\n+    bool operator<(const AutoData &o) const {\n+        // Variables are sorted by the CPU start address.\n+        // Overlapping memory ranges are considered equal.\n+        return (cpu_addr.start() < o.cpu_addr.start()) &&\n+               !cpu_addr.overlaps(o.cpu_addr);\n+    }\n+\n+    long add_reference() {\n+#ifndef TARGET_WINNT\n+        return __sync_fetch_and_add(&ref_count, 1);\n+#else // TARGET_WINNT\n+        return _InterlockedIncrement(&ref_count) - 1;\n+#endif // TARGET_WINNT\n+    }\n+\n+    long remove_reference() {\n+#ifndef TARGET_WINNT\n+        return __sync_sub_and_fetch(&ref_count, 1);\n+#else // TARGET_WINNT\n+        return _InterlockedDecrement(&ref_count);\n+#endif // TARGET_WINNT\n+    }\n+\n+    long get_reference() const {\n+        return ref_count;\n+    }\n+\n+public:\n+    // CPU address range\n+    const MemRange cpu_addr;\n+\n+private:\n+    // reference count for the entry\n+    long ref_count;\n+};\n+\n+// Set of autimatic variables\n+typedef std::set<AutoData> AutoSet;\n+\n+// Target image data\n+struct TargetImage\n+{\n+    TargetImage(const char *_name, const void *_data, uint64_t _size,\n+                const char *_origin, uint64_t _offset) :\n+        name(_name), data(_data), size(_size),\n+        origin(_origin), offset(_offset)\n+    {}\n+\n+    // library name\n+    const char* name;\n+\n+    // contents and size\n+    const void* data;\n+    uint64_t    size;\n+\n+    // file of origin and offset within that file\n+    const char* origin;\n+    uint64_t    offset;\n+};\n+\n+typedef std::list<TargetImage> TargetImageList;\n+\n+// Data associated with persistent auto objects\n+struct PersistData\n+{\n+    PersistData(const void *addr, uint64_t routine_num, uint64_t size) :\n+        stack_cpu_addr(addr), routine_id(routine_num)\n+    {\n+        stack_ptr_data = new PtrData(0, size);\n+    }\n+    // 1-st key value - begining of the stack at CPU\n+    const void *   stack_cpu_addr;\n+    // 2-nd key value - identifier of routine invocation at CPU\n+    uint64_t   routine_id;\n+    // corresponded PtrData; only stack_ptr_data->mic_buf is used\n+    PtrData * stack_ptr_data;\n+    // used to get offset of the variable in stack buffer\n+    char * cpu_stack_addr;\n+};\n+\n+typedef std::list<PersistData> PersistDataList;\n+\n+// class representing a single engine\n+struct Engine {\n+    friend void __offload_init_library_once(void);\n+    friend void __offload_fini_library(void);\n+\n+#define check_result(res, tag, ...) \\\n+    { \\\n+        if (res == COI_PROCESS_DIED) { \\\n+            fini_process(true); \\\n+            exit(1); \\\n+        } \\\n+        if (res != COI_SUCCESS) { \\\n+            __liboffload_error_support(tag, __VA_ARGS__); \\\n+            exit(1); \\\n+        } \\\n+    }\n+\n+    int get_logical_index() const {\n+        return m_index;\n+    }\n+\n+    int get_physical_index() const {\n+        return m_physical_index;\n+    }\n+\n+    const COIPROCESS& get_process() const {\n+        return m_process;\n+    }\n+\n+    // initialize device\n+    void init(void);\n+\n+    // add new library\n+    void add_lib(const TargetImage &lib)\n+    {\n+        m_lock.lock();\n+        m_ready = false;\n+        m_images.push_back(lib);\n+        m_lock.unlock();\n+    }\n+\n+    COIRESULT compute(\n+        const std::list<COIBUFFER> &buffers,\n+        const void*         data,\n+        uint16_t            data_size,\n+        void*               ret,\n+        uint16_t            ret_size,\n+        uint32_t            num_deps,\n+        const COIEVENT*     deps,\n+        COIEVENT*           event\n+    );\n+\n+#ifdef MYO_SUPPORT\n+    // temporary workaround for blocking behavior for myoiLibInit/Fini calls\n+    void init_myo(COIEVENT *event) {\n+        COIRESULT res;\n+        res = COI::PipelineRunFunction(get_pipeline(),\n+                                       m_funcs[c_func_myo_init],\n+                                       0, 0, 0, 0, 0, 0, 0, 0, 0,\n+                                       event);\n+        check_result(res, c_pipeline_run_func, m_index, res);\n+    }\n+\n+    void fini_myo(COIEVENT *event) {\n+        COIRESULT res;\n+        res = COI::PipelineRunFunction(get_pipeline(),\n+                                       m_funcs[c_func_myo_fini],\n+                                       0, 0, 0, 0, 0, 0, 0, 0, 0,\n+                                       event);\n+        check_result(res, c_pipeline_run_func, m_index, res);\n+    }\n+#endif // MYO_SUPPORT\n+\n+    //\n+    // Memory association table\n+    //\n+    PtrData* find_ptr_data(const void *ptr) {\n+        m_ptr_lock.lock();\n+        PtrSet::iterator res = m_ptr_set.find(PtrData(ptr, 0));\n+        m_ptr_lock.unlock();\n+        if (res == m_ptr_set.end()) {\n+            return 0;\n+        }\n+        return const_cast<PtrData*>(res.operator->());\n+    }\n+\n+    PtrData* insert_ptr_data(const void *ptr, uint64_t len, bool &is_new) {\n+        m_ptr_lock.lock();\n+        std::pair<PtrSet::iterator, bool> res =\n+            m_ptr_set.insert(PtrData(ptr, len));\n+        PtrData* ptr_data = const_cast<PtrData*>(res.first.operator->());\n+        m_ptr_lock.unlock();\n+\n+        is_new = res.second;\n+        if (is_new) {\n+            // It's necessary to lock as soon as possible.\n+            // unlock must be done at call site of insert_ptr_data at\n+            // branch for is_new\n+            ptr_data->alloc_ptr_data_lock.lock();\n+        }\n+        return ptr_data;\n+    }\n+\n+    void remove_ptr_data(const void *ptr) {\n+        m_ptr_lock.lock();\n+        m_ptr_set.erase(PtrData(ptr, 0));\n+        m_ptr_lock.unlock();\n+    }\n+\n+    //\n+    // Automatic variables\n+    //\n+    AutoData* find_auto_data(const void *ptr) {\n+        AutoSet &auto_vars = get_auto_vars();\n+        AutoSet::iterator res = auto_vars.find(AutoData(ptr, 0));\n+        if (res == auto_vars.end()) {\n+            return 0;\n+        }\n+        return const_cast<AutoData*>(res.operator->());\n+    }\n+\n+    AutoData* insert_auto_data(const void *ptr, uint64_t len) {\n+        AutoSet &auto_vars = get_auto_vars();\n+        std::pair<AutoSet::iterator, bool> res =\n+            auto_vars.insert(AutoData(ptr, len));\n+        return const_cast<AutoData*>(res.first.operator->());\n+    }\n+\n+    void remove_auto_data(const void *ptr) {\n+        get_auto_vars().erase(AutoData(ptr, 0));\n+    }\n+\n+    //\n+    // Signals\n+    //\n+    void add_signal(const void *signal, OffloadDescriptor *desc) {\n+        m_signal_lock.lock();\n+        m_signal_map[signal] = desc;\n+        m_signal_lock.unlock();\n+    }\n+\n+    OffloadDescriptor* find_signal(const void *signal, bool remove) {\n+        OffloadDescriptor *desc = 0;\n+\n+        m_signal_lock.lock();\n+        {\n+            SignalMap::iterator it = m_signal_map.find(signal);\n+            if (it != m_signal_map.end()) {\n+                desc = it->second;\n+                if (remove) {\n+                    m_signal_map.erase(it);\n+                }\n+            }\n+        }\n+        m_signal_lock.unlock();\n+\n+        return desc;\n+    }\n+\n+    // stop device process\n+    void fini_process(bool verbose);\n+\n+    // list of stacks active at the engine\n+    PersistDataList m_persist_list;\n+\n+private:\n+    Engine() : m_index(-1), m_physical_index(-1), m_process(0), m_ready(false),\n+               m_proc_number(0)\n+    {}\n+\n+    ~Engine() {\n+        if (m_process != 0) {\n+            fini_process(false);\n+        }\n+    }\n+\n+    // set indexes\n+    void set_indexes(int logical_index, int physical_index) {\n+        m_index = logical_index;\n+        m_physical_index = physical_index;\n+    }\n+\n+    // start process on device\n+    void init_process();\n+\n+    void load_libraries(void);\n+    void init_ptr_data(void);\n+\n+    // performs library intialization on the device side\n+    pid_t init_device(void);\n+\n+private:\n+    // get pipeline associated with a calling thread\n+    COIPIPELINE get_pipeline(void);\n+\n+    // get automatic vars set associated with the calling thread\n+    AutoSet& get_auto_vars(void);\n+\n+    // destructor for thread data\n+    static void destroy_thread_data(void *data);\n+\n+private:\n+    typedef std::set<PtrData> PtrSet;\n+    typedef std::map<const void*, OffloadDescriptor*> SignalMap;\n+\n+    // device indexes\n+    int         m_index;\n+    int         m_physical_index;\n+\n+    // number of COI pipes created for the engine\n+    long        m_proc_number;\n+\n+    // process handle\n+    COIPROCESS  m_process;\n+\n+    // If false, device either has not been initialized or new libraries\n+    // have been added.\n+    bool        m_ready;\n+    mutex_t     m_lock;\n+\n+    // List of libraries to be loaded\n+    TargetImageList m_images;\n+\n+    // var table\n+    PtrSet      m_ptr_set;\n+    mutex_t     m_ptr_lock;\n+\n+    // signals\n+    SignalMap m_signal_map;\n+    mutex_t   m_signal_lock;\n+\n+    // constants for accessing device function handles\n+    enum {\n+        c_func_compute = 0,\n+#ifdef MYO_SUPPORT\n+        c_func_myo_init,\n+        c_func_myo_fini,\n+#endif // MYO_SUPPORT\n+        c_func_init,\n+        c_func_var_table_size,\n+        c_func_var_table_copy,\n+        c_funcs_total\n+    };\n+    static const char* m_func_names[c_funcs_total];\n+\n+    // device function handles\n+    COIFUNCTION m_funcs[c_funcs_total];\n+\n+    // int -> name mapping for device signals\n+    static const int   c_signal_max = 32;\n+    static const char* c_signal_names[c_signal_max];\n+};\n+\n+#endif // OFFLOAD_ENGINE_H_INCLUDED"}, {"sha": "447c6edf74e4fb01e8664db67c82328b4dfb8d68", "filename": "liboffloadmic/runtime/offload_env.cpp", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_env.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_env.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_env.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,378 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#include \"offload_env.h\"\n+#include <string.h>\n+#include <ctype.h>\n+#include \"offload_util.h\"\n+#include \"liboffload_error_codes.h\"\n+\n+// for environment variables valid on all cards\n+const int MicEnvVar::any_card = -1;\n+\n+MicEnvVar::~MicEnvVar()\n+{\n+    for (std::list<MicEnvVar::CardEnvVars*>::const_iterator\n+         it = card_spec_list.begin();\n+         it != card_spec_list.end(); it++) {\n+        CardEnvVars *card_data = *it;\n+        delete card_data;\n+    }\n+}\n+\n+MicEnvVar::VarValue::~VarValue()\n+{\n+    free(env_var_value);\n+}\n+\n+MicEnvVar::CardEnvVars::~CardEnvVars()\n+{\n+    for (std::list<MicEnvVar::VarValue*>::const_iterator it = env_vars.begin();\n+        it != env_vars.end(); it++) {\n+            VarValue *var_value = *it;\n+            delete var_value;\n+    }\n+}\n+\n+// Searching for card in \"card_spec_list\" list with the same \"number\"\n+\n+MicEnvVar::CardEnvVars* MicEnvVar::get_card(int number)\n+{\n+    if (number == any_card) {\n+        return &common_vars;\n+    }\n+    for (std::list<MicEnvVar::CardEnvVars*>::const_iterator\n+         it = card_spec_list.begin();\n+         it != card_spec_list.end(); it++) {\n+        CardEnvVars *card_data = *it;\n+        if (card_data->card_number == number) {\n+            return card_data;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+// Searching for environment variable in \"env_var\" list with the same name\n+\n+MicEnvVar::VarValue* MicEnvVar::CardEnvVars::find_var(\n+    char* env_var_name,\n+    int env_var_name_length\n+)\n+{\n+    for (std::list<MicEnvVar::VarValue*>::const_iterator it = env_vars.begin();\n+        it != env_vars.end(); it++) {\n+            VarValue *var_value = *it;\n+            if (var_value->length == env_var_name_length &&\n+                !strncmp(var_value->env_var, env_var_name,\n+                         env_var_name_length)) {\n+                return var_value;\n+            }\n+    }\n+    return NULL;\n+}\n+\n+void MicEnvVar::analyze_env_var(char *env_var_string)\n+{\n+    char          *env_var_name;\n+    char          *env_var_def;\n+    int           card_number;\n+    int           env_var_name_length;\n+    MicEnvVarKind env_var_kind;\n+\n+    env_var_kind = get_env_var_kind(env_var_string,\n+                                    &card_number,\n+                                    &env_var_name,\n+                                    &env_var_name_length,\n+                                    &env_var_def);\n+    switch (env_var_kind) {\n+        case c_mic_var:\n+        case c_mic_card_var:\n+            add_env_var(card_number,\n+                        env_var_name,\n+                        env_var_name_length,\n+                        env_var_def);\n+            break;\n+        case c_mic_card_env:\n+            mic_parse_env_var_list(card_number, env_var_def);\n+            break;\n+        case c_no_mic:\n+        default:\n+            break;\n+    }\n+}\n+\n+void MicEnvVar::add_env_var(\n+    int card_number,\n+    char *env_var_name,\n+    int env_var_name_length,\n+    char *env_var_def\n+)\n+{\n+    VarValue *var;\n+    CardEnvVars *card;\n+\n+    // The case corresponds to common env var definition of kind\n+    // <mic-prefix>_<var>\n+    if (card_number == any_card) {\n+        card = &common_vars;\n+    }\n+    else {\n+        card = get_card(card_number);\n+        if (!card) {\n+            // definition for new card occured\n+            card = new CardEnvVars(card_number);\n+            card_spec_list.push_back(card);\n+        }\n+\n+    }\n+    var = card->find_var(env_var_name, env_var_name_length);\n+    if (!var) {\n+        // put new env var definition in \"env_var\" list\n+        var = new VarValue(env_var_name, env_var_name_length, env_var_def);\n+        card->env_vars.push_back(var);\n+    }\n+}\n+\n+// The routine analyses string pointed by \"env_var_string\" argument\n+// according to the following syntax:\n+//\n+// Specification of prefix for MIC environment variables\n+// MIC_ENV_PREFIX=<mic-prefix>\n+//\n+// Setting single MIC environment variable\n+// <mic-prefix>_<var>=<value>\n+// <mic-prefix>_<card-number>_<var>=<value>\n+\n+// Setting multiple MIC environment variables\n+// <mic-prefix>_<card-number>_ENV=<env-vars>\n+\n+MicEnvVarKind MicEnvVar::get_env_var_kind(\n+    char *env_var_string,\n+    int *card_number,\n+    char **env_var_name,\n+    int *env_var_name_length,\n+    char **env_var_def\n+)\n+{\n+    int len = strlen(prefix);\n+    char *c = env_var_string;\n+    int num = 0;\n+    bool card_is_set = false;\n+\n+    if (strncmp(c, prefix, len) != 0 || c[len] != '_') {\n+            return c_no_mic;\n+    }\n+    c += len + 1;\n+\n+    *card_number = any_card;\n+    if (isdigit(*c)) {\n+        while (isdigit (*c)) {\n+            num = (*c++ - '0') + (num * 10);\n+        }\n+    if (*c != '_') {\n+        return c_no_mic;\n+    }\n+    c++;\n+        *card_number = num;\n+        card_is_set = true;\n+    }\n+    if (!isalpha(*c)) {\n+        return c_no_mic;\n+    }\n+    *env_var_name = *env_var_def = c;\n+    if (strncmp(c, \"ENV=\", 4) == 0) {\n+        if (!card_is_set) {\n+            *env_var_name_length = 3;\n+            *env_var_name = *env_var_def = c;\n+            *env_var_def = strdup(*env_var_def);\n+            return  c_mic_var;\n+        }\n+        *env_var_def = c + strlen(\"ENV=\");\n+        *env_var_def = strdup(*env_var_def);\n+        return c_mic_card_env;\n+    }\n+    if (isalpha(*c)) {\n+        *env_var_name_length = 0;\n+        while (isalnum(*c) || *c == '_') {\n+            c++;\n+            (*env_var_name_length)++;\n+        }\n+    }\n+    if (*c != '=') {\n+        return c_no_mic;\n+    }\n+    *env_var_def = strdup(*env_var_def);\n+    return card_is_set? c_mic_card_var : c_mic_var;\n+}\n+\n+// analysing <env-vars> in form:\n+// <mic-prefix>_<card-number>_ENV=<env-vars>\n+// where:\n+//\n+// <env-vars>:\n+//                <env-var>\n+//                <env-vars> | <env-var>\n+//\n+// <env-var>:\n+//                variable=value\n+//                variable=\"value\"\n+//                variable=\n+\n+void MicEnvVar::mic_parse_env_var_list(\n+    int card_number, char *env_vars_def_list)\n+{\n+    char *c = env_vars_def_list;\n+    char *env_var_name;\n+    int  env_var_name_length;\n+    char *env_var_def;\n+    bool var_is_quoted;\n+\n+    if (*c == '\"') {\n+        c++;\n+    }\n+    while (*c != 0) {\n+        var_is_quoted = false;\n+        env_var_name = c;\n+        env_var_name_length = 0;\n+        if (isalpha(*c)) {\n+            while (isalnum(*c) || *c == '_') {\n+                c++;\n+                env_var_name_length++;\n+            }\n+        }\n+        else {\n+            LIBOFFLOAD_ERROR(c_mic_parse_env_var_list1);\n+            return;\n+        }\n+        if (*c != '=') {\n+            LIBOFFLOAD_ERROR(c_mic_parse_env_var_list2);\n+            return;\n+        }\n+        c++;\n+\n+        if (*c == '\"') {\n+            var_is_quoted = true;\n+            c++;\n+        }\n+        // Environment variable values that contain | will need to be escaped.\n+        while (*c != 0 && *c != '|' &&\n+               (!var_is_quoted || *c != '\"'))\n+        {\n+            // skip escaped symbol\n+            if (*c == '\\\\') {\n+                c++;\n+            }\n+            c++;\n+        }\n+        if (var_is_quoted) {\n+            c++; // for \"\n+            while (*c != 0 && *c != '|') {\n+                c++;\n+            }\n+        }\n+\n+        int sz = c - env_var_name;\n+        env_var_def = (char*)malloc(sz);\n+        if (env_var_def == NULL)\n+          LIBOFFLOAD_ERROR(c_malloc);\n+        memcpy(env_var_def, env_var_name, sz);\n+        env_var_def[sz] = 0;\n+\n+        if (*c == '|') {\n+            c++;\n+            while (*c != 0 && *c == ' ') {\n+                c++;\n+            }\n+        }\n+        add_env_var(card_number,\n+                    env_var_name,\n+                    env_var_name_length,\n+                    env_var_def);\n+    }\n+}\n+\n+// Collect all definitions for the card with number \"card_num\".\n+// The returned result is vector of string pointers defining one\n+// environment variable. The vector is terminated by NULL pointer.\n+// In the begining of the vector there are env vars defined as\n+// <mic-prefix>_<card-number>_<var>=<value>\n+// or\n+// <mic-prefix>_<card-number>_ENV=<env-vars>\n+// where <card-number> is equal to \"card_num\"\n+// They are followed by definitions valid for any card\n+// and absent in previous definitions.\n+\n+char** MicEnvVar::create_environ_for_card(int card_num)\n+{\n+    VarValue *var_value;\n+    VarValue *var_value_find;\n+    CardEnvVars *card_data = get_card(card_num);\n+    CardEnvVars *card_data_common;\n+    std::list<char*> new_env;\n+    char **rez;\n+\n+    if (!prefix) {\n+        return NULL;\n+    }\n+    // There is no personel env var definitions for the card with\n+    // number \"card_num\"\n+    if (!card_data) {\n+        return create_environ_for_card(any_card);\n+    }\n+\n+    for (std::list<MicEnvVar::VarValue*>::const_iterator\n+         it = card_data->env_vars.begin();\n+         it != card_data->env_vars.end(); it++) {\n+        var_value = *it;\n+        new_env.push_back(var_value->env_var_value);\n+    }\n+\n+    if (card_num != any_card) {\n+        card_data_common = get_card(any_card);\n+        for (std::list<MicEnvVar::VarValue*>::const_iterator\n+             it = card_data_common->env_vars.begin();\n+             it != card_data_common->env_vars.end(); it++) {\n+            var_value = *it;\n+            var_value_find = card_data->find_var(var_value->env_var,\n+                                                 var_value->length);\n+            if (!var_value_find) {\n+                new_env.push_back(var_value->env_var_value);\n+            }\n+        }\n+    }\n+\n+    int new_env_size = new_env.size();\n+    rez = (char**) malloc((new_env_size + 1) * sizeof(char*));\n+    if (rez == NULL)\n+      LIBOFFLOAD_ERROR(c_malloc);\n+    std::copy(new_env.begin(), new_env.end(), rez);\n+    rez[new_env_size] = 0;\n+    return rez;\n+}"}, {"sha": "e60e8601e9ca2a89695e484d6770db8dd9495e0a", "filename": "liboffloadmic/runtime/offload_env.h", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_env.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_env.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_env.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1", "patch": "@@ -0,0 +1,111 @@\n+/*\n+    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+#ifndef OFFLOAD_ENV_H_INCLUDED\n+#define OFFLOAD_ENV_H_INCLUDED\n+\n+#include <list>\n+\n+// data structure and routines to parse MIC user environment and pass to MIC\n+\n+enum MicEnvVarKind\n+{\n+    c_no_mic,         // not MIC env var\n+    c_mic_var,        // for <mic-prefix>_<var>\n+    c_mic_card_var,   // for <mic-prefix>_<card-number>_<var>\n+    c_mic_card_env    // for <mic-prefix>_<card-number>_ENV\n+};\n+\n+struct MicEnvVar {\n+public:\n+    MicEnvVar() : prefix(0) {}\n+    ~MicEnvVar();\n+\n+    void analyze_env_var(char *env_var_string);\n+    char** create_environ_for_card(int card_num);\n+    MicEnvVarKind get_env_var_kind(\n+        char *env_var_string,\n+        int *card_number,\n+        char **env_var_name,\n+        int *env_var_name_length,\n+        char **env_var_def\n+    );\n+    void add_env_var(\n+        int card_number,\n+        char *env_var_name,\n+        int env_var_name_length,\n+        char *env_var_def\n+    );\n+\n+    void set_prefix(const char *pref) {\n+        prefix = (pref && *pref != '\\0') ? pref : 0;\n+    }\n+\n+    struct VarValue {\n+    public:\n+        char* env_var;\n+        int   length;\n+        char* env_var_value;\n+\n+        VarValue(char* var, int ln, char* value)\n+        {\n+            env_var = var;\n+            length = ln;\n+            env_var_value = value;\n+        }\n+        ~VarValue();\n+    };\n+\n+    struct CardEnvVars {\n+    public:\n+\n+        int card_number;\n+        std::list<struct VarValue*> env_vars;\n+\n+        CardEnvVars() { card_number = any_card; }\n+        CardEnvVars(int num) { card_number = num; }\n+        ~CardEnvVars();\n+\n+        void add_new_env_var(int number, char *env_var, int length,\n+                             char *env_var_value);\n+        VarValue* find_var(char* env_var_name, int env_var_name_length);\n+    };\n+    static const int any_card;\n+\n+private:\n+    void         mic_parse_env_var_list(int card_number, char *env_var_def);\n+    CardEnvVars* get_card(int number);\n+\n+    const char *prefix;\n+    std::list<struct CardEnvVars *> card_spec_list;\n+    CardEnvVars common_vars;\n+};\n+\n+#endif // OFFLOAD_ENV_H_INCLUDED"}, {"sha": "23a873f38860e3ce4d24e78a7c63100fc963fb21", "filename": "liboffloadmic/runtime/offload_host.cpp", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "2212dec51494510adeda3374785bddd418e31f23", "filename": "liboffloadmic/runtime/offload_host.h", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "987d077957a14b59799b630b966b5cc9fd22f485", "filename": "liboffloadmic/runtime/offload_myo_host.cpp", "status": "added", "additions": 829, "deletions": 0, "changes": 829, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "1116ee3601ea9eda3e2d99766fd820ed2581f2de", "filename": "liboffloadmic/runtime/offload_myo_host.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_myo_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_myo_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_host.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "bd5ad17adbc4e72d374693c76ed7ba3b639476ad", "filename": "liboffloadmic/runtime/offload_myo_target.cpp", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "777a3da1acab00e1a4d1119b43cdba72ff4607d2", "filename": "liboffloadmic/runtime/offload_myo_target.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_myo_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_myo_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_target.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "ceba612ac3b4029140a142a95c70e05d7cf5f324", "filename": "liboffloadmic/runtime/offload_omp_host.cpp", "status": "added", "additions": 485, "deletions": 0, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "2ccce7c76874386747bbf89d3737fa9ba4ed612c", "filename": "liboffloadmic/runtime/offload_omp_target.cpp", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "aa3edc36e03fc61980aa15feb99fab8cd216084b", "filename": "liboffloadmic/runtime/offload_orsl.cpp", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_orsl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_orsl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_orsl.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "8bdbf1abb5077c5626dde9a43d5563014f16f833", "filename": "liboffloadmic/runtime/offload_orsl.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_orsl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_orsl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_orsl.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "d73def16e70218948a747b25056721425f83ba4f", "filename": "liboffloadmic/runtime/offload_table.cpp", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_table.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_table.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_table.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "cc4caad47a156725d93de6329b81a73a317cc0c9", "filename": "liboffloadmic/runtime/offload_table.h", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_table.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "2e5f91e8c0bf92e51cbbaf860d4748a95b27ca69", "filename": "liboffloadmic/runtime/offload_target.cpp", "status": "added", "additions": 776, "deletions": 0, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "f3a42f982c85c51c525ec9a70f1d421c005e4ddd", "filename": "liboffloadmic/runtime/offload_target.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "90aca8f0812e4dd3579e39f494387bbc764978c8", "filename": "liboffloadmic/runtime/offload_target_main.cpp", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_target_main.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_target_main.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target_main.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "847f9d15edad80e0f0273ce0b61776e71151c402", "filename": "liboffloadmic/runtime/offload_timer.h", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_timer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_timer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "719af887abc690d548482f216d9041e786027b47", "filename": "liboffloadmic/runtime/offload_timer_host.cpp", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "8dc4bbcc81dd06e1e1f63ce549e2319d57e807c6", "filename": "liboffloadmic/runtime/offload_timer_target.cpp", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "4ba678cee37a2678c70788e57ae4445536c953b5", "filename": "liboffloadmic/runtime/offload_trace.cpp", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_trace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_trace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_trace.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "02a0c8794dbc7d621f70906f3e918526b4f0cc49", "filename": "liboffloadmic/runtime/offload_trace.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_trace.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "ae6a75916d43767cfb0fecef0d80df98d671ecd4", "filename": "liboffloadmic/runtime/offload_util.cpp", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_util.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "2cffd82f70a458a9254af06deb1009594c18d9ef", "filename": "liboffloadmic/runtime/offload_util.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Foffload_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_util.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "6f4b536f5b732bbe636f9335de7cb4a94201f5fc", "filename": "liboffloadmic/runtime/ofldbegin.cpp", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fofldbegin.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fofldbegin.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fofldbegin.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "0256c5a0f2099b4b68529b19d2c31e110f61bd29", "filename": "liboffloadmic/runtime/ofldend.cpp", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fofldend.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fofldend.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fofldend.cpp?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "b629a1a91b50ff648b535fc83f67f19933c7fa2f", "filename": "liboffloadmic/runtime/orsl-lite/include/orsl-lite.h", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "af01c119c35ecea29d44e58550452dcae29bd4ae", "filename": "liboffloadmic/runtime/orsl-lite/lib/orsl-lite.c", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "ab5f59930fc3b9bf59c8e0306d0a2c7855e111c5", "filename": "liboffloadmic/runtime/orsl-lite/version.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Forsl-lite%2Fversion.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Forsl-lite%2Fversion.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Fversion.txt?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}, {"sha": "948f4838fbfb6ac9f16ad0c9c45a804130782a52", "filename": "liboffloadmic/runtime/use_mpss2.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fuse_mpss2.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f520819620642ecd2b070f96efa3007ac1f15a1/liboffloadmic%2Fruntime%2Fuse_mpss2.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fuse_mpss2.txt?ref=5f520819620642ecd2b070f96efa3007ac1f15a1"}]}