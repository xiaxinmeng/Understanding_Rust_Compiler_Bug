{"sha": "40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBhN2ZlMWUzODJlOTdkZGE3OGI3Y2ZmOWUwNWJjOGUxN2JjOTIxNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-06-01T13:08:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-06-01T13:08:53Z"}, "message": "lto-symtab.c (lto_symtab_merge_cgraph_nodes_1): Rename to ...\n\n\t* lto-symtab.c (lto_symtab_merge_cgraph_nodes_1): Rename to ...\n\t(lto_symtab_merge_symbols_1): ... this one.\n\t(lto_symtab_merge_cgraph_nodes): Rename to ...\n\t(lto_symtab_merge_symbols): ... this one; simplify.\n\t* cgraph.c (same_body_aliases_done): Rename to ...\n\t(cpp_implicit_aliases_done): ... this one.\n\t(cgraph_create_function_alias): Update.\n\t(cgraph_same_body_alias): Update.\n\t(dump_cgraph_node): Remove alias dumping; simplify\n\tthunk dumping.\n\t(verify_edge_corresponds_to_fndecl): Simplify.\n\t* cgraph.h (symtab_node_base): Add cpp_implicit_alias,\n\talias_target.\n\t(cgraph_node): Remove same_body_alias.\n\t(varpool_node): Remove alias_of and extra_name_alias.\n\t(same_body_aliases_done): Rename to ..\n\t(cpp_implicit_aliases_done): ... this one.\n\t(symtab_alias_ultimate_target): Add default parameter.\n\t(symtab_resolve_alias): New function.\n\t(fixup_same_cpp_alias_visibility): Declare.\n\t(cgraph_function_node): Add default parameter.\n\t(cgraph_node_asm_name): Likewise.\n\t(cgraph_function_or_thunk_node): Add default parameter; do\n\tnot ICE when it is NULL.\n\t(varpool_variable_node): Likewise.\n\t* tree-emutls.c (create_emultls_var): Update.\n\t(ipa_lower_emutls): Update.\n\t* cgraphunit.c (cgraph_decide_is_function_needed): Update.\n\t(cgraph_reset_node): Reset alias info.\n\t(cgraph_finalize_function): Update.\n\t(fixup_same_cpp_alias_visibility): Move to symtab.c.\n\t(analyze_function): Simplify.\n\t(cgraph_process_same_body_aliases): Simplify.\n\t(analyze_functions): Fixup same body aliases.\n\t(handle_alias_pairs): Simplify.\n\t(assemble_thunk): Update.\n\t(assemble_thunks_and_aliases): Update.\n\t(output_weakrefs): Rewrite.\n\t* lto-cgraph.c (lto_output_node): Rewrite alias handling.\n\t(lto_output_varpool_node): Likewise.\n\t(compute_ltrans_boundary): Remve assert.\n\t(get_alias_symbol): New functoin.\n\t(input_node): Rewrite alias handling.\n\t(input_varpool_node): Likewise.\n\t* ipa-pure-const.c (propagate_pure_const): Fix formating.\n\t* ipa.c (process_references): Handle weakrefs correctly.\n\t(symtab_remove_unreachable_nodes): Likewise.\n\t* trans-mem.c (get_cg_data): Update.\n\t(ipa_tm_create_version_alias): Update.\n\t(ipa_tm_execute): Update.\n\t* symtab.c (dump_symtab_base): Dump aliases.\n\t(verify_symtab_base): Verify aliases.\n\t(symtab_node_availability): New function.\n\t(symtab_alias_ultimate_target): Simplify.\n\t(fixup_same_cpp_alias_visibility): Move here from cgraphunit.c;\n\thandle all the fixup cases.\n\t(symtab_resolve_alias): New function.\n\t* passes.c (ipa_write_summaries): Handle weakrefs.\n\t* varpool.c (varpool_analyze_node): Simplify.\n\t(assemble_aliases): Update.\n\t(varpool_create_variable_alias): Simplify.\n\t(varpool_extra_name_alias): Simplify.\n\t* lto-streamer.h (lto_symtab_merge_cgraph_nodes): Rename to...\n\t(lto_symtab_merge_symbols): ... this one.\n\n\t* decl2.c (cp_write_global_declarations): Replace same_body_alias\n\tby symbol.cpp_implicit_alias.\n\n\t* lto.c (read_cgraph_and_symbols): Simplify dumping; Replace\n\tlto_symtab_merge_cgraph_nodes by lto_symtab_merge_symbols.\n\t(do_whole_program_analysis): Update dumping.\n\nFrom-SVN: r199577", "tree": {"sha": "227ede588b4d6d5d96381098725519f26a853909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/227ede588b4d6d5d96381098725519f26a853909"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/comments", "author": null, "committer": null, "parents": [{"sha": "2175988161659537ed19aed873d148ed2d04ed7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2175988161659537ed19aed873d148ed2d04ed7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2175988161659537ed19aed873d148ed2d04ed7f"}], "stats": {"total": 688, "additions": 384, "deletions": 304}, "files": [{"sha": "c6a7d7dce6fe81056732485058e4e35a9c1b2995", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -1,3 +1,70 @@\n+2013-06-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_symtab_merge_cgraph_nodes_1): Rename to ...\n+\t(lto_symtab_merge_symbols_1): ... this one.\n+\t(lto_symtab_merge_cgraph_nodes): Rename to ...\n+\t(lto_symtab_merge_symbols): ... this one; simplify.\n+\t* cgraph.c (same_body_aliases_done): Rename to ...\n+\t(cpp_implicit_aliases_done): ... this one.\n+\t(cgraph_create_function_alias): Update.\n+\t(cgraph_same_body_alias): Update.\n+\t(dump_cgraph_node): Remove alias dumping; simplify\n+\tthunk dumping.\n+\t(verify_edge_corresponds_to_fndecl): Simplify.\n+\t* cgraph.h (symtab_node_base): Add cpp_implicit_alias,\n+\talias_target.\n+\t(cgraph_node): Remove same_body_alias.\n+\t(varpool_node): Remove alias_of and extra_name_alias.\n+\t(same_body_aliases_done): Rename to ..\n+\t(cpp_implicit_aliases_done): ... this one.\n+\t(symtab_alias_ultimate_target): Add default parameter.\n+\t(symtab_resolve_alias): New function.\n+\t(fixup_same_cpp_alias_visibility): Declare.\n+\t(cgraph_function_node): Add default parameter.\n+\t(cgraph_node_asm_name): Likewise.\n+\t(cgraph_function_or_thunk_node): Add default parameter; do\n+\tnot ICE when it is NULL.\n+\t(varpool_variable_node): Likewise.\n+\t* tree-emutls.c (create_emultls_var): Update.\n+\t(ipa_lower_emutls): Update.\n+\t* cgraphunit.c (cgraph_decide_is_function_needed): Update.\n+\t(cgraph_reset_node): Reset alias info.\n+\t(cgraph_finalize_function): Update.\n+\t(fixup_same_cpp_alias_visibility): Move to symtab.c.\n+\t(analyze_function): Simplify.\n+\t(cgraph_process_same_body_aliases): Simplify.\n+\t(analyze_functions): Fixup same body aliases.\n+\t(handle_alias_pairs): Simplify.\n+\t(assemble_thunk): Update.\n+\t(assemble_thunks_and_aliases): Update.\n+\t(output_weakrefs): Rewrite.\n+\t* lto-cgraph.c (lto_output_node): Rewrite alias handling.\n+\t(lto_output_varpool_node): Likewise.\n+\t(compute_ltrans_boundary): Remve assert.\n+\t(get_alias_symbol): New functoin.\n+\t(input_node): Rewrite alias handling.\n+\t(input_varpool_node): Likewise.\n+\t* ipa-pure-const.c (propagate_pure_const): Fix formating.\n+\t* ipa.c (process_references): Handle weakrefs correctly.\n+\t(symtab_remove_unreachable_nodes): Likewise.\n+\t* trans-mem.c (get_cg_data): Update.\n+\t(ipa_tm_create_version_alias): Update.\n+\t(ipa_tm_execute): Update.\n+\t* symtab.c (dump_symtab_base): Dump aliases.\n+\t(verify_symtab_base): Verify aliases.\n+\t(symtab_node_availability): New function.\n+\t(symtab_alias_ultimate_target): Simplify.\n+\t(fixup_same_cpp_alias_visibility): Move here from cgraphunit.c;\n+\thandle all the fixup cases.\n+\t(symtab_resolve_alias): New function.\n+\t* passes.c (ipa_write_summaries): Handle weakrefs.\n+\t* varpool.c (varpool_analyze_node): Simplify.\n+\t(assemble_aliases): Update.\n+\t(varpool_create_variable_alias): Simplify.\n+\t(varpool_extra_name_alias): Simplify.\n+\t* lto-streamer.h (lto_symtab_merge_cgraph_nodes): Rename to...\n+\t(lto_symtab_merge_symbols): ... this one.\n+\n 2013-06-01  Dinar Temirbulatov  <dinar@kugelworks.com>\n \n \tRevert"}, {"sha": "445282a4c5282bb24811675541770f10f0b77eb0", "filename": "gcc/cgraph.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -129,7 +129,7 @@ static GTY(()) struct cgraph_node *free_nodes;\n static GTY(()) struct cgraph_edge *free_edges;\n \n /* Did procss_same_body_aliases run?  */\n-bool same_body_aliases_done;\n+bool cpp_implicit_aliases_done;\n \n /* Map a cgraph_node to cgraph_function_version_info using this htab.\n    The cgraph_function_version_info has a THIS_NODE field that is the\n@@ -556,15 +556,16 @@ cgraph_get_create_node (tree decl)\n    the function body is associated with (not necessarily cgraph_node (DECL).  */\n \n struct cgraph_node *\n-cgraph_create_function_alias (tree alias, tree decl)\n+cgraph_create_function_alias (tree alias, tree target)\n {\n   struct cgraph_node *alias_node;\n \n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+  gcc_assert (TREE_CODE (target) == FUNCTION_DECL\n+\t      || TREE_CODE (target) == IDENTIFIER_NODE);\n   gcc_assert (TREE_CODE (alias) == FUNCTION_DECL);\n   alias_node = cgraph_get_create_node (alias);\n   gcc_assert (!alias_node->symbol.definition);\n-  alias_node->thunk.alias = decl;\n+  alias_node->symbol.alias_target = target;\n   alias_node->symbol.definition = true;\n   alias_node->symbol.alias = true;\n   return alias_node;\n@@ -589,10 +590,10 @@ cgraph_same_body_alias (struct cgraph_node *decl_node ATTRIBUTE_UNUSED, tree ali\n     return NULL;\n \n   n = cgraph_create_function_alias (alias, decl);\n-  n->same_body_alias = true;\n-  if (same_body_aliases_done)\n-    ipa_record_reference ((symtab_node)n, (symtab_node)cgraph_get_node (decl),\n-\t\t\t  IPA_REF_ALIAS, NULL);\n+  n->symbol.cpp_implicit_alias = true;\n+  if (cpp_implicit_aliases_done)\n+    symtab_resolve_alias ((symtab_node)n,\n+\t\t\t  (symtab_node)cgraph_get_node (decl));\n   return n;\n }\n \n@@ -1545,10 +1546,13 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \n   if (node->thunk.thunk_p)\n     {\n-      fprintf (f, \"  Thunk of %s (asm: %s) fixed offset %i virtual value %i has \"\n+      fprintf (f, \"  Thunk\");\n+      if (node->thunk.alias)\n+        fprintf (f, \"  of %s (asm: %s)\",\n+\t         lang_hooks.decl_printable_name (node->thunk.alias, 2),\n+\t         IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->thunk.alias)));\n+      fprintf (f, \" fixed offset %i virtual value %i has \"\n \t       \"virtual offset %i)\\n\",\n-\t       lang_hooks.decl_printable_name (node->thunk.alias, 2),\n-\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->thunk.alias)),\n \t       (int)node->thunk.fixed_offset,\n \t       (int)node->thunk.virtual_value,\n \t       (int)node->thunk.virtual_offset_p);\n@@ -2288,17 +2292,11 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n     return false;\n   node = cgraph_function_or_thunk_node (node, NULL);\n \n-  if ((e->callee->former_clone_of != node->symbol.decl\n-       && (!node->same_body_alias\n-\t   || e->callee->former_clone_of != node->thunk.alias))\n+  if (e->callee->former_clone_of != node->symbol.decl\n       /* IPA-CP sometimes redirect edge to clone and then back to the former\n \t function.  This ping-pong has to go, eventually.  */\n       && (node != cgraph_function_or_thunk_node (e->callee, NULL))\n-      && !clone_of_p (node, e->callee)\n-      /* If decl is a same body alias of some other decl, allow e->callee to be\n-\t a clone of a clone of that other decl too.  */\n-      && (!node->same_body_alias\n-\t  || !clone_of_p (cgraph_get_node (node->thunk.alias), e->callee)))\n+      && !clone_of_p (cgraph_function_or_thunk_node (node, NULL), e->callee))\n     return true;\n   else\n     return false;"}, {"sha": "276e568230e07d5acf307d03dcad94e426d4d891", "filename": "gcc/cgraph.h", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -56,6 +56,13 @@ struct GTY(()) symtab_node_base\n   /* True when symbol is an alias.  \n      Set by assemble_alias.  */\n   unsigned alias : 1;\n+  /* C++ frontend produce same body aliases and extra name aliases for\n+     virutal functions and vtables that are obviously equivalent.\n+     Those aliases are bit special, especially because C++ frontend\n+     visibility code is so ugly it can not get them right at first time\n+     and their visibility needs to be copied from their \"masters\" at\n+     the end of parsing.  */\n+  unsigned cpp_implicit_alias : 1;\n   /* Set once the definition was analyzed.  The list of references and\n      other properties are built during analysis.  */\n   unsigned analyzed : 1;\n@@ -119,6 +126,11 @@ struct GTY(()) symtab_node_base\n   /* Vectors of referring and referenced entities.  */\n   struct ipa_ref_list ref_list;\n \n+  /* Alias target. May be either DECL pointer or ASSEMBLER_NAME pointer\n+     depending to what was known to frontend on the creation time.\n+     Once alias is resolved, this pointer become NULL.  */\n+  tree alias_target;\n+\n   /* File stream where this node is being written to.  */\n   struct lto_file_decl_data * lto_file_data;\n \n@@ -291,8 +303,6 @@ struct GTY(()) cgraph_node {\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n   unsigned process : 1;\n-  /* Set for aliases created as C++ same body aliases.  */\n-  unsigned same_body_alias : 1;\n   /* How commonly executed the node is.  Initialized during branch\n      probabilities pass.  */\n   ENUM_BITFIELD (node_frequency) frequency : 2;\n@@ -478,12 +488,9 @@ typedef struct cgraph_edge *cgraph_edge_p;\n \n struct GTY(()) varpool_node {\n   struct symtab_node_base symbol;\n-  /* For aliases points to declaration DECL is alias of.  */\n-  tree alias_of;\n \n   /* Set when variable is scheduled to be assembled.  */\n   unsigned output : 1;\n-  unsigned extra_name_alias : 1;\n };\n \n /* Every top level asm statement is put into a asm_node.  */\n@@ -553,7 +560,7 @@ extern cgraph_node_set cgraph_new_nodes;\n \n extern GTY(()) struct asm_node *asm_nodes;\n extern GTY(()) int symtab_order;\n-extern bool same_body_aliases_done;\n+extern bool cpp_implicit_aliases_done;\n \n /* In symtab.c  */\n void symtab_register_node (symtab_node);\n@@ -576,7 +583,10 @@ void verify_symtab_node (symtab_node);\n bool verify_symtab_base (symtab_node);\n bool symtab_used_from_object_file_p (symtab_node);\n void symtab_make_decl_local (tree);\n-symtab_node symtab_alias_ultimate_target (symtab_node, enum availability *);\n+symtab_node symtab_alias_ultimate_target (symtab_node,\n+\t\t\t\t\t  enum availability *avail = NULL);\n+bool symtab_resolve_alias (symtab_node node, symtab_node target);\n+void fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target);\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n@@ -672,7 +682,8 @@ struct cgraph_2node_hook_list *cgraph_add_node_duplication_hook (cgraph_2node_ho\n void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n bool cgraph_propagate_frequency (struct cgraph_node *node);\n-struct cgraph_node * cgraph_function_node (struct cgraph_node *, enum availability *);\n+struct cgraph_node * cgraph_function_node (struct cgraph_node *,\n+\t\t\t\t\t   enum availability *avail = NULL);\n \n /* In cgraphunit.c  */\n struct asm_node *add_asm_node (tree);\n@@ -822,7 +833,7 @@ varpool_get_node (const_tree decl)\n \n /* Return asm name of cgraph node.  */\n static inline const char *\n-cgraph_node_asm_name(struct cgraph_node *node)\n+cgraph_node_asm_name (struct cgraph_node *node)\n {\n   return symtab_node_asm_name ((symtab_node)node);\n }\n@@ -1258,12 +1269,14 @@ varpool_alias_target (struct varpool_node *n)\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n static inline struct cgraph_node *\n-cgraph_function_or_thunk_node (struct cgraph_node *node, enum availability *availability)\n+cgraph_function_or_thunk_node (struct cgraph_node *node,\n+\t\t\t       enum availability *availability = NULL)\n {\n   struct cgraph_node *n;\n \n-  n = dyn_cast <cgraph_node> (symtab_alias_ultimate_target ((symtab_node)node, availability));\n-  if (!n)\n+  n = dyn_cast <cgraph_node> (symtab_alias_ultimate_target ((symtab_node)node,\n+\t\t\t\t\t\t\t    availability));\n+  if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n   return n;\n }\n@@ -1272,12 +1285,14 @@ cgraph_function_or_thunk_node (struct cgraph_node *node, enum availability *avai\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n static inline struct varpool_node *\n-varpool_variable_node (struct varpool_node *node, enum availability *availability)\n+varpool_variable_node (struct varpool_node *node,\n+\t\t       enum availability *availability = NULL)\n {\n   struct varpool_node *n;\n \n-  n = dyn_cast <varpool_node> (symtab_alias_ultimate_target ((symtab_node)node, availability));\n-  if (!n)\n+  n = dyn_cast <varpool_node> (symtab_alias_ultimate_target ((symtab_node)node,\n+\t\t\t\t\t\t\t     availability));\n+  if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n   return n;\n }"}, {"sha": "76ef876aa4778e21b9e85694df5bd55aa5ef73fa", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 56, "deletions": 89, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -231,8 +231,7 @@ cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n   /* Double check that no one output the function into assembly file\n      early.  */\n   gcc_checking_assert (!DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t               || (node->thunk.thunk_p || node->same_body_alias)\n-\t               ||  !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)));\n+\t               || !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)));\n \n \n   /* Keep constructors, destructors and virtual functions.  */\n@@ -370,6 +369,8 @@ cgraph_reset_node (struct cgraph_node *node)\n   memset (&node->rtl, 0, sizeof (node->rtl));\n   node->symbol.analyzed = false;\n   node->symbol.definition = false;\n+  node->symbol.alias = false;\n+  node->symbol.cpp_implicit_alias = false;\n \n   cgraph_node_remove_callees (node);\n   ipa_remove_all_references (&node->symbol.ref_list);\n@@ -426,7 +427,7 @@ cgraph_finalize_function (tree decl, bool nested)\n      in the original implementation and it is unclear whether we want\n      to change the behavior here.  */\n   if ((!optimize\n-       && !node->same_body_alias\n+       && !node->symbol.cpp_implicit_alias\n        && !DECL_DISREGARD_INLINE_LIMITS (decl)\n        && !DECL_DECLARED_INLINE_P (decl)\n        && !(DECL_CONTEXT (decl)\n@@ -573,22 +574,6 @@ output_asm_statements (void)\n   asm_nodes = NULL;\n }\n \n-/* C++ FE sometimes change linkage flags after producing same body aliases.  */\n-void\n-fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target, tree alias)\n-{\n-  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (alias);\n-  if (TREE_PUBLIC (node->symbol.decl))\n-    {\n-      DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (alias);\n-      DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (alias);\n-      DECL_COMDAT_GROUP (node->symbol.decl) = DECL_COMDAT_GROUP (alias);\n-      if (DECL_ONE_ONLY (alias)\n-\t  && !node->symbol.same_comdat_group)\n-\tsymtab_add_to_same_comdat_group ((symtab_node)node, (symtab_node)target);\n-    }\n-}\n-\n /* Analyze the function scheduled to be output.  */\n static void\n analyze_function (struct cgraph_node *node)\n@@ -597,39 +582,14 @@ analyze_function (struct cgraph_node *node)\n   location_t saved_loc = input_location;\n   input_location = DECL_SOURCE_LOCATION (decl);\n \n-  if (node->symbol.alias && node->thunk.alias)\n-    {\n-      struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n-      struct cgraph_node *n;\n-\n-      for (n = tgt; n && n->symbol.alias;\n-\t   n = n->symbol.analyzed ? cgraph_alias_target (n) : NULL)\n-\tif (n == node)\n-\t  {\n-\t    error (\"function %q+D part of alias cycle\", node->symbol.decl);\n-\t    node->symbol.alias = false;\n-\t    input_location = saved_loc;\n-\t    return;\n-\t  }\n-      if (!vec_safe_length (node->symbol.ref_list.references))\n-        ipa_record_reference ((symtab_node)node, (symtab_node)tgt,\n-\t\t\t      IPA_REF_ALIAS, NULL);\n-      if (node->same_body_alias)\n-\t{ \n-\t  DECL_DECLARED_INLINE_P (node->symbol.decl)\n-\t     = DECL_DECLARED_INLINE_P (node->thunk.alias);\n-\t  DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl)\n-\t     = DECL_DISREGARD_INLINE_LIMITS (node->thunk.alias);\n-\t  fixup_same_cpp_alias_visibility ((symtab_node) node, (symtab_node) tgt, node->thunk.alias);\n-\t}\n-\n-      if (node->symbol.address_taken)\n-\tcgraph_mark_address_taken_node (cgraph_alias_target (node));\n-    }\n+  if (node->symbol.alias)\n+    symtab_resolve_alias\n+       ((symtab_node) node, (symtab_node) cgraph_get_node (node->symbol.alias_target));\n   else if (node->thunk.thunk_p)\n     {\n       cgraph_create_edge (node, cgraph_get_node (node->thunk.alias),\n \t\t\t  NULL, 0, CGRAPH_FREQ_BASE);\n+      node->thunk.alias = NULL;\n     }\n   else if (node->dispatcher_function)\n     {\n@@ -693,16 +653,12 @@ analyze_function (struct cgraph_node *node)\n void\n cgraph_process_same_body_aliases (void)\n {\n-  struct cgraph_node *node;\n-  FOR_EACH_FUNCTION (node)\n-    if (node->same_body_alias\n-\t&& !vec_safe_length (node->symbol.ref_list.references))\n-      {\n-        struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n-        ipa_record_reference ((symtab_node)node, (symtab_node)tgt,\n-\t\t\t      IPA_REF_ALIAS, NULL);\n-      }\n-  same_body_aliases_done = true;\n+  symtab_node node;\n+  FOR_EACH_SYMBOL (node)\n+    if (node->symbol.cpp_implicit_alias && !node->symbol.analyzed)\n+      symtab_resolve_alias (node,\n+\t\t\t    symtab_get_node (node->symbol.alias_target));\n+  cpp_implicit_aliases_done = true;\n }\n \n /* Process attributes common for vars and functions.  */\n@@ -890,6 +846,13 @@ analyze_functions (void)\n   bitmap_obstack_initialize (NULL);\n   cgraph_state = CGRAPH_STATE_CONSTRUCTION;\n \n+  /* Ugly, but the fixup can not happen at a time same body alias is created;\n+     C++ FE is confused about the COMDAT groups being right.  */\n+  if (cpp_implicit_aliases_done)\n+    FOR_EACH_SYMBOL (node)\n+      if (node->symbol.cpp_implicit_alias)\n+\t  fixup_same_cpp_alias_visibility (node, symtab_alias_target (node));\n+\n   /* Analysis adds static variables that in turn adds references to new functions.\n      So we need to iterate the process until it stabilize.  */\n   while (changed)\n@@ -940,7 +903,7 @@ analyze_functions (void)\n \t      and later using weak alias attribute to kill its body.\n \t      See gcc.c-torture/compile/20011119-1.c  */\n \t      if (!DECL_STRUCT_FUNCTION (decl)\n-\t\t  && (!cnode->symbol.alias || !cnode->thunk.alias)\n+\t\t  && !cnode->symbol.alias\n \t\t  && !cnode->thunk.thunk_p\n \t\t  && !cnode->dispatcher_function)\n \t\t{\n@@ -970,7 +933,7 @@ analyze_functions (void)\n \t  else\n \t    {\n \t      varpool_node *vnode = dyn_cast <varpool_node> (node);\n-\t      if (vnode && vnode->symbol.definition)\n+\t      if (vnode && vnode->symbol.definition && !vnode->symbol.analyzed)\n \t\tvarpool_analyze_node (vnode);\n \t    }\n \n@@ -1016,7 +979,7 @@ analyze_functions (void)\n \t  tree decl = node->symbol.decl;\n \n \t  if (cnode->symbol.definition && !gimple_has_body_p (decl)\n-\t      && (!cnode->symbol.alias || !cnode->thunk.alias)\n+\t      && !cnode->symbol.alias\n \t      && !cnode->thunk.thunk_p)\n \t    cgraph_reset_node (cnode);\n \n@@ -1057,17 +1020,11 @@ handle_alias_pairs (void)\n \t to later output the weakref pseudo op into asm file.  */\n       if (!target_node && lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)) != NULL)\n \t{\n-\t  if (TREE_CODE (p->decl) == FUNCTION_DECL)\n-\t    {\n-\t      struct cgraph_node *anode = cgraph_get_create_node (p->decl);\n-\t      anode->symbol.alias = true;\n-\t      anode->thunk.alias = p->target;\n-\t    }\n-\t  else\n+\t  symtab_node node = symtab_get_node (p->decl);\n+\t  if (node)\n \t    {\n-\t      struct varpool_node *anode = varpool_get_node (p->decl);\n-\t      anode->symbol.alias = true;\n-\t      anode->alias_of = p->target;\n+\t      node->symbol.alias_target = p->target;\n+\t      node->symbol.alias = true;\n \t    }\n \t  DECL_EXTERNAL (p->decl) = 1;\n \t  alias_pairs->unordered_remove (i);\n@@ -1380,7 +1337,7 @@ assemble_thunk (struct cgraph_node *node)\n   HOST_WIDE_INT fixed_offset = node->thunk.fixed_offset;\n   HOST_WIDE_INT virtual_value = node->thunk.virtual_value;\n   tree virtual_offset = NULL;\n-  tree alias = node->thunk.alias;\n+  tree alias = node->callees->callee->symbol.decl;\n   tree thunk_fndecl = node->symbol.decl;\n   tree a = DECL_ARGUMENTS (thunk_fndecl);\n \n@@ -1581,15 +1538,15 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n-        bool saved_written = TREE_ASM_WRITTEN (alias->thunk.alias);\n+        bool saved_written = TREE_ASM_WRITTEN (node->symbol.decl);\n \n \t/* Force assemble_alias to really output the alias this time instead\n \t   of buffering it in same alias pairs.  */\n-\tTREE_ASM_WRITTEN (alias->thunk.alias) = 1;\n+\tTREE_ASM_WRITTEN (node->symbol.decl) = 1;\n \tdo_assemble_alias (alias->symbol.decl,\n-\t\t\t   DECL_ASSEMBLER_NAME (alias->thunk.alias));\n+\t\t\t   DECL_ASSEMBLER_NAME (node->symbol.decl));\n \tassemble_thunks_and_aliases (alias);\n-\tTREE_ASM_WRITTEN (alias->thunk.alias) = saved_written;\n+\tTREE_ASM_WRITTEN (node->symbol.decl) = saved_written;\n       }\n }\n \n@@ -1929,22 +1886,32 @@ get_alias_symbol (tree decl)\n static void\n output_weakrefs (void)\n {\n-  struct cgraph_node *node;\n-  struct varpool_node *vnode;\n-  FOR_EACH_FUNCTION (node)\n+  symtab_node node;\n+  FOR_EACH_SYMBOL (node)\n     if (node->symbol.alias && DECL_EXTERNAL (node->symbol.decl)\n         && !TREE_ASM_WRITTEN (node->symbol.decl)\n \t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n-      do_assemble_alias (node->symbol.decl,\n-\t\t         node->thunk.alias && DECL_P (node->thunk.alias) ? DECL_ASSEMBLER_NAME (node->thunk.alias)\n-\t\t         : get_alias_symbol (node->symbol.decl));\n-  FOR_EACH_VARIABLE (vnode)\n-    if (vnode->symbol.alias && DECL_EXTERNAL (vnode->symbol.decl)\n-        && !TREE_ASM_WRITTEN (vnode->symbol.decl)\n-\t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))\n-      do_assemble_alias (vnode->symbol.decl,\n-\t\t         vnode->alias_of && DECL_P (vnode->alias_of) ? DECL_ASSEMBLER_NAME (vnode->alias_of)\n-\t\t         : get_alias_symbol (vnode->symbol.decl));\n+      {\n+\ttree target;\n+\n+\t/* Weakrefs are special by not requiring target definition in current\n+\t   compilation unit.  It is thus bit hard to work out what we want to\n+\t   alias.\n+\t   When alias target is defined, we need to fetch it from symtab reference,\n+\t   otherwise it is pointed to by alias_target.  */\n+\tif (node->symbol.alias_target)\n+\t  target = (DECL_P (node->symbol.alias_target)\n+\t\t    ? DECL_ASSEMBLER_NAME (node->symbol.alias_target)\n+\t\t    : node->symbol.alias_target);\n+\telse if (node->symbol.analyzed)\n+\t  target = DECL_ASSEMBLER_NAME (symtab_alias_target (node)->symbol.decl);\n+\telse\n+\t  {\n+\t    gcc_unreachable ();\n+\t    target = get_alias_symbol (node->symbol.decl);\n+\t  }\n+        do_assemble_alias (node->symbol.decl, target);\n+      }\n }\n \n /* Initialize callgraph dump file.  */"}, {"sha": "8dc30f986c535b43347bbdd2fc42d2a40ad46d54", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -1,3 +1,8 @@\n+2013-06-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (cp_write_global_declarations): Replace same_body_alias\n+\tby symbol.cpp_implicit_alias.\n+\n 2013-05-30  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/57404"}, {"sha": "3fe234e6f09ef17c812b3935f151b09c04d220e7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -4201,7 +4201,7 @@ cp_write_global_declarations (void)\n \t      struct cgraph_node *node, *next;\n \n \t      node = cgraph_get_node (decl);\n-\t      if (node->same_body_alias)\n+\t      if (node->symbol.cpp_implicit_alias)\n \t\tnode = cgraph_alias_target (node);\n \n \t      cgraph_for_node_and_aliases (node, clear_decl_external,"}, {"sha": "9705db19e12a3a4bf618ad6ee1c4c3f9dc50d8d6", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -1110,7 +1110,7 @@ propagate_pure_const (void)\n   if (dump_file)\n     {\n       dump_cgraph (dump_file);\n-      ipa_print_order(dump_file, \"reduced\", order, order_pos);\n+      ipa_print_order (dump_file, \"reduced\", order, order_pos);\n     }\n \n   /* Propagate the local information through the call graph to produce"}, {"sha": "5382b7a8f315f6566ed4861c0f3920dccc9fe067", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -139,8 +139,7 @@ process_references (struct ipa_ref_list *list,\n       symtab_node node = ref->referred;\n \n       if (node->symbol.definition\n-\t  && (!DECL_EXTERNAL (node->symbol.decl)\n-\t      || node->symbol.alias\n+\t  && ((!DECL_EXTERNAL (node->symbol.decl) || node->symbol.alias)\n \t      || (before_inlining_p\n \t\t  /* We use variable constructors during late complation for\n \t\t     constant folding.  Keep references alive so partitioning\n@@ -297,7 +296,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t  if (e->callee->symbol.definition\n \t\t      && (!e->inline_failed\n \t\t\t  || !DECL_EXTERNAL (e->callee->symbol.decl)\n-\t\t\t  || cnode->symbol.alias\n+\t\t\t  || e->callee->symbol.alias\n \t\t\t  || before_inlining_p))\n \t\t    pointer_set_insert (reachable, e->callee);\n \t\t  enqueue_node ((symtab_node) e->callee, &first, reachable);"}, {"sha": "6699b8aa2ffdbc7bd007ca51acbdf84d554635f6", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -377,6 +377,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   struct cgraph_node *clone_of;\n   struct ipa_opt_pass_d *pass;\n   int i;\n+  bool alias_p;\n \n   boundary_p = !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node);\n \n@@ -485,7 +486,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      defined in other unit, we may use the info on aliases to resolve \n      symbol1 != symbol2 type tests that we can do only for locally defined objects\n      otherwise.  */\n-  bp_pack_value (&bp, node->symbol.alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl)), 1);\n+  alias_p = node->symbol.alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl));\n+  bp_pack_value (&bp, alias_p, 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n@@ -504,15 +506,6 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.fixed_offset);\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n     }\n-  if ((node->symbol.alias || node->thunk.thunk_p)\n-      && (!boundary_p || (node->symbol.alias && DECL_EXTERNAL (node->symbol.decl))))\n-    {\n-      streamer_write_hwi_in_range (ob->main_stream, 0, 1,\n-\t\t\t\t\tnode->thunk.alias != NULL);\n-      if (node->thunk.alias != NULL)\n-        lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n-\t\t\t          node->thunk.alias);\n-    }\n }\n \n /* Output the varpool NODE to OB. \n@@ -522,10 +515,10 @@ static void\n lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n \t\t\t lto_symtab_encoder_t encoder)\n {\n-  bool boundary_p = (node->symbol.definition\n-\t\t     && !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node));\n+  bool boundary_p = !lto_symtab_encoder_in_partition_p (encoder, (symtab_node)node);\n   struct bitpack_d bp;\n   int ref;\n+  bool alias_p;\n \n   streamer_write_enum (ob->main_stream, LTO_symtab_tags, LTO_symtab_last_tag,\n \t\t       LTO_symtab_variable);\n@@ -536,8 +529,9 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   bp_pack_value (&bp, node->symbol.force_output, 1);\n   bp_pack_value (&bp, node->symbol.unique_name, 1);\n   bp_pack_value (&bp, node->symbol.definition, 1);\n-  bp_pack_value (&bp, node->symbol.alias, 1);\n-  bp_pack_value (&bp, node->alias_of != NULL, 1);\n+  alias_p = node->symbol.alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl));\n+  bp_pack_value (&bp, alias_p, 1);\n+  bp_pack_value (&bp, node->symbol.analyzed && !boundary_p, 1);\n   gcc_assert (node->symbol.definition || !node->symbol.analyzed);\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n@@ -554,12 +548,11 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n       bp_pack_value (&bp, node->symbol.definition\n \t\t     && referenced_from_other_partition_p (&node->symbol.ref_list,\n \t\t\t\t\t\t\t   encoder), 1);\n-      bp_pack_value (&bp, boundary_p && !DECL_EXTERNAL (node->symbol.decl), 1);\n+      bp_pack_value (&bp, node->symbol.analyzed\n+\t\t     && boundary_p && !DECL_EXTERNAL (node->symbol.decl), 1);\n \t  /* in_other_partition.  */\n     }\n   streamer_write_bitpack (&bp);\n-  if (node->alias_of)\n-    lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->alias_of);\n   if (node->symbol.same_comdat_group && !boundary_p)\n     {\n       ref = lto_symtab_encoder_lookup (encoder,\n@@ -756,7 +749,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n        !lsei_end_p (lsei); lsei_next_variable_in_partition (&lsei))\n     {\n       struct varpool_node *vnode = lsei_varpool_node (lsei);\n-      gcc_assert (!vnode->symbol.alias || vnode->alias_of);\n+\n       lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n       add_references (encoder, &vnode->symbol.ref_list);\n@@ -919,6 +912,17 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t\t\t     LDPR_NUM_KNOWN);\n }\n \n+/* Return string alias is alias of.  */\n+\n+static tree\n+get_alias_symbol (tree decl)\n+{\n+  tree alias = lookup_attribute (\"alias\", DECL_ATTRIBUTES (decl));\n+  gcc_assert (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)));\n+  return get_identifier (TREE_STRING_POINTER\n+\t\t\t  (TREE_VALUE (TREE_VALUE (alias))));\n+}\n+\n /* Read a node from input_block IB.  TAG is the node's tag just read.\n    Return the node read or overwriten.  */\n \n@@ -1004,15 +1008,8 @@ input_node (struct lto_file_decl_data *file_data,\n       node->thunk.virtual_value = virtual_value;\n       node->thunk.virtual_offset_p = (type & 4);\n     }\n-  if (node->thunk.thunk_p || node->symbol.alias)\n-    {\n-      if (streamer_read_hwi_in_range (ib, \"alias nonzero flag\", 0, 1))\n-\t{\n-          decl_index = streamer_read_uhwi (ib);\n-          node->thunk.alias = lto_file_decl_data_get_fn_decl (file_data,\n-\t\t\t\t\t\t\t      decl_index);\n-\t}\n-    }\n+  if (node->symbol.alias && !node->symbol.analyzed)\n+    node->symbol.alias_target = get_alias_symbol (node->symbol.decl);\n   return node;\n }\n \n@@ -1028,7 +1025,6 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   struct varpool_node *node;\n   struct bitpack_d bp;\n   int ref = LCC_NOT_FOUND;\n-  bool non_null_aliasof;\n   int order;\n \n   order = streamer_read_hwi (ib) + order_base;\n@@ -1046,20 +1042,16 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->symbol.unique_name = bp_unpack_value (&bp, 1);\n   node->symbol.definition = bp_unpack_value (&bp, 1);\n   node->symbol.alias = bp_unpack_value (&bp, 1);\n-  non_null_aliasof = bp_unpack_value (&bp, 1);\n+  node->symbol.analyzed = bp_unpack_value (&bp, 1);\n   node->symbol.used_from_other_partition = bp_unpack_value (&bp, 1);\n   node->symbol.in_other_partition = bp_unpack_value (&bp, 1);\n-  node->symbol.analyzed = (node->symbol.definition && (!node->symbol.alias || !node->symbol.in_other_partition)); \n   if (node->symbol.in_other_partition)\n     {\n       DECL_EXTERNAL (node->symbol.decl) = 1;\n       TREE_STATIC (node->symbol.decl) = 0;\n     }\n-  if (non_null_aliasof)\n-    {\n-      decl_index = streamer_read_uhwi (ib);\n-      node->alias_of = lto_file_decl_data_get_var_decl (file_data, decl_index);\n-    }\n+  if (node->symbol.alias && !node->symbol.analyzed)\n+    node->symbol.alias_target = get_alias_symbol (node->symbol.decl);\n   ref = streamer_read_hwi (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->symbol.same_comdat_group = (symtab_node) (intptr_t) ref;"}, {"sha": "0f05d180183f2b99fec77b0d89267bc5ba7a914b", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -898,7 +898,7 @@ lto_symtab_encoder_t compute_ltrans_boundary (lto_symtab_encoder_t encoder);\n \n /* In lto-symtab.c.  */\n extern void lto_symtab_merge_decls (void);\n-extern void lto_symtab_merge_cgraph_nodes (void);\n+extern void lto_symtab_merge_symbols (void);\n extern tree lto_symtab_prevailing_decl (tree decl);\n extern GTY(()) vec<tree, va_gc> *lto_global_var_decls;\n "}, {"sha": "2b41933c67e0ff3eb5f72ea76312610e1ff965ad", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 18, "deletions": 74, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -542,7 +542,7 @@ lto_symtab_merge_decls (void)\n /* Helper to process the decl chain for the symbol table entry *SLOT.  */\n \n static void\n-lto_symtab_merge_cgraph_nodes_1 (symtab_node prevailing)\n+lto_symtab_merge_symbols_1 (symtab_node prevailing)\n {\n   symtab_node e, next;\n \n@@ -568,88 +568,32 @@ lto_symtab_merge_cgraph_nodes_1 (symtab_node prevailing)\n    lto_symtab_merge_decls.  */\n \n void\n-lto_symtab_merge_cgraph_nodes (void)\n+lto_symtab_merge_symbols (void)\n {\n-  struct cgraph_node *cnode;\n-  struct varpool_node *vnode;\n   symtab_node node;\n \n-  /* Populate assembler name hash.   */\n-  symtab_initialize_asm_name_hash ();\n-\n   if (!flag_ltrans)\n-    FOR_EACH_SYMBOL (node)\n-      if (lto_symtab_symbol_p (node)\n-\t  && node->symbol.next_sharing_asm_name\n-\t  && !node->symbol.previous_sharing_asm_name)\n-        lto_symtab_merge_cgraph_nodes_1 (node);\n-\n-  FOR_EACH_FUNCTION (cnode)\n-    {\n-      /* Resolve weakrefs to symbol defined in other unit.  */\n-      if (!cnode->symbol.analyzed && cnode->thunk.alias && !DECL_P (cnode->thunk.alias))\n-\t{\n-\t  symtab_node node = symtab_node_for_asm (cnode->thunk.alias);\n-\t  if (node && is_a <cgraph_node> (node))\n-\t    {\n-\t      struct cgraph_node *n;\n-\n-\t      for (n = cgraph (node); n && n->symbol.alias;\n-\t\t   n = n->symbol.analyzed ? cgraph_alias_target (n) : NULL)\n-\t\tif (n == cnode)\n-\t\t  {\n-\t\t    error (\"function %q+D part of alias cycle\", cnode->symbol.decl);\n-\t\t    cnode->symbol.alias = false;\n-\t\t    break;\n-\t\t  }\n-\t      if (cnode->symbol.alias)\n-\t\t{\n-\t\t  cgraph_create_function_alias (cnode->symbol.decl, node->symbol.decl);\n-\t\t  ipa_record_reference ((symtab_node)cnode, (symtab_node)node,\n-\t\t\t\t\tIPA_REF_ALIAS, NULL);\n-\t\t  cnode->symbol.analyzed = true;\n-\t\t}\n-\t    }\n-\t  else if (node)\n-\t    error (\"%q+D alias in between function and variable is not supported\", cnode->symbol.decl);\n-\t}\n-      if ((cnode->thunk.thunk_p || cnode->symbol.alias)\n-\t  && cnode->thunk.alias && DECL_P (cnode->thunk.alias))\n-        cnode->thunk.alias = lto_symtab_prevailing_decl (cnode->thunk.alias);\n-      cnode->symbol.aux = NULL;\n-    }\n-  FOR_EACH_VARIABLE (vnode)\n     {\n-      /* Resolve weakrefs to symbol defined in other unit.  */\n-      if (!vnode->symbol.analyzed && vnode->alias_of && !DECL_P (vnode->alias_of))\n+      symtab_initialize_asm_name_hash ();\n+\n+      /* Do the actual merging.  */\n+      FOR_EACH_SYMBOL (node)\n+\tif (lto_symtab_symbol_p (node)\n+\t    && node->symbol.next_sharing_asm_name\n+\t    && !node->symbol.previous_sharing_asm_name)\n+\t  lto_symtab_merge_symbols_1 (node);\n+\n+      /* Resolve weakref aliases whose target are now in the compilation unit.  */\n+      FOR_EACH_SYMBOL (node)\n \t{\n-\t  symtab_node node = symtab_node_for_asm (vnode->alias_of);\n-\t  if (node && is_a <cgraph_node> (node))\n+\t  if (!node->symbol.analyzed && node->symbol.alias_target)\n \t    {\n-\t      struct varpool_node *n;\n-\n-\t      for (n = varpool (node); n && n->symbol.alias;\n-\t\t   n = n->symbol.analyzed ? varpool_alias_target (n) : NULL)\n-\t\tif (n == vnode)\n-\t\t  {\n-\t\t    error (\"function %q+D part of alias cycle\", vnode->symbol.decl);\n-\t\t    vnode->symbol.alias = false;\n-\t\t    break;\n-\t\t  }\n-\t      if (vnode->symbol.alias)\n-\t\t{\n-\t\t  varpool_create_variable_alias (vnode->symbol.decl, node->symbol.decl);\n-\t\t  ipa_record_reference ((symtab_node)vnode, (symtab_node)node,\n-\t\t\t\t\tIPA_REF_ALIAS, NULL);\n-\t\t  vnode->symbol.analyzed = true;\n-\t\t}\n+\t      symtab_node tgt = symtab_node_for_asm (node->symbol.alias_target);\n+\t      if (tgt)\n+\t\tsymtab_resolve_alias (node, tgt);\n \t    }\n-\t  else if (node)\n-\t    error (\"%q+D alias in between function and variable is not supported\", vnode->symbol.decl);\n+\t  node->symbol.aux = NULL;\n \t}\n-      if (vnode->symbol.alias && DECL_P (vnode->alias_of))\n-        vnode->alias_of = lto_symtab_prevailing_decl (vnode->alias_of);\n-      vnode->symbol.aux = NULL;\n     }\n }\n "}, {"sha": "0a01c1b4f12f897b13f087b7677b5a2295fa56c9", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -1,3 +1,9 @@\n+2013-06-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (read_cgraph_and_symbols): Simplify dumping; Replace\n+\tlto_symtab_merge_cgraph_nodes by lto_symtab_merge_symbols.\n+\t(do_whole_program_analysis): Update dumping.\n+\n 2013-05-29  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (has_analyzed_clone_p, lto_materialize_function): Update for new symtab"}, {"sha": "05867e1ecf9ce4e6876856ec761e0c36b19a1ff4", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -3033,10 +3033,9 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Before merging:\\n\");\n-      dump_cgraph (cgraph_dump_file);\n-      dump_varpool (cgraph_dump_file);\n+      dump_symtab (cgraph_dump_file);\n     }\n-  lto_symtab_merge_cgraph_nodes ();\n+  lto_symtab_merge_symbols ();\n   ggc_collect ();\n \n   /* FIXME: ipa_transforms_to_apply holds list of passes that have optimization\n@@ -3169,10 +3168,7 @@ do_whole_program_analysis (void)\n   cgraph_function_flags_ready = true;\n \n   if (cgraph_dump_file)\n-    {\n-      dump_cgraph (cgraph_dump_file);\n-      dump_varpool (cgraph_dump_file);\n-    }\n+    dump_symtab (cgraph_dump_file);\n   bitmap_obstack_initialize (NULL);\n   cgraph_state = CGRAPH_STATE_IPA_SSA;\n \n@@ -3182,8 +3178,7 @@ do_whole_program_analysis (void)\n   if (cgraph_dump_file)\n     {\n       fprintf (cgraph_dump_file, \"Optimized \");\n-      dump_cgraph (cgraph_dump_file);\n-      dump_varpool (cgraph_dump_file);\n+      dump_symtab (cgraph_dump_file);\n     }\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();"}, {"sha": "2a29d9f82441f35184a07591bae1262313e3b74b", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -2461,6 +2461,7 @@ ipa_write_summaries (void)\n   lto_symtab_encoder_t encoder;\n   int i, order_pos;\n   struct varpool_node *vnode;\n+  struct cgraph_node *node;\n   struct cgraph_node **order;\n \n   if (!flag_generate_lto || seen_error ())\n@@ -2496,9 +2497,11 @@ ipa_write_summaries (void)\n         lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n     }\n \n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (node->symbol.alias)\n+      lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n-    if ((!vnode->symbol.alias || vnode->alias_of))\n-      lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n+    lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n \n   ipa_write_summaries_1 (compute_ltrans_boundary (encoder));\n "}, {"sha": "af8e70bb02cb609487c4abe0c5dd0b2dccc28f91", "filename": "gcc/symtab.c", "status": "modified", "additions": 122, "deletions": 11, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -481,6 +481,14 @@ dump_symtab_base (FILE *f, symtab_node node)\n     fprintf (f, \" analyzed\");\n   if (node->symbol.alias)\n     fprintf (f, \" alias\");\n+  if (node->symbol.cpp_implicit_alias)\n+    fprintf (f, \" cpp_implicit_alias\");\n+  if (node->symbol.alias_target)\n+    fprintf (f, \" target:%s\",\n+\t     DECL_P (node->symbol.alias_target) \n+\t     ? IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME\n+\t\t\t\t     (node->symbol.alias_target))\n+\t     : IDENTIFIER_POINTER (node->symbol.alias_target));\n   fprintf (f, \"\\n  Visibility:\");\n   if (node->symbol.in_other_partition)\n     fprintf (f, \" in_other_partition\");\n@@ -666,6 +674,17 @@ verify_symtab_base (symtab_node node)\n       error (\"node is analyzed byt it is not a definition\");\n       error_found = true;\n     }\n+  if (node->symbol.cpp_implicit_alias && !node->symbol.alias)\n+    {\n+      error (\"node is alias but not implicit alias\");\n+      error_found = true;\n+    }\n+  if (node->symbol.alias && !node->symbol.definition\n+      && !lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+    {\n+      error (\"node is alias but not definition\");\n+      error_found = true;\n+    }\n   if (node->symbol.same_comdat_group)\n     {\n       symtab_node n = node->symbol.same_comdat_group;\n@@ -757,6 +776,7 @@ symtab_used_from_object_file_p (symtab_node node)\n \n /* Make DECL local.  FIXME: We shouldn't need to mess with rtl this early,\n    but other code such as notice_global_symbol generates rtl.  */\n+\n void\n symtab_make_decl_local (tree decl)\n {\n@@ -796,6 +816,17 @@ symtab_make_decl_local (tree decl)\n   SYMBOL_REF_WEAK (symbol) = DECL_WEAK (decl);\n }\n \n+/* Return availability of NODE.  */\n+\n+enum availability\n+symtab_node_availability (symtab_node node)\n+{\n+  if (is_a <cgraph_node> (node))\n+    return cgraph_function_body_availability (cgraph (node));\n+  else\n+    return cgraph_variable_initializer_availability (varpool (node));\n+}\n+\n /* Given NODE, walk the alias chain to return the symbol NODE is alias of.\n    If NODE is not an alias, return NODE.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n@@ -804,12 +835,7 @@ symtab_node\n symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n {\n   if (availability)\n-    {\n-      if (is_a <cgraph_node> (node))\n-        *availability = cgraph_function_body_availability (cgraph (node));\n-      else\n-        *availability = cgraph_variable_initializer_availability (varpool (node));\n-    }\n+    *availability = symtab_node_availability (node);\n   while (node)\n     {\n       if (node->symbol.alias && node->symbol.analyzed)\n@@ -818,11 +844,7 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n \treturn node;\n       if (node && availability)\n \t{\n-\t  enum availability a;\n-\t  if (is_a <cgraph_node> (node))\n-\t    a = cgraph_function_body_availability (cgraph (node));\n-\t  else\n-\t    a = cgraph_variable_initializer_availability (varpool (node));\n+\t  enum availability a = symtab_node_availability (node);\n \t  if (a < *availability)\n \t    *availability = a;\n \t}\n@@ -831,4 +853,93 @@ symtab_alias_ultimate_target (symtab_node node, enum availability *availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n   return NULL;\n }\n+\n+/* C++ FE sometimes change linkage flags after producing same body aliases.\n+\n+   FIXME: C++ produce implicit aliases for virtual functions and vtables that\n+   are obviously equivalent.  The way it is doing so is however somewhat\n+   kludgy and interferes with the visibility code. As a result we need to\n+   copy the visibility from the target to get things right.  */\n+\n+void\n+fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target)\n+{\n+  if (is_a <cgraph_node> (node))\n+    {\n+      DECL_DECLARED_INLINE_P (node->symbol.decl)\n+\t = DECL_DECLARED_INLINE_P (target->symbol.decl);\n+      DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl)\n+\t = DECL_DISREGARD_INLINE_LIMITS (target->symbol.decl);\n+    }\n+  /* FIXME: It is not really clear why those flags should not be copied for\n+     functions, too.  */\n+  else\n+    {\n+      DECL_WEAK (node->symbol.decl) = DECL_WEAK (target->symbol.decl);\n+      DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (target->symbol.decl);\n+      DECL_VISIBILITY (node->symbol.decl) = DECL_VISIBILITY (target->symbol.decl);\n+    }\n+  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (target->symbol.decl);\n+  if (TREE_PUBLIC (node->symbol.decl))\n+    {\n+      DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (target->symbol.decl);\n+      DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (target->symbol.decl);\n+      DECL_COMDAT_GROUP (node->symbol.decl)\n+\t = DECL_COMDAT_GROUP (target->symbol.decl);\n+      if (DECL_ONE_ONLY (target->symbol.decl)\n+\t  && !node->symbol.same_comdat_group)\n+\tsymtab_add_to_same_comdat_group ((symtab_node)node, (symtab_node)target);\n+    }\n+  node->symbol.externally_visible = target->symbol.externally_visible;\n+}\n+\n+/* Add reference recording that NODE is alias of TARGET.\n+   The function can fail in the case of aliasing cycles; in this case\n+   it returns false.  */\n+\n+bool\n+symtab_resolve_alias (symtab_node node, symtab_node target)\n+{\n+  symtab_node n;\n+\n+  gcc_assert (!node->symbol.analyzed\n+\t      && !vec_safe_length (node->symbol.ref_list.references));\n+\n+  /* Never let cycles to creep into the symbol table alias references;\n+     those will make alias walkers to be infinite.  */\n+  for (n = target; n && n->symbol.alias;\n+       n = n->symbol.analyzed ? symtab_alias_target (n) : NULL)\n+    if (n == node)\n+       {\n+\t if (is_a <cgraph_node> (node))\n+           error (\"function %q+D part of alias cycle\", node->symbol.decl);\n+         else if (is_a <varpool_node> (node))\n+           error (\"variable %q+D part of alias cycle\", node->symbol.decl);\n+\t else\n+\t   gcc_unreachable ();\n+\t node->symbol.alias = false;\n+\t return false;\n+       }\n+\n+  /* \"analyze\" the node - i.e. mark the reference.  */\n+  node->symbol.definition = true;\n+  node->symbol.alias = true;\n+  node->symbol.analyzed = true;\n+  ipa_record_reference (node, target, IPA_REF_ALIAS, NULL);\n+\n+  /* Alias targets become reudndant after alias is resolved into an reference.\n+     We do not want to keep it around or we would have to mind updating them\n+     when renaming symbols.  */\n+  node->symbol.alias_target = NULL;\n+  DECL_ATTRIBUTES (node->symbol.decl)\n+     = remove_attribute (\"alias\", DECL_ATTRIBUTES (node->symbol.decl));\n+\n+  if (node->symbol.cpp_implicit_alias && cgraph_state >= CGRAPH_STATE_CONSTRUCTION)\n+    fixup_same_cpp_alias_visibility (node, target);\n+\n+  /* If alias has address taken, so does the target.  */\n+  if (node->symbol.address_taken)\n+    symtab_alias_ultimate_target (target, NULL)->symbol.address_taken = true;\n+  return true;\n+}\n #include \"gt-symtab.h\""}, {"sha": "03aba755b92e2fd0b787d60dc329aee4f9846d93", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -3933,7 +3933,7 @@ get_cg_data (struct cgraph_node **node, bool traverse_aliases)\n   struct tm_ipa_cg_data *d;\n \n   if (traverse_aliases && (*node)->symbol.alias)\n-    *node = cgraph_get_node ((*node)->thunk.alias);\n+    *node = cgraph_alias_target (*node);\n \n   d = (struct tm_ipa_cg_data *) (*node)->symbol.aux;\n \n@@ -4699,7 +4699,7 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n   tree old_decl, new_decl, tm_name;\n   struct cgraph_node *new_node;\n \n-  if (!node->same_body_alias)\n+  if (!node->symbol.cpp_implicit_alias)\n     return false;\n \n   old_decl = node->symbol.decl;\n@@ -5369,7 +5369,7 @@ ipa_tm_execute (void)\n       bool doit = false;\n \n       node = tm_callees[i];\n-      if (node->same_body_alias)\n+      if (node->symbol.cpp_implicit_alias)\n \tcontinue;\n \n       a = cgraph_function_body_availability (node);"}, {"sha": "6329fdd50154556e0d37618efddac112f8e8b0c1", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -699,7 +699,9 @@ create_emultls_var (struct varpool_node *var, void *data)\n   tree cdecl;\n   struct varpool_node *cvar;\n \n-  cdecl = new_emutls_decl (var->symbol.decl, var->alias_of);\n+  cdecl = new_emutls_decl (var->symbol.decl,\n+\t\t\t   var->symbol.alias && var->symbol.analyzed\n+\t\t\t   ? varpool_alias_target (var)->symbol.decl : NULL);\n \n   cvar = varpool_get_node (cdecl);\n   control_vars.quick_push (cvar);\n@@ -711,7 +713,7 @@ create_emultls_var (struct varpool_node *var, void *data)\n \t need to do this once for the main variable.  */\n       emutls_common_1 (var->symbol.decl, cdecl, (tree *)data);\n     }\n-  if (var->symbol.alias && !var->alias_of)\n+  if (var->symbol.alias && !var->symbol.analyzed)\n     cvar->symbol.alias = true;\n \n   /* Indicate that the value of the TLS variable may be found elsewhere,\n@@ -767,7 +769,7 @@ ipa_lower_emutls (void)\n     {\n       var = tls_vars->nodes[i];\n \n-      if (var->symbol.alias && !var->alias_of)\n+      if (var->symbol.alias && !var->symbol.analyzed)\n \tany_aliases = true;\n       else if (!var->symbol.alias)\n \tvarpool_for_node_and_aliases (var, create_emultls_var, &ctor_body, true);"}, {"sha": "7915a95fb50450ab0bcf2883b3d02c08abae84cf", "filename": "gcc/varpool.c", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a7fe1e382e97dda78b7cff9e05bc8e17bc9216/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=40a7fe1e382e97dda78b7cff9e05bc8e17bc9216", "patch": "@@ -240,30 +240,9 @@ varpool_analyze_node (struct varpool_node *node)\n \t already informed about increased alignment.  */\n       align_variable (decl, 0);\n     }\n-  if (node->symbol.alias && node->alias_of)\n-    {\n-      struct varpool_node *tgt = varpool_node_for_decl (node->alias_of);\n-      struct varpool_node *n;\n-\n-      for (n = tgt; n && n->symbol.alias;\n-\t   n = n->symbol.analyzed ? varpool_alias_target (n) : NULL)\n-\tif (n == node)\n-\t  {\n-\t    error (\"variable %q+D part of alias cycle\", node->symbol.decl);\n-\t    node->symbol.alias = false;\n-\t    continue;\n-\t  }\n-      if (!vec_safe_length (node->symbol.ref_list.references))\n-\tipa_record_reference ((symtab_node)node, (symtab_node)tgt, IPA_REF_ALIAS, NULL);\n-      if (node->extra_name_alias)\n-\t{\n-\t  DECL_WEAK (node->symbol.decl) = DECL_WEAK (node->alias_of);\n-\t  DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (node->alias_of);\n-\t  DECL_VISIBILITY (node->symbol.decl) = DECL_VISIBILITY (node->alias_of);\n-\t  fixup_same_cpp_alias_visibility ((symtab_node) node,\n-\t\t\t\t\t   (symtab_node) tgt, node->alias_of);\n-\t}\n-    }\n+  if (node->symbol.alias)\n+    symtab_resolve_alias\n+       ((symtab_node) node, (symtab_node) varpool_get_node (node->symbol.alias_target));\n   else if (DECL_INITIAL (decl))\n     record_references_in_initializer (decl, node->symbol.analyzed);\n   node->symbol.analyzed = true;\n@@ -281,7 +260,7 @@ assemble_aliases (struct varpool_node *node)\n       {\n \tstruct varpool_node *alias = ipa_ref_referring_varpool_node (ref);\n \tdo_assemble_alias (alias->symbol.decl,\n-\t\t\tDECL_ASSEMBLER_NAME (alias->alias_of));\n+\t\t\t   DECL_ASSEMBLER_NAME (node->symbol.decl));\n \tassemble_aliases (alias);\n       }\n }\n@@ -494,18 +473,7 @@ varpool_create_variable_alias (tree alias, tree decl)\n   alias_node = varpool_node_for_decl (alias);\n   alias_node->symbol.alias = true;\n   alias_node->symbol.definition = true;\n-  alias_node->alias_of = decl;\n-\n-  /* Extra name alias mechanizm creates aliases really late\n-     via DECL_ASSEMBLER_NAME mechanizm.\n-     This is unfortunate because they are not going through the\n-     standard channels.  Ensure they get output.  */\n-  if (cgraph_state >= CGRAPH_STATE_IPA)\n-    {\n-      varpool_analyze_node (alias_node);\n-      if (TREE_PUBLIC (alias))\n-\talias_node->symbol.externally_visible = true;\n-    }\n+  alias_node->symbol.alias_target = decl;\n   return alias_node;\n }\n \n@@ -522,7 +490,15 @@ varpool_extra_name_alias (tree alias, tree decl)\n   return NULL;\n #endif\n   alias_node = varpool_create_variable_alias (alias, decl);\n-  alias_node->extra_name_alias = true;\n+  alias_node->symbol.cpp_implicit_alias = true;\n+\n+  /* Extra name alias mechanizm creates aliases really late\n+     via DECL_ASSEMBLER_NAME mechanizm.\n+     This is unfortunate because they are not going through the\n+     standard channels.  Ensure they get output.  */\n+  if (cpp_implicit_aliases_done)\n+    symtab_resolve_alias ((symtab_node)alias_node,\n+\t\t\t  (symtab_node)varpool_node_for_decl (decl));\n   return alias_node;\n }\n "}]}