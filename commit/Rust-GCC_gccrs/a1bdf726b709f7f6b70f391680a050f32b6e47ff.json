{"sha": "a1bdf726b709f7f6b70f391680a050f32b6e47ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFiZGY3MjZiNzA5ZjdmNmI3MGYzOTE2ODBhMDUwZjMyYjZlNDdmZg==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2005-12-18T08:46:30Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-12-18T08:46:30Z"}, "message": "re PR tree-optimization/24378 (gcc.dg/vect/pr24300.c (test for excess errors) fails)\n\n        PR tree-optimization/24378\n        * tree-vect-transform.c (vect_transform_loop): Create single-predecessor\n        basic-block after loop-versioning.\n\nFrom-SVN: r108746", "tree": {"sha": "0a126b82fdcf5cdc667dce21f12dcbd5adecbb17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a126b82fdcf5cdc667dce21f12dcbd5adecbb17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1bdf726b709f7f6b70f391680a050f32b6e47ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bdf726b709f7f6b70f391680a050f32b6e47ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1bdf726b709f7f6b70f391680a050f32b6e47ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1bdf726b709f7f6b70f391680a050f32b6e47ff/comments", "author": null, "committer": null, "parents": [{"sha": "6fbcd2e574071e9cfd1c53097a10ec6cdbc79ea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fbcd2e574071e9cfd1c53097a10ec6cdbc79ea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fbcd2e574071e9cfd1c53097a10ec6cdbc79ea6"}], "stats": {"total": 38, "additions": 38, "deletions": 0}, "files": [{"sha": "3ab24e68c958752cfe98b51b8c426bf29d8c311a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1bdf726b709f7f6b70f391680a050f32b6e47ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1bdf726b709f7f6b70f391680a050f32b6e47ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1bdf726b709f7f6b70f391680a050f32b6e47ff", "patch": "@@ -1,3 +1,9 @@\n+2005-12-18  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\tPR tree-optimization/24378\t\n+\t* tree-vect-transform.c (vect_transform_loop): Create single-predecessor\n+\tbasic-block after loop-versioning. \n+\n 2005-12-18  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-dom.c (simplify_switch_and_lookup_avail_expr): Code"}, {"sha": "13bca53da43963bf16163caa0fe39a03a8df8a07", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1bdf726b709f7f6b70f391680a050f32b6e47ff/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1bdf726b709f7f6b70f391680a050f32b6e47ff/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=a1bdf726b709f7f6b70f391680a050f32b6e47ff", "patch": "@@ -2822,12 +2822,44 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n       tree cond_expr_stmt_list = NULL_TREE;\n       basic_block condition_bb;\n       block_stmt_iterator cond_exp_bsi;\n+      basic_block merge_bb;\n+      basic_block new_exit_bb;\n+      edge new_exit_e, e;\n+      tree orig_phi, new_phi, arg;\n \n       cond_expr = vect_create_cond_for_align_checks (loop_vinfo,\n                                                      &cond_expr_stmt_list);\n       initialize_original_copy_tables ();\n       nloop = loop_version (loops, loop, cond_expr, &condition_bb, true);\n       free_original_copy_tables();\n+\n+      /** Loop versioning violates an assumption we try to maintain during \n+\t vectorization - that the loop exit block has a single predecessor.\n+\t After versioning, the exit block of both loop versions is the same\n+\t basic block (i.e. it has two predecessors). Just in order to simplify\n+\t following transformations in the vectorizer, we fix this situation\n+\t here by adding a new (empty) block on the exit-edge of the loop,\n+\t with the proper loop-exit phis to maintain loop-closed-form.  **/\n+      \n+      merge_bb = loop->single_exit->dest;\n+      gcc_assert (EDGE_COUNT (merge_bb->preds) == 2);\n+      new_exit_bb = split_edge (loop->single_exit);\n+      add_bb_to_loop (new_exit_bb, loop->outer);\n+      new_exit_e = loop->single_exit;\n+      e = EDGE_SUCC (new_exit_bb, 0);\n+\n+      for (orig_phi = phi_nodes (merge_bb); orig_phi; \n+\t   orig_phi = PHI_CHAIN (orig_phi))\n+\t{\n+          new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n+\t\t\t\t     new_exit_bb);\n+          arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n+          add_phi_arg (new_phi, arg, new_exit_e);\n+\t  SET_PHI_ARG_DEF (orig_phi, e->dest_idx, PHI_RESULT (new_phi));\n+\t} \n+\n+      /** end loop-exit-fixes after versioning  **/\n+\n       update_ssa (TODO_update_ssa);\n       cond_exp_bsi = bsi_last (condition_bb);\n       bsi_insert_before (&cond_exp_bsi, cond_expr_stmt_list, BSI_SAME_STMT);"}]}