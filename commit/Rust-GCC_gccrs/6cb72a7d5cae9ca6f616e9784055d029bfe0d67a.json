{"sha": "6cb72a7d5cae9ca6f616e9784055d029bfe0d67a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiNzJhN2Q1Y2FlOWNhNmY2MTZlOTc4NDA1NWQwMjliZmUwZDY3YQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-15T18:35:30Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-15T18:35:30Z"}, "message": "(self_promoting_args_p, self_promoting_type_p):\n\n(signed_type, unsigned_type, default_conversion, check_format):\n(build_binary_op, c_expand_start_case):\nUse TYPE_MAIN_VARIANT when comparing against specific non-void types.\n\nFrom-SVN: r1591", "tree": {"sha": "4dc6575202d456eebac1d8909d9cfa6da0e9b0f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4dc6575202d456eebac1d8909d9cfa6da0e9b0f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cb72a7d5cae9ca6f616e9784055d029bfe0d67a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb72a7d5cae9ca6f616e9784055d029bfe0d67a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cb72a7d5cae9ca6f616e9784055d029bfe0d67a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb72a7d5cae9ca6f616e9784055d029bfe0d67a/comments", "author": null, "committer": null, "parents": [{"sha": "90d56da8ee8816a10dec35ae2ffe3ebd510cff81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d56da8ee8816a10dec35ae2ffe3ebd510cff81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d56da8ee8816a10dec35ae2ffe3ebd510cff81"}], "stats": {"total": 55, "additions": 29, "deletions": 26}, "files": [{"sha": "c4246215c7096c31d1bfa7575a7e211dc61c3295", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb72a7d5cae9ca6f616e9784055d029bfe0d67a/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb72a7d5cae9ca6f616e9784055d029bfe0d67a/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6cb72a7d5cae9ca6f616e9784055d029bfe0d67a", "patch": "@@ -153,13 +153,11 @@ qualify_type (type, like)\n \f\n /* Return the common type of two types.\n    We assume that comptypes has already been done and returned 1;\n-   if that isn't so, this may crash.\n+   if that isn't so, this may crash.  In particular, we assume that qualifiers\n+   match.\n \n    This is the type for the result of most arithmetic operations\n-   if the operands have the given two types.\n-\n-   We do not deal with enumeral types here because they have already been\n-   converted to integer types.  */\n+   if the operands have the given two types.  */\n \n tree\n common_type (t1, t2)\n@@ -603,7 +601,7 @@ self_promoting_args_p (parms)\n       if (TREE_CHAIN (t) == 0 && type != void_type_node)\n \treturn 0;\n \n-      if (type == float_type_node)\n+      if (TYPE_MAIN_VARIANT (type) == float_type_node)\n \treturn 0;\n \n       if (type\n@@ -620,7 +618,7 @@ static int\n self_promoting_type_p (type)\n      tree type;\n {\n-  if (type == float_type_node)\n+  if (TYPE_MAIN_VARIANT (type) == float_type_node)\n     return 0;\n \n   if (TREE_CODE (type) == INTEGER_TYPE\n@@ -636,15 +634,16 @@ tree\n unsigned_type (type)\n      tree type;\n {\n-  if (type == signed_char_type_node || type == char_type_node)\n+  tree type1 = TYPE_MAIN_VARIANT (type);\n+  if (type1 == signed_char_type_node || type1 == char_type_node)\n     return unsigned_char_type_node;\n-  if (type == integer_type_node)\n+  if (type1 == integer_type_node)\n     return unsigned_type_node;\n-  if (type == short_integer_type_node)\n+  if (type1 == short_integer_type_node)\n     return short_unsigned_type_node;\n-  if (type == long_integer_type_node)\n+  if (type1 == long_integer_type_node)\n     return long_unsigned_type_node;\n-  if (type == long_long_integer_type_node)\n+  if (type1 == long_long_integer_type_node)\n     return long_long_unsigned_type_node;\n   return type;\n }\n@@ -655,15 +654,16 @@ tree\n signed_type (type)\n      tree type;\n {\n-  if (type == unsigned_char_type_node || type == char_type_node)\n+  tree type1 = TYPE_MAIN_VARIANT (type);\n+  if (type1 == unsigned_char_type_node || type1 == char_type_node)\n     return signed_char_type_node;\n-  if (type == unsigned_type_node)\n+  if (type1 == unsigned_type_node)\n     return integer_type_node;\n-  if (type == short_unsigned_type_node)\n+  if (type1 == short_unsigned_type_node)\n     return short_integer_type_node;\n-  if (type == long_unsigned_type_node)\n+  if (type1 == long_unsigned_type_node)\n     return long_integer_type_node;\n-  if (type == long_long_unsigned_type_node)\n+  if (type1 == long_long_unsigned_type_node)\n     return long_long_integer_type_node;\n   return type;\n }\n@@ -917,7 +917,7 @@ default_conversion (exp)\n \treturn convert (unsigned_type_node, exp);\n       return convert (integer_type_node, exp);\n     }\n-  if (flag_traditional && type == float_type_node)\n+  if (flag_traditional && TYPE_MAIN_VARIANT (type) == float_type_node)\n     return convert (double_type_node, exp);\n   if (code == VOID_TYPE)\n     {\n@@ -1537,7 +1537,8 @@ check_format (info, params)\n \t\t     It will work on most machines, because size_t and int\n \t\t     have the same mode.  But might as well warn anyway,\n \t\t     since it will fail on other machines.  */\n-\t\t  if (TREE_TYPE (cur_param) != integer_type_node)\n+\t\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n+\t\t      != integer_type_node)\n \t\t    {\n \t\t      sprintf (message,\n \t\t\t       \"field width is not type int (arg %d)\",\n@@ -1580,7 +1581,8 @@ check_format (info, params)\n \t\t      cur_param = TREE_VALUE (params);\n \t\t      params = TREE_CHAIN (params);\n \t\t      ++arg_num;\n-\t\t      if (TREE_TYPE (cur_param) != integer_type_node)\n+\t\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n+\t\t\t  != integer_type_node)\n \t\t        {\n \t\t          sprintf (message,\n \t\t\t\t   \"field width is not type int (arg %d)\",\n@@ -1723,7 +1725,7 @@ check_format (info, params)\n \n       /* Check the type of the \"real\" argument, if there's a type we want.  */\n       if (i == fci->pointer_count && wanted_type != 0\n-\t  && wanted_type != cur_type\n+\t  && wanted_type != TYPE_MAIN_VARIANT (cur_type)\n \t  /* If we want `void *', allow any pointer type.\n \t     (Anything else would already have got a warning.)  */\n \t  && ! (wanted_type == void_type_node\n@@ -2363,7 +2365,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t     regardless of size of value being shifted.  */\n \t  if (! flag_traditional)\n \t    {\n-\t      if (TREE_TYPE (op1) != integer_type_node)\n+\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n \t\top1 = convert (integer_type_node, op1);\n \t      /* Avoid converting op1 to result_type later.  */\n \t      converted = 1;\n@@ -2387,7 +2389,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t     regardless of size of value being shifted.  */\n \t  if (! flag_traditional)\n \t    {\n-\t      if (TREE_TYPE (op1) != integer_type_node)\n+\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n \t\top1 = convert (integer_type_node, op1);\n \t      /* Avoid converting op1 to result_type later.  */\n \t      converted = 1;\n@@ -2412,7 +2414,7 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t     regardless of size of value being shifted.  */\n \t  if (! flag_traditional)\n \t    {\n-\t      if (TREE_TYPE (op1) != integer_type_node)\n+\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (op1)) != integer_type_node)\n \t\top1 = convert (integer_type_node, op1);\n \t      /* Avoid converting op1 to result_type later.  */\n \t      converted = 1;\n@@ -5312,10 +5314,11 @@ c_expand_start_case (exp)\n   else\n     {\n       tree index;\n+      type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n \n       if (warn_traditional\n-\t  && (TREE_TYPE (exp) == long_integer_type_node\n-\t      || TREE_TYPE (exp) == long_unsigned_type_node))\n+\t  && (type == long_integer_type_node\n+\t      || type == long_unsigned_type_node))\n \tpedwarn (\"`long' switch expression not converted to `int' in ANSI C\");\n \n       exp = default_conversion (exp);"}]}