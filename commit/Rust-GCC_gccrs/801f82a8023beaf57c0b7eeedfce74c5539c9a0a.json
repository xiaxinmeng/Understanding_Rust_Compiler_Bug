{"sha": "801f82a8023beaf57c0b7eeedfce74c5539c9a0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAxZjgyYTgwMjNiZWFmNTdjMGI3ZWVlZGZjZTc0YzU1MzljOWEwYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-15T11:02:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-15T11:02:40Z"}, "message": "entered into RCS\n\nFrom-SVN: r9958", "tree": {"sha": "c03b11efd6ee256044c17e5d1d48bd8b208b2ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c03b11efd6ee256044c17e5d1d48bd8b208b2ca0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/801f82a8023beaf57c0b7eeedfce74c5539c9a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801f82a8023beaf57c0b7eeedfce74c5539c9a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801f82a8023beaf57c0b7eeedfce74c5539c9a0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801f82a8023beaf57c0b7eeedfce74c5539c9a0a/comments", "author": null, "committer": null, "parents": [{"sha": "d37df6cc7ee664d748a7c493d90bb253c22a00df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d37df6cc7ee664d748a7c493d90bb253c22a00df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d37df6cc7ee664d748a7c493d90bb253c22a00df"}], "stats": {"total": 130, "additions": 130, "deletions": 0}, "files": [{"sha": "93c5beaef54a2f69c97098da3392cf0031807d61", "filename": "gcc/README.NS32K", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801f82a8023beaf57c0b7eeedfce74c5539c9a0a/gcc%2FREADME.NS32K", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801f82a8023beaf57c0b7eeedfce74c5539c9a0a/gcc%2FREADME.NS32K", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.NS32K?ref=801f82a8023beaf57c0b7eeedfce74c5539c9a0a", "patch": "@@ -0,0 +1,130 @@\n+This file describes the implementation notes of the GNU C Compiler for\n+the National Semiconductor 32032 chip (and 32000 family).\n+\n+The 32032 machine description and configuration file for this compiler\n+is, for NS32000 family machine, primarily machine independent.\n+However, since this release still depends on vendor-supplied\n+assemblers and linkers, the compiler must obey the existing\n+conventions of the actual machine to which this compiler is targeted.\n+In this case, the actual machine which this compiler was targeted to\n+is a Sequent Balance 8000, running DYNIX 2.1.\n+\n+The assembler for DYNIX 2.1 (and DYNIX 3.0, alas) does not cope with\n+the full generality of the addressing mode REGISTER RELATIVE.\n+Specifically, it generates incorrect code for operands of the\n+following form:\n+\n+\tsym(rn)\n+\n+Where `rn' is one of the general registers.  Correct code is generated\n+for operands of the form\n+\n+\tsym(pn)\n+\n+where `pn' is one of the special processor registers (sb, fp, or sp).\n+\n+An equivalent operand can be generated by the form\n+\n+\tsym[rn:b]\n+\n+although this addressing mode is about twice as slow on the 32032.\n+\n+The more efficient addressing mode is controlled by defining the\n+constant SEQUENT_ADDRESS_BUG to 0.  It is currently defined to be 1.\n+\n+Another bug in the assembler makes it impossible to compute with\n+explicit addresses.  In order to compute with a symbolic address, it\n+is necessary to load that address into a register using the \"addr\"\n+instruction.  For example, it is not possible to say\n+\n+\tcmpd _p,@_x\n+\n+Rather one must say\n+\n+\taddr _x,rn\n+\tcmpd _p,rn\n+\n+\n+The ns32032 chip has a number of known bugs.  Any attempt to make the\n+compiler unaware of these deficiencies will surely bring disaster.\n+The current list of know bugs are as follows (list provided by Richard\n+Stallman):\n+\n+1) instructions with two overlapping operands in memory\n+(unlikely in C code, perhaps impossible).\n+\n+2) floating point conversion instructions with constant\n+operands (these may never happen, but I'm not certain).\n+\n+3) operands crossing a page boundary.  These can be prevented\n+by setting the flag in tm.h that requires strict alignment.\n+\n+4) Scaled indexing in an insn following an insn that has a read-write\n+operand in memory.  This can be prevented by placing a no-op in\n+between.  I, Michael Tiemann, do not understand what exactly is meant\n+by `read-write operand in memory'.  If this is referring to the special\n+TOS mode, for example \"addd 5,tos\" then one need not fear, since this\n+will never be generated.  However, is this includes \"addd 5,-4(fp)\"\n+then there is room for disaster.  The Sequent compiler does not insert\n+a no-op for code involving the latter, and I have been informed that\n+Sequent is aware of this list of bugs, so I must assume that it is not\n+a problem.\n+\n+5) The 32032 cannot shift by 32 bits.  It shifts modulo the word size\n+of the operand.  Therefore, for 32-bit operations, 32-bit shifts are\n+interpreted as zero bit shifts.  32-bit shifts have been removed from\n+the compiler, but future hackers must be careful not to reintroduce\n+them.\n+\n+6) The ns32032 is a very slow chip; however, some instructions are\n+still very much slower than one might expect.  For example, it is\n+almost always faster to double a quantity by adding it to itself than\n+by shifting it by one, even if that quantity is deep in memory.  The\n+MOVM instruction has a 20-cycle setup time, after which it moves data\n+at about the speed that normal moves would.  It is also faster to use\n+address generation instructions than shift instructions for left\n+shifts less than 4.  I do not claim that I generate optimal code for all\n+given patterns, but where I did escape from National's \"clean\n+architecture\", I did so because the timing specification from the data\n+book says that I will win if I do.  I suppose this is called the\n+\"performance gap\".\n+\n+\n+Signed bitfield extraction has not been implemented.  It is not\n+provided by the NS32032, and while it is most certainly possible to do\n+better than the standard shift-left/shift-right sequence, it is also\n+quite hairy.  Also, since signed bitfields do not yet exist in C, this\n+omission seems relatively harmless.\n+\n+\n+Zero extractions could be better implemented if it were possible in\n+GCC to provide sized zero extractions: i.e. a byte zero extraction\n+would be allowed to yield a byte result.  The current implementation\n+of GCC manifests 68000-ist thinking, where bitfields are extracted\n+into a register, and automatically sign/zero extended to fill the\n+register.  See comments in ns32k.md around the \"extzv\" insn for more\n+details.\n+\n+\n+It should be noted that while the NS32000 family was designed to\n+provide odd-aligned addressing capability for multi-byte data (also\n+provided by the 68020, but not by the 68000 or 68010), many machines\n+do not opt to take advantage of this.  For example, on the sequent,\n+although there is no advantage to long-word aligning word data, shorts\n+must be int-aligned in structs.  This is an example of another\n+machine-specific machine dependency.\n+\n+\n+Because the ns32032 is has a coherent byte-order/bit-order\n+architecture, many instructions which would be different for\n+68000-style machines, fold into the same instruction for the 32032.\n+The classic case is push effective address, where it does not matter\n+whether one is pushing a long, word, or byte address.  They all will\n+push the same address.\n+\n+\n+The macro FUNCTION_VALUE_REGNO_P is probably not sufficient, what is\n+needed is FUNCTION_VALUE_P, which also takes a MODE parameter.  In\n+this way it will be possible to determine more exactly whether a\n+register is really a function value register, or just one that happens\n+to look right."}]}