{"sha": "a2f29587957bf9f1853b9eeba2b05492c9b7150a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJmMjk1ODc5NTdiZjlmMTg1M2I5ZWViYTJiMDU0OTJjOWI3MTUwYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-05-26T02:35:29Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-05-26T02:35:29Z"}, "message": "re PR fortran/13912 (Does not accept consecutive arithmetic operators (*-))\n\n\n\tPR fortran/13912\n\t* matchexp.c: Allow unary operators after arithmetic operators\n\tas a GNU extension.\n\t(match_ext_mult_operand, match_ext_add_operand): New functions.\n\t(match_mult_operand): Tweak to call match_ext_mult_operand.\n\t(match_add_operand): Tweak to call match_ext_mult_operand.\n\t(match_level_2): Rearrange to call match_ext_add_operand.\n\nFrom-SVN: r82277", "tree": {"sha": "6f5765b663bb23e6df8435cb2a011290e1575360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f5765b663bb23e6df8435cb2a011290e1575360"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2f29587957bf9f1853b9eeba2b05492c9b7150a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f29587957bf9f1853b9eeba2b05492c9b7150a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2f29587957bf9f1853b9eeba2b05492c9b7150a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2f29587957bf9f1853b9eeba2b05492c9b7150a/comments", "author": null, "committer": null, "parents": [{"sha": "7d34a5a986580c5fa23a165c800eb60ad5348450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d34a5a986580c5fa23a165c800eb60ad5348450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d34a5a986580c5fa23a165c800eb60ad5348450"}], "stats": {"total": 143, "additions": 129, "deletions": 14}, "files": [{"sha": "74228782f576b1d4eb96885dc7ad9cceffafbe55", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2f29587957bf9f1853b9eeba2b05492c9b7150a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2f29587957bf9f1853b9eeba2b05492c9b7150a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a2f29587957bf9f1853b9eeba2b05492c9b7150a", "patch": "@@ -1,3 +1,13 @@\n+2004-05-25  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR fortran/13912\n+\t* matchexp.c: Allow unary operators after arithmetic operators\n+\tas a GNU extension.\n+\t(match_ext_mult_operand, match_ext_add_operand): New functions.\n+\t(match_mult_operand): Tweak to call match_ext_mult_operand.\n+\t(match_add_operand): Tweak to call match_ext_mult_operand.\n+\t(match_level_2): Rearrange to call match_ext_add_operand.\n+\n 2004-05-25  Paul Brook  <paul@codesourcery.com>\n \n \t* expr.c (check_inquiry): Remove bogus tests."}, {"sha": "539a91a31c185cdbc3552f03c5fd1cd3f184c8d0", "filename": "gcc/fortran/matchexp.c", "status": "modified", "additions": 119, "deletions": 14, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2f29587957bf9f1853b9eeba2b05492c9b7150a/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2f29587957bf9f1853b9eeba2b05492c9b7150a/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=a2f29587957bf9f1853b9eeba2b05492c9b7150a", "patch": "@@ -222,6 +222,38 @@ match_level_1 (gfc_expr ** result)\n }\n \n \n+/* As a GNU extension we support an expanded level-2 expression syntax.\n+   Via this extension we support (arbitrary) nesting of unary plus and\n+   minus operations following unary and binary operators, such as **.\n+   The grammar of section 7.1.1.3 is effectively rewitten as:\n+\n+\tR704  mult-operand     is level-1-expr [ power-op ext-mult-operand ]\n+\tR704' ext-mult-operand is add-op ext-mult-operand\n+\t\t\t       or mult-operand\n+\tR705  add-operand      is add-operand mult-op ext-mult-operand\n+\t\t\t       or mult-operand\n+\tR705' ext-add-operand  is add-op ext-add-operand\n+\t\t\t       or add-operand\n+\tR706  level-2-expr     is [ level-2-expr ] add-op ext-add-operand\n+\t\t\t       or add-operand\n+ */\n+\n+static match match_ext_mult_operand (gfc_expr ** result);\n+static match match_ext_add_operand (gfc_expr ** result);\n+\n+\n+static int\n+match_add_op (void)\n+{\n+\n+  if (next_operator (INTRINSIC_MINUS))\n+    return -1;\n+  if (next_operator (INTRINSIC_PLUS))\n+    return 1;\n+  return 0;\n+}\n+\n+\n static match\n match_mult_operand (gfc_expr ** result)\n {\n@@ -241,7 +273,7 @@ match_mult_operand (gfc_expr ** result)\n \n   where = *gfc_current_locus ();\n \n-  m = match_mult_operand (&exp);\n+  m = match_ext_mult_operand (&exp);\n   if (m == MATCH_NO)\n     gfc_error (\"Expected exponent in expression at %C\");\n   if (m != MATCH_YES)\n@@ -265,6 +297,46 @@ match_mult_operand (gfc_expr ** result)\n }\n \n \n+static match\n+match_ext_mult_operand (gfc_expr ** result)\n+{\n+  gfc_expr *all, *e;\n+  locus where;\n+  match m;\n+  int i;\n+\n+  where = *gfc_current_locus ();\n+  i = match_add_op ();\n+\n+  if (i == 0)\n+    return match_mult_operand (result);\n+\n+  if (gfc_notify_std (GFC_STD_GNU, \"Extension: Unary operator following\"\n+\t\t      \" arithmetic operator (use parentheses) at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  m = match_ext_mult_operand (&e);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (i == -1)\n+    all = gfc_uminus (e);\n+  else\n+    all = gfc_uplus (e);\n+\n+  if (all == NULL)\n+    {\n+      gfc_free_expr (e);\n+      return MATCH_ERROR;\n+    }\n+\n+  all->where = where;\n+  *result = all;\n+  return MATCH_YES;\n+}\n+\n+\n static match\n match_add_operand (gfc_expr ** result)\n {\n@@ -295,7 +367,7 @@ match_add_operand (gfc_expr ** result)\n \n       where = *gfc_current_locus ();\n \n-      m = match_mult_operand (&e);\n+      m = match_ext_mult_operand (&e);\n       if (m == MATCH_NO)\n \t{\n \t  gfc_set_locus (&old_loc);\n@@ -329,15 +401,43 @@ match_add_operand (gfc_expr ** result)\n }\n \n \n-static int\n-match_add_op (void)\n+static match\n+match_ext_add_operand (gfc_expr ** result)\n {\n+  gfc_expr *all, *e;\n+  locus where;\n+  match m;\n+  int i;\n \n-  if (next_operator (INTRINSIC_MINUS))\n-    return -1;\n-  if (next_operator (INTRINSIC_PLUS))\n-    return 1;\n-  return 0;\n+  where = *gfc_current_locus ();\n+  i = match_add_op ();\n+\n+  if (i == 0)\n+    return match_add_operand (result);\n+\n+  if (gfc_notify_std (GFC_STD_GNU, \"Extension: Unary operator following\"\n+\t\t      \" arithmetic operator (use parentheses) at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  m = match_ext_add_operand (&e);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (i == -1)\n+    all = gfc_uminus (e);\n+  else\n+    all = gfc_uplus (e);\n+\n+  if (all == NULL)\n+    {\n+      gfc_free_expr (e);\n+      return MATCH_ERROR;\n+    }\n+\n+  all->where = where;\n+  *result = all;\n+  return MATCH_YES;\n }\n \n \n@@ -354,12 +454,17 @@ match_level_2 (gfc_expr ** result)\n   where = *gfc_current_locus ();\n   i = match_add_op ();\n \n-  m = match_add_operand (&e);\n-  if (i != 0 && m == MATCH_NO)\n+  if (i != 0)\n     {\n-      gfc_error (expression_syntax);\n-      m = MATCH_ERROR;\n+      m = match_ext_add_operand (&e);\n+      if (m == MATCH_NO)\n+\t{\n+\t  gfc_error (expression_syntax);\n+\t  m = MATCH_ERROR;\n+\t}\n     }\n+  else\n+    m = match_add_operand (&e);\n \n   if (m != MATCH_YES)\n     return m;\n@@ -391,7 +496,7 @@ match_level_2 (gfc_expr ** result)\n       if (i == 0)\n \tbreak;\n \n-      m = match_add_operand (&e);\n+      m = match_ext_add_operand (&e);\n       if (m == MATCH_NO)\n \tgfc_error (expression_syntax);\n       if (m != MATCH_YES)"}]}