{"sha": "9566a759384066b68943dd736bcdf63fb04e4da4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU2NmE3NTkzODQwNjZiNjg5NDNkZDczNmJjZGY2M2ZiMDRlNGRhNA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-07-25T18:43:25Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-07-25T18:43:25Z"}, "message": "expr.c (handled_component_p): Constify.\n\n\t* expr.c (handled_component_p): Constify.\n\t* fold-const.c (fit_double_type): Likewise.\n\t* real.h (real_value_from_int_cst): Likewise.\n\t* tree-flow-inline.h (gimple_in_ssa_p,\n\tgimple_aliases_computed_p, gimple_addressable_vars,\n\tgimple_call_clobbered_vars, gimple_referenced_vars,\n\tgimple_global_var, gimple_nonlocal_all, gimple_var_anns,\n\tend_htab_p, end_referenced_vars_p, var_ann, function_ann,\n\tmay_aliases, end_readonly_imm_use_p, has_zero_uses,\n\thas_single_use, single_imm_use, num_imm_uses, is_exec_stmt,\n\tis_label_stmt, is_global_var, phi_ssa_name_p,\n\tfactoring_name_p, is_call_clobbered, tree_common_ann,\n\top_iter_done, end_imm_use_stmt_p, end_imm_use_on_stmt_p,\n\tunmodifiable_var_p, array_ref_contains_indirect_ref,\n\tref_contains_array_ref, lookup_subvars_for_var,\n\tvar_can_have_subvars, overlap_subvar, gimple_ssa_operands,\n\tgimple_mem_ref_stats): Likewise.\n\t* tree-flow.h (tree_common_ann, var_ann, function_ann,\n\tmay_aliases, is_exec_stmt, is_label_stmt,\n\tref_contains_array_ref, array_ref_contains_indirect_ref,\n\tvar_can_have_subvars, overlap_subvar, is_call_clobbered,\n\tunmodifiable_var_p): Likewise.\n\t* tree-gimple.c (is_gimple_min_invariant): Likewise.\n\t* tree-gimple.h (is_gimple_min_invariant): Likewise. \n\t* tree.c (type_hash_list, attribute_hash_list, tree_size,\n\tcst_and_fits_in_hwi, real_value_from_int_cst,\n\tbuild_real_from_int_cst, integer_zerop, integer_onep,\n\tinteger_all_onesp, integer_pow2p, integer_nonzerop, tree_log2,\n\ttree_floor_log2, real_zerop, real_onep, real_twop,\n\treal_minus_onep, really_constant_p, purpose_member, chain_member,\n\tlist_length, fields_length, int_size_in_bytes, bit_position,\n\tint_bit_position, byte_position, int_byte_position, expr_align,\n\tarray_type_nelts, tree_node_structure,\n\ttype_contains_placeholder_1, iterative_hash_pointer,\n\tis_attribute_with_length_p, is_attribute_p, check_qualified_type,\n\ttree_map_base_eq, type_hash_list, type_hash_eq,\n\tattribute_hash_list, type_num_arguments, tree_int_cst_equal,\n\ttree_int_cst_lt, tree_int_cst_compare, host_integerp,\n\ttree_low_cst, tree_int_cst_msb, tree_int_cst_sgn,\n\tsimple_cst_list_equal, compare_tree_int, iterative_hash_expr,\n\tint_fits_type_p, get_containing_scope, decl_function_context,\n\tdecl_type_context, omp_clause_operand_check_failed,\n\tinitializer_zerop, int_cst_value, num_ending_zeros): Likewise.\n\t* tree.h (omp_clause_operand_check_failed, tree_size,\n\tbuild_real_from_int_cst, array_type_nelts, purpose_member,\n\ttree_int_cst_equal, tree_int_cst_lt, tree_int_cst_compare,\n\thost_integerp, tree_low_cst, tree_int_cst_msb, tree_int_cst_sgn,\n\tis_attribute_p, check_qualified_type, expr_align,\n\tint_size_in_bytes, bit_position, int_bit_position, byte_position,\n\tint_byte_position, list_length, fields_length, initializer_zerop,\n\tinteger_zerop, integer_onep, integer_all_onesp, integer_pow2p,\n\tinteger_nonzerop, cst_and_fits_in_hwi, num_ending_zeros,\n\ttree_node_structure, handled_component_p, get_containing_scope,\n\tdecl_function_context, decl_type_context, real_zerop,\n\ttype_num_arguments, fit_double_type, really_constant_p,\n\tint_fits_type_p, tree_log2, tree_floor_log2, iterative_hash_expr,\n\tcompare_tree_int, chain_member, simple_cst_list_equal, real_onep,\n\treal_twop, real_minus_onep, int_cst_value): Likewise.\n\nFrom-SVN: r126923", "tree": {"sha": "78b02a018ce0ebd1ecd5d3c658c8ac93c137c8b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78b02a018ce0ebd1ecd5d3c658c8ac93c137c8b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9566a759384066b68943dd736bcdf63fb04e4da4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9566a759384066b68943dd736bcdf63fb04e4da4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9566a759384066b68943dd736bcdf63fb04e4da4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9566a759384066b68943dd736bcdf63fb04e4da4/comments", "author": null, "committer": null, "parents": [{"sha": "f7d504c227fb7e621b6521fe282956f021cd2337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d504c227fb7e621b6521fe282956f021cd2337", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d504c227fb7e621b6521fe282956f021cd2337"}], "stats": {"total": 416, "additions": 236, "deletions": 180}, "files": [{"sha": "ba929443a225a51ec8361fab928bde750dc5c578", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -1,3 +1,64 @@\n+2007-07-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* expr.c (handled_component_p): Constify.\n+\t* fold-const.c (fit_double_type): Likewise.\n+\t* real.h (real_value_from_int_cst): Likewise.\n+\t* tree-flow-inline.h (gimple_in_ssa_p,\n+\tgimple_aliases_computed_p, gimple_addressable_vars,\n+\tgimple_call_clobbered_vars, gimple_referenced_vars,\n+\tgimple_global_var, gimple_nonlocal_all, gimple_var_anns,\n+\tend_htab_p, end_referenced_vars_p, var_ann, function_ann,\n+\tmay_aliases, end_readonly_imm_use_p, has_zero_uses,\n+\thas_single_use, single_imm_use, num_imm_uses, is_exec_stmt,\n+\tis_label_stmt, is_global_var, phi_ssa_name_p,\n+\tfactoring_name_p, is_call_clobbered, tree_common_ann,\n+\top_iter_done, end_imm_use_stmt_p, end_imm_use_on_stmt_p,\n+\tunmodifiable_var_p, array_ref_contains_indirect_ref,\n+\tref_contains_array_ref, lookup_subvars_for_var,\n+\tvar_can_have_subvars, overlap_subvar, gimple_ssa_operands,\n+\tgimple_mem_ref_stats): Likewise.\n+\t* tree-flow.h (tree_common_ann, var_ann, function_ann,\n+\tmay_aliases, is_exec_stmt, is_label_stmt,\n+\tref_contains_array_ref, array_ref_contains_indirect_ref,\n+\tvar_can_have_subvars, overlap_subvar, is_call_clobbered,\n+\tunmodifiable_var_p): Likewise.\n+\t* tree-gimple.c (is_gimple_min_invariant): Likewise.\n+\t* tree-gimple.h (is_gimple_min_invariant): Likewise. \n+\t* tree.c (type_hash_list, attribute_hash_list, tree_size,\n+\tcst_and_fits_in_hwi, real_value_from_int_cst,\n+\tbuild_real_from_int_cst, integer_zerop, integer_onep,\n+\tinteger_all_onesp, integer_pow2p, integer_nonzerop, tree_log2,\n+\ttree_floor_log2, real_zerop, real_onep, real_twop,\n+\treal_minus_onep, really_constant_p, purpose_member, chain_member,\n+\tlist_length, fields_length, int_size_in_bytes, bit_position,\n+\tint_bit_position, byte_position, int_byte_position, expr_align,\n+\tarray_type_nelts, tree_node_structure,\n+\ttype_contains_placeholder_1, iterative_hash_pointer,\n+\tis_attribute_with_length_p, is_attribute_p, check_qualified_type,\n+\ttree_map_base_eq, type_hash_list, type_hash_eq,\n+\tattribute_hash_list, type_num_arguments, tree_int_cst_equal,\n+\ttree_int_cst_lt, tree_int_cst_compare, host_integerp,\n+\ttree_low_cst, tree_int_cst_msb, tree_int_cst_sgn,\n+\tsimple_cst_list_equal, compare_tree_int, iterative_hash_expr,\n+\tint_fits_type_p, get_containing_scope, decl_function_context,\n+\tdecl_type_context, omp_clause_operand_check_failed,\n+\tinitializer_zerop, int_cst_value, num_ending_zeros): Likewise.\n+\t* tree.h (omp_clause_operand_check_failed, tree_size,\n+\tbuild_real_from_int_cst, array_type_nelts, purpose_member,\n+\ttree_int_cst_equal, tree_int_cst_lt, tree_int_cst_compare,\n+\thost_integerp, tree_low_cst, tree_int_cst_msb, tree_int_cst_sgn,\n+\tis_attribute_p, check_qualified_type, expr_align,\n+\tint_size_in_bytes, bit_position, int_bit_position, byte_position,\n+\tint_byte_position, list_length, fields_length, initializer_zerop,\n+\tinteger_zerop, integer_onep, integer_all_onesp, integer_pow2p,\n+\tinteger_nonzerop, cst_and_fits_in_hwi, num_ending_zeros,\n+\ttree_node_structure, handled_component_p, get_containing_scope,\n+\tdecl_function_context, decl_type_context, real_zerop,\n+\ttype_num_arguments, fit_double_type, really_constant_p,\n+\tint_fits_type_p, tree_log2, tree_floor_log2, iterative_hash_expr,\n+\tcompare_tree_int, chain_member, simple_cst_list_equal, real_onep,\n+\treal_twop, real_minus_onep, int_cst_value): Likewise.\n+\n 2007-07-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cfglayout.c (insn_scope, insn_line): Constify."}, {"sha": "485d1e9d66e19a0baa85915f671864873864e315", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -6061,7 +6061,7 @@ component_ref_field_offset (tree exp)\n /* Return 1 if T is an expression that get_inner_reference handles.  */\n \n int\n-handled_component_p (tree t)\n+handled_component_p (const_tree t)\n {\n   switch (TREE_CODE (t))\n     {"}, {"sha": "88e57d4a3cbab0a88d5b3d2fc93cc07c20c93b58", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -198,7 +198,7 @@ decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n \n int\n fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\t unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, tree type)\n+\t\t unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, const_tree type)\n {\n   unsigned HOST_WIDE_INT low0 = l1;\n   HOST_WIDE_INT high0 = h1;"}, {"sha": "79ad9b697f59450a17232b43551d15f6f8918593", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -391,7 +391,7 @@ extern REAL_VALUE_TYPE dconste;\n \n /* Function to return a real value (not a tree node)\n    from a given integer constant.  */\n-REAL_VALUE_TYPE real_value_from_int_cst (tree, tree);\n+REAL_VALUE_TYPE real_value_from_int_cst (const_tree, const_tree);\n \n /* Given a CONST_DOUBLE in FROM, store into TO the value it represents.  */\n #define REAL_VALUE_FROM_CONST_DOUBLE(to, from) \\"}, {"sha": "870dc94490fcb500822c5b6fefda647f45114ef9", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -30,14 +30,14 @@ Boston, MA 02110-1301, USA.  */\n    infrastructure is initialized.  Check for presence of the datastructures\n    at first place.  */\n static inline bool\n-gimple_in_ssa_p (struct function *fun)\n+gimple_in_ssa_p (const struct function *fun)\n {\n   return fun && fun->gimple_df && fun->gimple_df->in_ssa_p;\n }\n \n /* 'true' after aliases have been computed (see compute_may_aliases).  */\n static inline bool\n-gimple_aliases_computed_p (struct function *fun)\n+gimple_aliases_computed_p (const struct function *fun)\n {\n   gcc_assert (fun && fun->gimple_df);\n   return fun->gimple_df->aliases_computed_p;\n@@ -51,7 +51,7 @@ gimple_aliases_computed_p (struct function *fun)\n    call-clobbered variables are addressable (e.g., a local static\n    variable).  */\n static inline bitmap\n-gimple_addressable_vars (struct function *fun)\n+gimple_addressable_vars (const struct function *fun)\n {\n   gcc_assert (fun && fun->gimple_df);\n   return fun->gimple_df->addressable_vars;\n@@ -60,15 +60,15 @@ gimple_addressable_vars (struct function *fun)\n /* Call clobbered variables in the function.  If bit I is set, then\n    REFERENCED_VARS (I) is call-clobbered.  */\n static inline bitmap\n-gimple_call_clobbered_vars (struct function *fun)\n+gimple_call_clobbered_vars (const struct function *fun)\n {\n   gcc_assert (fun && fun->gimple_df);\n   return fun->gimple_df->call_clobbered_vars;\n }\n \n /* Array of all variables referenced in the function.  */\n static inline htab_t\n-gimple_referenced_vars (struct function *fun)\n+gimple_referenced_vars (const struct function *fun)\n {\n   if (!fun->gimple_df)\n     return NULL;\n@@ -77,7 +77,7 @@ gimple_referenced_vars (struct function *fun)\n \n /* Artificial variable used to model the effects of function calls.  */\n static inline tree\n-gimple_global_var (struct function *fun)\n+gimple_global_var (const struct function *fun)\n {\n   gcc_assert (fun && fun->gimple_df);\n   return fun->gimple_df->global_var;\n@@ -86,7 +86,7 @@ gimple_global_var (struct function *fun)\n /* Artificial variable used to model the effects of nonlocal\n    variables.  */\n static inline tree\n-gimple_nonlocal_all (struct function *fun)\n+gimple_nonlocal_all (const struct function *fun)\n {\n   gcc_assert (fun && fun->gimple_df);\n   return fun->gimple_df->nonlocal_all;\n@@ -95,7 +95,7 @@ gimple_nonlocal_all (struct function *fun)\n /* Hashtable of variables annotations.  Used for static variables only;\n    local variables have direct pointer in the tree node.  */\n static inline htab_t\n-gimple_var_anns (struct function *fun)\n+gimple_var_anns (const struct function *fun)\n {\n   return fun->gimple_df->var_anns;\n }\n@@ -124,7 +124,7 @@ first_htab_element (htab_iterator *hti, htab_t table)\n    or NULL if we have  reached the end.  */\n \n static inline bool\n-end_htab_p (htab_iterator *hti)\n+end_htab_p (const htab_iterator *hti)\n {\n   if (hti->slot >= hti->limit)\n     return true;\n@@ -165,7 +165,7 @@ first_referenced_var (referenced_var_iterator *iter)\n    iterating through.  */\n \n static inline bool\n-end_referenced_vars_p (referenced_var_iterator *iter)\n+end_referenced_vars_p (const referenced_var_iterator *iter)\n {\n   return end_htab_p (&iter->hti);\n }\n@@ -198,7 +198,7 @@ fill_referenced_var_vec (VEC (tree, heap) **vec)\n /* Return the variable annotation for T, which must be a _DECL node.\n    Return NULL if the variable annotation doesn't already exist.  */\n static inline var_ann_t\n-var_ann (tree t)\n+var_ann (const_tree t)\n {\n   gcc_assert (t);\n   gcc_assert (DECL_P (t));\n@@ -231,7 +231,7 @@ get_var_ann (tree var)\n /* Return the function annotation for T, which must be a FUNCTION_DECL node.\n    Return NULL if the function annotation doesn't already exist.  */\n static inline function_ann_t\n-function_ann (tree t)\n+function_ann (const_tree t)\n {\n   gcc_assert (t);\n   gcc_assert (TREE_CODE (t) == FUNCTION_DECL);\n@@ -306,7 +306,7 @@ bb_for_stmt (tree t)\n /* Return the may_aliases bitmap for variable VAR, or NULL if it has\n    no may aliases.  */\n static inline bitmap\n-may_aliases (tree var)\n+may_aliases (const_tree var)\n {\n   return MTAG_ALIASES (var);\n }\n@@ -497,7 +497,7 @@ relink_imm_use_stmt (ssa_use_operand_t *linknode, ssa_use_operand_t *old, tree s\n \n /* Return true is IMM has reached the end of the immediate use list.  */\n static inline bool\n-end_readonly_imm_use_p (imm_use_iterator *imm)\n+end_readonly_imm_use_p (const imm_use_iterator *imm)\n {\n   return (imm->imm_use == imm->end_p);\n }\n@@ -541,20 +541,18 @@ next_readonly_imm_use (imm_use_iterator *imm)\n \n /* Return true if VAR has no uses.  */\n static inline bool\n-has_zero_uses (tree var)\n+has_zero_uses (const_tree var)\n {\n-  ssa_use_operand_t *ptr;\n-  ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n   /* A single use means there is no items in the list.  */\n   return (ptr == ptr->next);\n }\n \n /* Return true if VAR has a single use.  */\n static inline bool\n-has_single_use (tree var)\n+has_single_use (const_tree var)\n {\n-  ssa_use_operand_t *ptr;\n-  ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n   /* A single use means there is one item in the list.  */\n   return (ptr != ptr->next && ptr == ptr->next->next);\n }\n@@ -563,11 +561,9 @@ has_single_use (tree var)\n /* If VAR has only a single immediate use, return true, and set USE_P and STMT\n    to the use pointer and stmt of occurrence.  */\n static inline bool\n-single_imm_use (tree var, use_operand_p *use_p, tree *stmt)\n+single_imm_use (const_tree var, use_operand_p *use_p, tree *stmt)\n {\n-  ssa_use_operand_t *ptr;\n-\n-  ptr = &(SSA_NAME_IMM_USE_NODE (var));\n+  const ssa_use_operand_t *const ptr = &(SSA_NAME_IMM_USE_NODE (var));\n   if (ptr != ptr->next && ptr == ptr->next->next)\n     {\n       *use_p = ptr->next;\n@@ -581,13 +577,12 @@ single_imm_use (tree var, use_operand_p *use_p, tree *stmt)\n \n /* Return the number of immediate uses of VAR.  */\n static inline unsigned int\n-num_imm_uses (tree var)\n+num_imm_uses (const_tree var)\n {\n-  ssa_use_operand_t *ptr, *start;\n-  unsigned int num;\n+  const ssa_use_operand_t *const start = &(SSA_NAME_IMM_USE_NODE (var));\n+  const ssa_use_operand_t *ptr;\n+  unsigned int num = 0;\n \n-  start = &(SSA_NAME_IMM_USE_NODE (var));\n-  num = 0;\n   for (ptr = start->next; ptr != start; ptr = ptr->next)\n      num++;\n \n@@ -707,7 +702,7 @@ set_is_used (tree var)\n \n /* Return true if T is an executable statement.  */\n static inline bool\n-is_exec_stmt (tree t)\n+is_exec_stmt (const_tree t)\n {\n   return (t && !IS_EMPTY_STMT (t) && t != error_mark_node);\n }\n@@ -716,7 +711,7 @@ is_exec_stmt (tree t)\n /* Return true if this stmt can be the target of a control transfer stmt such\n    as a goto.  */\n static inline bool\n-is_label_stmt (tree t)\n+is_label_stmt (const_tree t)\n {\n   if (t)\n     switch (TREE_CODE (t))\n@@ -734,7 +729,7 @@ is_label_stmt (tree t)\n /* Return true if T (assumed to be a DECL) is a global variable.  */\n \n static inline bool\n-is_global_var (tree t)\n+is_global_var (const_tree t)\n {\n   if (MTAG_P (t))\n     return (TREE_STATIC (t) || MTAG_GLOBAL (t));\n@@ -747,7 +742,7 @@ is_global_var (tree t)\n    slip in in the meantime.  */\n \n static inline bool\n-phi_ssa_name_p (tree t)\n+phi_ssa_name_p (const_tree t)\n {\n   if (TREE_CODE (t) == SSA_NAME)\n     return true;\n@@ -905,14 +900,14 @@ memory_partition (tree sym)\n    name for a memory partition.  */\n \n static inline bool\n-factoring_name_p (tree name)\n+factoring_name_p (const_tree name)\n {\n   return TREE_CODE (SSA_NAME_VAR (name)) == MEMORY_PARTITION_TAG;\n }\n \n /* Return true if VAR is a clobbered by function calls.  */\n static inline bool\n-is_call_clobbered (tree var)\n+is_call_clobbered (const_tree var)\n {\n   if (!MTAG_P (var))\n     return var_ann (var)->call_clobbered;\n@@ -946,7 +941,7 @@ clear_call_clobbered (tree var)\n /* Return the common annotation for T.  Return NULL if the annotation\n    doesn't already exist.  */\n static inline tree_ann_common_t\n-tree_common_ann (tree t)\n+tree_common_ann (const_tree t)\n {\n   /* Watch out static variables with unshared annotations.  */\n   if (DECL_P (t) && TREE_CODE (t) == VAR_DECL)\n@@ -970,7 +965,7 @@ get_tree_common_ann (tree t)\n \n /* Return true if PTR is finished iterating.  */\n static inline bool\n-op_iter_done (ssa_op_iter *ptr)\n+op_iter_done (const ssa_op_iter *ptr)\n {\n   return ptr->done;\n }\n@@ -1436,7 +1431,7 @@ op_iter_init_phidef (ssa_op_iter *ptr, tree phi, int flags)\n /* Return true is IMM has reached the end of the immediate use stmt list.  */\n \n static inline bool\n-end_imm_use_stmt_p (imm_use_iterator *imm)\n+end_imm_use_stmt_p (const imm_use_iterator *imm)\n {\n   return (imm->imm_use == imm->end_p);\n }\n@@ -1570,7 +1565,7 @@ first_imm_use_on_stmt (imm_use_iterator *imm)\n /*  Return TRUE if the last use on the stmt IMM refers to has been visited.  */\n \n static inline bool\n-end_imm_use_on_stmt_p (imm_use_iterator *imm)\n+end_imm_use_on_stmt_p (const imm_use_iterator *imm)\n {\n   return (imm->imm_use == &(imm->iter_node));\n }\n@@ -1593,7 +1588,7 @@ next_imm_use_on_stmt (imm_use_iterator *imm)\n /* Return true if VAR cannot be modified by the program.  */\n \n static inline bool\n-unmodifiable_var_p (tree var)\n+unmodifiable_var_p (const_tree var)\n {\n   if (TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n@@ -1607,7 +1602,7 @@ unmodifiable_var_p (tree var)\n /* Return true if REF, an ARRAY_REF, has an INDIRECT_REF somewhere in it.  */\n \n static inline bool\n-array_ref_contains_indirect_ref (tree ref)\n+array_ref_contains_indirect_ref (const_tree ref)\n {\n   gcc_assert (TREE_CODE (ref) == ARRAY_REF);\n \n@@ -1622,7 +1617,7 @@ array_ref_contains_indirect_ref (tree ref)\n    somewhere in it.  */\n \n static inline bool\n-ref_contains_array_ref (tree ref)\n+ref_contains_array_ref (const_tree ref)\n {\n   gcc_assert (handled_component_p (ref));\n \n@@ -1639,7 +1634,7 @@ ref_contains_array_ref (tree ref)\n    subvariables for it.  */\n \n static inline subvar_t *\n-lookup_subvars_for_var (tree var)\n+lookup_subvars_for_var (const_tree var)\n {\n   var_ann_t ann = var_ann (var);\n   gcc_assert (ann);\n@@ -1682,7 +1677,7 @@ get_subvar_at (tree var, unsigned HOST_WIDE_INT offset)\n    types which are not gimple registers can have subvars.  */\n \n static inline bool\n-var_can_have_subvars (tree v)\n+var_can_have_subvars (const_tree v)\n {\n   /* Volatile variables should never have subvars.  */\n   if (TREE_THIS_VOLATILE (v))\n@@ -1712,7 +1707,7 @@ var_can_have_subvars (tree v)\n \n static inline bool\n overlap_subvar (unsigned HOST_WIDE_INT offset, unsigned HOST_WIDE_INT size,\n-\t\ttree sv,  bool *exact)\n+\t\tconst_tree sv,  bool *exact)\n {\n   /* There are three possible cases of overlap.\n      1. We can have an exact overlap, like so:   \n@@ -1811,14 +1806,14 @@ get_value_handle (tree expr)\n \n /* Accessor to tree-ssa-operands.c caches.  */\n static inline struct ssa_operands *\n-gimple_ssa_operands (struct function *fun)\n+gimple_ssa_operands (const struct function *fun)\n {\n   return &fun->gimple_df->ssa_operands;\n }\n \n /* Map describing reference statistics for function FN.  */\n static inline struct mem_ref_stats_d *\n-gimple_mem_ref_stats (struct function *fn)\n+gimple_mem_ref_stats (const struct function *fn)\n {\n   return &fn->gimple_df->mem_ref_stats;\n }"}, {"sha": "176b385dd0a05bb6f4613e4a39cb37af49b598a0", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -519,11 +519,11 @@ typedef struct function_ann_d *function_ann_t;\n typedef struct stmt_ann_d *stmt_ann_t;\n typedef struct tree_ann_common_d *tree_ann_common_t;\n \n-static inline tree_ann_common_t tree_common_ann (tree);\n+static inline tree_ann_common_t tree_common_ann (const_tree);\n static inline tree_ann_common_t get_tree_common_ann (tree);\n-static inline var_ann_t var_ann (tree);\n+static inline var_ann_t var_ann (const_tree);\n static inline var_ann_t get_var_ann (tree);\n-static inline function_ann_t function_ann (tree);\n+static inline function_ann_t function_ann (const_tree);\n static inline function_ann_t get_function_ann (tree);\n static inline stmt_ann_t stmt_ann (tree);\n static inline bool has_stmt_ann (tree);\n@@ -534,11 +534,11 @@ extern void set_bb_for_stmt (tree, basic_block);\n static inline bool noreturn_call_p (tree);\n static inline void update_stmt (tree);\n static inline bool stmt_modified_p (tree);\n-static inline bitmap may_aliases (tree);\n+static inline bitmap may_aliases (const_tree);\n static inline int get_lineno (tree);\n static inline const char *get_filename (tree);\n-static inline bool is_exec_stmt (tree);\n-static inline bool is_label_stmt (tree);\n+static inline bool is_exec_stmt (const_tree);\n+static inline bool is_label_stmt (const_tree);\n static inline bitmap addresses_taken (tree);\n \n /*---------------------------------------------------------------------------\n@@ -840,14 +840,14 @@ extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *,\n \t\t\t\t   unsigned *);\n static inline subvar_t get_subvars_for_var (tree);\n static inline tree get_subvar_at (tree, unsigned HOST_WIDE_INT);\n-static inline bool ref_contains_array_ref (tree);\n-static inline bool array_ref_contains_indirect_ref (tree);\n+static inline bool ref_contains_array_ref (const_tree);\n+static inline bool array_ref_contains_indirect_ref (const_tree);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n \t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n-static inline bool var_can_have_subvars (tree);\n+static inline bool var_can_have_subvars (const_tree);\n static inline bool overlap_subvar (unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   tree, bool *);\n+\t\t\t\t   const_tree, bool *);\n extern tree create_tag_raw (enum tree_code, tree, const char *);\n extern void delete_mem_ref_stats (struct function *);\n extern void dump_mem_ref_stats (FILE *);\n@@ -1061,10 +1061,10 @@ enum escape_type\n };\n \n /* In tree-flow-inline.h  */\n-static inline bool is_call_clobbered (tree);\n+static inline bool is_call_clobbered (const_tree);\n static inline void mark_call_clobbered (tree, unsigned int);\n static inline void set_is_used (tree);\n-static inline bool unmodifiable_var_p (tree);\n+static inline bool unmodifiable_var_p (const_tree);\n \n /* In tree-eh.c  */\n extern void make_eh_edges (tree);"}, {"sha": "4f42c9c2a4a8867c3a1085d7cabafb92e7610a7d", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -170,7 +170,7 @@ is_gimple_addressable (tree t)\n    form of function invariant.  */\n \n bool\n-is_gimple_min_invariant (tree t)\n+is_gimple_min_invariant (const_tree t)\n {\n   switch (TREE_CODE (t))\n     {"}, {"sha": "4a8e3b1b4e25c91b00d63765f6f6d0aacef89700", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -64,7 +64,7 @@ extern bool is_gimple_addressable (tree);\n extern bool is_gimple_lvalue (tree);\n \n /* Returns true iff T is a GIMPLE restricted function invariant.  */\n-extern bool is_gimple_min_invariant (tree);\n+extern bool is_gimple_min_invariant (const_tree);\n /* Returns true iff T is a GIMPLE rvalue.  */\n extern bool is_gimple_val (tree);\n /* Returns true iff T is a GIMPLE asm statement input.  */"}, {"sha": "8a1b242924ca37e0df5d9e7bb6db591db4896b77", "filename": "gcc/tree.c", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -162,8 +162,8 @@ static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n static int type_hash_marked_p (const void *);\n-static unsigned int type_hash_list (tree, hashval_t);\n-static unsigned int attribute_hash_list (tree, hashval_t);\n+static unsigned int type_hash_list (const_tree, hashval_t);\n+static unsigned int attribute_hash_list (const_tree, hashval_t);\n \n tree global_trees[TI_MAX];\n tree integer_types[itk_none];\n@@ -439,9 +439,9 @@ tree_code_size (enum tree_code code)\n /* Compute the number of bytes occupied by NODE.  This routine only\n    looks at TREE_CODE, except for those nodes that have variable sizes.  */\n size_t\n-tree_size (tree node)\n+tree_size (const_tree node)\n {\n-  enum tree_code code = TREE_CODE (node);\n+  const enum tree_code code = TREE_CODE (node);\n   switch (code)\n     {\n     case PHI_NODE:\n@@ -981,7 +981,7 @@ build_low_bits_mask (tree type, unsigned bits)\n    HOST_WIDE_INT without loss of precision.  */\n \n bool\n-cst_and_fits_in_hwi (tree x)\n+cst_and_fits_in_hwi (const_tree x)\n {\n   if (TREE_CODE (x) != INTEGER_CST)\n     return false;\n@@ -1123,7 +1123,7 @@ build_real (tree type, REAL_VALUE_TYPE d)\n    and whose value is the integer value of the INTEGER_CST node I.  */\n \n REAL_VALUE_TYPE\n-real_value_from_int_cst (tree type, tree i)\n+real_value_from_int_cst (const_tree type, const_tree i)\n {\n   REAL_VALUE_TYPE d;\n \n@@ -1141,7 +1141,7 @@ real_value_from_int_cst (tree type, tree i)\n    representing the same value as a floating-point constant of type TYPE.  */\n \n tree\n-build_real_from_int_cst (tree type, tree i)\n+build_real_from_int_cst (tree type, const_tree i)\n {\n   tree v;\n   int overflow = TREE_OVERFLOW (i);\n@@ -1294,7 +1294,7 @@ make_tree_vec_stat (int len MEM_STAT_DECL)\n    of zero.  */\n \n int\n-integer_zerop (tree expr)\n+integer_zerop (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -1310,7 +1310,7 @@ integer_zerop (tree expr)\n    complex constant.  */\n \n int\n-integer_onep (tree expr)\n+integer_onep (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -1326,7 +1326,7 @@ integer_onep (tree expr)\n    it contains.  Likewise for the corresponding complex constant.  */\n \n int\n-integer_all_onesp (tree expr)\n+integer_all_onesp (const_tree expr)\n {\n   int prec;\n   int uns;\n@@ -1378,7 +1378,7 @@ integer_all_onesp (tree expr)\n    one bit on).  */\n \n int\n-integer_pow2p (tree expr)\n+integer_pow2p (const_tree expr)\n {\n   int prec;\n   HOST_WIDE_INT high, low;\n@@ -1423,7 +1423,7 @@ integer_pow2p (tree expr)\n    complex constant other than zero.  */\n \n int\n-integer_nonzerop (tree expr)\n+integer_nonzerop (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -1439,7 +1439,7 @@ integer_nonzerop (tree expr)\n    power of two.  */\n \n int\n-tree_log2 (tree expr)\n+tree_log2 (const_tree expr)\n {\n   int prec;\n   HOST_WIDE_INT high, low;\n@@ -1477,7 +1477,7 @@ tree_log2 (tree expr)\n    than or equal to EXPR.  */\n \n int\n-tree_floor_log2 (tree expr)\n+tree_floor_log2 (const_tree expr)\n {\n   int prec;\n   HOST_WIDE_INT high, low;\n@@ -1515,7 +1515,7 @@ tree_floor_log2 (tree expr)\n /* Return 1 if EXPR is the real constant zero.  */\n \n int\n-real_zerop (tree expr)\n+real_zerop (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -1529,7 +1529,7 @@ real_zerop (tree expr)\n /* Return 1 if EXPR is the real constant one in real or complex form.  */\n \n int\n-real_onep (tree expr)\n+real_onep (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -1543,7 +1543,7 @@ real_onep (tree expr)\n /* Return 1 if EXPR is the real constant two.  */\n \n int\n-real_twop (tree expr)\n+real_twop (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -1557,7 +1557,7 @@ real_twop (tree expr)\n /* Return 1 if EXPR is the real constant minus one.  */\n \n int\n-real_minus_onep (tree expr)\n+real_minus_onep (const_tree expr)\n {\n   STRIP_NOPS (expr);\n \n@@ -1571,7 +1571,7 @@ real_minus_onep (tree expr)\n /* Nonzero if EXP is a constant or a cast of a constant.  */\n \n int\n-really_constant_p (tree exp)\n+really_constant_p (const_tree exp)\n {\n   /* This is not quite the same as STRIP_NOPS.  It does more.  */\n   while (TREE_CODE (exp) == NOP_EXPR\n@@ -1600,7 +1600,7 @@ value_member (tree elem, tree list)\n    Return 0 if ELEM is not in LIST.  */\n \n tree\n-purpose_member (tree elem, tree list)\n+purpose_member (const_tree elem, tree list)\n {\n   while (list)\n     {\n@@ -1614,7 +1614,7 @@ purpose_member (tree elem, tree list)\n /* Return nonzero if ELEM is part of the chain CHAIN.  */\n \n int\n-chain_member (tree elem, tree chain)\n+chain_member (const_tree elem, const_tree chain)\n {\n   while (chain)\n     {\n@@ -1631,11 +1631,11 @@ chain_member (tree elem, tree chain)\n    This is the Lisp primitive `length'.  */\n \n int\n-list_length (tree t)\n+list_length (const_tree t)\n {\n-  tree p = t;\n+  const_tree p = t;\n #ifdef ENABLE_TREE_CHECKING\n-  tree q = t;\n+  const_tree q = t;\n #endif\n   int len = 0;\n \n@@ -1656,7 +1656,7 @@ list_length (tree t)\n /* Returns the number of FIELD_DECLs in TYPE.  */\n \n int\n-fields_length (tree type)\n+fields_length (const_tree type)\n {\n   tree t = TYPE_FIELDS (type);\n   int count = 0;\n@@ -1793,7 +1793,7 @@ size_in_bytes (tree type)\n    or return -1 if the size can vary or is larger than an integer.  */\n \n HOST_WIDE_INT\n-int_size_in_bytes (tree type)\n+int_size_in_bytes (const_tree type)\n {\n   tree t;\n \n@@ -1849,7 +1849,7 @@ max_int_size_in_bytes (tree type)\n    This is a tree of type bitsizetype.  */\n \n tree\n-bit_position (tree field)\n+bit_position (const_tree field)\n {\n   return bit_from_pos (DECL_FIELD_OFFSET (field),\n \t\t       DECL_FIELD_BIT_OFFSET (field));\n@@ -1860,7 +1860,7 @@ bit_position (tree field)\n    option of returning -1 like int_size_in_byte can.  */\n \n HOST_WIDE_INT\n-int_bit_position (tree field)\n+int_bit_position (const_tree field)\n {\n   return tree_low_cst (bit_position (field), 0);\n }\n@@ -1869,7 +1869,7 @@ int_bit_position (tree field)\n    This is a tree of type sizetype.  */\n \n tree\n-byte_position (tree field)\n+byte_position (const_tree field)\n {\n   return byte_from_pos (DECL_FIELD_OFFSET (field),\n \t\t\tDECL_FIELD_BIT_OFFSET (field));\n@@ -1880,15 +1880,15 @@ byte_position (tree field)\n    option of returning -1 like int_size_in_byte can.  */\n \n HOST_WIDE_INT\n-int_byte_position (tree field)\n+int_byte_position (const_tree field)\n {\n   return tree_low_cst (byte_position (field), 0);\n }\n \f\n /* Return the strictest alignment, in bits, that T is known to have.  */\n \n unsigned int\n-expr_align (tree t)\n+expr_align (const_tree t)\n {\n   unsigned int align0, align1;\n \n@@ -1938,7 +1938,7 @@ expr_align (tree t)\n    ARRAY_TYPE) minus one. This counts only elements of the top array.  */\n \n tree\n-array_type_nelts (tree type)\n+array_type_nelts (const_tree type)\n {\n   tree index_type, min, max;\n \n@@ -2130,9 +2130,9 @@ skip_simple_arithmetic (tree expr)\n /* Return which tree structure is used by T.  */\n \n enum tree_node_structure_enum\n-tree_node_structure (tree t)\n+tree_node_structure (const_tree t)\n {\n-  enum tree_code code = TREE_CODE (t);\n+  const enum tree_code code = TREE_CODE (t);\n \n   switch (TREE_CODE_CLASS (code))\n     {      \n@@ -2297,7 +2297,7 @@ contains_placeholder_p (tree exp)\n    (for QUAL_UNION_TYPE) and field positions.  */\n \n static bool\n-type_contains_placeholder_1 (tree type)\n+type_contains_placeholder_1 (const_tree type)\n {\n   /* If the size contains a placeholder or the parent type (component type in\n      the case of arrays) type involves a placeholder, this type does.  */\n@@ -3585,7 +3585,7 @@ iterative_hash_hashval_t (hashval_t val, hashval_t val2)\n \n /* Produce good hash value combining PTR and VAL2.  */\n static inline hashval_t\n-iterative_hash_pointer (void *ptr, hashval_t val2)\n+iterative_hash_pointer (const void *ptr, hashval_t val2)\n {\n   if (sizeof (ptr) == sizeof (hashval_t))\n     return iterative_hash_hashval_t ((size_t) ptr, val2);\n@@ -3723,7 +3723,7 @@ build_type_attribute_variant (tree ttype, tree attribute)\n    their canonicalized form.  */\n \n static int\n-is_attribute_with_length_p (const char *attr, int attr_len, tree ident)\n+is_attribute_with_length_p (const char *attr, int attr_len, const_tree ident)\n {\n   int ident_len;\n   const char *p;\n@@ -3766,7 +3766,7 @@ is_attribute_with_length_p (const char *attr, int attr_len, tree ident)\n    We try both `text' and `__text__', ATTR may be either one.  */\n \n int\n-is_attribute_p (const char *attr, tree ident)\n+is_attribute_p (const char *attr, const_tree ident)\n {\n   return is_attribute_with_length_p (attr, strlen (attr), ident);\n }\n@@ -4117,7 +4117,7 @@ set_type_quals (tree type, int type_quals)\n /* Returns true iff cand is equivalent to base with type_quals.  */\n \n bool\n-check_qualified_type (tree cand, tree base, int type_quals)\n+check_qualified_type (const_tree cand, const_tree base, int type_quals)\n {\n   return (TYPE_QUALS (cand) == type_quals\n \t  && TYPE_NAME (cand) == TYPE_NAME (base)\n@@ -4244,7 +4244,7 @@ build_variant_type_copy (tree type)\n int\n tree_map_base_eq (const void *va, const void *vb)\n {\n-  const struct tree_map_base  *a = va, *b = vb;\n+  const struct tree_map_base  *const a = va, *const b = vb;\n   return (a->from == b->from);\n }\n \n@@ -4487,10 +4487,10 @@ decl_value_expr_insert (tree from, tree to)\n    with types in the TREE_VALUE slots), by adding the hash codes\n    of the individual types.  */\n \n-unsigned int\n-type_hash_list (tree list, hashval_t hashcode)\n+static unsigned int\n+type_hash_list (const_tree list, hashval_t hashcode)\n {\n-  tree tail;\n+  const_tree tail;\n \n   for (tail = list; tail; tail = TREE_CHAIN (tail))\n     if (TREE_VALUE (tail) != error_mark_node)\n@@ -4507,7 +4507,7 @@ type_hash_list (tree list, hashval_t hashcode)\n static int\n type_hash_eq (const void *va, const void *vb)\n {\n-  const struct type_hash *a = va, *b = vb;\n+  const struct type_hash *const a = va, *const b = vb;\n \n   /* First test the things that are the same for all types.  */\n   if (a->hash != b->hash\n@@ -4704,10 +4704,10 @@ print_type_hash_statistics (void)\n    with names in the TREE_PURPOSE slots and args in the TREE_VALUE slots),\n    by adding the hash codes of the individual attributes.  */\n \n-unsigned int\n-attribute_hash_list (tree list, hashval_t hashcode)\n+static unsigned int\n+attribute_hash_list (const_tree list, hashval_t hashcode)\n {\n-  tree tail;\n+  const_tree tail;\n \n   for (tail = list; tail; tail = TREE_CHAIN (tail))\n     /* ??? Do we want to add in TREE_VALUE too? */\n@@ -4808,7 +4808,7 @@ type_list_equal (tree l1, tree l2)\n    then this function counts only the ordinary arguments.  */\n \n int\n-type_num_arguments (tree type)\n+type_num_arguments (const_tree type)\n {\n   int i = 0;\n   tree t;\n@@ -4828,7 +4828,7 @@ type_num_arguments (tree type)\n    represent the same constant value.  */\n \n int\n-tree_int_cst_equal (tree t1, tree t2)\n+tree_int_cst_equal (const_tree t1, const_tree t2)\n {\n   if (t1 == t2)\n     return 1;\n@@ -4849,7 +4849,7 @@ tree_int_cst_equal (tree t1, tree t2)\n    The precise way of comparison depends on their data type.  */\n \n int\n-tree_int_cst_lt (tree t1, tree t2)\n+tree_int_cst_lt (const_tree t1, const_tree t2)\n {\n   if (t1 == t2)\n     return 0;\n@@ -4876,7 +4876,7 @@ tree_int_cst_lt (tree t1, tree t2)\n /* Returns -1 if T1 < T2, 0 if T1 == T2, and 1 if T1 > T2.  */\n \n int\n-tree_int_cst_compare (tree t1, tree t2)\n+tree_int_cst_compare (const_tree t1, const_tree t2)\n {\n   if (tree_int_cst_lt (t1, t2))\n     return -1;\n@@ -4892,7 +4892,7 @@ tree_int_cst_compare (tree t1, tree t2)\n    be represented in a single unsigned HOST_WIDE_INT.  */\n \n int\n-host_integerp (tree t, int pos)\n+host_integerp (const_tree t, int pos)\n {\n   return (TREE_CODE (t) == INTEGER_CST\n \t  && ((TREE_INT_CST_HIGH (t) == 0\n@@ -4908,7 +4908,7 @@ host_integerp (tree t, int pos)\n    be non-negative.  We must be able to satisfy the above conditions.  */\n \n HOST_WIDE_INT\n-tree_low_cst (tree t, int pos)\n+tree_low_cst (const_tree t, int pos)\n {\n   gcc_assert (host_integerp (t, pos));\n   return TREE_INT_CST_LOW (t);\n@@ -4917,7 +4917,7 @@ tree_low_cst (tree t, int pos)\n /* Return the most significant bit of the integer constant T.  */\n \n int\n-tree_int_cst_msb (tree t)\n+tree_int_cst_msb (const_tree t)\n {\n   int prec;\n   HOST_WIDE_INT h;\n@@ -4936,7 +4936,7 @@ tree_int_cst_msb (tree t)\n    Note that -1 will never be returned if T's type is unsigned.  */\n \n int\n-tree_int_cst_sgn (tree t)\n+tree_int_cst_sgn (const_tree t)\n {\n   if (TREE_INT_CST_LOW (t) == 0 && TREE_INT_CST_HIGH (t) == 0)\n     return 0;\n@@ -4952,7 +4952,7 @@ tree_int_cst_sgn (tree t)\n    are known to be equal; otherwise return 0.  */\n \n int\n-simple_cst_list_equal (tree l1, tree l2)\n+simple_cst_list_equal (const_tree l1, const_tree l2)\n {\n   while (l1 != NULL_TREE && l2 != NULL_TREE)\n     {\n@@ -5137,7 +5137,7 @@ simple_cst_equal (tree t1, tree t2)\n    than U, respectively.  */\n \n int\n-compare_tree_int (tree t, unsigned HOST_WIDE_INT u)\n+compare_tree_int (const_tree t, unsigned HOST_WIDE_INT u)\n {\n   if (tree_int_cst_sgn (t) < 0)\n     return -1;\n@@ -5211,7 +5211,7 @@ commutative_tree_code (enum tree_code code)\n    would compare equal using operand_equal_p.  */\n \n hashval_t\n-iterative_hash_expr (tree t, hashval_t val)\n+iterative_hash_expr (const_tree t, hashval_t val)\n {\n   int i;\n   enum tree_code code;\n@@ -6193,7 +6193,7 @@ get_narrower (tree op, int *unsignedp_ptr)\n    for type TYPE (an INTEGER_TYPE).  */\n \n int\n-int_fits_type_p (tree c, tree type)\n+int_fits_type_p (const_tree c, const_tree type)\n {\n   tree type_low_bound = TYPE_MIN_VALUE (type);\n   tree type_high_bound = TYPE_MAX_VALUE (type);\n@@ -6428,7 +6428,7 @@ variably_modified_type_p (tree type, tree fn)\n    NULL_TREE if there is no containing scope.  */\n \n tree\n-get_containing_scope (tree t)\n+get_containing_scope (const_tree t)\n {\n   return (TYPE_P (t) ? TYPE_CONTEXT (t) : DECL_CONTEXT (t));\n }\n@@ -6437,7 +6437,7 @@ get_containing_scope (tree t)\n    a FUNCTION_DECL, or zero if none.  */\n \n tree\n-decl_function_context (tree decl)\n+decl_function_context (const_tree decl)\n {\n   tree context;\n \n@@ -6473,7 +6473,7 @@ decl_function_context (tree decl)\n    TYPE_DECLs and FUNCTION_DECLs are transparent to this function.  */\n \n tree\n-decl_type_context (tree decl)\n+decl_type_context (const_tree decl)\n {\n   tree context = DECL_CONTEXT (decl);\n \n@@ -6959,7 +6959,7 @@ tree_operand_check_failed (int idx, tree exp, const char *file,\n    operands of an OMP_CLAUSE node.  */\n \n void\n-omp_clause_operand_check_failed (int idx, tree t, const char *file,\n+omp_clause_operand_check_failed (int idx, const_tree t, const char *file,\n \t\t\t         int line, const char *function)\n {\n   internal_error\n@@ -7500,7 +7500,7 @@ build_resx (int region_number)\n /* Given an initializer INIT, return TRUE if INIT is zero or some\n    aggregate of zeros.  Otherwise return FALSE.  */\n bool\n-initializer_zerop (tree init)\n+initializer_zerop (const_tree init)\n {\n   tree elt;\n \n@@ -7845,7 +7845,7 @@ find_compatible_field (tree record, tree orig_field)\n /* Return value of a constant X.  */\n \n HOST_WIDE_INT\n-int_cst_value (tree x)\n+int_cst_value (const_tree x)\n {\n   unsigned bits = TYPE_PRECISION (TREE_TYPE (x));\n   unsigned HOST_WIDE_INT val = TREE_INT_CST_LOW (x);\n@@ -8024,7 +8024,7 @@ operand_equal_for_phi_arg_p (tree arg0, tree arg1)\n    ??? Use ffs if available?  */\n \n tree\n-num_ending_zeros (tree x)\n+num_ending_zeros (const_tree x)\n {\n   unsigned HOST_WIDE_INT fr, nfr;\n   unsigned num, abits;"}, {"sha": "c2dbfed3f9dbe1149b06e4db7c42fe600c2179fd", "filename": "gcc/tree.h", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9566a759384066b68943dd736bcdf63fb04e4da4/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9566a759384066b68943dd736bcdf63fb04e4da4", "patch": "@@ -887,7 +887,7 @@ extern void tree_operand_check_failed (int, tree,\n extern void omp_clause_check_failed (const tree, const char *, int,\n \t\t\t\t     const char *, enum omp_clause_code)\n     ATTRIBUTE_NORETURN;\n-extern void omp_clause_operand_check_failed (int, tree, const char *,\n+extern void omp_clause_operand_check_failed (int, const_tree, const char *,\n \t\t\t\t             int, const char *)\n     ATTRIBUTE_NORETURN;\n extern void omp_clause_range_check_failed (const tree, const char *, int,\n@@ -3642,7 +3642,7 @@ extern bool decl_assembler_name_equal (tree decl, tree asmname);\n /* Compute the number of bytes occupied by 'node'.  This routine only\n    looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */\n \n-extern size_t tree_size (tree);\n+extern size_t tree_size (const_tree);\n \n /* Compute the number of bytes occupied by a tree with code CODE.  This\n    function cannot be used for TREE_VEC or PHI_NODE codes, which are of\n@@ -3759,7 +3759,7 @@ extern tree build_vector_from_ctor (tree, VEC(constructor_elt,gc) *);\n extern tree build_constructor (tree, VEC(constructor_elt,gc) *);\n extern tree build_constructor_single (tree, tree, tree);\n extern tree build_constructor_from_list (tree, tree);\n-extern tree build_real_from_int_cst (tree, tree);\n+extern tree build_real_from_int_cst (tree, const_tree);\n extern tree build_complex (tree, tree, tree);\n extern tree build_one_cst (tree);\n extern tree build_string (int, const char *);\n@@ -3811,22 +3811,22 @@ extern tree build_method_type (tree, tree);\n extern tree build_offset_type (tree, tree);\n extern tree build_complex_type (tree);\n extern tree build_resx (int);\n-extern tree array_type_nelts (tree);\n+extern tree array_type_nelts (const_tree);\n extern bool in_array_bounds_p (tree);\n extern bool range_in_array_bounds_p (tree);\n \n extern tree value_member (tree, tree);\n-extern tree purpose_member (tree, tree);\n+extern tree purpose_member (const_tree, tree);\n \n extern int attribute_list_equal (tree, tree);\n extern int attribute_list_contained (tree, tree);\n-extern int tree_int_cst_equal (tree, tree);\n-extern int tree_int_cst_lt (tree, tree);\n-extern int tree_int_cst_compare (tree, tree);\n-extern int host_integerp (tree, int);\n-extern HOST_WIDE_INT tree_low_cst (tree, int);\n-extern int tree_int_cst_msb (tree);\n-extern int tree_int_cst_sgn (tree);\n+extern int tree_int_cst_equal (const_tree, const_tree);\n+extern int tree_int_cst_lt (const_tree, const_tree);\n+extern int tree_int_cst_compare (const_tree, const_tree);\n+extern int host_integerp (const_tree, int);\n+extern HOST_WIDE_INT tree_low_cst (const_tree, int);\n+extern int tree_int_cst_msb (const_tree);\n+extern int tree_int_cst_sgn (const_tree);\n extern int tree_int_cst_sign_bit (tree);\n extern bool tree_expr_nonnegative_p (tree);\n extern bool tree_expr_nonnegative_warnv_p (tree, bool *);\n@@ -3926,7 +3926,7 @@ extern tree merge_type_attributes (tree, tree);\n /* Given a tree node and a string, return nonzero if the tree node is\n    a valid attribute name for the string.  */\n \n-extern int is_attribute_p (const char *, tree);\n+extern int is_attribute_p (const char *, const_tree);\n \n /* Given an attribute name and a list of attributes, return the list element\n    of the attribute or NULL_TREE if not found.  */\n@@ -3954,7 +3954,7 @@ extern tree handle_dll_attribute (tree *, tree, tree, int, bool *);\n /* Check whether CAND is suitable to be returned from get_qualified_type\n    (BASE, TYPE_QUALS).  */\n \n-extern bool check_qualified_type (tree, tree, int);\n+extern bool check_qualified_type (const_tree, const_tree, int);\n \n /* Return a version of the TYPE, qualified as indicated by the\n    TYPE_QUALS, if one exists.  If no qualified version exists yet,\n@@ -4076,17 +4076,17 @@ extern enum machine_mode mode_for_size_tree (tree, enum mode_class, int);\n extern tree non_lvalue (tree);\n \n extern tree convert (tree, tree);\n-extern unsigned int expr_align (tree);\n+extern unsigned int expr_align (const_tree);\n extern tree expr_first (tree);\n extern tree expr_last (tree);\n extern tree expr_only (tree);\n extern tree size_in_bytes (tree);\n-extern HOST_WIDE_INT int_size_in_bytes (tree);\n+extern HOST_WIDE_INT int_size_in_bytes (const_tree);\n extern HOST_WIDE_INT max_int_size_in_bytes (tree);\n-extern tree bit_position (tree);\n-extern HOST_WIDE_INT int_bit_position (tree);\n-extern tree byte_position (tree);\n-extern HOST_WIDE_INT int_byte_position (tree);\n+extern tree bit_position (const_tree);\n+extern HOST_WIDE_INT int_bit_position (const_tree);\n+extern tree byte_position (const_tree);\n+extern HOST_WIDE_INT int_byte_position (const_tree);\n \n /* Define data structures, macros, and functions for handling sizes\n    and the various types used to represent sizes.  */\n@@ -4155,16 +4155,16 @@ extern tree nreverse (tree);\n /* Returns the length of a chain of nodes\n    (number of chain pointers to follow before reaching a null pointer).  */\n \n-extern int list_length (tree);\n+extern int list_length (const_tree);\n \n /* Returns the number of FIELD_DECLs in a type.  */\n \n-extern int fields_length (tree);\n+extern int fields_length (const_tree);\n \n /* Given an initializer INIT, return TRUE if INIT is zero or some\n    aggregate of zeros.  Otherwise return FALSE.  */\n \n-extern bool initializer_zerop (tree);\n+extern bool initializer_zerop (const_tree);\n \n /* Examine CTOR to discover:\n    * how many scalar fields are set to nonzero values,\n@@ -4184,29 +4184,29 @@ extern HOST_WIDE_INT count_type_elements (tree, bool);\n \n /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0.  */\n \n-extern int integer_zerop (tree);\n+extern int integer_zerop (const_tree);\n \n /* integer_onep (tree x) is nonzero if X is an integer constant of value 1.  */\n \n-extern int integer_onep (tree);\n+extern int integer_onep (const_tree);\n \n /* integer_all_onesp (tree x) is nonzero if X is an integer constant\n    all of whose significant bits are 1.  */\n \n-extern int integer_all_onesp (tree);\n+extern int integer_all_onesp (const_tree);\n \n /* integer_pow2p (tree x) is nonzero is X is an integer constant with\n    exactly one bit 1.  */\n \n-extern int integer_pow2p (tree);\n+extern int integer_pow2p (const_tree);\n \n /* integer_nonzerop (tree x) is nonzero if X is an integer constant\n    with a nonzero value.  */\n \n-extern int integer_nonzerop (tree);\n+extern int integer_nonzerop (const_tree);\n \n-extern bool cst_and_fits_in_hwi (tree);\n-extern tree num_ending_zeros (tree);\n+extern bool cst_and_fits_in_hwi (const_tree);\n+extern tree num_ending_zeros (const_tree);\n \n /* staticp (tree x) is nonzero if X is a reference to data allocated\n    at a fixed address in memory.  Returns the outermost data.  */\n@@ -4226,7 +4226,7 @@ extern tree skip_simple_arithmetic (tree);\n \n /* Return which tree structure is used by T.  */\n \n-enum tree_node_structure_enum tree_node_structure (tree);\n+enum tree_node_structure_enum tree_node_structure (const_tree);\n \n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.\n@@ -4323,7 +4323,7 @@ extern bool contains_packed_reference (tree exp);\n \n /* Return 1 if T is an expression that get_inner_reference handles.  */\n \n-extern int handled_component_p (tree);\n+extern int handled_component_p (const_tree);\n \n /* Return a tree of sizetype representing the size, in bytes, of the element\n    of EXP, an ARRAY_REF.  */\n@@ -4348,18 +4348,18 @@ extern tree component_ref_field_offset (tree);\n /* Given a DECL or TYPE, return the scope in which it was declared, or\n    NUL_TREE if there is no containing scope.  */\n \n-extern tree get_containing_scope (tree);\n+extern tree get_containing_scope (const_tree);\n \n /* Return the FUNCTION_DECL which provides this _DECL with its context,\n    or zero if none.  */\n-extern tree decl_function_context (tree);\n+extern tree decl_function_context (const_tree);\n \n /* Return the RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE which provides\n    this _DECL with its context, or zero if none.  */\n-extern tree decl_type_context (tree);\n+extern tree decl_type_context (const_tree);\n \n /* Return 1 if EXPR is the real constant zero.  */\n-extern int real_zerop (tree);\n+extern int real_zerop (const_tree);\n \f\n /* Declare commonly used variables for tree structure.  */\n \n@@ -4381,7 +4381,7 @@ extern void clean_symbol_name (char *);\n extern tree get_file_function_name (const char *);\n extern tree get_callee_fndecl (tree);\n extern void change_decl_assembler_name (tree, tree);\n-extern int type_num_arguments (tree);\n+extern int type_num_arguments (const_tree);\n extern bool associative_tree_code (enum tree_code);\n extern bool commutative_tree_code (enum tree_code);\n extern tree upper_bound_in_type (tree, tree);\n@@ -4454,7 +4454,7 @@ extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t   int, bool);\n \n extern int fit_double_type (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, tree);\n+\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, const_tree);\n extern int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n@@ -4563,20 +4563,20 @@ extern int alias_sets_must_conflict_p (HOST_WIDE_INT, HOST_WIDE_INT);\n extern int objects_must_conflict_p (tree, tree);\n \n /* In tree.c */\n-extern int really_constant_p (tree);\n-extern int int_fits_type_p (tree, tree);\n+extern int really_constant_p (const_tree);\n+extern int int_fits_type_p (const_tree, const_tree);\n extern void get_type_static_bounds (tree, mpz_t, mpz_t);\n extern bool variably_modified_type_p (tree, tree);\n-extern int tree_log2 (tree);\n-extern int tree_floor_log2 (tree);\n+extern int tree_log2 (const_tree);\n+extern int tree_floor_log2 (const_tree);\n extern int simple_cst_equal (tree, tree);\n-extern hashval_t iterative_hash_expr (tree, hashval_t);\n-extern int compare_tree_int (tree, unsigned HOST_WIDE_INT);\n+extern hashval_t iterative_hash_expr (const_tree, hashval_t);\n+extern int compare_tree_int (const_tree, unsigned HOST_WIDE_INT);\n extern int type_list_equal (tree, tree);\n-extern int chain_member (tree, tree);\n+extern int chain_member (const_tree, const_tree);\n extern tree type_hash_lookup (unsigned int, tree);\n extern void type_hash_add (unsigned int, tree);\n-extern int simple_cst_list_equal (tree, tree);\n+extern int simple_cst_list_equal (const_tree, const_tree);\n extern void dump_tree_statistics (void);\n extern void expand_function_end (void);\n extern void expand_function_start (tree);\n@@ -4586,16 +4586,16 @@ extern void recompute_tree_invariant_for_addr_expr (tree);\n extern bool needs_to_live_in_memory (tree);\n extern tree reconstruct_complex_type (tree, tree);\n \n-extern int real_onep (tree);\n-extern int real_twop (tree);\n-extern int real_minus_onep (tree);\n+extern int real_onep (const_tree);\n+extern int real_twop (const_tree);\n+extern int real_minus_onep (const_tree);\n extern void init_ttree (void);\n extern void build_common_tree_nodes (bool, bool);\n extern void build_common_tree_nodes_2 (int);\n extern void build_common_builtin_nodes (void);\n extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n-extern HOST_WIDE_INT int_cst_value (tree);\n+extern HOST_WIDE_INT int_cst_value (const_tree);\n extern tree build_addr (tree, tree);\n \n extern bool fields_compatible_p (tree, tree);"}]}