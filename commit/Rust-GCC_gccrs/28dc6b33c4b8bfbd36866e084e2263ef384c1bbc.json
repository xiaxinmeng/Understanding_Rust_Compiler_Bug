{"sha": "28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhkYzZiMzNjNGI4YmZiZDM2ODY2ZTA4NGUyMjYzZWYzODRjMWJiYw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-08-24T16:16:16Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2007-08-24T16:16:16Z"}, "message": "re PR libfortran/32972 (performance of pack/unpack)\n\n2007-08-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/32972\n\t* iresolve.c:  Don't convert array masks.\n\n2007-08-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/32972\n\t* libgfortran.h:  Remove GFOR_POINTER_L8_TO_L4 macro.\n\tAdd GFOR_POINTER_TO_L1 macro.\n\t* m4/iforeach.m4(`m'name`'rtype_qual`_'atype_code):\n\tChange argument 'mask' to gfc_array_l1.  Adjust prototype.\n\tChange mask pointer to GFC_LOGICAL_1.  Multiply strides\n\tby kind of mask\n\t* m4/ifunction.m4:  Likewise.\n\t* intrinsics/pack_generic.c(pack_internal):  Likewise.\n\t* intrinsics/unpack_generic.c(unpack_internal):  Likewise.\n\t* m4/matmull.m4:  Switch to GFC_LOGICAL_1.  Multiply strides by\n\tkind of logical arguments a and b.\n\t* generated/matmul_l16.c: Regenerated.\n\t* generated/matmul_l4.c: Regenerated.\n\t* generated/matmul_l8.c: Regenerated.\n\t* generated/maxloc0_16_i1.c: Regenerated.\n\t* generated/maxloc0_16_i16.c: Regenerated.\n\t* generated/maxloc0_16_i2.c: Regenerated.\n\t* generated/maxloc0_16_i4.c: Regenerated.\n\t* generated/maxloc0_16_i8.c: Regenerated.\n\t* generated/maxloc0_16_r10.c: Regenerated.\n\t* generated/maxloc0_16_r16.c: Regenerated.\n\t* generated/maxloc0_16_r4.c: Regenerated.\n\t* generated/maxloc0_16_r8.c: Regenerated.\n\t* generated/maxloc0_4_i1.c: Regenerated.\n\t* generated/maxloc0_4_i16.c: Regenerated.\n\t* generated/maxloc0_4_i2.c: Regenerated.\n\t* generated/maxloc0_4_i4.c: Regenerated.\n\t* generated/maxloc0_4_i8.c: Regenerated.\n\t* generated/maxloc0_4_r10.c: Regenerated.\n\t* generated/maxloc0_4_r16.c: Regenerated.\n\t* generated/maxloc0_4_r4.c: Regenerated.\n\t* generated/maxloc0_4_r8.c: Regenerated.\n\t* generated/maxloc0_8_i1.c: Regenerated.\n\t* generated/maxloc0_8_i16.c: Regenerated.\n\t* generated/maxloc0_8_i2.c: Regenerated.\n\t* generated/maxloc0_8_i4.c: Regenerated.\n\t* generated/maxloc0_8_i8.c: Regenerated.\n\t* generated/maxloc0_8_r10.c: Regenerated.\n\t* generated/maxloc0_8_r16.c: Regenerated.\n\t* generated/maxloc0_8_r4.c: Regenerated.\n\t* generated/maxloc0_8_r8.c: Regenerated.\n\t* generated/maxloc1_16_i1.c: Regenerated.\n\t* generated/maxloc1_16_i16.c: Regenerated.\n\t* generated/maxloc1_16_i2.c: Regenerated.\n\t* generated/maxloc1_16_i4.c: Regenerated.\n\t* generated/maxloc1_16_i8.c: Regenerated.\n\t* generated/maxloc1_16_r10.c: Regenerated.\n\t* generated/maxloc1_16_r16.c: Regenerated.\n\t* generated/maxloc1_16_r4.c: Regenerated.\n\t* generated/maxloc1_16_r8.c: Regenerated.\n\t* generated/maxloc1_4_i1.c: Regenerated.\n\t* generated/maxloc1_4_i16.c: Regenerated.\n\t* generated/maxloc1_4_i2.c: Regenerated.\n\t* generated/maxloc1_4_i4.c: Regenerated.\n\t* generated/maxloc1_4_i8.c: Regenerated.\n\t* generated/maxloc1_4_r10.c: Regenerated.\n\t* generated/maxloc1_4_r16.c: Regenerated.\n\t* generated/maxloc1_4_r4.c: Regenerated.\n\t* generated/maxloc1_4_r8.c: Regenerated.\n\t* generated/maxloc1_8_i1.c: Regenerated.\n\t* generated/maxloc1_8_i16.c: Regenerated.\n\t* generated/maxloc1_8_i2.c: Regenerated.\n\t* generated/maxloc1_8_i4.c: Regenerated.\n\t* generated/maxloc1_8_i8.c: Regenerated.\n\t* generated/maxloc1_8_r10.c: Regenerated.\n\t* generated/maxloc1_8_r16.c: Regenerated.\n\t* generated/maxloc1_8_r4.c: Regenerated.\n\t* generated/maxloc1_8_r8.c: Regenerated.\n\t* generated/maxval_i1.c: Regenerated.\n\t* generated/maxval_i16.c: Regenerated.\n\t* generated/maxval_i2.c: Regenerated.\n\t* generated/maxval_i4.c: Regenerated.\n\t* generated/maxval_i8.c: Regenerated.\n\t* generated/maxval_r10.c: Regenerated.\n\t* generated/maxval_r16.c: Regenerated.\n\t* generated/maxval_r4.c: Regenerated.\n\t* generated/maxval_r8.c: Regenerated.\n\t* generated/minloc0_16_i1.c: Regenerated.\n\t* generated/minloc0_16_i16.c: Regenerated.\n\t* generated/minloc0_16_i2.c: Regenerated.\n\t* generated/minloc0_16_i4.c: Regenerated.\n\t* generated/minloc0_16_i8.c: Regenerated.\n\t* generated/minloc0_16_r10.c: Regenerated.\n\t* generated/minloc0_16_r16.c: Regenerated.\n\t* generated/minloc0_16_r4.c: Regenerated.\n\t* generated/minloc0_16_r8.c: Regenerated.\n\t* generated/minloc0_4_i1.c: Regenerated.\n\t* generated/minloc0_4_i16.c: Regenerated.\n\t* generated/minloc0_4_i2.c: Regenerated.\n\t* generated/minloc0_4_i4.c: Regenerated.\n\t* generated/minloc0_4_i8.c: Regenerated.\n\t* generated/minloc0_4_r10.c: Regenerated.\n\t* generated/minloc0_4_r16.c: Regenerated.\n\t* generated/minloc0_4_r4.c: Regenerated.\n\t* generated/minloc0_4_r8.c: Regenerated.\n\t* generated/minloc0_8_i1.c: Regenerated.\n\t* generated/minloc0_8_i16.c: Regenerated.\n\t* generated/minloc0_8_i2.c: Regenerated.\n\t* generated/minloc0_8_i4.c: Regenerated.\n\t* generated/minloc0_8_i8.c: Regenerated.\n\t* generated/minloc0_8_r10.c: Regenerated.\n\t* generated/minloc0_8_r16.c: Regenerated.\n\t* generated/minloc0_8_r4.c: Regenerated.\n\t* generated/minloc0_8_r8.c: Regenerated.\n\t* generated/minloc1_16_i1.c: Regenerated.\n\t* generated/minloc1_16_i16.c: Regenerated.\n\t* generated/minloc1_16_i2.c: Regenerated.\n\t* generated/minloc1_16_i4.c: Regenerated.\n\t* generated/minloc1_16_i8.c: Regenerated.\n\t* generated/minloc1_16_r10.c: Regenerated.\n\t* generated/minloc1_16_r16.c: Regenerated.\n\t* generated/minloc1_16_r4.c: Regenerated.\n\t* generated/minloc1_16_r8.c: Regenerated.\n\t* generated/minloc1_4_i1.c: Regenerated.\n\t* generated/minloc1_4_i16.c: Regenerated.\n\t* generated/minloc1_4_i2.c: Regenerated.\n\t* generated/minloc1_4_i4.c: Regenerated.\n\t* generated/minloc1_4_i8.c: Regenerated.\n\t* generated/minloc1_4_r10.c: Regenerated.\n\t* generated/minloc1_4_r16.c: Regenerated.\n\t* generated/minloc1_4_r4.c: Regenerated.\n\t* generated/minloc1_4_r8.c: Regenerated.\n\t* generated/minloc1_8_i1.c: Regenerated.\n\t* generated/minloc1_8_i16.c: Regenerated.\n\t* generated/minloc1_8_i2.c: Regenerated.\n\t* generated/minloc1_8_i4.c: Regenerated.\n\t* generated/minloc1_8_i8.c: Regenerated.\n\t* generated/minloc1_8_r10.c: Regenerated.\n\t* generated/minloc1_8_r16.c: Regenerated.\n\t* generated/minloc1_8_r4.c: Regenerated.\n\t* generated/minloc1_8_r8.c: Regenerated.\n\t* generated/minval_i1.c: Regenerated.\n\t* generated/minval_i16.c: Regenerated.\n\t* generated/minval_i2.c: Regenerated.\n\t* generated/minval_i4.c: Regenerated.\n\t* generated/minval_i8.c: Regenerated.\n\t* generated/minval_r10.c: Regenerated.\n\t* generated/minval_r16.c: Regenerated.\n\t* generated/minval_r4.c: Regenerated.\n\t* generated/minval_r8.c: Regenerated.\n\t* generated/product_c10.c: Regenerated.\n\t* generated/product_c16.c: Regenerated.\n\t* generated/product_c4.c: Regenerated.\n\t* generated/product_c8.c: Regenerated.\n\t* generated/product_i1.c: Regenerated.\n\t* generated/product_i16.c: Regenerated.\n\t* generated/product_i2.c: Regenerated.\n\t* generated/product_i4.c: Regenerated.\n\t* generated/product_i8.c: Regenerated.\n\t* generated/product_r10.c: Regenerated.\n\t* generated/product_r16.c: Regenerated.\n\t* generated/product_r4.c: Regenerated.\n\t* generated/product_r8.c: Regenerated.\n\t* generated/sum_c10.c: Regenerated.\n\t* generated/sum_c16.c: Regenerated.\n\t* generated/sum_c4.c: Regenerated.\n\t* generated/sum_c8.c: Regenerated.\n\t* generated/sum_i1.c: Regenerated.\n\t* generated/sum_i16.c: Regenerated.\n\t* generated/sum_i2.c: Regenerated.\n\t* generated/sum_i4.c: Regenerated.\n\t* generated/sum_i8.c: Regenerated.\n\t* generated/sum_r10.c: Regenerated.\n\t* generated/sum_r16.c: Regenerated.\n\t* generated/sum_r4.c: Regenerated.\n\t* generated/sum_r8.c: Regenerated.\n\nFrom-SVN: r127774", "tree": {"sha": "b12449583134bdcb1419a30d4a072fbb3e1c10fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b12449583134bdcb1419a30d4a072fbb3e1c10fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/comments", "author": null, "committer": null, "parents": [{"sha": "c6a8035acf00eb3ef5f1a4a22469e7ebb6785af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a8035acf00eb3ef5f1a4a22469e7ebb6785af5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a8035acf00eb3ef5f1a4a22469e7ebb6785af5"}], "stats": {"total": 6285, "additions": 3544, "deletions": 2741}, "files": [{"sha": "7ab6c1eddd7cc0d9d94daf9937ee123e01170c4e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -1,3 +1,8 @@\n+2007-08-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/32972\n+\t* iresolve.c:  Don't convert array masks.\n+\n 2007-08-24  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/33139"}, {"sha": "fc837e1fcd0191a3f88ebbaada0674e93aecb852", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -77,32 +77,18 @@ check_charlen_present (gfc_expr *source)\n static void\n resolve_mask_arg (gfc_expr *mask)\n {\n-  int newkind;\n \n-  /* The mask can be kind 4 or 8 for the array case.\n+  /* The mask can be any kind for an array.\n      For the scalar case, coerce it to kind=4 unconditionally\n      (because this is the only kind we have a library function\n      for).  */\n \n-  newkind = 0;\n-\n-  if (mask->rank == 0)\n-    {\n-      if (mask->ts.kind != 4)\n-\tnewkind = 4;\n-    }\n-  else\n-    {\n-      if (mask->ts.kind < 4)\n-\tnewkind = gfc_default_logical_kind;\n-    }\n-\n-  if (newkind)\n+  if (mask->rank == 0 && mask->ts.kind != 4)\n     {\n       gfc_typespec ts;\n \n       ts.type = BT_LOGICAL;\n-      ts.kind = newkind;\n+      ts.kind = 4;\n       gfc_convert_type (mask, &ts, 2);\n     }\n }"}, {"sha": "10e6009d8649da23602ec2e15dc3279990328d03", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -1,3 +1,173 @@\n+2007-08-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/32972\n+\t* libgfortran.h:  Remove GFOR_POINTER_L8_TO_L4 macro.\n+\tAdd GFOR_POINTER_TO_L1 macro.\n+\t* m4/iforeach.m4(`m'name`'rtype_qual`_'atype_code):\n+\tChange argument 'mask' to gfc_array_l1.  Adjust prototype.\n+\tChange mask pointer to GFC_LOGICAL_1.  Multiply strides\n+\tby kind of mask\n+\t* m4/ifunction.m4:  Likewise.\n+\t* intrinsics/pack_generic.c(pack_internal):  Likewise.\n+\t* intrinsics/unpack_generic.c(unpack_internal):  Likewise.\n+\t* m4/matmull.m4:  Switch to GFC_LOGICAL_1.  Multiply strides by\n+\tkind of logical arguments a and b.\n+\t* generated/matmul_l16.c: Regenerated.\n+\t* generated/matmul_l4.c: Regenerated.\n+\t* generated/matmul_l8.c: Regenerated.\n+\t* generated/maxloc0_16_i1.c: Regenerated.\n+\t* generated/maxloc0_16_i16.c: Regenerated.\n+\t* generated/maxloc0_16_i2.c: Regenerated.\n+\t* generated/maxloc0_16_i4.c: Regenerated.\n+\t* generated/maxloc0_16_i8.c: Regenerated.\n+\t* generated/maxloc0_16_r10.c: Regenerated.\n+\t* generated/maxloc0_16_r16.c: Regenerated.\n+\t* generated/maxloc0_16_r4.c: Regenerated.\n+\t* generated/maxloc0_16_r8.c: Regenerated.\n+\t* generated/maxloc0_4_i1.c: Regenerated.\n+\t* generated/maxloc0_4_i16.c: Regenerated.\n+\t* generated/maxloc0_4_i2.c: Regenerated.\n+\t* generated/maxloc0_4_i4.c: Regenerated.\n+\t* generated/maxloc0_4_i8.c: Regenerated.\n+\t* generated/maxloc0_4_r10.c: Regenerated.\n+\t* generated/maxloc0_4_r16.c: Regenerated.\n+\t* generated/maxloc0_4_r4.c: Regenerated.\n+\t* generated/maxloc0_4_r8.c: Regenerated.\n+\t* generated/maxloc0_8_i1.c: Regenerated.\n+\t* generated/maxloc0_8_i16.c: Regenerated.\n+\t* generated/maxloc0_8_i2.c: Regenerated.\n+\t* generated/maxloc0_8_i4.c: Regenerated.\n+\t* generated/maxloc0_8_i8.c: Regenerated.\n+\t* generated/maxloc0_8_r10.c: Regenerated.\n+\t* generated/maxloc0_8_r16.c: Regenerated.\n+\t* generated/maxloc0_8_r4.c: Regenerated.\n+\t* generated/maxloc0_8_r8.c: Regenerated.\n+\t* generated/maxloc1_16_i1.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc1_16_i2.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc1_4_i1.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_i2.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_8_i1.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc1_8_i2.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxval_i1.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/maxval_i2.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc0_16_i1.c: Regenerated.\n+\t* generated/minloc0_16_i16.c: Regenerated.\n+\t* generated/minloc0_16_i2.c: Regenerated.\n+\t* generated/minloc0_16_i4.c: Regenerated.\n+\t* generated/minloc0_16_i8.c: Regenerated.\n+\t* generated/minloc0_16_r10.c: Regenerated.\n+\t* generated/minloc0_16_r16.c: Regenerated.\n+\t* generated/minloc0_16_r4.c: Regenerated.\n+\t* generated/minloc0_16_r8.c: Regenerated.\n+\t* generated/minloc0_4_i1.c: Regenerated.\n+\t* generated/minloc0_4_i16.c: Regenerated.\n+\t* generated/minloc0_4_i2.c: Regenerated.\n+\t* generated/minloc0_4_i4.c: Regenerated.\n+\t* generated/minloc0_4_i8.c: Regenerated.\n+\t* generated/minloc0_4_r10.c: Regenerated.\n+\t* generated/minloc0_4_r16.c: Regenerated.\n+\t* generated/minloc0_4_r4.c: Regenerated.\n+\t* generated/minloc0_4_r8.c: Regenerated.\n+\t* generated/minloc0_8_i1.c: Regenerated.\n+\t* generated/minloc0_8_i16.c: Regenerated.\n+\t* generated/minloc0_8_i2.c: Regenerated.\n+\t* generated/minloc0_8_i4.c: Regenerated.\n+\t* generated/minloc0_8_i8.c: Regenerated.\n+\t* generated/minloc0_8_r10.c: Regenerated.\n+\t* generated/minloc0_8_r16.c: Regenerated.\n+\t* generated/minloc0_8_r4.c: Regenerated.\n+\t* generated/minloc0_8_r8.c: Regenerated.\n+\t* generated/minloc1_16_i1.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/minloc1_16_i2.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/minloc1_4_i1.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc1_4_i2.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_8_i1.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i2.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minval_i1.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/minval_i2.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i1.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/product_i2.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i1.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/sum_i2.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\t\n 2007-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR libfortran/23138"}, {"sha": "f4fb0b3770eb78cab0c12945dfb06ea97a339b23", "filename": "libgfortran/generated/matmul_l16.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmatmul_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmatmul_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -39,15 +39,15 @@ Boston, MA 02110-1301, USA.  */\n    Either a or b can be rank 1.  In this case x or y is 1.  */\n \n extern void matmul_l16 (gfc_array_l16 * const restrict, \n-\tgfc_array_l4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(matmul_l16);\n \n void\n matmul_l16 (gfc_array_l16 * const restrict retarray, \n-\tgfc_array_l4 * const restrict a, gfc_array_l4 * const restrict b)\n+\tgfc_array_l1 * const restrict a, gfc_array_l1 * const restrict b)\n {\n-  const GFC_INTEGER_4 * restrict abase;\n-  const GFC_INTEGER_4 * restrict bbase;\n+  const GFC_LOGICAL_1 * restrict abase;\n+  const GFC_LOGICAL_1 * restrict bbase;\n   GFC_LOGICAL_16 * restrict dest;\n   index_type rxstride;\n   index_type rystride;\n@@ -57,9 +57,11 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n   index_type ystride;\n   index_type x;\n   index_type y;\n+  int a_kind;\n+  int b_kind;\n \n-  const GFC_INTEGER_4 * restrict pa;\n-  const GFC_INTEGER_4 * restrict pb;\n+  const GFC_LOGICAL_1 * restrict pa;\n+  const GFC_LOGICAL_1 * restrict pb;\n   index_type astride;\n   index_type bstride;\n   index_type count;\n@@ -99,17 +101,29 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n     }\n \n   abase = a->data;\n-  if (GFC_DESCRIPTOR_SIZE (a) != 4)\n-    {\n-      assert (GFC_DESCRIPTOR_SIZE (a) == 8);\n-      abase = GFOR_POINTER_L8_TO_L4 (abase);\n-    }\n+  a_kind = GFC_DESCRIPTOR_SIZE (a);\n+\n+  if (a_kind == 1 || a_kind == 2 || a_kind == 4 || a_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+     || a_kind == 16\n+#endif\n+     )\n+    abase = GFOR_POINTER_TO_L1 (abase, a_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n   bbase = b->data;\n-  if (GFC_DESCRIPTOR_SIZE (b) != 4)\n-    {\n-      assert (GFC_DESCRIPTOR_SIZE (b) == 8);\n-      bbase = GFOR_POINTER_L8_TO_L4 (bbase);\n-    }\n+  b_kind = GFC_DESCRIPTOR_SIZE (b);\n+\n+  if (b_kind == 1 || b_kind == 2 || b_kind == 4 || b_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+     || b_kind == 16\n+#endif\n+     )\n+    bbase = GFOR_POINTER_TO_L1 (bbase, b_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n   dest = retarray->data;\n \n \n@@ -128,30 +142,30 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n      one.  */\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n+      astride = a->dim[0].stride * a_kind;\n       count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n       xstride = 0;\n       rxstride = 0;\n       xcount = 1;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      astride = a->dim[1].stride * a_kind;\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n       xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n+      bstride = b->dim[0].stride * b_kind;\n       assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n       ystride = 0;\n       rystride = 0;\n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n+      bstride = b->dim[0].stride * b_kind;\n       assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n       ystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n@@ -189,3 +203,4 @@ matmul_l16 (gfc_array_l16 * const restrict retarray,\n }\n \n #endif\n+"}, {"sha": "0b822f63e4de6143ff4b18804186c638aa72df00", "filename": "libgfortran/generated/matmul_l4.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmatmul_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmatmul_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -39,15 +39,15 @@ Boston, MA 02110-1301, USA.  */\n    Either a or b can be rank 1.  In this case x or y is 1.  */\n \n extern void matmul_l4 (gfc_array_l4 * const restrict, \n-\tgfc_array_l4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(matmul_l4);\n \n void\n matmul_l4 (gfc_array_l4 * const restrict retarray, \n-\tgfc_array_l4 * const restrict a, gfc_array_l4 * const restrict b)\n+\tgfc_array_l1 * const restrict a, gfc_array_l1 * const restrict b)\n {\n-  const GFC_INTEGER_4 * restrict abase;\n-  const GFC_INTEGER_4 * restrict bbase;\n+  const GFC_LOGICAL_1 * restrict abase;\n+  const GFC_LOGICAL_1 * restrict bbase;\n   GFC_LOGICAL_4 * restrict dest;\n   index_type rxstride;\n   index_type rystride;\n@@ -57,9 +57,11 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n   index_type ystride;\n   index_type x;\n   index_type y;\n+  int a_kind;\n+  int b_kind;\n \n-  const GFC_INTEGER_4 * restrict pa;\n-  const GFC_INTEGER_4 * restrict pb;\n+  const GFC_LOGICAL_1 * restrict pa;\n+  const GFC_LOGICAL_1 * restrict pb;\n   index_type astride;\n   index_type bstride;\n   index_type count;\n@@ -99,17 +101,29 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n     }\n \n   abase = a->data;\n-  if (GFC_DESCRIPTOR_SIZE (a) != 4)\n-    {\n-      assert (GFC_DESCRIPTOR_SIZE (a) == 8);\n-      abase = GFOR_POINTER_L8_TO_L4 (abase);\n-    }\n+  a_kind = GFC_DESCRIPTOR_SIZE (a);\n+\n+  if (a_kind == 1 || a_kind == 2 || a_kind == 4 || a_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+     || a_kind == 16\n+#endif\n+     )\n+    abase = GFOR_POINTER_TO_L1 (abase, a_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n   bbase = b->data;\n-  if (GFC_DESCRIPTOR_SIZE (b) != 4)\n-    {\n-      assert (GFC_DESCRIPTOR_SIZE (b) == 8);\n-      bbase = GFOR_POINTER_L8_TO_L4 (bbase);\n-    }\n+  b_kind = GFC_DESCRIPTOR_SIZE (b);\n+\n+  if (b_kind == 1 || b_kind == 2 || b_kind == 4 || b_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+     || b_kind == 16\n+#endif\n+     )\n+    bbase = GFOR_POINTER_TO_L1 (bbase, b_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n   dest = retarray->data;\n \n \n@@ -128,30 +142,30 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n      one.  */\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n+      astride = a->dim[0].stride * a_kind;\n       count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n       xstride = 0;\n       rxstride = 0;\n       xcount = 1;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      astride = a->dim[1].stride * a_kind;\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n       xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n+      bstride = b->dim[0].stride * b_kind;\n       assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n       ystride = 0;\n       rystride = 0;\n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n+      bstride = b->dim[0].stride * b_kind;\n       assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n       ystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n@@ -189,3 +203,4 @@ matmul_l4 (gfc_array_l4 * const restrict retarray,\n }\n \n #endif\n+"}, {"sha": "2fe0983076089554d0030138817c43e920cccea0", "filename": "libgfortran/generated/matmul_l8.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmatmul_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmatmul_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_l8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -39,15 +39,15 @@ Boston, MA 02110-1301, USA.  */\n    Either a or b can be rank 1.  In this case x or y is 1.  */\n \n extern void matmul_l8 (gfc_array_l8 * const restrict, \n-\tgfc_array_l4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(matmul_l8);\n \n void\n matmul_l8 (gfc_array_l8 * const restrict retarray, \n-\tgfc_array_l4 * const restrict a, gfc_array_l4 * const restrict b)\n+\tgfc_array_l1 * const restrict a, gfc_array_l1 * const restrict b)\n {\n-  const GFC_INTEGER_4 * restrict abase;\n-  const GFC_INTEGER_4 * restrict bbase;\n+  const GFC_LOGICAL_1 * restrict abase;\n+  const GFC_LOGICAL_1 * restrict bbase;\n   GFC_LOGICAL_8 * restrict dest;\n   index_type rxstride;\n   index_type rystride;\n@@ -57,9 +57,11 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n   index_type ystride;\n   index_type x;\n   index_type y;\n+  int a_kind;\n+  int b_kind;\n \n-  const GFC_INTEGER_4 * restrict pa;\n-  const GFC_INTEGER_4 * restrict pb;\n+  const GFC_LOGICAL_1 * restrict pa;\n+  const GFC_LOGICAL_1 * restrict pb;\n   index_type astride;\n   index_type bstride;\n   index_type count;\n@@ -99,17 +101,29 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n     }\n \n   abase = a->data;\n-  if (GFC_DESCRIPTOR_SIZE (a) != 4)\n-    {\n-      assert (GFC_DESCRIPTOR_SIZE (a) == 8);\n-      abase = GFOR_POINTER_L8_TO_L4 (abase);\n-    }\n+  a_kind = GFC_DESCRIPTOR_SIZE (a);\n+\n+  if (a_kind == 1 || a_kind == 2 || a_kind == 4 || a_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+     || a_kind == 16\n+#endif\n+     )\n+    abase = GFOR_POINTER_TO_L1 (abase, a_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n   bbase = b->data;\n-  if (GFC_DESCRIPTOR_SIZE (b) != 4)\n-    {\n-      assert (GFC_DESCRIPTOR_SIZE (b) == 8);\n-      bbase = GFOR_POINTER_L8_TO_L4 (bbase);\n-    }\n+  b_kind = GFC_DESCRIPTOR_SIZE (b);\n+\n+  if (b_kind == 1 || b_kind == 2 || b_kind == 4 || b_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+     || b_kind == 16\n+#endif\n+     )\n+    bbase = GFOR_POINTER_TO_L1 (bbase, b_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n   dest = retarray->data;\n \n \n@@ -128,30 +142,30 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n      one.  */\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n+      astride = a->dim[0].stride * a_kind;\n       count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n       xstride = 0;\n       rxstride = 0;\n       xcount = 1;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      astride = a->dim[1].stride * a_kind;\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n       xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n+      bstride = b->dim[0].stride * b_kind;\n       assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n       ystride = 0;\n       rystride = 0;\n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n+      bstride = b->dim[0].stride * b_kind;\n       assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n       ystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n@@ -189,3 +203,4 @@ matmul_l8 (gfc_array_l8 * const restrict retarray,\n }\n \n #endif\n+"}, {"sha": "aa52dece020f04e817ec4676c34bdbd97eebe641", "filename": "libgfortran/generated/maxloc0_16_i1.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i1 (gfc_array_i16 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_i1);\n \n void\n mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_1 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "30c91f5736caee734cbe3e35a4abd2d497c17871", "filename": "libgfortran/generated/maxloc0_16_i16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i16 (gfc_array_i16 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_i16);\n \n void\n mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "bf55fbd1d2d037ab4c508d36dc607596b2033c4d", "filename": "libgfortran/generated/maxloc0_16_i2.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i2 (gfc_array_i16 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_i2);\n \n void\n mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_2 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "ffe10a8e0ccbd55ffbfef0d397105f156ac707b8", "filename": "libgfortran/generated/maxloc0_16_i4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i4 (gfc_array_i16 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_i4);\n \n void\n mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "9f619178d4e7f7c0ec921b7e700b150a172e1f08", "filename": "libgfortran/generated/maxloc0_16_i8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_i8 (gfc_array_i16 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_i8);\n \n void\n mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "4da00f2176af09289e899a8a4e68c77ae6700c8c", "filename": "libgfortran/generated/maxloc0_16_r10.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_r10 (gfc_array_i16 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_r10);\n \n void\n mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_REAL_10 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "3f33f63d679c811932303f8a9319f2c1dfbcc7ab", "filename": "libgfortran/generated/maxloc0_16_r16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_r16 (gfc_array_i16 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_r16);\n \n void\n mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_REAL_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "0868d1fb41bdc5f13ec7c42379ddb87449cc9c4e", "filename": "libgfortran/generated/maxloc0_16_r4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_r4 (gfc_array_i16 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_r4);\n \n void\n mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_REAL_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "5fe64123d914f9f0d16b71d3f3325328bafd1389", "filename": "libgfortran/generated/maxloc0_16_r8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mmaxloc0_16_r8 (gfc_array_i16 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_16_r8);\n \n void\n mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_REAL_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "10ed2d0a51c63dba615b2970ea43e4ecacc3b310", "filename": "libgfortran/generated/maxloc0_4_i1.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i1 (gfc_array_i4 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_i1);\n \n void\n mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_1 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "4e80d675d7d6f46319d9f12ce477f55344e7b881", "filename": "libgfortran/generated/maxloc0_4_i16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i16 (gfc_array_i4 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_i16);\n \n void\n mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "15d975c7d59b90f880e07259aa546848278427be", "filename": "libgfortran/generated/maxloc0_4_i2.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i2 (gfc_array_i4 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_i2);\n \n void\n mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_2 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "813c8bd7accefee441ac130bd43e0da37370319b", "filename": "libgfortran/generated/maxloc0_4_i4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i4 (gfc_array_i4 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_i4);\n \n void\n mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "8c3fb9540a47c2e0d600088f9d4a12d0a9c2a9b0", "filename": "libgfortran/generated/maxloc0_4_i8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_i8 (gfc_array_i4 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_i8);\n \n void\n mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "74be989cf4b83b3e7e5ecb0791b4b5a28cdca1f2", "filename": "libgfortran/generated/maxloc0_4_r10.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_r10 (gfc_array_i4 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_r10);\n \n void\n mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_REAL_10 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "a6cf8bc011a25916b9eb8eff991a2a7232f8316a", "filename": "libgfortran/generated/maxloc0_4_r16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_r16 (gfc_array_i4 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_r16);\n \n void\n mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_REAL_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "50915d4f6524efbacbe363e5bc728e597b1a46d2", "filename": "libgfortran/generated/maxloc0_4_r4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_r4 (gfc_array_i4 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_r4);\n \n void\n mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_REAL_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "ec613e7741329ef8c667f02940b3b8724f755815", "filename": "libgfortran/generated/maxloc0_4_r8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mmaxloc0_4_r8 (gfc_array_i4 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_4_r8);\n \n void\n mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_REAL_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "916e4dcb1a254303e9f89d22efe6fed8d4c14766", "filename": "libgfortran/generated/maxloc0_8_i1.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i1 (gfc_array_i8 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_i1);\n \n void\n mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_1 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "e554f46e2a6116e3285f445bc0a7032f4920a453", "filename": "libgfortran/generated/maxloc0_8_i16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i16 (gfc_array_i8 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_i16);\n \n void\n mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "40ebe0f3628d9e1a1cfa72a990475576c23f09ea", "filename": "libgfortran/generated/maxloc0_8_i2.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i2 (gfc_array_i8 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_i2);\n \n void\n mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_2 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "df9a43e67dd3eba2e6af8fa328167f2788092338", "filename": "libgfortran/generated/maxloc0_8_i4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i4 (gfc_array_i8 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_i4);\n \n void\n mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "eedd6e69f116dc1c6f8da91ad2c0427f34b2a40d", "filename": "libgfortran/generated/maxloc0_8_i8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_i8 (gfc_array_i8 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_i8);\n \n void\n mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "215b53976064fcb57102be13267d0ab9531c6ac3", "filename": "libgfortran/generated/maxloc0_8_r10.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_r10 (gfc_array_i8 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_r10);\n \n void\n mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_REAL_10 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "32f4b859806021459144db1e07d72ca0be8ef9fe", "filename": "libgfortran/generated/maxloc0_8_r16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_r16 (gfc_array_i8 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_r16);\n \n void\n mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_REAL_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "140f6cb8f743afbe2d0f47a1176db57e93b5808f", "filename": "libgfortran/generated/maxloc0_8_r4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_r4 (gfc_array_i8 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_r4);\n \n void\n mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_REAL_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "907dbc7e03fd0a4d6eff35db190741e9e745d885", "filename": "libgfortran/generated/maxloc0_8_r8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ maxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mmaxloc0_8_r8 (gfc_array_i8 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mmaxloc0_8_r8);\n \n void\n mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_REAL_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mmaxloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "dc42f603df8ff8949de5eb4c1c9ded3a2021f303", "filename": "libgfortran/generated/maxloc1_16_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_i1);\n \n void\n mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "5b69dea88c9ec8245595562d4ca5eca6753217f9", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_i16);\n \n void\n mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "25360bc7ccaaa1567896027244e8da7390e45074", "filename": "libgfortran/generated/maxloc1_16_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_i2);\n \n void\n mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "d089126c934b0791fd3a2b7a41daddc057209f56", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_i4);\n \n void\n mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "502c951e90eeeaaa19a9bcb5e64d00cfd3819660", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_i8);\n \n void\n mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "721b390225131e7276691fa140b4492c28733e9c", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_r10);\n \n void\n mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "1a8e113b393f239e410bc69455e63a528382f89e", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_r16);\n \n void\n mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "fda1bfaf53dbef647d202a91c54ae8b4282c21f6", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_r4);\n \n void\n mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "4d2208a12e0ae75f3e954be9038e9f14e2b4ed4e", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxloc1_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_16_r8);\n \n void\n mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "0ae1a5ba528100c7f615d5c667554c08c3cdd0a9", "filename": "libgfortran/generated/maxloc1_4_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_i1);\n \n void\n mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "39a57c6f6848ea509dda29f78d1c7ef3b3664a1d", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_i16);\n \n void\n mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "bbf43ec4969ce1ec597a9a677b05e179032e3a96", "filename": "libgfortran/generated/maxloc1_4_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_i2);\n \n void\n mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "5b00fb1eda104c32ed729c2610062571bae0081c", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_i4);\n \n void\n mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "f5131140355318eb46dc9eab5d7e24d93ebdbfd5", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_i8);\n \n void\n mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "17e9cbba9a335255fdda6556e44df92cb3b691e5", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_r10);\n \n void\n mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "7b1c558e30fa68cf6902560e13f4a7b1a8587969", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_r16);\n \n void\n mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "4534e6f47393553253645e7c8bb81a3f6e3dadd1", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_r4);\n \n void\n mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "7917aae76ebbe9c8cbb1f536f5cf6d691668f940", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxloc1_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_4_r8);\n \n void\n mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "33966a235b6f3fdbd260ae32d6cc3502983925ef", "filename": "libgfortran/generated/maxloc1_8_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_i1);\n \n void\n mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "612003ef74a19dc3cd645efcccbb4c1672b4fc07", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_i16);\n \n void\n mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "04018e3791974c98e4b9b161cb7505251e0ff531", "filename": "libgfortran/generated/maxloc1_8_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_i2);\n \n void\n mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "833e4bed806ca41432346f336ff9cb202a12d23a", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_i4);\n \n void\n mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "880ad7ca4aeda34b91f18484316c84f409ab158e", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_i8);\n \n void\n mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "6de90ead1de34e370843485836d3f2681d16a132", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_r10);\n \n void\n mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "06e00dc0eb4992313ba5040165cbd4aa4105f0ee", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_r16);\n \n void\n mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "3d9d5c6df987e510c4ee280748dcce934f7a6b95", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_r4);\n \n void\n mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "ea2769ebc70ce63b9af6aeaaffbde0dcb85e3ac4", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxloc1_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxloc1_8_r8);\n \n void\n mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "08334d5bf5ef48366473b34966f845efdb65284e", "filename": "libgfortran/generated/maxval_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_i1 (gfc_array_i1 * const restrict retarray,\n \n extern void mmaxval_i1 (gfc_array_i1 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_i1);\n \n void\n mmaxval_i1 (gfc_array_i1 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_1 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_i1 (gfc_array_i1 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_1 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "56d7854021d6a5fa349990d38a8b9c771e449f48", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void mmaxval_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_i16);\n \n void\n mmaxval_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "111f5b910831df7f6108452231d097964aa72ed7", "filename": "libgfortran/generated/maxval_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_i2 (gfc_array_i2 * const restrict retarray,\n \n extern void mmaxval_i2 (gfc_array_i2 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_i2);\n \n void\n mmaxval_i2 (gfc_array_i2 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_2 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_i2 (gfc_array_i2 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_2 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "4413477f8b823ab936c39285d37b8538c90e870b", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void mmaxval_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_i4);\n \n void\n mmaxval_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "7e3cb16dd69cc3a00ed66c85870351e47c0d21d8", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void mmaxval_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_i8);\n \n void\n mmaxval_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "14338644b40c7a13eb8518a000f74f62613482cb", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n \n extern void mmaxval_r10 (gfc_array_r10 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_r10);\n \n void\n mmaxval_r10 (gfc_array_r10 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_10 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_10 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "6b4c409452d81cc2f2b099a619a4047a03cd41fb", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n \n extern void mmaxval_r16 (gfc_array_r16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_r16);\n \n void\n mmaxval_r16 (gfc_array_r16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_16 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "9e797d3f077494e0628f6a09f14a994767dc02b7", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n \n extern void mmaxval_r4 (gfc_array_r4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_r4);\n \n void\n mmaxval_r4 (gfc_array_r4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_4 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "ff4ed07d5ea0d2b3f764550a36d57cd2340daf75", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n \n extern void mmaxval_r8 (gfc_array_r8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mmaxval_r8);\n \n void\n mmaxval_r8 (gfc_array_r8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_8 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "5afd38763d188a64111b6f8aea0962944c03bfa4", "filename": "libgfortran/generated/minloc0_16_i1.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i1 (gfc_array_i16 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_i1);\n \n void\n mminloc0_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_1 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_i1 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "5f49874324b206c0833438efe20a09efb916ba96", "filename": "libgfortran/generated/minloc0_16_i16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i16 (gfc_array_i16 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_i16);\n \n void\n mminloc0_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_i16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "fed801515947cc6dbd15f8e00b716d996cb3da94", "filename": "libgfortran/generated/minloc0_16_i2.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i2 (gfc_array_i16 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_i2);\n \n void\n mminloc0_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_2 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_i2 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "bfb45413886d6b56081d8f890df07a3c8a47dfad", "filename": "libgfortran/generated/minloc0_16_i4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i4 (gfc_array_i16 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_i4);\n \n void\n mminloc0_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_i4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "d07297e90c31a63d43967e88dcd0c5eeab03f363", "filename": "libgfortran/generated/minloc0_16_i8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_i8 (gfc_array_i16 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_i8);\n \n void\n mminloc0_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_INTEGER_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_i8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "34b1d56735a82168201495ae73535c5f0b1eaef2", "filename": "libgfortran/generated/minloc0_16_r10.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_r10 (gfc_array_i16 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_r10);\n \n void\n mminloc0_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_REAL_10 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_r10 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "6e60e19203f1677d6ed57cd29125ed23dcfa4a93", "filename": "libgfortran/generated/minloc0_16_r16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_r16 (gfc_array_i16 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_r16);\n \n void\n mminloc0_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_REAL_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_r16 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "7e98c18b81e78d49a4db3472309be4e0ff207cf8", "filename": "libgfortran/generated/minloc0_16_r4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_r4 (gfc_array_i16 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_r4);\n \n void\n mminloc0_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_REAL_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_r4 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "4c2044b981eafad8d5ae01f0777a0255d3b2d63f", "filename": "libgfortran/generated/minloc0_16_r8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n \n \n extern void mminloc0_16_r8 (gfc_array_i16 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_16_r8);\n \n void\n mminloc0_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_16 *dest;\n   const GFC_REAL_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_16_r8 (gfc_array_i16 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "645af760ba023cde6747fbccf501277aeeaa69de", "filename": "libgfortran/generated/minloc0_4_i1.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i1 (gfc_array_i4 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_i1);\n \n void\n mminloc0_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_1 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_i1 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "5160d2e90a5b6f244c4afa4939b1deb25b217b4e", "filename": "libgfortran/generated/minloc0_4_i16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i16 (gfc_array_i4 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_i16);\n \n void\n mminloc0_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_i16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "28d0a7f9d44f3a671f4900fc646fe6d7b9018ece", "filename": "libgfortran/generated/minloc0_4_i2.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i2 (gfc_array_i4 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_i2);\n \n void\n mminloc0_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_2 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_i2 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "a820231df4945a81f33c2a7a0b5be75154230a00", "filename": "libgfortran/generated/minloc0_4_i4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i4 (gfc_array_i4 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_i4);\n \n void\n mminloc0_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_i4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "4d63109f8b907b21101deaed8e4b771ce9282eef", "filename": "libgfortran/generated/minloc0_4_i8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_i8 (gfc_array_i4 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_i8);\n \n void\n mminloc0_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_INTEGER_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_i8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "c2d8d82eba4031286727895da48a3add4cd98a8c", "filename": "libgfortran/generated/minloc0_4_r10.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_r10 (gfc_array_i4 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_r10);\n \n void\n mminloc0_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_REAL_10 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_r10 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "9a42aab29380e55c174caaba5c55b54fc6a932f8", "filename": "libgfortran/generated/minloc0_4_r16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_r16 (gfc_array_i4 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_r16);\n \n void\n mminloc0_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_REAL_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_r16 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "a2c67257476d419723111fa5093df477f31794e0", "filename": "libgfortran/generated/minloc0_4_r4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_r4 (gfc_array_i4 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_r4);\n \n void\n mminloc0_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_REAL_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_r4 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "ceefacf6cf158743229c5802844ed8974cc1143f", "filename": "libgfortran/generated/minloc0_4_r8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n \n \n extern void mminloc0_4_r8 (gfc_array_i4 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_4_r8);\n \n void\n mminloc0_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_4 *dest;\n   const GFC_REAL_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_4_r8 (gfc_array_i4 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "2629591cb7d56c3d5818b540ac8dfcf53d298e18", "filename": "libgfortran/generated/minloc0_8_i1.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i1 (gfc_array_i8 * const restrict, \n-\tgfc_array_i1 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_i1);\n \n void\n mminloc0_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_1 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_i1 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "30d8551cd8a4e195d1ed9700e9939f900911b278", "filename": "libgfortran/generated/minloc0_8_i16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i16 (gfc_array_i8 * const restrict, \n-\tgfc_array_i16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_i16);\n \n void\n mminloc0_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_i16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "34c236376423668f3895ac1ac0f5fb495757986f", "filename": "libgfortran/generated/minloc0_8_i2.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i2 (gfc_array_i8 * const restrict, \n-\tgfc_array_i2 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i2 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_i2);\n \n void\n mminloc0_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_2 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_i2 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "e1053e0b3f51ea6edbd869e8ea4b2fa2858f7081", "filename": "libgfortran/generated/minloc0_8_i4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i4 (gfc_array_i8 * const restrict, \n-\tgfc_array_i4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_i4);\n \n void\n mminloc0_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_i4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "851645e138962fdade9eec407a33484c84ea74f3", "filename": "libgfortran/generated/minloc0_8_i8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_i8 (gfc_array_i8 * const restrict, \n-\tgfc_array_i8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_i8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_i8);\n \n void\n mminloc0_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_INTEGER_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_i8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "569efa08b79e9283e8b3337683124a77cb59b04b", "filename": "libgfortran/generated/minloc0_8_r10.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_r10 (gfc_array_i8 * const restrict, \n-\tgfc_array_r10 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r10 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_r10);\n \n void\n mminloc0_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_REAL_10 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_r10 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "4e19efab4f2ba0c367f7050cdc195124d813a6c1", "filename": "libgfortran/generated/minloc0_8_r16.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_r16 (gfc_array_i8 * const restrict, \n-\tgfc_array_r16 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r16 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_r16);\n \n void\n mminloc0_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_REAL_16 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_r16 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "0bcf5c6344721bb37693a900ebfe113dfa65f93f", "filename": "libgfortran/generated/minloc0_8_r4.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_r4 (gfc_array_i8 * const restrict, \n-\tgfc_array_r4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r4 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_r4);\n \n void\n mminloc0_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_REAL_4 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_r4 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "778963376d3454665b786c887e4ecc029c3f634d", "filename": "libgfortran/generated/minloc0_8_r8.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc0_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -148,13 +148,13 @@ minloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n \n \n extern void mminloc0_8_r8 (gfc_array_i8 * const restrict, \n-\tgfc_array_r8 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_r8 * const restrict, gfc_array_l1 * const restrict);\n export_proto(mminloc0_8_r8);\n \n void\n mminloc0_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -163,9 +163,10 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type dstride;\n   GFC_INTEGER_8 *dest;\n   const GFC_REAL_8 *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -189,12 +190,25 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -207,17 +221,6 @@ mminloc0_8_r8 (gfc_array_i8 * const restrict retarray,\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "1e7b09bd1312afc866133913b1bcf096c858d016", "filename": "libgfortran/generated/minloc1_16_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i1 (gfc_array_i16 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_i1);\n \n void\n mminloc1_16_i1 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_i1 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "0570e1686ad1a3f7bef87f3454e3f72905297e10", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_i16);\n \n void\n mminloc1_16_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "3ec829ee7c07e696c3f502a38d1caeaf2ea9b676", "filename": "libgfortran/generated/minloc1_16_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i2 (gfc_array_i16 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_i2);\n \n void\n mminloc1_16_i2 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_i2 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "1d2a22982c744e0eeaf581e4655f72c82125c3b3", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i4 (gfc_array_i16 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_i4);\n \n void\n mminloc1_16_i4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "009bfc84b1a3906eacc8b5e42fbb2f8a0ec19ce3", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_i8 (gfc_array_i16 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_i8);\n \n void\n mminloc1_16_i8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "18e7d9038ba3d095c3d9dd2a61c03efd9a97458c", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_r10 (gfc_array_i16 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_r10);\n \n void\n mminloc1_16_r10 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "11d66700d047d69f73a2402cda21cfd6b51fc591", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_r16 (gfc_array_i16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_r16);\n \n void\n mminloc1_16_r16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "36ab93342a1928a7ddd71dadf6a96c095e1fd9c5", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_r4 (gfc_array_i16 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_r4);\n \n void\n mminloc1_16_r4 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "4bc2f7e9468dbaee9bc790b9605cdd4e2a10912d", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n extern void mminloc1_16_r8 (gfc_array_i16 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_16_r8);\n \n void\n mminloc1_16_r8 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "b94775d748dbc7e2e30356ab9367353c11e56a4d", "filename": "libgfortran/generated/minloc1_4_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i1 (gfc_array_i4 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_i1);\n \n void\n mminloc1_4_i1 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_i1 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "720d35c00662b0bc8890b91f336295ef6e21db68", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i16 (gfc_array_i4 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_i16);\n \n void\n mminloc1_4_i16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "10a3537f8cfd9cdc3dc3ca69eea8f44e164cbd79", "filename": "libgfortran/generated/minloc1_4_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i2 (gfc_array_i4 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_i2);\n \n void\n mminloc1_4_i2 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_i2 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "941ac82ae019a4708ca1d2d4cae40303964bd279", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_i4);\n \n void\n mminloc1_4_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "36768068183ca77e0d584a51d750606c3c1942ce", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_i8 (gfc_array_i4 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_i8);\n \n void\n mminloc1_4_i8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "84631c091e5e4b0629c4de3b612c913c22eb0954", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_r10 (gfc_array_i4 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_r10);\n \n void\n mminloc1_4_r10 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "d3e9b5fef8c77d64e14f94d1c5a6e81e026b3364", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_r16 (gfc_array_i4 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_r16);\n \n void\n mminloc1_4_r16 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "e2ccd58572e671f834c25ab2fa18ed03fbb0f748", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_r4 (gfc_array_i4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_r4);\n \n void\n mminloc1_4_r4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "6e96a65cdebec5bb3da778b3ecd2da54072b3fb4", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n extern void mminloc1_4_r8 (gfc_array_i4 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_4_r8);\n \n void\n mminloc1_4_r8 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "caa48af2a2e997d8d01be5a0ad59ea9be95d01e2", "filename": "libgfortran/generated/minloc1_8_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i1 (gfc_array_i8 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_i1);\n \n void\n mminloc1_8_i1 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_i1 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "1928c401004ada9f49fa41dfb62a5cbc1bf875e1", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i16 (gfc_array_i8 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_i16);\n \n void\n mminloc1_8_i16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "6c40de8040f4001b51a0f43c3dd88531e757967a", "filename": "libgfortran/generated/minloc1_8_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i2 (gfc_array_i8 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_i2);\n \n void\n mminloc1_8_i2 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_i2 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "9f563d5cdcef91396a68df7be9c4821681d002f7", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i4 (gfc_array_i8 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_i4);\n \n void\n mminloc1_8_i4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "6cdeec75db17dff9e8492041143a5541b5214736", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_i8);\n \n void\n mminloc1_8_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "1dc5be691979ea6eaf459bfcfef565b1434be2f2", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_r10 (gfc_array_i8 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_r10);\n \n void\n mminloc1_8_r10 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "5bec2992ff6ba88fe34cc7a70f5afcd05fb80d77", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_r16 (gfc_array_i8 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_r16);\n \n void\n mminloc1_8_r16 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "9952148093718e29550b4e2ab202dff794a26ff5", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_r4 (gfc_array_i8 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_r4);\n \n void\n mminloc1_8_r4 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "44e3eecb7cf8e3939494d13cdb0a7257f946bdb5", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -191,14 +191,14 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n extern void mminloc1_8_r8 (gfc_array_i8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminloc1_8_r8);\n \n void\n mminloc1_8_r8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -207,27 +207,42 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -237,7 +252,7 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -292,22 +307,11 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "5c72eb9306274de1e9eee4ba9106a38525a9efea", "filename": "libgfortran/generated/minval_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_i1 (gfc_array_i1 * const restrict retarray,\n \n extern void mminval_i1 (gfc_array_i1 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_i1);\n \n void\n mminval_i1 (gfc_array_i1 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_1 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_i1 (gfc_array_i1 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_1 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "eedadadc05897aa66b098a561533bc09965405fc", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void mminval_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_i16);\n \n void\n mminval_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "2ca350644214bfafb9b0f54283483553db57e36e", "filename": "libgfortran/generated/minval_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_i2 (gfc_array_i2 * const restrict retarray,\n \n extern void mminval_i2 (gfc_array_i2 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_i2);\n \n void\n mminval_i2 (gfc_array_i2 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_2 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_i2 (gfc_array_i2 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_2 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "2f5796efbe2a09bdf322ff33e1a805d47fcb02f2", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void mminval_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_i4);\n \n void\n mminval_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "0bdbb81b230ed69cba8c36f5212f948647ce9ce5", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void mminval_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_i8);\n \n void\n mminval_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "aa5c576d2ebb0e66e41770e3922bce29d455c67b", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n \n extern void mminval_r10 (gfc_array_r10 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_r10);\n \n void\n mminval_r10 (gfc_array_r10 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_10 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_10 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "ada6f8c6227eff9ffad5a675b92d38d34cea9179", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n \n extern void mminval_r16 (gfc_array_r16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_r16);\n \n void\n mminval_r16 (gfc_array_r16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_16 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "7143b2b604a232b317d70554450bc7edb9970844", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n \n extern void mminval_r4 (gfc_array_r4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_r4);\n \n void\n mminval_r4 (gfc_array_r4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_4 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "c21dc2350a921f99c0af8922f141dcc15f863678", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -185,14 +185,14 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n \n extern void mminval_r8 (gfc_array_r8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mminval_r8);\n \n void\n mminval_r8 (gfc_array_r8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -201,27 +201,42 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_8 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -231,7 +246,7 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -286,22 +301,11 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "b63cb6afabd931c6a91f90367348dca348f5bcf5", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n \n extern void mproduct_c10 (gfc_array_c10 * const restrict, \n \tgfc_array_c10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_c10);\n \n void\n mproduct_c10 (gfc_array_c10 * const restrict retarray, \n \tgfc_array_c10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_COMPLEX_10 * restrict dest;\n   const GFC_COMPLEX_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_COMPLEX_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_COMPLEX_10 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "3b6265a2720c9649a8bd4113d8e67307acc90057", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n \n extern void mproduct_c16 (gfc_array_c16 * const restrict, \n \tgfc_array_c16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_c16);\n \n void\n mproduct_c16 (gfc_array_c16 * const restrict retarray, \n \tgfc_array_c16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_COMPLEX_16 * restrict dest;\n   const GFC_COMPLEX_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_COMPLEX_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_COMPLEX_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "07e0df0b85edb62dec95013d8d587722d391776a", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n \n extern void mproduct_c4 (gfc_array_c4 * const restrict, \n \tgfc_array_c4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_c4);\n \n void\n mproduct_c4 (gfc_array_c4 * const restrict retarray, \n \tgfc_array_c4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_COMPLEX_4 * restrict dest;\n   const GFC_COMPLEX_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_COMPLEX_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_COMPLEX_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "a81241eca2cf4b87dd7fe87fc46223b407a7f8a6", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n \n extern void mproduct_c8 (gfc_array_c8 * const restrict, \n \tgfc_array_c8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_c8);\n \n void\n mproduct_c8 (gfc_array_c8 * const restrict retarray, \n \tgfc_array_c8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_COMPLEX_8 * restrict dest;\n   const GFC_COMPLEX_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_COMPLEX_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_COMPLEX_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "4c68414247ce9ceb5e65e99177c4af03a0c556d3", "filename": "libgfortran/generated/product_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_i1 (gfc_array_i1 * const restrict retarray,\n \n extern void mproduct_i1 (gfc_array_i1 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_i1);\n \n void\n mproduct_i1 (gfc_array_i1 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_1 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_i1 (gfc_array_i1 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_1 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "9e81e595931dbf21255d2ce1b02c4c615cda5475", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void mproduct_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_i16);\n \n void\n mproduct_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "dde442a7433e3d635041531d1c8fb0358455ce79", "filename": "libgfortran/generated/product_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_i2 (gfc_array_i2 * const restrict retarray,\n \n extern void mproduct_i2 (gfc_array_i2 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_i2);\n \n void\n mproduct_i2 (gfc_array_i2 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_2 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_i2 (gfc_array_i2 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_2 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "50875daafd3348ae3ac412f0daf5aa0d54e23859", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void mproduct_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_i4);\n \n void\n mproduct_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "0b9d268a6c76ef25973df39dc490683b6507ffae", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void mproduct_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_i8);\n \n void\n mproduct_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "28732503501aedba9c37c6f8ec80ba5cd2b943db", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n \n extern void mproduct_r10 (gfc_array_r10 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_r10);\n \n void\n mproduct_r10 (gfc_array_r10 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_10 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_10 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "61149515b7f18067c153d42b6545807015d6511e", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n \n extern void mproduct_r16 (gfc_array_r16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_r16);\n \n void\n mproduct_r16 (gfc_array_r16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_16 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "b3c9a0b25ca8707e004b65f803504d5a2ba3295a", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n \n extern void mproduct_r4 (gfc_array_r4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_r4);\n \n void\n mproduct_r4 (gfc_array_r4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_4 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "8d49b27989470e9d6e41526924f48b9b09f5e617", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n \n extern void mproduct_r8 (gfc_array_r8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(mproduct_r8);\n \n void\n mproduct_r8 (gfc_array_r8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_8 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "2fa759450aa54661dca378d0e6b486c6cc1ca953", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_c10 (gfc_array_c10 * const restrict retarray,\n \n extern void msum_c10 (gfc_array_c10 * const restrict, \n \tgfc_array_c10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_c10);\n \n void\n msum_c10 (gfc_array_c10 * const restrict retarray, \n \tgfc_array_c10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_COMPLEX_10 * restrict dest;\n   const GFC_COMPLEX_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_COMPLEX_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_COMPLEX_10 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "b74aa43b25041fd458d015bb512d3bc40da6625e", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_c16 (gfc_array_c16 * const restrict retarray,\n \n extern void msum_c16 (gfc_array_c16 * const restrict, \n \tgfc_array_c16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_c16);\n \n void\n msum_c16 (gfc_array_c16 * const restrict retarray, \n \tgfc_array_c16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_COMPLEX_16 * restrict dest;\n   const GFC_COMPLEX_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_COMPLEX_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_COMPLEX_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "bf41330a2f58b66b8fc7e8fa1f87023be5a6e764", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_c4 (gfc_array_c4 * const restrict retarray,\n \n extern void msum_c4 (gfc_array_c4 * const restrict, \n \tgfc_array_c4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_c4);\n \n void\n msum_c4 (gfc_array_c4 * const restrict retarray, \n \tgfc_array_c4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_COMPLEX_4 * restrict dest;\n   const GFC_COMPLEX_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_COMPLEX_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_COMPLEX_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "d7c3c9dadc2e92e09817abc66bcb0494bbe3ee60", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_c8 (gfc_array_c8 * const restrict retarray,\n \n extern void msum_c8 (gfc_array_c8 * const restrict, \n \tgfc_array_c8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_c8);\n \n void\n msum_c8 (gfc_array_c8 * const restrict retarray, \n \tgfc_array_c8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_COMPLEX_8 * restrict dest;\n   const GFC_COMPLEX_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_COMPLEX_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_COMPLEX_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "0b0d3c8135db0632b439ceb7f902d438831d6589", "filename": "libgfortran/generated/sum_i1.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i1.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_i1 (gfc_array_i1 * const restrict retarray,\n \n extern void msum_i1 (gfc_array_i1 * const restrict, \n \tgfc_array_i1 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_i1);\n \n void\n msum_i1 (gfc_array_i1 * const restrict retarray, \n \tgfc_array_i1 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_i1 (gfc_array_i1 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_1 * restrict dest;\n   const GFC_INTEGER_1 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_i1 (gfc_array_i1 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_i1 (gfc_array_i1 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_1 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_1 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "0f0bc55e373b600b4d645ee10b6ff1f85b2a1454", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_i16 (gfc_array_i16 * const restrict retarray,\n \n extern void msum_i16 (gfc_array_i16 * const restrict, \n \tgfc_array_i16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_i16);\n \n void\n msum_i16 (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_16 * restrict dest;\n   const GFC_INTEGER_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "c951d670177f00d1214f7153dd65b0439675112b", "filename": "libgfortran/generated/sum_i2.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i2.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_i2 (gfc_array_i2 * const restrict retarray,\n \n extern void msum_i2 (gfc_array_i2 * const restrict, \n \tgfc_array_i2 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_i2);\n \n void\n msum_i2 (gfc_array_i2 * const restrict retarray, \n \tgfc_array_i2 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_i2 (gfc_array_i2 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_2 * restrict dest;\n   const GFC_INTEGER_2 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_i2 (gfc_array_i2 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_i2 (gfc_array_i2 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_2 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_2 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "973b8f10297da857fb2ebb8dea8e9358d3a75476", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_i4 (gfc_array_i4 * const restrict retarray,\n \n extern void msum_i4 (gfc_array_i4 * const restrict, \n \tgfc_array_i4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_i4);\n \n void\n msum_i4 (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_4 * restrict dest;\n   const GFC_INTEGER_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "87e7ec650f02d6b1aeac4dd459386f1d806a6ba6", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_i8 (gfc_array_i8 * const restrict retarray,\n \n extern void msum_i8 (gfc_array_i8 * const restrict, \n \tgfc_array_i8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_i8);\n \n void\n msum_i8 (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_INTEGER_8 * restrict dest;\n   const GFC_INTEGER_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_INTEGER_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_INTEGER_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "f552026e4464304fb156ea5ef072f0cbf7a48b3d", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_r10 (gfc_array_r10 * const restrict retarray,\n \n extern void msum_r10 (gfc_array_r10 * const restrict, \n \tgfc_array_r10 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_r10);\n \n void\n msum_r10 (gfc_array_r10 * const restrict retarray, \n \tgfc_array_r10 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_10 * restrict dest;\n   const GFC_REAL_10 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_10 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_10 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "586105420119f119fe0176ee677dee818d8af79b", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_r16 (gfc_array_r16 * const restrict retarray,\n \n extern void msum_r16 (gfc_array_r16 * const restrict, \n \tgfc_array_r16 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_r16);\n \n void\n msum_r16 (gfc_array_r16 * const restrict retarray, \n \tgfc_array_r16 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_16 * restrict dest;\n   const GFC_REAL_16 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_16 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_16 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "4b07477d56e4b160df0698052de175f6ac51136f", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_r4 (gfc_array_r4 * const restrict retarray,\n \n extern void msum_r4 (gfc_array_r4 * const restrict, \n \tgfc_array_r4 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_r4);\n \n void\n msum_r4 (gfc_array_r4 * const restrict retarray, \n \tgfc_array_r4 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_4 * restrict dest;\n   const GFC_REAL_4 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_4 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_4 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "43df4a6f23b1970427d634cbeeb20e75a5147788", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -184,14 +184,14 @@ sum_r8 (gfc_array_r8 * const restrict retarray,\n \n extern void msum_r8 (gfc_array_r8 * const restrict, \n \tgfc_array_r8 * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(msum_r8);\n \n void\n msum_r8 (gfc_array_r8 * const restrict retarray, \n \tgfc_array_r8 * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -200,27 +200,42 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   GFC_REAL_8 * restrict dest;\n   const GFC_REAL_8 * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -230,7 +245,7 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -285,22 +300,11 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const GFC_REAL_8 * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       GFC_REAL_8 result;\n       src = base;\n       msrc = mbase;"}, {"sha": "30255f046865c5e19f958096d77ef52ad68b80c9", "filename": "libgfortran/intrinsics/pack_generic.c", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fintrinsics%2Fpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fintrinsics%2Fpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fpack_generic.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -76,7 +76,7 @@ array valued, and the other one where MASK is scalar.  */\n \n static void\n pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n-\t       const gfc_array_l4 *mask, const gfc_array_char *vector,\n+\t       const gfc_array_l1 *mask, const gfc_array_char *vector,\n \t       index_type size)\n {\n   /* r.* indicates the return array.  */\n@@ -89,7 +89,7 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n   /* m.* indicates the mask array.  */\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type mstride0;\n-  const GFC_LOGICAL_4 *mptr;\n+  const GFC_LOGICAL_1 *mptr;\n \n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -98,8 +98,31 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n   index_type dim;\n   index_type nelem;\n   index_type total;\n+  int mask_kind;\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  sptr = array->data;\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Don't convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   zero_sized = 0;\n   for (n = 0; n < dim; n++)\n     {\n@@ -108,25 +131,12 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n       if (extent[n] <= 0)\n        zero_sized = 1;\n       sstride[n] = array->dim[n].stride * size;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n     }\n   if (sstride[0] == 0)\n     sstride[0] = size;\n   if (mstride[0] == 0)\n-    mstride[0] = 1;\n-\n-  sptr = array->data;\n-  mptr = mask->data;\n-\n-  /* Use the same loop for both logical types. */\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      if (GFC_DESCRIPTOR_SIZE (mask) != 8)\n-        runtime_error (\"Funny sized logical array\");\n-      for (n = 0; n < dim; n++)\n-        mstride[n] <<= 1;\n-      mptr = GFOR_POINTER_L8_TO_L4 (mptr);\n-    }\n+    mstride[0] = mask_kind;\n \n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n@@ -156,7 +166,7 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n \t     cache behavior in the case where our cache is not big\n \t     enough to hold all elements that have to be copied.  */\n \n-\t  const GFC_LOGICAL_4 *m = mptr;\n+\t  const GFC_LOGICAL_1 *m = mptr;\n \n \t  total = 0;\n \t  if (zero_sized)"}, {"sha": "86c70fb7e45944a7d7ea2cf95fc52cdd0052deef", "filename": "libgfortran/intrinsics/unpack_generic.c", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fintrinsics%2Funpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fintrinsics%2Funpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Funpack_generic.c?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -36,7 +36,7 @@ Boston, MA 02110-1301, USA.  */\n \n static void\n unpack_internal (gfc_array_char *ret, const gfc_array_char *vector,\n-\t\t const gfc_array_l4 *mask, const gfc_array_char *field,\n+\t\t const gfc_array_l1 *mask, const gfc_array_char *field,\n \t\t index_type size, index_type fsize)\n {\n   /* r.* indicates the return array.  */\n@@ -54,16 +54,38 @@ unpack_internal (gfc_array_char *ret, const gfc_array_char *vector,\n   /* m.* indicates the mask array.  */\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   index_type mstride0;\n-  const GFC_LOGICAL_4 *mptr;\n+  const GFC_LOGICAL_1 *mptr;\n \n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n   index_type n;\n   index_type dim;\n \n   int empty;\n+  int mask_kind;\n \n   empty = 0;\n+\n+  mptr = mask->data;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Don't convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   if (ret->data == NULL)\n     {\n       /* The front end has signalled that we need to populate the\n@@ -80,7 +102,7 @@ unpack_internal (gfc_array_char *ret, const gfc_array_char *vector,\n \t  empty = empty || extent[n] <= 0;\n \t  rstride[n] = ret->dim[n].stride * size;\n \t  fstride[n] = field->dim[n].stride * fsize;\n-\t  mstride[n] = mask->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n \t  rs *= extent[n];\n \t}\n       ret->offset = 0;\n@@ -96,7 +118,7 @@ unpack_internal (gfc_array_char *ret, const gfc_array_char *vector,\n \t  empty = empty || extent[n] <= 0;\n \t  rstride[n] = ret->dim[n].stride * size;\n \t  fstride[n] = field->dim[n].stride * fsize;\n-\t  mstride[n] = mask->dim[n].stride;\n+\t  mstride[n] = mask->dim[n].stride * mask_kind;\n \t}\n       if (rstride[0] == 0)\n \trstride[0] = size;\n@@ -118,20 +140,8 @@ unpack_internal (gfc_array_char *ret, const gfc_array_char *vector,\n   mstride0 = mstride[0];\n   rptr = ret->data;\n   fptr = field->data;\n-  mptr = mask->data;\n   vptr = vector->data;\n \n-  /* Use the same loop for both logical types. */\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      if (GFC_DESCRIPTOR_SIZE (mask) != 8)\n-        runtime_error (\"Funny sized logical array\");\n-      for (n = 0; n < dim; n++)\n-        mstride[n] <<= 1;\n-      mstride0 <<= 1;\n-      mptr = GFOR_POINTER_L8_TO_L4 (mptr);\n-    }\n-\n   while (rptr)\n     {\n       if (*mptr)"}, {"sha": "555c6bfd4a8035e1545d3e1edf4b4353d05c9989", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -233,8 +233,8 @@ typedef GFC_INTEGER_4 gfc_charlen_type;\n extern int l8_to_l4_offset;\n internal_proto(l8_to_l4_offset);\n \n-#define GFOR_POINTER_L8_TO_L4(p8) \\\n-  (l8_to_l4_offset + (GFC_LOGICAL_4 *)(p8))\n+#define GFOR_POINTER_TO_L1(p, kind) \\\n+  (l8_to_l4_offset * (kind - 1) + (GFC_LOGICAL_1 *)(p))\n \n #define GFC_INTEGER_1_HUGE \\\n   (GFC_INTEGER_1)((((GFC_UINTEGER_1)1) << 7) - 1)\n@@ -322,6 +322,8 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_COMPLEX_10) gfc_array_c10;\n #ifdef HAVE_GFC_COMPLEX_16\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_COMPLEX_16) gfc_array_c16;\n #endif\n+typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_1) gfc_array_l1;\n+typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_2) gfc_array_l2;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_4) gfc_array_l4;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_8) gfc_array_l8;\n #ifdef HAVE_GFC_LOGICAL_16"}, {"sha": "720a4c05851ce917e03454b554a6149c840192d7", "filename": "libgfortran/m4/iforeach.m4", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fm4%2Fiforeach.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fm4%2Fiforeach.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fiforeach.m4?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -106,13 +106,13 @@ define(FINISH_FOREACH_FUNCTION,\n define(START_MASKED_FOREACH_FUNCTION,\n `\n extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict, \n-\tatype * const restrict, gfc_array_l4 * const restrict);\n+\tatype * const restrict, gfc_array_l1 * const restrict);\n export_proto(`m'name`'rtype_qual`_'atype_code);\n \n void\n `m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n \tatype * const restrict array,\n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -121,9 +121,10 @@ void\n   index_type dstride;\n   rtype_name *dest;\n   const atype_name *base;\n-  GFC_LOGICAL_4 *mbase;\n+  GFC_LOGICAL_1 *mbase;\n   int rank;\n   index_type n;\n+  int mask_kind;\n \n   rank = GFC_DESCRIPTOR_RANK (array);\n   if (rank <= 0)\n@@ -147,12 +148,25 @@ void\n         runtime_error (\"dimension of return array incorrect\");\n     }\n \n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->data;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   dstride = retarray->dim[0].stride;\n   dest = retarray->data;\n   for (n = 0; n < rank; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n       count[n] = 0;\n       if (extent[n] <= 0)\n@@ -165,17 +179,6 @@ void\n     }\n \n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n-\n \n   /* Initialize the return value.  */\n   for (n = 0; n < rank; n++)"}, {"sha": "d8a661c2a8908c6f169c443a60d41e8951669240", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -166,14 +166,14 @@ define(START_MASKED_ARRAY_FUNCTION,\n `\n extern void `m'name`'rtype_qual`_'atype_code (rtype * const restrict, \n \tatype * const restrict, const index_type * const restrict,\n-\tgfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict);\n export_proto(`m'name`'rtype_qual`_'atype_code);\n \n void\n `m'name`'rtype_qual`_'atype_code (rtype * const restrict retarray, \n \tatype * const restrict array, \n \tconst index_type * const restrict pdim, \n-\tgfc_array_l4 * const restrict mask)\n+\tgfc_array_l1 * const restrict mask)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -182,27 +182,42 @@ void\n   index_type mstride[GFC_MAX_DIMENSIONS];\n   rtype_name * restrict dest;\n   const atype_name * restrict base;\n-  const GFC_LOGICAL_4 * restrict mbase;\n+  const GFC_LOGICAL_1 * restrict mbase;\n   int rank;\n   int dim;\n   index_type n;\n   index_type len;\n   index_type delta;\n   index_type mdelta;\n+  int mask_kind;\n \n   dim = (*pdim) - 1;\n   rank = GFC_DESCRIPTOR_RANK (array) - 1;\n \n   len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n   if (len <= 0)\n     return;\n+\n+  mbase = mask->data;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n   delta = array->dim[dim].stride;\n-  mdelta = mask->dim[dim].stride;\n+  mdelta = mask->dim[dim].stride * mask_kind;\n \n   for (n = 0; n < dim; n++)\n     {\n       sstride[n] = array->dim[n].stride;\n-      mstride[n] = mask->dim[n].stride;\n+      mstride[n] = mask->dim[n].stride * mask_kind;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n \n       if (extent[n] < 0)\n@@ -212,7 +227,7 @@ void\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n-      mstride[n] = mask->dim[n + 1].stride;\n+      mstride[n] = mask->dim[n + 1].stride * mask_kind;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n \n@@ -267,22 +282,11 @@ void\n \n   dest = retarray->data;\n   base = array->data;\n-  mbase = mask->data;\n-\n-  if (GFC_DESCRIPTOR_SIZE (mask) != 4)\n-    {\n-      /* This allows the same loop to be used for all logical types.  */\n-      assert (GFC_DESCRIPTOR_SIZE (mask) == 8);\n-      for (n = 0; n < rank; n++)\n-        mstride[n] <<= 1;\n-      mdelta <<= 1;\n-      mbase = (GFOR_POINTER_L8_TO_L4 (mbase));\n-    }\n \n   while (base)\n     {\n       const atype_name * restrict src;\n-      const GFC_LOGICAL_4 * restrict msrc;\n+      const GFC_LOGICAL_1 * restrict msrc;\n       rtype_name result;\n       src = base;\n       msrc = mbase;"}, {"sha": "4e999fc34da67a269c5e65f478a308f1e9a9dd89", "filename": "libgfortran/m4/matmull.m4", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fm4%2Fmatmull.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28dc6b33c4b8bfbd36866e084e2263ef384c1bbc/libgfortran%2Fm4%2Fmatmull.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmull.m4?ref=28dc6b33c4b8bfbd36866e084e2263ef384c1bbc", "patch": "@@ -40,15 +40,15 @@ include(iparm.m4)dnl\n    Either a or b can be rank 1.  In this case x or y is 1.  */\n \n extern void matmul_'rtype_code` ('rtype` * const restrict, \n-\tgfc_array_l4 * const restrict, gfc_array_l4 * const restrict);\n+\tgfc_array_l1 * const restrict, gfc_array_l1 * const restrict);\n export_proto(matmul_'rtype_code`);\n \n void\n matmul_'rtype_code` ('rtype` * const restrict retarray, \n-\tgfc_array_l4 * const restrict a, gfc_array_l4 * const restrict b)\n+\tgfc_array_l1 * const restrict a, gfc_array_l1 * const restrict b)\n {\n-  const GFC_INTEGER_4 * restrict abase;\n-  const GFC_INTEGER_4 * restrict bbase;\n+  const GFC_LOGICAL_1 * restrict abase;\n+  const GFC_LOGICAL_1 * restrict bbase;\n   'rtype_name` * restrict dest;\n   index_type rxstride;\n   index_type rystride;\n@@ -58,9 +58,11 @@ matmul_'rtype_code` ('rtype` * const restrict retarray,\n   index_type ystride;\n   index_type x;\n   index_type y;\n+  int a_kind;\n+  int b_kind;\n \n-  const GFC_INTEGER_4 * restrict pa;\n-  const GFC_INTEGER_4 * restrict pb;\n+  const GFC_LOGICAL_1 * restrict pa;\n+  const GFC_LOGICAL_1 * restrict pb;\n   index_type astride;\n   index_type bstride;\n   index_type count;\n@@ -100,17 +102,29 @@ matmul_'rtype_code` ('rtype` * const restrict retarray,\n     }\n \n   abase = a->data;\n-  if (GFC_DESCRIPTOR_SIZE (a) != 4)\n-    {\n-      assert (GFC_DESCRIPTOR_SIZE (a) == 8);\n-      abase = GFOR_POINTER_L8_TO_L4 (abase);\n-    }\n+  a_kind = GFC_DESCRIPTOR_SIZE (a);\n+\n+  if (a_kind == 1 || a_kind == 2 || a_kind == 4 || a_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+     || a_kind == 16\n+#endif\n+     )\n+    abase = GFOR_POINTER_TO_L1 (abase, a_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n   bbase = b->data;\n-  if (GFC_DESCRIPTOR_SIZE (b) != 4)\n-    {\n-      assert (GFC_DESCRIPTOR_SIZE (b) == 8);\n-      bbase = GFOR_POINTER_L8_TO_L4 (bbase);\n-    }\n+  b_kind = GFC_DESCRIPTOR_SIZE (b);\n+\n+  if (b_kind == 1 || b_kind == 2 || b_kind == 4 || b_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+     || b_kind == 16\n+#endif\n+     )\n+    bbase = GFOR_POINTER_TO_L1 (bbase, b_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n   dest = retarray->data;\n '\n sinclude(`matmul_asm_'rtype_code`.m4')dnl\n@@ -130,30 +144,30 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n      one.  */\n   if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n-      astride = a->dim[0].stride;\n+      astride = a->dim[0].stride * a_kind;\n       count = a->dim[0].ubound + 1 - a->dim[0].lbound;\n       xstride = 0;\n       rxstride = 0;\n       xcount = 1;\n     }\n   else\n     {\n-      astride = a->dim[1].stride;\n+      astride = a->dim[1].stride * a_kind;\n       count = a->dim[1].ubound + 1 - a->dim[1].lbound;\n       xstride = a->dim[0].stride;\n       xcount = a->dim[0].ubound + 1 - a->dim[0].lbound;\n     }\n   if (GFC_DESCRIPTOR_RANK (b) == 1)\n     {\n-      bstride = b->dim[0].stride;\n+      bstride = b->dim[0].stride * b_kind;\n       assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n       ystride = 0;\n       rystride = 0;\n       ycount = 1;\n     }\n   else\n     {\n-      bstride = b->dim[0].stride;\n+      bstride = b->dim[0].stride * b_kind;\n       assert(count == b->dim[0].ubound + 1 - b->dim[0].lbound);\n       ystride = b->dim[1].stride;\n       ycount = b->dim[1].ubound + 1 - b->dim[1].lbound;\n@@ -191,4 +205,4 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n }\n \n #endif\n-'\n\\ No newline at end of file\n+'"}]}