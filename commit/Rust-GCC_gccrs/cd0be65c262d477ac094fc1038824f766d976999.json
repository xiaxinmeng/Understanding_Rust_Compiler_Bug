{"sha": "cd0be65c262d477ac094fc1038824f766d976999", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwYmU2NWMyNjJkNDc3YWMwOTRmYzEwMzg4MjRmNzY2ZDk3Njk5OQ==", "commit": {"author": {"name": "Wei Mi", "email": "wmi@google.com", "date": "2012-11-22T22:03:11Z"}, "committer": {"name": "Wei Mi", "email": "wmi@gcc.gnu.org", "date": "2012-11-22T22:03:11Z"}, "message": "tsan: New directory.\n\nlibsanitizer/\n\t* tsan: New directory. Import tsan runtime from llvm.\n\t* configure.ac: Add 64 bits tsan build.\n\t* Makefile.am: Likewise.\n\t* configure: Regenerated.\n\t* Makefile.in: Likewise.\n\nFrom-SVN: r193737", "tree": {"sha": "f83ad11b95452b47f813e942d24914f31a50394e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f83ad11b95452b47f813e942d24914f31a50394e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd0be65c262d477ac094fc1038824f766d976999", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0be65c262d477ac094fc1038824f766d976999", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd0be65c262d477ac094fc1038824f766d976999", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0be65c262d477ac094fc1038824f766d976999/comments", "author": {"login": "wmi-11", "id": 59629650, "node_id": "MDQ6VXNlcjU5NjI5NjUw", "avatar_url": "https://avatars.githubusercontent.com/u/59629650?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wmi-11", "html_url": "https://github.com/wmi-11", "followers_url": "https://api.github.com/users/wmi-11/followers", "following_url": "https://api.github.com/users/wmi-11/following{/other_user}", "gists_url": "https://api.github.com/users/wmi-11/gists{/gist_id}", "starred_url": "https://api.github.com/users/wmi-11/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wmi-11/subscriptions", "organizations_url": "https://api.github.com/users/wmi-11/orgs", "repos_url": "https://api.github.com/users/wmi-11/repos", "events_url": "https://api.github.com/users/wmi-11/events{/privacy}", "received_events_url": "https://api.github.com/users/wmi-11/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "32b4b7f53e341be663438f69fd6cb2f909427188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b4b7f53e341be663438f69fd6cb2f909427188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32b4b7f53e341be663438f69fd6cb2f909427188"}], "stats": {"total": 9665, "additions": 9661, "deletions": 4}, "files": [{"sha": "3d6bde32c4937c0cc0e0b19d7e330480c64bc553", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -1,3 +1,11 @@\n+2012-11-22  Wei Mi  <wmi@google.com>\n+\n+\t* tsan: New directory. Import tsan runtime from llvm.\n+\t* configure.ac: Add 64 bits tsan build.\n+\t* Makefile.am: Likewise.\n+\t* configure: Regenerated.\n+\t* Makefile.in: Likewise.\n+\n 2012-11-21  Kostya Serebryany  <kcc@google.com>\n \n         * README.gcc: Extend the README.gcc with mode details."}, {"sha": "d2192b2d38f02987135e646b22d3eefc44c0bc4f", "filename": "libsanitizer/Makefile.am", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.am?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -1,6 +1,10 @@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n \n+if MULTISUBDIR32 \n SUBDIRS = interception sanitizer_common asan \n+else\n+SUBDIRS = interception sanitizer_common asan tsan \n+endif\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "09eb6e2897afbfaf0c747c8e6bdfeb5b5a17a31e", "filename": "libsanitizer/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.in?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -78,7 +78,7 @@ AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n \tdistdir dist dist-all distcheck\n ETAGS = etags\n CTAGS = ctags\n-DIST_SUBDIRS = $(SUBDIRS)\n+DIST_SUBDIRS = interception sanitizer_common asan tsan\n DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n distdir = $(PACKAGE)-$(VERSION)\n top_distdir = $(distdir)\n@@ -244,7 +244,8 @@ top_build_prefix = @top_build_prefix@\n top_builddir = @top_builddir@\n top_srcdir = @top_srcdir@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n-SUBDIRS = interception sanitizer_common asan \n+@MULTISUBDIR32_FALSE@SUBDIRS = interception sanitizer_common asan tsan \n+@MULTISUBDIR32_TRUE@SUBDIRS = interception sanitizer_common asan \n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "519b1db893256576329c188b51730951b8da6058", "filename": "libsanitizer/configure", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -604,6 +604,8 @@ ac_subst_vars='am__EXEEXT_FALSE\n am__EXEEXT_TRUE\n LTLIBOBJS\n LIBOBJS\n+MULTISUBDIR32_FALSE\n+MULTISUBDIR32_TRUE\n enable_static\n enable_shared\n CXXCPP\n@@ -10898,7 +10900,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10901 \"configure\"\n+#line 10903 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11004,7 +11006,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11007 \"configure\"\n+#line 11009 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -14266,13 +14268,26 @@ if test \"${multilib}\" = \"yes\"; then\n else\n   multilib_arg=\n fi\n+ if test \"x$with_multisubdir\" = \"x32\"; then\n+  MULTISUBDIR32_TRUE=\n+  MULTISUBDIR32_FALSE='#'\n+else\n+  MULTISUBDIR32_TRUE='#'\n+  MULTISUBDIR32_FALSE=\n+fi\n+\n \n ac_config_files=\"$ac_config_files Makefile\"\n \n \n ac_config_files=\"$ac_config_files interception/Makefile sanitizer_common/Makefile asan/Makefile\"\n \n \n+if test \"x$with_multisubdir\" != \"x32\"; then\n+  ac_config_files=\"$ac_config_files tsan/Makefile\"\n+\n+fi\n+\n cat >confcache <<\\_ACEOF\n # This file is a shell script that caches the results of configure\n # tests run on this system so they can be shared between configure\n@@ -14434,6 +14449,10 @@ if test -z \"${am__fastdepCCAS_TRUE}\" && test -z \"${am__fastdepCCAS_FALSE}\"; then\n   as_fn_error \"conditional \\\"am__fastdepCCAS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${MULTISUBDIR32_TRUE}\" && test -z \"${MULTISUBDIR32_FALSE}\"; then\n+  as_fn_error \"conditional \\\"MULTISUBDIR32\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n \n : ${CONFIG_STATUS=./config.status}\n ac_write_fail=0\n@@ -15388,6 +15407,7 @@ do\n     \"interception/Makefile\") CONFIG_FILES=\"$CONFIG_FILES interception/Makefile\" ;;\n     \"sanitizer_common/Makefile\") CONFIG_FILES=\"$CONFIG_FILES sanitizer_common/Makefile\" ;;\n     \"asan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES asan/Makefile\" ;;\n+    \"tsan/Makefile\") CONFIG_FILES=\"$CONFIG_FILES tsan/Makefile\" ;;\n \n   *) as_fn_error \"invalid argument: \\`$ac_config_target'\" \"$LINENO\" 5;;\n   esac\n@@ -16752,6 +16772,17 @@ _EOF\n    . ${multi_basedir}/config-ml.in\n    { ml_norecursion=; unset ml_norecursion;}\n  ;;\n+    \"tsan/Makefile\":F) cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+    sed -f vpsed$$ $ac_file > tmp$$\n+    mv tmp$$ $ac_file\n+    rm vpsed$$\n+    echo 'MULTISUBDIR =' >> $ac_file\n+    ml_norecursion=yes\n+    . ${multi_basedir}/config-ml.in\n+    { ml_norecursion=; unset ml_norecursion;}\n+ ;;\n \n   esac\n done # for ac_tag"}, {"sha": "0f9e185aa2a92c249e7befd22c2b91cdd744caa6", "filename": "libsanitizer/configure.ac", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.ac?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -72,6 +72,7 @@ if test \"${multilib}\" = \"yes\"; then\n else\n   multilib_arg=\n fi\n+AM_CONDITIONAL(MULTISUBDIR32, [test \"x$with_multisubdir\" = \"x32\"])\n \n AC_CONFIG_FILES([Makefile])\n \n@@ -88,4 +89,19 @@ _EOF\n    AS_UNSET([ml_norecursion])\n ])\n \n+if test \"x$with_multisubdir\" != \"x32\"; then\n+  AC_CONFIG_FILES(AC_FOREACH([DIR], [tsan], [DIR/Makefile ]), \n+    [cat > vpsed$$ << \\_EOF\n+s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+    sed -f vpsed$$ $ac_file > tmp$$\n+    mv tmp$$ $ac_file\n+    rm vpsed$$\n+    echo 'MULTISUBDIR =' >> $ac_file\n+    ml_norecursion=yes\n+    . ${multi_basedir}/config-ml.in\n+    AS_UNSET([ml_norecursion])\n+])\n+fi\n+\n AC_OUTPUT"}, {"sha": "96b4fab8244f47f2424301f26b5256b1858ef9f5", "filename": "libsanitizer/tsan/Makefile.am", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,80 @@\n+AM_CPPFLAGS = -I $(top_srcdir) -I $(top_srcdir)/include\n+\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n+ACLOCAL_AMFLAGS = -I m4\n+\n+toolexeclib_LTLIBRARIES = libtsan.la\n+\n+tsan_files = \\\n+        tsan_clock.cc \\\n+        tsan_interface_atomic.cc \\\n+        tsan_mutex.cc \\\n+        tsan_report.cc \\\n+        tsan_rtl_thread.cc \\\n+        tsan_symbolize.cc \\\n+        tsan_flags.cc \\\n+        tsan_interface.cc \\\n+        tsan_platform_linux.cc \\\n+        tsan_rtl.cc \\\n+        tsan_stat.cc \\\n+        tsan_sync.cc \\\n+        tsan_interceptors.cc \\\n+        tsan_md5.cc \\\n+        tsan_platform_mac.cc \\\n+        tsan_rtl_mutex.cc \\\n+        tsan_suppressions.cc \\\n+        tsan_interface_ann.cc \\\n+        tsan_mman.cc \\\n+        tsan_printf.cc \\\n+        tsan_rtl_report.cc \\\n+        tsan_symbolize_addr2line_linux.cc\n+\n+libtsan_la_SOURCES = $(tsan_files) \n+libtsan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+libtsan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES=\n+\n+## ################################################################\n+"}, {"sha": "71439d601aaa051003edc0883e788c8b214b6b96", "filename": "libsanitizer/tsan/Makefile.in", "status": "added", "additions": 641, "deletions": 0, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,641 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+subdir = tsan\n+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n+\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n+\t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../libtool.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libtsan_la_DEPENDENCIES =  \\\n+\t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+\t$(top_builddir)/interception/libinterception.la \\\n+\t$(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+am__objects_1 = tsan_clock.lo tsan_interface_atomic.lo tsan_mutex.lo \\\n+\ttsan_report.lo tsan_rtl_thread.lo tsan_symbolize.lo \\\n+\ttsan_flags.lo tsan_interface.lo tsan_platform_linux.lo \\\n+\ttsan_rtl.lo tsan_stat.lo tsan_sync.lo tsan_interceptors.lo \\\n+\ttsan_md5.lo tsan_platform_mac.lo tsan_rtl_mutex.lo \\\n+\ttsan_suppressions.lo tsan_interface_ann.lo tsan_mman.lo \\\n+\ttsan_printf.lo tsan_rtl_report.lo \\\n+\ttsan_symbolize_addr2line_linux.lo\n+am_libtsan_la_OBJECTS = $(am__objects_1)\n+libtsan_la_OBJECTS = $(am_libtsan_la_OBJECTS)\n+libtsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libtsan_la_LDFLAGS) $(LDFLAGS) -o $@\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libtsan_la_SOURCES)\n+DIST_SOURCES = $(libtsan_la_SOURCES)\n+ETAGS = etags\n+CTAGS = ctags\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+RANLIB = @RANLIB@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AM_CPPFLAGS = -I $(top_srcdir) -I $(top_srcdir)/include\n+AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n+ACLOCAL_AMFLAGS = -I m4\n+toolexeclib_LTLIBRARIES = libtsan.la\n+tsan_files = \\\n+        tsan_clock.cc \\\n+        tsan_interface_atomic.cc \\\n+        tsan_mutex.cc \\\n+        tsan_report.cc \\\n+        tsan_rtl_thread.cc \\\n+        tsan_symbolize.cc \\\n+        tsan_flags.cc \\\n+        tsan_interface.cc \\\n+        tsan_platform_linux.cc \\\n+        tsan_rtl.cc \\\n+        tsan_stat.cc \\\n+        tsan_sync.cc \\\n+        tsan_interceptors.cc \\\n+        tsan_md5.cc \\\n+        tsan_platform_mac.cc \\\n+        tsan_rtl_mutex.cc \\\n+        tsan_suppressions.cc \\\n+        tsan_interface_ann.cc \\\n+        tsan_mman.cc \\\n+        tsan_printf.cc \\\n+        tsan_rtl_report.cc \\\n+        tsan_symbolize_addr2line_linux.cc\n+\n+libtsan_la_SOURCES = $(tsan_files) \n+libtsan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+libtsan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n+\n+# Work around what appears to be a GNU make bug handling MAKEFLAGS\n+# values defined in terms of make variables, as is the case for CC and\n+# friends when we are called from the top level Makefile.\n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"CC=$(CC)\" \\\n+\t\"CXX=$(CXX)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"DESTDIR=$(DESTDIR)\"\n+\n+MAKEOVERRIDES = \n+all: all-am\n+\n+.SUFFIXES:\n+.SUFFIXES: .cc .lo .o .obj\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign tsan/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign tsan/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libtsan.la: $(libtsan_la_OBJECTS) $(libtsan_la_DEPENDENCIES) \n+\t$(libtsan_la_LINK) -rpath $(toolexeclibdir) $(libtsan_la_OBJECTS) $(libtsan_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_clock.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_flags.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interceptors.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface_ann.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface_atomic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_md5.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_mman.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_mutex.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_platform_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_platform_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_printf.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_report.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_mutex.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_report.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_thread.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_stat.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_suppressions.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_symbolize.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_symbolize_addr2line_linux.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_sync.Plo@am__quote@\n+\n+.cc.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+check-am: all-am\n+check: check-am\n+all-am: Makefile $(LTLIBRARIES)\n+installdirs:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-tags\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am: install-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am: uninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: install-am install-strip\n+\n+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \\\n+\tclean-libtool clean-toolexeclibLTLIBRARIES ctags distclean \\\n+\tdistclean-compile distclean-generic distclean-libtool \\\n+\tdistclean-tags distdir dvi dvi-am html html-am info info-am \\\n+\tinstall install-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip install-toolexeclibLTLIBRARIES installcheck \\\n+\tinstallcheck-am installdirs maintainer-clean \\\n+\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\ttags uninstall uninstall-am uninstall-toolexeclibLTLIBRARIES\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "204fdd2d8e5fe21a5a9f9e23d6a6cf17d353362a", "filename": "libsanitizer/tsan/libtool-version", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Flibtool-version?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,6 @@\n+# This file is used to maintain libtool version info for libmudflap.  See\n+# the libtool manual to understand the meaning of the fields.  This is\n+# a separate file so that version updates don't involve re-running\n+# automake.\n+# CURRENT:REVISION:AGE\n+0:0:0"}, {"sha": "937f861477fa3f1bfe675033978f4f96c0a29a36", "filename": "libsanitizer/tsan/tsan_clock.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_clock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_clock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,116 @@\n+//===-- tsan_clock.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"tsan_clock.h\"\n+#include \"tsan_rtl.h\"\n+\n+// It's possible to optimize clock operations for some important cases\n+// so that they are O(1). The cases include singletons, once's, local mutexes.\n+// First, SyncClock must be re-implemented to allow indexing by tid.\n+// It must not necessarily be a full vector clock, though. For example it may\n+// be a multi-level table.\n+// Then, each slot in SyncClock must contain a dirty bit (it's united with\n+// the clock value, so no space increase). The acquire algorithm looks\n+// as follows:\n+// void acquire(thr, tid, thr_clock, sync_clock) {\n+//   if (!sync_clock[tid].dirty)\n+//     return;  // No new info to acquire.\n+//              // This handles constant reads of singleton pointers and\n+//              // stop-flags.\n+//   acquire_impl(thr_clock, sync_clock);  // As usual, O(N).\n+//   sync_clock[tid].dirty = false;\n+//   sync_clock.dirty_count--;\n+// }\n+// The release operation looks as follows:\n+// void release(thr, tid, thr_clock, sync_clock) {\n+//   // thr->sync_cache is a simple fixed-size hash-based cache that holds\n+//   // several previous sync_clock's.\n+//   if (thr->sync_cache[sync_clock] >= thr->last_acquire_epoch) {\n+//     // The thread did no acquire operations since last release on this clock.\n+//     // So update only the thread's slot (other slots can't possibly change).\n+//     sync_clock[tid].clock = thr->epoch;\n+//     if (sync_clock.dirty_count == sync_clock.cnt\n+//         || (sync_clock.dirty_count == sync_clock.cnt - 1\n+//           && sync_clock[tid].dirty == false))\n+//       // All dirty flags are set, bail out.\n+//       return;\n+//     set all dirty bits, but preserve the thread's bit.  // O(N)\n+//     update sync_clock.dirty_count;\n+//     return;\n+//   }\n+//   release_impl(thr_clock, sync_clock);  // As usual, O(N).\n+//   set all dirty bits, but preserve the thread's bit.\n+//   // The previous step is combined with release_impl(), so that\n+//   // we scan the arrays only once.\n+//   update sync_clock.dirty_count;\n+// }\n+\n+namespace __tsan {\n+\n+ThreadClock::ThreadClock() {\n+  nclk_ = 0;\n+  for (uptr i = 0; i < (uptr)kMaxTidInClock; i++)\n+    clk_[i] = 0;\n+}\n+\n+void ThreadClock::acquire(const SyncClock *src) {\n+  DCHECK(nclk_ <= kMaxTid);\n+  DCHECK(src->clk_.Size() <= kMaxTid);\n+\n+  const uptr nclk = src->clk_.Size();\n+  if (nclk == 0)\n+    return;\n+  nclk_ = max(nclk_, nclk);\n+  for (uptr i = 0; i < nclk; i++) {\n+    if (clk_[i] < src->clk_[i])\n+      clk_[i] = src->clk_[i];\n+  }\n+}\n+\n+void ThreadClock::release(SyncClock *dst) const {\n+  DCHECK(nclk_ <= kMaxTid);\n+  DCHECK(dst->clk_.Size() <= kMaxTid);\n+\n+  if (dst->clk_.Size() < nclk_)\n+    dst->clk_.Resize(nclk_);\n+  for (uptr i = 0; i < nclk_; i++) {\n+    if (dst->clk_[i] < clk_[i])\n+      dst->clk_[i] = clk_[i];\n+  }\n+}\n+\n+void ThreadClock::ReleaseStore(SyncClock *dst) const {\n+  DCHECK(nclk_ <= kMaxTid);\n+  DCHECK(dst->clk_.Size() <= kMaxTid);\n+\n+  if (dst->clk_.Size() < nclk_)\n+    dst->clk_.Resize(nclk_);\n+  for (uptr i = 0; i < nclk_; i++)\n+    dst->clk_[i] = clk_[i];\n+  for (uptr i = nclk_; i < dst->clk_.Size(); i++)\n+    dst->clk_[i] = 0;\n+}\n+\n+void ThreadClock::acq_rel(SyncClock *dst) {\n+  acquire(dst);\n+  release(dst);\n+}\n+\n+void ThreadClock::Disable(unsigned tid) {\n+  u64 c0 = clk_[tid];\n+  for (uptr i = 0; i < kMaxTidInClock; i++)\n+    clk_[i] = (u64)-1;\n+  clk_[tid] = c0;\n+}\n+\n+SyncClock::SyncClock()\n+  : clk_(MBlockClock) {\n+}\n+}  // namespace __tsan"}, {"sha": "d5c17305b315d4f442794f960bae305977202f72", "filename": "libsanitizer/tsan/tsan_clock.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_clock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_clock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,80 @@\n+//===-- tsan_clock.h --------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_CLOCK_H\n+#define TSAN_CLOCK_H\n+\n+#include \"tsan_defs.h\"\n+#include \"tsan_vector.h\"\n+\n+namespace __tsan {\n+\n+// The clock that lives in sync variables (mutexes, atomics, etc).\n+class SyncClock {\n+ public:\n+  SyncClock();\n+\n+  uptr size() const {\n+    return clk_.Size();\n+  }\n+\n+  void Reset() {\n+    clk_.Reset();\n+  }\n+\n+ private:\n+  Vector<u64> clk_;\n+  friend struct ThreadClock;\n+};\n+\n+// The clock that lives in threads.\n+struct ThreadClock {\n+ public:\n+  ThreadClock();\n+\n+  u64 get(unsigned tid) const {\n+    DCHECK_LT(tid, kMaxTidInClock);\n+    return clk_[tid];\n+  }\n+\n+  void set(unsigned tid, u64 v) {\n+    DCHECK_LT(tid, kMaxTid);\n+    DCHECK_GE(v, clk_[tid]);\n+    clk_[tid] = v;\n+    if (nclk_ <= tid)\n+      nclk_ = tid + 1;\n+  }\n+\n+  void tick(unsigned tid) {\n+    DCHECK_LT(tid, kMaxTid);\n+    clk_[tid]++;\n+    if (nclk_ <= tid)\n+      nclk_ = tid + 1;\n+  }\n+\n+  void Disable(unsigned tid);\n+\n+  uptr size() const {\n+    return nclk_;\n+  }\n+\n+  void acquire(const SyncClock *src);\n+  void release(SyncClock *dst) const;\n+  void acq_rel(SyncClock *dst);\n+  void ReleaseStore(SyncClock *dst) const;\n+\n+ private:\n+  uptr nclk_;\n+  u64 clk_[kMaxTidInClock];\n+};\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_CLOCK_H"}, {"sha": "6a6f6b9783270750d3d9444699c7528062f2a8b9", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,139 @@\n+//===-- tsan_defs.h ---------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef TSAN_DEFS_H\n+#define TSAN_DEFS_H\n+\n+#include \"sanitizer_common/sanitizer_internal_defs.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"tsan_stat.h\"\n+\n+#ifndef TSAN_DEBUG\n+#define TSAN_DEBUG 0\n+#endif  // TSAN_DEBUG\n+\n+namespace __tsan {\n+\n+const int kTidBits = 13;\n+const unsigned kMaxTid = 1 << kTidBits;\n+const unsigned kMaxTidInClock = kMaxTid * 2;  // This includes msb 'freed' bit.\n+const int kClkBits = 43;\n+#ifndef TSAN_GO\n+const int kShadowStackSize = 4 * 1024;\n+const int kTraceStackSize = 256;\n+#endif\n+\n+#ifdef TSAN_SHADOW_COUNT\n+# if TSAN_SHADOW_COUNT == 2 \\\n+  || TSAN_SHADOW_COUNT == 4 || TSAN_SHADOW_COUNT == 8\n+const unsigned kShadowCnt = TSAN_SHADOW_COUNT;\n+# else\n+#   error \"TSAN_SHADOW_COUNT must be one of 2,4,8\"\n+# endif\n+#else\n+// Count of shadow values in a shadow cell.\n+const unsigned kShadowCnt = 8;\n+#endif\n+\n+// That many user bytes are mapped onto a single shadow cell.\n+const unsigned kShadowCell = 8;\n+\n+// Size of a single shadow value (u64).\n+const unsigned kShadowSize = 8;\n+\n+#if defined(TSAN_COLLECT_STATS) && TSAN_COLLECT_STATS\n+const bool kCollectStats = true;\n+#else\n+const bool kCollectStats = false;\n+#endif\n+\n+// The following \"build consistency\" machinery ensures that all source files\n+// are built in the same configuration. Inconsistent builds lead to\n+// hard to debug crashes.\n+#if TSAN_DEBUG\n+void build_consistency_debug();\n+#else\n+void build_consistency_release();\n+#endif\n+\n+#if TSAN_COLLECT_STATS\n+void build_consistency_stats();\n+#else\n+void build_consistency_nostats();\n+#endif\n+\n+#if TSAN_SHADOW_COUNT == 1\n+void build_consistency_shadow1();\n+#elif TSAN_SHADOW_COUNT == 2\n+void build_consistency_shadow2();\n+#elif TSAN_SHADOW_COUNT == 4\n+void build_consistency_shadow4();\n+#else\n+void build_consistency_shadow8();\n+#endif\n+\n+static inline void USED build_consistency() {\n+#if TSAN_DEBUG\n+  build_consistency_debug();\n+#else\n+  build_consistency_release();\n+#endif\n+#if TSAN_COLLECT_STATS\n+  build_consistency_stats();\n+#else\n+  build_consistency_nostats();\n+#endif\n+#if TSAN_SHADOW_COUNT == 1\n+  build_consistency_shadow1();\n+#elif TSAN_SHADOW_COUNT == 2\n+  build_consistency_shadow2();\n+#elif TSAN_SHADOW_COUNT == 4\n+  build_consistency_shadow4();\n+#else\n+  build_consistency_shadow8();\n+#endif\n+}\n+\n+template<typename T>\n+T min(T a, T b) {\n+  return a < b ? a : b;\n+}\n+\n+template<typename T>\n+T max(T a, T b) {\n+  return a > b ? a : b;\n+}\n+\n+template<typename T>\n+T RoundUp(T p, int align) {\n+  DCHECK_EQ(align & (align - 1), 0);\n+  return (T)(((u64)p + align - 1) & ~(align - 1));\n+}\n+\n+struct MD5Hash {\n+  u64 hash[2];\n+  bool operator==(const MD5Hash &other) const;\n+};\n+\n+MD5Hash md5_hash(const void *data, uptr size);\n+\n+struct ThreadState;\n+struct ThreadContext;\n+struct Context;\n+struct ReportStack;\n+class ReportDesc;\n+class RegionAlloc;\n+class StackTrace;\n+struct MBlock;\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_DEFS_H"}, {"sha": "e8563f5f8770ad46c626af071081f3a055a8c3c9", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,80 @@\n+//===-- tsan_flags.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_flags.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"tsan_flags.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_mman.h\"\n+\n+namespace __tsan {\n+\n+Flags *flags() {\n+  return &CTX()->flags;\n+}\n+\n+// Can be overriden in frontend.\n+#ifdef TSAN_EXTERNAL_HOOKS\n+void OverrideFlags(Flags *f);\n+#else\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void WEAK OverrideFlags(Flags *f) {\n+  (void)f;\n+}\n+#endif\n+\n+void InitializeFlags(Flags *f, const char *env) {\n+  internal_memset(f, 0, sizeof(*f));\n+\n+  // Default values.\n+  f->enable_annotations = true;\n+  f->suppress_equal_stacks = true;\n+  f->suppress_equal_addresses = true;\n+  f->report_thread_leaks = true;\n+  f->report_destroy_locked = true;\n+  f->report_signal_unsafe = true;\n+  f->force_seq_cst_atomics = false;\n+  f->strip_path_prefix = \"\";\n+  f->suppressions = \"\";\n+  f->exitcode = 66;\n+  f->log_fileno = 2;\n+  f->atexit_sleep_ms = 1000;\n+  f->verbosity = 0;\n+  f->profile_memory = \"\";\n+  f->flush_memory_ms = 0;\n+  f->stop_on_start = false;\n+  f->running_on_valgrind = false;\n+  f->external_symbolizer_path = \"\";\n+\n+  // Let a frontend override.\n+  OverrideFlags(f);\n+\n+  // Override from command line.\n+  ParseFlag(env, &f->enable_annotations, \"enable_annotations\");\n+  ParseFlag(env, &f->suppress_equal_stacks, \"suppress_equal_stacks\");\n+  ParseFlag(env, &f->suppress_equal_addresses, \"suppress_equal_addresses\");\n+  ParseFlag(env, &f->report_thread_leaks, \"report_thread_leaks\");\n+  ParseFlag(env, &f->report_destroy_locked, \"report_destroy_locked\");\n+  ParseFlag(env, &f->report_signal_unsafe, \"report_signal_unsafe\");\n+  ParseFlag(env, &f->force_seq_cst_atomics, \"force_seq_cst_atomics\");\n+  ParseFlag(env, &f->strip_path_prefix, \"strip_path_prefix\");\n+  ParseFlag(env, &f->suppressions, \"suppressions\");\n+  ParseFlag(env, &f->exitcode, \"exitcode\");\n+  ParseFlag(env, &f->log_fileno, \"log_fileno\");\n+  ParseFlag(env, &f->atexit_sleep_ms, \"atexit_sleep_ms\");\n+  ParseFlag(env, &f->verbosity, \"verbosity\");\n+  ParseFlag(env, &f->profile_memory, \"profile_memory\");\n+  ParseFlag(env, &f->flush_memory_ms, \"flush_memory_ms\");\n+  ParseFlag(env, &f->stop_on_start, \"stop_on_start\");\n+  ParseFlag(env, &f->external_symbolizer_path, \"external_symbolizer_path\");\n+}\n+\n+}  // namespace __tsan"}, {"sha": "a6310e3ce6cdb2b6078e1ebe5a1748a39c4e96c5", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,71 @@\n+//===-- tsan_flags.h --------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+// NOTE: This file may be included into user code.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef TSAN_FLAGS_H\n+#define TSAN_FLAGS_H\n+\n+// ----------- ATTENTION -------------\n+// ThreadSanitizer user may provide its implementation of weak\n+// symbol __tsan::OverrideFlags(__tsan::Flags). Therefore, this\n+// header may be included in the user code, and shouldn't include\n+// other headers from TSan or common sanitizer runtime.\n+\n+namespace __tsan {\n+\n+struct Flags {\n+  // Enable dynamic annotations, otherwise they are no-ops.\n+  bool enable_annotations;\n+  // Supress a race report if we've already output another race report\n+  // with the same stack.\n+  bool suppress_equal_stacks;\n+  // Supress a race report if we've already output another race report\n+  // on the same address.\n+  bool suppress_equal_addresses;\n+  // Report thread leaks at exit?\n+  bool report_thread_leaks;\n+  // Report destruction of a locked mutex?\n+  bool report_destroy_locked;\n+  // Report violations of async signal-safety\n+  // (e.g. malloc() call from a signal handler).\n+  bool report_signal_unsafe;\n+  // If set, all atomics are effectively sequentially consistent (seq_cst),\n+  // regardless of what user actually specified.\n+  bool force_seq_cst_atomics;\n+  // Strip that prefix from file paths in reports.\n+  const char *strip_path_prefix;\n+  // Suppressions filename.\n+  const char *suppressions;\n+  // Override exit status if something was reported.\n+  int exitcode;\n+  // Log fileno (1 - stdout, 2 - stderr).\n+  int log_fileno;\n+  // Sleep in main thread before exiting for that many ms\n+  // (useful to catch \"at exit\" races).\n+  int atexit_sleep_ms;\n+  // Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\n+  int verbosity;\n+  // If set, periodically write memory profile to that file.\n+  const char *profile_memory;\n+  // Flush shadow memory every X ms.\n+  int flush_memory_ms;\n+  // Stops on start until __tsan_resume() is called (for debugging).\n+  bool stop_on_start;\n+  // Controls whether RunningOnValgrind() returns true or false.\n+  bool running_on_valgrind;\n+  // Path to external symbolizer.\n+  const char *external_symbolizer_path;\n+};\n+\n+Flags *flags();\n+void InitializeFlags(Flags *flags, const char *env);\n+}\n+\n+#endif  // TSAN_FLAGS_H"}, {"sha": "194e236ece7adc9da5f66ec7ec6032d212f42ade", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "added", "additions": 1515, "deletions": 0, "changes": 1515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,1515 @@\n+//===-- tsan_interceptors.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"tsan_interceptors.h\"\n+#include \"tsan_interface.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_mman.h\"\n+\n+using namespace __tsan;  // NOLINT\n+\n+const int kSigCount = 128;\n+\n+struct my_siginfo_t {\n+  int opaque[128];\n+};\n+\n+struct sigset_t {\n+  u64 val[1024 / 8 / sizeof(u64)];\n+};\n+\n+struct ucontext_t {\n+  uptr opaque[117];\n+};\n+\n+extern \"C\" int pthread_attr_init(void *attr);\n+extern \"C\" int pthread_attr_destroy(void *attr);\n+extern \"C\" int pthread_attr_getdetachstate(void *attr, int *v);\n+extern \"C\" int pthread_attr_setstacksize(void *attr, uptr stacksize);\n+extern \"C\" int pthread_attr_getstacksize(void *attr, uptr *stacksize);\n+extern \"C\" int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n+extern \"C\" int pthread_setspecific(unsigned key, const void *v);\n+extern \"C\" int pthread_mutexattr_gettype(void *a, int *type);\n+extern \"C\" int pthread_yield();\n+extern \"C\" int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);\n+extern \"C\" int sigfillset(sigset_t *set);\n+extern \"C\" void *pthread_self();\n+extern \"C\" void _exit(int status);\n+extern \"C\" int __cxa_atexit(void (*func)(void *arg), void *arg, void *dso);\n+extern \"C\" int *__errno_location();\n+const int PTHREAD_MUTEX_RECURSIVE = 1;\n+const int PTHREAD_MUTEX_RECURSIVE_NP = 1;\n+const int kPthreadAttrSize = 56;\n+const int EINVAL = 22;\n+const int EBUSY = 16;\n+const int EPOLL_CTL_ADD = 1;\n+const int SIGILL = 4;\n+const int SIGABRT = 6;\n+const int SIGFPE = 8;\n+const int SIGSEGV = 11;\n+const int SIGPIPE = 13;\n+const int SIGBUS = 7;\n+void *const MAP_FAILED = (void*)-1;\n+const int PTHREAD_BARRIER_SERIAL_THREAD = -1;\n+const int MAP_FIXED = 0x10;\n+typedef long long_t;  // NOLINT\n+\n+// From /usr/include/unistd.h\n+# define F_ULOCK 0      /* Unlock a previously locked region.  */\n+# define F_LOCK  1      /* Lock a region for exclusive use.  */\n+# define F_TLOCK 2      /* Test and lock a region for exclusive use.  */\n+# define F_TEST  3      /* Test a region for other processes locks.  */\n+\n+typedef void (*sighandler_t)(int sig);\n+\n+#define errno (*__errno_location())\n+\n+union pthread_attr_t {\n+  char size[kPthreadAttrSize];\n+  void *align;\n+};\n+\n+struct sigaction_t {\n+  union {\n+    sighandler_t sa_handler;\n+    void (*sa_sigaction)(int sig, my_siginfo_t *siginfo, void *uctx);\n+  };\n+  sigset_t sa_mask;\n+  int sa_flags;\n+  void (*sa_restorer)();\n+};\n+\n+const sighandler_t SIG_DFL = (sighandler_t)0;\n+const sighandler_t SIG_IGN = (sighandler_t)1;\n+const sighandler_t SIG_ERR = (sighandler_t)-1;\n+const int SA_SIGINFO = 4;\n+const int SIG_SETMASK = 2;\n+\n+namespace std {\n+struct nothrow_t {};\n+}  // namespace std\n+\n+static sigaction_t sigactions[kSigCount];\n+\n+namespace __tsan {\n+struct SignalDesc {\n+  bool armed;\n+  bool sigaction;\n+  my_siginfo_t siginfo;\n+  ucontext_t ctx;\n+};\n+\n+struct SignalContext {\n+  int int_signal_send;\n+  int pending_signal_count;\n+  SignalDesc pending_signals[kSigCount];\n+};\n+}\n+\n+static SignalContext *SigCtx(ThreadState *thr) {\n+  SignalContext *ctx = (SignalContext*)thr->signal_ctx;\n+  if (ctx == 0 && thr->is_alive) {\n+    ScopedInRtl in_rtl;\n+    ctx = (SignalContext*)internal_alloc(\n+        MBlockSignal, sizeof(*ctx));\n+    MemoryResetRange(thr, 0, (uptr)ctx, sizeof(*ctx));\n+    internal_memset(ctx, 0, sizeof(*ctx));\n+    thr->signal_ctx = ctx;\n+  }\n+  return ctx;\n+}\n+\n+static unsigned g_thread_finalize_key;\n+\n+static void process_pending_signals(ThreadState *thr);\n+\n+ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n+                                     uptr pc)\n+    : thr_(thr)\n+    , in_rtl_(thr->in_rtl) {\n+  if (thr_->in_rtl == 0) {\n+    Initialize(thr);\n+    FuncEntry(thr, pc);\n+    thr_->in_rtl++;\n+    DPrintf(\"#%d: intercept %s()\\n\", thr_->tid, fname);\n+  } else {\n+    thr_->in_rtl++;\n+  }\n+}\n+\n+ScopedInterceptor::~ScopedInterceptor() {\n+  thr_->in_rtl--;\n+  if (thr_->in_rtl == 0) {\n+    FuncExit(thr_);\n+    process_pending_signals(thr_);\n+  }\n+  CHECK_EQ(in_rtl_, thr_->in_rtl);\n+}\n+\n+TSAN_INTERCEPTOR(unsigned, sleep, unsigned sec) {\n+  SCOPED_TSAN_INTERCEPTOR(sleep, sec);\n+  unsigned res = sleep(sec);\n+  AfterSleep(thr, pc);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, usleep, long_t usec) {\n+  SCOPED_TSAN_INTERCEPTOR(usleep, usec);\n+  int res = usleep(usec);\n+  AfterSleep(thr, pc);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, nanosleep, void *req, void *rem) {\n+  SCOPED_TSAN_INTERCEPTOR(nanosleep, req, rem);\n+  int res = nanosleep(req, rem);\n+  AfterSleep(thr, pc);\n+  return res;\n+}\n+\n+class AtExitContext {\n+ public:\n+  AtExitContext()\n+    : mtx_(MutexTypeAtExit, StatMtxAtExit)\n+    , pos_() {\n+  }\n+\n+  typedef void(*atexit_t)();\n+\n+  int atexit(ThreadState *thr, uptr pc, atexit_t f) {\n+    Lock l(&mtx_);\n+    if (pos_ == kMaxAtExit)\n+      return 1;\n+    Release(thr, pc, (uptr)this);\n+    stack_[pos_] = f;\n+    pos_++;\n+    return 0;\n+  }\n+\n+  void exit(ThreadState *thr, uptr pc) {\n+    CHECK_EQ(thr->in_rtl, 0);\n+    for (;;) {\n+      atexit_t f = 0;\n+      {\n+        Lock l(&mtx_);\n+        if (pos_) {\n+          pos_--;\n+          f = stack_[pos_];\n+          ScopedInRtl in_rtl;\n+          Acquire(thr, pc, (uptr)this);\n+        }\n+      }\n+      if (f == 0)\n+        break;\n+      DPrintf(\"#%d: executing atexit func %p\\n\", thr->tid, f);\n+      CHECK_EQ(thr->in_rtl, 0);\n+      f();\n+    }\n+  }\n+\n+ private:\n+  static const int kMaxAtExit = 128;\n+  Mutex mtx_;\n+  atexit_t stack_[kMaxAtExit];\n+  int pos_;\n+};\n+\n+static AtExitContext *atexit_ctx;\n+\n+static void finalize(void *arg) {\n+  ThreadState * thr = cur_thread();\n+  uptr pc = 0;\n+  atexit_ctx->exit(thr, pc);\n+  {\n+    ScopedInRtl in_rtl;\n+    DestroyAndFree(atexit_ctx);\n+    REAL(usleep)(flags()->atexit_sleep_ms * 1000);\n+  }\n+  int status = Finalize(cur_thread());\n+  if (status)\n+    _exit(status);\n+}\n+\n+TSAN_INTERCEPTOR(int, atexit, void (*f)()) {\n+  SCOPED_TSAN_INTERCEPTOR(atexit, f);\n+  return atexit_ctx->atexit(thr, pc, f);\n+  return 0;\n+}\n+\n+TSAN_INTERCEPTOR(void, longjmp, void *env, int val) {\n+  SCOPED_TSAN_INTERCEPTOR(longjmp, env, val);\n+  TsanPrintf(\"ThreadSanitizer: longjmp() is not supported\\n\");\n+  Die();\n+}\n+\n+TSAN_INTERCEPTOR(void, siglongjmp, void *env, int val) {\n+  SCOPED_TSAN_INTERCEPTOR(siglongjmp, env, val);\n+  TsanPrintf(\"ThreadSanitizer: siglongjmp() is not supported\\n\");\n+  Die();\n+}\n+\n+static uptr fd2addr(int fd) {\n+  (void)fd;\n+  static u64 addr;\n+  return (uptr)&addr;\n+}\n+\n+static uptr epollfd2addr(int fd) {\n+  (void)fd;\n+  static u64 addr;\n+  return (uptr)&addr;\n+}\n+\n+static uptr file2addr(char *path) {\n+  (void)path;\n+  static u64 addr;\n+  return (uptr)&addr;\n+}\n+\n+static uptr dir2addr(char *path) {\n+  (void)path;\n+  static u64 addr;\n+  return (uptr)&addr;\n+}\n+\n+TSAN_INTERCEPTOR(void*, malloc, uptr size) {\n+  void *p = 0;\n+  {\n+    SCOPED_INTERCEPTOR_RAW(malloc, size);\n+    p = user_alloc(thr, pc, size);\n+  }\n+  invoke_malloc_hook(p, size);\n+  return p;\n+}\n+\n+TSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {\n+  void *p = 0;\n+  {\n+    SCOPED_INTERCEPTOR_RAW(calloc, size, n);\n+    p = user_alloc(thr, pc, n * size);\n+    if (p) internal_memset(p, 0, n * size);\n+  }\n+  invoke_malloc_hook(p, n * size);\n+  return p;\n+}\n+\n+TSAN_INTERCEPTOR(void*, realloc, void *p, uptr size) {\n+  if (p)\n+    invoke_free_hook(p);\n+  {\n+    SCOPED_INTERCEPTOR_RAW(realloc, p, size);\n+    p = user_realloc(thr, pc, p, size);\n+  }\n+  invoke_malloc_hook(p, size);\n+  return p;\n+}\n+\n+TSAN_INTERCEPTOR(void, free, void *p) {\n+  if (p == 0)\n+    return;\n+  invoke_free_hook(p);\n+  SCOPED_INTERCEPTOR_RAW(free, p);\n+  user_free(thr, pc, p);\n+}\n+\n+TSAN_INTERCEPTOR(void, cfree, void *p) {\n+  if (p == 0)\n+    return;\n+  invoke_free_hook(p);\n+  SCOPED_INTERCEPTOR_RAW(cfree, p);\n+  user_free(thr, pc, p);\n+}\n+\n+#define OPERATOR_NEW_BODY(mangled_name) \\\n+  void *p = 0; \\\n+  {  \\\n+    SCOPED_INTERCEPTOR_RAW(mangled_name, size); \\\n+    p = user_alloc(thr, pc, size); \\\n+  }  \\\n+  invoke_malloc_hook(p, size);  \\\n+  return p;\n+\n+void *operator new(__sanitizer::uptr size) {\n+  OPERATOR_NEW_BODY(_Znwm);\n+}\n+void *operator new[](__sanitizer::uptr size) {\n+  OPERATOR_NEW_BODY(_Znam);\n+}\n+void *operator new(__sanitizer::uptr size, std::nothrow_t const&) {\n+  OPERATOR_NEW_BODY(_ZnwmRKSt9nothrow_t);\n+}\n+void *operator new[](__sanitizer::uptr size, std::nothrow_t const&) {\n+  OPERATOR_NEW_BODY(_ZnamRKSt9nothrow_t);\n+}\n+\n+#define OPERATOR_DELETE_BODY(mangled_name) \\\n+  if (ptr == 0) return;  \\\n+  invoke_free_hook(ptr);  \\\n+  SCOPED_INTERCEPTOR_RAW(mangled_name, ptr);  \\\n+  user_free(thr, pc, ptr);\n+\n+void operator delete(void *ptr) {\n+  OPERATOR_DELETE_BODY(_ZdlPv);\n+}\n+void operator delete[](void *ptr) {\n+  OPERATOR_DELETE_BODY(_ZdlPvRKSt9nothrow_t);\n+}\n+void operator delete(void *ptr, std::nothrow_t const&) {\n+  OPERATOR_DELETE_BODY(_ZdaPv);\n+}\n+void operator delete[](void *ptr, std::nothrow_t const&) {\n+  OPERATOR_DELETE_BODY(_ZdaPvRKSt9nothrow_t);\n+}\n+\n+TSAN_INTERCEPTOR(uptr, strlen, const char *s) {\n+  SCOPED_TSAN_INTERCEPTOR(strlen, s);\n+  uptr len = internal_strlen(s);\n+  MemoryAccessRange(thr, pc, (uptr)s, len + 1, false);\n+  return len;\n+}\n+\n+TSAN_INTERCEPTOR(void*, memset, void *dst, int v, uptr size) {\n+  SCOPED_TSAN_INTERCEPTOR(memset, dst, v, size);\n+  MemoryAccessRange(thr, pc, (uptr)dst, size, true);\n+  return internal_memset(dst, v, size);\n+}\n+\n+TSAN_INTERCEPTOR(void*, memcpy, void *dst, const void *src, uptr size) {\n+  SCOPED_TSAN_INTERCEPTOR(memcpy, dst, src, size);\n+  MemoryAccessRange(thr, pc, (uptr)dst, size, true);\n+  MemoryAccessRange(thr, pc, (uptr)src, size, false);\n+  return internal_memcpy(dst, src, size);\n+}\n+\n+TSAN_INTERCEPTOR(int, memcmp, const void *s1, const void *s2, uptr n) {\n+  SCOPED_TSAN_INTERCEPTOR(memcmp, s1, s2, n);\n+  int res = 0;\n+  uptr len = 0;\n+  for (; len < n; len++) {\n+    if ((res = ((unsigned char*)s1)[len] - ((unsigned char*)s2)[len]))\n+      break;\n+  }\n+  MemoryAccessRange(thr, pc, (uptr)s1, len < n ? len + 1 : n, false);\n+  MemoryAccessRange(thr, pc, (uptr)s2, len < n ? len + 1 : n, false);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n+  SCOPED_TSAN_INTERCEPTOR(strcmp, s1, s2);\n+  uptr len = 0;\n+  for (; s1[len] && s2[len]; len++) {\n+    if (s1[len] != s2[len])\n+      break;\n+  }\n+  MemoryAccessRange(thr, pc, (uptr)s1, len + 1, false);\n+  MemoryAccessRange(thr, pc, (uptr)s2, len + 1, false);\n+  return s1[len] - s2[len];\n+}\n+\n+TSAN_INTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr n) {\n+  SCOPED_TSAN_INTERCEPTOR(strncmp, s1, s2, n);\n+  uptr len = 0;\n+  for (; len < n && s1[len] && s2[len]; len++) {\n+    if (s1[len] != s2[len])\n+      break;\n+  }\n+  MemoryAccessRange(thr, pc, (uptr)s1, len < n ? len + 1 : n, false);\n+  MemoryAccessRange(thr, pc, (uptr)s2, len < n ? len + 1 : n, false);\n+  return len == n ? 0 : s1[len] - s2[len];\n+}\n+\n+TSAN_INTERCEPTOR(void*, memchr, void *s, int c, uptr n) {\n+  SCOPED_TSAN_INTERCEPTOR(memchr, s, c, n);\n+  void *res = REAL(memchr)(s, c, n);\n+  uptr len = res ? (char*)res - (char*)s + 1 : n;\n+  MemoryAccessRange(thr, pc, (uptr)s, len, false);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(void*, memrchr, char *s, int c, uptr n) {\n+  SCOPED_TSAN_INTERCEPTOR(memrchr, s, c, n);\n+  MemoryAccessRange(thr, pc, (uptr)s, n, false);\n+  return REAL(memrchr)(s, c, n);\n+}\n+\n+TSAN_INTERCEPTOR(void*, memmove, void *dst, void *src, uptr n) {\n+  SCOPED_TSAN_INTERCEPTOR(memmove, dst, src, n);\n+  MemoryAccessRange(thr, pc, (uptr)dst, n, true);\n+  MemoryAccessRange(thr, pc, (uptr)src, n, false);\n+  return REAL(memmove)(dst, src, n);\n+}\n+\n+TSAN_INTERCEPTOR(char*, strchr, char *s, int c) {\n+  SCOPED_TSAN_INTERCEPTOR(strchr, s, c);\n+  char *res = REAL(strchr)(s, c);\n+  uptr len = res ? (char*)res - (char*)s + 1 : internal_strlen(s) + 1;\n+  MemoryAccessRange(thr, pc, (uptr)s, len, false);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(char*, strchrnul, char *s, int c) {\n+  SCOPED_TSAN_INTERCEPTOR(strchrnul, s, c);\n+  char *res = REAL(strchrnul)(s, c);\n+  uptr len = (char*)res - (char*)s + 1;\n+  MemoryAccessRange(thr, pc, (uptr)s, len, false);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(char*, strrchr, char *s, int c) {\n+  SCOPED_TSAN_INTERCEPTOR(strrchr, s, c);\n+  MemoryAccessRange(thr, pc, (uptr)s, internal_strlen(s) + 1, false);\n+  return REAL(strrchr)(s, c);\n+}\n+\n+TSAN_INTERCEPTOR(char*, strcpy, char *dst, const char *src) {  // NOLINT\n+  SCOPED_TSAN_INTERCEPTOR(strcpy, dst, src);  // NOLINT\n+  uptr srclen = internal_strlen(src);\n+  MemoryAccessRange(thr, pc, (uptr)dst, srclen + 1, true);\n+  MemoryAccessRange(thr, pc, (uptr)src, srclen + 1, false);\n+  return REAL(strcpy)(dst, src);  // NOLINT\n+}\n+\n+TSAN_INTERCEPTOR(char*, strncpy, char *dst, char *src, uptr n) {\n+  SCOPED_TSAN_INTERCEPTOR(strncpy, dst, src, n);\n+  uptr srclen = internal_strnlen(src, n);\n+  MemoryAccessRange(thr, pc, (uptr)dst, n, true);\n+  MemoryAccessRange(thr, pc, (uptr)src, min(srclen + 1, n), false);\n+  return REAL(strncpy)(dst, src, n);\n+}\n+\n+TSAN_INTERCEPTOR(const char*, strstr, const char *s1, const char *s2) {\n+  SCOPED_TSAN_INTERCEPTOR(strstr, s1, s2);\n+  const char *res = REAL(strstr)(s1, s2);\n+  uptr len1 = internal_strlen(s1);\n+  uptr len2 = internal_strlen(s2);\n+  MemoryAccessRange(thr, pc, (uptr)s1, len1 + 1, false);\n+  MemoryAccessRange(thr, pc, (uptr)s2, len2 + 1, false);\n+  return res;\n+}\n+\n+static bool fix_mmap_addr(void **addr, long_t sz, int flags) {\n+  if (*addr) {\n+    if (!IsAppMem((uptr)*addr) || !IsAppMem((uptr)*addr + sz - 1)) {\n+      if (flags & MAP_FIXED) {\n+        errno = EINVAL;\n+        return false;\n+      } else {\n+        *addr = 0;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+TSAN_INTERCEPTOR(void*, mmap, void *addr, long_t sz, int prot,\n+                         int flags, int fd, unsigned off) {\n+  SCOPED_TSAN_INTERCEPTOR(mmap, addr, sz, prot, flags, fd, off);\n+  if (!fix_mmap_addr(&addr, sz, flags))\n+    return MAP_FAILED;\n+  void *res = REAL(mmap)(addr, sz, prot, flags, fd, off);\n+  if (res != MAP_FAILED) {\n+    MemoryResetRange(thr, pc, (uptr)res, sz);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(void*, mmap64, void *addr, long_t sz, int prot,\n+                           int flags, int fd, u64 off) {\n+  SCOPED_TSAN_INTERCEPTOR(mmap64, addr, sz, prot, flags, fd, off);\n+  if (!fix_mmap_addr(&addr, sz, flags))\n+    return MAP_FAILED;\n+  void *res = REAL(mmap64)(addr, sz, prot, flags, fd, off);\n+  if (res != MAP_FAILED) {\n+    MemoryResetRange(thr, pc, (uptr)res, sz);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {\n+  SCOPED_TSAN_INTERCEPTOR(munmap, addr, sz);\n+  int res = REAL(munmap)(addr, sz);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n+  SCOPED_TSAN_INTERCEPTOR(memalign, align, sz);\n+  return user_alloc(thr, pc, sz, align);\n+}\n+\n+TSAN_INTERCEPTOR(void*, valloc, uptr sz) {\n+  SCOPED_TSAN_INTERCEPTOR(valloc, sz);\n+  return user_alloc(thr, pc, sz, kPageSize);\n+}\n+\n+TSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {\n+  SCOPED_TSAN_INTERCEPTOR(pvalloc, sz);\n+  sz = RoundUp(sz, kPageSize);\n+  return user_alloc(thr, pc, sz, kPageSize);\n+}\n+\n+TSAN_INTERCEPTOR(int, posix_memalign, void **memptr, uptr align, uptr sz) {\n+  SCOPED_TSAN_INTERCEPTOR(posix_memalign, memptr, align, sz);\n+  *memptr = user_alloc(thr, pc, sz, align);\n+  return 0;\n+}\n+\n+// Used in thread-safe function static initialization.\n+TSAN_INTERCEPTOR(int, __cxa_guard_acquire, char *m) {\n+  SCOPED_TSAN_INTERCEPTOR(__cxa_guard_acquire, m);\n+  int res = REAL(__cxa_guard_acquire)(m);\n+  if (res) {\n+    // This thread does the init.\n+  } else {\n+    Acquire(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(void, __cxa_guard_release, char *m) {\n+  SCOPED_TSAN_INTERCEPTOR(__cxa_guard_release, m);\n+  Release(thr, pc, (uptr)m);\n+  REAL(__cxa_guard_release)(m);\n+}\n+\n+static void thread_finalize(void *v) {\n+  uptr iter = (uptr)v;\n+  if (iter > 1) {\n+    if (pthread_setspecific(g_thread_finalize_key, (void*)(iter - 1))) {\n+      TsanPrintf(\"ThreadSanitizer: failed to set thread key\\n\");\n+      Die();\n+    }\n+    return;\n+  }\n+  {\n+    ScopedInRtl in_rtl;\n+    ThreadState *thr = cur_thread();\n+    ThreadFinish(thr);\n+    SignalContext *sctx = thr->signal_ctx;\n+    if (sctx) {\n+      thr->signal_ctx = 0;\n+      internal_free(sctx);\n+    }\n+  }\n+}\n+\n+\n+struct ThreadParam {\n+  void* (*callback)(void *arg);\n+  void *param;\n+  atomic_uintptr_t tid;\n+};\n+\n+extern \"C\" void *__tsan_thread_start_func(void *arg) {\n+  ThreadParam *p = (ThreadParam*)arg;\n+  void* (*callback)(void *arg) = p->callback;\n+  void *param = p->param;\n+  int tid = 0;\n+  {\n+    ThreadState *thr = cur_thread();\n+    ScopedInRtl in_rtl;\n+    if (pthread_setspecific(g_thread_finalize_key, (void*)4)) {\n+      TsanPrintf(\"ThreadSanitizer: failed to set thread key\\n\");\n+      Die();\n+    }\n+    while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n+      pthread_yield();\n+    atomic_store(&p->tid, 0, memory_order_release);\n+    ThreadStart(thr, tid, GetTid());\n+    CHECK_EQ(thr->in_rtl, 1);\n+  }\n+  void *res = callback(param);\n+  // Prevent the callback from being tail called,\n+  // it mixes up stack traces.\n+  volatile int foo = 42;\n+  foo++;\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_create,\n+    void *th, void *attr, void *(*callback)(void*), void * param) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_create, th, attr, callback, param);\n+  pthread_attr_t myattr;\n+  if (attr == 0) {\n+    pthread_attr_init(&myattr);\n+    attr = &myattr;\n+  }\n+  int detached = 0;\n+  pthread_attr_getdetachstate(attr, &detached);\n+  uptr stacksize = 0;\n+  pthread_attr_getstacksize(attr, &stacksize);\n+  // We place the huge ThreadState object into TLS, account for that.\n+  const uptr minstacksize = GetTlsSize() + 128*1024;\n+  if (stacksize < minstacksize) {\n+    DPrintf(\"ThreadSanitizer: stacksize %zu->%zu\\n\", stacksize, minstacksize);\n+    pthread_attr_setstacksize(attr, minstacksize);\n+  }\n+  ThreadParam p;\n+  p.callback = callback;\n+  p.param = param;\n+  atomic_store(&p.tid, 0, memory_order_relaxed);\n+  int res = REAL(pthread_create)(th, attr, __tsan_thread_start_func, &p);\n+  if (res == 0) {\n+    int tid = ThreadCreate(thr, pc, *(uptr*)th, detached);\n+    CHECK_NE(tid, 0);\n+    atomic_store(&p.tid, tid, memory_order_release);\n+    while (atomic_load(&p.tid, memory_order_acquire) != 0)\n+      pthread_yield();\n+  }\n+  if (attr == &myattr)\n+    pthread_attr_destroy(&myattr);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_join, th, ret);\n+  int tid = ThreadTid(thr, pc, (uptr)th);\n+  int res = REAL(pthread_join)(th, ret);\n+  if (res == 0) {\n+    ThreadJoin(thr, pc, tid);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_detach, void *th) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_detach, th);\n+  int tid = ThreadTid(thr, pc, (uptr)th);\n+  int res = REAL(pthread_detach)(th);\n+  if (res == 0) {\n+    ThreadDetach(thr, pc, tid);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_mutex_init, void *m, void *a) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_init, m, a);\n+  int res = REAL(pthread_mutex_init)(m, a);\n+  if (res == 0) {\n+    bool recursive = false;\n+    if (a) {\n+      int type = 0;\n+      if (pthread_mutexattr_gettype(a, &type) == 0)\n+        recursive = (type == PTHREAD_MUTEX_RECURSIVE\n+            || type == PTHREAD_MUTEX_RECURSIVE_NP);\n+    }\n+    MutexCreate(thr, pc, (uptr)m, false, recursive, false);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_mutex_destroy, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_destroy, m);\n+  int res = REAL(pthread_mutex_destroy)(m);\n+  if (res == 0 || res == EBUSY) {\n+    MutexDestroy(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_mutex_lock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_lock, m);\n+  int res = REAL(pthread_mutex_lock)(m);\n+  if (res == 0) {\n+    MutexLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_mutex_trylock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_trylock, m);\n+  int res = REAL(pthread_mutex_trylock)(m);\n+  if (res == 0) {\n+    MutexLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_timedlock, m, abstime);\n+  int res = REAL(pthread_mutex_timedlock)(m, abstime);\n+  if (res == 0) {\n+    MutexLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_mutex_unlock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_unlock, m);\n+  MutexUnlock(thr, pc, (uptr)m);\n+  int res = REAL(pthread_mutex_unlock)(m);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_spin_init, void *m, int pshared) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_spin_init, m, pshared);\n+  int res = REAL(pthread_spin_init)(m, pshared);\n+  if (res == 0) {\n+    MutexCreate(thr, pc, (uptr)m, false, false, false);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_spin_destroy, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_spin_destroy, m);\n+  int res = REAL(pthread_spin_destroy)(m);\n+  if (res == 0) {\n+    MutexDestroy(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_spin_lock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_spin_lock, m);\n+  int res = REAL(pthread_spin_lock)(m);\n+  if (res == 0) {\n+    MutexLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_spin_trylock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_spin_trylock, m);\n+  int res = REAL(pthread_spin_trylock)(m);\n+  if (res == 0) {\n+    MutexLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_spin_unlock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_spin_unlock, m);\n+  MutexUnlock(thr, pc, (uptr)m);\n+  int res = REAL(pthread_spin_unlock)(m);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_init, void *m, void *a) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_init, m, a);\n+  int res = REAL(pthread_rwlock_init)(m, a);\n+  if (res == 0) {\n+    MutexCreate(thr, pc, (uptr)m, true, false, false);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_destroy, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_destroy, m);\n+  int res = REAL(pthread_rwlock_destroy)(m);\n+  if (res == 0) {\n+    MutexDestroy(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_rdlock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_rdlock, m);\n+  int res = REAL(pthread_rwlock_rdlock)(m);\n+  if (res == 0) {\n+    MutexReadLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_tryrdlock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_tryrdlock, m);\n+  int res = REAL(pthread_rwlock_tryrdlock)(m);\n+  if (res == 0) {\n+    MutexReadLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_timedrdlock, void *m, void *abstime) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedrdlock, m, abstime);\n+  int res = REAL(pthread_rwlock_timedrdlock)(m, abstime);\n+  if (res == 0) {\n+    MutexReadLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_wrlock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_wrlock, m);\n+  int res = REAL(pthread_rwlock_wrlock)(m);\n+  if (res == 0) {\n+    MutexLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_trywrlock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_trywrlock, m);\n+  int res = REAL(pthread_rwlock_trywrlock)(m);\n+  if (res == 0) {\n+    MutexLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_timedwrlock, void *m, void *abstime) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedwrlock, m, abstime);\n+  int res = REAL(pthread_rwlock_timedwrlock)(m, abstime);\n+  if (res == 0) {\n+    MutexLock(thr, pc, (uptr)m);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_rwlock_unlock, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_unlock, m);\n+  MutexReadOrWriteUnlock(thr, pc, (uptr)m);\n+  int res = REAL(pthread_rwlock_unlock)(m);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_cond_init, void *c, void *a) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_cond_init, c, a);\n+  int res = REAL(pthread_cond_init)(c, a);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_cond_destroy, void *c) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_cond_destroy, c);\n+  int res = REAL(pthread_cond_destroy)(c);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_cond_signal, void *c) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_cond_signal, c);\n+  int res = REAL(pthread_cond_signal)(c);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_cond_broadcast, void *c) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_cond_broadcast, c);\n+  int res = REAL(pthread_cond_broadcast)(c);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_cond_wait, void *c, void *m) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_cond_wait, c, m);\n+  MutexUnlock(thr, pc, (uptr)m);\n+  int res = REAL(pthread_cond_wait)(c, m);\n+  MutexLock(thr, pc, (uptr)m);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_cond_timedwait, void *c, void *m, void *abstime) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_cond_timedwait, c, m, abstime);\n+  MutexUnlock(thr, pc, (uptr)m);\n+  int res = REAL(pthread_cond_timedwait)(c, m, abstime);\n+  MutexLock(thr, pc, (uptr)m);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_barrier_init, void *b, void *a, unsigned count) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_init, b, a, count);\n+  MemoryWrite1Byte(thr, pc, (uptr)b);\n+  int res = REAL(pthread_barrier_init)(b, a, count);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_barrier_destroy, void *b) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_destroy, b);\n+  MemoryWrite1Byte(thr, pc, (uptr)b);\n+  int res = REAL(pthread_barrier_destroy)(b);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_barrier_wait, void *b) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_wait, b);\n+  Release(thr, pc, (uptr)b);\n+  MemoryRead1Byte(thr, pc, (uptr)b);\n+  int res = REAL(pthread_barrier_wait)(b);\n+  MemoryRead1Byte(thr, pc, (uptr)b);\n+  if (res == 0 || res == PTHREAD_BARRIER_SERIAL_THREAD) {\n+    Acquire(thr, pc, (uptr)b);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_once, o, f);\n+  if (o == 0 || f == 0)\n+    return EINVAL;\n+  atomic_uint32_t *a = static_cast<atomic_uint32_t*>(o);\n+  u32 v = atomic_load(a, memory_order_acquire);\n+  if (v == 0 && atomic_compare_exchange_strong(a, &v, 1,\n+                                               memory_order_relaxed)) {\n+    const int old_in_rtl = thr->in_rtl;\n+    thr->in_rtl = 0;\n+    (*f)();\n+    CHECK_EQ(thr->in_rtl, 0);\n+    thr->in_rtl = old_in_rtl;\n+    Release(thr, pc, (uptr)o);\n+    atomic_store(a, 2, memory_order_release);\n+  } else {\n+    while (v != 2) {\n+      pthread_yield();\n+      v = atomic_load(a, memory_order_acquire);\n+    }\n+    Acquire(thr, pc, (uptr)o);\n+  }\n+  return 0;\n+}\n+\n+TSAN_INTERCEPTOR(int, sem_init, void *s, int pshared, unsigned value) {\n+  SCOPED_TSAN_INTERCEPTOR(sem_init, s, pshared, value);\n+  int res = REAL(sem_init)(s, pshared, value);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, sem_destroy, void *s) {\n+  SCOPED_TSAN_INTERCEPTOR(sem_destroy, s);\n+  int res = REAL(sem_destroy)(s);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, sem_wait, void *s) {\n+  SCOPED_TSAN_INTERCEPTOR(sem_wait, s);\n+  int res = REAL(sem_wait)(s);\n+  if (res == 0) {\n+    Acquire(thr, pc, (uptr)s);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, sem_trywait, void *s) {\n+  SCOPED_TSAN_INTERCEPTOR(sem_trywait, s);\n+  int res = REAL(sem_trywait)(s);\n+  if (res == 0) {\n+    Acquire(thr, pc, (uptr)s);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, sem_timedwait, void *s, void *abstime) {\n+  SCOPED_TSAN_INTERCEPTOR(sem_timedwait, s, abstime);\n+  int res = REAL(sem_timedwait)(s, abstime);\n+  if (res == 0) {\n+    Acquire(thr, pc, (uptr)s);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, sem_post, void *s) {\n+  SCOPED_TSAN_INTERCEPTOR(sem_post, s);\n+  Release(thr, pc, (uptr)s);\n+  int res = REAL(sem_post)(s);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, sem_getvalue, void *s, int *sval) {\n+  SCOPED_TSAN_INTERCEPTOR(sem_getvalue, s, sval);\n+  int res = REAL(sem_getvalue)(s, sval);\n+  if (res == 0) {\n+    Acquire(thr, pc, (uptr)s);\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, read, int fd, void *buf, long_t sz) {\n+  SCOPED_TSAN_INTERCEPTOR(read, fd, buf, sz);\n+  int res = REAL(read)(fd, buf, sz);\n+  if (res >= 0) {\n+    Acquire(thr, pc, fd2addr(fd));\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, pread, int fd, void *buf, long_t sz, unsigned off) {\n+  SCOPED_TSAN_INTERCEPTOR(pread, fd, buf, sz, off);\n+  int res = REAL(pread)(fd, buf, sz, off);\n+  if (res >= 0) {\n+    Acquire(thr, pc, fd2addr(fd));\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, pread64, int fd, void *buf, long_t sz, u64 off) {\n+  SCOPED_TSAN_INTERCEPTOR(pread64, fd, buf, sz, off);\n+  int res = REAL(pread64)(fd, buf, sz, off);\n+  if (res >= 0) {\n+    Acquire(thr, pc, fd2addr(fd));\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, readv, int fd, void *vec, int cnt) {\n+  SCOPED_TSAN_INTERCEPTOR(readv, fd, vec, cnt);\n+  int res = REAL(readv)(fd, vec, cnt);\n+  if (res >= 0) {\n+    Acquire(thr, pc, fd2addr(fd));\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, preadv64, int fd, void *vec, int cnt, u64 off) {\n+  SCOPED_TSAN_INTERCEPTOR(preadv64, fd, vec, cnt, off);\n+  int res = REAL(preadv64)(fd, vec, cnt, off);\n+  if (res >= 0) {\n+    Acquire(thr, pc, fd2addr(fd));\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, write, int fd, void *buf, long_t sz) {\n+  SCOPED_TSAN_INTERCEPTOR(write, fd, buf, sz);\n+  Release(thr, pc, fd2addr(fd));\n+  int res = REAL(write)(fd, buf, sz);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, pwrite, int fd, void *buf, long_t sz, unsigned off) {\n+  SCOPED_TSAN_INTERCEPTOR(pwrite, fd, buf, sz, off);\n+  Release(thr, pc, fd2addr(fd));\n+  int res = REAL(pwrite)(fd, buf, sz, off);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, pwrite64, int fd, void *buf, long_t sz, u64 off) {\n+  SCOPED_TSAN_INTERCEPTOR(pwrite64, fd, buf, sz, off);\n+  Release(thr, pc, fd2addr(fd));\n+  int res = REAL(pwrite64)(fd, buf, sz, off);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, writev, int fd, void *vec, int cnt) {\n+  SCOPED_TSAN_INTERCEPTOR(writev, fd, vec, cnt);\n+  Release(thr, pc, fd2addr(fd));\n+  int res = REAL(writev)(fd, vec, cnt);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, pwritev64, int fd, void *vec, int cnt, u64 off) {\n+  SCOPED_TSAN_INTERCEPTOR(pwritev64, fd, vec, cnt, off);\n+  Release(thr, pc, fd2addr(fd));\n+  int res = REAL(pwritev64)(fd, vec, cnt, off);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, send, int fd, void *buf, long_t len, int flags) {\n+  SCOPED_TSAN_INTERCEPTOR(send, fd, buf, len, flags);\n+  Release(thr, pc, fd2addr(fd));\n+  int res = REAL(send)(fd, buf, len, flags);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, sendmsg, int fd, void *msg, int flags) {\n+  SCOPED_TSAN_INTERCEPTOR(sendmsg, fd, msg, flags);\n+  Release(thr, pc, fd2addr(fd));\n+  int res = REAL(sendmsg)(fd, msg, flags);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, recv, int fd, void *buf, long_t len, int flags) {\n+  SCOPED_TSAN_INTERCEPTOR(recv, fd, buf, len, flags);\n+  int res = REAL(recv)(fd, buf, len, flags);\n+  if (res >= 0) {\n+    Acquire(thr, pc, fd2addr(fd));\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(long_t, recvmsg, int fd, void *msg, int flags) {\n+  SCOPED_TSAN_INTERCEPTOR(recvmsg, fd, msg, flags);\n+  int res = REAL(recvmsg)(fd, msg, flags);\n+  if (res >= 0) {\n+    Acquire(thr, pc, fd2addr(fd));\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, unlink, char *path) {\n+  SCOPED_TSAN_INTERCEPTOR(unlink, path);\n+  Release(thr, pc, file2addr(path));\n+  int res = REAL(unlink)(path);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(void*, fopen, char *path, char *mode) {\n+  SCOPED_TSAN_INTERCEPTOR(fopen, path, mode);\n+  void *res = REAL(fopen)(path, mode);\n+  Acquire(thr, pc, file2addr(path));\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(uptr, fread, void *ptr, uptr size, uptr nmemb, void *f) {\n+  SCOPED_TSAN_INTERCEPTOR(fread, ptr, size, nmemb, f);\n+  MemoryAccessRange(thr, pc, (uptr)ptr, size * nmemb, true);\n+  return REAL(fread)(ptr, size, nmemb, f);\n+}\n+\n+TSAN_INTERCEPTOR(uptr, fwrite, const void *p, uptr size, uptr nmemb, void *f) {\n+  SCOPED_TSAN_INTERCEPTOR(fwrite, p, size, nmemb, f);\n+  MemoryAccessRange(thr, pc, (uptr)p, size * nmemb, false);\n+  return REAL(fwrite)(p, size, nmemb, f);\n+}\n+\n+TSAN_INTERCEPTOR(int, puts, const char *s) {\n+  SCOPED_TSAN_INTERCEPTOR(puts, s);\n+  MemoryAccessRange(thr, pc, (uptr)s, internal_strlen(s), false);\n+  return REAL(puts)(s);\n+}\n+\n+TSAN_INTERCEPTOR(int, rmdir, char *path) {\n+  SCOPED_TSAN_INTERCEPTOR(rmdir, path);\n+  Release(thr, pc, dir2addr(path));\n+  int res = REAL(rmdir)(path);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(void*, opendir, char *path) {\n+  SCOPED_TSAN_INTERCEPTOR(opendir, path);\n+  void *res = REAL(opendir)(path);\n+  Acquire(thr, pc, dir2addr(path));\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n+  SCOPED_TSAN_INTERCEPTOR(epoll_ctl, epfd, op, fd, ev);\n+  if (op == EPOLL_CTL_ADD) {\n+    Release(thr, pc, epollfd2addr(epfd));\n+  }\n+  int res = REAL(epoll_ctl)(epfd, op, fd, ev);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n+  SCOPED_TSAN_INTERCEPTOR(epoll_wait, epfd, ev, cnt, timeout);\n+  int res = REAL(epoll_wait)(epfd, ev, cnt, timeout);\n+  if (res > 0) {\n+    Acquire(thr, pc, epollfd2addr(epfd));\n+  }\n+  return res;\n+}\n+\n+static void ALWAYS_INLINE rtl_generic_sighandler(bool sigact, int sig,\n+    my_siginfo_t *info, void *ctx) {\n+  ThreadState *thr = cur_thread();\n+  SignalContext *sctx = SigCtx(thr);\n+  // Don't mess with synchronous signals.\n+  if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\n+      sig == SIGABRT || sig == SIGFPE || sig == SIGPIPE ||\n+      (sctx && sig == sctx->int_signal_send)) {\n+    CHECK(thr->in_rtl == 0 || thr->in_rtl == 1);\n+    int in_rtl = thr->in_rtl;\n+    thr->in_rtl = 0;\n+    CHECK_EQ(thr->in_signal_handler, false);\n+    thr->in_signal_handler = true;\n+    if (sigact)\n+      sigactions[sig].sa_sigaction(sig, info, ctx);\n+    else\n+      sigactions[sig].sa_handler(sig);\n+    CHECK_EQ(thr->in_signal_handler, true);\n+    thr->in_signal_handler = false;\n+    thr->in_rtl = in_rtl;\n+    return;\n+  }\n+\n+  if (sctx == 0)\n+    return;\n+  SignalDesc *signal = &sctx->pending_signals[sig];\n+  if (signal->armed == false) {\n+    signal->armed = true;\n+    signal->sigaction = sigact;\n+    if (info)\n+      internal_memcpy(&signal->siginfo, info, sizeof(*info));\n+    if (ctx)\n+      internal_memcpy(&signal->ctx, ctx, sizeof(signal->ctx));\n+    sctx->pending_signal_count++;\n+  }\n+}\n+\n+static void rtl_sighandler(int sig) {\n+  rtl_generic_sighandler(false, sig, 0, 0);\n+}\n+\n+static void rtl_sigaction(int sig, my_siginfo_t *info, void *ctx) {\n+  rtl_generic_sighandler(true, sig, info, ctx);\n+}\n+\n+TSAN_INTERCEPTOR(int, sigaction, int sig, sigaction_t *act, sigaction_t *old) {\n+  SCOPED_TSAN_INTERCEPTOR(sigaction, sig, act, old);\n+  if (old)\n+    internal_memcpy(old, &sigactions[sig], sizeof(*old));\n+  if (act == 0)\n+    return 0;\n+  internal_memcpy(&sigactions[sig], act, sizeof(*act));\n+  sigaction_t newact;\n+  internal_memcpy(&newact, act, sizeof(newact));\n+  sigfillset(&newact.sa_mask);\n+  if (act->sa_handler != SIG_IGN && act->sa_handler != SIG_DFL) {\n+    if (newact.sa_flags & SA_SIGINFO)\n+      newact.sa_sigaction = rtl_sigaction;\n+    else\n+      newact.sa_handler = rtl_sighandler;\n+  }\n+  int res = REAL(sigaction)(sig, &newact, 0);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(sighandler_t, signal, int sig, sighandler_t h) {\n+  sigaction_t act;\n+  act.sa_handler = h;\n+  REAL(memset)(&act.sa_mask, -1, sizeof(act.sa_mask));\n+  act.sa_flags = 0;\n+  sigaction_t old;\n+  int res = sigaction(sig, &act, &old);\n+  if (res)\n+    return SIG_ERR;\n+  return old.sa_handler;\n+}\n+\n+TSAN_INTERCEPTOR(int, raise, int sig) {\n+  SCOPED_TSAN_INTERCEPTOR(raise, sig);\n+  SignalContext *sctx = SigCtx(thr);\n+  CHECK_NE(sctx, 0);\n+  int prev = sctx->int_signal_send;\n+  sctx->int_signal_send = sig;\n+  int res = REAL(raise)(sig);\n+  CHECK_EQ(sctx->int_signal_send, sig);\n+  sctx->int_signal_send = prev;\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, kill, int pid, int sig) {\n+  SCOPED_TSAN_INTERCEPTOR(kill, pid, sig);\n+  SignalContext *sctx = SigCtx(thr);\n+  CHECK_NE(sctx, 0);\n+  int prev = sctx->int_signal_send;\n+  if (pid == GetPid()) {\n+    sctx->int_signal_send = sig;\n+  }\n+  int res = REAL(kill)(pid, sig);\n+  if (pid == GetPid()) {\n+    CHECK_EQ(sctx->int_signal_send, sig);\n+    sctx->int_signal_send = prev;\n+  }\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, pthread_kill, void *tid, int sig) {\n+  SCOPED_TSAN_INTERCEPTOR(pthread_kill, tid, sig);\n+  SignalContext *sctx = SigCtx(thr);\n+  CHECK_NE(sctx, 0);\n+  int prev = sctx->int_signal_send;\n+  if (tid == pthread_self()) {\n+    sctx->int_signal_send = sig;\n+  }\n+  int res = REAL(pthread_kill)(tid, sig);\n+  if (tid == pthread_self()) {\n+    CHECK_EQ(sctx->int_signal_send, sig);\n+    sctx->int_signal_send = prev;\n+  }\n+  return res;\n+}\n+\n+static void process_pending_signals(ThreadState *thr) {\n+  CHECK_EQ(thr->in_rtl, 0);\n+  SignalContext *sctx = SigCtx(thr);\n+  if (sctx == 0 || sctx->pending_signal_count == 0 || thr->in_signal_handler)\n+    return;\n+  Context *ctx = CTX();\n+  thr->in_signal_handler = true;\n+  sctx->pending_signal_count = 0;\n+  // These are too big for stack.\n+  static THREADLOCAL sigset_t emptyset, oldset;\n+  sigfillset(&emptyset);\n+  pthread_sigmask(SIG_SETMASK, &emptyset, &oldset);\n+  for (int sig = 0; sig < kSigCount; sig++) {\n+    SignalDesc *signal = &sctx->pending_signals[sig];\n+    if (signal->armed) {\n+      signal->armed = false;\n+      if (sigactions[sig].sa_handler != SIG_DFL\n+          && sigactions[sig].sa_handler != SIG_IGN) {\n+        // Insure that the handler does not spoil errno.\n+        const int saved_errno = errno;\n+        errno = 0;\n+        if (signal->sigaction)\n+          sigactions[sig].sa_sigaction(sig, &signal->siginfo, &signal->ctx);\n+        else\n+          sigactions[sig].sa_handler(sig);\n+        if (errno != 0) {\n+          ScopedInRtl in_rtl;\n+          __tsan::StackTrace stack;\n+          uptr pc = signal->sigaction ?\n+              (uptr)sigactions[sig].sa_sigaction :\n+              (uptr)sigactions[sig].sa_handler;\n+          stack.Init(&pc, 1);\n+          ScopedReport rep(ReportTypeErrnoInSignal);\n+          if (!IsFiredSuppression(ctx, rep, stack)) {\n+            rep.AddStack(&stack);\n+            OutputReport(ctx, rep, rep.GetReport()->stacks[0]);\n+          }\n+        }\n+        errno = saved_errno;\n+      }\n+    }\n+  }\n+  pthread_sigmask(SIG_SETMASK, &oldset, 0);\n+  CHECK_EQ(thr->in_signal_handler, true);\n+  thr->in_signal_handler = false;\n+}\n+\n+namespace __tsan {\n+\n+void InitializeInterceptors() {\n+  CHECK_GT(cur_thread()->in_rtl, 0);\n+\n+  // We need to setup it early, because functions like dlsym() can call it.\n+  REAL(memset) = internal_memset;\n+  REAL(memcpy) = internal_memcpy;\n+  REAL(memcmp) = internal_memcmp;\n+\n+  TSAN_INTERCEPT(longjmp);\n+  TSAN_INTERCEPT(siglongjmp);\n+\n+  TSAN_INTERCEPT(malloc);\n+  TSAN_INTERCEPT(calloc);\n+  TSAN_INTERCEPT(realloc);\n+  TSAN_INTERCEPT(free);\n+  TSAN_INTERCEPT(cfree);\n+  TSAN_INTERCEPT(mmap);\n+  TSAN_INTERCEPT(mmap64);\n+  TSAN_INTERCEPT(munmap);\n+  TSAN_INTERCEPT(memalign);\n+  TSAN_INTERCEPT(valloc);\n+  TSAN_INTERCEPT(pvalloc);\n+  TSAN_INTERCEPT(posix_memalign);\n+\n+  TSAN_INTERCEPT(strlen);\n+  TSAN_INTERCEPT(memset);\n+  TSAN_INTERCEPT(memcpy);\n+  TSAN_INTERCEPT(strcmp);\n+  TSAN_INTERCEPT(memchr);\n+  TSAN_INTERCEPT(memrchr);\n+  TSAN_INTERCEPT(memmove);\n+  TSAN_INTERCEPT(memcmp);\n+  TSAN_INTERCEPT(strchr);\n+  TSAN_INTERCEPT(strchrnul);\n+  TSAN_INTERCEPT(strrchr);\n+  TSAN_INTERCEPT(strncmp);\n+  TSAN_INTERCEPT(strcpy);  // NOLINT\n+  TSAN_INTERCEPT(strncpy);\n+  TSAN_INTERCEPT(strstr);\n+\n+  TSAN_INTERCEPT(__cxa_guard_acquire);\n+  TSAN_INTERCEPT(__cxa_guard_release);\n+\n+  TSAN_INTERCEPT(pthread_create);\n+  TSAN_INTERCEPT(pthread_join);\n+  TSAN_INTERCEPT(pthread_detach);\n+\n+  TSAN_INTERCEPT(pthread_mutex_init);\n+  TSAN_INTERCEPT(pthread_mutex_destroy);\n+  TSAN_INTERCEPT(pthread_mutex_lock);\n+  TSAN_INTERCEPT(pthread_mutex_trylock);\n+  TSAN_INTERCEPT(pthread_mutex_timedlock);\n+  TSAN_INTERCEPT(pthread_mutex_unlock);\n+\n+  TSAN_INTERCEPT(pthread_spin_init);\n+  TSAN_INTERCEPT(pthread_spin_destroy);\n+  TSAN_INTERCEPT(pthread_spin_lock);\n+  TSAN_INTERCEPT(pthread_spin_trylock);\n+  TSAN_INTERCEPT(pthread_spin_unlock);\n+\n+  TSAN_INTERCEPT(pthread_rwlock_init);\n+  TSAN_INTERCEPT(pthread_rwlock_destroy);\n+  TSAN_INTERCEPT(pthread_rwlock_rdlock);\n+  TSAN_INTERCEPT(pthread_rwlock_tryrdlock);\n+  TSAN_INTERCEPT(pthread_rwlock_timedrdlock);\n+  TSAN_INTERCEPT(pthread_rwlock_wrlock);\n+  TSAN_INTERCEPT(pthread_rwlock_trywrlock);\n+  TSAN_INTERCEPT(pthread_rwlock_timedwrlock);\n+  TSAN_INTERCEPT(pthread_rwlock_unlock);\n+\n+  TSAN_INTERCEPT(pthread_cond_init);\n+  TSAN_INTERCEPT(pthread_cond_destroy);\n+  TSAN_INTERCEPT(pthread_cond_signal);\n+  TSAN_INTERCEPT(pthread_cond_broadcast);\n+  TSAN_INTERCEPT(pthread_cond_wait);\n+  TSAN_INTERCEPT(pthread_cond_timedwait);\n+\n+  TSAN_INTERCEPT(pthread_barrier_init);\n+  TSAN_INTERCEPT(pthread_barrier_destroy);\n+  TSAN_INTERCEPT(pthread_barrier_wait);\n+\n+  TSAN_INTERCEPT(pthread_once);\n+\n+  TSAN_INTERCEPT(sem_init);\n+  TSAN_INTERCEPT(sem_destroy);\n+  TSAN_INTERCEPT(sem_wait);\n+  TSAN_INTERCEPT(sem_trywait);\n+  TSAN_INTERCEPT(sem_timedwait);\n+  TSAN_INTERCEPT(sem_post);\n+  TSAN_INTERCEPT(sem_getvalue);\n+\n+  TSAN_INTERCEPT(read);\n+  TSAN_INTERCEPT(pread);\n+  TSAN_INTERCEPT(pread64);\n+  TSAN_INTERCEPT(readv);\n+  TSAN_INTERCEPT(preadv64);\n+  TSAN_INTERCEPT(write);\n+  TSAN_INTERCEPT(pwrite);\n+  TSAN_INTERCEPT(pwrite64);\n+  TSAN_INTERCEPT(writev);\n+  TSAN_INTERCEPT(pwritev64);\n+  TSAN_INTERCEPT(send);\n+  TSAN_INTERCEPT(sendmsg);\n+  TSAN_INTERCEPT(recv);\n+  TSAN_INTERCEPT(recvmsg);\n+\n+  TSAN_INTERCEPT(unlink);\n+  TSAN_INTERCEPT(fopen);\n+  TSAN_INTERCEPT(fread);\n+  TSAN_INTERCEPT(fwrite);\n+  TSAN_INTERCEPT(puts);\n+  TSAN_INTERCEPT(rmdir);\n+  TSAN_INTERCEPT(opendir);\n+\n+  TSAN_INTERCEPT(epoll_ctl);\n+  TSAN_INTERCEPT(epoll_wait);\n+\n+  TSAN_INTERCEPT(sigaction);\n+  TSAN_INTERCEPT(signal);\n+  TSAN_INTERCEPT(raise);\n+  TSAN_INTERCEPT(kill);\n+  TSAN_INTERCEPT(pthread_kill);\n+  TSAN_INTERCEPT(sleep);\n+  TSAN_INTERCEPT(usleep);\n+  TSAN_INTERCEPT(nanosleep);\n+\n+  atexit_ctx = new(internal_alloc(MBlockAtExit, sizeof(AtExitContext)))\n+      AtExitContext();\n+\n+  if (__cxa_atexit(&finalize, 0, 0)) {\n+    TsanPrintf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n+    Die();\n+  }\n+\n+  if (pthread_key_create(&g_thread_finalize_key, &thread_finalize)) {\n+    TsanPrintf(\"ThreadSanitizer: failed to create thread key\\n\");\n+    Die();\n+  }\n+}\n+\n+void internal_start_thread(void(*func)(void *arg), void *arg) {\n+  void *th;\n+  REAL(pthread_create)(&th, 0, (void*(*)(void *arg))func, arg);\n+  REAL(pthread_detach)(th);\n+}\n+\n+}  // namespace __tsan"}, {"sha": "2e8c553172c05205274e03b88f1c7632d12ae44e", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,52 @@\n+//===-- tsan_interceptors.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef TSAN_INTERCEPTORS_H\n+#define TSAN_INTERCEPTORS_H\n+\n+#include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"tsan_rtl.h\"\n+\n+namespace __tsan {\n+\n+class ScopedInterceptor {\n+ public:\n+  ScopedInterceptor(ThreadState *thr, const char *fname, uptr pc);\n+  ~ScopedInterceptor();\n+ private:\n+  ThreadState *const thr_;\n+  const int in_rtl_;\n+};\n+\n+#define SCOPED_INTERCEPTOR_RAW(func, ...) \\\n+    ThreadState *thr = cur_thread(); \\\n+    StatInc(thr, StatInterceptor); \\\n+    StatInc(thr, StatInt_##func); \\\n+    const uptr caller_pc = GET_CALLER_PC(); \\\n+    ScopedInterceptor si(thr, #func, caller_pc); \\\n+    /* Subtract one from pc as we need current instruction address */ \\\n+    const uptr pc = __sanitizer::StackTrace::GetCurrentPc() - 1; \\\n+    (void)pc; \\\n+/**/\n+\n+#define SCOPED_TSAN_INTERCEPTOR(func, ...) \\\n+    SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__); \\\n+    if (thr->in_rtl > 1) \\\n+      return REAL(func)(__VA_ARGS__); \\\n+/**/\n+\n+#define TSAN_INTERCEPTOR(ret, func, ...) INTERCEPTOR(ret, func, __VA_ARGS__)\n+#define TSAN_INTERCEPT(func) INTERCEPT_FUNCTION(func)\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_INTERCEPTORS_H"}, {"sha": "08a51651114778f91d8e7b0e82980cd5cf7efbd1", "filename": "libsanitizer/tsan/tsan_interface.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,40 @@\n+//===-- tsan_interface.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"tsan_interface.h\"\n+#include \"tsan_interface_ann.h\"\n+#include \"tsan_rtl.h\"\n+\n+#define CALLERPC ((uptr)__builtin_return_address(0))\n+\n+using namespace __tsan;  // NOLINT\n+\n+void __tsan_init() {\n+  Initialize(cur_thread());\n+}\n+\n+void __tsan_read16(void *addr) {\n+  MemoryRead8Byte(cur_thread(), CALLERPC, (uptr)addr);\n+  MemoryRead8Byte(cur_thread(), CALLERPC, (uptr)addr + 8);\n+}\n+\n+void __tsan_write16(void *addr) {\n+  MemoryWrite8Byte(cur_thread(), CALLERPC, (uptr)addr);\n+  MemoryWrite8Byte(cur_thread(), CALLERPC, (uptr)addr + 8);\n+}\n+\n+void __tsan_acquire(void *addr) {\n+  Acquire(cur_thread(), CALLERPC, (uptr)addr);\n+}\n+\n+void __tsan_release(void *addr) {\n+  Release(cur_thread(), CALLERPC, (uptr)addr);\n+}"}, {"sha": "72bb1e91c3dae71ee35e6a6dc5067e471f1c1c8a", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,50 @@\n+//===-- tsan_interface.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// The functions declared in this header will be inserted by the instrumentation\n+// module.\n+// This header can be included by the instrumented program or by TSan tests.\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_INTERFACE_H\n+#define TSAN_INTERFACE_H\n+\n+#include <sanitizer/common_interface_defs.h> \n+// This header should NOT include any other headers.\n+// All functions in this header are extern \"C\" and start with __tsan_.\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+// This function should be called at the very beginning of the process,\n+// before any instrumented code is executed and before any call to malloc.\n+void __tsan_init() SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_read1(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read2(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read4(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read8(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_read16(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_write1(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write2(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write4(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write8(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_write16(void *addr) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_vptr_update(void **vptr_p, void *new_val) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_func_entry(void *call_pc) SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_func_exit() SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // TSAN_INTERFACE_H"}, {"sha": "fd5c1cc6cd43081458b6b2f82e5e3d03575b75a3", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "added", "additions": 402, "deletions": 0, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,402 @@\n+//===-- tsan_interface_ann.cc ---------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"tsan_interface_ann.h\"\n+#include \"tsan_mutex.h\"\n+#include \"tsan_report.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_mman.h\"\n+#include \"tsan_flags.h\"\n+#include \"tsan_platform.h\"\n+\n+#define CALLERPC ((uptr)__builtin_return_address(0))\n+\n+using namespace __tsan;  // NOLINT\n+\n+namespace __tsan {\n+\n+class ScopedAnnotation {\n+ public:\n+  ScopedAnnotation(ThreadState *thr, const char *aname, const char *f, int l,\n+                   uptr pc)\n+      : thr_(thr)\n+      , in_rtl_(thr->in_rtl) {\n+    CHECK_EQ(thr_->in_rtl, 0);\n+    FuncEntry(thr_, pc);\n+    thr_->in_rtl++;\n+    DPrintf(\"#%d: annotation %s() %s:%d\\n\", thr_->tid, aname, f, l);\n+  }\n+\n+  ~ScopedAnnotation() {\n+    thr_->in_rtl--;\n+    CHECK_EQ(in_rtl_, thr_->in_rtl);\n+    FuncExit(thr_);\n+  }\n+ private:\n+  ThreadState *const thr_;\n+  const int in_rtl_;\n+};\n+\n+#define SCOPED_ANNOTATION(typ) \\\n+    if (!flags()->enable_annotations) \\\n+      return; \\\n+    ThreadState *thr = cur_thread(); \\\n+    const uptr pc = (uptr)__builtin_return_address(0); \\\n+    StatInc(thr, StatAnnotation); \\\n+    StatInc(thr, Stat##typ); \\\n+    ScopedAnnotation sa(thr, __FUNCTION__, f, l, \\\n+        (uptr)__builtin_return_address(0)); \\\n+    (void)pc; \\\n+/**/\n+\n+static const int kMaxDescLen = 128;\n+\n+struct ExpectRace {\n+  ExpectRace *next;\n+  ExpectRace *prev;\n+  int hitcount;\n+  uptr addr;\n+  uptr size;\n+  char *file;\n+  int line;\n+  char desc[kMaxDescLen];\n+};\n+\n+struct DynamicAnnContext {\n+  Mutex mtx;\n+  ExpectRace expect;\n+  ExpectRace benign;\n+\n+  DynamicAnnContext()\n+    : mtx(MutexTypeAnnotations, StatMtxAnnotations) {\n+  }\n+};\n+\n+static DynamicAnnContext *dyn_ann_ctx;\n+static char dyn_ann_ctx_placeholder[sizeof(DynamicAnnContext)] ALIGNED(64);\n+\n+static void AddExpectRace(ExpectRace *list,\n+    char *f, int l, uptr addr, uptr size, char *desc) {\n+  ExpectRace *race = list->next;\n+  for (; race != list; race = race->next) {\n+    if (race->addr == addr && race->size == size)\n+      return;\n+  }\n+  race = (ExpectRace*)internal_alloc(MBlockExpectRace, sizeof(ExpectRace));\n+  race->hitcount = 0;\n+  race->addr = addr;\n+  race->size = size;\n+  race->file = f;\n+  race->line = l;\n+  race->desc[0] = 0;\n+  if (desc) {\n+    int i = 0;\n+    for (; i < kMaxDescLen - 1 && desc[i]; i++)\n+      race->desc[i] = desc[i];\n+    race->desc[i] = 0;\n+  }\n+  race->prev = list;\n+  race->next = list->next;\n+  race->next->prev = race;\n+  list->next = race;\n+}\n+\n+static ExpectRace *FindRace(ExpectRace *list, uptr addr, uptr size) {\n+  for (ExpectRace *race = list->next; race != list; race = race->next) {\n+    uptr maxbegin = max(race->addr, addr);\n+    uptr minend = min(race->addr + race->size, addr + size);\n+    if (maxbegin < minend)\n+      return race;\n+  }\n+  return 0;\n+}\n+\n+static bool CheckContains(ExpectRace *list, uptr addr, uptr size) {\n+  ExpectRace *race = FindRace(list, addr, size);\n+  if (race == 0 && AlternativeAddress(addr))\n+    race = FindRace(list, AlternativeAddress(addr), size);\n+  if (race == 0)\n+    return false;\n+  DPrintf(\"Hit expected/benign race: %s addr=%zx:%d %s:%d\\n\",\n+      race->desc, race->addr, (int)race->size, race->file, race->line);\n+  race->hitcount++;\n+  return true;\n+}\n+\n+static void InitList(ExpectRace *list) {\n+  list->next = list;\n+  list->prev = list;\n+}\n+\n+void InitializeDynamicAnnotations() {\n+  dyn_ann_ctx = new(dyn_ann_ctx_placeholder) DynamicAnnContext;\n+  InitList(&dyn_ann_ctx->expect);\n+  InitList(&dyn_ann_ctx->benign);\n+}\n+\n+bool IsExpectedReport(uptr addr, uptr size) {\n+  Lock lock(&dyn_ann_ctx->mtx);\n+  if (CheckContains(&dyn_ann_ctx->expect, addr, size))\n+    return true;\n+  if (CheckContains(&dyn_ann_ctx->benign, addr, size))\n+    return true;\n+  return false;\n+}\n+\n+}  // namespace __tsan\n+\n+using namespace __tsan;  // NOLINT\n+\n+extern \"C\" {\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateHappensBefore(char *f, int l, uptr addr) {\n+  SCOPED_ANNOTATION(AnnotateHappensBefore);\n+  Release(cur_thread(), CALLERPC, addr);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateHappensAfter(char *f, int l, uptr addr) {\n+  SCOPED_ANNOTATION(AnnotateHappensAfter);\n+  Acquire(cur_thread(), CALLERPC, addr);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateCondVarSignal(char *f, int l, uptr cv) {\n+  SCOPED_ANNOTATION(AnnotateCondVarSignal);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateCondVarSignalAll(char *f, int l, uptr cv) {\n+  SCOPED_ANNOTATION(AnnotateCondVarSignalAll);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateMutexIsNotPHB(char *f, int l, uptr mu) {\n+  SCOPED_ANNOTATION(AnnotateMutexIsNotPHB);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateCondVarWait(char *f, int l, uptr cv, uptr lock) {\n+  SCOPED_ANNOTATION(AnnotateCondVarWait);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateRWLockCreate(char *f, int l, uptr m) {\n+  SCOPED_ANNOTATION(AnnotateRWLockCreate);\n+  MutexCreate(thr, pc, m, true, true, false);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateRWLockCreateStatic(char *f, int l, uptr m) {\n+  SCOPED_ANNOTATION(AnnotateRWLockCreateStatic);\n+  MutexCreate(thr, pc, m, true, true, true);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateRWLockDestroy(char *f, int l, uptr m) {\n+  SCOPED_ANNOTATION(AnnotateRWLockDestroy);\n+  MutexDestroy(thr, pc, m);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateRWLockAcquired(char *f, int l, uptr m, uptr is_w) {\n+  SCOPED_ANNOTATION(AnnotateRWLockAcquired);\n+  if (is_w)\n+    MutexLock(thr, pc, m);\n+  else\n+    MutexReadLock(thr, pc, m);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateRWLockReleased(char *f, int l, uptr m, uptr is_w) {\n+  SCOPED_ANNOTATION(AnnotateRWLockReleased);\n+  if (is_w)\n+    MutexUnlock(thr, pc, m);\n+  else\n+    MutexReadUnlock(thr, pc, m);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateTraceMemory(char *f, int l, uptr mem) {\n+  SCOPED_ANNOTATION(AnnotateTraceMemory);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateFlushState(char *f, int l) {\n+  SCOPED_ANNOTATION(AnnotateFlushState);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateNewMemory(char *f, int l, uptr mem, uptr size) {\n+  SCOPED_ANNOTATION(AnnotateNewMemory);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateNoOp(char *f, int l, uptr mem) {\n+  SCOPED_ANNOTATION(AnnotateNoOp);\n+}\n+\n+static void ReportMissedExpectedRace(ExpectRace *race) {\n+  TsanPrintf(\"==================\\n\");\n+  TsanPrintf(\"WARNING: ThreadSanitizer: missed expected data race\\n\");\n+  TsanPrintf(\"  %s addr=%zx %s:%d\\n\",\n+      race->desc, race->addr, race->file, race->line);\n+  TsanPrintf(\"==================\\n\");\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateFlushExpectedRaces(char *f, int l) {\n+  SCOPED_ANNOTATION(AnnotateFlushExpectedRaces);\n+  Lock lock(&dyn_ann_ctx->mtx);\n+  while (dyn_ann_ctx->expect.next != &dyn_ann_ctx->expect) {\n+    ExpectRace *race = dyn_ann_ctx->expect.next;\n+    if (race->hitcount == 0) {\n+      CTX()->nmissed_expected++;\n+      ReportMissedExpectedRace(race);\n+    }\n+    race->prev->next = race->next;\n+    race->next->prev = race->prev;\n+    internal_free(race);\n+  }\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateEnableRaceDetection(char *f, int l, int enable) {\n+  SCOPED_ANNOTATION(AnnotateEnableRaceDetection);\n+  // FIXME: Reconsider this functionality later. It may be irrelevant.\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateMutexIsUsedAsCondVar(char *f, int l, uptr mu) {\n+  SCOPED_ANNOTATION(AnnotateMutexIsUsedAsCondVar);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotatePCQGet(char *f, int l, uptr pcq) {\n+  SCOPED_ANNOTATION(AnnotatePCQGet);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotatePCQPut(char *f, int l, uptr pcq) {\n+  SCOPED_ANNOTATION(AnnotatePCQPut);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotatePCQDestroy(char *f, int l, uptr pcq) {\n+  SCOPED_ANNOTATION(AnnotatePCQDestroy);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotatePCQCreate(char *f, int l, uptr pcq) {\n+  SCOPED_ANNOTATION(AnnotatePCQCreate);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateExpectRace(char *f, int l, uptr mem, char *desc) {\n+  SCOPED_ANNOTATION(AnnotateExpectRace);\n+  Lock lock(&dyn_ann_ctx->mtx);\n+  AddExpectRace(&dyn_ann_ctx->expect,\n+                f, l, mem, 1, desc);\n+  DPrintf(\"Add expected race: %s addr=%zx %s:%d\\n\", desc, mem, f, l);\n+}\n+\n+static void BenignRaceImpl(char *f, int l, uptr mem, uptr size, char *desc) {\n+  Lock lock(&dyn_ann_ctx->mtx);\n+  AddExpectRace(&dyn_ann_ctx->benign,\n+                f, l, mem, size, desc);\n+  DPrintf(\"Add benign race: %s addr=%zx %s:%d\\n\", desc, mem, f, l);\n+}\n+\n+// FIXME: Turn it off later. WTF is benign race?1?? Go talk to Hans Boehm.\n+// SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateBenignRaceSized(char *f, int l, uptr mem, uptr size, char *desc) {\n+  SCOPED_ANNOTATION(AnnotateBenignRaceSized);\n+  BenignRaceImpl(f, l, mem, size, desc);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateBenignRace(char *f, int l, uptr mem, char *desc) {\n+  SCOPED_ANNOTATION(AnnotateBenignRace);\n+  BenignRaceImpl(f, l, mem, 1, desc);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateIgnoreReadsBegin(char *f, int l) {\n+  SCOPED_ANNOTATION(AnnotateIgnoreReadsBegin);\n+  IgnoreCtl(cur_thread(), false, true);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateIgnoreReadsEnd(char *f, int l) {\n+  SCOPED_ANNOTATION(AnnotateIgnoreReadsEnd);\n+  IgnoreCtl(cur_thread(), false, false);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateIgnoreWritesBegin(char *f, int l) {\n+  SCOPED_ANNOTATION(AnnotateIgnoreWritesBegin);\n+  IgnoreCtl(cur_thread(), true, true);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateIgnoreWritesEnd(char *f, int l) {\n+  SCOPED_ANNOTATION(AnnotateIgnoreWritesEnd);\n+  IgnoreCtl(cur_thread(), true, false);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotatePublishMemoryRange(char *f, int l, uptr addr, uptr size) {\n+  SCOPED_ANNOTATION(AnnotatePublishMemoryRange);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateUnpublishMemoryRange(char *f, int l, uptr addr, uptr size) {\n+  SCOPED_ANNOTATION(AnnotateUnpublishMemoryRange);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void AnnotateThreadName(char *f, int l, char *name) {\n+  SCOPED_ANNOTATION(AnnotateThreadName);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void WTFAnnotateHappensBefore(char *f, int l, uptr addr) {\n+  SCOPED_ANNOTATION(AnnotateHappensBefore);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void WTFAnnotateHappensAfter(char *f, int l, uptr addr) {\n+  SCOPED_ANNOTATION(AnnotateHappensAfter);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+void WTFAnnotateBenignRaceSized(char *f, int l, uptr mem, uptr sz, char *desc) {\n+  SCOPED_ANNOTATION(AnnotateBenignRaceSized);\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+int RunningOnValgrind() {\n+  return flags()->running_on_valgrind;\n+}\n+\n+double __attribute__((weak)) ValgrindSlowdown(void) {\n+  return 10.0;\n+}\n+\n+SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n+const char *ThreadSanitizerQuery(const char *query) {\n+  if (internal_strcmp(query, \"pure_happens_before\") == 0)\n+    return \"1\";\n+  else\n+    return \"0\";\n+}\n+}  // extern \"C\""}, {"sha": "1dafe6152a8d1f7c2e1a06f9e5f7e44ee7f3bce2", "filename": "libsanitizer/tsan/tsan_interface_ann.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_ann.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_ann.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,29 @@\n+//===-- tsan_interface_ann.h ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Interface for dynamic annotations.\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_INTERFACE_ANN_H\n+#define TSAN_INTERFACE_ANN_H\n+\n+// This header should NOT include any other headers.\n+// All functions in this header are extern \"C\" and start with __tsan_.\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+void __tsan_acquire(void *addr);\n+void __tsan_release(void *addr);\n+\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // TSAN_INTERFACE_ANN_H"}, {"sha": "7b459f15d466a2eda92ed9c7c63a238078d4f4c8", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,368 @@\n+//===-- tsan_interface_atomic.cc ------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"tsan_interface_atomic.h\"\n+#include \"tsan_flags.h\"\n+#include \"tsan_rtl.h\"\n+\n+using namespace __tsan;  // NOLINT\n+\n+class ScopedAtomic {\n+ public:\n+  ScopedAtomic(ThreadState *thr, uptr pc, const char *func)\n+      : thr_(thr) {\n+    CHECK_EQ(thr_->in_rtl, 1);  // 1 due to our own ScopedInRtl member.\n+    DPrintf(\"#%d: %s\\n\", thr_->tid, func);\n+  }\n+  ~ScopedAtomic() {\n+    CHECK_EQ(thr_->in_rtl, 1);\n+  }\n+ private:\n+  ThreadState *thr_;\n+  ScopedInRtl in_rtl_;\n+};\n+\n+// Some shortcuts.\n+typedef __tsan_memory_order morder;\n+typedef __tsan_atomic8 a8;\n+typedef __tsan_atomic16 a16;\n+typedef __tsan_atomic32 a32;\n+typedef __tsan_atomic64 a64;\n+const int mo_relaxed = __tsan_memory_order_relaxed;\n+const int mo_consume = __tsan_memory_order_consume;\n+const int mo_acquire = __tsan_memory_order_acquire;\n+const int mo_release = __tsan_memory_order_release;\n+const int mo_acq_rel = __tsan_memory_order_acq_rel;\n+const int mo_seq_cst = __tsan_memory_order_seq_cst;\n+\n+static void AtomicStatInc(ThreadState *thr, uptr size, morder mo, StatType t) {\n+  StatInc(thr, StatAtomic);\n+  StatInc(thr, t);\n+  StatInc(thr, size == 1 ? StatAtomic1\n+             : size == 2 ? StatAtomic2\n+             : size == 4 ? StatAtomic4\n+             :             StatAtomic8);\n+  StatInc(thr, mo == mo_relaxed ? StatAtomicRelaxed\n+             : mo == mo_consume ? StatAtomicConsume\n+             : mo == mo_acquire ? StatAtomicAcquire\n+             : mo == mo_release ? StatAtomicRelease\n+             : mo == mo_acq_rel ? StatAtomicAcq_Rel\n+             :                    StatAtomicSeq_Cst);\n+}\n+\n+static bool IsLoadOrder(morder mo) {\n+  return mo == mo_relaxed || mo == mo_consume\n+      || mo == mo_acquire || mo == mo_seq_cst;\n+}\n+\n+static bool IsStoreOrder(morder mo) {\n+  return mo == mo_relaxed || mo == mo_release || mo == mo_seq_cst;\n+}\n+\n+static bool IsReleaseOrder(morder mo) {\n+  return mo == mo_release || mo == mo_acq_rel || mo == mo_seq_cst;\n+}\n+\n+static bool IsAcquireOrder(morder mo) {\n+  return mo == mo_consume || mo == mo_acquire\n+      || mo == mo_acq_rel || mo == mo_seq_cst;\n+}\n+\n+#define SCOPED_ATOMIC(func, ...) \\\n+    if ((u32)mo > 100500) mo = (morder)((u32)mo - 100500); \\\n+    mo = flags()->force_seq_cst_atomics ? (morder)mo_seq_cst : mo; \\\n+    ThreadState *const thr = cur_thread(); \\\n+    const uptr pc = (uptr)__builtin_return_address(0); \\\n+    AtomicStatInc(thr, sizeof(*a), mo, StatAtomic##func); \\\n+    ScopedAtomic sa(thr, pc, __FUNCTION__); \\\n+    return Atomic##func(thr, pc, __VA_ARGS__); \\\n+/**/\n+\n+template<typename T>\n+static T AtomicLoad(ThreadState *thr, uptr pc, const volatile T *a,\n+    morder mo) {\n+  CHECK(IsLoadOrder(mo));\n+  T v = *a;\n+  if (IsAcquireOrder(mo))\n+    Acquire(thr, pc, (uptr)a);\n+  return v;\n+}\n+\n+template<typename T>\n+static void AtomicStore(ThreadState *thr, uptr pc, volatile T *a, T v,\n+    morder mo) {\n+  CHECK(IsStoreOrder(mo));\n+  if (IsReleaseOrder(mo))\n+    ReleaseStore(thr, pc, (uptr)a);\n+  *a = v;\n+}\n+\n+template<typename T>\n+static T AtomicExchange(ThreadState *thr, uptr pc, volatile T *a, T v,\n+    morder mo) {\n+  if (IsReleaseOrder(mo))\n+    Release(thr, pc, (uptr)a);\n+  v = __sync_lock_test_and_set(a, v);\n+  if (IsAcquireOrder(mo))\n+    Acquire(thr, pc, (uptr)a);\n+  return v;\n+}\n+\n+template<typename T>\n+static T AtomicFetchAdd(ThreadState *thr, uptr pc, volatile T *a, T v,\n+    morder mo) {\n+  if (IsReleaseOrder(mo))\n+    Release(thr, pc, (uptr)a);\n+  v = __sync_fetch_and_add(a, v);\n+  if (IsAcquireOrder(mo))\n+    Acquire(thr, pc, (uptr)a);\n+  return v;\n+}\n+\n+template<typename T>\n+static T AtomicFetchSub(ThreadState *thr, uptr pc, volatile T *a, T v,\n+    morder mo) {\n+  if (IsReleaseOrder(mo))\n+    Release(thr, pc, (uptr)a);\n+  v = __sync_fetch_and_sub(a, v);\n+  if (IsAcquireOrder(mo))\n+    Acquire(thr, pc, (uptr)a);\n+  return v;\n+}\n+\n+template<typename T>\n+static T AtomicFetchAnd(ThreadState *thr, uptr pc, volatile T *a, T v,\n+    morder mo) {\n+  if (IsReleaseOrder(mo))\n+    Release(thr, pc, (uptr)a);\n+  v = __sync_fetch_and_and(a, v);\n+  if (IsAcquireOrder(mo))\n+    Acquire(thr, pc, (uptr)a);\n+  return v;\n+}\n+\n+template<typename T>\n+static T AtomicFetchOr(ThreadState *thr, uptr pc, volatile T *a, T v,\n+    morder mo) {\n+  if (IsReleaseOrder(mo))\n+    Release(thr, pc, (uptr)a);\n+  v = __sync_fetch_and_or(a, v);\n+  if (IsAcquireOrder(mo))\n+    Acquire(thr, pc, (uptr)a);\n+  return v;\n+}\n+\n+template<typename T>\n+static T AtomicFetchXor(ThreadState *thr, uptr pc, volatile T *a, T v,\n+    morder mo) {\n+  if (IsReleaseOrder(mo))\n+    Release(thr, pc, (uptr)a);\n+  v = __sync_fetch_and_xor(a, v);\n+  if (IsAcquireOrder(mo))\n+    Acquire(thr, pc, (uptr)a);\n+  return v;\n+}\n+\n+template<typename T>\n+static bool AtomicCAS(ThreadState *thr, uptr pc,\n+    volatile T *a, T *c, T v, morder mo) {\n+  if (IsReleaseOrder(mo))\n+    Release(thr, pc, (uptr)a);\n+  T cc = *c;\n+  T pr = __sync_val_compare_and_swap(a, cc, v);\n+  if (IsAcquireOrder(mo))\n+    Acquire(thr, pc, (uptr)a);\n+  if (pr == cc)\n+    return true;\n+  *c = pr;\n+  return false;\n+}\n+\n+static void AtomicFence(ThreadState *thr, uptr pc, morder mo) {\n+  __sync_synchronize();\n+}\n+\n+a8 __tsan_atomic8_load(const volatile a8 *a, morder mo) {\n+  SCOPED_ATOMIC(Load, a, mo);\n+}\n+\n+a16 __tsan_atomic16_load(const volatile a16 *a, morder mo) {\n+  SCOPED_ATOMIC(Load, a, mo);\n+}\n+\n+a32 __tsan_atomic32_load(const volatile a32 *a, morder mo) {\n+  SCOPED_ATOMIC(Load, a, mo);\n+}\n+\n+a64 __tsan_atomic64_load(const volatile a64 *a, morder mo) {\n+  SCOPED_ATOMIC(Load, a, mo);\n+}\n+\n+void __tsan_atomic8_store(volatile a8 *a, a8 v, morder mo) {\n+  SCOPED_ATOMIC(Store, a, v, mo);\n+}\n+\n+void __tsan_atomic16_store(volatile a16 *a, a16 v, morder mo) {\n+  SCOPED_ATOMIC(Store, a, v, mo);\n+}\n+\n+void __tsan_atomic32_store(volatile a32 *a, a32 v, morder mo) {\n+  SCOPED_ATOMIC(Store, a, v, mo);\n+}\n+\n+void __tsan_atomic64_store(volatile a64 *a, a64 v, morder mo) {\n+  SCOPED_ATOMIC(Store, a, v, mo);\n+}\n+\n+a8 __tsan_atomic8_exchange(volatile a8 *a, a8 v, morder mo) {\n+  SCOPED_ATOMIC(Exchange, a, v, mo);\n+}\n+\n+a16 __tsan_atomic16_exchange(volatile a16 *a, a16 v, morder mo) {\n+  SCOPED_ATOMIC(Exchange, a, v, mo);\n+}\n+\n+a32 __tsan_atomic32_exchange(volatile a32 *a, a32 v, morder mo) {\n+  SCOPED_ATOMIC(Exchange, a, v, mo);\n+}\n+\n+a64 __tsan_atomic64_exchange(volatile a64 *a, a64 v, morder mo) {\n+  SCOPED_ATOMIC(Exchange, a, v, mo);\n+}\n+\n+a8 __tsan_atomic8_fetch_add(volatile a8 *a, a8 v, morder mo) {\n+  SCOPED_ATOMIC(FetchAdd, a, v, mo);\n+}\n+\n+a16 __tsan_atomic16_fetch_add(volatile a16 *a, a16 v, morder mo) {\n+  SCOPED_ATOMIC(FetchAdd, a, v, mo);\n+}\n+\n+a32 __tsan_atomic32_fetch_add(volatile a32 *a, a32 v, morder mo) {\n+  SCOPED_ATOMIC(FetchAdd, a, v, mo);\n+}\n+\n+a64 __tsan_atomic64_fetch_add(volatile a64 *a, a64 v, morder mo) {\n+  SCOPED_ATOMIC(FetchAdd, a, v, mo);\n+}\n+\n+a8 __tsan_atomic8_fetch_sub(volatile a8 *a, a8 v, morder mo) {\n+  SCOPED_ATOMIC(FetchSub, a, v, mo);\n+}\n+\n+a16 __tsan_atomic16_fetch_sub(volatile a16 *a, a16 v, morder mo) {\n+  SCOPED_ATOMIC(FetchSub, a, v, mo);\n+}\n+\n+a32 __tsan_atomic32_fetch_sub(volatile a32 *a, a32 v, morder mo) {\n+  SCOPED_ATOMIC(FetchSub, a, v, mo);\n+}\n+\n+a64 __tsan_atomic64_fetch_sub(volatile a64 *a, a64 v, morder mo) {\n+  SCOPED_ATOMIC(FetchSub, a, v, mo);\n+}\n+\n+a8 __tsan_atomic8_fetch_and(volatile a8 *a, a8 v, morder mo) {\n+  SCOPED_ATOMIC(FetchAnd, a, v, mo);\n+}\n+\n+a16 __tsan_atomic16_fetch_and(volatile a16 *a, a16 v, morder mo) {\n+  SCOPED_ATOMIC(FetchAnd, a, v, mo);\n+}\n+\n+a32 __tsan_atomic32_fetch_and(volatile a32 *a, a32 v, morder mo) {\n+  SCOPED_ATOMIC(FetchAnd, a, v, mo);\n+}\n+\n+a64 __tsan_atomic64_fetch_and(volatile a64 *a, a64 v, morder mo) {\n+  SCOPED_ATOMIC(FetchAnd, a, v, mo);\n+}\n+\n+a8 __tsan_atomic8_fetch_or(volatile a8 *a, a8 v, morder mo) {\n+  SCOPED_ATOMIC(FetchOr, a, v, mo);\n+}\n+\n+a16 __tsan_atomic16_fetch_or(volatile a16 *a, a16 v, morder mo) {\n+  SCOPED_ATOMIC(FetchOr, a, v, mo);\n+}\n+\n+a32 __tsan_atomic32_fetch_or(volatile a32 *a, a32 v, morder mo) {\n+  SCOPED_ATOMIC(FetchOr, a, v, mo);\n+}\n+\n+a64 __tsan_atomic64_fetch_or(volatile a64 *a, a64 v, morder mo) {\n+  SCOPED_ATOMIC(FetchOr, a, v, mo);\n+}\n+\n+a8 __tsan_atomic8_fetch_xor(volatile a8 *a, a8 v, morder mo) {\n+  SCOPED_ATOMIC(FetchXor, a, v, mo);\n+}\n+\n+a16 __tsan_atomic16_fetch_xor(volatile a16 *a, a16 v, morder mo) {\n+  SCOPED_ATOMIC(FetchXor, a, v, mo);\n+}\n+\n+a32 __tsan_atomic32_fetch_xor(volatile a32 *a, a32 v, morder mo) {\n+  SCOPED_ATOMIC(FetchXor, a, v, mo);\n+}\n+\n+a64 __tsan_atomic64_fetch_xor(volatile a64 *a, a64 v, morder mo) {\n+  SCOPED_ATOMIC(FetchXor, a, v, mo);\n+}\n+\n+int __tsan_atomic8_compare_exchange_strong(volatile a8 *a, a8 *c, a8 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+int __tsan_atomic16_compare_exchange_strong(volatile a16 *a, a16 *c, a16 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+int __tsan_atomic32_compare_exchange_strong(volatile a32 *a, a32 *c, a32 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+int __tsan_atomic64_compare_exchange_strong(volatile a64 *a, a64 *c, a64 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+int __tsan_atomic8_compare_exchange_weak(volatile a8 *a, a8 *c, a8 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+int __tsan_atomic16_compare_exchange_weak(volatile a16 *a, a16 *c, a16 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+int __tsan_atomic32_compare_exchange_weak(volatile a32 *a, a32 *c, a32 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+int __tsan_atomic64_compare_exchange_weak(volatile a64 *a, a64 *c, a64 v,\n+    morder mo) {\n+  SCOPED_ATOMIC(CAS, a, c, v, mo);\n+}\n+\n+void __tsan_atomic_thread_fence(morder mo) {\n+  char* a;\n+  SCOPED_ATOMIC(Fence, mo);\n+}\n+\n+void __tsan_atomic_signal_fence(morder mo) {\n+}"}, {"sha": "37532ce41856a666b2630433489c5c1cc7949321", "filename": "libsanitizer/tsan/tsan_interface_atomic.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,173 @@\n+//===-- tsan_interface_atomic.h ---------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_INTERFACE_ATOMIC_H\n+#define TSAN_INTERFACE_ATOMIC_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef char  __tsan_atomic8;\n+typedef short __tsan_atomic16;  // NOLINT\n+typedef int   __tsan_atomic32;\n+typedef long  __tsan_atomic64;  // NOLINT\n+\n+// Part of ABI, do not change.\n+// http://llvm.org/viewvc/llvm-project/libcxx/trunk/include/atomic?view=markup\n+typedef enum {\n+  __tsan_memory_order_relaxed = 1 << 0,\n+  __tsan_memory_order_consume = 1 << 1,\n+  __tsan_memory_order_acquire = 1 << 2,\n+  __tsan_memory_order_release = 1 << 3,\n+  __tsan_memory_order_acq_rel = 1 << 4,\n+  __tsan_memory_order_seq_cst = 1 << 5\n+} __tsan_memory_order;\n+\n+__tsan_atomic8 __tsan_atomic8_load(const volatile __tsan_atomic8 *a,\n+    __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic16 __tsan_atomic16_load(const volatile __tsan_atomic16 *a,\n+    __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic32 __tsan_atomic32_load(const volatile __tsan_atomic32 *a,\n+    __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic64 __tsan_atomic64_load(const volatile __tsan_atomic64 *a,\n+    __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_atomic8_store(volatile __tsan_atomic8 *a, __tsan_atomic8 v,\n+    __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_atomic16_store(volatile __tsan_atomic16 *a, __tsan_atomic16 v,\n+    __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_atomic32_store(volatile __tsan_atomic32 *a, __tsan_atomic32 v,\n+    __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_atomic64_store(volatile __tsan_atomic64 *a, __tsan_atomic64 v,\n+    __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+__tsan_atomic8 __tsan_atomic8_exchange(volatile __tsan_atomic8 *a,\n+    __tsan_atomic8 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic16 __tsan_atomic16_exchange(volatile __tsan_atomic16 *a,\n+    __tsan_atomic16 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic32 __tsan_atomic32_exchange(volatile __tsan_atomic32 *a,\n+    __tsan_atomic32 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic64 __tsan_atomic64_exchange(volatile __tsan_atomic64 *a, \n+    __tsan_atomic64 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+__tsan_atomic8 __tsan_atomic8_fetch_add(volatile __tsan_atomic8 *a,\n+    __tsan_atomic8 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic16 __tsan_atomic16_fetch_add(volatile __tsan_atomic16 *a,\n+    __tsan_atomic16 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic32 __tsan_atomic32_fetch_add(volatile __tsan_atomic32 *a,\n+    __tsan_atomic32 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic64 __tsan_atomic64_fetch_add(volatile __tsan_atomic64 *a,\n+    __tsan_atomic64 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+__tsan_atomic8 __tsan_atomic8_fetch_sub(volatile __tsan_atomic8 *a,\n+    __tsan_atomic8 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic16 __tsan_atomic16_fetch_sub(volatile __tsan_atomic16 *a,\n+    __tsan_atomic16 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic32 __tsan_atomic32_fetch_sub(volatile __tsan_atomic32 *a,\n+    __tsan_atomic32 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic64 __tsan_atomic64_fetch_sub(volatile __tsan_atomic64 *a,\n+    __tsan_atomic64 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+__tsan_atomic8 __tsan_atomic8_fetch_and(volatile __tsan_atomic8 *a,\n+    __tsan_atomic8 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic16 __tsan_atomic16_fetch_and(volatile __tsan_atomic16 *a,\n+    __tsan_atomic16 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic32 __tsan_atomic32_fetch_and(volatile __tsan_atomic32 *a,\n+    __tsan_atomic32 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic64 __tsan_atomic64_fetch_and(volatile __tsan_atomic64 *a,\n+    __tsan_atomic64 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+__tsan_atomic8 __tsan_atomic8_fetch_or(volatile __tsan_atomic8 *a,\n+    __tsan_atomic8 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic16 __tsan_atomic16_fetch_or(volatile __tsan_atomic16 *a,\n+    __tsan_atomic16 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic32 __tsan_atomic32_fetch_or(volatile __tsan_atomic32 *a,\n+    __tsan_atomic32 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic64 __tsan_atomic64_fetch_or(volatile __tsan_atomic64 *a,\n+    __tsan_atomic64 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+__tsan_atomic8 __tsan_atomic8_fetch_xor(volatile __tsan_atomic8 *a,\n+    __tsan_atomic8 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic16 __tsan_atomic16_fetch_xor(volatile __tsan_atomic16 *a,\n+    __tsan_atomic16 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic32 __tsan_atomic32_fetch_xor(volatile __tsan_atomic32 *a,\n+    __tsan_atomic32 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+__tsan_atomic64 __tsan_atomic64_fetch_xor(volatile __tsan_atomic64 *a,\n+    __tsan_atomic64 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+int __tsan_atomic8_compare_exchange_weak(volatile __tsan_atomic8 *a,\n+    __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+int __tsan_atomic16_compare_exchange_weak(volatile __tsan_atomic16 *a,\n+    __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+int __tsan_atomic32_compare_exchange_weak(volatile __tsan_atomic32 *a,\n+    __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+int __tsan_atomic64_compare_exchange_weak(volatile __tsan_atomic64 *a,\n+    __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+int __tsan_atomic8_compare_exchange_strong(volatile __tsan_atomic8 *a,\n+    __tsan_atomic8 *c, __tsan_atomic8 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+int __tsan_atomic16_compare_exchange_strong(volatile __tsan_atomic16 *a,\n+    __tsan_atomic16 *c, __tsan_atomic16 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+int __tsan_atomic32_compare_exchange_strong(volatile __tsan_atomic32 *a,\n+    __tsan_atomic32 *c, __tsan_atomic32 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+int __tsan_atomic64_compare_exchange_strong(volatile __tsan_atomic64 *a,\n+    __tsan_atomic64 *c, __tsan_atomic64 v, __tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+void __tsan_atomic_thread_fence(__tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+void __tsan_atomic_signal_fence(__tsan_memory_order mo)\n+    SANITIZER_WEAK_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE;\n+\n+#ifdef __cplusplus\n+}  // extern \"C\"\n+#endif\n+\n+#endif  // #ifndef TSAN_INTERFACE_ATOMIC_H"}, {"sha": "493e3f7778ed4dccecf824da183e071de08f2777", "filename": "libsanitizer/tsan/tsan_interface_inl.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_interface_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_inl.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,63 @@\n+//===-- tsan_interface_inl.h ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"tsan_interface.h\"\n+#include \"tsan_rtl.h\"\n+\n+#define CALLERPC ((uptr)__builtin_return_address(0))\n+\n+using namespace __tsan;  // NOLINT\n+\n+void __tsan_read1(void *addr) {\n+  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 0, 0);\n+}\n+\n+void __tsan_read2(void *addr) {\n+  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 1, 0);\n+}\n+\n+void __tsan_read4(void *addr) {\n+  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 2, 0);\n+}\n+\n+void __tsan_read8(void *addr) {\n+  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 3, 0);\n+}\n+\n+void __tsan_write1(void *addr) {\n+  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 0, 1);\n+}\n+\n+void __tsan_write2(void *addr) {\n+  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 1, 1);\n+}\n+\n+void __tsan_write4(void *addr) {\n+  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 2, 1);\n+}\n+\n+void __tsan_write8(void *addr) {\n+  MemoryAccess(cur_thread(), CALLERPC, (uptr)addr, 3, 1);\n+}\n+\n+void __tsan_vptr_update(void **vptr_p, void *new_val) {\n+  CHECK_EQ(sizeof(vptr_p), 8);\n+  if (*vptr_p != new_val)\n+    MemoryAccess(cur_thread(), CALLERPC, (uptr)vptr_p, 3, 1);\n+}\n+\n+void __tsan_func_entry(void *pc) {\n+  FuncEntry(cur_thread(), (uptr)pc);\n+}\n+\n+void __tsan_func_exit() {\n+  FuncExit(cur_thread());\n+}"}, {"sha": "6df823dae98226922360845aa323f591b31afff2", "filename": "libsanitizer/tsan/tsan_md5.cc", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_md5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_md5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_md5.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,243 @@\n+//===-- tsan_md5.cc -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"tsan_defs.h\"\n+\n+namespace __tsan {\n+\n+#define F(x, y, z)      ((z) ^ ((x) & ((y) ^ (z))))\n+#define G(x, y, z)      ((y) ^ ((z) & ((x) ^ (y))))\n+#define H(x, y, z)      ((x) ^ (y) ^ (z))\n+#define I(x, y, z)      ((y) ^ ((x) | ~(z)))\n+\n+#define STEP(f, a, b, c, d, x, t, s) \\\n+  (a) += f((b), (c), (d)) + (x) + (t); \\\n+  (a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s)))); \\\n+  (a) += (b);\n+\n+#define SET(n) \\\n+  (*(MD5_u32plus *)&ptr[(n) * 4])\n+#define GET(n) \\\n+  SET(n)\n+\n+typedef unsigned int MD5_u32plus;\n+typedef unsigned long ulong_t;  // NOLINT\n+\n+typedef struct {\n+  MD5_u32plus lo, hi;\n+  MD5_u32plus a, b, c, d;\n+  unsigned char buffer[64];\n+  MD5_u32plus block[16];\n+} MD5_CTX;\n+\n+static void *body(MD5_CTX *ctx, void *data, ulong_t size) {\n+  unsigned char *ptr;\n+  MD5_u32plus a, b, c, d;\n+  MD5_u32plus saved_a, saved_b, saved_c, saved_d;\n+\n+  ptr = (unsigned char*)data;\n+\n+  a = ctx->a;\n+  b = ctx->b;\n+  c = ctx->c;\n+  d = ctx->d;\n+\n+  do {\n+    saved_a = a;\n+    saved_b = b;\n+    saved_c = c;\n+    saved_d = d;\n+\n+    STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)\n+    STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)\n+    STEP(F, c, d, a, b, SET(2), 0x242070db, 17)\n+    STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)\n+    STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)\n+    STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)\n+    STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)\n+    STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)\n+    STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)\n+    STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)\n+    STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)\n+    STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)\n+    STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)\n+    STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)\n+    STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)\n+    STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)\n+\n+    STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)\n+    STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)\n+    STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)\n+    STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)\n+    STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)\n+    STEP(G, d, a, b, c, GET(10), 0x02441453, 9)\n+    STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)\n+    STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)\n+    STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)\n+    STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)\n+    STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)\n+    STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)\n+    STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)\n+    STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)\n+    STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)\n+    STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)\n+\n+    STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)\n+    STEP(H, d, a, b, c, GET(8), 0x8771f681, 11)\n+    STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)\n+    STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23)\n+    STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)\n+    STEP(H, d, a, b, c, GET(4), 0x4bdecfa9, 11)\n+    STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)\n+    STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23)\n+    STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)\n+    STEP(H, d, a, b, c, GET(0), 0xeaa127fa, 11)\n+    STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)\n+    STEP(H, b, c, d, a, GET(6), 0x04881d05, 23)\n+    STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)\n+    STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11)\n+    STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)\n+    STEP(H, b, c, d, a, GET(2), 0xc4ac5665, 23)\n+\n+    STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)\n+    STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)\n+    STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)\n+    STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)\n+    STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)\n+    STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)\n+    STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)\n+    STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)\n+    STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)\n+    STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)\n+    STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)\n+    STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)\n+    STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)\n+    STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)\n+    STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)\n+    STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)\n+\n+    a += saved_a;\n+    b += saved_b;\n+    c += saved_c;\n+    d += saved_d;\n+\n+    ptr += 64;\n+  } while (size -= 64);\n+\n+  ctx->a = a;\n+  ctx->b = b;\n+  ctx->c = c;\n+  ctx->d = d;\n+\n+  return ptr;\n+}\n+\n+void MD5_Init(MD5_CTX *ctx) {\n+  ctx->a = 0x67452301;\n+  ctx->b = 0xefcdab89;\n+  ctx->c = 0x98badcfe;\n+  ctx->d = 0x10325476;\n+\n+  ctx->lo = 0;\n+  ctx->hi = 0;\n+}\n+\n+void MD5_Update(MD5_CTX *ctx, void *data, ulong_t size) {\n+  MD5_u32plus saved_lo;\n+  ulong_t used, free;\n+\n+  saved_lo = ctx->lo;\n+  if ((ctx->lo = (saved_lo + size) & 0x1fffffff) < saved_lo)\n+    ctx->hi++;\n+  ctx->hi += size >> 29;\n+\n+  used = saved_lo & 0x3f;\n+\n+  if (used) {\n+    free = 64 - used;\n+\n+    if (size < free) {\n+      internal_memcpy(&ctx->buffer[used], data, size);\n+      return;\n+    }\n+\n+    internal_memcpy(&ctx->buffer[used], data, free);\n+    data = (unsigned char *)data + free;\n+    size -= free;\n+    body(ctx, ctx->buffer, 64);\n+  }\n+\n+  if (size >= 64) {\n+    data = body(ctx, data, size & ~(ulong_t)0x3f);\n+    size &= 0x3f;\n+  }\n+\n+  internal_memcpy(ctx->buffer, data, size);\n+}\n+\n+void MD5_Final(unsigned char *result, MD5_CTX *ctx) {\n+  ulong_t used, free;\n+\n+  used = ctx->lo & 0x3f;\n+\n+  ctx->buffer[used++] = 0x80;\n+\n+  free = 64 - used;\n+\n+  if (free < 8) {\n+    internal_memset(&ctx->buffer[used], 0, free);\n+    body(ctx, ctx->buffer, 64);\n+    used = 0;\n+    free = 64;\n+  }\n+\n+  internal_memset(&ctx->buffer[used], 0, free - 8);\n+\n+  ctx->lo <<= 3;\n+  ctx->buffer[56] = ctx->lo;\n+  ctx->buffer[57] = ctx->lo >> 8;\n+  ctx->buffer[58] = ctx->lo >> 16;\n+  ctx->buffer[59] = ctx->lo >> 24;\n+  ctx->buffer[60] = ctx->hi;\n+  ctx->buffer[61] = ctx->hi >> 8;\n+  ctx->buffer[62] = ctx->hi >> 16;\n+  ctx->buffer[63] = ctx->hi >> 24;\n+\n+  body(ctx, ctx->buffer, 64);\n+\n+  result[0] = ctx->a;\n+  result[1] = ctx->a >> 8;\n+  result[2] = ctx->a >> 16;\n+  result[3] = ctx->a >> 24;\n+  result[4] = ctx->b;\n+  result[5] = ctx->b >> 8;\n+  result[6] = ctx->b >> 16;\n+  result[7] = ctx->b >> 24;\n+  result[8] = ctx->c;\n+  result[9] = ctx->c >> 8;\n+  result[10] = ctx->c >> 16;\n+  result[11] = ctx->c >> 24;\n+  result[12] = ctx->d;\n+  result[13] = ctx->d >> 8;\n+  result[14] = ctx->d >> 16;\n+  result[15] = ctx->d >> 24;\n+\n+  internal_memset(ctx, 0, sizeof(*ctx));\n+}\n+\n+MD5Hash md5_hash(const void *data, uptr size) {\n+  MD5Hash res;\n+  MD5_CTX ctx;\n+  MD5_Init(&ctx);\n+  MD5_Update(&ctx, (void*)data, size);\n+  MD5_Final((unsigned char*)&res.hash[0], &ctx);\n+  return res;\n+}\n+}"}, {"sha": "ba4252eccc5ddd7943e0d3db651105b11fb7828d", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,159 @@\n+//===-- tsan_mman.cc ------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"tsan_mman.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_report.h\"\n+#include \"tsan_flags.h\"\n+\n+// May be overriden by front-end.\n+extern \"C\" void WEAK __tsan_malloc_hook(void *ptr, uptr size) {\n+  (void)ptr;\n+  (void)size;\n+}\n+\n+extern \"C\" void WEAK __tsan_free_hook(void *ptr) {\n+  (void)ptr;\n+}\n+\n+namespace __tsan {\n+\n+static char allocator_placeholder[sizeof(Allocator)] ALIGNED(64);\n+Allocator *allocator() {\n+  return reinterpret_cast<Allocator*>(&allocator_placeholder);\n+}\n+\n+void InitializeAllocator() {\n+  allocator()->Init();\n+}\n+\n+void AlloctorThreadFinish(ThreadState *thr) {\n+  allocator()->SwallowCache(&thr->alloc_cache);\n+}\n+\n+static void SignalUnsafeCall(ThreadState *thr, uptr pc) {\n+  if (!thr->in_signal_handler || !flags()->report_signal_unsafe)\n+    return;\n+  Context *ctx = CTX();\n+  StackTrace stack;\n+  stack.ObtainCurrent(thr, pc);\n+  ScopedReport rep(ReportTypeSignalUnsafe);\n+  if (!IsFiredSuppression(ctx, rep, stack)) {\n+    rep.AddStack(&stack);\n+    OutputReport(ctx, rep, rep.GetReport()->stacks[0]);\n+  }\n+}\n+\n+void *user_alloc(ThreadState *thr, uptr pc, uptr sz, uptr align) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  void *p = allocator()->Allocate(&thr->alloc_cache, sz, align);\n+  if (p == 0)\n+    return 0;\n+  MBlock *b = (MBlock*)allocator()->GetMetaData(p);\n+  b->size = sz;\n+  b->alloc_tid = thr->unique_id;\n+  b->alloc_stack_id = CurrentStackId(thr, pc);\n+  if (CTX() && CTX()->initialized) {\n+    MemoryRangeImitateWrite(thr, pc, (uptr)p, sz);\n+  }\n+  DPrintf(\"#%d: alloc(%zu) = %p\\n\", thr->tid, sz, p);\n+  SignalUnsafeCall(thr, pc);\n+  return p;\n+}\n+\n+void user_free(ThreadState *thr, uptr pc, void *p) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  CHECK_NE(p, (void*)0);\n+  DPrintf(\"#%d: free(%p)\\n\", thr->tid, p);\n+  MBlock *b = (MBlock*)allocator()->GetMetaData(p);\n+  if (b->head)   {\n+    Lock l(&b->mtx);\n+    for (SyncVar *s = b->head; s;) {\n+      SyncVar *res = s;\n+      s = s->next;\n+      StatInc(thr, StatSyncDestroyed);\n+      res->mtx.Lock();\n+      res->mtx.Unlock();\n+      DestroyAndFree(res);\n+    }\n+    b->head = 0;\n+  }\n+  if (CTX() && CTX()->initialized && thr->in_rtl == 1) {\n+    MemoryRangeFreed(thr, pc, (uptr)p, b->size);\n+  }\n+  allocator()->Deallocate(&thr->alloc_cache, p);\n+  SignalUnsafeCall(thr, pc);\n+}\n+\n+void *user_realloc(ThreadState *thr, uptr pc, void *p, uptr sz) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  void *p2 = 0;\n+  // FIXME: Handle \"shrinking\" more efficiently,\n+  // it seems that some software actually does this.\n+  if (sz) {\n+    p2 = user_alloc(thr, pc, sz);\n+    if (p2 == 0)\n+      return 0;\n+    if (p) {\n+      MBlock *b = user_mblock(thr, p);\n+      internal_memcpy(p2, p, min(b->size, sz));\n+    }\n+  }\n+  if (p) {\n+    user_free(thr, pc, p);\n+  }\n+  return p2;\n+}\n+\n+MBlock *user_mblock(ThreadState *thr, void *p) {\n+  // CHECK_GT(thr->in_rtl, 0);\n+  CHECK_NE(p, (void*)0);\n+  return (MBlock*)allocator()->GetMetaData(p);\n+}\n+\n+void invoke_malloc_hook(void *ptr, uptr size) {\n+  Context *ctx = CTX();\n+  ThreadState *thr = cur_thread();\n+  if (ctx == 0 || !ctx->initialized || thr->in_rtl)\n+    return;\n+  __tsan_malloc_hook(ptr, size);\n+}\n+\n+void invoke_free_hook(void *ptr) {\n+  Context *ctx = CTX();\n+  ThreadState *thr = cur_thread();\n+  if (ctx == 0 || !ctx->initialized || thr->in_rtl)\n+    return;\n+  __tsan_free_hook(ptr);\n+}\n+\n+void *internal_alloc(MBlockType typ, uptr sz) {\n+  ThreadState *thr = cur_thread();\n+  CHECK_GT(thr->in_rtl, 0);\n+  if (thr->nomalloc) {\n+    thr->nomalloc = 0;  // CHECK calls internal_malloc().\n+    CHECK(0);\n+  }\n+  return InternalAlloc(sz);\n+}\n+\n+void internal_free(void *p) {\n+  ThreadState *thr = cur_thread();\n+  CHECK_GT(thr->in_rtl, 0);\n+  if (thr->nomalloc) {\n+    thr->nomalloc = 0;  // CHECK calls internal_malloc().\n+    CHECK(0);\n+  }\n+  InternalFree(p);\n+}\n+\n+}  // namespace __tsan"}, {"sha": "326bda7ebd774d2c42e057877bad8a3f7bc0ebbb", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,77 @@\n+//===-- tsan_mman.h ---------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_MMAN_H\n+#define TSAN_MMAN_H\n+\n+#include \"tsan_defs.h\"\n+\n+namespace __tsan {\n+\n+const uptr kDefaultAlignment = 16;\n+\n+void InitializeAllocator();\n+void AlloctorThreadFinish(ThreadState *thr);\n+\n+// For user allocations.\n+void *user_alloc(ThreadState *thr, uptr pc, uptr sz,\n+                 uptr align = kDefaultAlignment);\n+// Does not accept NULL.\n+void user_free(ThreadState *thr, uptr pc, void *p);\n+void *user_realloc(ThreadState *thr, uptr pc, void *p, uptr sz);\n+void *user_alloc_aligned(ThreadState *thr, uptr pc, uptr sz, uptr align);\n+// Given the pointer p into a valid allocated block,\n+// returns the descriptor of the block.\n+MBlock *user_mblock(ThreadState *thr, void *p);\n+\n+// Invoking malloc/free hooks that may be installed by the user.\n+void invoke_malloc_hook(void *ptr, uptr size);\n+void invoke_free_hook(void *ptr);\n+\n+enum MBlockType {\n+  MBlockScopedBuf,\n+  MBlockString,\n+  MBlockStackTrace,\n+  MBlockShadowStack,\n+  MBlockSync,\n+  MBlockClock,\n+  MBlockThreadContex,\n+  MBlockDeadInfo,\n+  MBlockRacyStacks,\n+  MBlockRacyAddresses,\n+  MBlockAtExit,\n+  MBlockFlag,\n+  MBlockReport,\n+  MBlockReportMop,\n+  MBlockReportThread,\n+  MBlockReportMutex,\n+  MBlockReportLoc,\n+  MBlockReportStack,\n+  MBlockSuppression,\n+  MBlockExpectRace,\n+  MBlockSignal,\n+\n+  // This must be the last.\n+  MBlockTypeCount\n+};\n+\n+// For internal data structures.\n+void *internal_alloc(MBlockType typ, uptr sz);\n+void internal_free(void *p);\n+\n+template<typename T>\n+void DestroyAndFree(T *&p) {\n+  p->~T();\n+  internal_free(p);\n+  p = 0;\n+}\n+\n+}  // namespace __tsan\n+#endif  // TSAN_MMAN_H"}, {"sha": "83af02992b493ac129b503728becb17269bf6396", "filename": "libsanitizer/tsan/tsan_mutex.cc", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,261 @@\n+//===-- tsan_mutex.cc -----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"tsan_mutex.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+\n+namespace __tsan {\n+\n+// Simple reader-writer spin-mutex. Optimized for not-so-contended case.\n+// Readers have preference, can possibly starvate writers.\n+\n+// The table fixes what mutexes can be locked under what mutexes.\n+// E.g. if the row for MutexTypeThreads contains MutexTypeReport,\n+// then Report mutex can be locked while under Threads mutex.\n+// The leaf mutexes can be locked under any other mutexes.\n+// Recursive locking is not supported.\n+const MutexType MutexTypeLeaf = (MutexType)-1;\n+static MutexType CanLockTab[MutexTypeCount][MutexTypeCount] = {\n+  /*0 MutexTypeInvalid*/     {},\n+  /*1 MutexTypeTrace*/       {MutexTypeLeaf},\n+  /*2 MutexTypeThreads*/     {MutexTypeReport},\n+  /*3 MutexTypeReport*/      {},\n+  /*4 MutexTypeSyncVar*/     {},\n+  /*5 MutexTypeSyncTab*/     {MutexTypeSyncVar},\n+  /*6 MutexTypeSlab*/        {MutexTypeLeaf},\n+  /*7 MutexTypeAnnotations*/ {},\n+  /*8 MutexTypeAtExit*/      {MutexTypeSyncTab},\n+};\n+\n+static bool CanLockAdj[MutexTypeCount][MutexTypeCount];\n+\n+void InitializeMutex() {\n+  // Build the \"can lock\" adjacency matrix.\n+  // If [i][j]==true, then one can lock mutex j while under mutex i.\n+  const int N = MutexTypeCount;\n+  int cnt[N] = {};\n+  bool leaf[N] = {};\n+  for (int i = 1; i < N; i++) {\n+    for (int j = 0; j < N; j++) {\n+      MutexType z = CanLockTab[i][j];\n+      if (z == MutexTypeInvalid)\n+        continue;\n+      if (z == MutexTypeLeaf) {\n+        CHECK(!leaf[i]);\n+        leaf[i] = true;\n+        continue;\n+      }\n+      CHECK(!CanLockAdj[i][(int)z]);\n+      CanLockAdj[i][(int)z] = true;\n+      cnt[i]++;\n+    }\n+  }\n+  for (int i = 0; i < N; i++) {\n+    CHECK(!leaf[i] || cnt[i] == 0);\n+  }\n+  // Add leaf mutexes.\n+  for (int i = 0; i < N; i++) {\n+    if (!leaf[i])\n+      continue;\n+    for (int j = 0; j < N; j++) {\n+      if (i == j || leaf[j] || j == MutexTypeInvalid)\n+        continue;\n+      CHECK(!CanLockAdj[j][i]);\n+      CanLockAdj[j][i] = true;\n+    }\n+  }\n+  // Build the transitive closure.\n+  bool CanLockAdj2[MutexTypeCount][MutexTypeCount];\n+  for (int i = 0; i < N; i++) {\n+    for (int j = 0; j < N; j++) {\n+      CanLockAdj2[i][j] = CanLockAdj[i][j];\n+    }\n+  }\n+  for (int k = 0; k < N; k++) {\n+    for (int i = 0; i < N; i++) {\n+      for (int j = 0; j < N; j++) {\n+        if (CanLockAdj2[i][k] && CanLockAdj2[k][j]) {\n+          CanLockAdj2[i][j] = true;\n+        }\n+      }\n+    }\n+  }\n+#if 0\n+  TsanPrintf(\"Can lock graph:\\n\");\n+  for (int i = 0; i < N; i++) {\n+    for (int j = 0; j < N; j++) {\n+      TsanPrintf(\"%d \", CanLockAdj[i][j]);\n+    }\n+    TsanPrintf(\"\\n\");\n+  }\n+  TsanPrintf(\"Can lock graph closure:\\n\");\n+  for (int i = 0; i < N; i++) {\n+    for (int j = 0; j < N; j++) {\n+      TsanPrintf(\"%d \", CanLockAdj2[i][j]);\n+    }\n+    TsanPrintf(\"\\n\");\n+  }\n+#endif\n+  // Verify that the graph is acyclic.\n+  for (int i = 0; i < N; i++) {\n+    if (CanLockAdj2[i][i]) {\n+      TsanPrintf(\"Mutex %d participates in a cycle\\n\", i);\n+      Die();\n+    }\n+  }\n+}\n+\n+DeadlockDetector::DeadlockDetector() {\n+  // Rely on zero initialization because some mutexes can be locked before ctor.\n+}\n+\n+void DeadlockDetector::Lock(MutexType t) {\n+  // TsanPrintf(\"LOCK %d @%zu\\n\", t, seq_ + 1);\n+  u64 max_seq = 0;\n+  u64 max_idx = MutexTypeInvalid;\n+  for (int i = 0; i != MutexTypeCount; i++) {\n+    if (locked_[i] == 0)\n+      continue;\n+    CHECK_NE(locked_[i], max_seq);\n+    if (max_seq < locked_[i]) {\n+      max_seq = locked_[i];\n+      max_idx = i;\n+    }\n+  }\n+  locked_[t] = ++seq_;\n+  if (max_idx == MutexTypeInvalid)\n+    return;\n+  // TsanPrintf(\"  last %d @%zu\\n\", max_idx, max_seq);\n+  if (!CanLockAdj[max_idx][t]) {\n+    TsanPrintf(\"ThreadSanitizer: internal deadlock detected\\n\");\n+    TsanPrintf(\"ThreadSanitizer: can't lock %d while under %zu\\n\",\n+               t, (uptr)max_idx);\n+    CHECK(0);\n+  }\n+}\n+\n+void DeadlockDetector::Unlock(MutexType t) {\n+  // TsanPrintf(\"UNLO %d @%zu #%zu\\n\", t, seq_, locked_[t]);\n+  CHECK(locked_[t]);\n+  locked_[t] = 0;\n+}\n+\n+const uptr kUnlocked = 0;\n+const uptr kWriteLock = 1;\n+const uptr kReadLock = 2;\n+\n+class Backoff {\n+ public:\n+  Backoff()\n+    : iter_() {\n+  }\n+\n+  bool Do() {\n+    if (iter_++ < kActiveSpinIters)\n+      proc_yield(kActiveSpinCnt);\n+    else\n+      internal_sched_yield();\n+    return true;\n+  }\n+\n+  u64 Contention() const {\n+    u64 active = iter_ % kActiveSpinIters;\n+    u64 passive = iter_ - active;\n+    return active + 10 * passive;\n+  }\n+\n+ private:\n+  int iter_;\n+  static const int kActiveSpinIters = 10;\n+  static const int kActiveSpinCnt = 20;\n+};\n+\n+Mutex::Mutex(MutexType type, StatType stat_type) {\n+  CHECK_GT(type, MutexTypeInvalid);\n+  CHECK_LT(type, MutexTypeCount);\n+#if TSAN_DEBUG\n+  type_ = type;\n+#endif\n+#if TSAN_COLLECT_STATS\n+  stat_type_ = stat_type;\n+#endif\n+  atomic_store(&state_, kUnlocked, memory_order_relaxed);\n+}\n+\n+Mutex::~Mutex() {\n+  CHECK_EQ(atomic_load(&state_, memory_order_relaxed), kUnlocked);\n+}\n+\n+void Mutex::Lock() {\n+#if TSAN_DEBUG && !TSAN_GO\n+  cur_thread()->deadlock_detector.Lock(type_);\n+#endif\n+  uptr cmp = kUnlocked;\n+  if (atomic_compare_exchange_strong(&state_, &cmp, kWriteLock,\n+                                     memory_order_acquire))\n+    return;\n+  for (Backoff backoff; backoff.Do();) {\n+    if (atomic_load(&state_, memory_order_relaxed) == kUnlocked) {\n+      cmp = kUnlocked;\n+      if (atomic_compare_exchange_weak(&state_, &cmp, kWriteLock,\n+                                       memory_order_acquire)) {\n+#if TSAN_COLLECT_STATS\n+        StatInc(cur_thread(), stat_type_, backoff.Contention());\n+#endif\n+        return;\n+      }\n+    }\n+  }\n+}\n+\n+void Mutex::Unlock() {\n+  uptr prev = atomic_fetch_sub(&state_, kWriteLock, memory_order_release);\n+  (void)prev;\n+  DCHECK_NE(prev & kWriteLock, 0);\n+#if TSAN_DEBUG && !TSAN_GO\n+  cur_thread()->deadlock_detector.Unlock(type_);\n+#endif\n+}\n+\n+void Mutex::ReadLock() {\n+#if TSAN_DEBUG && !TSAN_GO\n+  cur_thread()->deadlock_detector.Lock(type_);\n+#endif\n+  uptr prev = atomic_fetch_add(&state_, kReadLock, memory_order_acquire);\n+  if ((prev & kWriteLock) == 0)\n+    return;\n+  for (Backoff backoff; backoff.Do();) {\n+    prev = atomic_load(&state_, memory_order_acquire);\n+    if ((prev & kWriteLock) == 0) {\n+#if TSAN_COLLECT_STATS\n+      StatInc(cur_thread(), stat_type_, backoff.Contention());\n+#endif\n+      return;\n+    }\n+  }\n+}\n+\n+void Mutex::ReadUnlock() {\n+  uptr prev = atomic_fetch_sub(&state_, kReadLock, memory_order_release);\n+  (void)prev;\n+  DCHECK_EQ(prev & kWriteLock, 0);\n+  DCHECK_GT(prev & ~kWriteLock, 0);\n+#if TSAN_DEBUG && !TSAN_GO\n+  cur_thread()->deadlock_detector.Unlock(type_);\n+#endif\n+}\n+\n+void Mutex::CheckLocked() {\n+  CHECK_NE(atomic_load(&state_, memory_order_relaxed), 0);\n+}\n+\n+}  // namespace __tsan"}, {"sha": "118066e75c3596ebb5176b6ab81f19ed216ee70e", "filename": "libsanitizer/tsan/tsan_mutex.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,78 @@\n+//===-- tsan_mutex.h --------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_MUTEX_H\n+#define TSAN_MUTEX_H\n+\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n+#include \"tsan_defs.h\"\n+\n+namespace __tsan {\n+\n+enum MutexType {\n+  MutexTypeInvalid,\n+  MutexTypeTrace,\n+  MutexTypeThreads,\n+  MutexTypeReport,\n+  MutexTypeSyncVar,\n+  MutexTypeSyncTab,\n+  MutexTypeSlab,\n+  MutexTypeAnnotations,\n+  MutexTypeAtExit,\n+\n+  // This must be the last.\n+  MutexTypeCount\n+};\n+\n+class Mutex {\n+ public:\n+  explicit Mutex(MutexType type, StatType stat_type);\n+  ~Mutex();\n+\n+  void Lock();\n+  void Unlock();\n+\n+  void ReadLock();\n+  void ReadUnlock();\n+\n+  void CheckLocked();\n+\n+ private:\n+  atomic_uintptr_t state_;\n+#if TSAN_DEBUG\n+  MutexType type_;\n+#endif\n+#if TSAN_COLLECT_STATS\n+  StatType stat_type_;\n+#endif\n+\n+  Mutex(const Mutex&);\n+  void operator = (const Mutex&);\n+};\n+\n+typedef GenericScopedLock<Mutex> Lock;\n+typedef GenericScopedReadLock<Mutex> ReadLock;\n+\n+class DeadlockDetector {\n+ public:\n+  DeadlockDetector();\n+  void Lock(MutexType t);\n+  void Unlock(MutexType t);\n+ private:\n+  u64 seq_;\n+  u64 locked_[MutexTypeCount];\n+};\n+\n+void InitializeMutex();\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_MUTEX_H"}, {"sha": "d7a4cf7b0e93d2a7903de7824ecaf5ec118b1a89", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,100 @@\n+//===-- tsan_platform.h -----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Platform-specific code.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef TSAN_PLATFORM_H\n+#define TSAN_PLATFORM_H\n+\n+#include \"tsan_rtl.h\"\n+\n+#if __LP64__\n+namespace __tsan {\n+\n+#if defined(TSAN_GO)\n+static const uptr kLinuxAppMemBeg = 0x000000000000ULL;\n+static const uptr kLinuxAppMemEnd = 0x00fcffffffffULL;\n+static const uptr kLinuxShadowMsk = 0x100000000000ULL;\n+// TSAN_COMPAT_SHADOW is intended for COMPAT virtual memory layout,\n+// when memory addresses are of the 0x2axxxxxxxxxx form.\n+// The option is enabled with 'setarch x86_64 -L'.\n+#elif defined(TSAN_COMPAT_SHADOW) && TSAN_COMPAT_SHADOW\n+static const uptr kLinuxAppMemBeg = 0x290000000000ULL;\n+static const uptr kLinuxAppMemEnd = 0x7fffffffffffULL;\n+#else\n+static const uptr kLinuxAppMemBeg = 0x7cf000000000ULL;\n+static const uptr kLinuxAppMemEnd = 0x7fffffffffffULL;\n+#endif\n+\n+static const uptr kLinuxAppMemMsk = 0x7c0000000000ULL;\n+\n+// This has to be a macro to allow constant initialization of constants below.\n+#ifndef TSAN_GO\n+#define MemToShadow(addr) \\\n+    (((addr) & ~(kLinuxAppMemMsk | (kShadowCell - 1))) * kShadowCnt)\n+#else\n+#define MemToShadow(addr) \\\n+    ((((addr) & ~(kShadowCell - 1)) * kShadowCnt) | kLinuxShadowMsk)\n+#endif\n+\n+static const uptr kLinuxShadowBeg = MemToShadow(kLinuxAppMemBeg);\n+static const uptr kLinuxShadowEnd =\n+  MemToShadow(kLinuxAppMemEnd) | (kPageSize - 1);\n+\n+static inline bool IsAppMem(uptr mem) {\n+  return mem >= kLinuxAppMemBeg && mem <= kLinuxAppMemEnd;\n+}\n+\n+static inline bool IsShadowMem(uptr mem) {\n+  return mem >= kLinuxShadowBeg && mem <= kLinuxShadowEnd;\n+}\n+\n+static inline uptr ShadowToMem(uptr shadow) {\n+  CHECK(IsShadowMem(shadow));\n+#ifdef TSAN_GO\n+  return (shadow & ~kLinuxShadowMsk) / kShadowCnt;\n+#else\n+  return (shadow / kShadowCnt) | kLinuxAppMemMsk;\n+#endif\n+}\n+\n+// For COMPAT mapping returns an alternative address\n+// that mapped to the same shadow address.\n+// COMPAT mapping is not quite one-to-one.\n+static inline uptr AlternativeAddress(uptr addr) {\n+#if defined(TSAN_COMPAT_SHADOW) && TSAN_COMPAT_SHADOW\n+  return (addr & ~kLinuxAppMemMsk) | 0x280000000000ULL;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+uptr GetShadowMemoryConsumption();\n+void FlushShadowMemory();\n+\n+const char *InitializePlatform();\n+void FinalizePlatform();\n+\n+void internal_start_thread(void(*func)(void*), void *arg);\n+\n+// Says whether the addr relates to a global var.\n+// Guesses with high probability, may yield both false positives and negatives.\n+bool IsGlobalVar(uptr addr);\n+uptr GetTlsSize();\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size);\n+\n+}  // namespace __tsan\n+\n+#else  // __LP64__\n+# error \"Only 64-bit is supported\"\n+#endif\n+\n+#endif  // TSAN_PLATFORM_H"}, {"sha": "d7de503c51d268ea5b7ef3907a54e2506b02b3f2", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,274 @@\n+//===-- tsan_platform_linux.cc --------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Linux-specific code.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __linux__\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_procmaps.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_flags.h\"\n+\n+#include <asm/prctl.h>\n+#include <fcntl.h>\n+#include <pthread.h>\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdarg.h>\n+#include <sys/mman.h>\n+#include <sys/prctl.h>\n+#include <sys/syscall.h>\n+#include <sys/time.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <sched.h>\n+#include <dlfcn.h>\n+\n+extern \"C\" int arch_prctl(int code, __sanitizer::uptr *addr);\n+\n+namespace __tsan {\n+\n+#ifndef TSAN_GO\n+ScopedInRtl::ScopedInRtl()\n+    : thr_(cur_thread()) {\n+  in_rtl_ = thr_->in_rtl;\n+  thr_->in_rtl++;\n+  errno_ = errno;\n+}\n+\n+ScopedInRtl::~ScopedInRtl() {\n+  thr_->in_rtl--;\n+  errno = errno_;\n+  CHECK_EQ(in_rtl_, thr_->in_rtl);\n+}\n+#else\n+ScopedInRtl::ScopedInRtl() {\n+}\n+\n+ScopedInRtl::~ScopedInRtl() {\n+}\n+#endif\n+\n+uptr GetShadowMemoryConsumption() {\n+  return 0;\n+}\n+\n+void FlushShadowMemory() {\n+  madvise((void*)kLinuxShadowBeg,\n+          kLinuxShadowEnd - kLinuxShadowBeg,\n+          MADV_DONTNEED);\n+}\n+\n+#ifndef TSAN_GO\n+static void ProtectRange(uptr beg, uptr end) {\n+  ScopedInRtl in_rtl;\n+  CHECK_LE(beg, end);\n+  if (beg == end)\n+    return;\n+  if (beg != (uptr)Mprotect(beg, end - beg)) {\n+    TsanPrintf(\"FATAL: ThreadSanitizer can not protect [%zx,%zx]\\n\", beg, end);\n+    TsanPrintf(\"FATAL: Make sure you are not using unlimited stack\\n\");\n+    Die();\n+  }\n+}\n+#endif\n+\n+void InitializeShadowMemory() {\n+  uptr shadow = (uptr)MmapFixedNoReserve(kLinuxShadowBeg,\n+    kLinuxShadowEnd - kLinuxShadowBeg);\n+  if (shadow != kLinuxShadowBeg) {\n+    TsanPrintf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n+    TsanPrintf(\"FATAL: Make sure to compile with -fPIE and \"\n+               \"to link with -pie (%p, %p).\\n\", shadow, kLinuxShadowBeg);\n+    Die();\n+  }\n+#ifndef TSAN_GO\n+  const uptr kClosedLowBeg  = 0x200000;\n+  const uptr kClosedLowEnd  = kLinuxShadowBeg - 1;\n+  const uptr kClosedMidBeg = kLinuxShadowEnd + 1;\n+  const uptr kClosedMidEnd = kLinuxAppMemBeg - 1;\n+  ProtectRange(kClosedLowBeg, kClosedLowEnd);\n+  ProtectRange(kClosedMidBeg, kClosedMidEnd);\n+#endif\n+#ifndef TSAN_GO\n+  DPrintf(\"kClosedLow   %zx-%zx (%zuGB)\\n\",\n+      kClosedLowBeg, kClosedLowEnd, (kClosedLowEnd - kClosedLowBeg) >> 30);\n+#endif\n+  DPrintf(\"kLinuxShadow %zx-%zx (%zuGB)\\n\",\n+      kLinuxShadowBeg, kLinuxShadowEnd,\n+      (kLinuxShadowEnd - kLinuxShadowBeg) >> 30);\n+#ifndef TSAN_GO\n+  DPrintf(\"kClosedMid   %zx-%zx (%zuGB)\\n\",\n+      kClosedMidBeg, kClosedMidEnd, (kClosedMidEnd - kClosedMidBeg) >> 30);\n+#endif\n+  DPrintf(\"kLinuxAppMem %zx-%zx (%zuGB)\\n\",\n+      kLinuxAppMemBeg, kLinuxAppMemEnd,\n+      (kLinuxAppMemEnd - kLinuxAppMemBeg) >> 30);\n+  DPrintf(\"stack        %zx\\n\", (uptr)&shadow);\n+}\n+\n+static uptr g_data_start;\n+static uptr g_data_end;\n+\n+#ifndef TSAN_GO\n+static void CheckPIE() {\n+  // Ensure that the binary is indeed compiled with -pie.\n+  MemoryMappingLayout proc_maps;\n+  uptr start, end;\n+  if (proc_maps.Next(&start, &end,\n+                     /*offset*/0, /*filename*/0, /*filename_size*/0)) {\n+    if ((u64)start < kLinuxAppMemBeg) {\n+      TsanPrintf(\"FATAL: ThreadSanitizer can not mmap the shadow memory (\"\n+             \"something is mapped at 0x%zx < 0x%zx)\\n\",\n+             start, kLinuxAppMemBeg);\n+      TsanPrintf(\"FATAL: Make sure to compile with -fPIE\"\n+             \" and to link with -pie.\\n\");\n+      Die();\n+    }\n+  }\n+}\n+\n+static void InitDataSeg() {\n+  MemoryMappingLayout proc_maps;\n+  uptr start, end, offset;\n+  char name[128];\n+  bool prev_is_data = false;\n+  while (proc_maps.Next(&start, &end, &offset, name, ARRAY_SIZE(name))) {\n+    DPrintf(\"%p-%p %p %s\\n\", start, end, offset, name);\n+    bool is_data = offset != 0 && name[0] != 0;\n+    // BSS may get merged with [heap] in /proc/self/maps. This is not very\n+    // reliable.\n+    bool is_bss = offset == 0 &&\n+      (name[0] == 0 || internal_strcmp(name, \"[heap]\") == 0) && prev_is_data;\n+    if (g_data_start == 0 && is_data)\n+      g_data_start = start;\n+    if (is_bss)\n+      g_data_end = end;\n+    prev_is_data = is_data;\n+  }\n+  DPrintf(\"guessed data_start=%p data_end=%p\\n\",  g_data_start, g_data_end);\n+  CHECK_LT(g_data_start, g_data_end);\n+  CHECK_GE((uptr)&g_data_start, g_data_start);\n+  CHECK_LT((uptr)&g_data_start, g_data_end);\n+}\n+\n+static uptr g_tls_size;\n+\n+#ifdef __i386__\n+# define INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))\n+#else\n+# define INTERNAL_FUNCTION\n+#endif\n+extern \"C\" void _dl_get_tls_static_info(size_t*, size_t*)\n+    __attribute__((weak)) INTERNAL_FUNCTION;\n+\n+static int InitTlsSize() {\n+  typedef void (*get_tls_func)(size_t*, size_t*) INTERNAL_FUNCTION;\n+  get_tls_func get_tls = &_dl_get_tls_static_info;\n+  if (get_tls == 0) {\n+    void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, \"_dl_get_tls_static_info\");\n+    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));\n+    internal_memcpy(&get_tls, &get_tls_static_info_ptr,\n+                    sizeof(get_tls_static_info_ptr));\n+  }\n+  CHECK_NE(get_tls, 0);\n+  size_t tls_size = 0;\n+  size_t tls_align = 0;\n+  get_tls(&tls_size, &tls_align);\n+  return tls_size;\n+}\n+#endif  // #ifndef TSAN_GO\n+\n+const char *InitializePlatform() {\n+  void *p = 0;\n+  if (sizeof(p) == 8) {\n+    // Disable core dumps, dumping of 16TB usually takes a bit long.\n+    // The following magic is to prevent clang from replacing it with memset.\n+    volatile rlimit lim;\n+    lim.rlim_cur = 0;\n+    lim.rlim_max = 0;\n+    setrlimit(RLIMIT_CORE, (rlimit*)&lim);\n+  }\n+  // TSan doesn't play well with unlimited stack size (as stack\n+  // overlaps with shadow memory). If we detect unlimited stack size,\n+  // we re-exec the program with limited stack size as a best effort.\n+  if (StackSizeIsUnlimited()) {\n+    const uptr kMaxStackSize = 32 * 1024 * 1024;  // 32 Mb\n+    Report(\"WARNING: Program is run with unlimited stack size, which \"\n+           \"wouldn't work with ThreadSanitizer.\\n\");\n+    Report(\"Re-execing with stack size limited to %zd bytes.\\n\", kMaxStackSize);\n+    SetStackSizeLimitInBytes(kMaxStackSize);\n+    ReExec();\n+  }\n+\n+#ifndef TSAN_GO\n+  CheckPIE();\n+  g_tls_size = (uptr)InitTlsSize();\n+  InitDataSeg();\n+#endif\n+  return getenv(\"TSAN_OPTIONS\");\n+}\n+\n+void FinalizePlatform() {\n+  fflush(0);\n+}\n+\n+uptr GetTlsSize() {\n+#ifndef TSAN_GO\n+  return g_tls_size;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size) {\n+#ifndef TSAN_GO\n+  arch_prctl(ARCH_GET_FS, tls_addr);\n+  *tls_addr -= g_tls_size;\n+  *tls_size = g_tls_size;\n+\n+  uptr stack_top, stack_bottom;\n+  GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n+  *stk_addr = stack_bottom;\n+  *stk_size = stack_top - stack_bottom;\n+\n+  if (!main) {\n+    // If stack and tls intersect, make them non-intersecting.\n+    if (*tls_addr > *stk_addr && *tls_addr < *stk_addr + *stk_size) {\n+      CHECK_GT(*tls_addr + *tls_size, *stk_addr);\n+      CHECK_LE(*tls_addr + *tls_size, *stk_addr + *stk_size);\n+      *stk_size -= *tls_size;\n+      *tls_addr = *stk_addr + *stk_size;\n+    }\n+  }\n+#else\n+  *stk_addr = 0;\n+  *stk_size = 0;\n+  *tls_addr = 0;\n+  *tls_size = 0;\n+#endif\n+}\n+\n+bool IsGlobalVar(uptr addr) {\n+  return g_data_start && addr >= g_data_start && addr < g_data_end;\n+}\n+\n+}  // namespace __tsan\n+\n+#endif  // #ifdef __linux__"}, {"sha": "e22a500cf15b6f988d66cffb1192d0ec68baeef9", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,102 @@\n+//===-- tsan_platform_mac.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Mac-specific code.\n+//===----------------------------------------------------------------------===//\n+\n+#ifdef __APPLE__\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_procmaps.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_flags.h\"\n+\n+#include <pthread.h>\n+#include <signal.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdarg.h>\n+#include <sys/mman.h>\n+#include <sys/syscall.h>\n+#include <sys/time.h>\n+#include <sys/types.h>\n+#include <sys/resource.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <sched.h>\n+\n+namespace __tsan {\n+\n+ScopedInRtl::ScopedInRtl() {\n+}\n+\n+ScopedInRtl::~ScopedInRtl() {\n+}\n+\n+uptr GetShadowMemoryConsumption() {\n+  return 0;\n+}\n+\n+void FlushShadowMemory() {\n+}\n+\n+void InitializeShadowMemory() {\n+  uptr shadow = (uptr)MmapFixedNoReserve(kLinuxShadowBeg,\n+    kLinuxShadowEnd - kLinuxShadowBeg);\n+  if (shadow != kLinuxShadowBeg) {\n+    TsanPrintf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n+    TsanPrintf(\"FATAL: Make sure to compile with -fPIE and \"\n+               \"to link with -pie.\\n\");\n+    Die();\n+  }\n+  DPrintf(\"kLinuxShadow %zx-%zx (%zuGB)\\n\",\n+      kLinuxShadowBeg, kLinuxShadowEnd,\n+      (kLinuxShadowEnd - kLinuxShadowBeg) >> 30);\n+  DPrintf(\"kLinuxAppMem %zx-%zx (%zuGB)\\n\",\n+      kLinuxAppMemBeg, kLinuxAppMemEnd,\n+      (kLinuxAppMemEnd - kLinuxAppMemBeg) >> 30);\n+}\n+\n+const char *InitializePlatform() {\n+  void *p = 0;\n+  if (sizeof(p) == 8) {\n+    // Disable core dumps, dumping of 16TB usually takes a bit long.\n+    // The following magic is to prevent clang from replacing it with memset.\n+    volatile rlimit lim;\n+    lim.rlim_cur = 0;\n+    lim.rlim_max = 0;\n+    setrlimit(RLIMIT_CORE, (rlimit*)&lim);\n+  }\n+\n+  return getenv(\"TSAN_OPTIONS\");\n+}\n+\n+void FinalizePlatform() {\n+  fflush(0);\n+}\n+\n+uptr GetTlsSize() {\n+  return 0;\n+}\n+\n+void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n+                          uptr *tls_addr, uptr *tls_size) {\n+  *stk_addr = 0;\n+  *stk_size = 0;\n+  *tls_addr = 0;\n+  *tls_size = 0;\n+}\n+\n+}  // namespace __tsan\n+\n+#endif  // #ifdef __APPLE__"}, {"sha": "982e2925dc3d98b52ee4b11dabc99adf509ce859", "filename": "libsanitizer/tsan/tsan_printf.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_printf.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,38 @@\n+//===-- tsan_printf.cc ----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"tsan_defs.h\"\n+#include \"tsan_mman.h\"\n+#include \"tsan_platform.h\"\n+\n+#include <stdarg.h>  // va_list\n+\n+namespace __sanitizer {\n+int VSNPrintf(char *buff, int buff_length, const char *format, va_list args);\n+}  // namespace __sanitizer\n+\n+namespace __tsan {\n+\n+void TsanPrintf(const char *format, ...) {\n+  ScopedInRtl in_rtl;\n+  const uptr kMaxLen = 16 * 1024;\n+  InternalScopedBuffer<char> buffer(kMaxLen);\n+  va_list args;\n+  va_start(args, format);\n+  uptr len = VSNPrintf(buffer.data(), buffer.size(), format, args);\n+  va_end(args);\n+  internal_write(CTX() ? flags()->log_fileno : 2,\n+      buffer.data(), len < buffer.size() ? len : buffer.size() - 1);\n+}\n+\n+}  // namespace __tsan"}, {"sha": "716a20f1213fc9f35e81a41c5248800f4aa183d6", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,183 @@\n+//===-- tsan_report.cc ----------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"tsan_report.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+\n+namespace __tsan {\n+\n+ReportDesc::ReportDesc()\n+    : stacks(MBlockReportStack)\n+    , mops(MBlockReportMop)\n+    , locs(MBlockReportLoc)\n+    , mutexes(MBlockReportMutex)\n+    , threads(MBlockReportThread)\n+    , sleep() {\n+}\n+\n+ReportDesc::~ReportDesc() {\n+}\n+\n+#ifndef TSAN_GO\n+\n+static void PrintHeader(ReportType typ) {\n+  TsanPrintf(\"WARNING: ThreadSanitizer: \");\n+\n+  if (typ == ReportTypeRace)\n+    TsanPrintf(\"data race\");\n+  else if (typ == ReportTypeUseAfterFree)\n+    TsanPrintf(\"heap-use-after-free\");\n+  else if (typ == ReportTypeThreadLeak)\n+    TsanPrintf(\"thread leak\");\n+  else if (typ == ReportTypeMutexDestroyLocked)\n+    TsanPrintf(\"destroy of a locked mutex\");\n+  else if (typ == ReportTypeSignalUnsafe)\n+    TsanPrintf(\"signal-unsafe call inside of a signal\");\n+  else if (typ == ReportTypeErrnoInSignal)\n+    TsanPrintf(\"signal handler spoils errno\");\n+\n+  TsanPrintf(\" (pid=%d)\\n\", GetPid());\n+}\n+\n+void PrintStack(const ReportStack *ent) {\n+  for (int i = 0; ent; ent = ent->next, i++) {\n+    TsanPrintf(\"    #%d %s %s:%d\", i, ent->func, ent->file, ent->line);\n+    if (ent->col)\n+      TsanPrintf(\":%d\", ent->col);\n+    if (ent->module && ent->offset)\n+      TsanPrintf(\" (%s+%p)\\n\", ent->module, (void*)ent->offset);\n+    else\n+      TsanPrintf(\" (%p)\\n\", (void*)ent->pc);\n+  }\n+  TsanPrintf(\"\\n\");\n+}\n+\n+static void PrintMop(const ReportMop *mop, bool first) {\n+  TsanPrintf(\"  %s of size %d at %p\",\n+      (first ? (mop->write ? \"Write\" : \"Read\")\n+             : (mop->write ? \"Previous write\" : \"Previous read\")),\n+      mop->size, (void*)mop->addr);\n+  if (mop->tid == 0)\n+    TsanPrintf(\" by main thread:\\n\");\n+  else\n+    TsanPrintf(\" by thread %d:\\n\", mop->tid);\n+  PrintStack(mop->stack);\n+}\n+\n+static void PrintLocation(const ReportLocation *loc) {\n+  if (loc->type == ReportLocationGlobal) {\n+    TsanPrintf(\"  Location is global '%s' of size %zu at %zx %s:%d\\n\",\n+               loc->name, loc->size, loc->addr, loc->file, loc->line);\n+  } else if (loc->type == ReportLocationHeap) {\n+    TsanPrintf(\"  Location is heap block of size %zu at %p allocated\",\n+        loc->size, loc->addr);\n+    if (loc->tid == 0)\n+      TsanPrintf(\" by main thread:\\n\");\n+    else\n+      TsanPrintf(\" by thread %d:\\n\", loc->tid);\n+    PrintStack(loc->stack);\n+  } else if (loc->type == ReportLocationStack) {\n+    TsanPrintf(\"  Location is stack of thread %d:\\n\", loc->tid);\n+  }\n+}\n+\n+static void PrintMutex(const ReportMutex *rm) {\n+  if (rm->stack == 0)\n+    return;\n+  TsanPrintf(\"  Mutex %d created at:\\n\", rm->id);\n+  PrintStack(rm->stack);\n+}\n+\n+static void PrintThread(const ReportThread *rt) {\n+  if (rt->id == 0)  // Little sense in describing the main thread.\n+    return;\n+  TsanPrintf(\"  Thread %d\", rt->id);\n+  if (rt->name)\n+    TsanPrintf(\" '%s'\", rt->name);\n+  TsanPrintf(\" (tid=%zu, %s)\", rt->pid, rt->running ? \"running\" : \"finished\");\n+  if (rt->stack)\n+    TsanPrintf(\" created at:\");\n+  TsanPrintf(\"\\n\");\n+  PrintStack(rt->stack);\n+}\n+\n+static void PrintSleep(const ReportStack *s) {\n+  TsanPrintf(\"  As if synchronized via sleep:\\n\");\n+  PrintStack(s);\n+}\n+\n+void PrintReport(const ReportDesc *rep) {\n+  TsanPrintf(\"==================\\n\");\n+  PrintHeader(rep->typ);\n+\n+  for (uptr i = 0; i < rep->stacks.Size(); i++) {\n+    if (i)\n+      TsanPrintf(\"  and:\\n\");\n+    PrintStack(rep->stacks[i]);\n+  }\n+\n+  for (uptr i = 0; i < rep->mops.Size(); i++)\n+    PrintMop(rep->mops[i], i == 0);\n+\n+  if (rep->sleep)\n+    PrintSleep(rep->sleep);\n+\n+  for (uptr i = 0; i < rep->locs.Size(); i++)\n+    PrintLocation(rep->locs[i]);\n+\n+  for (uptr i = 0; i < rep->mutexes.Size(); i++)\n+    PrintMutex(rep->mutexes[i]);\n+\n+  for (uptr i = 0; i < rep->threads.Size(); i++)\n+    PrintThread(rep->threads[i]);\n+\n+  TsanPrintf(\"==================\\n\");\n+}\n+\n+#else\n+\n+void PrintStack(const ReportStack *ent) {\n+  for (int i = 0; ent; ent = ent->next, i++) {\n+    TsanPrintf(\"  %s()\\n      %s:%d +0x%zx\\n\",\n+        ent->func, ent->file, ent->line, (void*)ent->offset);\n+  }\n+  TsanPrintf(\"\\n\");\n+}\n+\n+static void PrintMop(const ReportMop *mop, bool first) {\n+  TsanPrintf(\"%s by goroutine %d:\\n\",\n+      (first ? (mop->write ? \"Write\" : \"Read\")\n+             : (mop->write ? \"Previous write\" : \"Previous read\")),\n+      mop->tid);\n+  PrintStack(mop->stack);\n+}\n+\n+static void PrintThread(const ReportThread *rt) {\n+  if (rt->id == 0)  // Little sense in describing the main thread.\n+    return;\n+  TsanPrintf(\"Goroutine %d (%s) created at:\\n\",\n+    rt->id, rt->running ? \"running\" : \"finished\");\n+  PrintStack(rt->stack);\n+}\n+\n+void PrintReport(const ReportDesc *rep) {\n+  TsanPrintf(\"==================\\n\");\n+  TsanPrintf(\"WARNING: DATA RACE\\n\");\n+  for (uptr i = 0; i < rep->mops.Size(); i++)\n+    PrintMop(rep->mops[i], i == 0);\n+  for (uptr i = 0; i < rep->threads.Size(); i++)\n+    PrintThread(rep->threads[i]);\n+  TsanPrintf(\"==================\\n\");\n+}\n+\n+#endif\n+\n+}  // namespace __tsan"}, {"sha": "9972829131711714278caa05f9f47f6ce34154b5", "filename": "libsanitizer/tsan/tsan_report.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,103 @@\n+//===-- tsan_report.h -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_REPORT_H\n+#define TSAN_REPORT_H\n+\n+#include \"tsan_defs.h\"\n+#include \"tsan_vector.h\"\n+\n+namespace __tsan {\n+\n+enum ReportType {\n+  ReportTypeRace,\n+  ReportTypeUseAfterFree,\n+  ReportTypeThreadLeak,\n+  ReportTypeMutexDestroyLocked,\n+  ReportTypeSignalUnsafe,\n+  ReportTypeErrnoInSignal\n+};\n+\n+struct ReportStack {\n+  ReportStack *next;\n+  char *module;\n+  uptr offset;\n+  uptr pc;\n+  char *func;\n+  char *file;\n+  int line;\n+  int col;\n+};\n+\n+struct ReportMop {\n+  int tid;\n+  uptr addr;\n+  int size;\n+  bool write;\n+  int nmutex;\n+  int *mutex;\n+  ReportStack *stack;\n+};\n+\n+enum ReportLocationType {\n+  ReportLocationGlobal,\n+  ReportLocationHeap,\n+  ReportLocationStack\n+};\n+\n+struct ReportLocation {\n+  ReportLocationType type;\n+  uptr addr;\n+  uptr size;\n+  int tid;\n+  char *name;\n+  char *file;\n+  int line;\n+  ReportStack *stack;\n+};\n+\n+struct ReportThread {\n+  int id;\n+  uptr pid;\n+  bool running;\n+  char *name;\n+  ReportStack *stack;\n+};\n+\n+struct ReportMutex {\n+  int id;\n+  ReportStack *stack;\n+};\n+\n+class ReportDesc {\n+ public:\n+  ReportType typ;\n+  Vector<ReportStack*> stacks;\n+  Vector<ReportMop*> mops;\n+  Vector<ReportLocation*> locs;\n+  Vector<ReportMutex*> mutexes;\n+  Vector<ReportThread*> threads;\n+  ReportStack *sleep;\n+\n+  ReportDesc();\n+  ~ReportDesc();\n+\n+ private:\n+  ReportDesc(const ReportDesc&);\n+  void operator = (const ReportDesc&);\n+};\n+\n+// Format and output the report to the console/log. No additional logic.\n+void PrintReport(const ReportDesc *rep);\n+void PrintStack(const ReportStack *stack);\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_REPORT_H"}, {"sha": "4ff26973ce3e91c003a38a0994d66dfbf4556679", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "added", "additions": 578, "deletions": 0, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,578 @@\n+//===-- tsan_rtl.cc -------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Main file (entry points) for the TSan run-time.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n+#include \"tsan_defs.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_mman.h\"\n+#include \"tsan_suppressions.h\"\n+\n+volatile int __tsan_resumed = 0;\n+\n+extern \"C\" void __tsan_resume() {\n+  __tsan_resumed = 1;\n+}\n+\n+namespace __tsan {\n+\n+#ifndef TSAN_GO\n+THREADLOCAL char cur_thread_placeholder[sizeof(ThreadState)] ALIGNED(64);\n+#endif\n+static char ctx_placeholder[sizeof(Context)] ALIGNED(64);\n+\n+static Context *ctx;\n+Context *CTX() {\n+  return ctx;\n+}\n+\n+Context::Context()\n+  : initialized()\n+  , report_mtx(MutexTypeReport, StatMtxReport)\n+  , nreported()\n+  , nmissed_expected()\n+  , thread_mtx(MutexTypeThreads, StatMtxThreads)\n+  , racy_stacks(MBlockRacyStacks)\n+  , racy_addresses(MBlockRacyAddresses)\n+  , fired_suppressions(MBlockRacyAddresses) {\n+}\n+\n+// The objects are allocated in TLS, so one may rely on zero-initialization.\n+ThreadState::ThreadState(Context *ctx, int tid, int unique_id, u64 epoch,\n+                         uptr stk_addr, uptr stk_size,\n+                         uptr tls_addr, uptr tls_size)\n+  : fast_state(tid, epoch)\n+  // Do not touch these, rely on zero initialization,\n+  // they may be accessed before the ctor.\n+  // , fast_ignore_reads()\n+  // , fast_ignore_writes()\n+  // , in_rtl()\n+  , shadow_stack_pos(&shadow_stack[0])\n+  , tid(tid)\n+  , unique_id(unique_id)\n+  , stk_addr(stk_addr)\n+  , stk_size(stk_size)\n+  , tls_addr(tls_addr)\n+  , tls_size(tls_size) {\n+}\n+\n+ThreadContext::ThreadContext(int tid)\n+  : tid(tid)\n+  , unique_id()\n+  , os_id()\n+  , user_id()\n+  , thr()\n+  , status(ThreadStatusInvalid)\n+  , detached()\n+  , reuse_count()\n+  , epoch0()\n+  , epoch1()\n+  , dead_info()\n+  , dead_next() {\n+}\n+\n+static void WriteMemoryProfile(char *buf, uptr buf_size, int num) {\n+  uptr shadow = GetShadowMemoryConsumption();\n+\n+  int nthread = 0;\n+  int nlivethread = 0;\n+  uptr threadmem = 0;\n+  {\n+    Lock l(&ctx->thread_mtx);\n+    for (unsigned i = 0; i < kMaxTid; i++) {\n+      ThreadContext *tctx = ctx->threads[i];\n+      if (tctx == 0)\n+        continue;\n+      nthread += 1;\n+      threadmem += sizeof(ThreadContext);\n+      if (tctx->status != ThreadStatusRunning)\n+        continue;\n+      nlivethread += 1;\n+      threadmem += sizeof(ThreadState);\n+    }\n+  }\n+\n+  uptr nsync = 0;\n+  uptr syncmem = CTX()->synctab.GetMemoryConsumption(&nsync);\n+\n+  internal_snprintf(buf, buf_size, \"%d: shadow=%zuMB\"\n+                                   \" thread=%zuMB(total=%d/live=%d)\"\n+                                   \" sync=%zuMB(cnt=%zu)\\n\",\n+    num,\n+    shadow >> 20,\n+    threadmem >> 20, nthread, nlivethread,\n+    syncmem >> 20, nsync);\n+}\n+\n+static void MemoryProfileThread(void *arg) {\n+  ScopedInRtl in_rtl;\n+  fd_t fd = (fd_t)(uptr)arg;\n+  for (int i = 0; ; i++) {\n+    InternalScopedBuffer<char> buf(4096);\n+    WriteMemoryProfile(buf.data(), buf.size(), i);\n+    internal_write(fd, buf.data(), internal_strlen(buf.data()));\n+    SleepForSeconds(1);\n+  }\n+}\n+\n+static void InitializeMemoryProfile() {\n+  if (flags()->profile_memory == 0 || flags()->profile_memory[0] == 0)\n+    return;\n+  InternalScopedBuffer<char> filename(4096);\n+  internal_snprintf(filename.data(), filename.size(), \"%s.%d\",\n+      flags()->profile_memory, GetPid());\n+  fd_t fd = internal_open(filename.data(), true);\n+  if (fd == kInvalidFd) {\n+    TsanPrintf(\"Failed to open memory profile file '%s'\\n\", &filename[0]);\n+    Die();\n+  }\n+  internal_start_thread(&MemoryProfileThread, (void*)(uptr)fd);\n+}\n+\n+static void MemoryFlushThread(void *arg) {\n+  ScopedInRtl in_rtl;\n+  for (int i = 0; ; i++) {\n+    SleepForMillis(flags()->flush_memory_ms);\n+    FlushShadowMemory();\n+  }\n+}\n+\n+static void InitializeMemoryFlush() {\n+  if (flags()->flush_memory_ms == 0)\n+    return;\n+  if (flags()->flush_memory_ms < 100)\n+    flags()->flush_memory_ms = 100;\n+  internal_start_thread(&MemoryFlushThread, 0);\n+}\n+\n+void Initialize(ThreadState *thr) {\n+  // Thread safe because done before all threads exist.\n+  static bool is_initialized = false;\n+  if (is_initialized)\n+    return;\n+  is_initialized = true;\n+  // Install tool-specific callbacks in sanitizer_common.\n+  SetCheckFailedCallback(TsanCheckFailed);\n+\n+  ScopedInRtl in_rtl;\n+#ifndef TSAN_GO\n+  InitializeAllocator();\n+#endif\n+  InitializeInterceptors();\n+  const char *env = InitializePlatform();\n+  InitializeMutex();\n+  InitializeDynamicAnnotations();\n+  ctx = new(ctx_placeholder) Context;\n+  InitializeShadowMemory();\n+  ctx->dead_list_size = 0;\n+  ctx->dead_list_head = 0;\n+  ctx->dead_list_tail = 0;\n+  InitializeFlags(&ctx->flags, env);\n+  InitializeSuppressions();\n+#ifndef TSAN_GO\n+  // Initialize external symbolizer before internal threads are started.\n+  const char *external_symbolizer = flags()->external_symbolizer_path;\n+  if (external_symbolizer != 0 && external_symbolizer[0] != '\\0') {\n+    InitializeExternalSymbolizer(external_symbolizer);\n+  }\n+#endif\n+  InitializeMemoryProfile();\n+  InitializeMemoryFlush();\n+\n+  if (ctx->flags.verbosity)\n+    TsanPrintf(\"***** Running under ThreadSanitizer v2 (pid %d) *****\\n\",\n+               GetPid());\n+\n+  // Initialize thread 0.\n+  ctx->thread_seq = 0;\n+  int tid = ThreadCreate(thr, 0, 0, true);\n+  CHECK_EQ(tid, 0);\n+  ThreadStart(thr, tid, GetPid());\n+  CHECK_EQ(thr->in_rtl, 1);\n+  ctx->initialized = true;\n+\n+  if (flags()->stop_on_start) {\n+    TsanPrintf(\"ThreadSanitizer is suspended at startup (pid %d).\"\n+           \" Call __tsan_resume().\\n\",\n+           GetPid());\n+    while (__tsan_resumed == 0);\n+  }\n+}\n+\n+int Finalize(ThreadState *thr) {\n+  ScopedInRtl in_rtl;\n+  Context *ctx = __tsan::ctx;\n+  bool failed = false;\n+\n+  // Wait for pending reports.\n+  ctx->report_mtx.Lock();\n+  ctx->report_mtx.Unlock();\n+\n+  ThreadFinalize(thr);\n+\n+  if (ctx->nreported) {\n+    failed = true;\n+    TsanPrintf(\"ThreadSanitizer: reported %d warnings\\n\", ctx->nreported);\n+  }\n+\n+  if (ctx->nmissed_expected) {\n+    failed = true;\n+    TsanPrintf(\"ThreadSanitizer: missed %d expected races\\n\",\n+        ctx->nmissed_expected);\n+  }\n+\n+  StatOutput(ctx->stat);\n+  return failed ? flags()->exitcode : 0;\n+}\n+\n+#ifndef TSAN_GO\n+u32 CurrentStackId(ThreadState *thr, uptr pc) {\n+  if (thr->shadow_stack_pos == 0)  // May happen during bootstrap.\n+    return 0;\n+  if (pc) {\n+    thr->shadow_stack_pos[0] = pc;\n+    thr->shadow_stack_pos++;\n+  }\n+  u32 id = StackDepotPut(thr->shadow_stack,\n+                         thr->shadow_stack_pos - thr->shadow_stack);\n+  if (pc)\n+    thr->shadow_stack_pos--;\n+  return id;\n+}\n+#endif\n+\n+void TraceSwitch(ThreadState *thr) {\n+  thr->nomalloc++;\n+  ScopedInRtl in_rtl;\n+  Lock l(&thr->trace.mtx);\n+  unsigned trace = (thr->fast_state.epoch() / kTracePartSize) % kTraceParts;\n+  TraceHeader *hdr = &thr->trace.headers[trace];\n+  hdr->epoch0 = thr->fast_state.epoch();\n+  hdr->stack0.ObtainCurrent(thr, 0);\n+  thr->nomalloc--;\n+}\n+\n+#ifndef TSAN_GO\n+extern \"C\" void __tsan_trace_switch() {\n+  TraceSwitch(cur_thread());\n+}\n+\n+extern \"C\" void __tsan_report_race() {\n+  ReportRace(cur_thread());\n+}\n+#endif\n+\n+ALWAYS_INLINE\n+static Shadow LoadShadow(u64 *p) {\n+  u64 raw = atomic_load((atomic_uint64_t*)p, memory_order_relaxed);\n+  return Shadow(raw);\n+}\n+\n+ALWAYS_INLINE\n+static void StoreShadow(u64 *sp, u64 s) {\n+  atomic_store((atomic_uint64_t*)sp, s, memory_order_relaxed);\n+}\n+\n+ALWAYS_INLINE\n+static void StoreIfNotYetStored(u64 *sp, u64 *s) {\n+  StoreShadow(sp, *s);\n+  *s = 0;\n+}\n+\n+static inline void HandleRace(ThreadState *thr, u64 *shadow_mem,\n+                              Shadow cur, Shadow old) {\n+  thr->racy_state[0] = cur.raw();\n+  thr->racy_state[1] = old.raw();\n+  thr->racy_shadow_addr = shadow_mem;\n+  ReportRace(thr);\n+}\n+\n+static inline bool BothReads(Shadow s, int kAccessIsWrite) {\n+  return !kAccessIsWrite && !s.is_write();\n+}\n+\n+static inline bool OldIsRWStronger(Shadow old, int kAccessIsWrite) {\n+  return old.is_write() || !kAccessIsWrite;\n+}\n+\n+static inline bool OldIsRWWeaker(Shadow old, int kAccessIsWrite) {\n+  return !old.is_write() || kAccessIsWrite;\n+}\n+\n+static inline bool OldIsInSameSynchEpoch(Shadow old, ThreadState *thr) {\n+  return old.epoch() >= thr->fast_synch_epoch;\n+}\n+\n+static inline bool HappensBefore(Shadow old, ThreadState *thr) {\n+  return thr->clock.get(old.tid()) >= old.epoch();\n+}\n+\n+ALWAYS_INLINE\n+void MemoryAccessImpl(ThreadState *thr, uptr addr,\n+    int kAccessSizeLog, bool kAccessIsWrite, FastState fast_state,\n+    u64 *shadow_mem, Shadow cur) {\n+  StatInc(thr, StatMop);\n+  StatInc(thr, kAccessIsWrite ? StatMopWrite : StatMopRead);\n+  StatInc(thr, (StatType)(StatMop1 + kAccessSizeLog));\n+\n+  // This potentially can live in an MMX/SSE scratch register.\n+  // The required intrinsics are:\n+  // __m128i _mm_move_epi64(__m128i*);\n+  // _mm_storel_epi64(u64*, __m128i);\n+  u64 store_word = cur.raw();\n+\n+  // scan all the shadow values and dispatch to 4 categories:\n+  // same, replace, candidate and race (see comments below).\n+  // we consider only 3 cases regarding access sizes:\n+  // equal, intersect and not intersect. initially I considered\n+  // larger and smaller as well, it allowed to replace some\n+  // 'candidates' with 'same' or 'replace', but I think\n+  // it's just not worth it (performance- and complexity-wise).\n+\n+  Shadow old(0);\n+  if (kShadowCnt == 1) {\n+    int idx = 0;\n+#include \"tsan_update_shadow_word_inl.h\"\n+  } else if (kShadowCnt == 2) {\n+    int idx = 0;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 1;\n+#include \"tsan_update_shadow_word_inl.h\"\n+  } else if (kShadowCnt == 4) {\n+    int idx = 0;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 1;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 2;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 3;\n+#include \"tsan_update_shadow_word_inl.h\"\n+  } else if (kShadowCnt == 8) {\n+    int idx = 0;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 1;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 2;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 3;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 4;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 5;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 6;\n+#include \"tsan_update_shadow_word_inl.h\"\n+    idx = 7;\n+#include \"tsan_update_shadow_word_inl.h\"\n+  } else {\n+    CHECK(false);\n+  }\n+\n+  // we did not find any races and had already stored\n+  // the current access info, so we are done\n+  if (LIKELY(store_word == 0))\n+    return;\n+  // choose a random candidate slot and replace it\n+  StoreShadow(shadow_mem + (cur.epoch() % kShadowCnt), store_word);\n+  StatInc(thr, StatShadowReplace);\n+  return;\n+ RACE:\n+  HandleRace(thr, shadow_mem, cur, old);\n+  return;\n+}\n+\n+ALWAYS_INLINE\n+void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n+    int kAccessSizeLog, bool kAccessIsWrite) {\n+  u64 *shadow_mem = (u64*)MemToShadow(addr);\n+  DPrintf2(\"#%d: tsan::OnMemoryAccess: @%p %p size=%d\"\n+      \" is_write=%d shadow_mem=%p {%zx, %zx, %zx, %zx}\\n\",\n+      (int)thr->fast_state.tid(), (void*)pc, (void*)addr,\n+      (int)(1 << kAccessSizeLog), kAccessIsWrite, shadow_mem,\n+      (uptr)shadow_mem[0], (uptr)shadow_mem[1],\n+      (uptr)shadow_mem[2], (uptr)shadow_mem[3]);\n+#if TSAN_DEBUG\n+  if (!IsAppMem(addr)) {\n+    TsanPrintf(\"Access to non app mem %zx\\n\", addr);\n+    DCHECK(IsAppMem(addr));\n+  }\n+  if (!IsShadowMem((uptr)shadow_mem)) {\n+    TsanPrintf(\"Bad shadow addr %p (%zx)\\n\", shadow_mem, addr);\n+    DCHECK(IsShadowMem((uptr)shadow_mem));\n+  }\n+#endif\n+\n+  FastState fast_state = thr->fast_state;\n+  if (fast_state.GetIgnoreBit())\n+    return;\n+  fast_state.IncrementEpoch();\n+  thr->fast_state = fast_state;\n+  Shadow cur(fast_state);\n+  cur.SetAddr0AndSizeLog(addr & 7, kAccessSizeLog);\n+  cur.SetWrite(kAccessIsWrite);\n+\n+  // We must not store to the trace if we do not store to the shadow.\n+  // That is, this call must be moved somewhere below.\n+  TraceAddEvent(thr, fast_state.epoch(), EventTypeMop, pc);\n+\n+  MemoryAccessImpl(thr, addr, kAccessSizeLog, kAccessIsWrite, fast_state,\n+      shadow_mem, cur);\n+}\n+\n+static void MemoryRangeSet(ThreadState *thr, uptr pc, uptr addr, uptr size,\n+                           u64 val) {\n+  if (size == 0)\n+    return;\n+  // FIXME: fix me.\n+  uptr offset = addr % kShadowCell;\n+  if (offset) {\n+    offset = kShadowCell - offset;\n+    if (size <= offset)\n+      return;\n+    addr += offset;\n+    size -= offset;\n+  }\n+  DCHECK_EQ(addr % 8, 0);\n+  // If a user passes some insane arguments (memset(0)),\n+  // let it just crash as usual.\n+  if (!IsAppMem(addr) || !IsAppMem(addr + size - 1))\n+    return;\n+  (void)thr;\n+  (void)pc;\n+  // Some programs mmap like hundreds of GBs but actually used a small part.\n+  // So, it's better to report a false positive on the memory\n+  // then to hang here senselessly.\n+  const uptr kMaxResetSize = 4ull*1024*1024*1024;\n+  if (size > kMaxResetSize)\n+    size = kMaxResetSize;\n+  size = (size + (kShadowCell - 1)) & ~(kShadowCell - 1);\n+  u64 *p = (u64*)MemToShadow(addr);\n+  CHECK(IsShadowMem((uptr)p));\n+  CHECK(IsShadowMem((uptr)(p + size * kShadowCnt / kShadowCell - 1)));\n+  // FIXME: may overwrite a part outside the region\n+  for (uptr i = 0; i < size * kShadowCnt / kShadowCell;) {\n+    p[i++] = val;\n+    for (uptr j = 1; j < kShadowCnt; j++)\n+      p[i++] = 0;\n+  }\n+}\n+\n+void MemoryResetRange(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n+  MemoryRangeSet(thr, pc, addr, size, 0);\n+}\n+\n+void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n+  MemoryAccessRange(thr, pc, addr, size, true);\n+  Shadow s(thr->fast_state);\n+  s.MarkAsFreed();\n+  s.SetWrite(true);\n+  s.SetAddr0AndSizeLog(0, 3);\n+  MemoryRangeSet(thr, pc, addr, size, s.raw());\n+}\n+\n+void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size) {\n+  Shadow s(thr->fast_state);\n+  s.SetWrite(true);\n+  s.SetAddr0AndSizeLog(0, 3);\n+  MemoryRangeSet(thr, pc, addr, size, s.raw());\n+}\n+\n+void FuncEntry(ThreadState *thr, uptr pc) {\n+  DCHECK_EQ(thr->in_rtl, 0);\n+  StatInc(thr, StatFuncEnter);\n+  DPrintf2(\"#%d: FuncEntry %p\\n\", (int)thr->fast_state.tid(), (void*)pc);\n+  thr->fast_state.IncrementEpoch();\n+  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeFuncEnter, pc);\n+\n+  // Shadow stack maintenance can be replaced with\n+  // stack unwinding during trace switch (which presumably must be faster).\n+  DCHECK_GE(thr->shadow_stack_pos, &thr->shadow_stack[0]);\n+#ifndef TSAN_GO\n+  DCHECK_LT(thr->shadow_stack_pos, &thr->shadow_stack[kShadowStackSize]);\n+#else\n+  if (thr->shadow_stack_pos == thr->shadow_stack_end) {\n+    const int sz = thr->shadow_stack_end - thr->shadow_stack;\n+    const int newsz = 2 * sz;\n+    uptr *newstack = (uptr*)internal_alloc(MBlockShadowStack,\n+        newsz * sizeof(uptr));\n+    internal_memcpy(newstack, thr->shadow_stack, sz * sizeof(uptr));\n+    internal_free(thr->shadow_stack);\n+    thr->shadow_stack = newstack;\n+    thr->shadow_stack_pos = newstack + sz;\n+    thr->shadow_stack_end = newstack + newsz;\n+  }\n+#endif\n+  thr->shadow_stack_pos[0] = pc;\n+  thr->shadow_stack_pos++;\n+}\n+\n+void FuncExit(ThreadState *thr) {\n+  DCHECK_EQ(thr->in_rtl, 0);\n+  StatInc(thr, StatFuncExit);\n+  DPrintf2(\"#%d: FuncExit\\n\", (int)thr->fast_state.tid());\n+  thr->fast_state.IncrementEpoch();\n+  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeFuncExit, 0);\n+\n+  DCHECK_GT(thr->shadow_stack_pos, &thr->shadow_stack[0]);\n+#ifndef TSAN_GO\n+  DCHECK_LT(thr->shadow_stack_pos, &thr->shadow_stack[kShadowStackSize]);\n+#endif\n+  thr->shadow_stack_pos--;\n+}\n+\n+void IgnoreCtl(ThreadState *thr, bool write, bool begin) {\n+  DPrintf(\"#%d: IgnoreCtl(%d, %d)\\n\", thr->tid, write, begin);\n+  thr->ignore_reads_and_writes += begin ? 1 : -1;\n+  CHECK_GE(thr->ignore_reads_and_writes, 0);\n+  if (thr->ignore_reads_and_writes)\n+    thr->fast_state.SetIgnoreBit();\n+  else\n+    thr->fast_state.ClearIgnoreBit();\n+}\n+\n+bool MD5Hash::operator==(const MD5Hash &other) const {\n+  return hash[0] == other.hash[0] && hash[1] == other.hash[1];\n+}\n+\n+#if TSAN_DEBUG\n+void build_consistency_debug() {}\n+#else\n+void build_consistency_release() {}\n+#endif\n+\n+#if TSAN_COLLECT_STATS\n+void build_consistency_stats() {}\n+#else\n+void build_consistency_nostats() {}\n+#endif\n+\n+#if TSAN_SHADOW_COUNT == 1\n+void build_consistency_shadow1() {}\n+#elif TSAN_SHADOW_COUNT == 2\n+void build_consistency_shadow2() {}\n+#elif TSAN_SHADOW_COUNT == 4\n+void build_consistency_shadow4() {}\n+#else\n+void build_consistency_shadow8() {}\n+#endif\n+\n+}  // namespace __tsan\n+\n+#ifndef TSAN_GO\n+// Must be included in this file to make sure everything is inlined.\n+#include \"tsan_interface_inl.h\"\n+#endif"}, {"sha": "3df229c884417847c3dc824f0397cbb77cc61df2", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,554 @@\n+//===-- tsan_rtl.h ----------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Main internal TSan header file.\n+//\n+// Ground rules:\n+//   - C++ run-time should not be used (static CTORs, RTTI, exceptions, static\n+//     function-scope locals)\n+//   - All functions/classes/etc reside in namespace __tsan, except for those\n+//     declared in tsan_interface.h.\n+//   - Platform-specific files should be used instead of ifdefs (*).\n+//   - No system headers included in header files (*).\n+//   - Platform specific headres included only into platform-specific files (*).\n+//\n+//  (*) Except when inlining is critical for performance.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef TSAN_RTL_H\n+#define TSAN_RTL_H\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#if __WORDSIZE == 64\n+#include \"sanitizer_common/sanitizer_allocator64.h\"\n+#else\n+#include \"sanitizer_common/sanitizer_allocator.h\"\n+#endif\n+#include \"tsan_clock.h\"\n+#include \"tsan_defs.h\"\n+#include \"tsan_flags.h\"\n+#include \"tsan_sync.h\"\n+#include \"tsan_trace.h\"\n+#include \"tsan_vector.h\"\n+#include \"tsan_report.h\"\n+\n+namespace __tsan {\n+\n+// Descriptor of user's memory block.\n+struct MBlock {\n+  Mutex mtx;\n+  uptr size;\n+  u32 alloc_tid;\n+  u32 alloc_stack_id;\n+  SyncVar *head;\n+};\n+\n+#ifndef TSAN_GO\n+#if defined(TSAN_COMPAT_SHADOW) && TSAN_COMPAT_SHADOW\n+const uptr kAllocatorSpace = 0x7d0000000000ULL;\n+#else\n+const uptr kAllocatorSpace = 0x7d0000000000ULL;\n+#endif\n+const uptr kAllocatorSize  =  0x10000000000ULL;  // 1T.\n+\n+typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, sizeof(MBlock),\n+    DefaultSizeClassMap> PrimaryAllocator;\n+typedef SizeClassAllocatorLocalCache<PrimaryAllocator::kNumClasses,\n+    PrimaryAllocator> AllocatorCache;\n+typedef LargeMmapAllocator SecondaryAllocator;\n+typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n+    SecondaryAllocator> Allocator;\n+Allocator *allocator();\n+#endif\n+\n+void TsanCheckFailed(const char *file, int line, const char *cond,\n+                     u64 v1, u64 v2);\n+void TsanPrintf(const char *format, ...);\n+\n+// FastState (from most significant bit):\n+//   unused          : 1\n+//   tid             : kTidBits\n+//   epoch           : kClkBits\n+//   unused          : -\n+//   ignore_bit      : 1\n+class FastState {\n+ public:\n+  FastState(u64 tid, u64 epoch) {\n+    x_ = tid << kTidShift;\n+    x_ |= epoch << kClkShift;\n+    DCHECK(tid == this->tid());\n+    DCHECK(epoch == this->epoch());\n+  }\n+\n+  explicit FastState(u64 x)\n+      : x_(x) {\n+  }\n+\n+  u64 raw() const {\n+    return x_;\n+  }\n+\n+  u64 tid() const {\n+    u64 res = x_ >> kTidShift;\n+    return res;\n+  }\n+\n+  u64 epoch() const {\n+    u64 res = (x_ << (kTidBits + 1)) >> (64 - kClkBits);\n+    return res;\n+  }\n+\n+  void IncrementEpoch() {\n+    u64 old_epoch = epoch();\n+    x_ += 1 << kClkShift;\n+    DCHECK_EQ(old_epoch + 1, epoch());\n+    (void)old_epoch;\n+  }\n+\n+  void SetIgnoreBit() { x_ |= kIgnoreBit; }\n+  void ClearIgnoreBit() { x_ &= ~kIgnoreBit; }\n+  bool GetIgnoreBit() const { return x_ & kIgnoreBit; }\n+\n+ private:\n+  friend class Shadow;\n+  static const int kTidShift = 64 - kTidBits - 1;\n+  static const int kClkShift = kTidShift - kClkBits;\n+  static const u64 kIgnoreBit = 1ull;\n+  static const u64 kFreedBit = 1ull << 63;\n+  u64 x_;\n+};\n+\n+// Shadow (from most significant bit):\n+//   freed           : 1\n+//   tid             : kTidBits\n+//   epoch           : kClkBits\n+//   is_write        : 1\n+//   size_log        : 2\n+//   addr0           : 3\n+class Shadow : public FastState {\n+ public:\n+  explicit Shadow(u64 x) : FastState(x) { }\n+\n+  explicit Shadow(const FastState &s) : FastState(s.x_) { }\n+\n+  void SetAddr0AndSizeLog(u64 addr0, unsigned kAccessSizeLog) {\n+    DCHECK_EQ(x_ & 31, 0);\n+    DCHECK_LE(addr0, 7);\n+    DCHECK_LE(kAccessSizeLog, 3);\n+    x_ |= (kAccessSizeLog << 3) | addr0;\n+    DCHECK_EQ(kAccessSizeLog, size_log());\n+    DCHECK_EQ(addr0, this->addr0());\n+  }\n+\n+  void SetWrite(unsigned kAccessIsWrite) {\n+    DCHECK_EQ(x_ & 32, 0);\n+    if (kAccessIsWrite)\n+      x_ |= 32;\n+    DCHECK_EQ(kAccessIsWrite, is_write());\n+  }\n+\n+  bool IsZero() const { return x_ == 0; }\n+\n+  static inline bool TidsAreEqual(const Shadow s1, const Shadow s2) {\n+    u64 shifted_xor = (s1.x_ ^ s2.x_) >> kTidShift;\n+    DCHECK_EQ(shifted_xor == 0, s1.tid() == s2.tid());\n+    return shifted_xor == 0;\n+  }\n+\n+  static inline bool Addr0AndSizeAreEqual(const Shadow s1, const Shadow s2) {\n+    u64 masked_xor = (s1.x_ ^ s2.x_) & 31;\n+    return masked_xor == 0;\n+  }\n+\n+  static inline bool TwoRangesIntersect(Shadow s1, Shadow s2,\n+      unsigned kS2AccessSize) {\n+    bool res = false;\n+    u64 diff = s1.addr0() - s2.addr0();\n+    if ((s64)diff < 0) {  // s1.addr0 < s2.addr0  // NOLINT\n+      // if (s1.addr0() + size1) > s2.addr0()) return true;\n+      if (s1.size() > -diff)  res = true;\n+    } else {\n+      // if (s2.addr0() + kS2AccessSize > s1.addr0()) return true;\n+      if (kS2AccessSize > diff) res = true;\n+    }\n+    DCHECK_EQ(res, TwoRangesIntersectSLOW(s1, s2));\n+    DCHECK_EQ(res, TwoRangesIntersectSLOW(s2, s1));\n+    return res;\n+  }\n+\n+  // The idea behind the offset is as follows.\n+  // Consider that we have 8 bool's contained within a single 8-byte block\n+  // (mapped to a single shadow \"cell\"). Now consider that we write to the bools\n+  // from a single thread (which we consider the common case).\n+  // W/o offsetting each access will have to scan 4 shadow values at average\n+  // to find the corresponding shadow value for the bool.\n+  // With offsetting we start scanning shadow with the offset so that\n+  // each access hits necessary shadow straight off (at least in an expected\n+  // optimistic case).\n+  // This logic works seamlessly for any layout of user data. For example,\n+  // if user data is {int, short, char, char}, then accesses to the int are\n+  // offsetted to 0, short - 4, 1st char - 6, 2nd char - 7. Hopefully, accesses\n+  // from a single thread won't need to scan all 8 shadow values.\n+  unsigned ComputeSearchOffset() {\n+    return x_ & 7;\n+  }\n+  u64 addr0() const { return x_ & 7; }\n+  u64 size() const { return 1ull << size_log(); }\n+  bool is_write() const { return x_ & 32; }\n+\n+  // The idea behind the freed bit is as follows.\n+  // When the memory is freed (or otherwise unaccessible) we write to the shadow\n+  // values with tid/epoch related to the free and the freed bit set.\n+  // During memory accesses processing the freed bit is considered\n+  // as msb of tid. So any access races with shadow with freed bit set\n+  // (it is as if write from a thread with which we never synchronized before).\n+  // This allows us to detect accesses to freed memory w/o additional\n+  // overheads in memory access processing and at the same time restore\n+  // tid/epoch of free.\n+  void MarkAsFreed() {\n+     x_ |= kFreedBit;\n+  }\n+\n+  bool GetFreedAndReset() {\n+    bool res = x_ & kFreedBit;\n+    x_ &= ~kFreedBit;\n+    return res;\n+  }\n+\n+ private:\n+  u64 size_log() const { return (x_ >> 3) & 3; }\n+\n+  static bool TwoRangesIntersectSLOW(const Shadow s1, const Shadow s2) {\n+    if (s1.addr0() == s2.addr0()) return true;\n+    if (s1.addr0() < s2.addr0() && s1.addr0() + s1.size() > s2.addr0())\n+      return true;\n+    if (s2.addr0() < s1.addr0() && s2.addr0() + s2.size() > s1.addr0())\n+      return true;\n+    return false;\n+  }\n+};\n+\n+// Freed memory.\n+// As if 8-byte write by thread 0xff..f at epoch 0xff..f, races with everything.\n+const u64 kShadowFreed = 0xfffffffffffffff8ull;\n+\n+struct SignalContext;\n+\n+// This struct is stored in TLS.\n+struct ThreadState {\n+  FastState fast_state;\n+  // Synch epoch represents the threads's epoch before the last synchronization\n+  // action. It allows to reduce number of shadow state updates.\n+  // For example, fast_synch_epoch=100, last write to addr X was at epoch=150,\n+  // if we are processing write to X from the same thread at epoch=200,\n+  // we do nothing, because both writes happen in the same 'synch epoch'.\n+  // That is, if another memory access does not race with the former write,\n+  // it does not race with the latter as well.\n+  // QUESTION: can we can squeeze this into ThreadState::Fast?\n+  // E.g. ThreadState::Fast is a 44-bit, 32 are taken by synch_epoch and 12 are\n+  // taken by epoch between synchs.\n+  // This way we can save one load from tls.\n+  u64 fast_synch_epoch;\n+  // This is a slow path flag. On fast path, fast_state.GetIgnoreBit() is read.\n+  // We do not distinguish beteween ignoring reads and writes\n+  // for better performance.\n+  int ignore_reads_and_writes;\n+  uptr *shadow_stack_pos;\n+  u64 *racy_shadow_addr;\n+  u64 racy_state[2];\n+  Trace trace;\n+#ifndef TSAN_GO\n+  // C/C++ uses embed shadow stack of fixed size.\n+  uptr shadow_stack[kShadowStackSize];\n+#else\n+  // Go uses satellite shadow stack with dynamic size.\n+  uptr *shadow_stack;\n+  uptr *shadow_stack_end;\n+#endif\n+  ThreadClock clock;\n+#ifndef TSAN_GO\n+  AllocatorCache alloc_cache;\n+#endif\n+  u64 stat[StatCnt];\n+  const int tid;\n+  const int unique_id;\n+  int in_rtl;\n+  bool is_alive;\n+  const uptr stk_addr;\n+  const uptr stk_size;\n+  const uptr tls_addr;\n+  const uptr tls_size;\n+\n+  DeadlockDetector deadlock_detector;\n+\n+  bool in_signal_handler;\n+  SignalContext *signal_ctx;\n+\n+#ifndef TSAN_GO\n+  u32 last_sleep_stack_id;\n+  ThreadClock last_sleep_clock;\n+#endif\n+\n+  // Set in regions of runtime that must be signal-safe and fork-safe.\n+  // If set, malloc must not be called.\n+  int nomalloc;\n+\n+  explicit ThreadState(Context *ctx, int tid, int unique_id, u64 epoch,\n+                       uptr stk_addr, uptr stk_size,\n+                       uptr tls_addr, uptr tls_size);\n+};\n+\n+Context *CTX();\n+\n+#ifndef TSAN_GO\n+extern THREADLOCAL char cur_thread_placeholder[];\n+INLINE ThreadState *cur_thread() {\n+  return reinterpret_cast<ThreadState *>(&cur_thread_placeholder);\n+}\n+#endif\n+\n+enum ThreadStatus {\n+  ThreadStatusInvalid,   // Non-existent thread, data is invalid.\n+  ThreadStatusCreated,   // Created but not yet running.\n+  ThreadStatusRunning,   // The thread is currently running.\n+  ThreadStatusFinished,  // Joinable thread is finished but not yet joined.\n+  ThreadStatusDead       // Joined, but some info (trace) is still alive.\n+};\n+\n+// An info about a thread that is hold for some time after its termination.\n+struct ThreadDeadInfo {\n+  Trace trace;\n+};\n+\n+struct ThreadContext {\n+  const int tid;\n+  int unique_id;  // Non-rolling thread id.\n+  uptr os_id;  // pid\n+  uptr user_id;  // Some opaque user thread id (e.g. pthread_t).\n+  ThreadState *thr;\n+  ThreadStatus status;\n+  bool detached;\n+  int reuse_count;\n+  SyncClock sync;\n+  // Epoch at which the thread had started.\n+  // If we see an event from the thread stamped by an older epoch,\n+  // the event is from a dead thread that shared tid with this thread.\n+  u64 epoch0;\n+  u64 epoch1;\n+  StackTrace creation_stack;\n+  ThreadDeadInfo *dead_info;\n+  ThreadContext *dead_next;  // In dead thread list.\n+\n+  explicit ThreadContext(int tid);\n+};\n+\n+struct RacyStacks {\n+  MD5Hash hash[2];\n+  bool operator==(const RacyStacks &other) const {\n+    if (hash[0] == other.hash[0] && hash[1] == other.hash[1])\n+      return true;\n+    if (hash[0] == other.hash[1] && hash[1] == other.hash[0])\n+      return true;\n+    return false;\n+  }\n+};\n+\n+struct RacyAddress {\n+  uptr addr_min;\n+  uptr addr_max;\n+};\n+\n+struct FiredSuppression {\n+  ReportType type;\n+  uptr pc;\n+};\n+\n+struct Context {\n+  Context();\n+\n+  bool initialized;\n+\n+  SyncTab synctab;\n+\n+  Mutex report_mtx;\n+  int nreported;\n+  int nmissed_expected;\n+\n+  Mutex thread_mtx;\n+  unsigned thread_seq;\n+  unsigned unique_thread_seq;\n+  int alive_threads;\n+  int max_alive_threads;\n+  ThreadContext *threads[kMaxTid];\n+  int dead_list_size;\n+  ThreadContext* dead_list_head;\n+  ThreadContext* dead_list_tail;\n+\n+  Vector<RacyStacks> racy_stacks;\n+  Vector<RacyAddress> racy_addresses;\n+  Vector<FiredSuppression> fired_suppressions;\n+\n+  Flags flags;\n+\n+  u64 stat[StatCnt];\n+  u64 int_alloc_cnt[MBlockTypeCount];\n+  u64 int_alloc_siz[MBlockTypeCount];\n+};\n+\n+class ScopedInRtl {\n+ public:\n+  ScopedInRtl();\n+  ~ScopedInRtl();\n+ private:\n+  ThreadState*thr_;\n+  int in_rtl_;\n+  int errno_;\n+};\n+\n+class ScopedReport {\n+ public:\n+  explicit ScopedReport(ReportType typ);\n+  ~ScopedReport();\n+\n+  void AddStack(const StackTrace *stack);\n+  void AddMemoryAccess(uptr addr, Shadow s, const StackTrace *stack);\n+  void AddThread(const ThreadContext *tctx);\n+  void AddMutex(const SyncVar *s);\n+  void AddLocation(uptr addr, uptr size);\n+  void AddSleep(u32 stack_id);\n+\n+  const ReportDesc *GetReport() const;\n+\n+ private:\n+  Context *ctx_;\n+  ReportDesc *rep_;\n+\n+  ScopedReport(const ScopedReport&);\n+  void operator = (const ScopedReport&);\n+};\n+\n+void RestoreStack(int tid, const u64 epoch, StackTrace *stk);\n+\n+void StatAggregate(u64 *dst, u64 *src);\n+void StatOutput(u64 *stat);\n+void ALWAYS_INLINE INLINE StatInc(ThreadState *thr, StatType typ, u64 n = 1) {\n+  if (kCollectStats)\n+    thr->stat[typ] += n;\n+}\n+\n+void InitializeShadowMemory();\n+void InitializeInterceptors();\n+void InitializeDynamicAnnotations();\n+\n+void ReportRace(ThreadState *thr);\n+bool OutputReport(Context *ctx,\n+                  const ScopedReport &srep,\n+                  const ReportStack *suppress_stack = 0);\n+bool IsFiredSuppression(Context *ctx,\n+                        const ScopedReport &srep,\n+                        const StackTrace &trace);\n+bool IsExpectedReport(uptr addr, uptr size);\n+\n+#if defined(TSAN_DEBUG_OUTPUT) && TSAN_DEBUG_OUTPUT >= 1\n+# define DPrintf TsanPrintf\n+#else\n+# define DPrintf(...)\n+#endif\n+\n+#if defined(TSAN_DEBUG_OUTPUT) && TSAN_DEBUG_OUTPUT >= 2\n+# define DPrintf2 TsanPrintf\n+#else\n+# define DPrintf2(...)\n+#endif\n+\n+u32 CurrentStackId(ThreadState *thr, uptr pc);\n+void PrintCurrentStack(ThreadState *thr, uptr pc);\n+\n+void Initialize(ThreadState *thr);\n+int Finalize(ThreadState *thr);\n+\n+void MemoryAccess(ThreadState *thr, uptr pc, uptr addr,\n+    int kAccessSizeLog, bool kAccessIsWrite);\n+void MemoryAccessImpl(ThreadState *thr, uptr addr,\n+    int kAccessSizeLog, bool kAccessIsWrite, FastState fast_state,\n+    u64 *shadow_mem, Shadow cur);\n+void MemoryRead1Byte(ThreadState *thr, uptr pc, uptr addr);\n+void MemoryWrite1Byte(ThreadState *thr, uptr pc, uptr addr);\n+void MemoryRead8Byte(ThreadState *thr, uptr pc, uptr addr);\n+void MemoryWrite8Byte(ThreadState *thr, uptr pc, uptr addr);\n+void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n+                       uptr size, bool is_write);\n+void MemoryResetRange(ThreadState *thr, uptr pc, uptr addr, uptr size);\n+void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size);\n+void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size);\n+void IgnoreCtl(ThreadState *thr, bool write, bool begin);\n+\n+void FuncEntry(ThreadState *thr, uptr pc);\n+void FuncExit(ThreadState *thr);\n+\n+int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached);\n+void ThreadStart(ThreadState *thr, int tid, uptr os_id);\n+void ThreadFinish(ThreadState *thr);\n+int ThreadTid(ThreadState *thr, uptr pc, uptr uid);\n+void ThreadJoin(ThreadState *thr, uptr pc, int tid);\n+void ThreadDetach(ThreadState *thr, uptr pc, int tid);\n+void ThreadFinalize(ThreadState *thr);\n+void ThreadFinalizerGoroutine(ThreadState *thr);\n+\n+void MutexCreate(ThreadState *thr, uptr pc, uptr addr,\n+                 bool rw, bool recursive, bool linker_init);\n+void MutexDestroy(ThreadState *thr, uptr pc, uptr addr);\n+void MutexLock(ThreadState *thr, uptr pc, uptr addr);\n+void MutexUnlock(ThreadState *thr, uptr pc, uptr addr);\n+void MutexReadLock(ThreadState *thr, uptr pc, uptr addr);\n+void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr);\n+void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr);\n+\n+void Acquire(ThreadState *thr, uptr pc, uptr addr);\n+void Release(ThreadState *thr, uptr pc, uptr addr);\n+void ReleaseStore(ThreadState *thr, uptr pc, uptr addr);\n+void AfterSleep(ThreadState *thr, uptr pc);\n+\n+// The hacky call uses custom calling convention and an assembly thunk.\n+// It is considerably faster that a normal call for the caller\n+// if it is not executed (it is intended for slow paths from hot functions).\n+// The trick is that the call preserves all registers and the compiler\n+// does not treat it as a call.\n+// If it does not work for you, use normal call.\n+#if TSAN_DEBUG == 0\n+// The caller may not create the stack frame for itself at all,\n+// so we create a reserve stack frame for it (1024b must be enough).\n+#define HACKY_CALL(f) \\\n+  __asm__ __volatile__(\"sub $1024, %%rsp;\" \\\n+                       \"/*.cfi_adjust_cfa_offset 1024;*/\" \\\n+                       \"call \" #f \"_thunk;\" \\\n+                       \"add $1024, %%rsp;\" \\\n+                       \"/*.cfi_adjust_cfa_offset -1024;*/\" \\\n+                       ::: \"memory\", \"cc\");\n+#else\n+#define HACKY_CALL(f) f()\n+#endif\n+\n+void TraceSwitch(ThreadState *thr);\n+\n+extern \"C\" void __tsan_trace_switch();\n+void ALWAYS_INLINE INLINE TraceAddEvent(ThreadState *thr, u64 epoch,\n+                                        EventType typ, uptr addr) {\n+  StatInc(thr, StatEvents);\n+  if (UNLIKELY((epoch % kTracePartSize) == 0)) {\n+    TraceSwitch(thr);\n+  }\n+  Event *evp = &thr->trace.events[epoch % kTraceSize];\n+  Event ev = (u64)addr | ((u64)typ << 61);\n+  *evp = ev;\n+}\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_RTL_H"}, {"sha": "aee650d9f4e66add4d520be3242c72801547cdd6", "filename": "libsanitizer/tsan/tsan_rtl_amd64.S", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,164 @@\n+.section .text\n+\n+.globl __tsan_trace_switch_thunk\n+__tsan_trace_switch_thunk:\n+  .cfi_startproc\n+  # Save scratch registers.\n+  push %rax\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rax, 0\n+  push %rcx\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rcx, 0\n+  push %rdx\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rdx, 0\n+  push %rsi\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rsi, 0\n+  push %rdi\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rdi, 0\n+  push %r8\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %r8, 0\n+  push %r9\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %r9, 0\n+  push %r10\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %r10, 0\n+  push %r11\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %r11, 0\n+  # Align stack frame.\n+  push %rbx  # non-scratch\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rbx, 0\n+  mov %rsp, %rbx  # save current rsp\n+  .cfi_def_cfa_register %rbx\n+  shr $4, %rsp  # clear 4 lsb, align to 16\n+  shl $4, %rsp\n+\n+  call __tsan_trace_switch\n+\n+  # Unalign stack frame back.\n+  mov %rbx, %rsp  # restore the original rsp\n+  .cfi_def_cfa_register %rsp\n+  pop %rbx\n+  .cfi_adjust_cfa_offset -8\n+  # Restore scratch registers.\n+  pop %r11\n+  .cfi_adjust_cfa_offset -8\n+  pop %r10\n+  .cfi_adjust_cfa_offset -8\n+  pop %r9\n+  .cfi_adjust_cfa_offset -8\n+  pop %r8\n+  .cfi_adjust_cfa_offset -8\n+  pop %rdi\n+  .cfi_adjust_cfa_offset -8\n+  pop %rsi\n+  .cfi_adjust_cfa_offset -8\n+  pop %rdx\n+  .cfi_adjust_cfa_offset -8\n+  pop %rcx\n+  .cfi_adjust_cfa_offset -8\n+  pop %rax\n+  .cfi_adjust_cfa_offset -8\n+  .cfi_restore %rax\n+  .cfi_restore %rbx\n+  .cfi_restore %rcx\n+  .cfi_restore %rdx\n+  .cfi_restore %rsi\n+  .cfi_restore %rdi\n+  .cfi_restore %r8\n+  .cfi_restore %r9\n+  .cfi_restore %r10\n+  .cfi_restore %r11\n+  ret\n+  .cfi_endproc\n+\n+.globl __tsan_report_race_thunk\n+__tsan_report_race_thunk:\n+  .cfi_startproc\n+  # Save scratch registers.\n+  push %rax\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rax, 0\n+  push %rcx\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rcx, 0\n+  push %rdx\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rdx, 0\n+  push %rsi\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rsi, 0\n+  push %rdi\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rdi, 0\n+  push %r8\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %r8, 0\n+  push %r9\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %r9, 0\n+  push %r10\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %r10, 0\n+  push %r11\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %r11, 0\n+  # Align stack frame.\n+  push %rbx  # non-scratch\n+  .cfi_adjust_cfa_offset 8\n+  .cfi_rel_offset %rbx, 0\n+  mov %rsp, %rbx  # save current rsp\n+  .cfi_def_cfa_register %rbx\n+  shr $4, %rsp  # clear 4 lsb, align to 16\n+  shl $4, %rsp\n+\n+  call __tsan_report_race\n+\n+  # Unalign stack frame back.\n+  mov %rbx, %rsp  # restore the original rsp\n+  .cfi_def_cfa_register %rsp\n+  pop %rbx\n+  .cfi_adjust_cfa_offset -8\n+  # Restore scratch registers.\n+  pop %r11\n+  .cfi_adjust_cfa_offset -8\n+  pop %r10\n+  .cfi_adjust_cfa_offset -8\n+  pop %r9\n+  .cfi_adjust_cfa_offset -8\n+  pop %r8\n+  .cfi_adjust_cfa_offset -8\n+  pop %rdi\n+  .cfi_adjust_cfa_offset -8\n+  pop %rsi\n+  .cfi_adjust_cfa_offset -8\n+  pop %rdx\n+  .cfi_adjust_cfa_offset -8\n+  pop %rcx\n+  .cfi_adjust_cfa_offset -8\n+  pop %rax\n+  .cfi_adjust_cfa_offset -8\n+  .cfi_restore %rax\n+  .cfi_restore %rbx\n+  .cfi_restore %rcx\n+  .cfi_restore %rdx\n+  .cfi_restore %rsi\n+  .cfi_restore %rdi\n+  .cfi_restore %r8\n+  .cfi_restore %r9\n+  .cfi_restore %r10\n+  .cfi_restore %r11\n+  ret\n+  .cfi_endproc\n+\n+#ifdef __linux__\n+/* We do not need executable stack.  */\n+.section        .note.GNU-stack,\"\",@progbits\n+#endif"}, {"sha": "098894f5caa81596d45b2fdab93aa53236efda5e", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,269 @@\n+//===-- tsan_rtl_mutex.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"tsan_rtl.h\"\n+#include \"tsan_flags.h\"\n+#include \"tsan_sync.h\"\n+#include \"tsan_report.h\"\n+#include \"tsan_symbolize.h\"\n+#include \"tsan_platform.h\"\n+\n+namespace __tsan {\n+\n+void MutexCreate(ThreadState *thr, uptr pc, uptr addr,\n+                 bool rw, bool recursive, bool linker_init) {\n+  Context *ctx = CTX();\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: MutexCreate %zx\\n\", thr->tid, addr);\n+  StatInc(thr, StatMutexCreate);\n+  if (!linker_init && IsAppMem(addr))\n+    MemoryWrite1Byte(thr, pc, addr);\n+  SyncVar *s = ctx->synctab.GetAndLock(thr, pc, addr, true);\n+  s->is_rw = rw;\n+  s->is_recursive = recursive;\n+  s->is_linker_init = linker_init;\n+  s->mtx.Unlock();\n+}\n+\n+void MutexDestroy(ThreadState *thr, uptr pc, uptr addr) {\n+  Context *ctx = CTX();\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: MutexDestroy %zx\\n\", thr->tid, addr);\n+  StatInc(thr, StatMutexDestroy);\n+#ifndef TSAN_GO\n+  // Global mutexes not marked as LINKER_INITIALIZED\n+  // cause tons of not interesting reports, so just ignore it.\n+  if (IsGlobalVar(addr))\n+    return;\n+#endif\n+  SyncVar *s = ctx->synctab.GetAndRemove(thr, pc, addr);\n+  if (s == 0)\n+    return;\n+  if (IsAppMem(addr))\n+    MemoryWrite1Byte(thr, pc, addr);\n+  if (flags()->report_destroy_locked\n+      && s->owner_tid != SyncVar::kInvalidTid\n+      && !s->is_broken) {\n+    s->is_broken = true;\n+    ScopedReport rep(ReportTypeMutexDestroyLocked);\n+    rep.AddMutex(s);\n+    StackTrace trace;\n+    trace.ObtainCurrent(thr, pc);\n+    rep.AddStack(&trace);\n+    FastState last(s->last_lock);\n+    RestoreStack(last.tid(), last.epoch(), &trace);\n+    rep.AddStack(&trace);\n+    rep.AddLocation(s->addr, 1);\n+    OutputReport(ctx, rep);\n+  }\n+  DestroyAndFree(s);\n+}\n+\n+void MutexLock(ThreadState *thr, uptr pc, uptr addr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: MutexLock %zx\\n\", thr->tid, addr);\n+  if (IsAppMem(addr))\n+    MemoryRead1Byte(thr, pc, addr);\n+  thr->fast_state.IncrementEpoch();\n+  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeLock, addr);\n+  SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n+  if (s->owner_tid == SyncVar::kInvalidTid) {\n+    CHECK_EQ(s->recursion, 0);\n+    s->owner_tid = thr->tid;\n+    s->last_lock = thr->fast_state.raw();\n+  } else if (s->owner_tid == thr->tid) {\n+    CHECK_GT(s->recursion, 0);\n+  } else {\n+    TsanPrintf(\"ThreadSanitizer WARNING: double lock\\n\");\n+    PrintCurrentStack(thr, pc);\n+  }\n+  if (s->recursion == 0) {\n+    StatInc(thr, StatMutexLock);\n+    thr->clock.set(thr->tid, thr->fast_state.epoch());\n+    thr->clock.acquire(&s->clock);\n+    StatInc(thr, StatSyncAcquire);\n+    thr->clock.acquire(&s->read_clock);\n+    StatInc(thr, StatSyncAcquire);\n+  } else if (!s->is_recursive) {\n+    StatInc(thr, StatMutexRecLock);\n+  }\n+  s->recursion++;\n+  s->mtx.Unlock();\n+}\n+\n+void MutexUnlock(ThreadState *thr, uptr pc, uptr addr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: MutexUnlock %zx\\n\", thr->tid, addr);\n+  if (IsAppMem(addr))\n+    MemoryRead1Byte(thr, pc, addr);\n+  thr->fast_state.IncrementEpoch();\n+  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeUnlock, addr);\n+  SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n+  if (s->recursion == 0) {\n+    if (!s->is_broken) {\n+      s->is_broken = true;\n+      TsanPrintf(\"ThreadSanitizer WARNING: unlock of unlocked mutex\\n\");\n+      PrintCurrentStack(thr, pc);\n+    }\n+  } else if (s->owner_tid != thr->tid) {\n+    if (!s->is_broken) {\n+      s->is_broken = true;\n+      TsanPrintf(\"ThreadSanitizer WARNING: mutex unlock by another thread\\n\");\n+      PrintCurrentStack(thr, pc);\n+    }\n+  } else {\n+    s->recursion--;\n+    if (s->recursion == 0) {\n+      StatInc(thr, StatMutexUnlock);\n+      s->owner_tid = SyncVar::kInvalidTid;\n+      thr->clock.set(thr->tid, thr->fast_state.epoch());\n+      thr->fast_synch_epoch = thr->fast_state.epoch();\n+      thr->clock.ReleaseStore(&s->clock);\n+      StatInc(thr, StatSyncRelease);\n+    } else {\n+      StatInc(thr, StatMutexRecUnlock);\n+    }\n+  }\n+  s->mtx.Unlock();\n+}\n+\n+void MutexReadLock(ThreadState *thr, uptr pc, uptr addr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: MutexReadLock %zx\\n\", thr->tid, addr);\n+  StatInc(thr, StatMutexReadLock);\n+  if (IsAppMem(addr))\n+    MemoryRead1Byte(thr, pc, addr);\n+  thr->fast_state.IncrementEpoch();\n+  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeRLock, addr);\n+  SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, false);\n+  if (s->owner_tid != SyncVar::kInvalidTid) {\n+    TsanPrintf(\"ThreadSanitizer WARNING: read lock of a write locked mutex\\n\");\n+    PrintCurrentStack(thr, pc);\n+  }\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->clock.acquire(&s->clock);\n+  s->last_lock = thr->fast_state.raw();\n+  StatInc(thr, StatSyncAcquire);\n+  s->mtx.ReadUnlock();\n+}\n+\n+void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: MutexReadUnlock %zx\\n\", thr->tid, addr);\n+  StatInc(thr, StatMutexReadUnlock);\n+  if (IsAppMem(addr))\n+    MemoryRead1Byte(thr, pc, addr);\n+  thr->fast_state.IncrementEpoch();\n+  TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeRUnlock, addr);\n+  SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n+  if (s->owner_tid != SyncVar::kInvalidTid) {\n+    TsanPrintf(\"ThreadSanitizer WARNING: read unlock of a write \"\n+               \"locked mutex\\n\");\n+    PrintCurrentStack(thr, pc);\n+  }\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->fast_synch_epoch = thr->fast_state.epoch();\n+  thr->clock.release(&s->read_clock);\n+  StatInc(thr, StatSyncRelease);\n+  s->mtx.Unlock();\n+}\n+\n+void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: MutexReadOrWriteUnlock %zx\\n\", thr->tid, addr);\n+  if (IsAppMem(addr))\n+    MemoryRead1Byte(thr, pc, addr);\n+  SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n+  if (s->owner_tid == SyncVar::kInvalidTid) {\n+    // Seems to be read unlock.\n+    StatInc(thr, StatMutexReadUnlock);\n+    thr->fast_state.IncrementEpoch();\n+    TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeRUnlock, addr);\n+    thr->clock.set(thr->tid, thr->fast_state.epoch());\n+    thr->fast_synch_epoch = thr->fast_state.epoch();\n+    thr->clock.release(&s->read_clock);\n+    StatInc(thr, StatSyncRelease);\n+  } else if (s->owner_tid == thr->tid) {\n+    // Seems to be write unlock.\n+    CHECK_GT(s->recursion, 0);\n+    s->recursion--;\n+    if (s->recursion == 0) {\n+      StatInc(thr, StatMutexUnlock);\n+      s->owner_tid = SyncVar::kInvalidTid;\n+      // FIXME: Refactor me, plz.\n+      // The sequence of events is quite tricky and doubled in several places.\n+      // First, it's a bug to increment the epoch w/o writing to the trace.\n+      // Then, the acquire/release logic can be factored out as well.\n+      thr->fast_state.IncrementEpoch();\n+      TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeUnlock, addr);\n+      thr->clock.set(thr->tid, thr->fast_state.epoch());\n+      thr->fast_synch_epoch = thr->fast_state.epoch();\n+      thr->clock.ReleaseStore(&s->clock);\n+      StatInc(thr, StatSyncRelease);\n+    } else {\n+      StatInc(thr, StatMutexRecUnlock);\n+    }\n+  } else if (!s->is_broken) {\n+    s->is_broken = true;\n+    TsanPrintf(\"ThreadSanitizer WARNING: mutex unlock by another thread\\n\");\n+    PrintCurrentStack(thr, pc);\n+  }\n+  s->mtx.Unlock();\n+}\n+\n+void Acquire(ThreadState *thr, uptr pc, uptr addr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: Acquire %zx\\n\", thr->tid, addr);\n+  SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, false);\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->clock.acquire(&s->clock);\n+  StatInc(thr, StatSyncAcquire);\n+  s->mtx.ReadUnlock();\n+}\n+\n+void Release(ThreadState *thr, uptr pc, uptr addr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: Release %zx\\n\", thr->tid, addr);\n+  SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->clock.release(&s->clock);\n+  StatInc(thr, StatSyncRelease);\n+  s->mtx.Unlock();\n+}\n+\n+void ReleaseStore(ThreadState *thr, uptr pc, uptr addr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: ReleaseStore %zx\\n\", thr->tid, addr);\n+  SyncVar *s = CTX()->synctab.GetAndLock(thr, pc, addr, true);\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->clock.ReleaseStore(&s->clock);\n+  StatInc(thr, StatSyncRelease);\n+  s->mtx.Unlock();\n+}\n+\n+#ifndef TSAN_GO\n+void AfterSleep(ThreadState *thr, uptr pc) {\n+  Context *ctx = CTX();\n+  thr->last_sleep_stack_id = CurrentStackId(thr, pc);\n+  Lock l(&ctx->thread_mtx);\n+  for (unsigned i = 0; i < kMaxTid; i++) {\n+    ThreadContext *tctx = ctx->threads[i];\n+    if (tctx == 0)\n+      continue;\n+    if (tctx->status == ThreadStatusRunning)\n+      thr->last_sleep_clock.set(i, tctx->thr->fast_state.epoch());\n+    else\n+      thr->last_sleep_clock.set(i, tctx->epoch1);\n+  }\n+}\n+#endif\n+\n+}  // namespace __tsan"}, {"sha": "1511913d74288b246327f25ac002416789c6bf34", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,461 @@\n+//===-- tsan_rtl_report.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_suppressions.h\"\n+#include \"tsan_symbolize.h\"\n+#include \"tsan_report.h\"\n+#include \"tsan_sync.h\"\n+#include \"tsan_mman.h\"\n+#include \"tsan_flags.h\"\n+\n+namespace __tsan {\n+\n+void TsanCheckFailed(const char *file, int line, const char *cond,\n+                     u64 v1, u64 v2) {\n+  ScopedInRtl in_rtl;\n+  TsanPrintf(\"FATAL: ThreadSanitizer CHECK failed: \"\n+             \"%s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\",\n+             file, line, cond, (uptr)v1, (uptr)v2);\n+  Die();\n+}\n+\n+// Can be overriden by an application/test to intercept reports.\n+#ifdef TSAN_EXTERNAL_HOOKS\n+bool OnReport(const ReportDesc *rep, bool suppressed);\n+#else\n+SANITIZER_INTERFACE_ATTRIBUTE\n+bool WEAK OnReport(const ReportDesc *rep, bool suppressed) {\n+  (void)rep;\n+  return suppressed;\n+}\n+#endif\n+\n+static void StackStripMain(ReportStack *stack) {\n+  ReportStack *last_frame = 0;\n+  ReportStack *last_frame2 = 0;\n+  const char *prefix = \"__interceptor_\";\n+  uptr prefix_len = internal_strlen(prefix);\n+  const char *path_prefix = flags()->strip_path_prefix;\n+  uptr path_prefix_len = internal_strlen(path_prefix);\n+  char *pos;\n+  for (ReportStack *ent = stack; ent; ent = ent->next) {\n+    if (ent->func && 0 == internal_strncmp(ent->func, prefix, prefix_len))\n+      ent->func += prefix_len;\n+    if (ent->file && (pos = internal_strstr(ent->file, path_prefix)))\n+      ent->file = pos + path_prefix_len;\n+    if (ent->file && ent->file[0] == '.' && ent->file[1] == '/')\n+      ent->file += 2;\n+    last_frame2 = last_frame;\n+    last_frame = ent;\n+  }\n+\n+  if (last_frame2 == 0)\n+    return;\n+  const char *last = last_frame->func;\n+#ifndef TSAN_GO\n+  const char *last2 = last_frame2->func;\n+  // Strip frame above 'main'\n+  if (last2 && 0 == internal_strcmp(last2, \"main\")) {\n+    last_frame2->next = 0;\n+  // Strip our internal thread start routine.\n+  } else if (last && 0 == internal_strcmp(last, \"__tsan_thread_start_func\")) {\n+    last_frame2->next = 0;\n+  // Strip global ctors init.\n+  } else if (last && 0 == internal_strcmp(last, \"__do_global_ctors_aux\")) {\n+    last_frame2->next = 0;\n+  // If both are 0, then we probably just failed to symbolize.\n+  } else if (last || last2) {\n+    // Ensure that we recovered stack completely. Trimmed stack\n+    // can actually happen if we do not instrument some code,\n+    // so it's only a debug print. However we must try hard to not miss it\n+    // due to our fault.\n+    DPrintf(\"Bottom stack frame of stack %zx is missed\\n\", stack->pc);\n+  }\n+#else\n+  if (last && 0 == internal_strcmp(last, \"schedunlock\"))\n+    last_frame2->next = 0;\n+#endif\n+}\n+\n+static ReportStack *SymbolizeStack(const StackTrace& trace) {\n+  if (trace.IsEmpty())\n+    return 0;\n+  ReportStack *stack = 0;\n+  for (uptr si = 0; si < trace.Size(); si++) {\n+    // We obtain the return address, that is, address of the next instruction,\n+    // so offset it by 1 byte.\n+    bool is_last = (si == trace.Size() - 1);\n+    ReportStack *ent = SymbolizeCode(trace.Get(si) - !is_last);\n+    CHECK_NE(ent, 0);\n+    ReportStack *last = ent;\n+    while (last->next) {\n+      last->pc += !is_last;\n+      last = last->next;\n+    }\n+    last->pc += !is_last;\n+    last->next = stack;\n+    stack = ent;\n+  }\n+  StackStripMain(stack);\n+  return stack;\n+}\n+\n+ScopedReport::ScopedReport(ReportType typ) {\n+  ctx_ = CTX();\n+  void *mem = internal_alloc(MBlockReport, sizeof(ReportDesc));\n+  rep_ = new(mem) ReportDesc;\n+  rep_->typ = typ;\n+  ctx_->report_mtx.Lock();\n+}\n+\n+ScopedReport::~ScopedReport() {\n+  ctx_->report_mtx.Unlock();\n+  rep_->~ReportDesc();\n+  internal_free(rep_);\n+}\n+\n+void ScopedReport::AddStack(const StackTrace *stack) {\n+  ReportStack **rs = rep_->stacks.PushBack();\n+  *rs = SymbolizeStack(*stack);\n+}\n+\n+void ScopedReport::AddMemoryAccess(uptr addr, Shadow s,\n+                                   const StackTrace *stack) {\n+  void *mem = internal_alloc(MBlockReportMop, sizeof(ReportMop));\n+  ReportMop *mop = new(mem) ReportMop;\n+  rep_->mops.PushBack(mop);\n+  mop->tid = s.tid();\n+  mop->addr = addr + s.addr0();\n+  mop->size = s.size();\n+  mop->write = s.is_write();\n+  mop->nmutex = 0;\n+  mop->stack = SymbolizeStack(*stack);\n+}\n+\n+void ScopedReport::AddThread(const ThreadContext *tctx) {\n+  for (uptr i = 0; i < rep_->threads.Size(); i++) {\n+    if (rep_->threads[i]->id == tctx->tid)\n+      return;\n+  }\n+  void *mem = internal_alloc(MBlockReportThread, sizeof(ReportThread));\n+  ReportThread *rt = new(mem) ReportThread();\n+  rep_->threads.PushBack(rt);\n+  rt->id = tctx->tid;\n+  rt->pid = tctx->os_id;\n+  rt->running = (tctx->status == ThreadStatusRunning);\n+  rt->stack = SymbolizeStack(tctx->creation_stack);\n+}\n+\n+#ifndef TSAN_GO\n+static ThreadContext *FindThread(int unique_id) {\n+  CTX()->thread_mtx.CheckLocked();\n+  for (unsigned i = 0; i < kMaxTid; i++) {\n+    ThreadContext *tctx = CTX()->threads[i];\n+    if (tctx && tctx->unique_id == unique_id) {\n+      return tctx;\n+    }\n+  }\n+  return 0;\n+}\n+#endif\n+\n+void ScopedReport::AddMutex(const SyncVar *s) {\n+  void *mem = internal_alloc(MBlockReportMutex, sizeof(ReportMutex));\n+  ReportMutex *rm = new(mem) ReportMutex();\n+  rep_->mutexes.PushBack(rm);\n+  rm->id = 42;\n+  rm->stack = SymbolizeStack(s->creation_stack);\n+}\n+\n+void ScopedReport::AddLocation(uptr addr, uptr size) {\n+  if (addr == 0)\n+    return;\n+#ifndef TSAN_GO\n+  if (allocator()->PointerIsMine((void*)addr)) {\n+    MBlock *b = user_mblock(0, (void*)addr);\n+    ThreadContext *tctx = FindThread(b->alloc_tid);\n+    void *mem = internal_alloc(MBlockReportLoc, sizeof(ReportLocation));\n+    ReportLocation *loc = new(mem) ReportLocation();\n+    rep_->locs.PushBack(loc);\n+    loc->type = ReportLocationHeap;\n+    loc->addr = (uptr)allocator()->GetBlockBegin((void*)addr);\n+    loc->size = b->size;\n+    loc->tid = tctx ? tctx->tid : b->alloc_tid;\n+    loc->name = 0;\n+    loc->file = 0;\n+    loc->line = 0;\n+    loc->stack = 0;\n+    uptr ssz = 0;\n+    const uptr *stack = StackDepotGet(b->alloc_stack_id, &ssz);\n+    if (stack) {\n+      StackTrace trace;\n+      trace.Init(stack, ssz);\n+      loc->stack = SymbolizeStack(trace);\n+    }\n+    if (tctx)\n+      AddThread(tctx);\n+    return;\n+  }\n+#endif\n+  ReportStack *symb = SymbolizeData(addr);\n+  if (symb) {\n+    void *mem = internal_alloc(MBlockReportLoc, sizeof(ReportLocation));\n+    ReportLocation *loc = new(mem) ReportLocation();\n+    rep_->locs.PushBack(loc);\n+    loc->type = ReportLocationGlobal;\n+    loc->addr = addr;\n+    loc->size = size;\n+    loc->tid = 0;\n+    loc->name = symb->func;\n+    loc->file = symb->file;\n+    loc->line = symb->line;\n+    loc->stack = 0;\n+    internal_free(symb);\n+    return;\n+  }\n+}\n+\n+#ifndef TSAN_GO\n+void ScopedReport::AddSleep(u32 stack_id) {\n+  uptr ssz = 0;\n+  const uptr *stack = StackDepotGet(stack_id, &ssz);\n+  if (stack) {\n+    StackTrace trace;\n+    trace.Init(stack, ssz);\n+    rep_->sleep = SymbolizeStack(trace);\n+  }\n+}\n+#endif\n+\n+const ReportDesc *ScopedReport::GetReport() const {\n+  return rep_;\n+}\n+\n+void RestoreStack(int tid, const u64 epoch, StackTrace *stk) {\n+  ThreadContext *tctx = CTX()->threads[tid];\n+  if (tctx == 0)\n+    return;\n+  Trace* trace = 0;\n+  if (tctx->status == ThreadStatusRunning) {\n+    CHECK(tctx->thr);\n+    trace = &tctx->thr->trace;\n+  } else if (tctx->status == ThreadStatusFinished\n+      || tctx->status == ThreadStatusDead) {\n+    if (tctx->dead_info == 0)\n+      return;\n+    trace = &tctx->dead_info->trace;\n+  } else {\n+    return;\n+  }\n+  Lock l(&trace->mtx);\n+  const int partidx = (epoch / (kTraceSize / kTraceParts)) % kTraceParts;\n+  TraceHeader* hdr = &trace->headers[partidx];\n+  if (epoch < hdr->epoch0)\n+    return;\n+  const u64 eend = epoch % kTraceSize;\n+  const u64 ebegin = eend / kTracePartSize * kTracePartSize;\n+  DPrintf(\"#%d: RestoreStack epoch=%zu ebegin=%zu eend=%zu partidx=%d\\n\",\n+          tid, (uptr)epoch, (uptr)ebegin, (uptr)eend, partidx);\n+  InternalScopedBuffer<uptr> stack(1024);  // FIXME: de-hardcode 1024\n+  for (uptr i = 0; i < hdr->stack0.Size(); i++) {\n+    stack[i] = hdr->stack0.Get(i);\n+    DPrintf2(\"  #%02lu: pc=%zx\\n\", i, stack[i]);\n+  }\n+  uptr pos = hdr->stack0.Size();\n+  for (uptr i = ebegin; i <= eend; i++) {\n+    Event ev = trace->events[i];\n+    EventType typ = (EventType)(ev >> 61);\n+    uptr pc = (uptr)(ev & 0xffffffffffffull);\n+    DPrintf2(\"  %zu typ=%d pc=%zx\\n\", i, typ, pc);\n+    if (typ == EventTypeMop) {\n+      stack[pos] = pc;\n+    } else if (typ == EventTypeFuncEnter) {\n+      stack[pos++] = pc;\n+    } else if (typ == EventTypeFuncExit) {\n+      if (pos > 0)\n+        pos--;\n+    }\n+    for (uptr j = 0; j <= pos; j++)\n+      DPrintf2(\"      #%zu: %zx\\n\", j, stack[j]);\n+  }\n+  if (pos == 0 && stack[0] == 0)\n+    return;\n+  pos++;\n+  stk->Init(stack.data(), pos);\n+}\n+\n+static bool HandleRacyStacks(ThreadState *thr, const StackTrace (&traces)[2],\n+    uptr addr_min, uptr addr_max) {\n+  Context *ctx = CTX();\n+  bool equal_stack = false;\n+  RacyStacks hash = {};\n+  if (flags()->suppress_equal_stacks) {\n+    hash.hash[0] = md5_hash(traces[0].Begin(), traces[0].Size() * sizeof(uptr));\n+    hash.hash[1] = md5_hash(traces[1].Begin(), traces[1].Size() * sizeof(uptr));\n+    for (uptr i = 0; i < ctx->racy_stacks.Size(); i++) {\n+      if (hash == ctx->racy_stacks[i]) {\n+        DPrintf(\"ThreadSanitizer: suppressing report as doubled (stack)\\n\");\n+        equal_stack = true;\n+        break;\n+      }\n+    }\n+  }\n+  bool equal_address = false;\n+  RacyAddress ra0 = {addr_min, addr_max};\n+  if (flags()->suppress_equal_addresses) {\n+    for (uptr i = 0; i < ctx->racy_addresses.Size(); i++) {\n+      RacyAddress ra2 = ctx->racy_addresses[i];\n+      uptr maxbeg = max(ra0.addr_min, ra2.addr_min);\n+      uptr minend = min(ra0.addr_max, ra2.addr_max);\n+      if (maxbeg < minend) {\n+        DPrintf(\"ThreadSanitizer: suppressing report as doubled (addr)\\n\");\n+        equal_address = true;\n+        break;\n+      }\n+    }\n+  }\n+  if (equal_stack || equal_address) {\n+    if (!equal_stack)\n+      ctx->racy_stacks.PushBack(hash);\n+    if (!equal_address)\n+      ctx->racy_addresses.PushBack(ra0);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static void AddRacyStacks(ThreadState *thr, const StackTrace (&traces)[2],\n+    uptr addr_min, uptr addr_max) {\n+  Context *ctx = CTX();\n+  if (flags()->suppress_equal_stacks) {\n+    RacyStacks hash;\n+    hash.hash[0] = md5_hash(traces[0].Begin(), traces[0].Size() * sizeof(uptr));\n+    hash.hash[1] = md5_hash(traces[1].Begin(), traces[1].Size() * sizeof(uptr));\n+    ctx->racy_stacks.PushBack(hash);\n+  }\n+  if (flags()->suppress_equal_addresses) {\n+    RacyAddress ra0 = {addr_min, addr_max};\n+    ctx->racy_addresses.PushBack(ra0);\n+  }\n+}\n+\n+bool OutputReport(Context *ctx,\n+                  const ScopedReport &srep,\n+                  const ReportStack *suppress_stack) {\n+  const ReportDesc *rep = srep.GetReport();\n+  const uptr suppress_pc = IsSuppressed(rep->typ, suppress_stack);\n+  if (suppress_pc != 0) {\n+    FiredSuppression supp = {srep.GetReport()->typ, suppress_pc};\n+    ctx->fired_suppressions.PushBack(supp);\n+  }\n+  if (OnReport(rep, suppress_pc != 0))\n+    return false;\n+  PrintReport(rep);\n+  CTX()->nreported++;\n+  return true;\n+}\n+\n+bool IsFiredSuppression(Context *ctx,\n+                        const ScopedReport &srep,\n+                        const StackTrace &trace) {\n+  for (uptr k = 0; k < ctx->fired_suppressions.Size(); k++) {\n+    if (ctx->fired_suppressions[k].type != srep.GetReport()->typ)\n+      continue;\n+    for (uptr j = 0; j < trace.Size(); j++) {\n+      if (trace.Get(j) == ctx->fired_suppressions[k].pc)\n+        return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void ReportRace(ThreadState *thr) {\n+  ScopedInRtl in_rtl;\n+\n+  bool freed = false;\n+  {\n+    Shadow s(thr->racy_state[1]);\n+    freed = s.GetFreedAndReset();\n+    thr->racy_state[1] = s.raw();\n+  }\n+\n+  uptr addr = ShadowToMem((uptr)thr->racy_shadow_addr);\n+  uptr addr_min = 0;\n+  uptr addr_max = 0;\n+  {\n+    uptr a0 = addr + Shadow(thr->racy_state[0]).addr0();\n+    uptr a1 = addr + Shadow(thr->racy_state[1]).addr0();\n+    uptr e0 = a0 + Shadow(thr->racy_state[0]).size();\n+    uptr e1 = a1 + Shadow(thr->racy_state[1]).size();\n+    addr_min = min(a0, a1);\n+    addr_max = max(e0, e1);\n+    if (IsExpectedReport(addr_min, addr_max - addr_min))\n+      return;\n+  }\n+\n+  Context *ctx = CTX();\n+  Lock l0(&ctx->thread_mtx);\n+\n+  ScopedReport rep(freed ? ReportTypeUseAfterFree : ReportTypeRace);\n+  const uptr kMop = 2;\n+  StackTrace traces[kMop];\n+  const uptr toppc = thr->trace.events[thr->fast_state.epoch() % kTraceSize]\n+      & ((1ull << 61) - 1);\n+  traces[0].ObtainCurrent(thr, toppc);\n+  if (IsFiredSuppression(ctx, rep, traces[0]))\n+    return;\n+  Shadow s2(thr->racy_state[1]);\n+  RestoreStack(s2.tid(), s2.epoch(), &traces[1]);\n+\n+  if (HandleRacyStacks(thr, traces, addr_min, addr_max))\n+    return;\n+\n+  for (uptr i = 0; i < kMop; i++) {\n+    Shadow s(thr->racy_state[i]);\n+    rep.AddMemoryAccess(addr, s, &traces[i]);\n+  }\n+\n+  for (uptr i = 0; i < kMop; i++) {\n+    FastState s(thr->racy_state[i]);\n+    ThreadContext *tctx = ctx->threads[s.tid()];\n+    if (s.epoch() < tctx->epoch0 || s.epoch() > tctx->epoch1)\n+      continue;\n+    rep.AddThread(tctx);\n+  }\n+\n+  rep.AddLocation(addr_min, addr_max - addr_min);\n+\n+#ifndef TSAN_GO\n+  {  // NOLINT\n+    Shadow s(thr->racy_state[1]);\n+    if (s.epoch() <= thr->last_sleep_clock.get(s.tid()))\n+      rep.AddSleep(thr->last_sleep_stack_id);\n+  }\n+#endif\n+\n+  if (!OutputReport(ctx, rep, rep.GetReport()->mops[0]->stack))\n+    return;\n+\n+  AddRacyStacks(thr, traces, addr_min, addr_max);\n+}\n+\n+void PrintCurrentStack(ThreadState *thr, uptr pc) {\n+  StackTrace trace;\n+  trace.ObtainCurrent(thr, pc);\n+  PrintStack(SymbolizeStack(trace));\n+}\n+\n+}  // namespace __tsan"}, {"sha": "0ae658c17438210446d5e149cab6e9cac90e2d1f", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,397 @@\n+//===-- tsan_rtl_thread.cc ------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_mman.h\"\n+#include \"tsan_platform.h\"\n+#include \"tsan_report.h\"\n+#include \"tsan_sync.h\"\n+\n+namespace __tsan {\n+\n+#ifndef TSAN_GO\n+const int kThreadQuarantineSize = 16;\n+#else\n+const int kThreadQuarantineSize = 64;\n+#endif\n+\n+static void MaybeReportThreadLeak(ThreadContext *tctx) {\n+  if (tctx->detached)\n+    return;\n+  if (tctx->status != ThreadStatusCreated\n+      && tctx->status != ThreadStatusRunning\n+      && tctx->status != ThreadStatusFinished)\n+    return;\n+  ScopedReport rep(ReportTypeThreadLeak);\n+  rep.AddThread(tctx);\n+  OutputReport(CTX(), rep);\n+}\n+\n+void ThreadFinalize(ThreadState *thr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  if (!flags()->report_thread_leaks)\n+    return;\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  for (unsigned i = 0; i < kMaxTid; i++) {\n+    ThreadContext *tctx = ctx->threads[i];\n+    if (tctx == 0)\n+      continue;\n+    MaybeReportThreadLeak(tctx);\n+  }\n+}\n+\n+static void ThreadDead(ThreadState *thr, ThreadContext *tctx) {\n+  Context *ctx = CTX();\n+  CHECK_GT(thr->in_rtl, 0);\n+  CHECK(tctx->status == ThreadStatusRunning\n+      || tctx->status == ThreadStatusFinished);\n+  DPrintf(\"#%d: ThreadDead uid=%zu\\n\", thr->tid, tctx->user_id);\n+  tctx->status = ThreadStatusDead;\n+  tctx->user_id = 0;\n+  tctx->sync.Reset();\n+\n+  // Put to dead list.\n+  tctx->dead_next = 0;\n+  if (ctx->dead_list_size == 0)\n+    ctx->dead_list_head = tctx;\n+  else\n+    ctx->dead_list_tail->dead_next = tctx;\n+  ctx->dead_list_tail = tctx;\n+  ctx->dead_list_size++;\n+}\n+\n+int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  StatInc(thr, StatThreadCreate);\n+  int tid = -1;\n+  ThreadContext *tctx = 0;\n+  if (ctx->dead_list_size > kThreadQuarantineSize\n+      || ctx->thread_seq >= kMaxTid) {\n+    if (ctx->dead_list_size == 0) {\n+      TsanPrintf(\"ThreadSanitizer: %d thread limit exceeded. Dying.\\n\",\n+                 kMaxTid);\n+      Die();\n+    }\n+    StatInc(thr, StatThreadReuse);\n+    tctx = ctx->dead_list_head;\n+    ctx->dead_list_head = tctx->dead_next;\n+    ctx->dead_list_size--;\n+    if (ctx->dead_list_size == 0) {\n+      CHECK_EQ(tctx->dead_next, 0);\n+      ctx->dead_list_head = 0;\n+    }\n+    CHECK_EQ(tctx->status, ThreadStatusDead);\n+    tctx->status = ThreadStatusInvalid;\n+    tctx->reuse_count++;\n+    tctx->sync.Reset();\n+    tid = tctx->tid;\n+    DestroyAndFree(tctx->dead_info);\n+  } else {\n+    StatInc(thr, StatThreadMaxTid);\n+    tid = ctx->thread_seq++;\n+    void *mem = internal_alloc(MBlockThreadContex, sizeof(ThreadContext));\n+    tctx = new(mem) ThreadContext(tid);\n+    ctx->threads[tid] = tctx;\n+  }\n+  CHECK_NE(tctx, 0);\n+  CHECK_GE(tid, 0);\n+  CHECK_LT(tid, kMaxTid);\n+  DPrintf(\"#%d: ThreadCreate tid=%d uid=%zu\\n\", thr->tid, tid, uid);\n+  CHECK_EQ(tctx->status, ThreadStatusInvalid);\n+  ctx->alive_threads++;\n+  if (ctx->max_alive_threads < ctx->alive_threads) {\n+    ctx->max_alive_threads++;\n+    CHECK_EQ(ctx->max_alive_threads, ctx->alive_threads);\n+    StatInc(thr, StatThreadMaxAlive);\n+  }\n+  tctx->status = ThreadStatusCreated;\n+  tctx->thr = 0;\n+  tctx->user_id = uid;\n+  tctx->unique_id = ctx->unique_thread_seq++;\n+  tctx->detached = detached;\n+  if (tid) {\n+    thr->fast_state.IncrementEpoch();\n+    // Can't increment epoch w/o writing to the trace as well.\n+    TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeMop, 0);\n+    thr->clock.set(thr->tid, thr->fast_state.epoch());\n+    thr->fast_synch_epoch = thr->fast_state.epoch();\n+    thr->clock.release(&tctx->sync);\n+    StatInc(thr, StatSyncRelease);\n+\n+    tctx->creation_stack.ObtainCurrent(thr, pc);\n+  }\n+  return tid;\n+}\n+\n+void ThreadStart(ThreadState *thr, int tid, uptr os_id) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  uptr stk_addr = 0;\n+  uptr stk_size = 0;\n+  uptr tls_addr = 0;\n+  uptr tls_size = 0;\n+  GetThreadStackAndTls(tid == 0, &stk_addr, &stk_size, &tls_addr, &tls_size);\n+\n+  if (tid) {\n+    if (stk_addr && stk_size) {\n+      MemoryResetRange(thr, /*pc=*/ 1, stk_addr, stk_size);\n+    }\n+\n+    if (tls_addr && tls_size) {\n+      // Check that the thr object is in tls;\n+      const uptr thr_beg = (uptr)thr;\n+      const uptr thr_end = (uptr)thr + sizeof(*thr);\n+      CHECK_GE(thr_beg, tls_addr);\n+      CHECK_LE(thr_beg, tls_addr + tls_size);\n+      CHECK_GE(thr_end, tls_addr);\n+      CHECK_LE(thr_end, tls_addr + tls_size);\n+      // Since the thr object is huge, skip it.\n+      MemoryResetRange(thr, /*pc=*/ 2, tls_addr, thr_beg - tls_addr);\n+      MemoryResetRange(thr, /*pc=*/ 2, thr_end, tls_addr + tls_size - thr_end);\n+    }\n+  }\n+\n+  Lock l(&CTX()->thread_mtx);\n+  ThreadContext *tctx = CTX()->threads[tid];\n+  CHECK_NE(tctx, 0);\n+  CHECK_EQ(tctx->status, ThreadStatusCreated);\n+  tctx->status = ThreadStatusRunning;\n+  tctx->os_id = os_id;\n+  tctx->epoch0 = tctx->epoch1 + 1;\n+  tctx->epoch1 = (u64)-1;\n+  new(thr) ThreadState(CTX(), tid, tctx->unique_id,\n+      tctx->epoch0, stk_addr, stk_size,\n+      tls_addr, tls_size);\n+#ifdef TSAN_GO\n+  // Setup dynamic shadow stack.\n+  const int kInitStackSize = 8;\n+  thr->shadow_stack = (uptr*)internal_alloc(MBlockShadowStack,\n+      kInitStackSize * sizeof(uptr));\n+  thr->shadow_stack_pos = thr->shadow_stack;\n+  thr->shadow_stack_end = thr->shadow_stack + kInitStackSize;\n+#endif\n+  tctx->thr = thr;\n+  thr->fast_synch_epoch = tctx->epoch0;\n+  thr->clock.set(tid, tctx->epoch0);\n+  thr->clock.acquire(&tctx->sync);\n+  StatInc(thr, StatSyncAcquire);\n+  DPrintf(\"#%d: ThreadStart epoch=%zu stk_addr=%zx stk_size=%zx \"\n+          \"tls_addr=%zx tls_size=%zx\\n\",\n+          tid, (uptr)tctx->epoch0, stk_addr, stk_size, tls_addr, tls_size);\n+  thr->is_alive = true;\n+}\n+\n+void ThreadFinish(ThreadState *thr) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  StatInc(thr, StatThreadFinish);\n+  // FIXME: Treat it as write.\n+  if (thr->stk_addr && thr->stk_size)\n+    MemoryResetRange(thr, /*pc=*/ 3, thr->stk_addr, thr->stk_size);\n+  if (thr->tls_addr && thr->tls_size) {\n+    const uptr thr_beg = (uptr)thr;\n+    const uptr thr_end = (uptr)thr + sizeof(*thr);\n+    // Since the thr object is huge, skip it.\n+    MemoryResetRange(thr, /*pc=*/ 4, thr->tls_addr, thr_beg - thr->tls_addr);\n+    MemoryResetRange(thr, /*pc=*/ 5,\n+        thr_end, thr->tls_addr + thr->tls_size - thr_end);\n+  }\n+  thr->is_alive = false;\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  ThreadContext *tctx = ctx->threads[thr->tid];\n+  CHECK_NE(tctx, 0);\n+  CHECK_EQ(tctx->status, ThreadStatusRunning);\n+  CHECK_GT(ctx->alive_threads, 0);\n+  ctx->alive_threads--;\n+  if (tctx->detached) {\n+    ThreadDead(thr, tctx);\n+  } else {\n+    thr->fast_state.IncrementEpoch();\n+    // Can't increment epoch w/o writing to the trace as well.\n+    TraceAddEvent(thr, thr->fast_state.epoch(), EventTypeMop, 0);\n+    thr->clock.set(thr->tid, thr->fast_state.epoch());\n+    thr->fast_synch_epoch = thr->fast_state.epoch();\n+    thr->clock.release(&tctx->sync);\n+    StatInc(thr, StatSyncRelease);\n+    tctx->status = ThreadStatusFinished;\n+  }\n+\n+  // Save from info about the thread.\n+  tctx->dead_info = new(internal_alloc(MBlockDeadInfo, sizeof(ThreadDeadInfo)))\n+      ThreadDeadInfo();\n+  internal_memcpy(&tctx->dead_info->trace.events[0],\n+      &thr->trace.events[0], sizeof(thr->trace.events));\n+  for (int i = 0; i < kTraceParts; i++) {\n+    tctx->dead_info->trace.headers[i].stack0.CopyFrom(\n+        thr->trace.headers[i].stack0);\n+  }\n+  tctx->epoch1 = thr->fast_state.epoch();\n+\n+#ifndef TSAN_GO\n+  AlloctorThreadFinish(thr);\n+#endif\n+  thr->~ThreadState();\n+  StatAggregate(ctx->stat, thr->stat);\n+  tctx->thr = 0;\n+}\n+\n+int ThreadTid(ThreadState *thr, uptr pc, uptr uid) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  int res = -1;\n+  for (unsigned tid = 0; tid < kMaxTid; tid++) {\n+    ThreadContext *tctx = ctx->threads[tid];\n+    if (tctx != 0 && tctx->user_id == uid\n+        && tctx->status != ThreadStatusInvalid) {\n+      tctx->user_id = 0;\n+      res = tid;\n+      break;\n+    }\n+  }\n+  DPrintf(\"#%d: ThreadTid uid=%zu tid=%d\\n\", thr->tid, uid, res);\n+  return res;\n+}\n+\n+void ThreadJoin(ThreadState *thr, uptr pc, int tid) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  CHECK_GT(tid, 0);\n+  CHECK_LT(tid, kMaxTid);\n+  DPrintf(\"#%d: ThreadJoin tid=%d\\n\", thr->tid, tid);\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  ThreadContext *tctx = ctx->threads[tid];\n+  if (tctx->status == ThreadStatusInvalid) {\n+    TsanPrintf(\"ThreadSanitizer: join of non-existent thread\\n\");\n+    return;\n+  }\n+  CHECK_EQ(tctx->detached, false);\n+  CHECK_EQ(tctx->status, ThreadStatusFinished);\n+  thr->clock.acquire(&tctx->sync);\n+  StatInc(thr, StatSyncAcquire);\n+  ThreadDead(thr, tctx);\n+}\n+\n+void ThreadDetach(ThreadState *thr, uptr pc, int tid) {\n+  CHECK_GT(thr->in_rtl, 0);\n+  CHECK_GT(tid, 0);\n+  CHECK_LT(tid, kMaxTid);\n+  Context *ctx = CTX();\n+  Lock l(&ctx->thread_mtx);\n+  ThreadContext *tctx = ctx->threads[tid];\n+  if (tctx->status == ThreadStatusInvalid) {\n+    TsanPrintf(\"ThreadSanitizer: detach of non-existent thread\\n\");\n+    return;\n+  }\n+  if (tctx->status == ThreadStatusFinished) {\n+    ThreadDead(thr, tctx);\n+  } else {\n+    tctx->detached = true;\n+  }\n+}\n+\n+void ThreadFinalizerGoroutine(ThreadState *thr) {\n+  thr->clock.Disable(thr->tid);\n+}\n+\n+void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n+                       uptr size, bool is_write) {\n+  if (size == 0)\n+    return;\n+\n+  u64 *shadow_mem = (u64*)MemToShadow(addr);\n+  DPrintf2(\"#%d: MemoryAccessRange: @%p %p size=%d is_write=%d\\n\",\n+      thr->tid, (void*)pc, (void*)addr,\n+      (int)size, is_write);\n+\n+#if TSAN_DEBUG\n+  if (!IsAppMem(addr)) {\n+    TsanPrintf(\"Access to non app mem %zx\\n\", addr);\n+    DCHECK(IsAppMem(addr));\n+  }\n+  if (!IsAppMem(addr + size - 1)) {\n+    TsanPrintf(\"Access to non app mem %zx\\n\", addr + size - 1);\n+    DCHECK(IsAppMem(addr + size - 1));\n+  }\n+  if (!IsShadowMem((uptr)shadow_mem)) {\n+    TsanPrintf(\"Bad shadow addr %p (%zx)\\n\", shadow_mem, addr);\n+    DCHECK(IsShadowMem((uptr)shadow_mem));\n+  }\n+  if (!IsShadowMem((uptr)(shadow_mem + size * kShadowCnt / 8 - 1))) {\n+    TsanPrintf(\"Bad shadow addr %p (%zx)\\n\",\n+               shadow_mem + size * kShadowCnt / 8 - 1, addr + size - 1);\n+    DCHECK(IsShadowMem((uptr)(shadow_mem + size * kShadowCnt / 8 - 1)));\n+  }\n+#endif\n+\n+  StatInc(thr, StatMopRange);\n+\n+  FastState fast_state = thr->fast_state;\n+  if (fast_state.GetIgnoreBit())\n+    return;\n+\n+  fast_state.IncrementEpoch();\n+  thr->fast_state = fast_state;\n+  TraceAddEvent(thr, fast_state.epoch(), EventTypeMop, pc);\n+\n+  bool unaligned = (addr % kShadowCell) != 0;\n+\n+  // Handle unaligned beginning, if any.\n+  for (; addr % kShadowCell && size; addr++, size--) {\n+    int const kAccessSizeLog = 0;\n+    Shadow cur(fast_state);\n+    cur.SetWrite(is_write);\n+    cur.SetAddr0AndSizeLog(addr & (kShadowCell - 1), kAccessSizeLog);\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, fast_state,\n+        shadow_mem, cur);\n+  }\n+  if (unaligned)\n+    shadow_mem += kShadowCnt;\n+  // Handle middle part, if any.\n+  for (; size >= kShadowCell; addr += kShadowCell, size -= kShadowCell) {\n+    int const kAccessSizeLog = 3;\n+    Shadow cur(fast_state);\n+    cur.SetWrite(is_write);\n+    cur.SetAddr0AndSizeLog(0, kAccessSizeLog);\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, fast_state,\n+        shadow_mem, cur);\n+    shadow_mem += kShadowCnt;\n+  }\n+  // Handle ending, if any.\n+  for (; size; addr++, size--) {\n+    int const kAccessSizeLog = 0;\n+    Shadow cur(fast_state);\n+    cur.SetWrite(is_write);\n+    cur.SetAddr0AndSizeLog(addr & (kShadowCell - 1), kAccessSizeLog);\n+    MemoryAccessImpl(thr, addr, kAccessSizeLog, is_write, fast_state,\n+        shadow_mem, cur);\n+  }\n+}\n+\n+void MemoryRead1Byte(ThreadState *thr, uptr pc, uptr addr) {\n+  MemoryAccess(thr, pc, addr, 0, 0);\n+}\n+\n+void MemoryWrite1Byte(ThreadState *thr, uptr pc, uptr addr) {\n+  MemoryAccess(thr, pc, addr, 0, 1);\n+}\n+\n+void MemoryRead8Byte(ThreadState *thr, uptr pc, uptr addr) {\n+  MemoryAccess(thr, pc, addr, 3, 0);\n+}\n+\n+void MemoryWrite8Byte(ThreadState *thr, uptr pc, uptr addr) {\n+  MemoryAccess(thr, pc, addr, 3, 1);\n+}\n+}  // namespace __tsan"}, {"sha": "fcbc631e086db4befeb3e89cb0538051265f70ec", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,247 @@\n+//===-- tsan_stat.cc ------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"tsan_stat.h\"\n+#include \"tsan_rtl.h\"\n+\n+namespace __tsan {\n+\n+void StatAggregate(u64 *dst, u64 *src) {\n+  if (!kCollectStats)\n+    return;\n+  for (int i = 0; i < StatCnt; i++)\n+    dst[i] += src[i];\n+}\n+\n+void StatOutput(u64 *stat) {\n+  if (!kCollectStats)\n+    return;\n+\n+  stat[StatShadowNonZero] = stat[StatShadowProcessed] - stat[StatShadowZero];\n+\n+  static const char *name[StatCnt] = {};\n+  name[StatMop]                          = \"Memory accesses                   \";\n+  name[StatMopRead]                      = \"  Including reads                 \";\n+  name[StatMopWrite]                     = \"            writes                \";\n+  name[StatMop1]                         = \"  Including size 1                \";\n+  name[StatMop2]                         = \"            size 2                \";\n+  name[StatMop4]                         = \"            size 4                \";\n+  name[StatMop8]                         = \"            size 8                \";\n+  name[StatMopSame]                      = \"  Including same                  \";\n+  name[StatMopRange]                     = \"  Including range                 \";\n+  name[StatShadowProcessed]              = \"Shadow processed                  \";\n+  name[StatShadowZero]                   = \"  Including empty                 \";\n+  name[StatShadowNonZero]                = \"  Including non empty             \";\n+  name[StatShadowSameSize]               = \"  Including same size             \";\n+  name[StatShadowIntersect]              = \"            intersect             \";\n+  name[StatShadowNotIntersect]           = \"            not intersect         \";\n+  name[StatShadowSameThread]             = \"  Including same thread           \";\n+  name[StatShadowAnotherThread]          = \"            another thread        \";\n+  name[StatShadowReplace]                = \"  Including evicted               \";\n+\n+  name[StatFuncEnter]                    = \"Function entries                  \";\n+  name[StatFuncExit]                     = \"Function exits                    \";\n+  name[StatEvents]                       = \"Events collected                  \";\n+\n+  name[StatThreadCreate]                 = \"Total threads created             \";\n+  name[StatThreadFinish]                 = \"  threads finished                \";\n+  name[StatThreadReuse]                  = \"  threads reused                  \";\n+  name[StatThreadMaxTid]                 = \"  max tid                         \";\n+  name[StatThreadMaxAlive]               = \"  max alive threads               \";\n+\n+  name[StatMutexCreate]                  = \"Mutexes created                   \";\n+  name[StatMutexDestroy]                 = \"  destroyed                       \";\n+  name[StatMutexLock]                    = \"  lock                            \";\n+  name[StatMutexUnlock]                  = \"  unlock                          \";\n+  name[StatMutexRecLock]                 = \"  recursive lock                  \";\n+  name[StatMutexRecUnlock]               = \"  recursive unlock                \";\n+  name[StatMutexReadLock]                = \"  read lock                       \";\n+  name[StatMutexReadUnlock]              = \"  read unlock                     \";\n+\n+  name[StatSyncCreated]                  = \"Sync objects created              \";\n+  name[StatSyncDestroyed]                = \"             destroyed            \";\n+  name[StatSyncAcquire]                  = \"             acquired             \";\n+  name[StatSyncRelease]                  = \"             released             \";\n+\n+  name[StatAtomic]                       = \"Atomic operations                 \";\n+  name[StatAtomicLoad]                   = \"  Including load                  \";\n+  name[StatAtomicStore]                  = \"            store                 \";\n+  name[StatAtomicExchange]               = \"            exchange              \";\n+  name[StatAtomicFetchAdd]               = \"            fetch_add             \";\n+  name[StatAtomicCAS]                    = \"            compare_exchange      \";\n+  name[StatAtomicFence]                  = \"            fence                 \";\n+  name[StatAtomicRelaxed]                = \"  Including relaxed               \";\n+  name[StatAtomicConsume]                = \"            consume               \";\n+  name[StatAtomicAcquire]                = \"            acquire               \";\n+  name[StatAtomicRelease]                = \"            release               \";\n+  name[StatAtomicAcq_Rel]                = \"            acq_rel               \";\n+  name[StatAtomicSeq_Cst]                = \"            seq_cst               \";\n+  name[StatAtomic1]                      = \"  Including size 1                \";\n+  name[StatAtomic2]                      = \"            size 2                \";\n+  name[StatAtomic4]                      = \"            size 4                \";\n+  name[StatAtomic8]                      = \"            size 8                \";\n+\n+  name[StatInterceptor]                  = \"Interceptors                      \";\n+  name[StatInt_longjmp]                  = \"  longjmp                         \";\n+  name[StatInt_siglongjmp]               = \"  siglongjmp                      \";\n+  name[StatInt_malloc]                   = \"  malloc                          \";\n+  name[StatInt_calloc]                   = \"  calloc                          \";\n+  name[StatInt_realloc]                  = \"  realloc                         \";\n+  name[StatInt_free]                     = \"  free                            \";\n+  name[StatInt_cfree]                    = \"  cfree                           \";\n+  name[StatInt_mmap]                     = \"  mmap                            \";\n+  name[StatInt_mmap64]                   = \"  mmap64                          \";\n+  name[StatInt_munmap]                   = \"  munmap                          \";\n+  name[StatInt_memalign]                 = \"  memalign                        \";\n+  name[StatInt_valloc]                   = \"  valloc                          \";\n+  name[StatInt_pvalloc]                  = \"  pvalloc                         \";\n+  name[StatInt_posix_memalign]           = \"  posix_memalign                  \";\n+  name[StatInt__Znwm]                    = \"  _Znwm                           \";\n+  name[StatInt__ZnwmRKSt9nothrow_t]      = \"  _ZnwmRKSt9nothrow_t             \";\n+  name[StatInt__Znam]                    = \"  _Znam                           \";\n+  name[StatInt__ZnamRKSt9nothrow_t]      = \"  _ZnamRKSt9nothrow_t             \";\n+  name[StatInt__ZdlPv]                   = \"  _ZdlPv                          \";\n+  name[StatInt__ZdlPvRKSt9nothrow_t]     = \"  _ZdlPvRKSt9nothrow_t            \";\n+  name[StatInt__ZdaPv]                   = \"  _ZdaPv                          \";\n+  name[StatInt__ZdaPvRKSt9nothrow_t]     = \"  _ZdaPvRKSt9nothrow_t            \";\n+  name[StatInt_strlen]                   = \"  strlen                          \";\n+  name[StatInt_memset]                   = \"  memset                          \";\n+  name[StatInt_memcpy]                   = \"  memcpy                          \";\n+  name[StatInt_strcmp]                   = \"  strcmp                          \";\n+  name[StatInt_memchr]                   = \"  memchr                          \";\n+  name[StatInt_memrchr]                  = \"  memrchr                         \";\n+  name[StatInt_memmove]                  = \"  memmove                         \";\n+  name[StatInt_memcmp]                   = \"  memcmp                          \";\n+  name[StatInt_strchr]                   = \"  strchr                          \";\n+  name[StatInt_strchrnul]                = \"  strchrnul                       \";\n+  name[StatInt_strrchr]                  = \"  strrchr                         \";\n+  name[StatInt_strncmp]                  = \"  strncmp                         \";\n+  name[StatInt_strcpy]                   = \"  strcpy                          \";\n+  name[StatInt_strncpy]                  = \"  strncpy                         \";\n+  name[StatInt_strstr]                   = \"  strstr                          \";\n+  name[StatInt_atexit]                   = \"  atexit                          \";\n+  name[StatInt___cxa_guard_acquire]      = \"  __cxa_guard_acquire             \";\n+  name[StatInt___cxa_guard_release]      = \"  __cxa_guard_release             \";\n+  name[StatInt_pthread_create]           = \"  pthread_create                  \";\n+  name[StatInt_pthread_join]             = \"  pthread_join                    \";\n+  name[StatInt_pthread_detach]           = \"  pthread_detach                  \";\n+  name[StatInt_pthread_mutex_init]       = \"  pthread_mutex_init              \";\n+  name[StatInt_pthread_mutex_destroy]    = \"  pthread_mutex_destroy           \";\n+  name[StatInt_pthread_mutex_lock]       = \"  pthread_mutex_lock              \";\n+  name[StatInt_pthread_mutex_trylock]    = \"  pthread_mutex_trylock           \";\n+  name[StatInt_pthread_mutex_timedlock]  = \"  pthread_mutex_timedlock         \";\n+  name[StatInt_pthread_mutex_unlock]     = \"  pthread_mutex_unlock            \";\n+  name[StatInt_pthread_spin_init]        = \"  pthread_spin_init               \";\n+  name[StatInt_pthread_spin_destroy]     = \"  pthread_spin_destroy            \";\n+  name[StatInt_pthread_spin_lock]        = \"  pthread_spin_lock               \";\n+  name[StatInt_pthread_spin_trylock]     = \"  pthread_spin_trylock            \";\n+  name[StatInt_pthread_spin_unlock]      = \"  pthread_spin_unlock             \";\n+  name[StatInt_pthread_rwlock_init]      = \"  pthread_rwlock_init             \";\n+  name[StatInt_pthread_rwlock_destroy]   = \"  pthread_rwlock_destroy          \";\n+  name[StatInt_pthread_rwlock_rdlock]    = \"  pthread_rwlock_rdlock           \";\n+  name[StatInt_pthread_rwlock_tryrdlock] = \"  pthread_rwlock_tryrdlock        \";\n+  name[StatInt_pthread_rwlock_timedrdlock]\n+                                         = \"  pthread_rwlock_timedrdlock      \";\n+  name[StatInt_pthread_rwlock_wrlock]    = \"  pthread_rwlock_wrlock           \";\n+  name[StatInt_pthread_rwlock_trywrlock] = \"  pthread_rwlock_trywrlock        \";\n+  name[StatInt_pthread_rwlock_timedwrlock]\n+                                         = \"  pthread_rwlock_timedwrlock      \";\n+  name[StatInt_pthread_rwlock_unlock]    = \"  pthread_rwlock_unlock           \";\n+  name[StatInt_pthread_cond_init]        = \"  pthread_cond_init               \";\n+  name[StatInt_pthread_cond_destroy]     = \"  pthread_cond_destroy            \";\n+  name[StatInt_pthread_cond_signal]      = \"  pthread_cond_signal             \";\n+  name[StatInt_pthread_cond_broadcast]   = \"  pthread_cond_broadcast          \";\n+  name[StatInt_pthread_cond_wait]        = \"  pthread_cond_wait               \";\n+  name[StatInt_pthread_cond_timedwait]   = \"  pthread_cond_timedwait          \";\n+  name[StatInt_pthread_barrier_init]     = \"  pthread_barrier_init            \";\n+  name[StatInt_pthread_barrier_destroy]  = \"  pthread_barrier_destroy         \";\n+  name[StatInt_pthread_barrier_wait]     = \"  pthread_barrier_wait            \";\n+  name[StatInt_pthread_once]             = \"  pthread_once                    \";\n+  name[StatInt_sem_init]                 = \"  sem_init                        \";\n+  name[StatInt_sem_destroy]              = \"  sem_destroy                     \";\n+  name[StatInt_sem_wait]                 = \"  sem_wait                        \";\n+  name[StatInt_sem_trywait]              = \"  sem_trywait                     \";\n+  name[StatInt_sem_timedwait]            = \"  sem_timedwait                   \";\n+  name[StatInt_sem_post]                 = \"  sem_post                        \";\n+  name[StatInt_sem_getvalue]             = \"  sem_getvalue                    \";\n+  name[StatInt_read]                     = \"  read                            \";\n+  name[StatInt_pread]                    = \"  pread                           \";\n+  name[StatInt_pread64]                  = \"  pread64                         \";\n+  name[StatInt_readv]                    = \"  readv                           \";\n+  name[StatInt_preadv64]                 = \"  preadv64                        \";\n+  name[StatInt_write]                    = \"  write                           \";\n+  name[StatInt_pwrite]                   = \"  pwrite                          \";\n+  name[StatInt_pwrite64]                 = \"  pwrite64                        \";\n+  name[StatInt_writev]                   = \"  writev                          \";\n+  name[StatInt_pwritev64]                = \"  pwritev64                       \";\n+  name[StatInt_send]                     = \"  send                            \";\n+  name[StatInt_sendmsg]                  = \"  sendmsg                         \";\n+  name[StatInt_recv]                     = \"  recv                            \";\n+  name[StatInt_recvmsg]                  = \"  recvmsg                         \";\n+  name[StatInt_unlink]                   = \"  unlink                          \";\n+  name[StatInt_fopen]                    = \"  fopen                           \";\n+  name[StatInt_fread]                    = \"  fread                           \";\n+  name[StatInt_fwrite]                   = \"  fwrite                          \";\n+  name[StatInt_puts]                     = \"  puts                            \";\n+  name[StatInt_rmdir]                    = \"  rmdir                           \";\n+  name[StatInt_opendir]                  = \"  opendir                         \";\n+  name[StatInt_epoll_ctl]                = \"  epoll_ctl                       \";\n+  name[StatInt_epoll_wait]               = \"  epoll_wait                      \";\n+  name[StatInt_sigaction]                = \"  sigaction                       \";\n+\n+  name[StatAnnotation]                   = \"Dynamic annotations               \";\n+  name[StatAnnotateHappensBefore]        = \"  HappensBefore                   \";\n+  name[StatAnnotateHappensAfter]         = \"  HappensAfter                    \";\n+  name[StatAnnotateCondVarSignal]        = \"  CondVarSignal                   \";\n+  name[StatAnnotateCondVarSignalAll]     = \"  CondVarSignalAll                \";\n+  name[StatAnnotateMutexIsNotPHB]        = \"  MutexIsNotPHB                   \";\n+  name[StatAnnotateCondVarWait]          = \"  CondVarWait                     \";\n+  name[StatAnnotateRWLockCreate]         = \"  RWLockCreate                    \";\n+  name[StatAnnotateRWLockDestroy]        = \"  RWLockDestroy                   \";\n+  name[StatAnnotateRWLockAcquired]       = \"  RWLockAcquired                  \";\n+  name[StatAnnotateRWLockReleased]       = \"  RWLockReleased                  \";\n+  name[StatAnnotateTraceMemory]          = \"  TraceMemory                     \";\n+  name[StatAnnotateFlushState]           = \"  FlushState                      \";\n+  name[StatAnnotateNewMemory]            = \"  NewMemory                       \";\n+  name[StatAnnotateNoOp]                 = \"  NoOp                            \";\n+  name[StatAnnotateFlushExpectedRaces]   = \"  FlushExpectedRaces              \";\n+  name[StatAnnotateEnableRaceDetection]  = \"  EnableRaceDetection             \";\n+  name[StatAnnotateMutexIsUsedAsCondVar] = \"  MutexIsUsedAsCondVar            \";\n+  name[StatAnnotatePCQGet]               = \"  PCQGet                          \";\n+  name[StatAnnotatePCQPut]               = \"  PCQPut                          \";\n+  name[StatAnnotatePCQDestroy]           = \"  PCQDestroy                      \";\n+  name[StatAnnotatePCQCreate]            = \"  PCQCreate                       \";\n+  name[StatAnnotateExpectRace]           = \"  ExpectRace                      \";\n+  name[StatAnnotateBenignRaceSized]      = \"  BenignRaceSized                 \";\n+  name[StatAnnotateBenignRace]           = \"  BenignRace                      \";\n+  name[StatAnnotateIgnoreReadsBegin]     = \"  IgnoreReadsBegin                \";\n+  name[StatAnnotateIgnoreReadsEnd]       = \"  IgnoreReadsEnd                  \";\n+  name[StatAnnotateIgnoreWritesBegin]    = \"  IgnoreWritesBegin               \";\n+  name[StatAnnotateIgnoreWritesEnd]      = \"  IgnoreWritesEnd                 \";\n+  name[StatAnnotatePublishMemoryRange]   = \"  PublishMemoryRange              \";\n+  name[StatAnnotateUnpublishMemoryRange] = \"  UnpublishMemoryRange            \";\n+  name[StatAnnotateThreadName]           = \"  ThreadName                      \";\n+\n+  name[StatMtxTotal]                     = \"Contentionz                       \";\n+  name[StatMtxTrace]                     = \"  Trace                           \";\n+  name[StatMtxThreads]                   = \"  Threads                         \";\n+  name[StatMtxReport]                    = \"  Report                          \";\n+  name[StatMtxSyncVar]                   = \"  SyncVar                         \";\n+  name[StatMtxSyncTab]                   = \"  SyncTab                         \";\n+  name[StatMtxSlab]                      = \"  Slab                            \";\n+  name[StatMtxAtExit]                    = \"  Atexit                          \";\n+  name[StatMtxAnnotations]               = \"  Annotations                     \";\n+\n+  TsanPrintf(\"Statistics:\\n\");\n+  for (int i = 0; i < StatCnt; i++)\n+    TsanPrintf(\"%s: %zu\\n\", name[i], (uptr)stat[i]);\n+}\n+\n+}  // namespace __tsan"}, {"sha": "b194343a08a944f6a588c5501b9d1eb2e69ff1d5", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,257 @@\n+//===-- tsan_stat.h ---------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef TSAN_STAT_H\n+#define TSAN_STAT_H\n+\n+namespace __tsan {\n+\n+enum StatType {\n+  // Memory access processing related stuff.\n+  StatMop,\n+  StatMopRead,\n+  StatMopWrite,\n+  StatMop1,  // These must be consequtive.\n+  StatMop2,\n+  StatMop4,\n+  StatMop8,\n+  StatMopSame,\n+  StatMopRange,\n+  StatShadowProcessed,\n+  StatShadowZero,\n+  StatShadowNonZero,  // Derived.\n+  StatShadowSameSize,\n+  StatShadowIntersect,\n+  StatShadowNotIntersect,\n+  StatShadowSameThread,\n+  StatShadowAnotherThread,\n+  StatShadowReplace,\n+\n+  // Func processing.\n+  StatFuncEnter,\n+  StatFuncExit,\n+\n+  // Trace processing.\n+  StatEvents,\n+\n+  // Threads.\n+  StatThreadCreate,\n+  StatThreadFinish,\n+  StatThreadReuse,\n+  StatThreadMaxTid,\n+  StatThreadMaxAlive,\n+\n+  // Mutexes.\n+  StatMutexCreate,\n+  StatMutexDestroy,\n+  StatMutexLock,\n+  StatMutexUnlock,\n+  StatMutexRecLock,\n+  StatMutexRecUnlock,\n+  StatMutexReadLock,\n+  StatMutexReadUnlock,\n+\n+  // Synchronization.\n+  StatSyncCreated,\n+  StatSyncDestroyed,\n+  StatSyncAcquire,\n+  StatSyncRelease,\n+\n+  // Atomics.\n+  StatAtomic,\n+  StatAtomicLoad,\n+  StatAtomicStore,\n+  StatAtomicExchange,\n+  StatAtomicFetchAdd,\n+  StatAtomicFetchSub,\n+  StatAtomicFetchAnd,\n+  StatAtomicFetchOr,\n+  StatAtomicFetchXor,\n+  StatAtomicCAS,\n+  StatAtomicFence,\n+  StatAtomicRelaxed,\n+  StatAtomicConsume,\n+  StatAtomicAcquire,\n+  StatAtomicRelease,\n+  StatAtomicAcq_Rel,\n+  StatAtomicSeq_Cst,\n+  StatAtomic1,\n+  StatAtomic2,\n+  StatAtomic4,\n+  StatAtomic8,\n+\n+  // Interceptors.\n+  StatInterceptor,\n+  StatInt_longjmp,\n+  StatInt_siglongjmp,\n+  StatInt_malloc,\n+  StatInt_calloc,\n+  StatInt_realloc,\n+  StatInt_free,\n+  StatInt_cfree,\n+  StatInt_mmap,\n+  StatInt_mmap64,\n+  StatInt_munmap,\n+  StatInt_memalign,\n+  StatInt_valloc,\n+  StatInt_pvalloc,\n+  StatInt_posix_memalign,\n+  StatInt__Znwm,\n+  StatInt__ZnwmRKSt9nothrow_t,\n+  StatInt__Znam,\n+  StatInt__ZnamRKSt9nothrow_t,\n+  StatInt__ZdlPv,\n+  StatInt__ZdlPvRKSt9nothrow_t,\n+  StatInt__ZdaPv,\n+  StatInt__ZdaPvRKSt9nothrow_t,\n+  StatInt_strlen,\n+  StatInt_memset,\n+  StatInt_memcpy,\n+  StatInt_strcmp,\n+  StatInt_memchr,\n+  StatInt_memrchr,\n+  StatInt_memmove,\n+  StatInt_memcmp,\n+  StatInt_strchr,\n+  StatInt_strchrnul,\n+  StatInt_strrchr,\n+  StatInt_strncmp,\n+  StatInt_strcpy,\n+  StatInt_strncpy,\n+  StatInt_strstr,\n+  StatInt_atexit,\n+  StatInt___cxa_guard_acquire,\n+  StatInt___cxa_guard_release,\n+  StatInt_pthread_create,\n+  StatInt_pthread_join,\n+  StatInt_pthread_detach,\n+  StatInt_pthread_mutex_init,\n+  StatInt_pthread_mutex_destroy,\n+  StatInt_pthread_mutex_lock,\n+  StatInt_pthread_mutex_trylock,\n+  StatInt_pthread_mutex_timedlock,\n+  StatInt_pthread_mutex_unlock,\n+  StatInt_pthread_spin_init,\n+  StatInt_pthread_spin_destroy,\n+  StatInt_pthread_spin_lock,\n+  StatInt_pthread_spin_trylock,\n+  StatInt_pthread_spin_unlock,\n+  StatInt_pthread_rwlock_init,\n+  StatInt_pthread_rwlock_destroy,\n+  StatInt_pthread_rwlock_rdlock,\n+  StatInt_pthread_rwlock_tryrdlock,\n+  StatInt_pthread_rwlock_timedrdlock,\n+  StatInt_pthread_rwlock_wrlock,\n+  StatInt_pthread_rwlock_trywrlock,\n+  StatInt_pthread_rwlock_timedwrlock,\n+  StatInt_pthread_rwlock_unlock,\n+  StatInt_pthread_cond_init,\n+  StatInt_pthread_cond_destroy,\n+  StatInt_pthread_cond_signal,\n+  StatInt_pthread_cond_broadcast,\n+  StatInt_pthread_cond_wait,\n+  StatInt_pthread_cond_timedwait,\n+  StatInt_pthread_barrier_init,\n+  StatInt_pthread_barrier_destroy,\n+  StatInt_pthread_barrier_wait,\n+  StatInt_pthread_once,\n+  StatInt_sem_init,\n+  StatInt_sem_destroy,\n+  StatInt_sem_wait,\n+  StatInt_sem_trywait,\n+  StatInt_sem_timedwait,\n+  StatInt_sem_post,\n+  StatInt_sem_getvalue,\n+  StatInt_read,\n+  StatInt_pread,\n+  StatInt_pread64,\n+  StatInt_readv,\n+  StatInt_preadv64,\n+  StatInt_write,\n+  StatInt_pwrite,\n+  StatInt_pwrite64,\n+  StatInt_writev,\n+  StatInt_pwritev64,\n+  StatInt_send,\n+  StatInt_sendmsg,\n+  StatInt_recv,\n+  StatInt_recvmsg,\n+  StatInt_unlink,\n+  StatInt_fopen,\n+  StatInt_fread,\n+  StatInt_fwrite,\n+  StatInt_puts,\n+  StatInt_rmdir,\n+  StatInt_opendir,\n+  StatInt_epoll_ctl,\n+  StatInt_epoll_wait,\n+  StatInt_sigaction,\n+  StatInt_signal,\n+  StatInt_raise,\n+  StatInt_kill,\n+  StatInt_pthread_kill,\n+  StatInt_sleep,\n+  StatInt_usleep,\n+  StatInt_nanosleep,\n+\n+  // Dynamic annotations.\n+  StatAnnotation,\n+  StatAnnotateHappensBefore,\n+  StatAnnotateHappensAfter,\n+  StatAnnotateCondVarSignal,\n+  StatAnnotateCondVarSignalAll,\n+  StatAnnotateMutexIsNotPHB,\n+  StatAnnotateCondVarWait,\n+  StatAnnotateRWLockCreate,\n+  StatAnnotateRWLockCreateStatic,\n+  StatAnnotateRWLockDestroy,\n+  StatAnnotateRWLockAcquired,\n+  StatAnnotateRWLockReleased,\n+  StatAnnotateTraceMemory,\n+  StatAnnotateFlushState,\n+  StatAnnotateNewMemory,\n+  StatAnnotateNoOp,\n+  StatAnnotateFlushExpectedRaces,\n+  StatAnnotateEnableRaceDetection,\n+  StatAnnotateMutexIsUsedAsCondVar,\n+  StatAnnotatePCQGet,\n+  StatAnnotatePCQPut,\n+  StatAnnotatePCQDestroy,\n+  StatAnnotatePCQCreate,\n+  StatAnnotateExpectRace,\n+  StatAnnotateBenignRaceSized,\n+  StatAnnotateBenignRace,\n+  StatAnnotateIgnoreReadsBegin,\n+  StatAnnotateIgnoreReadsEnd,\n+  StatAnnotateIgnoreWritesBegin,\n+  StatAnnotateIgnoreWritesEnd,\n+  StatAnnotatePublishMemoryRange,\n+  StatAnnotateUnpublishMemoryRange,\n+  StatAnnotateThreadName,\n+\n+  // Internal mutex contentionz.\n+  StatMtxTotal,\n+  StatMtxTrace,\n+  StatMtxThreads,\n+  StatMtxReport,\n+  StatMtxSyncVar,\n+  StatMtxSyncTab,\n+  StatMtxSlab,\n+  StatMtxAnnotations,\n+  StatMtxAtExit,\n+\n+  // This must be the last.\n+  StatCnt\n+};\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_STAT_H"}, {"sha": "9b087add3c26a5c5a07ad05f16e9037034cb1afc", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,161 @@\n+//===-- tsan_suppressions.cc ----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"tsan_suppressions.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_flags.h\"\n+#include \"tsan_mman.h\"\n+#include \"tsan_platform.h\"\n+\n+namespace __tsan {\n+\n+static Suppression *g_suppressions;\n+\n+static char *ReadFile(const char *filename) {\n+  if (filename == 0 || filename[0] == 0)\n+    return 0;\n+  InternalScopedBuffer<char> tmp(4*1024);\n+  if (filename[0] == '/')\n+    internal_snprintf(tmp.data(), tmp.size(), \"%s\", filename);\n+  else\n+    internal_snprintf(tmp.data(), tmp.size(), \"%s/%s\", GetPwd(), filename);\n+  fd_t fd = internal_open(tmp.data(), false);\n+  if (fd == kInvalidFd) {\n+    TsanPrintf(\"ThreadSanitizer: failed to open suppressions file '%s'\\n\",\n+               tmp.data());\n+    Die();\n+  }\n+  const uptr fsize = internal_filesize(fd);\n+  if (fsize == (uptr)-1) {\n+    TsanPrintf(\"ThreadSanitizer: failed to stat suppressions file '%s'\\n\",\n+               tmp.data());\n+    Die();\n+  }\n+  char *buf = (char*)internal_alloc(MBlockSuppression, fsize + 1);\n+  if (fsize != internal_read(fd, buf, fsize)) {\n+    TsanPrintf(\"ThreadSanitizer: failed to read suppressions file '%s'\\n\",\n+               tmp.data());\n+    Die();\n+  }\n+  internal_close(fd);\n+  buf[fsize] = 0;\n+  return buf;\n+}\n+\n+bool SuppressionMatch(char *templ, const char *str) {\n+  if (str == 0 || str[0] == 0)\n+    return false;\n+  char *tpos;\n+  const char *spos;\n+  while (templ && templ[0]) {\n+    if (templ[0] == '*') {\n+      templ++;\n+      continue;\n+    }\n+    if (str[0] == 0)\n+      return false;\n+    tpos = (char*)internal_strchr(templ, '*');\n+    if (tpos != 0)\n+      tpos[0] = 0;\n+    spos = internal_strstr(str, templ);\n+    str = spos + internal_strlen(templ);\n+    templ = tpos;\n+    if (tpos)\n+      tpos[0] = '*';\n+    if (spos == 0)\n+      return false;\n+  }\n+  return true;\n+}\n+\n+Suppression *SuppressionParse(const char* supp) {\n+  Suppression *head = 0;\n+  const char *line = supp;\n+  while (line) {\n+    while (line[0] == ' ' || line[0] == '\\t')\n+      line++;\n+    const char *end = internal_strchr(line, '\\n');\n+    if (end == 0)\n+      end = line + internal_strlen(line);\n+    if (line != end && line[0] != '#') {\n+      const char *end2 = end;\n+      while (line != end2 && (end2[-1] == ' ' || end2[-1] == '\\t'))\n+        end2--;\n+      SuppressionType stype;\n+      if (0 == internal_strncmp(line, \"race:\", sizeof(\"race:\") - 1)) {\n+        stype = SuppressionRace;\n+        line += sizeof(\"race:\") - 1;\n+      } else if (0 == internal_strncmp(line, \"thread:\",\n+          sizeof(\"thread:\") - 1)) {\n+        stype = SuppressionThread;\n+        line += sizeof(\"thread:\") - 1;\n+      } else if (0 == internal_strncmp(line, \"mutex:\",\n+          sizeof(\"mutex:\") - 1)) {\n+        stype = SuppressionMutex;\n+        line += sizeof(\"mutex:\") - 1;\n+      } else if (0 == internal_strncmp(line, \"signal:\",\n+          sizeof(\"signal:\") - 1)) {\n+        stype = SuppressionSignal;\n+        line += sizeof(\"signal:\") - 1;\n+      } else {\n+        TsanPrintf(\"ThreadSanitizer: failed to parse suppressions file\\n\");\n+        Die();\n+      }\n+      Suppression *s = (Suppression*)internal_alloc(MBlockSuppression,\n+          sizeof(Suppression));\n+      s->next = head;\n+      head = s;\n+      s->type = stype;\n+      s->templ = (char*)internal_alloc(MBlockSuppression, end2 - line + 1);\n+      internal_memcpy(s->templ, line, end2 - line);\n+      s->templ[end2 - line] = 0;\n+    }\n+    if (end[0] == 0)\n+      break;\n+    line = end + 1;\n+  }\n+  return head;\n+}\n+\n+void InitializeSuppressions() {\n+  char *supp = ReadFile(flags()->suppressions);\n+  g_suppressions = SuppressionParse(supp);\n+}\n+\n+uptr IsSuppressed(ReportType typ, const ReportStack *stack) {\n+  if (g_suppressions == 0 || stack == 0)\n+    return 0;\n+  SuppressionType stype;\n+  if (typ == ReportTypeRace)\n+    stype = SuppressionRace;\n+  else if (typ == ReportTypeThreadLeak)\n+    stype = SuppressionThread;\n+  else if (typ == ReportTypeMutexDestroyLocked)\n+    stype = SuppressionMutex;\n+  else if (typ == ReportTypeSignalUnsafe)\n+    stype = SuppressionSignal;\n+  else\n+    return 0;\n+  for (const ReportStack *frame = stack; frame; frame = frame->next) {\n+    for (Suppression *supp = g_suppressions; supp; supp = supp->next) {\n+      if (stype == supp->type &&\n+          (SuppressionMatch(supp->templ, frame->func) ||\n+          SuppressionMatch(supp->templ, frame->file))) {\n+        DPrintf(\"ThreadSanitizer: matched suppression '%s'\\n\", supp->templ);\n+        return frame->pc;\n+      }\n+    }\n+  }\n+  return 0;\n+}\n+}  // namespace __tsan"}, {"sha": "4761eaa0cee88ce6406e9f5c793940c3f338dfe7", "filename": "libsanitizer/tsan/tsan_suppressions.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,41 @@\n+//===-- tsan_suppressions.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_SUPPRESSIONS_H\n+#define TSAN_SUPPRESSIONS_H\n+\n+#include \"tsan_report.h\"\n+\n+namespace __tsan {\n+\n+void InitializeSuppressions();\n+void FinalizeSuppressions();\n+uptr IsSuppressed(ReportType typ, const ReportStack *stack);\n+\n+// Exposed for testing.\n+enum SuppressionType {\n+  SuppressionRace,\n+  SuppressionMutex,\n+  SuppressionThread,\n+  SuppressionSignal\n+};\n+\n+struct Suppression {\n+  Suppression *next;\n+  SuppressionType type;\n+  char *templ;\n+};\n+\n+Suppression *SuppressionParse(const char* supp);\n+bool SuppressionMatch(char *templ, const char *str);\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_SUPPRESSIONS_H"}, {"sha": "439b8824c6ad5f69590c6a705654c90ccd5a1956", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,83 @@\n+//===-- tsan_symbolize.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"tsan_symbolize.h\"\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n+#include \"tsan_flags.h\"\n+#include \"tsan_report.h\"\n+\n+namespace __tsan {\n+\n+ReportStack *NewReportStackEntry(uptr addr) {\n+  ReportStack *ent = (ReportStack*)internal_alloc(MBlockReportStack,\n+                                                  sizeof(ReportStack));\n+  internal_memset(ent, 0, sizeof(*ent));\n+  ent->pc = addr;\n+  return ent;\n+}\n+\n+static ReportStack *NewReportStackEntry(const AddressInfo &info) {\n+  ReportStack *ent = NewReportStackEntry(info.address);\n+  if (info.module) {\n+    // Strip module path to make output shorter.\n+    const char *short_module_name = internal_strrchr(info.module, '/');\n+    if (short_module_name)\n+      short_module_name += 1;\n+    else\n+      short_module_name = info.module;\n+    ent->module = internal_strdup(short_module_name);\n+  }\n+  ent->offset = info.module_offset;\n+  if (info.function) {\n+    ent->func = internal_strdup(info.function);\n+  }\n+  if (info.file)\n+    ent->file = internal_strdup(info.file);\n+  ent->line = info.line;\n+  ent->col = info.column;\n+  return ent;\n+}\n+\n+ReportStack *SymbolizeCode(uptr addr) {\n+  if (0 != internal_strcmp(flags()->external_symbolizer_path, \"\")) {\n+    static const uptr kMaxAddrFrames = 16;\n+    InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n+    for (uptr i = 0; i < kMaxAddrFrames; i++)\n+      new(&addr_frames[i]) AddressInfo();\n+    uptr addr_frames_num = __sanitizer::SymbolizeCode(addr, addr_frames.data(),\n+                                                      kMaxAddrFrames);\n+    if (addr_frames_num == 0)\n+      return NewReportStackEntry(addr);\n+    ReportStack *top = 0;\n+    ReportStack *bottom = 0;\n+    for (uptr i = 0; i < addr_frames_num; i++) {\n+      ReportStack *cur_entry = NewReportStackEntry(addr_frames[i]);\n+      CHECK(cur_entry);\n+      addr_frames[i].Clear();\n+      if (i == 0)\n+        top = cur_entry;\n+      else\n+        bottom->next = cur_entry;\n+      bottom = cur_entry;\n+    }\n+    return top;\n+  }\n+  return SymbolizeCodeAddr2Line(addr);\n+}\n+\n+ReportStack *SymbolizeData(uptr addr) {\n+  return SymbolizeDataAddr2Line(addr);\n+}\n+\n+}  // namespace __tsan"}, {"sha": "6ac19ca5ccc94885683357ed6eb2624f6cb90d4d", "filename": "libsanitizer/tsan/tsan_symbolize.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,29 @@\n+//===-- tsan_symbolize.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_SYMBOLIZE_H\n+#define TSAN_SYMBOLIZE_H\n+\n+#include \"tsan_defs.h\"\n+#include \"tsan_report.h\"\n+\n+namespace __tsan {\n+\n+ReportStack *SymbolizeCode(uptr addr);\n+ReportStack *SymbolizeData(uptr addr);\n+\n+ReportStack *SymbolizeCodeAddr2Line(uptr addr);\n+ReportStack *SymbolizeDataAddr2Line(uptr addr);\n+\n+ReportStack *NewReportStackEntry(uptr addr);\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_SYMBOLIZE_H"}, {"sha": "9caf091fecf82aa48cf327adf44992bcdd10a9e8", "filename": "libsanitizer/tsan/tsan_symbolize_addr2line_linux.cc", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,191 @@\n+//===-- tsan_symbolize_addr2line.cc ---------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"tsan_symbolize.h\"\n+#include \"tsan_mman.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_platform.h\"\n+\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <link.h>\n+#include <linux/limits.h>\n+#include <sys/types.h>\n+\n+namespace __tsan {\n+\n+struct ModuleDesc {\n+  const char *fullname;\n+  const char *name;\n+  uptr base;\n+  int inp_fd;\n+  int out_fd;\n+};\n+\n+struct SectionDesc {\n+  SectionDesc *next;\n+  ModuleDesc *module;\n+  uptr base;\n+  uptr end;\n+};\n+\n+struct DlIteratePhdrCtx {\n+  SectionDesc *sections;\n+  bool is_first;\n+};\n+\n+static void NOINLINE InitModule(ModuleDesc *m) {\n+  int outfd[2] = {};\n+  if (pipe(&outfd[0])) {\n+    TsanPrintf(\"ThreadSanitizer: outfd pipe() failed (%d)\\n\", errno);\n+    Die();\n+  }\n+  int infd[2] = {};\n+  if (pipe(&infd[0])) {\n+    TsanPrintf(\"ThreadSanitizer: infd pipe() failed (%d)\\n\", errno);\n+    Die();\n+  }\n+  int pid = fork();\n+  if (pid == 0) {\n+    flags()->log_fileno = STDERR_FILENO;\n+    internal_close(STDOUT_FILENO);\n+    internal_close(STDIN_FILENO);\n+    internal_dup2(outfd[0], STDIN_FILENO);\n+    internal_dup2(infd[1], STDOUT_FILENO);\n+    internal_close(outfd[0]);\n+    internal_close(outfd[1]);\n+    internal_close(infd[0]);\n+    internal_close(infd[1]);\n+    for (int fd = getdtablesize(); fd > 2; fd--)\n+      internal_close(fd);\n+    execl(\"/usr/bin/addr2line\", \"/usr/bin/addr2line\", \"-Cfe\", m->fullname, 0);\n+    _exit(0);\n+  } else if (pid < 0) {\n+    TsanPrintf(\"ThreadSanitizer: failed to fork symbolizer\\n\");\n+    Die();\n+  }\n+  internal_close(outfd[0]);\n+  internal_close(infd[1]);\n+  m->inp_fd = infd[0];\n+  m->out_fd = outfd[1];\n+}\n+\n+static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n+  DlIteratePhdrCtx *ctx = (DlIteratePhdrCtx*)arg;\n+  InternalScopedBuffer<char> tmp(128);\n+  if (ctx->is_first) {\n+    internal_snprintf(tmp.data(), tmp.size(), \"/proc/%d/exe\", GetPid());\n+    info->dlpi_name = tmp.data();\n+  }\n+  ctx->is_first = false;\n+  if (info->dlpi_name == 0 || info->dlpi_name[0] == 0)\n+    return 0;\n+  ModuleDesc *m = (ModuleDesc*)internal_alloc(MBlockReportStack,\n+                                              sizeof(ModuleDesc));\n+  m->fullname = internal_strdup(info->dlpi_name);\n+  m->name = internal_strrchr(m->fullname, '/');\n+  if (m->name)\n+    m->name += 1;\n+  else\n+    m->name = m->fullname;\n+  m->base = (uptr)info->dlpi_addr;\n+  m->inp_fd = -1;\n+  m->out_fd = -1;\n+  DPrintf(\"Module %s %zx\\n\", m->name, m->base);\n+  for (int i = 0; i < info->dlpi_phnum; i++) {\n+    const Elf64_Phdr *s = &info->dlpi_phdr[i];\n+    DPrintf(\"  Section p_type=%zx p_offset=%zx p_vaddr=%zx p_paddr=%zx\"\n+            \" p_filesz=%zx p_memsz=%zx p_flags=%zx p_align=%zx\\n\",\n+            (uptr)s->p_type, (uptr)s->p_offset, (uptr)s->p_vaddr,\n+            (uptr)s->p_paddr, (uptr)s->p_filesz, (uptr)s->p_memsz,\n+            (uptr)s->p_flags, (uptr)s->p_align);\n+    if (s->p_type != PT_LOAD)\n+      continue;\n+    SectionDesc *sec = (SectionDesc*)internal_alloc(MBlockReportStack,\n+                                                    sizeof(SectionDesc));\n+    sec->module = m;\n+    sec->base = info->dlpi_addr + s->p_vaddr;\n+    sec->end = sec->base + s->p_memsz;\n+    sec->next = ctx->sections;\n+    ctx->sections = sec;\n+    DPrintf(\"  Section %zx-%zx\\n\", sec->base, sec->end);\n+  }\n+  return 0;\n+}\n+\n+static SectionDesc *InitSections() {\n+  DlIteratePhdrCtx ctx = {0, true};\n+  dl_iterate_phdr(dl_iterate_phdr_cb, &ctx);\n+  return ctx.sections;\n+}\n+\n+static SectionDesc *GetSectionDesc(uptr addr) {\n+  static SectionDesc *sections = 0;\n+  if (sections == 0)\n+    sections = InitSections();\n+  for (SectionDesc *s = sections; s; s = s->next) {\n+    if (addr >= s->base && addr < s->end) {\n+      if (s->module->inp_fd == -1)\n+        InitModule(s->module);\n+      return s;\n+    }\n+  }\n+  return 0;\n+}\n+\n+ReportStack *SymbolizeCodeAddr2Line(uptr addr) {\n+  SectionDesc *s = GetSectionDesc(addr);\n+  if (s == 0)\n+    return NewReportStackEntry(addr);\n+  ModuleDesc *m = s->module;\n+  uptr offset = addr - m->base;\n+  char addrstr[32];\n+  internal_snprintf(addrstr, sizeof(addrstr), \"%p\\n\", (void*)offset);\n+  if (0 >= internal_write(m->out_fd, addrstr, internal_strlen(addrstr))) {\n+    TsanPrintf(\"ThreadSanitizer: can't write from symbolizer (%d, %d)\\n\",\n+        m->out_fd, errno);\n+    Die();\n+  }\n+  InternalScopedBuffer<char> func(1024);\n+  ssize_t len = internal_read(m->inp_fd, func.data(), func.size() - 1);\n+  if (len <= 0) {\n+    TsanPrintf(\"ThreadSanitizer: can't read from symbolizer (%d, %d)\\n\",\n+        m->inp_fd, errno);\n+    Die();\n+  }\n+  func.data()[len] = 0;\n+  ReportStack *res = NewReportStackEntry(addr);\n+  res->module = internal_strdup(m->name);\n+  res->offset = offset;\n+  char *pos = (char*)internal_strchr(func.data(), '\\n');\n+  if (pos && func[0] != '?') {\n+    res->func = (char*)internal_alloc(MBlockReportStack, pos - func.data() + 1);\n+    internal_memcpy(res->func, func.data(), pos - func.data());\n+    res->func[pos - func.data()] = 0;\n+    char *pos2 = (char*)internal_strchr(pos, ':');\n+    if (pos2) {\n+      res->file = (char*)internal_alloc(MBlockReportStack, pos2 - pos - 1 + 1);\n+      internal_memcpy(res->file, pos + 1, pos2 - pos - 1);\n+      res->file[pos2 - pos - 1] = 0;\n+      res->line = atoi(pos2 + 1);\n+     }\n+  }\n+  return res;\n+}\n+\n+ReportStack *SymbolizeDataAddr2Line(uptr addr) {\n+  return 0;\n+}\n+\n+}  // namespace __tsan"}, {"sha": "3bd1b35f9b3ab76cba6663f1832b9e9090e1c334", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,278 @@\n+//===-- tsan_sync.cc ------------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"tsan_sync.h\"\n+#include \"tsan_rtl.h\"\n+#include \"tsan_mman.h\"\n+\n+namespace __tsan {\n+\n+SyncVar::SyncVar(uptr addr)\n+  : mtx(MutexTypeSyncVar, StatMtxSyncVar)\n+  , addr(addr)\n+  , owner_tid(kInvalidTid)\n+  , last_lock()\n+  , recursion()\n+  , is_rw()\n+  , is_recursive()\n+  , is_broken()\n+  , is_linker_init() {\n+}\n+\n+SyncTab::Part::Part()\n+  : mtx(MutexTypeSyncTab, StatMtxSyncTab)\n+  , val() {\n+}\n+\n+SyncTab::SyncTab() {\n+}\n+\n+SyncTab::~SyncTab() {\n+  for (int i = 0; i < kPartCount; i++) {\n+    while (tab_[i].val) {\n+      SyncVar *tmp = tab_[i].val;\n+      tab_[i].val = tmp->next;\n+      DestroyAndFree(tmp);\n+    }\n+  }\n+}\n+\n+SyncVar* SyncTab::GetAndLock(ThreadState *thr, uptr pc,\n+                             uptr addr, bool write_lock) {\n+#ifndef TSAN_GO\n+  if (PrimaryAllocator::PointerIsMine((void*)addr)) {\n+    MBlock *b = user_mblock(thr, (void*)addr);\n+    Lock l(&b->mtx);\n+    SyncVar *res = 0;\n+    for (res = b->head; res; res = res->next) {\n+      if (res->addr == addr)\n+        break;\n+    }\n+    if (res == 0) {\n+      StatInc(thr, StatSyncCreated);\n+      void *mem = internal_alloc(MBlockSync, sizeof(SyncVar));\n+      res = new(mem) SyncVar(addr);\n+      res->creation_stack.ObtainCurrent(thr, pc);\n+      res->next = b->head;\n+      b->head = res;\n+    }\n+    if (write_lock)\n+      res->mtx.Lock();\n+    else\n+      res->mtx.ReadLock();\n+    return res;\n+  }\n+#endif\n+\n+  Part *p = &tab_[PartIdx(addr)];\n+  {\n+    ReadLock l(&p->mtx);\n+    for (SyncVar *res = p->val; res; res = res->next) {\n+      if (res->addr == addr) {\n+        if (write_lock)\n+          res->mtx.Lock();\n+        else\n+          res->mtx.ReadLock();\n+        return res;\n+      }\n+    }\n+  }\n+  {\n+    Lock l(&p->mtx);\n+    SyncVar *res = p->val;\n+    for (; res; res = res->next) {\n+      if (res->addr == addr)\n+        break;\n+    }\n+    if (res == 0) {\n+      StatInc(thr, StatSyncCreated);\n+      void *mem = internal_alloc(MBlockSync, sizeof(SyncVar));\n+      res = new(mem) SyncVar(addr);\n+#ifndef TSAN_GO\n+      res->creation_stack.ObtainCurrent(thr, pc);\n+#endif\n+      res->next = p->val;\n+      p->val = res;\n+    }\n+    if (write_lock)\n+      res->mtx.Lock();\n+    else\n+      res->mtx.ReadLock();\n+    return res;\n+  }\n+}\n+\n+SyncVar* SyncTab::GetAndRemove(ThreadState *thr, uptr pc, uptr addr) {\n+#ifndef TSAN_GO\n+  if (PrimaryAllocator::PointerIsMine((void*)addr)) {\n+    MBlock *b = user_mblock(thr, (void*)addr);\n+    SyncVar *res = 0;\n+    {\n+      Lock l(&b->mtx);\n+      SyncVar **prev = &b->head;\n+      res = *prev;\n+      while (res) {\n+        if (res->addr == addr) {\n+          if (res->is_linker_init)\n+            return 0;\n+          *prev = res->next;\n+          break;\n+        }\n+        prev = &res->next;\n+        res = *prev;\n+      }\n+    }\n+    if (res) {\n+      StatInc(thr, StatSyncDestroyed);\n+      res->mtx.Lock();\n+      res->mtx.Unlock();\n+    }\n+    return res;\n+  }\n+#endif\n+\n+  Part *p = &tab_[PartIdx(addr)];\n+  SyncVar *res = 0;\n+  {\n+    Lock l(&p->mtx);\n+    SyncVar **prev = &p->val;\n+    res = *prev;\n+    while (res) {\n+      if (res->addr == addr) {\n+        if (res->is_linker_init)\n+          return 0;\n+        *prev = res->next;\n+        break;\n+      }\n+      prev = &res->next;\n+      res = *prev;\n+    }\n+  }\n+  if (res) {\n+    StatInc(thr, StatSyncDestroyed);\n+    res->mtx.Lock();\n+    res->mtx.Unlock();\n+  }\n+  return res;\n+}\n+\n+uptr SyncVar::GetMemoryConsumption() {\n+  return sizeof(*this)\n+      + clock.size() * sizeof(u64)\n+      + read_clock.size() * sizeof(u64)\n+      + creation_stack.Size() * sizeof(uptr);\n+}\n+\n+uptr SyncTab::GetMemoryConsumption(uptr *nsync) {\n+  uptr mem = 0;\n+  for (int i = 0; i < kPartCount; i++) {\n+    Part *p = &tab_[i];\n+    Lock l(&p->mtx);\n+    for (SyncVar *s = p->val; s; s = s->next) {\n+      *nsync += 1;\n+      mem += s->GetMemoryConsumption();\n+    }\n+  }\n+  return mem;\n+}\n+\n+int SyncTab::PartIdx(uptr addr) {\n+  return (addr >> 3) % kPartCount;\n+}\n+\n+StackTrace::StackTrace()\n+    : n_()\n+    , s_()\n+    , c_() {\n+}\n+\n+StackTrace::StackTrace(uptr *buf, uptr cnt)\n+    : n_()\n+    , s_(buf)\n+    , c_(cnt) {\n+  CHECK_NE(buf, 0);\n+  CHECK_NE(cnt, 0);\n+}\n+\n+StackTrace::~StackTrace() {\n+  Reset();\n+}\n+\n+void StackTrace::Reset() {\n+  if (s_ && !c_) {\n+    CHECK_NE(n_, 0);\n+    internal_free(s_);\n+    s_ = 0;\n+  }\n+  n_ = 0;\n+}\n+\n+void StackTrace::Init(const uptr *pcs, uptr cnt) {\n+  Reset();\n+  if (cnt == 0)\n+    return;\n+  if (c_) {\n+    CHECK_NE(s_, 0);\n+    CHECK_LE(cnt, c_);\n+  } else {\n+    s_ = (uptr*)internal_alloc(MBlockStackTrace, cnt * sizeof(s_[0]));\n+  }\n+  n_ = cnt;\n+  internal_memcpy(s_, pcs, cnt * sizeof(s_[0]));\n+}\n+\n+void StackTrace::ObtainCurrent(ThreadState *thr, uptr toppc) {\n+  Reset();\n+  n_ = thr->shadow_stack_pos - thr->shadow_stack;\n+  if (n_ + !!toppc == 0)\n+    return;\n+  uptr start = 0;\n+  if (c_) {\n+    CHECK_NE(s_, 0);\n+    if (n_ + !!toppc > c_) {\n+      start = n_ - c_ + !!toppc;\n+      n_ = c_ - !!toppc;\n+    }\n+  } else {\n+    s_ = (uptr*)internal_alloc(MBlockStackTrace,\n+                               (n_ + !!toppc) * sizeof(s_[0]));\n+  }\n+  for (uptr i = 0; i < n_; i++)\n+    s_[i] = thr->shadow_stack[start + i];\n+  if (toppc) {\n+    s_[n_] = toppc;\n+    n_++;\n+  }\n+}\n+\n+void StackTrace::CopyFrom(const StackTrace& other) {\n+  Reset();\n+  Init(other.Begin(), other.Size());\n+}\n+\n+bool StackTrace::IsEmpty() const {\n+  return n_ == 0;\n+}\n+\n+uptr StackTrace::Size() const {\n+  return n_;\n+}\n+\n+uptr StackTrace::Get(uptr i) const {\n+  CHECK_LT(i, n_);\n+  return s_[i];\n+}\n+\n+const uptr *StackTrace::Begin() const {\n+  return s_;\n+}\n+\n+}  // namespace __tsan"}, {"sha": "2912d2c0ddd467f330c139e4667ab74b98b2b104", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,106 @@\n+//===-- tsan_sync.h ---------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_SYNC_H\n+#define TSAN_SYNC_H\n+\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"tsan_clock.h\"\n+#include \"tsan_defs.h\"\n+#include \"tsan_mutex.h\"\n+\n+namespace __tsan {\n+\n+class SlabCache;\n+\n+class StackTrace {\n+ public:\n+  StackTrace();\n+  // Initialized the object in \"static mode\",\n+  // in this mode it never calls malloc/free but uses the provided buffer.\n+  StackTrace(uptr *buf, uptr cnt);\n+  ~StackTrace();\n+  void Reset();\n+\n+  void Init(const uptr *pcs, uptr cnt);\n+  void ObtainCurrent(ThreadState *thr, uptr toppc);\n+  bool IsEmpty() const;\n+  uptr Size() const;\n+  uptr Get(uptr i) const;\n+  const uptr *Begin() const;\n+  void CopyFrom(const StackTrace& other);\n+\n+ private:\n+  uptr n_;\n+  uptr *s_;\n+  const uptr c_;\n+\n+  StackTrace(const StackTrace&);\n+  void operator = (const StackTrace&);\n+};\n+\n+struct SyncVar {\n+  explicit SyncVar(uptr addr);\n+\n+  static const int kInvalidTid = -1;\n+\n+  Mutex mtx;\n+  const uptr addr;\n+  SyncClock clock;\n+  SyncClock read_clock;  // Used for rw mutexes only.\n+  StackTrace creation_stack;\n+  int owner_tid;  // Set only by exclusive owners.\n+  u64 last_lock;\n+  int recursion;\n+  bool is_rw;\n+  bool is_recursive;\n+  bool is_broken;\n+  bool is_linker_init;\n+  SyncVar *next;  // In SyncTab hashtable.\n+\n+  uptr GetMemoryConsumption();\n+};\n+\n+class SyncTab {\n+ public:\n+  SyncTab();\n+  ~SyncTab();\n+\n+  // If the SyncVar does not exist yet, it is created.\n+  SyncVar* GetAndLock(ThreadState *thr, uptr pc,\n+                      uptr addr, bool write_lock);\n+\n+  // If the SyncVar does not exist, returns 0.\n+  SyncVar* GetAndRemove(ThreadState *thr, uptr pc, uptr addr);\n+\n+  uptr GetMemoryConsumption(uptr *nsync);\n+\n+ private:\n+  struct Part {\n+    Mutex mtx;\n+    SyncVar *val;\n+    char pad[kCacheLineSize - sizeof(Mutex) - sizeof(SyncVar*)];  // NOLINT\n+    Part();\n+  };\n+\n+  // FIXME: Implement something more sane.\n+  static const int kPartCount = 1009;\n+  Part tab_[kPartCount];\n+\n+  int PartIdx(uptr addr);\n+\n+  SyncTab(const SyncTab&);  // Not implemented.\n+  void operator = (const SyncTab&);  // Not implemented.\n+};\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_SYNC_H"}, {"sha": "69233a61bab88a472b36b78a00c5ebc9d46b59d4", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,73 @@\n+//===-- tsan_trace.h --------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_TRACE_H\n+#define TSAN_TRACE_H\n+\n+#include \"tsan_defs.h\"\n+#include \"tsan_mutex.h\"\n+#include \"tsan_sync.h\"\n+\n+namespace __tsan {\n+\n+#ifndef TSAN_HISTORY_SIZE  // in kibitraces\n+#define TSAN_HISTORY_SIZE 128\n+#endif\n+\n+const int kTracePartSize = 16 * 1024;\n+const int kTraceParts = TSAN_HISTORY_SIZE * 1024 / kTracePartSize;\n+const int kTraceSize = kTracePartSize * kTraceParts;\n+\n+// Must fit into 3 bits.\n+enum EventType {\n+  EventTypeMop,\n+  EventTypeFuncEnter,\n+  EventTypeFuncExit,\n+  EventTypeLock,\n+  EventTypeUnlock,\n+  EventTypeRLock,\n+  EventTypeRUnlock\n+};\n+\n+// Represents a thread event (from most significant bit):\n+// u64 typ  : 3;   // EventType.\n+// u64 addr : 61;  // Associated pc.\n+typedef u64 Event;\n+\n+struct TraceHeader {\n+  StackTrace stack0;  // Start stack for the trace.\n+  u64        epoch0;  // Start epoch for the trace.\n+#ifndef TSAN_GO\n+  uptr       stack0buf[kTraceStackSize];\n+#endif\n+\n+  TraceHeader()\n+#ifndef TSAN_GO\n+      : stack0(stack0buf, kTraceStackSize)\n+#else\n+      : stack0()\n+#endif\n+      , epoch0() {\n+  }\n+};\n+\n+struct Trace {\n+  Event events[kTraceSize];\n+  TraceHeader headers[kTraceParts];\n+  Mutex mtx;\n+\n+  Trace()\n+    : mtx(MutexTypeTrace, StatMtxTrace) {\n+  }\n+};\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_TRACE_H"}, {"sha": "ae4a318f95254a82c89d0ea41238df5d5a5e8f6b", "filename": "libsanitizer/tsan/tsan_update_shadow_word_inl.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_update_shadow_word_inl.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,77 @@\n+//===-- tsan_update_shadow_word_inl.h ---------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// Body of the hottest inner loop.\n+// If we wrap this body into a function, compilers (both gcc and clang)\n+// produce sligtly less efficient code.\n+//===----------------------------------------------------------------------===//\n+do {\n+  StatInc(thr, StatShadowProcessed);\n+  const unsigned kAccessSize = 1 << kAccessSizeLog;\n+  unsigned off = cur.ComputeSearchOffset();\n+  u64 *sp = &shadow_mem[(idx + off) % kShadowCnt];\n+  old = LoadShadow(sp);\n+  if (old.IsZero()) {\n+    StatInc(thr, StatShadowZero);\n+    if (store_word)\n+      StoreIfNotYetStored(sp, &store_word);\n+    // The above StoreIfNotYetStored could be done unconditionally\n+    // and it even shows 4% gain on synthetic benchmarks (r4307).\n+    break;\n+  }\n+  // is the memory access equal to the previous?\n+  if (Shadow::Addr0AndSizeAreEqual(cur, old)) {\n+    StatInc(thr, StatShadowSameSize);\n+    // same thread?\n+    if (Shadow::TidsAreEqual(old, cur)) {\n+      StatInc(thr, StatShadowSameThread);\n+      if (OldIsInSameSynchEpoch(old, thr)) {\n+        if (OldIsRWStronger(old, kAccessIsWrite)) {\n+          // found a slot that holds effectively the same info\n+          // (that is, same tid, same sync epoch and same size)\n+          StatInc(thr, StatMopSame);\n+          return;\n+        }\n+        StoreIfNotYetStored(sp, &store_word);\n+        break;\n+      }\n+      if (OldIsRWWeaker(old, kAccessIsWrite))\n+        StoreIfNotYetStored(sp, &store_word);\n+      break;\n+    }\n+    StatInc(thr, StatShadowAnotherThread);\n+    if (HappensBefore(old, thr)) {\n+      StoreIfNotYetStored(sp, &store_word);\n+      break;\n+    }\n+    if (BothReads(old, kAccessIsWrite))\n+      break;\n+    goto RACE;\n+  }\n+\n+  // Do the memory access intersect?\n+  if (Shadow::TwoRangesIntersect(old, cur, kAccessSize)) {\n+    StatInc(thr, StatShadowIntersect);\n+    if (Shadow::TidsAreEqual(old, cur)) {\n+      StatInc(thr, StatShadowSameThread);\n+      break;\n+    }\n+    StatInc(thr, StatShadowAnotherThread);\n+    if (HappensBefore(old, thr))\n+      break;\n+\n+    if (BothReads(old, kAccessIsWrite))\n+      break;\n+\n+    goto RACE;\n+  }\n+  // The accesses do not intersect.\n+  StatInc(thr, StatShadowNotIntersect);\n+  break;\n+} while (0);"}, {"sha": "d6bb7076a455aabcba6ee1be29ab17fd33c713eb", "filename": "libsanitizer/tsan/tsan_vector.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd0be65c262d477ac094fc1038824f766d976999/libsanitizer%2Ftsan%2Ftsan_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_vector.h?ref=cd0be65c262d477ac094fc1038824f766d976999", "patch": "@@ -0,0 +1,108 @@\n+//===-- tsan_vector.h -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+// Low-fat STL-like vector container.\n+\n+#ifndef TSAN_VECTOR_H\n+#define TSAN_VECTOR_H\n+\n+#include \"tsan_defs.h\"\n+#include \"tsan_mman.h\"\n+\n+namespace __tsan {\n+\n+template<typename T>\n+class Vector {\n+ public:\n+  explicit Vector(MBlockType typ)\n+      : typ_(typ)\n+      , begin_()\n+      , end_()\n+      , last_() {\n+  }\n+\n+  ~Vector() {\n+    if (begin_)\n+      internal_free(begin_);\n+  }\n+\n+  void Reset() {\n+    if (begin_)\n+      internal_free(begin_);\n+    begin_ = 0;\n+    end_ = 0;\n+    last_ = 0;\n+  }\n+\n+  uptr Size() const {\n+    return end_ - begin_;\n+  }\n+\n+  T &operator[](uptr i) {\n+    DCHECK_LT(i, end_ - begin_);\n+    return begin_[i];\n+  }\n+\n+  const T &operator[](uptr i) const {\n+    DCHECK_LT(i, end_ - begin_);\n+    return begin_[i];\n+  }\n+\n+  T *PushBack(T v = T()) {\n+    EnsureSize(Size() + 1);\n+    end_[-1] = v;\n+    return &end_[-1];\n+  }\n+\n+  void Resize(uptr size) {\n+    uptr old_size = Size();\n+    EnsureSize(size);\n+    if (old_size < size) {\n+      for (uptr i = old_size; i < size; i++)\n+        begin_[i] = T();\n+    }\n+  }\n+\n+ private:\n+  const MBlockType typ_;\n+  T *begin_;\n+  T *end_;\n+  T *last_;\n+\n+  void EnsureSize(uptr size) {\n+    if (size <= Size())\n+      return;\n+    if (size <= (uptr)(last_ - begin_)) {\n+      end_ = begin_ + size;\n+      return;\n+    }\n+    uptr cap0 = last_ - begin_;\n+    uptr cap = 2 * cap0;\n+    if (cap == 0)\n+      cap = 16;\n+    if (cap < size)\n+      cap = size;\n+    T *p = (T*)internal_alloc(typ_, cap * sizeof(T));\n+    if (cap0) {\n+      internal_memcpy(p, begin_, cap0 * sizeof(T));\n+      internal_free(begin_);\n+    }\n+    begin_ = p;\n+    end_ = begin_ + size;\n+    last_ = begin_ + cap;\n+  }\n+\n+  Vector(const Vector&);\n+  void operator=(const Vector&);\n+};\n+}\n+\n+#endif  // #ifndef TSAN_VECTOR_H"}]}