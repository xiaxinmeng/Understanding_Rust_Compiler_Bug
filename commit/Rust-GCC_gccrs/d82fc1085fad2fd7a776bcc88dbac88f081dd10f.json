{"sha": "d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgyZmMxMDg1ZmFkMmZkN2E3NzZiY2M4OGRiYWM4OGYwODFkZDEwZg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-02T23:03:31Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-02T23:03:31Z"}, "message": "line-map.c: New.\n\n\t* line-map.c: New.\n\t* line-map.h: New.\n\t* Makefile.in (line-map.o): New.\n\t(LIBCPP_OBJS, LIBCPP_DEPS): Update.\n\t* c-lex.c (cb_file_change): Update for new cpp_file_change structure.\n\t* cpperror.c (print_containing_files): Similarly.\n\t(print_location): Update.  Don't output a space before _Pragma.\n\t* cppfiles.c (stack_include_file): Set to line 1 immediately.\n\t(stack_include_filee, cpp_make_system_header): Update.\n\t(_cpp_execute_include): Get logical line number right for calling\n\tas-yet-unterminated #include.\n\t* cpphash.h (struct cpp_reader): Add line_maps.\n\t(_cpp_do_file_change): Update.\n\t* cppinit.c (cpp_create_reader): Initialize line maps.\n\t(cpp_destroy): Destroy line maps.\n\t(cpp_start_read): Get logical line number right.\n\t* cpplex.c (parse_string): Only warn once for multi-line strings.\n\tUse boolean variable for null warning.\n\t* cpplib.c (_cpp_handle_directive): End the directive if it isn't\n\talready.\n\t(do_include_common): End the directive early.\n\t(do_line): Don't warn about out-of-range lines in preprocessed\n\tsource.  Update.  Remove unused variables.\n\t(_cpp_do_file_change): Update for new line mapping.\n\t(pragma_cb): New typedef.\n\t(cpp_register_pragma): Stop looking ahead before calling the\n\thandler.  Clean up.\n\t(do_pragma_system_header): End directive early.\n\t(cpp_get_line_maps): New.\n\t(cpp_pop_buffer): Fudge logical line.  Update.\n\t* cpplib.h: Include line-map.h\n\t(enum cpp_fc_reason): Remove.\n\t(struct cpp_file_change): Update.\n\t(cpp_get_line_maps): New.\n\t* cppmain.c (struct_printer): New member map.\n\t(cb_file_change): Update for new mappings.\n\t* fix-header.c (cb_file_change): Similarly.\ntestsuite:\n\t* gcc.dg/cpp/19951025-1.c: Update.\n\nFrom-SVN: r44584", "tree": {"sha": "aedb0e3e4381261de71d4d7cee777f2ccde7880d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aedb0e3e4381261de71d4d7cee777f2ccde7880d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/comments", "author": null, "committer": null, "parents": [{"sha": "6ff02a9579cfb21fd184f3e634c4c837732d7cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff02a9579cfb21fd184f3e634c4c837732d7cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff02a9579cfb21fd184f3e634c4c837732d7cb5"}], "stats": {"total": 504, "additions": 387, "deletions": 117}, "files": [{"sha": "d7aa23c787e1196b90d147a118e4e2419785f423", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -1,3 +1,43 @@\n+2001-08-03  Neil Booth  <neil@cat.daikokuya.demon.co.uk>\n+\n+\t* line-map.c: New.\n+\t* line-map.h: New.\n+\t* Makefile.in (line-map.o): New.\n+\t(LIBCPP_OBJS, LIBCPP_DEPS): Update.\n+\t* c-lex.c (cb_file_change): Update for new cpp_file_change structure.\n+\t* cpperror.c (print_containing_files): Similarly.\n+\t(print_location): Update.  Don't output a space before _Pragma.\n+\t* cppfiles.c (stack_include_file): Set to line 1 immediately.\n+\t(stack_include_filee, cpp_make_system_header): Update.\n+\t(_cpp_execute_include): Get logical line number right for calling\n+\tas-yet-unterminated #include.\n+\t* cpphash.h (struct cpp_reader): Add line_maps.\n+\t(_cpp_do_file_change): Update.\n+\t* cppinit.c (cpp_create_reader): Initialize line maps.\n+\t(cpp_destroy): Destroy line maps.\n+\t(cpp_start_read): Get logical line number right.\n+\t* cpplex.c (parse_string): Only warn once for multi-line strings.\n+\tUse boolean variable for null warning.\n+\t* cpplib.c (_cpp_handle_directive): End the directive if it isn't\n+\talready.\n+\t(do_include_common): End the directive early.\n+\t(do_line): Don't warn about out-of-range lines in preprocessed\n+\tsource.  Update.  Remove unused variables.\n+\t(_cpp_do_file_change): Update for new line mapping.\n+\t(pragma_cb): New typedef.\n+\t(cpp_register_pragma): Stop looking ahead before calling the\n+\thandler.  Clean up.\n+\t(do_pragma_system_header): End directive early.\n+\t(cpp_get_line_maps): New.\n+\t(cpp_pop_buffer): Fudge logical line.  Update.\n+\t* cpplib.h: Include line-map.h\n+\t(enum cpp_fc_reason): Remove.\n+\t(struct cpp_file_change): Update.\n+\t(cpp_get_line_maps): New.\n+\t* cppmain.c (struct_printer): New member map.\n+\t(cb_file_change): Update for new mappings.\n+\t* fix-header.c (cb_file_change): Similarly.\n+\n 2001-08-02  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* Makefile.in (libgcc.mk): Define mkinstalldirs."}, {"sha": "c465c9c3b0824e2fb94367f4e1fe1468064f9cbe", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -1324,6 +1324,8 @@ stringpool.o: stringpool.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(OBSTACK_H) \\\n \n hashtable.o: hashtable.c hashtable.h $(CONFIG_H) $(SYSTEM_H) $(OBSTACK_H)\n \n+line-map.o: line-map.c line-map.h $(CONFIG_H) $(SYSTEM_H)\n+\n ggc-none.o: ggc-none.c $(GCONFIG_H) $(SYSTEM_H) $(GGC_H)\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n@@ -1933,9 +1935,10 @@ PREPROCESSOR_DEFINES = \\\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o \\\n \t\tcpphash.o cpperror.o cppinit.o cppdefault.o \\\n-\t\thashtable.o mkdeps.o prefix.o version.o mbchar.o\n+\t\thashtable.o line-map.o mkdeps.o prefix.o version.o mbchar.o\n \n-LIBCPP_DEPS =\tcpplib.h cpphash.h hashtable.h intl.h $(OBSTACK_H) $(SYSTEM_H)\n+LIBCPP_DEPS =\tcpplib.h cpphash.h line-map.h hashtable.h intl.h \\\n+\t\t$(OBSTACK_H) $(SYSTEM_H)\n \n # Most of the other archives built/used by this makefile are for\n # targets.  This one is strictly for the host."}, {"sha": "ffd3b7441726df5e5b16b5d86adb9a1d7fc84c26", "filename": "gcc/c-lex.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -241,16 +241,20 @@ cb_file_change (pfile, fc)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n      const cpp_file_change *fc;\n {\n-  if (fc->reason == FC_ENTER)\n+  unsigned int from_line = SOURCE_LINE (fc->map - 1, fc->line - 1);\n+\n+  if (fc->reason == LC_ENTER)\n     {\n       /* Don't stack the main buffer on the input stack;\n \t we already did in compile_file.  */\n-      if (fc->from.filename)\n+      if (MAIN_FILE_P (fc->map))\n+\tmain_input_filename = fc->map->to_file;\n+      else\n \t{\n-\t  lineno = fc->from.lineno;\n-\t  push_srcloc (fc->to.filename, 1);\n+\t  lineno = from_line;\n+\t  push_srcloc (fc->map->to_file, 1);\n \t  input_file_stack->indent_level = indent_level;\n-\t  (*debug_hooks->start_source_file) (fc->from.lineno, fc->to.filename);\n+\t  (*debug_hooks->start_source_file) (lineno, fc->map->to_file);\n #ifndef NO_IMPLICIT_EXTERN_C\n \t  if (c_header_level)\n \t    ++c_header_level;\n@@ -261,10 +265,8 @@ cb_file_change (pfile, fc)\n \t    }\n #endif\n \t}\n-      else\n-\tmain_input_filename = fc->to.filename;\n     }\n-  else if (fc->reason == FC_LEAVE)\n+  else if (fc->reason == LC_LEAVE)\n     {\n       /* Popping out of a file.  */\n       if (input_file_stack->next)\n@@ -288,16 +290,16 @@ cb_file_change (pfile, fc)\n \t    }\n #endif\n \t  pop_srcloc ();\n-\t  (*debug_hooks->end_source_file) (input_file_stack->line);\n+\t  (*debug_hooks->end_source_file) (from_line);\n \t}\n       else\n \terror (\"leaving more files than we entered\");\n     }\n \n-  update_header_times (fc->to.filename);\n+  update_header_times (fc->map->to_file);\n   in_system_header = fc->sysp != 0;\n-  input_filename = fc->to.filename;\n-  lineno = fc->to.lineno;\t/* Do we need this?  */\n+  input_filename = fc->map->to_file;\n+  lineno = SOURCE_LINE (fc->map, fc->line); /* Do we need this?  */\n \n   /* Hook for C++.  */\n   extract_interface_info ();"}, {"sha": "f10198288f097da13ef4ce41f59dfeaf9d51fffa", "filename": "gcc/cpperror.c", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -29,7 +29,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpphash.h\"\n #include \"intl.h\"\n \n-static void print_containing_files\tPARAMS ((cpp_buffer *));\n+static void print_containing_files\tPARAMS ((struct line_map *,\n+\t\t\t\t\t\t struct line_map *));\n static void print_location\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const char *,\n \t\t\t\t\t\t const cpp_lexer_pos *));\n@@ -42,21 +43,25 @@ static void print_location\t\tPARAMS ((cpp_reader *,\n /* Print the file names and line numbers of the #include\n    commands which led to the current file.  */\n static void\n-print_containing_files (ip)\n-     cpp_buffer *ip;\n+print_containing_files (map_array, map)\n+     struct line_map *map_array;\n+     struct line_map *map;\n {\n   int first = 1;\n \n-  /* Find the other, outer source files.  */\n-  for (ip = ip->prev; ip; ip = ip->prev)\n+  for (;;)\n     {\n+      if (MAIN_FILE_P (map))\n+\tbreak;\n+      map = &map_array[map->included_from];\n+\n       if (first)\n \t{\n \t  first = 0;\n \t  /* The current line in each outer source file is now the\n \t     same as the line of the #include.  */\n \t  fprintf (stderr,  _(\"In file included from %s:%u\"),\n-\t\t   ip->nominal_fname, CPP_BUF_LINE (ip));\n+\t\t   map->to_file, LAST_SOURCE_LINE (map));\n \t}\n       else\n \t/* Translators note: this message is used in conjunction\n@@ -72,8 +77,9 @@ print_containing_files (ip)\n \t   The trailing comma is at the beginning of this message,\n \t   and the trailing colon is not translated.  */\n \tfprintf (stderr, _(\",\\n                 from %s:%u\"),\n-\t\t ip->nominal_fname, CPP_BUF_LINE (ip));\n+\t\t map->to_file, LAST_SOURCE_LINE (map));\n     }\n+\n   fputs (\":\\n\", stderr);\n }\n \n@@ -100,19 +106,24 @@ print_location (pfile, filename, pos)\n \tline = 0;\n       else\n \t{\n+\t  struct line_map *map;\n+\n+\t  line = pfile->line;\n \t  if (type == BUF_PRAGMA)\n \t    {\n \t      buffer = buffer->prev;\n-\t      line = CPP_BUF_LINE (buffer);\n \t      col = CPP_BUF_COL (buffer);\n \t    }\n-\t  else\n+\n+\t  map = lookup_line (&pfile->line_maps, line);\n+\t  if (pos == 0)\n \t    {\n-\t      if (pos == 0)\n-\t\tpos = cpp_get_line (pfile);\n-\t      line = pos->line;\n-\t      col = pos->col;\n+\t      pos = cpp_get_line (pfile);\n+\t      line = SOURCE_LINE (map, line);\n \t    }\n+\t  else\n+\t    line = pos->line;\n+\t  col = pos->col;\n \n \t  if (col == 0)\n \t    col = 1;\n@@ -121,22 +132,23 @@ print_location (pfile, filename, pos)\n \t  if (buffer->prev && ! buffer->include_stack_listed)\n \t    {\n \t      buffer->include_stack_listed = 1;\n-\t      print_containing_files (buffer);\n+\t      print_containing_files (pfile->line_maps.maps, map);\n \t    }\n \t}\n \n       if (filename == 0)\n \tfilename = buffer->nominal_fname;\n \n       if (line == 0)\n-\tfprintf (stderr, \"%s: \", filename);\n+\tfprintf (stderr, \"%s:\", filename);\n       else if (CPP_OPTION (pfile, show_column) == 0)\n-\tfprintf (stderr, \"%s:%u: \", filename, line);\n+\tfprintf (stderr, \"%s:%u:\", filename, line);\n       else\n-\tfprintf (stderr, \"%s:%u:%u: \", filename, line, col);\n+\tfprintf (stderr, \"%s:%u:%u:\", filename, line, col);\n \n       if (type == BUF_PRAGMA)\n-\tfprintf (stderr, \"_Pragma: \");\n+\tfprintf (stderr, \"_Pragma:\");\n+      fputc (' ', stderr);\n     }\n }\n "}, {"sha": "b939b405c889d659ab0512661138f8f497604c92", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -338,7 +338,7 @@ stack_include_file (pfile, inc)\n \n   /* Generate the call back.  */\n   fp->lineno = 0;\n-  _cpp_do_file_change (pfile, FC_ENTER, 0, 0);\n+  _cpp_do_file_change (pfile, LC_ENTER);\n   fp->lineno = 1;\n }\n \n@@ -579,8 +579,7 @@ cpp_make_system_header (pfile, syshdr, externc)\n   if (syshdr)\n     flags = 1 + (externc != 0);\n   pfile->buffer->sysp = flags;\n-  _cpp_do_file_change (pfile, FC_RENAME, pfile->buffer->nominal_fname,\n-\t\t       pfile->buffer->lineno);\n+  _cpp_do_file_change (pfile, LC_RENAME);\n }\n \n /* Report on all files that might benefit from a multiple include guard.\n@@ -681,6 +680,7 @@ _cpp_execute_include (pfile, header, type)\n \tpfile->system_include_depth++;\n \n       stack_include_file (pfile, inc);\n+      pfile->line++;\t\t/* Fake the '\\n' at the end of #include.  */\n \n       if (type == IT_IMPORT)\n \t_cpp_never_reread (inc);"}, {"sha": "0c1695c1d09328ba9d81cf1ba8afcbf7bb452e1b", "filename": "gcc/cpphash.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -249,6 +249,7 @@ struct cpp_reader\n   /* Source line tracking.  Subtract pseudo_newlines from the actual\n      line number to get the line number of preprocessed output.  Used\n      for escaped newlines and macro args that cross multiple lines.  */\n+  struct line_maps line_maps;\n   unsigned int line;\n   unsigned int pseudo_newlines;\n \n@@ -439,8 +440,7 @@ extern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n extern void _cpp_init_directives PARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n-extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum cpp_fc_reason,\n-\t\t\t\t\t const char *, unsigned int));\n+extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason));\n \n /* Utility routines and macros.  */\n #define DSC(str) (const U_CHAR *)str, sizeof str - 1"}, {"sha": "fa01b347055bb4a7344df436bf411511f5dc9d9a", "filename": "gcc/cppinit.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -496,6 +496,9 @@ cpp_create_reader (table, lang)\n      be needed.  */\n   pfile->deps = deps_init ();\n \n+  /* Initialise the line map.  */\n+  init_line_maps (&pfile->line_maps);\n+\n   /* Initialize lexer state.  */\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n \n@@ -585,6 +588,8 @@ cpp_destroy (pfile)\n       free (context);\n     }\n \n+  free_line_maps (&pfile->line_maps);\n+\n   result = pfile->errors;\n   free (pfile);\n \n@@ -941,6 +946,11 @@ cpp_start_read (pfile, fname)\n       p = q;\n     }\n \n+  /* This was zero when the initial buffer was stacked; so we must\n+     make up for a non-existent new line, as well as the intervening\n+     macro definitions, by setting it to 1.  */\n+  pfile->line = 1;\n+\n   /* The -imacros files can be scanned now, but the -include files\n      have to be pushed onto the buffer stack and processed later,\n      otherwise cppmain.c won't see the tokens.  include_head was built"}, {"sha": "fa32bd51561a108ac87c2b41b65cdc5a3452641a", "filename": "gcc/cpplex.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -657,7 +657,7 @@ parse_string (pfile, token, terminator)\n   cpp_pool *pool = &pfile->ident_pool;\n   unsigned char *dest, *limit;\n   cppchar_t c;\n-  unsigned int nulls = 0;\n+  bool warned_nulls = false, warned_multi = false;\n \n   dest = POOL_FRONT (pool);\n   limit = POOL_LIMIT (pool);\n@@ -707,18 +707,23 @@ parse_string (pfile, token, terminator)\n \t      break;\n \t    }\n \n-\t  cpp_pedwarn (pfile, \"multi-line string literals are deprecated\");\n+\t  if (!warned_multi)\n+\t    {\n+\t      warned_multi = true;\n+\t      cpp_pedwarn (pfile, \"multi-line string literals are deprecated\");\n+\t    }\n+\n \t  if (pfile->mlstring_pos.line == 0)\n \t    pfile->mlstring_pos = pfile->lexer_pos;\n \t      \n \t  c = handle_newline (pfile, c);\n \t  *dest++ = '\\n';\n \t  goto have_char;\n \t}\n-      else if (c == '\\0')\n+      else if (c == '\\0' && !warned_nulls)\n \t{\n-\t  if (nulls++ == 0)\n-\t    cpp_warning (pfile, \"null character(s) preserved in literal\");\n+\t  warned_nulls = true;\n+\t  cpp_warning (pfile, \"null character(s) preserved in literal\");\n \t}\n \n       *dest++ = c;\n@@ -914,8 +919,8 @@ _cpp_lex_token (pfile, result)\n \t  bol = 1;\n \t  pfile->lexer_pos.output_line = buffer->lineno;\n \t  /* This is a new line, so clear any white space flag.\n-\t     Newlines in arguments are white space (6.10.3.10);\n-\t     parse_arg takes care of that.  */\n+\t          Newlines in arguments are white space (6.10.3.10);\n+\t\t  parse_arg takes care of that.  */\n \t  result->flags &= ~(PREV_WHITE | AVOID_LPASTE);\n \t  goto next_char;\n \t}"}, {"sha": "b3d1c701794a6a7485bdbf3f20ea4752c64976f8", "filename": "gcc/cpplib.c", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -379,7 +379,8 @@ _cpp_handle_directive (pfile, indented)\n \t\t   cpp_token_as_text (pfile, &dname));\n     }\n \n-  end_directive (pfile, skip);\n+  if (pfile->state.in_directive)\n+    end_directive (pfile, skip);\n   return skip;\n }\n \n@@ -623,7 +624,7 @@ do_include_common (pfile, type)\n \t{\n \t  check_eol (pfile);\n \t  /* Get out of macro context, if we are.  */\n-\t  skip_rest_of_line (pfile);\n+\t  end_directive (pfile, 1);\n \t  if (pfile->cb.include)\n \t    (*pfile->cb.include) (pfile, pfile->directive->name, &header);\n \n@@ -713,9 +714,7 @@ do_line (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  const char *filename = buffer->nominal_fname;\n-  unsigned int lineno = buffer->lineno;\n-  enum cpp_fc_reason reason = FC_RENAME;\n+  enum lc_reason reason = LC_RENAME;\n   unsigned long new_lineno;\n   unsigned int cap;\n   cpp_token token;\n@@ -733,7 +732,8 @@ do_line (pfile)\n       return;\n     }      \n \n-  if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n+  if (CPP_PEDANTIC (pfile) && ! pfile->state.line_extension\n+      && (new_lineno == 0 || new_lineno > cap))\n     cpp_pedwarn (pfile, \"line number out of range\");\n \n   cpp_get_token (pfile, &token);\n@@ -751,12 +751,12 @@ do_line (pfile)\n \t  flag = read_flag (pfile, flag);\n \t  if (flag == 1)\n \t    {\n-\t      reason = FC_ENTER;\n+\t      reason = LC_ENTER;\n \t      flag = read_flag (pfile, flag);\n \t    }\n \t  else if (flag == 2)\n \t    {\n-\t      reason = FC_LEAVE;\n+\t      reason = LC_LEAVE;\n \t      flag = read_flag (pfile, flag);\n \t    }\n \t  if (flag == 3)\n@@ -767,15 +767,15 @@ do_line (pfile)\n \t\tsysp = 2, read_flag (pfile, flag);\n \t    }\n \n-\t  if (reason == FC_ENTER)\n+\t  if (reason == LC_ENTER)\n \t    {\n \t      /* Fake a buffer stack for diagnostics.  */\n \t      cpp_push_buffer (pfile, 0, 0, BUF_FAKE, fname);\n \t      /* Fake an include for cpp_included.  */\n \t      _cpp_fake_include (pfile, fname);\n \t      buffer = pfile->buffer;\n \t    }\n-\t  else if (reason == FC_LEAVE)\n+\t  else if (reason == LC_LEAVE)\n \t    {\n \t      if (buffer->type != BUF_FAKE)\n \t\tcpp_warning (pfile, \"file \\\"%s\\\" left but not entered\",\n@@ -808,49 +808,36 @@ do_line (pfile)\n       return;\n     }\n \n-  /* Our line number is incremented after the directive is processed.  */\n+  end_directive (pfile, 1);\n   buffer->lineno = new_lineno - 1;\n-  _cpp_do_file_change (pfile, reason, filename, lineno);\n+  _cpp_do_file_change (pfile, reason);\n }\n \n-/* Arrange the file_change callback.  */\n+/* Arrange the file_change callback.  It is assumed that the next line\n+   is given by incrementing buffer->lineno and pfile->line.  */\n void\n-_cpp_do_file_change (pfile, reason, from_file, from_lineno)\n+_cpp_do_file_change (pfile, reason)\n      cpp_reader *pfile;\n-     enum cpp_fc_reason reason;\n-     const char *from_file;\n-     unsigned int from_lineno;\n+     enum lc_reason reason;\n {\n+  cpp_buffer *buffer;\n+  struct line_map *map;\n+\n+  buffer = pfile->buffer;\n+  map = add_line_map (&pfile->line_maps, reason,\n+\t\t      pfile->line + 1, buffer->nominal_fname, buffer->lineno + 1);\n+\n   if (pfile->cb.file_change)\n     {\n       cpp_file_change fc;\n-      cpp_buffer *buffer = pfile->buffer;\n-\n+      \n+      fc.map = map;\n+      fc.line = pfile->line + 1;\n       fc.reason = reason;\n-      fc.to.filename = buffer->nominal_fname;\n-      fc.to.lineno = buffer->lineno + 1;\n       fc.sysp = buffer->sysp;\n       fc.externc = CPP_OPTION (pfile, cplusplus) && buffer->sysp == 2;\n \n-      /* Caller doesn't need to handle FC_ENTER.  */\n-      if (reason == FC_ENTER)\n-\t{\n-\t  if (buffer->prev)\n-\t    {\n-\t      from_file = buffer->prev->nominal_fname;\n-\t      from_lineno = buffer->prev->lineno;\n-\t    }\n-\t  else\n-\t    from_file = 0;\n-\t}\n-      /* Special case for file \"foo.i\" with \"# 1 foo.c\" on first line.  */\n-      else if (reason == FC_RENAME && ! buffer->prev\n-\t       && pfile->directive_pos.line == 1)\n-\tfrom_file = 0;\n-\n-      fc.from.filename = from_file;\n-      fc.from.lineno = from_lineno;\n-      pfile->cb.file_change (pfile, &fc);\n+      (*pfile->cb.file_change) (pfile, &fc);\n     }\n }\n \n@@ -915,14 +902,15 @@ do_ident (pfile)\n \n /* Sub-handlers for the pragmas needing treatment here.\n    They return 1 if the token buffer is to be popped, 0 if not.  */\n+typedef void (*pragma_cb) PARAMS ((cpp_reader *));\n struct pragma_entry\n {\n   struct pragma_entry *next;\n   const char *name;\n   size_t len;\n   int isnspace;\n   union {\n-    void (*handler) PARAMS ((cpp_reader *));\n+    pragma_cb handler;\n     struct pragma_entry *space;\n   } u;\n };\n@@ -932,7 +920,7 @@ cpp_register_pragma (pfile, space, name, handler)\n      cpp_reader *pfile;\n      const char *space;\n      const char *name;\n-     void (*handler) PARAMS ((cpp_reader *));\n+     pragma_cb handler;\n {\n   struct pragma_entry **x, *new;\n   size_t len;\n@@ -1014,9 +1002,9 @@ static void\n do_pragma (pfile)\n      cpp_reader *pfile;\n {\n+  pragma_cb handler = NULL;\n   const struct pragma_entry *p;\n   cpp_token tok;\n-  int drop = 0;\n \n   p = pfile->pragmas;\n   pfile->state.prevent_expansion++;\n@@ -1041,19 +1029,20 @@ do_pragma (pfile)\n \t\t}\n \t      else\n \t\t{\n-\t\t  (*p->u.handler) (pfile);\n-\t\t  drop = 1;\n+\t\t  handler = p->u.handler;\n \t\t  break;\n \t\t}\n \t    }\n \t  p = p->next;\n \t}\n     }\n \n-  cpp_stop_lookahead (pfile, drop);\n+  cpp_stop_lookahead (pfile, handler != NULL);\n   pfile->state.prevent_expansion--;\n \n-  if (!drop && pfile->cb.def_pragma)\n+  if (handler)\n+    (*handler) (pfile);\n+  else if (pfile->cb.def_pragma)\n     (*pfile->cb.def_pragma) (pfile);\n }\n \n@@ -1119,9 +1108,11 @@ do_pragma_system_header (pfile)\n   if (buffer->prev == 0)\n     cpp_warning (pfile, \"#pragma system_header ignored outside include file\");\n   else\n-    cpp_make_system_header (pfile, 1, 0);\n-\n-  check_eol (pfile);\n+    {\n+      check_eol (pfile);\n+      end_directive (pfile, 1);\n+      cpp_make_system_header (pfile, 1, 0);\n+    }\n }\n \n /* Check the modified date of the current include file against a specified\n@@ -1763,6 +1754,14 @@ cpp_get_callbacks (pfile)\n   return &pfile->cb;\n }\n \n+/* The line map set.  */\n+struct line_maps *\n+cpp_get_line_maps (pfile)\n+     cpp_reader *pfile;\n+{\n+  return &pfile->line_maps;\n+}\n+\n /* Copy the given callbacks structure to our own.  */\n void\n cpp_set_callbacks (pfile, cb)\n@@ -1875,8 +1874,8 @@ cpp_pop_buffer (pfile)\n       if (pfile->directive == &dtable[T_LINE])\n \tbreak;\n \n-      _cpp_do_file_change (pfile, FC_LEAVE, buffer->nominal_fname,\n-\t\t\t   buffer->lineno);\n+      pfile->line--;\t\t/* We have a '\\n' at the end of #include.  */\n+      _cpp_do_file_change (pfile, LC_LEAVE);\n       if (pfile->buffer->type == BUF_FILE)\n \tbreak;\n "}, {"sha": "bb91adb33eb36583aa6086d87c6098a0686f15e4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -25,6 +25,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #include <sys/types.h>\n #include \"hashtable.h\"\n+#include \"line-map.h\"\n \n #ifdef __cplusplus\n extern \"C\" {\n@@ -386,21 +387,12 @@ struct cpp_options\n   unsigned char help_only;\n };\n \n-/* This structure is passed to the call back when changing file.  */\n-enum cpp_fc_reason {FC_ENTER = 0, FC_LEAVE, FC_RENAME};\n-\n-struct cpp_file_loc\n-{\n-  const char *filename;\n-  unsigned int lineno;\n-};\n-\n typedef struct cpp_file_change cpp_file_change;\n struct cpp_file_change\n {\n-  struct cpp_file_loc from;\t/* Line of #include or #line.  */\n-  struct cpp_file_loc to;\t/* Line after #include or #line, or start.  */\n-  enum cpp_fc_reason reason;\t/* Reason for change.  */\n+  struct line_map *map;\t\t/* Line map to use until next callback.  */\n+  unsigned int line;\t\t/* Logical line number of next line.  */\n+  enum lc_reason reason;\t/* Reason for change.  */\n   unsigned char sysp;\t\t/* Nonzero if system header.  */\n   unsigned char externc;\t/* Nonzero if wrapper needed.  */\n };\n@@ -510,6 +502,7 @@ extern int cpp_destroy PARAMS ((cpp_reader *));\n    through the pointer returned from cpp_get_callbacks, or set them\n    with cpp_set_callbacks.  */\n extern cpp_options *cpp_get_options PARAMS ((cpp_reader *));\n+extern struct line_maps *cpp_get_line_maps PARAMS ((cpp_reader *));\n extern cpp_callbacks *cpp_get_callbacks PARAMS ((cpp_reader *));\n extern void cpp_set_callbacks PARAMS ((cpp_reader *, cpp_callbacks *));\n "}, {"sha": "cc3b81d10bd89ace35e61713802c157d4e66c251", "filename": "gcc/cppmain.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -35,6 +35,7 @@ struct printer\n   const char *syshdr_flags;\t/* system header flags, if any.  */\n   unsigned int lineno;\t\t/* line currently being written.  */\n   unsigned char printed;\t/* nonzero if something output at lineno.  */\n+  struct line_map *map;\t\t/* logical to physical line mappings.  */\n };\n \n int main\t\tPARAMS ((int, char **));\n@@ -402,10 +403,11 @@ cb_file_change (pfile, fc)\n      const cpp_file_change *fc;\n {\n   /* Bring current file to correct line (except first file).  */\n-  if (fc->reason == FC_ENTER && fc->from.filename)\n-    maybe_print_line (fc->from.lineno);\n+  if (fc->reason == LC_ENTER && !MAIN_FILE_P (fc->map))\n+    maybe_print_line (SOURCE_LINE (fc->map - 1, fc->line - 1));\n \n-  print.last_fname = fc->to.filename;\n+  print.map = fc->map;\n+  print.last_fname = fc->map->to_file;\n   if (fc->externc)\n     print.syshdr_flags = \" 3 4\";\n   else if (fc->sysp)\n@@ -417,17 +419,19 @@ cb_file_change (pfile, fc)\n     {\n       const char *flags = \"\";\n \n-      print.lineno = fc->to.lineno;\n-      if (fc->reason == FC_ENTER)\n+      print.lineno = SOURCE_LINE (fc->map, fc->line);\n+      if (fc->reason == LC_ENTER)\n \tflags = \" 1\";\n-      else if (fc->reason == FC_LEAVE)\n+      else if (fc->reason == LC_LEAVE)\n \tflags = \" 2\";\n \n       if (! options->no_line_commands)\n \tprint_line (flags);\n     }\n }\n \n+/* Copy a #pragma directive to the preprocessed output.  LINE is the\n+   line of the current source file, not the logical line.  */\n static void\n cb_def_pragma (pfile)\n      cpp_reader *pfile;"}, {"sha": "3124196e7b07b1b6c92652d21f894c97035ef292", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -603,7 +603,7 @@ cb_file_change (pfile, fc)\n      const cpp_file_change *fc;\n {\n   /* Just keep track of current file name.  */\n-  cur_file = fc->to.filename;\n+  cur_file = fc->map->to_file;\n }\n \n static void"}, {"sha": "a67191d3aed1a610cac482c86e653d2c04727eab", "filename": "gcc/line-map.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -0,0 +1,118 @@\n+/* Map logical line numbers to (source file, line number) pairs.\n+   Copyright (C) 2001\n+   Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"line-map.h\"\n+\n+/* Initialize a line map set.  */\n+\n+void\n+init_line_maps (set)\n+     struct line_maps *set;\n+{\n+  set->maps = 0;\n+  set->allocated = 0;\n+  set->used = 0;\n+}\n+\n+/* Free a line map set.  */\n+\n+void free_line_maps (set)\n+     struct line_maps *set;\n+{\n+  if (set->maps)\n+    free (set->maps);\n+}\n+\n+/* Add a mapping of logical source line to physical source file and\n+   line number.  Ther text pointed to by TO_FILE must have a lifetime\n+   at least as long as the final call to lookup_line ().\n+\n+   FROM_LINE should be monotonic increasing across calls to this\n+   function.  */\n+\n+struct line_map *\n+add_line_map (set, reason, from_line, to_file, to_line)\n+     struct line_maps *set;\n+     enum lc_reason reason;\n+     unsigned int from_line;\n+     const char *to_file;\n+     unsigned int to_line;\n+{\n+  struct line_map *map;\n+\n+  if (set->used && from_line < set->maps[set->used - 1].from_line)\n+    abort ();\n+\n+  if (set->used == set->allocated)\n+    {\n+      set->allocated = 2 * set->allocated + 256;\n+      set->maps = (struct line_map *)\n+\txrealloc (set->maps, set->allocated * sizeof (struct line_map));\n+    }\n+\n+  map = &set->maps[set->used];\n+  map->from_line = from_line;\n+  map->to_file = to_file;\n+  map->to_line = to_line;\n+\n+  if (set->used == 0)\n+    map->included_from = -1;\n+  else if (reason == LC_ENTER)\n+    map->included_from = set->used - 1;\n+  else if (reason == LC_RENAME)\n+    map->included_from = map[-1].included_from;\n+  else if (reason == LC_LEAVE)\n+    {\n+      if (map[-1].included_from < 0)\n+\tabort ();\n+      map->included_from = set->maps[map[-1].included_from].included_from;\n+    }\n+\n+  set->used++;\n+  return map;\n+}\n+\n+/* Translate a logical line number into a (source file, line) pair.  */\n+\n+struct line_map *\n+lookup_line (set, line)\n+     struct line_maps *set;\n+     unsigned int line;\n+{\n+  unsigned int md, mn = 0, mx = set->used;\n+\n+  if (mx == 0)\n+    abort ();\n+\n+  while (mx - mn > 1)\n+    {\n+      md = (mn + mx) / 2;\n+      if (set->maps[md].from_line > line)\n+\tmx = md;\n+      else\n+\tmn = md;\n+    }\n+\n+  return &set->maps[mn];\n+}"}, {"sha": "fe5e3cc6c9d6bd32cd9096a0343942a101094595", "filename": "gcc/line-map.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -0,0 +1,80 @@\n+/* Map logical line numbers to (source file, line number) pairs.\n+   Copyright (C) 2001\n+   Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#ifndef GCC_LINE_MAP_H\n+#define GCC_LINE_MAP_H\n+\n+/* The logical line FROM_LINE maps to physical source file TO_FILE at\n+   line TO_LINE, and subsequently one-to-one until the next line_map\n+   structure in the set.  */\n+struct line_map\n+{\n+  const char *to_file;\n+  unsigned int to_line;\n+  unsigned int from_line;\n+  int included_from;\n+};\n+\n+/* Contains a sequence of chronological line_map structures.  */\n+struct line_maps\n+{\n+  struct line_map *maps;\n+  unsigned int allocated;\n+  unsigned int used;\n+};\n+\n+/* Reason for adding a line change with add_line_map ().  */\n+enum lc_reason {LC_ENTER = 0, LC_LEAVE, LC_RENAME};\n+\n+/* Initialize a line map set.  */\n+extern void init_line_maps\n+  PARAMS ((struct line_maps *));\n+\n+/* Free a line map set.  */\n+extern void free_line_maps\n+  PARAMS ((struct line_maps *));\n+\n+/* Add a mapping of logical source line to physical source file and\n+   line number.  Ther text pointed to by TO_FILE must have a lifetime\n+   at least as long as the final call to lookup_line ().\n+\n+   FROM_LINE should be monotonic increasing across calls to this\n+   function.  */\n+extern struct line_map *add_line_map\n+  PARAMS ((struct line_maps *, enum lc_reason,\n+\t   unsigned int from_line, const char *to_file, unsigned int to_line));\n+\n+/* Given a logical line, returns the map from which the corresponding\n+   (source file, line) pair can be deduced.  */\n+extern struct line_map *lookup_line\n+  PARAMS ((struct line_maps *, unsigned int));\n+\n+/* Converts a map and logical line to source line.  */\n+#define SOURCE_LINE(MAP, LINE) ((LINE) + (MAP)->to_line - (MAP)->from_line)\n+\n+/* Returns the last source line within a map.  This is the (last) line\n+   of the #include, or other directive, that caused a map change.  */\n+#define LAST_SOURCE_LINE(MAP) SOURCE_LINE (MAP, (MAP)[1].from_line - 1)\n+\n+#define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n+\n+#endif /* !GCC_LINE_MAP_H  */"}, {"sha": "c03e7e3948e1942e24aa2406d6a3d796f2a945fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -1,3 +1,7 @@\n+2001-08-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/19951025-1.c: Update.\n+\n 2001-08-02  Jeffrey Oldham  <oldham@codesourcery.com>\n \n \t* g77.dg/ff90-1.f (s): Fix reference of variable z,"}, {"sha": "ca21a227c13b16c7ca61f6031e94b1cc7673b01d", "filename": "gcc/testsuite/gcc.dg/cpp/19951025-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d82fc1085fad2fd7a776bcc88dbac88f081dd10f/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c?ref=d82fc1085fad2fd7a776bcc88dbac88f081dd10f", "patch": "@@ -1,4 +1,4 @@\n /* { dg-do preprocess } */\n-/* { dg-error \"include expects\" \"\" { target *-*-* } 4 } */\n-/* { dg-error \"newline at end\" \"\" { target *-*-* } 4 } */\n+/* { dg-error \"include expects\" \"\" { target *-*-* } 5 } */\n+/* { dg-error \"newline at end\" \"\" { target *-*-* } 5 } */\n #include /\\"}]}