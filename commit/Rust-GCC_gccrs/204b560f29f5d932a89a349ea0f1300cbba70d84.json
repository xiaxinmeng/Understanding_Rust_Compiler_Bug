{"sha": "204b560f29f5d932a89a349ea0f1300cbba70d84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0YjU2MGYyOWY1ZDkzMmE4OWEzNDllYTBmMTMwMGNiYmE3MGQ4NA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-07-31T02:44:28Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-07-31T02:44:28Z"}, "message": "New implementation of Graphite.\n\n2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* Makefile.in (OBJS-common): Added dependence on graphite-blocking.o,\n\tgraphite-clast-to-gimple.o, graphite-dependences.o,\n\tgraphite-interchange.o, graphite-poly.o, graphite-ppl.o,\n\tgraphite-scop-detection.o, graphite-sese-to-poly.o, and sese.o.\n\t(graphite-blocking.o,\n\tgraphite-clast-to-gimple.o, graphite-dependences.o,\n\tgraphite-interchange.o, graphite-poly.o, graphite-ppl.o,\n\tgraphite-scop-detection.o, graphite-sese-to-poly.o, and sese.o): New.\n\t* cfgloop.c (alloc_loop): Set loop->can_be_parallel to false.\n\t* cfgloop.h (struct loop): Add can_be_parallel field.\n\t* common.opt (fgraphite-identity): Moved up.\n\t(fgraphite-force-parallel): New flag.\n\t* graphite.c: Rewrite.\n\t* graphite.h: Rewrite.\n\t* passes.c (init_optimization_passes): Schedule a pass of DCE and LIM\n\tafter Graphite.\n\t* toplev.c (graphite_out_file): New file descriptor.\n\t(graphite_in_file): New.\n\t(process_options): flag_graphite_force_parallel cannot be used without\n\tGraphite.\n\t* tree-ssa-loop.c: Include toplev.h.\n\t(gate_graphite_transforms): Enable flag_graphite for\n\tflag_graphite_force_parallel.\n\nFrom-SVN: r150301", "tree": {"sha": "97a4d56bceb53628871305cab824f736a9c334eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97a4d56bceb53628871305cab824f736a9c334eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/204b560f29f5d932a89a349ea0f1300cbba70d84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204b560f29f5d932a89a349ea0f1300cbba70d84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204b560f29f5d932a89a349ea0f1300cbba70d84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204b560f29f5d932a89a349ea0f1300cbba70d84/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2abae5f13adafd84ac3f4e2da2890da4515fd1fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2abae5f13adafd84ac3f4e2da2890da4515fd1fe"}], "stats": {"total": 6861, "additions": 260, "deletions": 6601}, "files": [{"sha": "f5c6a4f87dcff26dc1657b2384c324f1e50f3c5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -1,3 +1,29 @@\n+2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* Makefile.in (OBJS-common): Added dependence on graphite-blocking.o,\n+\tgraphite-clast-to-gimple.o, graphite-dependences.o,\n+\tgraphite-interchange.o, graphite-poly.o, graphite-ppl.o,\n+\tgraphite-scop-detection.o, graphite-sese-to-poly.o, and sese.o.\n+\t(graphite-blocking.o,\n+\tgraphite-clast-to-gimple.o, graphite-dependences.o,\n+\tgraphite-interchange.o, graphite-poly.o, graphite-ppl.o,\n+\tgraphite-scop-detection.o, graphite-sese-to-poly.o, and sese.o): New.\n+\t* cfgloop.c (alloc_loop): Set loop->can_be_parallel to false.\n+\t* cfgloop.h (struct loop): Add can_be_parallel field.\n+\t* common.opt (fgraphite-identity): Moved up.\n+\t(fgraphite-force-parallel): New flag.\n+\t* graphite.c: Rewrite.\n+\t* graphite.h: Rewrite.\n+\t* passes.c (init_optimization_passes): Schedule a pass of DCE and LIM\n+\tafter Graphite.\n+\t* toplev.c (graphite_out_file): New file descriptor.\n+\t(graphite_in_file): New.\n+\t(process_options): flag_graphite_force_parallel cannot be used without\n+\tGraphite.\n+\t* tree-ssa-loop.c: Include toplev.h.\n+\t(gate_graphite_transforms): Enable flag_graphite for\n+\tflag_graphite_force_parallel.\n+\n 2009-07-30  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* ChangeLog.graphite: New."}, {"sha": "b43e6ee574fb91e88fa5a85d5b037aba24cc5612", "filename": "gcc/Makefile.in", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -1178,6 +1178,14 @@ OBJS-common = \\\n \tgraph.o \\\n \tgraphds.o \\\n \tgraphite.o \\\n+\tgraphite-blocking.o \\\n+\tgraphite-clast-to-gimple.o \\\n+\tgraphite-dependences.o \\\n+\tgraphite-interchange.o \\\n+\tgraphite-poly.o \\\n+\tgraphite-ppl.o \\\n+\tgraphite-scop-detection.o \\\n+\tgraphite-sese-to-poly.o \\\n \tgtype-desc.o \\\n \thaifa-sched.o \\\n \thooks.o \\\n@@ -1251,6 +1259,7 @@ OBJS-common = \\\n \tsel-sched-ir.o \\\n \tsel-sched-dump.o \\\n \tsel-sched.o \\\n+\tsese.o \\\n \tsimplify-rtx.o \\\n \tsparseset.o \\\n \tsreal.o \\\n@@ -2450,11 +2459,64 @@ tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n    $(TREE_DATA_REF_H) $(TREE_PASS_H) langhooks.h\n+sese.o: sese.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n+   domwalk.h pointer-set.h value-prof.h\n graphite.o: graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n-   $(TREE_DATA_REF_H) $(SCEV_H) $(TREE_PASS_H) tree-chrec.h graphite.h \\\n-   pointer-set.h value-prof.h\n+   $(TREE_DATA_REF_H) tree-pass.h graphite.h \\\n+   pointer-set.h value-prof.h graphite-ppl.h sese.h \\\n+   graphite-scop-detection.h graphite-clast-to-gimple.h \\\n+   graphite-poly.h graphite-sese-to-poly.h\n+graphite-blocking.o: graphite-blocking.c $(CONFIG_H) $(SYSTEM_H) \\\n+   coretypes.h \\\n+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n+   $(TOPLEV_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n+   $(GIMPLE_H) $(TREE_DATA_REF_H) tree-pass.h \\\n+   graphite.h graphite-poly.h graphite-ppl.h\n+graphite-clast-to-gimple.o: graphite-clast-to-gimple.c $(CONFIG_H) \\\n+   $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n+   $(TREE_DATA_REF_H) tree-pass.h graphite.h \\\n+   pointer-set.h value-prof.h graphite-ppl.h sese.h \\\n+   graphite-scop-detection.h graphite-clast-to-gimple.h graphite-poly.h \\\n+   graphite-dependences.h\n+graphite-dependences.o: graphite-dependences.c $(CONFIG_H) $(SYSTEM_H) \\\n+   coretypes.h \\\n+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n+   $(TOPLEV_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n+   $(GIMPLE_H) $(TREE_DATA_REF_H) tree-pass.h \\\n+   graphite.h graphite-poly.h graphite-ppl.h graphite-dependences.h\n+graphite-interchange.o: graphite-interchange.c $(CONFIG_H) $(SYSTEM_H) \\\n+   coretypes.h \\\n+   $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) \\\n+   $(TOPLEV_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \\\n+   $(GIMPLE_H) $(TREE_DATA_REF_H) tree-pass.h \\\n+   graphite.h graphite-poly.h graphite-ppl.h\n+graphite-poly.o: graphite-poly.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n+   $(TREE_DATA_REF_H) tree-pass.h graphite.h graphite-dependences.h \\\n+   pointer-set.h value-prof.h graphite-ppl.h sese.h output.h graphite-poly.h\n+graphite-ppl.o: graphite-ppl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(GGC_H) graphite-ppl.h\n+graphite-scop-detection.o: graphite-scop-detection.c $(CONFIG_H) $(SYSTEM_H) \\\n+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n+   $(TREE_DATA_REF_H) tree-pass.h graphite.h $(TM_H) \\\n+   value-prof.h graphite-ppl.h sese.h pointer-set.h coretypes.h \\\n+   graphite-scop-detection.h graphite-poly.h\n+graphite-sese-to-poly.o: graphite-sese-to-poly.c $(CONFIG_H) \\\n+   $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n+   $(TREE_DATA_REF_H) tree-pass.h graphite.h \\\n+   pointer-set.h value-prof.h graphite-ppl.h sese.h \\\n+   graphite-scop-detection.h graphite-sese-to-poly.h $(PARAMS_H) \\\n+   graphite-clast-to-gimple.h graphite-poly.h\n tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) \\\n    $(TREE_DUMP_H) $(CFGLOOP_H) $(EXPR_H) $(RECOG_H) $(OPTABS_H) $(TOPLEV_H) \\"}, {"sha": "b9af098d070d03850a1bc30867d6d1160e27fb36", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -338,6 +338,7 @@ alloc_loop (void)\n \n   loop->exits = GGC_CNEW (struct loop_exit);\n   loop->exits->next = loop->exits->prev = loop->exits;\n+  loop->can_be_parallel = false;\n \n   return loop;\n }"}, {"sha": "d6c26bf0ba09acf8879c253d6ba448487fbf2300", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -157,6 +157,9 @@ struct GTY ((chain_next (\"%h.next\"))) loop {\n \n   /* Head of the cyclic list of the exits of the loop.  */\n   struct loop_exit *exits;\n+\n+  /* True if the loop can be parallel.  */\n+  bool can_be_parallel;\n };\n \n /* Flags for state of loop structure.  */"}, {"sha": "be1bf4c6f5d51fa5af823d62bfed6074a133d3fd", "filename": "gcc/common.opt", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -571,6 +571,16 @@ fgraphite\n Common Report Var(flag_graphite)\n Enable in and out of Graphite representation\n \n+; This option is not documented as it does not perform any useful optimization.\n+fgraphite-identity\n+Common Report Var(flag_graphite_identity) Optimization\n+Enable Graphite Identity transformation\n+\n+; This option is not documented as it will be removed\n+fgraphite-force-parallel\n+Common Report Var(flag_graphite_force_parallel) Optimization\n+Mark all loops as parallel\n+\n floop-strip-mine\n Common Report Var(flag_loop_strip_mine) Optimization\n Enable Loop Strip Mining transformation\n@@ -583,11 +593,6 @@ floop-block\n Common Report Var(flag_loop_block) Optimization\n Enable Loop Blocking transformation\n \n-; This option is not documented as it does not perform any useful optimization.\n-fgraphite-identity\n-Common Report Var(flag_graphite_identity) Optimization\n-Enable Graphite Identity transformation\n-\n fguess-branch-probability\n Common Report Var(flag_guess_branch_prob) Optimization\n Enable guessing of branch probabilities"}, {"sha": "997e164a34471ab7ab0ee4f96ff3d246a12aede1", "filename": "gcc/graphite.c", "status": "modified", "additions": 143, "deletions": 6039, "changes": 6182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=204b560f29f5d932a89a349ea0f1300cbba70d84"}, {"sha": "1007e9af4109ac937b3b5c782682da3708d2d97d", "filename": "gcc/graphite.h", "status": "modified", "additions": 0, "deletions": 552, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -21,556 +21,4 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GRAPHITE_H\n #define GCC_GRAPHITE_H\n \n-#include \"tree-data-ref.h\"\n-\n-int ref_nb_loops (data_reference_p);\n-\n-typedef struct graphite_bb *graphite_bb_p;\n-DEF_VEC_P(graphite_bb_p);\n-DEF_VEC_ALLOC_P (graphite_bb_p, heap);\n-\n-DEF_VEC_P(scop_p);\n-DEF_VEC_ALLOC_P (scop_p, heap);\n-\n-static inline int scop_nb_loops (scop_p scop);\n-static inline unsigned scop_nb_params (scop_p scop);\n-static inline bool scop_contains_loop (scop_p scop, struct loop *loop);\n-\n-typedef struct graphite_bb\n-{\n-  basic_block bb;\n-  scop_p scop;\n-\n-  /* The static schedule contains the textual order for every loop layer.\n-    \n-     Example:\n-\n-     S0\n-     for (i ...)\n-       {\n-         S1\n-         for (j ...)\n-           {\n-             S2\n-             S3\n-           }\n-         S4\n-       }\n-     S5\n-     for (k ...)\n-       {\n-         S6\n-         S7\n-         for (l ...)\n-           {\n-             S8\n-           }\n-         S9\n-       }\n-     S10\n-\n-     Schedules:\n-  \n-        | Depth       \n-     BB | 0  1  2 \n-     ------------\n-     S0 | 0\n-     S1 | 1, 0\n-     S2 | 1, 1, 0\n-     S3 | 1, 1, 1\n-     S4 | 1, 2\n-     S5 | 2\n-     S6 | 3, 0\n-     S7 | 3, 1\n-     S8 | 3, 2, 0\n-     S9 | 3, 3\n-     S10| 4\n-\n-   Normalization rules:\n-     - One SCoP can never contain two bbs with the same schedule timestamp.\n-     - All bbs at the same loop depth have a consecutive ordering (no gaps). */\n-  lambda_vector static_schedule;\n-\n-  /* The iteration domain of this bb. It contains this columns:\n-     - In/Eq: If this line is a equation or inequation.\n-     - For every loop iterator one column.\n-     - One column for every parameter in this SCoP.\n-     - The constant column to add integers to the (in)equations.\n-\n-     Example:\n-\n-     for (i = a - 7*b + 8; i <= 3*a + 13*b + 20; i++)\n-       for (j = 2; j <= 2*i + 5; j++)\n-         for (k = 0; k <= 5; k++)\n-           S (i,j,k)\n-\n-     Loop iterators: i, j, k \n-     Parameters: a, b\n-      \n-     (I)eq   i   j   k   a   b   1\n-  \n-     1       1   0   0  -1   7   -8    #  i >=  a -  7b +  8\n-     1      -1   0   0   3   13  20    #  i <= 3a + 13b + 20\n-     1       0   1   0   0   0   -2    #  j >= 2\n-     1       2  -1   0   0   0    5    #  j <= 2i + 5\n-     1       0   0   1   0   0    0    #  k >= 0 \n-     1       0   0  -1   0   0    5    #  k <= 5\n-\n-     The number of loop iterators may change and is not connected to the\n-     number of loops, that surrounded this bb in the gimple code. */\n-   CloogMatrix *domain;\n-\n-  /* Lists containing the restrictions of the conditional statements\n-     dominating this bb.  This bb can only be executed, if all conditions\n-     are true.\n- \n-     Example:\n- \n-     for (i = 0; i <= 20; i++)\n-     {\n-       A\n- \n-       if (2i <= 8)\n-         B\n-     }\n- \n-     So for B there is an additional condition (2i <= 8).\n- \n-     TODO: Add these restrictions to the domain matrix.\n-      \n-     List of COND_EXPR and SWITCH_EXPR.  A COND_EXPR is true only if the\n-     corresponding element in CONDITION_CASES is not NULL_TREE.  For a\n-     SWITCH_EXPR the corresponding element in CONDITION_CASES is a\n-     CASE_LABEL_EXPR.  */\n-  VEC (gimple, heap) *conditions;\n-  VEC (gimple, heap) *condition_cases;\n-\n-  /* LOOPS contains for every column in the graphite domain the corresponding\n-     gimple loop. If there exists no corresponding gimple loop LOOPS contains\n-     NULL. \n-  \n-     Example:\n-\n-     Original code:\n-\n-     for (i = 0; i <= 20; i++) \n-       for (j = 5; j <= 10; j++)\n-         A\n-\n-     Original domain:\n-\n-     (I)eq  i  j  1\n-     1      1  0  0   # i >= 0\n-     1     -1  0  20  # i <= 20\n-     1      0  1  0   # j >= 0\n-     1      0 -1  10  # j <= 10\n-\n-     Original loops vector:\n-     0         1 \n-     Loop i    Loop j\n-\n-     After some changes (Exchange i and j, strip-mine i):\n-     \n-     Domain:\n-\n-     (I)eq  j  ii i  k  1\n-     1      0  0  1  0  0   # i >= 0\n-     1      0  0 -1  0  20  # i <= 20\n-     1      1  0  0  0  0   # j >= 0\n-     1     -1  0  0  0  10  # j <= 10\n-     1      0 -1  1  0  0   # ii <= i\n-     1      0  1 -1  0  1   # ii + 1 >= i \n-     1      0 -1  0  2  0   # ii <= 2k\n-     1      0  1  0 -2  0   # ii >= 2k \n-\n-     Iterator vector:\n-     0        1        2         3\n-     Loop j   NULL     Loop i    NULL\n-    \n-     Means the original loop i is now at column two of the domain and\n-     loop j in the original loop nest is now at column 0.  Column 1 and\n-     3 are emtpy.  */\n-  VEC (loop_p, heap) *loops;\n-\n-  lambda_vector compressed_alpha_matrix;\n-  CloogMatrix *dynamic_schedule;\n-  VEC (data_reference_p, heap) *data_refs;\n-  htab_t cloog_iv_types;\n-} *gbb_p;\n-\n-#define GBB_BB(GBB) GBB->bb\n-#define GBB_SCOP(GBB) GBB->scop\n-#define GBB_STATIC_SCHEDULE(GBB) GBB->static_schedule\n-#define GBB_DATA_REFS(GBB) GBB->data_refs\n-#define GBB_ALPHA(GBB) GBB->compressed_alpha_matrix\n-#define GBB_DYNAMIC_SCHEDULE(GBB) GBB->dynamic_schedule\n-#define GBB_DOMAIN(GBB) GBB->domain\n-#define GBB_CONDITIONS(GBB) GBB->conditions\n-#define GBB_CONDITION_CASES(GBB) GBB->condition_cases\n-#define GBB_LOOPS(GBB) GBB->loops\n-#define GBB_CLOOG_IV_TYPES(GBB) GBB->cloog_iv_types\n-\n-/* Return the loop that contains the basic block GBB.  */\n-\n-static inline struct loop *\n-gbb_loop (struct graphite_bb *gbb)\n-{\n-  return GBB_BB (gbb)->loop_father;\n-}\n-\n-int nb_loops_around_gb (graphite_bb_p);\n-\n-/* Calculate the number of loops around GB in the current SCOP.  Only\n-   works if GBB_DOMAIN is built.  */\n-\n-static inline int\n-gbb_nb_loops (const struct graphite_bb *gb)\n-{\n-  scop_p scop = GBB_SCOP (gb);\n-\n-  if (GBB_DOMAIN (gb) == NULL)\n-    return 0;\n-  \n-  return GBB_DOMAIN (gb)->NbColumns - scop_nb_params (scop) - 2;\n-}\n-\n-/* Returns the gimple loop, that corresponds to the loop_iterator_INDEX.  \n-   If there is no corresponding gimple loop, we return NULL.  */\n-\n-static inline loop_p\n-gbb_loop_at_index (graphite_bb_p gb, int index)\n-{\n-  return VEC_index (loop_p, GBB_LOOPS (gb), index);\n-}\n-\n-/* Returns the index of LOOP in the loop nest around GB.  */\n-\n-static inline int\n-gbb_loop_index (graphite_bb_p gb, loop_p loop)\n-{\n-  int i;\n-  loop_p l;\n-\n-  for (i = 0; VEC_iterate (loop_p, GBB_LOOPS (gb), i, l); i++)\n-    if (loop == l)\n-      return i;\n-\n-  gcc_unreachable();\n-}\n-\n-struct loop_to_cloog_loop_str\n-{\n-  unsigned int loop_num;\n-  unsigned int loop_position; /* The column that represents this loop.  */\n-  CloogLoop *cloog_loop;\n-};\n-\n-typedef struct name_tree_d\n-{\n-  tree t;\n-  const char *name;\n-  struct loop *loop;\n-} *name_tree;\n-\n-DEF_VEC_P(name_tree);\n-DEF_VEC_ALLOC_P (name_tree, heap);\n-\n-/* A Single Entry, Single Exit region is a part of the CFG delimited\n-   by two edges.  */\n-typedef struct sese_d\n-{\n-  /* Single ENTRY and single EXIT from the SESE region.  */\n-  edge entry, exit;\n-\n-  /* REGION_BASIC_BLOCKS contains the set of all the basic blocks\n-     belonging to the SESE region.  */\n-  struct pointer_set_t *region_basic_blocks;\n-\n-  /* An SSA_NAME version is flagged in the LIVEOUT bitmap if the\n-     SSA_NAME is defined inside and used outside the SESE region.  */\n-  bitmap liveout;\n-\n-  /* The overall number of SSA_NAME versions used to index LIVEIN.  */\n-  int num_ver;\n-\n-  /* For each SSA_NAME version VER in LIVEOUT, LIVEIN[VER] contains\n-     the set of basic blocks indices that contain a use of VER.  */\n-  bitmap *livein;\n-} *sese;\n-\n-#define SESE_ENTRY(S) (S->entry)\n-#define SESE_EXIT(S) (S->exit)\n-#define SESE_REGION_BBS(S) (S->region_basic_blocks)\n-#define SESE_LIVEOUT(S) (S->liveout)\n-#define SESE_LIVEIN(S) (S->livein)\n-#define SESE_LIVEIN_VER(S, I) (S->livein[I])\n-#define SESE_NUM_VER(S) (S->num_ver)\n-\n-extern sese new_sese (edge, edge);\n-extern void free_sese (sese);\n-extern void sese_build_livein_liveouts (sese);\n-\n-/* A SCOP is a Static Control Part of the program, simple enough to be\n-   represented in polyhedral form.  */\n-struct scop\n-{\n-  /* A SCOP is defined as a SESE region.  */\n-  sese region;\n-\n-  /* All the basic blocks in this scop that contain memory references\n-     and that will be represented as statements in the polyhedral\n-     representation.  */\n-  VEC (graphite_bb_p, heap) *bbs;\n-\n-  lambda_vector static_schedule;\n-\n-  /* Parameters used within the SCOP.  */\n-  VEC (name_tree, heap) *params;\n-\n-  /* A collection of old induction variables*/ \n-  VEC (name_tree, heap) *old_ivs;\n-\n-  /* Loops completely contained in the SCOP.  */\n-  bitmap loops;\n-  VEC (loop_p, heap) *loop_nest;\n-\n-  /* ???  It looks like a global mapping loop_id -> cloog_loop would work.  */\n-  htab_t loop2cloog_loop;\n-\n-  /* Cloog representation of this scop.  */\n-  CloogProgram *program;\n-\n-  /* Are we allowed to add more params?  This is for debugging purpose.  We\n-     can only add new params before generating the bb domains, otherwise they\n-     become invalid.  */\n-  bool add_params;\n-\n-  /* LIVEOUT_RENAMES registers the rename mapping that has to be\n-     applied after code generation.  */\n-  htab_t liveout_renames;\n-};\n-\n-#define SCOP_BBS(S) S->bbs\n-#define SCOP_REGION(S) S->region\n-/* SCOP_ENTRY bb dominates all the bbs of the scop.  SCOP_EXIT bb\n-   post-dominates all the bbs of the scop.  SCOP_EXIT potentially\n-   contains non affine data accesses, side effect statements or\n-   difficult constructs, and thus is not considered part of the scop,\n-   but just a boundary.  SCOP_ENTRY is considered part of the scop.  */\n-#define SCOP_ENTRY(S) (SESE_ENTRY (SCOP_REGION (S))->dest)\n-#define SCOP_EXIT(S) (SESE_EXIT (SCOP_REGION (S))->dest)\n-#define SCOP_REGION_BBS(S) (SESE_REGION_BBS (SCOP_REGION (S)))\n-#define SCOP_STATIC_SCHEDULE(S) S->static_schedule\n-#define SCOP_LOOPS(S) S->loops\n-#define SCOP_LOOP_NEST(S) S->loop_nest\n-#define SCOP_ADD_PARAMS(S) S->add_params\n-#define SCOP_PARAMS(S) S->params\n-#define SCOP_OLDIVS(S) S->old_ivs\n-#define SCOP_PROG(S) S->program\n-#define SCOP_LOOP2CLOOG_LOOP(S) S->loop2cloog_loop\n-#define SCOP_LOOPS_MAPPING(S) S->loops_mapping\n-#define SCOP_LIVEOUT_RENAMES(S) S->liveout_renames\n-\n-extern void debug_scop (scop_p, int);\n-extern void debug_scops (int);\n-extern void print_graphite_bb (FILE *, graphite_bb_p, int, int);\n-extern void debug_gbb (graphite_bb_p, int);\n-extern void dot_scop (scop_p);\n-extern void dot_all_scops (void);\n-extern void debug_clast_stmt (struct clast_stmt *);\n-extern void debug_rename_map (htab_t);\n-extern void debug_ivtype_map (htab_t);\n-extern void debug_loop_vec (graphite_bb_p);\n-extern void debug_oldivs (scop_p);\n-\n-/* Describes the type of an iv stack entry.  */\n-typedef enum {\n-  iv_stack_entry_unknown = 0,\n-  iv_stack_entry_iv,\n-  iv_stack_entry_const\n-} iv_stack_entry_kind;\n-\n-/* Data contained in an iv stack entry.  */\n-typedef union iv_stack_entry_data_union\n-{\n-  name_tree iv;\n-  tree constant;\n-} iv_stack_entry_data;\n-\n-/* Datatype for loop iv stack entry.  */\n-typedef struct iv_stack_entry_struct\n-{\n-  iv_stack_entry_kind kind;\n-  iv_stack_entry_data data;\n-} iv_stack_entry;\n-\n-typedef iv_stack_entry *iv_stack_entry_p;\n-\n-DEF_VEC_P(iv_stack_entry_p);\n-DEF_VEC_ALLOC_P(iv_stack_entry_p,heap);\n-\n-typedef VEC(iv_stack_entry_p, heap) **loop_iv_stack;\n-extern void debug_loop_iv_stack (loop_iv_stack);\n-\n-/* Return the old induction variable of the LOOP that is in normal\n-   form in SCOP.  */\n-\n-static inline tree\n-oldiv_for_loop (scop_p scop, loop_p loop)\n-{\n-  int i;\n-  name_tree iv;\n-\n-  if (!loop)\n-    return NULL_TREE;\n-\n-  for (i = 0; VEC_iterate (name_tree, SCOP_OLDIVS (scop), i, iv); i++)\n-    if (iv->loop == loop)\n-      return iv->t;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Return the number of gimple loops contained in SCOP.  */\n-\n-static inline int\n-scop_nb_loops (scop_p scop)\n-{\n-  return VEC_length (loop_p, SCOP_LOOP_NEST (scop));\n-}\n-\n-/* Returns the number of parameters for SCOP.  */\n-\n-static inline unsigned\n-scop_nb_params (scop_p scop)\n-{\n-  return VEC_length (name_tree, SCOP_PARAMS (scop));\n-}\n-\n-/* Return the dimension of the domains for SCOP.  */\n-\n-static inline int\n-scop_dim_domain (scop_p scop)\n-{\n-  return scop_nb_loops (scop) + scop_nb_params (scop) + 1;\n-}\n-\n-/* Return the dimension of the domains for GB.  */\n-\n-static inline int\n-gbb_dim_domain (graphite_bb_p gb)\n-{\n-  return scop_dim_domain (GBB_SCOP (gb));\n-}\n-\n-/* Returns the dimensionality of a loop iteration domain for a given\n-   loop, identified by LOOP_NUM, with respect to SCOP.  */\n-\n-static inline int\n-loop_domain_dim (unsigned int loop_num, scop_p scop)\n-{\n-  struct loop_to_cloog_loop_str tmp, *slot; \n-  htab_t tab = SCOP_LOOP2CLOOG_LOOP (scop);\n-\n-  tmp.loop_num = loop_num;\n-  slot = (struct loop_to_cloog_loop_str *) htab_find (tab, &tmp);\n-\n-  /* The loop containing the entry of the scop is not always part of\n-     the SCoP, and it is not registered in SCOP_LOOP2CLOOG_LOOP.  */\n-  if (!slot)\n-    return scop_nb_params (scop) + 2;\n-\n-  return cloog_domain_dim (cloog_loop_domain (slot->cloog_loop)) + 2;\n-}\n-\n-/* Returns the dimensionality of a loop iteration vector in a loop\n-   iteration domain for a given loop (identified by LOOP_NUM) with\n-   respect to SCOP.  */\n-\n-static inline int\n-loop_iteration_vector_dim (unsigned int loop_num, scop_p scop)\n-{\n-  return loop_domain_dim (loop_num, scop) - 2 - scop_nb_params (scop);\n-}\n-\n-/* Checks, if SCOP contains LOOP.  */\n-\n-static inline bool\n-scop_contains_loop (scop_p scop, struct loop *loop)\n-{\n-  return bitmap_bit_p (SCOP_LOOPS (scop), loop->num);\n-}\n-\n-/* Returns the index of LOOP in the domain matrix for the SCOP.  */\n-\n-static inline int\n-scop_loop_index (scop_p scop, struct loop *loop)\n-{\n-  unsigned i;\n-  struct loop *l;\n-\n-  gcc_assert (scop_contains_loop (scop, loop));\n-\n-  for (i = 0; VEC_iterate (loop_p, SCOP_LOOP_NEST (scop), i, l); i++)\n-    if (l == loop)\n-      return i;\n-\n-  gcc_unreachable();\n-}\n-\n-/* Return the index of innermost loop that contains the basic block\n-   GBB.  */\n-\n-static inline int\n-gbb_inner_most_loop_index (scop_p scop, graphite_bb_p gb)\n-{\n-  return scop_loop_index(scop, gbb_loop (gb));\n-}\n-\n-/* Return the outermost loop that contains the loop LOOP.  The outer\n-   loops are searched until a sibling for the outer loop is found.  */\n-\n-static struct loop *\n-outer_most_loop_1 (scop_p scop, struct loop* loop, struct loop* current_outer)\n-{\n-  return (!scop_contains_loop (scop, loop)) ? current_outer :\n-    (loop->next != NULL) ? loop :\n-    outer_most_loop_1 (scop, loop_outer (loop), loop);\n-}\n-\n-/* Return the outermost loop that contains the loop LOOP.  */\n-\n-static struct loop *\n-outer_most_loop (scop_p scop, struct loop *loop)\n-{\n-  return outer_most_loop_1 (scop, loop, NULL);\n-}\n-\n-/* Return the index of the outermost loop that contains the basic\n-   block BB.  */\n-\n-static inline int\n-gbb_outer_most_loop_index (scop_p scop, graphite_bb_p gb)\n-{\n-  return scop_loop_index (scop, outer_most_loop (scop, gbb_loop (gb)));\n-}\n-\n-/* Return the loop depth of LOOP in SCOP.  */\n-\n-static inline unsigned int\n-scop_gimple_loop_depth (scop_p scop, loop_p loop)\n-{\n-  unsigned int depth = 0;\n-\n-  loop = loop_outer (loop);\n-\n-  while (scop_contains_loop (scop, loop))\n-    {\n-      depth++;\n-      loop = loop_outer (loop);\n-    }\n-\n-  return depth;\n-}\n-\n #endif  /* GCC_GRAPHITE_H  */"}, {"sha": "8d5ec3eeb7c4e1db32673a85288810e1f57c1768", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -658,6 +658,11 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_loop_distribution);\n \t  NEXT_PASS (pass_linear_transform);\n \t  NEXT_PASS (pass_graphite_transforms);\n+\t    {\n+\t      struct opt_pass **p = &pass_graphite_transforms.pass.sub;\n+\t      NEXT_PASS (pass_dce_loop);\n+\t      NEXT_PASS (pass_lim);\n+\t    }\n \t  NEXT_PASS (pass_iv_canon);\n \t  NEXT_PASS (pass_if_conversion);\n \t  NEXT_PASS (pass_vectorize);"}, {"sha": "3b6fd74128043a6fc29e6070528d1047446071bf", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -1801,7 +1801,8 @@ process_options (void)\n       || flag_loop_block\n       || flag_loop_interchange\n       || flag_loop_strip_mine\n-      || flag_graphite_identity)\n+      || flag_graphite_identity\n+      || flag_graphite_force_parallel)\n     sorry (\"Graphite loop optimizations cannot be used\");\n #endif\n \n@@ -2046,7 +2047,7 @@ process_options (void)\n   if (flag_signaling_nans)\n     flag_trapping_math = 1;\n \n-  /* We cannot reassociate if we want traps or signed zeros. \ufffd*/\n+  /* We cannot reassociate if we want traps or signed zeros.  */\n   if (flag_associative_math && (flag_trapping_math || flag_signed_zeros))\n     {\n       warning (0, \"-fassociative-math disabled; other options take precedence\");"}, {"sha": "cac6d6d35cdfd22bf4bac26c8a1f12e2330edb99", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/204b560f29f5d932a89a349ea0f1300cbba70d84/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=204b560f29f5d932a89a349ea0f1300cbba70d84", "patch": "@@ -36,6 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"tree-inline.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"toplev.h\"\n #include \"tree-vectorizer.h\"\n \n /* The loop superpass.  */\n@@ -307,9 +308,12 @@ gate_graphite_transforms (void)\n   /* Enable -fgraphite pass if any one of the graphite optimization flags \n      is turned on.  */\n   if (flag_loop_block || flag_loop_interchange || flag_loop_strip_mine\n-      || flag_graphite_identity)\n+      || flag_graphite_identity || flag_graphite_force_parallel)\n     flag_graphite = 1;\n \n+  if (flag_loop_block)\n+    sorry (\"loop blocking not implemented\");\n+\n   return flag_graphite != 0;\n }\n "}]}