{"sha": "b17e287057a8d64d65c30fda457085689ea1ef0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE3ZTI4NzA1N2E4ZDY0ZDY1YzMwZmRhNDU3MDg1Njg5ZWExZWYwZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-04-09T12:44:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-04-09T12:44:53Z"}, "message": "decl.c (start_decl): Pass attributes to grokdeclarator.\n\n\t* decl.c (start_decl): Pass attributes to grokdeclarator.\n\t(grokdeclarator): Handle attributes on constructor-syntax\n\tinitializers.\n\nFrom-SVN: r26313", "tree": {"sha": "de7d86cbb58875066c35ac3be5467ebf7ec1070c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de7d86cbb58875066c35ac3be5467ebf7ec1070c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b17e287057a8d64d65c30fda457085689ea1ef0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b17e287057a8d64d65c30fda457085689ea1ef0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b17e287057a8d64d65c30fda457085689ea1ef0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b17e287057a8d64d65c30fda457085689ea1ef0e/comments", "author": null, "committer": null, "parents": [{"sha": "09a076233d68120a839c7c4449dbb2b2b0ce3f7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a076233d68120a839c7c4449dbb2b2b0ce3f7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09a076233d68120a839c7c4449dbb2b2b0ce3f7a"}], "stats": {"total": 111, "additions": 71, "deletions": 40}, "files": [{"sha": "8a85396b40222361203a4cf1834615aee83ac80d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17e287057a8d64d65c30fda457085689ea1ef0e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17e287057a8d64d65c30fda457085689ea1ef0e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b17e287057a8d64d65c30fda457085689ea1ef0e", "patch": "@@ -1,3 +1,9 @@\n+1999-04-09  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (start_decl): Pass attributes to grokdeclarator.\n+\t(grokdeclarator): Handle attributes on constructor-syntax\n+\tinitializers.\n+\n 1999-04-08  Mark Mitchell  <mark@codesourcery.com>\n \n \t* error.c (dump_expr): Don't crash on INDIRECT_REFs whose operands"}, {"sha": "e50c90a22cdba2bc13cb5f19ee84211b8654baee", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b17e287057a8d64d65c30fda457085689ea1ef0e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b17e287057a8d64d65c30fda457085689ea1ef0e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b17e287057a8d64d65c30fda457085689ea1ef0e", "patch": "@@ -6975,6 +6975,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n   tree context;\n   extern int have_extern_spec;\n   extern int used_extern_spec;\n+  tree attrlist;\n \n #if 0\n   /* See code below that used this.  */\n@@ -6989,8 +6990,14 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n       used_extern_spec = 1;\n     }\n \n+  if (attributes || prefix_attributes)\n+    attrlist = build_scratch_list (attributes, prefix_attributes);\n+  else\n+    attrlist = NULL_TREE;\n+\n   decl = grokdeclarator (declarator, declspecs, NORMAL, initialized,\n-\t\t\t NULL_TREE);\n+\t\t\t attrlist);\n+\t\t\t \n   if (decl == NULL_TREE || TREE_CODE (decl) == VOID_TYPE)\n     return NULL_TREE;\n \n@@ -8900,6 +8907,41 @@ build_ptrmemfunc_type (type)\n   return t;\n }\n \n+/* DECL is a VAR_DECL defined in-class, whose TYPE is also given.\n+   Check to see that the definition is valid.  Issue appropriate error\n+   messages.  Return 1 if the definition is particularly bad, or 0\n+   otherwise.  */\n+\n+int\n+check_static_variable_definition (decl, type)\n+     tree decl;\n+     tree type;\n+{\n+  /* Motion 10 at San Diego: If a static const integral data member is\n+     initialized with an integral constant expression, the initializer\n+     may appear either in the declaration (within the class), or in\n+     the definition, but not both.  If it appears in the class, the\n+     member is a member constant.  The file-scope definition is always\n+     required.  */\n+  if (CLASS_TYPE_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      cp_error (\"in-class initialization of static data member of non-integral type `%T'\", \n+\t\ttype);\n+      /* If we just return the declaration, crashes will sometimes\n+\t occur.  We therefore return void_type_node, as if this was a\n+\t friend declaration, to cause callers to completely ignore\n+\t this declaration.  */\n+      return 1;\n+    }\n+  else if (!CP_TYPE_CONST_P (type))\n+    cp_error (\"ANSI C++ forbids in-class initialization of non-const static member `%D'\",\n+\t      decl);\n+  else if (pedantic && !INTEGRAL_TYPE_P (type))\n+    cp_pedwarn (\"ANSI C++ forbids initialization of member constant `%D' of non-integral type `%T'\", decl, type);\n+\n+  return 0;\n+}\n+\n /* Given declspecs and a declarator,\n    determine the name and type of the object declared\n    and construct a ..._DECL node for it.\n@@ -8927,6 +8969,9 @@ build_ptrmemfunc_type (type)\n      BITFIELD for a field with specified width.\n    INITIALIZED is 1 if the decl has an initializer.\n \n+   ATTRLIST is a TREE_LIST node with prefix attributes in TREE_VALUE and\n+   normal attributes in TREE_PURPOSE, or NULL_TREE.\n+\n    In the TYPENAME case, DECLARATOR is really an absolute declarator.\n    It may also be so in the PARM case, for a prototype where the\n    argument type is specified but not the name.\n@@ -8958,41 +9003,6 @@ build_ptrmemfunc_type (type)\n \n enum return_types { return_normal, return_ctor, return_dtor, return_conversion };\n \n-/* DECL is a VAR_DECL defined in-class, whose TYPE is also given.\n-   Check to see that the definition is valid.  Issue appropriate error\n-   messages.  Return 1 if the definition is particularly bad, or 0\n-   otherwise.  */\n-\n-int\n-check_static_variable_definition (decl, type)\n-     tree decl;\n-     tree type;\n-{\n-  /* Motion 10 at San Diego: If a static const integral data member is\n-     initialized with an integral constant expression, the initializer\n-     may appear either in the declaration (within the class), or in\n-     the definition, but not both.  If it appears in the class, the\n-     member is a member constant.  The file-scope definition is always\n-     required.  */\n-  if (CLASS_TYPE_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      cp_error (\"in-class initialization of static data member of non-integral type `%T'\", \n-\t\ttype);\n-      /* If we just return the declaration, crashes will sometimes\n-\t occur.  We therefore return void_type_node, as if this was a\n-\t friend declaration, to cause callers to completely ignore\n-\t this declaration.  */\n-      return 1;\n-    }\n-  else if (!CP_TYPE_CONST_P (type))\n-    cp_error (\"ANSI C++ forbids in-class initialization of non-const static member `%D'\",\n-\t      decl);\n-  else if (pedantic && !INTEGRAL_TYPE_P (type))\n-    cp_pedwarn (\"ANSI C++ forbids initialization of member constant `%D' of non-integral type `%T'\", decl, type);\n-\n-  return 0;\n-}\n-\n tree\n grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      tree declspecs;\n@@ -9129,14 +9139,29 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  case CALL_EXPR:\n \t    if (parmlist_is_exprlist (TREE_OPERAND (decl, 1)))\n \t      {\n-\t\t/* This is actually a variable declaration using constructor\n-\t\t   syntax.  We need to call start_decl and cp_finish_decl so we\n-\t\t   can get the variable initialized...  */\n+\t\t/* This is actually a variable declaration using\n+\t\t   constructor syntax.  We need to call start_decl and\n+\t\t   cp_finish_decl so we can get the variable\n+\t\t   initialized...  */\n+\n+\t\ttree attributes, prefix_attributes;\n \n \t\t*next = TREE_OPERAND (decl, 0);\n \t\tinit = TREE_OPERAND (decl, 1);\n \n-\t\tdecl = start_decl (declarator, declspecs, 1, NULL_TREE, NULL_TREE);\n+\t\tif (attrlist)\n+\t\t  {\n+\t\t    attributes = TREE_PURPOSE (attrlist);\n+\t\t    prefix_attributes = TREE_VALUE (attrlist);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    attributes = NULL_TREE;\n+\t\t    prefix_attributes = NULL_TREE;\n+\t\t  }\n+\n+\t\tdecl = start_decl (declarator, declspecs, 1,\n+\t\t\t\t   attributes, prefix_attributes);\n \t\tif (decl)\n \t\t  {\n \t\t    /* Look for __unused__ attribute */"}]}