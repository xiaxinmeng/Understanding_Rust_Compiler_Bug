{"sha": "ce6a6c007e5a985e64fd6293b9606420debe50f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U2YTZjMDA3ZTVhOTg1ZTY0ZmQ2MjkzYjk2MDY0MjBkZWJlNTBmNQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2019-11-11T23:00:03Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2019-11-11T23:00:03Z"}, "message": "Add prefixed insn support for stack_protect_setdi & stack_protect_testdi\n\n2019-11-11  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/predicates.md (prefixed_memory): New predicate.\n\t* config/rs6000/rs6000.md (stack_protect_setdi): Deal with either\n\taddress being a prefixed load/store.\n\t(stack_protect_testdi): Deal with either address being a prefixed\n\tload.\n\nFrom-SVN: r278069", "tree": {"sha": "42a39c6d9db8326c78ea9ad1aa3901405c837985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42a39c6d9db8326c78ea9ad1aa3901405c837985"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce6a6c007e5a985e64fd6293b9606420debe50f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce6a6c007e5a985e64fd6293b9606420debe50f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce6a6c007e5a985e64fd6293b9606420debe50f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce6a6c007e5a985e64fd6293b9606420debe50f5/comments", "author": null, "committer": null, "parents": [{"sha": "48042bd43e0b0407748a110ef8e917827f0fe422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48042bd43e0b0407748a110ef8e917827f0fe422", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48042bd43e0b0407748a110ef8e917827f0fe422"}], "stats": {"total": 95, "additions": 89, "deletions": 6}, "files": [{"sha": "9852383d8e892533ebbaaf822776b3cf1dd47b7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce6a6c007e5a985e64fd6293b9606420debe50f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce6a6c007e5a985e64fd6293b9606420debe50f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce6a6c007e5a985e64fd6293b9606420debe50f5", "patch": "@@ -1,3 +1,11 @@\n+2019-11-11  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/predicates.md (prefixed_memory): New predicate.\n+\t* config/rs6000/rs6000.md (stack_protect_setdi): Deal with either\n+\taddress being a prefixed load/store.\n+\t(stack_protect_testdi): Deal with either address being a prefixed\n+\tload.\n+\n 2019-11-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/92433"}, {"sha": "b5c510f99f211961a83ea3a6d96667c57f0664ca", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce6a6c007e5a985e64fd6293b9606420debe50f5/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce6a6c007e5a985e64fd6293b9606420debe50f5/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=ce6a6c007e5a985e64fd6293b9606420debe50f5", "patch": "@@ -1828,3 +1828,10 @@\n (define_predicate \"pcrel_local_or_external_address\"\n   (ior (match_operand 0 \"pcrel_local_address\")\n        (match_operand 0 \"pcrel_external_address\")))\n+\n+;; Return true if the operand is a memory address that uses a prefixed address.\n+(define_predicate \"prefixed_memory\"\n+  (match_code \"mem\")\n+{\n+  return address_is_prefixed (XEXP (op, 0), mode, NON_PREFIXED_DEFAULT);\n+})"}, {"sha": "e1db6ad2f45c816d93796b2583d844788c72000c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 74, "deletions": 6, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce6a6c007e5a985e64fd6293b9606420debe50f5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce6a6c007e5a985e64fd6293b9606420debe50f5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ce6a6c007e5a985e64fd6293b9606420debe50f5", "patch": "@@ -11536,14 +11536,44 @@\n   [(set_attr \"type\" \"three\")\n    (set_attr \"length\" \"12\")])\n \n+;; We can't use the prefixed attribute here because there are two memory\n+;; instructions.  We can't split the insn due to the fact that this operation\n+;; needs to be done in one piece.\n (define_insn \"stack_protect_setdi\"\n   [(set (match_operand:DI 0 \"memory_operand\" \"=Y\")\n \t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"Y\")] UNSPEC_SP_SET))\n    (set (match_scratch:DI 2 \"=&r\") (const_int 0))]\n   \"TARGET_64BIT\"\n-  \"ld%U1%X1 %2,%1\\;std%U0%X0 %2,%0\\;li %2,0\"\n+{\n+  if (prefixed_memory (operands[1], DImode))\n+    output_asm_insn (\"pld %2,%1\", operands);\n+  else\n+    output_asm_insn (\"ld%U1%X1 %2,%1\", operands);\n+\n+  if (prefixed_memory (operands[0], DImode))\n+    output_asm_insn (\"pstd %2,%0\", operands);\n+  else\n+    output_asm_insn (\"std%U0%X0 %2,%0\", operands);\n+\n+  return \"li %2,0\";\n+}\n   [(set_attr \"type\" \"three\")\n-   (set_attr \"length\" \"12\")])\n+\n+  ;; Back to back prefixed memory instructions take 20 bytes (8 bytes for each\n+  ;; prefixed instruction + 4 bytes for the possible NOP).  Add in 4 bytes for\n+  ;; the LI 0 at the end.\n+   (set_attr \"prefixed\" \"no\")\n+   (set_attr \"num_insns\" \"3\")\n+   (set (attr \"length\")\n+\t(cond [(and (match_operand 0 \"prefixed_memory\")\n+\t\t    (match_operand 1 \"prefixed_memory\"))\n+\t       (const_int 24)\n+\n+\t       (ior (match_operand 0 \"prefixed_memory\")\n+\t\t    (match_operand 1 \"prefixed_memory\"))\n+\t       (const_int 20)]\n+\n+\t      (const_int 12)))])\n \n (define_expand \"stack_protect_test\"\n   [(match_operand 0 \"memory_operand\")\n@@ -11582,6 +11612,9 @@\n    lwz%U1%X1 %3,%1\\;lwz%U2%X2 %4,%2\\;cmplw %0,%3,%4\\;li %3,0\\;li %4,0\"\n   [(set_attr \"length\" \"16,20\")])\n \n+;; We can't use the prefixed attribute here because there are two memory\n+;; instructions.  We can't split the insn due to the fact that this operation\n+;; needs to be done in one piece.\n (define_insn \"stack_protect_testdi\"\n   [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=x,?y\")\n         (unspec:CCEQ [(match_operand:DI 1 \"memory_operand\" \"Y,Y\")\n@@ -11590,10 +11623,45 @@\n    (set (match_scratch:DI 4 \"=r,r\") (const_int 0))\n    (clobber (match_scratch:DI 3 \"=&r,&r\"))]\n   \"TARGET_64BIT\"\n-  \"@\n-   ld%U1%X1 %3,%1\\;ld%U2%X2 %4,%2\\;xor. %3,%3,%4\\;li %4,0\n-   ld%U1%X1 %3,%1\\;ld%U2%X2 %4,%2\\;cmpld %0,%3,%4\\;li %3,0\\;li %4,0\"\n-  [(set_attr \"length\" \"16,20\")])\n+{\n+  if (prefixed_memory (operands[1], DImode))\n+    output_asm_insn (\"pld %3,%1\", operands);\n+  else\n+    output_asm_insn (\"ld%U1%X1 %3,%1\", operands);\n+\n+  if (prefixed_memory (operands[2], DImode))\n+    output_asm_insn (\"pld %4,%2\", operands);\n+  else\n+    output_asm_insn (\"ld%U2%X2 %4,%2\", operands);\n+\n+  if (which_alternative == 0)\n+    output_asm_insn (\"xor. %3,%3,%4\", operands);\n+  else\n+    output_asm_insn (\"cmpld %0,%3,%4\\;li %3,0\", operands);\n+\n+  return \"li %4,0\";\n+}\n+  ;; Back to back prefixed memory instructions take 20 bytes (8 bytes for each\n+  ;; prefixed instruction + 4 bytes for the possible NOP).  Add in either 4 or\n+  ;; 8 bytes to do the test.\n+  [(set_attr \"prefixed\" \"no\")\n+   (set_attr \"num_insns\" \"4,5\")\n+   (set (attr \"length\")\n+\t(cond [(and (match_operand 1 \"prefixed_memory\")\n+\t\t    (match_operand 2 \"prefixed_memory\"))\n+\t       (if_then_else (eq_attr \"alternative\" \"0\")\n+\t\t\t     (const_int 28)\n+\t\t\t     (const_int 32))\n+\n+\t       (ior (match_operand 1 \"prefixed_memory\")\n+\t\t    (match_operand 2 \"prefixed_memory\"))\n+\t       (if_then_else (eq_attr \"alternative\" \"0\")\n+\t\t\t     (const_int 20)\n+\t\t\t     (const_int 24))]\n+\n+\t      (if_then_else (eq_attr \"alternative\" \"0\")\n+\t\t\t    (const_int 16)\n+\t\t\t    (const_int 20))))])\n \n \f\n ;; Here are the actual compare insns."}]}