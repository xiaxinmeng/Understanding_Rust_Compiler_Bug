{"sha": "dc2faee140907409050417fc38004d94dd40ed22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyZmFlZTE0MDkwNzQwOTA1MDQxN2ZjMzgwMDRkOTRkZDQwZWQyMg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2013-11-14T18:24:32Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2013-11-14T18:24:32Z"}, "message": "rs6000.c (rs6000_emit_prologue): Do not place a RTX_FRAME_RELATED_P marker on the UNSPEC_MOVESI_FROM_CR insn.\n\nChangeLog:\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Do not place a\n\tRTX_FRAME_RELATED_P marker on the UNSPEC_MOVESI_FROM_CR insn.\n\tInstead, add USEs of all modified call-saved CR fields to the\n\tinsn storing the result to the stack slot, and provide an\n\tappropriate REG_FRAME_RELATED_EXPR for that insn.\n\t* config/rs6000/rs6000.md (\"*crsave\"): New insn pattern.\n\t* config/rs6000/predicates.md (\"crsave_operation\"): New predicate.\n\ntestsuite/ChangeLog:\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* g++.dg/eh/ppc64-sighandle-cr.C: New test.\n\nFrom-SVN: r204799", "tree": {"sha": "8360121d17838e511bb95f7c3b74096a7e800aa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8360121d17838e511bb95f7c3b74096a7e800aa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc2faee140907409050417fc38004d94dd40ed22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2faee140907409050417fc38004d94dd40ed22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc2faee140907409050417fc38004d94dd40ed22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc2faee140907409050417fc38004d94dd40ed22/comments", "author": null, "committer": null, "parents": [{"sha": "2e4ceca56c268b4d4d4aa093f9227b70bd2d6580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4ceca56c268b4d4d4aa093f9227b70bd2d6580", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e4ceca56c268b4d4d4aa093f9227b70bd2d6580"}], "stats": {"total": 116, "additions": 91, "deletions": 25}, "files": [{"sha": "307ac548e56473e0432b79abd32b15458d45859e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2faee140907409050417fc38004d94dd40ed22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2faee140907409050417fc38004d94dd40ed22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc2faee140907409050417fc38004d94dd40ed22", "patch": "@@ -1,3 +1,13 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Do not place a\n+\tRTX_FRAME_RELATED_P marker on the UNSPEC_MOVESI_FROM_CR insn.\n+\tInstead, add USEs of all modified call-saved CR fields to the\n+\tinsn storing the result to the stack slot, and provide an\n+\tappropriate REG_FRAME_RELATED_EXPR for that insn.\n+\t* config/rs6000/rs6000.md (\"*crsave\"): New insn pattern.\n+\t* config/rs6000/predicates.md (\"crsave_operation\"): New predicate.\n+\n 2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \t    Alan Modra  <amodra@gmail.com>\n "}, {"sha": "3f46001daf63309bd67277b32791ae2565460587", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2faee140907409050417fc38004d94dd40ed22/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2faee140907409050417fc38004d94dd40ed22/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=dc2faee140907409050417fc38004d94dd40ed22", "patch": "@@ -1538,6 +1538,26 @@\n   return 1;\n })\n \n+;; Return 1 if OP is valid for crsave insn, known to be a PARALLEL.\n+(define_predicate \"crsave_operation\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  int i;\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx exp = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (exp) != USE\n+\t  || GET_CODE (XEXP (exp, 0)) != REG\n+\t  || GET_MODE (XEXP (exp, 0)) != CCmode\n+\t  || ! CR_REGNO_P (REGNO (XEXP (exp, 0))))\n+\treturn 0;\n+    }\n+  return 1;\n+})\n+\n ;; Return 1 if OP is valid for lmw insn, known to be a PARALLEL.\n (define_predicate \"lmw_operation\"\n   (match_code \"parallel\")"}, {"sha": "1628bf31a1b4605d354f87277644e33b32b35768", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2faee140907409050417fc38004d94dd40ed22/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2faee140907409050417fc38004d94dd40ed22/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dc2faee140907409050417fc38004d94dd40ed22", "patch": "@@ -21766,21 +21766,9 @@ rs6000_emit_prologue (void)\n       && REGNO (frame_reg_rtx) != cr_save_regno\n       && !(using_static_chain_p && cr_save_regno == 11))\n     {\n-      rtx set;\n-\n       cr_save_rtx = gen_rtx_REG (SImode, cr_save_regno);\n       START_USE (cr_save_regno);\n-      insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      /* Now, there's no way that dwarf2out_frame_debug_expr is going\n-\t to understand '(unspec:SI [(reg:CC 68) ...] UNSPEC_MOVESI_FROM_CR)'.\n-\t But that's OK.  All we have to do is specify that _one_ condition\n-\t code register is saved in this stack slot.  The thrower's epilogue\n-\t will then restore all the call-saved registers.\n-\t We use CR2_REGNO (70) to be compatible with gcc-2.95 on Linux.  */\n-      set = gen_rtx_SET (VOIDmode, cr_save_rtx,\n-\t\t\t gen_rtx_REG (SImode, CR2_REGNO));\n-      add_reg_note (insn, REG_FRAME_RELATED_EXPR, set);\n+      emit_insn (gen_movesi_from_cr (cr_save_rtx));\n     }\n \n   /* Do any required saving of fpr's.  If only one or two to save, do\n@@ -22091,26 +22079,62 @@ rs6000_emit_prologue (void)\n       rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n \t\t\t       GEN_INT (info->cr_save_offset + frame_off));\n       rtx mem = gen_frame_mem (SImode, addr);\n-      /* See the large comment above about why CR2_REGNO is used.  */\n-      rtx magic_eh_cr_reg = gen_rtx_REG (SImode, CR2_REGNO);\n \n       /* If we didn't copy cr before, do so now using r0.  */\n       if (cr_save_rtx == NULL_RTX)\n \t{\n-\t  rtx set;\n-\n \t  START_USE (0);\n \t  cr_save_rtx = gen_rtx_REG (SImode, 0);\n-\t  insn = emit_insn (gen_movesi_from_cr (cr_save_rtx));\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  set = gen_rtx_SET (VOIDmode, cr_save_rtx, magic_eh_cr_reg);\n-\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, set);\n-\t}\n-      insn = emit_move_insn (mem, cr_save_rtx);\n+\t  emit_insn (gen_movesi_from_cr (cr_save_rtx));\n+\t}\n+\n+      /* Saving CR requires a two-instruction sequence: one instruction\n+\t to move the CR to a general-purpose register, and a second\n+\t instruction that stores the GPR to memory.\n+\n+\t We do not emit any DWARF CFI records for the first of these,\n+\t because we cannot properly represent the fact that CR is saved in\n+\t a register.  One reason is that we cannot express that multiple\n+\t CR fields are saved; another reason is that on 64-bit, the size\n+\t of the CR register in DWARF (4 bytes) differs from the size of\n+\t a general-purpose register.\n+\n+\t This means if any intervening instruction were to clobber one of\n+\t the call-saved CR fields, we'd have incorrect CFI.  To prevent\n+\t this from happening, we mark the store to memory as a use of\n+\t those CR fields, which prevents any such instruction from being\n+\t scheduled in between the two instructions.  */\n+      rtx crsave_v[9];\n+      int n_crsave = 0;\n+      int i;\n+\n+      crsave_v[n_crsave++] = gen_rtx_SET (VOIDmode, mem, cr_save_rtx);\n+      for (i = 0; i < 8; i++)\n+\tif (save_reg_p (CR0_REGNO + i))\n+\t  crsave_v[n_crsave++]\n+\t    = gen_rtx_USE (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO + i));\n+\n+      insn = emit_insn (gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t\t  gen_rtvec_v (n_crsave, crsave_v)));\n       END_USE (REGNO (cr_save_rtx));\n \n-      rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n-\t\t\t    NULL_RTX, NULL_RTX);\n+      /* Now, there's no way that dwarf2out_frame_debug_expr is going to\n+\t understand '(unspec:SI [(reg:CC 68) ...] UNSPEC_MOVESI_FROM_CR)',\n+\t so we need to construct a frame expression manually.  */\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* Update address to be stack-pointer relative, like\n+\t rs6000_frame_related would do.  */\n+      addr = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, STACK_POINTER_REGNUM),\n+\t\t\t   GEN_INT (info->cr_save_offset + sp_off));\n+      mem = gen_frame_mem (SImode, addr);\n+\n+      /* We still cannot express that multiple CR fields are saved in the\n+\t CR save slot.  By convention, we use a single CR regnum to represent\n+\t the fact that all call-saved CR fields are saved.  We use CR2_REGNO\n+\t to be compatible with gcc-2.95 on Linux.  */\n+      rtx set = gen_rtx_SET (VOIDmode, mem, gen_rtx_REG (SImode, CR2_REGNO));\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, set);\n     }\n \n   /* Update stack and set back pointer unless this is V.4,"}, {"sha": "20204682069ec6d1366c5b50a5eb414995c2564c", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2faee140907409050417fc38004d94dd40ed22/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2faee140907409050417fc38004d94dd40ed22/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=dc2faee140907409050417fc38004d94dd40ed22", "patch": "@@ -15035,6 +15035,14 @@\n   \"mfcr %0\"\n   [(set_attr \"type\" \"mfcr\")])\n \n+(define_insn \"*crsave\"\n+  [(match_parallel 0 \"crsave_operation\"\n+\t\t   [(set (match_operand:SI 1 \"memory_operand\" \"=m\")\n+\t\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))])]\n+  \"\"\n+  \"stw %2,%1\"\n+  [(set_attr \"type\" \"store\")])\n+\n (define_insn \"*stmw\"\n   [(match_parallel 0 \"stmw_operation\"\n \t\t   [(set (match_operand:SI 1 \"memory_operand\" \"=m\")"}, {"sha": "be9a3a56b99dac6e510e9cfa3af92c769fbfde3a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc2faee140907409050417fc38004d94dd40ed22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc2faee140907409050417fc38004d94dd40ed22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc2faee140907409050417fc38004d94dd40ed22", "patch": "@@ -1,3 +1,7 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* g++.dg/eh/ppc64-sighandle-cr.C: New test.\n+\n 2013-11-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.dg/torture/float128-cmp-invalid.c: Require fenv_exceptions."}]}