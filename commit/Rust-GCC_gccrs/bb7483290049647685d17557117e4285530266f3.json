{"sha": "bb7483290049647685d17557117e4285530266f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI3NDgzMjkwMDQ5NjQ3Njg1ZDE3NTU3MTE3ZTQyODU1MzAyNjZmMw==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2005-06-10T14:52:01Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2005-06-10T14:52:01Z"}, "message": "tree-vect-analyze.c (vect_analyze_data_ref_dependence): DRs whose dependence-distance modulo VF is 0 are recorded in the...\n\n        * tree-vect-analyze.c (vect_analyze_data_ref_dependence): DRs whose\n        dependence-distance modulo VF is 0 are recorded in the\n        SAME_ALIGN_REFs VEC in each DR.\n        (vect_enhance_data_refs_alignment): Avoid 80 column overflow. The\n        alignment information of DRs that are in the SAME_ALIGN_REFs VEC of the\n        DR we want to peel for, is set to 0.\n        * tree-vect-transform.c (vect_do_peeling_for_loop_bound): Fix printout.\n        * tree-vectorizer.c (destroy_loop_vec_info): Free the SAME_ALIGN_REFs\n        VEC.\n        * tree-vectorizer.h (dr_p): New type. Defined to use the VEC API.\n        (_stmt_vec_info): Added new field same_align_refs.\n        (STMT_VINFO_SAME_ALIGN_REFS): New macro.\n\nFrom-SVN: r100817", "tree": {"sha": "57c8ef6636055daf9e83a4e162b8bca978e69d33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57c8ef6636055daf9e83a4e162b8bca978e69d33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb7483290049647685d17557117e4285530266f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb7483290049647685d17557117e4285530266f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb7483290049647685d17557117e4285530266f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb7483290049647685d17557117e4285530266f3/comments", "author": null, "committer": null, "parents": [{"sha": "cdd5a1bebee6ddca1324d85535f6a1f82ba9cede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdd5a1bebee6ddca1324d85535f6a1f82ba9cede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdd5a1bebee6ddca1324d85535f6a1f82ba9cede"}], "stats": {"total": 163, "additions": 146, "deletions": 17}, "files": [{"sha": "13c5668e3bce09ca533d03af7138b249f3c02710", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -1,3 +1,18 @@\n+2005-06-10  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence): DRs whose\n+\tdependence-distance modulo VF is 0 are recorded in the \n+\tSAME_ALIGN_REFs VEC in each DR.\n+\t(vect_enhance_data_refs_alignment): Avoid 80 column overflow. The\n+\talignment information of DRs that are in the SAME_ALIGN_REFs VEC of the\n+\tDR we want to peel for, is set to 0.\n+\t* tree-vect-transform.c (vect_do_peeling_for_loop_bound): Fix printout.\n+\t* tree-vectorizer.c (destroy_loop_vec_info): Free the SAME_ALIGN_REFs\n+\tVEC.\n+\t* tree-vectorizer.h (dr_p): New type. Defined to use the VEC API.\n+\t(_stmt_vec_info): Added new field same_align_refs.\n+\t(STMT_VINFO_SAME_ALIGN_REFS): New macro.\n+\n 2005-06-10  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* vec.h (VEC_safe_grow): Append MEM_STAT_INFO."}, {"sha": "5c33debf4215366287ecce8ba87bd8b03b289b53", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -1,3 +1,14 @@\n+2005-06-10  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gfortran.dg/vect/vect-4.f90: Update comments. Only one unaligned\n+\taccess will be generated when this loop is vectorized. Test that\n+\taccesses with same alignment were detected.\n+\t* gcc.dg/vect/vect-dv-2.c: Remove \"vect_no_align\" from xfail.\n+\tTest that accesses with same alignment were detected.\n+\t* gcc.dg/vect/vect-ifcvt-1.c: Likewise.\n+\t* gcc.dg/vect/vect-91.c: New test. Test that accesses with same \n+\talignment were detected.\n+\n 2005-06-09  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* gcc.dg/Wcxx-compat-1.c: New."}, {"sha": "80afd692d354209ee1adb916ed6b0fe781fc27fd", "filename": "gcc/testsuite/gcc.dg/vect/vect-91.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 256\n+\n+extern int a[N];\n+\n+/* The alignment of 'pa' is unknown. \n+   Yet we do know that both the read access and write access have \n+   the same alignment. Peeling to align one of the accesses will \n+   align the other.\n+\n+   Not vectorized yet due to problems in dataref analysis that\n+   are fixed in autovect-branch but not yet in mainline.  */\n+\n+int\n+main1 (int * pa)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      pa[i] = pa[i] + 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* The alignment of 'a' is unknown. \n+   Yet we do know that both the read access and write access have \n+   the same alignment. Peeling to align one of the accesses will \n+   align the other.  */\n+\n+int\n+main2 ()\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = a[i] + 1;\n+    }\n+\n+  return 0;\n+}\n+\n+int \n+main3 ()\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = a[i+20];\n+    }\n+\n+  return 0;\n+}\n+\n+/* Currently only the loops in main2 and main3 get vectorized. After the merge \n+   of the datarefs-analysis cleanups from autovect-branch to mainline, the loop\n+   in main1 will also be vectorized.  */ \n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "69d619ed1ea66a6ffd6271e1ee5facdae54f62f2", "filename": "gcc/testsuite/gcc.dg/vect/vect-dv-2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-dv-2.c?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -69,5 +69,6 @@ int main ()\n \n \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 2 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7b40998568bad836e947a978ddda47c724aa5d62", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-1.c?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -70,5 +70,6 @@ int main ()\n \n \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 2 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e83c05c5e50b756d0c8578d88b9b7044dd1f90b3", "filename": "gcc/testsuite/gfortran.dg/vect/vect-4.f90", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -1,14 +1,18 @@\n ! { dg-do compile }\n ! { dg-require-effective-target vect_float }\n \n+! Peeling to align the store to Y will also align the load from Y.\n+! The load from X may still be misaligned.\n+\n SUBROUTINE SAXPY(X, Y, A)\n DIMENSION X(64), Y(64)\n Y = Y + A * X\n END\n \n-! fail to vectorize until the patch that ignores dependence-distance 0 is \n-! brought from autovect. \n+! fail to vectorize due to aliasing problems in dataref analysis that are\n+! solved in autvect-branch but not yet in mainline.\n ! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } \n ! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail *-*-* } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 1 \"vect\" { xfail *-*-* } } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "da033c82874b659687b33de54fe3111036bcfda5", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -853,7 +853,8 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n   int dist = 0;\n   unsigned int loop_depth = 0;\n   struct loop *loop_nest = loop;  \n-\n+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n+  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n   \n   if (!vect_base_addr_differ_p (dra, drb, &differ_p))\n     {\n@@ -924,10 +925,13 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n   dist = DDR_DIST_VECT (ddr)[loop_depth];\n \n   /* Same loop iteration.  */\n-  if (dist == 0)\n+  if (dist % vectorization_factor == 0)\n     {\n-      if (vect_print_dump_info (REPORT_DETAILS, LOOP_LOC (loop_vinfo)))\n-\tfprintf (vect_dump, \"dependence distance 0.\");\n+      /* Two references with distance zero have the same alignment.  */\n+      VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n+      VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n+      if (vect_print_dump_info (REPORT_ALIGNMENT, LOOP_LOC (loop_vinfo)))\n+\tfprintf (vect_dump, \"accesses have the same alignment.\");\n       return false;\n     }\n \n@@ -1146,7 +1150,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n   varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n   varray_type datarefs;\n+  VEC(dr_p,heap) *same_align_drs;\n   struct data_reference *dr0 = NULL;\n+  struct data_reference *dr;\n   unsigned int i, j;\n \n   /*\n@@ -1300,7 +1306,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      else if (known_alignment_for_access_p (dr)\n \t\t       && known_alignment_for_access_p (dr0))\n \t\t{\n-\t\t  int drsize = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n+\t\t  int drsize = \n+\t\t\tGET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n \n \t\t  DR_MISALIGNMENT (dr) += npeel * drsize;\n \t\t  DR_MISALIGNMENT (dr) %= UNITS_PER_SIMD_WORD;\n@@ -1311,6 +1318,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  datarefs = loop_read_datarefs;\n \t}\n \n+      same_align_drs = \n+\tSTMT_VINFO_SAME_ALIGN_REFS (vinfo_for_stmt (DR_STMT (dr0)));\n+      for (i = 0; VEC_iterate (dr_p, same_align_drs, i, dr); i++)\n+        {\n+          DR_MISALIGNMENT (dr) = 0;\n+        }\n+\n       DR_MISALIGNMENT (dr0) = 0;\n     }\n }"}, {"sha": "116f01a5fe42312dcaa8a9597a72c42c42f9eb37", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -962,9 +962,9 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     {\n       SSA_NAME_DEF_STMT (def) = *vec_stmt;\n \n-      /* If this virtual def has a use outside the loop and a loop peel is performed\n-         then the def may be renamed by the peel.  Mark it for renaming so the\n-         later use will also be renamed.  */\n+      /* If this virtual def has a use outside the loop and a loop peel is \n+\t performed then the def may be renamed by the peel.  Mark it for \n+\t renaming so the later use will also be renamed.  */\n       mark_sym_for_renaming (SSA_NAME_VAR (def));\n     }\n \n@@ -1776,7 +1776,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n #endif\n \n   if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n-    fprintf (vect_dump, \"=== vect_transtorm_for_unknown_loop_bound ===\");\n+    fprintf (vect_dump, \"=== vect_do_peeling_for_loop_bound ===\");\n \n   /* Generate the following variables on the preheader of original loop:\n \t "}, {"sha": "c6002c446ff70184572032abca67a91eccfd3016", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -1457,10 +1457,14 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n \t{\n \t  tree stmt = bsi_stmt (si);\n \t  stmt_ann_t ann = stmt_ann (stmt);\n-\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t  free (stmt_info);\n-\t  set_stmt_info ((tree_ann_t)ann, NULL);\n+\n+\t  if (stmt_info)\n+\t    {\n+\t      VEC_free (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmt_info));\n+\t      free (stmt_info);\n+\t      set_stmt_info ((tree_ann_t)ann, NULL);\n+\t    }\n \t}\n     }\n "}, {"sha": "7892e0a99caba3ff5b0424908e45a84f1387810a", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb7483290049647685d17557117e4285530266f3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb7483290049647685d17557117e4285530266f3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bb7483290049647685d17557117e4285530266f3", "patch": "@@ -158,6 +158,10 @@ enum stmt_vec_info_type {\n   condition_vec_info_type\n };\n \n+typedef struct data_reference *dr_p;\n+DEF_VEC_P(dr_p);\n+DEF_VEC_ALLOC_P(dr_p,heap);\n+\n typedef struct _stmt_vec_info {\n \n   enum stmt_vec_info_type type;\n@@ -230,6 +234,10 @@ typedef struct _stmt_vec_info {\n      in bytes.  */\n   tree misalignment;\n \n+  /* List of datarefs that are known to have the same alignment as the dataref\n+     of this stmt.  */\n+  VEC(dr_p,heap) *same_align_refs;\n+\n   /* Classify the def of this stmt.  */\n   enum vect_def_type def_type;\n \n@@ -252,6 +260,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VECT_STEP(S)           (S)->step\n #define STMT_VINFO_VECT_BASE_ALIGNED_P(S) (S)->base_aligned_p\n #define STMT_VINFO_VECT_MISALIGNMENT(S)   (S)->misalignment\n+#define STMT_VINFO_SAME_ALIGN_REFS(S)     (S)->same_align_refs\n #define STMT_VINFO_DEF_TYPE(S)            (S)->def_type\n \n static inline void set_stmt_info (tree_ann_t ann, stmt_vec_info stmt_info);"}]}