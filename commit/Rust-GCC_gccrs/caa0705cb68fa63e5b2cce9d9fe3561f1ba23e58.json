{"sha": "caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FhMDcwNWNiNjhmYTYzZTViMmNjZTlkOWZlMzU2MWYxYmEyM2U1OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-07-10T06:08:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-07-10T06:08:29Z"}, "message": "tree-ssa-alias.c (nonoverlapping_component_refs_p_1): Break out from ...; work also on duplicated types.\n\n\t* tree-ssa-alias.c (nonoverlapping_component_refs_p_1): Break out\n\tfrom ...; work also on duplicated types.\n\t(nonoverlapping_component_refs_since_match): ... here\n\t(ncr_type_uid): Break out from ...\n\t(ncr_compar): ... here; look for TYPE_UID of canonical type if\n\tavailable.\n\t(nonoverlapping_component_refs_p): Use same_type_for_tbaa to match\n\tthe types and nonoverlapping_component_refs_p_1 to disambiguate.\n\t* g++.dg/lto/alias-3_0.C: New file.\n\t* g++.dg/lto/alias-3_1.c: New file.\n\nFrom-SVN: r273322", "tree": {"sha": "fa0af75280ee8a52e5ce9e60c8a4cbd9659f78d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa0af75280ee8a52e5ce9e60c8a4cbd9659f78d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/comments", "author": null, "committer": null, "parents": [{"sha": "1d00272bf2d32c13e3d9d5a100b956074f1e0320", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d00272bf2d32c13e3d9d5a100b956074f1e0320", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d00272bf2d32c13e3d9d5a100b956074f1e0320"}], "stats": {"total": 269, "additions": 210, "deletions": 59}, "files": [{"sha": "2f9863383937f5e288f2ec802819cb534671d78f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "patch": "@@ -1,3 +1,14 @@\n+2019-07-09  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (nonoverlapping_component_refs_p_1): Break out\n+\tfrom ...; work also on duplicated types.\n+\t(nonoverlapping_component_refs_since_match): ... here\n+\t(ncr_type_uid): Break out from ...\n+\t(ncr_compar): ... here; look for TYPE_UID of canonical type if\n+\tavailable.\n+\t(nonoverlapping_component_refs_p): Use same_type_for_tbaa to match\n+\tthe types and nonoverlapping_component_refs_p_1 to disambiguate.\n+\n 2019-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/90989"}, {"sha": "c9fa127a5cdadc9693871dea410dade8942b42d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "patch": "@@ -1,3 +1,8 @@\n+2019-07-09  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/lto/alias-3_0.C: New file.\n+\t* g++.dg/lto/alias-3_1.c: New file.\n+\n 2019-07-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/90989"}, {"sha": "facba59dea7638df257d4ef7d1f459274e3093d8", "filename": "gcc/testsuite/g++.dg/lto/alias-3_0.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-3_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-3_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-3_0.C?ref=caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options { { -O3 -flto -fno-early-inlining } } } */\n+\n+struct a\n+{\n+  int foo,bar;\n+};\n+struct b\n+{\n+  struct a a[10];\n+};\n+\n+__attribute__ ((used)) struct b b, *bptr=&b, *bptr2=&b;\n+__attribute__ ((used)) int i,j;\n+\n+extern \"C\" void inline_me_late (void);\n+\n+int\n+main (void)\n+{\n+  int jj=j;\n+  bptr2->a[jj].bar = 0;\n+  inline_me_late ();\n+  if (!__builtin_constant_p (bptr2->a[jj].bar == 0))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "11b02687531ed9490673bbc8c2f7c0f4165b0ca6", "filename": "gcc/testsuite/g++.dg/lto/alias-3_1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-3_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-3_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Falias-3_1.c?ref=caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options { { -O3 -flto -fno-early-inlining } } } */\n+struct a\n+{\n+  int foo,bar;\n+};\n+struct b\n+{\n+  struct a a[10];\n+};\n+\n+extern  struct b *bptr;\n+extern  int i;\n+\n+void\n+inline_me_late (void)\n+{\n+  bptr->a[i].foo=1;\n+}\n+"}, {"sha": "54e3a5412711740f5f3d517879c21cb5e726f037", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 147, "deletions": 59, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=caa0705cb68fa63e5b2cce9d9fe3561f1ba23e58", "patch": "@@ -1128,6 +1128,94 @@ aliasing_component_refs_p (tree ref1,\n   return false;\n }\n \n+/* FIELD1 and FIELD2 are two fields of component refs.  We assume\n+   that bases of both component refs are either equivalent or nonoverlapping.\n+   We do not assume that the containers of FIELD1 and FIELD2 are of the\n+   same type or size.\n+\n+   Return 0 in case the base address of component_refs are same then \n+   FIELD1 and FIELD2 have same address. Note that FIELD1 and FIELD2\n+   may not be of same type or size.\n+\n+   Return 1 if FIELD1 and FIELD2 are non-overlapping.\n+\n+   Return -1 otherwise.\n+\n+   Main difference between 0 and -1 is to let\n+   nonoverlapping_component_refs_since_match_p discover the semantically\n+   equivalent part of the access path.\n+\n+   Note that this function is used even with -fno-strict-aliasing\n+   and makes use of no TBAA assumptions.  */\n+\n+static int\n+nonoverlapping_component_refs_p_1 (const_tree field1, const_tree field2)\n+{\n+  /* If both fields are of the same type, we could save hard work of\n+     comparing offsets.  */\n+  tree type1 = DECL_CONTEXT (field1);\n+  tree type2 = DECL_CONTEXT (field2);\n+\n+  if (TREE_CODE (type1) == RECORD_TYPE\n+      && DECL_BIT_FIELD_REPRESENTATIVE (field1))\n+    field1 = DECL_BIT_FIELD_REPRESENTATIVE (field1);\n+  if (TREE_CODE (type2) == RECORD_TYPE\n+      && DECL_BIT_FIELD_REPRESENTATIVE (field2))\n+    field2 = DECL_BIT_FIELD_REPRESENTATIVE (field2);\n+\n+  /* ??? Bitfields can overlap at RTL level so punt on them.\n+     FIXME: RTL expansion should be fixed by adjusting the access path\n+     when producing MEM_ATTRs for MEMs which are wider than \n+     the bitfields similarly as done in set_mem_attrs_minus_bitpos.  */\n+  if (DECL_BIT_FIELD (field1) && DECL_BIT_FIELD (field2))\n+    return -1;\n+\n+  /* Assume that different FIELD_DECLs never overlap within a RECORD_TYPE.  */\n+  if (type1 == type2 && TREE_CODE (type1) == RECORD_TYPE)\n+    return field1 != field2;\n+\n+  /* In common case the offsets and bit offsets will be the same.\n+     However if frontends do not agree on the alignment, they may be\n+     different even if they actually represent same address.\n+     Try the common case first and if that fails calcualte the\n+     actual bit offset.  */\n+  if (tree_int_cst_equal (DECL_FIELD_OFFSET (field1),\n+\t\t\t  DECL_FIELD_OFFSET (field2))\n+      && tree_int_cst_equal (DECL_FIELD_BIT_OFFSET (field1),\n+\t\t\t     DECL_FIELD_BIT_OFFSET (field2)))\n+    return 0;\n+\n+  /* Note that it may be possible to use component_ref_field_offset\n+     which would provide offsets as trees. However constructing and folding\n+     trees is expensive and does not seem to be worth the compile time\n+     cost.  */\n+\n+  poly_uint64 offset1, offset2;\n+  poly_uint64 bit_offset1, bit_offset2;\n+\n+  if (poly_int_tree_p (DECL_FIELD_OFFSET (field1), &offset1)\n+      && poly_int_tree_p (DECL_FIELD_OFFSET (field2), &offset2)\n+      && poly_int_tree_p (DECL_FIELD_BIT_OFFSET (field1), &bit_offset1)\n+      && poly_int_tree_p (DECL_FIELD_BIT_OFFSET (field2), &bit_offset2))\n+    {\n+      offset1 = (offset1 << LOG2_BITS_PER_UNIT) + bit_offset1;\n+      offset2 = (offset2 << LOG2_BITS_PER_UNIT) + bit_offset2;\n+\n+      if (known_eq (offset1, offset2))\n+\treturn 0;\n+\n+      poly_uint64 size1, size2;\n+\n+      if (poly_int_tree_p (DECL_SIZE (field1), &size1)\n+\t  && poly_int_tree_p (DECL_SIZE (field2), &size2)\n+\t  && !ranges_maybe_overlap_p (offset1, size1, offset2, size2))\n+\treturn 1;\n+    }\n+  /* Resort to slower overlap checking by looking for matching types in\n+     the middle of access path.  */\n+  return -1;\n+}\n+\n /* Try to disambiguate REF1 and REF2 under the assumption that MATCH1 and\n    MATCH2 either point to the same address or are disjoint.\n    MATCH1 and MATCH2 are assumed to be ref in the access path of REF1 and REF2\n@@ -1224,6 +1312,7 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n      case the return value will precisely be false.  */\n   while (true)\n     {\n+      bool seen_noncomponent_ref_p = false;\n       do\n \t{\n \t  if (component_refs1.is_empty ())\n@@ -1233,6 +1322,8 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n \t      return 0;\n \t    }\n \t  ref1 = component_refs1.pop ();\n+\t  if (TREE_CODE (ref1) != COMPONENT_REF)\n+\t    seen_noncomponent_ref_p = true;\n \t}\n       while (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (ref1, 0))));\n \n@@ -1245,17 +1336,15 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n \t      return 0;\n \t    }\n \t  ref2 = component_refs2.pop ();\n+\t  if (TREE_CODE (ref2) != COMPONENT_REF)\n+\t    seen_noncomponent_ref_p = true;\n \t}\n       while (!RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_OPERAND (ref2, 0))));\n \n-      /* Beware of BIT_FIELD_REF.  */\n-      if (TREE_CODE (ref1) != COMPONENT_REF\n-\t  || TREE_CODE (ref2) != COMPONENT_REF)\n-\t{\n-\t  ++alias_stats\n-\t\t.nonoverlapping_component_refs_since_match_p_may_alias;\n-\t  return -1;\n-\t}\n+      /* BIT_FIELD_REF and VIEW_CONVERT_EXPR are taken off the vectors\n+\t earlier.  */\n+      gcc_checking_assert (TREE_CODE (ref1) == COMPONENT_REF\n+\t\t\t   && TREE_CODE (ref2) == COMPONENT_REF);\n \n       tree field1 = TREE_OPERAND (ref1, 1);\n       tree field2 = TREE_OPERAND (ref2, 1);\n@@ -1266,33 +1355,27 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n       tree type1 = DECL_CONTEXT (field1);\n       tree type2 = DECL_CONTEXT (field2);\n \n-      /* We cannot disambiguate fields in a union or qualified union.  */\n-      if (type1 != type2 || TREE_CODE (type1) != RECORD_TYPE)\n+      /* If we skipped array refs on type of different sizes, we can\n+\t no longer be sure that there are not partial overlaps.  */\n+      if (seen_noncomponent_ref_p\n+\t  && !operand_equal_p (TYPE_SIZE (type1), TYPE_SIZE (type2), 0))\n \t{\n-\t  ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t  ++alias_stats\n+\t    .nonoverlapping_component_refs_since_match_p_may_alias;\n \t  return -1;\n \t}\n \n-      if (field1 != field2)\n+      int cmp = nonoverlapping_component_refs_p_1 (field1, field2);\n+      if (cmp == -1)\n \t{\n-\t  /* A field and its representative need to be considered the\n-\t     same.  */\n-\t  if (DECL_BIT_FIELD_REPRESENTATIVE (field1) == field2\n-\t      || DECL_BIT_FIELD_REPRESENTATIVE (field2) == field1)\n-\t    {\n-\t      ++alias_stats\n-\t\t.nonoverlapping_component_refs_since_match_p_must_overlap;\n-\t      return 0;\n-\t    }\n-\t  /* Different fields of the same record type cannot overlap.\n-\t     ??? Bitfields can overlap at RTL level so punt on them.  */\n-\t  if (DECL_BIT_FIELD (field1) && DECL_BIT_FIELD (field2))\n-\t    {\n-\t      ++alias_stats\n-\t\t.nonoverlapping_component_refs_since_match_p_must_overlap;\n-\t      return 0;\n-\t    }\n-\t  ++alias_stats.nonoverlapping_component_refs_since_match_p_no_alias;\n+\t  ++alias_stats\n+\t    .nonoverlapping_component_refs_since_match_p_may_alias;\n+\t  return -1;\n+\t}\n+      else if (cmp == 1)\n+\t{\n+\t  ++alias_stats\n+\t    .nonoverlapping_component_refs_since_match_p_no_alias;\n \t  return 1;\n \t}\n     }\n@@ -1301,6 +1384,24 @@ nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n   return 0;\n }\n \n+/* Return TYPE_UID which can be used to match record types we consider\n+   same for TBAA purposes.  */\n+\n+static inline int\n+ncr_type_uid (const_tree field)\n+{\n+  /* ??? We cannot simply use the type of operand #0 of the refs here\n+     as the Fortran compiler smuggles type punning into COMPONENT_REFs\n+     for common blocks instead of using unions like everyone else.  */\n+  tree type = DECL_FIELD_CONTEXT (field);\n+  /* With LTO types considered same_type_for_tbaa_p \n+     from different translation unit may not have same\n+     main variant.  They however have same TYPE_CANONICAL.  */\n+  if (TYPE_CANONICAL (type))\n+    return TYPE_UID (TYPE_CANONICAL (type));\n+  return TYPE_UID (type);\n+}\n+\n /* qsort compare function to sort FIELD_DECLs after their\n    DECL_FIELD_CONTEXT TYPE_UID.  */\n \n@@ -1309,8 +1410,9 @@ ncr_compar (const void *field1_, const void *field2_)\n {\n   const_tree field1 = *(const_tree *) const_cast <void *>(field1_);\n   const_tree field2 = *(const_tree *) const_cast <void *>(field2_);\n-  unsigned int uid1 = TYPE_UID (DECL_FIELD_CONTEXT (field1));\n-  unsigned int uid2 = TYPE_UID (DECL_FIELD_CONTEXT (field2));\n+  unsigned int uid1 = ncr_type_uid (field1);\n+  unsigned int uid2 = ncr_type_uid (field2);\n+\n   if (uid1 < uid2)\n     return -1;\n   else if (uid1 > uid2)\n@@ -1377,10 +1479,9 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n   if (fieldsx.length () == 1\n       && fieldsy.length () == 1)\n    {\n-     if ((DECL_FIELD_CONTEXT (fieldsx[0])\n-         == DECL_FIELD_CONTEXT (fieldsy[0]))\n-        && fieldsx[0] != fieldsy[0]\n-        && !(DECL_BIT_FIELD (fieldsx[0]) && DECL_BIT_FIELD (fieldsy[0])))\n+     if (same_type_for_tbaa (DECL_FIELD_CONTEXT (fieldsx[0]),\n+\t\t\t     DECL_FIELD_CONTEXT (fieldsy[0])) == 1\n+\t && nonoverlapping_component_refs_p_1 (fieldsx[0], fieldsy[0]) == 1)\n       {\n          ++alias_stats.nonoverlapping_component_refs_p_no_alias;\n          return true;\n@@ -1413,31 +1514,18 @@ nonoverlapping_component_refs_p (const_tree x, const_tree y)\n     {\n       const_tree fieldx = fieldsx[i];\n       const_tree fieldy = fieldsy[j];\n-      tree typex = DECL_FIELD_CONTEXT (fieldx);\n-      tree typey = DECL_FIELD_CONTEXT (fieldy);\n-      if (typex == typey)\n+\n+      /* We're left with accessing different fields of a structure,\n+\t no possible overlap.  */\n+      if (same_type_for_tbaa (DECL_FIELD_CONTEXT (fieldx),\n+\t\t\t      DECL_FIELD_CONTEXT (fieldy)) == 1\n+\t  && nonoverlapping_component_refs_p_1 (fieldx, fieldy) == 1)\n \t{\n-\t  /* We're left with accessing different fields of a structure,\n-\t     no possible overlap.  */\n-\t  if (fieldx != fieldy)\n-\t    {\n-\t      /* A field and its representative need to be considered the\n-\t\t same.  */\n-\t      if (DECL_BIT_FIELD_REPRESENTATIVE (fieldx) == fieldy\n-\t\t  || DECL_BIT_FIELD_REPRESENTATIVE (fieldy) == fieldx)\n-\t\t;\n-\t      /* Different fields of the same record type cannot overlap.\n-\t\t ??? Bitfields can overlap at RTL level so punt on them.  */\n-\t      else if (DECL_BIT_FIELD (fieldx) && DECL_BIT_FIELD (fieldy))\n-\t\t;\n-\t      else\n-\t\t{\n-\t\t  ++alias_stats.nonoverlapping_component_refs_p_no_alias;\n-\t\t  return true;\n-\t\t}\n-\t    }\n+\t  ++alias_stats.nonoverlapping_component_refs_p_no_alias;\n+\t  return true;\n \t}\n-      if (TYPE_UID (typex) < TYPE_UID (typey))\n+\n+      if (ncr_type_uid (fieldx) < ncr_type_uid (fieldy))\n \t{\n \t  i++;\n \t  if (i == fieldsx.length ())"}]}