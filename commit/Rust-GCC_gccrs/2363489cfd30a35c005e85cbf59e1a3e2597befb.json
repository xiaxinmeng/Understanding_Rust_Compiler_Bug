{"sha": "2363489cfd30a35c005e85cbf59e1a3e2597befb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM2MzQ4OWNmZDMwYTM1YzAwNWU4NWNiZjU5ZTFhM2UyNTk3YmVmYg==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "1999-01-14T12:09:01Z"}, "committer": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "1999-01-14T12:09:01Z"}, "message": "(mop_up): Set work->previous_argument to NULL after freeing it.\n\nFrom-SVN: r24663", "tree": {"sha": "29f97c168e908813305e93f0343b683ed6599007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29f97c168e908813305e93f0343b683ed6599007"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2363489cfd30a35c005e85cbf59e1a3e2597befb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2363489cfd30a35c005e85cbf59e1a3e2597befb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2363489cfd30a35c005e85cbf59e1a3e2597befb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2363489cfd30a35c005e85cbf59e1a3e2597befb/comments", "author": null, "committer": null, "parents": [{"sha": "ad236eab582b829e02bcdb05b90a5a9ed289df92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad236eab582b829e02bcdb05b90a5a9ed289df92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad236eab582b829e02bcdb05b90a5a9ed289df92"}], "stats": {"total": 232, "additions": 116, "deletions": 116}, "files": [{"sha": "a3eb85f013ead51d5da67775959aeeb8f483fbd9", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 116, "deletions": 116, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2363489cfd30a35c005e85cbf59e1a3e2597befb/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2363489cfd30a35c005e85cbf59e1a3e2597befb/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=2363489cfd30a35c005e85cbf59e1a3e2597befb", "patch": "@@ -1,9 +1,9 @@\n-/* Demangler for GNU C++ \n-   Copyright 1989, 91, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n+/* Demangler for GNU C++\n+   Copyright 1989, 91, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.\n    Written by James Clark (jjc@jclark.uucp)\n    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling\n    Modified by Satish Pai (pai@apollo.hp.com) for HP demangling\n-   \n+\n This file is part of the libiberty library.\n Libiberty is free software; you can redistribute it and/or\n modify it under the terms of the GNU Library General Public\n@@ -128,7 +128,7 @@ struct work_stuff\n   int constructor;\n   int destructor;\n   int static_type;\t/* A static member function */\n-  int temp_start;       /* index in demangled to start of template args */   \n+  int temp_start;       /* index in demangled to start of template args */\n   int type_quals;       /* The type qualifiers.  */\n   int dllimported;\t/* Symbol imported from a PE DLL */\n   char **tmpl_argvec;   /* Template function arguments. */\n@@ -233,17 +233,17 @@ static const struct optable\n /* These values are used to indicate the various type varieties.\n    They are all non-zero so that they can be used as `success'\n    values.  */\n-typedef enum type_kind_t \n-{ \n+typedef enum type_kind_t\n+{\n   tk_none,\n   tk_pointer,\n   tk_reference,\n-  tk_integral, \n+  tk_integral,\n   tk_bool,\n-  tk_char, \n+  tk_char,\n   tk_real\n } type_kind_t;\n-\t\t\t     \n+\n #define STRING_EMPTY(str)\t((str) -> b == (str) -> p)\n #define PREPEND_BLANK(str)\t{if (!STRING_EMPTY(str)) \\\n     string_prepend(str, \" \");}\n@@ -274,7 +274,7 @@ static char *\n internal_cplus_demangle PARAMS ((struct work_stuff *, const char *));\n \n static int\n-demangle_template_template_parm PARAMS ((struct work_stuff *work, \n+demangle_template_template_parm PARAMS ((struct work_stuff *work,\n \t\t\t\t\t const char **, string *));\n \n static int\n@@ -348,7 +348,7 @@ get_count PARAMS ((const char **, int *));\n static int\n consume_count PARAMS ((const char **));\n \n-static int \n+static int\n consume_count_with_underscores PARAMS ((const char**));\n \n static int\n@@ -388,17 +388,17 @@ forget_B_and_K_types PARAMS ((struct work_stuff *));\n static void\n string_prepends PARAMS ((string *, string *));\n \n-static int \n-demangle_template_value_parm PARAMS ((struct work_stuff*, const char**, \n+static int\n+demangle_template_value_parm PARAMS ((struct work_stuff*, const char**,\n \t\t\t\t      string*, type_kind_t));\n \n-static int \n+static int\n do_hpacc_template_const_value PARAMS ((struct work_stuff *, const char **, string *));\n \n-static int \n+static int\n do_hpacc_template_literal PARAMS ((struct work_stuff *, const char **, string *));\n \n-static int \n+static int\n snarf_numeric_literal PARAMS ((const char **, string *));\n \n /* There is a TYPE_QUAL value for each type qualifier.  They can be\n@@ -410,7 +410,7 @@ snarf_numeric_literal PARAMS ((const char **, string *));\n #define TYPE_QUAL_VOLATILE 0x2\n #define TYPE_QUAL_RESTRICT 0x4\n \n-static int \n+static int\n code_for_qualifier PARAMS ((int));\n \n static const char*\n@@ -460,14 +460,14 @@ consume_count_with_underscores (mangled)\n       if (**mangled != '_')\n \t/* The trailing underscore was missing. */\n \treturn -1;\n-\t    \n+\n       (*mangled)++;\n     }\n   else\n     {\n       if (**mangled < '0' || **mangled > '9')\n \treturn -1;\n-\t    \n+\n       idx = **mangled - '0';\n       (*mangled)++;\n     }\n@@ -482,14 +482,14 @@ static int\n code_for_qualifier (c)\n   int c;\n {\n-  switch (c) \n+  switch (c)\n     {\n     case 'C':\n       return TYPE_QUAL_CONST;\n \n     case 'V':\n       return TYPE_QUAL_VOLATILE;\n-      \n+\n     case 'u':\n       return TYPE_QUAL_RESTRICT;\n \n@@ -569,7 +569,7 @@ cplus_demangle_opname (opname, result, options)\n   ret = 0;\n   memset ((char *) work, 0, sizeof (work));\n   work->options = options;\n-  \n+\n   if (opname[0] == '_' && opname[1] == '_'\n       && opname[2] == 'o' && opname[3] == 'p')\n     {\n@@ -619,12 +619,12 @@ cplus_demangle_opname (opname, result, options)\n \t\t      strcat (result, optable[i].out);\n \t\t      ret = 1;\n \t\t      break;\n-\t\t    }\t\t      \n+\t\t    }\n \t\t}\n \t    }\n \t}\n     }\n-  else if (len >= 3 \n+  else if (len >= 3\n \t   && opname[0] == 'o'\n \t   && opname[1] == 'p'\n \t   && strchr (cplus_markers, opname[2]) != NULL)\n@@ -654,7 +654,7 @@ cplus_demangle_opname (opname, result, options)\n \t  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n \t    {\n \t      len1 = len - 3;\n-\t      if ((int) strlen (optable[i].in) == len1 \n+\t      if ((int) strlen (optable[i].in) == len1\n \t\t  && memcmp (optable[i].in, opname + 3, len1) == 0)\n \t\t{\n \t\t  strcat (result, \"operator\");\n@@ -722,7 +722,7 @@ cplus_mangle_opname (opname, options)\n \tDMGL_PARAMS\tFunction parameters are included.\n \n    For example,\n-   \n+\n    cplus_demangle (\"foo__1Ai\", DMGL_PARAMS)\t\t=> \"A::foo(int)\"\n    cplus_demangle (\"foo__1Ai\", DMGL_PARAMS | DMGL_ANSI)\t=> \"A::foo(int)\"\n    cplus_demangle (\"foo__1Ai\", 0)\t\t\t=> \"A::foo\"\n@@ -751,9 +751,9 @@ cplus_demangle (mangled, options)\n   squangle_mop_up (work);\n   return (ret);\n }\n-  \n \n-/* This function performs most of what cplus_demangle use to do, but \n+\n+/* This function performs most of what cplus_demangle use to do, but\n    to be able to demangle a name with a B, K or n code, we need to\n    have a longer term memory of what types have been seen. The original\n    now intializes and cleans up the squangle code info, while internal\n@@ -853,7 +853,7 @@ mop_up (work, declp, success)\n   char *demangled = NULL;\n \n   /* Discard the remembered types, if any.  */\n-  \n+\n   forget_types (work);\n   if (work -> typevec != NULL)\n     {\n@@ -867,19 +867,20 @@ mop_up (work, declp, success)\n       for (i = 0; i < work->ntmpl_args; i++)\n \tif (work->tmpl_argvec[i])\n \t  free ((char*) work->tmpl_argvec[i]);\n-      \n+\n       free ((char*) work->tmpl_argvec);\n       work->tmpl_argvec = NULL;\n     }\n   if (work->previous_argument)\n     {\n       string_delete (work->previous_argument);\n       free ((char*) work->previous_argument);\n+      work->previous_argument = NULL;\n     }\n \n   /* If demangling was successful, ensure that the demangled string is null\n      terminated and return it.  Otherwise, free the demangling decl.  */\n-  \n+\n   if (!success)\n     {\n       string_delete (declp);\n@@ -959,7 +960,7 @@ demangle_signature (work, mangled, declp)\n \t    }\n \t  oldmangled = NULL;\n \t  break;\n-\t  \n+\n \tcase 'S':\n \t  /* Static member function */\n \t  if (oldmangled == NULL)\n@@ -995,22 +996,22 @@ demangle_signature (work, mangled, declp)\n \t  else\n \t    success = 0;\n \t  break;\n-\t  \n+\n \tcase '0': case '1': case '2': case '3': case '4':\n \tcase '5': case '6': case '7': case '8': case '9':\n \t  if (oldmangled == NULL)\n \t    {\n \t      oldmangled = *mangled;\n \t    }\n-          work->temp_start = -1; /* uppermost call to demangle_class */ \n+          work->temp_start = -1; /* uppermost call to demangle_class */\n \t  success = demangle_class (work, mangled, declp);\n \t  if (success)\n \t    {\n \t      remember_type (work, oldmangled, *mangled - oldmangled);\n \t    }\n \t  if (AUTO_DEMANGLING || GNU_DEMANGLING || EDG_DEMANGLING)\n \t    {\n-              /* EDG and others will have the \"F\", so we let the loop cycle \n+              /* EDG and others will have the \"F\", so we let the loop cycle\n                  if we are looking at one. */\n               if (**mangled != 'F')\n                  expect_func = 1;\n@@ -1065,10 +1066,10 @@ demangle_signature (work, mangled, declp)\n             }\n \n \t  break;\n-\t  \n+\n \tcase 't':\n \t  /* G++ Template */\n-\t  string_init(&trawname); \n+\t  string_init(&trawname);\n \t  string_init(&tname);\n \t  if (oldmangled == NULL)\n \t    {\n@@ -1101,7 +1102,7 @@ demangle_signature (work, mangled, declp)\n \t  break;\n \n \tcase '_':\n-\t  if (GNU_DEMANGLING && expect_return_type) \n+\t  if (GNU_DEMANGLING && expect_return_type)\n \t    {\n \t      /* Read the return type. */\n \t      string return_type;\n@@ -1135,7 +1136,7 @@ demangle_signature (work, mangled, declp)\n \t  break;\n \n \tcase 'H':\n-\t  if (GNU_DEMANGLING) \n+\t  if (GNU_DEMANGLING)\n \t    {\n \t      /* A G++ template function.  Read the template arguments. */\n \t      success = demangle_template (work, mangled, declp, 0, 0,\n@@ -1271,7 +1272,7 @@ demangle_template_template_parm (work, mangled, tname)\n \t    else if (**mangled == 'z')\n \t      {\n \t\t(*mangled)++;\n-\t\tsuccess = \n+\t\tsuccess =\n \t\t  demangle_template_template_parm (work, mangled, tname);\n \t\tif (!success)\n \t\t  {\n@@ -1313,7 +1314,7 @@ demangle_integral_value (work, mangled, s)\n   if (**mangled == 'E')\n     {\n       int need_operator = 0;\n-      \n+\n       success = 1;\n       string_appendn (s, \"(\", 1);\n       (*mangled)++;\n@@ -1328,7 +1329,7 @@ demangle_integral_value (work, mangled, s)\n \n \t      len = strlen (*mangled);\n \n-\t      for (i = 0; \n+\t      for (i = 0;\n \t\t   i < sizeof (optable) / sizeof (optable [0]);\n \t\t   ++i)\n \t\t{\n@@ -1358,7 +1359,7 @@ demangle_integral_value (work, mangled, s)\n \n       if (**mangled != 'W')\n \t  success = 0;\n-      else \n+      else\n \t{\n \t  string_appendn (s, \")\", 1);\n \t  (*mangled)++;\n@@ -1382,11 +1383,11 @@ demangle_integral_value (work, mangled, s)\n \t  success = 1;\n \t}\n     }\n-  \n+\n   return success;\n }\n \n-static int \n+static int\n demangle_template_value_parm (work, mangled, s, tk)\n      struct work_stuff *work;\n      const char **mangled;\n@@ -1402,7 +1403,7 @@ demangle_template_value_parm (work, mangled, s, tk)\n \n       (*mangled)++;\n       idx = consume_count_with_underscores (mangled);\n-      if (idx == -1 \n+      if (idx == -1\n \t  || (work->tmpl_argvec && idx >= work->ntmpl_args)\n \t  || consume_count_with_underscores (mangled) == -1)\n \treturn -1;\n@@ -1554,7 +1555,7 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t  (*mangled)++;\n \n \t  idx = consume_count_with_underscores (mangled);\n-\t  if (idx == -1 \n+\t  if (idx == -1\n \t      || (work->tmpl_argvec && idx >= work->ntmpl_args)\n \t      || consume_count_with_underscores (mangled) == -1)\n \t    return (0);\n@@ -1638,7 +1639,7 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t  int r2;\n \t  (*mangled)++;\n \t  success = demangle_template_template_parm (work, mangled, tname);\n-\t  \n+\n \t  if (success\n \t      && (r2 = consume_count (mangled)) > 0\n \t      && (int) strlen (*mangled) >= r2)\n@@ -1698,7 +1699,7 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n \t      work->tmpl_argvec[i] = xmalloc (len + 1);\n \t      memcpy (work->tmpl_argvec[i], s->b, len);\n \t      work->tmpl_argvec[i][len] = '\\0';\n-\t      \n+\n \t      string_appends (tname, s);\n \t      string_delete (s);\n \t    }\n@@ -1710,7 +1711,7 @@ demangle_template (work, mangled, tname, trawname, is_type, remember)\n     string_append (tname, \" \");\n   string_append (tname, \">\");\n     }\n-  \n+\n   if (is_type && remember)\n     remember_Btype (work, tname->b, LEN_STRING (tname), bindex);\n \n@@ -1808,7 +1809,7 @@ demangle_arm_hp_template (work, mangled, n, declp)\n         string_appendn (declp, *mangled, n);\n       (*mangled) += n + 1;\n       string_init (&arg);\n-      if (work->temp_start == -1) /* non-recursive call */ \n+      if (work->temp_start == -1) /* non-recursive call */\n         work->temp_start = declp->p - declp->b;\n       string_append (declp, \"<\");\n       while (1)\n@@ -1822,32 +1823,32 @@ demangle_arm_hp_template (work, mangled, n, declp)\n                 if (!do_type (work, mangled, &arg))\n                   goto hpacc_template_args_done;\n                 break;\n-                \n+\n               case 'U':\n               case 'S':\n                 /* 'U' or 'S' signals an integral value */\n                 if (!do_hpacc_template_const_value (work, mangled, &arg))\n                   goto hpacc_template_args_done;\n                 break;\n-                \n+\n               case 'A':\n                 /* 'A' signals a named constant expression (literal) */\n                 if (!do_hpacc_template_literal (work, mangled, &arg))\n                   goto hpacc_template_args_done;\n                 break;\n-                \n+\n               default:\n                 /* Today, 1997-09-03, we have only the above types\n-                   of template parameters */ \n-                /* FIXME: maybe this should fail and return null */ \n+                   of template parameters */\n+                /* FIXME: maybe this should fail and return null */\n                 goto hpacc_template_args_done;\n             }\n           string_appends (declp, &arg);\n          /* Check if we're at the end of template args.\n              0 if at end of static member of template class,\n-             _ if done with template args for a function */ \n-          if ((**mangled == '\\000') || (**mangled == '_')) \n-            break; \n+             _ if done with template args for a function */\n+          if ((**mangled == '\\000') || (**mangled == '_'))\n+            break;\n           else\n             string_append (declp, \",\");\n         }\n@@ -1866,7 +1867,7 @@ demangle_arm_hp_template (work, mangled, n, declp)\n       string_init (&arg);\n       string_appendn (declp, *mangled, p - *mangled);\n       if (work->temp_start == -1)  /* non-recursive call */\n-\twork->temp_start = declp->p - declp->b;  \n+\twork->temp_start = declp->p - declp->b;\n       string_append (declp, \"<\");\n       /* should do error checking here */\n       while (args < e) {\n@@ -1879,7 +1880,7 @@ demangle_arm_hp_template (work, mangled, n, declp)\n \t    /* spec: Xt1Lv1 where t1 is a type, v1 is a literal value */\n \t    /* FIXME: We handle only numeric literals for HP cfront */\n           case 'X':\n-            /* A typed constant value follows */ \n+            /* A typed constant value follows */\n             args++;\n             if (!do_type (work, &args, &type_str))\n \t      goto cfront_template_args_done;\n@@ -1901,7 +1902,7 @@ demangle_arm_hp_template (work, mangled, n, declp)\n \t      goto cfront_template_args_done;\n             break;\n           default:\n-            /* Not handling other HP cfront stuff */ \n+            /* Not handling other HP cfront stuff */\n             if (!do_type (work, &args, &arg))\n               goto cfront_template_args_done;\n \t  }\n@@ -1911,7 +1912,7 @@ demangle_arm_hp_template (work, mangled, n, declp)\n     cfront_template_args_done:\n       string_delete (&arg);\n       if (args >= e)\n-\t--declp->p; /* remove extra comma */ \n+\t--declp->p; /* remove extra comma */\n       string_append (declp, \">\");\n     }\n   else if (n>10 && strncmp (*mangled, \"_GLOBAL_\", 8) == 0\n@@ -1924,8 +1925,8 @@ demangle_arm_hp_template (work, mangled, n, declp)\n     }\n   else\n     {\n-      if (work->temp_start == -1) /* non-recursive call only */ \n-\twork->temp_start = 0;     /* disable in recursive calls */ \n+      if (work->temp_start == -1) /* non-recursive call only */\n+\twork->temp_start = 0;     /* disable in recursive calls */\n       string_appendn (declp, *mangled, n);\n     }\n   *mangled += n;\n@@ -1998,7 +1999,7 @@ demangle_class (work, mangled, declp)\n   int success = 0;\n   int btype;\n   string class_name;\n-  char *save_class_name_end = 0;  \n+  char *save_class_name_end = 0;\n \n   string_init (&class_name);\n   btype = register_Btype (work);\n@@ -2020,7 +2021,7 @@ demangle_class (work, mangled, declp)\n \t    }\n \t  else\n \t    {\n-\t      work -> constructor -= 1; \n+\t      work -> constructor -= 1;\n \t    }\n \t}\n       class_name.p = save_class_name_end;\n@@ -2061,7 +2062,7 @@ DESCRIPTION\n \tthe mangled name.  Upon exit, it should point to the first character\n \tof the signature if demangling was successful, or to the first\n \tunconsumed character if demangling of the prefix was unsuccessful.\n-\t\n+\n \tReturns 1 on success, 0 otherwise.\n  */\n \n@@ -2076,7 +2077,7 @@ demangle_prefix (work, mangled, declp)\n   int i;\n \n   if (strlen(*mangled) > 6\n-      && (strncmp(*mangled, \"_imp__\", 6) == 0 \n+      && (strncmp(*mangled, \"_imp__\", 6) == 0\n           || strncmp(*mangled, \"__imp_\", 6) == 0))\n     {\n       /* it's a symbol imported from a PE dynamic library. Check for both\n@@ -2142,10 +2143,10 @@ demangle_prefix (work, mangled, declp)\n       i = strspn (scan, \"_\");\n       if (i > 2)\n \t{\n-\t  scan += (i - 2); \n+\t  scan += (i - 2);\n \t}\n     }\n- \n+\n   if (scan == NULL)\n     {\n       success = 0;\n@@ -2171,7 +2172,7 @@ demangle_prefix (work, mangled, declp)\n \t  consume_count (mangled);\n \t  string_append (declp, *mangled);\n \t  *mangled += strlen (*mangled);\n-\t  success = 1; \n+\t  success = 1;\n \t}\n       else\n \t{\n@@ -2188,7 +2189,7 @@ demangle_prefix (work, mangled, declp)\n     {\n       /* Cfront-style parameterized type.  Handled later as a signature. */\n       success = 1;\n-      \n+\n       /* ARM template? */\n       demangle_arm_hp_template (work, mangled, strlen (*mangled), declp);\n     }\n@@ -2198,7 +2199,7 @@ demangle_prefix (work, mangled, declp)\n     {\n       /* EDG-style parameterized type.  Handled later as a signature. */\n       success = 1;\n-      \n+\n       /* EDG template? */\n       demangle_arm_hp_template (work, mangled, strlen (*mangled), declp);\n     }\n@@ -2253,7 +2254,7 @@ demangle_prefix (work, mangled, declp)\n       string_append (declp, *mangled);\n       *mangled += strlen (*mangled);\n       success = 1;\n-    } \n+    }\n   return (success);\n }\n \n@@ -2465,13 +2466,13 @@ recursively_demangle(work, mangled, result, namelength)\n {\n   char * recurse = (char *)NULL;\n   char * recurse_dem = (char *)NULL;\n-  \n+\n   recurse = (char *) xmalloc (namelength + 1);\n   memcpy (recurse, *mangled, namelength);\n   recurse[namelength] = '\\000';\n-  \n+\n   recurse_dem = cplus_demangle (recurse, work->options);\n-  \n+\n   if (recurse_dem)\n     {\n       string_append (result, recurse_dem);\n@@ -2608,7 +2609,7 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \n   /* We only make use of ISFUNCNAME if the entity is a constructor or\n      destructor.  */\n-  isfuncname = (isfuncname \n+  isfuncname = (isfuncname\n \t\t&& ((work->constructor & 1) || (work->destructor & 1)));\n \n   string_init (&temp);\n@@ -2687,7 +2688,7 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n       int remember_K = 1;\n       string_clear (&last_name);\n \n-      if (*mangled[0] == '_') \n+      if (*mangled[0] == '_')\n \t(*mangled)++;\n \n       if (*mangled[0] == 't')\n@@ -2698,11 +2699,11 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n \t     (parameter-less) value is returned by demangle_template\n \t     in LAST_NAME.  We do not remember the template type here,\n \t     in order to match the G++ mangling algorithm.  */\n-\t  success = demangle_template(work, mangled, &temp, \n+\t  success = demangle_template(work, mangled, &temp,\n \t\t\t\t      &last_name, 1, 0);\n-\t  if (!success) \n+\t  if (!success)\n \t    break;\n-\t} \n+\t}\n       else if (*mangled[0] == 'K')\n \t{\n           int idx;\n@@ -2722,8 +2723,8 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n             {\n \t      int namelength;\n  \t      /* Now recursively demangle the qualifier\n- \t       * This is necessary to deal with templates in \n- \t       * mangling styles like EDG */ \n+ \t       * This is necessary to deal with templates in\n+ \t       * mangling styles like EDG */\n \t      namelength = consume_count (mangled);\n  \t      recursively_demangle(work, mangled, &temp, namelength);\n             }\n@@ -2750,15 +2751,15 @@ demangle_qualified (work, mangled, result, isfuncname, append)\n      We do this here because this is the most convenient place, where\n      we already have a pointer to the name and the length of the name.  */\n \n-  if (isfuncname) \n+  if (isfuncname)\n     {\n       string_append (&temp, SCOPE_STRING (work));\n       if (work -> destructor & 1)\n \tstring_append (&temp, \"~\");\n       string_appends (&temp, &last_name);\n     }\n \n-  /* Now either prepend the temp buffer to the result, or append it, \n+  /* Now either prepend the temp buffer to the result, or append it,\n      depending upon the state of the append flag.  */\n \n   if (append)\n@@ -2811,12 +2812,12 @@ get_count (type, count)\n \t{\n \t  p = *type;\n \t  n = *count;\n-\t  do \n+\t  do\n \t    {\n \t      n *= 10;\n \t      n += *p - '0';\n \t      p++;\n-\t    } \n+\t    }\n \t  while (isdigit ((unsigned char)*p));\n \t  if (*p == '_')\n \t    {\n@@ -3066,7 +3067,7 @@ do_type (work, mangled, result)\n \t(*mangled)++;\n \tidx = consume_count_with_underscores (mangled);\n \n-\tif (idx == -1 \n+\tif (idx == -1\n \t    || (work->tmpl_argvec && idx >= work->ntmpl_args)\n \t    || consume_count_with_underscores (mangled) == -1)\n \t  {\n@@ -3270,7 +3271,7 @@ demangle_fund_type (work, mangled, result)\n \t  strncpy (buf, *mangled, 2);\n \t  *mangled += 2;\n \t}\n-      sscanf (buf, \"%x\", &dec); \n+      sscanf (buf, \"%x\", &dec);\n       sprintf (buf, \"int%i_t\", dec);\n       APPEND_BLANK (result);\n       string_append (result, buf);\n@@ -3297,7 +3298,7 @@ demangle_fund_type (work, mangled, result)\n           APPEND_BLANK (result);\n           string_appends (result, &btype);\n         }\n-        else \n+        else\n           success = 0;\n         string_delete (&btype);\n         break;\n@@ -3330,7 +3331,7 @@ do_hpacc_template_const_value (work, mangled, result)\n \n   if (**mangled != 'U' && **mangled != 'S')\n     return 0;\n-  \n+\n   unsigned_const = (**mangled == 'U');\n \n   (*mangled)++;\n@@ -3339,12 +3340,12 @@ do_hpacc_template_const_value (work, mangled, result)\n     {\n       case 'N':\n         string_append (result, \"-\");\n-        /* fall through */ \n+        /* fall through */\n       case 'P':\n         (*mangled)++;\n         break;\n       case 'M':\n-        /* special case for -2^31 */ \n+        /* special case for -2^31 */\n         string_append (result, \"-2147483648\");\n         (*mangled)++;\n         return 1;\n@@ -3370,8 +3371,8 @@ do_hpacc_template_const_value (work, mangled, result)\n \n   /* FIXME? Some day we may have 64-bit (or larger :-) ) constants\n      with L or LL suffixes. pai/1997-09-03 */\n-  \n-  return 1; /* success */ \n+\n+  return 1; /* success */\n }\n \n /* Handle a template's literal parameter for HP aCC (extension from ARM)\n@@ -3386,7 +3387,7 @@ do_hpacc_template_literal (work, mangled, result)\n   int literal_len = 0;\n   char * recurse;\n   char * recurse_dem;\n-  \n+\n   if (**mangled != 'A')\n     return 0;\n \n@@ -3401,13 +3402,13 @@ do_hpacc_template_literal (work, mangled, result)\n      canonical representation uses the address operator */\n   string_append (result, \"&\");\n \n-  /* Now recursively demangle the literal name */ \n+  /* Now recursively demangle the literal name */\n   recurse = (char *) xmalloc (literal_len + 1);\n   memcpy (recurse, *mangled, literal_len);\n   recurse[literal_len] = '\\000';\n \n   recurse_dem = cplus_demangle (recurse, work->options);\n-  \n+\n   if (recurse_dem)\n     {\n       string_append (result, recurse_dem);\n@@ -3436,7 +3437,7 @@ snarf_numeric_literal (args, arg)\n     }\n   else if (**args == '+')\n     (*args)++;\n-  \n+\n   if (!isdigit ((unsigned char)**args))\n     return 0;\n \n@@ -3473,7 +3474,7 @@ do_arg (work, mangled, result)\n       if (work->previous_argument == 0)\n \treturn 0;\n \n-      /* We want to reissue the previous type in this argument list.  */ \n+      /* We want to reissue the previous type in this argument list.  */\n       string_appends (result, work->previous_argument);\n       return 1;\n     }\n@@ -3497,7 +3498,7 @@ do_arg (work, mangled, result)\n \t  else\n \t    (*mangled)++;\n \t}\n-      \n+\n       /* Now, the repeat is all set up.  */\n       return do_arg (work, mangled, result);\n     }\n@@ -3589,15 +3590,15 @@ remember_Ktype (work, start, len)\n }\n \n /* Register a B code, and get an index for it. B codes are registered\n-   as they are seen, rather than as they are completed, so map<temp<char> >  \n+   as they are seen, rather than as they are completed, so map<temp<char> >\n    registers map<temp<char> > as B0, and temp<char> as B1 */\n \n static int\n register_Btype (work)\n      struct work_stuff *work;\n {\n   int ret;\n- \n+\n   if (work -> numb >= work -> bsize)\n     {\n       if (work -> bsize == 0)\n@@ -3751,7 +3752,7 @@ demangle_args (work, mangled, declp)\n       if ((**mangled == 'N') || (**mangled == 'T'))\n \t{\n \t  temptype = *(*mangled)++;\n-\t  \n+\n \t  if (temptype == 'N')\n \t    {\n \t      if (!get_count (mangled, &r))\n@@ -3873,7 +3874,7 @@ demangle_nested_args (work, mangled, declp)\n \n   /* Actually demangle the arguments.  */\n   result = demangle_args (work, mangled, declp);\n-  \n+\n   /* Restore the previous_argument field.  */\n   if (work->previous_argument)\n     string_delete (work->previous_argument);\n@@ -3907,7 +3908,7 @@ demangle_function_name (work, mangled, declp, scan)\n      foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a\n      following _F marks the start of the function arguments.  Handle\n      the template arguments first. */\n-  \n+\n   if (HP_DEMANGLING && (**mangled == 'X'))\n     {\n       demangle_arm_hp_template (work, mangled, 0, declp);\n@@ -3936,7 +3937,7 @@ demangle_function_name (work, mangled, declp, scan)\n \t}\n     }\n \n-  if (declp->p - declp->b >= 3 \n+  if (declp->p - declp->b >= 3\n       && declp->b[0] == 'o'\n       && declp->b[1] == 'p'\n       && strchr (cplus_markers, declp->b[2]) != NULL)\n@@ -3964,7 +3965,7 @@ demangle_function_name (work, mangled, declp, scan)\n \t  for (i = 0; i < sizeof (optable) / sizeof (optable[0]); i++)\n \t    {\n \t      int len = declp->p - declp->b - 3;\n-\t      if ((int) strlen (optable[i].in) == len \n+\t      if ((int) strlen (optable[i].in) == len\n \t\t  && memcmp (optable[i].in, declp->b + 3, len) == 0)\n \t\t{\n \t\t  string_clear (declp);\n@@ -4035,7 +4036,7 @@ demangle_function_name (work, mangled, declp, scan)\n \t\t      string_append (declp, \"operator\");\n \t\t      string_append (declp, optable[i].out);\n \t\t      break;\n-\t\t    }\t\t      \n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -4089,7 +4090,7 @@ string_init (s)\n   s->b = s->p = s->e = NULL;\n }\n \n-static void \n+static void\n string_clear (s)\n      string *s;\n {\n@@ -4230,7 +4231,7 @@ static void\n usage (stream, status)\n      FILE *stream;\n      int status;\n-{    \n+{\n   fprintf (stream, \"\\\n Usage: %s [-_] [-n] [-s {gnu,lucid,arm,hp,edg}] [--strip-underscores]\\n\\\n        [--no-strip-underscores] [--format={gnu,lucid,arm,hp,edg}]\\n\\\n@@ -4344,7 +4345,7 @@ main (argc, argv)\n                               c == '<' || c == '>' || c == '#' || c == ',' || c == '*' || c == '&' ||\n                               c == '[' || c == ']' || c == ':' || c == '(' || c == ')'))\n                               /* the ones in the 2nd & 3rd lines were added to handle\n-                                 HP aCC template specialization manglings */ \n+                                 HP aCC template specialization manglings */\n \t    {\n \t      if (i >= MBUF_SIZE-1)\n \t\tbreak;\n@@ -4364,7 +4365,7 @@ main (argc, argv)\n \t\tskip_first = i;\n \n \t      mbuffer[i] = 0;\n-\t      \n+\n \t      result = cplus_demangle (mbuffer + skip_first, flags);\n \t      if (result)\n \t\t{\n@@ -4416,4 +4417,3 @@ xrealloc (ptr, size)\n   return value;\n }\n #endif\t/* main */\n-"}]}