{"sha": "3ddc18251a821fe69d6229abbf83d77284d2340a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RkYzE4MjUxYTgyMWZlNjlkNjIyOWFiYmY4M2Q3NzI4NGQyMzQwYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-13T11:40:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-01-13T12:38:41Z"}, "message": "tree-optimization/92645 - improve SLP with existing vectors\n\nThis improves SLP discovery in the face of existing vectors allowing\npunning of the vector shape (or even punning from an integer type).\nFor punning from integer types this does not yet handle lane zero\nextraction being represented as conversion rather than BIT_FIELD_REF.\n\n2021-01-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/92645\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Relax supported\n\tBIT_FIELD_REF argument.\n\t(vect_build_slp_tree_2): Record the desired vector type\n\ton the external vector def.\n\t(vectorizable_slp_permutation): Handle required punning\n\tof existing vector defs.\n\n\t* gcc.target/i386/pr92645-6.c: New testcase.", "tree": {"sha": "09a0019b71cc011fab596504d87c09afa2cb6276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09a0019b71cc011fab596504d87c09afa2cb6276"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ddc18251a821fe69d6229abbf83d77284d2340a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ddc18251a821fe69d6229abbf83d77284d2340a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ddc18251a821fe69d6229abbf83d77284d2340a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ddc18251a821fe69d6229abbf83d77284d2340a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ab67cdee6144cfca0705612a898f1940d4f3994", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab67cdee6144cfca0705612a898f1940d4f3994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab67cdee6144cfca0705612a898f1940d4f3994"}], "stats": {"total": 65, "additions": 63, "deletions": 2}, "files": [{"sha": "c5c5f8f8df2fec41c0a368bf94b4af99d50c318d", "filename": "gcc/testsuite/gcc.target/i386/pr92645-6.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddc18251a821fe69d6229abbf83d77284d2340a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddc18251a821fe69d6229abbf83d77284d2340a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr92645-6.c?ref=3ddc18251a821fe69d6229abbf83d77284d2340a", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O3 -msse2\" } */\n+\n+typedef long v2di __attribute__((vector_size(16)));\n+typedef int v4si __attribute__((vector_size(16)));\n+\n+void foo (v4si *p, v2di *q)\n+{\n+  union { v2di a; v4si b; } u;\n+  u.a = *q;\n+  (*p)[0] = u.b[0];\n+  (*p)[1] = u.b[2];\n+  (*p)[2] = u.b[1];\n+  (*p)[3] = u.b[3];\n+}\n+\n+void bar (v4si *p, __int128_t *q)\n+{\n+  union { __int128_t a; v4si b; } u;\n+  u.a = *q;\n+  (*p)[0] = u.b[1];\n+  (*p)[1] = u.b[2];\n+  (*p)[2] = u.b[1];\n+  (*p)[3] = u.b[3];\n+}\n+\n+/* Both functions should end up with sth like\n+     [v]pshufd $val, (%esi), %xmm0\n+     [v]movdqa %xmm0, (%edi)\n+     ret\n+   recognized by SLP vectorization involving an existing \"vector\".  */\n+/* { dg-final { scan-assembler-not \"punpck\" } } */\n+/* { dg-final { scan-assembler-times \"pshufd\" 2 } } */"}, {"sha": "f7f656a481024310cf2ac51121887779d1d779ff", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ddc18251a821fe69d6229abbf83d77284d2340a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ddc18251a821fe69d6229abbf83d77284d2340a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=3ddc18251a821fe69d6229abbf83d77284d2340a", "patch": "@@ -1105,7 +1105,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      tree vec = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n \t      if (!is_a <bb_vec_info> (vinfo)\n \t\t  || TREE_CODE (vec) != SSA_NAME\n-\t\t  || !types_compatible_p (vectype, TREE_TYPE (vec)))\n+\t\t  || !operand_equal_p (TYPE_SIZE (vectype),\n+\t\t\t\t       TYPE_SIZE (TREE_TYPE (vec))))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1642,7 +1643,11 @@ vect_build_slp_tree_2 (vec_info *vinfo, slp_tree node,\n \t  lperm.safe_push (std::make_pair (0, (unsigned)lane));\n \t}\n       slp_tree vnode = vect_create_new_slp_node (vNULL);\n-      SLP_TREE_VECTYPE (vnode) = TREE_TYPE (vec);\n+      /* ???  We record vectype here but we hide eventually necessary\n+\t punning and instead rely on code generation to materialize\n+\t VIEW_CONVERT_EXPRs as necessary.  We instead should make\n+\t this explicit somehow.  */\n+      SLP_TREE_VECTYPE (vnode) = vectype;\n       SLP_TREE_VEC_DEFS (vnode).safe_push (vec);\n       /* We are always building a permutation node even if it is an identity\n \t permute to shield the rest of the vectorizer from the odd node\n@@ -5671,6 +5676,18 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t      slp_tree first_node = SLP_TREE_CHILDREN (node)[first_vec.first];\n \t      tree first_def\n \t\t= vect_get_slp_vect_def (first_node, first_vec.second);\n+\t      /* ???  We SLP match existing vector element extracts but\n+\t\t allow punning which we need to re-instantiate at uses\n+\t\t but have no good way of explicitely representing.  */\n+\t      if (!types_compatible_p (TREE_TYPE (first_def), vectype))\n+\t\t{\n+\t\t  gassign *conv_stmt;\n+\t\t  conv_stmt = gimple_build_assign (make_ssa_name (vectype),\n+\t\t\t\t\t\t   build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t   vectype, first_def));\n+\t\t  vect_finish_stmt_generation (vinfo, NULL, conv_stmt, gsi);\n+\t\t  first_def = gimple_assign_lhs (conv_stmt);\n+\t\t}\n \t      gassign *perm_stmt;\n \t      tree perm_dest = make_ssa_name (vectype);\n \t      if (!identity_p)\n@@ -5679,6 +5696,16 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t\t    = SLP_TREE_CHILDREN (node)[second_vec.first];\n \t\t  tree second_def\n \t\t    = vect_get_slp_vect_def (second_node, second_vec.second);\n+\t\t  if (!types_compatible_p (TREE_TYPE (second_def), vectype))\n+\t\t    {\n+\t\t      gassign *conv_stmt;\n+\t\t      conv_stmt = gimple_build_assign (make_ssa_name (vectype),\n+\t\t\t\t\t\t       build1\n+\t\t\t\t\t\t\t (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t  vectype, second_def));\n+\t\t      vect_finish_stmt_generation (vinfo, NULL, conv_stmt, gsi);\n+\t\t      second_def = gimple_assign_lhs (conv_stmt);\n+\t\t    }\n \t\t  tree mask_vec = vect_gen_perm_mask_checked (vectype, indices);\n \t\t  perm_stmt = gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n \t\t\t\t\t\t   first_def, second_def,"}]}