{"sha": "21ff92b4e3c0e302181754b240c3246cfda4aead", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFmZjkyYjRlM2MwZTMwMjE4MTc1NGIyNDBjMzI0NmNmZGE0YWVhZA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-07-04T13:30:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-04T13:30:21Z"}, "message": "sem_type.adb (Covers): Verify that Corresponding_Record_Type is present before checking whether an...\n\n2005-07-04  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_type.adb (Covers): Verify that Corresponding_Record_Type is\n\tpresent before checking whether an interface type covers a synchronized\n\ttype.\n\nFrom-SVN: r101591", "tree": {"sha": "303b7bd83bcd4c0a838d0d89eace8c7735221197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/303b7bd83bcd4c0a838d0d89eace8c7735221197"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21ff92b4e3c0e302181754b240c3246cfda4aead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ff92b4e3c0e302181754b240c3246cfda4aead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21ff92b4e3c0e302181754b240c3246cfda4aead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ff92b4e3c0e302181754b240c3246cfda4aead/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16397eff06ff427844ae00e28a448a2694cbec65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16397eff06ff427844ae00e28a448a2694cbec65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16397eff06ff427844ae00e28a448a2694cbec65"}], "stats": {"total": 96, "additions": 49, "deletions": 47}, "files": [{"sha": "b43431966a62d33ded884616a52fc118aeabf4ed", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ff92b4e3c0e302181754b240c3246cfda4aead/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ff92b4e3c0e302181754b240c3246cfda4aead/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=21ff92b4e3c0e302181754b240c3246cfda4aead", "patch": "@@ -613,9 +613,9 @@ package body Sem_Type is\n    --  Start of processing for Covers\n \n    begin\n-      --  If either operand missing, then this is an error, but ignore\n-      --  it (and pretend we have a cover) if errors already detected,\n-      --  since this may simply mean we have malformed trees.\n+      --  If either operand missing, then this is an error, but ignore it (and\n+      --  pretend we have a cover) if errors already detected, since this may\n+      --  simply mean we have malformed trees.\n \n       if No (T1) or else No (T2) then\n          if Total_Errors_Detected /= 0 then\n@@ -763,8 +763,8 @@ package body Sem_Type is\n       then\n          return True;\n \n-      --  If the expected type is an anonymous access, the designated\n-      --  type must cover that of the expression.\n+      --  If the expected type is an anonymous access, the designated type must\n+      --  cover that of the expression.\n \n       elsif Ekind (T1) = E_Anonymous_Access_Type\n         and then Is_Access_Type (T2)\n@@ -852,8 +852,8 @@ package body Sem_Type is\n             (From_With_Type (Designated_Type (T1))\n               and then Covers (Designated_Type (T2), Designated_Type (T1)));\n \n-      --  A boolean operation on integer literals is compatible with a\n-      --  modular context.\n+      --  A boolean operation on integer literals is compatible with modular\n+      --  context.\n \n       elsif T2 = Any_Modular\n         and then Is_Modular_Integer_Type (T1)\n@@ -865,10 +865,10 @@ package body Sem_Type is\n       elsif Base_Type (T2) = Any_Type then\n          return True;\n \n-      --  A packed array type covers its corresponding non-packed type.\n-      --  This is not legitimate Ada, but allows the omission of a number\n-      --  of otherwise useless unchecked conversions, and since this can\n-      --  only arise in (known correct) expanded code, no harm is done\n+      --  A packed array type covers its corresponding non-packed type. This is\n+      --  not legitimate Ada, but allows the omission of a number of otherwise\n+      --  useless unchecked conversions, and since this can only arise in\n+      --  (known correct) expanded code, no harm is done\n \n       elsif Is_Array_Type (T2)\n         and then Is_Packed (T2)\n@@ -964,14 +964,14 @@ package body Sem_Type is\n       User_Subp   : Entity_Id;\n \n       function Inherited_From_Actual (S : Entity_Id) return Boolean;\n-      --  Determine whether one of the candidates is an operation inherited\n-      --  by a type that is derived from an actual in an instantiation.\n+      --  Determine whether one of the candidates is an operation inherited by\n+      --  a type that is derived from an actual in an instantiation.\n \n       function Is_Actual_Subprogram (S : Entity_Id) return Boolean;\n-      --  Determine whether a subprogram is an actual in an enclosing\n-      --  instance. An overloading between such a subprogram and one\n-      --  declared outside the instance is resolved in favor of the first,\n-      --  because it resolved in the generic.\n+      --  Determine whether a subprogram is an actual in an enclosing instance.\n+      --  An overloading between such a subprogram and one declared outside the\n+      --  instance is resolved in favor of the first, because it resolved in\n+      --  the generic.\n \n       function Matches (Actual, Formal : Node_Id) return Boolean;\n       --  Look for exact type match in an instance, to remove spurious\n@@ -981,16 +981,16 @@ package body Sem_Type is\n       --  Comment required ???\n \n       function Remove_Conversions return Interp;\n-      --  Last chance for pathological cases involving comparisons on\n-      --  literals, and user overloadings of the same operator. Such\n-      --  pathologies have been removed from the ACVC, but still appear in\n-      --  two DEC tests, with the following notable quote from Ben Brosgol:\n+      --  Last chance for pathological cases involving comparisons on literals,\n+      --  and user overloadings of the same operator. Such pathologies have\n+      --  been removed from the ACVC, but still appear in two DEC tests, with\n+      --  the following notable quote from Ben Brosgol:\n       --\n       --  [Note: I disclaim all credit/responsibility/blame for coming up with\n-      --  this example;  Robert Dewar brought it to our attention, since it\n-      --  is apparently found in the ACVC 1.5. I did not attempt to find\n-      --  the reason in the Reference Manual that makes the example legal,\n-      --  since I was too nauseated by it to want to pursue it further.]\n+      --  this example; Robert Dewar brought it to our attention, since it is\n+      --  apparently found in the ACVC 1.5. I did not attempt to find the\n+      --  reason in the Reference Manual that makes the example legal, since I\n+      --  was too nauseated by it to want to pursue it further.]\n       --\n       --  Accordingly, this is not a fully recursive solution, but it handles\n       --  DEC tests c460vsa, c460vsb. It also handles ai00136a, which pushes\n@@ -1102,9 +1102,9 @@ package body Sem_Type is\n                  and then Etype (F1) = Standard_Boolean\n                then\n                   --  If the two candidates are the original ones, the\n-                  --  ambiguity is real. Otherwise keep the original,\n-                  --  further calls to Disambiguate will take care of\n-                  --  others in the list of candidates.\n+                  --  ambiguity is real. Otherwise keep the original, further\n+                  --  calls to Disambiguate will take care of others in the\n+                  --  list of candidates.\n \n                   if It1 /= No_Interp then\n                      if It = Disambiguate.It1\n@@ -1142,9 +1142,9 @@ package body Sem_Type is\n                Get_Next_Interp (I, It);\n          end loop;\n \n-         --  After some error, a formal may have Any_Type and yield\n-         --  a spurious match. To avoid cascaded errors if possible,\n-         --  check for such a formal in either candidate.\n+         --  After some error, a formal may have Any_Type and yield a spurious\n+         --  match. To avoid cascaded errors if possible, check for such a\n+         --  formal in either candidate.\n \n          if Serious_Errors_Detected > 0 then\n             declare\n@@ -1269,9 +1269,9 @@ package body Sem_Type is\n          elsif Chars (Nam1) /= Name_Op_Not\n            and then (Typ = Standard_Boolean or else Typ = Any_Boolean)\n          then\n-            --  Equality or comparison operation. Choose predefined operator\n-            --  if arguments are universal. The node may be an operator, a\n-            --  name, or a function call, so unpack arguments accordingly.\n+            --  Equality or comparison operation. Choose predefined operator if\n+            --  arguments are universal. The node may be an operator, name, or\n+            --  a function call, so unpack arguments accordingly.\n \n             declare\n                Arg1, Arg2 : Node_Id;\n@@ -1345,10 +1345,10 @@ package body Sem_Type is\n             end if;\n \n          --  If the ambiguity occurs within an instance, it is due to several\n-         --  formal types with the same actual. Look for an exact match\n-         --  between the types of the formals of the overloadable entities,\n-         --  and the actuals in the call, to recover the unambiguous match\n-         --  in the original generic.\n+         --  formal types with the same actual. Look for an exact match between\n+         --  the types of the formals of the overloadable entities, and the\n+         --  actuals in the call, to recover the unambiguous match in the\n+         --  original generic.\n \n          --  The ambiguity can also be due to an overloading between a formal\n          --  subprogram and a subprogram declared outside the generic. If the\n@@ -1456,9 +1456,9 @@ package body Sem_Type is\n             return It2;\n          end if;\n \n-      --  Otherwise, the predefined operator has precedence, or if the\n-      --  user-defined operation is directly visible we have a true ambiguity.\n-      --  If this is a fixed-point multiplication and division in Ada83 mode,\n+      --  Otherwise, the predefined operator has precedence, or if the user-\n+      --  defined operation is directly visible we have a true ambiguity. If\n+      --  this is a fixed-point multiplication and division in Ada83 mode,\n       --  exclude the universal_fixed operator, which often causes ambiguities\n       --  in legacy code.\n \n@@ -1506,8 +1506,8 @@ package body Sem_Type is\n \n    function Entity_Matches_Spec (Old_S, New_S : Entity_Id) return Boolean is\n    begin\n-      --  Simple case: same entity kinds, type conformance is required.\n-      --  A parameterless function can also rename a literal.\n+      --  Simple case: same entity kinds, type conformance is required. A\n+      --  parameterless function can also rename a literal.\n \n       if Ekind (Old_S) = Ekind (New_S)\n         or else (Ekind (New_S) = E_Function\n@@ -1573,8 +1573,8 @@ package body Sem_Type is\n          null;\n       end if;\n \n-      --  If one of the operands is Universal_Fixed, the type of the\n-      --  other operand provides the context.\n+      --  If one of the operands is Universal_Fixed, the type of the other\n+      --  operand provides the context.\n \n       if Etype (R) = Universal_Fixed then\n          return T;\n@@ -1683,10 +1683,13 @@ package body Sem_Type is\n          return\n            Covers (Typ, Etype (N))\n \n-            --  Ada 2005 (AI-345)\n+            --  Ada 2005 (AI-345) The context may be a synchronized interface.\n+            --  If the type is already frozen use the corresponding_record\n+            --  to check whether it is a proper descendant.\n \n            or else\n              (Is_Concurrent_Type (Etype (N))\n+                and then Present (Corresponding_Record_Type (Etype (N)))\n                 and then Covers (Typ, Corresponding_Record_Type (Etype (N))))\n \n            or else\n@@ -1741,7 +1744,6 @@ package body Sem_Type is\n \n    function Hides_Op (F : Entity_Id; Op : Entity_Id) return Boolean is\n       Btyp : constant Entity_Id := Base_Type (Etype (First_Formal (F)));\n-\n    begin\n       return Operator_Matches_Spec (Op, F)\n         and then (In_Open_Scopes (Scope (F))"}]}