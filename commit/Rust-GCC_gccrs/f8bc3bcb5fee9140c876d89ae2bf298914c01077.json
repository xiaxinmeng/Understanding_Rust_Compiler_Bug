{"sha": "f8bc3bcb5fee9140c876d89ae2bf298914c01077", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhiYzNiY2I1ZmVlOTE0MGM4NzZkODlhZTJiZjI5ODkxNGMwMTA3Nw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-09-26T09:18:02Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-09-26T09:18:02Z"}, "message": "[Ada] New unit GNAT.Sets\n\nThis patch implements unit GNAT.Sets which currently offers a general purpose\nmembership set. The patch also streamlines GNAT.Dynamic_HTables and GNAT.Lists\nto use parts of the same API, types, and exceptions as those used by GNAT.Sets.\n\n2018-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/Make-lang.in: Add unit GNAT.Sets to the list of\n\tfront end sources.\n\t* impunit.adb: Add unit GNAT.Sets to the list of predefined\n\tunits.\n\t* Makefile.rtl: Add unit GNAT.Sets to the list of non-tasking\n\tunits.\n\t* libgnat/g-sets.adb: New unit.\n\t* libgnat/g-sets.ads: New unit.\n\t* libgnat/g-dynhta.adb (Minimum_Size): Decrease to 8 in order to\n\tallow for small sets.  Update all occurrences of Table_Locked to\n\tIterated.\n\t(Ensure_Unlocked): Query the number of iterators.\n\t(Find_Node): Use the supplied equality.\n\t(Is_Empty): New routine.\n\t(Lock): Update the number of iterators.\n\t(Prepend_Or_Replace): Use the supplied equality.\n\t(Size): Update the return type.\n\t(Unlock): Update the number of iterators.\n\t* libgnat/g-dynhta.ads: Update all occurrences of Table_Locked\n\tto Iterated.  Rename formal subprogram Equivalent_Keys to \"=\".\n\t(Bucket_Range_Type, Pair_Count_Type): Remove types.\n\t(Not_Created, Table_Locked, Iterator_Exhausted): Remove\n\texceptions.\n\t(Hash_Table): Update to store the number of iterators rather\n\tthan locks.\n\t(Is_Empty): New routine.\n\t(Size): Update the return type.\n\t* libgnat/g-lists.adb: Update all occurrences of List_Locked to\n\tIterated.\n\t(Ensure_Unlocked): Query the number of iterators.\n\t(Length): Remove.\n\t(Lock): Update the number of iterators.\n\t(Size): New routine.\n\t(Unlock): Update the number of iterators.\n\t* libgnat/g-lists.ads: Update all occurrences of List_Locked to\n\tIterated.\n\t(Element_Count_Type): Remove type.\n\t(Not_Created, Table_Locked, Iterator_Exhausted): Remove\n\texceptions.\n\t(Linked_List): Update type to store the number of iterators\n\trather than locks.\n\t(Length): Remove.\n\t(Size): New routine.\n\t* libgnat/gnat.ads (Bucket_Range_Type): New type.\n\t(Iterated, Iterator_Exhausted, and Not_Created): New exceptions.\n\ngcc/testsuite/\n\n\t* gnat.dg/sets1.adb: New testcase.\n\t* gnat.dg/dynhash.adb, gnat.dg/linkedlist.adb: Update testcases\n\tto new API.\n\nFrom-SVN: r264620", "tree": {"sha": "728e2e247528f8c955908f2ccacfe349fc880860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/728e2e247528f8c955908f2ccacfe349fc880860"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8bc3bcb5fee9140c876d89ae2bf298914c01077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8bc3bcb5fee9140c876d89ae2bf298914c01077", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8bc3bcb5fee9140c876d89ae2bf298914c01077", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8bc3bcb5fee9140c876d89ae2bf298914c01077/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fcf1dd74bc00a857879ef9a34ad719cdf7053295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf1dd74bc00a857879ef9a34ad719cdf7053295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcf1dd74bc00a857879ef9a34ad719cdf7053295"}], "stats": {"total": 1384, "additions": 1176, "deletions": 208}, "files": [{"sha": "92009ff9d6bb03c002fd5bda99b214b177f90e0e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -1,3 +1,51 @@\n+2018-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gcc-interface/Make-lang.in: Add unit GNAT.Sets to the list of\n+\tfront end sources.\n+\t* impunit.adb: Add unit GNAT.Sets to the list of predefined\n+\tunits.\n+\t* Makefile.rtl: Add unit GNAT.Sets to the list of non-tasking\n+\tunits.\n+\t* libgnat/g-sets.adb: New unit.\n+\t* libgnat/g-sets.ads: New unit.\n+\t* libgnat/g-dynhta.adb (Minimum_Size): Decrease to 8 in order to\n+\tallow for small sets.  Update all occurrences of Table_Locked to\n+\tIterated.\n+\t(Ensure_Unlocked): Query the number of iterators.\n+\t(Find_Node): Use the supplied equality.\n+\t(Is_Empty): New routine.\n+\t(Lock): Update the number of iterators.\n+\t(Prepend_Or_Replace): Use the supplied equality.\n+\t(Size): Update the return type.\n+\t(Unlock): Update the number of iterators.\n+\t* libgnat/g-dynhta.ads: Update all occurrences of Table_Locked\n+\tto Iterated.  Rename formal subprogram Equivalent_Keys to \"=\".\n+\t(Bucket_Range_Type, Pair_Count_Type): Remove types.\n+\t(Not_Created, Table_Locked, Iterator_Exhausted): Remove\n+\texceptions.\n+\t(Hash_Table): Update to store the number of iterators rather\n+\tthan locks.\n+\t(Is_Empty): New routine.\n+\t(Size): Update the return type.\n+\t* libgnat/g-lists.adb: Update all occurrences of List_Locked to\n+\tIterated.\n+\t(Ensure_Unlocked): Query the number of iterators.\n+\t(Length): Remove.\n+\t(Lock): Update the number of iterators.\n+\t(Size): New routine.\n+\t(Unlock): Update the number of iterators.\n+\t* libgnat/g-lists.ads: Update all occurrences of List_Locked to\n+\tIterated.\n+\t(Element_Count_Type): Remove type.\n+\t(Not_Created, Table_Locked, Iterator_Exhausted): Remove\n+\texceptions.\n+\t(Linked_List): Update type to store the number of iterators\n+\trather than locks.\n+\t(Length): Remove.\n+\t(Size): New routine.\n+\t* libgnat/gnat.ads (Bucket_Range_Type): New type.\n+\t(Iterated, Iterator_Exhausted, and Not_Created): New exceptions.\n+\n 2018-09-26  Javier Miranda  <miranda@adacore.com>\n \n \t* checks.adb (Install_Null_Excluding_Check): Do not add"}, {"sha": "e1b26de67a66e26c2228e452224f78b507f793c2", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -445,6 +445,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-sehash$(objext) \\\n   g-sercom$(objext) \\\n   g-sestin$(objext) \\\n+  g-sets$(objext) \\\n   g-sha1$(objext) \\\n   g-sha224$(objext) \\\n   g-sha256$(objext) \\"}, {"sha": "4866c2ad6a000114799661d0c193de6fd37b38c6", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -320,6 +320,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/libgnat/g-hesora.o\t\\\n  ada/libgnat/g-htable.o\t\\\n  ada/libgnat/g-lists.o \\\n+ ada/libgnat/g-sets.o \\\n  ada/libgnat/g-spchge.o\t\\\n  ada/libgnat/g-speche.o\t\\\n  ada/libgnat/g-u3spch.o\t\\"}, {"sha": "8f68b553b80c21161c2e81d4cc661721b3c94a81", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -298,6 +298,7 @@ package body Impunit is\n     (\"g-semaph\", F),  -- GNAT.Semaphores\n     (\"g-sercom\", F),  -- GNAT.Serial_Communications\n     (\"g-sestin\", F),  -- GNAT.Secondary_Stack_Info\n+    (\"g-sets  \", F),  -- GNAT.Sets\n     (\"g-sha1  \", F),  -- GNAT.SHA1\n     (\"g-sha224\", F),  -- GNAT.SHA224\n     (\"g-sha256\", F),  -- GNAT.SHA256"}, {"sha": "004c276070bf26ecef2f930e455e98224a1fcb8a", "filename": "gcc/ada/libgnat/g-dynhta.adb", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -369,7 +369,7 @@ package body GNAT.Dynamic_HTables is\n    --------------------\n \n    package body Dynamic_HTable is\n-      Minimum_Size : constant Bucket_Range_Type := 32;\n+      Minimum_Size : constant Bucket_Range_Type := 8;\n       --  Minimum size of the buckets\n \n       Safe_Compression_Size : constant Bucket_Range_Type :=\n@@ -401,8 +401,8 @@ package body GNAT.Dynamic_HTables is\n \n       procedure Ensure_Unlocked (T : Instance);\n       pragma Inline (Ensure_Unlocked);\n-      --  Verify that hash table T is unlocked. Raise Table_Locked if this is\n-      --  not the case.\n+      --  Verify that hash table T is unlocked. Raise Iterated if this is not\n+      --  the case.\n \n       function Find_Bucket\n         (Bkts : Bucket_Table_Ptr;\n@@ -472,9 +472,10 @@ package body GNAT.Dynamic_HTables is\n       -- Create --\n       ------------\n \n-      function Create (Initial_Size : Bucket_Range_Type) return Instance is\n+      function Create (Initial_Size : Positive) return Instance is\n          Size : constant Bucket_Range_Type :=\n-                           Bucket_Range_Type'Max (Initial_Size, Minimum_Size);\n+                           Bucket_Range_Type'Max\n+                             (Bucket_Range_Type (Initial_Size), Minimum_Size);\n          --  Ensure that the buckets meet a minimum size\n \n          T : constant Instance := new Hash_Table;\n@@ -661,8 +662,8 @@ package body GNAT.Dynamic_HTables is\n \n          --  The hash table has at least one outstanding iterator\n \n-         if T.Locked > 0 then\n-            raise Table_Locked;\n+         if T.Iterators > 0 then\n+            raise Iterated;\n          end if;\n       end Ensure_Unlocked;\n \n@@ -697,7 +698,7 @@ package body GNAT.Dynamic_HTables is\n \n          Nod := Head.Next;\n          while Is_Valid (Nod, Head) loop\n-            if Equivalent_Keys (Nod.Key, Key) then\n+            if Nod.Key = Key then\n                return Nod;\n             end if;\n \n@@ -797,6 +798,17 @@ package body GNAT.Dynamic_HTables is\n          return Is_OK;\n       end Has_Next;\n \n+      --------------\n+      -- Is_Empty --\n+      --------------\n+\n+      function Is_Empty (T : Instance) return Boolean is\n+      begin\n+         Ensure_Created (T);\n+\n+         return T.Pairs = 0;\n+      end Is_Empty;\n+\n       --------------\n       -- Is_Valid --\n       --------------\n@@ -880,7 +892,7 @@ package body GNAT.Dynamic_HTables is\n          --  The hash table may be locked multiple times if multiple iterators\n          --  are operating over it.\n \n-         T.Locked := T.Locked + 1;\n+         T.Iterators := T.Iterators + 1;\n       end Lock;\n \n       -----------------------\n@@ -1046,11 +1058,7 @@ package body GNAT.Dynamic_HTables is\n       -- Put --\n       ---------\n \n-      procedure Put\n-        (T     : Instance;\n-         Key   : Key_Type;\n-         Value : Value_Type)\n-      is\n+      procedure Put (T : Instance; Key : Key_Type; Value : Value_Type) is\n          procedure Expand;\n          pragma Inline (Expand);\n          --  Determine whether hash table T requires expansion, and if so,\n@@ -1099,7 +1107,7 @@ package body GNAT.Dynamic_HTables is\n \n             Nod := Head.Next;\n             while Is_Valid (Nod, Head) loop\n-               if Equivalent_Keys (Nod.Key, Key) then\n+               if Nod.Key = Key then\n                   Nod.Value := Value;\n                   return;\n                end if;\n@@ -1172,7 +1180,7 @@ package body GNAT.Dynamic_HTables is\n       -- Size --\n       ----------\n \n-      function Size (T : Instance) return Pair_Count_Type is\n+      function Size (T : Instance) return Natural is\n       begin\n          Ensure_Created (T);\n \n@@ -1188,7 +1196,7 @@ package body GNAT.Dynamic_HTables is\n          --  The hash table may be locked multiple times if multiple iterators\n          --  are operating over it.\n \n-         T.Locked := T.Locked - 1;\n+         T.Iterators := T.Iterators - 1;\n       end Unlock;\n    end Dynamic_HTable;\n "}, {"sha": "b8fb6a61dc5a40cc2ffed25c3682029eaa4c6347", "filename": "gcc/ada/libgnat/g-dynhta.ads", "status": "modified", "additions": 15, "deletions": 40, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -283,21 +283,11 @@ package GNAT.Dynamic_HTables is\n    --\n    --  The destruction of the table reclaims all storage occupied by it.\n \n-   --  The following type denotes the underlying range of the hash table\n-   --  buckets.\n-\n-   type Bucket_Range_Type is mod 2 ** 32;\n-\n    --  The following type denotes the multiplicative factor used in expansion\n    --  and compression of the hash table.\n \n    subtype Factor_Type is Bucket_Range_Type range 2 .. 100;\n \n-   --  The following type denotes the number of key-value pairs stored in the\n-   --  hash table.\n-\n-   type Pair_Count_Type is range 0 .. 2 ** 31 - 1;\n-\n    --  The following type denotes the threshold range used in expansion and\n    --  compression of the hash table.\n \n@@ -333,10 +323,9 @@ package GNAT.Dynamic_HTables is\n       --  that the size of the buckets will be halved once the load factor\n       --  drops below 0.5.\n \n-      with function Equivalent_Keys\n+      with function \"=\"\n              (Left  : Key_Type;\n               Right : Key_Type) return Boolean;\n-      --  Determine whether two keys are equivalent\n \n       with function Hash (Key : Key_Type) return Bucket_Range_Type;\n       --  Map an arbitrary key into the range of buckets\n@@ -353,52 +342,44 @@ package GNAT.Dynamic_HTables is\n       type Instance is private;\n       Nil : constant Instance;\n \n-      Not_Created : exception;\n-      --  This exception is raised when the hash table has not been created by\n-      --  routine Create, and an attempt is made to read or mutate its state.\n-\n-      Table_Locked : exception;\n-      --  This exception is raised when the hash table is being iterated on,\n-      --  and an attempt is made to mutate its state.\n-\n-      function Create (Initial_Size : Bucket_Range_Type) return Instance;\n+      function Create (Initial_Size : Positive) return Instance;\n       --  Create a new table with bucket capacity Initial_Size. This routine\n       --  must be called at the start of a hash table's lifetime.\n \n       procedure Delete (T : Instance; Key : Key_Type);\n       --  Delete the value which corresponds to key Key from hash table T. The\n       --  routine has no effect if the value is not present in the hash table.\n-      --  This action will raise Table_Locked if the hash table has outstanding\n+      --  This action will raise Iterated if the hash table has outstanding\n       --  iterators. If the load factor drops below Compression_Threshold, the\n       --  size of the buckets is decreased by Copression_Factor.\n \n       procedure Destroy (T : in out Instance);\n       --  Destroy the contents of hash table T, rendering it unusable. This\n       --  routine must be called at the end of a hash table's lifetime. This\n-      --  action will raise Table_Locked if the hash table has outstanding\n+      --  action will raise Iterated if the hash table has outstanding\n       --  iterators.\n \n       function Get (T : Instance; Key : Key_Type) return Value_Type;\n       --  Obtain the value which corresponds to key Key from hash table T. If\n       --  the value does not exist, return No_Value.\n \n-      procedure Put\n-        (T     : Instance;\n-         Key   : Key_Type;\n-         Value : Value_Type);\n+      function Is_Empty (T : Instance) return Boolean;\n+      --  Determine whether hash table T is empty\n+\n+      procedure Put (T : Instance; Key : Key_Type; Value : Value_Type);\n       --  Associate value Value with key Key in hash table T. If the table\n       --  already contains a mapping of the same key to a previous value, the\n-      --  previous value is overwritten. This action will raise Table_Locked\n-      --  if the hash table has outstanding iterators. If the load factor goes\n+      --  previous value is overwritten. This action will raise Iterated if\n+      --  the hash table has outstanding iterators. If the load factor goes\n       --  over Expansion_Threshold, the size of the buckets is increased by\n       --  Expansion_Factor.\n \n       procedure Reset (T : Instance);\n       --  Destroy the contents of hash table T, and reset it to its initial\n-      --  created state. This action will raise Table_Locked if the hash table\n+      --  created state. This action will raise Iterated if the hash table\n       --  has outstanding iterators.\n \n-      function Size (T : Instance) return Pair_Count_Type;\n+      function Size (T : Instance) return Natural;\n       --  Obtain the number of key-value pairs in hash table T\n \n       -------------------------\n@@ -420,10 +401,6 @@ package GNAT.Dynamic_HTables is\n \n       type Iterator is private;\n \n-      Iterator_Exhausted : exception;\n-      --  This exception is raised when an iterator is exhausted and further\n-      --  attempts to advance it are made by calling routine Next.\n-\n       function Iterate (T : Instance) return Iterator;\n       --  Obtain an iterator over the keys of hash table T. This action locks\n       --  all mutation functionality of the associated hash table.\n@@ -433,9 +410,7 @@ package GNAT.Dynamic_HTables is\n       --  iterator has been exhausted, restore all mutation functionality of\n       --  the associated hash table.\n \n-      procedure Next\n-        (Iter : in out Iterator;\n-         Key  : out Key_Type);\n+      procedure Next (Iter : in out Iterator; Key : out Key_Type);\n       --  Return the current key referenced by iterator Iter and advance to\n       --  the next available key. If the iterator has been exhausted and\n       --  further attempts are made to advance it, this routine restores\n@@ -487,10 +462,10 @@ package GNAT.Dynamic_HTables is\n          Initial_Size : Bucket_Range_Type := 0;\n          --  The initial size of the buckets as specified at creation time\n \n-         Locked : Natural := 0;\n+         Iterators : Natural := 0;\n          --  Number of outstanding iterators\n \n-         Pairs : Pair_Count_Type := 0;\n+         Pairs : Natural := 0;\n          --  Number of key-value pairs in the buckets\n       end record;\n "}, {"sha": "ca39a4c38440df72f244af6aafceec96db345e3d", "filename": "gcc/ada/libgnat/g-lists.adb", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-lists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.adb?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -54,7 +54,7 @@ package body GNAT.Lists is\n \n       procedure Ensure_Unlocked (L : Instance);\n       pragma Inline (Ensure_Unlocked);\n-      --  Verify that list L is unlocked. Raise List_Locked if this is not the\n+      --  Verify that list L is unlocked. Raise Iterated if this is not the\n       --  case.\n \n       function Find_Node\n@@ -306,8 +306,8 @@ package body GNAT.Lists is\n \n          --  The list has at least one outstanding iterator\n \n-         if L.Locked > 0 then\n-            raise List_Locked;\n+         if L.Iterators > 0 then\n+            raise Iterated;\n          end if;\n       end Ensure_Unlocked;\n \n@@ -514,17 +514,6 @@ package body GNAT.Lists is\n          return L.Nodes.Prev.Elem;\n       end Last;\n \n-      ------------\n-      -- Length --\n-      ------------\n-\n-      function Length (L : Instance) return Element_Count_Type is\n-      begin\n-         Ensure_Created (L);\n-\n-         return L.Elements;\n-      end Length;\n-\n       ----------\n       -- Lock --\n       ----------\n@@ -536,17 +525,14 @@ package body GNAT.Lists is\n          --  The list may be locked multiple times if multiple iterators are\n          --  operating over it.\n \n-         L.Locked := L.Locked + 1;\n+         L.Iterators := L.Iterators + 1;\n       end Lock;\n \n       ----------\n       -- Next --\n       ----------\n \n-      procedure Next\n-        (Iter : in out Iterator;\n-         Elem : out Element_Type)\n-      is\n+      procedure Next (Iter : in out Iterator; Elem : out Element_Type) is\n          Is_OK : constant Boolean  := Is_Valid (Iter);\n          Saved : constant Node_Ptr := Iter.Nod;\n \n@@ -617,6 +603,17 @@ package body GNAT.Lists is\n          end if;\n       end Replace;\n \n+      ----------\n+      -- Size --\n+      ----------\n+\n+      function Size (L : Instance) return Natural is\n+      begin\n+         Ensure_Created (L);\n+\n+         return L.Elements;\n+      end Size;\n+\n       ------------\n       -- Unlock --\n       ------------\n@@ -628,7 +625,7 @@ package body GNAT.Lists is\n          --  The list may be locked multiple times if multiple iterators are\n          --  operating over it.\n \n-         L.Locked := L.Locked - 1;\n+         L.Iterators := L.Iterators - 1;\n       end Unlock;\n    end Doubly_Linked_List;\n "}, {"sha": "bf7795a1ee48ceadea81008291343d2045e71d7a", "filename": "gcc/ada/libgnat/g-lists.ads", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-lists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-lists.ads?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -49,14 +49,10 @@ package GNAT.Lists is\n    --\n    --    <various operations>\n    --\n-   --    Destroy (List)\n+   --    Destroy (List);\n    --\n    --  The destruction of the list reclaims all storage occupied by it.\n \n-   --  The following type denotes the number of elements stored in a list\n-\n-   type Element_Count_Type is range 0 .. 2 ** 31 - 1;\n-\n    generic\n       type Element_Type is private;\n \n@@ -73,21 +69,14 @@ package GNAT.Lists is\n       type Instance is private;\n       Nil : constant Instance;\n \n-      List_Empty : exception;\n-      --  This exception is raised when the list is empty, and an attempt is\n-      --  made to delete an element from it.\n+      --  The following exception is raised when the list is empty, and an\n+      --  attempt is made to delete an element from it.\n \n-      List_Locked : exception;\n-      --  This exception is raised when the list is being iterated on, and an\n-      --  attempt is made to mutate its state.\n-\n-      Not_Created : exception;\n-      --  This exception is raised when the list has not been created by\n-      --  routine Create, and an attempt is made to read or mutate its state.\n+      List_Empty : exception;\n \n       procedure Append (L : Instance; Elem : Element_Type);\n       --  Insert element Elem at the end of list L. This action will raise\n-      --  List_Locked if the list has outstanding iterators.\n+      --  Iterated if the list has outstanding iterators.\n \n       function Contains (L : Instance; Elem : Element_Type) return Boolean;\n       --  Determine whether list L contains element Elem\n@@ -100,23 +89,23 @@ package GNAT.Lists is\n       --  not present. This action will raise\n       --\n       --    * List_Empty if the list is empty.\n-      --    * List_Locked if the list has outstanding iterators.\n+      --    * Iterated if the list has outstanding iterators.\n \n       procedure Delete_First (L : Instance);\n       --  Delete an element from the start of list L. This action will raise\n       --\n       --    * List_Empty if the list is empty.\n-      --    * List_Locked if the list has outstanding iterators.\n+      --    * Iterated if the list has outstanding iterators.\n \n       procedure Delete_Last (L : Instance);\n       --  Delete an element from the end of list L. This action will raise\n       --\n       --    * List_Empty if the list is empty.\n-      --    * List_Locked if the list has outstanding iterators.\n+      --    * Iterated if the list has outstanding iterators.\n \n       procedure Destroy (L : in out Instance);\n       --  Destroy the contents of list L. This routine must be called at the\n-      --  end of a list's lifetime. This action will raise List_Locked if the\n+      --  end of a list's lifetime. This action will raise Iterated if the\n       --  list has outstanding iterators.\n \n       function First (L : Instance) return Element_Type;\n@@ -129,15 +118,15 @@ package GNAT.Lists is\n          Elem  : Element_Type);\n       --  Insert new element Elem after element After in list L. The routine\n       --  has no effect if After is not present. This action will raise\n-      --  List_Locked if the list has outstanding iterators.\n+      --  Iterated if the list has outstanding iterators.\n \n       procedure Insert_Before\n         (L      : Instance;\n          Before : Element_Type;\n          Elem   : Element_Type);\n       --  Insert new element Elem before element Before in list L. The routine\n       --  has no effect if After is not present. This action will raise\n-      --  List_Locked if the list has outstanding iterators.\n+      --  Iterated if the list has outstanding iterators.\n \n       function Is_Empty (L : Instance) return Boolean;\n       --  Determine whether list L is empty\n@@ -146,20 +135,20 @@ package GNAT.Lists is\n       --  Obtain an element from the end of list L. This action will raise\n       --  List_Empty if the list is empty.\n \n-      function Length (L : Instance) return Element_Count_Type;\n-      --  Obtain the number of elements in list L\n-\n       procedure Prepend (L : Instance; Elem : Element_Type);\n       --  Insert element Elem at the start of list L. This action will raise\n-      --  List_Locked if the list has outstanding iterators.\n+      --  Iterated if the list has outstanding iterators.\n \n       procedure Replace\n         (L        : Instance;\n          Old_Elem : Element_Type;\n          New_Elem : Element_Type);\n       --  Replace old element Old_Elem with new element New_Elem in list L. The\n       --  routine has no effect if Old_Elem is not present. This action will\n-      --  raise List_Locked if the list has outstanding iterators.\n+      --  raise Iterated if the list has outstanding iterators.\n+\n+      function Size (L : Instance) return Natural;\n+      --  Obtain the number of elements in list L\n \n       -------------------------\n       -- Iterator operations --\n@@ -179,10 +168,6 @@ package GNAT.Lists is\n \n       type Iterator is private;\n \n-      Iterator_Exhausted : exception;\n-      --  This exception is raised when an iterator is exhausted and further\n-      --  attempts to advance it are made by calling routine Next.\n-\n       function Iterate (L : Instance) return Iterator;\n       --  Obtain an iterator over the elements of list L. This action locks all\n       --  mutation functionality of the associated list.\n@@ -192,9 +177,7 @@ package GNAT.Lists is\n       --  iterator has been exhausted, restore all mutation functionality of\n       --  the associated list.\n \n-      procedure Next\n-        (Iter : in out Iterator;\n-         Elem : out Element_Type);\n+      procedure Next (Iter : in out Iterator; Elem : out Element_Type);\n       --  Return the current element referenced by iterator Iter and advance\n       --  to the next available element. If the iterator has been exhausted\n       --  and further attempts are made to advance it, this routine restores\n@@ -216,10 +199,10 @@ package GNAT.Lists is\n       --  The following type represents a list\n \n       type Linked_List is record\n-         Elements : Element_Count_Type := 0;\n+         Elements : Natural := 0;\n          --  The number of elements in the list\n \n-         Locked : Natural := 0;\n+         Iterators : Natural := 0;\n          --  Number of outstanding iterators\n \n          Nodes : aliased Node;"}, {"sha": "90a5810c0e72d101095da263c5c191639dedd7d7", "filename": "gcc/ada/libgnat/g-sets.adb", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-sets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-sets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sets.adb?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -0,0 +1,131 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                            G N A T . S E T S                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                        Copyright (C) 2018, AdaCore                       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body GNAT.Sets is\n+\n+   --------------------\n+   -- Membership_Set --\n+   --------------------\n+\n+   package body Membership_Set is\n+\n+      --------------\n+      -- Contains --\n+      --------------\n+\n+      function Contains (S : Instance; Elem : Element_Type) return Boolean is\n+      begin\n+         return Hashed_Set.Get (Hashed_Set.Instance (S), Elem);\n+      end Contains;\n+\n+      ------------\n+      -- Create --\n+      ------------\n+\n+      function Create (Initial_Size : Positive) return Instance is\n+      begin\n+         return Instance (Hashed_Set.Create (Initial_Size));\n+      end Create;\n+\n+      ------------\n+      -- Delete --\n+      ------------\n+\n+      procedure Delete (S : Instance; Elem : Element_Type) is\n+      begin\n+         Hashed_Set.Delete (Hashed_Set.Instance (S), Elem);\n+      end Delete;\n+\n+      -------------\n+      -- Destroy --\n+      -------------\n+\n+      procedure Destroy (S : in out Instance) is\n+      begin\n+         Hashed_Set.Destroy (Hashed_Set.Instance (S));\n+      end Destroy;\n+\n+      --------------\n+      -- Has_Next --\n+      --------------\n+\n+      function Has_Next (Iter : Iterator) return Boolean is\n+      begin\n+         return Hashed_Set.Has_Next (Hashed_Set.Iterator (Iter));\n+      end Has_Next;\n+\n+      ------------\n+      -- Insert --\n+      ------------\n+\n+      procedure Insert (S : Instance; Elem : Element_Type) is\n+      begin\n+         Hashed_Set.Put (Hashed_Set.Instance (S), Elem, True);\n+      end Insert;\n+\n+      --------------\n+      -- Is_Empty --\n+      --------------\n+\n+      function Is_Empty (S : Instance) return Boolean is\n+      begin\n+         return Hashed_Set.Is_Empty (Hashed_Set.Instance (S));\n+      end Is_Empty;\n+\n+      -------------\n+      -- Iterate --\n+      -------------\n+\n+      function Iterate (S : Instance) return Iterator is\n+      begin\n+         return Iterator (Hashed_Set.Iterate (Hashed_Set.Instance (S)));\n+      end Iterate;\n+\n+      ----------\n+      -- Next --\n+      ----------\n+\n+      procedure Next (Iter : in out Iterator; Elem : out Element_Type) is\n+      begin\n+         Hashed_Set.Next (Hashed_Set.Iterator (Iter), Elem);\n+      end Next;\n+\n+      ----------\n+      -- Size --\n+      ----------\n+\n+      function Size (S : Instance) return Natural is\n+      begin\n+         return Hashed_Set.Size (Hashed_Set.Instance (S));\n+      end Size;\n+   end Membership_Set;\n+\n+end GNAT.Sets;"}, {"sha": "59e413b51a0350af6c3bb85faa1bfc7ca455f679", "filename": "gcc/ada/libgnat/g-sets.ads", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-sets.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fg-sets.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sets.ads?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -0,0 +1,161 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                            G N A T . S E T S                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                        Copyright (C) 2018, AdaCore                       --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Compiler_Unit_Warning;\n+\n+with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n+\n+package GNAT.Sets is\n+\n+   --------------------\n+   -- Membership_Set --\n+   --------------------\n+\n+   --  The following package offers a membership set abstraction with the\n+   --  following characteristics:\n+   --\n+   --    * Creation of multiple instances, of different sizes.\n+   --    * Iterable elements.\n+   --\n+   --  The following use pattern must be employed with this set:\n+   --\n+   --    Set : Instance := Create (<some size>);\n+   --\n+   --    <various operations>\n+   --\n+   --    Destroy (Set);\n+   --\n+   --  The destruction of the set reclaims all storage occupied by it.\n+\n+   generic\n+      type Element_Type is private;\n+\n+      with function \"=\"\n+             (Left  : Element_Type;\n+              Right : Element_Type) return Boolean;\n+\n+      with function Hash (Key : Element_Type) return Bucket_Range_Type;\n+      --  Map an arbitrary key into the range of buckets\n+\n+   package Membership_Set is\n+\n+      --------------------\n+      -- Set operations --\n+      --------------------\n+\n+      --  The following type denotes a membership set handle. Each instance\n+      --  must be created using routine Create.\n+\n+      type Instance is private;\n+      Nil : constant Instance;\n+\n+      function Contains (S : Instance; Elem : Element_Type) return Boolean;\n+      --  Determine whether membership set S contains element Elem\n+\n+      function Create (Initial_Size : Positive) return Instance;\n+      --  Create a new membership set with bucket capacity Initial_Size. This\n+      --  routine must be called at the start of the membership set's lifetime.\n+\n+      procedure Delete (S : Instance; Elem : Element_Type);\n+      --  Delete element Elem from membership set S. The routine has no effect\n+      --  if the element is not present in the membership set. This action will\n+      --  raise Iterated if the membership set has outstanding iterators.\n+\n+      procedure Destroy (S : in out Instance);\n+      --  Destroy the contents of membership set S, rendering it unusable. This\n+      --  routine must be called at the end of the membership set's lifetime.\n+      --  This action will raise Iterated if the hash table has outstanding\n+      --  iterators.\n+\n+      procedure Insert (S : Instance; Elem : Element_Type);\n+      --  Insert element Elem in membership set S. The routine has no effect\n+      --  if the element is already present in the membership set. This action\n+      --  will raise Iterated if the membership set has outstanding iterators.\n+\n+      function Is_Empty (S : Instance) return Boolean;\n+      --  Determine whether set S is empty\n+\n+      function Size (S : Instance) return Natural;\n+      --  Obtain the number of elements in membership set S\n+\n+      -------------------------\n+      -- Iterator operations --\n+      -------------------------\n+\n+      --  The following type represents an element iterator. An iterator locks\n+      --  all mutation operations, and unlocks them once it is exhausted. The\n+      --  iterator must be used with the following pattern:\n+      --\n+      --    Iter := Iterate (My_Set);\n+      --    while Has_Next (Iter) loop\n+      --       Next (Iter, Element);\n+      --    end loop;\n+      --\n+      --  It is possible to advance the iterator by using Next only, however\n+      --  this risks raising Iterator_Exhausted.\n+\n+      type Iterator is private;\n+\n+      function Iterate (S : Instance) return Iterator;\n+      --  Obtain an iterator over the elements of membership set S. This action\n+      --  locks all mutation functionality of the associated membership set.\n+\n+      function Has_Next (Iter : Iterator) return Boolean;\n+      --  Determine whether iterator Iter has more keys to examine. If the\n+      --  iterator has been exhausted, restore all mutation functionality of\n+      --  the associated membership set.\n+\n+      procedure Next (Iter : in out Iterator; Elem : out Element_Type);\n+      --  Return the current element referenced by iterator Iter and advance\n+      --  to the next available element. If the iterator has been exhausted\n+      --  and further attempts are made to advance it, this routine restores\n+      --  mutation functionality of the associated membership set, and then\n+      --  raises Iterator_Exhausted.\n+\n+   private\n+      package Hashed_Set is new Dynamic_HTable\n+        (Key_Type              => Element_Type,\n+         Value_Type            => Boolean,\n+         No_Value              => False,\n+         Expansion_Threshold   => 1.5,\n+         Expansion_Factor      => 2,\n+         Compression_Threshold => 0.3,\n+         Compression_Factor    => 2,\n+         \"=\"                   => \"=\",\n+         Hash                  => Hash);\n+\n+      type Instance is new Hashed_Set.Instance;\n+      Nil : constant Instance := Instance (Hashed_Set.Nil);\n+\n+      type Iterator is new Hashed_Set.Iterator;\n+   end Membership_Set;\n+\n+end GNAT.Sets;"}, {"sha": "faec6c5ba059bf8df086ec9b5fa0194f4bf52d38", "filename": "gcc/ada/libgnat/gnat.ads", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fgnat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Fada%2Flibgnat%2Fgnat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fgnat.ads?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -34,4 +34,24 @@\n package GNAT is\n    pragma Pure;\n \n+   --  The following type denotes the range of buckets for various hashed\n+   --  data structures in the GNAT unit hierarchy.\n+\n+   type Bucket_Range_Type is mod 2 ** 32;\n+\n+   --  The following exception is raised whenever an attempt is made to mutate\n+   --  the state of a data structure that is being iterated on.\n+\n+   Iterated : exception;\n+\n+   --  The following exception is raised when an iterator is exhausted and\n+   --  further attempts are made to advance it.\n+\n+   Iterator_Exhausted : exception;\n+\n+   --  The following exception is raised whenever an attempt is made to mutate\n+   --  the state of a data structure that has not been created yet.\n+\n+   Not_Created : exception;\n+\n end GNAT;"}, {"sha": "459563f3eb940b6b03e298aa7ba6b734f254edd6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -1,3 +1,9 @@\n+2018-09-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/sets1.adb: New testcase.\n+\t* gnat.dg/dynhash.adb, gnat.dg/linkedlist.adb: Update testcases\n+\tto new API.\n+\n 2018-09-26  Thomas Quinot  <quinot@adacore.com>\n \n \t* gnat.dg/sso12.adb: New testcase."}, {"sha": "c51e6e218e1d67516ee592935ab1d43549646880", "filename": "gcc/testsuite/gnat.dg/dynhash.adb", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash.adb?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -1,6 +1,7 @@\n --  { dg-do run }\n \n with Ada.Text_IO;          use Ada.Text_IO;\n+with GNAT;                 use GNAT;\n with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n \n procedure Dynhash is\n@@ -14,14 +15,14 @@ procedure Dynhash is\n       Expansion_Factor      => 2,\n       Compression_Threshold => 0.3,\n       Compression_Factor    => 2,\n-      Equivalent_Keys       => \"=\",\n+      \"=\"                   => \"=\",\n       Hash                  => Hash);\n    use DHT;\n \n    function Create_And_Populate\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Bucket_Range_Type) return Instance;\n+      Init_Size : Positive) return Instance;\n    --  Create a hash table with initial size Init_Size and populate it with\n    --  key-value pairs where both keys and values are in the range Low_Key\n    --  .. High_Key.\n@@ -50,19 +51,19 @@ procedure Dynhash is\n    procedure Check_Size\n      (Caller    : String;\n       T         : Instance;\n-      Exp_Count : Pair_Count_Type);\n+      Exp_Count : Natural);\n    --  Ensure that the count of key-value pairs of hash table T matches\n    --  expected count Exp_Count. Emit an error if this is not the case.\n \n-   procedure Test_Create (Init_Size : Bucket_Range_Type);\n+   procedure Test_Create (Init_Size : Positive);\n    --  Verify that all dynamic hash table operations fail on a non-created\n    --  table of size Init_Size.\n \n    procedure Test_Delete_Get_Put_Size\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Exp_Count : Pair_Count_Type;\n-      Init_Size : Bucket_Range_Type);\n+      Exp_Count : Natural;\n+      Init_Size : Positive);\n    --  Verify that\n    --\n    --    * Put properly inserts values in the hash table.\n@@ -78,7 +79,7 @@ procedure Dynhash is\n    procedure Test_Iterate\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Bucket_Range_Type);\n+      Init_Size : Positive);\n    --  Verify that iterators\n    --\n    --    * Properly visit each key exactly once.\n@@ -88,7 +89,7 @@ procedure Dynhash is\n    --  Low_Key and High_Key denote the range of keys to be inserted, retrieved,\n    --  and deleted. Init_Size denotes the initial size of the table.\n \n-   procedure Test_Iterate_Empty (Init_Size : Bucket_Range_Type);\n+   procedure Test_Iterate_Empty (Init_Size : Positive);\n    --  Verify that an iterator over an empty hash table\n    --\n    --    * Does not visit any key\n@@ -100,7 +101,7 @@ procedure Dynhash is\n    procedure Test_Iterate_Forced\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Bucket_Range_Type);\n+      Init_Size : Positive);\n    --  Verify that an iterator that is forcefully advanced by just Next\n    --\n    --    * Properly visit each key exactly once.\n@@ -113,15 +114,15 @@ procedure Dynhash is\n    procedure Test_Replace\n      (Low_Val   : Integer;\n       High_Val  : Integer;\n-      Init_Size : Bucket_Range_Type);\n+      Init_Size : Positive);\n    --  Verify that Put properly updates the value of a particular key. Low_Val\n    --  and High_Val denote the range of values to be updated. Init_Size denotes\n    --  the initial size of the table.\n \n    procedure Test_Reset\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Bucket_Range_Type);\n+      Init_Size : Positive);\n    --  Verify that Reset properly destroy and recreats a hash table. Low_Key\n    --  and High_Key denote the range of keys to be inserted in the hash table.\n    --  Init_Size denotes the initial size of the table.\n@@ -133,7 +134,7 @@ procedure Dynhash is\n    function Create_And_Populate\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Bucket_Range_Type) return Instance\n+      Init_Size : Positive) return Instance\n    is\n       T : Instance;\n \n@@ -232,7 +233,7 @@ procedure Dynhash is\n          Delete (T, 1);\n          Put_Line (\"ERROR: \" & Caller & \": Delete: no exception raised\");\n       exception\n-         when Table_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Delete: unexpected exception\");\n@@ -242,7 +243,7 @@ procedure Dynhash is\n          Destroy (T);\n          Put_Line (\"ERROR: \" & Caller & \": Destroy: no exception raised\");\n       exception\n-         when Table_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Destroy: unexpected exception\");\n@@ -252,7 +253,7 @@ procedure Dynhash is\n          Put (T, 1, 1);\n          Put_Line (\"ERROR: \" & Caller & \": Put: no exception raised\");\n       exception\n-         when Table_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Put: unexpected exception\");\n@@ -262,7 +263,7 @@ procedure Dynhash is\n          Reset (T);\n          Put_Line (\"ERROR: \" & Caller & \": Reset: no exception raised\");\n       exception\n-         when Table_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Reset: unexpected exception\");\n@@ -273,12 +274,12 @@ procedure Dynhash is\n    -- Check_Size --\n    ----------------\n \n-   procedure Check_Size\n+   procedure Check_Size \n      (Caller    : String;\n       T         : Instance;\n-      Exp_Count : Pair_Count_Type)\n+      Exp_Count : Natural)\n    is\n-      Count : constant Pair_Count_Type := Size (T);\n+      Count : constant Natural := Size (T);\n \n    begin\n       if Count /= Exp_Count then\n@@ -301,8 +302,8 @@ procedure Dynhash is\n    -- Test_Create --\n    -----------------\n \n-   procedure Test_Create (Init_Size : Bucket_Range_Type) is\n-      Count : Pair_Count_Type;\n+   procedure Test_Create (Init_Size : Positive) is\n+      Count : Natural;\n       Iter  : Iterator;\n       T     : Instance;\n       Val   : Integer;\n@@ -397,8 +398,8 @@ procedure Dynhash is\n    procedure Test_Delete_Get_Put_Size\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Exp_Count : Pair_Count_Type;\n-      Init_Size : Bucket_Range_Type)\n+      Exp_Count : Natural;\n+      Init_Size : Positive)\n    is\n       Exp_Val : Integer;\n       T       : Instance;\n@@ -478,7 +479,7 @@ procedure Dynhash is\n    procedure Test_Iterate\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Bucket_Range_Type)\n+      Init_Size : Positive)\n    is\n       Iter_1 : Iterator;\n       Iter_2 : Iterator;\n@@ -527,7 +528,7 @@ procedure Dynhash is\n       --  operations of the hash table because all outstanding iterators have\n       --  been exhausted.\n \n-      Check_Keys\n+      Check_Keys \n         (Caller   => \"Test_Iterate\",\n          Iter     => Iter_2,\n          Low_Key  => Low_Key,\n@@ -548,7 +549,7 @@ procedure Dynhash is\n    -- Test_Iterate_Empty --\n    ------------------------\n \n-   procedure Test_Iterate_Empty (Init_Size : Bucket_Range_Type) is\n+   procedure Test_Iterate_Empty (Init_Size : Positive) is\n       Iter : Iterator;\n       Key  : Integer;\n       T    : Instance;\n@@ -594,7 +595,7 @@ procedure Dynhash is\n    procedure Test_Iterate_Forced\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Bucket_Range_Type)\n+      Init_Size : Positive)\n    is\n       Iter : Iterator;\n       Key  : Integer;\n@@ -649,7 +650,7 @@ procedure Dynhash is\n    procedure Test_Replace\n      (Low_Val   : Integer;\n       High_Val  : Integer;\n-      Init_Size : Bucket_Range_Type)\n+      Init_Size : Positive)\n    is\n       Key : constant Integer := 1;\n       T   : Instance;\n@@ -681,10 +682,10 @@ procedure Dynhash is\n    -- Test_Reset --\n    ----------------\n \n-   procedure Test_Reset\n+   procedure Test_Reset \n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Bucket_Range_Type)\n+      Init_Size : Positive)\n    is\n       T : Instance;\n "}, {"sha": "b608fe183f18dfa6c949dd9b4968cd8dc675f0f2", "filename": "gcc/testsuite/gnat.dg/linkedlist.adb", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flinkedlist.adb?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -1,6 +1,7 @@\n --  { dg-do run }\n \n with Ada.Text_IO; use Ada.Text_IO;\n+with GNAT;        use GNAT;\n with GNAT.Lists;  use GNAT.Lists;\n \n procedure Linkedlist is\n@@ -97,15 +98,15 @@ procedure Linkedlist is\n    procedure Test_Last;\n    --  Verify that Last properly returns the tail of a list\n \n-   procedure Test_Length;\n-   --  Verify that Length returns the correct length of a list\n-\n    procedure Test_Prepend;\n    --  Verify that Prepend properly inserts at the head of a list\n \n    procedure Test_Replace;\n    --  Verify that Replace properly substitutes old elements with new ones\n \n+   procedure Test_Size;\n+   --  Verify that Size returns the correct size of a list\n+\n    -----------------\n    -- Check_Empty --\n    -----------------\n@@ -116,7 +117,7 @@ procedure Linkedlist is\n       Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n-      Len : constant Element_Count_Type := Length (L);\n+      Len : constant Natural := Size (L);\n \n    begin\n       for Elem in Low_Elem .. High_Elem loop\n@@ -142,7 +143,7 @@ procedure Linkedlist is\n          Append (L, 1);\n          Put_Line (\"ERROR: \" & Caller & \": Append: no exception raised\");\n       exception\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n             Put_Line (\"ERROR: \" & Caller & \": Append: unexpected exception\");\n@@ -154,7 +155,7 @@ procedure Linkedlist is\n       exception\n          when List_Empty =>\n             null;\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n             Put_Line (\"ERROR: \" & Caller & \": Delete: unexpected exception\");\n@@ -166,7 +167,7 @@ procedure Linkedlist is\n       exception\n          when List_Empty =>\n             null;\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n             Put_Line\n@@ -179,18 +180,18 @@ procedure Linkedlist is\n       exception\n          when List_Empty =>\n             null;\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n-            Put_Line\n+            Put_Line \n               (\"ERROR: \" & Caller & \": Delete_Last: unexpected exception\");\n       end;\n \n       begin\n          Destroy (L);\n          Put_Line (\"ERROR: \" & Caller & \": Destroy: no exception raised\");\n       exception\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n             Put_Line (\"ERROR: \" & Caller & \": Destroy: unexpected exception\");\n@@ -200,10 +201,10 @@ procedure Linkedlist is\n          Insert_After (L, 1, 2);\n          Put_Line (\"ERROR: \" & Caller & \": Insert_After: no exception raised\");\n       exception\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n-            Put_Line\n+            Put_Line \n               (\"ERROR: \" & Caller & \": Insert_After: unexpected exception\");\n       end;\n \n@@ -212,7 +213,7 @@ procedure Linkedlist is\n          Put_Line\n            (\"ERROR: \" & Caller & \": Insert_Before: no exception raised\");\n       exception\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n             Put_Line\n@@ -223,7 +224,7 @@ procedure Linkedlist is\n          Prepend (L, 1);\n          Put_Line (\"ERROR: \" & Caller & \": Prepend: no exception raised\");\n       exception\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n             Put_Line (\"ERROR: \" & Caller & \": Prepend: unexpected exception\");\n@@ -233,7 +234,7 @@ procedure Linkedlist is\n          Replace (L, 1, 2);\n          Put_Line (\"ERROR: \" & Caller & \": Replace: no exception raised\");\n       exception\n-         when List_Locked =>\n+         when Iterated =>\n             null;\n          when others =>\n             Put_Line (\"ERROR: \" & Caller & \": Replace: unexpected exception\");\n@@ -384,7 +385,7 @@ procedure Linkedlist is\n    -----------------\n \n    procedure Test_Create is\n-      Count : Element_Count_Type;\n+      Count : Natural;\n       Flag  : Boolean;\n       Iter  : Iterator;\n       L     : Instance;\n@@ -508,33 +509,33 @@ procedure Linkedlist is\n       end;\n \n       begin\n-         Count := Length (L);\n-         Put_Line (\"ERROR: Test_Create: Length: no exception raised\");\n+         Prepend (L, 1);\n+         Put_Line (\"ERROR: Test_Create: Prepend: no exception raised\");\n       exception\n          when Not_Created =>\n             null;\n          when others =>\n-            Put_Line (\"ERROR: Test_Create: Length: unexpected exception\");\n+            Put_Line (\"ERROR: Test_Create: Prepend: unexpected exception\");\n       end;\n \n       begin\n-         Prepend (L, 1);\n-         Put_Line (\"ERROR: Test_Create: Prepend: no exception raised\");\n+         Replace (L, 1, 2);\n+         Put_Line (\"ERROR: Test_Create: Replace: no exception raised\");\n       exception\n          when Not_Created =>\n             null;\n          when others =>\n-            Put_Line (\"ERROR: Test_Create: Prepend: unexpected exception\");\n+            Put_Line (\"ERROR: Test_Create: Replace: unexpected exception\");\n       end;\n \n       begin\n-         Replace (L, 1, 2);\n-         Put_Line (\"ERROR: Test_Create: Replace: no exception raised\");\n+         Count := Size (L);\n+         Put_Line (\"ERROR: Test_Create: Size: no exception raised\");\n       exception\n          when Not_Created =>\n             null;\n          when others =>\n-            Put_Line (\"ERROR: Test_Create: Replace: unexpected exception\");\n+            Put_Line (\"ERROR: Test_Create: Size: unexpected exception\");\n       end;\n    end Test_Create;\n \n@@ -654,7 +655,7 @@ procedure Linkedlist is\n \n       --  At this point the list should be completely empty\n \n-      Check_Empty\n+      Check_Empty \n         (Caller    => \"Test_Delete_First\",\n          L         => L,\n          Low_Elem  => Low_Elem,\n@@ -1055,44 +1056,6 @@ procedure Linkedlist is\n       Destroy (L);\n    end Test_Last;\n \n-   -----------------\n-   -- Test_Length --\n-   -----------------\n-\n-   procedure Test_Length is\n-      L   : Instance := Create;\n-      Len : Element_Count_Type;\n-\n-   begin\n-      Len := Length (L);\n-\n-      if Len /= 0 then\n-         Put_Line (\"ERROR: Test_Length: wrong length\");\n-         Put_Line (\"expected: 0\");\n-         Put_Line (\"got     :\" & Len'Img);\n-      end if;\n-\n-      Populate_With_Append (L, 1, 2);\n-      Len := Length (L);\n-\n-      if Len /= 2 then\n-         Put_Line (\"ERROR: Test_Length: wrong length\");\n-         Put_Line (\"expected: 2\");\n-         Put_Line (\"got     :\" & Len'Img);\n-      end if;\n-\n-      Populate_With_Append (L, 3, 6);\n-      Len := Length (L);\n-\n-      if Len /= 6 then\n-         Put_Line (\"ERROR: Test_Length: wrong length\");\n-         Put_Line (\"expected: 6\");\n-         Put_Line (\"got     :\" & Len'Img);\n-      end if;\n-\n-      Destroy (L);\n-   end Test_Length;\n-\n    ------------------\n    -- Test_Prepend --\n    ------------------\n@@ -1143,6 +1106,44 @@ procedure Linkedlist is\n       Destroy (L);\n    end Test_Replace;\n \n+   ---------------\n+   -- Test_Size --\n+   ---------------\n+\n+   procedure Test_Size is\n+      L : Instance := Create;\n+      S : Natural;\n+\n+   begin\n+      S := Size (L);\n+\n+      if S /= 0 then\n+         Put_Line (\"ERROR: Test_Size: wrong size\");\n+         Put_Line (\"expected: 0\");\n+         Put_Line (\"got     :\" & S'Img);\n+      end if;\n+\n+      Populate_With_Append (L, 1, 2);\n+      S := Size (L);\n+\n+      if S /= 2 then\n+         Put_Line (\"ERROR: Test_Size: wrong size\");\n+         Put_Line (\"expected: 2\");\n+         Put_Line (\"got     :\" & S'Img);\n+      end if;\n+\n+      Populate_With_Append (L, 3, 6);\n+      S := Size (L);\n+\n+      if S /= 6 then\n+         Put_Line (\"ERROR: Test_Size: wrong size\");\n+         Put_Line (\"expected: 6\");\n+         Put_Line (\"got     :\" & S'Img);\n+      end if;\n+\n+      Destroy (L);\n+   end Test_Size;\n+\n --  Start of processing for Operations\n \n begin\n@@ -1178,7 +1179,7 @@ begin\n       High_Elem => 5);\n \n    Test_Last;\n-   Test_Length;\n    Test_Prepend;\n    Test_Replace;\n+   Test_Size;\n end Linkedlist;"}, {"sha": "54a4983a1fa1116bd039d782c3011844a7dccaa4", "filename": "gcc/testsuite/gnat.dg/sets1.adb", "status": "added", "additions": 634, "deletions": 0, "changes": 634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Ftestsuite%2Fgnat.dg%2Fsets1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bc3bcb5fee9140c876d89ae2bf298914c01077/gcc%2Ftestsuite%2Fgnat.dg%2Fsets1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsets1.adb?ref=f8bc3bcb5fee9140c876d89ae2bf298914c01077", "patch": "@@ -0,0 +1,634 @@\n+--  { dg-do run }\n+\n+with Ada.Text_IO; use Ada.Text_IO;\n+with GNAT;        use GNAT;\n+with GNAT.Sets;   use GNAT.Sets;\n+\n+procedure Sets1 is\n+   function Hash (Key : Integer) return Bucket_Range_Type;\n+\n+   package Integer_Sets is new Membership_Set\n+     (Element_Type => Integer,\n+      \"=\"          => \"=\",\n+      Hash         => Hash);\n+   use Integer_Sets;\n+\n+   procedure Check_Empty\n+     (Caller    : String;\n+      S         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Ensure that none of the elements in the range Low_Elem .. High_Elem are\n+   --  present in set S, and that the set's length is 0.\n+\n+   procedure Check_Locked_Mutations (Caller : String; S : in out Instance);\n+   --  Ensure that all mutation operations of set S are locked\n+\n+   procedure Check_Present\n+     (Caller    : String;\n+      S         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Ensure that all elements in the range Low_Elem .. High_Elem are present\n+   --  in set S.\n+\n+   procedure Check_Unlocked_Mutations (Caller : String; S : in out Instance);\n+   --  Ensure that all mutation operations of set S are unlocked\n+\n+   procedure Populate\n+     (S         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer);\n+   --  Add elements in the range Low_Elem .. High_Elem in set S\n+\n+   procedure Test_Contains\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer;\n+      Init_Size : Positive);\n+   --  Verify that Contains properly identifies that elements in the range\n+   --  Low_Elem .. High_Elem are within a set. Init_Size denotes the initial\n+   --  size of the set.\n+\n+   procedure Test_Create;\n+   --  Verify that all set operations fail on a non-created set\n+\n+   procedure Test_Delete\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer;\n+      Init_Size : Positive);\n+   --  Verify that Delete properly removes elements in the range Low_Elem ..\n+   --  High_Elem from a set. Init_Size denotes the initial size of the set.\n+\n+   procedure Test_Is_Empty;\n+   --  Verify that Is_Empty properly returns this status of a set\n+\n+   procedure Test_Iterate;\n+   --  Verify that iterators properly manipulate mutation operations\n+\n+   procedure Test_Iterate_Empty;\n+   --  Verify that iterators properly manipulate mutation operations of an\n+   --  empty set.\n+\n+   procedure Test_Iterate_Forced\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer;\n+      Init_Size : Positive);\n+   --  Verify that an iterator that is forcefully advanced by Next properly\n+   --  unlocks the mutation operations of a set. Init_Size denotes the initial\n+   --  size of the set.\n+\n+   procedure Test_Size;\n+   --  Verify that Size returns the correct size of a set\n+\n+   -----------------\n+   -- Check_Empty --\n+   -----------------\n+\n+   procedure Check_Empty\n+     (Caller    : String;\n+      S         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      Siz : constant Natural := Size (S);\n+\n+   begin\n+      for Elem in Low_Elem .. High_Elem loop\n+         if Contains (S, Elem) then\n+            Put_Line (\"ERROR: \" & Caller & \": extra element\" & Elem'Img);\n+         end if;\n+      end loop;\n+\n+      if Siz /= 0 then\n+         Put_Line (\"ERROR: \" & Caller & \": wrong size\");\n+         Put_Line (\"expected: 0\");\n+         Put_Line (\"got     :\" & Siz'Img);\n+      end if;\n+   end Check_Empty;\n+\n+   ----------------------------\n+   -- Check_Locked_Mutations --\n+   ----------------------------\n+\n+   procedure Check_Locked_Mutations (Caller : String; S : in out Instance) is\n+   begin\n+      begin\n+         Delete (S, 1);\n+         Put_Line (\"ERROR: \" & Caller & \": Delete: no exception raised\");\n+      exception\n+         when Iterated =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: \" & Caller & \": Delete: unexpected exception\");\n+      end;\n+\n+      begin\n+         Destroy (S);\n+         Put_Line (\"ERROR: \" & Caller & \": Destroy: no exception raised\");\n+      exception\n+         when Iterated =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: \" & Caller & \": Destroy: unexpected exception\");\n+      end;\n+\n+      begin\n+         Insert (S, 1);\n+         Put_Line (\"ERROR: \" & Caller & \": Insert: no exception raised\");\n+      exception\n+         when Iterated =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: \" & Caller & \": Insert: unexpected exception\");\n+      end;\n+   end Check_Locked_Mutations;\n+\n+   -------------------\n+   -- Check_Present --\n+   -------------------\n+\n+   procedure Check_Present\n+     (Caller    : String;\n+      S         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+      Elem : Integer;\n+      Iter : Iterator;\n+\n+   begin\n+      Iter := Iterate (S);\n+      for Exp_Elem in Low_Elem .. High_Elem loop\n+         Next (Iter, Elem);\n+\n+         if Elem /= Exp_Elem then\n+            Put_Line (\"ERROR: \" & Caller & \": Check_Present: wrong element\");\n+            Put_Line (\"expected:\" & Exp_Elem'Img);\n+            Put_Line (\"got     :\" & Elem'Img);\n+         end if;\n+      end loop;\n+\n+      --  At this point all elements should have been accounted for. Check for\n+      --  extra elements.\n+\n+      while Has_Next (Iter) loop\n+         Next (Iter, Elem);\n+         Put_Line\n+           (\"ERROR: \" & Caller & \": Check_Present: extra element\" & Elem'Img);\n+      end loop;\n+\n+   exception\n+      when Iterator_Exhausted =>\n+         Put_Line\n+           (\"ERROR: \"\n+            & Caller\n+            & \"Check_Present: incorrect number of elements\");\n+   end Check_Present;\n+\n+   ------------------------------\n+   -- Check_Unlocked_Mutations --\n+   ------------------------------\n+\n+   procedure Check_Unlocked_Mutations (Caller : String; S : in out Instance) is\n+   begin\n+      Delete (S, 1);\n+      Insert (S, 1);\n+   end Check_Unlocked_Mutations;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (Key : Integer) return Bucket_Range_Type is\n+   begin\n+      return Bucket_Range_Type (Key);\n+   end Hash;\n+\n+   --------------\n+   -- Populate --\n+   --------------\n+\n+   procedure Populate\n+     (S         : Instance;\n+      Low_Elem  : Integer;\n+      High_Elem : Integer)\n+   is\n+   begin\n+      for Elem in Low_Elem .. High_Elem loop\n+         Insert (S, Elem);\n+      end loop;\n+   end Populate;\n+\n+   -------------------\n+   -- Test_Contains --\n+   -------------------\n+\n+   procedure Test_Contains\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer;\n+      Init_Size : Positive)\n+   is\n+      Low_Bogus  : constant Integer := Low_Elem  - 1;\n+      High_Bogus : constant Integer := High_Elem + 1;\n+\n+      S : Instance := Create (Init_Size);\n+\n+   begin\n+      Populate (S, Low_Elem, High_Elem);\n+\n+      --  Ensure that the elements are contained in the set\n+\n+      for Elem in Low_Elem .. High_Elem loop\n+         if not Contains (S, Elem) then\n+            Put_Line\n+              (\"ERROR: Test_Contains: element\" & Elem'Img & \" not in set\");\n+         end if;\n+      end loop;\n+\n+      --  Ensure that arbitrary elements which were not inserted in the set are\n+      --  not contained in the set.\n+\n+      if Contains (S, Low_Bogus) then\n+         Put_Line\n+           (\"ERROR: Test_Contains: element\" & Low_Bogus'Img & \" in set\");\n+      end if;\n+\n+      if Contains (S, High_Bogus) then\n+         Put_Line\n+           (\"ERROR: Test_Contains: element\" & High_Bogus'Img & \" in set\");\n+      end if;\n+\n+      Destroy (S);\n+   end Test_Contains;\n+\n+   -----------------\n+   -- Test_Create --\n+   -----------------\n+\n+   procedure Test_Create is\n+      Count : Natural;\n+      Flag  : Boolean;\n+      Iter  : Iterator;\n+      S     : Instance;\n+\n+   begin\n+      --  Ensure that every routine defined in the API fails on a set which\n+      --  has not been created yet.\n+\n+      begin\n+         Flag := Contains (S, 1);\n+         Put_Line (\"ERROR: Test_Create: Contains: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Contains: unexpected exception\");\n+      end;\n+\n+      begin\n+         Delete (S, 1);\n+         Put_Line (\"ERROR: Test_Create: Delete: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Delete: unexpected exception\");\n+      end;\n+\n+      begin\n+         Insert (S, 1);\n+         Put_Line (\"ERROR: Test_Create: Insert: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Insert: unexpected exception\");\n+      end;\n+\n+      begin\n+         Flag := Is_Empty (S);\n+         Put_Line (\"ERROR: Test_Create: Is_Empty: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Is_Empty: unexpected exception\");\n+      end;\n+\n+      begin\n+         Iter := Iterate (S);\n+         Put_Line (\"ERROR: Test_Create: Iterate: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Iterate: unexpected exception\");\n+      end;\n+\n+      begin\n+         Count := Size (S);\n+         Put_Line (\"ERROR: Test_Create: Size: no exception raised\");\n+      exception\n+         when Not_Created =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Create: Size: unexpected exception\");\n+      end;\n+   end Test_Create;\n+\n+   -----------------\n+   -- Test_Delete --\n+   -----------------\n+\n+   procedure Test_Delete\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer;\n+      Init_Size : Positive)\n+   is\n+      Iter : Iterator;\n+      S    : Instance := Create (Init_Size);\n+\n+   begin\n+      Populate (S, Low_Elem, High_Elem);\n+\n+      --  Delete all even elements\n+\n+      for Elem in Low_Elem .. High_Elem loop\n+         if Elem mod 2 = 0 then\n+            Delete (S, Elem);\n+         end if;\n+      end loop;\n+\n+      --  Ensure that all remaining odd elements are present in the set\n+\n+      for Elem in Low_Elem .. High_Elem loop\n+         if Elem mod 2 /= 0 and then not Contains (S, Elem) then\n+            Put_Line (\"ERROR: Test_Delete: missing element\" & Elem'Img);\n+         end if;\n+      end loop;\n+\n+      --  Delete all odd elements\n+\n+      for Elem in Low_Elem .. High_Elem loop\n+         if Elem mod 2 /= 0 then\n+            Delete (S, Elem);\n+         end if;\n+      end loop;\n+\n+      --  At this point the set should be completely empty\n+\n+      Check_Empty\n+        (Caller    => \"Test_Delete\",\n+         S         => S,\n+         Low_Elem  => Low_Elem,\n+         High_Elem => High_Elem);\n+\n+      Destroy (S);\n+   end Test_Delete;\n+\n+   -------------------\n+   -- Test_Is_Empty --\n+   -------------------\n+\n+   procedure Test_Is_Empty is\n+      S : Instance := Create (8);\n+\n+   begin\n+      if not Is_Empty (S) then\n+         Put_Line (\"ERROR: Test_Is_Empty: set is not empty\");\n+      end if;\n+\n+      Insert (S, 1);\n+\n+      if Is_Empty (S) then\n+         Put_Line (\"ERROR: Test_Is_Empty: set is empty\");\n+      end if;\n+\n+      Delete (S, 1);\n+\n+      if not Is_Empty (S) then\n+         Put_Line (\"ERROR: Test_Is_Empty: set is not empty\");\n+      end if;\n+\n+      Destroy (S);\n+   end Test_Is_Empty;\n+\n+   ------------------\n+   -- Test_Iterate --\n+   ------------------\n+\n+   procedure Test_Iterate is\n+      Elem   : Integer;\n+      Iter_1 : Iterator;\n+      Iter_2 : Iterator;\n+      S      : Instance := Create (5);\n+\n+   begin\n+      Populate (S, 1, 5);\n+\n+      --  Obtain an iterator. This action must lock all mutation operations of\n+      --  the set.\n+\n+      Iter_1 := Iterate (S);\n+\n+      --  Ensure that every mutation routine defined in the API fails on a set\n+      --  with at least one outstanding iterator.\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate\",\n+         S      => S);\n+\n+      --  Obtain another iterator\n+\n+      Iter_2 := Iterate (S);\n+\n+      --  Ensure that every mutation is still locked\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate\",\n+         S      => S);\n+\n+      --  Exhaust the first itertor\n+\n+      while Has_Next (Iter_1) loop\n+         Next (Iter_1, Elem);\n+      end loop;\n+\n+      --  Ensure that every mutation is still locked\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate\",\n+         S      => S);\n+\n+      --  Exhaust the second itertor\n+\n+      while Has_Next (Iter_2) loop\n+         Next (Iter_2, Elem);\n+      end loop;\n+\n+      --  Ensure that all mutation operations are once again callable\n+\n+      Check_Unlocked_Mutations\n+        (Caller => \"Test_Iterate\",\n+         S      => S);\n+\n+      Destroy (S);\n+   end Test_Iterate;\n+\n+   ------------------------\n+   -- Test_Iterate_Empty --\n+   ------------------------\n+\n+   procedure Test_Iterate_Empty is\n+      Elem : Integer;\n+      Iter : Iterator;\n+      S    : Instance := Create (5);\n+\n+   begin\n+      --  Obtain an iterator. This action must lock all mutation operations of\n+      --  the set.\n+\n+      Iter := Iterate (S);\n+\n+      --  Ensure that every mutation routine defined in the API fails on a set\n+      --  with at least one outstanding iterator.\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate_Empty\",\n+         S      => S);\n+\n+      --  Attempt to iterate over the elements\n+\n+      while Has_Next (Iter) loop\n+         Next (Iter, Elem);\n+\n+         Put_Line\n+           (\"ERROR: Test_Iterate_Empty: element\" & Elem'Img & \" exists\");\n+      end loop;\n+\n+      --  Ensure that all mutation operations are once again callable\n+\n+      Check_Unlocked_Mutations\n+        (Caller => \"Test_Iterate_Empty\",\n+         S      => S);\n+\n+      Destroy (S);\n+   end Test_Iterate_Empty;\n+\n+   -------------------------\n+   -- Test_Iterate_Forced --\n+   -------------------------\n+\n+   procedure Test_Iterate_Forced\n+     (Low_Elem  : Integer;\n+      High_Elem : Integer;\n+      Init_Size : Positive)\n+   is\n+      Elem : Integer;\n+      Iter : Iterator;\n+      S    : Instance := Create (Init_Size);\n+\n+   begin\n+      Populate (S, Low_Elem, High_Elem);\n+\n+      --  Obtain an iterator. This action must lock all mutation operations of\n+      --  the set.\n+\n+      Iter := Iterate (S);\n+\n+      --  Ensure that every mutation routine defined in the API fails on a set\n+      --  with at least one outstanding iterator.\n+\n+      Check_Locked_Mutations\n+        (Caller => \"Test_Iterate_Forced\",\n+         S      => S);\n+\n+      --  Forcibly advance the iterator until it raises an exception\n+\n+      begin\n+         for Guard in Low_Elem .. High_Elem + 1 loop\n+            Next (Iter, Elem);\n+         end loop;\n+\n+         Put_Line\n+           (\"ERROR: Test_Iterate_Forced: Iterator_Exhausted not raised\");\n+      exception\n+         when Iterator_Exhausted =>\n+            null;\n+         when others =>\n+            Put_Line (\"ERROR: Test_Iterate_Forced: unexpected exception\");\n+      end;\n+\n+      --  Ensure that all mutation operations are once again callable\n+\n+      Check_Unlocked_Mutations\n+        (Caller => \"Test_Iterate_Forced\",\n+         S      => S);\n+\n+      Destroy (S);\n+   end Test_Iterate_Forced;\n+\n+   ---------------\n+   -- Test_Size --\n+   ---------------\n+\n+   procedure Test_Size is\n+      S   : Instance := Create (6);\n+      Siz : Natural;\n+\n+   begin\n+      Siz := Size (S);\n+\n+      if Siz /= 0 then\n+         Put_Line (\"ERROR: Test_Size: wrong size\");\n+         Put_Line (\"expected: 0\");\n+         Put_Line (\"got     :\" & Siz'Img);\n+      end if;\n+\n+      Populate (S, 1, 2);\n+      Siz := Size (S);\n+\n+      if Siz /= 2 then\n+         Put_Line (\"ERROR: Test_Size: wrong size\");\n+         Put_Line (\"expected: 2\");\n+         Put_Line (\"got     :\" & Siz'Img);\n+      end if;\n+\n+      Populate (S, 3, 6);\n+      Siz := Size (S);\n+\n+      if Siz /= 6 then\n+         Put_Line (\"ERROR: Test_Size: wrong size\");\n+         Put_Line (\"expected: 6\");\n+         Put_Line (\"got     :\" & Siz'Img);\n+      end if;\n+\n+      Destroy (S);\n+   end Test_Size;\n+\n+--  Start of processing for Operations\n+\n+begin\n+   Test_Contains\n+     (Low_Elem  => 1,\n+      High_Elem => 5,\n+      Init_Size => 5);\n+\n+   Test_Create;\n+\n+   Test_Delete\n+     (Low_Elem  => 1,\n+      High_Elem => 10,\n+      Init_Size => 10);\n+\n+   Test_Is_Empty;\n+   Test_Iterate;\n+   Test_Iterate_Empty;\n+\n+   Test_Iterate_Forced\n+     (Low_Elem  => 1,\n+      High_Elem => 5,\n+      Init_Size => 5);\n+\n+   Test_Size;\n+end Sets1;"}]}