{"sha": "9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyOGM5ZDE1YWNlYjk1OGIzNmZlZjk2ZTJmM2I5ZTRkMGQ3NGRkNw==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-03-25T11:36:57Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-03-25T11:36:57Z"}, "message": "arm.c (vfp_print_multi): Remove.\n\n\t* config/arm/arm.c (vfp_print_multi): Remove.\n\t(arm_output_fldmx): New function.\n\t(vfp_emit_fstmx): Return block size, not insn. Add ARM10 VFPr1 bugfix.\n\t(arm_expand_prologue): Update to match.\n\t(arm_get_vfp_saved_size): New Function.\n\t(arm_get_frame_offsets): Use it.\n\t(arm_output_epilogue): Use new functions.\n\nFrom-SVN: r79950", "tree": {"sha": "446aa6602c076100953dc51897bb6dcdeb84201a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/446aa6602c076100953dc51897bb6dcdeb84201a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7/comments", "author": null, "committer": null, "parents": [{"sha": "32f4b1ed217cab26a80f94473ae2a8c610607efe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32f4b1ed217cab26a80f94473ae2a8c610607efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32f4b1ed217cab26a80f94473ae2a8c610607efe"}], "stats": {"total": 205, "additions": 111, "deletions": 94}, "files": [{"sha": "505adaca56e93d818972bd9ee3b34bbd39fc2a61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7", "patch": "@@ -1,3 +1,13 @@\n+2004-03-25  Paul Brook  <paul@codesourcery.com>\n+\n+\t* config/arm/arm.c (vfp_print_multi): Remove.\n+\t(arm_output_fldmx): New function.\n+\t(vfp_emit_fstmx): Return block size, not insn. Add ARM10 VFPr1 bugfix.\n+\t(arm_expand_prologue): Update to match.\n+\t(arm_get_vfp_saved_size): New Function.\n+\t(arm_get_frame_offsets): Use it.\n+\t(arm_output_epilogue): Use new functions.\n+\n 2004-03-24  Richard Henderson  <rth@redhat.com>\n \n \t* alias.c (alias_invariant, alias_invariant_size): Mark GTY."}, {"sha": "206647b1cb6411a12f1d8b3a30f9fbd86de22dea", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 101, "deletions": 94, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=9728c9d15aceb958b36fef96e2f3b9e4d0d74dd7", "patch": "@@ -7809,29 +7809,35 @@ print_multi_reg (FILE *stream, const char *instr, int reg, int mask)\n }\n \n \n-/* Output the operands of a FLDM/FSTM instruction to STREAM.\n-   REG is the base register,\n-   INSTR is the possibly suffixed load or store instruction.\n-   FMT specifies now to print the register name.\n-   START and COUNT specify the register range.  */\n+/* Output a FLDMX instruction to STREAM.\n+   BASE if the register containing the address.\n+   REG and COUNT specify the register range.\n+   Extra registers may be added to avoid hardware bugs.  */\n \n static void\n-vfp_print_multi (FILE *stream, const char *instr, int reg,\n-\t\t const char * fmt, int start, int count)\n+arm_output_fldmx (FILE * stream, unsigned int base, int reg, int count)\n {\n   int i;\n \n+  /* Workaround ARM10 VFPr1 bug.  */\n+  if (count == 2 && !arm_arch6)\n+    {\n+      if (reg == 15)\n+\treg--;\n+      count++;\n+    }\n+\n   fputc ('\\t', stream);\n-  asm_fprintf (stream, instr, reg);\n-  fputs (\", {\", stream);\n+  asm_fprintf (stream, \"fldmfdx\\t%r!, {\", base);\n \n-  for (i = start; i < start + count; i++)\n+  for (i = reg; i < reg + count; i++)\n     {\n-      if (i > start)\n+      if (i > reg)\n \tfputs (\", \", stream);\n-      asm_fprintf (stream, fmt, i);\n+      asm_fprintf (stream, \"d%d\", i);\n     }\n   fputs (\"}\\n\", stream);\n+\n }\n \n \n@@ -7863,16 +7869,27 @@ vfp_output_fstmx (rtx * operands)\n }\n \n \n-/* Emit RTL to save block of VFP register pairs to the stack.  */\n+/* Emit RTL to save block of VFP register pairs to the stack.  Returns the\n+   number of bytes pushed.  */\n \n-static rtx\n+static int\n vfp_emit_fstmx (int base_reg, int count)\n {\n   rtx par;\n   rtx dwarf;\n   rtx tmp, reg;\n   int i;\n \n+  /* Workaround ARM10 VFPr1 bug.  Data corruption can occur when exactly two\n+     register pairs are stored by a store multiple insn.  We avoid this\n+     by pushing an extra pair.  */\n+  if (count == 2 && !arm_arch6)\n+    {\n+      if (base_reg == LAST_VFP_REGNUM - 3)\n+\tbase_reg -= 2;\n+      count++;\n+    }\n+\n   /* ??? The frame layout is implementation defined.  We describe\n      standard format 1 (equivalent to a FSTMD insn and unused pad word).\n      We really need some way of representing the whole block so that the\n@@ -7922,7 +7939,9 @@ vfp_emit_fstmx (int base_reg, int count)\n   par = emit_insn (par);\n   REG_NOTES (par) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n \t\t\t\t       REG_NOTES (par));\n-  return par;\n+  RTX_FRAME_RELATED_P (par) = 1;\n+\n+  return count * 8 + 4;\n }\n \n \n@@ -8864,6 +8883,50 @@ arm_compute_save_reg_mask (void)\n   return save_reg_mask;\n }\n \n+\n+/* Return the number of bytes required to save VFP registers.  */\n+static int\n+arm_get_vfp_saved_size (void)\n+{\n+  unsigned int regno;\n+  int count;\n+  int saved;\n+\n+  saved = 0;\n+  /* Space for saved VFP registers.  */\n+  if (TARGET_HARD_FLOAT && TARGET_VFP)\n+    {\n+      count = 0;\n+      for (regno = FIRST_VFP_REGNUM;\n+\t   regno < LAST_VFP_REGNUM;\n+\t   regno += 2)\n+\t{\n+\t  if ((!regs_ever_live[regno] || call_used_regs[regno])\n+\t      && (!regs_ever_live[regno + 1] || call_used_regs[regno + 1]))\n+\t    {\n+\t      if (count > 0)\n+\t\t{\n+\t\t  /* Workaround ARM10 VFPr1 bug.  */\n+\t\t  if (count == 2 && !arm_arch6)\n+\t\t    count++;\n+\t\t  saved += count * 8 + 4;\n+\t\t}\n+\t      count = 0;\n+\t    }\n+\t  else\n+\t    count++;\n+\t}\n+      if (count > 0)\n+\t{\n+\t  if (count == 2 && !arm_arch6)\n+\t    count++;\n+\t  saved += count * 8 + 4;\n+\t}\n+    }\n+  return saved;\n+}\n+\n+\n /* Generate a function exit sequence.  If REALLY_RETURN is false, then do\n    everything bar the final return instruction.  */\n const char *\n@@ -9306,34 +9369,15 @@ arm_output_epilogue (rtx sibling)\n \n       if (TARGET_HARD_FLOAT && TARGET_VFP)\n \t{\n-\t  int nregs = 0;\n+\t  int saved_size;\n \n-\t  /* We save regs in pairs.  */\n-\t  /* A special insn for saving/restoring VFP registers.  This does\n-\t     not have base+offset addressing modes, so we use IP to\n-\t     hold the address.  Each block requires nregs*2+1 words.  */\n-\t  start_reg = FIRST_VFP_REGNUM;\n-\t  /* Count how many blocks of registers need saving.  */\n-\t  for (reg = FIRST_VFP_REGNUM; reg < LAST_VFP_REGNUM; reg += 2)\n-\t    {\n-\t      if ((!regs_ever_live[reg] || call_used_regs[reg])\n-\t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n-\t\t{\n-\t\t  if (start_reg != reg)\n-\t\t    floats_offset += 4;\n-\t\t  start_reg = reg + 2;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  floats_offset += 8;\n-\t\t  nregs++;\n-\t\t}\n-\t    }\n-\t  if (start_reg != reg)\n-\t    floats_offset += 4;\n+\t  /* The fldmx insn does not have base+offset addressing modes,\n+\t     so we use IP to hold the address.  */\n+\t  saved_size = arm_get_vfp_saved_size ();\n \n-\t  if (nregs > 0)\n+\t  if (saved_size > 0)\n \t    {\n+\t      floats_offset += saved_size;\n \t      asm_fprintf (f, \"\\tsub\\t%r, %r, #%d\\n\", IP_REGNUM,\n \t\t\t   FP_REGNUM, floats_offset - vfp_offset);\n \t    }\n@@ -9344,20 +9388,16 @@ arm_output_epilogue (rtx sibling)\n \t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n \t\t{\n \t\t  if (start_reg != reg)\n-\t\t    {\n-\t\t      vfp_print_multi (f, \"fldmfdx\\t%r!\", IP_REGNUM, \"d%d\",\n-\t\t\t\t       (start_reg - FIRST_VFP_REGNUM) / 2,\n-\t\t\t\t       (reg - start_reg) / 2);\n-\t\t    }\n+\t\t    arm_output_fldmx (f, IP_REGNUM,\n+\t\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n+\t\t\t\t      (reg - start_reg) / 2);\n \t\t  start_reg = reg + 2;\n \t\t}\n \t    }\n \t  if (start_reg != reg)\n-\t    {\n-\t      vfp_print_multi (f, \"fldmfdx\\t%r!\", IP_REGNUM, \"d%d\",\n-\t\t\t       (start_reg - FIRST_VFP_REGNUM) / 2,\n-\t\t\t       (reg - start_reg) / 2);\n-\t    }\n+\t    arm_output_fldmx (f, IP_REGNUM,\n+\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n+\t\t\t      (reg - start_reg) / 2);\n \t}\n \n       if (TARGET_IWMMXT)\n@@ -9478,20 +9518,16 @@ arm_output_epilogue (rtx sibling)\n \t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n \t\t{\n \t\t  if (start_reg != reg)\n-\t\t    {\n-\t\t      vfp_print_multi (f, \"fldmfdx\\t%r!\", SP_REGNUM, \"d%d\",\n-\t\t\t\t       (start_reg - FIRST_VFP_REGNUM) / 2,\n-\t\t\t\t       (reg - start_reg) / 2);\n-\t\t    }\n+\t\t    arm_output_fldmx (f, SP_REGNUM,\n+\t\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n+\t\t\t\t      (reg - start_reg) / 2);\n \t\t  start_reg = reg + 2;\n \t\t}\n \t    }\n \t  if (start_reg != reg)\n-\t    {\n-\t      vfp_print_multi (f, \"fldmfdx\\t%r!\", SP_REGNUM, \"d%d\",\n-\t\t\t       (start_reg - FIRST_VFP_REGNUM) / 2,\n-\t\t\t       (reg - start_reg) / 2);\n-\t    }\n+\t    arm_output_fldmx (f, SP_REGNUM,\n+\t\t\t      (start_reg - FIRST_VFP_REGNUM) / 2,\n+\t\t\t      (reg - start_reg) / 2);\n \t}\n       if (TARGET_IWMMXT)\n \tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n@@ -9855,7 +9891,6 @@ arm_get_frame_offsets (void)\n   struct arm_stack_offsets *offsets;\n   unsigned long func_type;\n   int leaf;\n-  bool new_block;\n   int saved;\n   HOST_WIDE_INT frame_size;\n \n@@ -9915,27 +9950,7 @@ arm_get_frame_offsets (void)\n \n \t  /* Space for saved VFP registers.  */\n \t  if (TARGET_HARD_FLOAT && TARGET_VFP)\n-\t    {\n-\t      new_block = TRUE;\n-\t      for (regno = FIRST_VFP_REGNUM;\n-\t\t   regno < LAST_VFP_REGNUM;\n-\t\t   regno += 2)\n-\t\t{\n-\t\t  if ((regs_ever_live[regno] && !call_used_regs[regno])\n-\t\t      || (regs_ever_live[regno + 1]\n-\t\t\t  && !call_used_regs[regno + 1]))\n-\t\t    {\n-\t\t      if (new_block)\n-\t\t\t{\n-\t\t\t  saved += 4;\n-\t\t\t  new_block = FALSE;\n-\t\t\t}\n-\t\t      saved += 8;\n-\t\t    }\n-\t\t  else\n-\t\t    new_block = TRUE;\n-\t\t}\n-\t    }\n+\t    saved += arm_get_vfp_saved_size ();\n \t}\n     }\n   else /* TARGET_THUMB */\n@@ -10317,22 +10332,14 @@ arm_expand_prologue (void)\n \t\t  && (!regs_ever_live[reg + 1] || call_used_regs[reg + 1]))\n \t\t{\n \t\t  if (start_reg != reg)\n-\t\t    {\n-\t\t      insn = vfp_emit_fstmx (start_reg,\n-\t\t\t\t\t    (reg - start_reg) / 2);\n-\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t      saved_regs += (start_reg - reg) * 4 + 4;\n-\t\t    }\n+\t\t    saved_regs += vfp_emit_fstmx (start_reg,\n+\t\t\t\t\t\t  (reg - start_reg) / 2);\n \t\t  start_reg = reg + 2;\n \t\t}\n \t    }\n \t  if (start_reg != reg)\n-\t    {\n-\t      insn = vfp_emit_fstmx (start_reg,\n-\t\t\t\t    (reg - start_reg) / 2);\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      saved_regs += (start_reg - reg) * 4 + 4;\n-\t    }\n+\t    saved_regs += vfp_emit_fstmx (start_reg,\n+\t\t\t\t\t  (reg - start_reg) / 2);\n \t}\n     }\n "}]}