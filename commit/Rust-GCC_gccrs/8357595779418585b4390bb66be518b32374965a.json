{"sha": "8357595779418585b4390bb66be518b32374965a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM1NzU5NTc3OTQxODU4NWI0MzkwYmI2NmJlNTE4YjMyMzc0OTY1YQ==", "commit": {"author": {"name": "Ian Dall", "email": "Ian.Dall@dsto.defence.gov.au", "date": "1998-11-25T23:34:42Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-11-25T23:34:42Z"}, "message": "Bulk ns32k patch from Ian Dall.  See ChangeLog for details.\n\nCo-Authored-By: Matthias Pfaller <leo@dachau.marco.de>\n\nFrom-SVN: r23887", "tree": {"sha": "67aa038fe8d8b1eef82738fc896e6e5674ceb31b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67aa038fe8d8b1eef82738fc896e6e5674ceb31b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8357595779418585b4390bb66be518b32374965a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8357595779418585b4390bb66be518b32374965a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8357595779418585b4390bb66be518b32374965a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8357595779418585b4390bb66be518b32374965a/comments", "author": null, "committer": null, "parents": [{"sha": "36696297f1a68d0789ec6cf07ac23cf640bd61ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36696297f1a68d0789ec6cf07ac23cf640bd61ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36696297f1a68d0789ec6cf07ac23cf640bd61ce"}], "stats": {"total": 1967, "additions": 1481, "deletions": 486}, "files": [{"sha": "e206ac6ae250f7b6e08704193b21516c58564839", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8357595779418585b4390bb66be518b32374965a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8357595779418585b4390bb66be518b32374965a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8357595779418585b4390bb66be518b32374965a", "patch": "@@ -1,3 +1,102 @@\n+Wed Nov 25 23:32:02 1998  Ian Dall  <Ian.Dall@dsto.defence.gov.au>\n+\t\t\t  Matthias Pfaller  <leo@dachau.marco.de>\n+\n+\t* invoke.texi (Option Summary, NS32K Options): add description\n+ \tof NS32K specific options.\n+\n+\t* ns32k.md (tstdf, cmpdf, movdf, truncdfsf2, fixdfqi2, fixdfhi2,\n+ \tfixdfsi2, fixunsdfqi2, fixunsdfhi2, fixunsdfsi2, fix_truncdfqi2,\n+ \tfix_truncdfhi2, fix_truncdfsi2, adddf3, subdf3, muldf3, divdf3,\n+ \tnegdf2, absdf2): Use l instead of f since the double class and\n+ \tfloat class are no longer the same.\n+\t(cmpsi, truncsiqi2, truncsihi2, addsi3, subsi3, mulsi3, umulsidi3,\n+ \tdivsi3, modsi3, andsi3, iorsi3, xorsi3, negsi2, one_cmplsi2,\n+ \tashlsi3, ashlhi3, ashlqi3, rotlsi3, rotlhi3, rotlqi3, abssi2,...):\n+ \tuse \"g\" instead of \"rmn\" since LEGITIMATE_PIC_OPERAND has been\n+ \tfixed.\n+\t(cmpsi, cmphi, cmpqi): use general_operand instead of\n+ \tnon_immediate_operand. Removes erroneous assumption that can't\n+ \tcompare constants.\n+\t(movsf, movsi, movhi, movqi,...): New register numbering scheme.\n+\t(movsi, addsi3): Use NS32K_DISPLACEMENT_P instead of hard coded\n+ \tconstants.\n+\t(movstrsi, movstrsi1, movstrsi2): completely new block move\n+ \tscheme.\n+\t(...): Patterns to exploit multiply-add instructions.\n+\t(udivmodsi4, udivmodsi_internal4, udivmodhi4,\n+ \tudivmoddihi4_internal, udivmodqi4, udivmoddiqi4_internal): new\n+ \tpatterns to exploit extended divide insns.\n+\t(udivsi3, udivhi3, udivqi3): remove since superceded by udivmodsi\n+\tetc patterns.\n+\n+\t* ns32k.h (FUNCTION_VALUE, LIBCALL_VALUE): Use f0 for complex\n+ \tfloat return values as well as simple scalar floats.\n+\t(TARGET_32381, TARGET_MULT_ADD, TARGET_SWITCHES):\n+ \tsupport new flag to denote 32381 fpu.\n+\t(OVERRIDE_OPTIONS): 32381 is a strict superset of 32081.\n+\t(CONDITIONAL_REGISTER_USAGE): disable extra 32381 registers if not\n+ \tcompling for 32381.\n+\t(FIRST_PSEUDO_REGISTER, FIXED_REGISTERS, CALL_USED_REGISTERS,\n+ \tREGISTER_NAMES, ADDITIONAL_REGISTER_NAMES, OUTPUT_REGISTER_NAMES,\n+ \tREG_ALLOC_ORDER, DBX_REGISTER_NUMBER, R0_REGNUM, F0_REGNUM,\n+ \tL1_REGNUM, STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM,\n+ \tLONG_FP_REGS_P, ARG_POINTER_REGNUM, reg_class, REG_CLASS_NAMES,\n+ \tREG_CLASS_CONTENTS, SUBSET_P,REGNO_REG_CLASS,\n+ \tREG_CLASS_FROM_LETTER, FUNCTION_PROLOGUE, FUNCTION_EPILOGUE,\n+ \tREGNO_OK_FOR_INDEX_P, FP_REG_P, REG_OK_FOR_INDEX_P,\n+ \tREG_OK_FOR_BASE_P, MEM_REG): new register scheme to include 32381\n+ \tfpu registers and special register classes for new 32381\n+ \tinstructions dotf and polyf.\n+\t(MODES_TIEABLE_P): Allow all integer modes, notably DI and SI, to\n+ \tbe tieable.\n+\t(INCOMING_RETURN_ADDR_RTX, RETURN_ADDR_RTX,\n+ \tINCOMING_FRAME_SP_OFFSET): New macros in case DWARF support is\n+ \trequired.\n+\t(SMALL_REGISTER_CLASSES): Make dependant on -mmult-add option.\n+\t(MOVE_RATIO): Set to zero because of smart movstrsi implimentation.\n+\t(REGISTER_MOVE_COST): move code to register_move_cost function for\n+\tease of coding and debugging.\n+\t(CLASS_LIKELY_SPILLED_P): Under new register scheme class\n+ \tLONG_FLOAT_REGO is likely spilled but not caught by default\n+ \tdefinition.\n+\t(CONSTANT_ADDRESS_P, CONSTANT_ADDRESS_NO_LABEL_P): use macro\n+ \tinstead of hard coded numbers in range check.\n+\t(ASM_OUTPUT_LABELREF_AS_INT): delete since unused.\n+\t(...): Add prototypes for functions in ns32k.c but disable because\n+\tof problems when ns32k.h is included in machine independant files.\n+\t\n+\t* ns32k.c: include \"system.h\", \"tree.h\", \"expr.h\", \"flags.h\".\n+\t(ns32k_reg_class_contents, regcass_map, ns32k_out_reg_names,\n+ \thard_regno_mode_ok, secondary_reload_class,\n+ \tprint_operand, print_operand_address): new register scheme to\n+ \tinclude 32381 fpu registers and special register classes for new\n+ \t32381 instructions dotf and polyf.\n+\t(gen_indexed_expr): Make static to keep namespace clean.\n+\t(check_reg): remove since never called.\n+\t(move_tail, expand_block_move): helper functions for \"movstrsi\"\n+ \tblock move insn.\n+\t(register_move_cost): Helper function for REGISTER_MOVE_COST macro.\n+\tIncrease cost of moves which go via memory.\n+\t* netbsd.h (TARGET_DEFAULT): Set (new) 32381 fpu flag.\n+\t(CPP_PREDEFINES): nolonger predefine \"unix\".\n+\n+\t* ns32k.md (movsi, movsi, adddi3, subdi3, subsi3, subhi3, subqi3,...):\n+ \tRemove erroneous %$. print_operand() can work out from the rtx is\n+ \tan immediate prefix is required.\n+\n+\t* ns32k.h (RETURN_POPS_ARGS, VALID_MACHINE_DECL_ATTRIBUTE,\n+ \tVALID_MACHINE_TYPE_ATTRIBUTE, COMP_TYPE_ATTRIBUTES,\n+ \tSET_DEFAULT_TYPE_ATTRIBUTES): Support for -mrtd calling\n+ \tconvention.\n+\t(LEGITIMATE_PIC_OPERAND_P, SYMBOLIC_CONST): Correct handling of\n+ \tpic operands.\n+\n+\t* ns32k.c (symbolic_reference_mentioned_p, print_operand):\n+\tCorrect handling of pic operands.\n+\t(ns32k_valid_decl_attribute_p, ns32k_valid_type_attribute_p,\n+ \tns32k_comp_type_attributes, ns32k_return_pops_args): Support for\n+\t-mrtd calling convention.\n+\n Wed Nov 25 23:42:20 1998  Tom Tromey  <tromey@cygnus.com>\n \n \t* gcc.c (option_map): Recognize --output-class-directory.\n@@ -13,7 +112,6 @@ Thu Nov 26 18:26:21 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \ttoo large to be immediate constants.  Also use it to find terms\n \tcommon to initial and final iteration values that can be removed.\n \n-\n Thu Nov 26 18:05:04 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* loop.h (struct loop_info): Define new structure.\n@@ -42,7 +140,6 @@ Thu Nov 26 18:05:04 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \t(loop_unroll_factor): Replace global array by element in\n \tloop_info structure.\n \n-\n Thu Nov 26 17:49:29 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* loop.c (check_dbra_loop): Update JUMP_LABEL field of jump insn\n@@ -87,7 +184,6 @@ Thu Nov 26 15:16:05 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \t(valid_parallel_operands_4, valid_parallel_operands_5,\n  \tvalid_parallel_operands_6): Reject pattern if the register destination\n \tof the first set is used as part of an address in the second set.\n-\t\n \n Thu Nov 26 14:56:32 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n "}, {"sha": "8e3610e33b5ec9713a98079202c90e7c7e7f9827", "filename": "gcc/README.NS32K", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8357595779418585b4390bb66be518b32374965a/gcc%2FREADME.NS32K", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8357595779418585b4390bb66be518b32374965a/gcc%2FREADME.NS32K", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.NS32K?ref=8357595779418585b4390bb66be518b32374965a", "patch": "@@ -1,6 +1,55 @@\n This file describes the implementation notes of the GNU C Compiler for\n the National Semiconductor 32032 chip (and 32000 family).\n \n+Much of this file was obsolete. It described restrictions caused by\n+bugs in early versions of of the ns32032 chip and by bugs in sequent\n+assemblers and linkers of the time.\n+\n+Many (all?) of the chip bugs were fixed in later revisions and\n+certainly fixed by later chips in the same series (ns32332 and\n+ns32532).\n+\n+Conditional code to support sequent assembler and/or linker restrictions\n+has not been removed deliberately, but has probably not been tested in\n+a *very* long time.\n+\n+Support for one sequent assembler bug has *not* been retained.\n+It was necessary to say:\n+\n+\taddr _x,rn\n+\tcmpd _p,rn\n+\n+rather than:\n+\n+\tcmpd _p,@_x\n+\n+\n+This used to be forced by the use of \"rmn\" register constraints rather\n+than \"g\". This is bad for other platforms which do not have this\n+restraint.\n+\n+It is likely that there are no Balance 8000's still in operation, but\n+if there are and the assembler bug was never fixed then the easiest\n+way to run gcc would be to also run gas.\n+\n+The code required by the sequent assembler is still generated when the\n+-fpic flag is in effect and this is forced by the appropriate\n+definition of LEGITIMATE_PIC_OPERAND_P. If support for the old sequent\n+assembler bug is required, then this could be achieved by adding the\n+test from LEGITIMATE_PIC_OPERAND to the GO_IF_LEGITIMATE_ADDRESS\n+definition. Of course, this should be conditional on something in the\n+sequent.h config file.\n+\n+The original contents of this file appear below as an historical note.\n+SEQUENT_ADDRESS_BUG mentioned below has been replaced by\n+INDEX_RATHER_THAN_BASE. Note that merlin.h still defines\n+SEQUENT_ADDRESS_BUG even though it is not used anywhere. Since it has\n+been like this for a long time, presumably either the\n+SEQUENT_ADDRESS_BUG is not required for the merlin, or no one is using\n+gcc on the merlin anymore.\n+\n+HISTORICAL NOTE\n+\n The 32032 machine description and configuration file for this compiler\n is, for NS32000 family machine, primarily machine independent.\n However, since this release still depends on vendor-supplied"}, {"sha": "bc86e31ccb6f4ac29265ab703f83a52d5d60e215", "filename": "gcc/config/ns32k/netbsd.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8357595779418585b4390bb66be518b32374965a/gcc%2Fconfig%2Fns32k%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8357595779418585b4390bb66be518b32374965a/gcc%2Fconfig%2Fns32k%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fnetbsd.h?ref=8357595779418585b4390bb66be518b32374965a", "patch": "@@ -24,9 +24,10 @@ Boston, MA 02111-1307, USA.\n \n /* Compile for the floating point unit & 32532 by default;\n    Don't assume SB is zero;\n-   Don't use bitfield instructions; */\n+   Don't use bitfield instructions;\n+   FPU is 32381; */\n \n-#define TARGET_DEFAULT (1 + 24 + 32 + 64)\n+#define TARGET_DEFAULT (1 + 24 + 32 + 64 + 256)\n \n /* 32-bit alignment for efficiency */\n \n@@ -68,7 +69,7 @@ Boston, MA 02111-1307, USA.\n /* Names to predefine in the preprocessor for this target machine.  */\n \n #undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dunix -Dns32k -Dns32000 -Dns32532 -D__NetBSD__ -Dpc532 -D__ns32k__ -Asystem(unix) -Asystem(NetBSD) -Acpu(ns32k) -Amachine(ns32k)\"\n+#define CPP_PREDEFINES \"-Dns32k -Dns32000 -Dns32532 -D__NetBSD__ -Dpc532 -D__ns32k__ -D__KPRINTF_ATTRIBUTE__ -Asystem(unix) -Asystem(NetBSD) -Acpu(ns32k) -Amachine(ns32k)\"\n \n /* Make gcc agree with <machine/ansi.h> */\n "}, {"sha": "af89e5999e098fcdf2c6d6bfe00335a50ad3377f", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 395, "deletions": 105, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8357595779418585b4390bb66be518b32374965a/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8357595779418585b4390bb66be518b32374965a/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=8357595779418585b4390bb66be518b32374965a", "patch": "@@ -20,7 +20,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Some output-actions in ns32k.md need these.  */\n #include \"config.h\"\n-#include <stdio.h>\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -30,90 +30,101 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-flags.h\"\n #include \"output.h\"\n #include \"insn-attr.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n \n #ifdef OSF_OS\n int ns32k_num_files = 0;\n #endif\n \n+/* This duplicates reg_class_contens in reg_class.c, but maybe that isn't\n+   initialized in time. Also this is more convenient as an array of ints.\n+   We know that HARD_REG_SET fits in an unsigned int */\n+\n+unsigned int ns32k_reg_class_contents[N_REG_CLASSES] = REG_CLASS_CONTENTS;\n+\n+enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n+{\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  FLOAT_REG0, LONG_FLOAT_REG0, FLOAT_REGS, FLOAT_REGS,\n+  FLOAT_REGS, FLOAT_REGS, FLOAT_REGS, FLOAT_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  FRAME_POINTER_REG, STACK_POINTER_REG\n+};\n+\n+char *ns32k_out_reg_names[] = OUTPUT_REGISTER_NAMES;\n+\n void\n trace (s, s1, s2)\n      char *s, *s1, *s2;\n {\n   fprintf (stderr, s, s1, s2);\n }\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */ \n \n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */ \n int\n hard_regno_mode_ok (regno, mode)\n      int regno;\n      enum machine_mode mode;\n {\n-  switch (mode)\n+  int size = GET_MODE_UNIT_SIZE(mode);\n+\n+  if (FLOAT_MODE_P(mode))\n     {\n-    case QImode:\n-    case HImode:\n-    case PSImode:\n-    case SImode:\n-    case PDImode:\n-    case VOIDmode:\n-    case BLKmode:\n-      if (regno < 8 || regno == 16 || regno == 17)\n+      if (size == UNITS_PER_WORD && regno < L1_REGNUM)\n \treturn 1;\n-      else\n-\treturn 0;\n-\n-    case DImode:\n-      if (regno < 8 && (regno & 1) == 0)\n+      if (size == UNITS_PER_WORD * 2\n+\t  && (((regno & 1) == 0 && regno < FRAME_POINTER_REGNUM)))\n \treturn 1;\n-      else\n-\treturn 0;\n-\n-    case SFmode:\n-    case SCmode:\n-      if (TARGET_32081)\n-\t{\n-\t  if (regno < 16)\n-\t    return 1;\n-\t  else\n-\t    return 0;\n-\t}\n-      else\n-\t{\n-\t  if (regno < 8)\n-\t    return 1;\n-\t  else \n-\t    return 0;\n-\t}\n-\n-    case DFmode:\n-    case DCmode:\n-      if ((regno & 1) == 0)\n-\t{\t\n-\t  if (TARGET_32081)\n-\t    {\n-\t      if (regno < 16)\n-\t\treturn 1;\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (regno < 8)\n-\t\treturn 1;\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t}\n-      else\n-\treturn 0;\n+      return 0;\n     }\n-\n-  /* Used to abort here, but simply saying \"no\" handles TImode\n-     much better.  */\n+  if (size == UNITS_PER_WORD * 2\n+      && (regno & 1) == 0 && regno < F0_REGNUM)\n+    return 1;\n+  if (size <= UNITS_PER_WORD\n+      && (regno < F0_REGNUM || regno == FRAME_POINTER_REGNUM\n+\t  || regno == STACK_POINTER_REGNUM))\n+    return 1;\n   return 0;\n }\n \n+int register_move_cost(CLASS1, CLASS2)\n+     enum reg_class CLASS1;\n+     enum reg_class CLASS2;\n+{\n+  if (CLASS1 == NO_REGS || CLASS2 == NO_REGS)\n+    return 2;\n+  if((SUBSET_P(CLASS1, FP_REGS) && !SUBSET_P(CLASS2, FP_REGS))\n+   || (!SUBSET_P(CLASS1, FP_REGS) && SUBSET_P(CLASS2, FP_REGS)))\n+    return 8;\n+  if (((CLASS1) == STACK_POINTER_REG && !SUBSET_P(CLASS2,GENERAL_REGS))\n+      || ((CLASS2) == STACK_POINTER_REG && !SUBSET_P(CLASS1,GENERAL_REGS)))\n+    return 6;\n+  if (((CLASS1) == FRAME_POINTER_REG && !SUBSET_P(CLASS2,GENERAL_REGS))\n+      || ((CLASS2) == FRAME_POINTER_REG && !SUBSET_P(CLASS1,GENERAL_REGS)))\n+    return 6;\n+  return 2;\n+}\n+\n+#if 0\n+/* We made the insn definitions copy from floating point to general\n+  registers via the stack. */\n+int secondary_memory_needed(CLASS1, CLASS2, M)\n+     enum reg_class CLASS1;\n+     enum reg_class CLASS2;\n+     enum machine_mode M;\n+{\n+  int ret = ((SUBSET_P(CLASS1, FP_REGS) && !SUBSET_P(CLASS2, FP_REGS))\n+   || (!SUBSET_P(CLASS1, FP_REGS) && SUBSET_P(CLASS2, FP_REGS)));\n+  return ret;\n+}\n+#endif\n+    \n+\n /* ADDRESS_COST calls this.  This function is not optimal\n    for the 32032 & 32332, but it probably is better than\n    the default. */\n@@ -146,8 +157,10 @@ calc_address_cost (operand)\n     case POST_DEC:\n     case PRE_DEC:\n       break;\n-    case MULT:\n     case MEM:\n+      cost += calc_address_cost (XEXP (operand, 0));\n+      break;\n+    case MULT:\n     case PLUS:\n       for (i = 0; i < GET_RTX_LENGTH (GET_CODE (operand)); i++)\n \t{\n@@ -174,30 +187,18 @@ secondary_reload_class (class, mode, in)\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     regno = -1;\n \n-  /* We can place anything into GENERAL_REGS and can put GENERAL_REGS\n-     into anything.  */\n-  if (class == GENERAL_REGS || (regno >= 0 && regno < 8))\n-    return NO_REGS;\n-\n-  /* Constants, memory, and FP registers can go into FP registers.  */\n-  if ((regno == -1 || (regno >= 8 && regno < 16)) && (class == FLOAT_REGS))\n-    return NO_REGS;\n-\n-#if 0 /* This isn't strictly true (can't move fp to sp or vice versa),\n-\t so it's cleaner to use PREFERRED_RELOAD_CLASS\n-\t to make the right things happen.  */\n-  if (regno >= 16 && class == GEN_AND_MEM_REGS)\n+  if ((class == FRAME_POINTER_REG && regno == STACK_POINTER_REGNUM)\n+      || ( class == STACK_POINTER_REG && regno == FRAME_POINTER_REGNUM))\n+    return GENERAL_REGS;\n+  else\n     return NO_REGS;\n-#endif\n-\n-  /* Otherwise, we need GENERAL_REGS. */\n-  return GENERAL_REGS;\n }\n+\n /* Generate the rtx that comes from an address expression in the md file */\n /* The expression to be build is BASE[INDEX:SCALE].  To recognize this,\n    scale must be converted from an exponent (from ASHIFT) to a\n    multiplier (for MULT). */\n-rtx\n+static rtx\n gen_indexed_expr (base, index, scale)\n      rtx base, index, scale;\n {\n@@ -226,6 +227,7 @@ reg_or_mem_operand (op, mode)\n \t      || GET_CODE (op) == SUBREG\n \t      || GET_CODE (op) == MEM));\n }\n+\n \f\n /* Split one or more DImode RTL references into pairs of SImode\n    references.  The RTL can be REG, offsettable MEM, integer constant, or\n@@ -404,27 +406,163 @@ output_move_double (operands)\n   return singlemove_string (operands);\n }\n \n-int\n-check_reg (oper, reg)\n-     rtx oper;\n-     int reg;\n+\f\n+#define MAX_UNALIGNED_COPY (32)\n+/* Expand string/block move operations.\n+\n+   operands[0] is the pointer to the destination.\n+   operands[1] is the pointer to the source.\n+   operands[2] is the number of bytes to move.\n+   operands[3] is the alignment.  */\n+\n+static void\n+move_tail(operands, bytes, offset)\n+     rtx operands[];\n+     int bytes;\n+     int offset;\n {\n-  register int i;\n+  if (bytes & 2)\n+    {\n+      rtx src, dest;\n+      dest = change_address(operands[0], HImode,\n+\t\t\t    plus_constant(XEXP(operands[0], 0), offset));\n+      src = change_address(operands[1], HImode,\n+\t\t\t   plus_constant(XEXP(operands[1], 0), offset));\n+      emit_move_insn(dest, src);\n+      offset += 2;\n+    }\n+  if (bytes & 1)\n+    {\n+      rtx src, dest;\n+      dest = change_address(operands[0], QImode,\n+\t\t\t    plus_constant(XEXP(operands[0], 0), offset));\n+      src = change_address(operands[1], QImode,\n+\t\t\t   plus_constant(XEXP(operands[1], 0), offset));\n+      emit_move_insn(dest, src);\n+    }\n+}\n \n-  if (oper == 0)\n-    return 0;\n-  switch (GET_CODE(oper))\n+void\n+expand_block_move (operands)\n+     rtx operands[];\n+{\n+  rtx bytes_rtx\t= operands[2];\n+  rtx align_rtx = operands[3];\n+  int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n+  int bytes\t= (constp ? INTVAL (bytes_rtx) : 0);\n+  int align\t= INTVAL (align_rtx);\n+  rtx src_reg = gen_rtx(REG, Pmode, 1);\n+  rtx dest_reg = gen_rtx(REG, Pmode, 2);\n+  rtx count_reg = gen_rtx(REG, SImode, 0);\n+  rtx insn;\n+\n+  if (constp && bytes <= 0)\n+    return;\n+\n+  if (constp && bytes < 20)\n     {\n-    case REG:\n-      return (REGNO(oper) == reg) ? 1 : 0;\n-    case MEM:\n-      return check_reg(XEXP(oper, 0), reg);\n-    case PLUS:\n-    case MULT:\n-      return check_reg(XEXP(oper, 0), reg) || check_reg(XEXP(oper, 1), reg);\n+      int words = bytes >> 2;\n+      if (words)\n+\tif (words < 3 || flag_unroll_loops)\n+\t  {\n+\t    int offset = 0;\n+\t    for (; words; words--, offset += 4)\n+\t      {\n+\t\trtx src, dest;\n+\t\tdest = change_address(operands[0], SImode,\n+\t\t\t\t      plus_constant(XEXP(operands[0], 0), offset));\n+\t\tsrc = change_address(operands[1], SImode,\n+\t\t\t\t     plus_constant(XEXP(operands[1], 0), offset));\n+\t\temit_move_insn(dest, src);\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    /* Use movmd. It is slower than multiple movd's but more\n+\t       compact. It is also slower than movsd for large copies\n+\t       but causes less registers reloading so is better than movsd\n+\t       for small copies. */\n+\t    rtx src, dest;\n+\t    dest = copy_addr_to_reg (XEXP(operands[0], 0));\n+\t    src = copy_addr_to_reg (XEXP(operands[1], 0));\n+\t    \n+\t    emit_insn(gen_movstrsi2(dest, src, GEN_INT(words)));\n+\t  }\n+      move_tail(operands, bytes & 3, bytes & ~3);\n+      return;\n+    }\n+\n+  if (align > UNITS_PER_WORD)\n+    align = UNITS_PER_WORD;\n+\n+  /* Move the address into scratch registers.  */\n+  emit_insn(gen_rtx(CLOBBER, VOIDmode, dest_reg));\n+  emit_move_insn(dest_reg, XEXP (operands[0], 0));\n+  emit_insn(gen_rtx(CLOBBER, VOIDmode, src_reg));\n+  emit_move_insn(src_reg, XEXP (operands[1], 0));\n+  emit_insn(gen_rtx(CLOBBER, VOIDmode, count_reg));\n+\n+  if (constp && (align == UNITS_PER_WORD || bytes < MAX_UNALIGNED_COPY))\n+    {\n+      rtx  bytes_reg;\n+\n+      /* constant no of bytes and aligned or small enough copy to not bother\n+       * aligning. Emit insns to copy by words.\n+       */\n+      if (bytes >> 2)\n+\t{\n+\t  emit_move_insn(count_reg, GEN_INT(bytes >> 2));\n+\t  emit_insn(gen_movstrsi1 (GEN_INT(4)));\n+\t}\n+      /* insns to copy rest */\n+      move_tail(operands, bytes & 3, bytes & ~3);\n+    }\n+  else if (align == UNITS_PER_WORD)\n+    {\n+      /* insns to copy by words */\n+      emit_insn(gen_lshrsi3 (count_reg, bytes_rtx, GEN_INT(2)));\n+      emit_insn(gen_movstrsi1 (GEN_INT(4)));\n+      /* insns to copy rest */\n+      emit_insn(gen_andsi3 (count_reg, bytes_rtx, GEN_INT(3)));\n+      emit_insn(gen_movstrsi1 (const1_rtx));\n+    }\n+  else\n+    {\n+      /* Not aligned and we may have a lot to copy so it is worth\n+       * aligning.\n+       */\n+      rtx aligned_label = gen_label_rtx ();\n+      rtx bytes_reg;\n+\n+      bytes_reg = copy_to_mode_reg(SImode, bytes_rtx);\n+      if (!constp)\n+\t{\n+\t  /* Emit insns to test and skip over the alignment if it is\n+\t   * not worth it. This doubles as a test to ensure that the alignment\n+\t   * operation can't copy too many bytes\n+\t   */\n+\t  emit_insn(gen_cmpsi (bytes_reg, GEN_INT(MAX_UNALIGNED_COPY)));\n+\t  emit_jump_insn (gen_blt (aligned_label));\n+\t}\n+\n+      /* Emit insns to do alignment at run time */\n+      emit_insn(gen_negsi2 (count_reg, src_reg));\n+      emit_insn(gen_andsi3 (count_reg, count_reg, GEN_INT(3)));\n+      emit_insn(gen_subsi3 (bytes_reg, bytes_reg, count_reg));\n+      emit_insn(gen_movstrsi1 (const1_rtx));\n+      if (!constp)\n+\temit_label (aligned_label);\n+\n+      /* insns to copy by words */\n+      emit_insn (gen_lshrsi3 (count_reg, bytes_reg, GEN_INT(2)));\n+      emit_insn(gen_movstrsi1 (GEN_INT(4)));\n+\n+      /* insns to copy rest */\n+      emit_insn (gen_andsi3 (count_reg, bytes_reg, GEN_INT(3)));\n+      emit_insn(gen_movstrsi1 (const1_rtx));    \n     }\n-  return 0;\n }\n+\f\n \n /* Returns 1 if OP contains a global symbol reference */\n \n@@ -465,11 +603,143 @@ global_symbolic_reference_mentioned_p (op, f)\n   return 0;\n }\n \n+\f\n+/* Returns 1 if OP contains a symbol reference */\n+\n+int\n+symbolic_reference_mentioned_p (op)\n+     rtx op;\n+{\n+  register char *fmt;\n+  register int i;\n+\n+  if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (op));\n+  for (i = GET_RTX_LENGTH (GET_CODE (op)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n+\t    if (symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && symbolic_reference_mentioned_p (XEXP (op, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\f\n+/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n+   attribute for DECL.  The attributes in ATTRIBUTES have previously been\n+   assigned to DECL.  */\n+\n+int\n+ns32k_valid_decl_attribute_p (decl, attributes, identifier, args)\n+     tree decl;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n+{\n+  return 0;\n+}\n+\n+/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific\n+   attribute for TYPE.  The attributes in ATTRIBUTES have previously been\n+   assigned to TYPE.  */\n+\n+int\n+ns32k_valid_type_attribute_p (type, attributes, identifier, args)\n+     tree type;\n+     tree attributes;\n+     tree identifier;\n+     tree args;\n+{\n+  if (TREE_CODE (type) != FUNCTION_TYPE\n+      && TREE_CODE (type) != FIELD_DECL\n+      && TREE_CODE (type) != TYPE_DECL)\n+    return 0;\n+\n+  /* Stdcall attribute says callee is responsible for popping arguments\n+     if they are not variable.  */\n+  if (is_attribute_p (\"stdcall\", identifier))\n+    return (args == NULL_TREE);\n+\n+  /* Cdecl attribute says the callee is a normal C declaration */\n+  if (is_attribute_p (\"cdecl\", identifier))\n+    return (args == NULL_TREE);\n+\n+  return 0;\n+}\n+\n+/* Return 0 if the attributes for two types are incompatible, 1 if they\n+   are compatible, and 2 if they are nearly compatible (which causes a\n+   warning to be generated).  */\n+\n+int\n+ns32k_comp_type_attributes (type1, type2)\n+     tree type1;\n+     tree type2;\n+{\n+  return 1;\n+}\n+\n+\f\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the ns32k, the RET insn may be used to pop them if the number\n+     of args is fixed, but if the number is variable then the caller\n+     must pop them all.  RET can't be used for library calls now\n+     because the library is compiled with the Unix compiler.\n+   Use of RET is a selectable option, since it is incompatible with\n+   standard Unix calling sequences.  If the option is not selected,\n+   the caller must always pop the args.\n+\n+   The attribute stdcall is equivalent to RET on a per module basis.  */\n+\n+int\n+ns32k_return_pops_args (fundecl, funtype, size)\n+     tree fundecl;\n+     tree funtype;\n+     int size;\n+{\n+  int rtd = TARGET_RTD;\n+\n+  if (TREE_CODE (funtype) == IDENTIFIER_NODE)\n+    return rtd ? size : 0;\n+\n+  /* Cdecl functions override -mrtd, and never pop the stack */\n+  if (lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (funtype)))\n+    return 0;\n+\n+  /* Stdcall functions will pop the stack if not variable args */\n+  if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (funtype)))\n+    rtd = 1;\n+\n+  if (rtd)\n+    {\n+      if (TYPE_ARG_TYPES (funtype) == NULL_TREE\n+\t  || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (funtype))) == void_type_node))\n+\treturn size;\n+    }\n+\n+  return 0;\n+}\n \f\n /* PRINT_OPERAND is defined to call this function,\n    which is easier to debug than putting all the code in\n    a macro definition in ns32k.h.  */\n \n+/* XXX time 12% of cpu time is in fprintf for non optimizing */\n void\n print_operand (file, x, code)\n      FILE *file;\n@@ -481,7 +751,7 @@ print_operand (file, x, code)\n   else if (code == '?')\n     PUT_EXTERNAL_PREFIX (file);\n   else if (GET_CODE (x) == REG)\n-    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+    fprintf (file, \"%s\", ns32k_out_reg_names[REGNO (x)]);\n   else if (GET_CODE (x) == MEM)\n     {\n       rtx tmp = XEXP (x, 0);\n@@ -528,11 +798,30 @@ print_operand (file, x, code)\n     }\n   else\n     {\n+      if (flag_pic\n+          && GET_CODE (x) == CONST\n+          && symbolic_reference_mentioned_p (x))\n+        {\n+\t  fprintf(stderr, \"illegal constant for pic-mode: \\n\");\n+\t  print_rtl(stderr, x);\n+          fprintf(stderr, \"\\nGET_CODE (x) == %d, CONST == %d, symbolic_reference_mentioned_p (x) == %d\\n\",\n+\t\t  GET_CODE (x), CONST, symbolic_reference_mentioned_p(x));\n+\t  abort ();\n+\t}\n+      else if (flag_pic\n+               && (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF))\n+\t{\n+\t  output_addr_const (file, x);\n+\t  fprintf (file, \"(sb)\");\n+\t}\n+      else\n+        {\n #ifdef NO_IMMEDIATE_PREFIX_IF_SYMBOLIC\n-      if (GET_CODE (x) == CONST_INT)\n+          if (GET_CODE (x) == CONST_INT)\n #endif\n-\tPUT_IMMEDIATE_PREFIX (file);\n-      output_addr_const (file, x);\n+\t    PUT_IMMEDIATE_PREFIX (file);\n+          output_addr_const (file, x);\n+\t}\n     }\n }\n \f\n@@ -545,6 +834,7 @@ print_operand (file, x, code)\n    figure out how it worked.\n    90-11-25 Tatu Yl|nen <ylo@cs.hut.fi> */\n \n+void\n print_operand_address (file, addr)\n      register FILE *file;\n      register rtx addr;\n@@ -597,7 +887,7 @@ print_operand_address (file, addr)\n \t    base = tmp;\n \t  break;\n \tcase REG:\n-\t  if (REGNO (tmp) < 8)\n+\t  if (REGNO (tmp) < F0_REGNUM)\n \t    if (base)\n \t      {\n \t\tindexexp = tmp;\n@@ -728,7 +1018,7 @@ print_operand_address (file, addr)\n \t   (disp(sb)) (MEM ...)\n \t   */\n       case REG:\n-\tfprintf (file, \"(%s)\", reg_names[REGNO (base)]);\n+\tfprintf (file, \"(%s)\", ns32k_out_reg_names[REGNO (base)]);\n \tbreak;\n       case SYMBOL_REF:\n \tif (! flag_pic)\n@@ -785,7 +1075,7 @@ print_operand_address (file, addr)\n \tfprintf (file, \"(\");\n \toutput_addr_const (file, offset);\n \tif (base)\n-\t  fprintf (file, \"(%s)\", reg_names[REGNO (base)]);\n+\t  fprintf (file, \"(%s)\", ns32k_out_reg_names[REGNO (base)]);\n \telse if (TARGET_SB)\n \t  fprintf (file, \"(sb)\");\n \telse\n@@ -816,16 +1106,16 @@ print_operand_address (file, addr)\n \t}\n       else\n \tscale = 0;\n-      if (GET_CODE (indexexp) != REG || REGNO (indexexp) >= 8)\n+      if (GET_CODE (indexexp) != REG || REGNO (indexexp) >= F0_REGNUM)\n \tabort ();\n \n #ifdef UTEK_ASM\n       fprintf (file, \"[%c`%s]\",\n \t       scales[scale],\n-\t       reg_names[REGNO (indexexp)]);\n+\t       ns32k_out_reg_names[REGNO (indexexp)]);\n #else\n       fprintf (file, \"[%s:%c]\",\n-\t       reg_names[REGNO (indexexp)],\n+\t       ns32k_out_reg_names[REGNO (indexexp)],\n \t       scales[scale]);\n #endif\n     }"}, {"sha": "d409ac26408d76068243458a40074ed95d53e549", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 367, "deletions": 121, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8357595779418585b4390bb66be518b32374965a/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8357595779418585b4390bb66be518b32374965a/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=8357595779418585b4390bb66be518b32374965a", "patch": "@@ -23,8 +23,6 @@ Boston, MA 02111-1307, USA.  */\n /* Note that some other tm.h files include this one and then override\n    many of the definitions that relate to assembler syntax.  */\n \n-extern enum reg_class secondary_reload_class();\n-\n /* Names to predefine in the preprocessor for this target machine.  */\n \n #define CPP_PREDEFINES \"-Dns32000 -Dunix -Asystem(unix) -Acpu(ns32k) -Amachine(ns32k)\"\n@@ -66,6 +64,18 @@ extern int target_flags;\n \n /* Compile 32081 insns for floating point (not library calls). */\n #define TARGET_32081 (target_flags & 1)\n+#define TARGET_32381 (target_flags & 256)\n+\n+/* The use of multiply-add instructions is optional because it can\n+ * cause an abort due to being unable to find a spill register. The\n+ * main problem is that the multiply-add instructions require f0 and\n+ * f0 is not available for spilling because it is \"explicitly\n+ * mentioned\" in the rtl for function return values. This can be fixed\n+ * by defining SMALL_REGISTER_CLASSES, but that causes worse code for\n+ * the (more common) integer case. We really need better reload code.\n+ */\n+\n+#define TARGET_MULT_ADD (target_flags & 512)\n \n /* Compile using rtd insn calling sequence.\n    This will not work unless you use prototypes at least\n@@ -93,9 +103,9 @@ extern int target_flags;\n    where VALUE is the bits to set or minus the bits to clear.\n    An empty string NAME is used to identify the default VALUE.  */\n \n-#define TARGET_SWITCHES  \\\n+#define TARGET_SWITCHES\t\t\t\t\\\n   { { \"32081\", 1},\t\t\t\t\\\n-    { \"soft-float\", -1},\t\t\t\\\n+    { \"soft-float\", -257},\t\t\t\\\n     { \"rtd\", 2},\t\t\t\t\\\n     { \"nortd\", -2},\t\t\t\t\\\n     { \"regparm\", 4},\t\t\t\t\\\n@@ -110,17 +120,66 @@ extern int target_flags;\n     { \"nobitfield\", 64},\t\t\t\\\n     { \"himem\", 128},\t\t\t\t\\\n     { \"nohimem\", -128},\t\t\t\t\\\n+    { \"32381\", 256},\t\t\t\t\\\n+    { \"mult-add\", 512},\t\t\t\t\\\n+    { \"nomult-add\", -512},            \t\t\\\n     { \"\", TARGET_DEFAULT}}\n+\n /* TARGET_DEFAULT is defined in encore.h, pc532.h, etc.  */\n \n /* When we are generating PIC, the sb is used as a pointer\n-   to the GOT.  */\n+   to the GOT. 32381 is a superset of 32081  */\n \n-#define OVERRIDE_OPTIONS\t\t\\\n-{\t\t\t\t\t\\\n+#define OVERRIDE_OPTIONS\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n   if (flag_pic || TARGET_HIMEM) target_flags |= 32;\t\\\n+  if (TARGET_32381) target_flags |= 1;\t\t\t\\\n+  else target_flags &= ~512;\t\t\t\t\\\n }\n \n+/* Zero or more C statements that may conditionally modify two\n+   variables `fixed_regs' and `call_used_regs' (both of type `char\n+   []') after they have been initialized from the two preceding\n+   macros.\n+\n+   This is necessary in case the fixed or call-clobbered registers\n+   depend on target flags.\n+\n+   You need not define this macro if it has no work to do.\n+\n+   If the usage of an entire class of registers depends on the target\n+   flags, you may indicate this to GCC by using this macro to modify\n+   `fixed_regs' and `call_used_regs' to 1 for each of the registers in\n+   the classes which should not be used by GCC.  Also define the macro\n+   `REG_CLASS_FROM_LETTER' to return `NO_REGS' if it is called with a\n+   letter for a class that shouldn't be used.\n+\n+   (However, if this class is not included in `GENERAL_REGS' and all\n+   of the insn patterns whose constraints permit this class are\n+   controlled by target switches, then GCC will automatically avoid\n+   using these registers when the target switches are opposed to\n+   them.)  */\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!TARGET_32081)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint regno;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfor (regno = F0_REGNUM; regno <= F0_REGNUM + 8; regno++)\t\\\n+\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (!TARGET_32381)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint regno;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tfor (regno = L1_REGNUM; regno <= L1_REGNUM + 8; regno++)\t\\\n+\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n \f\n /* target machine storage layout */\n \n@@ -190,13 +249,14 @@ extern int target_flags;\n    from 0 to just below FIRST_PSEUDO_REGISTER.\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n-#define FIRST_PSEUDO_REGISTER 18\n+#define FIRST_PSEUDO_REGISTER 26\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    On the ns32k, these are the FP, SP, (SB and PC are not included here).  */\n #define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, \\\n \t\t\t 0, 0, 0, 0, 0, 0, 0, 0, \\\n+                         0, 0, 0, 0, 0, 0, 0, 0, \\\n \t\t\t 1, 1}\n \n /* 1 for registers not available across function calls.\n@@ -207,13 +267,70 @@ extern int target_flags;\n    Aside from that, you can include as many other registers as you like.  */\n #define CALL_USED_REGISTERS {1, 1, 1, 0, 0, 0, 0, 0, \\\n \t\t\t     1, 1, 1, 1, 0, 0, 0, 0, \\\n+\t\t\t     1, 1, 0, 0, 0, 0, 0, 0, \\\n \t\t\t     1, 1}\n \n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \\\n+ \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \\\n+ \"l1\", \"l1h\",\"l3\", \"l3h\",\"l5\", \"l5h\",\"l7\", \"l7h\", \\\n+ \"fp\", \"sp\"}\n+\n+\n+#define ADDITIONAL_REGISTER_NAMES \\\n+{{\"l0\", 8}, {\"l2\", 10}, {\"l4\", 12}, {\"l6\", 14}}\n+\n+/* l0-7 are not recognized by the assembler. These are the names to use,\n+ * but we don't want ambiguous names in REGISTER_NAMES\n+ */\n+#define OUTPUT_REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \\\n+ \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \\\n+ \"f1\", \"l1h\",\"f3\", \"l3h\",\"f5\", \"l5h\",\"f7\", \"f7h\", \\\n+ \"fp\", \"sp\"}\n+\n+#define REG_ALLOC_ORDER \\\n+{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 10, 11, 18, 12, 13, 20, 14, 15, 22, 24, 25, 17, 19, 23}\n+\n+/* How to renumber registers for dbx and gdb.\n+   NS32000 may need more change in the numeration. XXX */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+  ((REGNO) < L1_REGNUM? (REGNO) \\\n+   : (REGNO) < FRAME_POINTER_REGNUM? (REGNO) - L1_REGNUM + 22 \\\n+   : (REGNO) == FRAME_POINTER_REGNUM? 17 \\\n+   : 16)\n+\n+\n+\n+\n+#define R0_REGNUM 0\n+#define F0_REGNUM 8\n+#define L1_REGNUM 16\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* NS32000 pc is not overloaded on a register.  */\n+/* #define PC_REGNUM */\n+\n+/* Register to use for pushing function arguments. */\n+#define STACK_POINTER_REGNUM 25\n+\n+/* Base register for access to local variables of the function. */\n+#define FRAME_POINTER_REGNUM 24\n+\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n-   On the ns32k, all registers are 32 bits long.  */\n+   On the ns32k, all registers are 32 bits long except for the 32381 \"long\"\n+   registers but we treat those as pairs  */\n+#define LONG_FP_REGS_P(REGNO) ((REGNO) >= L1_REGNUM && (REGNO) < L1_REGNUM + 8)\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n@@ -223,22 +340,19 @@ extern int target_flags;\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (((MODE1) == DFmode || (MODE1) == DCmode || (MODE1) == DImode) ==\t\\\n-   ((MODE2) == DFmode || (MODE2) == DCmode || (MODE2) == DImode))\n+   for any hard reg, then this must be 0 for correct output.\n \n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* NS32000 pc is not overloaded on a register.  */\n-/* #define PC_REGNUM */\n+   Early documentation says SI and DI are not tieable if some reg can\n+   be OK for SI but not for DI. However other ports (mips, i860, mvs\n+   and tahoe) don't meet the above criterion. Evidently the real\n+   requirement is somewhat laxer. Documentation was changed for gcc\n+   2.8 but was not picked up by egcs (at least egcs 1.0). Having all\n+   integer modes tieable definitely generates faster code. */\n \n-/* Register to use for pushing function arguments. */\n-#define STACK_POINTER_REGNUM 17\n-\n-/* Base register for access to local variables of the function. */\n-#define FRAME_POINTER_REGNUM 16\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n+  ((FLOAT_MODE_P(MODE1) && FLOAT_MODE_P(MODE2)\t\t\t\t\\\n+    && (GET_MODE_UNIT_SIZE(MODE1) == GET_MODE_UNIT_SIZE(MODE2)))\t\\\n+   || (!FLOAT_MODE_P(MODE1) && !FLOAT_MODE_P(MODE2)))\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -247,7 +361,7 @@ extern int target_flags;\n #define FRAME_POINTER_REQUIRED 0\n \n /* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 16\n+#define ARG_POINTER_REGNUM 24\n \n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM 1\n@@ -275,37 +389,39 @@ extern int target_flags;\n \n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n-   \n-enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n-\t\t FRAME_POINTER_REG, STACK_POINTER_REG, \n-                 GEN_AND_MEM_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+enum reg_class\n+{ NO_REGS, GENERAL_REGS, FLOAT_REG0, LONG_FLOAT_REG0, FLOAT_REGS,\n+  FP_REGS, GEN_AND_FP_REGS, FRAME_POINTER_REG, STACK_POINTER_REG,\n+  GEN_AND_MEM_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"GENERAL_REGS\", \"FLOAT_REGS\", \"GEN_AND_FP_REGS\",  \\\n-  \"FRAME_POINTER_REG\", \"STACK_POINTER_REG\", \"GEN_AND_MEM_REGS\", \"ALL_REGS\" }\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"FLOAT_REG0\", \"LONG_FLOAT_REG0\", \"FLOAT_REGS\", \\\n+  \"FP_REGS\", \"GEN_AND_FP_REGS\", \"FRAME_POINTER_REG\", \"STACK_POINTER_REG\", \\\n+  \"GEN_AND_MEM_REGS\", \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS {0, 0x00ff, 0xff00, 0xffff, \\\n-\t\t\t    0x10000, 0x20000, 0x300ff, 0x3ffff }\n+#define REG_CLASS_CONTENTS {0, 0x00ff, 0x100, 0x300, 0xff00, \\\n+                            0xffff00, 0xffffff, 0x1000000, 0x2000000, \\\n+                            0x30000ff, 0x3ffffff }\n+\n+#define SUBSET_P(CLASS1, CLASS2) \\\n+   ((ns32k_reg_class_contents[CLASS1] & ~ns32k_reg_class_contents[CLASS2]) \\\n+     == 0)\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO) \\\n-  ((REGNO) < 8 ? GENERAL_REGS          \\\n-   : (REGNO) < 16 ? FLOAT_REGS         \\\n-   : (REGNO) == 16 ? FRAME_POINTER_REG \\\n-   : (REGNO) == 17 ? STACK_POINTER_REG \\\n-   : NO_REGS)\n+#define REGNO_REG_CLASS(REGNO)  (regclass_map[REGNO])\n \n /* The class value for index registers, and the one for base regs.  */\n \n@@ -314,10 +430,13 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n \n /* Get reg_class from a letter such as appears in the machine description.  */\n \n-#define REG_CLASS_FROM_LETTER(C)\t\\\n- ((C) == 'f' ? FLOAT_REGS\t\t\\\n-  : (C) == 'x' ? FRAME_POINTER_REG\t\\\n-  : (C) == 'y' ? STACK_POINTER_REG      \\\n+#define REG_CLASS_FROM_LETTER(C)\t\t\\\n+ ((C) == 'u' ? FLOAT_REG0\t\t\t\\\n+  : (C) == 'v' ? LONG_FLOAT_REG0\t\t\\\n+  : (C) == 'f' ? FLOAT_REGS\t\t\t\\\n+  : (C) == 'l' ? FP_REGS\t\t\t\\\n+  : (C) == 'x' ? FRAME_POINTER_REG\t\t\\\n+  : (C) == 'y' ? STACK_POINTER_REG\t\t\\\n   : NO_REGS)\n \n /* The letters I, J, K, L and M in a register constraint string\n@@ -353,13 +472,15 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n \n /* We return GENERAL_REGS instead of GEN_AND_MEM_REGS.\n    The latter offers no real additional possibilities\n-   and can cause spurious secondary reloading.  */ \n+   and can cause spurious secondary reloading.  */\n+\n #define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n  ((CLASS) == GEN_AND_MEM_REGS ? GENERAL_REGS : (CLASS))\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On the 32000, this is the size of MODE in words */\n+\n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \f\n@@ -381,6 +502,46 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n    of the first local allocated.  */\n #define STARTING_FRAME_OFFSET 0\n \n+/* A C expression whose value is RTL representing the location of the\n+   incoming return address at the beginning of any function, before\n+   the prologue.  This RTL is either a `REG', indicating that the\n+   return value is saved in `REG', or a `MEM' representing a location\n+   in the stack.\n+\n+   You only need to define this macro if you want to support call\n+   frame debugging information like that provided by DWARF 2.\n+\n+   Before the prologue, RA is at 0(sp).  */\n+\n+#define INCOMING_RETURN_ADDR_RTX \\\n+  gen_rtx (MEM, VOIDmode, gen_rtx (REG, VOIDmode, STACK_POINTER_REGNUM))\n+\n+/* A C expression whose value is RTL representing the value of the\n+   return address for the frame COUNT steps up from the current frame,\n+   after the prologue.  FRAMEADDR is the frame pointer of the COUNT\n+   frame, or the frame pointer of the COUNT - 1 frame if\n+   `RETURN_ADDR_IN_PREVIOUS_FRAME' is defined.\n+\n+   After the prologue, RA is at 4(fp) in the current frame.  */\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n+  (gen_rtx (MEM, Pmode, gen_rtx (PLUS, Pmode, (FRAME), GEN_INT(4))))\n+\n+/* A C expression whose value is an integer giving the offset, in\n+   bytes, from the value of the stack pointer register to the top of\n+   the stack frame at the beginning of any function, before the\n+   prologue.  The top of the frame is defined to be the value of the\n+   stack pointer in the previous frame, just before the call\n+   instruction.\n+\n+   You only need to define this macro if you want to support call\n+   frame debugging information like that provided by DWARF 2. */\n+\n+#define INCOMING_FRAME_SP_OFFSET 4\n+\n+/* Offset of the CFA from the argument pointer register value.  */\n+#define ARG_POINTER_CFA_OFFSET 8\n+\n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n    On the 32000, sp@- in a byte insn really pushes a BYTE.  */\n@@ -402,38 +563,32 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n      because the library is compiled with the Unix compiler.\n    Use of RET is a selectable option, since it is incompatible with\n    standard Unix calling sequences.  If the option is not selected,\n-   the caller must always pop the args.  */\n+   the caller must always pop the args.\n+\n+   The attribute stdcall is equivalent to RTD on a per module basis.  */\n \n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)   \\\n-  ((TARGET_RTD && (!(FUNDECL) || TREE_CODE (FUNDECL) != IDENTIFIER_NODE)\t\\\n-    && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n-\t|| (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n-\t    == void_type_node)))\t\t\t\t\\\n-   ? (SIZE) : 0)\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n+  (ns32k_return_pops_args (FUNDECL, FUNTYPE, SIZE))\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n \n /* On the 32000 the return value is in R0,\n-   or perhaps in F0 is there is fp support.  */   \n+   or perhaps in F0 if there is fp support.  */\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_32081 \\\n-   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8) \\\n-   : gen_rtx (REG, TYPE_MODE (VALTYPE), 0))\n+#define FUNCTION_VALUE(VALTYPE, FUNC) LIBCALL_VALUE(TYPE_MODE (VALTYPE))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n /* On the 32000 the return value is in R0,\n-   or perhaps F0 is there is fp support.  */   \n+   or perhaps F0 is there is fp support.  */\n \n #define LIBCALL_VALUE(MODE)  \\\n-  (((MODE) == DFmode || (MODE) == SFmode) && TARGET_32081 \\\n-   ? gen_rtx (REG, MODE, 8) \\\n-   : gen_rtx (REG, MODE, 0))\n+  gen_rtx (REG, MODE,\t\t\t\t  \\\n+\t   FLOAT_MODE_P(MODE) && TARGET_32081 ? F0_REGNUM: R0_REGNUM)\n \n /* Define this if PCC uses the nonreentrant convention for returning\n    structure and union values.  */\n@@ -554,18 +709,18 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n #define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n { register int regno, g_regs_used = 0;\t\t\t\t\\\n   int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n-  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n+  int used_fregs_buf[17], *fbufp = used_fregs_buf;\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\\\n   extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n   MAIN_FUNCTION_PROLOGUE;\t\t\t\t\t\\\n-  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n+  for (regno = R0_REGNUM; regno < F0_REGNUM; regno++)\t\t\\\n     if (regs_ever_live[regno]\t\t\t\t\t\\\n \t&& ! call_used_regs[regno])\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n         *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n   *bufp = -1;\t\t\t\t\t\t\t\\\n-  for (; regno < 16; regno++)\t\t\t\t\t\\\n+  for (; regno < FRAME_POINTER_REGNUM; regno++)\t\t\t\\\n     if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n       {\t\t\t\t\t\t\t\t\\\n         *fbufp++ = regno;\t\t\t\t\t\\\n@@ -600,11 +755,12 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n   fbufp = used_fregs_buf;\t\t\t\t\t\\\n   while (*fbufp >= 0)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\t\t\\\n-\tfprintf (FILE, \"\\tmovf f%d,tos\\n\", *fbufp++ - 8);\t\\\n+      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\t\\\n+\tfprintf (FILE, \"\\tmovf %s,tos\\n\", ns32k_out_reg_names[*fbufp++]); \\\n       else\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl f%d,tos\\n\", fbufp[0] - 8);\t\\\n+\t  fprintf (FILE, \"\\tmovl %s,tos\\n\",                     \\\n+\t\t   ns32k_out_reg_names[fbufp[0]]);                    \\\n \t  fbufp += 2;\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n@@ -678,32 +834,33 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n #define FUNCTION_EPILOGUE(FILE, SIZE) \\\n { register int regno, g_regs_used = 0, f_regs_used = 0;\t\t\\\n   int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n-  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n+  int used_fregs_buf[17], *fbufp = used_fregs_buf;\t\t\\\n   extern char call_used_regs[];\t\t\t\t\t\\\n   extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n   if (flag_pic && current_function_uses_pic_offset_table)\t\\\n     fprintf (FILE, \"\\tlprd sb,tos\\n\");\t\t\t\t\\\n   *fbufp++ = -2;\t\t\t\t\t\t\\\n-  for (regno = 8; regno < 16; regno++)\t\t\t\t\\\n+  for (regno = F0_REGNUM; regno < FRAME_POINTER_REGNUM; regno++) \\\n     if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n       {\t\t\t\t\t\t\t\t\\\n        *fbufp++ = regno; f_regs_used++;\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n   fbufp--;\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n+  for (regno = 0; regno < F0_REGNUM; regno++)\t\t\t\\\n     if (regs_ever_live[regno]\t\t\t\t\t\\\n \t&& ! call_used_regs[regno])\t\t\t\t\\\n       {                                                        \t\\\n         *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n       }                                                        \t\\\n   while (fbufp > used_fregs_buf)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\t\t\\\n+      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\t        \\\n \t{\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tmovl tos,f%d\\n\", fbufp[-1] - 8);\t\\\n+\t  fprintf (FILE, \"\\tmovl tos,%s\\n\",                     \\\n+\t\t   ns32k_out_reg_names[fbufp[-1]]);                   \\\n \t  fbufp -= 2;\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n-      else fprintf (FILE, \"\\tmovf tos,f%d\\n\", *fbufp-- - 8);\t\\\n+      else fprintf (FILE, \"\\tmovf tos,%s\\n\", ns32k_out_reg_names[*fbufp--]); \\\n     }\t\t\t\t\t\t\t\t\\\n   if (frame_pointer_needed)\t\t\t\t\t\\\n     fprintf (FILE, \"\\texit [\");\t\t\t\t\t\\\n@@ -742,9 +899,12 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, GEN_AND_FP_REGS,\n   int regno;\t\t\t\t\t\t\t\\\n   int offset = -4;\t\t\t\t\t\t\\\n   extern int current_function_uses_pic_offset_table, flag_pic;\t\\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+  for (regno = 0; regno < L1_REGNUM; regno++)\t\t\t\\\n     if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n       offset += 4;\t\t\t\t\t\t\\\n+  for (; regno < FRAME_POINTER_REGNUM; regno++)\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      offset += 8;\t\t\t\t\t\t\\\n   if (flag_pic && current_function_uses_pic_offset_table)\t\\\n     offset += 4;\t\t\t\t\t\t\\\n   (DEPTH) = (offset + get_frame_size ()\t\t\t\t\\\n@@ -824,12 +984,13 @@ __transfer_from_trampoline ()\t\t\\\n \n /* note that FP and SP cannot be used as an index. What about PC? */\n #define REGNO_OK_FOR_INDEX_P(REGNO)  \\\n-((REGNO) < 8 || (unsigned)reg_renumber[REGNO] < 8)\n+((REGNO) < F0_REGNUM || (unsigned)reg_renumber[REGNO] < F0_REGNUM)\n #define REGNO_OK_FOR_BASE_P(REGNO)   \\\n-((REGNO) < 8 || (unsigned)reg_renumber[REGNO] < 8 \\\n+((REGNO) < F0_REGNUM || (unsigned)reg_renumber[REGNO] < F0_REGNUM \\\n  || (REGNO) == FRAME_POINTER_REGNUM || (REGNO) == STACK_POINTER_REGNUM)\n \n-#define FP_REG_P(X)  (GET_CODE (X) == REG && REGNO (X) > 7 && REGNO (X) < 16)\n+#define FP_REG_P(X) \\\n+ (GET_CODE (X) == REG && REGNO (X) >= F0_REGNUM && REGNO (X) < FRAME_POINTER_REGNUM)\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -838,19 +999,18 @@ __transfer_from_trampoline ()\t\t\\\n /* Recognize any constant value that is a valid address.\n    This might not work on future ns32k processors as negative\n    displacements are not officially allowed but a mode reserved\n-   to National.  This works on processors up to 32532, though. */\n+   to National.  This works on processors up to 32532, though,\n+   and we don't expect any new ones in the series ;-( */\n \n #define CONSTANT_ADDRESS_P(X)   \\\n   (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n    || GET_CODE (X) == CONST\t\t\t\t\t\t\\\n    || (GET_CODE (X) == CONST_INT\t\t\t\t\t\\\n-       && ((unsigned)INTVAL (X) >= 0xe0000000\t\t\t\t\\\n-\t   || (unsigned)INTVAL (X) < 0x20000000)))\n+       && NS32K_DISPLACEMENT_P (INTVAL (X))))\n \n #define CONSTANT_ADDRESS_NO_LABEL_P(X)   \\\n   (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n-   && ((unsigned)INTVAL (X) >= 0xe0000000\t\t\t\t\\\n-       || (unsigned)INTVAL (X) < 0x20000000))\n+   && NS32K_DISPLACEMENT_P (INTVAL (X)))\n \n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n@@ -859,6 +1019,42 @@ __transfer_from_trampoline ()\t\t\\\n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n   secondary_reload_class (CLASS, MODE, IN)\n \n+/*  Certain machines have the property that some registers cannot be\n+    copied to some other registers without using memory.  Define this\n+    macro on those machines to be a C expression that is non-zero if\n+    objects of mode M in registers of CLASS1 can only be copied to\n+    registers of class CLASS2 by storing a register of CLASS1 into\n+    memory and loading that memory location into a register of CLASS2.\n+\n+    On the ns32k, floating point regs can only be loaded through memory\n+\n+    The movdf and movsf insns in ns32k.md copy between general and\n+    floating registers using the stack. In principle, we could get\n+    better code not allowing that case in the constraints and defining\n+    SECONDARY_MEMORY_NEEDED in practice, though the stack slots used\n+    are not available for optimization.  */\n+\n+#if 0\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, M)\t\t\t\\\n+     secondary_memory_needed(CLASS1, CLASS2, M)\n+#endif\n+\n+/* SMALL_REGISTER_CLASSES is true only if we have said we are using the\n+ * multiply-add instructions.\n+ */\n+#define SMALL_REGISTER_CLASSES (target_flags & 512)\n+\n+/* A C expression whose value is nonzero if pseudos that have been\n+   assigned to registers of class CLASS would likely be spilled\n+   because registers of CLASS are needed for spill registers.\n+\n+   The default definition won't do because class LONG_FLOAT_REG0 has two\n+   registers which are always acessed as a pair */\n+\n+#define CLASS_LIKELY_SPILLED_P(CLASS) \\\n+  (reg_class_size[(int) (CLASS)] == 1 || (CLASS) == LONG_FLOAT_REG0)\n+\n+\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n@@ -882,10 +1078,10 @@ __transfer_from_trampoline ()\t\t\\\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) < 8 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  (REGNO (X) < F0_REGNUM || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n /* Nonzero if X is a hard reg that can be used as a base reg\n    of if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) (REGNO (X) < 8 || REGNO (X) >= FRAME_POINTER_REGNUM)\n+#define REG_OK_FOR_BASE_P(X) (REGNO (X) < F0_REGNUM || REGNO (X) >= FRAME_POINTER_REGNUM)\n /* Nonzero if X is a floating point reg or a pseudo reg.  */\n \n #else\n@@ -936,7 +1132,8 @@ __transfer_from_trampoline ()\t\t\\\n \n /* Check for frame pointer or stack pointer.  */\n #define MEM_REG(X) \\\n-  (GET_CODE (X) == REG && (REGNO (X) ^ 16) < 2)\n+  (GET_CODE (X) == REG && (REGNO (X) == FRAME_POINTER_REGNUM  \\\n+\t\t\t   || REGNO(X) == STACK_POINTER_REGNUM))\n \n /* A memory ref whose address is the FP or SP, with optional integer offset,\n    or (on certain machines) a constant address.  */\n@@ -1040,15 +1237,21 @@ __transfer_from_trampoline ()\t\t\\\n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   {}\n \n /* Nonzero if the constant value X is a legitimate general operand\n-   when generating PIC code.  It is given that flag_pic is on and \n+   when generating PIC code.  It is given that flag_pic is on and\n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n extern int current_function_uses_pic_offset_table, flag_pic;\n #define LEGITIMATE_PIC_OPERAND_P(X) \\\n   (((! current_function_uses_pic_offset_table\t\t\t\\\n-     && global_symbolic_reference_mentioned_p (X, 1))?\t\t\\\n+     && symbolic_reference_mentioned_p (X))?\t\t\t\\\n       (current_function_uses_pic_offset_table = 1):0\t\t\\\n-   ), 1)\n+   ), (! SYMBOLIC_CONST (X)\t\t\t\t\t\\\n+   || GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF))\n+\n+#define SYMBOLIC_CONST(X)\t\\\n+(GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n+ || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n+ || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n \n /* Define this macro if references to a symbol must be treated\n    differently depending on something about the variable or\n@@ -1082,6 +1285,33 @@ while (0)\n  { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n      goto LABEL;}\n \f\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, NAME, ARGS) \\\n+  (ns32k_valid_decl_attribute_p (DECL, ATTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is nonzero if IDENTIFIER\n+   with arguments ARGS is a valid machine specific attribute for TYPE.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+\n+#define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRIBUTES, NAME, ARGS) \\\n+  (ns32k_valid_type_attribute_p (TYPE, ATTRIBUTES, NAME, ARGS))\n+\n+/* If defined, a C expression whose value is zero if the attributes on\n+   TYPE1 and TYPE2 are incompatible, one if they are compatible, and\n+   two if they are nearly compatible (which causes a warning to be\n+   generated).  */\n+\n+#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n+  (ns32k_comp_type_attributes (TYPE1, TYPE2))\n+\n+/* If defined, a C statement that assigns default attributes to newly\n+   defined TYPE.  */\n+\n+/* #define SET_DEFAULT_TYPE_ATTRIBUTES (TYPE) */\n+\f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.\n    HI mode is more efficient but the range is not wide enough for\n@@ -1107,6 +1337,12 @@ while (0)\n    in one reasonably fast instruction.  */\n #define MOVE_MAX 4\n \n+/* The number of scalar move insns which should be generated instead\n+   of a string move insn or a library call.\n+   \n+   We have a smart movstrsi insn */\n+#define MOVE_RATIO 0\n+\n /* Define this if zero-extension is slow (more than one real instruction).  */\n /* #define SLOW_ZERO_EXTEND */\n \n@@ -1226,16 +1462,13 @@ while (0)\n /* Describe the costs of the following register moves which are discouraged:\n    1.) Moves between the Floating point registers and the frame pointer and stack pointer\n    2.) Moves between the stack pointer and the frame pointer\n-   3.) Moves between the floating point and general registers */\n+   3.) Moves between the floating point and general registers\n+\n+  These all involve two memory references. This is worse than a memory\n+  to memory move (default cost 4)\n+ */\n \n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)   \\\n-  ((((CLASS1) == FLOAT_REGS && ((CLASS2) == STACK_POINTER_REG || (CLASS2) == FRAME_POINTER_REG))    \\\n-   || ((CLASS2) == FLOAT_REGS && ((CLASS1) == STACK_POINTER_REG || (CLASS1) == FRAME_POINTER_REG))  \\\n-   || ((CLASS1) == STACK_POINTER_REG && (CLASS2) == FRAME_POINTER_REG)                              \\\n-   || ((CLASS2) == STACK_POINTER_REG && (CLASS1) == FRAME_POINTER_REG)                              \\\n-   || ((CLASS1) == FLOAT_REGS && (CLASS2) == GENERAL_REGS)                                          \\\n-   || ((CLASS1) == GENERAL_REGS && (CLASS2) == FLOAT_REGS))                                         \\\n- ? 4  : 2)\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)  register_move_cost(CLASS1, CLASS2)\n \n #define OUTPUT_JUMP(NORMAL, NO_OV)  \\\n { if (cc_status.flags & CC_NO_OVERFLOW)\t\t\t\t\\\n@@ -1307,12 +1540,8 @@ while (0)\n /* This is how to output an assembler line defining an external/static\n    address which is not in tree format (for collect.c).  */\n \n-#define ASM_OUTPUT_LABELREF_AS_INT(STREAM, NAME)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.long\\t\");\t\t\t\t\t\\\n-  ASM_OUTPUT_LABELREF (STREAM, NAME);\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-} while (0)\n+/* The prefix to add to user-visible assembler symbols. */\n+#define USER_LABEL_PREFIX \"_\"\n \n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n@@ -1326,19 +1555,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n   fprintf (FILE, \"\\tmovd tos,%s\\n\", reg_names[REGNO])\n \n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \\\n- \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \\\n- \"fp\", \"sp\"}\n-\n-/* How to renumber registers for dbx and gdb.\n-   NS32000 may need more change in the numeration.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) ((REGNO < 8) ? (REGNO)+4 : (REGNO))\n-\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n \n@@ -1365,9 +1581,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n #endif\n \n-/* The prefix to add to user-visible assembler symbols. */\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n \n-#define USER_LABEL_PREFIX \"_\"\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n \n /* This is how to output an internal numbered label where\n    PREFIX is the class of label and NUM is the number within the class.  */\n@@ -1463,11 +1681,39 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address(FILE, ADDR)\n \n-/* Define functions in ns32k.c and used in insn-output.c.  */\n-\n-extern char *output_move_double ();\n-extern char *output_shift_insn ();\n-extern char *output_move_dconst ();\n+/* Prototypes for functions in ns32k.c */\n+\n+/* Prototypes would be nice, but for now it causes too many problems.\n+   This file gets included in places where the types (such as \"rtx\"\n+   and enum machine_mode) are not defined. */\n+#define NS32K_PROTO(ARGS) ()\n+\n+int hard_regno_mode_ok NS32K_PROTO((int regno, enum machine_mode mode));\n+int register_move_cost NS32K_PROTO((enum reg_class CLASS1, enum reg_class CLASS2));\n+int calc_address_cost NS32K_PROTO((rtx operand));\n+enum reg_class secondary_reload_class NS32K_PROTO((enum reg_class class,\n+\t\t\t\t\t     enum machine_mode mode, rtx in));\n+int reg_or_mem_operand NS32K_PROTO((register rtx op, enum machine_mode mode));\n+\n+void split_di NS32K_PROTO((rtx operands[], int num, rtx lo_half[], hi_half[]));\n+\n+void expand_block_move NS32K_PROTO((rtx operands[]));\n+int global_symbolic_reference_mentioned_p NS32K_PROTO((rtx op, int f));\n+int ns32k_comp_type_attributes NS32K_PROTO((tree type1, tree type2));\n+int ns32k_return_pops_args NS32K_PROTO((tree fundecl, tree funtype, int size));\n+int ns32k_valid_decl_attribute_p NS32K_PROTO((tree decl, tree attributes,\n+\t\t\t\t\t\ttree identifier, tree args));\n+int ns32k_valid_type_attribute_p NS32K_PROTO((tree decl, tree attributes,\n+\t\t\t\t\t\ttree identifier, tree args));\n+void print_operand NS32K_PROTO((FILE *file, rtx x, char code));\n+void print_operand_address NS32K_PROTO((register FILE *file, register rtx addr));\n+char *output_move_dconst NS32K_PROTO((int n, char *s));\n+char *output_move_double NS32K_PROTO((rtx *operands));\n+char *output_shift_insn NS32K_PROTO((rtx *operands));\n+\n+extern unsigned int ns32k_reg_class_contents[N_REG_CLASSES];\n+extern char *ns32k_out_reg_names[];\n+extern enum reg_class regclass_map[];\t\t/* smalled class containing REGNO */\n \n /*\n Local variables:"}, {"sha": "161b74e80a7511e672ee10da01d290ea374485b5", "filename": "gcc/config/ns32k/ns32k.md", "status": "modified", "additions": 446, "deletions": 254, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8357595779418585b4390bb66be518b32374965a/gcc%2Fconfig%2Fns32k%2Fns32k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8357595779418585b4390bb66be518b32374965a/gcc%2Fconfig%2Fns32k%2Fns32k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.md?ref=8357595779418585b4390bb66be518b32374965a", "patch": "@@ -39,7 +39,20 @@\n ;; We don't want to allow a constant operand for test insns because\n ;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n ;; be folded while optimizing anyway.\n-\n+;;\n+;; In order for pic mode to work we cannot generate, for example\n+;;\n+;;   addd _x+5,r1\n+;;\n+;; instead we must force gcc to generate something like\n+;;\n+;;   addr 5(_x(sb)),r0\n+;;   addd r0,r1\n+;;\n+;; This was done through operand constraints (using \"rmn\" in place of \"g\"),\n+;; but with the proper definition of LEGITIMATE_PIC_OPERAND (ns32k.h)\n+;; this is unnecessary.\n+;;\n (define_insn \"tstsi\"\n   [(set (cc0)\n \t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n@@ -69,7 +82,7 @@\n \n (define_insn \"tstdf\"\n   [(set (cc0)\n-\t(match_operand:DF 0 \"general_operand\" \"fmF\"))]\n+\t(match_operand:DF 0 \"general_operand\" \"lmF\"))]\n   \"TARGET_32081\"\n   \"*\n { cc_status.flags |= CC_REVERSED;\n@@ -85,10 +98,11 @@\n   operands[1] = CONST0_RTX (SFmode);\n   return \\\"cmpf %1,%0\\\"; }\")\n \n+;; See note 1\n (define_insn \"cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"rmn\")\n-\t\t (match_operand:SI 1 \"general_operand\" \"rmn\")))]\n+\t(compare (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t (match_operand:SI 1 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n {\n@@ -113,7 +127,7 @@\n \n (define_insn \"cmphi\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"g\")\n+\t(compare (match_operand:HI 0 \"general_operand\" \"g\")\n \t\t (match_operand:HI 1 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n@@ -145,7 +159,7 @@\n \n (define_insn \"cmpqi\"\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"g\")\n+\t(compare (match_operand:QI 0 \"general_operand\" \"g\")\n \t\t (match_operand:QI 1 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n@@ -177,8 +191,8 @@\n \n (define_insn \"cmpdf\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"fmF\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+\t(compare (match_operand:DF 0 \"general_operand\" \"lmF\")\n+\t\t (match_operand:DF 1 \"general_operand\" \"lmF\")))]\n   \"TARGET_32081\"\n   \"cmpl %0,%1\")\n \n@@ -189,9 +203,14 @@\n   \"TARGET_32081\"\n   \"cmpf %0,%1\")\n \f\n+;; movdf and movsf copy between general and floating registers using\n+;; the stack. In principle, we could get better code not allowing\n+;; that case in the constraints and defining SECONDARY_MEMORY_NEEDED\n+;; in practice, though the stack slots used are not available for\n+;; optimization.\n (define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fg<\")\n-\t(match_operand:DF 1 \"general_operand\" \"fFg\"))]\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lg<\")\n+\t(match_operand:DF 1 \"general_operand\" \"lFg\"))]\n   \"\"\n   \"*\n {\n@@ -231,7 +250,7 @@\n {\n   if (FP_REG_P (operands[0]))\n     {\n-      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 8)\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < F0_REGNUM)\n \treturn \\\"movd %1,tos\\;movf tos,%0\\\";\n       else\n \treturn \\\"movf %1,%0\\\";\n@@ -308,8 +327,8 @@\n \n ;; This special case must precede movsi.\n (define_insn \"\"\n-  [(set (reg:SI 17)\n-\t(match_operand:SI 0 \"general_operand\" \"rmn\"))]\n+  [(set (reg:SI 25)\n+\t(match_operand:SI 0 \"general_operand\" \"g\"))]\n   \"\"\n   \"lprd sp,%0\")\n \n@@ -323,7 +342,7 @@\n \n   if (FP_REG_P (operands[0]))\n     {\n-      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 8)\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < F0_REGNUM)\n \treturn \\\"movd %1,tos\\;movf tos,%0\\\";\n       else\n \treturn \\\"movf %1,%0\\\";\n@@ -347,28 +366,28 @@\n \t{\n \t  if (i <= 7 && i >= -8)\n \t    return \\\"movqd %1,%0\\\";\n-\t  if (i <= 0x1fffffff && i >= -0x20000000)\n+\t  if (NS32K_DISPLACEMENT_P (i))\n #if defined (GNX_V3) || defined (UTEK_ASM)\n \t    return \\\"addr %c1,%0\\\";\n #else\n \t    return \\\"addr @%c1,%0\\\";\n #endif\n-\t  return \\\"movd %$%1,%0\\\";\n+\t  return \\\"movd %1,%0\\\";\n \t}\n       else\n-        return output_move_dconst(i, \\\"%$%1,%0\\\");\n+        return output_move_dconst(i, \\\"%1,%0\\\");\n     }\n   else if (GET_CODE (operands[1]) == CONST && ! flag_pic)\n     {\n \t/* Must contain symbols so we don`t know how big it is. In\n \t * that case addr might lead to overflow. For PIC symbolic\n \t * address loads always have to be done with addr.\n \t */\n-\treturn \\\"movd %$%1,%0\\\";\n+\treturn \\\"movd %1,%0\\\";\n     }\n   else if (GET_CODE (operands[1]) == REG)\n     {\n-      if (REGNO (operands[1]) < 16)\n+      if (REGNO (operands[1]) < F0_REGNUM)\n         return \\\"movd %1,%0\\\";\n       else if (REGNO (operands[1]) == FRAME_POINTER_REGNUM)\n \t{\n@@ -426,7 +445,7 @@\n     }\n   else if (FP_REG_P (operands[0]))\n     {\n-      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 8)\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < F0_REGNUM)\n \treturn \\\"movwf %1,tos\\;movf tos,%0\\\";\n       else\n \treturn \\\"movwf %1,%0\\\";\n@@ -472,7 +491,7 @@\n     }\n   else if (FP_REG_P (operands[0]))\n     {\n-      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 8)\n+      if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < F0_REGNUM)\n \treturn \\\"movbf %1,tos\\;movf tos,%0\\\";\n       else\n \treturn \\\"movbf %1,%0\\\";\n@@ -499,89 +518,77 @@\n   return \\\"movb %1,%0\\\";\n }\")\n \f\n-;; This is here to accept 4 arguments and pass the first 3 along\n-;; to the movstrsi1 pattern that really does the work.\n+;; Block moves\n+;; Argument 0 is the destination\n+;; Argument 1 is the source\n+;; Argument 2 is the length\n+;; Argument 3 is the alignment\n+;;\n+;; Strategy: Use define_expand to\n+;; either emit insns directly if it can be done simply or\n+;; emit rtl to match movstrsi1 which has extra scratch registers\n+;; which can be used to generate more complex code.\n+\n (define_expand \"movstrsi\"\n-  [(set (match_operand:BLK 0 \"general_operand\" \"=g\")\n-\t(match_operand:BLK 1 \"general_operand\" \"g\"))\n-   (use (match_operand:SI 2 \"general_operand\" \"rmn\"))\n-   (match_operand 3 \"\" \"\")]\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"general_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n   \"\"\n   \"\n-  emit_insn (gen_movstrsi1 (operands[0], operands[1], operands[2]));\n-  DONE;\n-\")\n+{\n+  if (operands[0])\t\t/* avoid unused code messages */\n+    {\n+      expand_block_move (operands);\n+      DONE;\n+    }\n+}\")\n+\n+;; Special Registers:\n+;; r0  count\n+;; r1  from \n+;; r2  to   \n+;; r3  match\n+\n \n-;; The definition of this insn does not really explain what it does,\n-;; but it should suffice\n-;; that anything generated as this insn will be recognized as one\n-;; and that it won't successfully combine with anything.\n (define_insn \"movstrsi1\"\n-  [(set (match_operand:BLK 0 \"general_operand\" \"=g\")\n-\t(match_operand:BLK 1 \"general_operand\" \"g\"))\n-   (use (match_operand:SI 2 \"general_operand\" \"rmn\"))\n-   (clobber (reg:SI 0))\n-   (clobber (reg:SI 1))\n-   (clobber (reg:SI 2))]\n+  [(set (mem:BLK (reg:SI 2))\n+\t(mem:BLK (reg:SI 1)))\n+   (use (reg:SI 0))\n+   (set (reg:SI 2) (plus:SI (reg:SI 2) (mult:SI (reg:SI 0) (match_operand:SI 0 \"const_int_operand\" \"\"))))\n+   (set (reg:SI 1) (plus:SI (reg:SI 1) (mult:SI (reg:SI 0) (match_dup 0))))\n+   (set (reg:SI 0) (const_int 0))]\n   \"\"\n   \"*\n-{\n-  if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-    abort ();\n-  operands[0] = XEXP (operands[0], 0);\n-  operands[1] = XEXP (operands[1], 0);\n-  if (GET_CODE (operands[0]) == MEM)\n-    if (GET_CODE (operands[1]) == MEM)\n-      output_asm_insn (\\\"movd %0,r2\\;movd %1,r1\\\", operands);\n-    else\n-      output_asm_insn (\\\"movd %0,r2\\;addr %a1,r1\\\", operands);\n-  else if (GET_CODE (operands[1]) == MEM)\n-    output_asm_insn (\\\"addr %a0,r2\\;movd %1,r1\\\", operands);\n-  else\n-    output_asm_insn (\\\"addr %a0,r2\\;addr %a1,r1\\\", operands);\n+  {\n+     int align = INTVAL(operands[0]);\n+     if (align == 4)\n+       return \\\"movsd\\\";\n+     else\n+       return \\\"movsb\\\";\n+  }\")\n+\n+(define_insn \"movstrsi2\"\n+  [(set (mem:BLK (match_operand:SI 0 \"address_operand\" \"g\"))\n+\t(mem:BLK (match_operand:SI 1 \"address_operand\" \"g\")))\n+   (use (match_operand 2 \"immediate_operand\" \"i\"))]\n+  \"\"\n+  \"movmd %a1,%a0,%2\")\n \n-#ifdef UTEK_ASM\n-  if (GET_CODE (operands[2]) == CONST_INT && (INTVAL (operands[2]) & 0x3) == 0)\n-    {\n-      operands[2] = GEN_INT (INTVAL (operands[2]) >> 2);\n-      if ((unsigned) INTVAL (operands[2]) <= 7)\n-\treturn \\\"movqd %2,r0\\;movsd $0\\\";\n-      else \n-\treturn \\\"movd %2,r0\\;movsd $0\\\";\n-    }\n-  else\n-    {\n-      return \\\"movd %2,r0\\;movsb $0\\\";\n-    }\n-#else\n-  if (GET_CODE (operands[2]) == CONST_INT && (INTVAL (operands[2]) & 0x3) == 0)\n-    {\n-      operands[2] = GEN_INT (INTVAL (operands[2]) >> 2);\n-      if ((unsigned) INTVAL (operands[2]) <= 7)\n-\treturn \\\"movqd %2,r0\\;movsd\\\";\n-      else \n-\treturn \\\"movd %2,r0\\;movsd\\\";\n-    }\n-  else\n-    {\n-      return \\\"movd %2,r0\\;movsb\\\";\n-    }\n-#endif\n-}\")\n \f\n ;; Extension and truncation insns.\n ;; Those for integer source operand\n ;; are ordered widest source type first.\n \n (define_insn \"truncsiqi2\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n-\t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"rmn\")))]\n+\t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n   \"movb %1,%0\")\n \n (define_insn \"truncsihi2\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n-\t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"rmn\")))]\n+\t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n   \"movw %1,%0\")\n \n@@ -610,14 +617,14 @@\n   \"movxbd %1,%0\")\n \n (define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm<\")\n \t(float_extend:DF (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n   \"TARGET_32081\"\n   \"movfl %1,%0\")\n \n (define_insn \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=fm<\")\n-\t(float_truncate:SF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+\t(float_truncate:SF (match_operand:DF 1 \"general_operand\" \"lmF\")))]\n   \"TARGET_32081\"\n   \"movlf %1,%0\")\n \n@@ -657,7 +664,7 @@\n   \"movdf %1,%0\")\n \n (define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm<\")\n \t(float:DF (match_operand:SI 1 \"general_operand\" \"rm\")))]\n   \"TARGET_32081\"\n   \"movdl %1,%0\")\n@@ -669,7 +676,7 @@\n   \"movwf %1,%0\")\n \n (define_insn \"floathidf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm<\")\n \t(float:DF (match_operand:HI 1 \"general_operand\" \"rm\")))]\n   \"TARGET_32081\"\n   \"movwl %1,%0\")\n@@ -683,7 +690,7 @@\n ; Some assemblers warn that this insn doesn't work.\n ; Maybe they know something we don't.\n ;(define_insn \"floatqidf2\"\n-;  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n+;  [(set (match_operand:DF 0 \"general_operand\" \"=lm<\")\n ;\t(float:DF (match_operand:QI 1 \"general_operand\" \"rm\")))]\n ;  \"TARGET_32081\"\n ;  \"movbl %1,%0\")\n@@ -711,19 +718,19 @@\n \n (define_insn \"fixdfqi2\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n-\t(fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+\t(fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"lm\"))))]\n   \"TARGET_32081\"\n   \"trunclb %1,%0\")\n \n (define_insn \"fixdfhi2\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n-\t(fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+\t(fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"lm\"))))]\n   \"TARGET_32081\"\n   \"trunclw %1,%0\")\n \n (define_insn \"fixdfsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"lm\"))))]\n   \"TARGET_32081\"\n   \"truncld %1,%0\")\n \n@@ -749,19 +756,19 @@\n \n (define_insn \"fixunsdfqi2\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n-\t(unsigned_fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+\t(unsigned_fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"lm\"))))]\n   \"TARGET_32081\"\n   \"trunclb %1,%0\")\n \n (define_insn \"fixunsdfhi2\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n-\t(unsigned_fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+\t(unsigned_fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"lm\"))))]\n   \"TARGET_32081\"\n   \"trunclw %1,%0\")\n \n (define_insn \"fixunsdfsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n-\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"fm\"))))]\n+\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"lm\"))))]\n   \"TARGET_32081\"\n   \"truncld %1,%0\")\n \n@@ -786,28 +793,69 @@\n \n (define_insn \"fix_truncdfqi2\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g<\")\n-\t(fix:QI (match_operand:DF 1 \"general_operand\" \"fm\")))]\n+\t(fix:QI (match_operand:DF 1 \"general_operand\" \"lm\")))]\n   \"TARGET_32081\"\n   \"trunclb %1,%0\")\n \n (define_insn \"fix_truncdfhi2\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g<\")\n-\t(fix:HI (match_operand:DF 1 \"general_operand\" \"fm\")))]\n+\t(fix:HI (match_operand:DF 1 \"general_operand\" \"lm\")))]\n   \"TARGET_32081\"\n   \"trunclw %1,%0\")\n \n (define_insn \"fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n-\t(fix:SI (match_operand:DF 1 \"general_operand\" \"fm\")))]\n+\t(fix:SI (match_operand:DF 1 \"general_operand\" \"lm\")))]\n   \"TARGET_32081\"\n   \"truncld %1,%0\")\n \f\n+;; Multiply-add instructions\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=v,v\")\n+\t(plus:DF (mult:DF (match_operand:DF 1 \"general_operand\" \"%lmF,0\")\n+\t\t          (match_operand:DF 2 \"general_operand\" \"lmF,lmF\"))\n+                 (match_operand:DF 3 \"general_operand\" \"0,lmF\")))]\n+  \"TARGET_MULT_ADD\"\n+  \"@\n+   dotl %1,%2\n+   polyl %2,%3\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=u,u\")\n+\t(plus:SF (mult:SF (match_operand:SF 1 \"general_operand\" \"%fmF,0\")\n+\t\t          (match_operand:SF 2 \"general_operand\" \"fmF,fmF\"))\n+                 (match_operand:SF 3 \"general_operand\" \"0,fmF\")))]\n+  \"TARGET_MULT_ADD\"\n+  \"@\n+   dotf %1,%2\n+   polyf %2,%3\")\n+\n+\n+;; Multiply-sub instructions\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=v\")\n+\t(minus:DF (mult:DF (match_operand:DF 1 \"general_operand\" \"%lmF\")\n+\t\t          (match_operand:DF 2 \"general_operand\" \"lmF\"))\n+                 (match_operand:DF 3 \"general_operand\" \"0\")))]\n+  \"TARGET_MULT_ADD\"\n+  \"@\n+   negl %0,%0\\;dotl %1,%2\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=u\")\n+\t(minus:SF (mult:SF (match_operand:SF 1 \"general_operand\" \"%fmF\")\n+\t\t          (match_operand:SF 2 \"general_operand\" \"fmF\"))\n+                 (match_operand:SF 3 \"general_operand\" \"0\")))]\n+  \"TARGET_MULT_ADD\"\n+  \"@\n+   negf %0,%0\\;dotf %1,%2\")\n+\n ;;- All kinds of add instructions.\n \n (define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm\")\n \t(plus:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"fmF\")))]\n+\t\t (match_operand:DF 2 \"general_operand\" \"lmF\")))]\n   \"TARGET_32081\"\n   \"addl %2,%0\")\n \n@@ -820,8 +868,8 @@\n   \"addf %2,%0\")\n \n (define_insn \"\"\n-  [(set (reg:SI 17)\n-\t(plus:SI (reg:SI 17)\n+  [(set (reg:SI 25)\n+\t(plus:SI (reg:SI 25)\n \t\t (match_operand:SI 0 \"immediate_operand\" \"i\")))]\n   \"GET_CODE (operands[0]) == CONST_INT\"\n   \"*\n@@ -837,23 +885,23 @@\n   if (! TARGET_32532)\n     {\n       if (INTVAL (operands[0]) < 64 && INTVAL (operands[0]) > -64)\n-        return \\\"adjspb %$%n0\\\";\n+        return \\\"adjspb %n0\\\";\n       else if (INTVAL (operands[0]) < 8192 && INTVAL (operands[0]) >= -8192)\n-        return \\\"adjspw %$%n0\\\";\n+        return \\\"adjspw %n0\\\";\n     }\n-  return \\\"adjspd %$%n0\\\";\n+  return \\\"adjspd %n0\\\";\n }\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n-\t(plus:SI (reg:SI 16)\n+\t(plus:SI (reg:SI 24)\n \t\t (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n   \"GET_CODE (operands[1]) == CONST_INT\"\n   \"addr %c1(fp),%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n-\t(plus:SI (reg:SI 17)\n+\t(plus:SI (reg:SI 25)\n \t\t (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n   \"GET_CODE (operands[1]) == CONST_INT\"\n   \"addr %c1(sp),%0\")\n@@ -882,14 +930,14 @@\n \t    {\n \t      i = INTVAL (xops[3]);\n \t      if (i <= 7 && i >= -8)\n-                output_asm_insn (\\\"addqd %$%3,%1\\\", xops);\n+                output_asm_insn (\\\"addqd %3,%1\\\", xops);\n \t      else\n-                output_asm_insn (\\\"addd %$%3,%1\\\", xops);\n+                output_asm_insn (\\\"addd %3,%1\\\", xops);\n \t    }\n \t  else\n \t    {\n-              output_asm_insn (\\\"addqd %$%2,%0\\\", xops);\n-              output_asm_insn (\\\"addcd %$%3,%1\\\", xops);\n+              output_asm_insn (\\\"addqd %2,%0\\\", xops);\n+              output_asm_insn (\\\"addcd %3,%1\\\", xops);\n \t    }\n \t  return \\\"\\\";\n \t}\n@@ -899,29 +947,40 @@\n   return \\\"\\\";\n }\")\n \n+;; See Note 1\n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g,=g&<\")\n \t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,r\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmn,n\")))]\n+\t\t (match_operand:SI 2 \"general_operand\" \"g,i\")))]\n   \"\"\n   \"*\n {\n   if (which_alternative == 1)\n     {\n-      int i = INTVAL (operands[2]);\n-      if (NS32K_DISPLACEMENT_P (i))\n-\treturn \\\"addr %c2(%1),%0\\\";\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+        {\n+\t  int i = INTVAL (operands[2]);\n+\t  if (NS32K_DISPLACEMENT_P (i))\n+\t    return \\\"addr %c2(%1),%0\\\";\n+\t  else\n+\t    return \\\"movd %1,%0\\;addd %2,%0\\\";\n+        }\n       else\n-\treturn \\\"movd %1,%0\\;addd %2,%0\\\";\n+        {\n+          if (flag_pic) \n+            return \\\"addr %a2[%1:b],%0\\\";\n+\t  else\n+\t    return \\\"addr %c2(%1),%0\\\";\n+        }\n     }\n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  else if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int i = INTVAL (operands[2]);\n \n       if (i <= 7 && i >= -8)\n \treturn \\\"addqd %2,%0\\\";\n       else if (! TARGET_32532 && GET_CODE (operands[0]) == REG\n-\t       && i <= 0x1fffffff && i >= -0x20000000)\n+\t       && NS32K_DISPLACEMENT_P (i))\n \treturn \\\"addr %c2(%0),%0\\\";\n     }\n   return \\\"addd %2,%0\\\";\n@@ -986,9 +1045,9 @@\n ;;- All kinds of subtract instructions.\n \n (define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm\")\n \t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:DF 2 \"general_operand\" \"fmF\")))]\n+\t\t  (match_operand:DF 2 \"general_operand\" \"lmF\")))]\n   \"TARGET_32081\"\n   \"subl %2,%0\")\n \n@@ -1000,16 +1059,16 @@\n   \"subf %2,%0\")\n \n (define_insn \"\"\n-  [(set (reg:SI 17)\n-\t(minus:SI (reg:SI 17)\n+  [(set (reg:SI 25)\n+\t(minus:SI (reg:SI 25)\n \t\t  (match_operand:SI 0 \"immediate_operand\" \"i\")))]\n   \"GET_CODE (operands[0]) == CONST_INT\"\n   \"*\n {\n   if (! TARGET_32532 && GET_CODE(operands[0]) == CONST_INT \n       && INTVAL(operands[0]) < 64 && INTVAL(operands[0]) > -64)\n-    return \\\"adjspb %$%0\\\";\n-  return \\\"adjspd %$%0\\\";\n+    return \\\"adjspb %0\\\";\n+  return \\\"adjspd %0\\\";\n }\")\n \n (define_insn \"subdi3\"\n@@ -1036,14 +1095,14 @@\n \t    {\n \t      i = INTVAL (xops[3]);\n \t      if (i <= 8 && i >= -7)\n-                output_asm_insn (\\\"addqd %$%n3,%1\\\", xops);\n+                output_asm_insn (\\\"addqd %n3,%1\\\", xops);\n \t      else\n-                output_asm_insn (\\\"subd %$%3,%1\\\", xops);\n+                output_asm_insn (\\\"subd %3,%1\\\", xops);\n \t    }\n \t  else\n \t    {\n-              output_asm_insn (\\\"addqd %$%n2,%0\\\", xops);\n-              output_asm_insn (\\\"subcd %$%3,%1\\\", xops);\n+              output_asm_insn (\\\"addqd %n2,%0\\\", xops);\n+              output_asm_insn (\\\"subcd %3,%1\\\", xops);\n \t    }\n \t  return \\\"\\\";\n \t}\n@@ -1056,15 +1115,15 @@\n (define_insn \"subsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t  (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n { if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int i = INTVAL (operands[2]);\n \n       if (i <= 8 && i >= -7)\n-        return \\\"addqd %$%n2,%0\\\";\n+        return \\\"addqd %n2,%0\\\";\n     }\n   return \\\"subd %2,%0\\\";\n }\")\n@@ -1080,7 +1139,7 @@\n       int i = INTVAL (operands[2]);\n \n       if (i <= 8 && i >= -7)\n-        return \\\"addqw %$%n2,%0\\\";\n+        return \\\"addqw %n2,%0\\\";\n     }\n   return \\\"subw %2,%0\\\";\n }\")\n@@ -1094,7 +1153,7 @@\n {\n   if (GET_CODE (operands[1]) == CONST_INT\n       && INTVAL (operands[1]) >-8 && INTVAL(operands[1]) < 9)\n-    return \\\"addqw %$%n2,%0\\\";\n+    return \\\"addqw %n2,%0\\\";\n   return \\\"subw %2,%0\\\";\n }\")\n \n@@ -1109,7 +1168,7 @@\n       int i = INTVAL (operands[2]);\n \n       if (i <= 8 && i >= -7)\n-\treturn \\\"addqb %$%n2,%0\\\";\n+\treturn \\\"addqb %n2,%0\\\";\n     }\n   return \\\"subb %2,%0\\\";\n }\")\n@@ -1123,16 +1182,16 @@\n {\n   if (GET_CODE (operands[1]) == CONST_INT\n       && INTVAL (operands[1]) >-8 && INTVAL(operands[1]) < 9)\n-    return \\\"addqb %$%n2,%0\\\";\n+    return \\\"addqb %n2,%0\\\";\n   return \\\"subb %2,%0\\\";\n }\")\n \f\n ;;- Multiply instructions.\n \n (define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm\")\n \t(mult:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"fmF\")))]\n+\t\t (match_operand:DF 2 \"general_operand\" \"lmF\")))]\n   \"TARGET_32081\"\n   \"mull %2,%0\")\n \n@@ -1143,10 +1202,11 @@\n   \"TARGET_32081\"\n   \"mulf %2,%0\")\n \n+;; See note 1\n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"muld %2,%0\")\n \n@@ -1169,16 +1229,195 @@\n \t(mult:DI (zero_extend:DI\n \t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"0\"))\n \t\t (zero_extend:DI\n-\t\t  (match_operand:SI 2 \"nonimmediate_operand\" \"rmn\"))))]\n+\t\t  (match_operand:SI 2 \"nonimmediate_operand\" \"g\"))))]\n   \"\"\n   \"meid %2,%0\")\n \f\n+;; divmod insns: We can only do the unsigned case.\n+(define_expand \"udivmodsi4\"\n+  [(parallel\n+  [(set (match_operand:SI 0 \"reg_or_mem_operand\" \"\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"\")))\n+   (set (match_operand:SI 3 \"reg_or_mem_operand\" \"\")\n+\t(umod:SI (match_dup 1) (match_dup 2)))])]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx(DImode);\n+  rtx insn, first, last;\n+  first = emit_move_insn(gen_lowpart(SImode, temp), operands[1]);\n+  emit_move_insn(gen_highpart(SImode, temp), const0_rtx);\n+  emit_insn(gen_udivmoddisi4_internal(temp, temp, operands[2]));\n+  last = emit_move_insn(temp, temp);\n+  {\n+    rtx divdi, moddi, divsi, modsi;\n+    divsi = gen_rtx (UDIV, SImode, operands[1], operands[2]);\n+    modsi = gen_rtx (UMOD, SImode, operands[1], operands[2]);\n+    divdi = gen_rtx (ZERO_EXTEND, DImode, divsi);\n+    moddi = gen_rtx (ZERO_EXTEND, DImode, modsi);\n+    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+\t\t\t         REG_NOTES (first));\n+    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n+                                gen_rtx (EXPR_LIST, REG_EQUAL,\n+                       gen_rtx (IOR, DImode, moddi,\n+                               gen_rtx (ASHIFT, DImode, divdi, GEN_INT(32))),\n+                       REG_NOTES (last)));\n+  }\n+\n+  insn = emit_move_insn(operands[0], gen_highpart(SImode, temp));\n+  insn = emit_move_insn(operands[3], gen_lowpart(SImode, temp));\n+  DONE;\n+}\")\n+\n+;; If we try and describe what this does, we have to zero-expand an\n+;; operand, which prevents it being a constant (VOIDmode) (see udivmoddisi4\n+;; below. This udivmoddisi4_internal never matches anything and is only\n+;; ever used when explicitly emitted by a define_expand.\n+(define_insn \"udivmoddisi4_internal\"\n+  [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"=rm\")\n+        (unspec:SI [(match_operand:DI 1 \"reg_or_mem_operand\" \"0\")\n+                    (match_operand:SI 2 \"general_operand\" \"g\")] 0))]\n+  \"\"\n+  \"deid %2,%0\")\n+\n+;; Retain this insn which *does* have a pattern indicating what it does,\n+;; just in case the compiler is smart enough to recognize a substitution.\n+(define_insn \"udivmoddisi4\"\n+  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=rm\") 1)\n+\t(truncate:SI (udiv:DI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\")\n+\t\t (zero_extend:DI (match_operand:SI 2 \"nonimmediate_operand\" \"g\")))))\n+   (set (subreg:SI (match_operand:DI 3 \"register_operand\" \"=0\") 0)\n+\t(truncate:SI (umod:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))]\n+  \"\"\n+  \"deid %2,%0\")\n+\n+;; Part word variants. These seem to never be used at the moment (gcc\n+;; 2.7.2.2). The code generation prefers to zero extend hi's and qi's\n+;; and use signed div and mod. Keep these insns incase that changes.\n+;; divmod should have an advantage when both div and mod are needed. However,\n+;; divmod uses two registers, so maybe the compiler knows best.\n+\n+(define_expand \"udivmodhi4\"\n+  [(parallel\n+  [(set (match_operand:HI 0 \"reg_or_mem_operand\" \"\")\n+\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"\")))\n+   (set (match_operand:HI 3 \"reg_or_mem_operand\" \"\")\n+\t(umod:HI (match_dup 1) (match_dup 2)))])]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx(DImode);\n+  rtx insn, first, last;\n+  first = emit_move_insn(gen_lowpart(HImode, temp), operands[1]);\n+  emit_move_insn(gen_highpart (HImode, temp), const0_rtx);\n+  operands[2] = force_reg(HImode, operands[2]);\n+  emit_insn(gen_udivmoddihi4_internal(temp, temp, operands[2]));\n+  last = emit_move_insn(temp, temp);\n+  {\n+    rtx divdi, moddi, divhi, modhi;\n+    divhi = gen_rtx (UDIV, HImode, operands[1], operands[2]);\n+    modhi = gen_rtx (UMOD, HImode, operands[1], operands[2]);\n+    divdi = gen_rtx (ZERO_EXTEND, DImode, divhi);\n+    moddi = gen_rtx (ZERO_EXTEND, DImode, modhi);\n+    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+\t\t\t         REG_NOTES (first));\n+    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n+                                gen_rtx (EXPR_LIST, REG_EQUAL,\n+                       gen_rtx(IOR, DImode, moddi,\n+                               gen_rtx(ASHIFT, DImode, divdi, GEN_INT(32))),\n+                       REG_NOTES (last)));\n+  }\n+\n+  insn = emit_move_insn(operands[0], gen_highpart(HImode, temp));\n+  insn = emit_move_insn(operands[3], gen_lowpart(HImode, temp));\n+  DONE;\n+}\")\n+\n+;; deiw wants two hi's in seperate registers or else they can be adjacent\n+;; in memory. DI mode will ensure two registers are available, but if we\n+;; want to allow memory as an operand we would need SI mode. There is no\n+;; way to do this, so just restrict operand 0 and 1 to be in registers.\n+(define_insn \"udivmoddihi4_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (unspec:HI [(match_operand:DI 1 \"register_operand\" \"0\")\n+                    (match_operand:HI 2 \"general_operand\" \"g\")] 0))]\n+  \"\"\n+  \"deiw %2,%0\")\n+\n+(define_insn \"udivmoddihi4\"\n+  [(set (subreg:HI (match_operand:DI 0 \"register_operand\" \"=r\") 1)\n+\t(truncate:HI (udiv:DI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\")\n+\t\t (zero_extend:DI (match_operand:HI 2 \"nonimmediate_operand\" \"g\")))))\n+   (set (subreg:HI (match_operand:DI 3 \"register_operand\" \"=0\") 0)\n+\t(truncate:HI (umod:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))]\n+  \"\"\n+  \"deiw %2,%0\")\n+\n+(define_expand \"udivmodqi4\"\n+  [(parallel\n+  [(set (match_operand:QI 0 \"reg_or_mem_operand\" \"\")\n+\t(udiv:QI (match_operand:QI 1 \"general_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"\")))\n+   (set (match_operand:QI 3 \"reg_or_mem_operand\" \"\")\n+\t(umod:QI (match_dup 1) (match_dup 2)))])]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx(DImode);\n+  rtx insn, first, last;\n+  first = emit_move_insn(gen_lowpart(QImode, temp), operands[1]);\n+  emit_move_insn(gen_highpart(QImode, temp), const0_rtx);\n+  operands[2] = force_reg(QImode, operands[2]);\n+  emit_insn(gen_udivmoddiqi4_internal(temp, temp, operands[2]));\n+  last = emit_move_insn(temp, temp);\n+  {\n+    rtx divdi, moddi, divqi, modqi;\n+    divqi = gen_rtx (UDIV, QImode, operands[1], operands[2]);\n+    modqi = gen_rtx (UMOD, QImode, operands[1], operands[2]);\n+    divdi = gen_rtx (ZERO_EXTEND, DImode, divqi);\n+    moddi = gen_rtx (ZERO_EXTEND, DImode, modqi);\n+    REG_NOTES (first) = gen_rtx (INSN_LIST, REG_LIBCALL, last,\n+\t\t\t         REG_NOTES (first));\n+    REG_NOTES (last) = gen_rtx (INSN_LIST, REG_RETVAL, first,\n+                                gen_rtx (EXPR_LIST, REG_EQUAL,\n+                       gen_rtx(IOR, DImode, moddi,\n+                               gen_rtx(ASHIFT, DImode, divdi, GEN_INT(32))),\n+                       REG_NOTES (last)));\n+  }\n+\n+  insn = emit_move_insn(operands[0], gen_highpart(QImode, temp));\n+  insn = emit_move_insn(operands[3], gen_lowpart(QImode, temp));\n+  DONE;\n+}\")\n+\n+;; deib wants two qi's in seperate registers or else they can be adjacent\n+;; in memory. DI mode will ensure two registers are available, but if we\n+;; want to allow memory as an operand we would need HI mode. There is no\n+;; way to do this, so just restrict operand 0 and 1 to be in registers.\n+(define_insn \"udivmoddiqi4_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (unspec:QI [(match_operand:DI 1 \"reg_or_mem_operand\" \"0\")\n+                    (match_operand:QI 2 \"general_operand\" \"g\")] 0))]\n+  \"\"\n+  \"deib %2,%0\")\n+\n+(define_insn \"udivmoddiqi4\"\n+  [(set (subreg:QI (match_operand:DI 0 \"register_operand\" \"=r\") 1)\n+\t(truncate:QI (udiv:DI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\")\n+\t\t (zero_extend:DI (match_operand:QI 2 \"nonimmediate_operand\" \"g\")))))\n+   (set (subreg:QI (match_operand:DI 3 \"register_operand\" \"=0\") 0)\n+\t(truncate:QI (umod:DI (match_dup 1) (zero_extend:DI (match_dup 2)))))]\n+  \"\"\n+  \"deib %2,%0\")\n+\f\n ;;- Divide instructions.\n \n (define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm\")\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm\")\n \t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t(match_operand:DF 2 \"general_operand\" \"fmF\")))]\n+\t\t(match_operand:DF 2 \"general_operand\" \"lmF\")))]\n   \"TARGET_32081\"\n   \"divl %2,%0\")\n \n@@ -1189,10 +1428,11 @@\n   \"TARGET_32081\"\n   \"divf %2,%0\")\n \n+;; See note 1\n (define_insn \"divsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"quod %2,%0\")\n \n@@ -1209,46 +1449,14 @@\n \t\t(match_operand:QI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"quob %2,%0\")\n-\n-(define_insn \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(udiv:SI (subreg:SI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-  return \\\"deid %2,%0\\;movd %1,%0\\\";\n-}\")\n-\n-(define_insn \"udivhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(udiv:HI (subreg:HI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n-\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[1] = gen_rtx (REG, HImode, REGNO (operands[0]) + 1);\n-  return \\\"deiw %2,%0\\;movw %1,%0\\\";\n-}\")\n-\n-(define_insn \"udivqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(udiv:QI (subreg:QI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n-\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[1] = gen_rtx (REG, QImode, REGNO (operands[0]) + 1);\n-  return \\\"deib %2,%0\\;movb %1,%0\\\";\n-}\")\n-\n+\f\n ;; Remainder instructions.\n \n+;; See note 1\n (define_insn \"modsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(mod:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"remd %2,%0\")\n \n@@ -1266,43 +1474,14 @@\n   \"\"\n   \"remb %2,%0\")\n \n-(define_insn \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(umod:SI (subreg:SI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n-  \"\"\n-  \"deid %2,%0\")\n-\n-(define_insn \"umodhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(umod:HI (subreg:HI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n-\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"deiw %2,%0\")\n-\n-(define_insn \"umodqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(umod:QI (subreg:QI (match_operand:DI 1 \"reg_or_mem_operand\" \"0\") 0)\n-\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"deib %2,%0\")\n-\n-; This isn't be usable in its current form.\n-;(define_insn \"udivmoddisi4\"\n-;  [(set (subreg:SI (match_operand:DI 0 \"general_operand\" \"=r\") 1)\n-;\t(udiv:SI (match_operand:DI 1 \"general_operand\" \"0\")\n-;\t\t (match_operand:SI 2 \"general_operand\" \"rmn\")))\n-;   (set (subreg:SI (match_dup 0) 0)\n-;\t(umod:SI (match_dup 1) (match_dup 2)))]\n-;  \"\"\n-;  \"deid %2,%0\")\n \f\n ;;- Logical Instructions: AND\n \n+;; See note 1\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(and:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n {\n@@ -1360,9 +1539,10 @@\n   \"\"\n   \"andb %2,%0\")\n \n+;; See note 1\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"rmn\"))\n+\t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"g\"))\n \t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n   \"\"\n   \"bicd %1,%0\")\n@@ -1383,10 +1563,11 @@\n \f\n ;;- Bit set instructions.\n \n+;; See note 1\n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n {\n@@ -1421,10 +1602,11 @@\n \n ;;- xor instructions.\n \n+;; See note 1\n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n {\n@@ -1458,8 +1640,8 @@\n   \"xorb %2,%0\")\n \f\n (define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n-\t(neg:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm<\")\n+\t(neg:DF (match_operand:DF 1 \"general_operand\" \"lmF\")))]\n   \"TARGET_32081\"\n   \"negl %1,%0\")\n \n@@ -1497,9 +1679,10 @@\n   return \\\"\\\"; \n }\")\n \n+;; See note 1\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n-\t(neg:SI (match_operand:SI 1 \"general_operand\" \"rmn\")))]\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n   \"\"\n   \"negd %1,%0\")\n \n@@ -1515,9 +1698,10 @@\n   \"\"\n   \"negb %1,%0\")\n \f\n+;; See note 1\n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n-\t(not:SI (match_operand:SI 1 \"general_operand\" \"rmn\")))]\n+\t(not:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n   \"\"\n   \"comd %1,%0\")\n \n@@ -1540,10 +1724,11 @@\n ;; than elsewhere.\n \n ;; alternative 0 never matches on the 32532\n+;; See note 1\n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g,g\")\n \t(ashift:SI (match_operand:SI 1 \"general_operand\" \"r,0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"I,rmn\")))]\n+\t\t   (match_operand:SI 2 \"general_operand\" \"I,g\")))]\n   \"\"\n   \"*\n { if (TARGET_32532)\n@@ -1555,7 +1740,7 @@\n (define_insn \"ashlhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n \t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t   (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n { if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1574,7 +1759,7 @@\n (define_insn \"ashlqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n \t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t   (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n { if (GET_CODE (operands[2]) == CONST_INT)\n@@ -1607,7 +1792,7 @@\n \t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"ashd %$%n2,%0\")\n+  \"ashd %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n@@ -1632,7 +1817,7 @@\n \t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"ashw %$%n2,%0\")\n+  \"ashw %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n@@ -1657,7 +1842,7 @@\n \t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"ashb %$%n2,%0\")\n+  \"ashb %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n@@ -1685,7 +1870,7 @@\n \t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"lshd %$%n2,%0\")\n+  \"lshd %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n@@ -1710,7 +1895,7 @@\n \t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"lshw %$%n2,%0\")\n+  \"lshw %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n@@ -1735,7 +1920,7 @@\n \t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"lshb %$%n2,%0\")\n+  \"lshb %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n@@ -1746,24 +1931,25 @@\n \n ;; Rotate instructions\n \n+;; See note 1\n (define_insn \"rotlsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n \t(rotate:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t   (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"rotd %2,%0\")\n \n (define_insn \"rotlhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n \t(rotate:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t   (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"rotw %2,%0\")\n \n (define_insn \"rotlqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n \t(rotate:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmn\")))]\n+\t\t   (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"rotb %2,%0\")\n \n@@ -1784,7 +1970,7 @@\n \t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"rotd %$%n2,%0\")\n+  \"rotd %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n@@ -1809,7 +1995,7 @@\n \t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"rotw %$%n2,%0\")\n+  \"rotw %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n@@ -1834,7 +2020,7 @@\n \t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n-  \"rotb %$%n2,%0\")\n+  \"rotb %n2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n@@ -1871,53 +2057,58 @@\n ;;; Index insns.  These are about the same speed as multiply-add counterparts.\n ;;; but slower then using power-of-2 shifts if we can use them\n ;\n+;;; See note 1\n ;(define_insn \"\"\n ;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-;\t(plus:SI (match_operand:SI 1 \"general_operand\" \"rmn\")\n+;\t(plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n ;\t\t (mult:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-;\t\t\t  (plus:SI (match_operand:SI 3 \"general_operand\" \"rmn\") (const_int 1)))))]\n+;\t\t\t  (plus:SI (match_operand:SI 3 \"general_operand\" \"g\") (const_int 1)))))]\n ;  \"GET_CODE (operands[3]) != CONST_INT || INTVAL (operands[3]) > 8\"\n ;  \"indexd %0,%3,%1\")\n ;\n ;(define_insn \"\"\n ;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n ;\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-;\t\t\t  (plus:SI (match_operand:SI 2 \"general_operand\" \"rmn\") (const_int 1)))\n-;\t\t (match_operand:SI 3 \"general_operand\" \"rmn\")))]\n+;\t\t\t  (plus:SI (match_operand:SI 2 \"general_operand\" \"g\") (const_int 1)))\n+;\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n ;  \"GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) > 8\"\n ;  \"indexd %0,%2,%3\")\n \f\n ;; Set, Clear, and Invert bit\n \n+;; See note 1\n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n \t\t\t (const_int 1)\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"rmn\"))\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"g\"))\n \t(const_int 1))]\n   \"\"\n   \"sbitd %1,%0\")\n \n+;; See note 1\n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"+g\")\n \t\t\t (const_int 1)\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"rmn\"))\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"g\"))\n \t(const_int 0))]\n   \"\"\n   \"cbitd %1,%0\")\n \n+;; See note 1\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"+g\")\n \t(xor:SI (ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 1 \"general_operand\" \"rmn\"))\n+\t\t\t   (match_operand:SI 1 \"general_operand\" \"g\"))\n \t\t(match_dup 0)))]\n   \"\"\n   \"ibitd %1,%0\")\n \n+;; See note 1\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n \t(xor:QI (subreg:QI\n \t\t (ashift:SI (const_int 1)\n-\t\t\t    (match_operand:QI 1 \"general_operand\" \"rmn\")) 0)\n+\t\t\t    (match_operand:QI 1 \"general_operand\" \"g\")) 0)\n \t\t(match_dup 0)))]\n   \"\"\n   \"ibitb %1,%0\")\n@@ -2308,7 +2499,7 @@\n        (minus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n   \"INTVAL (operands[1]) > -8 && INTVAL (operands[1]) <= 8\"\n-  \"acbd %$%n1,%0,%l2\")\n+  \"acbd %n1,%0,%l2\")\n \n (define_insn \"\"\n   [(set (pc)\n@@ -2450,14 +2641,15 @@\n   \"absf %1,%0\")\n \n (define_insn \"absdf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=fm<\")\n-\t(abs:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n+  [(set (match_operand:DF 0 \"general_operand\" \"=lm<\")\n+\t(abs:DF (match_operand:DF 1 \"general_operand\" \"lmF\")))]\n   \"TARGET_32081\"\n   \"absl %1,%0\")\n \n+;; See note 1\n (define_insn \"abssi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g<\")\n-\t(abs:SI (match_operand:SI 1 \"general_operand\" \"rmn\")))]\n+\t(abs:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n   \"\"\n   \"absd %1,%0\")\n \n@@ -2745,14 +2937,14 @@\n ;; Speed up stack adjust followed by a HI fixedpoint push.\n \n (define_peephole\n-  [(set (reg:SI 17) (plus:SI (reg:SI 17) (const_int -2)))\n+  [(set (reg:SI 25) (plus:SI (reg:SI 25) (const_int -2)))\n    (set (match_operand:HI 0 \"push_operand\" \"=m\")\n \t(match_operand:HI 1 \"general_operand\" \"g\"))]\n   \"! reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n-\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%$%1,tos\\\"),\n+\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%1,tos\\\"),\n \t\t\t operands);\n   else\n \toutput_asm_insn (\\\"movzwd %1,tos\\\", operands);\n@@ -2762,14 +2954,14 @@\n ;; Speed up stack adjust followed by a zero_extend:HI(QI) fixedpoint push.\n \n (define_peephole\n-  [(set (reg:SI 17) (plus:SI (reg:SI 17) (const_int -2)))\n+  [(set (reg:SI 25) (plus:SI (reg:SI 25) (const_int -2)))\n    (set (match_operand:HI 0 \"push_operand\" \"=m\")\n \t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"g\")))]\n   \"! reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n-\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%$%1,tos\\\"),\n+\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%1,tos\\\"),\n \t\t\t operands);\n   else\n \toutput_asm_insn (\\\"movzbd %1,tos\\\", operands);\n@@ -2779,14 +2971,14 @@\n ;; Speed up stack adjust followed by a sign_extend:HI(QI) fixedpoint push.\n \n (define_peephole\n-  [(set (reg:SI 17) (plus:SI (reg:SI 17) (const_int -2)))\n+  [(set (reg:SI 25) (plus:SI (reg:SI 25) (const_int -2)))\n    (set (match_operand:HI 0 \"push_operand\" \"=m\")\n \t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"g\")))]\n   \"! reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n-\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%$%1,tos\\\"),\n+\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%1,tos\\\"),\n \t\t\t operands);\n   else\n \toutput_asm_insn (\\\"movxbd %1,tos\\\", operands);\n@@ -2796,14 +2988,14 @@\n ;; Speed up stack adjust followed by a QI fixedpoint push.\n \n (define_peephole\n-  [(set (reg:SI 17) (plus:SI (reg:SI 17) (const_int -3)))\n+  [(set (reg:SI 25) (plus:SI (reg:SI 25) (const_int -3)))\n    (set (match_operand:QI 0 \"push_operand\" \"=m\")\n \t(match_operand:QI 1 \"general_operand\" \"g\"))]\n   \"! reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n-\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%$%1,tos\\\"),\n+\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%1,tos\\\"),\n \t\t\t operands);\n   else\n \toutput_asm_insn (\\\"movzbd %1,tos\\\", operands);\n@@ -2813,14 +3005,14 @@\n ;; Speed up stack adjust followed by a SI fixedpoint push.\n \n (define_peephole\n-  [(set (reg:SI 17) (plus:SI (reg:SI 17) (const_int 4)))\n+  [(set (reg:SI 25) (plus:SI (reg:SI 25) (const_int 4)))\n    (set (match_operand:SI 0 \"push_operand\" \"=m\")\n \t(match_operand:SI 1 \"general_operand\" \"g\"))]\n   \"! reg_mentioned_p (stack_pointer_rtx, operands[1])\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n-\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%$%1,0(sp)\\\"),\n+\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%1,0(sp)\\\"),\n \t\t\t operands);\n   else if (GET_CODE (operands[1]) != REG\n \t   && GET_CODE (operands[1]) != MEM\n@@ -2834,7 +3026,7 @@\n ;; Speed up stack adjust followed by two fullword fixedpoint pushes.\n \n (define_peephole\n-  [(set (reg:SI 17) (plus:SI (reg:SI 17) (const_int 8)))\n+  [(set (reg:SI 25) (plus:SI (reg:SI 25) (const_int 8)))\n    (set (match_operand:SI 0 \"push_operand\" \"=m\")\n \t(match_operand:SI 1 \"general_operand\" \"g\"))\n    (set (match_operand:SI 2 \"push_operand\" \"=m\")\n@@ -2844,7 +3036,7 @@\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n-\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%$%1,4(sp)\\\"),\n+\toutput_asm_insn (output_move_dconst (INTVAL (operands[1]), \\\"%1,4(sp)\\\"),\n \t\t\t operands);\n   else if (GET_CODE (operands[1]) != REG\n \t   && GET_CODE (operands[1]) != MEM\n@@ -2854,7 +3046,7 @@\n \toutput_asm_insn (\\\"movd %1,4(sp)\\\", operands);\n \n   if (GET_CODE (operands[3]) == CONST_INT)\n-\toutput_asm_insn (output_move_dconst (INTVAL (operands[3]), \\\"%$%3,0(sp)\\\"),\n+\toutput_asm_insn (output_move_dconst (INTVAL (operands[3]), \\\"%3,0(sp)\\\"),\n \t\t\t operands);\n   else if (GET_CODE (operands[3]) != REG\n \t   && GET_CODE (operands[3]) != MEM"}, {"sha": "5ce08e095a64a8fb972c48df583672944bbf0df2", "filename": "gcc/invoke.texi", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8357595779418585b4390bb66be518b32374965a/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8357595779418585b4390bb66be518b32374965a/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=8357595779418585b4390bb66be518b32374965a", "patch": "@@ -393,6 +393,11 @@ in the following sections.\n -mprolog-function -mno-prolog-function -mspace\n -mtda=@var{n} -msda=@var{n} -mzda=@var{n}\n -mv850 -mbig-switch\n+\n+@emph{NS32K Options}\n+-m32032 -m32332 -m32532 -m32081 -m32381 -mmult-add -mnomult-add\n+-msoft-float -mrtd -mnortd -mregparam -mnoregparam -msb -mnosb\n+-mbitfield -mnobitfield -mhimem -mnohimem\n @end smallexample\n \n @item Code Generation Options\n@@ -3055,6 +3060,7 @@ that macro, which enables you to change the defaults.\n * System V Options::\n * V850 Options::\n * ARC Options::\n+* NS32K Options::\n @end menu\n \n @node M680x0 Options\n@@ -5678,6 +5684,121 @@ by default.  This can be overridden with the @code{section} attribute.\n \n @end table\n \n+@node NS32K Options\n+@subsection NS32K Options\n+@cindex NS32K options\n+\n+These are the @samp{-m} options defined for the 32000 series.  The default\n+values for these options depends on which style of 32000 was selected when\n+the compiler was configured; the defaults for the most common choices are\n+given below.\n+\n+@table @code\n+@item -m32032\n+@itemx -m32032\n+Generate output for a 32032.  This is the default\n+when the compiler is configured for 32032 and 32016 based systems.\n+\n+@item -m32332\n+@itemx -m32332\n+Generate output for a 32332.  This is the default\n+when the compiler is configured for 32332-based systems.\n+\n+@item -m32532\n+@itemx -m32532\n+Generate output for a 32532.  This is the default\n+when the compiler is configured for 32532-based systems.\n+\n+@item -m32081\n+Generate output containing 32081 instructions for floating point.\n+This is the default for all systems.\n+\n+@item -m32381\n+Generate output containing 32381 instructions for floating point.  This\n+also implies @samp{-m32081}. The 32381 is only compatible with the 32332\n+and 32532 cpus. This is the default for the pc532-netbsd configuration.\n+\n+@item -mmulti-add\n+Try and generate multiply-add floating point instructions @code{polyF}\n+and @code{dotF}. This option is only available if the @samp{-m32381}\n+option is in effect. Using these instructions requires changes to to\n+register allocation which generally has a negative impact on\n+performance.  This option should only be enabled when compiling code\n+particularly likely to make heavy use of multiply-add instructions.\n+\n+@item -mnomulti-add\n+Do not try and generate multiply-add floating point instructions\n+@code{polyF} and @code{dotF}. This is the default on all platforms.\n+\n+@item -msoft-float\n+Generate output containing library calls for floating point.\n+@strong{Warning:} the requisite libraries may not be available.\n+\n+@item -mnobitfield\n+Do not use the bit-field instructions. On some machines it is faster to\n+use shifting and masking operations. This is the default for the pc532.\n+\n+@item -mbitfield\n+Do use the bit-field instructions. This is the default for all platforms\n+except the pc532.\n+\n+@item -mrtd\n+Use a different function-calling convention, in which functions\n+that take a fixed number of arguments return pop their\n+arguments on return with the @code{ret} instruction.\n+\n+This calling convention is incompatible with the one normally\n+used on Unix, so you cannot use it if you need to call libraries\n+compiled with the Unix compiler.\n+\n+Also, you must provide function prototypes for all functions that\n+take variable numbers of arguments (including @code{printf});\n+otherwise incorrect code will be generated for calls to those\n+functions.\n+\n+In addition, seriously incorrect code will result if you call a\n+function with too many arguments.  (Normally, extra arguments are\n+harmlessly ignored.)\n+\n+This option takes its name from the 680x0 @code{rtd} instruction.\n+\n+\n+@item -mregparam\n+Use a different function-calling convention where the first two arguments\n+are passed in registers.\n+\n+This calling convention is incompatible with the one normally\n+used on Unix, so you cannot use it if you need to call libraries\n+compiled with the Unix compiler.\n+\n+@item -mnoregparam\n+Do not pass any arguments in registers. This is the default for all\n+targets.\n+\n+@item -msb\n+It is OK to use the sb as an index register which is always loaded with\n+zero. This is the default for the pc532-netbsd target.\n+\n+@item -mnosb\n+The sb register is not available for use or has not been initialized to\n+zero by the run time system. This is the default for all targets except\n+the pc532-netbsd. It is also implied whenever @samp{-mhimem} or\n+@samp{-fpic} is set.\n+\n+@item -mhimem\n+Many ns32000 series addressing modes use displacements of up to 512MB.\n+If an address is above 512MB then displacements from zero can not be used.\n+This option causes code to be generated which can be loaded above 512MB.\n+This may be useful for operating systems or ROM code.\n+\n+@item -mnohimem\n+Assume code will be loaded in the first 512MB of virtual address space.\n+This is the default for all platforms.\n+\n+\n+@end table\n+\n+\n \n @node Code Gen Options\n @section Options for Code Generation Conventions"}]}