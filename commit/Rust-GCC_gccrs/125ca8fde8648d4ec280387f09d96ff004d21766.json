{"sha": "125ca8fde8648d4ec280387f09d96ff004d21766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI1Y2E4ZmRlODY0OGQ0ZWMyODAzODdmMDlkOTZmZjAwNGQyMTc2Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-04-02T07:08:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-04-02T07:08:16Z"}, "message": "except.c (convert_from_eh_region_ranges_1): Smash REG_EH_REGION notes for nothrow calls if flag_forced_unwind_exceptions.\n\n        * except.c (convert_from_eh_region_ranges_1): Smash REG_EH_REGION\n        notes for nothrow calls if flag_forced_unwind_exceptions.\n        (build_post_landing_pads): Mind flag_forced_unwind_exceptions.\n        (sjlj_find_directly_reachable_regions): Likewise.\n        (reachable_handlers): Likewise.\n        (can_throw_external): Likewise.\n        (collect_one_action_chain): Record cleanups after catch-all and\n        must-not-throw if flag_forced_unwind_exceptions.\n        * flags.h (flag_forced_unwind_exceptions): Declare.\n        * toplev.c (flag_forced_unwind_exceptions): New.\n        (lang_independent_options): Add it.\n\t* doc/invoke.text: Add it.\n\n        * g++.dg/eh/forced1.C: New.\n        * g++.dg/eh/forced2.C: New.\n\nFrom-SVN: r65158", "tree": {"sha": "f5fd434b155cb047fdfef9811d5e14bb52fc5de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5fd434b155cb047fdfef9811d5e14bb52fc5de9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/125ca8fde8648d4ec280387f09d96ff004d21766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125ca8fde8648d4ec280387f09d96ff004d21766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/125ca8fde8648d4ec280387f09d96ff004d21766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125ca8fde8648d4ec280387f09d96ff004d21766/comments", "author": null, "committer": null, "parents": [{"sha": "5b64bfc45b6f8f12a5dfac32d708cae70a31432f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b64bfc45b6f8f12a5dfac32d708cae70a31432f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b64bfc45b6f8f12a5dfac32d708cae70a31432f"}], "stats": {"total": 338, "additions": 314, "deletions": 24}, "files": [{"sha": "a25207869af734c22c2dda987f54e0fe1fbf0645", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=125ca8fde8648d4ec280387f09d96ff004d21766", "patch": "@@ -1,3 +1,18 @@\n+2003-04-01  Richard Henderson  <rth@redhat.com>\n+\n+        * except.c (convert_from_eh_region_ranges_1): Smash REG_EH_REGION\n+        notes for nothrow calls if flag_forced_unwind_exceptions.\n+        (build_post_landing_pads): Mind flag_forced_unwind_exceptions.\n+        (sjlj_find_directly_reachable_regions): Likewise.\n+        (reachable_handlers): Likewise.\n+        (can_throw_external): Likewise.\n+        (collect_one_action_chain): Record cleanups after catch-all and\n+        must-not-throw if flag_forced_unwind_exceptions.\n+        * flags.h (flag_forced_unwind_exceptions): Declare.\n+        * toplev.c (flag_forced_unwind_exceptions): New.\n+        (lang_independent_options): Add it.\n+\t* doc/invoke.text: Add it.\n+\n 2003-04-01  David Mosberger <davidm@hpl.hp.com>\n \n         * config/ia64/crti.asm: Clean up trailing whitespace."}, {"sha": "3d8026cc847c672404aa0a0f7d51a934b829ecc1", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=125ca8fde8648d4ec280387f09d96ff004d21766", "patch": "@@ -705,7 +705,7 @@ in the following sections.\n -fcall-saved-@var{reg}  -fcall-used-@var{reg} @gol\n -ffixed-@var{reg} -fexceptions @gol\n -fnon-call-exceptions  -funwind-tables @gol\n--fasynchronous-unwind-tables @gol\n+-fasynchronous-unwind-tables -fforced-unwind-exceptions @gol\n -finhibit-size-directive  -finstrument-functions @gol\n -fno-common  -fno-ident  -fno-gnu-linker @gol\n -fpcc-struct-return  -fpic  -fPIC @gol\n@@ -10843,6 +10843,13 @@ instructions to throw exceptions, i.e.@: memory references or floating\n point instructions.  It does not allow exceptions to be thrown from\n arbitrary signal handlers such as @code{SIGALRM}.\n \n+@item -fforced-unwind-exceptions\n+@opindex fforced-unwind-exceptions\n+Generate code that checks for non-catchable exceptions derived from\n+@code{_Unwind_ForcedUnwind}, such as from @code{longjmp_unwind} or\n+from pthread cancellation.  There is some amount of code-size \n+overhead associated with this, so it is not default.\n+\n @item -funwind-tables\n @opindex funwind-tables\n Similar to @option{-fexceptions}, except that it will just generate any needed"}, {"sha": "00c5e5b9a545f221799d9a135582b57927687902", "filename": "gcc/except.c", "status": "modified", "additions": 123, "deletions": 23, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=125ca8fde8648d4ec280387f09d96ff004d21766", "patch": "@@ -1111,21 +1111,40 @@ convert_from_eh_region_ranges_1 (pinsns, orig_sp, cur)\n \t}\n       else if (INSN_P (insn))\n \t{\n-\t  if (cur > 0\n-\t      && ! find_reg_note (insn, REG_EH_REGION, NULL_RTX)\n-\t      /* Calls can always potentially throw exceptions, unless\n-\t\t they have a REG_EH_REGION note with a value of 0 or less.\n-\t\t Which should be the only possible kind so far.  */\n-\t      && (GET_CODE (insn) == CALL_INSN\n-\t\t  /* If we wanted exceptions for non-call insns, then\n-\t\t     any may_trap_p instruction could throw.  */\n-\t\t  || (flag_non_call_exceptions\n-\t\t      && GET_CODE (PATTERN (insn)) != CLOBBER\n-\t\t      && GET_CODE (PATTERN (insn)) != USE\n-\t\t      && may_trap_p (PATTERN (insn)))))\n+\t  rtx note;\n+\t  switch (cur)\n \t    {\n-\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_EH_REGION, GEN_INT (cur),\n+\t    default:\n+\t      /* An existing region note may be present to suppress\n+\t\t exception handling.  Anything with a note value of -1\n+\t\t cannot throw an exception of any kind.  A note value\n+\t\t of 0 means that \"normal\" exceptions are suppressed,\n+\t\t but not necessarily \"forced unwind\" exceptions.  */\n+\t      note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+\t      if (note)\n+\t\t{\n+\t\t  if (flag_forced_unwind_exceptions\n+\t\t      && INTVAL (XEXP (note, 0)) >= 0)\n+\t\t    XEXP (note, 0) = GEN_INT (cur);\n+\t\t  break;\n+\t\t}\n+\n+\t      /* Calls can always potentially throw exceptions; if we wanted\n+\t\t exceptions for non-call insns, then any may_trap_p\n+\t\t instruction can throw.  */\n+\t      if (GET_CODE (insn) != CALL_INSN\n+\t\t  && (!flag_non_call_exceptions\n+\t\t      || GET_CODE (PATTERN (insn)) == CLOBBER\n+\t\t      || GET_CODE (PATTERN (insn)) == USE\n+\t\t      || !may_trap_p (PATTERN (insn))))\n+\t\tbreak;\n+\n+\t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_EH_REGION,\n+\t\t\t\t\t\t  GEN_INT (cur),\n \t\t\t\t\t\t  REG_NOTES (insn));\n+\n+\t    case 0:\n+\t      break;\n \t    }\n \n \t  if (GET_CODE (insn) == CALL_INSN\n@@ -1683,9 +1702,15 @@ build_post_landing_pads ()\n \t    struct eh_region *c;\n \t    for (c = region->u.try.catch; c ; c = c->u.catch.next_catch)\n \t      {\n-\t\t/* ??? _Unwind_ForcedUnwind wants no match here.  */\n \t\tif (c->u.catch.type_list == NULL)\n-\t\t  emit_jump (c->label);\n+\t\t  {\n+\t\t    if (flag_forced_unwind_exceptions)\n+\t\t      emit_cmp_and_jump_insns\n+\t\t\t(cfun->eh->filter, const0_rtx, GT, NULL_RTX,\n+\t\t\t word_mode, 0, c->label);\n+\t\t    else\n+\t\t      emit_jump (c->label);\n+\t\t  }\n \t\telse\n \t\t  {\n \t\t    /* Need for one cmp/jump per type caught. Each type\n@@ -1746,10 +1771,35 @@ build_post_landing_pads ()\n \t  break;\n \n \tcase ERT_CLEANUP:\n-\tcase ERT_MUST_NOT_THROW:\n \t  region->post_landing_pad = region->label;\n \t  break;\n \n+\tcase ERT_MUST_NOT_THROW:\n+\t  /* See maybe_remove_eh_handler about removing region->label.  */\n+\t  if (flag_forced_unwind_exceptions && region->label)\n+\t    {\n+\t      region->post_landing_pad = gen_label_rtx ();\n+\n+\t      start_sequence ();\n+\n+\t      emit_label (region->post_landing_pad);\n+\t      emit_cmp_and_jump_insns (cfun->eh->filter, const0_rtx, GT,\n+\t\t\t\t       NULL_RTX, word_mode, 0, region->label);\n+\n+\t      region->resume\n+\t        = emit_jump_insn (gen_rtx_RESX (VOIDmode,\n+\t\t\t\t\t\tregion->region_number));\n+\t      emit_barrier ();\n+\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n+\n+\t      emit_insn_before (seq, region->label);\n+\t    }\n+\t  else\n+\t    region->post_landing_pad = region->label;\n+\t  break;\n+\n \tcase ERT_CATCH:\n \tcase ERT_THROW:\n \t  /* Nothing to do.  */\n@@ -1927,6 +1977,19 @@ sjlj_find_directly_reachable_regions (lp_info)\n \t  if (rc != RNL_NOT_CAUGHT)\n \t    break;\n \t}\n+\n+      /* Forced unwind exceptions aren't blocked.  */\n+      if (flag_forced_unwind_exceptions && rc == RNL_BLOCKED)\n+\t{\n+          struct eh_region *r;\n+\t  for (r = region->outer; r ; r = r->outer)\n+\t    if (r->type == ERT_CLEANUP)\n+\t      {\n+\t\trc = RNL_MAYBE_CAUGHT;\n+\t\tbreak;\n+\t      }\n+\t}\n+\n       if (rc == RNL_MAYBE_CAUGHT || rc == RNL_CAUGHT)\n \t{\n \t  lp_info[region->region_number].directly_reachable = 1;\n@@ -2581,8 +2644,6 @@ reachable_next_level (region, type_thrown, info)\n \tfor (c = region->u.try.catch; c ; c = c->u.catch.next_catch)\n \t  {\n \t    /* A catch-all handler ends the search.  */\n-\t    /* ??? _Unwind_ForcedUnwind will want outer cleanups\n-\t       to be run as well.  */\n \t    if (c->u.catch.type_list == NULL)\n \t      {\n \t\tadd_reachable_handler (info, region, c);\n@@ -2767,7 +2828,21 @@ reachable_handlers (insn)\n   while (region)\n     {\n       if (reachable_next_level (region, type_thrown, &info) >= RNL_CAUGHT)\n-\tbreak;\n+\t{\n+\t  /* Forced unwind exceptions are neither BLOCKED nor CAUGHT.\n+\t     Make sure the cleanup regions are reachable.  */\n+\t  if (flag_forced_unwind_exceptions)\n+\t    {\n+\t      while ((region = region->outer) != NULL)\n+\t\tif (region->type == ERT_CLEANUP)\n+\t\t  {\n+\t\t    add_reachable_handler (&info, region, region);\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t  break;\n+\t}\n+\n       /* If we have processed one cleanup, there is no point in\n \t processing any more of them.  Each cleanup will have an edge\n \t to the next outer cleanup region, so the flow graph will be\n@@ -2889,6 +2964,10 @@ can_throw_external (insn)\n   if (INTVAL (XEXP (note, 0)) <= 0)\n     return false;\n \n+  /* Forced unwind excptions are not catchable.  */\n+  if (flag_forced_unwind_exceptions && GET_CODE (insn) == CALL_INSN)\n+    return true;\n+\n   region = cfun->eh->region_array[INTVAL (XEXP (note, 0))];\n \n   type_thrown = NULL_TREE;\n@@ -3243,12 +3322,26 @@ collect_one_action_chain (ar_hash, region)\n \t{\n \t  if (c->u.catch.type_list == NULL)\n \t    {\n+\t      int filter;\n+\n+\t      /* Forced exceptions run cleanups, always.  Record them if\n+\t\t they exist.  */\n+\t      next = 0;\n+\t      if (flag_forced_unwind_exceptions)\n+\t\t{\n+\t\t  struct eh_region *r;\n+\t\t  for (r = c->outer; r ; r = r->outer)\n+\t\t    if (r->type == ERT_CLEANUP)\n+\t\t      {\n+\t\t\tnext = add_action_record (ar_hash, 0, 0);\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\n \t      /* Retrieve the filter from the head of the filter list\n \t\t where we have stored it (see assign_filter_values).  */\n-\t      int filter\n-\t\t= TREE_INT_CST_LOW (TREE_VALUE (c->u.catch.filter_list));\n-\n-\t      next = add_action_record (ar_hash, filter, 0);\n+\t      filter = TREE_INT_CST_LOW (TREE_VALUE (c->u.catch.filter_list));\n+\t      next = add_action_record (ar_hash, filter, next);\n \t    }\n \t  else\n \t    {\n@@ -3293,6 +3386,13 @@ collect_one_action_chain (ar_hash, region)\n \t requires no call-site entry.  Note that this differs from\n \t the no handler or cleanup case in that we do require an lsda\n \t to be generated.  Return a magic -2 value to record this.  */\n+      if (flag_forced_unwind_exceptions)\n+\t{\n+\t  struct eh_region *r;\n+\t  for (r = region->outer; r ; r = r->outer)\n+\t    if (r->type == ERT_CLEANUP)\n+\t      return 0;\n+\t}\n       return -2;\n \n     case ERT_CATCH:"}, {"sha": "88ed465e010c41fb969c4f013805c3b50a84973b", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=125ca8fde8648d4ec280387f09d96ff004d21766", "patch": "@@ -476,6 +476,10 @@ extern int flag_unwind_tables;\n \n extern int flag_asynchronous_unwind_tables;\n \n+/* Nonzero means allow for forced unwinding.  */\n+\n+extern int flag_forced_unwind_exceptions;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n "}, {"sha": "512d7204ad630b5b911b8437adf462546442721b", "filename": "gcc/testsuite/g++.dg/eh/forced1.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced1.C?ref=125ca8fde8648d4ec280387f09d96ff004d21766", "patch": "@@ -0,0 +1,71 @@\n+// { dg-do run }\n+// { dg-options \"-fforced-unwind-exceptions\" }\n+\n+// Test that forced unwinding runs all cleanups, and only cleanups.\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+\n+static int test = 0;\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    {\n+      if (test != 5)\n+        abort ();\n+      exit (0);\n+    }\n+\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  _Unwind_Exception *exc = new _Unwind_Exception;\n+  exc->exception_class = 0;\n+  exc->exception_cleanup = 0;\n+                   \n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+                   \n+  abort ();\n+}\n+\n+struct S\n+{\n+  int bit;\n+  S(int b) : bit(b) { }\n+  ~S() { test |= bit; }\n+};\n+  \n+static void doit ()\n+{\n+  try {\n+    S four(4);\n+\n+    try {\n+      S one(1);\n+      force_unwind ();\n+  \n+    } catch(...) { \n+      test |= 2;\n+    }\n+\n+  } catch(...) {\n+    test |= 8;\n+  }\n+}\n+\n+int main()\n+{ \n+  try {\n+    doit ();\n+  } catch (...) {\n+  }\n+  abort ();\n+}"}, {"sha": "f681209524659af77170f173706560caee1d5255", "filename": "gcc/testsuite/g++.dg/eh/forced2.C", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced2.C?ref=125ca8fde8648d4ec280387f09d96ff004d21766", "patch": "@@ -0,0 +1,87 @@\n+// { dg-do run }\n+// { dg-options \"-fforced-unwind-exceptions\" }\n+\n+// Test that forced unwinding runs all cleanups, and only cleanups.\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+\n+static int test = 0;\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    {\n+      if (test != 5)\n+        abort ();\n+      exit (0);\n+    }\n+\n+  return _URC_NO_REASON;\n+}\n+\n+// Note that neither the noreturn nor the nothrow specification\n+// affects forced unwinding.\n+\n+static void __attribute__((noreturn))\n+force_unwind () throw()\n+{\n+  _Unwind_Exception *exc = new _Unwind_Exception;\n+  exc->exception_class = 0;\n+  exc->exception_cleanup = 0;\n+                   \n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+                   \n+  abort ();\n+}\n+\n+struct S\n+{\n+  int bit;\n+  S(int b) : bit(b) { }\n+  ~S() { test |= bit; }\n+};\n+  \n+static void doit_3 ()\n+{\n+  S one(1);\n+  force_unwind ();\n+}\n+\n+static void doit_2 ()\n+{\n+  try {\n+    doit_3 ();\n+  } catch (...) {\n+    test |= 2;\n+  }\n+}\n+\n+static void doit_1 ()\n+{\n+  S four(4);\n+  doit_2 ();\n+}\n+\n+static void doit ()\n+{\n+  try {\n+    doit_1 ();\n+  } catch(...) {\n+    test |= 8;\n+  }\n+}\n+\n+int main()\n+{ \n+  try {\n+    doit ();\n+  } catch (...) {\n+  }\n+  abort ();\n+}"}, {"sha": "1be5202344af2cb6f38dbf73384564709d5ffdea", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125ca8fde8648d4ec280387f09d96ff004d21766/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=125ca8fde8648d4ec280387f09d96ff004d21766", "patch": "@@ -744,6 +744,10 @@ int flag_unwind_tables = 0;\n \n int flag_asynchronous_unwind_tables = 0;\n \n+/* Nonzero means allow for forced unwinding.  */\n+\n+int flag_forced_unwind_exceptions;\n+\n /* Nonzero means don't place uninitialized global data in common storage\n    by default.  */\n \n@@ -1128,6 +1132,8 @@ static const lang_independent_options f_options[] =\n    N_(\"Generate unwind tables exact at each instruction boundary\") },\n   {\"non-call-exceptions\", &flag_non_call_exceptions, 1,\n    N_(\"Support synchronous non-call exceptions\") },\n+  {\"forced-unwind-exceptions\", &flag_forced_unwind_exceptions, 1,\n+   N_(\"Support forced unwinding, e.g. for thread cancellation\") },\n   {\"profile-arcs\", &profile_arc_flag, 1,\n    N_(\"Insert arc based program profiling code\") },\n   {\"test-coverage\", &flag_test_coverage, 1,"}]}