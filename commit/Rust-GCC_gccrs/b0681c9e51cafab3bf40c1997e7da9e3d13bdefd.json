{"sha": "b0681c9e51cafab3bf40c1997e7da9e3d13bdefd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA2ODFjOWU1MWNhZmFiM2JmNDBjMTk5N2U3ZGE5ZTNkMTNiZGVmZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-09-10T15:37:57Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-09-10T15:37:57Z"}, "message": "lra.c (lra): Clear lra_optional_reload_pseudos before every constraint pass.\n\n2013-09-10  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* lra.c (lra): Clear lra_optional_reload_pseudos before every\n\tconstraint pass.\n\t* lra-constraints.c (curr_insn_transform): Switch on optional\n\treloads.  Check destination too to check move insn.\n\t(undo_optional_reloads): Add check that the original peudo did not\n\tchanged its allocation and the optional reload was inherited on\n\tlast inheritance pass.  Break loop after deciding to keep optional\n\treload.\n\t(lra_undo_inheritance): Add check that inherited pseudo still in\n\tmemory.\n\nFrom-SVN: r202468", "tree": {"sha": "0a7a73889f7b810825425d92ac8210b4254413e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a7a73889f7b810825425d92ac8210b4254413e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14c34330495ec168199e0f9694cc39f74c3dbe56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c34330495ec168199e0f9694cc39f74c3dbe56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14c34330495ec168199e0f9694cc39f74c3dbe56"}], "stats": {"total": 87, "additions": 62, "deletions": 25}, "files": [{"sha": "bf0a9b46d2f4785a9b2d2602e6be0df7b86a7363", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0681c9e51cafab3bf40c1997e7da9e3d13bdefd", "patch": "@@ -1,3 +1,16 @@\n+2013-09-10  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* lra.c (lra): Clear lra_optional_reload_pseudos before every\n+\tconstraint pass.\n+\t* lra-constraints.c (curr_insn_transform): Switch on optional\n+\treloads.  Check destination too to check move insn.\n+\t(undo_optional_reloads): Add check that the original peudo did not\n+\tchanged its allocation and the optional reload was inherited on\n+\tlast inheritance pass.  Break loop after deciding to keep optional\n+\treload.\n+\t(lra_undo_inheritance): Add check that inherited pseudo still in\n+\tmemory.\n+\n 2013-09-10  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64.md (generic_sched): New."}, {"sha": "479d2cbc22dcf38a109f4d2d7dc30c1088cec5df", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=b0681c9e51cafab3bf40c1997e7da9e3d13bdefd", "patch": "@@ -3309,15 +3309,19 @@ curr_insn_transform (void)\n \t     reg, we might improve the code through inheritance.  If\n \t     it does not get a hard register we coalesce memory/memory\n \t     moves later.  Ignore move insns to avoid cycling.  */\n-\t  if (0 && ! lra_simple_p\n+\t  if (! lra_simple_p\n \t      && lra_undo_inheritance_iter < LRA_MAX_INHERITANCE_PASSES\n \t      && goal_alt[i] != NO_REGS && REG_P (op)\n \t      && (regno = REGNO (op)) >= FIRST_PSEUDO_REGISTER\n+\t      && ! lra_former_scratch_p (regno)\n \t      && reg_renumber[regno] < 0\n \t      && (curr_insn_set == NULL_RTX\n-\t\t  || !(REG_P (SET_SRC (curr_insn_set))\n-\t\t       || MEM_P (SET_SRC (curr_insn_set))\n-\t\t       || GET_CODE (SET_SRC (curr_insn_set)) == SUBREG)))\n+\t\t  || !((REG_P (SET_SRC (curr_insn_set))\n+\t\t\t|| MEM_P (SET_SRC (curr_insn_set))\n+\t\t\t|| GET_CODE (SET_SRC (curr_insn_set)) == SUBREG)\n+\t\t       && (REG_P (SET_DEST (curr_insn_set))\n+\t\t\t   || MEM_P (SET_DEST (curr_insn_set))\n+\t\t\t   || GET_CODE (SET_DEST (curr_insn_set)) == SUBREG))))\n \t    optional_p = true;\n \t  else\n \t    continue;\n@@ -5441,7 +5445,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n static bool\n undo_optional_reloads (void)\n {\n-  bool change_p;\n+  bool change_p, keep_p;\n   unsigned int regno, uid;\n   bitmap_iterator bi, bi2;\n   rtx insn, set, src, dest;\n@@ -5451,26 +5455,42 @@ undo_optional_reloads (void)\n   bitmap_copy (&removed_optional_reload_pseudos, &lra_optional_reload_pseudos);\n   EXECUTE_IF_SET_IN_BITMAP (&lra_optional_reload_pseudos, 0, regno, bi)\n     if (reg_renumber[regno] >= 0)\n-      EXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi2)\n-\t{\n-\t  insn = lra_insn_recog_data[uid]->insn;\n-\t  if ((set = single_set (insn)) == NULL_RTX)\n-\t    continue;\n-\t  src = SET_SRC (set);\n-\t  dest = SET_DEST (set);\n-\t  if (! REG_P (src) || ! REG_P (dest))\n-\t    continue;\n-\t  if ((REGNO (src) == regno\n-\t       && lra_reg_info[regno].restore_regno != (int) REGNO (dest))\n-\t      || (REGNO (dest) == regno\n-\t\t  && lra_reg_info[regno].restore_regno != (int) REGNO (src)))\n+      {\n+\tkeep_p = false;\n+\tif (reg_renumber[lra_reg_info[regno].restore_regno] >= 0)\n+\t  /* If the original pseudo changed its allocation, just\n+\t     removing the optional pseudo is dangerous as the original\n+\t     pseudo will have longer live range.  */\n+\t  keep_p = true;\n+\telse\n+\t  EXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi2)\n \t    {\n-\t      /* Optional reload was inherited.  Keep it.  */\n-\t      bitmap_clear_bit (&removed_optional_reload_pseudos, regno);\n-\t      if (lra_dump_file != NULL)\n-\t\tfprintf (lra_dump_file, \"Keep optional reload reg %d\\n\", regno);\n+\t      insn = lra_insn_recog_data[uid]->insn;\n+\t      if ((set = single_set (insn)) == NULL_RTX)\n+\t\tcontinue;\n+\t      src = SET_SRC (set);\n+\t      dest = SET_DEST (set);\n+\t      if (! REG_P (src) || ! REG_P (dest))\n+\t\tcontinue;\n+\t      if (REGNO (dest) == regno\n+\t\t  /* Ignore insn for optional reloads itself.  */\n+\t\t  && lra_reg_info[regno].restore_regno != (int) REGNO (src)\n+\t\t  /* Check only inheritance on last inheritance pass.  */\n+\t\t  && (int) REGNO (src) >= new_regno_start\n+\t\t  /* Check that the optional reload was inherited.  */\n+\t\t  && bitmap_bit_p (&lra_inheritance_pseudos, REGNO (src)))\n+\t\t{\n+\t\t  keep_p = true;\n+\t\t  break;\n+\t\t}\n \t    }\n-\t}\n+\tif (keep_p)\n+\t  {\n+\t    bitmap_clear_bit (&removed_optional_reload_pseudos, regno);\n+\t    if (lra_dump_file != NULL)\n+\t      fprintf (lra_dump_file, \"Keep optional reload reg %d\\n\", regno);\n+\t  }\n+      }\n   change_p = ! bitmap_empty_p (&removed_optional_reload_pseudos);\n   bitmap_initialize (&insn_bitmap, &reg_obstack);\n   EXECUTE_IF_SET_IN_BITMAP (&removed_optional_reload_pseudos, 0, regno, bi)\n@@ -5552,7 +5572,11 @@ lra_undo_inheritance (void)\n     if (lra_reg_info[regno].restore_regno >= 0)\n       {\n \tn_all_inherit++;\n-\tif (reg_renumber[regno] < 0)\n+\tif (reg_renumber[regno] < 0\n+\t    /* If the original pseudo changed its allocation, just\n+\t       removing inheritance is dangerous as for changing\n+\t       allocation we used shorter live-ranges.  */\n+\t    && reg_renumber[lra_reg_info[regno].restore_regno] < 0)\n \t  bitmap_set_bit (&remove_pseudos, regno);\n \telse\n \t  n_inherit++;"}, {"sha": "df457f5bc9e57f4e73dc6f592324981e7b0e884d", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0681c9e51cafab3bf40c1997e7da9e3d13bdefd/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=b0681c9e51cafab3bf40c1997e7da9e3d13bdefd", "patch": "@@ -2315,6 +2315,7 @@ lra (FILE *f)\n     {\n       for (;;)\n \t{\n+\t  bitmap_clear (&lra_optional_reload_pseudos);\n \t  /* We should try to assign hard registers to scratches even\n \t     if there were no RTL transformations in\n \t     lra_constraints.  */\n@@ -2365,7 +2366,6 @@ lra (FILE *f)\n \t      if (! live_p)\n \t\tlra_clear_live_ranges ();\n \t    }\n-\t  bitmap_clear (&lra_optional_reload_pseudos);\n \t}\n       bitmap_clear (&lra_subreg_reload_pseudos);\n       bitmap_clear (&lra_inheritance_pseudos);"}]}