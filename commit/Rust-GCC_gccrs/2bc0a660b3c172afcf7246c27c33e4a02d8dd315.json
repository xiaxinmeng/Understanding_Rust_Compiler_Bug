{"sha": "2bc0a660b3c172afcf7246c27c33e4a02d8dd315", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJjMGE2NjBiM2MxNzJhZmNmNzI0NmMyN2MzM2U0YTAyZDhkZDMxNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-09T13:57:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-09T13:57:05Z"}, "message": "gimple.h (gcc_gimple_checking_assert): New macro.\n\n\t* gimple.h (gcc_gimple_checking_assert): New macro.\n \t(gimple_set_def_ops, gimple_set_use_ops,\n \tgimple_set_vuse, gimple_set_vdef,\n \tgimple_omp_subcode, gimple_omp_set_subcode, gimple_ops, gimple_op,\n \tgimple_op_ptr, gimple_op_ptr, gimple_set_op, gimple_bind_set_block,\n \tgimple_asm_input_op, gimple_asm_input_op_ptr, gimple_asm_set_input_op,\n \tgimple_asm_output_op, gimple_asm_output_op_ptr,\n \tgimple_asm_set_output_op, gimple_asm_clobber_op, \n \tgimple_asm_set_clobber_op, gimple_asm_label_op,\n \tgimple_asm_set_label_op, gimple_try_set_kind, gimple_try_catch_is_cleanup\n \tgimple_try_set_catch_is_cleanup, gimple_phi_arg, \n \tgimple_switch_num_labels, gimple_switch_set_index, gimple_switch_label,\n \tgimple_switch_set_label, gimple_omp_for_index, gimple_omp_for_index_ptr,\n \tgimple_omp_for_set_index, gimple_omp_for_initial, gimple_omp_for_initial_ptr,\n \tgimple_omp_for_set_initial, gimple_omp_for_final, gimple_omp_for_final_ptr,\n \tgimple_omp_for_set_final, gimple_omp_for_incr, gimple_omp_for_incr_ptr,\n \tgimple_omp_for_set_incr, gimple_omp_for_set_cond, gimple_omp_for_cond): Make\n \tchecking conditional with ENABLE_GIMPLE_CHECKING.\n \t(gimple_phi_set_arg): Likewise; replace memcpy by assignment.\n\nFrom-SVN: r160474", "tree": {"sha": "52087d4816382f457b44a188df4025f457aff1f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52087d4816382f457b44a188df4025f457aff1f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bc0a660b3c172afcf7246c27c33e4a02d8dd315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc0a660b3c172afcf7246c27c33e4a02d8dd315", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc0a660b3c172afcf7246c27c33e4a02d8dd315", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc0a660b3c172afcf7246c27c33e4a02d8dd315/comments", "author": null, "committer": null, "parents": [{"sha": "6521ac8542fc402e4ffdf0b8f2c7270f22248842", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6521ac8542fc402e4ffdf0b8f2c7270f22248842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6521ac8542fc402e4ffdf0b8f2c7270f22248842"}], "stats": {"total": 165, "additions": 86, "deletions": 79}, "files": [{"sha": "31e03a39f1e988b12b7689dc31b94f94d06c7d50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc0a660b3c172afcf7246c27c33e4a02d8dd315/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc0a660b3c172afcf7246c27c33e4a02d8dd315/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bc0a660b3c172afcf7246c27c33e4a02d8dd315", "patch": "@@ -1,3 +1,25 @@\n+2010-06-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gimple.h (gcc_gimple_checking_assert): New macro.\n+ \t(gimple_set_def_ops, gimple_set_use_ops,\n+ \tgimple_set_vuse, gimple_set_vdef,\n+ \tgimple_omp_subcode, gimple_omp_set_subcode, gimple_ops, gimple_op,\n+ \tgimple_op_ptr, gimple_op_ptr, gimple_set_op, gimple_bind_set_block,\n+ \tgimple_asm_input_op, gimple_asm_input_op_ptr, gimple_asm_set_input_op,\n+ \tgimple_asm_output_op, gimple_asm_output_op_ptr,\n+ \tgimple_asm_set_output_op, gimple_asm_clobber_op, \n+ \tgimple_asm_set_clobber_op, gimple_asm_label_op,\n+ \tgimple_asm_set_label_op, gimple_try_set_kind, gimple_try_catch_is_cleanup\n+ \tgimple_try_set_catch_is_cleanup, gimple_phi_arg, \n+ \tgimple_switch_num_labels, gimple_switch_set_index, gimple_switch_label,\n+ \tgimple_switch_set_label, gimple_omp_for_index, gimple_omp_for_index_ptr,\n+ \tgimple_omp_for_set_index, gimple_omp_for_initial, gimple_omp_for_initial_ptr,\n+ \tgimple_omp_for_set_initial, gimple_omp_for_final, gimple_omp_for_final_ptr,\n+ \tgimple_omp_for_set_final, gimple_omp_for_incr, gimple_omp_for_incr_ptr,\n+ \tgimple_omp_for_set_incr, gimple_omp_for_set_cond, gimple_omp_for_cond): Make\n+ \tchecking conditional with ENABLE_GIMPLE_CHECKING.\n+ \t(gimple_phi_set_arg): Likewise; replace memcpy by assignment.\n+\n 2010-06-09  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* tree-ssa-loop-ivopts.c (adjust_setup_cost): New function."}, {"sha": "5d153677005255e8aa9e9cb831df49c64e1e1149", "filename": "gcc/gimple.h", "status": "modified", "additions": 64, "deletions": 79, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc0a660b3c172afcf7246c27c33e4a02d8dd315/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc0a660b3c172afcf7246c27c33e4a02d8dd315/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=2bc0a660b3c172afcf7246c27c33e4a02d8dd315", "patch": "@@ -51,6 +51,7 @@ extern const unsigned char gimple_rhs_class_table[];\n \n /* Error out if a gimple tuple is addressed incorrectly.  */\n #if defined ENABLE_GIMPLE_CHECKING\n+#define gcc_gimple_checking_assert(EXPR) gcc_assert (EXPR)\n extern void gimple_check_failed (const_gimple, const char *, int,          \\\n                                  const char *, enum gimple_code,           \\\n \t\t\t\t enum tree_code) ATTRIBUTE_NORETURN;\n@@ -63,6 +64,7 @@ extern void gimple_check_failed (const_gimple, const char *, int,          \\\n \t  \t\t   (CODE), ERROR_MARK);\t\t\t\t\\\n   } while (0)\n #else  /* not ENABLE_GIMPLE_CHECKING  */\n+#define gcc_gimple_checking_assert(EXPR) ((void)(0 && (EXPR)))\n #define GIMPLE_CHECK(GS, CODE)\t\t\t(void)0\n #endif\n \n@@ -1084,9 +1086,7 @@ gimple_code (const_gimple g)\n static inline enum gimple_statement_structure_enum\n gss_for_code (enum gimple_code code)\n {\n-#ifdef ENABLE_CHECKING\n-  gcc_assert ((unsigned int)code < LAST_AND_UNUSED_GIMPLE_CODE);\n-#endif\n+  gcc_gimple_checking_assert ((unsigned int)code < LAST_AND_UNUSED_GIMPLE_CODE);\n   return gss_for_code_[code];\n }\n \n@@ -1326,7 +1326,7 @@ gimple_def_ops (const_gimple g)\n static inline void\n gimple_set_def_ops (gimple g, struct def_optype_d *def)\n {\n-  gcc_assert (gimple_has_ops (g));\n+  gcc_gimple_checking_assert (gimple_has_ops (g));\n   g->gsops.opbase.def_ops = def;\n }\n \n@@ -1347,7 +1347,7 @@ gimple_use_ops (const_gimple g)\n static inline void\n gimple_set_use_ops (gimple g, struct use_optype_d *use)\n {\n-  gcc_assert (gimple_has_ops (g));\n+  gcc_gimple_checking_assert (gimple_has_ops (g));\n   g->gsops.opbase.use_ops = use;\n }\n \n@@ -1428,7 +1428,7 @@ gimple_vdef_ptr (gimple g)\n static inline void\n gimple_set_vuse (gimple g, tree vuse)\n {\n-  gcc_assert (gimple_has_mem_ops (g));\n+  gcc_gimple_checking_assert (gimple_has_mem_ops (g));\n   g->gsmembase.vuse = vuse;\n }\n \n@@ -1437,7 +1437,7 @@ gimple_set_vuse (gimple g, tree vuse)\n static inline void\n gimple_set_vdef (gimple g, tree vdef)\n {\n-  gcc_assert (gimple_has_mem_ops (g));\n+  gcc_gimple_checking_assert (gimple_has_mem_ops (g));\n   g->gsmembase.vdef = vdef;\n }\n \n@@ -1528,7 +1528,7 @@ gimple_references_memory_p (gimple stmt)\n static inline unsigned\n gimple_omp_subcode (const_gimple s)\n {\n-  gcc_assert (gimple_code (s) >= GIMPLE_OMP_ATOMIC_LOAD\n+  gcc_gimple_checking_assert (gimple_code (s) >= GIMPLE_OMP_ATOMIC_LOAD\n \t      && gimple_code (s) <= GIMPLE_OMP_SINGLE);\n   return s->gsbase.subcode;\n }\n@@ -1540,7 +1540,7 @@ gimple_omp_set_subcode (gimple s, unsigned int subcode)\n {\n   /* We only have 16 bits for the subcode.  Assert that we are not\n      overflowing it.  */\n-  gcc_assert (subcode < (1 << 16));\n+  gcc_gimple_checking_assert (subcode < (1 << 16));\n   s->gsbase.subcode = subcode;\n }\n \n@@ -1640,7 +1640,7 @@ gimple_ops (gimple gs)\n      of the structure.  Note that those structures that do not\n      have an operand vector have a zero offset.  */\n   off = gimple_ops_offset_[gimple_statement_structure (gs)];\n-  gcc_assert (off != 0);\n+  gcc_gimple_checking_assert (off != 0);\n \n   return (tree *) ((char *) gs + off);\n }\n@@ -1653,9 +1653,7 @@ gimple_op (const_gimple gs, unsigned i)\n {\n   if (gimple_has_ops (gs))\n     {\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (i < gimple_num_ops (gs));\n-#endif\n+      gcc_gimple_checking_assert (i < gimple_num_ops (gs));\n       return gimple_ops (CONST_CAST_GIMPLE (gs))[i];\n     }\n   else\n@@ -1669,9 +1667,7 @@ gimple_op_ptr (const_gimple gs, unsigned i)\n {\n   if (gimple_has_ops (gs))\n     {\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (i < gimple_num_ops (gs));\n-#endif\n+      gcc_gimple_checking_assert (i < gimple_num_ops (gs));\n       return gimple_ops (CONST_CAST_GIMPLE (gs)) + i;\n     }\n   else\n@@ -1683,7 +1679,7 @@ gimple_op_ptr (const_gimple gs, unsigned i)\n static inline void\n gimple_set_op (gimple gs, unsigned i, tree op)\n {\n-  gcc_assert (gimple_has_ops (gs) && i < gimple_num_ops (gs));\n+  gcc_gimple_checking_assert (gimple_has_ops (gs) && i < gimple_num_ops (gs));\n \n   /* Note.  It may be tempting to assert that OP matches\n      is_gimple_operand, but that would be wrong.  Different tuples\n@@ -2626,7 +2622,8 @@ static inline void\n gimple_bind_set_block (gimple gs, tree block)\n {\n   GIMPLE_CHECK (gs, GIMPLE_BIND);\n-  gcc_assert (block == NULL_TREE || TREE_CODE (block) == BLOCK);\n+  gcc_gimple_checking_assert (block == NULL_TREE\n+\t\t\t      || TREE_CODE (block) == BLOCK);\n   gs->gimple_bind.block = block;\n }\n \n@@ -2675,7 +2672,7 @@ static inline tree\n gimple_asm_input_op (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.ni);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.ni);\n   return gimple_op (gs, index);\n }\n \n@@ -2685,7 +2682,7 @@ static inline tree *\n gimple_asm_input_op_ptr (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.ni);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.ni);\n   return gimple_op_ptr (gs, index);\n }\n \n@@ -2696,8 +2693,8 @@ static inline void\n gimple_asm_set_input_op (gimple gs, unsigned index, tree in_op)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.ni);\n-  gcc_assert (TREE_CODE (in_op) == TREE_LIST);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.ni\n+\t\t\t      && TREE_CODE (in_op) == TREE_LIST);\n   gimple_set_op (gs, index, in_op);\n }\n \n@@ -2708,7 +2705,7 @@ static inline tree\n gimple_asm_output_op (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.no);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.no);\n   return gimple_op (gs, index + gs->gimple_asm.ni);\n }\n \n@@ -2718,7 +2715,7 @@ static inline tree *\n gimple_asm_output_op_ptr (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.no);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.no);\n   return gimple_op_ptr (gs, index + gs->gimple_asm.ni);\n }\n \n@@ -2729,8 +2726,8 @@ static inline void\n gimple_asm_set_output_op (gimple gs, unsigned index, tree out_op)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.no);\n-  gcc_assert (TREE_CODE (out_op) == TREE_LIST);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.no\n+\t\t\t      && TREE_CODE (out_op) == TREE_LIST);\n   gimple_set_op (gs, index + gs->gimple_asm.ni, out_op);\n }\n \n@@ -2741,7 +2738,7 @@ static inline tree\n gimple_asm_clobber_op (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.nc);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.nc);\n   return gimple_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.no);\n }\n \n@@ -2752,8 +2749,8 @@ static inline void\n gimple_asm_set_clobber_op (gimple gs, unsigned index, tree clobber_op)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.nc);\n-  gcc_assert (TREE_CODE (clobber_op) == TREE_LIST);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.nc\n+\t\t\t      && TREE_CODE (clobber_op) == TREE_LIST);\n   gimple_set_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.no, clobber_op);\n }\n \n@@ -2763,7 +2760,7 @@ static inline tree\n gimple_asm_label_op (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.nl);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.nl);\n   return gimple_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.nc);\n }\n \n@@ -2773,8 +2770,8 @@ static inline void\n gimple_asm_set_label_op (gimple gs, unsigned index, tree label_op)\n {\n   GIMPLE_CHECK (gs, GIMPLE_ASM);\n-  gcc_assert (index <= gs->gimple_asm.nl);\n-  gcc_assert (TREE_CODE (label_op) == TREE_LIST);\n+  gcc_gimple_checking_assert (index <= gs->gimple_asm.nl\n+\t\t\t      && TREE_CODE (label_op) == TREE_LIST);\n   gimple_set_op (gs, index + gs->gimple_asm.ni + gs->gimple_asm.nc, label_op);\n }\n \n@@ -2987,7 +2984,8 @@ static inline void\n gimple_try_set_kind (gimple gs, enum gimple_try_flags kind)\n {\n   GIMPLE_CHECK (gs, GIMPLE_TRY);\n-  gcc_assert (kind == GIMPLE_TRY_CATCH || kind == GIMPLE_TRY_FINALLY);\n+  gcc_gimple_checking_assert (kind == GIMPLE_TRY_CATCH\n+\t\t\t      || kind == GIMPLE_TRY_FINALLY);\n   if (gimple_try_kind (gs) != kind)\n     gs->gsbase.subcode = (unsigned int) kind;\n }\n@@ -2998,7 +2996,7 @@ gimple_try_set_kind (gimple gs, enum gimple_try_flags kind)\n static inline bool\n gimple_try_catch_is_cleanup (const_gimple gs)\n {\n-  gcc_assert (gimple_try_kind (gs) == GIMPLE_TRY_CATCH);\n+  gcc_gimple_checking_assert (gimple_try_kind (gs) == GIMPLE_TRY_CATCH);\n   return (gs->gsbase.subcode & GIMPLE_TRY_CATCH_IS_CLEANUP) != 0;\n }\n \n@@ -3029,7 +3027,7 @@ gimple_try_cleanup (gimple gs)\n static inline void\n gimple_try_set_catch_is_cleanup (gimple g, bool catch_is_cleanup)\n {\n-  gcc_assert (gimple_try_kind (g) == GIMPLE_TRY_CATCH);\n+  gcc_gimple_checking_assert (gimple_try_kind (g) == GIMPLE_TRY_CATCH);\n   if (catch_is_cleanup)\n     g->gsbase.subcode |= GIMPLE_TRY_CATCH_IS_CLEANUP;\n   else\n@@ -3156,7 +3154,7 @@ static inline struct phi_arg_d *\n gimple_phi_arg (gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PHI);\n-  gcc_assert (index <= gs->gimple_phi.capacity);\n+  gcc_gimple_checking_assert (index <= gs->gimple_phi.capacity);\n   return &(gs->gimple_phi.args[index]);\n }\n \n@@ -3167,8 +3165,8 @@ static inline void\n gimple_phi_set_arg (gimple gs, unsigned index, struct phi_arg_d * phiarg)\n {\n   GIMPLE_CHECK (gs, GIMPLE_PHI);\n-  gcc_assert (index <= gs->gimple_phi.nargs);\n-  memcpy (gs->gimple_phi.args + index, phiarg, sizeof (struct phi_arg_d));\n+  gcc_gimple_checking_assert (index <= gs->gimple_phi.nargs);\n+  gs->gimple_phi.args[index] = *phiarg;\n }\n \n /* Return the region number for GIMPLE_RESX GS.  */\n@@ -3215,7 +3213,7 @@ gimple_switch_num_labels (const_gimple gs)\n   unsigned num_ops;\n   GIMPLE_CHECK (gs, GIMPLE_SWITCH);\n   num_ops = gimple_num_ops (gs);\n-  gcc_assert (num_ops > 1);\n+  gcc_gimple_checking_assert (num_ops > 1);\n   return num_ops - 1;\n }\n \n@@ -3256,7 +3254,7 @@ static inline void\n gimple_switch_set_index (gimple gs, tree index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_SWITCH);\n-  gcc_assert (SSA_VAR_P (index) || CONSTANT_CLASS_P (index));\n+  gcc_gimple_checking_assert (SSA_VAR_P (index) || CONSTANT_CLASS_P (index));\n   gimple_set_op (gs, 0, index);\n }\n \n@@ -3268,7 +3266,7 @@ static inline tree\n gimple_switch_label (const_gimple gs, unsigned index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_SWITCH);\n-  gcc_assert (gimple_num_ops (gs) > index + 1);\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) > index + 1);\n   return gimple_op (gs, index + 1);\n }\n \n@@ -3278,8 +3276,9 @@ static inline void\n gimple_switch_set_label (gimple gs, unsigned index, tree label)\n {\n   GIMPLE_CHECK (gs, GIMPLE_SWITCH);\n-  gcc_assert (gimple_num_ops (gs) > index + 1);\n-  gcc_assert (label == NULL_TREE || TREE_CODE (label) == CASE_LABEL_EXPR);\n+  gcc_gimple_checking_assert (gimple_num_ops (gs) > index + 1\n+\t\t\t      && (label == NULL_TREE\n+\t\t\t          || TREE_CODE (label) == CASE_LABEL_EXPR));\n   gimple_set_op (gs, index + 1, label);\n }\n \n@@ -3324,9 +3323,7 @@ static inline tree\n gimple_debug_bind_get_var (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (gimple_debug_bind_p (dbg));\n-#endif\n+  gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n   return gimple_op (dbg, 0);\n }\n \n@@ -3337,9 +3334,7 @@ static inline tree\n gimple_debug_bind_get_value (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (gimple_debug_bind_p (dbg));\n-#endif\n+  gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n   return gimple_op (dbg, 1);\n }\n \n@@ -3350,9 +3345,7 @@ static inline tree *\n gimple_debug_bind_get_value_ptr (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (gimple_debug_bind_p (dbg));\n-#endif\n+  gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n   return gimple_op_ptr (dbg, 1);\n }\n \n@@ -3362,9 +3355,7 @@ static inline void\n gimple_debug_bind_set_var (gimple dbg, tree var)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (gimple_debug_bind_p (dbg));\n-#endif\n+  gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n   gimple_set_op (dbg, 0, var);\n }\n \n@@ -3375,9 +3366,7 @@ static inline void\n gimple_debug_bind_set_value (gimple dbg, tree value)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (gimple_debug_bind_p (dbg));\n-#endif\n+  gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n   gimple_set_op (dbg, 1, value);\n }\n \n@@ -3392,9 +3381,7 @@ static inline void\n gimple_debug_bind_reset_value (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (gimple_debug_bind_p (dbg));\n-#endif\n+  gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n   gimple_set_op (dbg, 1, GIMPLE_DEBUG_BIND_NOVALUE);\n }\n \n@@ -3405,9 +3392,7 @@ static inline bool\n gimple_debug_bind_has_value_p (gimple dbg)\n {\n   GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (gimple_debug_bind_p (dbg));\n-#endif\n+  gcc_gimple_checking_assert (gimple_debug_bind_p (dbg));\n   return gimple_op (dbg, 1) != GIMPLE_DEBUG_BIND_NOVALUE;\n }\n \n@@ -3506,7 +3491,7 @@ static inline tree\n gimple_omp_for_index (const_gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return gs->gimple_omp_for.iter[i].index;\n }\n \n@@ -3517,7 +3502,7 @@ static inline tree *\n gimple_omp_for_index_ptr (gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return &gs->gimple_omp_for.iter[i].index;\n }\n \n@@ -3528,7 +3513,7 @@ static inline void\n gimple_omp_for_set_index (gimple gs, size_t i, tree index)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   gs->gimple_omp_for.iter[i].index = index;\n }\n \n@@ -3539,7 +3524,7 @@ static inline tree\n gimple_omp_for_initial (const_gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return gs->gimple_omp_for.iter[i].initial;\n }\n \n@@ -3550,7 +3535,7 @@ static inline tree *\n gimple_omp_for_initial_ptr (gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return &gs->gimple_omp_for.iter[i].initial;\n }\n \n@@ -3561,7 +3546,7 @@ static inline void\n gimple_omp_for_set_initial (gimple gs, size_t i, tree initial)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   gs->gimple_omp_for.iter[i].initial = initial;\n }\n \n@@ -3572,7 +3557,7 @@ static inline tree\n gimple_omp_for_final (const_gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return gs->gimple_omp_for.iter[i].final;\n }\n \n@@ -3583,7 +3568,7 @@ static inline tree *\n gimple_omp_for_final_ptr (gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return &gs->gimple_omp_for.iter[i].final;\n }\n \n@@ -3594,7 +3579,7 @@ static inline void\n gimple_omp_for_set_final (gimple gs, size_t i, tree final)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   gs->gimple_omp_for.iter[i].final = final;\n }\n \n@@ -3605,7 +3590,7 @@ static inline tree\n gimple_omp_for_incr (const_gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return gs->gimple_omp_for.iter[i].incr;\n }\n \n@@ -3616,7 +3601,7 @@ static inline tree *\n gimple_omp_for_incr_ptr (gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return &gs->gimple_omp_for.iter[i].incr;\n }\n \n@@ -3627,7 +3612,7 @@ static inline void\n gimple_omp_for_set_incr (gimple gs, size_t i, tree incr)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   gs->gimple_omp_for.iter[i].incr = incr;\n }\n \n@@ -4129,8 +4114,8 @@ static inline void\n gimple_omp_for_set_cond (gimple gs, size_t i, enum tree_code cond)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (TREE_CODE_CLASS (cond) == tcc_comparison);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (TREE_CODE_CLASS (cond) == tcc_comparison\n+\t\t\t      && i < gs->gimple_omp_for.collapse);\n   gs->gimple_omp_for.iter[i].cond = cond;\n }\n \n@@ -4141,7 +4126,7 @@ static inline enum tree_code\n gimple_omp_for_cond (const_gimple gs, size_t i)\n {\n   GIMPLE_CHECK (gs, GIMPLE_OMP_FOR);\n-  gcc_assert (i < gs->gimple_omp_for.collapse);\n+  gcc_gimple_checking_assert (i < gs->gimple_omp_for.collapse);\n   return gs->gimple_omp_for.iter[i].cond;\n }\n "}]}