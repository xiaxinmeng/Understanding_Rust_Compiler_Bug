{"sha": "75cb8865aeb49acf813a8eb900466aa40b6954cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVjYjg4NjVhZWI0OWFjZjgxM2E4ZWI5MDA0NjZhYTQwYjY5NTRjZA==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "1998-12-02T10:36:07Z"}, "committer": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "1998-12-02T10:36:07Z"}, "message": "Fix indentation from last patch.\n\nRemove trailing whitespace.\n\nFrom-SVN: r24061", "tree": {"sha": "6b957446429faaf4bc44ec7bb1ff354335e75580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b957446429faaf4bc44ec7bb1ff354335e75580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75cb8865aeb49acf813a8eb900466aa40b6954cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cb8865aeb49acf813a8eb900466aa40b6954cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75cb8865aeb49acf813a8eb900466aa40b6954cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cb8865aeb49acf813a8eb900466aa40b6954cd/comments", "author": null, "committer": null, "parents": [{"sha": "066b4a1cc8da79e2ff195d3f154de68577a76c14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066b4a1cc8da79e2ff195d3f154de68577a76c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066b4a1cc8da79e2ff195d3f154de68577a76c14"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "54c834f92b60b48a27ac91e8db0f747a92c5385a", "filename": "gcc/c-lex.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75cb8865aeb49acf813a8eb900466aa40b6954cd/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75cb8865aeb49acf813a8eb900466aa40b6954cd/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=75cb8865aeb49acf813a8eb900466aa40b6954cd", "patch": "@@ -59,9 +59,9 @@ tree ridpointers[(int) RID_MAX];\n \n #if USE_CPPLIB\n extern unsigned char *yy_cur, *yy_lim;\n-  \n+\n extern int yy_get_token ();\n-  \n+\n #define GETC() (yy_cur < yy_lim ? *yy_cur++ : yy_get_token ())\n #define UNGETC(c) ((c), yy_cur--)\n #else\n@@ -167,7 +167,7 @@ remember_protocol_qualifiers ()\n     else if (wordlist[i].rid == RID_BYREF)\n       wordlist[i].name = \"byref\";\n     else if (wordlist[i].rid == RID_ONEWAY)\n-      wordlist[i].name = \"oneway\";   \n+      wordlist[i].name = \"oneway\";\n }\n \f\n char *\n@@ -486,7 +486,7 @@ extend_token_buffer (p)\n   return token_buffer + offset;\n }\n \f\n-#if defined HANDLE_PRAGMA \n+#if defined HANDLE_PRAGMA\n /* Local versions of these macros, that can be passed as function pointers.  */\n static int\n pragma_getc ()\n@@ -560,7 +560,7 @@ check_newline ()\n \t      if (token != IDENTIFIER)\n \t\tgoto skipline;\n #endif /* HANDLE_PRAGMA || HANDLE_GENERIC_PRAGMAS */\n-\t      \n+\n #ifdef HANDLE_PRAGMA\n \t      /* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS (if\n \t\t both are defined), in order to give the back end a chance to\n@@ -572,27 +572,27 @@ check_newline ()\n \t\t  UNGETC (c);\n \t\t}\n #endif /* !USE_CPPLIB */\n-\t      \n+\n \t      if (TREE_CODE (yylval.ttype) != IDENTIFIER_NODE)\n \t\tgoto skipline;\n \n \t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc,\n \t\t\t\t IDENTIFIER_POINTER (yylval.ttype)))\n \t\treturn GETC ();\n #endif /* HANDLE_PRAGMA */\n-\t      \n+\n #ifdef HANDLE_GENERIC_PRAGMAS\n \t      if (handle_generic_pragma (token))\n \t\treturn GETC ();\n #endif /* HANDLE_GENERIC_PRAGMAS */\n-\t      \n+\n \t      /* Issue a warning message if we have been asked to do so.\n \t\t Ignoring unknown pragmas in system header file unless\n \t\t an explcit -Wunknown-pragmas has been given. */\n \t      if (warn_unknown_pragmas > 1\n \t\t  || (warn_unknown_pragmas && ! in_system_header))\n \t\twarning (\"ignoring pragma: %s\", token_buffer);\n-\t      \n+\n \t      goto skipline;\n \t    }\n \t}\n@@ -782,7 +782,7 @@ check_newline ()\n \t\t  struct file_stack *p = input_file_stack;\n \t\t  if (indent_level != p->indent_level)\n \t\t    {\n-\t\t      warning_with_file_and_line \n+\t\t      warning_with_file_and_line\n \t\t\t(p->name, old_lineno,\n \t\t\t \"This file contains more `%c's than `%c's.\",\n \t\t\t indent_level > p->indent_level ? '{' : '}',\n@@ -889,7 +889,7 @@ handle_generic_pragma (token)\n       while (c == ' ' || c == '\\t')\n \tc = GETC ();\n       UNGETC (c);\n-      \n+\n       if (c == '\\n' || c == EOF)\n \treturn handle_pragma_token (NULL, NULL);\n \n@@ -1076,7 +1076,7 @@ struct try_type\n   char long_long_flag;\n };\n \n-struct try_type type_sequence[] = \n+struct try_type type_sequence[] =\n {\n   { &integer_type_node, 0, 0, 0},\n   { &unsigned_type_node, 1, 0, 0},\n@@ -1278,7 +1278,7 @@ yylex ()\n \t\t   && TREE_CODE (DECL_INITIAL (lastiddecl)) == STRING_CST)\n \t    {\n \t      tree stringval = DECL_INITIAL (lastiddecl);\n-\t      \n+\n \t      /* Copy the string value so that we won't clobber anything\n \t\t if we put something in the TREE_CHAIN of this one.  */\n \t      yylval.ttype = build_string (TREE_STRING_LENGTH (stringval),\n@@ -1387,7 +1387,7 @@ yylex ()\n \t\t  floatflag = AFTER_POINT;\n \n \t\tif (base == 8)\n-\t\tbase = 10;\n+\t\t  base = 10;\n \t\t*p++ = c = GETC();\n \t\t/* Accept '.' as the start of a floating-point number\n \t\t   only when it is followed by a digit.\n@@ -1508,7 +1508,7 @@ yylex ()\n \t\t/* Exponent is decimal, even if string is a hex float.  */\n \t\tif (! ISDIGIT (c))\n \t\t  error (\"floating constant exponent has no digits\");\n-\t        while (ISDIGIT (c))\n+\t\twhile (ISDIGIT (c))\n \t\t  {\n \t\t    if (p >= token_buffer + maxtoken - 3)\n \t\t      p = extend_token_buffer (p);\n@@ -1593,7 +1593,7 @@ yylex ()\n \t\t    if (base == 16)\n \t\t      value = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n \t\t    else\n-\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t      value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n \t\t    conversion_errno = errno;\n \t\t    /* A diagnostic is required here by some ANSI C testsuites.\n \t\t       This is not pedwarn, because some people don't want\n@@ -1608,7 +1608,7 @@ yylex ()\n \t\t    if (base == 16)\n \t\t      value = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n \t\t    else\n-\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t      value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n \t\t    conversion_errno = errno;\n \t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n \t\t      warning (\"floating point number exceeds range of `long double'\");\n@@ -1619,7 +1619,7 @@ yylex ()\n \t\t    if (base == 16)\n \t\t      value = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n \t\t    else\n-\t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\t\t      value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n \t\t    conversion_errno = errno;\n \t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n \t\t      warning (\"floating point number exceeds range of `double'\");\n@@ -1726,7 +1726,7 @@ yylex ()\n \t\t\t << (i * HOST_BITS_PER_CHAR));\n \t\tlow |= (HOST_WIDE_INT) parts[i] << (i * HOST_BITS_PER_CHAR);\n \t      }\n-\t    \n+\n \t    yylval.ttype = build_int_2 (low, high);\n \t    TREE_TYPE (yylval.ttype) = long_long_unsigned_type_node;\n "}]}