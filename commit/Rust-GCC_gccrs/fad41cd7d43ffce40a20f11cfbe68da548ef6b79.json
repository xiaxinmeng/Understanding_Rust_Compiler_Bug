{"sha": "fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFkNDFjZDdkNDNmZmNlNDBhMjBmMTFjZmJlNjhkYTU0OGVmNmI3OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2006-03-22T12:50:45Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2006-03-22T12:50:45Z"}, "message": "re PR middle-end/26084 (ICE (segfault) on C++ OpenMP code)\n\n        PR middle-end/26084\n        * except.c (duplicate_eh_regions_0): New.\n        (duplicate_eh_region_1): Duplicate the children of the node as\n        well as the node itself.  Link them up properly.\n        (duplicate_eh_region_2): Merge into ...\n        (duplicate_eh_regions): ... here.  Take copy_region argument, and\n        copy only a sub-tree if asked.  Simplify copying and fixup.\n        (eh_region_outer_p): New.\n        * except.h (duplicate_eh_regions): Update decl.\n        (eh_region_outer_p): Declare.\n        * omp-low.c (lower_omp_single): Fix eh region placement wrt OMP_RETURN.\n        (lower_omp_master): Likewise.\n        (lower_omp_ordered): Likewise.\n        * tree-cfg.c (struct move_stmt_d): Add new_label_map.\n        (move_stmt_r): Use it to remap labels.  Handle recursion vs\n        remap_decls_p properly.\n        (move_block_to_fn): Pass in new_label_map.  Remap RESX_EXPR.\n        (find_outermost_region_in_block): New.\n        (new_label_mapper): New.\n        (move_sese_region_to_fn): Copy eh information to the new function\n        properly.\n        * tree-inline.c (copy_cfg_body): Update for new duplicate_eh_regions\n        argument.\n        * tree-pretty-print.c (dump_generic_node): Dump RESX_EXPR region\n        number.\n\nFrom-SVN: r112283", "tree": {"sha": "600f6369cacf022589c2e874590e5a90eb2f99e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/600f6369cacf022589c2e874590e5a90eb2f99e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/comments", "author": null, "committer": null, "parents": [{"sha": "ee51e035d90930ba62d16122a40ffd3188f44c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee51e035d90930ba62d16122a40ffd3188f44c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee51e035d90930ba62d16122a40ffd3188f44c2c"}], "stats": {"total": 478, "additions": 345, "deletions": 133}, "files": [{"sha": "1f564ad23da383629687d9b377d43e0318a2e001", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "patch": "@@ -1,3 +1,31 @@\n+2006-03-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/26084\n+\t* except.c (duplicate_eh_regions_0): New.\n+\t(duplicate_eh_region_1): Duplicate the children of the node as\n+\twell as the node itself.  Link them up properly.\n+\t(duplicate_eh_region_2): Merge into ...\n+\t(duplicate_eh_regions): ... here.  Take copy_region argument, and\n+\tcopy only a sub-tree if asked.  Simplify copying and fixup.\n+\t(eh_region_outer_p): New.\n+\t* except.h (duplicate_eh_regions): Update decl.\n+\t(eh_region_outer_p): Declare.\n+\t* omp-low.c (lower_omp_single): Fix eh region placement wrt OMP_RETURN.\n+\t(lower_omp_master): Likewise.\n+\t(lower_omp_ordered): Likewise.\n+\t* tree-cfg.c (struct move_stmt_d): Add new_label_map.\n+\t(move_stmt_r): Use it to remap labels.  Handle recursion vs\n+\tremap_decls_p properly.\n+\t(move_block_to_fn): Pass in new_label_map.  Remap RESX_EXPR.\n+\t(find_outermost_region_in_block): New.\n+\t(new_label_mapper): New.\n+\t(move_sese_region_to_fn): Copy eh information to the new function\n+\tproperly.\n+\t* tree-inline.c (copy_cfg_body): Update for new duplicate_eh_regions\n+\targument.\n+\t* tree-pretty-print.c (dump_generic_node): Dump RESX_EXPR region\n+\tnumber.\n+\n 2006-03-22  Richard Sandiford  <richard@codesourcery.com>\n \n \t* doc/md.texi (-mshared): Mention that -mshared code can be linked"}, {"sha": "01f11087c3bd24f1c480e03ae30f67b3a2c5ce44", "filename": "gcc/except.c", "status": "modified", "additions": 177, "deletions": 106, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "patch": "@@ -857,84 +857,145 @@ current_function_has_exception_handlers (void)\n   return false;\n }\n \f\n-static struct eh_region *\n-duplicate_eh_region_1 (struct eh_region *o)\n-{\n-  struct eh_region *n = ggc_alloc_cleared (sizeof (struct eh_region));\n-\n-  *n = *o;\n+/* A subroutine of duplicate_eh_regions.  Search the region tree under O\n+   for the miniumum and maximum region numbers.  Update *MIN and *MAX.  */\n \n-  n->region_number = o->region_number + cfun->eh->last_region_number;\n-  VEC_replace (eh_region, cfun->eh->region_array, n->region_number, n);\n-  gcc_assert (!o->aka);\n+static void\n+duplicate_eh_regions_0 (eh_region o, int *min, int *max)\n+{\n+  if (o->region_number < *min)\n+    *min = o->region_number;\n+  if (o->region_number > *max)\n+    *max = o->region_number;\n \n-  return n;\n+  if (o->inner)\n+    {\n+      o = o->inner;\n+      duplicate_eh_regions_0 (o, min, max);\n+      while (o->next_peer)\n+\t{\n+\t  o = o->next_peer;\n+\t  duplicate_eh_regions_0 (o, min, max);\n+\t}\n+    }\n }\n \n-static void\n-duplicate_eh_region_2 (struct eh_region *o, struct eh_region **n_array,\n-\t\t       struct eh_region *prev_try)\n+/* A subroutine of duplicate_eh_regions.  Copy the region tree under OLD.\n+   Root it at OUTER, and apply EH_OFFSET to the region number.  Don't worry\n+   about the other internal pointers just yet, just the tree-like pointers.  */\n+\n+static eh_region\n+duplicate_eh_regions_1 (eh_region old, eh_region outer, int eh_offset)\n {\n-  struct eh_region *n = n_array[o->region_number];\n+  eh_region ret, n;\n \n-  switch (n->type)\n-    {\n-    case ERT_TRY:\n-      if (o->u.try.catch)\n-        n->u.try.catch = n_array[o->u.try.catch->region_number];\n-      if (o->u.try.last_catch)\n-        n->u.try.last_catch = n_array[o->u.try.last_catch->region_number];\n-      break;\n+  ret = n = ggc_alloc (sizeof (struct eh_region));\n \n-    case ERT_CATCH:\n-      if (o->u.catch.next_catch)\n-\tn->u.catch.next_catch = n_array[o->u.catch.next_catch->region_number];\n-      if (o->u.catch.prev_catch)\n-\tn->u.catch.prev_catch = n_array[o->u.catch.prev_catch->region_number];\n-      break;\n+  *n = *old;\n+  n->outer = outer;\n+  gcc_assert (!old->aka);\n \n-    case ERT_CLEANUP:\n-      if (o->u.cleanup.prev_try)\n-\tn->u.cleanup.prev_try = n_array[o->u.cleanup.prev_try->region_number];\n-      else\n-        n->u.cleanup.prev_try = prev_try;\n-      break;\n+  n->region_number += eh_offset;\n+  VEC_replace (eh_region, cfun->eh->region_array, n->region_number, n);\n \n-    default:\n-      break;\n+  if (old->inner)\n+    {\n+      old = old->inner;\n+      n = n->inner = duplicate_eh_regions_1 (old, ret, eh_offset);\n+      while (old->next_peer)\n+\t{\n+\t  old = old->next_peer;\n+\t  n = n->next_peer = duplicate_eh_regions_1 (old, ret, eh_offset);\n+\t}\n     }\n \n-  if (o->outer)\n-    n->outer = n_array[o->outer->region_number];\n-  if (o->inner)\n-    n->inner = n_array[o->inner->region_number];\n-  if (o->next_peer)\n-    n->next_peer = n_array[o->next_peer->region_number];\n+  return ret;\n }\n \n-/* Duplicate the EH regions of IFUN into current function, root the tree in\n-   OUTER_REGION and remap labels using MAP callback.  */\n+/* Duplicate the EH regions of IFUN, rootted at COPY_REGION, into current\n+   function and root the tree below OUTER_REGION.  Remap labels using MAP\n+   callback.  The special case of COPY_REGION of 0 means all regions.  */\n+\n int\n duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n-\t\t      void *data, int outer_region)\n+\t\t      void *data, int copy_region, int outer_region)\n {\n-  int ifun_last_region_number = ifun->eh->last_region_number;\n-  struct eh_region **n_array, *root, *cur, *prev_try;\n-  int i;\n+  eh_region cur, prev_try, outer, *splice;\n+  int i, min_region, max_region, eh_offset, cfun_last_region_number;\n+  int num_regions;\n \n-  if (ifun_last_region_number == 0 || !ifun->eh->region_tree)\n+  if (!ifun->eh->region_tree)\n     return 0;\n \n-  n_array = xcalloc (ifun_last_region_number + 1, sizeof (*n_array));\n+  /* Find the range of region numbers to be copied.  The interface we \n+     provide here mandates a single offset to find new number from old,\n+     which means we must look at the numbers present, instead of the\n+     count or something else.  */\n+  if (copy_region > 0)\n+    {\n+      min_region = INT_MAX;\n+      max_region = 0;\n+\n+      cur = VEC_index (eh_region, ifun->eh->region_array, copy_region);\n+      duplicate_eh_regions_0 (cur, &min_region, &max_region);\n+    }\n+  else\n+    min_region = 1, max_region = ifun->eh->last_region_number;\n+  num_regions = max_region - min_region + 1;\n+  cfun_last_region_number = cfun->eh->last_region_number;\n+  eh_offset = cfun_last_region_number + 1 - min_region;\n+\n+  /* If we've not yet created a region array, do so now.  */\n   VEC_safe_grow (eh_region, gc, cfun->eh->region_array,\n-\t\t cfun->eh->last_region_number + 1 + ifun_last_region_number);\n+\t\t cfun_last_region_number + 1 + num_regions);\n+  cfun->eh->last_region_number = max_region + eh_offset;\n \n-  /* We might've created new cfun->eh->region_array so zero out nonexisting region 0.  */\n+  /* We may have just allocated the array for the first time.\n+     Make sure that element zero is null.  */\n   VEC_replace (eh_region, cfun->eh->region_array, 0, 0);\n \n-  for (i = cfun->eh->last_region_number + 1;\n-       i < cfun->eh->last_region_number + 1 + ifun_last_region_number; i++)\n-    VEC_replace (eh_region, cfun->eh->region_array, i, 0);\n+  /* Zero all entries in the range allocated.  */\n+  memset (VEC_address (eh_region, cfun->eh->region_array)\n+\t  + cfun_last_region_number + 1, 0, num_regions);\n+\n+  /* Locate the spot at which to insert the new tree.  */\n+  if (outer_region > 0)\n+    {\n+      outer = VEC_index (eh_region, cfun->eh->region_array, outer_region);\n+      splice = &outer->inner;\n+    }\n+  else\n+    {\n+      outer = NULL;\n+      splice = &cfun->eh->region_tree;\n+    }\n+  while (*splice)\n+    splice = &(*splice)->next_peer;\n+\n+  /* Copy all the regions in the subtree.  */\n+  if (copy_region > 0)\n+    {\n+      cur = VEC_index (eh_region, ifun->eh->region_array, copy_region);\n+      *splice = duplicate_eh_regions_1 (cur, outer, eh_offset);\n+    }\n+  else\n+    {\n+      eh_region n;\n+\n+      cur = ifun->eh->region_tree;\n+      *splice = n = duplicate_eh_regions_1 (cur, outer, eh_offset);\n+      while (cur->next_peer)\n+\t{\n+\t  cur = cur->next_peer;\n+\t  n = n->next_peer = duplicate_eh_regions_1 (cur, outer, eh_offset);\n+\t}\n+    }\n+\n+  /* Remap all the labels in the new regions.  */\n+  for (i = cfun_last_region_number + 1;\n+       VEC_iterate (eh_region, cfun->eh->region_array, i, cur); ++i)\n+    if (cur && cur->tree_label)\n+      cur->tree_label = map (cur->tree_label, data);\n \n   /* Search for the containing ERT_TRY region to fix up\n      the prev_try short-cuts for ERT_CLEANUP regions.  */\n@@ -945,67 +1006,77 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n \t prev_try = prev_try->outer)\n       ;\n \n-  for (i = 1; i <= ifun_last_region_number; ++i)\n-    {\n-      cur = VEC_index (eh_region, ifun->eh->region_array, i);\n-      if (!cur || cur->region_number != i)\n-\tcontinue;\n-      n_array[i] = duplicate_eh_region_1 (cur);\n-      if (cur->tree_label)\n-\t{\n-\t  tree newlabel = map (cur->tree_label, data);\n-\t  n_array[i]->tree_label = newlabel;\n-\t}\n-      else\n-\tn_array[i]->tree_label = NULL;\n-    }\n-  for (i = 1; i <= ifun_last_region_number; ++i)\n+  /* Remap all of the internal catch and cleanup linkages.  Since we \n+     duplicate entire subtrees, all of the referenced regions will have\n+     been copied too.  And since we renumbered them as a block, a simple\n+     bit of arithmetic finds us the index for the replacement region.  */\n+  for (i = cfun_last_region_number + 1;\n+       VEC_iterate (eh_region, cfun->eh->region_array, i, cur); ++i)\n     {\n-      cur = VEC_index (eh_region, ifun->eh->region_array, i);\n-      if (!cur || cur->region_number != i)\n+      if (cur == NULL)\n \tcontinue;\n-      duplicate_eh_region_2 (cur, n_array, prev_try);\n-    }\n \n-  root = n_array[ifun->eh->region_tree->region_number];\n-  gcc_assert (root->outer == NULL);\n-  if (outer_region > 0)\n-    {\n-      struct eh_region *cur\n-         = VEC_index (eh_region, cfun->eh->region_array, outer_region);\n-      struct eh_region *p = cur->inner;\n+#define REMAP(REG) \\\n+\t(REG) = VEC_index (eh_region, cfun->eh->region_array, \\\n+\t\t\t   (REG)->region_number + eh_offset)\n \n-      if (p)\n+      switch (cur->type)\n \t{\n-\t  while (p->next_peer)\n-\t    p = p->next_peer;\n-\t  p->next_peer = root;\n-\t}\n-      else\n-        cur->inner = root;\n-      for (i = 1; i <= ifun_last_region_number; ++i)\n-\tif (n_array[i] && n_array[i]->outer == NULL)\n-\t  n_array[i]->outer = cur;\n-    }\n-  else\n-    {\n-      struct eh_region *p = cfun->eh->region_tree;\n-      if (p)\n-\t{\n-\t  while (p->next_peer)\n-\t    p = p->next_peer;\n-\t  p->next_peer = root;\n+\tcase ERT_TRY:\n+\t  if (cur->u.try.catch)\n+\t    REMAP (cur->u.try.catch);\n+\t  if (cur->u.try.last_catch)\n+\t    REMAP (cur->u.try.last_catch);\n+\t  break;\n+\n+\tcase ERT_CATCH:\n+\t  if (cur->u.catch.next_catch)\n+\t    REMAP (cur->u.catch.next_catch);\n+\t  if (cur->u.catch.prev_catch)\n+\t    REMAP (cur->u.catch.prev_catch);\n+\t  break;\n+\n+\tcase ERT_CLEANUP:\n+\t  if (cur->u.cleanup.prev_try)\n+\t    REMAP (cur->u.cleanup.prev_try);\n+\t  else\n+\t    cur->u.cleanup.prev_try = prev_try;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n-      else\n-        cfun->eh->region_tree = root;\n+\n+#undef REMAP\n     }\n \n-  free (n_array);\n+  return eh_offset;\n+}\n \n-  i = cfun->eh->last_region_number;\n-  cfun->eh->last_region_number = i + ifun_last_region_number;\n+/* Return true if REGION_A is outer to REGION_B in IFUN.  */\n \n-  return i;\n+bool\n+eh_region_outer_p (struct function *ifun, int region_a, int region_b)\n+{\n+  struct eh_region *rp_a, *rp_b;\n+\n+  gcc_assert (ifun->eh->last_region_number > 0);\n+  gcc_assert (ifun->eh->region_tree);\n+\n+  rp_a = VEC_index (eh_region, ifun->eh->region_array, region_a);\n+  rp_b = VEC_index (eh_region, ifun->eh->region_array, region_b);\n+  gcc_assert (rp_a != NULL);\n+  gcc_assert (rp_b != NULL);\n+\n+  do\n+    {\n+      if (rp_a == rp_b)\n+\treturn true;\n+      rp_b = rp_b->outer;\n+    }\n+  while (rp_b);\n+\n+  return false;\n }\n \f\n static int"}, {"sha": "5b28296c8b4660cbc45035c2a1deb4232da14c09", "filename": "gcc/except.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "patch": "@@ -82,7 +82,8 @@ extern rtx expand_builtin_extend_pointer (tree);\n extern rtx get_exception_pointer (struct function *);\n extern rtx get_exception_filter (struct function *);\n typedef tree (*duplicate_eh_regions_map) (tree, void *);\n-extern int duplicate_eh_regions (struct function *, duplicate_eh_regions_map, void *, int);\n+extern int duplicate_eh_regions (struct function *, duplicate_eh_regions_map,\n+\t\t\t\t void *, int, int);\n \n extern void sjlj_emit_function_exit_after (rtx);\n extern void default_init_unwind_resume_libfunc (void);\n@@ -106,6 +107,7 @@ extern void collect_eh_region_array (void);\n extern void expand_resx_expr (tree);\n extern void verify_eh_tree (struct function *);\n extern void dump_eh_tree (FILE *, struct function *);\n+extern bool eh_region_outer_p (struct function *, int, int);\n \n /* tree-eh.c */\n extern void add_stmt_to_eh_region_fn (struct function *, tree, int);"}, {"sha": "41b4093e692dc164bd67e9dce0e41ce42d8982b6", "filename": "gcc/omp-low.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "patch": "@@ -3464,6 +3464,9 @@ lower_omp_sections (tree *stmt_p, omp_context *ctx)\n   new_body = alloc_stmt_list ();\n   append_to_statement_list (ilist, &new_body);\n   append_to_statement_list (stmt, &new_body);\n+  /* ??? The OMP_RETURN doesn't logically belong here, but in\n+     expand_omp_sections we expect this marker to be where the\n+     individual sections join after completing the loop.  */\n   append_to_statement_list (region_exit, &new_body);\n   append_to_statement_list (olist, &new_body);\n   append_to_statement_list (dlist, &new_body);\n@@ -3610,9 +3613,9 @@ lower_omp_single (tree *stmt_p, omp_context *ctx)\n     lower_omp_single_simple (single_stmt, &BIND_EXPR_BODY (bind));\n \n   append_to_statement_list (dlist, &BIND_EXPR_BODY (bind));\n+  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n   t = make_node (OMP_RETURN_EXPR);\n   append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n-  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n   pop_gimplify_context (bind);\n \n   BIND_EXPR_VARS (bind) = chainon (BIND_EXPR_VARS (bind), ctx->block_vars);\n@@ -3647,9 +3650,9 @@ lower_omp_master (tree *stmt_p, omp_context *ctx)\n \n   x = build1 (LABEL_EXPR, void_type_node, lab);\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n+  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n   x = make_node (OMP_RETURN_EXPR);\n   append_to_statement_list (x, &BIND_EXPR_BODY (bind));\n-  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n   pop_gimplify_context (bind);\n \n   BIND_EXPR_VARS (bind) = chainon (BIND_EXPR_VARS (bind), ctx->block_vars);\n@@ -3683,9 +3686,9 @@ lower_omp_ordered (tree *stmt_p, omp_context *ctx)\n   x = built_in_decls[BUILT_IN_GOMP_ORDERED_END];\n   x = build_function_call_expr (x, NULL);\n   gimplify_and_add (x, &BIND_EXPR_BODY (bind));\n+  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n   x = make_node (OMP_RETURN_EXPR);\n   append_to_statement_list (x, &BIND_EXPR_BODY (bind));\n-  maybe_catch_exception (&BIND_EXPR_BODY (bind));\n   pop_gimplify_context (bind);\n \n   BIND_EXPR_VARS (bind) = chainon (BIND_EXPR_VARS (bind), ctx->block_vars);"}, {"sha": "6f0e947f9432d5e1957bd0aae934c2c0cbb7908d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 127, "deletions": 20, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "patch": "@@ -4591,6 +4591,7 @@ struct move_stmt_d\n   tree from_context;\n   tree to_context;\n   bitmap vars_to_remove;\n+  htab_t new_label_map;\n   bool remap_decls_p;\n };\n \n@@ -4599,39 +4600,62 @@ struct move_stmt_d\n    variable referenced in *TP.  */\n \n static tree\n-move_stmt_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n+move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n {\n   struct move_stmt_d *p = (struct move_stmt_d *) data;\n+  tree t = *tp;\n \n-  if (p->block && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (*tp))))\n-    TREE_BLOCK (*tp) = p->block;\n+  if (p->block && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t))))\n+    TREE_BLOCK (t) = p->block;\n \n-  if (OMP_DIRECTIVE_P (*tp))\n+  if (OMP_DIRECTIVE_P (t) && TREE_CODE (t) != OMP_RETURN_EXPR)\n     {\n       /* Do not remap variables inside OMP directives.  Variables\n \t referenced in clauses and directive header belong to the\n \t parent function and should not be moved into the child\n \t function.  */\n+      bool save_remap_decls_p = p->remap_decls_p;\n       p->remap_decls_p = false;\n-    }\n+      *walk_subtrees = 0;\n+\n+      walk_tree (&OMP_BODY (t), move_stmt_r, p, NULL);\n \n-  if (p->remap_decls_p\n-      && DECL_P (*tp)\n-      && DECL_CONTEXT (*tp) == p->from_context)\n+      p->remap_decls_p = save_remap_decls_p;\n+    }\n+  else if (DECL_P (t) && DECL_CONTEXT (t) == p->from_context)\n     {\n-      DECL_CONTEXT (*tp) = p->to_context;\n+      if (TREE_CODE (t) == LABEL_DECL)\n+\t{\n+\t  if (p->new_label_map)\n+\t    {\n+\t      struct tree_map in, *out;\n+\t      in.from = t;\n+\t      out = htab_find_with_hash (p->new_label_map, &in, DECL_UID (t));\n+\t      if (out)\n+\t\t*tp = t = out->to;\n+\t    }\n \n-      if (TREE_CODE (*tp) == VAR_DECL)\n+\t  DECL_CONTEXT (t) = p->to_context;\n+\t}\n+      else if (p->remap_decls_p)\n \t{\n-\t  struct function *f = DECL_STRUCT_FUNCTION (p->to_context);\n-\t  f->unexpanded_var_list = tree_cons (0, *tp, f->unexpanded_var_list);\n+\t  DECL_CONTEXT (t) = p->to_context;\n \n-\t  /* Mark *TP to be removed from the original function,\n-\t     otherwise it will be given a DECL_RTL when the original\n-\t     function is expanded.  */\n-\t  bitmap_set_bit (p->vars_to_remove, DECL_UID (*tp));\n+\t  if (TREE_CODE (t) == VAR_DECL)\n+\t    {\n+\t      struct function *f = DECL_STRUCT_FUNCTION (p->to_context);\n+\t      f->unexpanded_var_list\n+\t\t= tree_cons (0, t, f->unexpanded_var_list);\n+\n+\t      /* Mark T to be removed from the original function,\n+\t         otherwise it will be given a DECL_RTL when the\n+\t\t original function is expanded.  */\n+\t      bitmap_set_bit (p->vars_to_remove, DECL_UID (t));\n+\t    }\n \t}\n     }\n+  else if (TYPE_P (t))\n+    *walk_subtrees = 0;\n \n   return NULL_TREE;\n }\n@@ -4650,7 +4674,7 @@ move_stmt_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n static void\n move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t\t  basic_block after, bool update_edge_count_p,\n-\t\t  bitmap vars_to_remove)\n+\t\t  bitmap vars_to_remove, htab_t new_label_map, int eh_offset)\n {\n   struct control_flow_graph *cfg;\n   edge_iterator ei;\n@@ -4701,10 +4725,12 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n   for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n     {\n       tree stmt = bsi_stmt (si);\n+      int region;\n \n       d.from_context = cfun->decl;\n       d.to_context = dest_cfun->decl;\n       d.remap_decls_p = true;\n+      d.new_label_map = new_label_map;\n       if (TREE_BLOCK (stmt))\n \td.block = DECL_INITIAL (dest_cfun->decl);\n \n@@ -4736,11 +4762,66 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t  if (uid >= dest_cfun->last_label_uid)\n \t    dest_cfun->last_label_uid = uid + 1;\n \t}\n+      else if (TREE_CODE (stmt) == RESX_EXPR && eh_offset != 0)\n+\tTREE_OPERAND (stmt, 0) =\n+\t  build_int_cst (NULL_TREE,\n+\t\t\t TREE_INT_CST_LOW (TREE_OPERAND (stmt, 0))\n+\t\t\t + eh_offset);\n+\n+      region = lookup_stmt_eh_region (stmt);\n+      if (region >= 0)\n+\t{\n+\t  add_stmt_to_eh_region_fn (dest_cfun, stmt, region + eh_offset);\n+\t  remove_stmt_from_eh_region (stmt);\n+\t}\n+    }\n+}\n+\n+/* Examine the statements in BB (which is in SRC_CFUN); find and return\n+   the outermost EH region.  Use REGION as the incoming base EH region.  */\n+\n+static int\n+find_outermost_region_in_block (struct function *src_cfun,\n+\t\t\t\tbasic_block bb, int region)\n+{\n+  block_stmt_iterator si;\n+  \n+  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+    {\n+      tree stmt = bsi_stmt (si);\n+      int stmt_region;\n \n-      remove_stmt_from_eh_region (stmt);\n+      stmt_region = lookup_stmt_eh_region_fn (src_cfun, stmt);\n+      if (stmt_region > 0\n+\t  && (region < 0 || eh_region_outer_p (src_cfun, stmt_region, region)))\n+\tregion = stmt_region;\n     }\n+\n+  return region;\n }\n \n+static tree\n+new_label_mapper (tree decl, void *data)\n+{\n+  htab_t hash = (htab_t) data;\n+  struct tree_map *m;\n+  void **slot;\n+\n+  gcc_assert (TREE_CODE (decl) == LABEL_DECL);\n+\n+  m = xmalloc (sizeof (struct tree_map));\n+  m->hash = DECL_UID (decl);\n+  m->from = decl;\n+  m->to = create_artificial_label ();\n+  LABEL_DECL_UID (m->to) = LABEL_DECL_UID (decl);\n+\n+  slot = htab_find_slot_with_hash (hash, m, m->hash, INSERT);\n+  gcc_assert (*slot == NULL);\n+\n+  *slot = m;\n+\n+  return m->to;\n+}\n \n /* Move a single-entry, single-exit region delimited by ENTRY_BB and\n    EXIT_BB to function DEST_CFUN.  The whole region is replaced by a\n@@ -4763,11 +4844,12 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   VEC(basic_block,heap) *bbs;\n   basic_block after, bb, *entry_pred, *exit_succ;\n   struct function *saved_cfun;\n-  int *entry_flag, *exit_flag;\n+  int *entry_flag, *exit_flag, eh_offset;\n   unsigned i, num_entry_edges, num_exit_edges;\n   edge e;\n   edge_iterator ei;\n   bitmap vars_to_remove;\n+  htab_t new_label_map;\n \n   saved_cfun = cfun;\n \n@@ -4813,7 +4895,28 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n   /* Switch context to the child function to initialize DEST_FN's CFG.  */\n   gcc_assert (dest_cfun->cfg == NULL);\n   cfun = dest_cfun;\n+\n   init_empty_tree_cfg ();\n+\n+  /* Initialize EH information for the new function.  */\n+  eh_offset = 0;\n+  new_label_map = NULL;\n+  if (saved_cfun->eh)\n+    {\n+      int region = -1;\n+\n+      for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+\tregion = find_outermost_region_in_block (saved_cfun, bb, region);\n+\n+      init_eh_for_function ();\n+      if (region != -1)\n+\t{\n+\t  new_label_map = htab_create (17, tree_map_hash, tree_map_eq, free);\n+\t  eh_offset = duplicate_eh_regions (saved_cfun, new_label_mapper,\n+\t\t\t\t\t    new_label_map, region, 0);\n+\t}\n+    }\n+\n   cfun = saved_cfun;\n \n   /* Move blocks from BBS into DEST_CFUN.  */\n@@ -4825,10 +4928,14 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n       /* No need to update edge counts on the last block.  It has\n \t already been updated earlier when we detached the region from\n \t the original CFG.  */\n-      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, vars_to_remove);\n+      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, vars_to_remove,\n+\t                new_label_map, eh_offset);\n       after = bb;\n     }\n \n+  if (new_label_map)\n+    htab_delete (new_label_map);\n+\n   /* Remove the variables marked in VARS_TO_REMOVE from\n      CFUN->UNEXPANDED_VAR_LIST.  Otherwise, they will be given a\n      DECL_RTL in the context of CFUN.  */"}, {"sha": "3e35842a76e77378fe8584da87776a8ca6af38e7", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "patch": "@@ -924,7 +924,8 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency,\n       if (id->transform_new_cfg)\n         init_eh_for_function ();\n       id->eh_region_offset\n-\t= duplicate_eh_regions (cfun_to_copy, remap_decl_1, id, id->eh_region);\n+\t= duplicate_eh_regions (cfun_to_copy, remap_decl_1, id,\n+\t\t\t\t0, id->eh_region);\n     }\n   /* Use aux pointers to map the original blocks to copy.  */\n   FOR_EACH_BB_FN (bb, cfun_to_copy)"}, {"sha": "a8a33a50fcfc65a9c573819012ec76ac0d650276", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fad41cd7d43ffce40a20f11cfbe68da548ef6b79/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=fad41cd7d43ffce40a20f11cfbe68da548ef6b79", "patch": "@@ -1557,8 +1557,8 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case RESX_EXPR:\n-      pp_string (buffer, \"resx\");\n-      /* ??? Any sensible way to present the eh region?  */\n+      pp_string (buffer, \"resx \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n       break;\n \n     case ASM_EXPR:"}]}