{"sha": "cfef86e454ad355db3353810ae981bf6a646a04b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlZjg2ZTQ1NGFkMzU1ZGIzMzUzODEwYWU5ODFiZjZhNjQ2YTA0Yg==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-01-19T11:19:20Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-01-19T11:19:20Z"}, "message": "loop.c (current_loop_info): Renamed from loop_info_data and changed to a pointer.\n\n\t* loop.c (current_loop_info): Renamed from loop_info_data\n\tand changed to a pointer.\n\t(loop_optimize): Allocate loop_info structure for each loop\n\tand initialise to zero.\n\t(scan_loop): Set current_loop_info.\n\n\t* unroll.c (loop_iterations): Don't abort if REG_USERVAR_P set\n\ton iteration_var.\n\nFrom-SVN: r31501", "tree": {"sha": "fdb434cc0eb7f99ced77dc81bd95efde671d920d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdb434cc0eb7f99ced77dc81bd95efde671d920d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfef86e454ad355db3353810ae981bf6a646a04b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfef86e454ad355db3353810ae981bf6a646a04b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfef86e454ad355db3353810ae981bf6a646a04b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfef86e454ad355db3353810ae981bf6a646a04b/comments", "author": null, "committer": null, "parents": [{"sha": "e4b68cedfd8fe2d9c380f701d8add1fec4c2532f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b68cedfd8fe2d9c380f701d8add1fec4c2532f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4b68cedfd8fe2d9c380f701d8add1fec4c2532f"}], "stats": {"total": 13, "additions": 8, "deletions": 5}, "files": [{"sha": "d69094f5db8f8d0e35d70f02a08f027fb3119308", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfef86e454ad355db3353810ae981bf6a646a04b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfef86e454ad355db3353810ae981bf6a646a04b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=cfef86e454ad355db3353810ae981bf6a646a04b", "patch": "@@ -53,10 +53,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n \n-/* Information about the loop being processed used to compute\n+/* Information about the current loop being processed used to compute\n    the number of loop iterations for loop unrolling and doloop\n    optimization.  */\n-static struct loop_info loop_info_data;\n+static struct loop_info *current_loop_info;\n \n /* Vector mapping INSN_UIDs to luids.\n    The luids are like uids but increase monotonically always.\n@@ -516,6 +516,9 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n     {\n       struct loop *loop = &loops->array[i];\n \n+      loop->info = (struct loop_info *) alloca (sizeof (struct loop_info));\n+      memset (loop->info, 0, sizeof (struct loop_info));\n+      \n       if (! loop->invalid && loop->end)\n \tscan_loop (loop, unroll_p, bct_p);\n     }\n@@ -578,6 +581,7 @@ scan_loop (loop, unroll_p, bct_p)\n   register int i;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n+  struct loop_info *loop_info = loop->info;\n   rtx p;\n   /* 1 if we are scanning insns that could be executed zero times.  */\n   int maybe_never = 0;\n@@ -605,9 +609,8 @@ scan_loop (loop, unroll_p, bct_p)\n   /* Nonzero if we are scanning instructions in a sub-loop.  */\n   int loop_depth = 0;\n   int nregs;\n-  struct loop_info *loop_info = &loop_info_data;\n \n-  loop->info = loop_info;\n+  current_loop_info = loop_info;\n   loop->top = 0;\n \n   /* Determine whether this loop starts with a jump down to a test at\n@@ -3230,7 +3233,7 @@ invariant_p (x)\n \t  && ! current_function_has_nonlocal_goto)\n \treturn 1;\n \n-      if (loop_info_data.has_call\n+      if (current_loop_info->has_call\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER && call_used_regs[REGNO (x)])\n \treturn 0;\n "}]}