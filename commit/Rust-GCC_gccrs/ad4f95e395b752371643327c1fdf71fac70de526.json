{"sha": "ad4f95e395b752371643327c1fdf71fac70de526", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ0Zjk1ZTM5NWI3NTIzNzE2NDMzMjdjMWZkZjcxZmFjNzBkZTUyNg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2015-08-23T21:50:30Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2015-08-23T21:50:30Z"}, "message": "re PR libfortran/54572 (Use libbacktrace library)\n\n\tPR libfortran/54572\n\n\t* Makefile.def: Make libgfortran depend on libbacktrace.\n\t* Makefile.in: Regenerate.\n\n\t* config-lang.in: Add libbacktrace to target_libs.\n\n\t* Makefile.am (libgfortran_la_LDFLAGS): Link in libbacktrace.\n\t(AM_CPPFLAGS): Add libbacktrace directories to include paths.\n\t* Makefile.in: Regenerate.\n\t* aclocal.m4: Regenerate.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\t* configure.ac: Remove checks for strtok_r, wait, execve, pipe,\n\tand dup2. Remove call to GCC_CHECK_UNWIND_GETIPINFO.\n\t* libgfortran.h (full_exe_path, find_addr2line, backtrace): Remove\n\tprototypes.\n\t(show_backtrace): Add prototype.\n\t* runtime/backtrace.c: Rework file entirely.\n\t* runtime/compile_options.c (backtrace_handler): Rename backtrace\n\tto show_backtrace.\n\t(maybe_find_addr2line): Remove function.\n\t(set_options): Remove call to maybe_find_addr2line.\n\t* runtime/error.c (sys_abort): Rename backtrace to show_backtrace.\n\t* runtime/main.c (store_exe_path): Empty function body.\n\t(full_exe_path, gfstrtok_r, find_addr2line): Remove functions.\n\t(cleanup): Don't free removed variables.\n\t* runtime/minimal.c (full_exe_path): Remove function.\n\t(set_args): Don't set exe_path.\n\n\t* gfortran.dg/backtrace_1.f90: New test.\n\nFrom-SVN: r227106", "tree": {"sha": "2d9bb42bb8fba1bb8290c5fdeb49a6955a68c642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d9bb42bb8fba1bb8290c5fdeb49a6955a68c642"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad4f95e395b752371643327c1fdf71fac70de526", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad4f95e395b752371643327c1fdf71fac70de526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad4f95e395b752371643327c1fdf71fac70de526", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad4f95e395b752371643327c1fdf71fac70de526/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1487cca00ca6f4e0fe60d72761737da162e96840", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1487cca00ca6f4e0fe60d72761737da162e96840", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1487cca00ca6f4e0fe60d72761737da162e96840"}], "stats": {"total": 665, "additions": 166, "deletions": 499}, "files": [{"sha": "0c7ce18d080e559f09b1d1287c283ce19d1f7a01", "filename": "ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -1,3 +1,9 @@\n+2015-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR libfortran/54572\n+\t* Makefile.def: Make libgfortran depend on libbacktrace.\n+\t* Makefile.in: Regenerate.\n+\n 2015-08-20  Simon Dardis  <simon.dardis@imgtec.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "8b4dad99160e187dea10abef5ac07ea7342a680b", "filename": "Makefile.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -597,6 +597,7 @@ dependencies = { module=all-target-winsup; on=all-target-libtermcap; };\n dependencies = { module=configure-target-newlib; on=all-binutils; };\n dependencies = { module=configure-target-newlib; on=all-ld; };\n dependencies = { module=configure-target-libgfortran; on=all-target-libquadmath; };\n+dependencies = { module=configure-target-libgfortran; on=all-target-libbacktrace; };\n \n languages = { language=c;\tgcc-check-target=check-gcc; };\n languages = { language=c++;\tgcc-check-target=check-c++;"}, {"sha": "bc2bae6d7fa7fe98951b93e78207a16abd718c6f", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -50921,6 +50921,7 @@ all-target-winsup: maybe-all-target-libtermcap\n configure-target-newlib: maybe-all-binutils\n configure-target-newlib: maybe-all-ld\n configure-target-libgfortran: maybe-all-target-libquadmath\n+configure-target-libgfortran: maybe-all-target-libbacktrace\n \n \n # Dependencies for target modules on other target modules are"}, {"sha": "d345368b70f6739129a0176e4a5e28bf17cf611f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -1,3 +1,8 @@\n+2015-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR libfortran/54572\n+\t* config-lang.in: Add libbacktrace to target_libs.\n+\n 2015-08-18  Trevor Saunders  <tbsaunde@tbsaunde.org>\n \n \t* dependency.c, dependency.h, gfortran.h, io.c, module.c,"}, {"sha": "a6c6b92e25286ff03854e29b831c282536e8c460", "filename": "gcc/fortran/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/gcc%2Ffortran%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/gcc%2Ffortran%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconfig-lang.in?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -27,7 +27,7 @@ language=\"fortran\"\n \n compilers=\"f951\\$(exeext)\"\n \n-target_libs=target-libgfortran\n+target_libs=\"target-libgfortran target-libbacktrace\"\n \n gtfiles=\"\\$(srcdir)/fortran/f95-lang.c \\$(srcdir)/fortran/trans-decl.c \\$(srcdir)/fortran/trans-intrinsic.c \\$(srcdir)/fortran/trans-io.c \\$(srcdir)/fortran/trans-stmt.c \\$(srcdir)/fortran/trans-types.c \\$(srcdir)/fortran/trans-types.h \\$(srcdir)/fortran/trans.h \\$(srcdir)/fortran/trans-const.h\"\n "}, {"sha": "6235844f53482e4ec06bed412de549a030784ecd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -1,3 +1,8 @@\n+2015-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR libfortran/54572\n+\t* gfortran.dg/backtrace_1.f90: New test.\n+\n 2015-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR libfortran/62296"}, {"sha": "fdde832d238ffef421793588c022bc20ed2f786d", "filename": "gcc/testsuite/gfortran.dg/backtrace_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/gcc%2Ftestsuite%2Fgfortran.dg%2Fbacktrace_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/gcc%2Ftestsuite%2Fgfortran.dg%2Fbacktrace_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbacktrace_1.f90?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do run }\n+! \n+! Check that BACKTRACE is available on all targets. We cannot actually\n+! check its output, but we should at least be able to call it, then exit\n+! normally.\n+!\n+program test\n+  call backtrace\n+  stop\n+end program test"}, {"sha": "b74b71d3c2fde1a8e3e962d64d993657b929d9fc", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -1,3 +1,29 @@\n+2015-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR libfortran/54572\n+\t* Makefile.am (libgfortran_la_LDFLAGS): Link in libbacktrace.\n+\t(AM_CPPFLAGS): Add libbacktrace directories to include paths.\n+\t* Makefile.in: Regenerate.\n+\t* aclocal.m4: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* configure.ac: Remove checks for strtok_r, wait, execve, pipe,\n+\tand dup2. Remove call to GCC_CHECK_UNWIND_GETIPINFO.\n+\t* libgfortran.h (full_exe_path, find_addr2line, backtrace): Remove\n+\tprototypes.\n+\t(show_backtrace): Add prototype.\n+\t* runtime/backtrace.c: Rework file entirely.\n+\t* runtime/compile_options.c (backtrace_handler): Rename backtrace\n+\tto show_backtrace.\n+\t(maybe_find_addr2line): Remove function.\n+\t(set_options): Remove call to maybe_find_addr2line.\n+\t* runtime/error.c (sys_abort): Rename backtrace to show_backtrace.\n+\t* runtime/main.c (store_exe_path): Empty function body.\n+\t(full_exe_path, gfstrtok_r, find_addr2line): Remove functions.\n+\t(cleanup): Don't free removed variables.\n+\t* runtime/minimal.c (full_exe_path): Remove function.\n+\t(set_args): Don't set exe_path.\n+\n 2015-08-23  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR libfortran/62296"}, {"sha": "e4764337310fb583f3b15b1cedccd7d6756ff693", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -37,7 +37,8 @@ toolexeclib_LTLIBRARIES = libgfortran.la\n toolexeclib_DATA = libgfortran.spec\n libgfortran_la_LINK = $(LINK) $(libgfortran_la_LDFLAGS)\n libgfortran_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` \\\n-\t$(LTLDFLAGS) $(LIBQUADLIB) -lm $(extra_ldflags_libgfortran) \\\n+\t$(LTLDFLAGS) $(LIBQUADLIB) ../libbacktrace/libbacktrace.la \\\n+\t-lm $(extra_ldflags_libgfortran) \\\n \t$(version_arg) -Wc,-shared-libgcc\n libgfortran_la_DEPENDENCIES = $(version_dep) libgfortran.spec $(LIBQUADLIB_DEP)\n \n@@ -59,7 +60,10 @@ AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n \t      -I$(srcdir)/$(MULTISRCTOP)../gcc/config $(LIBQUADINCLUDE) \\\n \t      -I$(MULTIBUILDTOP)../../$(host_subdir)/gcc \\\n \t      -I$(srcdir)/$(MULTISRCTOP)../libgcc \\\n-\t      -I$(MULTIBUILDTOP)../libgcc\n+\t      -I$(MULTIBUILDTOP)../libgcc \\\n+\t      -I$(srcdir)/$(MULTISRCTOP)../libbacktrace \\\n+\t      -I$(MULTIBUILDTOP)../libbacktrace \\\n+\t      -I../libbacktrace\n \n # Fortran rules for complex multiplication and division\n AM_CFLAGS += -fcx-fortran-rules"}, {"sha": "f0ddb38f5aba3431f89fe932d8d89116a09f07c3", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -132,7 +132,6 @@ am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n \t$(top_srcdir)/../config/multi.m4 \\\n \t$(top_srcdir)/../config/override.m4 \\\n \t$(top_srcdir)/../config/stdint.m4 \\\n-\t$(top_srcdir)/../config/unwind_ipinfo.m4 \\\n \t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n \t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n \t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../config/acx.m4 \\\n@@ -598,7 +597,8 @@ toolexeclib_LTLIBRARIES = libgfortran.la\n toolexeclib_DATA = libgfortran.spec\n libgfortran_la_LINK = $(LINK) $(libgfortran_la_LDFLAGS)\n libgfortran_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` \\\n-\t$(LTLDFLAGS) $(LIBQUADLIB) -lm $(extra_ldflags_libgfortran) \\\n+\t$(LTLDFLAGS) $(LIBQUADLIB) ../libbacktrace/libbacktrace.la \\\n+\t-lm $(extra_ldflags_libgfortran) \\\n \t$(version_arg) -Wc,-shared-libgcc\n \n libgfortran_la_DEPENDENCIES = $(version_dep) libgfortran.spec $(LIBQUADLIB_DEP)\n@@ -614,7 +614,10 @@ AM_CPPFLAGS = -iquote$(srcdir)/io -I$(srcdir)/$(MULTISRCTOP)../gcc \\\n \t      -I$(srcdir)/$(MULTISRCTOP)../gcc/config $(LIBQUADINCLUDE) \\\n \t      -I$(MULTIBUILDTOP)../../$(host_subdir)/gcc \\\n \t      -I$(srcdir)/$(MULTISRCTOP)../libgcc \\\n-\t      -I$(MULTIBUILDTOP)../libgcc\n+\t      -I$(MULTIBUILDTOP)../libgcc \\\n+\t      -I$(srcdir)/$(MULTISRCTOP)../libbacktrace \\\n+\t      -I$(MULTIBUILDTOP)../libbacktrace \\\n+\t      -I../libbacktrace\n \n gfor_io_src = io/size_from_kind.c $(am__append_2)\n gfor_io_headers = \\"}, {"sha": "403feabae9d5887eaeb7e21b31c6226d33d9e92a", "filename": "libgfortran/aclocal.m4", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Faclocal.m4?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -1029,7 +1029,6 @@ m4_include([../config/lthostflags.m4])\n m4_include([../config/multi.m4])\n m4_include([../config/override.m4])\n m4_include([../config/stdint.m4])\n-m4_include([../config/unwind_ipinfo.m4])\n m4_include([../ltoptions.m4])\n m4_include([../ltsugar.m4])\n m4_include([../ltversion.m4])"}, {"sha": "5dfa7c67a25756a2314c5d2c10f25c5a53763744", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -315,9 +315,6 @@\n /* Define to 1 if you have the `dup' function. */\n #undef HAVE_DUP\n \n-/* Define to 1 if you have the `dup2' function. */\n-#undef HAVE_DUP2\n-\n /* Define to 1 if you have the `erf' function. */\n #undef HAVE_ERF\n \n@@ -339,9 +336,6 @@\n /* Define to 1 if you have the `execl' function. */\n #undef HAVE_EXECL\n \n-/* Define to 1 if you have the `execve' function. */\n-#undef HAVE_EXECVE\n-\n /* Define to 1 if you have the `exp' function. */\n #undef HAVE_EXP\n \n@@ -462,9 +456,6 @@\n /* Define to 1 if you have the `gethostname' function. */\n #undef HAVE_GETHOSTNAME\n \n-/* Define if _Unwind_GetIPInfo is available. */\n-#undef HAVE_GETIPINFO\n-\n /* Define to 1 if you have the `getlogin' function. */\n #undef HAVE_GETLOGIN\n \n@@ -636,9 +627,6 @@\n /* Define to 1 if you have the `nextafterl' function. */\n #undef HAVE_NEXTAFTERL\n \n-/* Define to 1 if you have the `pipe' function. */\n-#undef HAVE_PIPE\n-\n /* Define to 1 if we have POSIX getpwuid_r which takes 5 arguments. */\n #undef HAVE_POSIX_GETPWUID_R\n \n@@ -753,9 +741,6 @@\n /* Define to 1 if you have the `strtof' function. */\n #undef HAVE_STRTOF\n \n-/* Define to 1 if you have the `strtok_r' function. */\n-#undef HAVE_STRTOK_R\n-\n /* Define to 1 if you have the `strtold' function. */\n #undef HAVE_STRTOLD\n \n@@ -855,9 +840,6 @@\n /* Define to 1 if you have the `vsnprintf' function. */\n #undef HAVE_VSNPRINTF\n \n-/* Define to 1 if you have the `wait' function. */\n-#undef HAVE_WAIT\n-\n /* Define if target has a reliable stat. */\n #undef HAVE_WORKING_STAT\n "}, {"sha": "d7dad11a161444c08182f20eab1395badeb46d8a", "filename": "libgfortran/configure", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -776,7 +776,6 @@ with_gnu_ld\n enable_libtool_lock\n enable_largefile\n enable_libquadmath_support\n-with_system_libunwind\n '\n       ac_precious_vars='build_alias\n host_alias\n@@ -1435,7 +1434,6 @@ Optional Packages:\n   --with-pic              try to use only PIC/non-PIC objects [default=use\n                           both]\n   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]\n-  --with-system-libunwind use installed libunwind\n \n Some influential environment variables:\n   CC          C compiler command\n@@ -2572,11 +2570,7 @@ as_fn_append ac_func_list \" alarm\"\n as_fn_append ac_func_list \" access\"\n as_fn_append ac_func_list \" fork\"\n as_fn_append ac_func_list \" execl\"\n-as_fn_append ac_func_list \" wait\"\n as_fn_append ac_func_list \" setmode\"\n-as_fn_append ac_func_list \" execve\"\n-as_fn_append ac_func_list \" pipe\"\n-as_fn_append ac_func_list \" dup2\"\n as_fn_append ac_func_list \" close\"\n as_fn_append ac_func_list \" fcntl\"\n as_fn_append ac_func_list \" strcasestr\"\n@@ -2607,7 +2601,6 @@ as_fn_append ac_func_list \" __secure_getenv\"\n as_fn_append ac_func_list \" mkostemp\"\n as_fn_append ac_func_list \" strnlen\"\n as_fn_append ac_func_list \" strndup\"\n-as_fn_append ac_func_list \" strtok_r\"\n as_fn_append ac_func_list \" newlocale\"\n as_fn_append ac_func_list \" freelocale\"\n as_fn_append ac_func_list \" uselocale\"\n@@ -12376,7 +12369,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12379 \"configure\"\n+#line 12372 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12482,7 +12475,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12485 \"configure\"\n+#line 12478 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -16514,9 +16507,6 @@ $as_echo \"#define HAVE_STRNLEN 1\" >>confdefs.h\n $as_echo \"#define HAVE_STRNDUP 1\" >>confdefs.h\n \n \n-$as_echo \"#define HAVE_STRTOK_R 1\" >>confdefs.h\n-\n-\n    # At some point, we should differentiate between architectures\n    # like x86, which have long double versions, and alpha/powerpc/etc.,\n    # which don't. For the time being, punt.\n@@ -16642,16 +16632,6 @@ done\n \n \n \n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n \n \n \n@@ -26584,44 +26564,6 @@ $as_echo \"#define HAVE_CRLF 1\" >>confdefs.h\n \n fi\n \n-# Check whether we have _Unwind_GetIPInfo for backtrace\n-\n-\n-# Check whether --with-system-libunwind was given.\n-if test \"${with_system_libunwind+set}\" = set; then :\n-  withval=$with_system_libunwind;\n-fi\n-\n-  # If system-libunwind was not specifically set, pick a default setting.\n-  if test x$with_system_libunwind = x; then\n-    case ${target} in\n-      ia64-*-hpux*) with_system_libunwind=yes ;;\n-      *) with_system_libunwind=no ;;\n-    esac\n-  fi\n-  # Based on system-libunwind and target, do we have ipinfo?\n-  if  test x$with_system_libunwind = xyes; then\n-    case ${target} in\n-      ia64-*-*) have_unwind_getipinfo=no ;;\n-      *) have_unwind_getipinfo=yes ;;\n-    esac\n-  else\n-    # Darwin before version 9 does not have _Unwind_GetIPInfo.\n-\n-    case ${target} in\n-      *-*-darwin[3-8]|*-*-darwin[3-8].*) have_unwind_getipinfo=no ;;\n-      *) have_unwind_getipinfo=yes ;;\n-    esac\n-\n-  fi\n-\n-  if test x$have_unwind_getipinfo = xyes; then\n-\n-$as_echo \"#define HAVE_GETIPINFO 1\" >>confdefs.h\n-\n-  fi\n-\n-\n cat >confcache <<\\_ACEOF\n # This file is a shell script that caches the results of configure\n # tests run on this system so they can be shared between configure"}, {"sha": "c1113a0188db4e613e8d647a4fc33a2aaa35d0be", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -287,7 +287,6 @@ if test \"x${with_newlib}\" = \"xyes\"; then\n    AC_DEFINE(HAVE_GMTIME_R, 1, [Define if you have gmtime_r.])\n    AC_DEFINE(HAVE_STRNLEN, 1, [Define if you have strnlen.])\n    AC_DEFINE(HAVE_STRNDUP, 1, [Define if you have strndup.])\n-   AC_DEFINE(HAVE_STRTOK_R, 1, [Define if you have strtok_r.])\n \n    # At some point, we should differentiate between architectures\n    # like x86, which have long double versions, and alpha/powerpc/etc.,\n@@ -298,11 +297,11 @@ if test \"x${with_newlib}\" = \"xyes\"; then\n else\n    AC_CHECK_FUNCS_ONCE(getrusage times mkstemp strtof strtold snprintf \\\n    ftruncate chsize chdir getlogin gethostname kill link symlink sleep ttyname \\\n-   alarm access fork execl wait setmode execve pipe dup2 close fcntl \\\n+   alarm access fork execl setmode close fcntl \\\n    strcasestr getrlimit gettimeofday stat fstat lstat getpwuid vsnprintf dup \\\n    getcwd localtime_r gmtime_r getpwuid_r ttyname_r clock_gettime \\\n    readlink getgid getpid getppid getuid geteuid umask getegid \\\n-   secure_getenv __secure_getenv mkostemp strnlen strndup strtok_r newlocale \\\n+   secure_getenv __secure_getenv mkostemp strnlen strndup newlocale \\\n    freelocale uselocale strerror_l)\n fi\n \n@@ -610,9 +609,6 @@ LIBGFOR_CHECK_UNLINK_OPEN_FILE\n # Check whether line terminator is LF or CRLF\n LIBGFOR_CHECK_CRLF\n \n-# Check whether we have _Unwind_GetIPInfo for backtrace\n-GCC_CHECK_UNWIND_GETIPINFO\n-\n AC_CACHE_SAVE\n \n if test ${multilib} = yes; then"}, {"sha": "7c6e79995422a6ec4f9e1f3e77459e22edc9366d", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -649,16 +649,11 @@ internal_proto(get_args);\n extern void store_exe_path (const char *);\n export_proto(store_exe_path);\n \n-extern char * full_exe_path (void);\n-internal_proto(full_exe_path);\n-\n-extern void find_addr2line (void);\n-internal_proto(find_addr2line);\n-\n /* backtrace.c */\n \n-extern void backtrace (void);\n-iexport_proto(backtrace);\n+extern void show_backtrace (int);\n+internal_proto(show_backtrace);\n+\n \n /* error.c */\n "}, {"sha": "0d7c1fcea22b4e93cdbdc4b906b32f776a1bf350", "filename": "libgfortran/runtime/backtrace.c", "status": "modified", "additions": 85, "deletions": 212, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbacktrace.c?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -31,249 +31,122 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <unistd.h>\n #endif\n \n-#ifdef HAVE_SYS_WAIT_H\n-#include <sys/wait.h>\n-#endif\n-\n-#include <limits.h>\n-\n-#include \"unwind.h\"\n-\n+#include \"backtrace-supported.h\"\n+#include \"backtrace.h\"\n \n-/* Macros for common sets of capabilities: can we fork and exec, and\n-   can we use pipes to communicate with the subprocess.  */\n-#define CAN_FORK (defined(HAVE_FORK) && defined(HAVE_EXECVE) \\\n-\t\t  && defined(HAVE_WAIT))\n-#define CAN_PIPE (CAN_FORK && defined(HAVE_PIPE) \\\n-\t\t  && defined(HAVE_DUP2) && defined(HAVE_CLOSE))\n \n-#ifndef PATH_MAX\n-#define PATH_MAX 4096\n-#endif\n+/* Store our own state while backtracing.  */\n+struct mystate\n+{\n+  int try_simple;\n+  int frame;\n+};\n \n \n-/* GDB style #NUM index for each stack frame.  */\n+/* Does a function name have \"_gfortran_\" or \"_gfortrani_\" prefix, possibly\n+   with additional underscore(s) at the beginning?  Cannot use strncmp()\n+   because we might be called from a signal handler.  */\n \n-static void \n-bt_header (int num)\n+static int\n+has_gfortran_prefix (const char *s)\n {\n-  st_printf (\"#%d  \", num);\n-}\n+  if (!s)\n+    return 0;\n \n+  while (*s == '_')\n+    s++;\n \n-/* fgets()-like function that reads a line from a fd, without\n-   needing to malloc() a buffer, and does not use locks, hence should\n-   be async-signal-safe.  */\n+  return (s[0] == 'g' && s[1] == 'f' && s[2] == 'o' && s[3] == 'r'\n+\t  && s[4] == 't' && s[5] == 'r' && s[6] == 'a' && s[7] == 'n'\n+\t  && (s[8] == '_' || (s[8] == 'i' && s[9] == '_')));\n+}\n \n-static char *\n-fd_gets (char *s, int size, int fd)\n+static void\n+error_callback (void *data, const char *msg, int errnum)\n {\n-  for (int i = 0; i < size; i++)\n+  struct mystate *state = (struct mystate *) data;\n+  if (errnum < 0)\n     {\n-      char c;\n-      ssize_t nread = read (fd, &c, 1);\n-      if (nread == 1)\n-\t{\n-\t  s[i] = c;\n-\t  if (c == '\\n')\n-\t    {\n-\t      if (i + 1 < size)\n-\t\ts[i+1] = '\\0';\n-\t      else\n-\t\ts[i] = '\\0';\n-\t      break;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  s[i] = '\\0';\n-\t  if (i == 0)\n-\t    return NULL;\n-\t  break;\n-\t}\n+      state->try_simple = 1;\n+      return;\n     }\n-  return s;\n-}\n \n+  estr_write (\"\\nSomething went wrong while printing the backtrace: \");\n+  estr_write (msg);\n+  estr_write (\"\\n\");\n+}\n \n-extern char *addr2line_path;\n+static int\n+simple_callback (void *data, uintptr_t pc)\n+{\n+  struct mystate *state = (struct mystate *) data;\n+  st_printf (\"#%d  0x%lx\\n\", state->frame, (unsigned long) pc);\n+  (state->frame)++;\n+  return 0;\n+}\n \n-/* Struct containing backtrace state.  */\n-typedef struct\n+static int\n+full_callback (void *data, uintptr_t pc, const char *filename,\n+\t       int lineno, const char *function)\n {\n-  int frame_number;\n-  int direct_output;\n-  int outfd;\n-  int infd;\n-  int error;\n+  struct mystate *state = (struct mystate *) data;\n+\n+  if (has_gfortran_prefix (function))\n+    return 0;\n+\n+  st_printf (\"#%d  0x%lx in %s\\n\", state->frame,\n+\t     (unsigned long) pc, function == NULL ? \"???\" : function);\n+  if (filename || lineno != 0)\n+    st_printf (\"\\tat %s:%d\\n\", filename == NULL ? \"???\" : filename, lineno);\n+  (state->frame)++;\n+\n+  if (function != NULL && strcmp (function, \"main\") == 0)\n+    return 1;\n+\n+  return 0;\n }\n-bt_state;\n \n-static _Unwind_Reason_Code\n-trace_function (struct _Unwind_Context *context, void *state_ptr)\n+\n+/* Display the backtrace.  */\n+\n+void\n+show_backtrace (int in_signal_handler)\n {\n-  bt_state* state = (bt_state*) state_ptr;\n-  _Unwind_Ptr ip;\n-#ifdef HAVE_GETIPINFO\n-  int ip_before_insn = 0;\n-  ip = _Unwind_GetIPInfo (context, &ip_before_insn);\n-  \n-  /* If the unwinder gave us a 'return' address, roll it back a little\n-     to ensure we get the correct line number for the call itself.  */\n-  if (! ip_before_insn)\n-    --ip;\n-#else  \n-  ip = _Unwind_GetIP (context);\n-#endif\n+  struct backtrace_state *lbstate;\n+  struct mystate state = { 0, 0 };\n+ \n+  lbstate = backtrace_create_state (NULL, 1, error_callback, NULL);\n \n-  if (state->direct_output)\n+  if (!BACKTRACE_SUPPORTED || (in_signal_handler && BACKTRACE_USES_MALLOC))\n     {\n-      bt_header(state->frame_number);\n-      st_printf (\"%p\\n\", (void*) ip);\n+      /* If symbolic backtrace is not supported on this target, or would\n+\t require malloc() and we are in a signal handler, go with a\n+\t simple backtrace.  */\n+\n+      backtrace_simple (lbstate, 0, simple_callback, error_callback, &state);\n     }\n   else\n     {\n-      char addr_buf[GFC_XTOA_BUF_SIZE], func[1024], file[PATH_MAX];\n-      char *p;\n-      const char* addr = gfc_xtoa (ip, addr_buf, sizeof (addr_buf));\n-      write (state->outfd, addr, strlen (addr));\n-      write (state->outfd, \"\\n\", 1);\n-\n-      if (! fd_gets (func, sizeof(func), state->infd))\n-\t{\n-\t  state->error = 1;\n-\t  goto done;\n-\t}\n-      if (! fd_gets (file, sizeof(file), state->infd))\n-\t{\n-\t  state->error = 1;\n-\t  goto done;\n-\t}\n-\t    \n-\tfor (p = func; *p != '\\n' && *p != '\\r'; p++)\n-\t  ;\n-\t*p = '\\0';\n-\t\n-\t/* _start is a setup routine that calls main(), and main() is\n-\t   the frontend routine that calls some setup stuff and then\n-\t   calls MAIN__, so at this point we should stop.  */\n-\tif (strcmp (func, \"_start\") == 0 || strcmp (func, \"main\") == 0)\n-\t  return _URC_END_OF_STACK;\n-\t\n-\tbt_header (state->frame_number);\n-\testr_write (\"0x\");\n-\testr_write (addr);\n-\n-\tif (func[0] != '?' && func[1] != '?')\n-\t  {\n-\t    estr_write (\" in \");\n-\t    estr_write (func);\n-\t  }\n-\t\n-\tif (strncmp (file, \"??\", 2) == 0)\n-\t  estr_write (\"\\n\");\n-\telse\n-\t  {\n-\t    estr_write (\" at \");\n-\t    estr_write (file);\n-\t  }\n+      /* libbacktrace uses mmap, which is safe to call from a signal handler\n+\t (in practice, if not in theory).  Thus we can generate a symbolic\n+\t backtrace, if debug symbols are available.  */\n+\n+      backtrace_full (lbstate, 0, full_callback, error_callback, &state);\n+      if (state.try_simple)\n+\tbacktrace_simple (lbstate, 0, simple_callback, error_callback, &state);\n     }\n+}\n \n- done:\n \n-  state->frame_number++;\n-  \n-  return _URC_NO_REASON;\n-}\n \n+/* Function called by the front-end translating the BACKTRACE intrinsic.  */\n \n-/* Display the backtrace.  */\n+extern void backtrace (void);\n+export_proto (backtrace);\n \n void\n backtrace (void)\n {\n-  bt_state state;\n-  state.frame_number = 0;\n-  state.error = 0;\n-\n-#if CAN_PIPE\n-\n-  if (addr2line_path == NULL)\n-    goto fallback_noerr;\n-\n-  /* We attempt to extract file and line information from addr2line.  */\n-  do\n-  {\n-    /* Local variables.  */\n-    int f[2], pid, inp[2];\n-\n-    /* Don't output an error message if something goes wrong, we'll simply\n-       fall back to printing the addresses.  */\n-    if (pipe (f) != 0)\n-      break;\n-    if (pipe (inp) != 0)\n-      break;\n-    if ((pid = fork ()) == -1)\n-      break;\n-\n-    if (pid == 0)\n-      {\n-\t/* Child process.  */\n-#define NUM_FIXEDARGS 7\n-\tchar *arg[NUM_FIXEDARGS];\n-\tchar *newenv[] = { NULL };\n-\n-\tclose (f[0]);\n-\n-\tclose (inp[1]);\n-\tif (dup2 (inp[0], STDIN_FILENO) == -1)\n-\t  _exit (1);\n-\tclose (inp[0]);\n-\n-\tclose (STDERR_FILENO);\n-\n-\tif (dup2 (f[1], STDOUT_FILENO) == -1)\n-\t  _exit (1);\n-\tclose (f[1]);\n-\n-\targ[0] = addr2line_path;\n-\targ[1] = (char *) \"-e\";\n-\targ[2] = full_exe_path ();\n-\targ[3] = (char *) \"-f\";\n-\targ[4] = (char *) \"-s\";\n-\targ[5] = (char *) \"-C\";\n-\targ[6] = NULL;\n-\texecve (addr2line_path, arg, newenv);\n-\t_exit (1);\n-#undef NUM_FIXEDARGS\n-      }\n-\n-    /* Father process.  */\n-    close (f[1]);\n-    close (inp[0]);\n-\n-    state.outfd = inp[1];\n-    state.infd = f[0];\n-    state.direct_output = 0;\n-    _Unwind_Backtrace (trace_function, &state);\n-    if (state.error)\n-      goto fallback;\n-    close (inp[1]);\n-    close (f[0]);\n-    wait (NULL);\n-    return;\n-\n-fallback:\n-    estr_write (\"** Something went wrong while running addr2line. **\\n\"\n-\t\t\"** Falling back to a simpler backtrace scheme. **\\n\");\n-  }\n-  while (0);\n-\n-fallback_noerr:\n-#endif /* CAN_PIPE */\n-\n-  /* Fallback to the simple backtrace without addr2line.  */\n-  state.direct_output = 1;\n-  _Unwind_Backtrace (trace_function, &state);\n+  show_backtrace (0);\n }\n-iexport(backtrace);\n+"}, {"sha": "f44256b43b425e899b4f7cbc18e2cf754921d7ec", "filename": "libgfortran/runtime/compile_options.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Fcompile_options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Fcompile_options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fcompile_options.c?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -30,7 +30,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n compile_options_t compile_options;\n \n #ifndef LIBGFOR_MINIMAL\n-volatile sig_atomic_t fatal_error_in_progress = 0;\n+static volatile sig_atomic_t fatal_error_in_progress = 0;\n \n \n /* Helper function for backtrace_handler to write information about the\n@@ -126,7 +126,7 @@ backtrace_handler (int signum)\n \n   show_signal (signum);\n   estr_write (\"\\nBacktrace for this error:\\n\");\n-  backtrace ();\n+  show_backtrace (1);\n \n   /* Now reraise the signal.  We reactivate the signal's\n      default handling, which is to terminate the process.\n@@ -136,16 +136,6 @@ backtrace_handler (int signum)\n   signal (signum, SIG_DFL);\n   raise (signum);\n }\n-\n-\n-/* Helper function for set_options because we need to access the\n-   global variable options which is not seen in set_options.  */\n-static void\n-maybe_find_addr2line (void)\n-{\n-  if (options.backtrace == -1)\n-    find_addr2line ();\n-}\n #endif\n \n /* Set the usual compile-time options.  */\n@@ -211,8 +201,6 @@ set_options (int num, int options[])\n #if defined(SIGXFSZ)\n       signal (SIGXFSZ, backtrace_handler);\n #endif\n-\n-      maybe_find_addr2line ();\n     }\n #endif\n }"}, {"sha": "9eb07645411ab7f6857bd113b42838b62d013249", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -173,7 +173,7 @@ sys_abort (void)\n       || (options.backtrace == -1 && compile_options.backtrace == 1))\n     {\n       estr_write (\"\\nProgram aborted. Backtrace:\\n\");\n-      backtrace ();\n+      show_backtrace (0);\n       signal (SIGABRT, SIG_DFL);\n     }\n "}, {"sha": "ecb613dc91d3d31ff3254056acd3564a9200c137", "filename": "libgfortran/runtime/main.c", "status": "modified", "additions": 4, "deletions": 162, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmain.c?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -70,162 +70,13 @@ determine_endianness (void)\n static int argc_save;\n static char **argv_save;\n \n-static const char *exe_path;\n-static bool please_free_exe_path_when_done;\n \n-/* Save the path under which the program was called, for use in the\n-   backtrace routines.  */\n void\n-store_exe_path (const char * argv0)\n+store_exe_path (const char * argv0 __attribute__ ((unused)))\n {\n-#ifndef DIR_SEPARATOR   \n-#define DIR_SEPARATOR '/'\n-#endif\n-\n-  char *cwd, *path;\n-\n-  /* This can only happen if store_exe_path is called multiple times.  */\n-  if (please_free_exe_path_when_done)\n-    free ((char *) exe_path);\n-\n-  /* Reading the /proc/self/exe symlink is Linux-specific(?), but if\n-     it works it gives the correct answer.  */\n-#ifdef HAVE_READLINK\n-  ssize_t len, psize = 256;\n-  while (1)\n-    {\n-      path = xmalloc (psize);\n-      len = readlink (\"/proc/self/exe\", path, psize);\n-      if (len < 0)\n-\t{\n-\t  free (path);\n-\t  break;\n-\t}\n-      else if (len < psize)\n-\t{\n-\t  path[len] = '\\0';\n-\t  exe_path = strdup (path);\n-\t  free (path);\n-\t  please_free_exe_path_when_done = true;\n-\t  return;\n-\t}\n-      /* The remaining option is len == psize.  */\n-      free (path);\n-      psize *= 4;\n-    }\n-#endif\n-\n-  /* If the path is absolute or on a simulator where argv is not set.  */\n-#ifdef __MINGW32__\n-  if (argv0 == NULL\n-      || ('A' <= argv0[0] && argv0[0] <= 'Z' && argv0[1] == ':')\n-      || ('a' <= argv0[0] && argv0[0] <= 'z' && argv0[1] == ':')\n-      || (argv0[0] == '/' && argv0[1] == '/')\n-      || (argv0[0] == '\\\\' && argv0[1] == '\\\\'))\n-#else\n-  if (argv0 == NULL || argv0[0] == DIR_SEPARATOR)\n-#endif\n-    {\n-      exe_path = argv0;\n-      please_free_exe_path_when_done = false;\n-      return;\n-    }\n-\n-#ifdef HAVE_GETCWD\n-  size_t cwdsize = 256;\n-  while (1)\n-    {\n-      cwd = xmalloc (cwdsize);\n-      if (getcwd (cwd, cwdsize))\n-\tbreak;\n-      else if (errno == ERANGE)\n-\t{\n-\t  free (cwd);\n-\t  cwdsize *= 4;\n-\t}\n-      else\n-\t{\n-\t  free (cwd);\n-\t  cwd = NULL;\n-\t  break;\n-\t}\n-    }\n-#else\n-  cwd = NULL;\n-#endif\n-\n-  if (!cwd)\n-    {\n-      exe_path = argv0;\n-      please_free_exe_path_when_done = false;\n-      return;\n-    }\n-\n-  /* exe_path will be cwd + \"/\" + argv[0] + \"\\0\".  This will not work\n-     if the executable is not in the cwd, but at this point we're out\n-     of better ideas.  */\n-  size_t pathlen = strlen (cwd) + 1 + strlen (argv0) + 1;\n-  path = xmalloc (pathlen);\n-  snprintf (path, pathlen, \"%s%c%s\", cwd, DIR_SEPARATOR, argv0);\n-  free (cwd);\n-  exe_path = path;\n-  please_free_exe_path_when_done = true;\n-}\n-\n-\n-/* Return the full path of the executable.  */\n-char *\n-full_exe_path (void)\n-{\n-  return (char *) exe_path;\n-}\n-\n-\n-#ifndef HAVE_STRTOK_R\n-static char*\n-gfstrtok_r (char *str, const char *delim, \n-\t    char **saveptr __attribute__ ((unused)))\n-{\n-  return strtok (str, delim);\n-}\n-#define strtok_r gfstrtok_r\n-#endif\n-\n-char *addr2line_path;\n-\n-/* Find addr2line and store the path.  */\n-\n-void\n-find_addr2line (void)\n-{\n-#ifdef HAVE_ACCESS\n-#define A2L_LEN 11\n-  char *path = secure_getenv (\"PATH\");\n-  if (!path)\n-    return;\n-  char *tp = strdup (path);\n-  if (!tp)\n-    return;\n-  size_t n = strlen (path);\n-  char *ap = xmalloc (n + A2L_LEN);\n-  char *saveptr;\n-  for (char *str = tp;; str = NULL)\n-    {\n-      char *token = strtok_r (str, \":\", &saveptr);\n-      if (!token)\n-\tbreak;\n-      size_t toklen = strlen (token);\n-      memcpy (ap, token, toklen);\n-      memcpy (ap + toklen, \"/addr2line\", A2L_LEN);\n-      if (access (ap, R_OK|X_OK) == 0)\n-\t{\n-\t  addr2line_path = strdup (ap);\n-\t  break;\n-\t}\n-    }\n-  free (tp);\n-  free (ap);\n-#endif\n+  /* This function is now useless, but is retained due to ABI compatibility.\n+    Remove when bumping the library ABI.  */\n+  ;\n }\n \n \n@@ -236,7 +87,6 @@ set_args (int argc, char **argv)\n {\n   argc_save = argc;\n   argv_save = argv;\n-  store_exe_path (argv[0]);\n }\n iexport(set_args);\n \n@@ -279,9 +129,6 @@ init (void)\n   /* if (argc > 1 && strcmp(argv[1], \"--resume\") == 0) resume();  */\n #endif\n \n-  if (options.backtrace == 1)\n-    find_addr2line ();\n-\n   random_seed_i4 (NULL, NULL, NULL);\n }\n \n@@ -292,9 +139,4 @@ static void __attribute__((destructor))\n cleanup (void)\n {\n   close_units ();\n-  \n-  if (please_free_exe_path_when_done)\n-    free ((char *) exe_path);\n-\n-  free (addr2line_path);\n }"}, {"sha": "693d748222bf2cf669732bf717c168eae999f6d8", "filename": "libgfortran/runtime/minimal.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Fminimal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad4f95e395b752371643327c1fdf71fac70de526/libgfortran%2Fruntime%2Fminimal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fminimal.c?ref=ad4f95e395b752371643327c1fdf71fac70de526", "patch": "@@ -53,8 +53,6 @@ int big_endian = 0;\n static int argc_save;\n static char **argv_save;\n \n-static const char *exe_path;\n-\n /* recursion_check()-- It's possible for additional errors to occur\n  * during fatal error processing.  We detect this condition here and\n  * exit with code 4 immediately. */\n@@ -163,22 +161,13 @@ internal_error (st_parameter_common *cmp, const char *message)\n }\n \n \n-/* Return the full path of the executable.  */\n-char *\n-full_exe_path (void)\n-{\n-  return (char *) exe_path;\n-}\n-\n-\n /* Set the saved values of the command line arguments.  */\n \n void\n set_args (int argc, char **argv)\n {\n   argc_save = argc;\n   argv_save = argv;\n-  exe_path = argv[0];\n }\n iexport(set_args);\n "}]}