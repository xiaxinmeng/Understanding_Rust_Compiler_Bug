{"sha": "482829acf2c9c685445ef08f6e1300898e1f2468", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgyODI5YWNmMmM5YzY4NTQ0NWVmMDhmNmUxMzAwODk4ZTFmMjQ2OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-25T17:21:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-25T17:21:28Z"}, "message": "Use backend interface for function types.\n\nDrop type_tree() functions for Float_type and Complex_type.\nDon't define builtin functions until gogo is created.\n\n\t* go-gcc.cc (Gcc_backend::error_type): Implement.\n\t(Gcc_backend::string_type): Remove.\n\t(Gcc_backend::function_type): Change signature and implement.\n\t(Gcc_backend::struct_type): Change signature.\n\t(Gcc_backend::slice_type, Gcc_backend::map_type): Remove.\n\t(Gcc_backend::channel_type, Gcc_backend::interface_type): Remove.\n\t(Gcc_backend::pointer_type): Check for error.\n\t* Make-lang.in (go/types.o): Depend on go/gofrontend/backend.h.\n\nFrom-SVN: r172932", "tree": {"sha": "f38009e3762666720c9319813b80afdda98236a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f38009e3762666720c9319813b80afdda98236a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/482829acf2c9c685445ef08f6e1300898e1f2468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482829acf2c9c685445ef08f6e1300898e1f2468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/482829acf2c9c685445ef08f6e1300898e1f2468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482829acf2c9c685445ef08f6e1300898e1f2468/comments", "author": null, "committer": null, "parents": [{"sha": "0aa5e7f22a2ba320a7ccf0669e9549466d83905c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aa5e7f22a2ba320a7ccf0669e9549466d83905c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aa5e7f22a2ba320a7ccf0669e9549466d83905c"}], "stats": {"total": 350, "additions": 178, "deletions": 172}, "files": [{"sha": "9ed4e47c7cbfb9962cbf3beec2016387c5b691c0", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -1,3 +1,14 @@\n+2011-04-25  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::error_type): Implement.\n+\t(Gcc_backend::string_type): Remove.\n+\t(Gcc_backend::function_type): Change signature and implement.\n+\t(Gcc_backend::struct_type): Change signature.\n+\t(Gcc_backend::slice_type, Gcc_backend::map_type): Remove.\n+\t(Gcc_backend::channel_type, Gcc_backend::interface_type): Remove.\n+\t(Gcc_backend::pointer_type): Check for error.\n+\t* Make-lang.in (go/types.o): Depend on go/gofrontend/backend.h.\n+\n 2011-04-25  Evan Shaw  <edsrzf@gmail.com>\n \n \t* go-gcc.c (class Gcc_tree): Make get_tree const."}, {"sha": "8b52cf23df0c3dd2808573cf6dbf4b8b5e7742d7", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -287,6 +287,7 @@ go/statements.o: go/gofrontend/statements.cc $(GO_SYSTEM_H) \\\n go/types.o: go/gofrontend/types.cc $(GO_SYSTEM_H) $(TOPLEV_H) intl.h $(TREE_H) \\\n \t$(GIMPLE_H) $(REAL_H) convert.h $(GO_C_H) $(GO_GOGO_H) \\\n \tgo/gofrontend/operator.h $(GO_EXPRESSIONS_H) $(GO_STATEMENTS_H) \\\n-\tgo/gofrontend/export.h $(GO_IMPORT_H) $(GO_TYPES_H)\n+\tgo/gofrontend/export.h $(GO_IMPORT_H) go/gofrontend/backend.h \\\n+\t$(GO_TYPES_H)\n go/unsafe.o: go/gofrontend/unsafe.cc $(GO_SYSTEM_H) $(GO_C_H) $(GO_TYPES_H) \\\n \t$(GO_GOGO_H)"}, {"sha": "d250646ecda24e2772810c28bebc9b73bafd1597", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 86, "deletions": 30, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -129,7 +129,7 @@ class Gcc_backend : public Backend\n \n   Btype*\n   error_type()\n-  { gcc_unreachable(); }\n+  { return this->make_type(error_mark_node); }\n \n   Btype*\n   void_type()\n@@ -149,43 +149,22 @@ class Gcc_backend : public Backend\n   complex_type(int);\n \n   Btype*\n-  string_type()\n-  { gcc_unreachable(); }\n+  pointer_type(Btype*);\n \n   Btype*\n-  pointer_type(const Btype*);\n-\n-  Btype*\n-  function_type(const Function_type*, Btype* /* receiver */,\n-\t\tconst Btypes* /* parameters */,\n-\t\tconst Btypes* /* results */)\n-  { gcc_unreachable(); }\n+  function_type(const Btyped_identifier&,\n+\t\tconst std::vector<Btyped_identifier>&,\n+\t\tconst std::vector<Btyped_identifier>&,\n+\t\tsource_location);\n \n   Btype*\n-  struct_type(const Struct_type*, const Btypes* /* field_types */)\n+  struct_type(const std::vector<Btyped_identifier>&)\n   { gcc_unreachable(); }\n \n   Btype*\n   array_type(const Btype* /* element_type */, const Bexpression* /* length */)\n   { gcc_unreachable(); }\n \n-  Btype*\n-  slice_type(const Btype* /* element_type */)\n-  { gcc_unreachable(); }\n-\n-  Btype*\n-  map_type(const Btype* /* key_type */, const Btype* /* value_type */,\n-\t   source_location)\n-  { gcc_unreachable(); }\n-\n-  Btype*\n-  channel_type(const Btype* /* element_type */)\n-  { gcc_unreachable(); }\n-\n-  Btype*\n-  interface_type(const Interface_type*, const Btypes* /* method_types */)\n-  { gcc_unreachable(); }\n-\n   // Statements.\n \n   Bstatement*\n@@ -387,12 +366,89 @@ Gcc_backend::complex_type(int bits)\n // Get a pointer type.\n \n Btype*\n-Gcc_backend::pointer_type(const Btype* to_type)\n+Gcc_backend::pointer_type(Btype* to_type)\n {\n-  tree type = build_pointer_type(to_type->get_tree());\n+  tree to_type_tree = to_type->get_tree();\n+  if (to_type_tree == error_mark_node)\n+    return this->error_type();\n+  tree type = build_pointer_type(to_type_tree);\n   return this->make_type(type);\n }\n \n+// Make a function type.\n+\n+Btype*\n+Gcc_backend::function_type(const Btyped_identifier& receiver,\n+\t\t\t   const std::vector<Btyped_identifier>& parameters,\n+\t\t\t   const std::vector<Btyped_identifier>& results,\n+\t\t\t   source_location location)\n+{\n+  tree args = NULL_TREE;\n+  tree* pp = &args;\n+  if (receiver.btype != NULL)\n+    {\n+      tree t = receiver.btype->get_tree();\n+      if (t == error_mark_node)\n+\treturn this->error_type();\n+      *pp = tree_cons(NULL_TREE, t, NULL_TREE);\n+      pp = &TREE_CHAIN(*pp);\n+    }\n+\n+  for (std::vector<Btyped_identifier>::const_iterator p = parameters.begin();\n+       p != parameters.end();\n+       ++p)\n+    {\n+      tree t = p->btype->get_tree();\n+      if (t == error_mark_node)\n+\treturn this->error_type();\n+      *pp = tree_cons(NULL_TREE, t, NULL_TREE);\n+      pp = &TREE_CHAIN(*pp);\n+    }\n+\n+  // Varargs is handled entirely at the Go level.  When converted to\n+  // GENERIC functions are not varargs.\n+  *pp = void_list_node;\n+\n+  tree result;\n+  if (results.empty())\n+    result = void_type_node;\n+  else if (results.size() == 1)\n+    result = results.front().btype->get_tree();\n+  else\n+    {\n+      result = make_node(RECORD_TYPE);\n+      tree field_trees = NULL_TREE;\n+      pp = &field_trees;\n+      for (std::vector<Btyped_identifier>::const_iterator p = results.begin();\n+\t   p != results.end();\n+\t   ++p)\n+\t{\n+\t  const std::string name = (p->name.empty()\n+\t\t\t\t    ? \"UNNAMED\"\n+\t\t\t\t    : p->name);\n+\t  tree name_tree = get_identifier_from_string(name);\n+\t  tree field_type_tree = p->btype->get_tree();\n+\t  if (field_type_tree == error_mark_node)\n+\t    return this->error_type();\n+\t  tree field = build_decl(location, FIELD_DECL, name_tree,\n+\t\t\t\t  field_type_tree);\n+\t  DECL_CONTEXT(field) = result;\n+\t  *pp = field;\n+\t  pp = &DECL_CHAIN(field);\n+\t}\n+      TYPE_FIELDS(result) = field_trees;\n+      layout_type(result);\n+    }\n+  if (result == error_mark_node)\n+    return this->error_type();\n+\n+  tree fntype = build_function_type(result, args);\n+  if (fntype == error_mark_node)\n+    return this->error_type();\n+\n+  return this->make_type(build_pointer_type(fntype));\n+}\n+\n // An expression as a statement.\n \n Bstatement*"}, {"sha": "33f4e58595290df9d96b269c9344f6946007d049", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -7,10 +7,6 @@\n #ifndef GO_BACKEND_H\n #define GO_BACKEND_H\n \n-class Function_type;\n-class Struct_type;\n-class Interface_type;\n-\n // Pointers to these types are created by the backend, passed to the\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n@@ -36,9 +32,6 @@ class Bvariable;\n // The backend representation of a label.\n class Blabel;\n \n-// A list of backend types.\n-typedef std::vector<Btype*> Btypes;\n-\n // The backend interface.  This is a pure abstract class that a\n // specific backend will implement.\n \n@@ -47,6 +40,24 @@ class Backend\n  public:\n   virtual ~Backend() { }\n \n+  // Name/type/location.  Used for function parameters, struct fields,\n+  // interface methods.\n+  struct Btyped_identifier\n+  {\n+    std::string name;\n+    Btype* btype;\n+    source_location location;\n+\n+    Btyped_identifier()\n+      : name(), btype(NULL), location(UNKNOWN_LOCATION)\n+    { }\n+\n+    Btyped_identifier(const std::string& a_name, Btype* a_btype,\n+\t\t     source_location a_location)\n+      : name(a_name), btype(a_btype), location(a_location)\n+    { }\n+  };\n+\n   // Types.\n \n   // Produce an error type.  Actually the backend could probably just\n@@ -69,56 +80,36 @@ class Backend\n   virtual Btype*\n   integer_type(bool is_unsigned, int bits) = 0;\n \n-  // Get an unnamed floating point type with the given number of bits.\n+  // Get an unnamed floating point type with the given number of bits\n+  // (32 or 64).\n   virtual Btype*\n   float_type(int bits) = 0;\n \n-  // Get an unnamed complex type with the given number of bits.\n+  // Get an unnamed complex type with the given number of bits (64 or 128).\n   virtual Btype*\n   complex_type(int bits) = 0;\n \n-  // Get the unnamed string type.\n-  virtual Btype*\n-  string_type() = 0;\n-\n   // Get a pointer type.\n   virtual Btype*\n-  pointer_type(const Btype* to_type) = 0;\n+  pointer_type(Btype* to_type) = 0;\n \n   // Get a function type.  The receiver, parameter, and results are\n   // generated from the types in the Function_type.  The Function_type\n   // is provided so that the names are available.\n   virtual Btype*\n-  function_type(const Function_type*, Btype* receiver,\n-\t\tconst Btypes* parameters,\n-\t\tconst Btypes* results) = 0;\n+  function_type(const Btyped_identifier& receiver,\n+\t\tconst std::vector<Btyped_identifier>& parameters,\n+\t\tconst std::vector<Btyped_identifier>& results,\n+\t\tsource_location location) = 0;\n \n-  // Get a struct type.  The Struct_type is provided to get the field\n-  // names.\n+  // Get a struct type.\n   virtual Btype*\n-  struct_type(const Struct_type*, const Btypes* field_types) = 0;\n+  struct_type(const std::vector<Btyped_identifier>& fields) = 0;\n \n   // Get an array type.\n   virtual Btype*\n   array_type(const Btype* element_type, const Bexpression* length) = 0;\n \n-  // Get a slice type.\n-  virtual Btype*\n-  slice_type(const Btype* element_type) = 0;\n-\n-  // Get a map type.\n-  virtual Btype*\n-  map_type(const Btype* key_type, const Btype* value_type, source_location) = 0;\n-\n-  // Get a channel type.\n-  virtual Btype*\n-  channel_type(const Btype* element_type) = 0;\n-\n-  // Get an interface type.  The Interface_type is provided to get the\n-  // method names.\n-  virtual Btype*\n-  interface_type(const Interface_type*, const Btypes* method_types) = 0;\n-\n   // Statements.\n \n   // Create an error statement.  This is used for cases which should"}, {"sha": "3dc344027657c8dfc3182c413bead3d5e4d7ee96", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -31,6 +31,9 @@ go_create_gogo(int int_type_size, int pointer_size)\n   ::gogo = new Gogo(go_get_backend(), int_type_size, pointer_size);\n   if (!unique_prefix.empty())\n     ::gogo->set_unique_prefix(unique_prefix);\n+\n+  // FIXME: This should be in the gcc dependent code.\n+  ::gogo->define_builtin_function_trees();\n }\n \n // Set the unique prefix we use for exported symbols."}, {"sha": "b1ccfc3ae62b8e3cfb4241470727d5a9e9a0fbf4", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -1743,7 +1743,7 @@ go_type_for_mode(enum machine_mode mode, int unsignedp)\n \t    return long_double_type_node;\n \t  return NULL_TREE;\n \t}\n-      return type->float_type()->type_tree();\n+      return type->get_tree(go_get_gogo());\n     }\n   else if (mc == MODE_COMPLEX_FLOAT)\n     {\n@@ -1763,7 +1763,7 @@ go_type_for_mode(enum machine_mode mode, int unsignedp)\n \t    return complex_long_double_type_node;\n \t  return NULL_TREE;\n \t}\n-      return type->complex_type()->type_tree();\n+      return type->get_tree(go_get_gogo());\n     }\n   else\n     return NULL_TREE;"}, {"sha": "c0dd9884a543234552df148bbdbec30e54ae0cac", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -203,8 +203,6 @@ Gogo::Gogo(Backend* backend, int int_type_size, int pointer_size)\n   imag_type->set_is_varargs();\n   imag_type->set_is_builtin();\n   this->globals_->add_function_declaration(\"imag\", NULL, imag_type, loc);\n-\n-  this->define_builtin_function_trees();\n }\n \n // Munge name for use in an error message."}, {"sha": "6a0b994ab60b2301caad7bc08dfcafd433c89d5b", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -439,6 +439,10 @@ class Gogo\n   void\n   write_globals();\n \n+  // Create trees for implicit builtin functions.\n+  void\n+  define_builtin_function_trees();\n+\n   // Build a call to a builtin function.  PDECL should point to a NULL\n   // initialized static pointer which will hold the fndecl.  NAME is\n   // the name of the function.  NARGS is the number of arguments.\n@@ -558,10 +562,6 @@ class Gogo\n   // The stack of functions.\n   typedef std::vector<Open_function> Open_functions;\n \n-  // Create trees for implicit builtin functions.\n-  void\n-  define_builtin_function_trees();\n-\n   // Set up the built-in unsafe package.\n   void\n   import_unsafe(const std::string&, bool is_exported, source_location);"}, {"sha": "6c344cefae9188717a7651d85c4d3d0e4dbdada0", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 42, "deletions": 88, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -850,10 +850,10 @@ Type::get_tree(Gogo* gogo)\n   if (this->is_error_type())\n     return error_mark_node;\n \n-  // To avoid confusing GIMPLE, we need to translate all identical Go\n-  // types to the same GIMPLE type.  We use a hash table to do that.\n-  // There is no need to use the hash table for named types, as named\n-  // types are only identical to themselves.\n+  // To avoid confusing the backend, translate all identical Go types\n+  // to the same backend type.  We use a hash table to do that.  There\n+  // is no need to use the hash table for named types, as named types\n+  // are only identical to themselves.\n \n   std::pair<Type*, tree> val(this, NULL);\n   std::pair<Type_trees::iterator, bool> ins =\n@@ -1802,20 +1802,19 @@ Integer_type::do_hash_for_method(Gogo*) const\n \t  + ((this->is_abstract_ ? 1 : 0) << 9));\n }\n \n-// Get the tree for an Integer_type.\n+// Convert an Integer_type to the backend representation.\n \n tree\n-Integer_type::do_get_tree(Gogo*)\n+Integer_type::do_get_tree(Gogo* gogo)\n {\n   if (this->is_abstract_)\n     {\n       go_assert(saw_errors());\n       return error_mark_node;\n     }\n \n-  // FIXME: GOGO can be NULL when called from go_type_for_size, so call\n-  // go_get_backend() instead of gogo->backend().\n-  Btype* btype = go_get_backend()->integer_type(this->is_unsigned_, this->bits_);\n+  Btype* btype = gogo->backend()->integer_type(this->is_unsigned_,\n+\t\t\t\t\t       this->bits_);\n   return type_to_tree(btype);\n }\n \n@@ -1944,23 +1943,15 @@ Float_type::do_hash_for_method(Gogo*) const\n   return (this->bits_ << 4) + ((this->is_abstract_ ? 1 : 0) << 8);\n }\n \n-// Get a tree without using a Gogo*.\n+// Convert to the backend representation.\n \n tree\n-Float_type::type_tree() const\n+Float_type::do_get_tree(Gogo* gogo)\n {\n-  Btype* btype = go_get_backend()->float_type(this->bits_);\n+  Btype* btype = gogo->backend()->float_type(this->bits_);\n   return type_to_tree(btype);\n }\n \n-// Get a tree.\n-\n-tree\n-Float_type::do_get_tree(Gogo*)\n-{\n-  return this->type_tree();\n-}\n-\n tree\n Float_type::do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n {\n@@ -2089,21 +2080,12 @@ Complex_type::do_hash_for_method(Gogo*) const\n   return (this->bits_ << 4) + ((this->is_abstract_ ? 1 : 0) << 8);\n }\n \n-// Get a tree without using a Gogo*.\n+// Convert to the backend representation.\n \n tree\n-Complex_type::type_tree() const\n+Complex_type::do_get_tree(Gogo* gogo)\n {\n-  Btype* btype = go_get_backend()->complex_type(this->bits_);\n-  return type_to_tree(btype);\n-}\n-\n-// Get a tree.\n-\n-tree\n-Complex_type::do_get_tree(Gogo*)\n-{\n-  return this->type_tree();\n+  return type_to_tree(gogo->backend()->complex_type(this->bits_));\n }\n \n // Zero initializer.\n@@ -2175,8 +2157,8 @@ Type::lookup_complex_type(const char* name)\n \n // Class String_type.\n \n-// Return the tree for String_type.  A string is a struct with two\n-// fields: a pointer to the characters and a length.\n+// Convert String_type to the backend representation.  A string is a\n+// struct with two fields: a pointer to the characters and a length.\n \n tree\n String_type::do_get_tree(Gogo*)\n@@ -2608,83 +2590,55 @@ Function_type::do_hash_for_method(Gogo* gogo) const\n tree\n Function_type::do_get_tree(Gogo* gogo)\n {\n-  tree args = NULL_TREE;\n-  tree* pp = &args;\n-\n+  Backend::Btyped_identifier breceiver;\n   if (this->receiver_ != NULL)\n     {\n-      Type* rtype = this->receiver_->type();\n-      tree ptype = rtype->get_tree(gogo);\n-      if (ptype == error_mark_node)\n-\treturn error_mark_node;\n+      breceiver.name = this->receiver_->name();\n \n       // We always pass the address of the receiver parameter, in\n       // order to make interface calls work with unknown types.\n+      Type* rtype = this->receiver_->type();\n       if (rtype->points_to() == NULL)\n-\tptype = build_pointer_type(ptype);\n-\n-      *pp = tree_cons (NULL_TREE, ptype, NULL_TREE);\n-      pp = &TREE_CHAIN (*pp);\n+\trtype = Type::make_pointer_type(rtype);\n+      breceiver.btype = tree_to_type(rtype->get_tree(gogo));\n+      breceiver.location = this->receiver_->location();\n     }\n \n+  std::vector<Backend::Btyped_identifier> bparameters;\n   if (this->parameters_ != NULL)\n     {\n+      bparameters.resize(this->parameters_->size());\n+      size_t i = 0;\n       for (Typed_identifier_list::const_iterator p = this->parameters_->begin();\n \t   p != this->parameters_->end();\n-\t   ++p)\n+\t   ++p, ++i)\n \t{\n-\t  tree ptype = p->type()->get_tree(gogo);\n-\t  if (ptype == error_mark_node)\n-\t    return error_mark_node;\n-\t  *pp = tree_cons (NULL_TREE, ptype, NULL_TREE);\n-\t  pp = &TREE_CHAIN (*pp);\n+\t  bparameters[i].name = p->name();\n+\t  bparameters[i].btype = tree_to_type(p->type()->get_tree(gogo));\n+\t  bparameters[i].location = p->location();\n \t}\n+      gcc_assert(i == bparameters.size());\n     }\n \n-  // Varargs is handled entirely at the Go level.  At the tree level,\n-  // functions are not varargs.\n-  *pp = void_list_node;\n-\n-  tree result;\n-  if (this->results_ == NULL)\n-    result = void_type_node;\n-  else if (this->results_->size() == 1)\n-    result = this->results_->begin()->type()->get_tree(gogo);\n-  else\n+  std::vector<Backend::Btyped_identifier> bresults;\n+  if (this->results_ != NULL)\n     {\n-      result = make_node(RECORD_TYPE);\n-      tree field_trees = NULL_TREE;\n-      tree* pp = &field_trees;\n+      bresults.resize(this->results_->size());\n+      size_t i = 0;\n       for (Typed_identifier_list::const_iterator p = this->results_->begin();\n \t   p != this->results_->end();\n-\t   ++p)\n+\t   ++p, ++i)\n \t{\n-\t  const std::string name = (p->name().empty()\n-\t\t\t\t    ? \"UNNAMED\"\n-\t\t\t\t    : Gogo::unpack_hidden_name(p->name()));\n-\t  tree name_tree = get_identifier_with_length(name.data(),\n-\t\t\t\t\t\t      name.length());\n-\t  tree field_type_tree = p->type()->get_tree(gogo);\n-\t  if (field_type_tree == error_mark_node)\n-\t    return error_mark_node;\n-\t  tree field = build_decl(this->location_, FIELD_DECL, name_tree,\n-\t\t\t\t  field_type_tree);\n-\t  DECL_CONTEXT(field) = result;\n-\t  *pp = field;\n-\t  pp = &DECL_CHAIN(field);\n+\t  bresults[i].name = p->name();\n+\t  bresults[i].btype = tree_to_type(p->type()->get_tree(gogo));\n+\t  bresults[i].location = p->location();\n \t}\n-      TYPE_FIELDS(result) = field_trees;\n-      layout_type(result);\n+      gcc_assert(i == bresults.size());\n     }\n \n-  if (result == error_mark_node)\n-    return error_mark_node;\n-\n-  tree fntype = build_function_type(result, args);\n-  if (fntype == error_mark_node)\n-    return fntype;\n-\n-  return build_pointer_type(fntype);\n+  Btype* fntype = gogo->backend()->function_type(breceiver, bparameters,\n+\t\t\t\t\t\t bresults, this->location());\n+  return type_to_tree(fntype);\n }\n \n // Functions are initialized to NULL."}, {"sha": "5e6da62e514a1a38b3f299517e95748f63e735f9", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482829acf2c9c685445ef08f6e1300898e1f2468/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=482829acf2c9c685445ef08f6e1300898e1f2468", "patch": "@@ -1396,10 +1396,6 @@ class Float_type : public Type\n   bool\n   is_identical(const Float_type* t) const;\n \n-  // Return a tree for this type without using a Gogo*.\n-  tree\n-  type_tree() const;\n-\n  protected:\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n@@ -1468,10 +1464,6 @@ class Complex_type : public Type\n   bool\n   is_identical(const Complex_type* t) const;\n \n-  // Return a tree for this type without using a Gogo*.\n-  tree\n-  type_tree() const;\n-\n  protected:\n   unsigned int\n   do_hash_for_method(Gogo*) const;"}]}