{"sha": "2c132d34c00cd0783204d45763f37507c6916c37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMxMzJkMzRjMDBjZDA3ODMyMDRkNDU3NjNmMzc1MDdjNjkxNmMzNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-17T16:15:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-17T16:15:29Z"}, "message": "ipa-devirt.c (type_pair, [...]): New types.\n\n\n\t* ipa-devirt.c (type_pair, default_hashset_traits): New types.\n\t(odr_types_equivalent_p): Use pair hash.\n\t(odr_subtypes_equivalent_p): Likewise, do structural compare\n\ton ODR types that may be mismatched.\n\t(warn_odr): Support warning when only one field is given.\n\t(odr_types_equivalent_p): Strenghten comparsions made;\n\tsupport VOIDtype.\n\t(add_type_duplicate): Update VISITED hash set.\n\nFrom-SVN: r215328", "tree": {"sha": "4ef870f270b0fc78fbedf82b5fec71cfca85bca4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ef870f270b0fc78fbedf82b5fec71cfca85bca4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c132d34c00cd0783204d45763f37507c6916c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c132d34c00cd0783204d45763f37507c6916c37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c132d34c00cd0783204d45763f37507c6916c37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c132d34c00cd0783204d45763f37507c6916c37/comments", "author": null, "committer": null, "parents": [{"sha": "366d28eedfd27b69992f6cd3e522a3d0d6870fcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/366d28eedfd27b69992f6cd3e522a3d0d6870fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/366d28eedfd27b69992f6cd3e522a3d0d6870fcb"}], "stats": {"total": 184, "additions": 135, "deletions": 49}, "files": [{"sha": "baed7a31ca9ad6bdc9cbb700e27f3e266eb2d83c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c132d34c00cd0783204d45763f37507c6916c37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c132d34c00cd0783204d45763f37507c6916c37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c132d34c00cd0783204d45763f37507c6916c37", "patch": "@@ -1,3 +1,14 @@\n+2014-09-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (type_pair, default_hashset_traits): New types.\n+\t(odr_types_equivalent_p): Use pair hash.\n+\t(odr_subtypes_equivalent_p): Likewise, do structural compare\n+\ton ODR types that may be mismatched.\n+\t(warn_odr): Support warning when only one field is given.\n+\t(odr_types_equivalent_p): Strenghten comparsions made;\n+\tsupport VOIDtype.\n+\t(add_type_duplicate): Update VISITED hash set.\n+\n 2014-09-17  Sebastian Huber  <sebastian.huber@embedded-brains.de>\n \n \t* config.gcc (*-*-rtems*): Default to 'rtems' thread model."}, {"sha": "1480b29a89f74e1da677df54d37b6f75a02480d0", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 124, "deletions": 49, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c132d34c00cd0783204d45763f37507c6916c37/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c132d34c00cd0783204d45763f37507c6916c37/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=2c132d34c00cd0783204d45763f37507c6916c37", "patch": "@@ -136,8 +136,44 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"hash-map.h\"\n \n+/* Hash based set of pairs of types.  */\n+typedef struct\n+{\n+  tree first;\n+  tree second;\n+} type_pair;\n+\n+struct pair_traits : default_hashset_traits\n+{\n+  static hashval_t\n+  hash (type_pair p)\n+  {\n+    return TYPE_UID (p.first) ^ TYPE_UID (p.second);\n+  }\n+  static bool\n+  is_empty (type_pair p)\n+  {\n+    return p.first == NULL;\n+  }\n+  static bool\n+  is_deleted (type_pair p ATTRIBUTE_UNUSED)\n+    {\n+      return false;\n+    }\n+  static bool\n+  equal (const type_pair &a, const type_pair &b)\n+    {\n+      return a.first==b.first && a.second == b.second;\n+    }\n+  static void\n+  mark_empty (type_pair &e)\n+    {\n+      e.first = NULL;\n+    }\n+};\n+\n static bool odr_types_equivalent_p (tree, tree, bool, bool *,\n-\t\t\t\t    hash_set<tree> *);\n+\t\t\t\t    hash_set<type_pair,pair_traits> *);\n \n static bool odr_violation_reported = false;\n \n@@ -471,7 +507,7 @@ set_type_binfo (tree type, tree binfo)\n /* Compare T2 and T2 based on name or structure.  */\n \n static bool\n-odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<tree> *visited)\n+odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<type_pair,pair_traits> *visited)\n {\n   bool an1, an2;\n \n@@ -489,29 +525,39 @@ odr_subtypes_equivalent_p (tree t1, tree t2, hash_set<tree> *visited)\n   if (an1 != an2 || an1)\n     return false;\n \n-  /* For types where we can not establish ODR equivalency (either by ODR names\n-     or by virtual tables), recurse and deeply compare.  */\n-  if ((!odr_type_p (t1) || !odr_type_p (t2))\n-      && (TREE_CODE (t1) != RECORD_TYPE || TREE_CODE (t2) != RECORD_TYPE\n-          || !TYPE_BINFO (t1) || !TYPE_BINFO (t2)\n-          || !polymorphic_type_binfo_p (TYPE_BINFO (t1))\n-          || !polymorphic_type_binfo_p (TYPE_BINFO (t2))))\n+  /* For ODR types be sure to compare their names.  */\n+  if ((odr_type_p (t1) && !odr_type_p (t2))\n+      || (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE\n+          && TYPE_BINFO (t1) && TYPE_BINFO (t2)\n+          && polymorphic_type_binfo_p (TYPE_BINFO (t1))\n+          && polymorphic_type_binfo_p (TYPE_BINFO (t2))))\n     {\n-      if (TREE_CODE (t1) != TREE_CODE (t2))\n-\treturn false;\n-      if ((TYPE_NAME (t1) == NULL_TREE) != (TYPE_NAME (t2) == NULL_TREE))\n-\treturn false;\n-      if (TYPE_NAME (t1) && DECL_NAME (TYPE_NAME (t1)) != DECL_NAME (TYPE_NAME (t2)))\n-\treturn false;\n-      /* This should really be a pair hash, but for the moment we do not need\n-\t 100% reliability and it would be better to compare all ODR types so\n-\t recursion here is needed only for component types.  */\n-      if (visited->add (t1))\n-\treturn true;\n-      return odr_types_equivalent_p (t1, t2, false, NULL, visited);\n+      if (!types_same_for_odr (t1, t2))\n+        return false;\n+      /* Limit recursion: If subtypes are ODR types and we know\n+         that they are same, be happy.  */\n+      if (!get_odr_type (t1, true)->odr_violated)\n+        return true;\n     }\n \n-  return types_same_for_odr (t1, t2);\n+  /* Component types, builtins and possibly vioalting ODR types\n+     have to be compared structurally.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+  if ((TYPE_NAME (t1) == NULL_TREE) != (TYPE_NAME (t2) == NULL_TREE))\n+    return false;\n+  if (TYPE_NAME (t1) && DECL_NAME (TYPE_NAME (t1)) != DECL_NAME (TYPE_NAME (t2)))\n+    return false;\n+\n+  type_pair pair={t1,t2};\n+  if (TYPE_UID (t1) > TYPE_UID (t2))\n+    {\n+      pair.first = t2;\n+      pair.second = t1;\n+    }\n+  if (visited->add (pair))\n+    return true;\n+  return odr_types_equivalent_p (t1, t2, false, NULL, visited);\n }\n \n /* Compare two virtual tables, PREVAILING and VTABLE and output ODR\n@@ -646,16 +692,25 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n \t\t   \"type %qT violates one definition rule\",\n \t\t   t1))\n     return;\n-  if (!st1)\n+  if (!st1 && !st2)\n     ;\n-  else if (TREE_CODE (st1) == FIELD_DECL)\n+  /* For FIELD_DECL support also case where one of fields is\n+     NULL - this is used when the structures have mismatching number of\n+     elements.  */\n+  else if (!st1 || TREE_CODE (st1) == FIELD_DECL)\n     {\n       inform (DECL_SOURCE_LOCATION (decl2),\n \t      \"a different type is defined in another translation unit\");\n+      if (!st1)\n+\t{\n+\t  st1 = st2;\n+\t  st2 = NULL;\n+\t}\n       inform (DECL_SOURCE_LOCATION (st1),\n \t      \"the first difference of corresponding definitions is field %qD\",\n \t      st1);\n-      decl2 = st2;\n+      if (st2)\n+        decl2 = st2;\n     }\n   else if (TREE_CODE (st1) == FUNCTION_DECL)\n     {\n@@ -710,7 +765,7 @@ warn_types_mismatch (tree t1, tree t2)\n    gimple_canonical_types_compatible_p.  */\n \n static bool\n-odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<tree> *visited)\n+odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<type_pair,pair_traits> *visited)\n {\n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n@@ -834,7 +889,6 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<tree\n \t    }\n \t}\n \n-      /* Tail-recurse to components.  */\n       if ((TREE_CODE (t1) == VECTOR_TYPE || TREE_CODE (t1) == COMPLEX_TYPE)\n \t  && !odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2), visited))\n \t{\n@@ -846,17 +900,9 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<tree\n \t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n \t  return false;\n \t}\n-\n-      gcc_assert (operand_equal_p (TYPE_SIZE (t1), TYPE_SIZE (t2), 0));\n-      gcc_assert (operand_equal_p (TYPE_SIZE_UNIT (t1),\n-\t\t\t\t   TYPE_SIZE_UNIT (t2), 0));\n-      gcc_assert (TYPE_MODE (t1) == TYPE_MODE (t2));\n-\n-      return true;\n     }\n-\n   /* Do type-specific comparisons.  */\n-  switch (TREE_CODE (t1))\n+  else switch (TREE_CODE (t1))\n     {\n     case ARRAY_TYPE:\n       {\n@@ -896,11 +942,8 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<tree\n \t\t\t \"in another translation unit\"));\n \t    return false;\n \t  }\n-\tgcc_assert (operand_equal_p (TYPE_SIZE (t1), TYPE_SIZE (t2), 0));\n-\tgcc_assert (operand_equal_p (TYPE_SIZE_UNIT (t1),\n-\t\t\t\t     TYPE_SIZE_UNIT (t2), 0));\n       }\n-      return true;\n+    break;\n \n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n@@ -1013,9 +1056,20 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<tree\n \t       are not the same.  */\n \t    if (f1 || f2)\n \t      {\n-\t\twarn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t\t\t  G_(\"a type with different number of fields \"\n-\t\t\t     \"is defined in another translation unit\"));\n+\t\tif (f1 && DECL_ARTIFICIAL (f1))\n+\t\t  f1 = NULL;\n+\t\tif (f2 && DECL_ARTIFICIAL (f2))\n+\t\t  f2 = NULL;\n+\t\tif (f1 || f2)\n+\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n+\t\t\t    G_(\"a type with different number of fields \"\n+\t\t\t       \"is defined in another translation unit\"));\n+\t\t/* Ideally we should never get this generic message.  */\n+\t\telse\n+\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n+\t\t\t    G_(\"a type with different memory representation \"\n+\t\t\t       \"is defined in another translation unit\"));\n+\t\t\n \t\treturn false;\n \t      }\n \t    if ((TYPE_MAIN_VARIANT (t1) == t1 || TYPE_MAIN_VARIANT (t2) == t2)\n@@ -1063,17 +1117,38 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned, hash_set<tree\n \t\t    return false;\n \t\t  }\n \t      }\n-\t    gcc_assert (operand_equal_p (TYPE_SIZE (t1), TYPE_SIZE (t2), 0));\n-\t    gcc_assert (operand_equal_p (TYPE_SIZE_UNIT (t1),\n-\t\t\t\t\t TYPE_SIZE_UNIT (t2), 0));\n \t  }\n-\n-\treturn true;\n+\tbreak;\n       }\n+    case VOID_TYPE:\n+      break;\n \n     default:\n+      debug_tree (t1);\n       gcc_unreachable ();\n     }\n+\n+  /* Those are better to come last as they are utterly uninformative.  */\n+  if (TYPE_SIZE (t1) && TYPE_SIZE (t2)\n+      && !operand_equal_p (TYPE_SIZE (t1), TYPE_SIZE (t2), 0))\n+    {\n+      warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\tG_(\"a type with different size \"\n+\t\t   \"is defined in another translation unit\"));\n+      return false;\n+    }\n+  if (COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2)\n+      && TYPE_ALIGN (t1) != TYPE_ALIGN (t2))\n+    {\n+      warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\tG_(\"a type with different alignment \"\n+\t\t   \"is defined in another translation unit\"));\n+      return false;\n+    }\n+  gcc_assert (!TYPE_SIZE_UNIT (t1) || !TYPE_SIZE_UNIT (t2)\n+\t      || operand_equal_p (TYPE_SIZE_UNIT (t1),\n+\t\t\t\t  TYPE_SIZE_UNIT (t2), 0));\n+  return true;\n }\n \n /* TYPE is equivalent to VAL by ODR, but its tree representation differs\n@@ -1106,7 +1181,7 @@ add_type_duplicate (odr_type val, tree type)\n       bool base_mismatch = false;\n       unsigned int i,j;\n       bool warned = false;\n-      hash_set<tree> visited;\n+      hash_set<type_pair,pair_traits> visited;\n \n       gcc_assert (in_lto_p);\n       vec_safe_push (val->types, type);"}]}