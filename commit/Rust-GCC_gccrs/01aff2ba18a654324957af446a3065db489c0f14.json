{"sha": "01aff2ba18a654324957af446a3065db489c0f14", "node_id": "C_kwDOANBUbNoAKDAxYWZmMmJhMThhNjU0MzI0OTU3YWY0NDZhMzA2NWRiNDg5YzBmMTQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-23T20:18:55Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-23T20:18:55Z"}, "message": "c++: context completion in lookup_template_class [PR105982]\n\nThe below testcase demonstrates that completion of the substituted\ncontext during lookup_template_class can end up registering the desired\nspecialization for us in more cases than r13-1045-gcb7fd1ea85feea\nanticipated.  In particular this can happen for a non-dependent\nspecialization of a nested class as well.\n\nFor this testcase, during overload resolution with A's guides, we\nsubstitute the deduced argument T=int into the TYPENAME_TYPE B::C,\nduring which we call lookup_template_class for A<T>::B with T=int,\nwhich completes A<int> for the first time, which recursively registers\nthe desired specialization of B already.  The parent call to\nlookup_template_class then tries to register the same specialization,\ntriggering an ICE.\n\nThis patch fixes this by making lookup_template_class determine more\ndirectly whether we need to recheck the specializations table after\ncompletion of the context -- when and only when the call to complete_type\nhad an effect.\n\n\tPR c++/105982\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (lookup_template_class): After calling complete_type for\n\tthe substituted context, check the table again iff the type was\n\tpreviously incomplete and complete_type made it complete.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/class-deduction111.C: New test.", "tree": {"sha": "d353dc5418891eb6c4b6330339f7c3a0274112ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d353dc5418891eb6c4b6330339f7c3a0274112ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01aff2ba18a654324957af446a3065db489c0f14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01aff2ba18a654324957af446a3065db489c0f14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01aff2ba18a654324957af446a3065db489c0f14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01aff2ba18a654324957af446a3065db489c0f14/comments", "author": null, "committer": null, "parents": [{"sha": "5ee8e1d1b0c0d9f6310d27a37a6162e0be80e413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee8e1d1b0c0d9f6310d27a37a6162e0be80e413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ee8e1d1b0c0d9f6310d27a37a6162e0be80e413"}], "stats": {"total": 31, "additions": 22, "deletions": 9}, "files": [{"sha": "8672da123f4de785fa494aef9871ca2eccc1a18e", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01aff2ba18a654324957af446a3065db489c0f14/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01aff2ba18a654324957af446a3065db489c0f14/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=01aff2ba18a654324957af446a3065db489c0f14", "patch": "@@ -10089,16 +10089,19 @@ lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n \t    {\n \t      context = tsubst_aggr_type (context, arglist,\n \t\t\t\t\t  complain, in_decl, true);\n-\t      context = complete_type (context);\n-\t      if (is_dependent_type && arg_depth > 1)\n+\t      /* Try completing the enclosing context if it's not already so.  */\n+\t      if (context != error_mark_node\n+\t\t  && !COMPLETE_TYPE_P (context))\n \t\t{\n-\t\t  /* If this is a dependent nested specialization such as\n-\t\t     A<T>::B<U> [with T=int, U=U], then completion of A<int>\n-\t\t     could have caused to register the desired specialization\n-\t\t     of B already, so check the table again (33959).  */\n-\t\t  entry = type_specializations->find_with_hash (&elt, hash);\n-\t\t  if (entry)\n-\t\t    return entry->spec;\n+\t\t  context = complete_type (context);\n+\t\t  if (COMPLETE_TYPE_P (context))\n+\t\t    {\n+\t\t      /* Completion could have caused us to register the desired\n+\t\t\t specialization already, so check the table again.  */\n+\t\t      entry = type_specializations->find_with_hash (&elt, hash);\n+\t\t      if (entry)\n+\t\t\treturn entry->spec;\n+\t\t    }\n \t\t}\n \t    }\n \t}"}, {"sha": "2406529ea5aee2af44e20a8557af9100de8fffba", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction111.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01aff2ba18a654324957af446a3065db489c0f14/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction111.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01aff2ba18a654324957af446a3065db489c0f14/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction111.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction111.C?ref=01aff2ba18a654324957af446a3065db489c0f14", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/105982\n+// { dg-do compile { target c++17 } }\n+\n+template<class T>\n+struct A {\n+  struct B { struct C { }; };\n+  A(T, typename B::C);\n+};\n+\n+A a(0, {});"}]}