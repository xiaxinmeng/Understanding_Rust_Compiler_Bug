{"sha": "0f84b066791763e603fa12330f381bef3353d4e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY4NGIwNjY3OTE3NjNlNjAzZmExMjMzMGYzODFiZWYzMzUzZDRlOA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2007-03-09T20:05:08Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2007-03-09T20:05:08Z"}, "message": "re PR tree-optimization/30375 (tree-ssa-dse incorrectly removes struct initialization)\n\n        PR tree-optimization/30375\n        * tree-ssa-dse.c (dse_possible_dead_store_p): Do not eliminate if\n        LHS of statements is not the same.\n        * testsuite/gcc.dg/tree-ssa/ssa-dse-10.c: New.\n\nFrom-SVN: r122758", "tree": {"sha": "c9430a0a92da8d81b5ec3f994b8012825972f9ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9430a0a92da8d81b5ec3f994b8012825972f9ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f84b066791763e603fa12330f381bef3353d4e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f84b066791763e603fa12330f381bef3353d4e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f84b066791763e603fa12330f381bef3353d4e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f84b066791763e603fa12330f381bef3353d4e8/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f868e1cefd522190eeac6c6ad662bfd3a277d21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f868e1cefd522190eeac6c6ad662bfd3a277d21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f868e1cefd522190eeac6c6ad662bfd3a277d21"}], "stats": {"total": 1556, "additions": 1556, "deletions": 0}, "files": [{"sha": "6c69dd38b227182e07117e237269190ccb7f87b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f84b066791763e603fa12330f381bef3353d4e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f84b066791763e603fa12330f381bef3353d4e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f84b066791763e603fa12330f381bef3353d4e8", "patch": "@@ -1,3 +1,10 @@\n+2007-03-09  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        PR tree-optimization/30375\n+        * tree-ssa-dse.c (dse_possible_dead_store_p): Do not eliminate if\n+        LHS of statements is not the same.\n+        * testsuite/gcc.dg/tree-ssa/ssa-dse-10.c: New.\n+\n 2007-03-09  Chao-ying Fu  <fu@mips.com>\n \n \t* doc/extend.texi (MIPS DSP Built-in Functions): Document the DSP"}, {"sha": "d8cfcc7accdde3af26bb994c890c4a0d9898c9e7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-10.c", "status": "added", "additions": 1523, "deletions": 0, "changes": 1523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f84b066791763e603fa12330f381bef3353d4e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f84b066791763e603fa12330f381bef3353d4e8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-10.c?ref=0f84b066791763e603fa12330f381bef3353d4e8", "patch": "@@ -0,0 +1,1523 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -w -fdump-tree-dse-vops\" } */\n+\n+typedef unsigned int size_t;\n+typedef struct _IO_FILE FILE;\n+typedef struct\n+{\n+} __mbstate_t;\n+typedef struct\n+{\n+} _G_fpos_t;\n+typedef struct\n+{\n+};\n+typedef int (*__gconv_trans_fct) (struct __gconv_step *,\n+      size_t *);\n+typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,\n+     size_t *);\n+struct __gconv_trans_data\n+{\n+};\n+struct __gconv_step_data\n+{\n+};\n+typedef struct __gconv_info\n+{\n+} *__gconv_t;\n+typedef union\n+{\n+  struct\n+  {\n+  } __combined;\n+} _G_iconv_t;\n+typedef __builtin_va_list __gnuc_va_list;\n+enum __codecvt_result\n+{\n+  __codecvt_noconv\n+};\n+struct _IO_FILE {\n+};\n+vprintf (__const char *__restrict __fmt, __gnuc_va_list __arg)\n+{\n+}\n+putchar (int __c)\n+{\n+}\n+fputc_unlocked (int __c, FILE *__stream)\n+{\n+}\n+putc_unlocked (int __c, FILE *__stream)\n+{\n+}\n+__attribute__ ((__nothrow__)) ferror_unlocked (FILE *__stream)\n+{\n+}\n+extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,\n+     __gnuc_va_list __ap);\n+gets (char *__str)\n+{\n+}\n+extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,\n+     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));\n+fgets (char *__restrict __s, int __n, FILE *__restrict __stream)\n+{\n+}\n+typedef void *LPVOID;\n+typedef int BOOL, *PBOOL, *LPBOOL;\n+typedef unsigned char BYTE, *PBYTE, *LPBYTE;\n+typedef unsigned short WORD, *PWORD, *LPWORD;\n+typedef unsigned int DWORD, *PDWORD, *LPDWORD;\n+typedef struct _GUID\n+{\n+} GUID;\n+enum\n+{\n+  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),\n+};\n+extern char *__strtok_r (char *__restrict __s,\n+    __const char *__restrict __delim,\n+         char **__restrict __save_ptr)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2, 3)));\n+__strcspn_c3 (__const char *__s, int __reject1, int __reject2,\n+       int __reject3)\n+{\n+}\n+extern __inline size_t __strspn_c3 (__const char *__s, int __accept1,\n+        int __accept2, int __accept3);\n+extern __inline size_t\n+__strspn_c3 (__const char *__s, int __accept1, int __accept2, int __accept3)\n+{\n+}\n+extern __inline char *__strpbrk_c2 (__const char *__s, int __accept1,\n+         int __accept2);\n+extern __inline char *\n+__strpbrk_c2 (__const char *__s, int __accept1, int __accept2)\n+{\n+}\n+extern __inline char *__strpbrk_c3 (__const char *__s, int __accept1,\n+       int __accept3)\n+{\n+}\n+__strtok_r_1c (char *__s, char __sep, char **__nextp)\n+{\n+    {\n+   {\n+   }\n+    }\n+}\n+__strsep_1c (char **__s, char __reject)\n+{\n+}\n+__strsep_2c (char **__s, char __reject1, char __reject2)\n+{\n+    {\n+ {\n+ }\n+    }\n+}\n+extern __inline char *__strsep_3c (char **__s, char __reject1, char __reject2,\n+       char __reject3);\n+extern __inline char *\n+__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)\n+{\n+    {\n+ {\n+     {\n+     }\n+ }\n+    }\n+}\n+__attribute__ ((__nothrow__)) __memcpy_ichk (void *__restrict __dest, __const void *__restrict __src, size_t __len)\n+{\n+}\n+__attribute__ ((__nothrow__)) __memmove_ichk (void *__dest, __const void *__src, size_t __len)\n+{\n+}\n+__attribute__ ((__nothrow__)) __strncpy_ichk (char *__restrict __dest, __const char *__restrict __src, size_t __len)\n+{\n+}\n+__attribute__ ((__nothrow__)) stpncpy (char *__dest, __const char *__src, size_t __n)\n+{\n+  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1\n+      && (!__builtin_constant_p (__n) || __n <= __builtin_object_size (__dest, 2 > 1)))\n+    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));\n+}\n+__attribute__ ((__nothrow__)) __strncat_ichk (char *__restrict __dest, __const char *__restrict __src, size_t __len)\n+{\n+}\n+typedef void *PVOID;\n+typedef char CHAR, *PCHAR;\n+typedef int LONG, *PLONG;\n+typedef unsigned short WCHAR, *PWCHAR;\n+typedef CHAR *PSTR, *LPSTR, *NPSTR;\n+typedef const CHAR *PCSTR, *LPCSTR;\n+typedef WCHAR *PWSTR, *LPWSTR, *NWPSTR;\n+typedef LONG HRESULT;\n+typedef struct _MEMORY_BASIC_INFORMATION\n+{\n+} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;\n+typedef enum _HEAP_INFORMATION_CLASS {\n+    HeapCompatibilityInformation,\n+} HEAP_INFORMATION_CLASS;\n+typedef struct _FLOATING_SAVE_AREA\n+{\n+} CONTEXT86;\n+typedef struct _LDT_ENTRY {\n+    union {\n+        struct {\n+        } Bits;\n+    } HighWord;\n+} LDT_ENTRY, *PLDT_ENTRY;\n+typedef struct _EXCEPTION_RECORD\n+{\n+} EXCEPTION_RECORD, *PEXCEPTION_RECORD;\n+typedef struct _EXCEPTION_POINTERS\n+{\n+} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;\n+typedef struct _NT_TIB\n+{\n+ union {\n+ } ;\n+} NT_TIB, *PNT_TIB;\n+extern inline struct _TEB * __attribute__((__stdcall__)) NtCurrentTeb(void)\n+{\n+} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n+typedef struct _IMAGE_SYMBOL {\n+    union {\n+        struct {\n+        } FcnAry;\n+    } Section;\n+} IMAGE_AUX_SYMBOL;\n+typedef struct _IMAGE_EXPORT_DIRECTORY {\n+ union {\n+ } u1;\n+} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;\n+typedef struct _IMAGE_BASE_RELOCATION\n+{\n+} IMAGE_BASE_RELOCATION,*PIMAGE_BASE_RELOCATION;\n+typedef struct _IMAGE_RELOCATION\n+{\n+    union {\n+    } ;\n+} IMAGE_RELOCATION, *PIMAGE_RELOCATION;\n+typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER\n+{\n+} IMAGE_RESOURCE_DIRECTORY,*PIMAGE_RESOURCE_DIRECTORY;\n+typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {\n+ union {\n+  struct {\n+  } ;\n+                struct {\n+  } ;\n+ } ;\n+} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;\n+typedef enum ReplacesCorHdrNumericDefines\n+{\n+    MAX_PACKAGE_NAME = 1024,\n+} ReplacesCorHdrNumericDefines;\n+typedef struct IMAGE_COR20_HEADER\n+{\n+} MESSAGE_RESOURCE_DATA,*PMESSAGE_RESOURCE_DATA;\n+typedef PVOID PSECURITY_DESCRIPTOR;\n+typedef enum _TOKEN_INFORMATION_CLASS {\n+  TokenUser = 1,\n+} TOKEN_INFORMATION_CLASS;\n+typedef struct _GENERIC_MAPPING {\n+} ACL, *PACL;\n+typedef struct _ACL_SIZE_INFORMATION\n+{\n+} ACL_SIZE_INFORMATION, *PACL_SIZE_INFORMATION;\n+typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;\n+typedef struct {\n+} SID_AND_ATTRIBUTES;\n+typedef enum {\n+    WinBuiltinTerminalServerLicenseServersSid = 60\n+} WELL_KNOWN_SID_TYPE;\n+typedef struct _TOKEN_USER {\n+} TOKEN_GROUPS, *PTOKEN_GROUPS;\n+typedef union _LARGE_INTEGER {\n+    struct {\n+    };\n+} LARGE_INTEGER, *PLARGE_INTEGER;\n+typedef union _ULARGE_INTEGER {\n+    struct {\n+    };\n+} LUID, *PLUID;\n+typedef struct _LUID_AND_ATTRIBUTES {\n+} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;\n+typedef enum tagTOKEN_TYPE {\n+  TokenPrimary = 1,\n+} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL;\n+typedef struct _SECURITY_QUALITY_OF_SERVICE {\n+} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;\n+typedef enum _LATENCY_TIME {\n+        VerifyProcessorPowerPolicyDc,\n+} POWER_INFORMATION_LEVEL;\n+typedef struct _ADMINISTRATOR_POWER_POLICY {\n+} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;\n+typedef struct _RTL_CRITICAL_SECTION {\n+} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;\n+typedef struct _IO_COUNTERS {\n+} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;\n+typedef struct {\n+} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;\n+typedef struct {\n+} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;\n+typedef struct {\n+} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;\n+typedef struct tagSIZE\n+{\n+} POINT, *PPOINT, *LPPOINT;\n+typedef struct _POINTL\n+{\n+} FILETIME, *PFILETIME, *LPFILETIME;\n+typedef struct tagRECT\n+{\n+  } ldiv_t;\n+extern double strtod (__const char *__restrict __nptr,\n+        char **__restrict __endptr)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));\n+extern long int strtol (__const char *__restrict __nptr,\n+   char **__restrict __endptr, int __base)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));\n+extern long int __strtol_internal (__const char *__restrict __nptr,\n+       int __base, int __group)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));\n+extern unsigned long int __strtoul_internal (__const char *__restrict __nptr,\n+          int __base, int __group)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));\n+extern __inline double\n+__attribute__ ((__nothrow__)) strtod (__const char *__restrict __nptr, char **__restrict __endptr)\n+{\n+}\n+extern __inline long int\n+__attribute__ ((__nothrow__)) strtol (__const char *__restrict __nptr, char **__restrict __endptr, int __base)\n+{\n+}\n+__attribute__ ((__nothrow__)) strtoll (__const char *__restrict __nptr, char **__restrict __endptr, int __base)\n+{\n+}\n+__attribute__ ((__nothrow__)) atoi (__const char *__nptr)\n+{\n+}\n+typedef int int32_t __attribute__ ((__mode__ (__SI__)));\n+typedef struct\n+  {\n+  };\n+extern int random_r (struct random_data *__restrict __buf,\n+       int32_t *__restrict __result) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));\n+struct drand48_data\n+  {\n+  };\n+extern int drand48_r (struct drand48_data *__restrict __buffer,\n+        long int *__restrict __result)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));\n+extern int mrand48_r (struct drand48_data *__restrict __buffer,\n+        long int *__restrict __result)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));\n+extern int jrand48_r (unsigned short int __xsubi[3],\n+        long int *__restrict __result)\n+     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (2)));\n+extern int seed48_r (unsigned short int __seed16v[3],\n+       struct drand48_data *__buffer) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));\n+extern char *qfcvt (long double __value, int __ndigit,\n+        size_t __resolvedlen) __attribute__ ((__nothrow__)) __attribute__ ((__warn_unused_result__));\n+__attribute__ ((__nothrow__)) realpath (__const char *__restrict __name, char *__restrict __resolved)\n+{\n+}\n+__attribute__ ((__nothrow__)) ptsname_r (int __fd, char *__buf, size_t __buflen)\n+{\n+}\n+typedef struct _EXCEPTION_DEBUG_INFO {\n+} EXCEPTION_DEBUG_INFO;\n+typedef struct _CREATE_THREAD_DEBUG_INFO {\n+} CREATE_THREAD_DEBUG_INFO;\n+typedef struct _CREATE_PROCESS_DEBUG_INFO {\n+} CREATE_PROCESS_DEBUG_INFO;\n+typedef struct _EXIT_THREAD_DEBUG_INFO {\n+} LOAD_DLL_DEBUG_INFO;\n+typedef struct _UNLOAD_DLL_DEBUG_INFO {\n+} RIP_INFO;\n+typedef struct _DEBUG_EVENT {\n+    union {\n+    } u;\n+} DEBUG_EVENT, *LPDEBUG_EVENT;\n+typedef struct _OFSTRUCT\n+{\n+} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;\n+typedef struct _WIN32_FIND_DATAW\n+{\n+} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;\n+typedef enum _FINDEX_SEARCH_OPS\n+{\n+ FindExSearchNameMatch,\n+} FINDEX_SEARCH_OPS;\n+typedef struct _PROCESS_HEAP_ENTRY\n+{\n+    union {\n+        struct {\n+        } Block;\n+        struct {\n+        } Region;\n+    } ;\n+} PROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY;\n+typedef struct tagMEMORYSTATUS\n+{\n+} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;\n+typedef struct _SYSTEMTIME{\n+        WORD wYear;\n+} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;\n+typedef struct _OVERLAPPED {\n+        union {\n+            struct {\n+            } ;\n+        } ;\n+} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;\n+typedef struct _TIME_ZONE_INFORMATION{\n+} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;\n+typedef struct _BY_HANDLE_FILE_INFORMATION\n+{\n+} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;\n+typedef struct tagACTCTX_SECTION_KEYED_DATA {\n+} COMMTIMEOUTS,*LPCOMMTIMEOUTS;\n+typedef enum _COMPUTER_NAME_FORMAT\n+{\n+ ComputerNameNetBIOS,\n+} COMPUTER_NAME_FORMAT;\n+typedef struct tagHW_PROFILE_INFOA {\n+} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;\n+typedef struct tagHW_PROFILE_INFOW {\n+} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;\n+BOOL __attribute__((__stdcall__)) SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR,SECURITY_DESCRIPTOR_CONTROL,\n+                                                SECURITY_DESCRIPTOR_CONTROL);\n+typedef struct tagSYSLEVEL\n+{\n+} SYSLEVEL;\n+static inline PVOID __attribute__((__stdcall__)) InterlockedCompareExchangePointer( PVOID volatile *dest, PVOID xchg, PVOID compare )\n+{\n+}\n+static inline PVOID __attribute__((__stdcall__)) InterlockedExchangePointer( PVOID volatile *dest, PVOID val )\n+{\n+}\n+typedef unsigned long HCRYPTPROV;\n+typedef unsigned long HCRYPTKEY;\n+typedef void *HCERTSTOREPROV;\n+typedef struct _PROV_ENUMALGS {\n+} PROV_ENUMALGS;\n+typedef struct _HMAC_INFO {\n+} HMAC_INFO, *PHMAC_INFO;\n+typedef struct _CRYPTOAPI_BLOB {\n+  DWORD cbData;\n+  BYTE* pbData;\n+} CRYPT_INTEGER_BLOB, *PCRYPT_INTEGER_BLOB,\n+  CRYPT_OBJID_BLOB, *PCRYPT_OBJID_BLOB,\n+  CERT_NAME_BLOB, *PCERT_NAME_BLOB,\n+  CERT_RDN_VALUE_BLOB, *PCERT_RDN_VALUE_BLOB,\n+  CRYPT_DER_BLOB, *PCRYPT_DER_BLOB,\n+  CRYPT_ATTR_BLOB, *PCRYPT_ATTR_BLOB;\n+typedef struct _CRYPTPROTECT_PROMPTSTRUCT{\n+} CRYPTPROTECT_PROMPTSTRUCT, *PCRYPTPROTECT_PROMPTSTRUCT;\n+typedef struct _CRYPT_ALGORITHM_IDENTIFIER {\n+  LPSTR pszObjId;\n+  CRYPT_OBJID_BLOB Parameters;\n+} CRYPT_ALGORITHM_IDENTIFIER, *PCRYPT_ALGORITHM_IDENTIFIER;\n+typedef struct _CRYPT_ATTRIBUTE_TYPE_VALUE {\n+} CRYPT_ATTRIBUTE_TYPE_VALUE, *PCRYPT_ATTRIBUTE_TYPE_VALUE;\n+typedef struct _PUBLICKEYSTRUC {\n+} BLOBHEADER, PUBLICKEYSTRUC;\n+typedef struct _RSAPUBKEY {\n+    DWORD magic;\n+    DWORD pubexp;\n+} RSAPUBKEY;\n+typedef struct _CRYPT_BIT_BLOB {\n+    DWORD cbData;\n+    BYTE *pbData;\n+    DWORD cUnusedBits;\n+} CRYPT_BIT_BLOB, *PCRYPT_BIT_BLOB;\n+typedef struct _CRYPT_KEY_PROV_PARAM {\n+} CRYPT_KEY_PROV_PARAM, *PCRYPT_KEY_PROV_PARAM;\n+typedef struct _CRYPT_KEY_PROV_INFO {\n+    CRYPT_ALGORITHM_IDENTIFIER Algorithm;\n+    CRYPT_BIT_BLOB PublicKey;\n+} CERT_PUBLIC_KEY_INFO, *PCERT_PUBLIC_KEY_INFO;\n+typedef struct _CERT_EXTENSION {\n+    LPSTR pszObjId;\n+    CRYPT_OBJID_BLOB Value;\n+} CERT_EXTENSION, *PCERT_EXTENSION;\n+typedef struct _CERT_EXTENSIONS {\n+    DWORD cExtension;\n+    PCERT_EXTENSION rgExtension;\n+} CERT_EXTENSIONS, *PCERT_EXTENSIONS;\n+typedef struct _CERT_INFO {\n+    CRYPT_INTEGER_BLOB SerialNumber;\n+    CERT_NAME_BLOB Subject;\n+    CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;\n+} CERT_INFO, *PCERT_INFO;\n+typedef struct _CERT_RDN_ATTR {\n+    LPSTR pszObjId;\n+    CERT_RDN_VALUE_BLOB Value;\n+} CERT_RDN_ATTR, *PCERT_RDN_ATTR;\n+typedef struct _CERT_RDN {\n+} CERT_RDN, *PCERT_RDN;\n+typedef struct _CERT_NAME_INFO {\n+    DWORD cRDN;\n+} CERT_NAME_INFO, *PCERT_NAME_INFO;\n+typedef struct _CERT_NAME_VALUE {\n+    DWORD dwValueType;\n+    CERT_RDN_VALUE_BLOB Value;\n+} CERT_NAME_VALUE, *PCERT_NAME_VALUE;\n+typedef struct _CERT_ENCRYPTED_PRIVATE_KEY_INFO {\n+    CERT_NAME_BLOB CertIssuer;\n+} CERT_AUTHORITY_KEY_ID_INFO, *PCERT_AUTHORITY_KEY_ID_INFO;\n+typedef struct _CERT_PRIVATE_KEY_VALIDITY {\n+} CERT_OTHER_NAME, *PCERT_OTHER_NAME;\n+typedef struct _CERT_ALT_NAME_ENTRY {\n+    DWORD dwAltNameChoice;\n+    union {\n+        LPWSTR pwszURL;\n+    } ;\n+} CERT_ALT_NAME_ENTRY, *PCERT_ALT_NAME_ENTRY;\n+typedef struct _CERT_ALT_NAME_INFO {\n+    DWORD cAltEntry;\n+    PCERT_ALT_NAME_ENTRY rgAltEntry;\n+} CERT_ALT_NAME_INFO, *PCERT_ALT_NAME_INFO;\n+typedef struct _CERT_BASIC_CONSTRAINTS_INFO {\n+    CERT_NAME_BLOB *rgSubtreesConstraint;\n+} CERT_BASIC_CONSTRAINTS_INFO, *PCERT_BASIC_CONSTRAINTS_INFO;\n+typedef struct _CERT_BASIC_CONSTRAINTS2_INFO {\n+} CERT_BASIC_CONSTRAINTS2_INFO, *PCERT_BASIC_CONSTRAINTS2_INFO;\n+typedef struct _CERT_POLICY_QUALIFIER_INFO {\n+} CERT_POLICY_QUALIFIER_INFO, *PCERT_POLICY_QUALIFIER_INFO;\n+typedef struct _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE {\n+} CERT_POLICY_QUALIFIER_NOTICE_REFERENCE,\n+ *PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE;\n+typedef struct _CERT_POLICY_QUALIFIER_USER_NOTICE {\n+    DWORD cValue;\n+    PCRYPT_DER_BLOB rgValue;\n+} CRYPT_SEQUENCE_OF_ANY, *PCRYPT_SEQUENCE_OF_ANY;\n+typedef struct _CERT_AUTHORITY_KEY_ID2_INFO {\n+    PCERT_INFO pCertInfo;\n+} CERT_CONTEXT, *PCERT_CONTEXT;\n+typedef const CERT_CONTEXT *PCCERT_CONTEXT;\n+typedef struct _CRL_ENTRY {\n+} CRL_ENTRY, *PCRL_ENTRY;\n+typedef struct _CRL_INFO {\n+    DWORD cCRLEntry;\n+    DWORD cExtension;\n+} CRL_INFO, *PCRL_INFO;\n+typedef struct _CRL_DIST_POINT_NAME {\n+    DWORD dwDistPointNameChoice;\n+    union {\n+    } ;\n+} CRL_DIST_POINT_NAME, *PCRL_DIST_POINT_NAME;\n+typedef struct _CRL_DIST_POINT {\n+    CRL_DIST_POINT_NAME DistPointName;\n+    CRYPT_BIT_BLOB ReasonFlags;\n+    CERT_ALT_NAME_INFO CRLIssuer;\n+} CRL_DIST_POINT, *PCRL_DIST_POINT;\n+typedef struct _CRL_DIST_POINTS_INFO {\n+    DWORD cDistPoint;\n+    PCRL_DIST_POINT rgDistPoint;\n+} CRL_DIST_POINTS_INFO, *PCRL_DIST_POINTS_INFO;\n+typedef struct _CRL_ISSUING_DIST_POINT {\n+    BOOL fOnlyContainsUserCerts;\n+} CRL_ISSUING_DIST_POINT, *PCRL_ISSUING_DIST_POINT;\n+typedef struct _CERT_GENERAL_SUBTREE {\n+} CRYPT_ATTRIBUTE, *PCRYPT_ATTRIBUTE;\n+typedef struct _CRYPT_ATTRIBUTES {\n+} CRYPT_ATTRIBUTES, *PCRYPT_ATTRIBUTES;\n+typedef struct _CERT_REQUEST_INFO {\n+    DWORD dwVersion;\n+    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;\n+    CRYPT_BIT_BLOB Signature;\n+} CERT_SIGNED_CONTENT_INFO, *PCERT_SIGNED_CONTENT_INFO;\n+typedef struct _CRL_CONTEXT {\n+} CRL_CONTEXT, *PCRL_CONTEXT;\n+typedef struct _VTableProvStruc {\n+} CTL_CONTEXT, *PCTL_CONTEXT;\n+typedef struct _CRYPT_TIME_STAMP_REQUEST_INFO {\n+} CERT_REVOCATION_STATUS, *PCERT_REVOCATION_STATUS;\n+typedef struct _CERT_TRUST_STATUS {\n+} CERT_SYSTEM_STORE_RELOCATE_PARA, *PCERT_SYSTEM_STORE_RELOCATE_PARA;\n+typedef BOOL (__attribute__((__stdcall__)) *PFN_CERT_ENUM_SYSTEM_STORE_LOCATION)(\n+ void *pvArg);\n+typedef struct _CRYPT_ENCODE_PARA {\n+} CERT_STORE_PROV_INFO, *PCERT_STORE_PROV_INFO;\n+typedef BOOL (__attribute__((__stdcall__)) *PFN_CERT_DLL_OPEN_STORE_PROV_FUNC)(\n+ DWORD dwFlags, DWORD dwCtrlType, void const *pvCtrlPara);\n+typedef struct _CERT_STORE_PROV_FIND_INFO {\n+} CERT_STORE_PROV_FIND_INFO, *PCERT_STORE_PROV_FIND_INFO;\n+typedef BOOL (__attribute__((__stdcall__)) *PFN_CERT_STORE_PROV_FIND_CERT)(HCERTSTOREPROV hStoreProv,\n+ DWORD dwFlags, void **ppvStoreProvFindInfo, PCCERT_CONTEXT *ppProvCertContext);\n+typedef BOOL (__attribute__((__stdcall__)) *PFN_CERT_STORE_PROV_FREE_FIND_CERT)(\n+ DWORD dwFlags, void *pvData, DWORD *pcbData);\n+typedef BOOL (__attribute__((__stdcall__)) *PFN_CERT_STORE_PROV_GET_CTL_PROPERTY)(\n+ DWORD dwFlags, void *pvData);\n+typedef struct _CERT_CREATE_CONTEXT_PARA {\n+} CRYPT_OID_FUNC_ENTRY, *PCRYPT_OID_FUNC_ENTRY;\n+typedef BOOL (__attribute__((__stdcall__)) *PFN_CRYPT_ENUM_OID_FUNC)(DWORD dwEncodingType,\n+ const DWORD rgcbValueData[], void *pvArg);\n+typedef struct _CRYPT_OID_INFO {\n+    union {\n+    } ;\n+} CRYPT_OID_INFO, *PCRYPT_OID_INFO;\n+typedef const CRYPT_OID_INFO CCRYPT_OID_INFO, *PCCRYPT_OID_INFO;\n+typedef BOOL (__attribute__((__stdcall__)) *PFN_CRYPT_ENUM_OID_INFO)(PCCRYPT_OID_INFO pInfo,\n+ void *pvArg);\n+typedef struct _CRYPT_SIGN_MESSAGE_PARA {\n+} CRYPT_HASH_MESSAGE_PARA, *PCRYPT_HASH_MESSAGE_PARA;\n+typedef struct _CRYPT_KEY_SIGN_MESSAGE_PARA {\n+} CRYPT_URL_INFO, *PCRYPT_URL_INFO;\n+typedef void (__attribute__((__stdcall__)) *PFN_CRYPT_ASYNC_PARAM_FREE_FUNC)(LPSTR pszParamOid,\n+ LPVOID pvParam);\n+typedef struct _CRYPT_CREDENTIALS {\n+} CRYPT_CREDENTIALS, *PCRYPT_CREDENTIALS;\n+typedef struct _CRYPT_PASSWORD_CREDENTIALSA {\n+} CRYPT_PASSWORD_CREDENTIALSW, *PCRYPT_PASSWORD_CREDENTIALSW;\n+typedef struct _CRYPT_RETRIEVE_AUX_INFO {\n+} CRYPT_RETRIEVE_AUX_INFO, *PCRYPT_RETRIEVE_AUX_INFO;\n+typedef struct _CERT_CHAIN_ENGINE_CONFIG\n+{\n+} CERT_CHAIN_ENGINE_CONFIG, *PCERT_CHAIN_ENGINE_CONFIG;\n+BOOL __attribute__((__stdcall__)) CryptExportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwKeySpec,\n+ DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags,\n+ void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo);\n+BOOL __attribute__((__stdcall__)) CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv,\n+ PCRYPT_RETRIEVE_AUX_INFO pAuxInfo);\n+struct encodedInt\n+{\n+    int val;\n+    const BYTE *encoded;\n+};\n+static const struct encodedInt ints[] = {\n+};\n+struct encodedBigInt\n+{\n+    const BYTE *val;\n+    const BYTE *encoded;\n+};\n+static const struct encodedBigInt bigInts[] = {\n+};\n+static const struct encodedBigInt bigUInts[] = {\n+};\n+static void test_encodeInt(DWORD dwEncoding)\n+{\n+    DWORD bufSize = 0;\n+    int i;\n+    BOOL ret;\n+    CRYPT_INTEGER_BLOB blob;\n+    BYTE *buf = ((void *)0);\n+    ret = CryptEncodeObjectEx(0, ((LPCSTR)27), &ints[0].val, 0, ((void *)0), ((void *)0),\n+     \"Expected STATUS_ACCESS_VIOLATION, got %08x\\n\", GetLastError());\n+    {\n+        ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)27), &ints[i].val,\n+         0x08000, ((void *)0), &buf, &bufSize);\n+        {\n+            (winetest_set_location(\"encode.c\", 119), 0) ? 0 : winetest_ok(buf[0] == 2, \"Got unexpected type %d for integer (expected 2)\\n\",\n+             buf[1], ints[i].encoded[1]);\n+        }\n+        ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)28), &blob,\n+         0, ((void *)0), ((void *)0), &bufSize);\n+        {\n+        }\n+        ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)38), &blob,\n+         0x08000, ((void *)0), &buf, &bufSize);\n+        {\n+            (winetest_set_location(\"encode.c\", 187), 0) ? 0 : winetest_ok(buf[1] == bigUInts[i].encoded[1], \"Got length %d, expected %d\\n\",\n+             buf[1], bigUInts[i].encoded[1]);\n+            (winetest_set_location(\"encode.c\", 189), 0) ? 0 : winetest_ok(!memcmp(buf + 1, bigUInts[i].encoded + 1,\n+             bigUInts[i].encoded[1] + 1),\n+             \"Encoded value didn't match expected\\n\");\n+        }\n+    }\n+}\n+static void test_decodeInt(DWORD dwEncoding)\n+{\n+    static const BYTE longForm[] = { 2, 0x81, 0x01, 0x01 };\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0;\n+    int i;\n+    BOOL ret;\n+    ret = CryptDecodeObjectEx(3, ((LPCSTR)27), (BYTE *)&ints[0].encoded,\n+     ints[0].encoded[1] + 2, 0, ((void *)0), ((void *)0), &bufSize);\n+    (winetest_set_location(\"encode.c\", 225), 0) ? 0 : winetest_ok(!ret && GetLastError() == ((HRESULT)0x80093104L),\n+     \"Expected CRYPT_E_ASN1_BADTAG, got %d\\n\", GetLastError());\n+    {\n+        {\n+            (winetest_set_location(\"encode.c\", 249), 0) ? 0 : winetest_ok(!memcmp(buf, &ints[i].val, bufSize), \"Expected %d, got %d\\n\",\n+             ints[i].val, *(int *)buf);\n+        }\n+    }\n+    {\n+        ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)28),\n+         &bufSize);\n+        {\n+            CRYPT_INTEGER_BLOB *blob = (CRYPT_INTEGER_BLOB *)buf;\n+            (winetest_set_location(\"encode.c\", 296), 0) ? 0 : winetest_ok(blob->cbData == strlen((const char*)bigUInts[i].val),\n+             \"Unexpected value\\n\");\n+        }\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)28), longForm,\n+     sizeof(longForm), 0x08000, ((void *)0), (BYTE *)&buf, &bufSize);\n+    {\n+    }\n+}\n+static const struct encodedInt enums[] = {\n+};\n+static const LPCSTR enumeratedTypes[] = { ((LPCSTR)29),\n+ \"2.5.29.21\" };\n+static void test_encodeEnumerated(DWORD dwEncoding)\n+{\n+    DWORD i, j;\n+    {\n+        {\n+            BOOL ret;\n+            DWORD bufSize = 0;\n+            ret = CryptEncodeObjectEx(dwEncoding, enumeratedTypes[i],\n+             &bufSize);\n+            {\n+            }\n+        }\n+    }\n+}\n+static void test_decodeEnumerated(DWORD dwEncoding)\n+{\n+    DWORD i, j;\n+    {\n+        {\n+            BOOL ret;\n+            DWORD bufSize = sizeof(int);\n+            int val;\n+            ret = CryptDecodeObjectEx(dwEncoding, enumeratedTypes[i],\n+             (BYTE *)&val, &bufSize);\n+            (winetest_set_location(\"encode.c\", 403), 0) ? 0 : winetest_ok(val == enums[j].val, \"Unexpected value %d, expected %d\\n\",\n+             val, enums[j].val);\n+        }\n+    }\n+}\n+struct encodedFiletime\n+{\n+    SYSTEMTIME sysTime;\n+    const BYTE *encodedTime;\n+};\n+static void testTimeEncoding(DWORD dwEncoding, LPCSTR structType,\n+ const struct encodedFiletime *time)\n+{\n+}\n+static void testTimeDecoding(DWORD dwEncoding, LPCSTR structType,\n+ const struct encodedFiletime *time)\n+{\n+    BOOL ret;\n+    if (structType == ((LPCSTR)30) ||\n+     (time->sysTime.wYear >= 1950 && time->sysTime.wYear <= 2050))\n+    {\n+    }\n+        (winetest_set_location(\"encode.c\", 476), 0) ? 0 : winetest_ok(!ret && GetLastError() == ((HRESULT)0x8009310BL),\n+         \"Expected CRYPT_E_ASN1_BADTAG, got 0x%08x\\n\", GetLastError());\n+}\n+static const BYTE bin22[] = {\n+    0x18,0x0f,'2','1','4','5','0','6','0','6','1','6','1','0','0','0','Z'};\n+static const struct encodedFiletime times[] = {\n+};\n+static void test_encodeFiletime(DWORD dwEncoding)\n+{\n+    {\n+    }\n+}\n+static const BYTE bin23[] = {\n+    0x18,0x13,'1','9','4','5','0','6','0','6','1','6','1','0','0','0','.','0','0','0','Z'};\n+static const BYTE bin24[] = {\n+    0x18,0x13,'1','9','4','5','0','6','0','6','1','6','1','0','0','0','.','9','9','9','Z'};\n+static const BYTE bin26[] = {\n+    0x17,0x0b,'4','5','0','6','0','6','1','6','1','0','Z'};\n+static const BYTE bin33[] = {\n+    0x17,0x0f,'4','5','0','6','0','6','1','6','1','0','-','0','1','0','0'};\n+static const BYTE bin35[] = {\n+    0x17,0x08, '4','5','0','6','0','6','1','6'};\n+static const BYTE bin38[] = {\n+    0x18,0x08, '2','1','4','5','0','6','0','6'};\n+static void test_decodeFiletime(DWORD dwEncoding)\n+{\n+    static const struct encodedFiletime otherTimes[] = {\n+    };\n+    static const unsigned char *bogusTimes[] = {\n+    };\n+    {\n+    }\n+}\n+static const char commonName[] = \"Juan Lang\";\n+static const char surName[] = \"Lang\";\n+static const BYTE emptySequence[] = { 0x30, 0 };\n+static const BYTE emptyRDNs[] = { 0x30, 0x02, 0x31, 0 };\n+static const BYTE twoRDNs[] = {\n+    0x13,0x0a,0x4a,0x75,0x61,0x6e,0x20,0x4c,0x61,0x6e,0x67,0};\n+static const BYTE encodedTwoRDNs[] = {\n+};\n+static const BYTE us[] = { 0x55, 0x53 };\n+static const BYTE minnesota[] = { 0x4d, 0x69, 0x6e, 0x6e, 0x65, 0x73, 0x6f,\n+ 0x6f, 0x6c, 0x69, 0x73 };\n+static const BYTE codeweavers[] = { 0x43, 0x6f, 0x64, 0x65, 0x57, 0x65, 0x61,\n+ 0x76, 0x65, 0x72, 0x73 };\n+static const BYTE wine[] = { 0x57, 0x69, 0x6e, 0x65, 0x20, 0x44, 0x65, 0x76,\n+ 0x65, 0x6c, 0x6f, 0x70, 0x6d, 0x65, 0x6e, 0x74 };\n+static const BYTE aric[] = { 0x61, 0x72, 0x69, 0x63, 0x40, 0x63, 0x6f, 0x64,\n+ 0x65, 0x77, 0x65, 0x61, 0x76, 0x65, 0x72, 0x73, 0x2e, 0x63, 0x6f, 0x6d };\n+static CHAR oid_us[] = \"2.5.4.6\",\n+            oid_aric[] = \"1.2.840.113549.1.9.1\";\n+static CERT_RDN_ATTR rdnAttrs[] = { { oid_us, 4, { sizeof(us), (LPBYTE)us } },\n+                                           { oid_aric, 7, { sizeof(aric), (LPBYTE)aric } } };\n+static const BYTE encodedRDNAttrs[] = {\n+};\n+static void test_encodeName(DWORD dwEncoding)\n+{\n+    CERT_NAME_INFO info;\n+    static CHAR oid_common_name[] = \"2.5.4.3\",\n+                oid_sur_name[] = \"2.5.4.4\";\n+    BOOL ret;\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)7), ((void *)0),\n+     \"Expected STATUS_ACCESS_VIOLATION, got %08x\\n\", GetLastError());\n+    {\n+    }\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)7), &info,\n+     \"Expected STATUS_ACCESS_VIOLATION, got %08x\\n\", GetLastError());\n+    {\n+    }\n+    {\n+    }\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)7), &info,\n+     \"Expected E_INVALIDARG, got %08x\\n\", GetLastError());\n+    {\n+    }\n+}\n+static WCHAR commonNameW[] = { 'J','u','a','n',' ','L','a','n','g',0 };\n+static const BYTE twoRDNsNoNull[] = {\n+ 0x20,0x4c,0x61,0x6e,0x67 };\n+static const BYTE anyType[] = {\n+ 0x61,0x4c,0x67,0x6e };\n+static void test_encodeUnicodeName(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)20), ((void *)0),\n+     \"Expected STATUS_ACCESS_VIOLATION, got %08x\\n\", GetLastError());\n+    {\n+    }\n+}\n+static void compareNameValues(const CERT_NAME_VALUE *expected,\n+ const CERT_NAME_VALUE *got)\n+{\n+    (winetest_set_location(\"encode.c\", 913), 0) ? 0 : winetest_ok(got->dwValueType == expected->dwValueType,\n+     expected->dwValueType, got->Value.cbData, expected->Value.cbData);\n+        (winetest_set_location(\"encode.c\", 920), 0) ? 0 : winetest_ok(!memcmp(got->Value.pbData, expected->Value.pbData,\n+         (((got->Value.cbData) < (expected->Value.cbData)) ? (got->Value.cbData) : (expected->Value.cbData))),\n+         \"String type %d: unexpected value\\n\", expected->dwValueType);\n+}\n+static void compareRDNAttrs(const CERT_RDN_ATTR *expected,\n+ const CERT_RDN_ATTR *got)\n+{\n+    {\n+        {\n+            (winetest_set_location(\"encode.c\", 934), 0) ? 0 : winetest_ok(!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (got->pszObjId) && __builtin_constant_p (expected->pszObjId) && (__s1_len = strlen (got->pszObjId), __s2_len = strlen (expected->pszObjId), (!((size_t)(const void *)((got->pszObjId) + 1) - (size_t)(const void *)(got->pszObjId) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((expected->pszObjId) + 1) - (size_t)(const void *)(expected->pszObjId) == 1) || __s2_len >= 4)) ? __builtin_strcmp (got->pszObjId, expected->pszObjId) : (__builtin_constant_p (got->pszObjId) && ((size_t)(const void *)((got->pszObjId) + 1) - (size_t)(const void *)(got->pszObjId) == 1) && (__s1_len = strlen (got->pszObjId), __s1_len < 4) ? (__builtin_constant_p (expected->pszObjId) && ((size_t)(const void *)((expected->pszObjId) + 1) - (size_t)(const void *)(expected->pszObjId) == 1) ? __builtin_strcmp (got->pszObjId, expected->pszObjId) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (expected->pszObjId); register int __result = (((__const unsigned char *) (__const char *) (got->pszObjId))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (got->pszObjId))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (got->pszObjId))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (got->pszObjId))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (expected->pszObjId) && ((size_t)(const void *)((expected->pszObjId) + 1) - (size_t)(const void *)(expected->pszObjId) == 1) && (__s2_len = strlen (expected->pszObjId), __s2_len < 4) ? (__builtin_constant_p (got->pszObjId) && ((size_t)(const void *)((got->pszObjId) + 1) - (size_t)(const void *)(got->pszObjId) == 1) ? __builtin_strcmp (got->pszObjId, expected->pszObjId) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (got->pszObjId); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (expected->pszObjId))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (expected->pszObjId))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (expected->pszObjId))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (expected->pszObjId))[3]); } } __result; }))) : __builtin_strcmp (got->pszObjId, expected->pszObjId)))); }),\n+             expected->pszObjId);\n+        }\n+    }\n+}\n+static void compareRDNs(const CERT_RDN *expected, const CERT_RDN *got)\n+{\n+    {\n+    }\n+}\n+static void compareNames(const CERT_NAME_INFO *expected,\n+ const CERT_NAME_INFO *got)\n+{\n+    (winetest_set_location(\"encode.c\", 959), 0) ? 0 : winetest_ok(got->cRDN == expected->cRDN, \"Expected %d RDNs, got %d\\n\",\n+     expected->cRDN, got->cRDN);\n+    {\n+    }\n+}\n+static void test_decodeName(DWORD dwEncoding)\n+{\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0;\n+    BOOL ret;\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)7), emptySequence,\n+     (BYTE *)&buf, &bufSize);\n+    {\n+        static CHAR oid_sur_name[] = \"2.5.4.4\",\n+                    oid_common_name[] = \"2.5.4.3\";\n+        CERT_RDN_ATTR attrs[] = {\n+         { oid_sur_name, 4, { sizeof(surName),\n+          (BYTE *)commonName } },\n+        };\n+    }\n+    {\n+    }\n+}\n+static void test_decodeUnicodeName(DWORD dwEncoding)\n+{\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0;\n+    BOOL ret;\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)20), emptySequence,\n+     (BYTE *)&buf, &bufSize);\n+    {\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)20), emptyRDNs,\n+     (BYTE *)&buf, &bufSize);\n+    {\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)20), twoRDNsNoNull,\n+     (BYTE *)&buf, &bufSize);\n+    {\n+        static CHAR oid_sur_name[] = \"2.5.4.4\",\n+                    oid_common_name[] = \"2.5.4.3\";\n+        CERT_RDN_ATTR attrs[] = {\n+         { oid_sur_name, 4,\n+         { lstrlenW(commonNameW) * sizeof(WCHAR), (BYTE *)commonNameW } },\n+        };\n+    }\n+}\n+struct EncodedNameValue\n+{\n+    CERT_NAME_VALUE value;\n+};\n+static const char bogusPrintable[] = \"~\";\n+static const BYTE bin42[] = { 0x16,0x02,0x80,0x00 };\n+static const BYTE bin43[] = { 0x13,0x02,0x7e,0x00 };\n+static BYTE octetCommonNameValue[] = {\n+ 0x12,0x0a,0x4a,0x75,0x61,0x6e,0x20,0x4c,0x61,0x6e,0x67,0x00 };\n+static BYTE printableCommonNameValue[] = {\n+ 0x13,0x0a,0x4a,0x75,0x61,0x6e,0x20,0x4c,0x61,0x6e,0x67,0x00 };\n+static BYTE t61CommonNameValue[] = {\n+ 0x14,0x0a,0x4a,0x75,0x61,0x6e,0x20,0x4c,0x61,0x6e,0x67,0x00 };\n+static BYTE graphicCommonNameValue[] = {\n+ 0x61,0x00,0x6e,0x00,0x67,0x00,0x00 };\n+static BYTE utf8CommonNameValue[] = {\n+ 0x0c,0x0a,0x4a,0x75,0x61,0x6e,0x20,0x4c,0x61,0x6e,0x67,0x00 };\n+static struct EncodedNameValue nameValues[] = {\n+ { { 5, { sizeof(commonName), (BYTE *)commonName } },\n+     sizeof(bin42) },\n+ { { 4, { sizeof(bogusPrintable),\n+     (BYTE *)bogusPrintable } }, bin43, sizeof(bin43) },\n+};\n+static void test_encodeNameValue(DWORD dwEncoding)\n+{\n+    DWORD size = 0, i;\n+    BOOL ret;\n+    CERT_NAME_VALUE value = { 0, { 0, ((void *)0) } };\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)6), &value,\n+     \"Expected CRYPT_E_ASN1_CHOICE, got %08x\\n\", GetLastError());\n+    {\n+        (winetest_set_location(\"encode.c\", 1209), 0) ? 0 : winetest_ok(size == sizeof(printableCommonNameValue), \"Unexpected size %d\\n\",\n+         \"Unexpected encoding\\n\");\n+        ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)6),\n+         nameValues[i].value.dwValueType, GetLastError());\n+        {\n+        }\n+    }\n+}\n+static void test_decodeNameValue(DWORD dwEncoding)\n+{\n+    int i;\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0;\n+    BOOL ret;\n+    {\n+        ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)6),\n+         (BYTE *)&buf, &bufSize);\n+        {\n+            compareNameValues(&nameValues[i].value,\n+             (const CERT_NAME_VALUE *)buf);\n+        }\n+    }\n+}\n+static const BYTE emptyURL[] = { 0x30, 0x02, 0x86, 0x00 };\n+static const WCHAR url[] = { 'h','t','t','p',':','/','/','w','i','n','e',\n+ 0x6f, 0x72, 0x67 };\n+static const BYTE encodedIPAddr[] = { 0x30, 0x06, 0x87, 0x04, 0x7f, 0x00, 0x00,\n+ 0x01 };\n+static void test_encodeAltName(DWORD dwEncoding)\n+{\n+    CERT_ALT_NAME_INFO info = { 0 };\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0;\n+    BOOL ret;\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)12), &info,\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+    }\n+    {\n+    }\n+}\n+static void test_decodeAltName(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    DWORD bufSize = 0;\n+    CERT_ALT_NAME_INFO *info;\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)12),\n+     &bufSize);\n+    {\n+        (winetest_set_location(\"encode.c\", 1392), 0) ? 0 : winetest_ok(info->cAltEntry == 0, \"Expected 0 entries, got %d\\n\",\n+         info->cAltEntry);\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)12), emptyURL,\n+     &bufSize);\n+    {\n+    }\n+}\n+struct encodedBits\n+{\n+    const BYTE *encoded;\n+    DWORD cbDecoded;\n+};\n+static const struct encodedBits bits[] = {\n+};\n+static void test_encodeBits(DWORD dwEncoding)\n+{\n+    DWORD i;\n+    {\n+        DWORD bufSize = 0;\n+        {\n+            (winetest_set_location(\"encode.c\", 1802), 0) ? 0 : winetest_ok(bufSize == bits[i].encoded[1] + 2,\n+             bits[i].encoded[1] + 2);\n+        }\n+    }\n+}\n+static void test_decodeBits(DWORD dwEncoding)\n+{\n+    DWORD i;\n+    {\n+        {\n+            CRYPT_BIT_BLOB *blob;\n+            (winetest_set_location(\"encode.c\", 1835), 0) ? 0 : winetest_ok(blob->cbData == bits[i].cbDecoded,\n+                 \"Unexpected value\\n\");\n+        }\n+    }\n+    {\n+    }\n+}\n+struct Constraints2\n+{\n+    CERT_BASIC_CONSTRAINTS2_INFO info;\n+};\n+static const struct Constraints2 constraints2[] = {\n+};\n+static const BYTE encodedDomainName[] = { 0x30, 0x2b, 0x31, 0x29, 0x30, 0x11,\n+ 0x16, 0x06, 0x77, 0x69, 0x6e, 0x65, 0x68, 0x71 };\n+static void test_encodeBasicConstraints(DWORD dwEncoding)\n+{\n+    CERT_NAME_BLOB nameBlob = { sizeof(encodedDomainName),\n+     (LPBYTE)encodedDomainName };\n+    {\n+        {\n+        }\n+    }\n+    {\n+    }\n+}\n+static const unsigned char encodedCommonName[] = {\n+    0x30,0x15,0x31,0x13,0x30,0x11,0x06,0x03,0x55,0x04,0x03,0x13,0x0a,'J','u','a','n',' ','L','a','n','g',0};\n+static void test_decodeBasicConstraints(DWORD dwEncoding)\n+{\n+    static const BYTE inverted[] = { 0x30, 0x06, 0x02, 0x01, 0x01, 0x01, 0x01,\n+     0xff };\n+    DWORD i;\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0;\n+    {\n+        ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)15),\n+         0x08000, ((void *)0), (BYTE *)&buf, &bufSize);\n+        {\n+            CERT_BASIC_CONSTRAINTS2_INFO *info =\n+            (winetest_set_location(\"encode.c\", 1984), 0) ? 0 : winetest_ok(!memcmp(info, &constraints2[i].info, sizeof(*info)),\n+             \"Unexpected value for item %d\\n\", i);\n+        }\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)15),\n+     (BYTE *)&buf, &bufSize);\n+    {\n+        CERT_BASIC_CONSTRAINTS_INFO *info = (CERT_BASIC_CONSTRAINTS_INFO *)buf;\n+        {\n+            (winetest_set_location(\"encode.c\", 2043), 0) ? 0 : winetest_ok(info->rgSubtreesConstraint[0].cbData ==\n+             info->rgSubtreesConstraint[0].cbData);\n+            (winetest_set_location(\"encode.c\", 2046), 0) ? 0 : winetest_ok(!memcmp(info->rgSubtreesConstraint[0].pbData, encodedDomainName,\n+             sizeof(encodedDomainName)), \"Unexpected value\\n\");\n+        }\n+    }\n+}\n+static const BYTE modulus1[] = { 0,0,0,1,1,1,1,1 };\n+struct EncodedRSAPubKey\n+{\n+    const BYTE *modulus;\n+    size_t decodedModulusLen;\n+};\n+struct EncodedRSAPubKey rsaPubKeys[] = {\n+};\n+static void test_encodeRsaPublicKey(DWORD dwEncoding)\n+{\n+    BYTE toEncode[sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + sizeof(modulus1)];\n+    RSAPUBKEY *rsaPubKey = (RSAPUBKEY *)(toEncode + sizeof(BLOBHEADER));\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0, i;\n+    ret = CryptDecodeObjectEx(dwEncoding, \"1.2.840.113549.1.1.1\",\n+     \"Expected ERROR_FILE_NOT_FOUND, got %08x\\n\", GetLastError());\n+    {\n+        {\n+            (winetest_set_location(\"encode.c\", 2210), 0) ? 0 : winetest_ok(bufSize >= sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) +\n+             \"Wrong size %d\\n\", bufSize);\n+            (winetest_set_location(\"encode.c\", 2223), 0) ? 0 : winetest_ok(rsaPubKey->magic == 0x31415352,\n+             rsaPubKey->pubexp);\n+            (winetest_set_location(\"encode.c\", 2229), 0) ? 0 : winetest_ok(!memcmp(buf + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY),\n+             rsaPubKeys[i].modulus, rsaPubKeys[i].decodedModulusLen),\n+             \"Unexpected modulus\\n\");\n+        }\n+    }\n+}\n+static const BYTE intSequence[] = { 0x30, 0x1b, 0x02, 0x01, 0x01, 0x02, 0x01,\n+ 0x02, 0xff, 0x7f, 0x02, 0x04, 0xba, 0xdd, 0xf0, 0x0d };\n+static const BYTE mixedSequence[] = { 0x30, 0x27, 0x17, 0x0d, 0x30, 0x35, 0x30,\n+ 0xff, 0x7f, 0x02, 0x04, 0xba, 0xdd, 0xf0, 0x0d };\n+static void test_encodeSequenceOfAny(DWORD dwEncoding)\n+{\n+    BYTE *buf = ((void *)0);\n+    {\n+    }\n+    {\n+        (winetest_set_location(\"encode.c\", 2284), 0) ? 0 : winetest_ok(!memcmp(buf, mixedSequence, mixedSequence[1] + 2),\n+         \"Unexpected value\\n\");\n+    }\n+}\n+static void test_decodeSequenceOfAny(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0;\n+    {\n+        {\n+        }\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)34), mixedSequence,\n+     &bufSize);\n+    {\n+        CRYPT_SEQUENCE_OF_ANY *seq = (CRYPT_SEQUENCE_OF_ANY *)buf;\n+        (winetest_set_location(\"encode.c\", 2324), 0) ? 0 : winetest_ok(seq->cValue == sizeof(ints) / sizeof(ints[0]),\n+         seq->rgValue[0].cbData);\n+        (winetest_set_location(\"encode.c\", 2330), 0) ? 0 : winetest_ok(!memcmp(seq->rgValue[0].pbData, times[0].encodedTime,\n+         times[0].encodedTime[1] + 2), \"Unexpected value\\n\");\n+    }\n+}\n+struct encodedExtensions\n+{\n+    CERT_EXTENSIONS exts;\n+};\n+static BYTE noncrit_ext_data[] = { 0x30,0x06,0x01,0x01,0xff,0x02,0x01,0x01 };\n+static CHAR oid_basic_constraints2[] = \"2.5.29.19\";\n+static CERT_EXTENSION nonCriticalExt =\n+ { oid_basic_constraints2, 0, { 8, noncrit_ext_data } };\n+static const struct encodedExtensions exts[] = {\n+};\n+static void test_encodeExtensions(DWORD dwEncoding)\n+{\n+    DWORD i;\n+    {\n+        {\n+        }\n+    }\n+    {\n+        BOOL ret;\n+        BYTE *buf = ((void *)0);\n+        DWORD bufSize = 0;\n+        ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)5),\n+         ((void *)0), (BYTE *)&buf, &bufSize);\n+        {\n+            CERT_EXTENSIONS *ext = (CERT_EXTENSIONS *)buf;\n+            DWORD j;\n+            (winetest_set_location(\"encode.c\", 2405), 0) ? 0 : winetest_ok(ext->cExtension == exts[i].exts.cExtension,\n+             ext->cExtension);\n+            {\n+                (winetest_set_location(\"encode.c\", 2410), 0) ? 0 : winetest_ok(!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (ext->rgExtension[j].pszObjId) && __builtin_constant_p (exts[i].exts.rgExtension[j].pszObjId) && (__s1_len = strlen (ext->rgExtension[j].pszObjId), __s2_len = strlen (exts[i].exts.rgExtension[j].pszObjId), (!((size_t)(const void *)((ext->rgExtension[j].pszObjId) + 1) - (size_t)(const void *)(ext->rgExtension[j].pszObjId) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((exts[i].exts.rgExtension[j].pszObjId) + 1) - (size_t)(const void *)(exts[i].exts.rgExtension[j].pszObjId) == 1) || __s2_len >= 4)) ? __builtin_strcmp (ext->rgExtension[j].pszObjId, exts[i].exts.rgExtension[j].pszObjId) : (__builtin_constant_p (ext->rgExtension[j].pszObjId) && ((size_t)(const void *)((ext->rgExtension[j].pszObjId) + 1) - (size_t)(const void *)(ext->rgExtension[j].pszObjId) == 1) && (__s1_len = strlen (ext->rgExtension[j].pszObjId), __s1_len < 4) ? (__builtin_constant_p (exts[i].exts.rgExtension[j].pszObjId) && ((size_t)(const void *)((exts[i].exts.rgExtension[j].pszObjId) + 1) - (size_t)(const void *)(exts[i].exts.rgExtension[j].pszObjId) == 1) ? __builtin_strcmp (ext->rgExtension[j].pszObjId, exts[i].exts.rgExtension[j].pszObjId) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (exts[i].exts.rgExtension[j].pszObjId); register int __result = (((__const unsigned char *) (__const char *) (ext->rgExtension[j].pszObjId))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ext->rgExtension[j].pszObjId))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (ext->rgExtension[j].pszObjId))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (ext->rgExtension[j].pszObjId))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (exts[i].exts.rgExtension[j].pszObjId) && ((size_t)(const void *)((exts[i].exts.rgExtension[j].pszObjId) + 1) - (size_t)(const void *)(exts[i].exts.rgExtension[j].pszObjId) == 1) && (__s2_len = strlen (exts[i].exts.rgExtension[j].pszObjId), __s2_len < 4) ? (__builtin_constant_p (ext->rgExtension[j].pszObjId) && ((size_t)(const void *)((ext->rgExtension[j].pszObjId) + 1) - (size_t)(const void *)(ext->rgExtension[j].pszObjId) == 1) ? __builtin_strcmp (ext->rgExtension[j].pszObjId, exts[i].exts.rgExtension[j].pszObjId) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (ext->rgExtension[j].pszObjId); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (exts[i].exts.rgExtension[j].pszObjId))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (exts[i].exts.rgExtension[j].pszObjId))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (exts[i].exts.rgExtension[j].pszObjId))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (exts[i].exts.rgExtension[j].pszObjId))[3]); } } __result; }))) : __builtin_strcmp (ext->rgExtension[j].pszObjId, exts[i].exts.rgExtension[j].pszObjId)))); }),\n+                 ext->rgExtension[j].pszObjId);\n+                (winetest_set_location(\"encode.c\", 2415), 0) ? 0 : winetest_ok(!memcmp(ext->rgExtension[j].Value.pbData,\n+                 exts[i].exts.rgExtension[j].Value.cbData),\n+                 \"Unexpected value\\n\");\n+            }\n+        }\n+    }\n+}\n+struct encodedPublicKey\n+{\n+    const BYTE *encoded;\n+    const BYTE *encodedNoNull;\n+};\n+static const BYTE aKey[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd,\n+ 0xe, 0xf };\n+static const BYTE params[] = { 0x02, 0x01, 0x01 };\n+static const unsigned char bin66[] = {\n+    0x30,0x0f,0x30,0x0a,0x06,0x06,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x05,0x00,0x03,0x01,0x00};\n+static const unsigned char bin67[] = {\n+    0x30,0x0d,0x30,0x08,0x06,0x06,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x03,0x01,0x00};\n+static const unsigned char bin69[] = {\n+    0x0f};\n+static unsigned char bin72[] = { 0x05,0x00};\n+static CHAR oid_bogus[] = \"1.2.3\",\n+            oid_rsa[] = \"1.2.840.113549\";\n+static const struct encodedPublicKey pubKeys[] = {\n+ { { { oid_rsa, { 0, ((void *)0) } }, { 0, ((void *)0), 0} },\n+  { { oid_rsa, { 2, bin72 } }, { sizeof(aKey), (BYTE *)aKey, 0} } },\n+ { { { oid_rsa, { sizeof(params), (BYTE *)params } }, { sizeof(aKey),\n+  (BYTE *)aKey, 0 } } },\n+};\n+static void test_encodePublicKeyInfo(DWORD dwEncoding)\n+{\n+    DWORD i;\n+    {\n+        BOOL ret;\n+        BYTE *buf = ((void *)0);\n+        DWORD bufSize = 0;\n+        ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)8),\n+         &bufSize);\n+        {\n+            (winetest_set_location(\"encode.c\", 2505), 0) ? 0 : winetest_ok(bufSize == pubKeys[i].encoded[1] + 2 ||\n+             pubKeys[i].encodedNoNull[1] + 2, bufSize);\n+                (winetest_set_location(\"encode.c\", 2510), 0) ? 0 : winetest_ok(!memcmp(buf, pubKeys[i].encoded, pubKeys[i].encoded[1] + 2),\n+                 \"Unexpected value\\n\");\n+                (winetest_set_location(\"encode.c\", 2513), 0) ? 0 : winetest_ok(!memcmp(buf, pubKeys[i].encodedNoNull,\n+                 pubKeys[i].encodedNoNull[1] + 2), \"Unexpected value\\n\");\n+        }\n+    }\n+}\n+static void comparePublicKeyInfo(const CERT_PUBLIC_KEY_INFO *expected,\n+ const CERT_PUBLIC_KEY_INFO *got)\n+{\n+    (winetest_set_location(\"encode.c\", 2523), 0) ? 0 : winetest_ok(!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (expected->Algorithm.pszObjId) && __builtin_constant_p (got->Algorithm.pszObjId) && (__s1_len = strlen (expected->Algorithm.pszObjId), __s2_len = strlen (got->Algorithm.pszObjId), (!((size_t)(const void *)((expected->Algorithm.pszObjId) + 1) - (size_t)(const void *)(expected->Algorithm.pszObjId) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((got->Algorithm.pszObjId) + 1) - (size_t)(const void *)(got->Algorithm.pszObjId) == 1) || __s2_len >= 4)) ? __builtin_strcmp (expected->Algorithm.pszObjId, got->Algorithm.pszObjId) : (__builtin_constant_p (expected->Algorithm.pszObjId) && ((size_t)(const void *)((expected->Algorithm.pszObjId) + 1) - (size_t)(const void *)(expected->Algorithm.pszObjId) == 1) && (__s1_len = strlen (expected->Algorithm.pszObjId), __s1_len < 4) ? (__builtin_constant_p (got->Algorithm.pszObjId) && ((size_t)(const void *)((got->Algorithm.pszObjId) + 1) - (size_t)(const void *)(got->Algorithm.pszObjId) == 1) ? __builtin_strcmp (expected->Algorithm.pszObjId, got->Algorithm.pszObjId) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (got->Algorithm.pszObjId); register int __result = (((__const unsigned char *) (__const char *) (expected->Algorithm.pszObjId))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (expected->Algorithm.pszObjId))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (expected->Algorithm.pszObjId))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (expected->Algorithm.pszObjId))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (got->Algorithm.pszObjId) && ((size_t)(const void *)((got->Algorithm.pszObjId) + 1) - (size_t)(const void *)(got->Algorithm.pszObjId) == 1) && (__s2_len = strlen (got->Algorithm.pszObjId), __s2_len < 4) ? (__builtin_constant_p (expected->Algorithm.pszObjId) && ((size_t)(const void *)((expected->Algorithm.pszObjId) + 1) - (size_t)(const void *)(expected->Algorithm.pszObjId) == 1) ? __builtin_strcmp (expected->Algorithm.pszObjId, got->Algorithm.pszObjId) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (expected->Algorithm.pszObjId); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (got->Algorithm.pszObjId))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (got->Algorithm.pszObjId))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (got->Algorithm.pszObjId))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (got->Algorithm.pszObjId))[3]); } } __result; }))) : __builtin_strcmp (expected->Algorithm.pszObjId, got->Algorithm.pszObjId)))); }),\n+     expected->PublicKey.cbData, got->PublicKey.cbData);\n+        (winetest_set_location(\"encode.c\", 2538), 0) ? 0 : winetest_ok(!memcmp(expected->PublicKey.pbData, got->PublicKey.pbData,\n+         got->PublicKey.cbData), \"Unexpected public key value\\n\");\n+}\n+static void test_decodePublicKeyInfo(DWORD dwEncoding)\n+{\n+    static const BYTE bogusPubKeyInfo[] = { 0x30, 0x22, 0x30, 0x0d, 0x06, 0x06,\n+     0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0;\n+    {\n+        ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)8),\n+         0x08000, ((void *)0), (BYTE *)&buf, &bufSize);\n+        {\n+        }\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)8),\n+     \"Expected CRYPT_E_ASN1_CORRUPT, got %08x\\n\", GetLastError());\n+}\n+static const BYTE v1Cert[] = { 0x30, 0x33, 0x02, 0x00, 0x30, 0x02, 0x06, 0x00,\n+ 0x02, 0x06, 0x00, 0x03, 0x01, 0x00 };\n+static const BYTE v2Cert[] = { 0x30, 0x38, 0xa0, 0x03, 0x02, 0x01, 0x01, 0x02,\n+ 0x30, 0x5a, 0x30, 0x07, 0x30, 0x02, 0x06, 0x00, 0x03, 0x01, 0x00 };\n+static const BYTE v3Cert[] = { 0x30, 0x38, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02,\n+ 0x30, 0x5a, 0x30, 0x07, 0x30, 0x02, 0x06, 0x00, 0x03, 0x01, 0x00 };\n+static const BYTE v1CertWithConstraints[] = { 0x30, 0x4b, 0x02, 0x00, 0x30,\n+ 0x06, 0x01, 0x01, 0xff, 0x02, 0x01, 0x01 };\n+static const BYTE v1CertWithSerial[] = { 0x30, 0x4c, 0x02, 0x01, 0x01, 0x30,\n+ 0x06, 0x01, 0x01, 0xff, 0x02, 0x01, 0x01 };\n+static const BYTE bigCert[] = { 0x30, 0x7a, 0x02, 0x01, 0x01, 0x30, 0x02, 0x06,\n+ 0x01, 0xff, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xff, 0x02, 0x01, 0x01 };\n+static void test_encodeCertToBeSigned(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0;\n+    CERT_INFO info = { 0 };\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)2), ((void *)0),\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+    }\n+    {\n+    }\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)2), &info,\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+    }\n+    {\n+    }\n+}\n+static void test_decodeCertToBeSigned(DWORD dwEncoding)\n+{\n+    static const BYTE *corruptCerts[] = { v1Cert, v2Cert, v3Cert,\n+     v1CertWithConstraints, v1CertWithSerial };\n+    BOOL ret;\n+    (winetest_set_location(\"encode.c\", 2727), 0) ? 0 : winetest_ok(!ret && GetLastError() == ((HRESULT)0x80093102L),\n+     \"Expected STATUS_ACCESS_VIOLATION, got %08x\\n\", GetLastError());\n+    {\n+        ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)2),\n+         \"Expected CRYPT_E_ASN1_CORRUPT, got %08x\\n\", GetLastError());\n+    }\n+    {\n+    }\n+}\n+static const BYTE hash[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd,\n+ 0xe, 0xf };\n+static const BYTE signedBigCert[] = {\n+ 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 };\n+static void test_encodeCert(DWORD dwEncoding)\n+{\n+    CERT_SIGNED_CONTENT_INFO info = { { sizeof(bigCert), (BYTE *)bigCert },\n+     { ((void *)0), { 0, ((void *)0) } }, { sizeof(hash), (BYTE *)hash, 0 } };\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD bufSize = 0;\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)1), &info,\n+     0x08000, ((void *)0), (BYTE *)&buf, &bufSize);\n+    {\n+    }\n+}\n+static void test_decodeCert(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0;\n+    {\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)2), signedBigCert,\n+     sizeof(signedBigCert), 0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+        CERT_INFO *info = (CERT_INFO *)buf;\n+        (winetest_set_location(\"encode.c\", 2843), 0) ? 0 : winetest_ok(info->SerialNumber.cbData == 1,\n+         *info->SerialNumber.pbData);\n+        (winetest_set_location(\"encode.c\", 2852), 0) ? 0 : winetest_ok(info->Subject.cbData == sizeof(encodedCommonName),\n+         \"Wrong size %d\\n\", info->Subject.cbData);\n+        (winetest_set_location(\"encode.c\", 2854), 0) ? 0 : winetest_ok(!memcmp(info->Subject.pbData, encodedCommonName,\n+         info->Subject.cbData), \"Unexpected subject\\n\");\n+    }\n+}\n+static const BYTE distPointWithUrl[] = { 0x30, 0x19, 0x30, 0x17, 0xa0, 0x15,\n+ 0x6e, 0x65, 0x68, 0x71, 0x2e, 0x6f, 0x72, 0x67 };\n+static const BYTE distPointWithIssuer[] = { 0x30, 0x17, 0x30, 0x15, 0xa2, 0x13,\n+ 0x2e, 0x6f, 0x72, 0x67 };\n+static const BYTE crlReason = 1 |\n+ 3;\n+static void test_encodeCRLDistPoints(DWORD dwEncoding)\n+{\n+    CRL_DIST_POINTS_INFO xxxinfo = { 0 };\n+    CRL_DIST_POINT point = { { 0 } };\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0;\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)35), &xxxinfo,\n+     \"Expected E_INVALIDARG, got %08x\\n\", GetLastError());\n+    xxxinfo.cDistPoint = 1;\n+    xxxinfo.rgDistPoint = &point;\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)35), &xxxinfo,\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    point.ReasonFlags.cbData = sizeof(crlReason);\n+    {\n+    }\n+}\n+static void test_decodeCRLDistPoints(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0;\n+    PCERT_ALT_NAME_ENTRY entry;\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)35),\n+     (BYTE *)&buf, &size);\n+    {\n+        (winetest_set_location(\"encode.c\", 3065), 0) ? 0 : winetest_ok(entry->dwAltNameChoice == 7,\n+         \"Expected CERT_ALT_NAME_URL, got %d\\n\", entry->dwAltNameChoice);\n+    }\n+}\n+static const BYTE urlIDP[] = { 0x30,0x17,0xa0,0x15,0xa0,0x13,0x86,0x11,0x68,\n+ 0x67 };\n+static void test_encodeCRLIssuingDistPoint(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0;\n+    CRL_ISSUING_DIST_POINT point = { { 0 } };\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)54), ((void *)0),\n+     \"Expected STATUS_ACCESS_VIOLATION, got %08x\\n\", GetLastError());\n+    {\n+    }\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)54), &point,\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+    }\n+    {\n+    }\n+}\n+static void compareAltNameEntry(const CERT_ALT_NAME_ENTRY *expected,\n+ const CERT_ALT_NAME_ENTRY *got)\n+{\n+    (winetest_set_location(\"encode.c\", 3149), 0) ? 0 : winetest_ok(expected->dwAltNameChoice == got->dwAltNameChoice,\n+     got->dwAltNameChoice);\n+    {\n+        {\n+            (winetest_set_location(\"encode.c\", 3161), 0) ? 0 : winetest_ok((!(*expected).pwszURL && !(*got).pwszURL) ||\n+               !lstrcmpW((*expected).pwszURL, (*got).pwszURL), \"Unexpected name\\n\");\n+        }\n+    }\n+}\n+static void compareAltNameInfo(const CERT_ALT_NAME_INFO *expected,\n+ const CERT_ALT_NAME_INFO *got)\n+{\n+}\n+static const BYTE v1CRL[] = { 0x30, 0x15, 0x30, 0x02, 0x06, 0x00, 0x18, 0x0f,\n+ 0x30, 0x5a };\n+static const BYTE v2CRL[] = { 0x30, 0x18, 0x02, 0x01, 0x01, 0x30, 0x02, 0x06,\n+ 0x30, 0x30, 0x30, 0x30, 0x5a };\n+static const BYTE v1CRLWithIssuer[] = { 0x30, 0x2c, 0x30, 0x02, 0x06, 0x00,\n+ 0x5a };\n+static const BYTE v1CRLWithIssuerAndEmptyEntry[] = { 0x30, 0x43, 0x30, 0x02,\n+ 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a };\n+static const BYTE v1CRLWithIssuerAndEntry[] = { 0x30, 0x44, 0x30, 0x02, 0x06,\n+ 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a };\n+static const BYTE v1CRLWithEntryExt[] = { 0x30,0x5a,0x30,0x02,0x06,0x00,0x30,\n+ 0x04,0x08,0x30,0x06,0x01,0x01,0xff,0x02,0x01,0x01 };\n+static const BYTE v1CRLWithExt[] = { 0x30,0x5c,0x30,0x02,0x06,0x00,0x30,0x15,\n+ 0xff,0x04,0x08,0x30,0x06,0x01,0x01,0xff,0x02,0x01,0x01 };\n+static const BYTE v2CRLWithExt[] = { 0x30,0x5c,0x02,0x01,0x01,0x30,0x02,0x06,\n+ 0x13,0x04,0x08,0x30,0x06,0x01,0x01,0xff,0x02,0x01,0x01 };\n+static const BYTE v2CRLWithIssuingDistPoint[] = { 0x30,0x5c,0x02,0x01,0x01,\n+ 0x03,0x55,0x1d,0x13,0x04,0x08,0x30,0x06,0x01,0x01,0xff,0x02,0x01,0x01 };\n+static void test_encodeCRLToBeSigned(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0;\n+    CRL_INFO info = { 0 };\n+    {\n+        (winetest_set_location(\"encode.c\", 3386), 0) ? 0 : winetest_ok(size == sizeof(v1CRLWithIssuerAndEntry),\n+         \"Wrong size %d\\n\", size);\n+    }\n+    {\n+    }\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)3), &info,\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+    }\n+    {\n+    }\n+}\n+static const BYTE verisignCRL[] = { 0x30, 0x82, 0x01, 0xb1, 0x30, 0x82, 0x01,\n+0x61,0xc0,0x99,0x16,0x71,0x05,0xb6,0x25,0x14,0x64,0x4f,0x30 };\n+static void test_decodeCRLToBeSigned(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0, i;\n+    {\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)3),\n+     (BYTE *)&buf, &size);\n+    {\n+        CRL_INFO *info = (CRL_INFO *)buf;\n+        (winetest_set_location(\"encode.c\", 4016), 0) ? 0 : winetest_ok(info->cCRLEntry == 0, \"Expected 0 CRL entries, got %d\\n\",\n+         \"Unexpected issuer\\n\");\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)3),\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+        CRL_INFO *info = (CRL_INFO *)buf;\n+        (winetest_set_location(\"encode.c\", 4041), 0) ? 0 : winetest_ok(info->cCRLEntry == 1, \"Expected 1 CRL entries, got %d\\n\",\n+         \"Unexpected issuer\\n\");\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)3),\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+        CRL_INFO *info = (CRL_INFO *)buf;\n+        (winetest_set_location(\"encode.c\", 4085), 0) ? 0 : winetest_ok(info->cCRLEntry == 209, \"Expected 209 CRL entries, got %d\\n\",\n+         info->cExtension);\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)3),\n+     ((void *)0), (BYTE *)&buf, &size);\n+    {\n+    }\n+}\n+static const BYTE authorityKeyIdWithIssuer[] = { 0x30,0x19,0xa1,0x17,0x30,0x15,\n+ 0x20,0x4c,0x61,0x6e,0x67,0x00 };\n+static const BYTE authorityKeyIdWithSerial[] = { 0x30,0x03,0x82,0x01,0x01 };\n+static void test_encodeAuthorityKeyId(DWORD dwEncoding)\n+{\n+    CERT_AUTHORITY_KEY_ID_INFO info = { { 0 } };\n+    BOOL ret;\n+    BYTE *buf = ((void *)0);\n+    DWORD size = 0;\n+    {\n+    }\n+    {\n+    }\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)9), &info,\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+    }\n+    ret = CryptEncodeObjectEx(dwEncoding, ((LPCSTR)9), &info,\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+        (winetest_set_location(\"encode.c\", 4284), 0) ? 0 : winetest_ok(size == sizeof(authorityKeyIdWithSerial), \"Unexpected size %d\\n\",\n+         size);\n+    }\n+}\n+static void test_decodeAuthorityKeyId(DWORD dwEncoding)\n+{\n+    BOOL ret;\n+    LPBYTE buf = ((void *)0);\n+    DWORD size = 0;\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)9),\n+     (BYTE *)&buf, &size);\n+    {\n+    }\n+    ret = CryptDecodeObjectEx(dwEncoding, ((LPCSTR)9),\n+     0x08000, ((void *)0), (BYTE *)&buf, &size);\n+    {\n+        (winetest_set_location(\"encode.c\", 4355), 0) ? 0 : winetest_ok(size >= sizeof(CERT_AUTHORITY_KEY_ID_INFO), \"Unexpected size %d\\n\",\n+         \"Unexpected serial number\\n\");\n+    }\n+}\n+static void testExportPublicKey(HCRYPTPROV csp, PCERT_PUBLIC_KEY_INFO *pInfo)\n+{\n+    BOOL ret;\n+    DWORD size = 0;\n+    {\n+        ret = CryptExportPublicKeyInfoEx(csp, 2, 0x00000001,\n+         ((void *)0), 0, ((void *)0), ((void *)0), &size);\n+        {\n+            {\n+                (winetest_set_location(\"encode.c\", 4416), 0) ? 0 : winetest_ok(!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ((*pInfo)->Algorithm.pszObjId) && __builtin_constant_p (\"1.2.840.113549.1.1.1\") && (__s1_len = strlen ((*pInfo)->Algorithm.pszObjId), __s2_len = strlen (\"1.2.840.113549.1.1.1\"), (!((size_t)(const void *)(((*pInfo)->Algorithm.pszObjId) + 1) - (size_t)(const void *)((*pInfo)->Algorithm.pszObjId) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((\"1.2.840.113549.1.1.1\") + 1) - (size_t)(const void *)(\"1.2.840.113549.1.1.1\") == 1) || __s2_len >= 4)) ? __builtin_strcmp ((*pInfo)->Algorithm.pszObjId, \"1.2.840.113549.1.1.1\") : (__builtin_constant_p ((*pInfo)->Algorithm.pszObjId) && ((size_t)(const void *)(((*pInfo)->Algorithm.pszObjId) + 1) - (size_t)(const void *)((*pInfo)->Algorithm.pszObjId) == 1) && (__s1_len = strlen ((*pInfo)->Algorithm.pszObjId), __s1_len < 4) ? (__builtin_constant_p (\"1.2.840.113549.1.1.1\") && ((size_t)(const void *)((\"1.2.840.113549.1.1.1\") + 1) - (size_t)(const void *)(\"1.2.840.113549.1.1.1\") == 1) ? __builtin_strcmp ((*pInfo)->Algorithm.pszObjId, \"1.2.840.113549.1.1.1\") : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"); register int __result = (((__const unsigned char *) (__const char *) ((*pInfo)->Algorithm.pszObjId))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((*pInfo)->Algorithm.pszObjId))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) ((*pInfo)->Algorithm.pszObjId))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) ((*pInfo)->Algorithm.pszObjId))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (\"1.2.840.113549.1.1.1\") && ((size_t)(const void *)((\"1.2.840.113549.1.1.1\") + 1) - (size_t)(const void *)(\"1.2.840.113549.1.1.1\") == 1) && (__s2_len = strlen (\"1.2.840.113549.1.1.1\"), __s2_len < 4) ? (__builtin_constant_p ((*pInfo)->Algorithm.pszObjId) && ((size_t)(const void *)(((*pInfo)->Algorithm.pszObjId) + 1) - (size_t)(const void *)((*pInfo)->Algorithm.pszObjId) == 1) ? __builtin_strcmp ((*pInfo)->Algorithm.pszObjId, \"1.2.840.113549.1.1.1\") : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) ((*pInfo)->Algorithm.pszObjId); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"))[3]); } } __result; }))) : __builtin_strcmp ((*pInfo)->Algorithm.pszObjId, \"1.2.840.113549.1.1.1\")))); }),\n+                 (*pInfo)->Algorithm.pszObjId);\n+            }\n+        }\n+    }\n+}\n+static const BYTE expiredCert[] = { 0x30, 0x82, 0x01, 0x33, 0x30, 0x81, 0xe2,\n+ 0x49, 0xe5, 0xf9, 0x65, 0xf3 };\n+static void testImportPublicKey(HCRYPTPROV csp, PCERT_PUBLIC_KEY_INFO info)\n+{\n+    BOOL ret;\n+    HCRYPTKEY key;\n+    PCCERT_CONTEXT context;\n+    (winetest_set_location(\"encode.c\", 4464), 0) ? 0 : winetest_ok(!ret && GetLastError() == 2,\n+     GetLastError());\n+    {\n+        (winetest_set_location(\"encode.c\", 4485), 0) ? 0 : winetest_ok(!__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (\"1.2.840.113549.1.1.1\") && __builtin_constant_p (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) && (__s1_len = strlen (\"1.2.840.113549.1.1.1\"), __s2_len = strlen (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId), (!((size_t)(const void *)((\"1.2.840.113549.1.1.1\") + 1) - (size_t)(const void *)(\"1.2.840.113549.1.1.1\") == 1) || __s1_len >= 4) && (!((size_t)(const void *)((context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) + 1) - (size_t)(const void *)(context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) == 1) || __s2_len >= 4)) ? __builtin_strcmp (\"1.2.840.113549.1.1.1\", context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) : (__builtin_constant_p (\"1.2.840.113549.1.1.1\") && ((size_t)(const void *)((\"1.2.840.113549.1.1.1\") + 1) - (size_t)(const void *)(\"1.2.840.113549.1.1.1\") == 1) && (__s1_len = strlen (\"1.2.840.113549.1.1.1\"), __s1_len < 4) ? (__builtin_constant_p (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) && ((size_t)(const void *)((context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) + 1) - (size_t)(const void *)(context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) == 1) ? __builtin_strcmp (\"1.2.840.113549.1.1.1\", context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) : (__extension__ ({ __const unsigned char *__s2 = (__const unsigned char *) (__const char *) (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId); register int __result = (((__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) && ((size_t)(const void *)((context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) + 1) - (size_t)(const void *)(context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) == 1) && (__s2_len = strlen (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId), __s2_len < 4) ? (__builtin_constant_p (\"1.2.840.113549.1.1.1\") && ((size_t)(const void *)((\"1.2.840.113549.1.1.1\") + 1) - (size_t)(const void *)(\"1.2.840.113549.1.1.1\") == 1) ? __builtin_strcmp (\"1.2.840.113549.1.1.1\", context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId) : (__extension__ ({ __const unsigned char *__s1 = (__const unsigned char *) (__const char *) (\"1.2.840.113549.1.1.1\"); register int __result = __s1[0] - ((__const unsigned char *) (__const char *) (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((__const unsigned char *) (__const char *) (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((__const unsigned char *) (__const char *) (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((__const unsigned char *) (__const char *) (context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId))[3]); } } __result; }))) : __builtin_strcmp (\"1.2.840.113549.1.1.1\", context->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId)))); }),\n+         &context->pCertInfo->SubjectPublicKeyInfo, 0, 0, ((void *)0), &key);\n+    }\n+}\n+static const char cspName[] = \"WineCryptTemp\";\n+static void testPortPublicKeyInfo(void)\n+{\n+    HCRYPTPROV csp;\n+    BOOL ret;\n+    CryptAcquireContextA(&csp, cspName, \"Microsoft Base Cryptographic Provider v1.0\", 1,\n+     0x00000008);\n+    ret = CryptAcquireContextA(&csp, cspName, \"Microsoft Base Cryptographic Provider v1.0\", 1,\n+     0x00000010);\n+}\n+void func_encode(void)\n+{\n+    test_encodeCRLDistPoints(0x00000001);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" xxxinfo = {}\" 1 \"dse1\"} } */\n+/* { dg-final { cleanup-tree-dump \"dse1\" } } */"}, {"sha": "bb5d14d78f9731371f5881e9dd74ae019f7978cd", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f84b066791763e603fa12330f381bef3353d4e8/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f84b066791763e603fa12330f381bef3353d4e8/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=0f84b066791763e603fa12330f381bef3353d4e8", "patch": "@@ -283,6 +283,32 @@ dse_possible_dead_store_p (tree stmt,\n       gcc_assert (*use_p != NULL_USE_OPERAND_P);\n       *first_use_p = *use_p;\n \n+      /* In the case of memory partitions, we may get:\n+\n+\t   # MPT.764_162 = VDEF <MPT.764_161(D)>\n+\t   x = {};\n+\t   # MPT.764_167 = VDEF <MPT.764_162>\n+\t   y = {};\n+\n+\t   So we must make sure we're talking about the same LHS.\n+      */\n+      if (TREE_CODE (temp) == GIMPLE_MODIFY_STMT)\n+\t{\n+\t  tree base1 = get_base_address (GIMPLE_STMT_OPERAND (stmt, 0));\n+\t  tree base2 =  get_base_address (GIMPLE_STMT_OPERAND (temp, 0));\n+\n+\t  while (base1 && INDIRECT_REF_P (base1))\n+\t    base1 = TREE_OPERAND (base1, 0);\n+\t  while (base2 && INDIRECT_REF_P (base2))\n+\t    base2 = TREE_OPERAND (base2, 0);\n+\n+\t  if (base1 != base2)\n+\t    {\n+\t      fail = true;\n+\t      break;\n+\t    }\n+\t}\n+\n       /* If the immediate use of DEF_VAR is not the same as the\n \t previously find immediate uses, then we will not be able\n \t to eliminate STMT.  */"}]}