{"sha": "56bab4461e068180a6221184fc399adadc909035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiYWI0NDYxZTA2ODE4MGE2MjIxMTg0ZmMzOTlhZGFkYzkwOTAzNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-03-04T20:11:08Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-03-04T20:11:08Z"}, "message": "ppro.md: Rewrite as a DFA pipeline description.\n\n\t* ppro.md: Rewrite as a DFA pipeline description.\n\t* i386.md: Remove all uses of the ppro_uops attribute.\n\t* i386.c: (ix86_safe_ppro_uops, ix86_dump_ppro_packet,\n\tix86_reorder_insn, ix86_sched_reorder_ppro, ix86_sched_init,\n\tix86_sched_reorder, ix86_variable_issue,\n\tstruct ix86_sched_data, TARGET_SCHED_VARIABLE_ISSUE,\n\tTARGET_SCHED_INIT, TARGET_SCHED_REORDER): Remove.\n\t(ia32_use_dfa_pipeline_interface): Add TARGET_PENTIUMPRO.\n\t(ia32_multipass_dfa_lookahead): Add TARGET_PENTIUMPRO.\n\t* athlon.md (athlon_ssecmp_load): Fix comment\n\nFrom-SVN: r78933", "tree": {"sha": "e8688c0f8101126c3a314ae3b7d4612ac790b1ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8688c0f8101126c3a314ae3b7d4612ac790b1ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56bab4461e068180a6221184fc399adadc909035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56bab4461e068180a6221184fc399adadc909035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56bab4461e068180a6221184fc399adadc909035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56bab4461e068180a6221184fc399adadc909035/comments", "author": null, "committer": null, "parents": [{"sha": "5a26b329043d2e5f3ba3ab31073cedcf5c508ed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a26b329043d2e5f3ba3ab31073cedcf5c508ed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a26b329043d2e5f3ba3ab31073cedcf5c508ed0"}], "stats": {"total": 1275, "additions": 804, "deletions": 471}, "files": [{"sha": "85b7c0eba31b71c9843d22f9fc00261946aed425", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bab4461e068180a6221184fc399adadc909035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bab4461e068180a6221184fc399adadc909035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56bab4461e068180a6221184fc399adadc909035", "patch": "@@ -1,7 +1,22 @@\n+2004-03-04  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* ppro.md: Rewrite as a DFA pipeline description.\n+\t* i386.md: Remove all uses of the ppro_uops attribute.\n+\t* i386.c: (ix86_safe_ppro_uops, ix86_dump_ppro_packet,\n+\tix86_reorder_insn, ix86_sched_reorder_ppro, ix86_sched_init,\n+\tix86_sched_reorder, ix86_variable_issue,\n+\tstruct ix86_sched_data, TARGET_SCHED_VARIABLE_ISSUE,\n+\tTARGET_SCHED_INIT, TARGET_SCHED_REORDER): Remove.\n+\t(ia32_use_dfa_pipeline_interface): Add TARGET_PENTIUMPRO.\n+\t(ia32_multipass_dfa_lookahead): Add TARGET_PENTIUMPRO.\n+\t* athlon.md (athlon_ssecmp_load): Fix comment\n+\n 2004-03-04  Stuart Hastings  <stuart@apple.com>\n+\n \t* gcc/doc/invoke.texi: Document -mlongcall for Darwin/PPC.\n \n 2004-03-04  Stuart Hastings  <stuart@apple.com>\n+\n \t* gcc/config/i386/darwin.h: Darwin/x86 doesn't support CPUs before\n \t686, tell Darwin assembler to allow prefetch insns, non-empty def\n \tof SUBTARGET_OPTION_TRANSLATE_TABLE."}, {"sha": "308ae1e381c8c1fb14da69d6021386cd230449cf", "filename": "gcc/config/i386/athlon.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bab4461e068180a6221184fc399adadc909035/gcc%2Fconfig%2Fi386%2Fathlon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bab4461e068180a6221184fc399adadc909035/gcc%2Fconfig%2Fi386%2Fathlon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fathlon.md?ref=56bab4461e068180a6221184fc399adadc909035", "patch": "@@ -581,7 +581,7 @@\n \t\t\t (and (eq_attr \"cpu\" \"k8\")\n \t\t\t      (eq_attr \"type\" \"sselog\"))\n \t\t\t \"athlon-double,athlon-fpsched,athlon-fmul\")\n-;; ??? pcmp executes in addmul, probably not wortwhile to brother about that.\n+;; ??? pcmp executes in addmul, probably not worthwhile to bother about that.\n (define_insn_reservation \"athlon_ssecmp_load\" 2\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")\n \t\t\t      (and (eq_attr \"type\" \"ssecmp\")"}, {"sha": "58e26333a5ca73a7ca70a4cbeee42972e6e3965b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 249, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bab4461e068180a6221184fc399adadc909035/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bab4461e068180a6221184fc399adadc909035/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=56bab4461e068180a6221184fc399adadc909035", "patch": "@@ -806,26 +806,19 @@ static rtx gen_push (rtx);\n static int memory_address_length (rtx addr);\n static int ix86_flags_dependant (rtx, rtx, enum attr_type);\n static int ix86_agi_dependant (rtx, rtx, enum attr_type);\n-static enum attr_ppro_uops ix86_safe_ppro_uops (rtx);\n-static void ix86_dump_ppro_packet (FILE *);\n-static void ix86_reorder_insn (rtx *, rtx *);\n static struct machine_function * ix86_init_machine_status (void);\n static int ix86_split_to_parts (rtx, rtx *, enum machine_mode);\n static int ix86_nsaved_regs (void);\n static void ix86_emit_save_regs (void);\n static void ix86_emit_save_regs_using_mov (rtx, HOST_WIDE_INT);\n static void ix86_emit_restore_regs_using_mov (rtx, HOST_WIDE_INT, int);\n static void ix86_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void ix86_sched_reorder_ppro (rtx *, rtx *);\n static HOST_WIDE_INT ix86_GOT_alias_set (void);\n static void ix86_adjust_counter (rtx, HOST_WIDE_INT);\n static rtx ix86_expand_aligntest (rtx, int);\n static void ix86_expand_strlensi_unroll_1 (rtx, rtx, rtx);\n static int ix86_issue_rate (void);\n static int ix86_adjust_cost (rtx, rtx, rtx, int);\n-static void ix86_sched_init (FILE *, int, int);\n-static int ix86_sched_reorder (FILE *, int, rtx *, int *, int);\n-static int ix86_variable_issue (FILE *, int, rtx, int);\n static int ia32_use_dfa_pipeline_interface (void);\n static int ia32_multipass_dfa_lookahead (void);\n static void ix86_init_mmx_sse_builtins (void);\n@@ -975,12 +968,6 @@ static void init_ext_80387_constants (void);\n #define TARGET_SCHED_ADJUST_COST ix86_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE ix86_issue_rate\n-#undef TARGET_SCHED_VARIABLE_ISSUE\n-#define TARGET_SCHED_VARIABLE_ISSUE ix86_variable_issue\n-#undef TARGET_SCHED_INIT\n-#define TARGET_SCHED_INIT ix86_sched_init\n-#undef TARGET_SCHED_REORDER\n-#define TARGET_SCHED_REORDER ix86_sched_reorder\n #undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \\\n   ia32_use_dfa_pipeline_interface\n@@ -12321,244 +12308,12 @@ ix86_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n   return cost;\n }\n \n-static union\n-{\n-  struct ppro_sched_data\n-  {\n-    rtx decode[3];\n-    int issued_this_cycle;\n-  } ppro;\n-} ix86_sched_data;\n-\n-static enum attr_ppro_uops\n-ix86_safe_ppro_uops (rtx insn)\n-{\n-  if (recog_memoized (insn) >= 0)\n-    return get_attr_ppro_uops (insn);\n-  else\n-    return PPRO_UOPS_MANY;\n-}\n-\n-static void\n-ix86_dump_ppro_packet (FILE *dump)\n-{\n-  if (ix86_sched_data.ppro.decode[0])\n-    {\n-      fprintf (dump, \"PPRO packet: %d\",\n-\t       INSN_UID (ix86_sched_data.ppro.decode[0]));\n-      if (ix86_sched_data.ppro.decode[1])\n-\tfprintf (dump, \" %d\", INSN_UID (ix86_sched_data.ppro.decode[1]));\n-      if (ix86_sched_data.ppro.decode[2])\n-\tfprintf (dump, \" %d\", INSN_UID (ix86_sched_data.ppro.decode[2]));\n-      fputc ('\\n', dump);\n-    }\n-}\n-\n-/* We're beginning a new block.  Initialize data structures as necessary.  */\n-\n-static void\n-ix86_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n-\t\t int sched_verbose ATTRIBUTE_UNUSED,\n-\t\t int veclen ATTRIBUTE_UNUSED)\n-{\n-  memset (&ix86_sched_data, 0, sizeof (ix86_sched_data));\n-}\n-\n-/* Shift INSN to SLOT, and shift everything else down.  */\n-\n-static void\n-ix86_reorder_insn (rtx *insnp, rtx *slot)\n-{\n-  if (insnp != slot)\n-    {\n-      rtx insn = *insnp;\n-      do\n-\tinsnp[0] = insnp[1];\n-      while (++insnp != slot);\n-      *insnp = insn;\n-    }\n-}\n-\n-static void\n-ix86_sched_reorder_ppro (rtx *ready, rtx *e_ready)\n-{\n-  rtx decode[3];\n-  enum attr_ppro_uops cur_uops;\n-  int issued_this_cycle;\n-  rtx *insnp;\n-  int i;\n-\n-  /* At this point .ppro.decode contains the state of the three\n-     decoders from last \"cycle\".  That is, those insns that were\n-     actually independent.  But here we're scheduling for the\n-     decoder, and we may find things that are decodable in the\n-     same cycle.  */\n-\n-  memcpy (decode, ix86_sched_data.ppro.decode, sizeof (decode));\n-  issued_this_cycle = 0;\n-\n-  insnp = e_ready;\n-  cur_uops = ix86_safe_ppro_uops (*insnp);\n-\n-  /* If the decoders are empty, and we've a complex insn at the\n-     head of the priority queue, let it issue without complaint.  */\n-  if (decode[0] == NULL)\n-    {\n-      if (cur_uops == PPRO_UOPS_MANY)\n-\t{\n-\t  decode[0] = *insnp;\n-\t  goto ppro_done;\n-\t}\n-\n-      /* Otherwise, search for a 2-4 uop unsn to issue.  */\n-      while (cur_uops != PPRO_UOPS_FEW)\n-\t{\n-\t  if (insnp == ready)\n-\t    break;\n-\t  cur_uops = ix86_safe_ppro_uops (*--insnp);\n-\t}\n-\n-      /* If so, move it to the head of the line.  */\n-      if (cur_uops == PPRO_UOPS_FEW)\n-\tix86_reorder_insn (insnp, e_ready);\n-\n-      /* Issue the head of the queue.  */\n-      issued_this_cycle = 1;\n-      decode[0] = *e_ready--;\n-    }\n-\n-  /* Look for simple insns to fill in the other two slots.  */\n-  for (i = 1; i < 3; ++i)\n-    if (decode[i] == NULL)\n-      {\n-\tif (ready > e_ready)\n-\t  goto ppro_done;\n-\n-\tinsnp = e_ready;\n-\tcur_uops = ix86_safe_ppro_uops (*insnp);\n-\twhile (cur_uops != PPRO_UOPS_ONE)\n-\t  {\n-\t    if (insnp == ready)\n-\t      break;\n-\t    cur_uops = ix86_safe_ppro_uops (*--insnp);\n-\t  }\n-\n-\t/* Found one.  Move it to the head of the queue and issue it.  */\n-\tif (cur_uops == PPRO_UOPS_ONE)\n-\t  {\n-\t    ix86_reorder_insn (insnp, e_ready);\n-\t    decode[i] = *e_ready--;\n-\t    issued_this_cycle++;\n-\t    continue;\n-\t  }\n-\n-\t/* ??? Didn't find one.  Ideally, here we would do a lazy split\n-\t   of 2-uop insns, issue one and queue the other.  */\n-      }\n-\n- ppro_done:\n-  if (issued_this_cycle == 0)\n-    issued_this_cycle = 1;\n-  ix86_sched_data.ppro.issued_this_cycle = issued_this_cycle;\n-}\n-\n-/* We are about to being issuing insns for this clock cycle.\n-   Override the default sort algorithm to better slot instructions.  */\n-static int\n-ix86_sched_reorder (FILE *dump ATTRIBUTE_UNUSED,\n-\t\t    int sched_verbose ATTRIBUTE_UNUSED, rtx *ready,\n-\t\t    int *n_readyp, int clock_var ATTRIBUTE_UNUSED)\n-{\n-  int n_ready = *n_readyp;\n-  rtx *e_ready = ready + n_ready - 1;\n-\n-  /* Make sure to go ahead and initialize key items in\n-     ix86_sched_data if we are not going to bother trying to\n-     reorder the ready queue.  */\n-  if (n_ready < 2)\n-    {\n-      ix86_sched_data.ppro.issued_this_cycle = 1;\n-      goto out;\n-    }\n-\n-  switch (ix86_tune)\n-    {\n-    default:\n-      break;\n-\n-    case PROCESSOR_PENTIUMPRO:\n-      ix86_sched_reorder_ppro (ready, e_ready);\n-      break;\n-    }\n-\n-out:\n-  return ix86_issue_rate ();\n-}\n-\n-/* We are about to issue INSN.  Return the number of insns left on the\n-   ready queue that can be issued this cycle.  */\n-\n-static int\n-ix86_variable_issue (FILE *dump, int sched_verbose, rtx insn,\n-\t\t     int can_issue_more)\n-{\n-  int i;\n-  switch (ix86_tune)\n-    {\n-    default:\n-      return can_issue_more - 1;\n-\n-    case PROCESSOR_PENTIUMPRO:\n-      {\n-\tenum attr_ppro_uops uops = ix86_safe_ppro_uops (insn);\n-\n-\tif (uops == PPRO_UOPS_MANY)\n-\t  {\n-\t    if (sched_verbose)\n-\t      ix86_dump_ppro_packet (dump);\n-\t    ix86_sched_data.ppro.decode[0] = insn;\n-\t    ix86_sched_data.ppro.decode[1] = NULL;\n-\t    ix86_sched_data.ppro.decode[2] = NULL;\n-\t    if (sched_verbose)\n-\t      ix86_dump_ppro_packet (dump);\n-\t    ix86_sched_data.ppro.decode[0] = NULL;\n-\t  }\n-\telse if (uops == PPRO_UOPS_FEW)\n-\t  {\n-\t    if (sched_verbose)\n-\t      ix86_dump_ppro_packet (dump);\n-\t    ix86_sched_data.ppro.decode[0] = insn;\n-\t    ix86_sched_data.ppro.decode[1] = NULL;\n-\t    ix86_sched_data.ppro.decode[2] = NULL;\n-\t  }\n-\telse\n-\t  {\n-\t    for (i = 0; i < 3; ++i)\n-\t      if (ix86_sched_data.ppro.decode[i] == NULL)\n-\t\t{\n-\t\t  ix86_sched_data.ppro.decode[i] = insn;\n-\t\t  break;\n-\t\t}\n-\t    if (i == 3)\n-\t      abort ();\n-\t    if (i == 2)\n-\t      {\n-\t        if (sched_verbose)\n-\t          ix86_dump_ppro_packet (dump);\n-\t\tix86_sched_data.ppro.decode[0] = NULL;\n-\t\tix86_sched_data.ppro.decode[1] = NULL;\n-\t\tix86_sched_data.ppro.decode[2] = NULL;\n-\t      }\n-\t  }\n-      }\n-      return --ix86_sched_data.ppro.issued_this_cycle;\n-    }\n-}\n-\n static int\n ia32_use_dfa_pipeline_interface (void)\n {\n-  if (TARGET_PENTIUM || TARGET_ATHLON_K8)\n+  if (TARGET_PENTIUM\n+      || TARGET_PENTIUMPRO\n+      || TARGET_ATHLON_K8)\n     return 1;\n   return 0;\n }\n@@ -12572,8 +12327,12 @@ ia32_multipass_dfa_lookahead (void)\n {\n   if (ix86_tune == PROCESSOR_PENTIUM)\n     return 2;\n+\n+  if (ix86_tune == PROCESSOR_PENTIUMPRO)\n+    return 1;\n+\n   else\n-   return 0;\n+    return 0;\n }\n \n \f"}, {"sha": "e957552b9d7387d05e04792db8bcbc1a6783acfc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 35, "deletions": 89, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bab4461e068180a6221184fc399adadc909035/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bab4461e068180a6221184fc399adadc909035/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=56bab4461e068180a6221184fc399adadc909035", "patch": "@@ -246,7 +246,7 @@\n     (const_int 1)\n     (const_int 0)))\n \n-;; Set when 0f opcode prefix is used.\n+;; Set when REX opcode prefix is used.\n (define_attr \"prefix_rex\" \"\"\n   (cond [(and (eq_attr \"mode\" \"DI\")\n   \t      (eq_attr \"type\" \"!push,pop,call,callv,leave,ibr\"))\n@@ -939,8 +939,7 @@\n   \"fnstsw\\t%0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"mode\" \"SI\")\n-   (set_attr \"unit\" \"i387\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"unit\" \"i387\")])\n \n ;; FP compares, step 3\n ;; Get ax into flags, general case.\n@@ -952,8 +951,7 @@\n   \"sahf\"\n   [(set_attr \"length\" \"1\")\n    (set_attr \"athlon_decode\" \"vector\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"ppro_uops\" \"one\")])\n+   (set_attr \"mode\" \"SI\")])\n \n ;; Pentium Pro can do steps 1 through 3 in one go.\n \n@@ -1264,8 +1262,7 @@\n    (set_attr \"pent_pair\" \"np\")\n    (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"mode\" \"SI\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"modrm\" \"0\")])\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n@@ -1384,8 +1381,7 @@\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"pent_pair\" \"np\")\n    (set_attr \"mode\" \"HI\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"modrm\" \"0\")])\n \n (define_insn \"*swaphi_2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"+r\")\n@@ -1397,8 +1393,7 @@\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"pent_pair\" \"np\")\n    (set_attr \"mode\" \"SI\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"modrm\" \"0\")])\n \n (define_expand \"movstricthi\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"\"))\n@@ -1557,8 +1552,7 @@\n   [(set_attr \"type\" \"imov\")\n    (set_attr \"pent_pair\" \"np\")\n    (set_attr \"mode\" \"QI\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"modrm\" \"0\")])\n \n (define_expand \"movstrictqi\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"\"))\n@@ -2115,8 +2109,7 @@\n    (set_attr \"pent_pair\" \"np\")\n    (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"mode\" \"DI\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"modrm\" \"0\")])\n \n   \n (define_expand \"movsf\"\n@@ -4450,8 +4443,7 @@\n   \"fnstcw\\t%0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"mode\" \"HI\")\n-   (set_attr \"unit\" \"i387\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"unit\" \"i387\")])\n \n (define_insn \"x86_fldcw_1\"\n   [(set (reg:HI 18)\n@@ -4461,8 +4453,7 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"mode\" \"HI\")\n    (set_attr \"unit\" \"i387\")\n-   (set_attr \"athlon_decode\" \"vector\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"athlon_decode\" \"vector\")])\n \f\n ;; Conversion between fixed point and floating point.\n \n@@ -4972,8 +4963,7 @@\n   \"adc{q}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"mode\" \"DI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"DI\")])\n \n (define_insn \"*adddi3_cc_rex64\"\n   [(set (reg:CC 17)\n@@ -4997,8 +4987,7 @@\n   \"adc{b}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"mode\" \"QI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"QI\")])\n \n (define_insn \"addhi3_carry\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n@@ -5010,8 +4999,7 @@\n   \"adc{w}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"mode\" \"HI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"HI\")])\n \n (define_insn \"addsi3_carry\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n@@ -5023,8 +5011,7 @@\n   \"adc{l}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*addsi3_carry_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -5037,8 +5024,7 @@\n   \"adc{l}\\t{%2, %k0|%k0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*addsi3_cc\"\n   [(set (reg:CC 17)\n@@ -6645,7 +6631,6 @@\n   \"sbb{q}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_insn \"*subdi_1_rex64\"\n@@ -6694,7 +6679,6 @@\n   \"sbb{b}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_insn \"subhi3_carry\"\n@@ -6707,7 +6691,6 @@\n   \"sbb{w}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"HI\")])\n \n (define_insn \"subsi3_carry\"\n@@ -6720,7 +6703,6 @@\n   \"sbb{l}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"subsi3_carry_zext\"\n@@ -6734,7 +6716,6 @@\n   \"sbb{l}\\t{%2, %k0|%k0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"pent_pair\" \"pu\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_expand \"subsi3\"\n@@ -7155,7 +7136,6 @@\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"mul{q}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n@@ -7183,7 +7163,6 @@\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"mul{l}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n@@ -7272,7 +7251,6 @@\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"mul{q}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n@@ -7308,7 +7286,6 @@\n   \"GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM\"\n   \"mul{l}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n@@ -7331,7 +7308,6 @@\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"mul{l}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"length_immediate\" \"0\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n@@ -7368,7 +7344,6 @@\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"imul{q}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n@@ -7403,7 +7378,6 @@\n   \"GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM\"\n   \"imul{l}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n@@ -7425,7 +7399,6 @@\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"imul{l}\\t%2\"\n   [(set_attr \"type\" \"imul\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set (attr \"athlon_decode\")\n      (if_then_else (eq_attr \"cpu\" \"athlon\")\n         (const_string \"vector\")\n@@ -7465,8 +7438,7 @@\n   \"TARGET_QIMODE_MATH\"\n   \"idiv{b}\\t%2\"\n   [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"QI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"QI\")])\n \n (define_insn \"udivqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=a\")\n@@ -7476,8 +7448,7 @@\n   \"TARGET_QIMODE_MATH\"\n   \"div{b}\\t%2\"\n   [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"QI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"QI\")])\n \n ;; The patterns that match these are at the end of this file.\n \n@@ -7550,8 +7521,7 @@\n   \"TARGET_64BIT\"\n   \"idiv{q}\\t%2\"\n   [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"DI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"DI\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -7635,8 +7605,7 @@\n   \"\"\n   \"idiv{l}\\t%2\"\n   [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"SI\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -7710,7 +7679,6 @@\n   \"TARGET_64BIT\"\n   \"div{q}\\t%2\"\n   [(set_attr \"type\" \"idiv\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"DI\")])\n \n (define_split\n@@ -7754,7 +7722,6 @@\n   \"\"\n   \"div{l}\\t%2\"\n   [(set_attr \"type\" \"idiv\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_split\n@@ -7797,8 +7764,7 @@\n   \"\"\n   \"div{w}\\t%2\"\n   [(set_attr \"type\" \"idiv\")\n-   (set_attr \"mode\" \"HI\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"HI\")])\n \n ;; We can not use div/idiv for double division, because it causes\n ;; \"division by zero\" on the overflow and that's not what we expect\n@@ -7817,8 +7783,7 @@\n ;   (clobber (reg:CC 17))]\n ;  \"\"\n ;  \"div{l}\\t{%2, %0|%0, %2}\"\n-;  [(set_attr \"type\" \"idiv\")\n-;   (set_attr \"ppro_uops\" \"few\")])\n+;  [(set_attr \"type\" \"idiv\")])\n \f\n ;;- Logical AND instructions\n \n@@ -9932,17 +9897,15 @@\n   \"TARGET_80387 && reload_completed\"\n   \"fchs\"\n   [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"SF\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"SF\")])\n \n (define_insn \"*negdf2_1\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(neg:DF (match_operand:DF 1 \"register_operand\" \"0\")))]\n   \"TARGET_80387 && reload_completed\"\n   \"fchs\"\n   [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"DF\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*negextendsfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n@@ -9951,17 +9914,15 @@\n   \"TARGET_80387\"\n   \"fchs\"\n   [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"DF\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"DF\")])\n \n (define_insn \"*negxf2_1\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(neg:XF (match_operand:XF 1 \"register_operand\" \"0\")))]\n   \"TARGET_80387 && reload_completed\"\n   \"fchs\"\n   [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"XF\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"XF\")])\n \n (define_insn \"*negextenddfxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n@@ -9970,8 +9931,7 @@\n   \"TARGET_80387\"\n   \"fchs\"\n   [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"XF\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"XF\")])\n \n (define_insn \"*negextendsfxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n@@ -9980,8 +9940,7 @@\n   \"TARGET_80387\"\n   \"fchs\"\n   [(set_attr \"type\" \"fsgn\")\n-   (set_attr \"mode\" \"XF\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"mode\" \"XF\")])\n \f\n ;; Absolute value instructions\n \n@@ -10762,8 +10721,7 @@\n    (set_attr \"prefix_0f\" \"1\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"athlon_decode\" \"vector\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+   (set_attr \"athlon_decode\" \"vector\")])\n \n (define_expand \"x86_shift_adj_1\"\n   [(set (reg:CCZ 17)\n@@ -11466,7 +11424,6 @@\n   [(set_attr \"type\" \"ishift\")\n    (set_attr \"prefix_0f\" \"1\")\n    (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"ppro_uops\" \"few\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_expand \"x86_shift_adj_3\"\n@@ -13484,8 +13441,7 @@\n   else\n     return \"dec{l}\\t%1\\;%+jne\\t%l0\";\n }\n-  [(set_attr \"ppro_uops\" \"many\")\n-   (set (attr \"length\")\n+  [(set (attr \"length\")\n \t(if_then_else (and (eq_attr \"alternative\" \"0\")\n \t\t\t   (and (ge (minus (match_dup 0) (pc))\n \t\t\t            (const_int -126))\n@@ -13871,8 +13827,7 @@\n   \"nop\"\n   [(set_attr \"length\" \"1\")\n    (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"modrm\" \"0\")\n-   (set_attr \"ppro_uops\" \"one\")])\n+   (set_attr \"modrm\" \"0\")])\n \n ;; Align to 16-byte boundary, max skip in op0.  Used to avoid\n ;; branch prediction penalty for the third jump in a 16-byte\n@@ -14033,17 +13988,15 @@\n \t(ctz:SI (match_dup 1)))]\n   \"\"\n   \"bsf{l}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"prefix_0f\" \"1\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+  [(set_attr \"prefix_0f\" \"1\")])\n \n (define_insn \"ctzsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ctz:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))\n    (clobber (reg:CC 17))]\n   \"\"\n   \"bsf{l}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"prefix_0f\" \"1\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+  [(set_attr \"prefix_0f\" \"1\")])\n \n (define_expand \"clzsi2\"\n   [(parallel\n@@ -14064,8 +14017,7 @@\n    (clobber (reg:CC 17))]\n   \"\"\n   \"bsr{l}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"prefix_0f\" \"1\")\n-   (set_attr \"ppro_uops\" \"few\")])\n+  [(set_attr \"prefix_0f\" \"1\")])\n \f\n ;; Thread-local storage patterns for ELF.\n ;;\n@@ -14482,7 +14434,6 @@\n               ]\n               (const_string \"fop\")))\n    (set_attr \"fp_int_src\" \"true\")\n-   (set_attr \"ppro_uops\" \"many\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*fop_sf_3\"\n@@ -14500,7 +14451,6 @@\n               ]\n               (const_string \"fop\")))\n    (set_attr \"fp_int_src\" \"true\")\n-   (set_attr \"ppro_uops\" \"many\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*fop_df_1_nosse\"\n@@ -14581,7 +14531,6 @@\n               ]\n               (const_string \"fop\")))\n    (set_attr \"fp_int_src\" \"true\")\n-   (set_attr \"ppro_uops\" \"many\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*fop_df_3\"\n@@ -14599,7 +14548,6 @@\n               ]\n               (const_string \"fop\")))\n    (set_attr \"fp_int_src\" \"true\")\n-   (set_attr \"ppro_uops\" \"many\")\n    (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*fop_df_4\"\n@@ -14686,8 +14634,7 @@\n               ]\n               (const_string \"fop\")))\n    (set_attr \"fp_int_src\" \"true\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"ppro_uops\" \"many\")])\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*fop_xf_3\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")\n@@ -14704,8 +14651,7 @@\n               ]\n               (const_string \"fop\")))\n    (set_attr \"fp_int_src\" \"true\")\n-   (set_attr \"mode\" \"SI\")\n-   (set_attr \"ppro_uops\" \"many\")])\n+   (set_attr \"mode\" \"SI\")])\n \n (define_insn \"*fop_xf_4\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f,f\")"}, {"sha": "fc1374d59386ba2b778fbedf9fe35e3bcc652617", "filename": "gcc/config/i386/ppro.md", "status": "modified", "additions": 745, "deletions": 132, "changes": 877, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56bab4461e068180a6221184fc399adadc909035/gcc%2Fconfig%2Fi386%2Fppro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56bab4461e068180a6221184fc399adadc909035/gcc%2Fconfig%2Fi386%2Fppro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fppro.md?ref=56bab4461e068180a6221184fc399adadc909035", "patch": "@@ -1,5 +1,5 @@\n-;; Pentium Pro/PII Scheduling\n-;; Copyright (C) 2002 Free Software Foundation, Inc.\n+;; Scheduling for the Intel P6 family of processors\n+;; Copyright (C) 2004 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -18,133 +18,746 @@\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.  */\n \n-;; Categorize how many uops an ia32 instruction evaluates to:\n-;;   one --  an instruction with 1 uop can be decoded by any of the\n-;;           three decoders.\n-;;   few --  an instruction with 1 to 4 uops can be decoded only by \n-;;\t     decoder 0.\n-;;   many -- a complex instruction may take an unspecified number of\n-;;\t     cycles to decode in decoder 0.\n-\n-(define_attr \"ppro_uops\" \"one,few,many\"\n-  (cond [(eq_attr \"type\" \"other,multi,call,callv,fpspc,str\")\n-\t   (const_string \"many\")\n-\t (eq_attr \"type\" \"icmov,fcmov,str,cld,leave\")\n-\t   (const_string \"few\")\n-\t (eq_attr \"type\" \"imov\")\n-\t   (if_then_else (eq_attr \"memory\" \"store,both\")\n-\t     (const_string \"few\")\n-\t     (const_string \"one\"))\n-\t (eq_attr \"memory\" \"!none\")\n-\t   (const_string \"few\")\n-\t]\n-\t(const_string \"one\")))\n-\n-;;\n-;; The PPro has an out-of-order core, but the instruction decoders are\n-;; naturally in-order and asymmetric.  We get best performance by scheduling\n-;; for the decoders, for in doing so we give the oo execution unit the \n-;; most choices.\n-;;\n-;; Rough readiness numbers.  Fine tuning happens in i386.c.\n-;;\n-;; p0\tdescribes port 0.\n-;; p01\tdescribes ports 0 and 1 as a pair; alu insns can issue to either.\n-;; p2\tdescribes port 2 for loads.\n-;; p34\tdescribes ports 3 and 4 for stores.\n-;; fpu\tdescribes the fpu accessed via port 0. \n-;;\t??? It is less than clear if there are separate fadd and fmul units\n-;;\tthat could operate in parallel.\n-;;\n-;; ??? fxch isn't handled; not an issue until sched3 after reg-stack is real.\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"ishift,rotate,ishift1,rotate1,lea,ibr,cld\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"imul\"))\n-  4 1)\n-\n-;; ??? Does the divider lock out the pipe while it works,\n-;; or is there a disconnected unit?\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"idiv\"))\n-  17 17)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fop,fsgn,fistp\"))\n-  3 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fcmov\"))\n-  2 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fcmp\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fmov\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fmul\"))\n-  5 1)\n-\n-(define_function_unit \"ppro_p0\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fdiv,fpspc\"))\n-  56 1)\n-\n-(define_function_unit \"ppro_p01\" 2 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"!imov,fmov\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p01\" 2 0\n-  (and (and (eq_attr \"cpu\" \"pentiumpro\")\n-            (eq_attr \"type\" \"imov,fmov\"))\n-       (eq_attr \"memory\" \"none\"))\n-  1 1)\n-\n-(define_function_unit \"ppro_p2\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (ior (eq_attr \"type\" \"pop,leave\")\n-\t    (eq_attr \"memory\" \"load,both\")))\n-  3 1)\n-\n-(define_function_unit \"ppro_p34\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (ior (eq_attr \"type\" \"push\")\n-\t    (eq_attr \"memory\" \"store,both\")))\n-  1 1)\n-\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fop,fsgn,fmov,fcmp,fcmov,fistp\"))\n-  1 1)\n-\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fmul\"))\n-  5 2)\n-\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"fdiv,fpspc\"))\n-  56 56)\n-\n-;; imul uses the fpu.  ??? does it have the same throughput as fmul?\n-(define_function_unit \"fpu\" 1 0\n-  (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"imul\"))\n-  4 1)\n+;; The P6 familiy includes the Pentium Pro, Pentium II, Pentium III, Celeron\n+;; and Xeon lines of CPUs.  The DFA scheduler description in this file is\n+;; based on information that can be found in the following three documents:\n+;;\n+;;    \"P6 Family of Processors Hardware Developer's Manual\",\n+;;    Intel, September 1999.\n+;;\n+;;    \"Intel Architecture Optimization Manual\",\n+;;    Intel, 1999 (Order Number: 245127-001).\n+;;\n+;;    \"How to optimize for the Pentium family of microprocessors\",\n+;;    by Agner Fog, PhD.\n+;;\n+;; The P6 pipeline has three major components:\n+;;   1) the FETCH/DECODE unit, an in-order issue front-end\n+;;   2) the DISPATCH/EXECUTE unit, which is the out-of-order core\n+;;   3) the RETIRE unit, an in-order retirement unit\n+;;\n+;; So, the P6 CPUs have out-of-order cores, but the instruction decoder and\n+;; retirement unit are naturally in-order.\n+;;\n+;;                       BUS INTERFACE UNIT\n+;;                     /                   \\\n+;;                L1 ICACHE             L1 DCACHE\n+;;              /     |     \\              |     \\\n+;;       DECODER0  DECODER1  DECODER2  DISP/EXEC  RETIRE\n+;;              \\     |     /              |        |\n+;;            INSTRUCTION POOL   __________|_______/\n+;;          (inc. reorder buffer)\n+;;\n+;; Since the P6 CPUs execute instructions out-of-order, the most important\n+;; consideration in performance tuning is making sure enough micro-ops are\n+;; ready for execution in the out-of-order core, while not stalling the\n+;; decoder.\n+;;\n+;; TODO:\n+;; - Find a less crude way to model complex instructions, in\n+;;   particular how many cycles they take to be decoded.\n+;; - Include decoder latencies in the total reservation latencies.\n+;;   This isn't necessary right now because we assume for every\n+;;   instruction that it never blocks a decoder.\n+;; - Figure out where the p0 and p1 reservations come from.  These\n+;;   appear not to be in the manual (e.g. why is cld \"(p0+p1)*2\"\n+;;   better than \"(p0|p1)*4\" ???)\n+;; - Lots more because I'm sure this is still far from optimal :-)\n+\n+;; The ppro_idiv and ppro_fdiv automata are used to model issue\n+;; latencies of idiv and fdiv type insns.\n+(define_automaton \"ppro_decoder,ppro_core,ppro_idiv,ppro_fdiv,ppro_load,ppro_store\")\n+\n+;; Simple instructions of the register-register form have only one uop.\n+;; Load instructions are also only one uop.  Store instructions decode to\n+;; two uops, and simple read-modify instructions also take two uops.\n+;; Simple instructions of the register-memory form have two to three uops.\n+;; Simple read-modify-write instructions have four uops.  The rules for\n+;; the decoder are simple:\n+;;  - an instruction with 1 uop can be decoded by any of the three\n+;;    decoders in one cycle.\n+;;  - an instruction with 1 to 4 uops can be decoded only by decoder 0\n+;;    but still in only one cycle.\n+;;  - a complex (microcode) instruction can also only be decoded by\n+;;    decoder 0, and this takes an unspecified number of cycles.\n+;;    \n+;; The goal is to schedule such that we have a few-one-one uops sequence\n+;; in each cycle, to decode as many instructions per cycle as possible.\n+(define_cpu_unit \"decoder0\" \"ppro_decoder\")\n+(define_cpu_unit \"decoder1\" \"ppro_decoder\")\n+(define_cpu_unit \"decoder2\" \"ppro_decoder\")\n+\n+;; We first wish to find an instruction for decoder0, so exclude\n+;; decoder1 and decoder2 from being reserved until decoder 0 is\n+;; reserved.\n+(presence_set \"decoder1\" \"decoder0\")\n+(presence_set \"decoder2\" \"decoder0\")\n+\n+;; Most instructions can be decoded on any of the three decoders.\n+(define_reservation \"decodern\" \"(decoder0|decoder1|decoder2)\")\n+\n+;; The out-of-order core has five pipelines.  During each cycle, the core\n+;; may dispatch zero or one uop on the port of any of the five pipelines\n+;; so the maximum number of dispatched uops per cycle is 5.  In practicer,\n+;; 3 uops per cycle is more realistic.\n+;;\n+;; Two of the five pipelines contain several execution units:\n+;;\n+;; Port 0\tPort 1\t\tPort 2\t\tPort 3\t\tPort 4\n+;; ALU\t\tALU\t\tLOAD\t\tSAC\t\tSDA\n+;; FPU\t\tJUE\n+;; AGU\t\tMMX\n+;; MMX\t\tP3FPU\n+;; P3FPU\n+;;\n+;; (SAC=Store Address Calculation, SDA=Store Data Unit, P3FPU = SSE unit,\n+;;  JUE = Jump Execution Unit, AGU = Addres Generation Unit)\n+;;\n+(define_cpu_unit \"p0,p1\" \"ppro_core\")\n+(define_cpu_unit \"p2\" \"ppro_load\")\n+(define_cpu_unit \"p3,p4\" \"ppro_store\")\n+(define_cpu_unit \"idiv\" \"ppro_idiv\")\n+(define_cpu_unit \"fdiv\" \"ppro_fdiv\")\n+\n+;; Only the irregular instructions have to be modeled here.  A load\n+;; increases the latency by 2 or 3, or by nothing if the manual gives\n+;; a latency already.  Store latencies are not accounted for.\n+;;\n+;; The simple instructions follow a very regular pattern of 1 uop per\n+;; reg-reg operation, 1 uop per load on port 2. and 2 uops per store\n+;; on port 4 and port 3.  These instructions are modelled at the bottom\n+;; of this file.\n+;;\n+;; For microcoded instructions we don't know how many uops are produced.\n+;; These instructions are the \"complex\" ones in the Intel manuals.  All\n+;; we _do_ know is that they typically produce four or more uops, so\n+;; they can only be decoded on decoder0.  Modelling their latencies\n+;; doesn't make sense because we don't know how these instructions are\n+;; executed in the core.  So we just model that they can only be decoded\n+;; on decoder 0, and say that it takes a little while before the result\n+;; is availale.\n+(define_insn_reservation \"ppro_complex_insn\" 6\n+\t\t\t (eq_attr \"type\" \"other,multi,call,callv,str\")\n+\t\t\t \"decoder0\")\n+\n+;; imov with memory operands does not use the integer units.\n+(define_insn_reservation \"ppro_imov\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"imov\")))\n+\t\t\t \"decodern,(p0|p1)\")\n+\n+(define_insn_reservation \"ppro_imov_load\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (eq_attr \"type\" \"imov\")))\n+\t\t\t \"decodern,p2\")\n+\n+(define_insn_reservation \"ppro_imov_store\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"store\")\n+\t\t\t\t   (eq_attr \"type\" \"imov\")))\n+\t\t\t \"decoder0,p4+p3\")\n+\n+;; imovx always decodes to one uop, and also doesn't use the integer\n+;; units if it has memory operands.\n+(define_insn_reservation \"ppro_imovx\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"imovx\")))\n+\t\t\t \"decodern,(p0|p1)\")\n+\n+(define_insn_reservation \"ppro_imovx_load\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (eq_attr \"type\" \"imovx\")))\n+\t\t\t \"decodern,p2\")\n+\n+;; lea executes on port 0 with latency one and throughput 1.\n+(define_insn_reservation \"ppro_lea\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"lea\")))\n+\t\t\t \"decodern,p0\")\n+\n+;; Shift and rotate execute on port 0 with latency and throughput 1.\n+;; The load and store units need to be reserved when memory operands\n+;; are involved.\n+(define_insn_reservation \"ppro_shift_rotate\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"ishift,ishift1,rotate,rotate1\")))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_shift_rotate_mem\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"!none\")\n+\t\t\t\t   (eq_attr \"type\" \"ishift,ishift1,rotate,rotate1\")))\n+\t\t\t \"decoder0,p2+p0,p4+p3\")\n+\n+(define_insn_reservation \"ppro_cld\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (eq_attr \"type\" \"cld\"))\n+\t\t\t \"decoder0,(p0+p1)*2\")\n+\n+;; The P6 has a sophisticated branch prediction mechanism to miminize\n+;; latencies due to branching.  In particular, it has a fast way to\n+;; execute branches that are taken multiple times (such as in loops).\n+;; Branches not taken suffer no penalty, and correctly predicted\n+;; branches cost only one fetch cycle.  Mispredicted branches are very\n+;; costly: typically 15 cycles and possibly as many as 26 cycles.\n+;;\n+;; Unfortunatetely all this makes it quite difficult to properly model\n+;; the latencies for the compiler.  Here I've made the choice to be\n+;; optimistic and assume branches are often predicted correctly, so\n+;; they have latency 1, and the decoders are not blocked.\n+;;\n+;; In addition, the model assumes a branch always decodes to only 1 uop,\n+;; which is not exactly true because there are a few instructions that\n+;; decode to 2 uops or microcode.  But this probably gives the best\n+;; results because we can assume these instructions can decode on all\n+;; decoders.\n+(define_insn_reservation \"ppro_branch\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"ibr\")))\n+\t\t\t \"decodern,p1\")\n+\n+;; ??? Indirect branches probably have worse latency than this.\n+(define_insn_reservation \"ppro_indirect_branch\" 6\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"!none\")\n+\t\t\t\t   (eq_attr \"type\" \"ibr\")))\n+\t\t\t \"decoder0,p2+p1\")\n+\n+(define_insn_reservation \"ppro_leave\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (eq_attr \"type\" \"leave\"))\n+\t\t\t \"decoder0,p2+(p0|p1),(p0|p1)\")\n+\n+;; imul has throughput one, but latency 4, and can only execute on port 0.\n+(define_insn_reservation \"ppro_imul\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"imul\")))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_imul_mem\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"!none\")\n+\t\t\t\t   (eq_attr \"type\" \"imul\")))\n+\t\t\t \"decoder0,p2+p0\")\n+\n+;; div and idiv are very similar, so we model them the same.\n+;; QI, HI, and SI have issue latency 12, 21, and 37, respectively.\n+;; These issue latencies are modelled via the ppro_div automaton.\n+(define_insn_reservation \"ppro_idiv_QI\" 19\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"QI\")\n+\t\t\t\t\t(eq_attr \"type\" \"idiv\"))))\n+\t\t\t \"decoder0,(p0+idiv)*2,(p0|p1)+idiv,idiv*9\")\n+\n+(define_insn_reservation \"ppro_idiv_QI_load\" 19\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"QI\")\n+\t\t\t\t\t(eq_attr \"type\" \"idiv\"))))\n+\t\t\t \"decoder0,p2+p0+idiv,p0+idiv,(p0|p1)+idiv,idiv*9\")\n+\n+(define_insn_reservation \"ppro_idiv_HI\" 23\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"HI\")\n+\t\t\t\t\t(eq_attr \"type\" \"idiv\"))))\n+\t\t\t \"decoder0,(p0+idiv)*3,(p0|p1)+idiv,idiv*17\")\n+\n+(define_insn_reservation \"ppro_idiv_HI_load\" 23\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"HI\")\n+\t\t\t\t\t(eq_attr \"type\" \"idiv\"))))\n+\t\t\t \"decoder0,p2+p0+idiv,p0+idiv,(p0|p1)+idiv,idiv*18\")\n+\n+(define_insn_reservation \"ppro_idiv_SI\" 39\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SI\")\n+\t\t\t\t\t(eq_attr \"type\" \"idiv\"))))\n+\t\t\t \"decoder0,(p0+idiv)*3,(p0|p1)+idiv,idiv*33\")\n+\n+(define_insn_reservation \"ppro_idiv_SI_load\" 39\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SI\")\n+\t\t\t\t\t(eq_attr \"type\" \"idiv\"))))\n+\t\t\t \"decoder0,p2+p0+idiv,p0+idiv,(p0|p1)+idiv,idiv*34\")\n+\n+;; Floating point operations always execute on port 0.\n+;; ??? where do these latencies come from? fadd has latency 3 and\n+;;     has throughput \"1/cycle (align with FADD)\".  What do they\n+;;     mean and how can we model that?\n+(define_insn_reservation \"ppro_fop\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none,unknown\")\n+\t\t\t\t   (eq_attr \"type\" \"fop\")))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_fop_load\" 5\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (eq_attr \"type\" \"fop\")))\n+\t\t\t \"decoder0,p2+p0,p0\")\n+\n+(define_insn_reservation \"ppro_fop_store\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"store\")\n+\t\t\t\t   (eq_attr \"type\" \"fop\")))\n+\t\t\t \"decoder0,p0,p0,p0+p4+p3\")\n+\n+(define_insn_reservation \"ppro_fop_both\" 5\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"both\")\n+\t\t\t\t   (eq_attr \"type\" \"fop\")))\n+\t\t\t \"decoder0,p2+p0,p0+p4+p3\")\n+\n+(define_insn_reservation \"ppro_fsgn\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (eq_attr \"type\" \"fsgn\"))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_fistp\" 5\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (eq_attr \"type\" \"fistp\"))\n+\t\t\t \"decoder0,p0*2,p4+p3\")\n+\n+(define_insn_reservation \"ppro_fcmov\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (eq_attr \"type\" \"fcmov\"))\n+\t\t\t \"decoder0,p0*2\")\n+\n+(define_insn_reservation \"ppro_fcmp\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"fcmp\")))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_fcmp_load\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (eq_attr \"type\" \"fcmp\")))\n+\t\t\t \"decoder0,p2+p0\")\n+\n+(define_insn_reservation \"ppro_fmov\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"fmov\")))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_fmov_load\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"!XF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fmov\"))))\n+\t\t\t \"decodern,p2\")\n+\n+(define_insn_reservation \"ppro_fmov_XF_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"XF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fmov\"))))\n+\t\t\t \"decoder0,(p2+p0)*2\")\n+\n+(define_insn_reservation \"ppro_fmov_store\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"store\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"!XF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fmov\"))))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_fmov_XF_store\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"store\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"XF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fmov\"))))\n+\t\t\t \"decoder0,(p0+p4),(p0+p3)\")\n+\n+;; fmul executes on port 0 with latency 5.  It has issue latency 2,\n+;; but we don't model this.\n+(define_insn_reservation \"ppro_fmul\" 5\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"fmul\")))\n+\t\t\t \"decoder0,p0*2\")\n+\n+(define_insn_reservation \"ppro_fmul_load\" 6\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (eq_attr \"type\" \"fmul\")))\n+\t\t\t \"decoder0,p2+p0,p0\")\n+\n+;; fdiv latencies depend on the mode of the operands.  XFmode gives\n+;; a latency of 38 cycles, DFmode gives 32, and SFmode gives latency 18.\n+;; Division by a power of 2 takes only 9 cycles, but we cannot model\n+;; that.  Throughput is equal to latency - 1, which we model using the\n+;; ppro_div automaton.\n+(define_insn_reservation \"ppro_fdiv_SF\" 18\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fdiv,fpspc\"))))\n+\t\t\t \"decodern,p0+fdiv,fdiv*16\")\n+\n+(define_insn_reservation \"ppro_fdiv_SF_load\" 19\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fdiv,fpspc\"))))\n+\t\t\t \"decoder0,p2+p0+fdiv,fdiv*16\")\n+\n+(define_insn_reservation \"ppro_fdiv_DF\" 32\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"DF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fdiv,fpspc\"))))\n+\t\t\t \"decodern,p0+fdiv,fdiv*30\")\n+\n+(define_insn_reservation \"ppro_fdiv_DF_load\" 33\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"DF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fdiv,fpspc\"))))\n+\t\t\t \"decoder0,p2+p0+fdiv,fdiv*30\")\n+\n+(define_insn_reservation \"ppro_fdiv_XF\" 38\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"XF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fdiv,fpspc\"))))\n+\t\t\t \"decodern,p0+fdiv,fdiv*36\")\n+\n+(define_insn_reservation \"ppro_fdiv_XF_load\" 39\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"XF\")\n+\t\t\t\t\t(eq_attr \"type\" \"fdiv,fpspc\"))))\n+\t\t\t \"decoder0,p2+p0+fdiv,fdiv*36\")\n+\n+;; MMX instructions can execute on either port 0 or port 1 with a\n+;; throughput of 1/cycle.\n+;;   on port 0:\t- ALU (latency 1)\n+;;\t\t- Multiplier Unit (latency 3)\n+;;   on port 1:\t- ALU (latency 1)\n+;;\t\t- Shift Unit (latency 1)\n+;;\n+;; MMX instructions are either of the type reg-reg, or read-modify, and\n+;; except for mmxshft and mmxmul they can execute on port 0 or port 1,\n+;; so they behave as \"simple\" instructions that need no special modelling.\n+;; We only have to model mmxshft and mmxmul.\n+(define_insn_reservation \"ppro_mmx_shft\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"mmxshft\")))\n+\t\t\t \"decodern,p1\")\n+\n+(define_insn_reservation \"ppro_mmx_shft_load\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"mmxshft\")))\n+\t\t\t \"decoder0,p2+p1\")\n+\n+(define_insn_reservation \"ppro_mmx_mul\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"mmxmul\")))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_mmx_mul_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (eq_attr \"type\" \"mmxmul\")))\n+\t\t\t \"decoder0,p2+p0\")\n+\n+(define_insn_reservation \"ppro_sse_mmxcvt\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"mode\" \"DI\")\n+\t\t\t\t   (eq_attr \"type\" \"mmxcvt\")))\n+\t\t\t \"decodern,p1\")\n+\n+;; FIXME: These are Pentium III only, but we cannot tell here if\n+;; we're generating code for PentiumPro/Pentium II or Pentium III\n+;; (define_insn_reservation \"ppro_sse_mmxshft\" 2\n+;;\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+;;\t\t\t      (and (eq_attr \"mode\" \"DI\")\n+;;\t\t\t\t   (eq_attr \"type\" \"mmxshft\")))\n+;;\t\t\t \"decodern,p0\")\n+\n+;; SSE is very complicated, and takes a bit more effort.\n+;; ??? I assumed that all SSE instructions decode on decoder0,\n+;;     but is this correct?\n+\n+;; The sfence instruction.\n+(define_insn_reservation \"ppro_sse_sfence\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"unknown\")\n+\t\t\t\t   (eq_attr \"type\" \"sse\")))\n+\t\t\t \"decoder0,p4+p3\")\n+\n+;; FIXME: This reservation is all wrong when we're scheduling sqrtss.\n+(define_insn_reservation \"ppro_sse_SF\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t   (eq_attr \"type\" \"sse\")))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_sse_add_SF\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"sseadd\"))))\n+\t\t\t \"decodern,p1\")\n+\n+(define_insn_reservation \"ppro_sse_add_SF_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"sseadd\"))))\n+\t\t\t \"decoder0,p2+p1\")\n+\n+(define_insn_reservation \"ppro_sse_cmp_SF\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssecmp\"))))\n+\t\t\t \"decoder0,p1\")\n+\n+(define_insn_reservation \"ppro_sse_cmp_SF_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssecmp\"))))\n+\t\t\t \"decoder0,p2+p1\")\n+\n+(define_insn_reservation \"ppro_sse_comi_SF\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssecomi\"))))\n+\t\t\t \"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_sse_comi_SF_load\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssecomi\"))))\n+\t\t\t \"decoder0,p2+p0\")\n+\n+(define_insn_reservation \"ppro_sse_mul_SF\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemul\"))))\n+\t\t\t\"decodern,p0\")\n+\n+(define_insn_reservation \"ppro_sse_mul_SF_load\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemul\"))))\n+\t\t\t\"decoder0,p2+p0\")\n+\n+;; FIXME: ssediv doesn't close p0 for 17 cycles, surely???\n+(define_insn_reservation \"ppro_sse_div_SF\" 18\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssediv\"))))\n+\t\t\t \"decoder0,p0*17\")\n+\n+(define_insn_reservation \"ppro_sse_div_SF_load\" 18\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssediv\"))))\n+\t\t\t \"decoder0,(p2+p0),p0*16\")\n+\n+(define_insn_reservation \"ppro_sse_icvt_SF\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t   (eq_attr \"type\" \"sseicvt\")))\n+\t\t\t \"decoder0,(p2+p1)*2\")\n+\n+(define_insn_reservation \"ppro_sse_icvt_SI\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"mode\" \"SI\")\n+\t\t\t\t   (eq_attr \"type\" \"sseicvt\")))\n+\t\t\t \"decoder0,(p2+p1)\")\n+\n+(define_insn_reservation \"ppro_sse_mov_SF\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemov\"))))\n+\t\t\t \"decoder0,(p0|p1)\")\n+\n+(define_insn_reservation \"ppro_sse_mov_SF_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemov\"))))\n+\t\t\t \"decoder0,p2+(p0|p1)\")\n+\n+(define_insn_reservation \"ppro_sse_mov_SF_store\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"store\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemov\"))))\n+\t\t\t \"decoder0,p4+p3\")\n+\n+(define_insn_reservation \"ppro_sse_V4SF\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t   (eq_attr \"type\" \"sse\")))\n+\t\t\t \"decoder0,p1*2\")\n+\n+(define_insn_reservation \"ppro_sse_add_V4SF\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"sseadd\"))))\n+\t\t\t \"decoder0,p1*2\")\n+\n+(define_insn_reservation \"ppro_sse_add_V4SF_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"sseadd\"))))\n+\t\t\t \"decoder0,(p2+p1)*2\")\n+\n+(define_insn_reservation \"ppro_sse_cmp_V4SF\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssecmp\"))))\n+\t\t\t \"decoder0,p1*2\")\n+\n+(define_insn_reservation \"ppro_sse_cmp_V4SF_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssecmp\"))))\n+\t\t\t \"decoder0,(p2+p1)*2\")\n+\n+(define_insn_reservation \"ppro_sse_cvt_V4SF\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none,unknown\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssecvt\"))))\n+\t\t\t \"decoder0,p1*2\")\n+\n+(define_insn_reservation \"ppro_sse_cvt_V4SF_other\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"!none,unknown\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssecmp\"))))\n+\t\t\t \"decoder0,p1,p4+p3\")\n+\n+(define_insn_reservation \"ppro_sse_mul_V4SF\" 5\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemul\"))))\n+\t\t\t\"decoder0,p0*2\")\n+\n+(define_insn_reservation \"ppro_sse_mul_V4SF_load\" 5\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemul\"))))\n+\t\t\t\"decoder0,(p2+p0)*2\")\n+\n+;; FIXME: p0 really closed this long???\n+(define_insn_reservation \"ppro_sse_div_V4SF\" 48\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssediv\"))))\n+\t\t\t \"decoder0,p0*34\")\n+\n+(define_insn_reservation \"ppro_sse_div_V4SF_load\" 48\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssediv\"))))\n+\t\t\t \"decoder0,(p2+p0)*2,p0*32\")\n+\n+(define_insn_reservation \"ppro_sse_log_V4SF\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"sselog\"))))\n+\t\t\t \"decodern,p1\")\n+\n+(define_insn_reservation \"ppro_sse_log_V4SF_load\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"sselog\"))))\n+\t\t\t \"decoder0,(p2+p1)\")\n+\n+(define_insn_reservation \"ppro_sse_mov_V4SF\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemov\"))))\n+\t\t\t \"decoder0,(p0|p1)*2\")\n+\n+(define_insn_reservation \"ppro_sse_mov_V4SF_load\" 2\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemov\"))))\n+\t\t\t \"decoder0,p2*2\")\n+\n+(define_insn_reservation \"ppro_sse_mov_V4SF_store\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"store\")\n+\t\t\t\t   (and (eq_attr \"mode\" \"V4SF\")\n+\t\t\t\t\t(eq_attr \"type\" \"ssemov\"))))\n+\t\t\t \"decoder0,(p4+p3)*2\")\n+\n+;; All other instructions are modelled as simple instructions.\n+;; We have already modelled all i387 floating point instructions, so all\n+;; other instructions execute on either port 0 or port 1.  This includes\n+;; the ALU units, and the MMX units.\n+;;\n+;; reg-reg instructions produce 1 uop so they can be decoded on any of\n+;; the three decoders.\n+(define_insn_reservation \"ppro_insn\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"none,unknown\")\n+\t\t\t\t   (eq_attr \"type\" \"alu,alu1,negnot,incdec,icmp,test,setcc,icmov,push,pop,fxch,sseiadd,sseishft,sseimul,mmx,mmxadd,mmxcmp\")))\n+\t\t\t \"decodern,(p0|p1)\")\n+\n+;; read-modify and register-memory instructions have 2 or three uops,\n+;; so they have to be decoded on decoder0.\n+(define_insn_reservation \"ppro_insn_load\" 3\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"load\")\n+\t\t\t\t   (eq_attr \"type\" \"alu,alu1,negnot,incdec,icmp,test,setcc,icmov,push,pop,fxch,sseiadd,sseishft,sseimul,mmx,mmxadd,mmxcmp\")))\n+\t\t\t \"decoder0,p2+(p0|p1)\")\n+\n+(define_insn_reservation \"ppro_insn_store\" 1\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"store\")\n+\t\t\t\t   (eq_attr \"type\" \"alu,alu1,negnot,incdec,icmp,test,setcc,icmov,push,pop,fxch,sseiadd,sseishft,sseimul,mmx,mmxadd,mmxcmp\")))\n+\t\t\t \"decoder0,(p0|p1),p4+p3\")\n+\n+;; read-modify-store instructions produce 4 uops so they have to be\n+;; decoded on decoder0 as well.\n+(define_insn_reservation \"ppro_insn_both\" 4\n+\t\t\t (and (eq_attr \"cpu\" \"pentiumpro\")\n+\t\t\t      (and (eq_attr \"memory\" \"both\")\n+\t\t\t\t   (eq_attr \"type\" \"alu,alu1,negnot,incdec,icmp,test,setcc,icmov,push,pop,fxch,sseiadd,sseishft,sseimul,mmx,mmxadd,mmxcmp\")))\n+\t\t\t \"decoder0,p2+(p0|p1),p4+p3\")\n+"}]}