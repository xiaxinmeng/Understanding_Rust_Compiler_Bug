{"sha": "8f99553ff6cdc54e5af910042f93fbfbdaac0424", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5OTU1M2ZmNmNkYzU0ZTVhZjkxMDA0MmY5M2ZiZmJkYWFjMDQyNA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-07-05T19:49:20Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-07-05T19:49:20Z"}, "message": "c-decl.c, [...]: Don't check TARGET_MEM_FUNCTIONS.\n\n\t* c-decl.c, config/m32r/m32r.c, expr.c, optabs.c: Don't check\n\tTARGET_MEM_FUNCTIONS.\n\t* system.h: Poison TARGET_MEM_FUNCTIONS.\n\t* libfuncs.h (LTI_bcopy, LTI_bcmp, LTI_bzero, bcopy_libfunc,\n\tbcmp_libfunc, bzero_libfunc): Remove.\n\t* optabs.c (init_obtabs): Don't set bcopy_libfunc, bcmp_libfunc or\n\tbzero_libfunc.\n\t* doc/tm.texi (TARGET_MEM_FUNCTIONS): Remove.\n\t* doc/standards.texi: Don't mention calling BSD string functions.\n\t* doc/invoke.texi: Likewise.  Mention that memmove may be called.\n\t* config/vax/t-memfuncs: New.\n\t* config/memcmp.c, config/memcpy.c, config/memmove.c,\n\tconfig/memset.c: New.\n\t* config/pdp11/t-pdp11 (LIB2FUNCS_EXTRA): Use these files.\n\t* config.gcc (vax-*-bsd*, vax-*-sysv*, vax-*-ultrix*): Use\n\tvax/t-memfuncs.\n\t* config/alpha/alpha.h, config/arc/arc.h, config/arm/arm.h,\n\tconfig/avr/avr.h, config/c4x/c4x.h, config/cris/aout.h,\n\tconfig/elfos.h, config/gnu.h, config/h8300/h8300.h,\n\tconfig/i386/gas.h, config/ia64/ia64.h, config/interix.h,\n\tconfig/ip2k/ip2k.h, config/lynx-ng.h, config/m32r/m32r.h,\n\tconfig/mcore/mcore.h, config/mips/mips.h, config/mmix/mmix.h,\n\tconfig/netbsd.h, config/openbsd.h, config/pa/pa.h,\n\tconfig/rs6000/rs6000.h, config/rtems.h, config/s390/s390.h,\n\tconfig/sh/sh.h, config/sparc/sparc.h, config/stormy16/stormy16.h,\n\tconfig/svr3.h: Don't define TARGET_MEM_FUNCTIONS.\n\nFrom-SVN: r84130", "tree": {"sha": "8e0aa0cf5c8ffabad8a0bb6237050ce3904720e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e0aa0cf5c8ffabad8a0bb6237050ce3904720e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f99553ff6cdc54e5af910042f93fbfbdaac0424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f99553ff6cdc54e5af910042f93fbfbdaac0424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f99553ff6cdc54e5af910042f93fbfbdaac0424", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f99553ff6cdc54e5af910042f93fbfbdaac0424/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd4c82502007c08b94a8a24d7d63c00c3a4868b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd4c82502007c08b94a8a24d7d63c00c3a4868b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd4c82502007c08b94a8a24d7d63c00c3a4868b9"}], "stats": {"total": 401, "additions": 136, "deletions": 265}, "files": [{"sha": "66f6821dfc17cd552ed27eee4338f570b0be54e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -1,3 +1,32 @@\n+2004-07-05  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-decl.c, config/m32r/m32r.c, expr.c, optabs.c: Don't check\n+\tTARGET_MEM_FUNCTIONS.\n+\t* system.h: Poison TARGET_MEM_FUNCTIONS.\n+\t* libfuncs.h (LTI_bcopy, LTI_bcmp, LTI_bzero, bcopy_libfunc,\n+\tbcmp_libfunc, bzero_libfunc): Remove.\n+\t* optabs.c (init_obtabs): Don't set bcopy_libfunc, bcmp_libfunc or\n+\tbzero_libfunc.\n+\t* doc/tm.texi (TARGET_MEM_FUNCTIONS): Remove.\n+\t* doc/standards.texi: Don't mention calling BSD string functions.\n+\t* doc/invoke.texi: Likewise.  Mention that memmove may be called.\n+\t* config/vax/t-memfuncs: New.\n+\t* config/memcmp.c, config/memcpy.c, config/memmove.c,\n+\tconfig/memset.c: New.\n+\t* config/pdp11/t-pdp11 (LIB2FUNCS_EXTRA): Use these files.\n+\t* config.gcc (vax-*-bsd*, vax-*-sysv*, vax-*-ultrix*): Use\n+\tvax/t-memfuncs.\n+\t* config/alpha/alpha.h, config/arc/arc.h, config/arm/arm.h,\n+\tconfig/avr/avr.h, config/c4x/c4x.h, config/cris/aout.h,\n+\tconfig/elfos.h, config/gnu.h, config/h8300/h8300.h,\n+\tconfig/i386/gas.h, config/ia64/ia64.h, config/interix.h,\n+\tconfig/ip2k/ip2k.h, config/lynx-ng.h, config/m32r/m32r.h,\n+\tconfig/mcore/mcore.h, config/mips/mips.h, config/mmix/mmix.h,\n+\tconfig/netbsd.h, config/openbsd.h, config/pa/pa.h,\n+\tconfig/rs6000/rs6000.h, config/rtems.h, config/s390/s390.h,\n+\tconfig/sh/sh.h, config/sparc/sparc.h, config/stormy16/stormy16.h,\n+\tconfig/svr3.h: Don't define TARGET_MEM_FUNCTIONS.\n+\n 2004-07-05  Richard Henderson  <rth@redhat.com>\n \n \t* function.c (assign_parm_setup_reg): Properly rename variables in"}, {"sha": "5e34bb59e82cda9425a1be64e8e9856fb388b808", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -2944,17 +2944,10 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  tree builtin = built_in_decls [DECL_FUNCTION_CODE (decl)];\n \t  SET_DECL_RTL (builtin, NULL_RTX);\n \t  change_decl_assembler_name (builtin, get_identifier (starred));\n-#ifdef TARGET_MEM_FUNCTIONS\n \t  if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMCPY)\n \t    init_block_move_fn (starred);\n \t  else if (DECL_FUNCTION_CODE (decl) == BUILT_IN_MEMSET)\n \t    init_block_clear_fn (starred);\n-#else\n-\t  if (DECL_FUNCTION_CODE (decl) == BUILT_IN_BCOPY)\n-\t    init_block_move_fn (starred);\n-\t  else if (DECL_FUNCTION_CODE (decl) == BUILT_IN_BZERO)\n-\t    init_block_clear_fn (starred);\n-#endif\n \t}\n       SET_DECL_RTL (decl, NULL_RTX);\n       change_decl_assembler_name (decl, get_identifier (starred));"}, {"sha": "2d70d44708cb6fb2201d320329342fed38c7c7d5", "filename": "gcc/config.gcc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -2012,11 +2012,13 @@ v850-*-*)\n \t;;\n vax-*-bsd*)\t\t\t# VAXen running BSD\n \ttm_file=\"${tm_file} vax/bsd.h\"\n+\ttmake_file=vax/t-memfuncs\n \tuse_collect2=yes\n \tuse_fixproto=yes\n \t;;\n vax-*-sysv*)\t\t\t# VAXen running system V\n \ttm_file=\"${tm_file} vax/vaxv.h\"\n+\ttmake_file=vax/t-memfuncs\n \tuse_fixproto=yes\n \t;;\n vax-*-netbsdelf*)\n@@ -2034,6 +2036,7 @@ vax-*-openbsd*)\n \t;;\n vax-*-ultrix*)\t\t\t# VAXen running ultrix\n \ttm_file=\"${tm_file} vax/ultrix.h\"\n+\ttmake_file=vax/t-memfuncs\n \tuse_fixproto=yes\n \t;;\n xscale-*-elf)"}, {"sha": "8e03fd7531039c05ab0ae96159f1f17813f4db72", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -1835,6 +1835,3 @@ do {\t\t\t\t\t\t\t\\\n \n /* The system headers under Alpha systems are generally C++-aware.  */\n #define NO_IMPLICIT_EXTERN_C\n-\n-/* Generate calls to memcpy, etc., not bcopy, etc.  */\n-#define TARGET_MEM_FUNCTIONS 1"}, {"sha": "1ee15192711611fa1df7cb688aa34e072601726a", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -802,11 +802,6 @@ do { \\\n   emit_insn (gen_flush_icache (validize_mem (gen_rtx_MEM (SImode, TRAMP)))); \\\n } while (0)\n \f\n-/* Library calls.  */\n-\n-/* Generate calls to memcpy, memcmp and memset.  */\n-#define TARGET_MEM_FUNCTIONS\n-\f\n /* Addressing modes, and classification of registers for them.  */\n \n /* Maximum number of registers that can appear in a valid memory address.  */"}, {"sha": "3067153131f29e20deee1c7737368becb3f898d5", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -536,9 +536,6 @@ extern int arm_is_6_or_7;\n    that is controlled by the APCS-FRAME option.  */\n #define CAN_DEBUG_WITHOUT_FP\n \n-#undef  TARGET_MEM_FUNCTIONS\n-#define TARGET_MEM_FUNCTIONS 1\n-\n #define OVERRIDE_OPTIONS  arm_override_options ()\n \n /* Nonzero if PIC code requires explicit qualifiers to generate"}, {"sha": "da06c207604dc3a4a883771da207d2aff280de1f", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -803,8 +803,6 @@ extern int avr_case_values_threshold;\n #define ADJUST_INSN_LENGTH(INSN, LENGTH) (LENGTH =\\\n \t\t\t\t\t  adjust_insn_length (INSN, LENGTH))\n \n-#define TARGET_MEM_FUNCTIONS\n-\n #define CPP_SPEC \"%{posix:-D_POSIX_SOURCE}\"\n \n #define CC1_SPEC \"%{profile:-p}\""}, {"sha": "cff2548df775c3f9519f35d31ec7a605bef78556", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -1193,10 +1193,6 @@ CUMULATIVE_ARGS;\n \tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n      }\n \n-/* Implicit Calls to Library Routines.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n /* CC_NOOVmode should be used when the first operand is a PLUS, MINUS, NEG\n    or MULT.\n    CCmode should be used when no special processing is needed.  */"}, {"sha": "9a409cf8a4283716cb4ca28f5f69a5f43e234052", "filename": "gcc/config/cris/aout.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fcris%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fcris%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Faout.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -139,11 +139,6 @@ Boston, MA 02111-1307, USA.  */\n #define MAX_OFILE_ALIGNMENT 16\n \n \n-/* Node: Library Calls */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n-\n /* Node: Data Output */\n \n #define ESCAPES \\"}, {"sha": "743ae71ab6dc0639cc09cbcb02c261f15d2614b6", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -58,10 +58,6 @@ Boston, MA 02111-1307, USA.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n #endif\n \n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n /* Handle #pragma weak and #pragma pack.  */\n \n #define HANDLE_SYSV_PRAGMA 1"}, {"sha": "79c64c77ba98871fd463a069e0e0101eb5377fa5", "filename": "gcc/config/gnu.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fgnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fgnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgnu.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -12,10 +12,6 @@\n #undef STANDARD_INCLUDE_DIR\n #define STANDARD_INCLUDE_DIR \"/include\"\n \n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-#undef TARGET_MEM_FUNCTIONS\n-#define TARGET_MEM_FUNCTIONS\n-\n /* The system headers under GNU are C++-aware.  */\n #define NO_IMPLICIT_EXTERN_C\n "}, {"sha": "fcb082372a125a86dc6f8964e4208e23e90e8964", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -1138,12 +1138,6 @@ struct cum_arg\n #define FINAL_PRESCAN_INSN(insn, operand, nop)\t\\\n   final_prescan_insn (insn, operand, nop)\n \n-/* Define this macro if GCC should generate calls to the System V\n-   (and ANSI C) library functions `memcpy' and `memset' rather than\n-   the BSD functions `bcopy' and `bzero'.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n #define MOVE_RATIO 3\n \n /* Define the codes that are matched by predicates in h8300.c.  */"}, {"sha": "9f002431018527fc98bbaa585f37101fe73c48ea", "filename": "gcc/config/i386/gas.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fi386%2Fgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fi386%2Fgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgas.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -49,10 +49,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define ASM_OUTPUT_IDENT(FILE, NAME) fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n \n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n /* In the past there was confusion as to what the argument to .align was\n    in GAS.  For the last several years the rule has been this: for a.out\n    file formats that argument is LOG, and for all other file formats the"}, {"sha": "930266c6f85a5d1f24b75345d944b82ee4969d30", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -1555,15 +1555,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \\\n   ia64_initialize_trampoline((ADDR), (FNADDR), (STATIC_CHAIN))\n-\f\n-/* Implicit Calls to Library Routines */\n-\n-/* Define this macro if GCC should generate calls to the System V (and ANSI\n-   C) library functions `memcpy' and `memset' rather than the BSD functions\n-   `bcopy' and `bzero'.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n \f\n /* Addressing Modes */\n "}, {"sha": "9db2d84af98fab867b7220349598b2f777cdbd8b", "filename": "gcc/config/interix.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Finterix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Finterix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Finterix.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -22,10 +22,6 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#ifndef TARGET_MEM_FUNCTIONS\n-#define TARGET_MEM_FUNCTIONS\n-#endif\n-\n /* POSIX/Uni-thread only for now.  Look at the winnt version\n for windows/multi thread */\n "}, {"sha": "c24c49370f5644f5798a47a5ed9fec387718901c", "filename": "gcc/config/ip2k/ip2k.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -808,8 +808,6 @@ extern int ip2k_reorg_merge_qimode;\n #define FUNCTION_PROFILER(FILE, LABELNO)  \\\n   fprintf ((FILE), \"/* profiler %d */\", (LABELNO))\n \n-#define TARGET_MEM_FUNCTIONS\n-\n #undef ENDFILE_SPEC\n #undef LINK_SPEC\n #undef STARTFILE_SPEC"}, {"sha": "a1fe786b463f57d0c3a76bc131f3a4cf1f7563e5", "filename": "gcc/config/lynx-ng.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Flynx-ng.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Flynx-ng.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flynx-ng.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -64,10 +64,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define SDB_DEBUGGING_INFO 1\n \n-/* Generate calls to memcpy, memcmp and memset.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n /* Handle #pragma pack and sometimes #pragma weak.  */\n \n #define HANDLE_SYSV_PRAGMA 1"}, {"sha": "9de4eb34d286ed30a1bd4c0e8eedb555061cbc72", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -2601,19 +2601,11 @@ block_move_call (rtx dest_reg, rtx src_reg, rtx bytes_rtx)\n       && GET_MODE (bytes_rtx) != Pmode)\n     bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);\n \n-#ifdef TARGET_MEM_FUNCTIONS\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"memcpy\"), 0,\n \t\t     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,\n \t\t     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,\n \t\t\t\t      TYPE_UNSIGNED (sizetype)),\n \t\t     TYPE_MODE (sizetype));\n-#else\n-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"bcopy\"), 0,\n-\t\t     VOIDmode, 3, src_reg, Pmode, dest_reg, Pmode,\n-\t\t     convert_to_mode (TYPE_MODE (integer_type_node), bytes_rtx,\n-\t\t\t\t      TYPE_UNSIGNED (integer_type_node)),\n-\t\t     TYPE_MODE (integer_type_node));\n-#endif\n }\n \n /* The maximum number of bytes to copy using pairs of load/store instructions."}, {"sha": "14f266c0949773f5e4cfbdb149a7d94d1852dfd3", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -1260,11 +1260,6 @@ L2:     .word STATIC\n     }\t\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \f\n-/* Library calls.  */\n-\n-/* Generate calls to memcpy, memcmp and memset.  */\n-#define TARGET_MEM_FUNCTIONS\n-\f\n #define RETURN_ADDR_RTX(COUNT, FRAME) m32r_return_addr (COUNT)\n \n #define INCOMING_RETURN_ADDR_RTX   gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM)"}, {"sha": "b6e5d87a42a30c1999178748a6631855c35aa73b", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -953,9 +953,6 @@ extern const enum reg_class reg_class_from_letter[];\n \n #define WORD_REGISTER_OPERATIONS\n \n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n /* Assembler output control.  */\n #define ASM_COMMENT_START \"\\t//\"\n "}, {"sha": "2348afe1d27f7101adaa1970ee7f040e2343f35c", "filename": "gcc/config/memcmp.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmemcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmemcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmemcmp.c?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -0,0 +1,16 @@\n+/* Public domain.  */\n+#include <stddef.h>\n+\n+int\n+memcmp (const void *str1, const void *str2, size_t count)\n+{\n+  const unsigned char *s1 = str1;\n+  const unsigned char *s2 = str2;\n+\n+  while (count-- > 0)\n+    {\n+      if (*s1++ != *s2++)\n+\t  return s1[-1] < s2[-1] ? -1 : 1;\n+    }\n+  return 0;\n+}"}, {"sha": "58b1e405627aaac66d1973be344aed72cdeddc21", "filename": "gcc/config/memcpy.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmemcpy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmemcpy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmemcpy.c?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -0,0 +1,12 @@\n+/* Public domain.  */\n+#include <stddef.h>\n+\n+void *\n+memcpy (void *dest, const void *src, size_t len)\n+{\n+  char *d = dest;\n+  const char *s = src;\n+  while (len--)\n+    *d++ = *s++;\n+  return dest;\n+}"}, {"sha": "13b340af6a01171d21a17f04482cfcc814080e97", "filename": "gcc/config/memmove.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmemmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmemmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmemmove.c?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -0,0 +1,20 @@\n+/* Public domain.  */\n+#include <stddef.h>\n+\n+void *\n+memmove (void *dest, const void *src, size_t len)\n+{\n+  char *d = dest;\n+  const char *s = src;\n+  if (d < s)\n+    while (len--)\n+      *d++ = *s++;\n+  else\n+    {\n+      char *lasts = s + (len-1);\n+      char *lastd = d + (len-1);\n+      while (len--)\n+        *lastd-- = *lasts--;\n+    }\n+  return dest;\n+}"}, {"sha": "3e7025ee39443990b016a56f51aa1c2dbb63c6cd", "filename": "gcc/config/memset.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmemset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmemset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmemset.c?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -0,0 +1,11 @@\n+/* Public domain.  */\n+#include <stddef.h>\n+\n+void *\n+memset (void *dest, int val, size_t len)\n+{\n+  unsigned char *ptr = dest;\n+  while (len-- > 0)\n+    *ptr++ = val;\n+  return dest;\n+}"}, {"sha": "77ea0e0e32ebe9d13d471fb808281a264587352b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -3363,9 +3363,6 @@ while (0)\n \n #define DONT_ACCESS_GBLS_AFTER_EPILOGUE (TARGET_ABICALLS && !TARGET_OLDABI)\n \f\n-/* Generate calls to memcpy, etc., not bcopy, etc.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n #ifndef __mips16\n /* Since the bits of the _init and _fini function is spread across\n    many object files, each potentially with its own GP, we must assume"}, {"sha": "8e5432bb211f5f5f1ef152b52d9bfdf8f4f20510", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -806,11 +806,6 @@ typedef struct { int regs; int lib; } CUMULATIVE_ARGS;\n  mmix_initialize_trampoline (ADDR, FNADDR, STATIC_CHAIN)\n \n \n-/* Node: Library Calls */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n-\n /* Node: Addressing Modes */\n \n #define CONSTANT_ADDRESS_P(X) \\"}, {"sha": "40adf1a381d207cf66dd4955bcb733e6db7ff584", "filename": "gcc/config/netbsd.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnetbsd.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -159,11 +159,6 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_HAS_F_SETLKW\n #define TARGET_HAS_F_SETLKW\n \n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-\n-#undef TARGET_MEM_FUNCTIONS\n-#define TARGET_MEM_FUNCTIONS 1\n-\n /* Handle #pragma weak and #pragma pack.  */\n \n #define HANDLE_SYSV_PRAGMA 1"}, {"sha": "b472182718ff98623865d6ee64a0327dc36f4923", "filename": "gcc/config/openbsd.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fopenbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fopenbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fopenbsd.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -130,13 +130,6 @@ Boston, MA 02111-1307, USA.  */\n \f\n /* Runtime target specification.  */\n \n-/* Implicit calls to library routines.  */\n-\n-/* Use memcpy and memset instead of bcopy and bzero.  */\n-#ifndef TARGET_MEM_FUNCTIONS\n-#define TARGET_MEM_FUNCTIONS\n-#endif\n-\n /* Miscellaneous parameters.  */\n \n /* Controlling debugging info: dbx options.  */"}, {"sha": "fec6f2cf0ca32e3454a6719aa4abf52ebee15593", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -500,9 +500,6 @@ do {\t\t\t\t\t\t\t\t\\\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n \n-/* Generate calls to memcpy, memcmp and memset.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,"}, {"sha": "c0a23c2ec45261e242144b4f89b4b34517490980", "filename": "gcc/config/pdp11/t-pdp11", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fpdp11%2Ft-pdp11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fpdp11%2Ft-pdp11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Ft-pdp11?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -1,5 +1,7 @@\n TARGET_LIBGCC2_CFLAGS = -O2 -mfloat32\n-LIB2FUNCS_EXTRA = $(srcdir)/config/udivmod.c $(srcdir)/config/udivmodsi4.c\n+LIB2FUNCS_EXTRA = $(srcdir)/config/udivmod.c $(srcdir)/config/udivmodsi4.c \\\n+    $(srcdir)/config/memcmp.c $(srcdir)/config/memcpy.c \\\n+    $(srcdir)/config/memmove.c $(srcdir)/config/memset.c\n # floating point emulation libraries\n \n FPBIT = fp-bit.c"}, {"sha": "17df6c082eb5ca6719fd5bd85d512a4d0116a4e8", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -2217,10 +2217,6 @@ extern int rs6000_compare_fp_p;\n    the end of the line.  */\n #define ASM_COMMENT_START \" #\"\n \n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n /* Flag to say the TOC is initialized */\n extern int toc_initialized;\n "}, {"sha": "301154325fbb75304407028d4d572c0464e6b98d", "filename": "gcc/config/rtems.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frtems.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -21,11 +21,6 @@ Boston, MA 02111-1307, USA.  */\n /* The system headers under RTEMS are C++-aware.  */\n #define NO_IMPLICIT_EXTERN_C\n \n-/* Generate calls to memcpy, memcmp and memset.  */\n-#ifndef TARGET_MEM_FUNCTIONS\n-#define TARGET_MEM_FUNCTIONS\n-#endif\n-\n /*\n  * Dummy start/end specification to let linker work as\n  * needed by autoconf scripts using this compiler."}, {"sha": "85168b4d99a7deeb373cf745a98df20cfe6ca056", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -722,12 +722,6 @@ CUMULATIVE_ARGS;\n    s390_trampoline_template (FILE)\n \n \n-/* Library calls.  */\n-\n-/* We should use memcpy, not bcopy.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n-\n /* Addressing modes, and classification of registers for them.  */\n \n /* Recognize any constant value that is a valid address.  */"}, {"sha": "c9f411ae72f1f026f42f8cd2224dd37eee30738b", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -3232,10 +3232,6 @@ enum mdep_reorg_phase_e\n \n extern enum mdep_reorg_phase_e mdep_reorg_phase;\n \n-/* Generate calls to memcpy, memcmp and memset.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n /* Handle Renesas compiler's pragmas.  */\n #define REGISTER_TARGET_PRAGMAS() do {\t\t\t\t\t\\\n   c_register_pragma (0, \"interrupt\", sh_pr_interrupt);\t\t\t\\"}, {"sha": "030d3ab7863e591eb2006af8356c869ceae22926", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -2207,9 +2207,6 @@ do {                                                                    \\\n /* Specify the machine mode used for addresses.  */\n #define Pmode (TARGET_ARCH64 ? DImode : SImode)\n \n-/* Generate calls to memcpy, memcmp and memset.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.  For floating-point,\n    CCFP[E]mode is used.  CC_NOOVmode should be used when the first operand"}, {"sha": "b2472bc841f152af47f1ae2cb8d77626cd49d8ac", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -497,10 +497,6 @@ enum reg_class\n   xstormy16_initialize_trampoline (ADDR, FNADDR, STATIC_CHAIN)\n \n \f\n-/* Implicit Calls to Library Routines */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n /* Define this macro to override the type used by the library routines to pick\n    up arguments of type `float'.  (By default, they use a union of `float' and\n    `int'.)"}, {"sha": "b544abba91a73065bc5edc8b728bc85549f4a8b6", "filename": "gcc/config/svr3.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fsvr3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fsvr3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr3.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -70,10 +70,6 @@ Boston, MA 02111-1307, USA. */\n \n #define NO_DOLLAR_IN_LABEL\n \n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n /* System V Release 3 uses COFF debugging info.  */\n \n #define SDB_DEBUGGING_INFO 1"}, {"sha": "6a8da6146b5e0cbd3761dc9b4c31097b41bc215c", "filename": "gcc/config/vax/t-memfuncs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fvax%2Ft-memfuncs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fconfig%2Fvax%2Ft-memfuncs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Ft-memfuncs?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -0,0 +1,3 @@\n+LIB2FUNCS_EXTRA = \\\n+    $(srcdir)/config/memcmp.c $(srcdir)/config/memcpy.c \\\n+    $(srcdir)/config/memmove.c $(srcdir)/config/memset.c"}, {"sha": "c764ee800f79a3d09b130ae7b70e658411ee92fb", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -5437,19 +5437,19 @@ or @option{-nodefaultlibs} is used.\n Do not use the standard system libraries when linking.\n Only the libraries you specify will be passed to the linker.\n The standard startup files are used normally, unless @option{-nostartfiles}\n-is used.  The compiler may generate calls to memcmp, memset, and memcpy\n-for System V (and ISO C) environments or to bcopy and bzero for\n-BSD environments.  These entries are usually resolved by entries in\n+is used.  The compiler may generate calls to @code{memcmp},\n+@code{memset}, @code{memcpy} and @code{memmove}.\n+These entries are usually resolved by entries in\n libc.  These entry points should be supplied through some other\n mechanism when this option is specified.\n \n @item -nostdlib\n @opindex nostdlib\n Do not use the standard system startup files or libraries when linking.\n No startup files and only the libraries you specify will be passed to\n-the linker.  The compiler may generate calls to memcmp, memset, and memcpy\n-for System V (and ISO C) environments or to bcopy and bzero for\n-BSD environments.  These entries are usually resolved by entries in\n+the linker.  The compiler may generate calls to @code{memcmp}, @code{memset},\n+@code{memcpy} and @code{memmove}.\n+These entries are usually resolved by entries in\n libc.  These entry points should be supplied through some other\n mechanism when this option is specified.\n "}, {"sha": "dcedc754f5971437ce661c47877441f48bce4acf", "filename": "gcc/doc/standards.texi", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fdoc%2Fstandards.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fdoc%2Fstandards.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fstandards.texi?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -145,9 +145,7 @@ GNU C library).  @xref{Standard Libraries,,Standard Libraries}.\n Most of the compiler support routines used by GCC are present in\n @file{libgcc}, but there are a few exceptions.  GCC requires the\n freestanding environment provide @code{memcpy}, @code{memmove},\n-@code{memset} and @code{memcmp}.  Some older ports of GCC are\n-configured to use the BSD @code{bcopy}, @code{bzero} and @code{bcmp}\n-functions instead, but this is deprecated for new ports.\n+@code{memset} and @code{memcmp}.\n Finally, if @code{__builtin_trap} is used, and the target does\n not implement the @code{trap} pattern, then GCC will emit a call\n to @code{abort}."}, {"sha": "5cbff1c53d1c789d5fedbd222aff7130bea695c7", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -4811,17 +4811,6 @@ refers to the global ``variable'' @code{errno}.  (On certain systems,\n macro, a reasonable default is used.\n @end defmac\n \n-@cindex @code{bcopy}, implicit usage\n-@cindex @code{memcpy}, implicit usage\n-@cindex @code{memmove}, implicit usage\n-@cindex @code{bzero}, implicit usage\n-@cindex @code{memset}, implicit usage\n-@defmac TARGET_MEM_FUNCTIONS\n-Define this macro if GCC should generate calls to the ISO C\n-(and System V) library functions @code{memcpy}, @code{memmove} and\n-@code{memset} rather than the BSD functions @code{bcopy} and @code{bzero}.\n-@end defmac\n-\n @cindex C99 math functions, implicit usage\n @defmac TARGET_C99_FUNCTIONS\n When this macro is nonzero, GCC will implicitly optimize @code{sin} calls into"}, {"sha": "3c15a7bde7aae0371d7f5d96d595321eb9486a74", "filename": "gcc/expr.c", "status": "modified", "additions": 30, "deletions": 92, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -77,14 +77,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #endif\n #endif\n \n-/* Convert defined/undefined to boolean.  */\n-#ifdef TARGET_MEM_FUNCTIONS\n-#undef TARGET_MEM_FUNCTIONS\n-#define TARGET_MEM_FUNCTIONS 1\n-#else\n-#define TARGET_MEM_FUNCTIONS 0\n-#endif\n-\n \n /* If this is nonzero, we do not bother generating VOLATILE\n    around volatile memory references, and we are willing to\n@@ -1511,7 +1503,7 @@ emit_block_move_via_movstr (rtx x, rtx y, rtx size, unsigned int align)\n   return false;\n }\n \n-/* A subroutine of emit_block_move.  Expand a call to memcpy or bcopy.\n+/* A subroutine of emit_block_move.  Expand a call to memcpy.\n    Return the return value from memcpy, 0 otherwise.  */\n \n static rtx\n@@ -1550,10 +1542,7 @@ emit_block_move_via_libcall (rtx dst, rtx src, rtx size)\n   dst_tree = make_tree (ptr_type_node, dst_addr);\n   src_tree = make_tree (ptr_type_node, src_addr);\n \n-  if (TARGET_MEM_FUNCTIONS)\n-    size_mode = TYPE_MODE (sizetype);\n-  else\n-    size_mode = TYPE_MODE (unsigned_type_node);\n+  size_mode = TYPE_MODE (sizetype);\n \n   size = convert_to_mode (size_mode, size, 1);\n   size = copy_to_mode_reg (size_mode, size);\n@@ -1562,27 +1551,14 @@ emit_block_move_via_libcall (rtx dst, rtx src, rtx size)\n      memcpy in this context.  This could be a user call to memcpy and\n      the user may wish to examine the return value from memcpy.  For\n      targets where libcalls and normal calls have different conventions\n-     for returning pointers, we could end up generating incorrect code.\n+     for returning pointers, we could end up generating incorrect code.  */\n \n-     For convenience, we generate the call to bcopy this way as well.  */\n-\n-  if (TARGET_MEM_FUNCTIONS)\n-    size_tree = make_tree (sizetype, size);\n-  else\n-    size_tree = make_tree (unsigned_type_node, size);\n+  size_tree = make_tree (sizetype, size);\n \n   fn = emit_block_move_libcall_fn (true);\n   arg_list = tree_cons (NULL_TREE, size_tree, NULL_TREE);\n-  if (TARGET_MEM_FUNCTIONS)\n-    {\n-      arg_list = tree_cons (NULL_TREE, src_tree, arg_list);\n-      arg_list = tree_cons (NULL_TREE, dst_tree, arg_list);\n-    }\n-  else\n-    {\n-      arg_list = tree_cons (NULL_TREE, dst_tree, arg_list);\n-      arg_list = tree_cons (NULL_TREE, src_tree, arg_list);\n-    }\n+  arg_list = tree_cons (NULL_TREE, src_tree, arg_list);\n+  arg_list = tree_cons (NULL_TREE, dst_tree, arg_list);\n \n   /* Now we have to build up the CALL_EXPR itself.  */\n   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n@@ -1601,7 +1577,7 @@ emit_block_move_via_libcall (rtx dst, rtx src, rtx size)\n \t\t\t\t\t     gen_rtx_CLOBBER (VOIDmode, dst),\n \t\t\t\t\t     NULL_RTX));\n \n-  return TARGET_MEM_FUNCTIONS ? retval : NULL_RTX;\n+  return retval;\n }\n \n /* A subroutine of emit_block_move_via_libcall.  Create the tree node\n@@ -1617,20 +1593,10 @@ init_block_move_fn (const char *asmspec)\n     {\n       tree args, fn;\n \n-      if (TARGET_MEM_FUNCTIONS)\n-\t{\n-\t  fn = get_identifier (\"memcpy\");\n-\t  args = build_function_type_list (ptr_type_node, ptr_type_node,\n-\t\t\t\t\t   const_ptr_type_node, sizetype,\n-\t\t\t\t\t   NULL_TREE);\n-\t}\n-      else\n-\t{\n-\t  fn = get_identifier (\"bcopy\");\n-\t  args = build_function_type_list (void_type_node, const_ptr_type_node,\n-\t\t\t\t\t   ptr_type_node, unsigned_type_node,\n-\t\t\t\t\t   NULL_TREE);\n-\t}\n+      fn = get_identifier (\"memcpy\");\n+      args = build_function_type_list (ptr_type_node, ptr_type_node,\n+\t\t\t\t       const_ptr_type_node, sizetype,\n+\t\t\t\t       NULL_TREE);\n \n       fn = build_decl (FUNCTION_DECL, fn, args);\n       DECL_EXTERNAL (fn) = 1;\n@@ -2642,7 +2608,7 @@ clear_storage_via_clrstr (rtx object, rtx size, unsigned int align)\n   return false;\n }\n \n-/* A subroutine of clear_storage.  Expand a call to memset or bzero.\n+/* A subroutine of clear_storage.  Expand a call to memset.\n    Return the return value of memset, 0 otherwise.  */\n \n static rtx\n@@ -2673,31 +2639,22 @@ clear_storage_via_libcall (rtx object, rtx size)\n \n   object = copy_to_mode_reg (Pmode, XEXP (object, 0));\n \n-  if (TARGET_MEM_FUNCTIONS)\n-    size_mode = TYPE_MODE (sizetype);\n-  else\n-    size_mode = TYPE_MODE (unsigned_type_node);\n+  size_mode = TYPE_MODE (sizetype);\n   size = convert_to_mode (size_mode, size, 1);\n   size = copy_to_mode_reg (size_mode, size);\n \n   /* It is incorrect to use the libcall calling conventions to call\n      memset in this context.  This could be a user call to memset and\n      the user may wish to examine the return value from memset.  For\n      targets where libcalls and normal calls have different conventions\n-     for returning pointers, we could end up generating incorrect code.\n-\n-     For convenience, we generate the call to bzero this way as well.  */\n+     for returning pointers, we could end up generating incorrect code.  */\n \n   object_tree = make_tree (ptr_type_node, object);\n-  if (TARGET_MEM_FUNCTIONS)\n-    size_tree = make_tree (sizetype, size);\n-  else\n-    size_tree = make_tree (unsigned_type_node, size);\n+  size_tree = make_tree (sizetype, size);\n \n   fn = clear_storage_libcall_fn (true);\n   arg_list = tree_cons (NULL_TREE, size_tree, NULL_TREE);\n-  if (TARGET_MEM_FUNCTIONS)\n-    arg_list = tree_cons (NULL_TREE, integer_zero_node, arg_list);\n+  arg_list = tree_cons (NULL_TREE, integer_zero_node, arg_list);\n   arg_list = tree_cons (NULL_TREE, object_tree, arg_list);\n \n   /* Now we have to build up the CALL_EXPR itself.  */\n@@ -2713,7 +2670,7 @@ clear_storage_via_libcall (rtx object, rtx size)\n   if (RTX_UNCHANGING_P (object))\n     emit_insn (gen_rtx_CLOBBER (VOIDmode, object));\n \n-  return (TARGET_MEM_FUNCTIONS ? retval : NULL_RTX);\n+  return retval;\n }\n \n /* A subroutine of clear_storage_via_libcall.  Create the tree node\n@@ -2729,19 +2686,10 @@ init_block_clear_fn (const char *asmspec)\n     {\n       tree fn, args;\n \n-      if (TARGET_MEM_FUNCTIONS)\n-\t{\n-\t  fn = get_identifier (\"memset\");\n-\t  args = build_function_type_list (ptr_type_node, ptr_type_node,\n-\t\t\t\t\t   integer_type_node, sizetype,\n-\t\t\t\t\t   NULL_TREE);\n-\t}\n-      else\n-\t{\n-\t  fn = get_identifier (\"bzero\");\n-\t  args = build_function_type_list (void_type_node, ptr_type_node,\n-\t\t\t\t\t   unsigned_type_node, NULL_TREE);\n-\t}\n+      fn = get_identifier (\"memset\");\n+      args = build_function_type_list (ptr_type_node, ptr_type_node,\n+\t\t\t\t       integer_type_node, sizetype,\n+\t\t\t\t       NULL_TREE);\n \n       fn = build_decl (FUNCTION_DECL, fn, args);\n       DECL_EXTERNAL (fn) = 1;\n@@ -4029,21 +3977,12 @@ expand_assignment (tree to, tree from, int want_value)\n       size = expr_size (from);\n       from_rtx = expand_expr (from, NULL_RTX, VOIDmode, 0);\n \n-      if (TARGET_MEM_FUNCTIONS)\n-\temit_library_call (memmove_libfunc, LCT_NORMAL,\n-\t\t\t   VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n-\t\t\t   XEXP (from_rtx, 0), Pmode,\n-\t\t\t   convert_to_mode (TYPE_MODE (sizetype),\n-\t\t\t\t\t    size, TYPE_UNSIGNED (sizetype)),\n-\t\t\t   TYPE_MODE (sizetype));\n-      else\n-        emit_library_call (bcopy_libfunc, LCT_NORMAL,\n-\t\t\t   VOIDmode, 3, XEXP (from_rtx, 0), Pmode,\n-\t\t\t   XEXP (to_rtx, 0), Pmode,\n-\t\t\t   convert_to_mode (TYPE_MODE (integer_type_node),\n-\t\t\t\t\t    size,\n-\t\t\t\t\t    TYPE_UNSIGNED (integer_type_node)),\n-\t\t\t   TYPE_MODE (integer_type_node));\n+      emit_library_call (memmove_libfunc, LCT_NORMAL,\n+\t\t\t VOIDmode, 3, XEXP (to_rtx, 0), Pmode,\n+\t\t\t XEXP (from_rtx, 0), Pmode,\n+\t\t\t convert_to_mode (TYPE_MODE (sizetype),\n+\t\t\t\t\t  size, TYPE_UNSIGNED (sizetype)),\n+\t\t\t TYPE_MODE (sizetype));\n \n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n@@ -5207,10 +5146,10 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t and then \"or\" in whatever non-constant ranges we need in addition.\n \n \t If a large set is all zero or all ones, it is\n-\t probably better to set it using memset (if available) or bzero.\n+\t probably better to set it using memset.\n \t Also, if a large set has just a single range, it may also be\n \t better to first clear all the first clear the set (using\n-\t bzero/memset), and set the bits we want.  */\n+\t memset), and set the bits we want.  */\n \n       /* Check for all zeros.  */\n       if (elt == NULL_TREE && size > 0)\n@@ -5342,8 +5281,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t  /* Optimization:  If startbit and endbit are constants divisible\n \t     by BITS_PER_UNIT, call memset instead.  */\n-\t  if (TARGET_MEM_FUNCTIONS\n-\t      && TREE_CODE (startbit) == INTEGER_CST\n+\t  if (TREE_CODE (startbit) == INTEGER_CST\n \t      && TREE_CODE (endbit) == INTEGER_CST\n \t      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0\n \t      && (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)"}, {"sha": "32cde82c185dd52c3c4ade9ea2ed2daabbc078ad", "filename": "gcc/libfuncs.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Flibfuncs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Flibfuncs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibfuncs.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -27,11 +27,8 @@ enum libfunc_index\n   LTI_abort,\n   LTI_memcpy,\n   LTI_memmove,\n-  LTI_bcopy,\n   LTI_memcmp,\n-  LTI_bcmp,\n   LTI_memset,\n-  LTI_bzero,\n   LTI_setbits,\n \n   LTI_unwind_resume,\n@@ -58,11 +55,8 @@ extern GTY(()) rtx libfunc_table[LTI_MAX];\n #define abort_libfunc\t(libfunc_table[LTI_abort])\n #define memcpy_libfunc\t(libfunc_table[LTI_memcpy])\n #define memmove_libfunc\t(libfunc_table[LTI_memmove])\n-#define bcopy_libfunc\t(libfunc_table[LTI_bcopy])\n #define memcmp_libfunc\t(libfunc_table[LTI_memcmp])\n-#define bcmp_libfunc\t(libfunc_table[LTI_bcmp])\n #define memset_libfunc\t(libfunc_table[LTI_memset])\n-#define bzero_libfunc\t(libfunc_table[LTI_bzero])\n #define setbits_libfunc\t(libfunc_table[LTI_setbits])\n \n #define unwind_resume_libfunc\t(libfunc_table[LTI_unwind_resume])"}, {"sha": "021033113e5f3cfb60e3b019ac2bef97236b48c4", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -3744,15 +3744,9 @@ prepare_cmp_insn (rtx *px, rtx *py, enum rtx_code *pcomparison, rtx size,\n \t  return;\n \t}\n \n-      /* Otherwise call a library function, memcmp if we've got it,\n-\t bcmp otherwise.  */\n-#ifdef TARGET_MEM_FUNCTIONS\n+      /* Otherwise call a library function, memcmp.  */\n       libfunc = memcmp_libfunc;\n       length_type = sizetype;\n-#else\n-      libfunc = bcmp_libfunc;\n-      length_type = integer_type_node;\n-#endif\n       result_mode = TYPE_MODE (integer_type_node);\n       cmp_mode = TYPE_MODE (length_type);\n       size = convert_to_mode (TYPE_MODE (length_type), size,\n@@ -5522,11 +5516,8 @@ init_optabs (void)\n   abort_libfunc = init_one_libfunc (\"abort\");\n   memcpy_libfunc = init_one_libfunc (\"memcpy\");\n   memmove_libfunc = init_one_libfunc (\"memmove\");\n-  bcopy_libfunc = init_one_libfunc (\"bcopy\");\n   memcmp_libfunc = init_one_libfunc (\"memcmp\");\n-  bcmp_libfunc = init_one_libfunc (\"__gcc_bcmp\");\n   memset_libfunc = init_one_libfunc (\"memset\");\n-  bzero_libfunc = init_one_libfunc (\"bzero\");\n   setbits_libfunc = init_one_libfunc (\"__setbits\");\n \n   unwind_resume_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS"}, {"sha": "90d906b3b3a078d99155efdc534c41b7e235f9d8", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f99553ff6cdc54e5af910042f93fbfbdaac0424/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=8f99553ff6cdc54e5af910042f93fbfbdaac0424", "patch": "@@ -618,7 +618,7 @@ extern int snprintf (char *, size_t, const char *, ...);\n \tDBX_OUTPUT_STANDARD_TYPES BUILTIN_SETJMP_FRAME_VALUE\t\t   \\\n \tSUNOS4_SHARED_LIBRARIES PROMOTE_FOR_CALL_ONLY\t\t\t   \\\n \tSPACE_AFTER_L_OPTION NO_RECURSIVE_FUNCTION_CSE\t\t\t   \\\n-\tDEFAULT_MAIN_RETURN\n+\tDEFAULT_MAIN_RETURN TARGET_MEM_FUNCTIONS\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}]}