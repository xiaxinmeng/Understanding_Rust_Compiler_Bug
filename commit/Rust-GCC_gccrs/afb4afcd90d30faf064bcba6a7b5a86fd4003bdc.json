{"sha": "afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZiNGFmY2Q5MGQzMGZhZjA2NGJjYmE2YTdiNWE4NmZkNDAwM2JkYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-10-16T19:28:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-10-16T19:28:52Z"}, "message": "exp_dbug.ads: Adjust type names in comments.\n\n\t* exp_dbug.ads: Adjust type names in comments.\n\t* gcc-interface/decl.c (maybe_pad_type): Remove NAME_TRAILER parameter,\n\tadd new IS_COMPONENT_TYPE parameter.  Adjust.  Remove dead code.\n\t(gnat_to_gnu_entity): Adjust for above change.\n\t(gnat_to_gnu_component_type): Likewise.\n\t(gnat_to_gnu_field): Likewise.\n\t* gcc-interface/trans.c (call_to_gnu): Likewise.  Do not unnecessarily\n\tcall max_size.\n\t* gcc-interface/utils.c (finish_record_type): Remove obsolete code.\n\t* gcc-interface/gigi.h (maybe_pad_type): Adjust prototype.\n\nFrom-SVN: r152916", "tree": {"sha": "cb3644326b2ac3cdc4b94ace7e353dcd04c121fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb3644326b2ac3cdc4b94ace7e353dcd04c121fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/comments", "author": null, "committer": null, "parents": [{"sha": "3b24c708a1d4da6b37ce1bde62d44a056030b635", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b24c708a1d4da6b37ce1bde62d44a056030b635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b24c708a1d4da6b37ce1bde62d44a056030b635"}], "stats": {"total": 113, "additions": 56, "deletions": 57}, "files": [{"sha": "4338d03d16780f4b749c2bc08bcdadc44b9ffd03", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "patch": "@@ -1,3 +1,16 @@\n+2009-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_dbug.ads: Adjust type names in comments.\n+\t* gcc-interface/decl.c (maybe_pad_type): Remove NAME_TRAILER parameter,\n+\tadd new IS_COMPONENT_TYPE parameter.  Adjust.  Remove dead code.\n+\t(gnat_to_gnu_entity): Adjust for above change.\n+\t(gnat_to_gnu_component_type): Likewise.\n+\t(gnat_to_gnu_field): Likewise.\n+\t* gcc-interface/trans.c (call_to_gnu): Likewise.  Do not unnecessarily\n+\tcall max_size.\n+\t* gcc-interface/utils.c (finish_record_type): Remove obsolete code.\n+\t* gcc-interface/gigi.h (maybe_pad_type): Adjust prototype.\n+\n 2009-10-16  Joel Sherrill <joel.sherrill@oarcorp.com>\n \n \t* s-osinte-rtems.ads: Add mutex type to pthread_mutexattr_t"}, {"sha": "1d26bb3ef754fb24e37fe8cdf4315608c27bd993", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "patch": "@@ -873,12 +873,12 @@ package Exp_Dbug is\n       --  the element type for AT1 might have a type defined as if it had\n       --  been written:\n       --\n-      --     type at1___C_PAD is record null; end record;\n-      --     for at1___C_PAD'Size use 16 * 8;\n+      --     type at1___PAD is record null; end record;\n+      --     for at1___PAD'Size use 16 * 8;\n       --\n       --  and there would also be\n       --\n-      --     type at1___C_PAD___XVS is record t1: Integer; end record;\n+      --     type at1___PAD___XVS is record t1: Integer; end record;\n       --     type t1 is ...\n       --\n       --  Had the subtype Int been dynamic:\n@@ -888,7 +888,7 @@ package Exp_Dbug is\n       --  Then the compiler would also generate a declaration whose effect\n       --  would be\n       --\n-      --     at1___C_PAD___XVZ: constant Integer := 32 + M * 8 + padding term;\n+      --     at1___PAD___XVZ: constant Integer := 32 + M * 8 + padding term;\n       --\n       --  Not all unconstrained types are so encoded; the XVS convention may be\n       --  unnecessary for unconstrained types of fixed size. However, this"}, {"sha": "afef46ec8093ee81bcfaeebf6f36a09e870b16c8", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "patch": "@@ -633,7 +633,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    else\n \t      gnu_type\n \t\t= maybe_pad_type (gnu_type, NULL_TREE, align, gnat_entity,\n-\t\t\t\t  \"PAD\", false, definition, true);\n+\t\t\t\t  false, false, definition, true);\n \t  }\n \n \t/* If we are defining the object, see if it has a Size value and\n@@ -838,7 +838,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_object_size = gnu_size ? gnu_size : TYPE_SIZE (gnu_type);\n \tif (gnu_size || align > 0)\n \t  gnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n-\t\t\t\t     \"PAD\", false, definition,\n+\t\t\t\t     false, false, definition,\n \t\t\t\t     gnu_size ? true : false);\n \n \t/* If this is a renaming, avoid as much as possible to create a new\n@@ -1017,8 +1017,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && !gnu_expr\n \t    && TREE_CODE (gnu_type) == RECORD_TYPE\n \t    && (TYPE_CONTAINS_TEMPLATE_P (gnu_type)\n-\t        /* Beware that padding might have been introduced\n-\t\t   via maybe_pad_type above.  */\n+\t        /* Beware that padding might have been introduced above.  */\n \t\t|| (TYPE_IS_PADDING_P (gnu_type)\n \t\t    && TREE_CODE (TREE_TYPE (TYPE_FIELDS (gnu_type)))\n \t\t       == RECORD_TYPE\n@@ -4446,7 +4445,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t us when we make the new TYPE_DECL below.  */\n       if (gnu_size || align > 0)\n \tgnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n-\t\t\t\t   \"PAD\", true, definition, false);\n+\t\t\t\t   false, true, definition, false);\n \n       if (TREE_CODE (gnu_type) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (gnu_type))\n@@ -5037,7 +5036,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n \torig_type = gnu_type;\n \n       gnu_type = maybe_pad_type (gnu_type, gnu_comp_size, 0, gnat_array,\n-\t\t\t\t \"C_PAD\", false, definition, true);\n+\t\t\t\t true, false, definition, true);\n \n       /* If a padding record was made, declare it now since it will never be\n \t declared otherwise.  This is necessary to ensure that its subtrees\n@@ -6046,25 +6045,20 @@ make_packable_type (tree type, bool in_record)\n \f\n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n    if needed.  We have already verified that SIZE and TYPE are large enough.\n-\n-   GNAT_ENTITY and NAME_TRAILER are used to name the resulting record and\n-   to issue a warning.\n-\n-   IS_USER_TYPE is true if we must complete the original type.\n-\n-   DEFINITION is true if this type is being defined.\n-\n-   SAME_RM_SIZE is true if the RM size of the resulting type is to be set\n-   to SIZE too; otherwise, it's set to the RM size of the original type.  */\n+   GNAT_ENTITY is used to name the resulting record and to issue a warning.\n+   IS_COMPONENT_TYPE is true if this is being done for the component type\n+   of an array.  IS_USER_TYPE is true if we must complete the original type.\n+   DEFINITION is true if this type is being defined.  SAME_RM_SIZE is true\n+   if the RM size of the resulting type is to be set to SIZE too; otherwise,\n+   it's set to the RM size of the original type.  */\n \n tree\n maybe_pad_type (tree type, tree size, unsigned int align,\n-\t\tEntity_Id gnat_entity, const char *name_trailer,\n+\t\tEntity_Id gnat_entity, bool is_component_type,\n \t\tbool is_user_type, bool definition, bool same_rm_size)\n {\n   tree orig_rm_size = same_rm_size ? NULL_TREE : rm_size (type);\n   tree orig_size = TYPE_SIZE (type);\n-  unsigned int orig_align = align;\n   tree record, field;\n \n   /* If TYPE is a padded type, see if it agrees with any size and alignment\n@@ -6124,15 +6118,12 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   TYPE_IS_PADDING_P (record) = 1;\n \n   if (Present (gnat_entity))\n-    TYPE_NAME (record) = create_concat_name (gnat_entity, name_trailer);\n+    TYPE_NAME (record) = create_concat_name (gnat_entity, \"PAD\");\n \n   TYPE_VOLATILE (record)\n     = Present (gnat_entity) && Treat_As_Volatile (gnat_entity);\n \n   TYPE_ALIGN (record) = align;\n-  if (orig_align)\n-    TYPE_USER_ALIGN (record) = align;\n-\n   TYPE_SIZE (record) = size ? size : orig_size;\n   TYPE_SIZE_UNIT (record)\n     = convert (sizetype,\n@@ -6256,7 +6247,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t    post_error_ne_tree (\"{^ }bits of & unused?\",\n \t\t\t\tgnat_error_node, gnat_entity,\n \t\t\t\tsize_diffop (size, orig_size));\n-\t  else if (name_trailer[0] == 'C')\n+\t  else if (is_component_type)\n \t    post_error_ne_tree (\"component of& padded{ by ^ bits}?\",\n \t\t\t\tgnat_entity, gnat_entity,\n \t\t\t\tsize_diffop (size, orig_size));\n@@ -6634,7 +6625,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \n       orig_field_type = gnu_field_type;\n       gnu_field_type = maybe_pad_type (gnu_field_type, gnu_size, 0, gnat_field,\n-\t\t\t\t       \"PAD\", false, definition, true);\n+\t\t\t\t       false, false, definition, true);\n \n       /* If a padding record was made, declare it now since it will never be\n \t declared otherwise.  This is necessary to ensure that its subtrees"}, {"sha": "f376b22e2ccecca2ec06b81beaedd921ec58b5f3", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "patch": "@@ -124,21 +124,16 @@ extern tree make_aligning_type (tree type, unsigned int align, tree size,\n \n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n    if needed.  We have already verified that SIZE and TYPE are large enough.\n-\n-   GNAT_ENTITY and NAME_TRAILER are used to name the resulting record and\n-   to issue a warning.\n-\n-   IS_USER_TYPE is true if we must be sure we complete the original type.\n-\n-   DEFINITION is true if this type is being defined.\n-\n-   SAME_RM_SIZE is true if the RM_Size of the resulting type is to be\n-   set to its TYPE_SIZE; otherwise, it's set to the RM_Size of the original\n-   type.  */\n+   GNAT_ENTITY is used to name the resulting record and to issue a warning.\n+   IS_COMPONENT_TYPE is true if this is being done for the component type\n+   of an array.  IS_USER_TYPE is true if we must complete the original type.\n+   DEFINITION is true if this type is being defined.  SAME_RM_SIZE is true\n+   if the RM size of the resulting type is to be set to SIZE too; otherwise,\n+   it's set to the RM size of the original type.  */\n extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n-                            Entity_Id gnat_entity, const char *name_trailer,\n+\t\t\t    Entity_Id gnat_entity, bool is_component_type,\n \t\t\t    bool is_user_type, bool definition,\n-                            bool same_rm_size);\n+\t\t\t    bool same_rm_size);\n \n /* Given a GNU tree and a GNAT list of choices, generate an expression to test\n    the value passed against the list of choices.  */"}, {"sha": "74aa2b67ef422643eccbfc6879fd2017c6cfe992", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "patch": "@@ -2423,22 +2423,27 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       }\n     }\n \n-  /* If we are calling by supplying a pointer to a target, set up that\n-     pointer as the first argument.  Use GNU_TARGET if one was passed;\n-     otherwise, make a target by building a variable of the maximum size\n-     of the type.  */\n+  /* If we are calling by supplying a pointer to a target, set up that pointer\n+     as the first argument.  Use GNU_TARGET if one was passed; otherwise, make\n+     a target by building a variable and use the maximum size of the type if\n+     it has self-referential size.  */\n   if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n     {\n-      tree gnu_real_ret_type\n+      tree gnu_ret_type\n \t= TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (gnu_subprog_type)));\n \n       if (!gnu_target)\n \t{\n-\t  tree gnu_obj_type\n-\t    = maybe_pad_type (gnu_real_ret_type,\n-\t\t\t      max_size (TYPE_SIZE (gnu_real_ret_type), true),\n-\t\t\t      0, Etype (Name (gnat_node)), \"PAD\", false,\n-\t\t\t      false, false);\n+\t  tree gnu_obj_type;\n+\n+\t  if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_ret_type)))\n+\t    gnu_obj_type\n+\t      = maybe_pad_type (gnu_ret_type,\n+\t\t\t\tmax_size (TYPE_SIZE (gnu_ret_type), true),\n+\t\t\t\t0, Etype (Name (gnat_node)), false, false,\n+\t\t\t\tfalse, true);\n+\t  else\n+\t    gnu_obj_type = gnu_ret_type;\n \n \t  /* ??? We may be about to create a static temporary if we happen to\n \t     be at the global binding level.  That's a regression from what\n@@ -2454,7 +2459,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       gnu_actual_list\n \t= tree_cons (NULL_TREE,\n \t\t     build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t     unchecked_convert (gnu_real_ret_type,\n+\t\t\t\t     unchecked_convert (gnu_ret_type,\n \t\t\t\t\t\t\tgnu_target,\n \t\t\t\t\t\t\tfalse)),\n \t\t     NULL_TREE);"}, {"sha": "f1a4b0065ba0cdc5968dd000bb1860c73671f99f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afb4afcd90d30faf064bcba6a7b5a86fd4003bdc/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=afb4afcd90d30faf064bcba6a7b5a86fd4003bdc", "patch": "@@ -739,11 +739,6 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n   if (code == QUAL_UNION_TYPE)\n     nreverse (fieldlist);\n \n-  /* If the type is discriminated, it can be used to access all its\n-     constrained subtypes, so force structural equality checks.  */\n-  if (CONTAINS_PLACEHOLDER_P (size))\n-    SET_TYPE_STRUCTURAL_EQUALITY (record_type);\n-\n   if (rep_level < 2)\n     {\n       /* If this is a padding record, we never want to make the size smaller"}]}