{"sha": "2720cc47173b23e02cb9e08975919e40e75f6109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcyMGNjNDcxNzNiMjNlMDJjYjllMDg5NzU5MTllNDBlNzVmNjEwOQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2010-10-06T08:16:18Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2010-10-06T08:16:18Z"}, "message": "mn10300.h (FIRST_PSEUDO_REGISTER): Increment by one.\n\n        * config/mn10300/mn10300.h (FIRST_PSEUDO_REGISTER): Increment by\n        one.\n        (MDR_REGNUM): Define.\n        (FIXED_REGISTERS, CALL_USED_REGISTERS): Add MDR as a fixed\n        register.\n        (REG_CLASS_CONTENTS): Add MDR to ALL_REGS.\n        (INCOMING_RETURN_ADDR_RTX): Define in terms of MDR.\n        (REGISTER_NAMES): Add MDR.\n        (DWARF2_DEBUGGING_INFO): Define to 1.\n        * config/mn10300/mn10300.c (TARGET_EXCEPT_UNWIND_INFO): Define.\n        (F): New function.  Sets RTX_FRAME_RELATED_P.\n        (mn10300_gen_multiple_store): Use F.\n        (expand_prologue): Use F.  Use gen_movsf() to push floating\n        point registers.\n        (expand_epilogue): Use gen_movsf() to pop floating point\n        registers.\n        (mn10300_option_override): Disable combine stack adjust pass.\n\nFrom-SVN: r165015", "tree": {"sha": "dbd71169883e9fea8fbcb7c7d183fa75dab57f1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbd71169883e9fea8fbcb7c7d183fa75dab57f1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2720cc47173b23e02cb9e08975919e40e75f6109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2720cc47173b23e02cb9e08975919e40e75f6109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2720cc47173b23e02cb9e08975919e40e75f6109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2720cc47173b23e02cb9e08975919e40e75f6109/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28ce2f29b89c076138efd52cef11f1b0a799cd92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ce2f29b89c076138efd52cef11f1b0a799cd92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ce2f29b89c076138efd52cef11f1b0a799cd92"}], "stats": {"total": 119, "additions": 78, "deletions": 41}, "files": [{"sha": "64c670af0198ddf98eda8acee684e78f5e45b4a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2720cc47173b23e02cb9e08975919e40e75f6109/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2720cc47173b23e02cb9e08975919e40e75f6109/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2720cc47173b23e02cb9e08975919e40e75f6109", "patch": "@@ -1,3 +1,23 @@\n+2010-10-06  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mn10300/mn10300.h (FIRST_PSEUDO_REGISTER): Increment by\n+\tone.\n+\t(MDR_REGNUM): Define.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Add MDR as a fixed\n+\tregister.\n+\t(REG_CLASS_CONTENTS): Add MDR to ALL_REGS.\n+\t(INCOMING_RETURN_ADDR_RTX): Define in terms of MDR.\n+\t(REGISTER_NAMES): Add MDR.\n+\t(DWARF2_DEBUGGING_INFO): Define to 1.\n+\t* config/mn10300/mn10300.c (TARGET_EXCEPT_UNWIND_INFO): Define.\n+\t(F): New function.  Sets RTX_FRAME_RELATED_P.\n+\t(mn10300_gen_multiple_store): Use F.\n+\t(expand_prologue): Use F.  Use gen_movsf() to push floating\n+\tpoint registers.\n+\t(expand_epilogue): Use gen_movsf() to pop floating point\n+\tregisters.\n+\t(mn10300_option_override): Disable combine stack adjust pass.\n+\n 2010-10-06  Thomas Schwinge  <thomas@schwinge.name>\n \n \tPR target/45901"}, {"sha": "47e5293b890ebe5e09747886283d72b81819a6fb", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2720cc47173b23e02cb9e08975919e40e75f6109/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2720cc47173b23e02cb9e08975919e40e75f6109/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=2720cc47173b23e02cb9e08975919e40e75f6109", "patch": "@@ -93,6 +93,9 @@ static void mn10300_asm_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_\n static bool mn10300_can_output_mi_thunk (const_tree, HOST_WIDE_INT, HOST_WIDE_INT, const_tree);\n \f\n /* Initialize the GCC target structure.  */\n+#undef  TARGET_EXCEPT_UNWIND_INFO\n+#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n+\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n \n@@ -187,6 +190,12 @@ mn10300_option_override (void)\n {\n   if (TARGET_AM33)\n     target_flags &= ~MASK_MULT_BUG;\n+\n+  /* FIXME: The combine stack adjustments pass is breaking\n+     cc0-setter/cc0-user relationship by inserting a jump\n+     instruction.  This should be investigated, but for now\n+     just disable the pass.  */\n+  flag_combine_stack_adjustments = 0;\n }\n \n static void\n@@ -661,6 +670,13 @@ mn10300_get_live_callee_saved_regs (void)\n   return mask;\n }\n \n+static rtx\n+F (rtx r)\n+{\n+  RTX_FRAME_RELATED_P (r) = 1;\n+  return r;\n+}\n+\n /* Generate an instruction that pushes several registers onto the stack.\n    Register K will be saved if bit K in MASK is set.  The function does\n    nothing if MASK is zero.\n@@ -702,11 +718,11 @@ mn10300_gen_multiple_store (int mask)\n \n       /* Create the instruction that updates the stack pointer.  */\n       XVECEXP (par, 0, 0)\n-\t= gen_rtx_SET (SImode,\n-\t\t       stack_pointer_rtx,\n-\t\t       gen_rtx_PLUS (SImode,\n-\t\t\t\t     stack_pointer_rtx,\n-\t\t\t\t     GEN_INT (-count * 4)));\n+\t= F (gen_rtx_SET (SImode,\n+\t\t\t  stack_pointer_rtx,\n+\t\t\t  gen_rtx_PLUS (SImode,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (-count * 4))));\n \n       /* Create each store.  */\n       pari = 1;\n@@ -717,14 +733,13 @@ mn10300_gen_multiple_store (int mask)\n \t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\tGEN_INT (-pari * 4));\n \t    XVECEXP(par, 0, pari)\n-\t      = gen_rtx_SET (VOIDmode,\n-\t\t\t     gen_rtx_MEM (SImode, address),\n-\t\t\t     gen_rtx_REG (SImode, i));\n+\t      = F (gen_rtx_SET (VOIDmode,\n+\t\t\t\tgen_rtx_MEM (SImode, address),\n+\t\t\t\tgen_rtx_REG (SImode, i)));\n \t    pari += 1;\n \t  }\n \n-      par = emit_insn (par);\n-      RTX_FRAME_RELATED_P (par) = 1;\n+      F (emit_insn (par));\n     }\n }\n \n@@ -751,7 +766,6 @@ expand_prologue (void)\n \t     save_a0_no_merge } strategy;\n       unsigned int strategy_size = (unsigned)-1, this_strategy_size;\n       rtx reg;\n-      rtx insn;\n \n       /* We have several different strategies to save FP registers.\n \t We can store them using SP offsets, which is beneficial if\n@@ -891,25 +905,25 @@ expand_prologue (void)\n \t{\n \tcase save_sp_no_merge:\n \tcase save_a0_no_merge:\n-\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t GEN_INT (-4 * num_regs_to_save)));\n+\t  F (emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-4 * num_regs_to_save))));\n \t  xsize = 0;\n \t  break;\n \n \tcase save_sp_partial_merge:\n-\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t GEN_INT (-128)));\n+\t  F (emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-128))));\n \t  xsize = 128 - 4 * num_regs_to_save;\n \t  size -= xsize;\n \t  break;\n \n \tcase save_sp_merge:\n \tcase save_a0_merge:\n-\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t GEN_INT (-(size + 4 * num_regs_to_save))));\n+\t  F (emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t    stack_pointer_rtx,\n+\t\t\t\t    GEN_INT (-(size + 4 * num_regs_to_save)))));\n \t  /* We'll have to adjust FP register saves according to the\n \t     frame size.  */\n \t  xsize = size;\n@@ -934,9 +948,9 @@ expand_prologue (void)\n \tcase save_a0_merge:\n \tcase save_a0_no_merge:\n \t  reg = gen_rtx_REG (SImode, FIRST_ADDRESS_REGNUM);\n-\t  emit_insn (gen_movsi (reg, stack_pointer_rtx));\n+\t  F (emit_insn (gen_movsi (reg, stack_pointer_rtx)));\n \t  if (xsize)\n-\t    emit_insn (gen_addsi3 (reg, reg, GEN_INT (xsize)));\n+\t    F (emit_insn (gen_addsi3 (reg, reg, GEN_INT (xsize))));\n \t  reg = gen_rtx_POST_INC (SImode, reg);\n \t  break;\n \n@@ -967,22 +981,21 @@ expand_prologue (void)\n \t\txsize += 4;\n \t      }\n \n-\t    insn = emit_insn (gen_movsi (gen_rtx_MEM (SImode, addr),\n-\t\t\t\t\t gen_rtx_REG (SImode, i)));\n-\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t    F (emit_insn (gen_movsf (gen_rtx_MEM (SFmode, addr),\n+\t\t\t\t     gen_rtx_REG (SFmode, i))));\n \t  }\n     }\n \n   /* Now put the frame pointer into the frame pointer register.  */\n   if (frame_pointer_needed)\n-    emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+    F (emit_move_insn (frame_pointer_rtx, stack_pointer_rtx));\n \n   /* Allocate stack for this frame.  */\n   if (size)\n-    emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t   stack_pointer_rtx,\n-\t\t\t   GEN_INT (-size)));\n+    F (emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t      stack_pointer_rtx,\n+\t\t\t      GEN_INT (-size))));\n+\n   if (flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM))\n     emit_insn (gen_GOTaddr2picreg ());\n }\n@@ -1169,8 +1182,8 @@ expand_epilogue (void)\n \n \t    size += 4;\n \n-\t    emit_insn (gen_movsi (gen_rtx_REG (SImode, i),\n-\t\t\t\t  gen_rtx_MEM (SImode, addr)));\n+\t    emit_insn (gen_movsf (gen_rtx_REG (SFmode, i),\n+\t\t\t\t  gen_rtx_MEM (SFmode, addr)));\n \t  }\n \n       /* If we were using the restore_a1 strategy and the number of\n@@ -1261,8 +1274,8 @@ notice_update_cc (rtx body, rtx insn)\n       /* The insn is a compare instruction.  */\n       CC_STATUS_INIT;\n       cc_status.value1 = SET_SRC (body);\n-      if (GET_CODE (cc_status.value1) == COMPARE\n-\t  && GET_MODE (XEXP (cc_status.value1, 0)) == SFmode)\n+      if (GET_CODE (SET_SRC (body)) == COMPARE\n+\t  && GET_MODE (XEXP (SET_SRC (body), 0)) == SFmode)\n \tcc_status.mdep.fpCC = 1;\n       break;\n \n@@ -2138,7 +2151,7 @@ mn10300_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed ATTRI\n bool\n mn10300_wide_const_load_uses_clr (rtx operands[2])\n {\n-  long val[2];\n+  long val[2] = {0, 0};\n \n   if (GET_CODE (operands[0]) != REG\n       || REGNO_REG_CLASS (REGNO (operands[0])) != DATA_REGS)"}, {"sha": "26990adf50e3d2340750026c77149a8d91f78041", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2720cc47173b23e02cb9e08975919e40e75f6109/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2720cc47173b23e02cb9e08975919e40e75f6109/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=2720cc47173b23e02cb9e08975919e40e75f6109", "patch": "@@ -117,7 +117,7 @@ extern enum processor_type mn10300_processor;\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n \n-#define FIRST_PSEUDO_REGISTER 50\n+#define FIRST_PSEUDO_REGISTER 51\n \n /* Specify machine-specific register numbers.  */\n #define FIRST_DATA_REGNUM 0\n@@ -128,6 +128,7 @@ extern enum processor_type mn10300_processor;\n #define LAST_EXTENDED_REGNUM 17\n #define FIRST_FP_REGNUM 18\n #define LAST_FP_REGNUM 49\n+#define MDR_REGNUM 50\n #define FIRST_ARGUMENT_REGNUM 0\n \n /* Specify the registers used for certain standard purposes.\n@@ -153,7 +154,7 @@ extern enum processor_type mn10300_processor;\n #define FIXED_REGISTERS \\\n   { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 \\\n   , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\\n-  , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\\n+  , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 \\\n   }\n \n /* 1 for registers not available across function calls.\n@@ -167,7 +168,7 @@ extern enum processor_type mn10300_processor;\n #define CALL_USED_REGISTERS \\\n   { 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 \\\n   , 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\\n-  , 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 \\\n+  , 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 \\\n   }\n \n /* Note: The definition of CALL_REALLY_USED_REGISTERS is not\n@@ -298,7 +299,7 @@ enum reg_class {\n  { 0xfffc0000, 0x3ffff }, /* FP_REGS */\t\t\\\n  { 0x03fc0000, 0 },\t/* FP_ACC_REGS */\t\\\n  { 0x3fdff, 0 }, \t/* GENERAL_REGS */\t\\\n- { 0xffffffff, 0x3ffff } /* ALL_REGS \t*/\t\\\n+ { 0xffffffff, 0x7ffff } /* ALL_REGS \t*/\t\\\n }\n \n /* The following macro defines cover classes for Integrated Register\n@@ -587,6 +588,8 @@ struct cum_arg {int nbytes; };\n   ((COUNT == 0)                         \\\n    ? gen_rtx_MEM (Pmode, arg_pointer_rtx) \\\n    : (rtx) 0)\n+\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG (Pmode, MDR_REGNUM)\n \f\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n@@ -765,7 +768,7 @@ struct cum_arg {int nbytes; };\n , \"fs0\", \"fs1\", \"fs2\", \"fs3\", \"fs4\", \"fs5\", \"fs6\", \"fs7\" \\\n , \"fs8\", \"fs9\", \"fs10\", \"fs11\", \"fs12\", \"fs13\", \"fs14\", \"fs15\" \\\n , \"fs16\", \"fs17\", \"fs18\", \"fs19\", \"fs20\", \"fs21\", \"fs22\", \"fs23\" \\\n-, \"fs24\", \"fs25\", \"fs26\", \"fs27\", \"fs28\", \"fs29\", \"fs30\", \"fs31\" \\\n+    , \"fs24\", \"fs25\", \"fs26\", \"fs27\", \"fs28\", \"fs29\", \"fs30\", \"fs31\", \"mdr\"\t\\\n }\n \n #define ADDITIONAL_REGISTER_NAMES \\\n@@ -810,8 +813,9 @@ struct cum_arg {int nbytes; };\n #define DEFAULT_GDB_EXTENSIONS 1\n \n /* Use dwarf2 debugging info by default.  */\n-#undef PREFERRED_DEBUGGING_TYPE\n+#undef  PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+#define DWARF2_DEBUGGING_INFO 1\n \n #define DWARF2_ASM_LINE_DEBUG_INFO 1\n "}]}