{"sha": "181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgxYzlmNGE5YmE2YjJkNjRjN2MwYjU2Yjc3N2FkMzY2ZTA1YTljMQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2005-12-10T20:01:56Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2005-12-10T20:01:56Z"}, "message": "re PR fortran/23815 (Add -byteswapio flag)\n\n2005-12-10  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/23815\n\t* io.c (top level):  Add convert to io_tag.\n\t(resolve_tag):  convert is GFC_STD_GNU.\n\t(match_open_element):  Add convert.\n\t(gfc_free_open):  Likewise.\n\t(gfc_resolve_open):  Likewise.\n\t(gfc_free_inquire):  Likewise.\n\t(match_inquire_element):  Likewise.\n\t* dump-parse-tree.c (gfc_show_code_node):  Add\n\tconvet for open and inquire.\n\tgfortran.h: Add convert to gfc_open and gfc_inquire.\n\t* trans-io.c (gfc_trans_open):  Add convert.\n\t(gfc_trans_inquire):  Likewise.\n\t* ioparm.def:  Add convert to open and inquire.\n\t* gfortran.texi:  Document CONVERT.\n\n2005-12-10  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/23815\n\t* io/file_pos.c (unformatted_backspace):  If flags.convert\n\tdoes not equal CONVERT_NATIVE, reverse the record marker.\n\t* io/open.c:  Add convert_opt[].\n\t(st_open):  If no convert option is given, set CONVERT_NATIVE.\n\tIf CONVERT_BIG or CONVERT_LITTLE are given, set flags.convert to\n\tCONVERT_NATIVE or CONVERT_SWAP (depending on wether we have\n\ta big- or little-endian system).\n\t* io/transfer.c (unformatted_read):  Remove unused attribute\n\tfrom arguments.\n\tIf we need to reverse\n\tbytes, break up large transfers into a loop.  Split complex\n\tnumbers into its two parts.\n\t(unformatted_write):  Likewise.\n\t(us_read):  If flags.convert does not equal CONVERT_NATIVE,\n\treverse the record marker.\n\t(next_record_w): Likewise.\n\t(reverse_memcpy):  New function.\n\t* io/inquire.c (inquire_via_unit):  Implement convert.\n\t* io/io.h (top level):  Add enum unit_convert.\n\tAdd convert to st_parameter_open and st_parameter_inquire.\n\tDefine IOPARM_OPEN_HAS_CONVERT and IOPARM_INQUIRE_HAS_CONVERT.\n\tIncrease padding for st_parameter_dt.\n\tDeclare reverse_memcpy().\n\n2005-12-10  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/23815\n\t* gfortran.dg/unf_io_convert_1.f90:  New test.\n\t* gfortran.dg/unf_io_convert_2.f90:  New test.\n\t* gfortran.dg/unf_io_convert_3.f90:  New test.\n\nFrom-SVN: r108358", "tree": {"sha": "a3d754eebe0bc2166ffe8c241b2d9dfdd1098340", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3d754eebe0bc2166ffe8c241b2d9dfdd1098340"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/comments", "author": null, "committer": null, "parents": [{"sha": "775fe6e36ddaef38cca67c39bf34b93fcb836dc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/775fe6e36ddaef38cca67c39bf34b93fcb836dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/775fe6e36ddaef38cca67c39bf34b93fcb836dc3"}], "stats": {"total": 481, "additions": 465, "deletions": 16}, "files": [{"sha": "e9a8f308dae0271a391856076bfffa2db0dd421b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -1,3 +1,21 @@\n+2005-12-10  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/23815\n+\t* io.c (top level):  Add convert to io_tag.\n+\t(resolve_tag):  convert is GFC_STD_GNU.\n+\t(match_open_element):  Add convert.\n+\t(gfc_free_open):  Likewise.\n+\t(gfc_resolve_open):  Likewise.\n+\t(gfc_free_inquire):  Likewise.\n+\t(match_inquire_element):  Likewise.\n+\t* dump-parse-tree.c (gfc_show_code_node):  Add\n+\tconvet for open and inquire.\n+\tgfortran.h: Add convert to gfc_open and gfc_inquire.\n+\t* trans-io.c (gfc_trans_open):  Add convert.\n+\t(gfc_trans_inquire):  Likewise.\n+\t* ioparm.def:  Add convert to open and inquire.\n+\t* gfortran.texi:  Document CONVERT.\n+\n 2005-12-09  Roger Sayle  <roger@eyesopen.com>\n \n \tPR fortran/22527"}, {"sha": "ef5c88a94b4a7a783f7dcd33050d85ac0e70ca86", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -1148,6 +1148,11 @@ gfc_show_code_node (int level, gfc_code * c)\n \t  gfc_status (\" PAD=\");\n \t  gfc_show_expr (open->pad);\n \t}\n+      if (open->convert)\n+\t{\n+\t  gfc_status (\" CONVERT=\");\n+\t  gfc_show_expr (open->convert);\n+\t}\n       if (open->err != NULL)\n \tgfc_status (\" ERR=%d\", open->err->value);\n \n@@ -1349,6 +1354,11 @@ gfc_show_code_node (int level, gfc_code * c)\n \t  gfc_status (\" PAD=\");\n \t  gfc_show_expr (i->pad);\n \t}\n+      if (i->convert)\n+\t{\n+\t  gfc_status (\" CONVERT=\");\n+\t  gfc_show_expr (i->convert);\n+\t}\n \n       if (i->err != NULL)\n \tgfc_status (\" ERR=%d\", i->err->value);"}, {"sha": "f22f6a48ab6da9a5400c5efed28da2933cf13225", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -1309,7 +1309,7 @@ gfc_alloc;\n typedef struct\n {\n   gfc_expr *unit, *file, *status, *access, *form, *recl,\n-    *blank, *position, *action, *delim, *pad, *iostat, *iomsg;\n+    *blank, *position, *action, *delim, *pad, *iostat, *iomsg, *convert;\n   gfc_st_label *err;\n }\n gfc_open;\n@@ -1336,7 +1336,7 @@ typedef struct\n   gfc_expr *unit, *file, *iostat, *exist, *opened, *number, *named,\n     *name, *access, *sequential, *direct, *form, *formatted,\n     *unformatted, *recl, *nextrec, *blank, *position, *action, *read,\n-    *write, *readwrite, *delim, *pad, *iolength, *iomsg;\n+    *write, *readwrite, *delim, *pad, *iolength, *iomsg, *convert;\n \n   gfc_st_label *err;\n "}, {"sha": "ea3ac245aa51a2f161ee9780b27e21eb9f98d443", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -587,6 +587,7 @@ of extensions, and @option{-std=legacy} allows both without warning.\n * Implicitly interconvert LOGICAL and INTEGER::\n * Hollerith constants support::\n * Cray pointers::\n+* CONVERT specifier::\n @end menu\n \n @node Old-style kind specifications\n@@ -930,6 +931,42 @@ pointees are passed as arguments, they are treated as ordinary\n variables in the invoked function.  Subsequent changes to the pointer\n will not change the base address of the array that was passed.\n \n+@node CONVERT specifier\n+@section CONVERT specifier\n+@cindex CONVERT specifier\n+\n+gfortran allows the conversion of unformatted data between little-\n+and big-endian representation to facilitate moving of data\n+between different systems.  The conversion is indicated with\n+the @code{CONVERT} specifier on the @code{OPEN} statement.\n+\n+Valid values for @code{CONVERT} are:\n+@itemize @w{}\n+@item @code{CONVERT='NATIVE'} Use the native format.  This is the default.\n+@item @code{CONVERT='SWAP'} Swap between little- and big-endian.\n+@item @code{CONVERT='LITTLE_ENDIAN'} Use the little-endian format\n+        for unformatted files.\n+@item @code{CONVERT='BIG_ENDIAN'} Use the big-endian format for\n+        unformatted files.\n+@end itemize\n+\n+Using the option could look like this:\n+@smallexample\n+  open(file='big.dat',form='unformatted',access='sequential', &\n+       convert='big_endian')\n+@end smallexample\n+\n+The value of the conversion can be queried by using\n+@code{INQUIRE(CONVERT=ch)}.  The values returned are\n+@code{'BIG_ENDIAN'} and @code{'LITTLE_ENDIAN'}.\n+\n+@code{CONVERT} works between big- and little-endian for\n+@code{INTEGER} values of all supported kinds and for @code{REAL}\n+on IEEE sytems of kinds 4 and 8.  Conversion between different\n+``extended double'' types on different architectures such as\n+m68k and x86_64, which gfortran\n+supports as @code{REAL(KIND=10)} will probably not work.\n+\n @c ---------------------------------------------------------------------\n @include intrinsic.texi\n @c ---------------------------------------------------------------------"}, {"sha": "090f905ea30fdcdb93d00d9ad8d14281326b6319", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -78,6 +78,7 @@ static const io_tag\n \ttag_s_delim\t= {\"DELIM\", \" delim = %v\", BT_CHARACTER},\n \ttag_s_pad\t= {\"PAD\", \" pad = %v\", BT_CHARACTER},\n \ttag_iolength\t= {\"IOLENGTH\", \" iolength = %v\", BT_INTEGER},\n+\ttag_convert     = {\"CONVERT\", \" convert = %e\", BT_CHARACTER},\n \ttag_err\t\t= {\"ERR\", \" err = %l\", BT_UNKNOWN},\n \ttag_end\t\t= {\"END\", \" end = %l\", BT_UNKNOWN},\n \ttag_eor\t\t= {\"EOR\", \" eor = %l\", BT_UNKNOWN};\n@@ -1051,6 +1052,12 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n \t\t\t      &e->where) == FAILURE)\n \t    return FAILURE;\n \t}\n+      if (tag == &tag_convert)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_GNU, \"Extension: CONVERT tag at %L\",\n+\t\t\t      &e->where) == FAILURE)\n+\t    return FAILURE;\n+\t}\n     }\n \n   return SUCCESS;\n@@ -1104,6 +1111,9 @@ match_open_element (gfc_open * open)\n   if (m != MATCH_NO)\n     return m;\n   m = match_ltag (&tag_err, &open->err);\n+  if (m != MATCH_NO)\n+    return m;\n+  m = match_etag (&tag_convert, &open->convert);\n   if (m != MATCH_NO)\n     return m;\n \n@@ -1133,6 +1143,7 @@ gfc_free_open (gfc_open * open)\n   gfc_free_expr (open->action);\n   gfc_free_expr (open->delim);\n   gfc_free_expr (open->pad);\n+  gfc_free_expr (open->convert);\n \n   gfc_free (open);\n }\n@@ -1158,6 +1169,7 @@ gfc_resolve_open (gfc_open * open)\n   RESOLVE_TAG (&tag_e_action, open->action);\n   RESOLVE_TAG (&tag_e_delim, open->delim);\n   RESOLVE_TAG (&tag_e_pad, open->pad);\n+  RESOLVE_TAG (&tag_convert, open->convert);\n \n   if (gfc_reference_st_label (open->err, ST_LABEL_TARGET) == FAILURE)\n     return FAILURE;\n@@ -2438,6 +2450,7 @@ gfc_free_inquire (gfc_inquire * inquire)\n   gfc_free_expr (inquire->delim);\n   gfc_free_expr (inquire->pad);\n   gfc_free_expr (inquire->iolength);\n+  gfc_free_expr (inquire->convert);\n \n   gfc_free (inquire);\n }\n@@ -2479,6 +2492,7 @@ match_inquire_element (gfc_inquire * inquire)\n   RETM m = match_vtag (&tag_s_delim, &inquire->delim);\n   RETM m = match_vtag (&tag_s_pad, &inquire->pad);\n   RETM m = match_vtag (&tag_iolength, &inquire->iolength);\n+  RETM m = match_vtag (&tag_convert, &inquire->convert);\n   RETM return MATCH_NO;\n }\n \n@@ -2632,6 +2646,7 @@ gfc_resolve_inquire (gfc_inquire * inquire)\n   RESOLVE_TAG (&tag_s_delim, inquire->delim);\n   RESOLVE_TAG (&tag_s_pad, inquire->pad);\n   RESOLVE_TAG (&tag_iolength, inquire->iolength);\n+  RESOLVE_TAG (&tag_convert, inquire->convert);\n \n   if (gfc_reference_st_label (inquire->err, ST_LABEL_TARGET) == FAILURE)\n     return FAILURE;"}, {"sha": "0fe9a7b45bfd94ffc28718e04e21d09d4b72b0ef", "filename": "gcc/fortran/ioparm.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fioparm.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Fioparm.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fioparm.def?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -25,6 +25,7 @@ IOPARM (open,    position,\t1 << 13, char1)\n IOPARM (open,    action,\t1 << 14, char2)\n IOPARM (open,    delim,\t\t1 << 15, char1)\n IOPARM (open,    pad,\t\t1 << 16, char2)\n+IOPARM (open,    convert,       1 << 17, char1)\n IOPARM (close,   common,\t0,\t common)\n IOPARM (close,   status,\t1 << 7,  char1)\n IOPARM (filepos, common,\t0,\t common)\n@@ -51,6 +52,7 @@ IOPARM (inquire, unformatted,\t1 << 25, char1)\n IOPARM (inquire, read,\t\t1 << 26, char2)\n IOPARM (inquire, write,\t\t1 << 27, char1)\n IOPARM (inquire, readwrite,\t1 << 28, char2)\n+IOPARM (inquire, convert,       1 << 29, char1)\n #ifndef IOPARM_dt_list_format\n #define IOPARM_dt_list_format\t\t(1 << 7)\n #define IOPARM_dt_namelist_read_mode\t(1 << 8)"}, {"sha": "87a11c3d8618bfba0c7485fb97679be0505f1b25", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -791,6 +791,10 @@ gfc_trans_open (gfc_code * code)\n   if (p->err)\n     mask |= IOPARM_common_err;\n \n+  if (p->convert)\n+    mask |= set_string (&block, &post_block, var, IOPARM_open_convert,\n+\t\t\tp->convert);\n+\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);\n@@ -1073,6 +1077,10 @@ gfc_trans_inquire (gfc_code * code)\n   if (p->err)\n     mask |= IOPARM_common_err;\n \n+  if (p->convert)\n+    mask |= set_string (&block, &post_block, var, IOPARM_inquire_convert,\n+\t\t\tp->convert);\n+\n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n \n   tmp = gfc_build_addr_expr (NULL_TREE, var);"}, {"sha": "8c170f041028e441ddd62388ec389b34f65a7907", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -1,3 +1,10 @@\n+2005-12-10  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/23815\n+\t* gfortran.dg/unf_io_convert_1.f90:  New test.\n+\t* gfortran.dg/unf_io_convert_2.f90:  New test.\n+\t* gfortran.dg/unf_io_convert_3.f90:  New test.\n+\n 2005-12-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \tPR testsuite/20772"}, {"sha": "0ed3fc5dd9cbb29be2bef5bac82f1580e1f49ca8", "filename": "gcc/testsuite/gfortran.dg/unf_io_convert_1.f90", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_1.f90?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do run }\n+! { dg-options \"-pedantic\" }\n+!  This test verifies the most basic sequential unformatted I/O\n+!  with convert=\"swap\".\n+!  Adapted from seq_io.f.\n+!      write 3 records of various sizes\n+!      then read them back\n+program main\n+  implicit none\n+  integer size\n+  parameter(size=100)\n+  logical debug \n+  data debug /.FALSE./\n+! set debug to true for help in debugging failures.\n+  integer m(2)\n+  integer n\n+  real*4 r(size)\n+  integer i\n+  character*4 str\n+\n+  m(1) = Z'11223344'\n+  m(2) = Z'55667788'\n+  n    = Z'77AABBCC'\n+  str = 'asdf'\n+  do i = 1,size\n+     r(i) = i\n+  end do\n+  open(9,form=\"unformatted\",access=\"sequential\",convert=\"swap\") ! { dg-warning \"Extension: CONVERT\" }\n+  write(9) m  ! an array of 2\n+  write(9) n  ! an integer\n+  write(9) r  ! an array of reals\n+  write(9)str ! String\n+! zero all the results so we can compare after they are read back\n+  do i = 1,size\n+     r(i) = 0\n+  end do\n+  m(1) = 0\n+  m(2) = 0\n+  n = 0\n+  str = ' '\n+  \n+  rewind(9)\n+  read(9) m\n+  read(9) n\n+  read(9) r\n+  read(9) str\n+  !\n+  ! check results\n+  if (m(1).ne.Z'11223344') then\n+     if (debug) then\n+        print '(A,Z8)','m(1) incorrect.  m(1) = ',m(1)\n+     else\n+        call abort\n+     endif\n+  endif\n+  \n+  if (m(2).ne.Z'55667788') then\n+     if (debug) then\n+        print '(A,Z8)','m(2) incorrect.  m(2) = ',m(2)\n+     else\n+        call abort\n+     endif\n+  endif\n+  \n+  if (n.ne.Z'77AABBCC') then\n+     if (debug) then\n+        print '(A,Z8)','n incorrect.  n = ',n\n+     else\n+        call abort\n+     endif\n+  endif\n+  \n+  do i = 1,size\n+     if (int(r(i)).ne.i) then\n+        if (debug) then\n+           print*,'element ',i,' was ',r(i),' should be ',i\n+        else\n+           call abort\n+        endif\n+     endif\n+  end do\n+  if (str .ne. 'asdf') then\n+     if (debug) then\n+        print *,'str incorrect, str = ', str\n+     else\n+        call abort\n+     endif\n+     ! use hexdump to look at the file \"fort.9\"\n+     if (debug) then\n+        close(9)\n+     else\n+        close(9,status='DELETE')\n+     endif\n+  end if\n+end program main"}, {"sha": "42bad3ee30ff5ea17b136644f6dbff866f1c3922", "filename": "gcc/testsuite/gfortran.dg/unf_io_convert_2.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_2.f90?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+program main\n+  complex(kind=4) :: c\n+  real(kind=4) :: a(2)\n+  integer(kind=4) :: i(2)\n+  integer(kind=1) :: b(8)\n+  integer(kind=8) :: j\n+\n+  c = (3.14, 2.71)\n+  open (10, form=\"unformatted\",convert=\"swap\") ! { dg-warning \"Extension: CONVERT\" }\n+  write (10) c\n+  rewind (10)\n+  read (10) a\n+  if (a(1) /= 3.14 .or. a(2) /= 2.71) call abort\n+  close(10,status=\"delete\")\n+\n+  open (10, form=\"unformatted\",convert=\"big_endian\") ! { dg-warning \"Extension: CONVERT\" }\n+  i = (/ Z'11223344', Z'55667700' /)\n+  write (10) i\n+  rewind (10)\n+  read (10) b\n+  if (any(b /= (/ Z'11', Z'22', Z'33', Z'44', Z'55', Z'66', Z'77', Z'00' /))) &\n+    call abort\n+  backspace 10\n+  read (10) j\n+  if (j /= Z'1122334455667700') call abort\n+  close (10, status=\"delete\")\n+\n+  open (10, form=\"unformatted\", convert=\"little_endian\") ! { dg-warning \"Extension: CONVERT\" }\n+  write (10) i\n+  rewind (10)\n+  read (10) b\n+  if (any(b /= (/ Z'44', Z'33', Z'22', Z'11', Z'00', Z'77', Z'66', Z'55' /))) &\n+    call abort\n+  backspace 10\n+  read (10) j\n+  if (j /= Z'5566770011223344') call abort\n+\n+end program main"}, {"sha": "40ace2a0e06f1e898531f8a2230f8529658e00b6", "filename": "gcc/testsuite/gfortran.dg/unf_io_convert_3.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_3.f90?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run}\n+! { dg-require-effective-target fortran_large_real }\n+program main\n+  integer,parameter :: k = selected_real_kind (precision (0.0_8) + 1)\n+  real(kind=k) a,b,c\n+  a = 1.1_k\n+  open(10,convert=\"swap\",form=\"unformatted\") ! { dg-warning \"Extension: CONVERT\" }\n+  write(10) a\n+  backspace 10\n+  read (10) b\n+  close(10,status=\"delete\")\n+  if (a /= b) call abort\n+  write (11) a\n+  backspace 11\n+  open (11,form=\"unformatted\")\n+  read (11) c\n+  if (a .ne. c) call abort\n+  close (11, status=\"delete\")\n+end program main"}, {"sha": "88da4a60e6e0c617a8e7a7898a45f6ec48c94d30", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -1,3 +1,30 @@\n+2005-12-10  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/23815\n+\t* io/file_pos.c (unformatted_backspace):  If flags.convert\n+\tdoes not equal CONVERT_NATIVE, reverse the record marker.\n+\t* io/open.c:  Add convert_opt[].\n+\t(st_open):  If no convert option is given, set CONVERT_NATIVE.\n+\tIf CONVERT_BIG or CONVERT_LITTLE are given, set flags.convert to\n+\tCONVERT_NATIVE or CONVERT_SWAP (depending on wether we have\n+\ta big- or little-endian system).\n+\t* io/transfer.c (unformatted_read):  Remove unused attribute\n+\tfrom arguments.\n+\tIf we need to reverse\n+\tbytes, break up large transfers into a loop.  Split complex\n+\tnumbers into its two parts.\n+\t(unformatted_write):  Likewise.\n+\t(us_read):  If flags.convert does not equal CONVERT_NATIVE,\n+\treverse the record marker.\n+\t(next_record_w): Likewise.\n+\t(reverse_memcpy):  New function.\n+\t* io/inquire.c (inquire_via_unit):  Implement convert.\n+\t* io/io.h (top level):  Add enum unit_convert.\n+\tAdd convert to st_parameter_open and st_parameter_inquire.\n+\tDefine IOPARM_OPEN_HAS_CONVERT and IOPARM_INQUIRE_HAS_CONVERT.\n+\tIncrease padding for st_parameter_dt.\n+\tDeclare reverse_memcpy().\n+\n 2005-12-09  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR libfortran/24991"}, {"sha": "3d7dd9ab8b6ca8e4a9b1402cfdaabc01377495a0", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -114,7 +114,12 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n   if (p == NULL)\n     goto io_error;\n \n-  memcpy (&m, p, sizeof (gfc_offset));\n+  /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n+  if (u->flags.convert == CONVERT_NATIVE)\n+    memcpy (&m, p, sizeof (gfc_offset));\n+  else\n+    reverse_memcpy (&m, p, sizeof (gfc_offset));\n+\n   new = file_position (u->s) - m - 2*length;\n   if (sseek (u->s, new) == FAILURE)\n     goto io_error;"}, {"sha": "9044bf83e2114e153cf1a141a48b2e0fa0f587fc", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -283,6 +283,29 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n \n       cf_strcpy (iqp->pad, iqp->pad_len, p);\n     }\n+ \n+  if ((cf & IOPARM_INQUIRE_HAS_CONVERT) != 0)\n+    {\n+      if (u == NULL)\n+\tp = undefined;\n+      else\n+\tswitch (u->flags.convert)\n+\t  {\n+\t    /*  l8_to_l4_offset is 0 for little-endian, 1 for big-endian.  */\n+\t  case CONVERT_NATIVE:\n+\t    p = l8_to_l4_offset ? \"BIG_ENDIAN\" : \"LITTLE_ENDIAN\";\n+\t    break;\n+\n+\t  case CONVERT_SWAP:\n+\t    p = l8_to_l4_offset ? \"LITTLE_ENDIAN\" : \"BIG_ENDIAN\";\n+\t    break;\n+\n+\t  default:\n+\t    internal_error (&iqp->common, \"inquire_via_unit(): Bad convert\");\n+\t  }\n+\n+      cf_strcpy (iqp->convert, iqp->convert_len, p);\n+    }\n }\n \n "}, {"sha": "e36417100cd4da202a81a5b26107f1131d6037f9", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -206,6 +206,10 @@ typedef enum\n {READING, WRITING}\n unit_mode;\n \n+typedef enum\n+{ CONVERT_NATIVE, CONVERT_SWAP, CONVERT_BIG, CONVERT_LITTLE }\n+unit_convert;\n+\n #define CHARACTER1(name) \\\n \t      char * name; \\\n \t      gfc_charlen_type name ## _len\n@@ -247,6 +251,7 @@ st_parameter_common;\n #define IOPARM_OPEN_HAS_ACTION\t\t(1 << 14)\n #define IOPARM_OPEN_HAS_DELIM\t\t(1 << 15)\n #define IOPARM_OPEN_HAS_PAD\t\t(1 << 16)\n+#define IOPARM_OPEN_HAS_CONVERT\t\t(1 << 17)\n \n typedef struct\n {\n@@ -261,6 +266,7 @@ typedef struct\n   CHARACTER2 (action);\n   CHARACTER1 (delim);\n   CHARACTER2 (pad);\n+  CHARACTER1 (convert);\n }\n st_parameter_open;\n \n@@ -301,6 +307,7 @@ st_parameter_filepos;\n #define IOPARM_INQUIRE_HAS_READ\t\t(1 << 26)\n #define IOPARM_INQUIRE_HAS_WRITE\t(1 << 27)\n #define IOPARM_INQUIRE_HAS_READWRITE\t(1 << 28)\n+#define IOPARM_INQUIRE_HAS_CONVERT\t(1 << 29)\n \n typedef struct\n {\n@@ -323,6 +330,7 @@ typedef struct\n   CHARACTER2 (read);\n   CHARACTER1 (write);\n   CHARACTER2 (readwrite);\n+  CHARACTER1 (convert);\n }\n st_parameter_inquire;\n \n@@ -419,7 +427,7 @@ typedef struct st_parameter_dt\n \t     kind.  */\n \t  char value[32];\n \t} p;\n-      char pad[16 * sizeof (char *) + 32 * sizeof (int)];\n+      char pad[16 * sizeof (char *) + 34 * sizeof (int)];\n     } u;\n }\n st_parameter_dt;\n@@ -438,6 +446,7 @@ typedef struct\n   unit_position position;\n   unit_status status;\n   unit_pad pad;\n+  unit_convert convert;\n }\n unit_flags;\n \n@@ -738,6 +747,9 @@ internal_proto(init_loop_spec);\n extern void next_record (st_parameter_dt *, int);\n internal_proto(next_record);\n \n+extern void reverse_memcpy (void *, const void *, size_t);\n+internal_proto (reverse_memcpy);\n+\n /* read.c */\n \n extern void set_integer (void *, GFC_INTEGER_LARGEST, int);"}, {"sha": "3dc2b11955c3ea750f8eed8eda7621c038ddb407", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -98,6 +98,14 @@ static const st_option pad_opt[] =\n   { NULL, 0}\n };\n \n+static const st_option convert_opt[] =\n+{\n+  { \"native\", CONVERT_NATIVE},\n+  { \"swap\", CONVERT_SWAP},\n+  { \"big_endian\", CONVERT_BIG},\n+  { \"little_endian\", CONVERT_LITTLE},\n+  { NULL, 0}\n+};\n \n /* Given a unit, test to see if the file is positioned at the terminal\n    point, and if so, change state from NO_ENDFILE flag to AT_ENDFILE.\n@@ -531,6 +539,36 @@ st_open (st_parameter_open *opp)\n     find_option (&opp->common, opp->status, opp->status_len,\n \t\t status_opt, \"Bad STATUS parameter in OPEN statement\");\n \n+  if (cf & IOPARM_OPEN_HAS_CONVERT)\n+    {\n+      unit_convert conv;\n+      conv = find_option (&opp->common, opp->convert, opp->convert_len,\n+\t\t\t  convert_opt, \"Bad CONVERT parameter in OPEN statement\");\n+      /* We use l8_to_l4_offset, which is 0 on little-endian machines\n+ \t and 1 on big-endian machines.  */\n+      switch (conv)\n+ \t{\n+ \tcase CONVERT_NATIVE:\n+ \tcase CONVERT_SWAP:\n+ \t  break;\n+\t  \n+ \tcase CONVERT_BIG:\n+ \t  conv = l8_to_l4_offset ? CONVERT_NATIVE : CONVERT_SWAP;\n+ \t  break;\n+\t  \n+ \tcase CONVERT_LITTLE:\n+ \t  conv = l8_to_l4_offset ? CONVERT_SWAP : CONVERT_NATIVE;\n+ \t  break;\n+ \n+ \tdefault:\n+ \t  internal_error (&opp->common,\t\"Illegal value for CONVERT\");\n+ \t  break;\n+ \t}\n+      flags.convert = conv;\n+    }\n+  else\n+    flags.convert = CONVERT_NATIVE;\n+\n   if (opp->common.unit < 0)\n     generate_error (&opp->common, ERROR_BAD_OPTION,\n \t\t    \"Bad unit number in OPEN statement\");"}, {"sha": "f3ca8dfb039ba35449abe8394bcdccc74799783c", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 106, "deletions": 12, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=181c9f4a9ba6b2d64c7c0b56b777ad366e05a9c1", "patch": "@@ -399,26 +399,89 @@ write_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n /* Master function for unformatted reads.  */\n \n static void\n-unformatted_read (st_parameter_dt *dtp, bt type __attribute__((unused)),\n-\t\t  void *dest, int kind __attribute__((unused)),\n+unformatted_read (st_parameter_dt *dtp, bt type,\n+\t\t  void *dest, int kind,\n \t\t  size_t size, size_t nelems)\n {\n-  size *= nelems;\n-\n-  read_block_direct (dtp, dest, &size);\n+  /* Currently, character implies size=1.  */\n+  if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE\n+      || size == 1 || type == BT_CHARACTER)\n+    {\n+      size *= nelems;\n+      read_block_direct (dtp, dest, &size);\n+    }\n+  else\n+    {\n+      char buffer[16];\n+      char *p;\n+      size_t i, sz;\n+      \n+      /* Break up complex into its constituent reals.  */\n+      if (type == BT_COMPLEX)\n+\t{\n+\t  nelems *= 2;\n+\t  size /= 2;\n+\t}\n+      p = dest;\n+      \n+      /* By now, all complex variables have been split into their\n+\t constituent reals.  For types with padding, we only need to\n+\t read kind bytes.  We don't care about the contents\n+\t of the padding.  */\n+      \n+      sz = kind;\n+      for (i=0; i<nelems; i++)\n+\t{\n+ \t  read_block_direct (dtp, buffer, &sz);\n+ \t  reverse_memcpy (p, buffer, sz);\n+ \t  p += size;\n+ \t}\n+    }\n }\n \n \n /* Master function for unformatted writes.  */\n \n static void\n-unformatted_write (st_parameter_dt *dtp, bt type __attribute__((unused)),\n-\t\t   void *source, int kind __attribute__((unused)),\n+unformatted_write (st_parameter_dt *dtp, bt type,\n+\t\t   void *source, int kind,\n \t\t   size_t size, size_t nelems)\n {\n-  size *= nelems;\n+  if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE ||\n+      size == 1 || type == BT_CHARACTER)\n+    {\n+      size *= nelems;\n+\n+      write_block_direct (dtp, source, &size);\n+    }\n+  else\n+    {\n+      char buffer[16];\n+      char *p;\n+      size_t i, sz;\n+  \n+      /* Break up complex into its constituent reals.  */\n+      if (type == BT_COMPLEX)\n+\t{\n+\t  nelems *= 2;\n+\t  size /= 2;\n+\t}      \n+\n+      p = source;\n \n-  write_block_direct (dtp, source, &size);\n+      /* By now, all complex variables have been split into their\n+\t constituent reals.  For types with padding, we only need to\n+\t read kind bytes.  We don't care about the contents\n+\t of the padding.  */\n+\n+      sz = kind;\n+      for (i=0; i<nelems; i++)\n+\t{\n+\t  reverse_memcpy(buffer, p, size);\n+ \t  p+= size;\n+\t  write_block_direct (dtp, buffer, &sz);\n+\t}\n+    }\n }\n \n \n@@ -1154,7 +1217,12 @@ us_read (st_parameter_dt *dtp)\n       return;\n     }\n \n-  memcpy (&i, p, sizeof (gfc_offset));\n+  /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n+  if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n+    memcpy (&i, p, sizeof (gfc_offset));\n+  else\n+    reverse_memcpy (&i, p, sizeof (gfc_offset));\n+    \n   dtp->u.p.current_unit->bytes_left = i;\n }\n \n@@ -1722,7 +1790,12 @@ next_record_w (st_parameter_dt *dtp)\n       if (p == NULL)\n \tgoto io_error;\n \n-      memcpy (p, &m, sizeof (gfc_offset));\n+      /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n+      if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n+\tmemcpy (p, &m, sizeof (gfc_offset));\n+      else\n+\treverse_memcpy (p, &m, sizeof (gfc_offset));\n+      \n       if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n \tgoto io_error;\n \n@@ -1733,7 +1806,12 @@ next_record_w (st_parameter_dt *dtp)\n       if (p == NULL)\n \tgenerate_error (&dtp->common, ERROR_OS, NULL);\n \n-      memcpy (p, &m, sizeof (gfc_offset));\n+      /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n+      if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n+\tmemcpy (p, &m, sizeof (gfc_offset));\n+      else\n+\treverse_memcpy (p, &m, sizeof (gfc_offset));\n+\t\n       if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n \tgoto io_error;\n \n@@ -2161,3 +2239,19 @@ st_set_nml_var_dim (st_parameter_dt *dtp, GFC_INTEGER_4 n_dim,\n   nml->dim[n].lbound = (ssize_t)lbound;\n   nml->dim[n].ubound = (ssize_t)ubound;\n }\n+\n+/* Reverse memcpy - used for byte swapping.  */\n+\n+void reverse_memcpy (void *dest, const void *src, size_t n)\n+{\n+  char *d, *s;\n+  size_t i;\n+\n+  d = (char *) dest;\n+  s = (char *) src + n - 1;\n+\n+  /* Write with ascending order - this is likely faster\n+     on modern architectures because of write combining.  */\n+  for (i=0; i<n; i++)\n+      *(d++) = *(s--);\n+}"}]}