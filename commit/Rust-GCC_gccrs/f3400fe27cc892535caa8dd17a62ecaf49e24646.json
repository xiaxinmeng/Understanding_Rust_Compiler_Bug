{"sha": "f3400fe27cc892535caa8dd17a62ecaf49e24646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM0MDBmZTI3Y2M4OTI1MzVjYWE4ZGQxN2E2MmVjYWY0OWUyNDY0Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-12-04T11:14:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-12-04T11:14:21Z"}, "message": "pt.c (check_template_shadow): New fn.\n\n\t* pt.c (check_template_shadow): New fn.\n\t* decl2.c (grokfield): Use it.\n\t* decl.c (pushdecl): Likewise.\n\t(pushdecl_class_level): Likewise.\n\t(start_method): Likewise.\n\t(xref_tag): Don't try to use 't' if we're defining.\nFixes Sec14/7/C14387.cm.\n\t* call.c (check_dtor_name): Just return an error_mark_node.\n\t* pt.c (lookup_template_class): Complain about using non-template here.\n\t* parse.y (apparent_template_type): Not here.\nFixes Sec14/C14339.cm.\n\t* pt.c (check_explicit_specialization): Complain about specialization\n\twith C linkage.\nFixes Sec14/C14340.cm.\n\t* lang-options.h: Add -f{no-,}implicit-inline-templates.\n\t* pt.c (convert_nontype_argument): Don't assume that any integer\n\targument is intended to be a constant-expression.\nFixes Sec14/7/P14245.C.\n\nFrom-SVN: r24086", "tree": {"sha": "deef17e4d8047bf5208c860b90ec9e7d611781e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deef17e4d8047bf5208c860b90ec9e7d611781e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3400fe27cc892535caa8dd17a62ecaf49e24646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3400fe27cc892535caa8dd17a62ecaf49e24646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3400fe27cc892535caa8dd17a62ecaf49e24646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3400fe27cc892535caa8dd17a62ecaf49e24646/comments", "author": null, "committer": null, "parents": [{"sha": "2ec10ea98a951e150ac0a9e0a76bbdd5c0b3ce70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec10ea98a951e150ac0a9e0a76bbdd5c0b3ce70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec10ea98a951e150ac0a9e0a76bbdd5c0b3ce70"}], "stats": {"total": 1528, "additions": 772, "deletions": 756}, "files": [{"sha": "dce5cc60594aba154c378f0ff52e235af0abfcb5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646", "patch": "@@ -1,3 +1,24 @@\n+1998-12-04  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (check_template_shadow): New fn.\n+\t* decl2.c (grokfield): Use it.\n+\t* decl.c (pushdecl): Likewise.\n+\t(pushdecl_class_level): Likewise.\n+\t(start_method): Likewise.\n+\t(xref_tag): Don't try to use 't' if we're defining.\n+\n+\t* call.c (check_dtor_name): Just return an error_mark_node.\n+\t* pt.c (lookup_template_class): Complain about using non-template here.\n+\t* parse.y (apparent_template_type): Not here.\n+\n+\t* pt.c (check_explicit_specialization): Complain about specialization\n+\twith C linkage.\n+\n+\t* lang-options.h: Add -f{no-,}implicit-inline-templates.\n+\n+\t* pt.c (convert_nontype_argument): Don't assume that any integer\n+\targument is intended to be a constant-expression.\n+\n 1998-12-03  Mark Mitchell  <mark@markmitchell.com>\n \n \t* class.c (handle_using_decl): Fix comment.  Don't lookup\n@@ -1416,7 +1437,6 @@ Tue Oct  6 07:57:26 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \t* decl2.c (merge_functions): Remove duplicates.\n \n \t* decl2.c: Add -f{no-,}implicit-inline-templates.\n-\t(lang_decode_option): Unset it if -frepo.\n \t(import_export_decl): Check it.\n \n \t* decl.c (lookup_name_real): Template parms also take precedence"}, {"sha": "cfc94fa67f3c0e9779226c430438b93a55201986", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646", "patch": "@@ -347,6 +347,9 @@ check_dtor_name (basetype, name)\n {\n   name = TREE_OPERAND (name, 0);\n \n+  if (name == error_mark_node)\n+    return error_mark_node;\n+\n   if (TREE_CODE (name) == TYPE_DECL)\n     name = TREE_TYPE (name);\n   else if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')"}, {"sha": "81b835d83eff8f2aef88d2b3940041a8be2ec4d0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646", "patch": "@@ -3452,6 +3452,8 @@ pushdecl (x)\n \t    }\n \t}\n \n+      check_template_shadow (x);\n+\n       if (TREE_CODE (x) == FUNCTION_DECL && ! DECL_FUNCTION_MEMBER_P (x))\n \t{\n \t  t = push_overloaded_decl (x, 1);\n@@ -3671,16 +3673,6 @@ pushdecl (x)\n \t      if (warnstring)\n \t\twarning (warnstring, IDENTIFIER_POINTER (name));\n \t    }\n-\t  /* Check to see if decl redeclares a template parameter. */\n- \t  if (oldlocal && (current_class_type || current_function_decl) \n- \t      && current_template_parms)\n- \t    {\n- \t      if (decl_template_parm_p (oldlocal))\n- \t\t{\n-\t\t  cp_error (\"re-using name of template parameter `%T' in this scope\", name);\n- \t\t  cp_error_at (\" previously declared here `%#D'\", oldlocal);\n- \t\t}\n- \t    }\n \t}\n \n       if (TREE_CODE (x) == FUNCTION_DECL)\n@@ -3816,7 +3808,6 @@ pushdecl_class_level (x)\n \t     Types, enums, and static vars are checked here; other\n \t     members are checked in finish_struct.  */\n \t  tree icv = IDENTIFIER_CLASS_VALUE (name);\n-\t  tree ilv = IDENTIFIER_LOCAL_VALUE (name);\n \n \t  if (icv && icv != x\n \t      && flag_optional_diags\n@@ -3831,17 +3822,7 @@ pushdecl_class_level (x)\n \t\t\t     icv);\n \t    }\n \n-\t  /* Check to see if decl redeclares a template parameter. */\n-\t  if (ilv && ! decls_match (ilv, x)\n-\t      && (current_class_type || current_function_decl) \n-\t      && current_template_parms)\n-\t    {\n-\t      if (decl_template_parm_p (ilv))\n-\t\t{\n-\t\t  cp_error (\"re-using name of template parameter `%T' in this scope\", name);\n-\t\t  cp_error_at (\" previously declared here `%#D'\", ilv);\n-\t\t}\n-\t    }\n+\t  check_template_shadow (x);\n \t}\n \n       push_class_level_binding (name, x);\n@@ -11842,19 +11823,9 @@ xref_tag (code_type_node, name, globalize)\n \n   if (! globalize)\n     {\n-      if (t && (TREE_CODE (t) == TEMPLATE_TYPE_PARM \n-\t\t\t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM))\n-\t{\n-\t  cp_error (\"redeclaration of template type-parameter `%T'\", name);\n-\t  cp_error_at (\"  previously declared here `%#D'\", \n-\t\t       TEMPLATE_TYPE_DECL (t));\n-\t}\n-      if (t && TYPE_CONTEXT (t) && got_type)\n-\tref = t;\n-      else\n-\t/* If we know we are defining this tag, only look it up in\n-\t   this scope and don't try to find it as a type.  */\n-\tref = lookup_tag (code, name, b, 1);\n+      /* If we know we are defining this tag, only look it up in\n+\t this scope and don't try to find it as a type.  */\n+      ref = lookup_tag (code, name, b, 1);\n     }\n   else\n     {\n@@ -13784,6 +13755,8 @@ start_method (declspecs, declarator, attrlist)\n       return void_type_node;\n     }\n \n+  check_template_shadow (fndecl);\n+\n   DECL_THIS_INLINE (fndecl) = 1;\n \n   if (flag_default_inline)"}, {"sha": "3bcc08dc9f94c613a9b8b10268be84f2f945fdca", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646", "patch": "@@ -1642,18 +1642,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))\n     value = push_template_decl (value);\n \n-  /* Check to see if a field redeclares a template parameter. */\n-  if (current_template_parms \n-      && TREE_CODE (declarator) == IDENTIFIER_NODE\n-      && IDENTIFIER_LOCAL_VALUE (declarator))\n-      {\n-\ttree olddecl = IDENTIFIER_LOCAL_VALUE (declarator);\n-\tif (decl_template_parm_p (olddecl))\n-\t  {\n-\t    cp_error (\"redeclaration of template parameter `%T'\", declarator);\n-\t    cp_error_at (\" previously declared here `%#D'\", olddecl);\n-\t  }\n-      }\n+  check_template_shadow (value);\n \n   if (attrlist)\n     cplus_decl_attributes (value, TREE_PURPOSE (attrlist),"}, {"sha": "c3ec3b52fa7c35aa8a48f6cc450be38dd48f9456", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646", "patch": "@@ -1849,7 +1849,8 @@ cp_line_of (t)\n   int line = 0;\n   if (TREE_CODE (t) == PARM_DECL && DECL_CONTEXT (t))\n     line = DECL_SOURCE_LINE (DECL_CONTEXT (t));\n-  if (TREE_CODE (t) == TYPE_DECL && DECL_ARTIFICIAL (t))\n+  if (TREE_CODE (t) == TYPE_DECL && DECL_ARTIFICIAL (t)\n+      && TYPE_MAIN_DECL (TREE_TYPE (t)))\n     t = TREE_TYPE (t);\n \n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')"}, {"sha": "9f68bb81e9a6bdbc06473e9fbae4a69208f05924", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646", "patch": "@@ -63,8 +63,10 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-fno-huge-objects\", \"\" },\n   { \"-fimplement-inlines\", \"\" },\n   { \"-fno-implement-inlines\", \"Export functions even if they can be inlined\" },\n-  { \"-fimplicit-templates\", \"Emit implicit template instatiations when used\" },\n-  { \"-fno-implicit-templates\", \"\" },\n+  { \"-fimplicit-templates\", \"\" },\n+  { \"-fno-implicit-templates\", \"Only emit explicit template instatiations\" },\n+  { \"-fimplicit-inline-templates\", \"\" },\n+  { \"-fno-implicit-inline-templates\", \"Only emit explicit instatiations of inline templates\" },\n   { \"-finit-priority\", \"Handle the init_priority attribute\" },\n   { \"-fno-init-priority\", \"\" },\n   { \"-flabels-ok\", \"Labels can be used as first class objects\" },"}, {"sha": "9da858962ebb8f2d928bd647a418e413dd913eaa", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 660, "deletions": 663, "changes": 1323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646"}, {"sha": "87ac736ea1ebcc711b37ba9478874ce0d599c94f", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646", "patch": "@@ -913,10 +913,7 @@ apparent_template_type:\n \t  template_type\n \t| identifier '<' template_arg_list_opt '>'\n \t    .finish_template_type\n-\t\t{\n-\t\t  cp_error (\"template class %T was not declared yet\", $1);\n-\t\t  $$ = $5;\n-\t\t}\n+\t\t{ $$ = $5; }\n \n self_template_type:\n \t  SELFNAME  '<' template_arg_list_opt template_close_bracket"}, {"sha": "001b82a0f19ea16029e0169c4a3c288c086e0907", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 72, "deletions": 38, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3400fe27cc892535caa8dd17a62ecaf49e24646/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f3400fe27cc892535caa8dd17a62ecaf49e24646", "patch": "@@ -1206,6 +1206,8 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      (\"default argument specified in explicit specialization\");\n \t    break;\n \t  }\n+      if (current_lang_name == lang_name_c)\n+\tcp_error (\"template specialization with C linkage\");\n     }\n \n   if (specialization || member_specialization || explicit_instantiation)\n@@ -1513,8 +1515,33 @@ int decl_template_parm_p (old_decl)\n   return 0;\n }\n \n+/* Complain if DECL shadows a template parameter.\n+\n+   [temp.local]: A template-parameter shall not be redeclared within its\n+   scope (including nested scopes).  */\n+\n+void\n+check_template_shadow (decl)\n+     tree decl;\n+{\n+  if (current_template_parms \n+      && IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)))\n+    {\n+      tree olddecl = IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl));\n+\n+      /* We check for decl != olddecl to avoid bogus errors for using a\n+\t name inside a class.  We check TPFI to avoid duplicate errors for\n+\t inline member templates.  */\n+      if (decl != olddecl && decl_template_parm_p (olddecl)\n+\t  && ! TEMPLATE_PARMS_FOR_INLINE (current_template_parms))\n+\t{\n+\t  cp_error_at (\"declaration of `%#D'\", decl);\n+\t  cp_error_at (\" shadows template parm `%#D'\", olddecl);\n+\t}\n+    }\n+}\n \n- /* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,\n+/* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,\n    ORIG_LEVEL, DECL, and TYPE.  */\n \n static tree\n@@ -2471,22 +2498,9 @@ convert_nontype_argument (type, expr)\n        Check this first since if expr_type is the unknown_type_node\n        we would otherwise complain below.  */\n     ;\n-  else if (INTEGRAL_TYPE_P (expr_type) \n-\t   || TYPE_PTRMEM_P (expr_type) \n-\t   || TYPE_PTRMEMFUNC_P (expr_type)\n-\t   /* The next two are g++ extensions.  */\n-\t   || TREE_CODE (expr_type) == REAL_TYPE\n-\t   || TREE_CODE (expr_type) == COMPLEX_TYPE)\n-    {\n-      if (! TREE_CONSTANT (expr))\n-\t{\n-\tnon_constant:\n-\t  cp_error (\"non-constant `%E' cannot be used as template argument\",\n-\t\t    expr);\n-\t  return NULL_TREE;\n-\t}\n-    }\n-  else if (TYPE_PTR_P (expr_type) \n+  else if (TYPE_PTR_P (expr_type)\n+\t   || TREE_CODE (expr_type) == ARRAY_TYPE\n+\t   || TREE_CODE (type) == REFERENCE_TYPE\n \t   /* If expr is the address of an overloaded function, we\n \t      will get the unknown_type_node at this point.  */\n \t   || expr_type == unknown_type_node)\n@@ -2495,21 +2509,27 @@ convert_nontype_argument (type, expr)\n       tree e = expr;\n       STRIP_NOPS (e);\n \n-      if (TREE_CODE (e) != ADDR_EXPR)\n+      if (TREE_CODE (type) == REFERENCE_TYPE\n+\t  || TREE_CODE (expr_type) == ARRAY_TYPE)\n+\treferent = e;\n+      else\n \t{\n-\tbad_argument:\n-\t  cp_error (\"`%E' is not a valid template argument\", expr);\n-\t  error (\"it must be %s%s with external linkage\",\n-\t\t TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n-\t\t ? \"a pointer to \" : \"\",\n-\t\t TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == FUNCTION_TYPE\n-\t\t ? \"a function\" : \"an object\");\n-\t  return NULL_TREE;\n+\t  if (TREE_CODE (e) != ADDR_EXPR)\n+\t    {\n+\t    bad_argument:\n+\t      cp_error (\"`%E' is not a valid template argument\", expr);\n+\t      error (\"it must be %s%s with external linkage\",\n+\t\t     TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n+\t\t     ? \"a pointer to \" : \"\",\n+\t\t     TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == FUNCTION_TYPE\n+\t\t     ? \"a function\" : \"an object\");\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  referent = TREE_OPERAND (e, 0);\n+\t  STRIP_NOPS (referent);\n \t}\n \n-      referent = TREE_OPERAND (e, 0);\n-      STRIP_NOPS (referent);\n-      \n       if (TREE_CODE (referent) == STRING_CST)\n \t{\n \t  cp_error (\"string literal %E is not a valid template argument\", \n@@ -2529,10 +2549,20 @@ convert_nontype_argument (type, expr)\n \t  return error_mark_node;\n \t}\n     }\n-  else if (TREE_CODE (expr) == VAR_DECL)\n+  else if (INTEGRAL_TYPE_P (expr_type) \n+\t   || TYPE_PTRMEM_P (expr_type) \n+\t   || TYPE_PTRMEMFUNC_P (expr_type)\n+\t   /* The next two are g++ extensions.  */\n+\t   || TREE_CODE (expr_type) == REAL_TYPE\n+\t   || TREE_CODE (expr_type) == COMPLEX_TYPE)\n     {\n-      if (!TREE_PUBLIC (expr))\n-\tgoto bad_argument;\n+      if (! TREE_CONSTANT (expr))\n+\t{\n+\tnon_constant:\n+\t  cp_error (\"non-constant `%E' cannot be used as template argument\",\n+\t\t    expr);\n+\t  return NULL_TREE;\n+\t}\n     }\n   else \n     {\n@@ -2556,7 +2586,7 @@ convert_nontype_argument (type, expr)\n       expr = digest_init (type, expr, (tree*) 0);\n \n       if (TREE_CODE (expr) != INTEGER_CST)\n-\t/* Curiously, some TREE_CONSTNAT integral expressions do not\n+\t/* Curiously, some TREE_CONSTANT integral expressions do not\n \t   simplify to integer constants.  For example, `3 % 0',\n \t   remains a TRUNC_MOD_EXPR.  */\n \tgoto non_constant;\n@@ -3415,10 +3445,11 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n     }\n   else if (TREE_CODE (d1) == TYPE_DECL && IS_AGGR_TYPE (TREE_TYPE (d1)))\n     {\n-      if (CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (d1)) == NULL_TREE)\n-\treturn error_mark_node;\n-      template = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (d1));\n-      d1 = DECL_NAME (template);\n+      if (CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (d1)))\n+\t{\n+\t  template = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (d1));\n+\t  d1 = DECL_NAME (template);\n+\t}\n     }\n   else if (TREE_CODE (d1) == ENUMERAL_TYPE \n \t   || (TREE_CODE_CLASS (TREE_CODE (d1)) == 't' \n@@ -3442,7 +3473,10 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n      We don't want to do that, but we have to deal with the situation, so\n      let's give them some syntax errors to chew on instead of a crash.  */\n   if (! template)\n-    return error_mark_node;\n+    {\n+      cp_error (\"`%T' is not a template\", d1);\n+      return error_mark_node;\n+    }\n \n   if (context == NULL_TREE)\n     context = global_namespace;"}]}