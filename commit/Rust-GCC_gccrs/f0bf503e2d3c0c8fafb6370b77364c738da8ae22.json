{"sha": "f0bf503e2d3c0c8fafb6370b77364c738da8ae22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBiZjUwM2UyZDNjMGM4ZmFmYjYzNzBiNzczNjRjNzM4ZGE4YWUyMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-12-22T23:05:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-12-22T23:05:57Z"}, "message": "trans.c (call_to_gnu): Make the temporary for non-addressable In parameters passed by reference.\n\n\t* trans.c (call_to_gnu): Make the temporary for non-addressable\n\tIn parameters passed by reference.\n\t(addressable_p): Return true for STRING_CST and CALL_EXPR.\n\nFrom-SVN: r131140", "tree": {"sha": "949d5662c2a5c86022ef6cfdf5e6098a4440a8a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/949d5662c2a5c86022ef6cfdf5e6098a4440a8a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0bf503e2d3c0c8fafb6370b77364c738da8ae22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0bf503e2d3c0c8fafb6370b77364c738da8ae22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0bf503e2d3c0c8fafb6370b77364c738da8ae22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/comments", "author": null, "committer": null, "parents": [{"sha": "111716e0e166cbcec6880ec3266bbc335f96d2ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/111716e0e166cbcec6880ec3266bbc335f96d2ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/111716e0e166cbcec6880ec3266bbc335f96d2ca"}], "stats": {"total": 190, "additions": 102, "deletions": 88}, "files": [{"sha": "3f9956628bd1517cdd1c913c9cbe3cde0e54a88f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f0bf503e2d3c0c8fafb6370b77364c738da8ae22", "patch": "@@ -1,3 +1,9 @@\n+2007-12-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* trans.c (call_to_gnu): Make the temporary for non-addressable\n+\tIn parameters passed by reference.\n+\t(addressable_p): Return true for STRING_CST and CALL_EXPR.\n+\n 2007-12-19  Robert Dewar  <dewar@adacore.com>\n \n \t* g-expect-vms.adb, g-expect.adb, s-poosiz.adb: "}, {"sha": "aa4b28298a861f7144b174fbf48cde5a6924f950", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 70, "deletions": 88, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=f0bf503e2d3c0c8fafb6370b77364c738da8ae22", "patch": "@@ -2089,80 +2089,77 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       tree gnu_actual;\n \n       /* If it's possible we may need to use this expression twice, make sure\n-\t than any side-effects are handled via SAVE_EXPRs. Likewise if we need\n+\t that any side-effects are handled via SAVE_EXPRs.  Likewise if we need\n \t to force side-effects before the call.\n \n \t ??? This is more conservative than we need since we don't need to do\n-\t this for pass-by-ref with no conversion. If we are passing a\n-\t non-addressable Out or In Out parameter by reference, pass the address\n-\t of a copy and set up to copy back out after the call.  */\n+\t this for pass-by-ref with no conversion.  */\n       if (Ekind (gnat_formal) != E_In_Parameter)\n+\tgnu_name = gnat_stabilize_reference (gnu_name, true);\n+\n+      /* If we are passing a non-addressable parameter by reference, pass the\n+\t address of a copy.  In the Out or In Out case, set up to copy back\n+\t out after the call.  */\n+      if (!addressable_p (gnu_name)\n+\t  && gnu_formal\n+\t  && (DECL_BY_REF_P (gnu_formal)\n+\t      || (TREE_CODE (gnu_formal) == PARM_DECL\n+\t\t  && (DECL_BY_COMPONENT_PTR_P (gnu_formal)\n+\t\t      || (DECL_BY_DESCRIPTOR_P (gnu_formal))))))\n \t{\n-\t  gnu_name = gnat_stabilize_reference (gnu_name, true);\n-\n-\t  if (!addressable_p (gnu_name)\n-\t      && gnu_formal\n-\t      && (DECL_BY_REF_P (gnu_formal)\n-\t\t  || (TREE_CODE (gnu_formal) == PARM_DECL\n-\t\t      && (DECL_BY_COMPONENT_PTR_P (gnu_formal)\n-\t\t\t  || (DECL_BY_DESCRIPTOR_P (gnu_formal))))))\n-\t    {\n-\t      tree gnu_copy = gnu_name;\n-\t      tree gnu_temp;\n-\n-\t      /* If the type is by_reference, a copy is not allowed.  */\n-\t      if (Is_By_Reference_Type (Etype (gnat_formal)))\n-\t\tpost_error\n-\t\t  (\"misaligned & cannot be passed by reference\", gnat_actual);\n-\n-\t      /* For users of Starlet we issue a warning because the\n-\t\t interface apparently assumes that by-ref parameters\n-\t\t outlive the procedure invocation.  The code still\n-\t\t will not work as intended, but we cannot do much\n-\t\t better since other low-level parts of the back-end\n-\t\t would allocate temporaries at will because of the\n-\t\t misalignment if we did not do so here.  */\n+\t  tree gnu_copy = gnu_name, gnu_temp;\n \n-\t      else if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n-\t\t{\n-\t\t  post_error\n-\t\t    (\"?possible violation of implicit assumption\",\n-\t\t     gnat_actual);\n-\t\t  post_error_ne\n-\t\t    (\"?made by pragma Import_Valued_Procedure on &\",\n-\t\t     gnat_actual, Entity (Name (gnat_node)));\n-\t\t  post_error_ne\n-\t\t    (\"?because of misalignment of &\",\n-\t\t     gnat_actual, gnat_formal);\n-\t\t}\n+\t  /* If the type is by_reference, a copy is not allowed.  */\n+\t  if (Is_By_Reference_Type (Etype (gnat_formal)))\n+\t    post_error\n+\t      (\"misaligned & cannot be passed by reference\", gnat_actual);\n+\n+\t  /* For users of Starlet we issue a warning because the\n+\t     interface apparently assumes that by-ref parameters\n+\t     outlive the procedure invocation.  The code still\n+\t     will not work as intended, but we cannot do much\n+\t     better since other low-level parts of the back-end\n+\t     would allocate temporaries at will because of the\n+\t     misalignment if we did not do so here.  */\n+\t  else if (Is_Valued_Procedure (Entity (Name (gnat_node))))\n+\t    {\n+\t      post_error\n+\t\t(\"?possible violation of implicit assumption\", gnat_actual);\n+\t      post_error_ne\n+\t\t(\"?made by pragma Import_Valued_Procedure on &\", gnat_actual,\n+\t\t Entity (Name (gnat_node)));\n+\t      post_error_ne (\"?because of misalignment of &\", gnat_actual,\n+\t\t\t     gnat_formal);\n+\t    }\n \n-\t      /* Remove any unpadding on the actual and make a copy.  But if\n-\t\t the actual is a justified modular type, first convert\n-\t\t to it.  */\n-\t      if (TREE_CODE (gnu_name) == COMPONENT_REF\n-\t\t  && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_name, 0)))\n-\t\t       == RECORD_TYPE)\n-\t\t      && (TYPE_IS_PADDING_P\n-\t\t\t  (TREE_TYPE (TREE_OPERAND (gnu_name, 0))))))\n-\t\tgnu_name = gnu_copy = TREE_OPERAND (gnu_name, 0);\n-\t      else if (TREE_CODE (gnu_name_type) == RECORD_TYPE\n-\t\t       && (TYPE_JUSTIFIED_MODULAR_P (gnu_name_type)))\n-\t\tgnu_name = convert (gnu_name_type, gnu_name);\n-\n-\t      /* Make a SAVE_EXPR to both properly account for potential side\n-\t\t effects and handle the creation of a temporary copy.  Special\n-\t\t code in gnat_gimplify_expr ensures that the same temporary is\n-\t\t used as the actual and copied back after the call.  */\n-\t      gnu_actual = save_expr (gnu_name);\n-\n-\t      /* Set up to move the copy back to the original.  */\n-\t      gnu_temp = build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t  gnu_copy, gnu_actual);\n+\t  /* Remove any unpadding on the actual and make a copy.  But if\n+\t     the actual is a justified modular type, first convert to it.  */\n+\t  if (TREE_CODE (gnu_name) == COMPONENT_REF\n+\t      && ((TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_name, 0)))\n+\t\t   == RECORD_TYPE)\n+\t\t  && (TYPE_IS_PADDING_P\n+\t\t      (TREE_TYPE (TREE_OPERAND (gnu_name, 0))))))\n+\t    gnu_name = gnu_copy = TREE_OPERAND (gnu_name, 0);\n+\n+\t  else if (TREE_CODE (gnu_name_type) == RECORD_TYPE\n+\t\t   && (TYPE_JUSTIFIED_MODULAR_P (gnu_name_type)))\n+\t    gnu_name = convert (gnu_name_type, gnu_name);\n+\n+\t  /* Make a SAVE_EXPR to both properly account for potential side\n+\t     effects and handle the creation of a temporary copy.  Special\n+\t     code in gnat_gimplify_expr ensures that the same temporary is\n+\t     used as the actual and copied back after the call if needed.  */\n+\t  gnu_name = build1 (SAVE_EXPR, TREE_TYPE (gnu_name), gnu_name);\n+\t  TREE_SIDE_EFFECTS (gnu_name) = 1;\n+\t  TREE_INVARIANT (gnu_name) = 1;\n+\n+\t  /* Set up to move the copy back to the original.  */\n+\t  if (Ekind (gnat_formal) != E_In_Parameter)\n+\t    {\n+\t      gnu_temp = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_copy,\n+\t\t\t\t\t  gnu_name);\n \t      set_expr_location_from_node (gnu_temp, gnat_actual);\n \t      append_to_statement_list (gnu_temp, &gnu_after_list);\n-\n-\t      /* Account for next statement just below.  */\n-\t      gnu_name = gnu_actual;\n \t    }\n \t}\n \n@@ -2222,7 +2219,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t copied in. Otherwise, look at the PARM_DECL to see if it is passed by\n \t reference. */\n       if (gnu_formal\n-\t  && TREE_CODE (gnu_formal) == PARM_DECL && DECL_BY_REF_P (gnu_formal))\n+\t  && TREE_CODE (gnu_formal) == PARM_DECL\n+\t  && DECL_BY_REF_P (gnu_formal))\n \t{\n \t  if (Ekind (gnat_formal) != E_In_Parameter)\n \t    {\n@@ -2250,32 +2248,13 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t      gnu_actual);\n \t    }\n \n-\t  /* Otherwise, if we have a non-addressable COMPONENT_REF of a\n-\t     variable-size type see if it's doing a unpadding operation.  If\n-\t     so, remove that operation since we have no way of allocating the\n-\t     required temporary.  */\n-\t  if (TREE_CODE (gnu_actual) == COMPONENT_REF\n-\t      && !TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_actual)))\n-\t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_actual, 0)))\n-\t\t  == RECORD_TYPE)\n-\t      && TYPE_IS_PADDING_P (TREE_TYPE\n-\t\t\t\t    (TREE_OPERAND (gnu_actual, 0)))\n-\t      && !addressable_p (gnu_actual))\n-\t    gnu_actual = TREE_OPERAND (gnu_actual, 0);\n-\n-\t  /* For In parameters, gnu_actual might still not be addressable at\n-\t     this point and we need the creation of a temporary copy since\n-\t     this is to be passed by ref.  Resorting to save_expr to force a\n-\t     SAVE_EXPR temporary creation here is not guaranteed to work\n-\t     because the actual might be invariant or readonly without side\n-\t     effects, so we let the gimplifier process this case.  */\n-\n \t  /* The symmetry of the paths to the type of an entity is broken here\n \t     since arguments don't know that they will be passed by ref. */\n \t  gnu_formal_type = TREE_TYPE (get_gnu_tree (gnat_formal));\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n-      else if (gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL\n+      else if (gnu_formal\n+\t       && TREE_CODE (gnu_formal) == PARM_DECL\n \t       && DECL_BY_COMPONENT_PTR_P (gnu_formal))\n \t{\n \t  gnu_formal_type = TREE_TYPE (get_gnu_tree (gnat_formal));\n@@ -2299,7 +2278,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\tbuild_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t\tgnu_actual));\n \t}\n-      else if (gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL\n+      else if (gnu_formal\n+\t       && TREE_CODE (gnu_formal) == PARM_DECL\n \t       && DECL_BY_DESCRIPTOR_P (gnu_formal))\n \t{\n \t  /* If arg is 'Null_Parameter, pass zero descriptor.  */\n@@ -6077,8 +6057,10 @@ addressable_p (tree gnu_expr)\n     case UNCONSTRAINED_ARRAY_REF:\n     case INDIRECT_REF:\n     case CONSTRUCTOR:\n+    case STRING_CST:\n     case NULL_EXPR:\n     case SAVE_EXPR:\n+    case CALL_EXPR:\n       return true;\n \n     case COMPONENT_REF:"}, {"sha": "008192e155ecc65b64bd2845b16c76896a78bb8e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f0bf503e2d3c0c8fafb6370b77364c738da8ae22", "patch": "@@ -1,3 +1,7 @@\n+2007-12-23  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/pack2.adb: New test.\n+\n 2007-12-22  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/34559"}, {"sha": "7837c8ad8bdcb50ca9dbd3d40358679f880bff27", "filename": "gcc/testsuite/gnat.dg/pack2.adb", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/gcc%2Ftestsuite%2Fgnat.dg%2Fpack2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0bf503e2d3c0c8fafb6370b77364c738da8ae22/gcc%2Ftestsuite%2Fgnat.dg%2Fpack2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fpack2.adb?ref=f0bf503e2d3c0c8fafb6370b77364c738da8ae22", "patch": "@@ -0,0 +1,22 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+\n+procedure Pack2 is\n+\n+   type Bits_T is record\n+      B0, B1, B2: Boolean;\n+   end record;\n+\n+   type State_T is record\n+      Valid : Boolean;\n+      Value : Bits_T;\n+   end record;\n+   pragma Pack (State_T);\n+      \n+   procedure Process (Bits : Bits_T) is begin null; end;\n+   \n+   State : State_T;\n+\n+begin\n+   Process (State.Value);\n+end;"}]}