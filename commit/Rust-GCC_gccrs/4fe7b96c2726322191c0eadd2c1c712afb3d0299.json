{"sha": "4fe7b96c2726322191c0eadd2c1c712afb3d0299", "node_id": "C_kwDOANBUbNoAKDRmZTdiOTZjMjcyNjMyMjE5MWMwZWFkZDJjMWM3MTJhZmIzZDAyOTk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-07-21T11:07:51Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:25Z"}, "message": "Const functions need to be marked as DECL_DECLARED_CONSTEXPR_P\n\nThis signifys in the GCC generic that this is a constant function and\nshould be foldable in the constexpr evaluation. This also ports over the\ncorrect eval_store_expression which updates the context tables.\n\nCPP consteval seems pretty powerful but overall the algorithm is fairly\nsimple at least for simple types. When we encounter a CALL_EXPR we must\n\"bind\" the arguments. So when we encourter a PARAM_DECL the associated\nargument for this parameter is bound to this parameter in a map of\nmap<tree, tree> using their pointer as the key to value. So when folding\na function body every usage of the parameter decl is then updated in the\ncontext with the apropriate value fomr the context. When we hit\nassignment operations a similar context store occurs for VAR_DECLS.\n\nWhile walking the tree We finally hit the RESULT_DECL with the folded\nresult. The complex pieces remaining are aggregate, record and union types\nso that we have zero allocation required to find the result. We also need\nto support walking conditionals and loop expressions which require porting\na few more functions and using the jump_target tree.", "tree": {"sha": "117f357a9849069359e7bf8d0ffe4ce56bdd3d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/117f357a9849069359e7bf8d0ffe4ce56bdd3d57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fe7b96c2726322191c0eadd2c1c712afb3d0299", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe7b96c2726322191c0eadd2c1c712afb3d0299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe7b96c2726322191c0eadd2c1c712afb3d0299", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe7b96c2726322191c0eadd2c1c712afb3d0299/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a9b94d8c3ac6c691fa49585756c0df234602d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9b94d8c3ac6c691fa49585756c0df234602d8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a9b94d8c3ac6c691fa49585756c0df234602d8b"}], "stats": {"total": 1424, "additions": 1392, "deletions": 32}, "files": [{"sha": "ab330c45668055ea901f8dccf16be5ee6ceaf8d4", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=4fe7b96c2726322191c0eadd2c1c712afb3d0299", "patch": "@@ -56,6 +56,7 @@ HIRCompileBase::setup_fndecl (tree fndecl, bool is_main_entry_point,\n     }\n \n   // is it a const fn\n+  DECL_DECLARED_CONSTEXPR_P (fndecl) = qualifiers.is_const ();\n   if (qualifiers.is_const ())\n     {\n       TREE_READONLY (fndecl) = 1;\n@@ -630,6 +631,11 @@ HIRCompileBase::compile_function (\n   ctx->pop_fn ();\n   ctx->push_function (fndecl);\n \n+  if (DECL_DECLARED_CONSTEXPR_P (fndecl))\n+    {\n+      maybe_save_constexpr_fundef (fndecl);\n+    }\n+\n   return fndecl;\n }\n "}, {"sha": "fef1de8dcf55c546974a16d6ad896ee071f96008", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 1321, "deletions": 8, "changes": 1329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=4fe7b96c2726322191c0eadd2c1c712afb3d0299", "patch": "@@ -28,6 +28,8 @@\n #include \"timevar.h\"\n #include \"varasm.h\"\n #include \"cgraph.h\"\n+#include \"tree-inline.h\"\n+#include \"vec.h\"\n \n #define VERIFY_CONSTANT(X)                                                     \\\n   do                                                                           \\\n@@ -40,6 +42,29 @@\n namespace Rust {\n namespace Compile {\n \n+/* Returns true iff FUN is an instantiation of a constexpr function\n+ template or a defaulted constexpr function.  */\n+\n+bool\n+is_instantiation_of_constexpr (tree fun)\n+{\n+  return DECL_DECLARED_CONSTEXPR_P (fun);\n+}\n+\n+/* Return true if T is a literal type.   */\n+\n+bool\n+literal_type_p (tree t)\n+{\n+  if (SCALAR_TYPE_P (t) || VECTOR_TYPE_P (t) || TYPE_REF_P (t)\n+      || (VOID_TYPE_P (t)))\n+    return true;\n+\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return literal_type_p (strip_array_types (t));\n+  return false;\n+}\n+\n static bool\n verify_constant (tree, bool, bool *, bool *);\n \n@@ -49,6 +74,12 @@ static int\n array_index_cmp (tree key, tree index);\n inline tree\n get_nth_callarg (tree t, int n);\n+tree\n+unshare_constructor (tree t MEM_STAT_DECL);\n+void\n+explain_invalid_constexpr_fn (tree fun);\n+void\n+maybe_save_constexpr_fundef (tree fun);\n \n struct constexpr_global_ctx\n {\n@@ -156,6 +187,268 @@ struct constexpr_ctx\n   bool manifestly_const_eval;\n };\n \n+struct constexpr_fundef_hasher : ggc_ptr_hash<constexpr_fundef>\n+{\n+  static hashval_t hash (const constexpr_fundef *);\n+  static bool equal (const constexpr_fundef *, const constexpr_fundef *);\n+};\n+\n+/* This table holds all constexpr function definitions seen in\n+   the current translation unit.  */\n+\n+static GTY (()) hash_table<constexpr_fundef_hasher> *constexpr_fundef_table;\n+\n+/* Utility function used for managing the constexpr function table.\n+   Return true if the entries pointed to by P and Q are for the\n+   same constexpr function.  */\n+\n+inline bool\n+constexpr_fundef_hasher::equal (const constexpr_fundef *lhs,\n+\t\t\t\tconst constexpr_fundef *rhs)\n+{\n+  return lhs->decl == rhs->decl;\n+}\n+\n+/* Utility function used for managing the constexpr function table.\n+   Return a hash value for the entry pointed to by Q.  */\n+\n+inline hashval_t\n+constexpr_fundef_hasher::hash (const constexpr_fundef *fundef)\n+{\n+  return DECL_UID (fundef->decl);\n+}\n+\n+/* Return a previously saved definition of function FUN.   */\n+\n+constexpr_fundef *\n+retrieve_constexpr_fundef (tree fun)\n+{\n+  if (constexpr_fundef_table == NULL)\n+    return NULL;\n+\n+  constexpr_fundef fundef = {fun, NULL_TREE, NULL_TREE, NULL_TREE};\n+  return constexpr_fundef_table->find (&fundef);\n+}\n+\n+/* This internal flag controls whether we should avoid doing anything during\n+   constexpr evaluation that would cause extra DECL_UID generation, such as\n+   template instantiation and function body copying.  */\n+\n+static bool uid_sensitive_constexpr_evaluation_value;\n+\n+/* An internal counter that keeps track of the number of times\n+   uid_sensitive_constexpr_evaluation_p returned true.  */\n+\n+static unsigned uid_sensitive_constexpr_evaluation_true_counter;\n+\n+/* The accessor for uid_sensitive_constexpr_evaluation_value which also\n+   increments the corresponding counter.  */\n+\n+static bool\n+uid_sensitive_constexpr_evaluation_p ()\n+{\n+  if (uid_sensitive_constexpr_evaluation_value)\n+    {\n+      ++uid_sensitive_constexpr_evaluation_true_counter;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* RAII sentinel that saves the value of a variable, optionally\n+   overrides it right away, and restores its value when the sentinel\n+   id destructed.  */\n+\n+template <typename T> class temp_override\n+{\n+  T &overridden_variable;\n+  T saved_value;\n+\n+public:\n+  temp_override (T &var) : overridden_variable (var), saved_value (var) {}\n+  temp_override (T &var, T overrider)\n+    : overridden_variable (var), saved_value (var)\n+  {\n+    overridden_variable = overrider;\n+  }\n+  ~temp_override () { overridden_variable = saved_value; }\n+};\n+\n+/* An RAII sentinel used to restrict constexpr evaluation so that it\n+   doesn't do anything that causes extra DECL_UID generation.  */\n+\n+struct uid_sensitive_constexpr_evaluation_sentinel\n+{\n+  temp_override<bool> ovr;\n+  uid_sensitive_constexpr_evaluation_sentinel ();\n+};\n+\n+/* Used to determine whether uid_sensitive_constexpr_evaluation_p was\n+   called and returned true, indicating that we've restricted constexpr\n+   evaluation in order to avoid UID generation.  We use this to control\n+   updates to the fold_cache and cv_cache.  */\n+\n+struct uid_sensitive_constexpr_evaluation_checker\n+{\n+  const unsigned saved_counter;\n+  uid_sensitive_constexpr_evaluation_checker ();\n+  bool evaluation_restricted_p () const;\n+};\n+\n+/* The default constructor for uid_sensitive_constexpr_evaluation_sentinel\n+   enables the internal flag for uid_sensitive_constexpr_evaluation_p\n+   during the lifetime of the sentinel object.  Upon its destruction, the\n+   previous value of uid_sensitive_constexpr_evaluation_p is restored.  */\n+\n+uid_sensitive_constexpr_evaluation_sentinel ::\n+  uid_sensitive_constexpr_evaluation_sentinel ()\n+  : ovr (uid_sensitive_constexpr_evaluation_value, true)\n+{}\n+\n+/* The default constructor for uid_sensitive_constexpr_evaluation_checker\n+   records the current number of times that uid_sensitive_constexpr_evaluation_p\n+   has been called and returned true.  */\n+\n+uid_sensitive_constexpr_evaluation_checker ::\n+  uid_sensitive_constexpr_evaluation_checker ()\n+  : saved_counter (uid_sensitive_constexpr_evaluation_true_counter)\n+{}\n+\n+/* Returns true iff uid_sensitive_constexpr_evaluation_p is true, and\n+   some constexpr evaluation was restricted due to u_s_c_e_p being called\n+   and returning true during the lifetime of this checker object.  */\n+\n+bool\n+uid_sensitive_constexpr_evaluation_checker::evaluation_restricted_p () const\n+{\n+  return (uid_sensitive_constexpr_evaluation_value\n+\t  && saved_counter != uid_sensitive_constexpr_evaluation_true_counter);\n+}\n+\n+/* A table of all constexpr calls that have been evaluated by the\n+   compiler in this translation unit.  */\n+\n+static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n+\n+static tree\n+cxx_eval_constant_expression (const constexpr_ctx *, tree, bool, bool *, bool *,\n+\t\t\t      tree * = NULL);\n+\n+/* Compute a hash value for a constexpr call representation.  */\n+\n+inline hashval_t\n+constexpr_call_hasher::hash (constexpr_call *info)\n+{\n+  return info->hash;\n+}\n+\n+/* Return true if the objects pointed to by P and Q represent calls\n+   to the same constexpr function with the same arguments.\n+   Otherwise, return false.  */\n+\n+bool\n+constexpr_call_hasher::equal (constexpr_call *lhs, constexpr_call *rhs)\n+{\n+  if (lhs == rhs)\n+    return true;\n+  if (lhs->hash != rhs->hash)\n+    return false;\n+  if (lhs->manifestly_const_eval != rhs->manifestly_const_eval)\n+    return false;\n+  if (!constexpr_fundef_hasher::equal (lhs->fundef, rhs->fundef))\n+    return false;\n+  return rs_tree_equal (lhs->bindings, rhs->bindings);\n+}\n+\n+/* Initialize the constexpr call table, if needed.  */\n+\n+static void\n+maybe_initialize_constexpr_call_table (void)\n+{\n+  if (constexpr_call_table == NULL)\n+    constexpr_call_table = hash_table<constexpr_call_hasher>::create_ggc (101);\n+}\n+\n+/* During constexpr CALL_EXPR evaluation, to avoid issues with sharing when\n+   a function happens to get called recursively, we unshare the callee\n+   function's body and evaluate this unshared copy instead of evaluating the\n+   original body.\n+\n+   FUNDEF_COPIES_TABLE is a per-function freelist of these unshared function\n+   copies.  The underlying data structure of FUNDEF_COPIES_TABLE is a hash_map\n+   that's keyed off of the original FUNCTION_DECL and whose value is a\n+   TREE_LIST of this function's unused copies awaiting reuse.\n+\n+   This is not GC-deletable to avoid GC affecting UID generation.  */\n+\n+static GTY (()) decl_tree_map *fundef_copies_table;\n+\n+/* Reuse a copy or create a new unshared copy of the function FUN.\n+   Return this copy.  We use a TREE_LIST whose PURPOSE is body, VALUE\n+   is parms, TYPE is result.  */\n+\n+static tree\n+get_fundef_copy (constexpr_fundef *fundef)\n+{\n+  tree copy;\n+  bool existed;\n+  tree *slot\n+    = &(hash_map_safe_get_or_insert<hm_ggc> (fundef_copies_table, fundef->decl,\n+\t\t\t\t\t     &existed, 127));\n+\n+  if (!existed)\n+    {\n+      /* There is no cached function available, or in use.  We can use\n+\t the function directly.  That the slot is now created records\n+\t that this function is now in use.  */\n+      copy = build_tree_list (fundef->body, fundef->parms);\n+      TREE_TYPE (copy) = fundef->result;\n+    }\n+  else if (*slot == NULL_TREE)\n+    {\n+      if (uid_sensitive_constexpr_evaluation_p ())\n+\treturn NULL_TREE;\n+\n+      /* We've already used the function itself, so make a copy.  */\n+      copy = build_tree_list (NULL, NULL);\n+      tree saved_body = DECL_SAVED_TREE (fundef->decl);\n+      tree saved_parms = DECL_ARGUMENTS (fundef->decl);\n+      tree saved_result = DECL_RESULT (fundef->decl);\n+      tree saved_fn = current_function_decl;\n+      DECL_SAVED_TREE (fundef->decl) = fundef->body;\n+      DECL_ARGUMENTS (fundef->decl) = fundef->parms;\n+      DECL_RESULT (fundef->decl) = fundef->result;\n+      current_function_decl = fundef->decl;\n+      TREE_PURPOSE (copy)\n+\t= copy_fn (fundef->decl, TREE_VALUE (copy), TREE_TYPE (copy));\n+      current_function_decl = saved_fn;\n+      DECL_RESULT (fundef->decl) = saved_result;\n+      DECL_ARGUMENTS (fundef->decl) = saved_parms;\n+      DECL_SAVED_TREE (fundef->decl) = saved_body;\n+    }\n+  else\n+    {\n+      /* We have a cached function available.  */\n+      copy = *slot;\n+      *slot = TREE_CHAIN (copy);\n+    }\n+\n+  return copy;\n+}\n+\n+/* Save the copy COPY of function FUN for later reuse by\n+   get_fundef_copy().  By construction, there will always be an entry\n+   to find.  */\n+\n+static void\n+save_fundef_copy (tree fun, tree copy)\n+{\n+  tree *slot = fundef_copies_table->get (fun);\n+  TREE_CHAIN (copy) = *slot;\n+  *slot = copy;\n+}\n+\n static tree\n constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p,\n \t\t  bool unshare_p);\n@@ -176,14 +469,58 @@ static tree\n eval_store_expression (const constexpr_ctx *ctx, tree r, bool, bool *, bool *);\n \n static tree\n-eval_call_expression (const constexpr_ctx *ctx, tree r);\n+eval_call_expression (const constexpr_ctx *ctx, tree r, bool, bool *, bool *);\n \n static tree\n eval_binary_expression (const constexpr_ctx *ctx, tree r, bool, bool *, bool *);\n \n static tree\n get_function_named_in_call (tree t);\n \n+static tree\n+eval_statement_list (const constexpr_ctx *ctx, tree t, bool *non_constant_p,\n+\t\t     bool *overflow_p, tree *jump_target);\n+static tree\n+extract_string_elt (tree string, unsigned chars_per_elt, unsigned index);\n+\n+/* Variables and functions to manage constexpr call expansion context.\n+   These do not need to be marked for PCH or GC.  */\n+\n+/* FIXME remember and print actual constant arguments.  */\n+static vec<tree> call_stack;\n+static int call_stack_tick;\n+static int last_cx_error_tick;\n+\n+static int\n+push_cx_call_context (tree call)\n+{\n+  ++call_stack_tick;\n+  if (!EXPR_HAS_LOCATION (call))\n+    SET_EXPR_LOCATION (call, input_location);\n+  call_stack.safe_push (call);\n+  int len = call_stack.length ();\n+  if (len > max_constexpr_depth)\n+    return false;\n+  return len;\n+}\n+\n+static void\n+pop_cx_call_context (void)\n+{\n+  ++call_stack_tick;\n+  call_stack.pop ();\n+}\n+\n+vec<tree>\n+cx_error_context (void)\n+{\n+  vec<tree> r = vNULL;\n+  if (call_stack_tick != last_cx_error_tick && !call_stack.is_empty ())\n+    r = call_stack;\n+  last_cx_error_tick = call_stack_tick;\n+  return r;\n+}\n+\n // this is ported from cxx_eval_outermost_constant_expr\n tree\n fold_expr (tree expr)\n@@ -262,6 +599,28 @@ constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       }\n       break;\n \n+    case PARM_DECL:\n+      if (lval && !TYPE_REF_P (TREE_TYPE (t)))\n+\t/* glvalue use.  */;\n+      else if (tree *p = ctx->global->values.get (r))\n+\tr = *p;\n+      else if (lval)\n+\t/* Defer in case this is only used for its type.  */;\n+      else if (COMPLETE_TYPE_P (TREE_TYPE (t))\n+\t       && is_really_empty_class (TREE_TYPE (t), /*ignore_vptr*/ false))\n+\t{\n+\t  /* If the class is empty, we aren't actually loading anything.  */\n+\t  r = build_constructor (TREE_TYPE (t), NULL);\n+\t  TREE_CONSTANT (r) = true;\n+\t}\n+      else\n+\t{\n+\t  if (!ctx->quiet)\n+\t    error (\"%qE is not a constant expression\", t);\n+\t  *non_constant_p = true;\n+\t}\n+      break;\n+\n     case POINTER_PLUS_EXPR:\n     case POINTER_DIFF_EXPR:\n     case PLUS_EXPR:\n@@ -307,7 +666,7 @@ constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       break;\n \n     case CALL_EXPR:\n-      r = eval_call_expression (ctx, t);\n+      r = eval_call_expression (ctx, t, false, non_constant_p, overflow_p);\n       break;\n \n     case RETURN_EXPR:\n@@ -320,17 +679,201 @@ constexpr_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       r = eval_store_expression (ctx, t, false, non_constant_p, overflow_p);\n       break;\n \n+    case STATEMENT_LIST:\n+      // new_ctx = *ctx;\n+      // new_ctx.ctor = new_ctx.object = NULL_TREE;\n+      return eval_statement_list (ctx, t, non_constant_p, overflow_p,\n+\t\t\t\t  jump_target);\n+\n+    case BIND_EXPR:\n+      return constexpr_expression (ctx, BIND_EXPR_BODY (t), lval,\n+\t\t\t\t   non_constant_p, overflow_p, jump_target);\n+\n+    case RESULT_DECL:\n+      if (lval)\n+\treturn t;\n+      /* We ask for an rvalue for the RESULT_DECL when indirecting\n+\t through an invisible reference, or in named return value\n+\t optimization.  */\n+      if (tree *p = ctx->global->values.get (t))\n+\treturn *p;\n+      else\n+\t{\n+\t  if (!ctx->quiet)\n+\t    error (\"%qE is not a constant expression\", t);\n+\t  *non_constant_p = true;\n+\t}\n+      break;\n+\n+    case SAVE_EXPR:\n+      /* Avoid evaluating a SAVE_EXPR more than once.  */\n+      if (tree *p = ctx->global->values.get (t))\n+\tr = *p;\n+      else\n+\t{\n+\t  r = constexpr_expression (ctx, TREE_OPERAND (t, 0), false,\n+\t\t\t\t    non_constant_p, overflow_p);\n+\t  if (*non_constant_p)\n+\t    break;\n+\t  ctx->global->values.put (t, r);\n+\t  if (ctx->save_exprs)\n+\t    ctx->save_exprs->safe_push (t);\n+\t}\n+      break;\n+\n     default:\n       break;\n     }\n \n   return r;\n }\n \n+/* Return a pointer to the constructor_elt of CTOR which matches INDEX.  If no\n+   matching constructor_elt exists, then add one to CTOR.\n+\n+   As an optimization, if POS_HINT is non-negative then it is used as a guess\n+   for the (integer) index of the matching constructor_elt within CTOR.  */\n+\n+static constructor_elt *\n+get_or_insert_ctor_field (tree ctor, tree index, int pos_hint = -1)\n+{\n+  /* Check the hint first.  */\n+  if (pos_hint >= 0 && (unsigned) pos_hint < CONSTRUCTOR_NELTS (ctor)\n+      && CONSTRUCTOR_ELT (ctor, pos_hint)->index == index)\n+    return CONSTRUCTOR_ELT (ctor, pos_hint);\n+\n+  tree type = TREE_TYPE (ctor);\n+  if (TREE_CODE (type) == VECTOR_TYPE && index == NULL_TREE)\n+    {\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (ctor), index, NULL_TREE);\n+      return &CONSTRUCTOR_ELTS (ctor)->last ();\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      if (TREE_CODE (index) == RANGE_EXPR)\n+\t{\n+\t  /* Support for RANGE_EXPR index lookups is currently limited to\n+\t     accessing an existing element via POS_HINT, or appending a new\n+\t     element to the end of CTOR.  ??? Support for other access\n+\t     patterns may also be needed.  */\n+\t  vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (ctor);\n+\t  if (vec_safe_length (elts))\n+\t    {\n+\t      tree lo = TREE_OPERAND (index, 0);\n+\t      gcc_assert (array_index_cmp (elts->last ().index, lo) < 0);\n+\t    }\n+\t  CONSTRUCTOR_APPEND_ELT (elts, index, NULL_TREE);\n+\t  return &elts->last ();\n+\t}\n+\n+      HOST_WIDE_INT i = find_array_ctor_elt (ctor, index, /*insert*/ true);\n+      gcc_assert (i >= 0);\n+      constructor_elt *cep = CONSTRUCTOR_ELT (ctor, i);\n+      gcc_assert (cep->index == NULL_TREE\n+\t\t  || TREE_CODE (cep->index) != RANGE_EXPR);\n+      return cep;\n+    }\n+  else\n+    {\n+      gcc_assert (\n+\tTREE_CODE (index) == FIELD_DECL\n+\t&& (same_type_ignoring_top_level_qualifiers_p (DECL_CONTEXT (index),\n+\t\t\t\t\t\t       TREE_TYPE (ctor))));\n+\n+      /* We must keep the CONSTRUCTOR's ELTS in FIELD order.\n+\t Usually we meet initializers in that order, but it is\n+\t possible for base types to be placed not in program\n+\t order.  */\n+      tree fields = TYPE_FIELDS (DECL_CONTEXT (index));\n+      unsigned HOST_WIDE_INT idx = 0;\n+      constructor_elt *cep = NULL;\n+\n+      /* Check if we're changing the active member of a union.  */\n+      if (TREE_CODE (type) == UNION_TYPE && CONSTRUCTOR_NELTS (ctor)\n+\t  && CONSTRUCTOR_ELT (ctor, 0)->index != index)\n+\tvec_safe_truncate (CONSTRUCTOR_ELTS (ctor), 0);\n+      /* If the bit offset of INDEX is larger than that of the last\n+\t constructor_elt, then we can just immediately append a new\n+\t constructor_elt to the end of CTOR.  */\n+      else if (CONSTRUCTOR_NELTS (ctor)\n+\t       && tree_int_cst_compare (\n+\t\t    bit_position (index),\n+\t\t    bit_position (CONSTRUCTOR_ELTS (ctor)->last ().index))\n+\t\t    > 0)\n+\t{\n+\t  idx = CONSTRUCTOR_NELTS (ctor);\n+\t  goto insert;\n+\t}\n+\n+      /* Otherwise, we need to iterate over CTOR to find or insert INDEX\n+\t appropriately.  */\n+\n+      for (; vec_safe_iterate (CONSTRUCTOR_ELTS (ctor), idx, &cep);\n+\t   idx++, fields = DECL_CHAIN (fields))\n+\t{\n+\t  if (index == cep->index)\n+\t    goto found;\n+\n+\t  /* The field we're initializing must be on the field\n+\t     list.  Look to see if it is present before the\n+\t     field the current ELT initializes.  */\n+\t  for (; fields != cep->index; fields = DECL_CHAIN (fields))\n+\t    if (index == fields)\n+\t      goto insert;\n+\t}\n+      /* We fell off the end of the CONSTRUCTOR, so insert a new\n+\t entry at the end.  */\n+\n+      insert : {\n+\tconstructor_elt ce = {index, NULL_TREE};\n+\n+\tvec_safe_insert (CONSTRUCTOR_ELTS (ctor), idx, ce);\n+\tcep = CONSTRUCTOR_ELT (ctor, idx);\n+      }\n+    found:;\n+\n+      return cep;\n+    }\n+}\n+\n+/* Complain about a const object OBJ being modified in a constant expression.\n+   EXPR is the MODIFY_EXPR expression performing the modification.  */\n+\n+static void\n+modifying_const_object_error (tree expr, tree obj)\n+{\n+  location_t loc = EXPR_LOCATION (expr);\n+  auto_diagnostic_group d;\n+  error_at (loc,\n+\t    \"modifying a const object %qE is not allowed in \"\n+\t    \"a constant expression\",\n+\t    TREE_OPERAND (expr, 0));\n+  inform (location_of (obj), \"originally declared %<const%> here\");\n+}\n+\n+/* Return true iff DECL is an empty field, either for an empty base or a\n+   [[no_unique_address]] data member.  */\n+\n+bool\n+is_empty_field (tree decl)\n+{\n+  if (!decl || TREE_CODE (decl) != FIELD_DECL)\n+    return false;\n+\n+  bool r = is_empty_class (TREE_TYPE (decl));\n+\n+  /* Empty fields should have size zero.  */\n+  gcc_checking_assert (!r || integer_zerop (DECL_SIZE (decl)));\n+\n+  return r;\n+}\n+\n static tree\n eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t       bool *non_constant_p, bool *overflow_p)\n {\n+  constexpr_ctx new_ctx = *ctx;\n+\n   tree init = TREE_OPERAND (t, 1);\n   if (TREE_CLOBBER_P (init))\n     /* Just ignore clobbers.  */\n@@ -345,29 +888,356 @@ eval_store_expression (const constexpr_ctx *ctx, tree t, bool lval,\n     {\n       /* Evaluate the value to be stored without knowing what object it will be\n \t stored in, so that any side-effects happen first.  */\n-      init = fold_expr (init);\n+      if (!SCALAR_TYPE_P (type))\n+\tnew_ctx.ctor = new_ctx.object = NULL_TREE;\n+      init = constexpr_expression (&new_ctx, init, false, non_constant_p,\n+\t\t\t\t   overflow_p);\n+      if (*non_constant_p)\n+\treturn t;\n     }\n \n   bool evaluated = false;\n+  if (lval)\n+    {\n+      /* If we want to return a reference to the target, we need to evaluate it\n+\t as a whole; otherwise, only evaluate the innermost piece to avoid\n+\t building up unnecessary *_REFs.  */\n+      target\n+\t= constexpr_expression (ctx, target, true, non_constant_p, overflow_p);\n+      evaluated = true;\n+      if (*non_constant_p)\n+\treturn t;\n+    }\n+\n+  /* Find the underlying variable.  */\n+  releasing_vec refs;\n   tree object = NULL_TREE;\n+  /* If we're modifying a const object, save it.  */\n+  tree const_object_being_modified = NULL_TREE;\n+  bool mutable_p = false;\n   for (tree probe = target; object == NULL_TREE;)\n     {\n       switch (TREE_CODE (probe))\n \t{\n+\tcase BIT_FIELD_REF:\n+\tcase COMPONENT_REF:\n+\t  case ARRAY_REF: {\n+\t    tree ob = TREE_OPERAND (probe, 0);\n+\t    tree elt = TREE_OPERAND (probe, 1);\n+\t    if (TREE_CODE (elt) == FIELD_DECL /*&& DECL_MUTABLE_P (elt)*/)\n+\t      mutable_p = true;\n+\t    if (TREE_CODE (probe) == ARRAY_REF)\n+\t      {\n+\t\t// TODO\n+\t\tgcc_unreachable ();\n+\t\t// elt = eval_and_check_array_index (ctx, probe, false,\n+\t\t// \t\t\t\t  non_constant_p, overflow_p);\n+\t\tif (*non_constant_p)\n+\t\t  return t;\n+\t      }\n+\t    /* We don't check modifying_const_object_p for ARRAY_REFs.  Given\n+\t       \"int a[10]\", an ARRAY_REF \"a[2]\" can be \"const int\", even though\n+\t       the array isn't const.  Instead, check \"a\" in the next iteration;\n+\t       that will detect modifying \"const int a[10]\".  */\n+\t    // else if (evaluated\n+\t    //          && modifying_const_object_p (TREE_CODE (t), probe,\n+\t    //     \t\t\t\t  mutable_p)\n+\t    //          && const_object_being_modified == NULL_TREE)\n+\t    //   const_object_being_modified = probe;\n+\t    vec_safe_push (refs, elt);\n+\t    vec_safe_push (refs, TREE_TYPE (probe));\n+\t    probe = ob;\n+\t  }\n+\t  break;\n+\n \tdefault:\n \t  if (evaluated)\n \t    object = probe;\n \t  else\n \t    {\n-\t      probe = constexpr_expression (ctx, probe, lval, non_constant_p,\n+\t      probe = constexpr_expression (ctx, probe, true, non_constant_p,\n \t\t\t\t\t    overflow_p);\n \t      evaluated = true;\n+\t      if (*non_constant_p)\n+\t\treturn t;\n \t    }\n \t  break;\n \t}\n     }\n \n-  return init;\n+  // if (modifying_const_object_p (TREE_CODE (t), object, mutable_p)\n+  //   && const_object_being_modified == NULL_TREE)\n+  // const_object_being_modified = object;\n+\n+  /* And then find/build up our initializer for the path to the subobject\n+     we're initializing.  */\n+  tree *valp;\n+  if (DECL_P (object))\n+    valp = ctx->global->values.get (object);\n+  else\n+    valp = NULL;\n+  if (!valp)\n+    {\n+      /* A constant-expression cannot modify objects from outside the\n+\t constant-expression.  */\n+      if (!ctx->quiet)\n+\terror (\"modification of %qE is not a constant expression\", object);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+  type = TREE_TYPE (object);\n+  bool no_zero_init = true;\n+\n+  releasing_vec ctors, indexes;\n+  auto_vec<int> index_pos_hints;\n+  bool activated_union_member_p = false;\n+  while (!refs->is_empty ())\n+    {\n+      if (*valp == NULL_TREE)\n+\t{\n+\t  *valp = build_constructor (type, NULL);\n+\t  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;\n+\t}\n+      else if (TREE_CODE (*valp) == STRING_CST)\n+\t{\n+\t  /* An array was initialized with a string constant, and now\n+\t     we're writing into one of its elements.  Explode the\n+\t     single initialization into a set of element\n+\t     initializations.  */\n+\t  gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n+\n+\t  tree string = *valp;\n+\t  tree elt_type = TREE_TYPE (type);\n+\t  unsigned chars_per_elt\n+\t    = (TYPE_PRECISION (elt_type) / TYPE_PRECISION (char_type_node));\n+\t  unsigned num_elts = TREE_STRING_LENGTH (string) / chars_per_elt;\n+\t  tree ary_ctor = build_constructor (type, NULL);\n+\n+\t  vec_safe_reserve (CONSTRUCTOR_ELTS (ary_ctor), num_elts);\n+\t  for (unsigned ix = 0; ix != num_elts; ix++)\n+\t    {\n+\t      constructor_elt elt\n+\t\t= {build_int_cst (size_type_node, ix),\n+\t\t   extract_string_elt (string, chars_per_elt, ix)};\n+\t      CONSTRUCTOR_ELTS (ary_ctor)->quick_push (elt);\n+\t    }\n+\n+\t  *valp = ary_ctor;\n+\t}\n+\n+      /* If the value of object is already zero-initialized, any new ctors for\n+\t subobjects will also be zero-initialized.  */\n+      no_zero_init = CONSTRUCTOR_NO_CLEARING (*valp);\n+\n+      enum tree_code code = TREE_CODE (type);\n+      type = refs->pop ();\n+      tree index = refs->pop ();\n+\n+      if (code == RECORD_TYPE && is_empty_field (index))\n+\t/* Don't build a sub-CONSTRUCTOR for an empty base or field, as they\n+\t   have no data and might have an offset lower than previously declared\n+\t   fields, which confuses the middle-end.  The code below will notice\n+\t   that we don't have a CONSTRUCTOR for our inner target and just\n+\t   return init.  */\n+\tbreak;\n+\n+      if (code == UNION_TYPE && CONSTRUCTOR_NELTS (*valp)\n+\t  && CONSTRUCTOR_ELT (*valp, 0)->index != index)\n+\t{\n+\t  if (TREE_CODE (t) == MODIFY_EXPR && CONSTRUCTOR_NO_CLEARING (*valp))\n+\t    {\n+\t      /* Diagnose changing the active union member while the union\n+\t\t is in the process of being initialized.  */\n+\t      if (!ctx->quiet)\n+\t\terror_at (EXPR_LOCATION (t),\n+\t\t\t  \"change of the active member of a union \"\n+\t\t\t  \"from %qD to %qD during initialization\",\n+\t\t\t  CONSTRUCTOR_ELT (*valp, 0)->index, index);\n+\t      *non_constant_p = true;\n+\t    }\n+\t  no_zero_init = true;\n+\t}\n+\n+      vec_safe_push (ctors, *valp);\n+      vec_safe_push (indexes, index);\n+\n+      constructor_elt *cep = get_or_insert_ctor_field (*valp, index);\n+      index_pos_hints.safe_push (cep - CONSTRUCTOR_ELTS (*valp)->begin ());\n+\n+      if (code == UNION_TYPE)\n+\tactivated_union_member_p = true;\n+\n+      valp = &cep->value;\n+    }\n+\n+  /* Detect modifying a constant object in constexpr evaluation.\n+     We have found a const object that is being modified.  Figure out\n+     if we need to issue an error.  Consider\n+\n+     struct A {\n+       int n;\n+       constexpr A() : n(1) { n = 2; } // #1\n+     };\n+     struct B {\n+       const A a;\n+       constexpr B() { a.n = 3; } // #2\n+     };\n+    constexpr B b{};\n+\n+    #1 is OK, since we're modifying an object under construction, but\n+    #2 is wrong, since \"a\" is const and has been fully constructed.\n+    To track it, we use the TREE_READONLY bit in the object's CONSTRUCTOR\n+    which means that the object is read-only.  For the example above, the\n+    *ctors stack at the point of #2 will look like:\n+\n+      ctors[0] = {.a={.n=2}}  TREE_READONLY = 0\n+      ctors[1] = {.n=2}       TREE_READONLY = 1\n+\n+    and we're modifying \"b.a\", so we search the stack and see if the\n+    constructor for \"b.a\" has already run.  */\n+  if (const_object_being_modified)\n+    {\n+      bool fail = false;\n+      tree const_objtype\n+\t= strip_array_types (TREE_TYPE (const_object_being_modified));\n+      if (!CLASS_TYPE_P (const_objtype))\n+\tfail = true;\n+      else\n+\t{\n+\t  /* [class.ctor]p5 \"A constructor can be invoked for a const,\n+\t     volatile, or const volatile object.  const and volatile\n+\t     semantics are not applied on an object under construction.\n+\t     They come into effect when the constructor for the most\n+\t     derived object ends.\"  */\n+\t  for (tree elt : *ctors)\n+\t    if (same_type_ignoring_top_level_qualifiers_p (\n+\t\t  TREE_TYPE (const_object_being_modified), TREE_TYPE (elt)))\n+\t      {\n+\t\tfail = TREE_READONLY (elt);\n+\t\tbreak;\n+\t      }\n+\t}\n+      if (fail)\n+\t{\n+\t  if (!ctx->quiet)\n+\t    modifying_const_object_error (t, const_object_being_modified);\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+    }\n+\n+  if (!preeval)\n+    {\n+      /* We're handling an INIT_EXPR of class type, so the value of the\n+\t initializer can depend on the object it's initializing.  */\n+\n+      /* Create a new CONSTRUCTOR in case evaluation of the initializer\n+\t wants to modify it.  */\n+      if (*valp == NULL_TREE)\n+\t{\n+\t  *valp = build_constructor (type, NULL);\n+\t  CONSTRUCTOR_NO_CLEARING (*valp) = no_zero_init;\n+\t}\n+      new_ctx.ctor = *valp;\n+      new_ctx.object = target;\n+      /* Avoid temporary materialization when initializing from a TARGET_EXPR.\n+\t We don't need to mess with AGGR_EXPR_SLOT/VEC_INIT_EXPR_SLOT because\n+\t expansion of those trees uses ctx instead.  */\n+      if (TREE_CODE (init) == TARGET_EXPR)\n+\tif (tree tinit = TARGET_EXPR_INITIAL (init))\n+\t  init = tinit;\n+      init = constexpr_expression (&new_ctx, init, false, non_constant_p,\n+\t\t\t\t   overflow_p);\n+      /* The hash table might have moved since the get earlier, and the\n+\t initializer might have mutated the underlying CONSTRUCTORs, so we must\n+\t recompute VALP. */\n+      valp = ctx->global->values.get (object);\n+      for (unsigned i = 0; i < vec_safe_length (indexes); i++)\n+\t{\n+\t  constructor_elt *cep\n+\t    = get_or_insert_ctor_field (*valp, indexes[i], index_pos_hints[i]);\n+\t  valp = &cep->value;\n+\t}\n+    }\n+\n+  /* Don't share a CONSTRUCTOR that might be changed later.  */\n+  init = unshare_constructor (init);\n+\n+  if (*valp && TREE_CODE (*valp) == CONSTRUCTOR\n+      && TREE_CODE (init) == CONSTRUCTOR)\n+    {\n+      /* An outer ctx->ctor might be pointing to *valp, so replace\n+\t its contents.  */\n+      if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (init),\n+\t\t\t\t\t\t      TREE_TYPE (*valp)))\n+\t{\n+\t  /* For initialization of an empty base, the original target will be\n+\t   *(base*)this, evaluation of which resolves to the object\n+\t   argument, which has the derived type rather than the base type.  In\n+\t   this situation, just evaluate the initializer and return, since\n+\t   there's no actual data to store.  */\n+\t  gcc_assert (is_empty_class (TREE_TYPE (init)));\n+\t  return lval ? target : init;\n+\t}\n+      CONSTRUCTOR_ELTS (*valp) = CONSTRUCTOR_ELTS (init);\n+      TREE_CONSTANT (*valp) = TREE_CONSTANT (init);\n+      TREE_SIDE_EFFECTS (*valp) = TREE_SIDE_EFFECTS (init);\n+      CONSTRUCTOR_NO_CLEARING (*valp) = CONSTRUCTOR_NO_CLEARING (init);\n+    }\n+  else if (TREE_CODE (init) == CONSTRUCTOR\n+\t   && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (init),\n+\t\t\t\t\t\t\t  type))\n+    {\n+      /* See above on initialization of empty bases.  */\n+      gcc_assert (is_empty_class (TREE_TYPE (init)) && !lval);\n+      return init;\n+    }\n+  else\n+    *valp = init;\n+\n+  /* After initialization, 'const' semantics apply to the value of the\n+     object.  Make a note of this fact by marking the CONSTRUCTOR\n+     TREE_READONLY.  */\n+  if (TREE_CODE (t) == INIT_EXPR && TREE_CODE (*valp) == CONSTRUCTOR\n+      && TYPE_READONLY (type))\n+    {\n+      // this vs self? can rust's self be anything other than self or &self in\n+      // constexpr mode? if (INDIRECT_REF_P (target)\n+      //     && (is_this_parameter (\n+      //       tree_strip_nop_conversions (TREE_OPERAND (target, 0)))))\n+      /* We've just initialized '*this' (perhaps via the target\n+\t constructor of a delegating constructor).  Leave it up to the\n+\t caller that set 'this' to set TREE_READONLY appropriately.  */\n+      //   gcc_checking_assert (\n+      //     same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (target),\n+      //     type));\n+      // else\n+      //   TREE_READONLY (*valp) = true;\n+    }\n+\n+  /* Update TREE_CONSTANT and TREE_SIDE_EFFECTS on enclosing\n+     CONSTRUCTORs, if any.  */\n+  bool c = TREE_CONSTANT (init);\n+  bool s = TREE_SIDE_EFFECTS (init);\n+  if (!c || s || activated_union_member_p)\n+    for (tree elt : *ctors)\n+      {\n+\tif (!c)\n+\t  TREE_CONSTANT (elt) = false;\n+\tif (s)\n+\t  TREE_SIDE_EFFECTS (elt) = true;\n+\t/* Clear CONSTRUCTOR_NO_CLEARING since we've activated a member of\n+\t   this union.  */\n+\tif (TREE_CODE (TREE_TYPE (elt)) == UNION_TYPE)\n+\t  CONSTRUCTOR_NO_CLEARING (elt) = false;\n+      }\n+\n+  if (*non_constant_p)\n+    return t;\n+  else if (lval)\n+    return target;\n+  else\n+    return init;\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -526,10 +1396,290 @@ rs_bind_parameters_in_call (const constexpr_ctx *ctx, tree t, tree fun,\n // Evaluate the call expression tree T in the context of OLD_CALL expression\n // evaluation.\n static tree\n-eval_call_expression (const constexpr_ctx *ctx, tree t)\n+eval_call_expression (const constexpr_ctx *ctx, tree t, bool lval,\n+\t\t      bool *non_constant_p, bool *overflow_p)\n {\n+  location_t loc = EXPR_LOCATION (t);\n   tree fun = get_function_named_in_call (t);\n-  return constexpr_fn_retval (ctx, DECL_SAVED_TREE (fun));\n+  constexpr_call new_call = {NULL, NULL, NULL, 0, ctx->manifestly_const_eval};\n+  int depth_ok;\n+\n+  if (fun == NULL_TREE)\n+    {\n+      // return cxx_eval_internal_function (ctx, t, lval,\n+      //     \t\t\t       non_constant_p, overflow_p);\n+      gcc_unreachable ();\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (fun) != FUNCTION_DECL)\n+    {\n+      if (!ctx->quiet && !*non_constant_p)\n+\terror_at (loc,\n+\t\t  \"expression %qE does not designate a %<constexpr%> \"\n+\t\t  \"function\",\n+\t\t  fun);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+\n+  bool non_constant_args = false;\n+  new_call.bindings\n+    = rs_bind_parameters_in_call (ctx, t, fun, non_constant_p, overflow_p,\n+\t\t\t\t  &non_constant_args);\n+\n+  /* We build up the bindings list before we know whether we already have this\n+   call cached.  If we don't end up saving these bindings, ggc_free them when\n+   this function exits.  */\n+  class free_bindings\n+  {\n+    tree *bindings;\n+\n+  public:\n+    free_bindings (tree &b) : bindings (&b) {}\n+    ~free_bindings ()\n+    {\n+      if (bindings)\n+\tggc_free (*bindings);\n+    }\n+    void preserve () { bindings = NULL; }\n+  } fb (new_call.bindings);\n+\n+  if (*non_constant_p)\n+    return t;\n+\n+  /* If in direct recursive call, optimize definition search.  */\n+  if (ctx && ctx->call && ctx->call->fundef && ctx->call->fundef->decl == fun)\n+    new_call.fundef = ctx->call->fundef;\n+  else\n+    {\n+      new_call.fundef = retrieve_constexpr_fundef (fun);\n+      if (new_call.fundef == NULL || new_call.fundef->body == NULL\n+\t  || new_call.fundef->result == error_mark_node\n+\t  || fun == current_function_decl)\n+\t{\n+\t  if (!ctx->quiet)\n+\t    {\n+\t      /* We need to check for current_function_decl here in case we're\n+\t\t being called during cp_fold_function, because at that point\n+\t\t DECL_INITIAL is set properly and we have a fundef but we\n+\t\t haven't lowered invisirefs yet (c++/70344).  */\n+\t      if (DECL_INITIAL (fun) == error_mark_node\n+\t\t  || fun == current_function_decl)\n+\t\terror_at (loc,\n+\t\t\t  \"%qD called in a constant expression before its \"\n+\t\t\t  \"definition is complete\",\n+\t\t\t  fun);\n+\t      else if (DECL_INITIAL (fun))\n+\t\t{\n+\t\t  // /* The definition of fun was somehow unsuitable.  But\n+\t\t  // pretend\n+\t\t  //    that lambda static thunks don't exist.  */\n+\t\t  // if (!lambda_static_thunk_p (fun))\n+\t\t  //   error_at (loc, \"%qD called in a constant expression\",\n+\t\t  //   fun);\n+\t\t  explain_invalid_constexpr_fn (fun);\n+\t\t}\n+\t      else\n+\t\terror_at (loc, \"%qD used before its definition\", fun);\n+\t    }\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+    }\n+\n+  depth_ok = push_cx_call_context (t);\n+\n+  tree result = NULL_TREE;\n+  constexpr_call *entry = NULL;\n+  if (depth_ok && !non_constant_args && ctx->strict)\n+    {\n+      new_call.hash = constexpr_fundef_hasher::hash (new_call.fundef);\n+      // new_call.hash\n+      //   = iterative_hash_template_arg (new_call.bindings, new_call.hash);\n+      new_call.hash\n+\t= iterative_hash_object (ctx->manifestly_const_eval, new_call.hash);\n+\n+      /* If we have seen this call before, we are done.  */\n+      maybe_initialize_constexpr_call_table ();\n+      constexpr_call **slot\n+\t= constexpr_call_table->find_slot (&new_call, INSERT);\n+      entry = *slot;\n+      if (entry == NULL)\n+\t{\n+\t  /* Only cache up to constexpr_cache_depth to limit memory use.  */\n+\t  if (depth_ok < constexpr_cache_depth)\n+\t    {\n+\t      /* We need to keep a pointer to the entry, not just the slot, as\n+\t\t the slot can move during evaluation of the body.  */\n+\t      *slot = entry = ggc_alloc<constexpr_call> ();\n+\t      *entry = new_call;\n+\t      fb.preserve ();\n+\t    }\n+\t}\n+      /* Calls that are in progress have their result set to NULL, so that we\n+\t can detect circular dependencies.  Now that we only cache up to\n+\t constexpr_cache_depth this won't catch circular dependencies that\n+\t start deeper, but they'll hit the recursion or ops limit.  */\n+      else if (entry->result == NULL)\n+\t{\n+\t  if (!ctx->quiet)\n+\t    error (\"call has circular dependency\");\n+\t  *non_constant_p = true;\n+\t  entry->result = result = error_mark_node;\n+\t}\n+      else\n+\tresult = entry->result;\n+    }\n+\n+  if (!depth_ok)\n+    {\n+      if (!ctx->quiet)\n+\terror (\"%<constexpr%> evaluation depth exceeds maximum of %d (use \"\n+\t       \"%<-fconstexpr-depth=%> to increase the maximum)\",\n+\t       max_constexpr_depth);\n+      *non_constant_p = true;\n+      result = error_mark_node;\n+    }\n+  else\n+    {\n+      bool cacheable = true;\n+      if (result && result != error_mark_node)\n+\t/* OK */;\n+      else if (!DECL_SAVED_TREE (fun))\n+\t{\n+\t  /* When at_eof >= 2, cgraph has started throwing away\n+\t     DECL_SAVED_TREE, so fail quietly.  FIXME we get here because of\n+\t     late code generation for VEC_INIT_EXPR, which needs to be\n+\t     completely reconsidered.  */\n+\t  // gcc_assert (at_eof >= 2 && ctx->quiet);\n+\t  *non_constant_p = true;\n+\t}\n+      else if (tree copy = get_fundef_copy (new_call.fundef))\n+\t{\n+\t  tree body, parms, res;\n+\t  releasing_vec ctors;\n+\n+\t  /* Reuse or create a new unshared copy of this function's body.  */\n+\t  body = TREE_PURPOSE (copy);\n+\t  parms = TREE_VALUE (copy);\n+\t  res = TREE_TYPE (copy);\n+\n+\t  /* Associate the bindings with the remapped parms.  */\n+\t  tree bound = new_call.bindings;\n+\t  tree remapped = parms;\n+\t  for (int i = 0; i < TREE_VEC_LENGTH (bound); ++i)\n+\t    {\n+\t      tree arg = TREE_VEC_ELT (bound, i);\n+\t      if (entry)\n+\t\t{\n+\t\t  /* Unshare args going into the hash table to separate them\n+\t\t     from the caller's context, for better GC and to avoid\n+\t\t     problems with verify_gimple.  */\n+\t\t  arg = unshare_expr_without_location (arg);\n+\t\t  TREE_VEC_ELT (bound, i) = arg;\n+\n+\t\t  /* And then unshare again so the callee doesn't change the\n+\t\t     argument values in the hash table. XXX Could we unshare\n+\t\t     lazily in cxx_eval_store_expression?  */\n+\t\t  arg = unshare_constructor (arg);\n+\t\t  if (TREE_CODE (arg) == CONSTRUCTOR)\n+\t\t    vec_safe_push (ctors, arg);\n+\t\t}\n+\n+\t      ctx->global->values.put (remapped, arg);\n+\t      remapped = DECL_CHAIN (remapped);\n+\t    }\n+\t  /* Add the RESULT_DECL to the values map, too.  */\n+\t  gcc_assert (!DECL_BY_REFERENCE (res));\n+\t  ctx->global->values.put (res, NULL_TREE);\n+\n+\t  /* Track the callee's evaluated SAVE_EXPRs and TARGET_EXPRs so that\n+\t     we can forget their values after the call.  */\n+\t  constexpr_ctx ctx_with_save_exprs = *ctx;\n+\t  auto_vec<tree, 10> save_exprs;\n+\t  ctx_with_save_exprs.save_exprs = &save_exprs;\n+\t  ctx_with_save_exprs.call = &new_call;\n+\t  unsigned save_heap_alloc_count = ctx->global->heap_vars.length ();\n+\t  unsigned save_heap_dealloc_count = ctx->global->heap_dealloc_count;\n+\n+\t  tree jump_target = NULL_TREE;\n+\t  constexpr_expression (&ctx_with_save_exprs, body, lval,\n+\t\t\t\tnon_constant_p, overflow_p, &jump_target);\n+\n+\t  if (VOID_TYPE_P (TREE_TYPE (res)))\n+\t    result = void_node;\n+\t  else\n+\t    {\n+\t      result = *ctx->global->values.get (res);\n+\t      if (result == NULL_TREE && !*non_constant_p)\n+\t\t{\n+\t\t  if (!ctx->quiet)\n+\t\t    error (\"%<constexpr%> call flows off the end \"\n+\t\t\t   \"of the function\");\n+\t\t  *non_constant_p = true;\n+\t\t}\n+\t    }\n+\n+\t  /* Forget the saved values of the callee's SAVE_EXPRs and\n+\t     TARGET_EXPRs.  */\n+\t  for (tree save_expr : save_exprs)\n+\t    ctx->global->values.remove (save_expr);\n+\n+\t  /* Remove the parms/result from the values map.  Is it worth\n+\t     bothering to do this when the map itself is only live for\n+\t     one constexpr evaluation?  If so, maybe also clear out\n+\t     other vars from call, maybe in BIND_EXPR handling?  */\n+\t  ctx->global->values.remove (res);\n+\t  for (tree parm = parms; parm; parm = TREE_CHAIN (parm))\n+\t    ctx->global->values.remove (parm);\n+\n+\t  /* Make the unshared function copy we used available for re-use.  */\n+\t  save_fundef_copy (fun, copy);\n+\n+\t  /* If the call allocated some heap object that hasn't been\n+\t     deallocated during the call, or if it deallocated some heap\n+\t     object it has not allocated, the call isn't really stateless\n+\t     for the constexpr evaluation and should not be cached.\n+\t     It is fine if the call allocates something and deallocates it\n+\t     too.  */\n+\t  if (entry\n+\t      && (save_heap_alloc_count != ctx->global->heap_vars.length ()\n+\t\t  || (save_heap_dealloc_count\n+\t\t      != ctx->global->heap_dealloc_count)))\n+\t    {\n+\t      tree heap_var;\n+\t      unsigned int i;\n+\t      if ((ctx->global->heap_vars.length ()\n+\t\t   - ctx->global->heap_dealloc_count)\n+\t\t  != save_heap_alloc_count - save_heap_dealloc_count)\n+\t\tcacheable = false;\n+\t      else\n+\t\tFOR_EACH_VEC_ELT_FROM (ctx->global->heap_vars, i, heap_var,\n+\t\t\t\t       save_heap_alloc_count)\n+\t\t  if (DECL_NAME (heap_var) != heap_deleted_identifier)\n+\t\t    {\n+\t\t      cacheable = false;\n+\t\t      break;\n+\t\t    }\n+\t    }\n+\t}\n+      else\n+\t/* Couldn't get a function copy to evaluate.  */\n+\t*non_constant_p = true;\n+\n+      if (result == error_mark_node)\n+\t*non_constant_p = true;\n+      if (*non_constant_p || *overflow_p)\n+\tresult = error_mark_node;\n+      else if (!result)\n+\tresult = void_node;\n+      if (entry)\n+\tentry->result = cacheable ? result : error_mark_node;\n+    }\n+\n+  pop_cx_call_context ();\n+  return result;\n }\n \n // Subroutine of check_constexpr_fundef.  BODY is the body of a function\n@@ -828,7 +1978,7 @@ unshare_constructor (tree t MEM_STAT_DECL)\n }\n \n /* Returns the index of the constructor_elt of ARY which matches DINDEX, or -1\n-   if none.  If INSERT is true, insert a matching element rather than fail.  */\n+   if none.  If INSERT is true, insert a matching element rather than fail. */\n \n static HOST_WIDE_INT\n find_array_ctor_elt (tree ary, tree dindex, bool insert)\n@@ -1269,5 +2419,168 @@ free_constructor (tree t)\n     }\n }\n \n+/* Check whether the parameter and return types of FUN are valid for a\n+   constexpr function, and complain if COMPLAIN.  */\n+\n+bool\n+is_valid_constexpr_fn (tree fun, bool complain)\n+{\n+  bool ret = true;\n+\n+  for (tree parm = FUNCTION_FIRST_USER_PARM (fun); parm != NULL_TREE;\n+       parm = TREE_CHAIN (parm))\n+    if (!literal_type_p (TREE_TYPE (parm)))\n+      {\n+\tret = false;\n+\tif (complain)\n+\t  {\n+\t    auto_diagnostic_group d;\n+\t    error (\"invalid type for parameter %d of %<constexpr%> \"\n+\t\t   \"function %q+#D\",\n+\t\t   DECL_PARM_INDEX (parm), fun);\n+\t  }\n+      }\n+\n+  return ret;\n+}\n+\n+void\n+explain_invalid_constexpr_fn (tree fun)\n+{\n+  static hash_set<tree> *diagnosed;\n+  tree body;\n+\n+  if (diagnosed == NULL)\n+    diagnosed = new hash_set<tree>;\n+  if (diagnosed->add (fun))\n+    /* Already explained.  */\n+    return;\n+\n+  iloc_sentinel ils = input_location;\n+  // if (!lambda_static_thunk_p (fun))\n+  //   {\n+  //     /* Diagnostics should completely ignore the static thunk, so leave\n+  //        input_location set to our caller's location.  */\n+  //     input_location = DECL_SOURCE_LOCATION (fun);\n+  //     inform (input_location,\n+  //             \"%qD is not usable as a %<constexpr%> function because:\",\n+  //             fun);\n+  //   }\n+\n+  /* First check the declaration.  */\n+  if (is_valid_constexpr_fn (fun, true))\n+    {\n+      // /* Then if it's OK, the body.  */\n+      // if (!DECL_DECLARED_CONSTEXPR_P (fun))\n+      //   explain_implicit_non_constexpr (fun);\n+      // else\n+      //   {\n+      //     if (constexpr_fundef *fd = retrieve_constexpr_fundef (fun))\n+      //       body = fd->body;\n+      //     else\n+      //       body = DECL_SAVED_TREE (fun);\n+      //     body = massage_constexpr_body (fun, body);\n+      //     require_potential_rvalue_constant_expression (body);\n+      //   }\n+    }\n+}\n+\n+/* BODY is a validated and massaged definition of a constexpr\n+   function.  Register it in the hash table.  */\n+\n+void\n+register_constexpr_fundef (const constexpr_fundef &value)\n+{\n+  /* Create the constexpr function table if necessary.  */\n+  if (constexpr_fundef_table == NULL)\n+    constexpr_fundef_table\n+      = hash_table<constexpr_fundef_hasher>::create_ggc (101);\n+\n+  constexpr_fundef **slot = constexpr_fundef_table->find_slot (\n+    const_cast<constexpr_fundef *> (&value), INSERT);\n+\n+  gcc_assert (*slot == NULL);\n+  *slot = ggc_alloc<constexpr_fundef> ();\n+  **slot = value;\n+}\n+\n+/* We are processing the definition of the constexpr function FUN.\n+   Check that its body fulfills the apropriate requirements and\n+   enter it in the constexpr function definition table.  */\n+\n+void\n+maybe_save_constexpr_fundef (tree fun)\n+{\n+  // FIXME\n+\n+  constexpr_fundef entry = {fun, NULL_TREE, NULL_TREE, NULL_TREE};\n+  bool clear_ctx = false;\n+  if (DECL_RESULT (fun) && DECL_CONTEXT (DECL_RESULT (fun)) == NULL_TREE)\n+    {\n+      clear_ctx = true;\n+      DECL_CONTEXT (DECL_RESULT (fun)) = fun;\n+    }\n+  tree saved_fn = current_function_decl;\n+  current_function_decl = fun;\n+  entry.body = copy_fn (entry.decl, entry.parms, entry.result);\n+  current_function_decl = saved_fn;\n+  if (clear_ctx)\n+    DECL_CONTEXT (DECL_RESULT (entry.decl)) = NULL_TREE;\n+\n+  register_constexpr_fundef (entry);\n+}\n+\n+/* Evaluate a STATEMENT_LIST for side-effects.  Handles various jump\n+   semantics, for switch, break, continue, and return.  */\n+\n+static tree\n+eval_statement_list (const constexpr_ctx *ctx, tree t, bool *non_constant_p,\n+\t\t     bool *overflow_p, tree *jump_target)\n+{\n+  tree local_target;\n+  /* In a statement-expression we want to return the last value.\n+     For empty statement expression return void_node.  */\n+  tree r = void_node;\n+  if (!jump_target)\n+    {\n+      local_target = NULL_TREE;\n+      jump_target = &local_target;\n+    }\n+  for (tree stmt : tsi_range (t))\n+    {\n+      /* We've found a continue, so skip everything until we reach\n+\t the label its jumping to.  */\n+      // FIXME\n+      // if (continues (jump_target))\n+      //   {\n+      //     if (label_matches (ctx, jump_target, stmt))\n+      //       /* Found it.  */\n+      //       *jump_target = NULL_TREE;\n+      //     else\n+      //       continue;\n+      //   }\n+      if (TREE_CODE (stmt) == DEBUG_BEGIN_STMT)\n+\tcontinue;\n+      r = constexpr_expression (ctx, stmt, false, non_constant_p, overflow_p,\n+\t\t\t\tjump_target);\n+      if (*non_constant_p)\n+\tbreak;\n+      // FIXME\n+      // if (returns (jump_target) || breaks (jump_target))\n+      //   break;\n+    }\n+  if (*jump_target && jump_target == &local_target)\n+    {\n+      /* We aren't communicating the jump to our caller, so give up.  We don't\n+\t need to support evaluation of jumps out of statement-exprs.  */\n+      if (!ctx->quiet)\n+\terror_at (EXPR_LOCATION (r), \"statement is not a constant expression\");\n+      *non_constant_p = true;\n+    }\n+  return r;\n+}\n+\n+// #include \"gt-rust-rust-constexpr.h\"\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "77a0797a019da5ac273187dee6fe0ab145f54530", "filename": "gcc/rust/backend/rust-constexpr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-constexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-constexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.h?ref=4fe7b96c2726322191c0eadd2c1c712afb3d0299", "patch": "@@ -24,6 +24,8 @@ namespace Rust {\n namespace Compile {\n \n extern tree fold_expr (tree);\n+extern void\n+maybe_save_constexpr_fundef (tree fun);\n \n } // namespace Compile\n } // namespace Rust"}, {"sha": "98c112a7d83eb8b3a3c352f5329e3d6f4856fcc3", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=4fe7b96c2726322191c0eadd2c1c712afb3d0299", "patch": "@@ -2228,8 +2228,8 @@ set_array_type_canon (tree t, tree elt_type, tree index_type, bool dep)\n \t   || (index_type && TYPE_CANONICAL (index_type) != index_type))\n     TYPE_CANONICAL (t)\n       = build_cplus_array_type (TYPE_CANONICAL (elt_type),\n-\t\t\t\tindex_type\n-\t\t\t\t? TYPE_CANONICAL (index_type) : index_type,\n+\t\t\t\tindex_type ? TYPE_CANONICAL (index_type)\n+\t\t\t\t\t   : index_type,\n \t\t\t\tdep);\n   else\n     TYPE_CANONICAL (t) = t;\n@@ -2289,12 +2289,10 @@ bool\n is_byte_access_type (tree type)\n {\n   type = TYPE_MAIN_VARIANT (type);\n-  if (type == char_type_node\n-      || type == unsigned_char_type_node)\n+  if (type == char_type_node || type == unsigned_char_type_node)\n     return true;\n \n-  return (TREE_CODE (type) == ENUMERAL_TYPE\n-\t  && TYPE_CONTEXT (type) == std_node\n+  return (TREE_CODE (type) == ENUMERAL_TYPE && TYPE_CONTEXT (type) == std_node\n \t  && !strcmp (\"byte\", TYPE_NAME_STRING (type)));\n }\n \n@@ -2318,8 +2316,8 @@ build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n \n   if (elt_type != TYPE_MAIN_VARIANT (elt_type))\n     /* Start with an array of the TYPE_MAIN_VARIANT.  */\n-    t = build_cplus_array_type (TYPE_MAIN_VARIANT (elt_type),\n-\t\t\t\tindex_type, dependent);\n+    t = build_cplus_array_type (TYPE_MAIN_VARIANT (elt_type), index_type,\n+\t\t\t\tdependent);\n   else if (dependent)\n     {\n       /* Since type_hash_canon calls layout_type, we need to use our own\n@@ -2329,14 +2327,14 @@ build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n \n       if (cplus_array_htab == NULL)\n \tcplus_array_htab = hash_table<cplus_array_hasher>::create_ggc (61);\n-      \n+\n       hash = TYPE_UID (elt_type);\n       if (index_type)\n \thash ^= TYPE_UID (index_type);\n       cai.type = elt_type;\n       cai.domain = index_type;\n \n-      tree *e = cplus_array_htab->find_slot_with_hash (&cai, hash, INSERT); \n+      tree *e = cplus_array_htab->find_slot_with_hash (&cai, hash, INSERT);\n       if (*e)\n \t/* We have found the type: we're done.  */\n \treturn (tree) *e;\n@@ -2370,8 +2368,7 @@ build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n     {\n       tree m = t;\n       for (t = m; t; t = TYPE_NEXT_VARIANT (t))\n-\tif (TREE_TYPE (t) == elt_type\n-\t    && TYPE_NAME (t) == NULL_TREE\n+\tif (TREE_TYPE (t) == elt_type && TYPE_NAME (t) == NULL_TREE\n \t    && TYPE_ATTRIBUTES (t) == NULL_TREE)\n \t  break;\n       if (!t)\n@@ -2404,13 +2401,13 @@ build_cplus_array_type (tree elt_type, tree index_type, int dependent)\n \n   /* Push these needs up to the ARRAY_TYPE so that initialization takes\n      place more easily.  */\n-  bool needs_ctor = (TYPE_NEEDS_CONSTRUCTING (t)\n-\t\t     = TYPE_NEEDS_CONSTRUCTING (elt_type));\n+  bool needs_ctor\n+    = (TYPE_NEEDS_CONSTRUCTING (t) = TYPE_NEEDS_CONSTRUCTING (elt_type));\n   bool needs_dtor = (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t\t     = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (elt_type));\n \n-  if (!dependent && t == TYPE_MAIN_VARIANT (t)\n-      && !COMPLETE_TYPE_P (t) && COMPLETE_TYPE_P (elt_type))\n+  if (!dependent && t == TYPE_MAIN_VARIANT (t) && !COMPLETE_TYPE_P (t)\n+      && COMPLETE_TYPE_P (elt_type))\n     {\n       /* The element type has been completed since the last time we saw\n \t this array type; update the layout and 'tor flags for any variants\n@@ -2539,8 +2536,8 @@ rs_build_qualified_type_real (tree type, int type_quals,\n \n   /* A restrict-qualified type must be a pointer (or reference)\n      to object or incomplete type. */\n-  if ((type_quals & TYPE_QUAL_RESTRICT)\n-      && TREE_CODE (type) != TYPENAME_TYPE && !INDIRECT_TYPE_P (type))\n+  if ((type_quals & TYPE_QUAL_RESTRICT) && TREE_CODE (type) != TYPENAME_TYPE\n+      && !INDIRECT_TYPE_P (type))\n     {\n       bad_quals |= TYPE_QUAL_RESTRICT;\n       type_quals &= ~TYPE_QUAL_RESTRICT;\n@@ -4015,4 +4012,25 @@ require_deduced_type (tree decl, tsubst_flags_t complain)\n {\n   return true;\n }\n+\n+/* Return the location of a tree passed to %+ formats.  */\n+\n+location_t\n+location_of (tree t)\n+{\n+  if (TYPE_P (t))\n+    {\n+      t = TYPE_MAIN_DECL (t);\n+      if (t == NULL_TREE)\n+\treturn input_location;\n+    }\n+  else if (TREE_CODE (t) == OVERLOAD)\n+    t = OVL_FIRST (t);\n+\n+  if (DECL_P (t))\n+    return DECL_SOURCE_LOCATION (t);\n+\n+  return EXPR_LOCATION (t);\n+}\n+\n } // namespace Rust"}, {"sha": "01de727320fd05817bfa1364bad803da4d00e35f", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe7b96c2726322191c0eadd2c1c712afb3d0299/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=4fe7b96c2726322191c0eadd2c1c712afb3d0299", "patch": "@@ -2425,13 +2425,13 @@ extern bool is_byte_access_type (tree);\n extern bool\n comptypes (tree, tree, int);\n \n-extern tree canonical_eh_spec\t\t\t(tree);\n+extern tree canonical_eh_spec (tree);\n \n-extern int cp_tree_operand_length\t\t(const_tree);\n+extern int cp_tree_operand_length (const_tree);\n \n-extern bool rs_tree_equal\t\t\t(tree, tree);\n+extern bool rs_tree_equal (tree, tree);\n \n-extern bool compparms\t\t\t\t(const_tree, const_tree);\n+extern bool compparms (const_tree, const_tree);\n \n extern tree\n rs_build_qualified_type_real (tree, int, tsubst_flags_t);\n@@ -2443,11 +2443,12 @@ extern bool similar_type_p (tree, tree);\n \n extern bool rs_tree_equal (tree, tree);\n \n-extern bool vector_targets_convertible_p (const_tree t1, const_tree t2);\n+extern bool\n+vector_targets_convertible_p (const_tree t1, const_tree t2);\n \n extern bool same_type_ignoring_top_level_qualifiers_p (tree, tree);\n \n-extern bool comp_ptr_ttypes_const\t\t(tree, tree, compare_bounds_t);\n+extern bool comp_ptr_ttypes_const (tree, tree, compare_bounds_t);\n \n extern tree\n get_class_binding_direct (tree, tree, bool want_type = false);\n@@ -2709,6 +2710,23 @@ vec_safe_push (releasing_vec &r, const tree &t CXX_MEM_STAT_INFO)\n   return vec_safe_push (*&r, t PASS_MEM_STAT);\n }\n \n+inline bool\n+vec_safe_reserve (releasing_vec &r, unsigned n,\n+\t\t  bool e = false CXX_MEM_STAT_INFO)\n+{\n+  return vec_safe_reserve (*&r, n, e PASS_MEM_STAT);\n+}\n+inline unsigned\n+vec_safe_length (releasing_vec &r)\n+{\n+  return r->length ();\n+}\n+inline void\n+vec_safe_splice (releasing_vec &r, vec<tree, va_gc> *p CXX_MEM_STAT_INFO)\n+{\n+  vec_safe_splice (*&r, p PASS_MEM_STAT);\n+}\n+\n inline bool\n null_node_p (const_tree expr)\n {\n@@ -2730,6 +2748,9 @@ cxx_incomplete_type_error (const_tree value, const_tree type)\n   cxx_incomplete_type_diagnostic (value, type, DK_ERROR);\n }\n \n+extern location_t\n+location_of (tree t);\n+\n } // namespace Rust\n \n #endif // RUST_TREE"}]}