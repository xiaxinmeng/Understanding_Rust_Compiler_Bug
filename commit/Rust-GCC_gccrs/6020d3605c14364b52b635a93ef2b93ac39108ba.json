{"sha": "6020d3605c14364b52b635a93ef2b93ac39108ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAyMGQzNjA1YzE0MzY0YjUyYjYzNWE5M2VmMmI5M2FjMzkxMDhiYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-09-18T23:33:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-18T23:33:56Z"}, "message": "final.c (final_scan_insn): Hand BARRIERs off to the dwarf2 code.\n\n\t* final.c (final_scan_insn): Hand BARRIERs off to the dwarf2 code.\n\t* dwarf2out.c (dwarf2out_frame_debug): Pass the whole insn along.\n\t(dwarf2out_stack_adjust): A BARRIER resets the args space to 0.\n\n\t* except.c (end_eh_unwinder): Subtract 1 from return address.\n\t* libgcc2.c (__throw): Likewise.\n\t(find_exception_handler): Don't change PC here.  Compare end with >.\n\nFrom-SVN: r15554", "tree": {"sha": "0c64bd1926558404f2fe6db31186a19420fcc900", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c64bd1926558404f2fe6db31186a19420fcc900"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6020d3605c14364b52b635a93ef2b93ac39108ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6020d3605c14364b52b635a93ef2b93ac39108ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6020d3605c14364b52b635a93ef2b93ac39108ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6020d3605c14364b52b635a93ef2b93ac39108ba/comments", "author": null, "committer": null, "parents": [{"sha": "feb5876a0b33803a8ff6a5ba645b1f6f58647b27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb5876a0b33803a8ff6a5ba645b1f6f58647b27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb5876a0b33803a8ff6a5ba645b1f6f58647b27"}], "stats": {"total": 105, "additions": 70, "deletions": 35}, "files": [{"sha": "b84b5e321cd5f9a8669e57c41a1172bf92af260e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6020d3605c14364b52b635a93ef2b93ac39108ba", "patch": "@@ -1,3 +1,13 @@\n+Thu Sep 18 14:22:22 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* final.c (final_scan_insn): Hand BARRIERs off to the dwarf2 code.\n+\t* dwarf2out.c (dwarf2out_frame_debug): Pass the whole insn along.\n+\t(dwarf2out_stack_adjust): A BARRIER resets the args space to 0.\n+\n+\t* except.c (end_eh_unwinder): Subtract 1 from return address.\n+\t* libgcc2.c (__throw): Likewise.\n+\t(find_exception_handler): Don't change PC here.  Compare end with >.\n+\n Thu Sep 18 10:43:07 1997  Nick Clifton  <nickc@cygnus.com>\n  \n  \t* v850.c (compute_register_save_size): Correct register"}, {"sha": "041f2e4a17c839e0f7c62912c6aea7ef59e4f040", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 46, "deletions": 26, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6020d3605c14364b52b635a93ef2b93ac39108ba", "patch": "@@ -913,44 +913,64 @@ static void\n dwarf2out_stack_adjust (insn)\n      rtx insn;\n {\n-  rtx src, dest;\n-  enum rtx_code code;\n   long offset;\n   char *label;\n \n-  if (GET_CODE (insn) != SET)\n-    return;\n-\n-  src = SET_SRC (insn);\n-  dest = SET_DEST (insn);\n-  if (dest == stack_pointer_rtx)\n+  if (GET_CODE (insn) == BARRIER)\n     {\n-      /* (set (reg sp) (plus (reg sp) (const_int))) */\n-      code = GET_CODE (src);\n-      if (! (code == PLUS || code == MINUS)\n-\t  || XEXP (src, 0) != stack_pointer_rtx\n-\t  || GET_CODE (XEXP (src, 1)) != CONST_INT)\n-\treturn;\n-\n-      offset = INTVAL (XEXP (src, 1));\n+      /* When we see a BARRIER, we know to reset args_size to 0.  Usually\n+\t the compiler will have already emitted a stack adjustment, but\n+\t doesn't bother for calls to noreturn functions.  */\n+#ifdef STACK_GROWS_DOWNWARD\n+      offset = -args_size;\n+#else\n+      offset = args_size;\n+#endif\n     }\n-  else if (GET_CODE (dest) == MEM)\n+  else if (GET_CODE (PATTERN (insn)) == SET)\n     {\n-      /* (set (mem (pre_dec (reg sp))) (foo)) */\n-      src = XEXP (dest, 0);\n-      code = GET_CODE (src);\n+      rtx src, dest;\n+      enum rtx_code code;\n+\n+      insn = PATTERN (insn);\n+      src = SET_SRC (insn);\n+      dest = SET_DEST (insn);\n+\n+      if (dest == stack_pointer_rtx)\n+\t{\n+\t  /* (set (reg sp) (plus (reg sp) (const_int))) */\n+\t  code = GET_CODE (src);\n+\t  if (! (code == PLUS || code == MINUS)\n+\t      || XEXP (src, 0) != stack_pointer_rtx\n+\t      || GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\t    return;\n+\n+\t  offset = INTVAL (XEXP (src, 1));\n+\t}\n+      else if (GET_CODE (dest) == MEM)\n+\t{\n+\t  /* (set (mem (pre_dec (reg sp))) (foo)) */\n+\t  src = XEXP (dest, 0);\n+\t  code = GET_CODE (src);\n+\n+\t  if (! (code == PRE_DEC || code == PRE_INC)\n+\t      || XEXP (src, 0) != stack_pointer_rtx)\n+\t    return;\n \n-      if (! (code == PRE_DEC || code == PRE_INC)\n-\t  || XEXP (src, 0) != stack_pointer_rtx)\n+\t  offset = GET_MODE_SIZE (GET_MODE (dest));\n+\t}\n+      else\n \treturn;\n \n-      offset = GET_MODE_SIZE (GET_MODE (dest));\n+      if (code == PLUS || code == PRE_INC)\n+\toffset = -offset;\n     }\n   else\n     return;\n \n-  if (code == PLUS || code == PRE_INC)\n-    offset = -offset;\n+  if (offset == 0)\n+    return;\n+\n   if (cfa_reg == STACK_POINTER_REGNUM)\n     cfa_offset += offset;\n \n@@ -997,7 +1017,7 @@ dwarf2out_frame_debug (insn)\n \n   if (! RTX_FRAME_RELATED_P (insn))\n     {\n-      dwarf2out_stack_adjust (PATTERN (insn));\n+      dwarf2out_stack_adjust (insn);\n       return;\n     }\n "}, {"sha": "ae75175393bf5968a78c3d25af00c054ba47ed0a", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6020d3605c14364b52b635a93ef2b93ac39108ba", "patch": "@@ -1668,6 +1668,8 @@ end_eh_unwinder ()\n   /* Get the address we need to use to determine what exception\n      handler should be invoked, and store it in __eh_pc.  */\n   return_val_rtx = eh_outer_context (return_val_rtx);\n+  return_val_rtx = expand_binop (Pmode, sub_optab, return_val_rtx, GEN_INT (1),\n+\t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n   emit_move_insn (eh_saved_pc_rtx, return_val_rtx);\n   \n   /* Either set things up so we do a return directly to __throw, or"}, {"sha": "8e7675e15c960b3ad298e7f2ae81d7a44af158ea", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6020d3605c14364b52b635a93ef2b93ac39108ba", "patch": "@@ -1589,6 +1589,12 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t is true.  */\t \n       if (NEXT_INSN (insn))\n \tASM_OUTPUT_ALIGN_CODE (file);\n+#endif\n+#if defined (DWARF2_UNWIND_INFO) && !defined (ACCUMULATE_OUTGOING_ARGS)\n+\t/* If we push arguments, we need to check all insns for stack\n+\t   adjustments.  */\n+\tif (dwarf2out_do_frame ())\n+\t  dwarf2out_frame_debug (insn);\n #endif\n       break;\n "}, {"sha": "2b9c6bc886449c355609905a2e750497b5c6012a", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6020d3605c14364b52b635a93ef2b93ac39108ba/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=6020d3605c14364b52b635a93ef2b93ac39108ba", "patch": "@@ -3337,15 +3337,11 @@ find_exception_handler (void *pc, exception_table *table)\n       int pos;\n       int best = -1;\n \n-      /* We subtract 1 from PC to avoid hitting the beginning of the next\n-\t region.  */\n-      --pc;\n-\n       /* We can't do a binary search because the table isn't guaranteed\n \t to be sorted from function to function.  */\n       for (pos = 0; table[pos].exception_handler != (void *) -1; ++pos)\n \t{\n-\t  if (table[pos].start <= pc && table[pos].end >= pc)\n+\t  if (table[pos].start <= pc && table[pos].end > pc)\n \t    {\n \t      /* This can apply.  Make sure it is at least as small as\n \t\t the previous best.  */\n@@ -3354,7 +3350,7 @@ find_exception_handler (void *pc, exception_table *table)\n \t\tbest = pos;\n \t    }\n \t  /* But it is sorted by starting PC within a function.  */\n-\t  else if (best && table[pos].start > pc)\n+\t  else if (best >= 0 && table[pos].start > pc)\n \t    break;\n \t}\n       if (best != -1)\n@@ -3686,8 +3682,9 @@ __throw ()\n \t  break;\n \t}\n \n-      /* Otherwise, we continue searching.  */\n-      pc = get_return_addr (udata, sub_udata);\n+      /* Otherwise, we continue searching.  We subtract 1 from PC to avoid\n+\t hitting the beginning of the next region.  */\n+      pc = get_return_addr (udata, sub_udata) - 1;\n     }\n \n   /* If we haven't found a handler by now, this is an unhandled\n@@ -3736,7 +3733,7 @@ __throw ()\n \t\tput_reg (i, val, my_udata);\n \t      }\n \n-\t  pc = get_return_addr (udata, sub_udata);\n+\t  pc = get_return_addr (udata, sub_udata) - 1;\n \t}\n \n #ifdef INCOMING_REGNO"}]}