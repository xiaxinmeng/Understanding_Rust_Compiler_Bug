{"sha": "99a6c6f4080775d4495b2c1a298232fe0bcfae9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTlhNmM2ZjQwODA3NzVkNDQ5NWIyYzFhMjk4MjMyZmUwYmNmYWU5Zg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-02T04:34:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-02T04:34:22Z"}, "message": "cp-tree.h (CLASSTYPE_N_BASECLASSES): Use BINFO_N_BASETYPES.\n\n\t* cp-tree.h (CLASSTYPE_N_BASECLASSES): Use BINFO_N_BASETYPES.\n\t(BINFO_PRIMARY_MARKED_P): New macro.\n\t(SET_BINFO_PRIMARY_MARKED_P): Likewise.\n\t(CLEAR_BINFO_PRIMARY_MARKED_P): Likewise.\n\t(mark_primary_bases): New function.\n\t(unmark_primary_bases): Likewise.\n\t* search.c (get_abstract_virtuals_1): Remove.\n\t(dfs_mark_primary_bases): New function.\n\t(mark_primary_bases): Likewise.\n\t(dfs_unmark_primary_bases): Likewise.\n\t(unmark_primary_bases): Likewise.\n\t(dfs_get_pure_virtuals): Likewise.\n\nFrom-SVN: r31164", "tree": {"sha": "3d9dddf9dcda16108698f39768c5d28c428d2375", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d9dddf9dcda16108698f39768c5d28c428d2375"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99a6c6f4080775d4495b2c1a298232fe0bcfae9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99a6c6f4080775d4495b2c1a298232fe0bcfae9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99a6c6f4080775d4495b2c1a298232fe0bcfae9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99a6c6f4080775d4495b2c1a298232fe0bcfae9f/comments", "author": null, "committer": null, "parents": [{"sha": "07b7a812fd2ee579c95189586fa8ab7f5bd856aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b7a812fd2ee579c95189586fa8ab7f5bd856aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b7a812fd2ee579c95189586fa8ab7f5bd856aa"}], "stats": {"total": 167, "additions": 119, "deletions": 48}, "files": [{"sha": "db9a5e4a3615d4530ce79f39d80f4a3049319bec", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99a6c6f4080775d4495b2c1a298232fe0bcfae9f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99a6c6f4080775d4495b2c1a298232fe0bcfae9f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=99a6c6f4080775d4495b2c1a298232fe0bcfae9f", "patch": "@@ -1420,8 +1420,7 @@ struct lang_type\n \n /* Number of direct baseclasses of NODE.  */\n #define CLASSTYPE_N_BASECLASSES(NODE) \\\n-  (TYPE_BINFO_BASETYPES (NODE) ? \\\n-   TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES(NODE)) : 0)\n+  (BINFO_N_BASETYPES (TYPE_BINFO (NODE)))\n \n /* Used for keeping search-specific information.  Any search routine\n    which uses this must define what exactly this slot is used for.  */\n@@ -1563,6 +1562,16 @@ struct lang_type\n #define SET_BINFO_PUSHDECLS_MARKED(NODE) SET_BINFO_VTABLE_PATH_MARKED (NODE)\n #define CLEAR_BINFO_PUSHDECLS_MARKED(NODE) CLEAR_BINFO_VTABLE_PATH_MARKED (NODE)\n \n+/* Nonzero if this BINFO has been marked as a primary base class.  */\n+#define BINFO_PRIMARY_MARKED_P(NODE) BINFO_VTABLE_PATH_MARKED (NODE)\n+\n+/* Mark NODE as a primary base class.  */\n+#define SET_BINFO_PRIMARY_MARKED_P(NODE) SET_BINFO_VTABLE_PATH_MARKED (NODE)\n+\n+/* Clear the primary base class mark.  */\n+#define CLEAR_BINFO_PRIMARY_MARKED_P(NODE) \\\n+  CLEAR_BINFO_VTABLE_PATH_MARKED (NODE)\n+\n /* Used by various search routines.  */\n #define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \f\n@@ -2533,7 +2542,7 @@ extern int flag_new_for_scope;\n    to `struct S {}; typedef struct S S;' in C.  This macro will hold\n    for the typedef indicated in this example.  Note that in C++, there\n    is a second implicit typedef for each class, in the scope of `S'\n-   itself, so that you can `S::S'.  This macro does *not* hold for\n+   itself, so that you can say `S::S'.  This macro does *not* hold for\n    those typedefs.  */\n #define DECL_IMPLICIT_TYPEDEF_P(NODE) \\\n   (TREE_CODE ((NODE)) == TYPE_DECL && DECL_LANG_FLAG_2 ((NODE)))\n@@ -3900,6 +3909,8 @@ extern tree dfs_walk                            PROTO((tree,\n \t\t\t\t\t\t       void *));\n extern tree dfs_unmark                          PROTO((tree, void *));\n extern tree markedp                             PROTO((tree, void *));\n+extern void mark_primary_bases                  PROTO((tree));\n+extern void unmark_primary_bases                PROTO((tree));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PROTO((tree));"}, {"sha": "c22391db6a3a32499cd899e8283928fa5d0fdeb6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 105, "deletions": 45, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99a6c6f4080775d4495b2c1a298232fe0bcfae9f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99a6c6f4080775d4495b2c1a298232fe0bcfae9f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=99a6c6f4080775d4495b2c1a298232fe0bcfae9f", "patch": "@@ -75,7 +75,6 @@ pop_stack_level (stack)\n #define search_level stack_level\n static struct search_level *search_stack;\n \n-static tree get_abstract_virtuals_1 PROTO((tree, int, tree));\n static tree next_baselink PROTO((tree));\n static tree get_vbase_1 PROTO((tree, tree, unsigned int *));\n static tree convert_pointer_to_vbase PROTO((tree, tree));\n@@ -152,6 +151,8 @@ static int friend_accessible_p PROTO ((tree, tree, tree, tree));\n static void setup_class_bindings PROTO ((tree, int));\n static int template_self_reference_p PROTO ((tree, tree));\n static void fixup_all_virtual_upcast_offsets PROTO ((tree, tree));\n+static tree dfs_mark_primary_bases PROTO((tree, void *));\n+static tree dfs_unmark_primary_bases PROTO((tree, void *));\n \n /* Allocate a level of searching.  */\n \n@@ -2103,46 +2104,100 @@ get_matching_virtual (binfo, fndecl, dtorp)\n     }\n }\n \n-/* Return the list of virtual functions which are abstract in type\n-   TYPE that come from non virtual base classes.  See\n-   expand_direct_vtbls_init for the style of search we do.  */\n+/* Called via dfs_walk from mark_nonprimary_bases.  */\n \n static tree\n-get_abstract_virtuals_1 (binfo, do_self, abstract_virtuals)\n+dfs_mark_primary_bases (binfo, data)\n      tree binfo;\n-     int do_self;\n-     tree abstract_virtuals;\n+     void *data ATTRIBUTE_UNUSED;\n {\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  for (i = 0; i < n_baselinks; i++)\n+  if (CLASSTYPE_HAS_PRIMARY_BASE_P (BINFO_TYPE (binfo)))\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      int is_not_base_vtable\n-\t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-      if (! TREE_VIA_VIRTUAL (base_binfo))\n-\tabstract_virtuals\n-\t  = get_abstract_virtuals_1 (base_binfo, is_not_base_vtable,\n-\t\t\t\t     abstract_virtuals);\n+      int i;\n+\n+      i = CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      SET_BINFO_PRIMARY_MARKED_P (BINFO_BASETYPE (binfo, i));\n     }\n-  /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (do_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+\n+  SET_BINFO_MARKED (binfo);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Set BINFO_PRIMARY_MARKED_P for all binfos in the hierarchy\n+   dominated by TYPE that are primary bases.  (In addition,\n+   BINFO_MARKED is set for all classes in the hierarchy; callers\n+   should clear BINFO_MARKED.)  */\n+\n+void\n+mark_primary_bases (type)\n+     tree type;\n+{\n+  dfs_walk (TYPE_BINFO (type), \n+\t    dfs_mark_primary_bases,\n+\t    unmarkedp,\n+\t    NULL);\n+}\n+\n+/* Called from unmark_primary_bases via dfs_walk.  */\n+\n+static tree\n+dfs_unmark_primary_bases (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  CLEAR_BINFO_PRIMARY_MARKED_P (binfo);\n+  return NULL_TREE;\n+}\n+\n+/* Clear BINFO_PRIMARY_MARKED_P for all binfo in the hierarchy\n+   dominated by TYPE.  */\n+\n+void\n+unmark_primary_bases (type)\n+     tree type;\n+{\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark_primary_bases, NULL, NULL);\n+}\n+\n+/* Called via dfs_walk from dfs_get_pure_virtuals.  */\n+\n+static tree\n+dfs_get_pure_virtuals (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  /* We're not interested in primary base classes; the derived class\n+     of which they are a primary base will contain the information we\n+     need.  */\n+  if (!BINFO_PRIMARY_MARKED_P (binfo))\n     {\n+      tree type = (tree) data;\n+      tree shared_binfo;\n       tree virtuals;\n+      \n+      /* If this is a virtual base class, then use the shared binfo\n+\t since that is the only place where BINFO_VIRTUALS is valid;\n+\t the various copies in the main hierarchy are not updated when\n+\t vtables are created.  */\n+      shared_binfo = (TREE_VIA_VIRTUAL (binfo) \n+\t\t      ? BINFO_FOR_VBASE (BINFO_TYPE (binfo), type)\n+\t\t      : binfo);\n+\n+      for (virtuals = skip_rtti_stuff (shared_binfo, \n+\t\t\t\t       BINFO_TYPE (shared_binfo), \n+\t\t\t\t       NULL);\n+\t   virtuals;\n+\t   virtuals = TREE_CHAIN (virtuals))\n+\tif (DECL_PURE_VIRTUAL_P (TREE_VALUE (virtuals)))\n+\t  CLASSTYPE_PURE_VIRTUALS (type) \n+\t    = tree_cons (NULL_TREE, TREE_VALUE (virtuals),\n+\t\t\t CLASSTYPE_PURE_VIRTUALS (type));\n+    }\n+\n+  CLEAR_BINFO_MARKED (binfo);\n \n-      virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL);\n-\n-      while (virtuals)\n-\t{\n-\t  tree base_fndecl = TREE_VALUE (virtuals);\n-\t  if (DECL_PURE_VIRTUAL_P (base_fndecl))\n-\t    abstract_virtuals = tree_cons (NULL_TREE, base_fndecl, \n-\t\t\t\t\t   abstract_virtuals);\n-\t  virtuals = TREE_CHAIN (virtuals);\n-\t}\n-    }\n-  return abstract_virtuals;\n+  return NULL_TREE;\n }\n \n /* Set CLASSTYPE_PURE_VIRTUALS for TYPE.  */\n@@ -2152,31 +2207,36 @@ get_pure_virtuals (type)\n      tree type;\n {\n   tree vbases;\n-  tree abstract_virtuals = NULL;\n \n-  /* First get all from non-virtual bases.  */\n-  abstract_virtuals\n-    = get_abstract_virtuals_1 (TYPE_BINFO (type), 1, abstract_virtuals);\n-\t\t\t\t\t       \n+  /* Clear the CLASSTYPE_PURE_VIRTUALS list; whatever is already there\n+     is going to be overridden.  */\n+  CLASSTYPE_PURE_VIRTUALS (type) = NULL_TREE;\n+  /* Find all the primary bases.  */\n+  mark_primary_bases (type);\n+  /* Now, run through all the bases which are not primary bases, and\n+     collect the pure virtual functions.  We look at the vtable in\n+     each class to determine what pure virtual functions are present.\n+     (A primary base is not interesting because the derived class of\n+     which it is a primary base will contain vtable entries for the\n+     pure virtuals in the base class.  */\n+  dfs_walk (TYPE_BINFO (type), dfs_get_pure_virtuals, markedp, type);\n+  /* Now, clear the BINFO_PRIMARY_MARKED_P bit.  */\n+  unmark_primary_bases (type);\n+  /* Put the pure virtuals in dfs order.  */\n+  CLASSTYPE_PURE_VIRTUALS (type) = nreverse (CLASSTYPE_PURE_VIRTUALS (type));\n+\n   for (vbases = CLASSTYPE_VBASECLASSES (type); vbases; vbases = TREE_CHAIN (vbases))\n     {\n-      tree virtuals;\n-\n-      virtuals = skip_rtti_stuff (vbases, BINFO_TYPE (vbases), NULL);\n+      tree virtuals = skip_rtti_stuff (vbases, BINFO_TYPE (vbases), NULL);\n \n       while (virtuals)\n \t{\n \t  tree base_fndecl = TREE_VALUE (virtuals);\n \t  if (DECL_NEEDS_FINAL_OVERRIDER_P (base_fndecl))\n \t    cp_error (\"`%#D' needs a final overrider\", base_fndecl);\n-\t  else if (DECL_PURE_VIRTUAL_P (base_fndecl))\n-\t    abstract_virtuals = tree_cons (NULL_TREE, base_fndecl, \n-\t\t\t\t\t   abstract_virtuals);\n \t  virtuals = TREE_CHAIN (virtuals);\n \t}\n     }\n-\n-  CLASSTYPE_PURE_VIRTUALS (type) = nreverse (abstract_virtuals);\n }\n \n static tree"}]}