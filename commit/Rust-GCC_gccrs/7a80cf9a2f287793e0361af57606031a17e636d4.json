{"sha": "7a80cf9a2f287793e0361af57606031a17e636d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E4MGNmOWEyZjI4Nzc5M2UwMzYxYWY1NzYwNjAzMWExN2U2MzZkNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-09-23T23:35:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-09-23T23:35:38Z"}, "message": "function.c (pop_function_context_from): var_refs_queue and temp slots now in GC memory.\n\n\t* function.c (pop_function_context_from): var_refs_queue\n\tand temp slots now in GC memory.\n\t(mark_function_status, free_after_compilation): Likewise;\n\talso struct function now in GC memory.\n\t(assign_stack_temp_for_type): struct temp_slot now in GC memory.\n\t(combine_temp_slots): Likewise.\n\t(schedule_fixup_var_refs): var_refs_queue now in GC memory.\n\t(prepare_function_start): Use GC memory for struct function.\n\t(mark_temp_slot): Deleted.\n\t(gcc_mark_struct_function): struct function now in GC memory.\n\nFrom-SVN: r45764", "tree": {"sha": "43575df8ec28d9792fbbda374cdb1ffd42cbd46d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43575df8ec28d9792fbbda374cdb1ffd42cbd46d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a80cf9a2f287793e0361af57606031a17e636d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a80cf9a2f287793e0361af57606031a17e636d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a80cf9a2f287793e0361af57606031a17e636d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a80cf9a2f287793e0361af57606031a17e636d4/comments", "author": null, "committer": null, "parents": [{"sha": "0629440fd84cd3db12f49084719ae0a7528d8833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0629440fd84cd3db12f49084719ae0a7528d8833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0629440fd84cd3db12f49084719ae0a7528d8833"}], "stats": {"total": 99, "additions": 44, "deletions": 55}, "files": [{"sha": "2508fa35115b28f5ac70f55cf7c3ed2926661aba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a80cf9a2f287793e0361af57606031a17e636d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a80cf9a2f287793e0361af57606031a17e636d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a80cf9a2f287793e0361af57606031a17e636d4", "patch": "@@ -1,5 +1,16 @@\n Sun Sep 23 18:19:48 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* function.c (pop_function_context_from): var_refs_queue\n+\tand temp slots now in GC memory.\n+\t(mark_function_status, free_after_compilation): Likewise;\n+\talso struct function now in GC memory.\n+\t(assign_stack_temp_for_type): struct temp_slot now in GC memory.\n+\t(combine_temp_slots): Likewise.\n+\t(schedule_fixup_var_refs): var_refs_queue now in GC memory.\n+\t(prepare_function_start): Use GC memory for struct function.\n+\t(mark_temp_slot): Deleted.\n+\t(gcc_mark_struct_function): struct function now in GC memory.\n+\n \t* fold-const.c (extract_muldiv, case PLUS_EXPR): Only adjust\n \tcode for division, not modulus.\n "}, {"sha": "46c0b8f832ec5f905e9bc851cebe4bc1d85d1671", "filename": "gcc/function.c", "status": "modified", "additions": 33, "deletions": 55, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a80cf9a2f287793e0361af57606031a17e636d4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a80cf9a2f287793e0361af57606031a17e636d4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=7a80cf9a2f287793e0361af57606031a17e636d4", "patch": "@@ -219,7 +219,8 @@ struct fixup_replacement\n   struct fixup_replacement *next;\n };\n \n-struct insns_for_mem_entry {\n+struct insns_for_mem_entry\n+{\n   /* The KEY in HE will be a MEM.  */\n   struct hash_entry he;\n   /* These are the INSNS which reference the MEM.  */\n@@ -300,7 +301,6 @@ static unsigned long insns_for_mem_hash PARAMS ((hash_table_key));\n static bool insns_for_mem_comp PARAMS ((hash_table_key, hash_table_key));\n static int insns_for_mem_walk   PARAMS ((rtx *, void *));\n static void compute_insns_for_mem PARAMS ((rtx, rtx, struct hash_table *));\n-static void mark_temp_slot PARAMS ((struct temp_slot *));\n static void mark_function_status PARAMS ((struct function *));\n static void maybe_mark_struct_function PARAMS ((void *));\n static void prepare_function_start PARAMS ((void));\n@@ -378,7 +378,6 @@ pop_function_context_from (context)\n {\n   struct function *p = outer_function_chain;\n   struct var_refs_queue *queue;\n-  struct var_refs_queue *next;\n \n   cfun = p;\n   outer_function_chain = p->outer;\n@@ -393,13 +392,10 @@ pop_function_context_from (context)\n \n   /* Finish doing put_var_into_stack for any of our variables\n      which became addressable during the nested function.  */\n-  for (queue = p->fixup_var_refs_queue; queue; queue = next)\n-    {\n-      next = queue->next;\n-      fixup_var_refs (queue->modified, queue->promoted_mode,\n-\t\t      queue->unsignedp, 0);\n-      free (queue);\n-    }\n+  for (queue = p->fixup_var_refs_queue; queue; queue = queue->next)\n+    fixup_var_refs (queue->modified, queue->promoted_mode,\n+\t\t    queue->unsignedp, 0);\n+\n   p->fixup_var_refs_queue = 0;\n \n   /* Reset variables that have known state during rtx generation.  */\n@@ -440,9 +436,6 @@ void\n free_after_compilation (f)\n      struct function *f;\n {\n-  struct temp_slot *ts;\n-  struct temp_slot *next;\n-\n   free_eh_status (f);\n   free_expr_status (f);\n   free_emit_status (f);\n@@ -454,13 +447,7 @@ free_after_compilation (f)\n   if (f->x_parm_reg_stack_loc)\n     free (f->x_parm_reg_stack_loc);\n \n-  for (ts = f->x_temp_slots; ts; ts = next)\n-    {\n-      next = ts->next;\n-      free (ts);\n-    }\n   f->x_temp_slots = NULL;\n-\n   f->arg_offset_rtx = NULL;\n   f->return_rtx = NULL;\n   f->internal_arg_pointer = NULL;\n@@ -487,8 +474,6 @@ free_after_compilation (f)\n   f->original_decl_initial = NULL;\n   f->inl_last_parm_insn = NULL;\n   f->epilogue_delay_list = NULL;\n-\n-  free (f);\n }\n \f\n /* Allocate fixed slots in the stack frame of the current function.  */\n@@ -701,7 +686,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n \n \t  if (best_p->size - rounded_size >= alignment)\n \t    {\n-\t      p = (struct temp_slot *) xmalloc (sizeof (struct temp_slot));\n+\t      p = (struct temp_slot *) ggc_alloc (sizeof (struct temp_slot));\n \t      p->in_use = p->addr_taken = 0;\n \t      p->size = best_p->size - rounded_size;\n \t      p->base_offset = best_p->base_offset + rounded_size;\n@@ -732,7 +717,7 @@ assign_stack_temp_for_type (mode, size, keep, type)\n     {\n       HOST_WIDE_INT frame_offset_old = frame_offset;\n \n-      p = (struct temp_slot *) xmalloc (sizeof (struct temp_slot));\n+      p = (struct temp_slot *) ggc_alloc (sizeof (struct temp_slot));\n \n       /* We are passing an explicit alignment request to assign_stack_local.\n \t One side effect of that is assign_stack_local will not round SIZE\n@@ -936,10 +921,7 @@ combine_temp_slots ()\n \t      }\n \t    /* Either delete Q or advance past it.  */\n \t    if (delete_q)\n-\t      {\n-\t\tprev_q->next = q->next;\n-\t\tfree (q);\n-\t      }\n+\t      prev_q->next = q->next;\n \t    else\n \t      prev_q = q;\n \t  }\n@@ -1531,7 +1513,7 @@ schedule_fixup_var_refs (function, reg, type, promoted_mode, ht)\n       struct var_refs_queue *temp;\n \n       temp\n-\t= (struct var_refs_queue *) xmalloc (sizeof (struct var_refs_queue));\n+\t= (struct var_refs_queue *) ggc_alloc (sizeof (struct var_refs_queue));\n       temp->modified = reg;\n       temp->promoted_mode = promoted_mode;\n       temp->unsignedp = unsigned_p;\n@@ -1674,6 +1656,7 @@ fixup_var_refs_insns (insn, var, promoted_mode, unsignedp, toplevel)\n    N.B. No need for special processing of CALL_PLACEHOLDERs here,\n    because the hash table will point straight to the interesting insn\n    (inside the CALL_PLACEHOLDER).  */\n+\n static void\n fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp)\n      struct hash_table *ht;\n@@ -1702,6 +1685,7 @@ fixup_var_refs_insns_with_hash (ht, var, promoted_mode, unsignedp)\n    references to, PROMOTED_MODE and UNSIGNEDP describe VAR, and\n    TOPLEVEL is nonzero if this is the main insn chain for this\n    function.  */\n+\n static void\n fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel)\n      rtx insn;\n@@ -3268,7 +3252,8 @@ insns_for_mem_comp (k1, k2)\n   return k1 == k2;\n }\n \n-struct insns_for_mem_walk_info {\n+struct insns_for_mem_walk_info\n+{\n   /* The hash table that we are using to record which INSNs use which\n      MEMs.  */\n   struct hash_table *ht;\n@@ -6079,10 +6064,11 @@ number_blocks (fn)\n }\n \f\n /* Allocate a function structure and reset its contents to the defaults.  */\n+\n static void\n prepare_function_start ()\n {\n-  cfun = (struct function *) xcalloc (1, sizeof (struct function));\n+  cfun = (struct function *) ggc_alloc_cleared (sizeof (struct function));\n \n   init_stmt_for_function ();\n   init_eh_for_function ();\n@@ -7583,29 +7569,14 @@ reposition_prologue_and_epilogue_notes (f)\n #endif /* HAVE_prologue or HAVE_epilogue */\n }\n \n-/* Mark T for GC.  */\n-\n-static void\n-mark_temp_slot (t)\n-     struct temp_slot *t;\n-{\n-  while (t)\n-    {\n-      ggc_mark_rtx (t->slot);\n-      ggc_mark_rtx (t->address);\n-      ggc_mark_tree (t->rtl_expr);\n-      ggc_mark_tree (t->type);\n-\n-      t = t->next;\n-    }\n-}\n-\n /* Mark P for GC.  */\n \n static void\n mark_function_status (p)\n      struct function *p;\n {\n+  struct var_refs_queue *q;\n+  struct temp_slot *t;\n   int i;\n   rtx *r;\n \n@@ -7636,16 +7607,20 @@ mark_function_status (p)\n   ggc_mark_rtx (p->epilogue_delay_list);\n   ggc_mark_rtx (p->x_clobber_return_insn);\n \n-  mark_temp_slot (p->x_temp_slots);\n+  for (t = p->x_temp_slots; t != 0; t = t->next)\n+    {\n+      ggc_mark (t);\n+      ggc_mark_rtx (t->slot);\n+      ggc_mark_rtx (t->address);\n+      ggc_mark_tree (t->rtl_expr);\n+      ggc_mark_tree (t->type);\n+    }\n \n-  {\n-    struct var_refs_queue *q = p->fixup_var_refs_queue;\n-    while (q)\n-      {\n-\tggc_mark_rtx (q->modified);\n-\tq = q->next;\n+  for (q = p->fixup_var_refs_queue; q != 0; q = q->next)\n+    {\n+      ggc_mark (q);\n+      ggc_mark_rtx (q->modified);\n       }\n-  }\n \n   ggc_mark_rtx (p->x_nonlocal_goto_handler_slots);\n   ggc_mark_rtx (p->x_nonlocal_goto_handler_labels);\n@@ -7658,6 +7633,7 @@ mark_function_status (p)\n /* Mark the struct function pointed to by *ARG for GC, if it is not\n    NULL.  This is used to mark the current function and the outer\n    function chain.  */\n+\n static void\n maybe_mark_struct_function (arg)\n      void *arg;\n@@ -7671,10 +7647,12 @@ maybe_mark_struct_function (arg)\n }\n \n /* Mark a struct function * for GC.  This is called from ggc-common.c.  */\n+\n void\n ggc_mark_struct_function (f)\n      struct function *f;\n {\n+  ggc_mark (f);\n   ggc_mark_tree (f->decl);\n \n   mark_function_status (f);"}]}