{"sha": "68c23af0dd7403c95c43310edc15669d4dacb005", "node_id": "C_kwDOANBUbNoAKDY4YzIzYWYwZGQ3NDAzYzk1YzQzMzEwZWRjMTU2NjlkNGRhY2IwMDU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-02T19:16:37Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-02T19:16:37Z"}, "message": "libstdc++: Consistently use ::type when deriving from __and/or/not_\n\nNow that these internal type traits are (again) class templates, it's\nbetter to derive from the trait's ::type instead of from the trait\nitself, for sake of a shallower inheritance chain.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/tuple (tuple::_UseOtherCtor): Use ::type when\n\tderiving from __and_, __or_ or __not_.\n\t* include/std/type_traits (negation): Likewise.\n\t(is_unsigned): Likewise.\n\t(__is_implicitly_default_constructible): Likewise.\n\t(is_trivially_destructible): Likewise.\n\t(__is_nt_invocable_impl): Likewise.", "tree": {"sha": "c9b7264916d8bda7f3214b67c098d1cbe25e0430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9b7264916d8bda7f3214b67c098d1cbe25e0430"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68c23af0dd7403c95c43310edc15669d4dacb005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68c23af0dd7403c95c43310edc15669d4dacb005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68c23af0dd7403c95c43310edc15669d4dacb005", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68c23af0dd7403c95c43310edc15669d4dacb005/comments", "author": null, "committer": null, "parents": [{"sha": "b6aa7d45b502c01f8703c8d2cee2690f9aa8e282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6aa7d45b502c01f8703c8d2cee2690f9aa8e282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6aa7d45b502c01f8703c8d2cee2690f9aa8e282"}], "stats": {"total": 12, "additions": 6, "deletions": 6}, "files": [{"sha": "26e248431ec0cab0064add4853cda3168c483740", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68c23af0dd7403c95c43310edc15669d4dacb005/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68c23af0dd7403c95c43310edc15669d4dacb005/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=68c23af0dd7403c95c43310edc15669d4dacb005", "patch": "@@ -826,7 +826,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // then TUPLE should match tuple(UTypes&&...) instead.\n       template<typename _Tuple, typename _Tp, typename _Up>\n \tstruct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>\n-\t: __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>\n+\t: __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>::type\n \t{ };\n       // If TUPLE and *this each have a single element of the same type,\n       // then TUPLE should match a copy/move constructor instead."}, {"sha": "c7a96079ebf4a4135f9bf6236b2d976258e832f9", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68c23af0dd7403c95c43310edc15669d4dacb005/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68c23af0dd7403c95c43310edc15669d4dacb005/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=68c23af0dd7403c95c43310edc15669d4dacb005", "patch": "@@ -235,7 +235,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Pp>\n     struct negation\n-    : __not_<_Pp>\n+    : __not_<_Pp>::type\n     { };\n \n   /** @ingroup variable_templates\n@@ -845,7 +845,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// is_unsigned\n   template<typename _Tp>\n     struct is_unsigned\n-    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>\n+    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type\n     { };\n \n   /// @cond undocumented\n@@ -1222,7 +1222,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template <typename _Tp>\n     struct __is_implicitly_default_constructible\n     : public __and_<__is_constructible_impl<_Tp>,\n-\t\t    __is_implicitly_default_constructible_safe<_Tp>>\n+\t\t    __is_implicitly_default_constructible_safe<_Tp>>::type\n     { };\n \n   /// is_trivially_copy_constructible\n@@ -1282,7 +1282,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct is_trivially_destructible\n     : public __and_<__is_destructible_safe<_Tp>,\n-\t\t    __bool_constant<__has_trivial_destructor(_Tp)>>\n+\t\t    __bool_constant<__has_trivial_destructor(_Tp)>>::type\n     {\n       static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),\n \t\"template argument must be a complete class or an unbounded array\");\n@@ -2975,7 +2975,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __is_nt_invocable_impl<_Result, _Ret,\n \t\t\t\t  __void_t<typename _Result::type>>\n     : __or_<is_void<_Ret>,\n-\t    __is_nothrow_convertible<typename _Result::type, _Ret>>\n+\t    __is_nothrow_convertible<typename _Result::type, _Ret>>::type\n     { };\n   /// @endcond\n "}]}