{"sha": "c70f6ed31478e27420d2038d09f3a343422db22f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcwZjZlZDMxNDc4ZTI3NDIwZDIwMzhkMDlmM2EzNDM0MjJkYjIyZg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-07T06:26:32Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-07T06:26:32Z"}, "message": "cpptrad.c (struct block, [...]): New.\n\n\t* cpptrad.c (struct block, BLOCK_HEADER_LEN, BLOCK_LEN,\n\tscan_parameters, save_replacement_text, replacement_length): New.\n\t(scan_out_logical_line): Take a macro and save parameters if\n\tnon-NULL.\n\t(_cpp_logical_line_trad): Update.\n\t(_cpp_create_trad_definition): Update to handle function-like\n\tmacros.\n\t* cpplex.c (new_buff): Update.\n\t(struct dummy, DEFAULT_ALIGNMENT, CPP_ALIGN): Move...\n\t* cpphash.h: ...here.\n\t(CPP_ALIGN2, _cpp_save_parameter): New.\n\t* cppmacro.c (save_parameter): Rename, export.\n\t(parse_params): Update.\n\nFrom-SVN: r54331", "tree": {"sha": "6aed42053a56ed0593bc263de6125d7efc67c493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6aed42053a56ed0593bc263de6125d7efc67c493"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c70f6ed31478e27420d2038d09f3a343422db22f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c70f6ed31478e27420d2038d09f3a343422db22f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c70f6ed31478e27420d2038d09f3a343422db22f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c70f6ed31478e27420d2038d09f3a343422db22f/comments", "author": null, "committer": null, "parents": [{"sha": "aec2ac46a748e1d224db7cf7ce05a4516918c8ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aec2ac46a748e1d224db7cf7ce05a4516918c8ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aec2ac46a748e1d224db7cf7ce05a4516918c8ff"}], "stats": {"total": 299, "additions": 246, "deletions": 53}, "files": [{"sha": "239331c174d521bb1e7f852b1d1ddd8a8fb43a62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c70f6ed31478e27420d2038d09f3a343422db22f", "patch": "@@ -1,3 +1,19 @@\n+2002-06-07  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpptrad.c (struct block, BLOCK_HEADER_LEN, BLOCK_LEN,\n+\tscan_parameters, save_replacement_text, replacement_length): New.\n+\t(scan_out_logical_line): Take a macro and save parameters if\n+\tnon-NULL.\n+\t(_cpp_logical_line_trad): Update.\n+\t(_cpp_create_trad_definition): Update to handle function-like\n+\tmacros.\n+\t* cpplex.c (new_buff): Update.\n+\t(struct dummy, DEFAULT_ALIGNMENT, CPP_ALIGN): Move...\n+\t* cpphash.h: ...here.\n+\t(CPP_ALIGN2, _cpp_save_parameter): New.\n+\t* cppmacro.c (save_parameter): Rename, export.\n+\t(parse_params): Update.\n+\n 2002-06-07  Andreas Jaeger  <aj@suse.de>\n \n \t* config/mmix/mmix.c: Remove extra broken prototype for"}, {"sha": "38ba244769a876b3145fa83f94d9dabc1aa88a77", "filename": "gcc/cpphash.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=c70f6ed31478e27420d2038d09f3a343422db22f", "patch": "@@ -50,6 +50,21 @@ typedef unsigned char uchar;\n    efficiency, and partly to limit runaway recursion.  */\n #define CPP_STACK_MAX 200\n \n+/* Host alignment handling.  */\n+struct dummy\n+{\n+  char c;\n+  union\n+  {\n+    double d;\n+    int *p;\n+  } u;\n+};\n+\n+#define DEFAULT_ALIGNMENT offsetof (struct dummy, u)\n+#define CPP_ALIGN2(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n+#define CPP_ALIGN(size) CPP_ALIGN2 (size, DEFAULT_ALIGNMENT)\n+\n /* Each macro definition is recorded in a cpp_macro structure.\n    Variadic macros cannot occur with traditional cpp.  */\n struct cpp_macro\n@@ -428,7 +443,8 @@ extern bool _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_pop_context\t\tPARAMS ((cpp_reader *));\n extern void _cpp_push_text_context\tPARAMS ((cpp_reader *, cpp_hashnode *,\n \t\t\t\t\t\t const uchar *, const uchar*));\n-extern bool _cpp_create_trad_definition PARAMS ((cpp_reader *, cpp_macro *));\n+extern bool _cpp_save_parameter\t\tPARAMS ((cpp_reader *, cpp_macro *,\n+\t\t\t\t\t\t cpp_hashnode *));\n \n /* In cpphash.c */\n extern void _cpp_init_hashtable\t\tPARAMS ((cpp_reader *, hash_table *));\n@@ -483,6 +499,7 @@ extern void _cpp_overlay_buffer PARAMS ((cpp_reader *pfile, const uchar *,\n \t\t\t\t\t size_t));\n extern cpp_hashnode *_cpp_lex_identifier_trad PARAMS ((cpp_reader *));\n extern void _cpp_set_trad_context PARAMS ((cpp_reader *));\n+extern bool _cpp_create_trad_definition PARAMS ((cpp_reader *, cpp_macro *));\n \n /* Utility routines and macros.  */\n #define DSC(str) (const uchar *)str, sizeof str - 1"}, {"sha": "0dd9d22ec65629ae1e34da198ebb5c014e584e42", "filename": "gcc/cpplex.c", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=c70f6ed31478e27420d2038d09f3a343422db22f", "patch": "@@ -2011,19 +2011,6 @@ cpp_interpret_charconst (pfile, token, pchars_seen, unsignedp)\n   #error BUFF_SIZE_UPPER_BOUND must be at least as large as MIN_BUFF_SIZE!\n #endif\n \n-struct dummy\n-{\n-  char c;\n-  union\n-  {\n-    double d;\n-    int *p;\n-  } u;\n-};\n-\n-#define DEFAULT_ALIGNMENT (offsetof (struct dummy, u))\n-#define CPP_ALIGN(size, align) (((size) + ((align) - 1)) & ~((align) - 1))\n-\n /* Create a new allocation buffer.  Place the control block at the end\n    of the buffer, so that buffer overflows will cause immediate chaos.  */\n static _cpp_buff *\n@@ -2035,7 +2022,7 @@ new_buff (len)\n \n   if (len < MIN_BUFF_SIZE)\n     len = MIN_BUFF_SIZE;\n-  len = CPP_ALIGN (len, DEFAULT_ALIGNMENT);\n+  len = CPP_ALIGN (len);\n \n   base = xmalloc (len + sizeof (_cpp_buff));\n   result = (_cpp_buff *) (base + len);"}, {"sha": "5e954d457e0a8bc6a3325f546904891eda919d90", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=c70f6ed31478e27420d2038d09f3a343422db22f", "patch": "@@ -70,7 +70,6 @@ static cpp_token *alloc_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n static cpp_token *lex_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n static bool warn_of_redefinition PARAMS ((cpp_reader *, const cpp_hashnode *,\n \t\t\t\t\t  const cpp_macro *));\n-static int save_parameter PARAMS ((cpp_reader *, cpp_macro *, cpp_hashnode *));\n static int parse_params PARAMS ((cpp_reader *, cpp_macro *));\n static void check_trad_stringification PARAMS ((cpp_reader *,\n \t\t\t\t\t\tconst cpp_macro *,\n@@ -1197,8 +1196,8 @@ _cpp_free_definition (h)\n \n /* Save parameter NODE to the parameter list of macro MACRO.  Returns\n    zero on success, non-zero if the parameter is a duplicate.  */\n-static int\n-save_parameter (pfile, macro, node)\n+bool\n+_cpp_save_parameter (pfile, macro, node)\n      cpp_reader *pfile;\n      cpp_macro *macro;\n      cpp_hashnode *node;\n@@ -1255,7 +1254,7 @@ parse_params (pfile, macro)\n \t    }\n \t  prev_ident = 1;\n \n-\t  if (save_parameter (pfile, macro, token->val.node))\n+\t  if (_cpp_save_parameter (pfile, macro, token->val.node))\n \t    return 0;\n \t  continue;\n \n@@ -1277,7 +1276,8 @@ parse_params (pfile, macro)\n \t  macro->variadic = 1;\n \t  if (!prev_ident)\n \t    {\n-\t      save_parameter (pfile, macro, pfile->spec_nodes.n__VA_ARGS__);\n+\t      _cpp_save_parameter (pfile, macro,\n+\t\t\t\t   pfile->spec_nodes.n__VA_ARGS__);\n \t      pfile->state.va_args_ok = 1;\n \t      if (! CPP_OPTION (pfile, c99) && CPP_OPTION (pfile, pedantic))\n \t\tcpp_error (pfile, DL_PEDWARN,"}, {"sha": "3886b4522c7e90266446f7f18d0ee775b8b4cc5e", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 206, "deletions": 33, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c70f6ed31478e27420d2038d09f3a343422db22f/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=c70f6ed31478e27420d2038d09f3a343422db22f", "patch": "@@ -21,6 +21,29 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n+/* The replacement text of a function-like macro is stored as a\n+   contiguous sequence of aligned blocks.  Each block represents the\n+   portion of text from the start of the previous block (or the start\n+   of the macro replacement text in the case of the first block) to\n+   the next parameter, or the end of the replacement list if there\n+   are none left.\n+\n+   Each block consists of an unsigned int, which is the length of text\n+   contained in the third part, an unsigned short, which is the\n+   one-based index of the argument that immediately follows that text,\n+   and the text itself.  The final block in the macro expansion is\n+   recognizable as it has an argument index of zero.  */\n+\n+struct block\n+{\n+  unsigned int text_len;\n+  unsigned short arg_index;\n+  uchar text[1];\n+};\n+\n+#define BLOCK_HEADER_LEN offsetof (struct block, text)\n+#define BLOCK_LEN(TEXT_LEN) CPP_ALIGN (BLOCK_HEADER_LEN + TEXT_LEN)\n+\n /* Lexing TODO: Handle -C, maybe -CC, and space in escaped newlines.\n    Stop cpplex.c from recognizing comments and directives during its\n    lexing pass.  Get rid of line_base usage - seems pointless?  Do we\n@@ -32,10 +55,14 @@ static const uchar *skip_escaped_newlines PARAMS ((cpp_reader *,\n static const uchar *skip_whitespace PARAMS ((cpp_reader *, const uchar *));\n static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n static const uchar *skip_comment PARAMS ((cpp_reader *, const uchar *));\n-static void scan_out_logical_line PARAMS ((cpp_reader *pfile));\n+static void scan_out_logical_line PARAMS ((cpp_reader *pfile, cpp_macro *));\n static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n static void restore_buff PARAMS ((cpp_reader *));\n static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n+static bool scan_parameters PARAMS ((cpp_reader *, cpp_macro *));\n+static void save_replacement_text PARAMS ((cpp_reader *, cpp_macro *,\n+\t\t\t\t\t   unsigned int));\n+static unsigned int replacement_length PARAMS ((cpp_macro *));\n \n /* Ensures we have N bytes' space in the output buffer, and\n    reallocates it if not.  */\n@@ -272,7 +299,7 @@ _cpp_read_logical_line_trad (pfile)\n   CUR (pfile->context) = buffer->cur;\n   RLIMIT (pfile->context) = buffer->rlimit;\n   pfile->trad_out_cur = pfile->trad_out_base;\n-  scan_out_logical_line (pfile);\n+  scan_out_logical_line (pfile, NULL);\n   buffer->cur = CUR (pfile->context);\n \n   pfile->trad_line = pfile->line;\n@@ -284,10 +311,15 @@ _cpp_read_logical_line_trad (pfile)\n \n /* Copies the next logical line in the current buffer to the output\n    buffer.  The output is guaranteed to terminate with a NUL\n-   character.  */\n+   character.\n+\n+   If MACRO is non-NULL, then we are scanning the replacement list of\n+   MACRO, and we call save_replacement_text every time we meet an\n+   argument.  */\n static void\n-scan_out_logical_line (pfile)\n+scan_out_logical_line (pfile, macro)\n      cpp_reader *pfile;\n+     cpp_macro *macro;\n {\n   cpp_context *context;\n   const uchar *cur;\n@@ -379,21 +411,30 @@ scan_out_logical_line (pfile)\n \tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n \tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n \tcase 'Y': case 'Z':\n-\t  {\n-\t    cpp_hashnode *node;\n-\n-\t    pfile->trad_out_cur = --out;\n-\t    node = lex_identifier (pfile, cur - 1);\n-\t    if (node->type == NT_MACRO)\n-\t      {\n-\t\t/* Remove the macro name from the output.  */\n-\t\tpfile->trad_out_cur = out;\n-\t\tpush_replacement_text (pfile, node);\n-\t\tgoto new_context;\n-\t      }\n-\t    out = pfile->trad_out_cur;\n-\t    cur = CUR (context);\n-\t  }\n+\t  if (quote == 0 || macro)\n+\t    {\n+\t      cpp_hashnode *node;\n+\n+\t      pfile->trad_out_cur = --out;\n+\t      node = lex_identifier (pfile, cur - 1);\n+\n+\t      if (node->type == NT_MACRO && !pfile->state.prevent_expansion)\n+\t\t{\n+\t\t  /* Remove the macro name from the output.  */\n+\t\t  pfile->trad_out_cur = out;\n+\t\t  push_replacement_text (pfile, node);\n+\t\t  goto new_context;\n+\t\t}\n+\t      else if (macro && node->arg_index)\n+\t\t{\n+\t\t  /* Remove the macro name from the output.  */\n+\t\t  pfile->trad_out_cur = out;\n+\t\t  save_replacement_text (pfile, macro, node->arg_index);\n+\t\t}\n+\n+\t      out = pfile->trad_out_cur;\n+\t      cur = CUR (context);\n+\t    }\n \t  break;\n \n \tdefault:\n@@ -417,36 +458,168 @@ push_replacement_text (pfile, node)\n \t\t\t  macro->exp.text + macro->count);\n }\n \n-/* Analyze and save the replacement text of a macro.  */\n+/* Read and record the parameters, if any, of a function-like macro\n+   definition.  Destroys pfile->trad_out_cur.\n+\n+   Returns true on success, false on failure (syntax error or a\n+   duplicate parameter).  On success, CUR (pfile->context) is just\n+   past the closing parenthesis.  */\n+static bool\n+scan_parameters (pfile, macro)\n+     cpp_reader *pfile;\n+     cpp_macro *macro;\n+{\n+  const uchar *cur = CUR (pfile->context) + 1;\n+  bool ok;\n+\n+  for (;;)\n+    {\n+      cur = skip_whitespace (pfile, cur);\n+\n+      if (ISIDST (*cur))\n+\t{\n+\t  ok = false;\n+\t  if (_cpp_save_parameter (pfile, macro, lex_identifier (pfile, cur)))\n+\t    break;\n+\t  cur = skip_whitespace (pfile, CUR (pfile->context));\n+\t  if (*cur == ',')\n+\t    {\n+\t      cur++;\n+\t      continue;\n+\t    }\n+\t  ok = (*cur == ')');\n+\t  break;\n+\t}\n+\n+      ok = (*cur == ')' && macro->paramc == 0);\n+      break;\n+    }\n+\n+  CUR (pfile->context) = cur + (*cur == ')');\n+\n+  return ok;\n+}\n+\n+/* Calculate the length of the replacement text of MACRO.  */\n+static unsigned int\n+replacement_length (macro)\n+     cpp_macro *macro;\n+{\n+  unsigned int result = 0;\n+  const uchar *exp = macro->exp.text;\n+\n+  for (;;)\n+    {\n+      struct block *block = (struct block *) exp;\n+\n+      result += block->text_len;\n+      if (block->arg_index == 0)\n+\treturn result;\n+      exp += BLOCK_LEN (block->text_len);\n+    }\n+}\n+\n+/* Save the text from pfile->trad_out_base to pfile->trad_out_cur as\n+   the replacement text for the current macro, followed by argument\n+   ARG_INDEX, with zero indicating the end of the replacement\n+   text.  */\n+static void\n+save_replacement_text (pfile, macro, arg_index)\n+     cpp_reader *pfile;\n+     cpp_macro *macro;\n+     unsigned int arg_index;\n+{\n+  size_t len = pfile->trad_out_cur - pfile->trad_out_base;\n+  uchar *exp;\n+\n+  if (macro->paramc == 0)\n+    {\n+      /* Object-like and function-like macros without parameters\n+\t simply store their NUL-terminated replacement text.  */\n+      exp = _cpp_unaligned_alloc (pfile, len + 1);\n+      memcpy (exp, pfile->trad_out_base, len);\n+      exp[len] = '\\0';\n+      macro->exp.text = exp;\n+      macro->count = len;\n+    }\n+  else\n+    {\n+      /* Store the text's length (unsigned int), the argument index\n+\t (unsigned short, base 1) and then the text.  */\n+      size_t blen = BLOCK_LEN (len);\n+      struct block *block;\n+\n+      if (macro->count + blen > BUFF_ROOM (pfile->a_buff))\n+\t_cpp_extend_buff (pfile, &pfile->a_buff, macro->count + blen);\n+\n+      exp = BUFF_FRONT (pfile->a_buff);\n+      block = (struct block *) (exp + macro->count);\n+      macro->exp.text = exp;\n+\n+      /* Write out the block information.  */\n+      block->text_len = len;\n+      block->arg_index = arg_index;\n+      memcpy (block->text, pfile->trad_out_base, len);\n+\n+      /* Lex the rest into the start of the output buffer.  */\n+      pfile->trad_out_cur = pfile->trad_out_base;\n+\n+      /* If this is the end of the macro, count up the bytes of text\n+\t in the replacement list, excluding the parameter names, and\n+\t save this in macro->count, else store the total bytes in the\n+\t replacement text so far (including block headers).  */\n+      if (arg_index == 0)\n+\tmacro->count = replacement_length (macro);\n+      else\n+\tmacro->count += blen;\n+    }\n+}\n+\n+/* Analyze and save the replacement text of a macro.  Returns true on\n+   success.  */\n bool\n _cpp_create_trad_definition (pfile, macro)\n      cpp_reader *pfile;\n      cpp_macro *macro;\n {\n-  const uchar *cur, *limit;\n-  uchar *exp;\n-  size_t len;\n+  const uchar *cur;\n+  uchar *limit;\n \n   /* Skip leading whitespace now.  */\n   CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n \n+  /* Is this a function-like macro?  */\n+  if (* CUR (pfile->context) == '(')\n+    {\n+      /* Setting macro to NULL indicates an error occurred.  */\n+      if (!scan_parameters (pfile, macro))\n+\tmacro = NULL;\n+      else\n+\t{\n+\t  /* Success.  Commit the parameter array.  */\n+\t  macro->params = (cpp_hashnode **) BUFF_FRONT (pfile->a_buff);\n+\t  BUFF_FRONT (pfile->a_buff) = (uchar *) &macro->params[macro->paramc];\n+\t  macro->fun_like = 1;\n+\t}\n+\n+      CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n+    }\n+\n   pfile->trad_out_cur = pfile->trad_out_base;\n-  scan_out_logical_line (pfile);\n+  pfile->state.prevent_expansion++;\n+  scan_out_logical_line (pfile, macro);\n+  pfile->state.prevent_expansion--;\n+\n+  if (!macro)\n+    return false;\n \n   /* Skip trailing white space.  */\n   cur = pfile->trad_out_base;\n   limit = pfile->trad_out_cur;\n   while (limit > cur && is_space (limit[-1]))\n     limit--;\n-\n-  len = (size_t) (limit - cur);\n-  exp = _cpp_unaligned_alloc (pfile, len + 1);\n-  memcpy (exp, cur, len);\n-  exp[len] = '\\0';\n-\n-  macro->exp.text = exp;\n-  /* Include NUL.  */\n-  macro->count = len;\n+  pfile->trad_out_cur = limit;\n+  save_replacement_text (pfile, macro, 0);\n \n   return true;\n }"}]}