{"sha": "0d12220fa33e53380cc1c1f8b764131a10360e8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQxMjIyMGZhMzNlNTMzODBjYzFjMWY4Yjc2NDEzMWExMDM2MGU4Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-03-29T10:07:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-03-29T10:07:09Z"}, "message": "dwarf2out.c (dw_loc_list_node): Add resolved_addr and replaced.\n\ngcc/\n\t* dwarf2out.c (dw_loc_list_node): Add resolved_addr and replaced.\n\t(cached_dw_loc_list_def): New structure.\n\t(cached_dw_loc_list): New typedef.\n\t(cached_dw_loc_list_table): New variable.\n\t(cached_dw_loc_list_table_hash): New function.\n\t(cached_dw_loc_list_table_eq): Likewise.\n\t(add_location_or_const_value_attribute): Take a bool cache_p.\n\tCache the list when the parameter is true.\n\t(gen_formal_parameter_die): Update caller.\n\t(gen_variable_die): Likewise.\n\t(dwarf2out_finish): Likewise.\n\t(dwarf2out_abstract_function): Nullify cached_dw_loc_list_table\n\twhile generating debug info for the decl.\n\t(dwarf2out_function_decl): Clear cached_dw_loc_list_table.\n\t(dwarf2out_init): Initialize cached_dw_loc_list_table.\n\t(resolve_addr): Cache the result of resolving a chain of\n\tlocation lists.\n\nFrom-SVN: r171655", "tree": {"sha": "6002dc961796529c0c447c72e9a04a2c8485c5c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6002dc961796529c0c447c72e9a04a2c8485c5c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d12220fa33e53380cc1c1f8b764131a10360e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d12220fa33e53380cc1c1f8b764131a10360e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d12220fa33e53380cc1c1f8b764131a10360e8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d12220fa33e53380cc1c1f8b764131a10360e8f/comments", "author": null, "committer": null, "parents": [{"sha": "d91909c0133554d00379f0ef41fe2d2ff6ab9968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91909c0133554d00379f0ef41fe2d2ff6ab9968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91909c0133554d00379f0ef41fe2d2ff6ab9968"}], "stats": {"total": 160, "additions": 141, "deletions": 19}, "files": [{"sha": "df8f78a53d87fbb23f38e785cb81f5570dc1bc40", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d12220fa33e53380cc1c1f8b764131a10360e8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d12220fa33e53380cc1c1f8b764131a10360e8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d12220fa33e53380cc1c1f8b764131a10360e8f", "patch": "@@ -1,3 +1,23 @@\n+2011-03-29  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* dwarf2out.c (dw_loc_list_node): Add resolved_addr and replaced.\n+\t(cached_dw_loc_list_def): New structure.\n+\t(cached_dw_loc_list): New typedef.\n+\t(cached_dw_loc_list_table): New variable.\n+\t(cached_dw_loc_list_table_hash): New function.\n+\t(cached_dw_loc_list_table_eq): Likewise.\n+\t(add_location_or_const_value_attribute): Take a bool cache_p.\n+\tCache the list when the parameter is true.\n+\t(gen_formal_parameter_die): Update caller.\n+\t(gen_variable_die): Likewise.\n+\t(dwarf2out_finish): Likewise.\n+\t(dwarf2out_abstract_function): Nullify cached_dw_loc_list_table\n+\twhile generating debug info for the decl.\n+\t(dwarf2out_function_decl): Clear cached_dw_loc_list_table.\n+\t(dwarf2out_init): Initialize cached_dw_loc_list_table.\n+\t(resolve_addr): Cache the result of resolving a chain of\n+\tlocation lists.\n+\n 2011-03-28  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* ira-color.c (update_left_conflict_sizes_p): Don't assume that"}, {"sha": "efd30eaf9d85cd73ccab4682a54219d8741b6357", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 121, "deletions": 19, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d12220fa33e53380cc1c1f8b764131a10360e8f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d12220fa33e53380cc1c1f8b764131a10360e8f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=0d12220fa33e53380cc1c1f8b764131a10360e8f", "patch": "@@ -4430,6 +4430,11 @@ typedef struct GTY(()) dw_loc_list_struct {\n   const char *section; /* Section this loclist is relative to */\n   dw_loc_descr_ref expr;\n   hashval_t hash;\n+  /* True if all addresses in this and subsequent lists are known to be\n+     resolved.  */\n+  bool resolved_addr;\n+  /* True if this list has been replaced by dw_loc_next.  */\n+  bool replaced;\n   bool emitted;\n } dw_loc_list_node;\n \n@@ -6122,6 +6127,19 @@ static int tail_call_site_count = -1;\n    DIEs.  */\n static VEC (dw_die_ref, heap) *block_map;\n \n+/* A cached location list.  */\n+struct GTY (()) cached_dw_loc_list_def {\n+  /* The DECL_UID of the decl that this entry describes.  */\n+  unsigned int decl_id;\n+\n+  /* The cached location list.  */\n+  dw_loc_list_ref loc_list;\n+};\n+typedef struct cached_dw_loc_list_def cached_dw_loc_list;\n+\n+/* Table of cached location lists.  */\n+static GTY ((param_is (cached_dw_loc_list))) htab_t cached_dw_loc_list_table;\n+\n /* A pointer to the base of a list of references to DIE's that\n    are uniquely identified by their tag, presence/absence of\n    children DIE's, and list of attribute/value pairs.  */\n@@ -6433,7 +6451,7 @@ static void insert_int (HOST_WIDE_INT, unsigned, unsigned char *);\n static void insert_double (double_int, unsigned char *);\n static void insert_float (const_rtx, unsigned char *);\n static rtx rtl_for_decl_location (tree);\n-static bool add_location_or_const_value_attribute (dw_die_ref, tree,\n+static bool add_location_or_const_value_attribute (dw_die_ref, tree, bool,\n \t\t\t\t\t\t   enum dwarf_attribute);\n static bool tree_add_const_value_attribute (dw_die_ref, tree);\n static bool tree_add_const_value_attribute_for_decl (dw_die_ref, tree);\n@@ -8181,6 +8199,24 @@ lookup_decl_loc (const_tree decl)\n     htab_find_with_hash (decl_loc_table, decl, DECL_UID (decl));\n }\n \n+/* Returns a hash value for X (which really is a cached_dw_loc_list_list).  */\n+\n+static hashval_t\n+cached_dw_loc_list_table_hash (const void *x)\n+{\n+  return (hashval_t) ((const cached_dw_loc_list *) x)->decl_id;\n+}\n+\n+/* Return nonzero if decl_id of cached_dw_loc_list X is the same as\n+   UID of decl *Y.  */\n+\n+static int\n+cached_dw_loc_list_table_eq (const void *x, const void *y)\n+{\n+  return (((const cached_dw_loc_list *) x)->decl_id\n+\t  == DECL_UID ((const_tree) y));\n+}\n+\n /* Equate a DIE to a particular declaration.  */\n \n static void\n@@ -16894,15 +16930,22 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n    these things can crop up in other ways also.)  Note that one type of\n    constant value which can be passed into an inlined function is a constant\n    pointer.  This can happen for example if an actual argument in an inlined\n-   function call evaluates to a compile-time constant address.  */\n+   function call evaluates to a compile-time constant address.\n+\n+   CACHE_P is true if it is worth caching the location list for DECL,\n+   so that future calls can reuse it rather than regenerate it from scratch.\n+   This is true for BLOCK_NONLOCALIZED_VARS in inlined subroutines,\n+   since we will need to refer to them each time the function is inlined.  */\n \n static bool\n-add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n+add_location_or_const_value_attribute (dw_die_ref die, tree decl, bool cache_p,\n \t\t\t\t       enum dwarf_attribute attr)\n {\n   rtx rtl;\n   dw_loc_list_ref list;\n   var_loc_list *loc_list;\n+  cached_dw_loc_list *cache;\n+  void **slot;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return false;\n@@ -16939,7 +16982,33 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n \t  && add_const_value_attribute (die, rtl))\n \t return true;\n     }\n-  list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2);\n+  /* If this decl is from BLOCK_NONLOCALIZED_VARS, we might need its\n+     list several times.  See if we've already cached the contents.  */\n+  list = NULL;\n+  if (loc_list == NULL || cached_dw_loc_list_table == NULL)\n+    cache_p = false;\n+  if (cache_p)\n+    {\n+      cache = (cached_dw_loc_list *)\n+\thtab_find_with_hash (cached_dw_loc_list_table, decl, DECL_UID (decl));\n+      if (cache)\n+\tlist = cache->loc_list;\n+    }\n+  if (list == NULL)\n+    {\n+      list = loc_list_from_tree (decl, decl_by_reference_p (decl) ? 0 : 2);\n+      /* It is usually worth caching this result if the decl is from\n+\t BLOCK_NONLOCALIZED_VARS and if the list has at least two elements.  */\n+      if (cache_p && list && list->dw_loc_next)\n+\t{\n+\t  slot = htab_find_slot_with_hash (cached_dw_loc_list_table, decl,\n+\t\t\t\t\t   DECL_UID (decl), INSERT);\n+\t  cache = ggc_alloc_cleared_cached_dw_loc_list ();\n+\t  cache->decl_id = DECL_UID (decl);\n+\t  cache->loc_list = list;\n+\t  *slot = cache;\n+\t}\n+    }\n   if (list)\n     {\n       add_AT_location_description (die, attr, list);\n@@ -18637,7 +18706,7 @@ gen_formal_parameter_die (tree node, tree origin, bool emit_name_p,\n         equate_decl_number_to_die (node, parm_die);\n       if (! DECL_ABSTRACT (node_or_origin))\n \tadd_location_or_const_value_attribute (parm_die, node_or_origin,\n-\t\t\t\t\t       DW_AT_location);\n+\t\t\t\t\t       node == NULL, DW_AT_location);\n \n       break;\n \n@@ -18822,6 +18891,7 @@ dwarf2out_abstract_function (tree decl)\n   tree context;\n   int was_abstract;\n   htab_t old_decl_loc_table;\n+  htab_t old_cached_dw_loc_list_table;\n   int old_call_site_count, old_tail_call_site_count;\n   struct call_arg_loc_node *old_call_arg_locations;\n \n@@ -18838,6 +18908,8 @@ dwarf2out_abstract_function (tree decl)\n      get locations in abstract instantces.  */\n   old_decl_loc_table = decl_loc_table;\n   decl_loc_table = NULL;\n+  old_cached_dw_loc_list_table = cached_dw_loc_list_table;\n+  cached_dw_loc_list_table = NULL;\n   old_call_arg_locations = call_arg_locations;\n   call_arg_locations = NULL;\n   old_call_site_count = call_site_count;\n@@ -18868,6 +18940,7 @@ dwarf2out_abstract_function (tree decl)\n \n   current_function_decl = save_fn;\n   decl_loc_table = old_decl_loc_table;\n+  cached_dw_loc_list_table = old_cached_dw_loc_list_table;\n   call_arg_locations = old_call_arg_locations;\n   call_site_count = old_call_site_count;\n   tail_call_site_count = old_tail_call_site_count;\n@@ -19815,9 +19888,8 @@ gen_variable_die (tree decl, tree origin, dw_die_ref context_die)\n           && !TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl_or_origin)))\n \tdefer_location (decl_or_origin, var_die);\n       else\n-        add_location_or_const_value_attribute (var_die,\n-\t\t\t\t\t       decl_or_origin,\n-\t\t\t\t\t       DW_AT_location);\n+        add_location_or_const_value_attribute (var_die, decl_or_origin,\n+\t\t\t\t\t       decl == NULL, DW_AT_location);\n       add_pubname (decl_or_origin, var_die);\n     }\n   else\n@@ -21623,6 +21695,7 @@ dwarf2out_function_decl (tree decl)\n   tail_call_site_count = -1;\n   VEC_free (dw_die_ref, heap, block_map);\n   htab_empty (decl_loc_table);\n+  htab_empty (cached_dw_loc_list_table);\n }\n \n /* Output a marker (i.e. a label) for the beginning of the generated code for\n@@ -22291,6 +22364,11 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   decl_loc_table = htab_create_ggc (10, decl_loc_table_hash,\n \t\t\t\t    decl_loc_table_eq, NULL);\n \n+  /* Allocate the cached_dw_loc_list_table.  */\n+  cached_dw_loc_list_table\n+    = htab_create_ggc (10, cached_dw_loc_list_table_hash,\n+\t\t       cached_dw_loc_list_table_eq, NULL);\n+\n   /* Allocate the initial hunk of the decl_scope_table.  */\n   decl_scope_table = VEC_alloc (tree, gc, 256);\n \n@@ -22925,30 +23003,53 @@ resolve_addr (dw_die_ref die)\n {\n   dw_die_ref c;\n   dw_attr_ref a;\n-  dw_loc_list_ref *curr;\n+  dw_loc_list_ref *curr, *start, loc;\n   unsigned ix;\n \n   FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     switch (AT_class (a))\n       {\n       case dw_val_class_loc_list:\n-\tcurr = AT_loc_list_ptr (a);\n-\twhile (*curr)\n+\tstart = curr = AT_loc_list_ptr (a);\n+\tloc = *curr;\n+\tgcc_assert (loc);\n+\t/* The same list can be referenced more than once.  See if we have\n+\t   already recorded the result from a previous pass.  */\n+\tif (loc->replaced)\n+\t  *curr = loc->dw_loc_next;\n+\telse if (!loc->resolved_addr)\n \t  {\n-\t    if (!resolve_addr_in_expr ((*curr)->expr))\n+\t    /* As things stand, we do not expect or allow one die to\n+\t       reference a suffix of another die's location list chain.\n+\t       References must be identical or completely separate.\n+\t       There is therefore no need to cache the result of this\n+\t       pass on any list other than the first; doing so\n+\t       would lead to unnecessary writes.  */\n+\t    while (*curr)\n \t      {\n-\t\tdw_loc_list_ref next = (*curr)->dw_loc_next;\n-\t\tif (next && (*curr)->ll_symbol)\n+\t\tgcc_assert (!(*curr)->replaced && !(*curr)->resolved_addr);\n+\t\tif (!resolve_addr_in_expr ((*curr)->expr))\n \t\t  {\n-\t\t    gcc_assert (!next->ll_symbol);\n-\t\t    next->ll_symbol = (*curr)->ll_symbol;\n+\t\t    dw_loc_list_ref next = (*curr)->dw_loc_next;\n+\t\t    if (next && (*curr)->ll_symbol)\n+\t\t      {\n+\t\t\tgcc_assert (!next->ll_symbol);\n+\t\t\tnext->ll_symbol = (*curr)->ll_symbol;\n+\t\t      }\n+\t\t    *curr = next;\n \t\t  }\n-\t\t*curr = next;\n+\t\telse\n+\t\t  curr = &(*curr)->dw_loc_next;\n \t      }\n+\t    if (loc == *start)\n+\t      loc->resolved_addr = 1;\n \t    else\n-\t      curr = &(*curr)->dw_loc_next;\n+\t      {\n+\t\tloc->replaced = 1;\n+\t\tloc->dw_loc_next = *start;\n+\t      }\n \t  }\n-\tif (!AT_loc_list (a))\n+\tif (!*start)\n \t  {\n \t    remove_AT (die, a->dw_attr);\n \t    ix--;\n@@ -23404,6 +23505,7 @@ dwarf2out_finish (const char *filename)\n       add_location_or_const_value_attribute (\n         VEC_index (deferred_locations, deferred_locations_list, i)->die,\n         VEC_index (deferred_locations, deferred_locations_list, i)->variable,\n+\tfalse,\n \tDW_AT_location);\n     }\n "}]}