{"sha": "a1360f5702b28237af3c00a517492a8faf78f494", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEzNjBmNTcwMmIyODIzN2FmM2MwMGE1MTc0OTJhOGZhZjc4ZjQ5NA==", "commit": {"author": {"name": "Silvius Rus", "email": "rus@google.com", "date": "2010-01-10T08:25:23Z"}, "committer": {"name": "Silvius Rus", "email": "rus@gcc.gnu.org", "date": "2010-01-10T08:25:23Z"}, "message": "libstdc++ profile mode bug fixes and minor updates\n\nFrom-SVN: r155786", "tree": {"sha": "2ae0e898916516734c5d6bcf4385bc03d46207e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ae0e898916516734c5d6bcf4385bc03d46207e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1360f5702b28237af3c00a517492a8faf78f494", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1360f5702b28237af3c00a517492a8faf78f494", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1360f5702b28237af3c00a517492a8faf78f494", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1360f5702b28237af3c00a517492a8faf78f494/comments", "author": null, "committer": null, "parents": [{"sha": "9b2adcdbc12edf30eb4bedcff79f8f9050c7f29a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2adcdbc12edf30eb4bedcff79f8f9050c7f29a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2adcdbc12edf30eb4bedcff79f8f9050c7f29a"}], "stats": {"total": 5640, "additions": 2830, "deletions": 2810}, "files": [{"sha": "a45c73539b2a5804daff1bd27587d89131f690dd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -1,3 +1,37 @@\n+2010-01-10  Silvius Rus  <rus@google.com>\n+\n+\t* configure.ac: Add detection of execinfo.h.\n+\t* configure: Same.\n+\t* config.h.in: Same.\n+\t* doc/xml/manual/profile_mode.xml: Add list_to_slist manual.\n+\tAlso, correct user interface mistakes.\n+\t* include/Makefile.in: Add references to new include files.\n+\t* include/Makefile.am: Add references to new include files.\n+\t* include/backward/hash_map: Remove profile include.\n+\t* include/backward/hash_set: Remove profile include.\n+\t* include/profile/hashtable.h: Delete file.\n+\t* include/profile/iterator_tracker.h: New file.\n+\t* include/profile/vector: Add instrumentation for tracked iterator.\n+\t* include/profile/list: Same.\n+\t* include/profile/impl/profiler_list_to_slist.h: New file.\n+\t* include/profile/impl/profiler_list_to_vector.h: Same.\n+\t* include/profile/impl/profiler.h: Add list_to_slist and\n+\tlist_to_vector instrumentation hook interfaces.  Fixed broken\n+\tdiagnostic disabling mechanism.\n+\t(_GLIBCXX_PROFILE_DEFINE_DATA,_GLIBCXX_PROFILE_DATA) New macros.\n+\t(__reentrance_guard) Fix bug.\n+\t* include/profile/impl/profiler_trace.h: Replace dummy templates\n+\twith _GLIBCXX_PROFILE_DEFINE_DATA.\n+\t* include/profile/impl/profiler_container_size.h: Same.\n+\t* include/profile/impl/profiler_vector_size.h: Same.\n+\t* include/profile/impl/profiler_hash_func.h: Same.\n+\t* include/profile/impl/profiler_vector_to_list.h: Same.\n+\t* include/profile/impl/profiler_map_to_unordered_map.h: Same.\n+\t* include/profile/impl/profiler_hashtable_size.h: Same.\n+\t* include/profile/impl/profiler_node.h: Same.\n+\t* include/profile/impl/profiler_state.h: Same.  Also, remove\n+\tclass __state. Also, use __sync_val_compare_and_swap to set state.\n+\n 2010-01-09  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR other/42230"}, {"sha": "c39f423771e3f2587523500f76e4ad6e454177c8", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -66,6 +66,9 @@\n /* Define to 1 if you have the <endian.h> header file. */\n #undef HAVE_ENDIAN_H\n \n+/* Define to 1 if you have the <execinfo.h> header file. */\n+#undef HAVE_EXECINFO_H\n+\n /* Define if ENODATA exists. */\n #undef HAVE_ENODATA\n "}, {"sha": "2abdfc2451a48892aae92337085147ab5f99e492", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -19449,8 +19449,8 @@ fi\n \n \n # Check for available headers.\n-for ac_header in endian.h float.h fp.h ieeefp.h inttypes.h locale.h \\\n-machine/endian.h machine/param.h nan.h stdint.h stdlib.h string.h \\\n+for ac_header in endian.h execinfo.h float.h fp.h ieeefp.h inttypes.h \\\n+locale.h machine/endian.h machine/param.h nan.h stdint.h stdlib.h string.h \\\n strings.h sys/ipc.h sys/isa_defs.h sys/machine.h sys/param.h \\\n sys/resource.h sys/sem.h sys/stat.h sys/time.h sys/types.h unistd.h \\\n wchar.h wctype.h"}, {"sha": "0137f0a1c66adf08dc3964adbdf9bb7610b46de9", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -165,8 +165,8 @@ GLIBCXX_CHECK_GTHREADS\n AC_LC_MESSAGES\n \n # Check for available headers.\n-AC_CHECK_HEADERS([endian.h float.h fp.h ieeefp.h inttypes.h locale.h \\\n-machine/endian.h machine/param.h nan.h stdint.h stdlib.h string.h \\\n+AC_CHECK_HEADERS([endian.h execinfo.h float.h fp.h ieeefp.h inttypes.h \\\n+locale.h machine/endian.h machine/param.h nan.h stdint.h stdlib.h string.h \\\n strings.h sys/ipc.h sys/isa_defs.h sys/machine.h sys/param.h \\\n sys/resource.h sys/sem.h sys/stat.h sys/time.h sys/types.h unistd.h \\\n wchar.h wctype.h])"}, {"sha": "5396e15f4d299eafb0bd9ae718e77f91ad847102", "filename": "libstdc++-v3/doc/xml/manual/profile_mode.xml", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fprofile_mode.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fprofile_mode.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fprofile_mode.xml?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -134,14 +134,17 @@ vector-size: improvement = 3: call stack = 0x804842c ...\n   </itemizedlist>\n   </para>\n \n-  <para>Two files are generated.  <code>libstdcxx-profile.txt</code>\n+  <para>Three files are generated.  <code>libstdcxx-profile.txt</code>\n    contains human readable advice.  <code>libstdcxx-profile.raw</code>\n    contains implementation specific data about each diagnostic.\n    Their format is not documented.  They are sufficient to generate\n    all the advice given in <code>libstdcxx-profile.txt</code>.  The advantage\n    of keeping this raw format is that traces from multiple executions can\n    be aggregated simply by concatenating the raw traces.  We intend to\n    offer an external utility program that can issue advice from a trace.\n+   <code>libstdcxx-profile.conf.out</code> lists the actual diagnostic\n+   parameters used.  To alter parameters, edit this file and rename it to\n+   <code>libstdcxx-profile.conf</code>.\n   </para>\n \n   <para>Advice is given regardless whether the transformation is valid.\n@@ -163,19 +166,19 @@ vector-size: improvement = 3: call stack = 0x804842c ...\n    in the environment where the program is run, before starting execution.\n   <itemizedlist>\n   <listitem><para>\n-   <code>[NO]_GLIBCXX_PROFILE_&lt;diagnostic&gt;</code>:\n-   enable/disable specific diagnostics.\n+   <code>_GLIBCXX_PROFILE_NO_&lt;diagnostic&gt;</code>:\n+   disable specific diagnostics.\n    See section Diagnostics for possible values.\n    (Environment variables not supported.)\n    </para></listitem>\n   <listitem><para>\n-   <code>GLIBCXX_PROFILE_TRACE_PATH_ROOT</code>: set an alternative root\n+   <code>_GLIBCXX_PROFILE_TRACE_PATH_ROOT</code>: set an alternative root\n    path for the output files.\n    </para></listitem>\n-  <listitem><para>GLIBCXX_PROFILE_MAX_WARN_COUNT: set it to the maximum\n+  <listitem><para>_GLIBCXX_PROFILE_MAX_WARN_COUNT: set it to the maximum\n    number of warnings desired.  The default value is 10.</para></listitem>\n   <listitem><para>\n-   <code>GLIBCXX_PROFILE_MAX_STACK_DEPTH</code>: if set to 0, \n+   <code>_GLIBCXX_PROFILE_MAX_STACK_DEPTH</code>: if set to 0, \n    the advice will\n    be collected and reported for the program as a whole, and not for each\n    call context.\n@@ -184,24 +187,24 @@ vector-size: improvement = 3: call stack = 0x804842c ...\n    The default value is 32.\n    </para></listitem>\n   <listitem><para>\n-   <code>GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC</code>:\n+   <code>_GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC</code>:\n    set a limit on how much memory to use for the accounting tables for each\n    diagnostic type.  When this limit is reached, new events are ignored\n    until the memory usage decreases under the limit.  Generally, this means\n    that newly created containers will not be instrumented until some\n    live containers are deleted.  The default is 128 MB.\n    </para></listitem>\n   <listitem><para>\n-   <code>GLIBCXX_PROFILE_NOTHREADS</code>:\n-   Make the library not use threads.  Otherwise, pthread mutexes are used\n-   to protect access to internal data structures.  This should be useful\n-   only if the program is single threaded and you want to avoid the overhead\n-   of aquiring/releasing locks unnecessarily.\n+   <code>_GLIBCXX_PROFILE_NO_THREADS</code>:\n+   Make the library not use threads.  If thread local storage (TLS) is not \n+   available, you will get a preprocessor error asking you to set\n+   -D_GLIBCXX_PROFILE_NO_THREADS if your program is single-threaded.\n+   Multithreded execution without TLS is not supported.\n    (Environment variable not supported.)\n    </para></listitem>\n   <listitem><para>\n-   <code>HAVE_EXECINFO_H</code>:\n-   This name should be defined at library configuration time.\n+   <code>_GLIBCXX_HAVE_EXECINFO_H</code>:\n+   This name should be defined automatically at library configuration time.\n    If your library was configured without <code>execinfo.h</code>, but\n    you have it in your include path, you can define it explicitly.  Without\n    it, advice is collected for the program as a whole, and not for each\n@@ -1320,6 +1323,52 @@ memory references.\n </itemizedlist>\n </sect3>\n \n+<sect3 id=\"manual.ext.profile_mode.analysis.list_to_slist\"\n+ xreflabel=\"List to Forward List\">\n+<title>List to Forward List (Slist)</title>\n+<itemizedlist>\n+  <listitem><para><emphasis>Switch:</emphasis>\n+  <code>_GLIBCXX_PROFILE_LIST_TO_SLIST</code>.\n+  </para></listitem>\n+  <listitem><para><emphasis>Goal:</emphasis> Detect cases where \n+  <code>list</code> could be substituted with <code>forward_list</code> for\n+  better performance.\n+  </para></listitem>\n+  <listitem><para><emphasis>Fundamentals:</emphasis>\n+  The memory footprint of a forward_list is smaller than that of a list.\n+  This has beneficial effects on memory subsystem, e.g., fewer cache misses.\n+  </para></listitem>\n+  <listitem><para><emphasis>Sample runtime reduction:</emphasis>40%.\n+  Note that the reduction is only noticeable if the size of the forward_list\n+  node is in fact larger than that of the list node.  For memory allocators\n+  with size classes, you will only notice an effect when the two node sizes\n+  belong to different allocator size classes.\n+  </para></listitem>\n+  <listitem><para><emphasis>Recommendation:</emphasis>Replace list with\n+  forward_list at site S.</para></listitem>\n+  <listitem><para><emphasis>To instrument:</emphasis><code>list</code>\n+  operations and iteration methods.</para></listitem>\n+  <listitem><para><emphasis>Analysis:</emphasis>\n+  Issue the advice if there are no <code>backwards</code> traversals\n+  or insertion before a given node.\n+  </para></listitem>\n+  <listitem><para><emphasis>Cost model:</emphasis>\n+  Always true.</para></listitem>\n+  <listitem><para><emphasis>Example:</emphasis> \n+<programlisting>\n+1  list&lt;int&gt; l;\n+...\n+2  int sum = 0;\n+3  for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); ++it) {\n+4    sum += *it;\n+5  }\n+\n+foo.cc:1: advice: Change \"list\" to \"forward_list\".\n+</programlisting>\n+</para></listitem>\n+</itemizedlist>\n+</sect3>\n+\n <sect3 id=\"manual.ext.profile_mode.analysis.assoc_ord_to_unord\"\n  xreflabel=\"Ordered to Unordered Associative Container\">\n <title>Ordered to Unordered Associative Container</title>"}, {"sha": "ee7696b6f5080c7cac69c583d7eddf6ab2d5e6d0", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -793,7 +793,7 @@ profile_headers = \\\n \t${profile_srcdir}/multiset.h \\\n \t${profile_srcdir}/set \\\n \t${profile_srcdir}/set.h \\\n-\t${profile_srcdir}/hashtable.h\n+\t${profile_srcdir}/iterator_tracker.h\n profile_impl_srcdir = ${glibcxx_srcdir}/include/profile/impl\n profile_impl_builddir = ./profile/impl\n profile_impl_headers = \\\n@@ -806,7 +806,9 @@ profile_impl_headers = \\\n \t${profile_impl_srcdir}/profiler_state.h \\\n \t${profile_impl_srcdir}/profiler_trace.h \\\n \t${profile_impl_srcdir}/profiler_vector_size.h \\\n-\t${profile_impl_srcdir}/profiler_vector_to_list.h\n+\t${profile_impl_srcdir}/profiler_vector_to_list.h \\\n+\t${profile_impl_srcdir}/profiler_list_to_vector.h \\\n+\t${profile_impl_srcdir}/profiler_list_to_slist.h\n \n # Some of the different \"C\" header models need extra files.\n # Some \"C\" header schemes require the \"C\" compatibility headers."}, {"sha": "62a8dafcf5d4948a0f307e59e26d30e37208fca9", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -1026,7 +1026,7 @@ profile_headers = \\\n \t${profile_srcdir}/multiset.h \\\n \t${profile_srcdir}/set \\\n \t${profile_srcdir}/set.h \\\n-\t${profile_srcdir}/hashtable.h\n+\t${profile_srcdir}/iterator_tracker.h\n \n profile_impl_srcdir = ${glibcxx_srcdir}/include/profile/impl\n profile_impl_builddir = ./profile/impl\n@@ -1040,7 +1040,9 @@ profile_impl_headers = \\\n \t${profile_impl_srcdir}/profiler_state.h \\\n \t${profile_impl_srcdir}/profiler_trace.h \\\n \t${profile_impl_srcdir}/profiler_vector_size.h \\\n-\t${profile_impl_srcdir}/profiler_vector_to_list.h\n+\t${profile_impl_srcdir}/profiler_vector_to_list.h \\\n+\t${profile_impl_srcdir}/profiler_list_to_vector.h \\\n+\t${profile_impl_srcdir}/profiler_list_to_slist.h\n \n @GLIBCXX_C_HEADERS_EXTRA_FALSE@c_base_headers_extra = \n "}, {"sha": "469429ccc24c3b94c006b02141b5955a9dd79c45", "filename": "libstdc++-v3/include/backward/hash_map", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -58,11 +58,7 @@\n \n #include \"backward_warning.h\"\n #include <bits/c++config.h>\n-#ifdef _GLIBCXX_PROFILE\n-#include <profile/hashtable.h>\n-#else\n #include <backward/hashtable.h>\n-#endif\n #include <bits/concept_check.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)"}, {"sha": "32fa2205eeabcba3fe84fea8d3f3b158a0e2944d", "filename": "libstdc++-v3/include/backward/hash_set", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -58,11 +58,7 @@\n \n #include \"backward_warning.h\"\n #include <bits/c++config.h>\n-#ifdef _GLIBCXX_PROFILE\n-#include <profile/hashtable.h>\n-#else\n #include <backward/hashtable.h>\n-#endif\n #include <bits/concept_check.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)"}, {"sha": "20891877121291e0194afcabe834a88a21e0a718", "filename": "libstdc++-v3/include/profile/hashtable.h", "status": "removed", "additions": 0, "deletions": 1151, "changes": 1151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2adcdbc12edf30eb4bedcff79f8f9050c7f29a/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2adcdbc12edf30eb4bedcff79f8f9050c7f29a/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fhashtable.h?ref=9b2adcdbc12edf30eb4bedcff79f8f9050c7f29a", "patch": "@@ -1,1151 +0,0 @@\n-// Hashtable implementation used by containers -*- C++ -*-\n-\n-// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1996,1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- *\n- * Copyright (c) 1994\n- * Hewlett-Packard Company\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Hewlett-Packard Company makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- *\n- */\n-\n-/** @file profile/hashtable.h copied from backward/hashtable.h\n- *  This file is a GNU extension to the Standard C++ Library (possibly\n- *  containing extensions from the HP/SGI STL subset).\n- */\n-\n-#ifndef _HASHTABLE_H\n-#define _HASHTABLE_H 1\n-\n-// Hashtable class, used to implement the hashed associative containers\n-// hash_set, hash_map, hash_multiset, and hash_multimap.\n-// Skip instrumentation on vector.\n-#include <vector>\n-#include <iterator>\n-#include <algorithm>\n-#include <bits/stl_function.h>\n-#include <backward/hash_fun.h>\n-#include <profile/base.h>\n-\n-_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n-\n-  using std::size_t;\n-  using std::ptrdiff_t;\n-  using std::forward_iterator_tag;\n-  using std::input_iterator_tag;\n-  using std::_Construct;\n-  using std::_Destroy;\n-  using std::distance;\n-  using std::_GLIBCXX_STD_D::vector;\n-  using std::pair;\n-  using std::__iterator_category;\n-\n-  template<class _Val>\n-    struct _Hashtable_node\n-    {\n-      _Hashtable_node* _M_next;\n-      _Val _M_val;\n-    };\n-\n-  template<class _Val, class _Key, class _HashFcn, class _ExtractKey, \n-\t   class _EqualKey, class _Alloc = std::allocator<_Val> >\n-    class hashtable;\n-\n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    struct _Hashtable_iterator;\n-\n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    struct _Hashtable_const_iterator;\n-\n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    struct _Hashtable_iterator\n-    {\n-      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n-        _Hashtable;\n-      typedef _Hashtable_iterator<_Val, _Key, _HashFcn,\n-\t\t\t\t  _ExtractKey, _EqualKey, _Alloc>\n-        iterator;\n-      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n-\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n-        const_iterator;\n-      typedef _Hashtable_node<_Val> _Node;\n-      typedef forward_iterator_tag iterator_category;\n-      typedef _Val value_type;\n-      typedef ptrdiff_t difference_type;\n-      typedef size_t size_type;\n-      typedef _Val& reference;\n-      typedef _Val* pointer;\n-      \n-      _Node* _M_cur;\n-      _Hashtable* _M_ht;\n-\n-      _Hashtable_iterator(_Node* __n, _Hashtable* __tab)\n-      : _M_cur(__n), _M_ht(__tab) { }\n-\n-      _Hashtable_iterator() { }\n-\n-      reference\n-      operator*() const\n-      { return _M_cur->_M_val; }\n-\n-      pointer\n-      operator->() const\n-      { return &(operator*()); }\n-\n-      iterator&\n-      operator++();\n-\n-      iterator\n-      operator++(int);\n-\n-      bool\n-      operator==(const iterator& __it) const\n-      { return _M_cur == __it._M_cur; }\n-\n-      bool\n-      operator!=(const iterator& __it) const\n-      { return _M_cur != __it._M_cur; }\n-    };\n-\n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    struct _Hashtable_const_iterator\n-    {\n-      typedef hashtable<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>\n-        _Hashtable;\n-      typedef _Hashtable_iterator<_Val,_Key,_HashFcn,\n-\t\t\t\t  _ExtractKey,_EqualKey,_Alloc>\n-        iterator;\n-      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn,\n-\t\t\t\t\t_ExtractKey, _EqualKey, _Alloc>\n-        const_iterator;\n-      typedef _Hashtable_node<_Val> _Node;\n-\n-      typedef forward_iterator_tag iterator_category;\n-      typedef _Val value_type;\n-      typedef ptrdiff_t difference_type;\n-      typedef size_t size_type;\n-      typedef const _Val& reference;\n-      typedef const _Val* pointer;\n-      \n-      const _Node* _M_cur;\n-      const _Hashtable* _M_ht;\n-\n-      _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)\n-      : _M_cur(__n), _M_ht(__tab) { }\n-\n-      _Hashtable_const_iterator() { }\n-\n-      _Hashtable_const_iterator(const iterator& __it)\n-      : _M_cur(__it._M_cur), _M_ht(__it._M_ht) { }\n-\n-      reference\n-      operator*() const\n-      { return _M_cur->_M_val; }\n-\n-      pointer\n-      operator->() const\n-      { return &(operator*()); }\n-\n-      const_iterator&\n-      operator++();\n-\n-      const_iterator\n-      operator++(int);\n-\n-      bool\n-      operator==(const const_iterator& __it) const\n-      { return _M_cur == __it._M_cur; }\n-\n-      bool\n-      operator!=(const const_iterator& __it) const\n-      { return _M_cur != __it._M_cur; }\n-    };\n-\n-  // Note: assumes long is at least 32 bits.\n-  enum { _S_num_primes = 28 };\n-\n-  static const unsigned long __stl_prime_list[_S_num_primes] =\n-    {\n-      53ul,         97ul,         193ul,       389ul,       769ul,\n-      1543ul,       3079ul,       6151ul,      12289ul,     24593ul,\n-      49157ul,      98317ul,      196613ul,    393241ul,    786433ul,\n-      1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,\n-      50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,\n-      1610612741ul, 3221225473ul, 4294967291ul\n-    };\n-\n-  inline unsigned long\n-  __stl_next_prime(unsigned long __n)\n-  {\n-    const unsigned long* __first = __stl_prime_list;\n-    const unsigned long* __last = __stl_prime_list + (int)_S_num_primes;\n-    const unsigned long* pos = std::lower_bound(__first, __last, __n);\n-    return pos == __last ? *(__last - 1) : *pos;\n-  }\n-\n-  // Forward declaration of operator==.  \n-  template<class _Val, class _Key, class _HF, class _Ex,\n-\t   class _Eq, class _All>\n-    class hashtable;\n-\n-  template<class _Val, class _Key, class _HF, class _Ex,\n-\t   class _Eq, class _All>\n-    bool\n-    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n-\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2);\n-\n-  // Hashtables handle allocators a bit differently than other\n-  // containers do.  If we're using standard-conforming allocators, then\n-  // a hashtable unconditionally has a member variable to hold its\n-  // allocator, even if it so happens that all instances of the\n-  // allocator type are identical.  This is because, for hashtables,\n-  // this extra storage is negligible.  Additionally, a base class\n-  // wouldn't serve any other purposes; it wouldn't, for example,\n-  // simplify the exception-handling code.  \n-  template<class _Val, class _Key, class _HashFcn,\n-\t   class _ExtractKey, class _EqualKey, class _Alloc>\n-    class hashtable\n-    {\n-    public:\n-      typedef _Key key_type;\n-      typedef _Val value_type;\n-      typedef _HashFcn hasher;\n-      typedef _EqualKey key_equal;\n-\n-      typedef size_t            size_type;\n-      typedef ptrdiff_t         difference_type;\n-      typedef value_type*       pointer;\n-      typedef const value_type* const_pointer;\n-      typedef value_type&       reference;\n-      typedef const value_type& const_reference;\n-\n-      hasher\n-      hash_funct() const\n-      { return _M_hash; }\n-\n-      key_equal\n-      key_eq() const\n-      { return _M_equals; }\n-\n-    private:\n-      typedef _Hashtable_node<_Val> _Node;\n-\n-    public:\n-      typedef typename _Alloc::template rebind<value_type>::other allocator_type;\n-      allocator_type\n-      get_allocator() const\n-      { return _M_node_allocator; }\n-\n-    private:\n-      typedef typename _Alloc::template rebind<_Node>::other _Node_Alloc;\n-      typedef typename _Alloc::template rebind<_Node*>::other _Nodeptr_Alloc;\n-      typedef vector<_Node*, _Nodeptr_Alloc> _Vector_type;\n-\n-      _Node_Alloc _M_node_allocator;\n-\n-      _Node*\n-      _M_get_node()\n-      { return _M_node_allocator.allocate(1); }\n-\n-      void\n-      _M_put_node(_Node* __p)\n-      { _M_node_allocator.deallocate(__p, 1); }\n-\n-    private:\n-      hasher                _M_hash;\n-      key_equal             _M_equals;\n-      _ExtractKey           _M_get_key;\n-      _Vector_type          _M_buckets;\n-      size_type             _M_num_elements;\n-      \n-    public:\n-      typedef _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n-\t\t\t\t  _EqualKey, _Alloc>\n-        iterator;\n-      typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n-\t\t\t\t\t_EqualKey, _Alloc>\n-        const_iterator;\n-\n-      friend struct\n-      _Hashtable_iterator<_Val, _Key, _HashFcn, _ExtractKey, _EqualKey, _Alloc>;\n-\n-      friend struct\n-      _Hashtable_const_iterator<_Val, _Key, _HashFcn, _ExtractKey,\n-\t\t\t\t_EqualKey, _Alloc>;\n-\n-    public:\n-      hashtable(size_type __n, const _HashFcn& __hf,\n-\t\tconst _EqualKey& __eql, const _ExtractKey& __ext,\n-\t\tconst allocator_type& __a = allocator_type())\n-      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n-\t_M_get_key(__ext), _M_buckets(__a), _M_num_elements(0)\n-      { _M_initialize_buckets(__n); }\n-\n-      hashtable(size_type __n, const _HashFcn& __hf,\n-\t\tconst _EqualKey& __eql,\n-\t\tconst allocator_type& __a = allocator_type())\n-      : _M_node_allocator(__a), _M_hash(__hf), _M_equals(__eql),\n-\t_M_get_key(_ExtractKey()), _M_buckets(__a), _M_num_elements(0)\n-      { _M_initialize_buckets(__n); }\n-\n-      hashtable(const hashtable& __ht)\n-      : _M_node_allocator(__ht.get_allocator()), _M_hash(__ht._M_hash),\n-      _M_equals(__ht._M_equals), _M_get_key(__ht._M_get_key),\n-      _M_buckets(__ht.get_allocator()), _M_num_elements(0)\n-      { _M_copy_from(__ht); }\n-\n-      hashtable&\n-      operator= (const hashtable& __ht)\n-      {\n-\tif (&__ht != this)\n-\t  {\n-\t    clear();\n-\t    _M_hash = __ht._M_hash;\n-\t    _M_equals = __ht._M_equals;\n-\t    _M_get_key = __ht._M_get_key;\n-\t    _M_copy_from(__ht);\n-\t  }\n-\treturn *this;\n-      }\n-\n-      ~hashtable()\n-      { clear(); }\n-\n-      size_type\n-      size() const\n-      { return _M_num_elements; }\n-\n-      size_type\n-      max_size() const\n-      { return size_type(-1); }\n-\n-      bool\n-      empty() const\n-      { return size() == 0; }\n-\n-      void\n-      swap(hashtable& __ht)\n-      {\n-\tstd::swap(_M_hash, __ht._M_hash);\n-\tstd::swap(_M_equals, __ht._M_equals);\n-\tstd::swap(_M_get_key, __ht._M_get_key);\n-\t_M_buckets.swap(__ht._M_buckets);\n-\tstd::swap(_M_num_elements, __ht._M_num_elements);\n-      }\n-\n-      iterator\n-      begin()\n-      {\n-\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n-\t  if (_M_buckets[__n])\n-\t    return iterator(_M_buckets[__n], this);\n-\treturn end();\n-      }\n-\n-      iterator\n-      end()\n-      { return iterator(0, this); }\n-\n-      const_iterator\n-      begin() const\n-      {\n-\tfor (size_type __n = 0; __n < _M_buckets.size(); ++__n)\n-\t  if (_M_buckets[__n])\n-\t    return const_iterator(_M_buckets[__n], this);\n-\treturn end();\n-      }\n-\n-      const_iterator\n-      end() const\n-      { return const_iterator(0, this); }\n-\n-      template<class _Vl, class _Ky, class _HF, class _Ex, class _Eq,\n-\t\tclass _Al>\n-        friend bool\n-        operator==(const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,\n-\t\t   const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);\n-\n-    public:\n-      size_type\n-      bucket_count() const\n-      { return _M_buckets.size(); }\n-\n-      size_type\n-      max_bucket_count() const\n-      { return __stl_prime_list[(int)_S_num_primes - 1]; }\n-\n-      size_type\n-      elems_in_bucket(size_type __bucket) const\n-      {\n-\tsize_type __result = 0;\n-\tfor (_Node* __n = _M_buckets[__bucket]; __n; __n = __n->_M_next)\n-\t  __result += 1;\n-\treturn __result;\n-      }\n-\n-      pair<iterator, bool>\n-      insert_unique(const value_type& __obj)\n-      {\n-\tresize(_M_num_elements + 1);\n-\treturn insert_unique_noresize(__obj);\n-      }\n-\n-      iterator\n-      insert_equal(const value_type& __obj)\n-      {\n-\tresize(_M_num_elements + 1);\n-\treturn insert_equal_noresize(__obj);\n-      }\n-\n-      pair<iterator, bool>\n-      insert_unique_noresize(const value_type& __obj);\n-\n-      iterator\n-      insert_equal_noresize(const value_type& __obj);\n-\n-      template<class _InputIterator>\n-        void\n-        insert_unique(_InputIterator __f, _InputIterator __l)\n-        { insert_unique(__f, __l, __iterator_category(__f)); }\n-\n-      template<class _InputIterator>\n-        void\n-        insert_equal(_InputIterator __f, _InputIterator __l)\n-        { insert_equal(__f, __l, __iterator_category(__f)); }\n-\n-      template<class _InputIterator>\n-        void\n-        insert_unique(_InputIterator __f, _InputIterator __l,\n-\t\t      input_iterator_tag)\n-        {\n-\t  for ( ; __f != __l; ++__f)\n-\t    insert_unique(*__f);\n-\t}\n-\n-      template<class _InputIterator>\n-        void\n-        insert_equal(_InputIterator __f, _InputIterator __l,\n-\t\t     input_iterator_tag)\n-        {\n-\t  for ( ; __f != __l; ++__f)\n-\t    insert_equal(*__f);\n-\t}\n-\n-      template<class _ForwardIterator>\n-        void\n-        insert_unique(_ForwardIterator __f, _ForwardIterator __l,\n-\t\t      forward_iterator_tag)\n-        {\n-\t  size_type __n = distance(__f, __l);\n-\t  resize(_M_num_elements + __n);\n-\t  for ( ; __n > 0; --__n, ++__f)\n-\t    insert_unique_noresize(*__f);\n-\t}\n-\n-      template<class _ForwardIterator>\n-        void\n-        insert_equal(_ForwardIterator __f, _ForwardIterator __l,\n-\t\t     forward_iterator_tag)\n-        {\n-\t  size_type __n = distance(__f, __l);\n-\t  resize(_M_num_elements + __n);\n-\t  for ( ; __n > 0; --__n, ++__f)\n-\t    insert_equal_noresize(*__f);\n-\t}\n-\n-      reference\n-      find_or_insert(const value_type& __obj);\n-\n-      iterator\n-      find(const key_type& __key)\n-      {\n-\tsize_type __n = _M_bkt_num_key(__key);\n-\t_Node* __first;\n-\tfor (__first = _M_buckets[__n];\n-\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n-\t     __first = __first->_M_next)\n-\t  { }\n-\treturn iterator(__first, this);\n-      }\n-\n-      const_iterator\n-      find(const key_type& __key) const\n-      {\n-\tsize_type __n = _M_bkt_num_key(__key);\n-\tconst _Node* __first;\n-\tfor (__first = _M_buckets[__n];\n-\t     __first && !_M_equals(_M_get_key(__first->_M_val), __key);\n-\t     __first = __first->_M_next)\n-\t  { }\n-\treturn const_iterator(__first, this);\n-      }\n-\n-      size_type\n-      count(const key_type& __key) const\n-      {\n-\tconst size_type __n = _M_bkt_num_key(__key);\n-\tsize_type __result = 0;\n-\t\n-\tfor (const _Node* __cur = _M_buckets[__n]; __cur;\n-\t     __cur = __cur->_M_next)\n-\t  if (_M_equals(_M_get_key(__cur->_M_val), __key))\n-\t    ++__result;\n-\treturn __result;\n-      }\n-\n-      pair<iterator, iterator>\n-      equal_range(const key_type& __key);\n-\n-      pair<const_iterator, const_iterator>\n-      equal_range(const key_type& __key) const;\n-\n-      size_type\n-      erase(const key_type& __key);\n-      \n-      void\n-      erase(const iterator& __it);\n-\n-      void\n-      erase(iterator __first, iterator __last);\n-\n-      void\n-      erase(const const_iterator& __it);\n-\n-      void\n-      erase(const_iterator __first, const_iterator __last);\n-\n-      void\n-      resize(size_type __num_elements_hint);\n-\n-      void\n-      clear();\n-\n-    private:\n-      size_type\n-      _M_next_size(size_type __n) const\n-      { return __stl_next_prime(__n); }\n-\n-      void\n-      _M_initialize_buckets(size_type __n)\n-      {\n-\tconst size_type __n_buckets = _M_next_size(__n);\n-\t_M_buckets.reserve(__n_buckets);\n-\t_M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);\n-\t_M_num_elements = 0;\n-        __profcxx_hashtable_construct(this, __n_buckets);\n-        __profcxx_hashtable_construct2(this);\n-      }\n-\n-      size_type\n-      _M_bkt_num_key(const key_type& __key) const\n-      { return _M_bkt_num_key(__key, _M_buckets.size()); }\n-\n-      size_type\n-      _M_bkt_num(const value_type& __obj) const\n-      { return _M_bkt_num_key(_M_get_key(__obj)); }\n-\n-      size_type\n-      _M_bkt_num_key(const key_type& __key, size_t __n) const\n-      { return _M_hash(__key) % __n; }\n-\n-      size_type\n-      _M_bkt_num(const value_type& __obj, size_t __n) const\n-      { return _M_bkt_num_key(_M_get_key(__obj), __n); }\n-\n-      _Node*\n-      _M_new_node(const value_type& __obj)\n-      {\n-\t_Node* __n = _M_get_node();\n-\t__n->_M_next = 0;\n-\ttry\n-\t  {\n-\t    this->get_allocator().construct(&__n->_M_val, __obj);\n-\t    return __n;\n-\t  }\n-\tcatch(...)\n-\t  {\n-\t    _M_put_node(__n);\n-\t    __throw_exception_again;\n-\t  }\n-      }\n-\n-      void\n-      _M_delete_node(_Node* __n)\n-      {\n-\tthis->get_allocator().destroy(&__n->_M_val);\n-\t_M_put_node(__n);\n-      }\n-      \n-      void\n-      _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);\n-\n-      void\n-      _M_erase_bucket(const size_type __n, _Node* __last);\n-\n-      void\n-      _M_copy_from(const hashtable& __ht);\n-    };\n-\n-  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-\t    class _All>\n-    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n-    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n-    operator++()\n-    {\n-      const _Node* __old = _M_cur;\n-      _M_cur = _M_cur->_M_next;\n-      if (!_M_cur)\n-\t{\n-\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n-\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n-\t    _M_cur = _M_ht->_M_buckets[__bucket];\n-\t}\n-      return *this;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-\t    class _All>\n-    inline _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n-    _Hashtable_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n-    operator++(int)\n-    {\n-      iterator __tmp = *this;\n-      ++*this;\n-      return __tmp;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-\t    class _All>\n-    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>&\n-    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n-    operator++()\n-    {\n-      const _Node* __old = _M_cur;\n-      _M_cur = _M_cur->_M_next;\n-      if (!_M_cur)\n-\t{\n-\t  size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);\n-\t  while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())\n-\t    _M_cur = _M_ht->_M_buckets[__bucket];\n-\t}\n-      return *this;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _ExK, class _EqK,\n-\t    class _All>\n-    inline _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>\n-    _Hashtable_const_iterator<_Val, _Key, _HF, _ExK, _EqK, _All>::\n-    operator++(int)\n-    {\n-      const_iterator __tmp = *this;\n-      ++*this;\n-      return __tmp;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    bool\n-    operator==(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n-\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n-    {\n-      typedef typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::_Node _Node;\n-\n-      if (__ht1._M_buckets.size() != __ht2._M_buckets.size())\n-\treturn false;\n-\n-      for (size_t __n = 0; __n < __ht1._M_buckets.size(); ++__n)\n-\t{\n-\t  _Node* __cur1 = __ht1._M_buckets[__n];\n-\t  _Node* __cur2 = __ht2._M_buckets[__n];\n-\t  // Check same length of lists\n-\t  for (; __cur1 && __cur2;\n-\t       __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)\n-\t    { } \n-\t  if (__cur1 || __cur2)\n-\t    return false;\n-\t  // Now check one's elements are in the other\n-\t  for (__cur1 = __ht1._M_buckets[__n] ; __cur1;\n-\t       __cur1 = __cur1->_M_next)\n-\t    {\n-\t      bool _found__cur1 = false;\n-\t      for (__cur2 = __ht2._M_buckets[__n];\n-\t\t   __cur2; __cur2 = __cur2->_M_next)\n-\t\t{\n-\t\t  if (__cur1->_M_val == __cur2->_M_val)\n-\t\t    {\n-\t\t      _found__cur1 = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (!_found__cur1)\n-\t\treturn false;\n-\t    }\n-\t}\n-      return true;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    inline bool\n-    operator!=(const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht1,\n-\t       const hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>& __ht2)\n-    { return !(__ht1 == __ht2); }\n-\n-  template<class _Val, class _Key, class _HF, class _Extract, class _EqKey,\n-\t    class _All>\n-    inline void\n-    swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,\n-\t hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2)\n-    { __ht1.swap(__ht2); }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator, bool>\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    insert_unique_noresize(const value_type& __obj)\n-    {\n-      const size_type __n = _M_bkt_num(__obj);\n-      _Node* __first = _M_buckets[__n];\n-      \n-      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-\t  return pair<iterator, bool>(iterator(__cur, this), false);\n-      \n-      _Node* __tmp = _M_new_node(__obj);\n-      __tmp->_M_next = __first;\n-      _M_buckets[__n] = __tmp;\n-      ++_M_num_elements;\n-      return pair<iterator, bool>(iterator(__tmp, this), true);\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    insert_equal_noresize(const value_type& __obj)\n-    {\n-      const size_type __n = _M_bkt_num(__obj);\n-      _Node* __first = _M_buckets[__n];\n-      \n-      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-\t  {\n-\t    _Node* __tmp = _M_new_node(__obj);\n-\t    __tmp->_M_next = __cur->_M_next;\n-\t    __cur->_M_next = __tmp;\n-\t    ++_M_num_elements;\n-\t    return iterator(__tmp, this);\n-\t  }\n-\n-      _Node* __tmp = _M_new_node(__obj);\n-      __tmp->_M_next = __first;\n-      _M_buckets[__n] = __tmp;\n-      ++_M_num_elements;\n-      return iterator(__tmp, this);\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::reference\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    find_or_insert(const value_type& __obj)\n-    {\n-      resize(_M_num_elements + 1);\n-\n-      size_type __n = _M_bkt_num(__obj);\n-      _Node* __first = _M_buckets[__n];\n-      \n-      for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)\n-\tif (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))\n-\t  return __cur->_M_val;\n-      \n-      _Node* __tmp = _M_new_node(__obj);\n-      __tmp->_M_next = __first;\n-      _M_buckets[__n] = __tmp;\n-      ++_M_num_elements;\n-      return __tmp->_M_val;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator,\n-\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::iterator>\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    equal_range(const key_type& __key)\n-    {\n-      typedef pair<iterator, iterator> _Pii;\n-      const size_type __n = _M_bkt_num_key(__key);\n-\n-      for (_Node* __first = _M_buckets[__n]; __first;\n-\t   __first = __first->_M_next)\n-\tif (_M_equals(_M_get_key(__first->_M_val), __key))\n-\t  {\n-\t    for (_Node* __cur = __first->_M_next; __cur;\n-\t\t __cur = __cur->_M_next)\n-\t      if (!_M_equals(_M_get_key(__cur->_M_val), __key))\n-\t\treturn _Pii(iterator(__first, this), iterator(__cur, this));\n-\t    for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n-\t      if (_M_buckets[__m])\n-\t\treturn _Pii(iterator(__first, this),\n-\t\t\t    iterator(_M_buckets[__m], this));\n-\t    return _Pii(iterator(__first, this), end());\n-\t  }\n-      return _Pii(end(), end());\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    pair<typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator,\n-\t typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::const_iterator>\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    equal_range(const key_type& __key) const\n-    {\n-      typedef pair<const_iterator, const_iterator> _Pii;\n-      const size_type __n = _M_bkt_num_key(__key);\n-\n-      for (const _Node* __first = _M_buckets[__n]; __first;\n-\t   __first = __first->_M_next)\n-\t{\n-\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n-\t    {\n-\t      for (const _Node* __cur = __first->_M_next; __cur;\n-\t\t   __cur = __cur->_M_next)\n-\t\tif (!_M_equals(_M_get_key(__cur->_M_val), __key))\n-\t\t  return _Pii(const_iterator(__first, this),\n-\t\t\t      const_iterator(__cur, this));\n-\t      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)\n-\t\tif (_M_buckets[__m])\n-\t\t  return _Pii(const_iterator(__first, this),\n-\t\t\t      const_iterator(_M_buckets[__m], this));\n-\t      return _Pii(const_iterator(__first, this), end());\n-\t    }\n-\t}\n-      return _Pii(end(), end());\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    typename hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::size_type\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(const key_type& __key)\n-    {\n-      const size_type __n = _M_bkt_num_key(__key);\n-      _Node* __first = _M_buckets[__n];\n-      size_type __erased = 0;\n-      \n-      if (__first)\n-\t{\n-\t  _Node* __cur = __first;\n-\t  _Node* __next = __cur->_M_next;\n-\t  while (__next)\n-\t    {\n-\t      if (_M_equals(_M_get_key(__next->_M_val), __key))\n-\t\t{\n-\t\t  __cur->_M_next = __next->_M_next;\n-\t\t  _M_delete_node(__next);\n-\t\t  __next = __cur->_M_next;\n-\t\t  ++__erased;\n-\t\t  --_M_num_elements;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  __cur = __next;\n-\t\t  __next = __cur->_M_next;\n-\t\t}\n-\t    }\n-\t  if (_M_equals(_M_get_key(__first->_M_val), __key))\n-\t    {\n-\t      _M_buckets[__n] = __first->_M_next;\n-\t      _M_delete_node(__first);\n-\t      ++__erased;\n-\t      --_M_num_elements;\n-\t    }\n-\t}\n-      return __erased;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(const iterator& __it)\n-    {\n-      _Node* __p = __it._M_cur;\n-      if (__p)\n-\t{\n-\t  const size_type __n = _M_bkt_num(__p->_M_val);\n-\t  _Node* __cur = _M_buckets[__n];\n-\t  \n-\t  if (__cur == __p)\n-\t    {\n-\t      _M_buckets[__n] = __cur->_M_next;\n-\t      _M_delete_node(__cur);\n-\t      --_M_num_elements;\n-\t    }\n-\t  else\n-\t    {\n-\t      _Node* __next = __cur->_M_next;\n-\t      while (__next)\n-\t\t{\n-\t\t  if (__next == __p)\n-\t\t    {\n-\t\t      __cur->_M_next = __next->_M_next;\n-\t\t      _M_delete_node(__next);\n-\t\t      --_M_num_elements;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      __cur = __next;\n-\t\t      __next = __cur->_M_next;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(iterator __first, iterator __last)\n-    {\n-      size_type __f_bucket = __first._M_cur ? _M_bkt_num(__first._M_cur->_M_val)\n-\t                                    : _M_buckets.size();\n-\n-      size_type __l_bucket = __last._M_cur ? _M_bkt_num(__last._M_cur->_M_val)\n-\t                                   : _M_buckets.size();\n-\n-      if (__first._M_cur == __last._M_cur)\n-\treturn;\n-      else if (__f_bucket == __l_bucket)\n-\t_M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);\n-      else\n-\t{\n-\t  _M_erase_bucket(__f_bucket, __first._M_cur, 0);\n-\t  for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)\n-\t    _M_erase_bucket(__n, 0);\n-\t  if (__l_bucket != _M_buckets.size())\n-\t    _M_erase_bucket(__l_bucket, __last._M_cur);\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    inline void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(const_iterator __first, const_iterator __last)\n-    {\n-      erase(iterator(const_cast<_Node*>(__first._M_cur),\n-\t\t     const_cast<hashtable*>(__first._M_ht)),\n-\t    iterator(const_cast<_Node*>(__last._M_cur),\n-\t\t     const_cast<hashtable*>(__last._M_ht)));\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    inline void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    erase(const const_iterator& __it)\n-    { erase(iterator(const_cast<_Node*>(__it._M_cur),\n-\t\t     const_cast<hashtable*>(__it._M_ht))); }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    resize(size_type __num_elements_hint)\n-    {\n-      const size_type __old_n = _M_buckets.size();\n-      if (__num_elements_hint > __old_n)\n-\t{\n-\t  const size_type __n = _M_next_size(__num_elements_hint);\n-\t  if (__n > __old_n)\n-\t    {\n-\t      _Vector_type __tmp(__n, (_Node*)(0), _M_buckets.get_allocator());\n-\t      try\n-\t\t{\n-\t\t  for (size_type __bucket = 0; __bucket < __old_n; ++__bucket)\n-\t\t    {\n-\t\t      _Node* __first = _M_buckets[__bucket];\n-\t\t      while (__first)\n-\t\t\t{\n-\t\t\t  size_type __new_bucket = _M_bkt_num(__first->_M_val,\n-\t\t\t\t\t\t\t      __n);\n-\t\t\t  _M_buckets[__bucket] = __first->_M_next;\n-\t\t\t  __first->_M_next = __tmp[__new_bucket];\n-\t\t\t  __tmp[__new_bucket] = __first;\n-\t\t\t  __first = _M_buckets[__bucket];\n-\t\t\t}\n-\t\t    }\n-\t\t  _M_buckets.swap(__tmp);\n-\t\t}\n-\t      catch(...)\n-\t\t{\n-\t\t  for (size_type __bucket = 0; __bucket < __tmp.size();\n-\t\t       ++__bucket)\n-\t\t    {\n-\t\t      while (__tmp[__bucket])\n-\t\t\t{\n-\t\t\t  _Node* __next = __tmp[__bucket]->_M_next;\n-\t\t\t  _M_delete_node(__tmp[__bucket]);\n-\t\t\t  __tmp[__bucket] = __next;\n-\t\t\t}\n-\t\t    }\n-\t\t  __throw_exception_again;\n-\t\t}\n-        __profcxx_hashtable_resize(this, __num_elements_hint, __n);\n-\t    }\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)\n-    {\n-      _Node* __cur = _M_buckets[__n];\n-      if (__cur == __first)\n-\t_M_erase_bucket(__n, __last);\n-      else\n-\t{\n-\t  _Node* __next;\n-\t  for (__next = __cur->_M_next;\n-\t       __next != __first;\n-\t       __cur = __next, __next = __cur->_M_next)\n-\t    ;\n-\t  while (__next != __last)\n-\t    {\n-\t      __cur->_M_next = __next->_M_next;\n-\t      _M_delete_node(__next);\n-\t      __next = __cur->_M_next;\n-\t      --_M_num_elements;\n-\t    }\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    _M_erase_bucket(const size_type __n, _Node* __last)\n-    {\n-      _Node* __cur = _M_buckets[__n];\n-      while (__cur != __last)\n-\t{\n-\t  _Node* __next = __cur->_M_next;\n-\t  _M_delete_node(__cur);\n-\t  __cur = __next;\n-\t  _M_buckets[__n] = __cur;\n-\t  --_M_num_elements;\n-\t}\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    clear()\n-    {\n-      size_type __hops=0, __lc = 0, __chain = 0;\n-      if (_M_num_elements != 0) \n-         __profcxx_hashtable_destruct(this, _M_buckets.size(), _M_num_elements);\n-      \n-      for (size_type __i = 0; __i < _M_buckets.size(); ++__i)\n-\t{\n-\t  _Node* __cur = _M_buckets[__i];\n-\t  while (__cur != 0)\n-\t    {\n-\t      _Node* __next = __cur->_M_next;\n-\t      _M_delete_node(__cur);\n-\t      __cur = __next;\n-\n-          // Compute the longest chain count.\n-          __chain++;\n-\t    }\n-\t  _M_buckets[__i] = 0;\n-\n-      // Collect number of hops.\n-      if (__chain > 1) {\n-        __lc = __lc > __chain ? __lc : __chain;\n-        __hops += (__chain-1) * __chain / 2;\n-      }\n-      __chain = 0;\n-\t}\n-      if (_M_num_elements) {\n-        __profcxx_hashtable_destruct2(this, __lc, _M_num_elements, __hops);\n-      }\n-      _M_num_elements = 0;\n-    }\n-\n-  template<class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>\n-    void\n-    hashtable<_Val, _Key, _HF, _Ex, _Eq, _All>::\n-    _M_copy_from(const hashtable& __ht)\n-    {\n-      _M_buckets.clear();\n-      _M_buckets.reserve(__ht._M_buckets.size());\n-      _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);\n-      try\n-\t{\n-\t  for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {\n-\t    const _Node* __cur = __ht._M_buckets[__i];\n-\t    if (__cur)\n-\t      {\n-\t\t_Node* __local_copy = _M_new_node(__cur->_M_val);\n-\t\t_M_buckets[__i] = __local_copy;\n-\t\t\n-\t\tfor (_Node* __next = __cur->_M_next;\n-\t\t     __next;\n-\t\t     __cur = __next, __next = __cur->_M_next)\n-\t\t  {\n-\t\t    __local_copy->_M_next = _M_new_node(__next->_M_val);\n-\t\t    __local_copy = __local_copy->_M_next;\n-\t\t  }\n-\t      }\n-\t  }\n-\t  _M_num_elements = __ht._M_num_elements;\n-\t}\n-      catch(...)\n-\t{\n-\t  clear();\n-\t  __throw_exception_again;\n-\t}\n-    }\n-\n-_GLIBCXX_END_NAMESPACE\n-\n-#endif"}, {"sha": "81d8dbad462e283ef74403106220e9fd8d714565", "filename": "libstdc++-v3/include/profile/impl/profiler.h", "status": "modified", "additions": 172, "deletions": 66, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -43,6 +43,20 @@\n #include <stddef.h>\n #endif\n \n+// Mechanism to define data with inline linkage.\n+#define _GLIBCXX_PROFILE_DEFINE_DATA(__type, __name, __initial_value...) \\\n+  inline __type& __get_##__name() {                                      \\\n+    static __type __name(__initial_value);                               \\\n+    return __name;                                                       \\\n+  }\n+#define _GLIBCXX_PROFILE_DATA(__name) \\\n+  __get_##__name()\n+\n+/**\n+ * @namespace std::__cxxprof_guard\n+ * @brief Mechanism to protect all __gnu_profile operations against\n+ * multithreaded and exception reentrance.\n+ */\n namespace __gnu_profile\n {\n   /** @brief Reentrance guard.\n@@ -53,80 +67,127 @@ namespace __gnu_profile\n   struct __reentrance_guard\n   {\n     static bool\n-    _S_set_in()\n+    __get_in()\n     {\n-      if (_S_get_in())\n+      if (__inside() == true)\n \treturn false;\n       else\n \t{\n-\t  _S_get_in() = true;\n+\t  __inside() = true;\n \t  return true;\n \t}\n     }\n \n     static bool&\n-    _S_get_in()\n+    __inside()\n     {\n       static __thread bool _S_inside(false);\n       return _S_inside;\n     }\n \n     __reentrance_guard() { }\n-    ~__reentrance_guard() { _S_get_in() = false; }\n+    ~__reentrance_guard() { __inside() = false; }\n   };\n \n #define _GLIBCXX_PROFILE_REENTRANCE_GUARD(__x...)\t      \t\\\n   {                                                             \\\n-    if (__gnu_profile::__reentrance_guard::_S_get_in())\t \t\\\n+    if (__gnu_profile::__reentrance_guard::__get_in())          \\\n     {                                                           \\\n       __gnu_profile::__reentrance_guard __get_out; \t\t\\\n       __x;                                                      \\\n     }                                                           \\\n   }\n+}\n+\n+/**\n+ * @namespace std::__gnu_profile\n+ * @brief Implementation of profile extension.\n+ */\n+namespace __gnu_profile\n+{\n+// Forward declarations of implementation functions.\n+// Don't use any __gnu_profile:: in user code.\n+// Instead, use the __profcxx... macros, which offer guarded access.\n+bool __turn_on();\n+bool __turn_off();\n+bool __is_invalid();\n+bool __is_on();\n+bool __is_off();\n+void __report(void);\n+void __trace_hashtable_size_resize(const void*, size_t, size_t);\n+void __trace_hashtable_size_destruct(const void*, size_t, size_t);\n+void __trace_hashtable_size_construct(const void*, size_t);\n+void __trace_vector_size_resize(const void*, size_t, size_t);\n+void __trace_vector_size_destruct(const void*, size_t, size_t);\n+void __trace_vector_size_construct(const void*, size_t);\n+void __trace_hash_func_destruct(const void*, size_t, size_t, size_t);\n+void __trace_hash_func_construct(const void*);\n+void __trace_vector_to_list_destruct(const void*);\n+void __trace_vector_to_list_construct(const void*);\n+void __trace_vector_to_list_insert(const void*, size_t, size_t);\n+void __trace_vector_to_list_iterate(const void*, size_t);\n+void __trace_vector_to_list_invalid_operator(const void*);\n+void __trace_vector_to_list_resize(const void*, size_t, size_t);\n+void __trace_vector_to_list_find(const void*, size_t);\n+\n+void __trace_list_to_slist_destruct(const void*);\n+void __trace_list_to_slist_construct(const void*);\n+void __trace_list_to_slist_rewind(const void*); \n+void __trace_list_to_slist_operation(const void*);\n+\n+void __trace_list_to_vector_destruct(const void*);\n+void __trace_list_to_vector_construct(const void*);\n+void __trace_list_to_vector_insert(const void*, size_t, size_t); \n+void __trace_list_to_vector_iterate(const void*, size_t);\n+void __trace_list_to_vector_invalid_operator(const void*);\n+void __trace_list_to_vector_resize(const void*, size_t, size_t); \n \n+void __trace_list_to_set_destruct(const void*);\n+void __trace_list_to_set_construct(const void*);\n+void __trace_list_to_set_insert(const void*, size_t, size_t); \n+void __trace_list_to_set_iterate(const void*, size_t);\n+void __trace_list_to_set_invalid_operator(const void*);\n+void __trace_list_to_set_find(const void*, size_t); \n \n-  // Forward declarations of implementation functions.\n-  // Don't use any __gnu_profile:: in user code.\n-  // Instead, use the __profcxx... macros, which offer guarded access.\n-  void __turn_on();\n-  void __turn_off();\n-  bool __is_invalid();\n-  bool __is_on();\n-  bool __is_off();\n-  void __report(void);\n-  void __trace_hashtable_size_resize(const void*, size_t, size_t);\n-  void __trace_hashtable_size_destruct(const void*, size_t, size_t);\n-  void __trace_hashtable_size_construct(const void*, size_t);\n-  void __trace_vector_size_resize(const void*, size_t, size_t);\n-  void __trace_vector_size_destruct(const void*, size_t, size_t);\n-  void __trace_vector_size_construct(const void*, size_t);\n-  void __trace_hash_func_destruct(const void*, size_t, size_t, size_t);\n-  void __trace_hash_func_construct(const void*);\n-  void __trace_vector_to_list_destruct(const void*);\n-  void __trace_vector_to_list_construct(const void*);\n-  void __trace_vector_to_list_insert(const void*, size_t, size_t);\n-  void __trace_vector_to_list_iterate(const void*, size_t);\n-  void __trace_vector_to_list_invalid_operator(const void*);\n-  void __trace_vector_to_list_resize(const void*, size_t, size_t);\n-  void __trace_map_to_unordered_map_construct(const void*);\n-  void __trace_map_to_unordered_map_invalidate(const void*);\n-  void __trace_map_to_unordered_map_insert(const void*, size_t, size_t);\n-  void __trace_map_to_unordered_map_erase(const void*, size_t, size_t);\n-  void __trace_map_to_unordered_map_iterate(const void*, size_t);\n-  void __trace_map_to_unordered_map_find(const void*, size_t);\n-  void __trace_map_to_unordered_map_destruct(const void*);\n+void __trace_map_to_unordered_map_construct(const void*);\n+void __trace_map_to_unordered_map_invalidate(const void*);\n+void __trace_map_to_unordered_map_insert(const void*, size_t, size_t);\n+void __trace_map_to_unordered_map_erase(const void*, size_t, size_t);\n+void __trace_map_to_unordered_map_iterate(const void*, size_t);\n+void __trace_map_to_unordered_map_find(const void*, size_t);\n+void __trace_map_to_unordered_map_destruct(const void*);\n } // namespace __gnu_profile\n \n-// Master switch turns on all diagnostics.\n+// Master switch turns on all diagnostics that are not explicitly turned off.\n #ifdef _GLIBCXX_PROFILE\n+#ifndef _GLIBCXX_PROFILE_NO_HASHTABLE_TOO_SMALL\n #define _GLIBCXX_PROFILE_HASHTABLE_TOO_SMALL\n+#endif\n+#ifndef _GLIBCXX_PROFILE_NO_HASHTABLE_TOO_LARGE\n #define _GLIBCXX_PROFILE_HASHTABLE_TOO_LARGE\n+#endif\n+#ifndef _GLIBCXX_PROFILE_NO_VECTOR_TOO_SMALL\n #define _GLIBCXX_PROFILE_VECTOR_TOO_SMALL\n+#endif\n+#ifndef _GLIBCXX_PROFILE_NO_VECTOR_TOO_LARGE\n #define _GLIBCXX_PROFILE_VECTOR_TOO_LARGE\n+#endif\n+#ifndef _GLIBCXX_PROFILE_NO_INEFFICIENT_HASH\n #define _GLIBCXX_PROFILE_INEFFICIENT_HASH\n+#endif\n+#ifndef _GLIBCXX_PROFILE_NO_VECTOR_TO_LIST\n #define _GLIBCXX_PROFILE_VECTOR_TO_LIST\n+#endif\n+#ifndef _GLIBCXX_PROFILE_NO_LIST_TO_SLIST\n+#define _GLIBCXX_PROFILE_LIST_TO_SLIST\n+#endif\n+#ifndef _GLIBCXX_PROFILE_NO_LIST_TO_VECTOR\n+#define _GLIBCXX_PROFILE_LIST_TO_VECTOR\n+#endif\n+#ifndef _GLIBCXX_PROFILE_NO_MAP_TO_UNORDERED_MAP\n #define _GLIBCXX_PROFILE_MAP_TO_UNORDERED_MAP\n #endif\n+#endif\n \n // Expose global management routines to user code.\n #ifdef _GLIBCXX_PROFILE\n@@ -152,10 +213,8 @@ namespace __gnu_profile\n #endif\n \n // Turn on/off instrumentation for HASHTABLE_TOO_SMALL and HASHTABLE_TOO_LARGE.\n-#if ((defined(_GLIBCXX_PROFILE_HASHTABLE_TOO_SMALL) \\\n-      && !defined(_NO_GLIBCXX_PROFILE_HASHTABLE_TOO_SMALL)) \\\n-     || (defined(_GLIBCXX_PROFILE_HASHTABLE_TOO_LARGE) \\\n-\t && !defined(_NO_GLIBCXX_PROFILE_HASHTABLE_TOO_LARGE)))\n+#if (defined(_GLIBCXX_PROFILE_HASHTABLE_TOO_SMALL) \\\n+     || defined(_GLIBCXX_PROFILE_HASHTABLE_TOO_LARGE))\n #define __profcxx_hashtable_resize(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_hashtable_size_resize(__x))\n@@ -166,16 +225,14 @@ namespace __gnu_profile\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_hashtable_size_construct(__x))\n #else\n-#define __profcxx_hashtable_resize(__x...)\n-#define __profcxx_hashtable_destruct(__x...)\n-#define __profcxx_hashtable_construct(__x...)\n+#define __profcxx_hashtable_resize(__x...)  \n+#define __profcxx_hashtable_destruct(__x...) \n+#define __profcxx_hashtable_construct(__x...)  \n #endif\n \n // Turn on/off instrumentation for VECTOR_TOO_SMALL and VECTOR_TOO_LARGE.\n-#if ((defined(_GLIBCXX_PROFILE_VECTOR_TOO_SMALL) \\\n-      && !defined(_NO_GLIBCXX_PROFILE_VECTOR_TOO_SMALL)) \\\n-     || (defined(_GLIBCXX_PROFILE_VECTOR_TOO_LARGE) \\\n-\t && !defined(_NO_GLIBCXX_PROFILE_VECTOR_TOO_LARGE)))\n+#if (defined(_GLIBCXX_PROFILE_VECTOR_TOO_SMALL) \\\n+     || defined(_GLIBCXX_PROFILE_VECTOR_TOO_LARGE))\n #define __profcxx_vector_resize(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_vector_size_resize(__x))\n@@ -186,28 +243,26 @@ namespace __gnu_profile\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_vector_size_construct(__x))\n #else\n-#define __profcxx_vector_resize(__x...)\n-#define __profcxx_vector_destruct(__x...)\n-#define __profcxx_vector_construct(__x...)\n-#endif\n+#define __profcxx_vector_resize(__x...)  \n+#define __profcxx_vector_destruct(__x...) \n+#define __profcxx_vector_construct(__x...)  \n+#endif \n \n // Turn on/off instrumentation for INEFFICIENT_HASH.\n-#if (defined(_GLIBCXX_PROFILE_INEFFICIENT_HASH) \\\n-     && !defined(_NO_GLIBCXX_PROFILE_INEFFICIENT_HASH))\n+#if defined(_GLIBCXX_PROFILE_INEFFICIENT_HASH)\n #define __profcxx_hashtable_construct2(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_hash_func_construct(__x))\n #define __profcxx_hashtable_destruct2(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_hash_func_destruct(__x))\n #else\n-#define __profcxx_hashtable_destruct2(__x...)\n-#define __profcxx_hashtable_construct2(__x...)\n+#define __profcxx_hashtable_destruct2(__x...) \n+#define __profcxx_hashtable_construct2(__x...)  \n #endif\n \n // Turn on/off instrumentation for VECTOR_TO_LIST.\n-#if (defined(_GLIBCXX_PROFILE_VECTOR_TO_LIST) \\\n-     && !defined(_NO_GLIBCXX_PROFILE_VECTOR_TO_LIST))\n+#if defined(_GLIBCXX_PROFILE_VECTOR_TO_LIST)\n #define __profcxx_vector_construct2(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_vector_to_list_construct(__x))\n@@ -226,18 +281,67 @@ namespace __gnu_profile\n #define __profcxx_vector_resize2(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_vector_to_list_resize(__x))\n+#define __profcxx_vector_find(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_vector_to_list_find(__x))\n #else\n #define __profcxx_vector_destruct2(__x...)\n #define __profcxx_vector_construct2(__x...)\n #define __profcxx_vector_insert(__x...)\n #define __profcxx_vector_iterate(__x...)\n #define __profcxx_vector_invalid_operator(__x...)\n #define __profcxx_vector_resize2(__x...)\n+#define __profcxx_vector_find(__x...)\n #endif\n \n+// Turn on/off instrumentation for LIST_TO_VECTOR. \n+#if defined(_GLIBCXX_PROFILE_LIST_TO_VECTOR)\n+#define __profcxx_list_construct2(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_vector_construct(__x))\n+#define __profcxx_list_destruct2(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_vector_destruct(__x))\n+#define __profcxx_list_insert(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_vector_insert(__x))\n+#define __profcxx_list_iterate(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_vector_iterate(__x))\n+#define __profcxx_list_invalid_operator(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_vector_invalid_operator(__x))\n+#else\n+#define __profcxx_list_destruct2(__x...)\n+#define __profcxx_list_construct2(__x...)\n+#define __profcxx_list_insert(__x...)\n+#define __profcxx_list_iterate(__x...)\n+#define __profcxx_list_invalid_operator(__x...)\n+#endif\n+\n+// Turn on/off instrumentation for LIST_TO_SLIST.  \n+#if defined(_GLIBCXX_PROFILE_LIST_TO_SLIST)\n+#define __profcxx_list_rewind(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_slist_rewind(__x))\n+#define __profcxx_list_operation(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_slist_operation(__x))\n+#define __profcxx_list_destruct(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_slist_destruct(__x))\n+#define __profcxx_list_construct(__x...) \\\n+  _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n+      __gnu_profile::__trace_list_to_slist_construct(__x))\n+#else\n+#define __profcxx_list_rewind(__x...)  \n+#define __profcxx_list_operation(__x...)\n+#define __profcxx_list_destruct(__x...) \n+#define __profcxx_list_construct(__x...)  \n+#endif \n+\n // Turn on/off instrumentation for MAP_TO_UNORDERED_MAP.\n-#if (defined(_GLIBCXX_PROFILE_MAP_TO_UNORDERED_MAP) \\\n-     && !defined(_NO_GLIBCXX_PROFILE_MAP_TO_UNORDERED_MAP))\n+#if defined(_GLIBCXX_PROFILE_MAP_TO_UNORDERED_MAP)\n #define __profcxx_map_to_unordered_map_construct(__x...) \\\n   _GLIBCXX_PROFILE_REENTRANCE_GUARD( \\\n       __gnu_profile::__trace_map_to_unordered_map_construct(__x))\n@@ -261,7 +365,7 @@ namespace __gnu_profile\n       __gnu_profile::__trace_map_to_unordered_map_find(__x))\n #else\n #define __profcxx_map_to_unordered_map_construct(__x...) \\\n-\n+  \n #define __profcxx_map_to_unordered_map_destruct(__x...)\n #define __profcxx_map_to_unordered_map_insert(__x...)\n #define __profcxx_map_to_unordered_map_erase(__x...)\n@@ -271,7 +375,7 @@ namespace __gnu_profile\n #endif\n \n // Run multithreaded unless instructed not to do so.\n-#ifndef _GLIBCXX_PROFILE_NOTHREADS\n+#ifndef _GLIBCXX_PROFILE_NO_THREADS\n #define _GLIBCXX_PROFILE_THREADS\n #endif\n \n@@ -280,11 +384,11 @@ namespace __gnu_profile\n #define _GLIBCXX_PROFILE_TRACE_PATH_ROOT \"libstdcxx-profile\"\n #endif\n #ifndef _GLIBCXX_PROFILE_TRACE_ENV_VAR\n-#define _GLIBCXX_PROFILE_TRACE_ENV_VAR \"GLIBCXX_PROFILE_TRACE_PATH_ROOT\"\n+#define _GLIBCXX_PROFILE_TRACE_ENV_VAR \"_GLIBCXX_PROFILE_TRACE_PATH_ROOT\"\n #endif\n #ifndef _GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR\n #define _GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR \\\n-  \"GLIBCXX_PROFILE_MAX_WARN_COUNT\"\n+  \"_GLIBCXX_PROFILE_MAX_WARN_COUNT\"\n #endif\n #ifndef _GLIBCXX_PROFILE_MAX_WARN_COUNT\n #define _GLIBCXX_PROFILE_MAX_WARN_COUNT 10\n@@ -294,14 +398,14 @@ namespace __gnu_profile\n #endif\n #ifndef _GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR\n #define _GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR \\\n-  \"GLIBCXX_PROFILE_MAX_STACK_DEPTH\"\n+  \"_GLIBCXX_PROFILE_MAX_STACK_DEPTH\"\n #endif\n #ifndef _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC\n #define _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC 2 << 27\n #endif\n #ifndef _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR\n #define _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR \\\n-  \"GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC\"\n+  \"_GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC\"\n #endif\n \n // Instrumentation hook implementations.\n@@ -310,5 +414,7 @@ namespace __gnu_profile\n #include \"profile/impl/profiler_map_to_unordered_map.h\"\n #include \"profile/impl/profiler_vector_size.h\"\n #include \"profile/impl/profiler_vector_to_list.h\"\n+#include \"profile/impl/profiler_list_to_slist.h\"\n+#include \"profile/impl/profiler_list_to_vector.h\"\n \n #endif // _GLIBCXX_PROFILE_PROFILER_H"}, {"sha": "bfbab85199be1eb425e48615df5e190c1cdffaed", "filename": "libstdc++-v3/include/profile/impl/profiler_container_size.h", "status": "modified", "additions": 170, "deletions": 188, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -47,214 +47,196 @@\n #include <string.h>\n #endif\n \n+#include <sstream>\n+\n #include \"profile/impl/profiler.h\"\n #include \"profile/impl/profiler_node.h\"\n #include \"profile/impl/profiler_trace.h\"\n \n namespace __gnu_profile\n {\n-  /** @brief A container size instrumentation line in the object table.  */\n-  class __container_size_info: public __object_info_base\n-  {\n-  public:\n-    __container_size_info();\n-    __container_size_info(const __container_size_info& __o);\n-    __container_size_info(__stack_t __stack, size_t __num);\n-    virtual ~__container_size_info() { }\n-\n-    void __write(FILE* f) const;\n-    float __magnitude() const { return static_cast<float>(_M_cost); }\n-    const char* __advice() const;\n-\n-    void __merge(const __container_size_info& __o);\n-\n-    // Call if a container is destructed or cleaned.\n-    void __destruct(size_t __num, size_t __inum);\n-\n-    // Estimate the cost of resize/rehash.\n-    float __resize_cost(size_t __from, size_t __to) { return __from; }\n-\n-    // Call if container is resized.\n-    void __resize(size_t __from, size_t __to);\n-\n-  private:\n-    size_t _M_init;\n-    size_t _M_max;  // Range of # buckets.\n-    size_t _M_min;\n-    size_t _M_total;\n-    size_t _M_item_min;  // Range of # items.\n-    size_t _M_item_max;\n-    size_t _M_item_total;\n-    size_t _M_count;\n-    size_t _M_resize;\n-    size_t _M_cost;\n-  };\n-\n-  inline const char* \n-  __container_size_info::__advice() const\n-  {\n-    const size_t __max_chars_size_t_printed = 20;\n-    const char* __message_pattern =\n-      \"change initial container size from %d to %d\";\n-    size_t __message_size = (strlen(__message_pattern)\n-\t\t\t     + 2 * __max_chars_size_t_printed\n-\t\t\t     - 2 * 2);\n-    char* __message = new char[__message_size + 1];\n-\n-    if (_M_init < _M_item_max)\n-      snprintf(__message, __message_size, __message_pattern, _M_init,\n-\t       _M_item_max);\n-    else\n-      snprintf(__message, __message_size, __message_pattern, _M_init,\n-\t       _M_item_max);\n-\n-    return __message;\n-  }\n \n-  inline void \n-  __container_size_info::__destruct(size_t __num, size_t __inum)\n-  {\n-    _M_max = __max(_M_max, __num);\n-    _M_item_max = __max(_M_item_max, __inum);\n-    if (_M_min == 0) \n-      {\n-\t_M_min = __num;\n-\t_M_item_min = __inum;\n-      } \n-    else \n-      {\n-\t_M_min = __min(_M_min, __num);\n-\t_M_item_min = __min(_M_item_min, __inum);\n-      }\n-    _M_total += __num;\n-    _M_item_total += __inum;\n-    _M_count += 1;\n-  }\n+/** @brief A container size instrumentation line in the object table.  */\n+class __container_size_info: public __object_info_base \n+{\n+ public:\n+  __container_size_info();\n+  __container_size_info(const __container_size_info& __o);\n+  __container_size_info(__stack_t __stack, size_t __num);\n+  virtual ~__container_size_info() {}\n+\n+  void __write(FILE* f) const;\n+  float __magnitude() const { return static_cast<float>(_M_cost); }\n+  const char* __advice() const;\n+\n+  void __merge(const __container_size_info& __o);\n+  // Call if a container is destructed or cleaned.\n+  void __destruct(size_t __num, size_t __inum);\n+  // Estimate the cost of resize/rehash. \n+  float __resize_cost(size_t __from, size_t __to) { return __from; }\n+  // Call if container is resized.\n+  void __resize(size_t __from, size_t __to);\n+\n+ private:\n+  size_t _M_init;\n+  size_t _M_max;  // range of # buckets\n+  size_t _M_min;\n+  size_t _M_total;\n+  size_t _M_item_min;  // range of # items\n+  size_t _M_item_max;\n+  size_t _M_item_total;\n+  size_t _M_count;\n+  size_t _M_resize;\n+  size_t _M_cost;\n+};\n+\n+inline const char* __container_size_info::__advice() const\n+{\n+  std::stringstream __message;\n+  if (_M_init < _M_item_max)\n+    __message << \"change initial container size from \" << _M_init\n+              << \" to \" << _M_item_max;\n \n-  inline void \n-  __container_size_info::__resize(size_t __from, size_t __to)\n-  {\n-    _M_cost += this->__resize_cost(__from, __to);\n-    _M_resize += 1;\n-    _M_max = __max(_M_max, __to);\n-  }\n+  return strdup(__message.str().c_str());\n+}\n \n-  inline void \n-  __container_size_info::__merge(const __container_size_info& __o)\n-  {\n-    _M_init        = __max(_M_init, __o._M_init);\n-    _M_max         = __max(_M_max, __o._M_max);\n-    _M_item_max    = __max(_M_item_max, __o._M_item_max);\n-    _M_min         = __min(_M_min, __o._M_min);\n-    _M_item_min    = __min(_M_item_min, __o._M_item_min);\n-    _M_total      += __o._M_total;\n-    _M_item_total += __o._M_item_total;\n-    _M_count      += __o._M_count;\n-    _M_cost       += __o._M_cost;\n-    _M_resize     += __o._M_resize;\n+inline void __container_size_info::__destruct(size_t __num, size_t __inum) \n+{\n+  _M_max = __max(_M_max, __num);\n+  _M_item_max = __max(_M_item_max, __inum);\n+  if (_M_min == 0) {\n+    _M_min = __num; \n+    _M_item_min = __inum;\n+  } else {\n+    _M_min = __min(_M_min, __num);\n+    _M_item_min = __min(_M_item_min, __inum);\n   }\n+  _M_total += __num;\n+  _M_item_total += __inum;\n+  _M_count += 1;\n+}\n \n-  inline __container_size_info::__container_size_info()\n-  : _M_init(0), _M_max(0), _M_item_max(0), _M_min(0), _M_item_min(0),\n-    _M_total(0), _M_item_total(0), _M_cost(0), _M_count(0), _M_resize(0)\n-  { }\n-\n-  inline __container_size_info::__container_size_info(__stack_t __stack,\n-\t\t\t\t\t\t      size_t __num)\n-  : __object_info_base(__stack), _M_init(0), _M_max(0), _M_item_max(0),\n-    _M_min(0), _M_item_min(0), _M_total(0), _M_item_total(0), _M_cost(0),\n-    _M_count(0), _M_resize(0)\n-  {\n-    _M_init = _M_max = __num;\n-    _M_item_min = _M_item_max = _M_item_total = _M_total = 0;\n-    _M_min = 0;\n-    _M_count = 0;\n-    _M_resize = 0;\n-  }\n+inline void __container_size_info::__resize(size_t __from, size_t __to) \n+{\n+  _M_cost += this->__resize_cost(__from, __to);\n+  _M_resize += 1;\n+  _M_max = __max(_M_max, __to);\n+}\n+\n+inline __container_size_info::__container_size_info(__stack_t __stack, \n+                                                    size_t __num)\n+    : __object_info_base(__stack), _M_init(0), _M_max(0), _M_item_max(0), \n+      _M_min(0), _M_item_min(0), _M_total(0), _M_item_total(0), _M_cost(0), \n+      _M_count(0), _M_resize(0)\n+{\n+  _M_init = _M_max = __num;\n+  _M_item_min = _M_item_max = _M_item_total = _M_total = 0;\n+  _M_min = 0;\n+  _M_count = 0;\n+  _M_resize = 0;\n+}\n+\n+inline void __container_size_info::__merge(const __container_size_info& __o)\n+{\n+  _M_init        = __max(_M_init, __o._M_init);\n+  _M_max         = __max(_M_max, __o._M_max);\n+  _M_item_max    = __max(_M_item_max, __o._M_item_max);\n+  _M_min         = __min(_M_min, __o._M_min);\n+  _M_item_min    = __min(_M_item_min, __o._M_item_min);\n+  _M_total      += __o._M_total;\n+  _M_item_total += __o._M_item_total;\n+  _M_count      += __o._M_count;\n+  _M_cost       += __o._M_cost;\n+  _M_resize     += __o._M_resize;\n+}\n+\n+inline __container_size_info::__container_size_info()\n+    : _M_init(0), _M_max(0), _M_item_max(0), _M_min(0), _M_item_min(0),\n+      _M_total(0), _M_item_total(0), _M_cost(0), _M_count(0), _M_resize(0)\n+{\n+}\n \n-  inline __container_size_info::__container_size_info(const __container_size_info& __o)\n+inline __container_size_info::__container_size_info(\n+    const __container_size_info& __o)\n     : __object_info_base(__o)\n-  {\n-    _M_init        = __o._M_init;\n-    _M_max         = __o._M_max;\n-    _M_item_max    = __o._M_item_max;\n-    _M_min         = __o._M_min;\n-    _M_item_min    = __o._M_item_min;\n-    _M_total       = __o._M_total;\n-    _M_item_total  = __o._M_item_total;\n-    _M_cost        = __o._M_cost;\n-    _M_count       = __o._M_count;\n-    _M_resize      = __o._M_resize;\n-  }\n+{\n+  _M_init        = __o._M_init;\n+  _M_max         = __o._M_max;\n+  _M_item_max    = __o._M_item_max;\n+  _M_min         = __o._M_min;\n+  _M_item_min    = __o._M_item_min;\n+  _M_total       = __o._M_total;\n+  _M_item_total  = __o._M_item_total;\n+  _M_cost        = __o._M_cost;\n+  _M_count       = __o._M_count;\n+  _M_resize      = __o._M_resize;\n+}\n+\n+/** @brief A container size instrumentation line in the stack table.  */\n+class __container_size_stack_info: public __container_size_info\n+{\n+ public:\n+  __container_size_stack_info(const __container_size_info& __o)\n+      : __container_size_info(__o) {}\n+};\n+\n+/** @brief Container size instrumentation trace producer.  */\n+class __trace_container_size\n+    : public __trace_base<__container_size_info, __container_size_stack_info> \n+{\n+ public:\n+  ~__trace_container_size() {}\n+  __trace_container_size()\n+      : __trace_base<__container_size_info, __container_size_stack_info>() {};\n+\n+  // Insert a new node at construct with object, callstack and initial size. \n+  void __insert(const __object_t __obj, __stack_t __stack, size_t __num);\n+  // Call at destruction/clean to set container final size.\n+  void __destruct(const void* __obj, size_t __num, size_t __inum);\n+  void __construct(const void* __obj, size_t __inum);\n+  // Call at resize to set resize/cost information.\n+  void __resize(const void* __obj, int __from, int __to);\n+};\n+\n+inline void __trace_container_size::__insert(const __object_t __obj,\n+                                             __stack_t __stack, size_t __num)\n+{\n+  __add_object(__obj, __container_size_info(__stack, __num));\n+}\n \n-  /** @brief A container size instrumentation line in the stack table.  */\n-  class __container_size_stack_info: public __container_size_info\n-  {\n-  public:\n-    __container_size_stack_info(const __container_size_info& __o)\n-    : __container_size_info(__o) { }\n-  };\n-\n-  /** @brief Container size instrumentation trace producer.  */\n-  class __trace_container_size\n-  : public __trace_base<__container_size_info, __container_size_stack_info>\n-  {\n-  public:\n-    __trace_container_size()\n-    : __trace_base<__container_size_info, __container_size_stack_info>() { };\n-\n-    ~__trace_container_size() { }\n-\n-    // Insert a new node at construct with object, callstack and initial size.\n-    void __insert(const __object_t __obj, __stack_t __stack, size_t __num);\n-\n-    // Call at destruction/clean to set container final size.\n-    void __destruct(const void* __obj, size_t __num, size_t __inum);\n-    void __construct(const void* __obj, size_t __inum);\n-\n-    // Call at resize to set resize/cost information.\n-    void __resize(const void* __obj, int __from, int __to);\n-  };\n-\n-  inline void \n-  __trace_container_size::__insert(const __object_t __obj,\n-\t\t\t\t   __stack_t __stack, size_t __num)\n-  { __add_object(__obj, __container_size_info(__stack, __num)); }\n-\n-  inline void \n-  __container_size_info::__write(FILE* __f) const\n-  {\n-    fprintf(__f, \"%Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu\\n\",\n-\t    _M_init, _M_count, _M_cost, _M_resize, _M_min, _M_max, _M_total,\n-\t    _M_item_min, _M_item_max, _M_item_total);\n-  }\n+inline void __container_size_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu\\n\", \n+          _M_init, _M_count, _M_cost, _M_resize, _M_min, _M_max, _M_total,\n+          _M_item_min, _M_item_max, _M_item_total);\n+}\n \n-  inline void \n-  __trace_container_size::__destruct(const void* __obj, size_t __num, \n-\t\t\t\t     size_t __inum)\n-  {\n-    if (!__is_on()) return;\n+inline void __trace_container_size::__destruct(const void* __obj, \n+                                               size_t __num, size_t __inum)\n+{\n+  if (!__is_on()) return;\n \n-    __object_t __obj_handle = static_cast<__object_t>(__obj);\n+  __object_t __obj_handle = static_cast<__object_t>(__obj);\n \n-    __container_size_info* __object_info = __get_object_info(__obj_handle);\n-    if (!__object_info)\n-      return;\n+  __container_size_info* __object_info = __get_object_info(__obj_handle);\n+  if (!__object_info)\n+    return;\n \n-    __object_info->__destruct(__num, __inum);\n-    __retire_object(__obj_handle);\n-  }\n+  __object_info->__destruct(__num, __inum);\n+  __retire_object(__obj_handle);\n+}\n \n-  inline void \n-  __trace_container_size::__resize(const void* __obj, int __from, int __to)\n-  {\n-    if (!__is_on()) return;\n+inline void __trace_container_size::__resize(const void* __obj, int __from, \n+                                             int __to)\n+{\n+  if (!__is_on()) return;\n \n-    __container_size_info* __object_info = __get_object_info(__obj);\n-    if (!__object_info)\n-      return;\n+  __container_size_info* __object_info = __get_object_info(__obj);\n+  if (!__object_info)\n+    return;\n+\n+  __object_info->__resize(__from, __to);\n+}\n \n-    __object_info->__resize(__from, __to);\n-  }\n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_CONTAINER_SIZE_H */"}, {"sha": "95fad192590b0b29e6df3833e1f9367b4de32b27", "filename": "libstdc++-v3/include/profile/impl/profiler_hash_func.h", "status": "modified", "additions": 116, "deletions": 125, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -52,143 +52,134 @@\n \n namespace __gnu_profile\n {\n-  /** @brief A hash performance instrumentation line in the object table.  */\n-  class __hashfunc_info: public __object_info_base\n-  {\n-  public:\n-    __hashfunc_info() :_M_longest_chain(0), _M_accesses(0), _M_hops(0) { }\n-\n-    __hashfunc_info(const __hashfunc_info& o);\n-\n-    __hashfunc_info(__stack_t __stack) \n-    : __object_info_base(__stack), _M_longest_chain(0), \n-      _M_accesses(0), _M_hops(0) { }\n-\n-    virtual ~__hashfunc_info() { }\n-\n-    void __merge(const __hashfunc_info& __o);\n-    void __destruct(size_t __chain, size_t __accesses, size_t __hops);\n-    void __write(FILE* __f) const;\n-    float __magnitude() const { return static_cast<float>(_M_hops); }\n-    const char* __advice() const { return \"change hash function\"; }\n-\n-  private:\n-    size_t _M_longest_chain;\n-    size_t _M_accesses;\n-    size_t _M_hops;\n-  };\n-\n-  inline __hashfunc_info::__hashfunc_info(const __hashfunc_info& __o)\n-  : __object_info_base(__o)\n-  {\n-    _M_longest_chain = __o._M_longest_chain;\n-    _M_accesses      = __o._M_accesses;\n-    _M_hops          = __o._M_hops;\n-  }\n \n-  inline void \n-  __hashfunc_info::__merge(const __hashfunc_info& __o)\n-  {\n-    _M_longest_chain  = __max(_M_longest_chain, __o._M_longest_chain);\n-    _M_accesses      += __o._M_accesses;\n-    _M_hops          += __o._M_hops;\n-  }\n+/** @brief A hash performance instrumentation line in the object table.  */\n+class __hashfunc_info: public __object_info_base\n+{\n+ public:\n+  __hashfunc_info()\n+      :_M_longest_chain(0), _M_accesses(0), _M_hops(0) {}\n+  __hashfunc_info(const __hashfunc_info& o);\n+  __hashfunc_info(__stack_t __stack)\n+      : __object_info_base(__stack),\n+        _M_longest_chain(0), _M_accesses(0), _M_hops(0){} \n+  virtual ~__hashfunc_info() {}\n+\n+  void __merge(const __hashfunc_info& __o);\n+  void __destruct(size_t __chain, size_t __accesses, size_t __hops);\n+  void __write(FILE* __f) const;\n+  float __magnitude() const { return static_cast<float>(_M_hops); }\n+  const char* __advice() const { return strdup(\"change hash function\"); }\n+\n+private:\n+  size_t _M_longest_chain;\n+  size_t _M_accesses;\n+  size_t _M_hops;\n+};\n+\n+inline __hashfunc_info::__hashfunc_info(const __hashfunc_info& __o)\n+    : __object_info_base(__o)\n+{\n+  _M_longest_chain = __o._M_longest_chain;\n+  _M_accesses      = __o._M_accesses;\n+  _M_hops          = __o._M_hops;\n+}\n \n-  inline void \n-  __hashfunc_info::__destruct(size_t __chain, size_t __accesses, size_t __hops)\n-  {\n-    _M_longest_chain  = __max(_M_longest_chain, __chain);\n-    _M_accesses      += __accesses;\n-    _M_hops          += __hops;\n-  }\n+inline void __hashfunc_info::__merge(const __hashfunc_info& __o)\n+{\n+  _M_longest_chain  = __max(_M_longest_chain, __o._M_longest_chain);\n+  _M_accesses      += __o._M_accesses;\n+  _M_hops          += __o._M_hops;\n+}\n+\n+inline void __hashfunc_info::__destruct(size_t __chain, size_t __accesses, \n+                                        size_t __hops)\n+{ \n+  _M_longest_chain  = __max(_M_longest_chain, __chain);\n+  _M_accesses      += __accesses;\n+  _M_hops          += __hops;\n+}\n+\n+/** @brief A hash performance instrumentation line in the stack table.  */\n+class __hashfunc_stack_info: public __hashfunc_info {\n+ public:\n+  __hashfunc_stack_info(const __hashfunc_info& __o) : __hashfunc_info(__o) {}\n+};\n+\n+/** @brief Hash performance instrumentation producer.  */\n+class __trace_hash_func\n+    : public __trace_base<__hashfunc_info, __hashfunc_stack_info> \n+{\n+ public:\n+  __trace_hash_func();\n+  ~__trace_hash_func() {}\n+\n+  // Insert a new node at construct with object, callstack and initial size. \n+  void __insert(__object_t __obj, __stack_t __stack);\n+  // Call at destruction/clean to set container final size.\n+  void __destruct(const void* __obj, size_t __chain,\n+                  size_t __accesses, size_t __hops);\n+};\n+\n+inline __trace_hash_func::__trace_hash_func()\n+    : __trace_base<__hashfunc_info, __hashfunc_stack_info>()\n+{\n+  __id = \"hash-distr\";\n+}\n \n-  /** @brief A hash performance instrumentation line in the stack table.  */\n-  class __hashfunc_stack_info: public __hashfunc_info \n-  {\n-  public:\n-    __hashfunc_stack_info(const __hashfunc_info& __o) : __hashfunc_info(__o) { }\n-  };\n-\n-  /** @brief Hash performance instrumentation producer.  */\n-  class __trace_hash_func\n-  : public __trace_base<__hashfunc_info, __hashfunc_stack_info>\n-  {\n-  public:\n-    __trace_hash_func();\n-    ~__trace_hash_func() { }\n-\n-    // Insert a new node at construct with object, callstack and initial size.\n-    void __insert(__object_t __obj, __stack_t __stack);\n-\n-    // Call at destruction/clean to set container final size.\n-    void __destruct(const void* __obj, size_t __chain, size_t __accesses, \n-\t\t    size_t __hops);\n-  };\n-\n-  inline __trace_hash_func::__trace_hash_func()\n-  : __trace_base<__hashfunc_info, __hashfunc_stack_info>()\n-  { __id = \"hash-distr\"; }\n-\n-  inline void \n-  __trace_hash_func::__insert(__object_t __obj, __stack_t __stack)\n-  { __add_object(__obj, __hashfunc_info(__stack)); }\n-\n-  inline void \n-  __hashfunc_info::__write(FILE* __f) const\n-  { fprintf(__f, \"%Zu %Zu %Zu\\n\", _M_hops, _M_accesses, _M_longest_chain); }\n-\n-  inline void \n-  __trace_hash_func::__destruct(const void* __obj, size_t __chain,\n-\t\t\t\tsize_t __accesses, size_t __hops)\n-  {\n-    if (!__is_on()) \n-      return;\n-\n-    // First find the item from the live objects and update the informations.\n-    __hashfunc_info* __objs = __get_object_info(__obj);\n-    if (!__objs)\n-      return;\n-\n-    __objs->__destruct(__chain, __accesses, __hops);\n-    __retire_object(__obj);\n-  }\n+inline void __trace_hash_func::__insert(__object_t __obj, __stack_t __stack)\n+{\n+  __add_object(__obj, __hashfunc_info(__stack));\n+}\n \n+inline void __hashfunc_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu\\n\", _M_hops, _M_accesses, _M_longest_chain);\n+}\n \n-  // Initialization and report.\n-  inline void \n-  __trace_hash_func_init()\n-  { __tables<0>::_S_hash_func = new __trace_hash_func(); }\n+inline void __trace_hash_func::__destruct(const void* __obj, size_t __chain,\n+                                          size_t __accesses, size_t __hops)\n+{\n+  if (!__is_on()) return;\n \n-  inline void \n-  __trace_hash_func_report(FILE* __f, __warning_vector_t& __warnings)\n-  {\n-    if (__tables<0>::_S_hash_func) \n-      {\n-\t__tables<0>::_S_hash_func->__collect_warnings(__warnings);\n-\t__tables<0>::_S_hash_func->__write(__f);\n-      }\n-  }\n+  // First find the item from the live objects and update the informations.\n+  __hashfunc_info* __objs = __get_object_info(__obj);\n+  if (!__objs)\n+    return;\n \n+  __objs->__destruct(__chain, __accesses, __hops);\n+  __retire_object(__obj);\n+}\n \n-  // Implementations of instrumentation hooks.\n-  inline void \n-  __trace_hash_func_construct(const void* __obj)\n-  {\n-    if (!__profcxx_init()) \n-      return;\n+inline void __trace_hash_func_init()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_hash_func) = new __trace_hash_func();\n+}\n \n-    __tables<0>::_S_hash_func->__insert(__obj, __get_stack());\n+inline void __trace_hash_func_report(FILE* __f,\n+                                     __warning_vector_t& __warnings)\n+{\n+  if (_GLIBCXX_PROFILE_DATA(_S_hash_func)) {\n+    _GLIBCXX_PROFILE_DATA(_S_hash_func)->__collect_warnings(__warnings);\n+    _GLIBCXX_PROFILE_DATA(_S_hash_func)->__write(__f);\n   }\n+}\n \n-  inline void \n-  __trace_hash_func_destruct(const void* __obj, size_t __chain,\n-\t\t\t     size_t __accesses, size_t __hops)\n-  {\n-    if (!__profcxx_init()) \n-      return;\n+inline void __trace_hash_func_construct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __tables<0>::_S_hash_func->__destruct(__obj, __chain, __accesses, __hops);\n-  }\n+  _GLIBCXX_PROFILE_DATA(_S_hash_func)->__insert(__obj, __get_stack());\n+}\n+\n+inline void __trace_hash_func_destruct(const void* __obj, size_t __chain,\n+                                       size_t __accesses, size_t __hops)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_hash_func)->__destruct(__obj, __chain, __accesses, \n+                                                  __hops);\n+}\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_HASH_FUNC_H */"}, {"sha": "8248f47e75d9562ef236f23ff236548a2464f975", "filename": "libstdc++-v3/include/profile/impl/profiler_hashtable_size.h", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -54,57 +54,54 @@\n \n namespace __gnu_profile\n {\n-  /** @brief Hashtable size instrumentation trace producer.  */\n-  class __trace_hashtable_size : public __trace_container_size\n-  {\n-  public:\n-    __trace_hashtable_size() : __trace_container_size()\n-    { __id = \"hashtable-size\"; }\n-  };\n-\n-  // Initialization and report.\n-  inline void\n-  __trace_hashtable_size_init()\n-  { __tables<0>::_S_hashtable_size = new __trace_hashtable_size(); }\n-\n-  inline void\n-  __trace_hashtable_size_report(FILE* __f, __warning_vector_t& __warnings)\n+\n+/** @brief Hashtable size instrumentation trace producer.  */\n+class __trace_hashtable_size : public __trace_container_size\n+{\n+ public:\n+  __trace_hashtable_size() : __trace_container_size()\n   {\n-    if (__tables<0>::_S_hashtable_size)\n-      {\n-\t__tables<0>::_S_hashtable_size->__collect_warnings(__warnings);\n-\t__tables<0>::_S_hashtable_size->__write(__f);\n-      }\n+    __id = \"hashtable-size\";\n   }\n+};\n \n-  // Implementations of instrumentation hooks.\n-  inline void\n-  __trace_hashtable_size_construct(const void* __obj, size_t __num)\n-  {\n-    if (!__profcxx_init())\n-      return;\n+inline void __trace_hashtable_size_init()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_hashtable_size) = new __trace_hashtable_size();\n+}\n \n-    __tables<0>::_S_hashtable_size->__insert(__obj, __get_stack(), __num);\n+inline void __trace_hashtable_size_report(FILE* __f, \n+                                          __warning_vector_t& __warnings)\n+{\n+  if (_GLIBCXX_PROFILE_DATA(_S_hashtable_size)) {\n+    _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__collect_warnings(__warnings);\n+    _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__write(__f);\n   }\n+}\n \n-  inline void\n-  __trace_hashtable_size_destruct(const void* __obj, size_t __num,\n-\t\t\t\t  size_t __inum)\n-  {\n-    if (!__profcxx_init())\n-      return;\n+inline void __trace_hashtable_size_construct(const void* __obj, size_t __num)\n+{\n+  if (!__profcxx_init()) return;\n+  \n+  _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__insert(__obj, __get_stack(),\n+                                                     __num);\n+}\n+\n+inline void __trace_hashtable_size_destruct(const void* __obj, size_t __num, \n+                                            size_t __inum)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __tables<0>::_S_hashtable_size->__destruct(__obj, __num, __inum);\n-  }\n+  _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__destruct(__obj, __num, __inum);\n+}\n \n-  inline void\n-  __trace_hashtable_size_resize(const void* __obj, size_t __from, size_t __to)\n-  {\n-    if (!__profcxx_init())\n-      return;\n+inline void __trace_hashtable_size_resize(const void* __obj, size_t __from, \n+                                          size_t __to)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __tables<0>::_S_hashtable_size->__resize(__obj, __from, __to);\n-  }\n+  _GLIBCXX_PROFILE_DATA(_S_hashtable_size)->__resize(__obj, __from, __to);\n+}\n \n } // namespace __gnu_profile\n "}, {"sha": "073bdf275871c99f9fa60b7f1e1a0a1a48d3d4d9", "filename": "libstdc++-v3/include/profile/impl/profiler_list_to_slist.h", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_slist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_slist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_slist.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -0,0 +1,182 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_list_to_slist.h\n+ *  @brief Diagnostics for list to slist.\n+ */\n+\n+// Written by Changhee Jung.\n+\n+#ifndef _GLIBCXX_PROFILE_PROFILER_LIST_TO_SLIST_H\n+#define _GLIBCXX_PROFILE_PROFILER_LIST_TO_SLIST_H 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdlib>\n+#include <cstdio>\n+#include <cstring>\n+#else\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#endif\n+#include \"profile/impl/profiler.h\"\n+#include \"profile/impl/profiler_node.h\"\n+#include \"profile/impl/profiler_trace.h\"\n+\n+namespace __gnu_profile\n+{\n+\n+class __list2slist_info: public __object_info_base\n+{\n+ public:\n+  __list2slist_info() : _M_rewind(false), _M_operations(0) {}\n+  __list2slist_info(__stack_t __stack) \n+      : _M_rewind(false), _M_operations(0),__object_info_base(__stack) {}\n+  virtual ~__list2slist_info() {}\n+  __list2slist_info(const __list2slist_info& __o) : __object_info_base(__o)\n+  { _M_rewind = __o._M_rewind; _M_operations = __o._M_operations; }\n+  // XXX: the magnitude should be multiplied with a constant factor F,\n+  // where F is 1 when the malloc size class of list nodes is different\n+  // from the malloc size class of slist nodes.  When they fall into the same\n+  // class, the only slist benefit is from having to set fewer links, so\n+  // the factor F should be much smaller, closer to 0 than to 1.\n+  // This could be implemented by passing the size classes in the config file.\n+  // For now, we always assume F to be 1.\n+  float __magnitude() const\n+  { if (!_M_rewind) return _M_operations; else return 0; }\n+  void __merge(const __list2slist_info& __o) {};\n+  void __write(FILE* __f) const;\n+  const char* __advice() const\n+  { return strdup(\"change std::list to std::forward_list\"); }\n+  void __opr_rewind() { _M_rewind = true; _M_valid = false;}\n+  void __record_operation() { _M_operations++; }\n+  bool __has_rewind() { return _M_rewind; }\n+\n+private:\n+  bool _M_rewind;\n+  size_t _M_operations;\n+};\n+\n+class __list2slist_stack_info: public __list2slist_info {\n+ public:\n+  __list2slist_stack_info(const __list2slist_info& __o) \n+      : __list2slist_info(__o) {}\n+};\n+\n+class __trace_list_to_slist\n+    : public __trace_base<__list2slist_info, __list2slist_stack_info> \n+{\n+ public:\n+  ~__trace_list_to_slist() {}\n+  __trace_list_to_slist() \n+      : __trace_base<__list2slist_info, __list2slist_stack_info>()\n+  { __id = \"list-to-slist\"; }\n+  void __opr_rewind(const void* __obj);\n+  void __record_operation(const void* __obj);\n+  void __insert(const __object_t __obj, __stack_t __stack)\n+  { __add_object(__obj, __list2slist_info(__stack)); }\n+  void __destruct(const void* __obj);\n+};\n+\n+inline void __list2slist_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%s\\n\", _M_rewind ? \"invalid\" : \"valid\");\n+}\n+\n+inline void __trace_list_to_slist::__destruct(const void* __obj)\n+{\n+  if (!__is_on())\n+    return;\n+\n+  __list2slist_info* __res = __get_object_info(__obj);\n+  if (!__res)\n+    return;\n+\n+  __retire_object(__obj);\n+}\n+\n+inline void __trace_list_to_slist_init()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_slist) = new __trace_list_to_slist();\n+}\n+\n+inline void __trace_list_to_slist_report(FILE* __f, \n+                                       __warning_vector_t& __warnings)\n+{\n+  if (_GLIBCXX_PROFILE_DATA(_S_list_to_slist)) {\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__collect_warnings(__warnings);\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__write(__f);\n+  }\n+}\n+\n+inline void __trace_list_to_slist::__opr_rewind(const void* __obj)\n+{\n+  __list2slist_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__opr_rewind();\n+}\n+\n+inline void __trace_list_to_slist::__record_operation(const void* __obj)\n+{\n+  __list2slist_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__record_operation();\n+}\n+\n+inline void __trace_list_to_slist_rewind(const void* __obj) \n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__opr_rewind(__obj);\n+}\n+\n+inline void __trace_list_to_slist_operation(const void* __obj) \n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__record_operation(__obj);\n+}\n+\n+inline void __trace_list_to_slist_construct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__insert(__obj, __get_stack());\n+}\n+\n+inline void __trace_list_to_slist_destruct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_slist)->__destruct(__obj);\n+}\n+\n+} // namespace __gnu_profile\n+#endif /* _GLIBCXX_PROFILE_PROFILER_LIST_TO_SLIST_H */"}, {"sha": "d3a3713954c6ef00c45929e4c85e4be6408676af", "filename": "libstdc++-v3/include/profile/impl/profiler_list_to_vector.h", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_list_to_vector.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -0,0 +1,313 @@\n+// -*- C++ -*-\n+//\n+// Copyright (C) 2009 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the terms\n+// of the GNU General Public License as published by the Free Software\n+// Foundation; either version 2, or (at your option) any later\n+// version.\n+\n+// This library is distributed in the hope that it will be useful, but\n+// WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING.  If not, write to\n+// the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+// MA 02111-1307, USA.\n+\n+// As a special exception, you may use this file as part of a free\n+// software library without restriction.  Specifically, if other files\n+// instantiate templates or use macros or inline functions from this\n+// file, or you compile this file and link it with other files to\n+// produce an executable, this file does not by itself cause the\n+// resulting executable to be covered by the GNU General Public\n+// License.  This exception does not however invalidate any other\n+// reasons why the executable file might be covered by the GNU General\n+// Public License.\n+\n+/** @file profile/impl/profiler_list_to_vector.h\n+ *  @brief diagnostics for list to vector.\n+ */\n+\n+// Written by Changhee Jung.\n+\n+#ifndef _GLIBCXX_PROFILE_PROFILER_LIST_TO_VECTOR_H\n+#define _GLIBCXX_PROFILE_PROFILER_LIST_TO_VECTOR_H 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <cstdio>\n+#include <cstdlib>\n+#include <cstring>\n+#else\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <string.h>\n+#endif\n+#include <string>\n+#include <sstream>\n+#include \"profile/impl/profiler.h\"\n+#include \"profile/impl/profiler_node.h\"\n+#include \"profile/impl/profiler_trace.h\"\n+\n+namespace __gnu_profile\n+{\n+\n+/** @brief A list-to-vector instrumentation line in the object table.  */\n+class __list2vector_info: public __object_info_base\n+{\n+ public:\n+  __list2vector_info()\n+      :_M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n+       _M_vector_cost(0), _M_valid(true), _M_max_size(0) {}\n+  __list2vector_info(__stack_t __stack)\n+      : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n+        _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true),\n+        _M_max_size(0) {}\n+  virtual ~__list2vector_info() {}\n+  __list2vector_info(const __list2vector_info& __o);\n+  void __merge(const __list2vector_info& __o);\n+  void __write(FILE* __f) const;\n+  float __magnitude() const { return _M_list_cost - _M_vector_cost; }\n+  const char* __advice() const;\n+  size_t __shift_count() { return _M_shift_count; }\n+  size_t __iterate()   { return _M_iterate; }\n+  float __list_cost() { return _M_list_cost; }\n+  size_t __resize() { return _M_resize; }\n+  void __set_list_cost(float __lc) { _M_list_cost = __lc; }\n+  void __set_vector_cost(float __vc) { _M_vector_cost = __vc; }\n+  bool __is_valid() { return _M_valid; }\n+  void __set_invalid() { _M_valid = false; }\n+\n+  void __opr_insert(size_t __shift, size_t __size);\n+  void __opr_iterate(size_t __num) { _M_iterate += __num;}\n+\n+  void __resize(size_t __from, size_t __to);\n+\n+private:\n+  size_t _M_shift_count;\n+  size_t _M_iterate;\n+  size_t _M_resize;\n+  float _M_list_cost;\n+  float _M_vector_cost;\n+  bool  _M_valid;\n+  size_t _M_max_size;\n+};\n+\n+inline __list2vector_info::__list2vector_info(const __list2vector_info& __o)\n+    : __object_info_base(__o)\n+{\n+  _M_shift_count  = __o._M_shift_count;\n+  _M_iterate      = __o._M_iterate;\n+  _M_vector_cost  = __o._M_vector_cost;\n+  _M_list_cost    = __o._M_list_cost;\n+  _M_valid        = __o._M_valid;\n+  _M_resize       = __o._M_resize;\n+  _M_max_size     = __o._M_max_size;\n+}\n+\n+inline const char* __list2vector_info::__advice() const {\n+  std::stringstream __sstream;\n+  __sstream \n+      << \"change std::list to std::vector and its initial size from 0 to \"\n+      << _M_max_size;\n+  return strdup(__sstream.str().c_str());\n+}\n+\n+inline void __list2vector_info::__merge(const __list2vector_info& __o)\n+{\n+  _M_shift_count  += __o._M_shift_count;\n+  _M_iterate      += __o._M_iterate;\n+  _M_vector_cost  += __o._M_vector_cost;\n+  _M_list_cost    += __o._M_list_cost;\n+  _M_valid        &= __o._M_valid;\n+  _M_resize       += __o._M_resize;\n+  _M_max_size     = __max( _M_max_size, __o._M_max_size);\n+}\n+\n+inline void __list2vector_info::__opr_insert(size_t __shift, size_t __size) \n+{\n+  _M_shift_count += __shift;\n+  _M_max_size = __max(_M_max_size, __size);\n+}\n+\n+inline void __list2vector_info::__resize(size_t __from, size_t __to)\n+{\n+  _M_resize += __from;\n+}\n+\n+class __list2vector_stack_info: public __list2vector_info {\n+ public:\n+  __list2vector_stack_info(const __list2vector_info& __o) \n+      : __list2vector_info(__o) {}\n+};\n+\n+class __trace_list_to_vector\n+    : public __trace_base<__list2vector_info, __list2vector_stack_info> \n+{\n+ public:\n+  __trace_list_to_vector();\n+  ~__trace_list_to_vector() {}\n+\n+  // Insert a new node at construct with object, callstack and initial size. \n+  void __insert(__object_t __obj, __stack_t __stack);\n+  // Call at destruction/clean to set container final size.\n+  void __destruct(const void* __obj);\n+\n+  // Find the node in the live map.\n+  __list2vector_info* __find(const void* __obj);\n+\n+  // Collect cost of operations.\n+  void __opr_insert(const void* __obj, size_t __shift, size_t __size);\n+  void __opr_iterate(const void* __obj, size_t __num);\n+  void __invalid_operator(const void* __obj);\n+  void __resize(const void* __obj, size_t __from, size_t __to);\n+  float __vector_cost(size_t __shift, size_t __iterate);\n+  float __list_cost(size_t __shift, size_t __iterate);\n+};\n+\n+inline __trace_list_to_vector::__trace_list_to_vector()\n+    : __trace_base<__list2vector_info, __list2vector_stack_info>()\n+{\n+  __id = \"list-to-vector\";\n+}\n+\n+inline void __trace_list_to_vector::__insert(__object_t __obj,\n+                                             __stack_t __stack)\n+{\n+  __add_object(__obj, __list2vector_info(__stack));\n+}\n+\n+inline void __list2vector_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\",\n+          _M_shift_count, _M_resize, _M_iterate, _M_vector_cost, _M_list_cost);\n+}\n+\n+inline float __trace_list_to_vector::__vector_cost(size_t __shift, \n+                                                   size_t __iterate)\n+{\n+  // The resulting vector will use a 'reserve' method.\n+  return __shift * _GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor).__value + \n+      __iterate * _GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor).__value; \n+}\n+\n+inline float __trace_list_to_vector::__list_cost(size_t __shift, \n+                                                 size_t __iterate)\n+{\n+  return __shift * _GLIBCXX_PROFILE_DATA(__list_shift_cost_factor).__value + \n+      __iterate * _GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor).__value; \n+}\n+\n+inline void __trace_list_to_vector::__destruct(const void* __obj)\n+{\n+  if (!__is_on())\n+    return;\n+\n+ __list2vector_info* __res = __get_object_info(__obj);\n+  if (!__res)\n+    return;\n+\n+  float __vc = __vector_cost(__res->__shift_count(), __res->__iterate());\n+  float __lc = __list_cost(__res->__shift_count(), __res->__iterate());\n+  __res->__set_vector_cost(__vc);\n+  __res->__set_list_cost(__lc);\n+  __retire_object(__obj);\n+}\n+\n+inline void __trace_list_to_vector::__opr_insert(const void* __obj, \n+                                                 size_t __shift, size_t __size)\n+{\n+  __list2vector_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__opr_insert(__shift, __size);\n+}\n+\n+inline void __trace_list_to_vector::__opr_iterate(const void* __obj,\n+                                                  size_t __num)\n+{\n+  __list2vector_info* __res = __get_object_info(__obj);\n+  if (__res) {\n+    __res->__opr_iterate(__num);\n+  }\n+}\n+\n+inline void __trace_list_to_vector::__invalid_operator(const void* __obj)\n+{\n+  __list2vector_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__set_invalid();\n+}\n+\n+inline void __trace_list_to_vector::__resize(const void* __obj, size_t __from, \n+                                             size_t __to)\n+{\n+  __list2vector_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__resize(__from, __to);\n+}\n+\n+inline void __trace_list_to_vector_init()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_vector) = new __trace_list_to_vector();\n+}\n+\n+inline void __trace_list_to_vector_report(FILE* __f, \n+                                          __warning_vector_t& __warnings)\n+{\n+  if (_GLIBCXX_PROFILE_DATA(_S_list_to_vector)) {\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__collect_warnings(__warnings);\n+    _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__write(__f);\n+  }\n+}\n+\n+inline void __trace_list_to_vector_construct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__insert(__obj, __get_stack());\n+}\n+\n+inline void __trace_list_to_vector_destruct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__destruct(__obj);\n+}\n+\n+inline void __trace_list_to_vector_insert(const void* __obj, \n+                                          size_t __shift, size_t __size)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__opr_insert(__obj, __shift, \n+                                                         __size);\n+}\n+\n+\n+inline void __trace_list_to_vector_iterate(const void* __obj, size_t __num = 1)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__opr_iterate(__obj, __num);\n+}\n+\n+inline void __trace_list_to_vector_invalid_operator(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__invalid_operator(__obj);\n+}\n+\n+inline void __trace_list_to_vector_resize(const void* __obj, \n+                                          size_t __from, size_t __to)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_list_to_vector)->__resize(__obj, __from, __to);\n+}\n+\n+} // namespace __gnu_profile\n+#endif /* _GLIBCXX_PROFILE_PROFILER_LIST_TO_VECTOR_H__ */"}, {"sha": "e715e4cd46728b693fac68af56b70cf553bb8039", "filename": "libstdc++-v3/include/profile/impl/profiler_map_to_unordered_map.h", "status": "modified", "additions": 200, "deletions": 234, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -52,275 +52,241 @@\n \n namespace __gnu_profile\n {\n-  // Cost model. \n-  //  Map operations:\n-  //   - insert: 1.5 * log(size)\n-  //   - erase: 1.5 * log(size)\n-  //   - find: log(size)\n-  //   - iterate: 2.3\n-  //  Unordered map operations:\n-  //   - insert: 12\n-  //   - erase: 12\n-  //   - find: 10\n-  //   - iterate: 1.7\n-  // XXX: this must be taken from the machine model instead.\n-  const float __map_insert_cost_factor = 1.5;\n-  const float __map_erase_cost_factor = 1.5;\n-  const float __map_find_cost_factor = 1;\n-  const float __map_iterate_cost = 2.3;\n-\n-  const float __umap_insert_cost = 12.0;\n-  const float __umap_erase_cost = 12.0;\n-  const float __umap_find_cost = 10.0;\n-  const float __umap_iterate_cost = 1.7;\n-\n-  inline int \n-  __log2(size_t __size)\n+\n+inline int __log2(size_t __size)\n+{\n+  for (int __bit_count = sizeof(size_t) - 1; __bit_count >= 0; -- __bit_count) \n   {\n-    int __bit_count = sizeof(size_t) - 1;\n-    for (; __bit_count >= 0; --__bit_count) \n-      {\n-\tif ((2 << __bit_count) & __size)\n-\t  return __bit_count;\n-      }\n-    return 0;\n+    if ((2 << __bit_count) & __size) {\n+      return __bit_count;\n+    }\n   }\n+  return 0;\n+}\n \n-  inline float \n-  __map_insert_cost(size_t __size)\n-  { return __map_insert_cost_factor * static_cast<float>(__log2(__size)); }\n-\n-  inline float \n-  __map_erase_cost(size_t __size)\n-  { return __map_erase_cost_factor * static_cast<float>(__log2(__size)); }\n-\n-  inline float \n-  __map_find_cost(size_t __size)\n-  { return __map_find_cost_factor * static_cast<float>(__log2(__size)); }\n+inline float __map_insert_cost(size_t __size)\n+{\n+  return (_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor).__value \n+          * static_cast<float>(__log2(__size)));\n+}\n \n-  /** @brief A map-to-unordered_map instrumentation line in the object table. */\n-  class __map2umap_info: public __object_info_base\n-  {\n-  public:\n-    __map2umap_info()\n-    : _M_insert(0), _M_erase(0), _M_find(0), _M_iterate(0),\n-      _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) { }\n-\n-    __map2umap_info(__stack_t __stack)\n-    : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0), \n-      _M_iterate(0), _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) { } \n-\n-    virtual ~__map2umap_info() { }\n-\n-    __map2umap_info(const __map2umap_info& o);\n-\n-    void __merge(const __map2umap_info& o);\n-    void __write(FILE* __f) const;\n-    float __magnitude() const { return _M_map_cost - _M_umap_cost; }\n-    const char* __advice() const;\n-\n-    void __record_insert(size_t __size, size_t __count);\n-    void __record_erase(size_t __size, size_t __count);\n-    void __record_find(size_t __size);\n-    void __record_iterate(size_t __count);\n-    void __record_invalidate();\n-\n-  private:\n-    size_t _M_insert;\n-    size_t _M_erase;\n-    size_t _M_find;\n-    size_t _M_iterate;\n-    float _M_umap_cost;\n-    float _M_map_cost;\n-    bool  _M_valid;\n-  };\n-\n-  inline __map2umap_info::__map2umap_info(const __map2umap_info& __o)\n-  : __object_info_base(__o), \n-    _M_insert(__o._M_insert),\n-    _M_erase(__o._M_erase),\n-    _M_find(__o._M_find),\n-    _M_iterate(__o._M_iterate),\n-    _M_map_cost(__o._M_map_cost),\n-    _M_umap_cost(__o._M_umap_cost),\n-    _M_valid(__o._M_valid)\n-  { }\n-\n-  inline const char* \n-  __map2umap_info::__advice() const\n-  { return \"change std::map to std::unordered_map\"; }\n-\n-  inline void \n-  __map2umap_info::__merge(const __map2umap_info& __o)\n-  {\n-    _M_insert    += __o._M_insert;\n-    _M_erase     += __o._M_erase;\n-    _M_find      += __o._M_find;\n-    _M_map_cost  += __o._M_map_cost;\n-    _M_umap_cost += __o._M_umap_cost;\n-    _M_valid     &= __o._M_valid;\n-  }\n+inline float __map_erase_cost(size_t __size)\n+{\n+  return (_GLIBCXX_PROFILE_DATA(__map_erase_cost_factor).__value\n+          * static_cast<float>(__log2(__size)));\n+}\n \n-  inline void \n-  __map2umap_info:: __record_insert(size_t __size, size_t __count)\n-  {\n-    _M_insert += __count;\n-    _M_map_cost += __count * __map_insert_cost(__size);\n-    _M_umap_cost += __count * __umap_insert_cost;\n-  }\n+inline float __map_find_cost(size_t __size)\n+{\n+  return (_GLIBCXX_PROFILE_DATA(__map_find_cost_factor).__value\n+          * static_cast<float>(__log2(__size)));\n+}\n \n-  inline void \n-  __map2umap_info:: __record_erase(size_t __size, size_t __count)\n-  {\n-    _M_erase += __count;\n-    _M_map_cost += __count * __map_erase_cost(__size);\n-    _M_umap_cost += __count * __umap_erase_cost;\n-  }\n+/** @brief A map-to-unordered_map instrumentation line in the object table.  */\n+class __map2umap_info: public __object_info_base\n+{\n+ public:\n+  __map2umap_info()\n+      : _M_insert(0), _M_erase(0), _M_find(0), _M_iterate(0),\n+        _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) {}\n+  __map2umap_info(__stack_t __stack)\n+      : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0), \n+        _M_iterate(0), _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) {} \n+  virtual ~__map2umap_info() {}\n+  __map2umap_info(const __map2umap_info& o);\n+  void __merge(const __map2umap_info& o);\n+  void __write(FILE* __f) const;\n+  float __magnitude() const { return _M_map_cost - _M_umap_cost; }\n+  const char* __advice() const;\n+\n+  void __record_insert(size_t __size, size_t __count);\n+  void __record_erase(size_t __size, size_t __count);\n+  void __record_find(size_t __size);\n+  void __record_iterate(size_t __count);\n+  void __record_invalidate();\n+\n+ private:\n+  size_t _M_insert;\n+  size_t _M_erase;\n+  size_t _M_find;\n+  size_t _M_iterate;\n+  float _M_umap_cost;\n+  float _M_map_cost;\n+  bool  _M_valid;\n+};\n+\n+inline const char* __map2umap_info::__advice() const\n+{\n+  return strdup(\"change std::map to std::unordered_map\");\n+}\n+\n+inline __map2umap_info::__map2umap_info(const __map2umap_info& __o)\n+    : __object_info_base(__o), \n+      _M_insert(__o._M_insert),\n+      _M_erase(__o._M_erase),\n+      _M_find(__o._M_find),\n+      _M_iterate(__o._M_iterate),\n+      _M_map_cost(__o._M_map_cost),\n+      _M_umap_cost(__o._M_umap_cost),\n+      _M_valid(__o._M_valid)\n+{}\n+\n+inline void __map2umap_info::__merge(const __map2umap_info& __o)\n+{\n+  _M_insert    += __o._M_insert;\n+  _M_erase     += __o._M_erase;\n+  _M_find      += __o._M_find;\n+  _M_map_cost  += __o._M_map_cost;\n+  _M_umap_cost += __o._M_umap_cost;\n+  _M_valid     &= __o._M_valid;\n+}\n+\n+inline void __map2umap_info:: __record_insert(size_t __size, size_t __count)\n+{\n+  _M_insert += __count;\n+  _M_map_cost += __count * __map_insert_cost(__size);\n+  _M_umap_cost += (__count\n+                   * _GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor).__value);\n+}\n \n-  inline void \n-  __map2umap_info:: __record_find(size_t __size)\n-  {\n-    _M_find += 1;\n-    _M_map_cost += __map_find_cost(__size);\n-    _M_umap_cost += __umap_find_cost;\n-  }\n+inline void __map2umap_info:: __record_erase(size_t __size, size_t __count)\n+{\n+  _M_erase += __count;\n+  _M_map_cost += __count * __map_erase_cost(__size);\n+  _M_umap_cost += (__count\n+                   * _GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor).__value);\n+}\n \n-  inline void \n-  __map2umap_info:: __record_iterate(size_t __count)\n-  {\n-    _M_iterate += __count;\n-    _M_map_cost += __count * __map_iterate_cost;\n-    _M_umap_cost += __count * __umap_iterate_cost;\n-  }\n+inline void __map2umap_info:: __record_find(size_t __size)\n+{\n+  _M_find += 1;\n+  _M_map_cost += __map_find_cost(__size);\n+  _M_umap_cost += _GLIBCXX_PROFILE_DATA(__umap_find_cost_factor).__value;\n+}\n \n-  inline void \n-  __map2umap_info:: __record_invalidate()\n-  {\n-    _M_valid = false;\n-  }\n+inline void __map2umap_info:: __record_iterate(size_t __count)\n+{\n+  _M_iterate += __count;\n+  _M_map_cost += (__count\n+                  * _GLIBCXX_PROFILE_DATA(__map_iterate_cost_factor).__value);\n+  _M_umap_cost += (\n+      __count * _GLIBCXX_PROFILE_DATA(__umap_iterate_cost_factor).__value);\n+}\n+\n+inline void __map2umap_info:: __record_invalidate()\n+{\n+  _M_valid = false;\n+}\n \n-  inline void \n-  __map2umap_info::__write(FILE* __f) const\n-  {\n-    fprintf(__f, \"%Zu %Zu %Zu %Zu %.0f %.0f %s\\n\",\n-\t    _M_insert, _M_erase, _M_find, _M_iterate, _M_map_cost, _M_umap_cost,\n-\t    _M_valid ? \"valid\" : \"invalid\");\n-  }\n+inline void __map2umap_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu %Zu %.0f %.0f %s\\n\",\n+          _M_insert, _M_erase, _M_find, _M_iterate, _M_map_cost, _M_umap_cost,\n+          _M_valid ? \"valid\" : \"invalid\");\n+}\n \n-  /** @brief A map-to-unordered_map instrumentation line in the stack table.  */\n-  class __map2umap_stack_info: public __map2umap_info\n-  {\n-  public:\n-    __map2umap_stack_info(const __map2umap_info& o) : __map2umap_info(o) { }\n-  };\n+/** @brief A map-to-unordered_map instrumentation line in the stack table.  */\n+class __map2umap_stack_info: public __map2umap_info\n+{\n+ public:\n+  __map2umap_stack_info(const __map2umap_info& o) : __map2umap_info(o) {}\n+};\n \n-  /** @brief Map-to-unordered_map instrumentation producer.  */\n-  class __trace_map2umap\n-  : public __trace_base<__map2umap_info, __map2umap_stack_info> \n-  {\n-  public:\n-    __trace_map2umap();\n-  };\n+/** @brief Map-to-unordered_map instrumentation producer.  */\n+class __trace_map2umap\n+    : public __trace_base<__map2umap_info, __map2umap_stack_info> \n+{\n+ public:\n+  __trace_map2umap();\n+};\n \n-  inline __trace_map2umap::__trace_map2umap()\n-  : __trace_base<__map2umap_info, __map2umap_stack_info>()\n-  { __id = \"map-to-unordered-map\"; }\n+inline __trace_map2umap::__trace_map2umap()\n+    : __trace_base<__map2umap_info, __map2umap_stack_info>()\n+{\n+  __id = \"map-to-unordered-map\";\n+}\n \n-  inline void \n-  __trace_map_to_unordered_map_init()\n-  { __tables<0>::_S_map2umap = new __trace_map2umap(); }\n+inline void __trace_map_to_unordered_map_init()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_map2umap) = new __trace_map2umap();\n+}\n \n-  inline void \n-  __trace_map_to_unordered_map_report(FILE* __f, __warning_vector_t& __warnings)\n-  {\n-    if (__tables<0>::_S_map2umap) \n-      {\n-\t__tables<0>::_S_map2umap->__collect_warnings(__warnings);\n-\t__tables<0>::_S_map2umap->__write(__f);\n-      }\n+inline void __trace_map_to_unordered_map_report(\n+    FILE* __f, __warning_vector_t& __warnings)\n+{\n+  if (_GLIBCXX_PROFILE_DATA(_S_map2umap)) {\n+    _GLIBCXX_PROFILE_DATA(_S_map2umap)->__collect_warnings(__warnings);\n+    _GLIBCXX_PROFILE_DATA(_S_map2umap)->__write(__f);\n   }\n+}\n \n-  // Implementations of instrumentation hooks.\n-  inline void \n-  __trace_map_to_unordered_map_construct(const void* __obj)\n-  {\n-    if (!__profcxx_init()) \n-      return;\n+inline void __trace_map_to_unordered_map_construct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __tables<0>::_S_map2umap->__add_object(__obj, \n-\t\t\t\t\t   __map2umap_info(__get_stack()));\n-  }\n+  _GLIBCXX_PROFILE_DATA(_S_map2umap)->__add_object(\n+      __obj, __map2umap_info(__get_stack()));\n+}\n \n-  inline void \n-  __trace_map_to_unordered_map_destruct(const void* __obj)\n-  {\n-    if (!__profcxx_init()) \n-      return;\n+inline void __trace_map_to_unordered_map_destruct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __tables<0>::_S_map2umap->__retire_object(__obj);\n-  }\n+  _GLIBCXX_PROFILE_DATA(_S_map2umap)->__retire_object(__obj);\n+}\n \n-  inline void \n-  __trace_map_to_unordered_map_insert(const void* __obj, size_t __size, \n-\t\t\t\t      size_t __count)\n-  {\n-    if (!__profcxx_init()) \n-      return;\n+inline void __trace_map_to_unordered_map_insert(const void* __obj, \n+                                                size_t __size, size_t __count)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+  __map2umap_info* __info =\n+      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-    if (__info) \n-      __info->__record_insert(__size, __count);\n-  }\n+  if (__info) __info->__record_insert(__size, __count);\n+}\n \n-  inline void \n-  __trace_map_to_unordered_map_erase(const void* __obj, size_t __size, \n-\t\t\t\t     size_t __count)\n-  {\n-    if (!__profcxx_init())\n-      return;\n+inline void __trace_map_to_unordered_map_erase(const void* __obj, \n+                                               size_t __size, size_t __count)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+  __map2umap_info* __info =\n+      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-    if (__info) \n-      __info->__record_erase(__size, __count);\n-  }\n+  if (__info) __info->__record_erase(__size, __count);\n+}\n \n-  inline void \n-  __trace_map_to_unordered_map_find(const void* __obj, size_t __size)\n-  {\n-    if (!__profcxx_init()) \n-      return;\n+inline void __trace_map_to_unordered_map_find(const void* __obj, size_t __size)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+  __map2umap_info* __info =\n+      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-    if (__info) \n-      __info->__record_find(__size);\n-  }\n+  if (__info) __info->__record_find(__size);\n+}\n \n-  inline void \n-  __trace_map_to_unordered_map_iterate(const void* __obj, size_t __count)\n-  {\n-    if (!__profcxx_init()) \n-      return;\n+inline void __trace_map_to_unordered_map_iterate(const void* __obj, \n+                                                 size_t __count)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+  __map2umap_info* __info =\n+      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-    if (__info) \n-      __info->__record_iterate(__count);\n-  }\n+  if (__info) __info->__record_iterate(__count);\n+}\n \n-  inline void \n-  __trace_map_to_unordered_map_invalidate(const void* __obj)\n-  {\n-    if (!__profcxx_init()) \n-      return;\n+inline void __trace_map_to_unordered_map_invalidate(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n \n-    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+  __map2umap_info* __info =\n+      _GLIBCXX_PROFILE_DATA(_S_map2umap)->__get_object_info(__obj);\n \n-    if (__info) \n-      __info->__record_invalidate();\n-  }\n+  if (__info) __info->__record_invalidate();\n+}\n \n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_MAP_TO_UNORDERED_MAP_H */"}, {"sha": "77654a8f813e5f998673efc2044b84fb876641be", "filename": "libstdc++-v3/include/profile/impl/profiler_node.h", "status": "modified", "additions": 97, "deletions": 93, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -47,122 +47,126 @@\n #include <string.h>\n #endif\n #include <vector>\n-#if defined HAVE_EXECINFO_H\n+#if defined _GLIBCXX_HAVE_EXECINFO_H\n #include <execinfo.h>\n #endif\n \n namespace __gnu_profile\n {\n-  typedef const void* __object_t;\n-  typedef void* __instruction_address_t;\n-  typedef std::_GLIBCXX_STD_PR::vector<__instruction_address_t> __stack_npt;\n-  typedef __stack_npt* __stack_t;\n+typedef const void* __object_t;\n+typedef void* __instruction_address_t;\n+typedef std::_GLIBCXX_STD_PR::vector<__instruction_address_t> __stack_npt;\n+typedef __stack_npt* __stack_t;\n \n-  size_t __stack_max_depth();\n+size_t __stack_max_depth();\n \n-  inline __stack_t __get_stack()\n-  {\n-#if defined HAVE_EXECINFO_H\n-    size_t __max_depth = __stack_max_depth();\n-    if (__max_depth == 0)\n-      return NULL;\n-    __stack_npt __buffer(__max_depth);\n-    int __depth = backtrace(&__buffer[0], __max_depth);\n-    __stack_t __stack = new __stack_npt(__depth);\n-    memcpy(&(*__stack)[0], &__buffer[0], __depth * sizeof(__object_t));\n-    return __stack;\n-#else\n+inline __stack_t __get_stack()\n+{\n+#if defined _GLIBCXX_HAVE_EXECINFO_H\n+  size_t __max_depth = __stack_max_depth();\n+  if (__max_depth == 0)\n     return NULL;\n+  __stack_npt __buffer(__max_depth);\n+  int __depth = backtrace(&__buffer[0], __max_depth);\n+  __stack_t __stack = new __stack_npt(__depth);\n+  memcpy(&(*__stack)[0], &__buffer[0], __depth * sizeof(__object_t));\n+  return __stack;\n+#else\n+  return NULL;\n #endif\n+}\n+\n+inline __size(const __stack_t& __stack)\n+{\n+  if (!__stack) {\n+    return 0;\n+  } else {\n+    return __stack->size();\n   }\n+}\n \n-  inline __size(const __stack_t& __stack)\n-  {\n-    if (!__stack)\n-      return 0;\n-    else\n-      return __stack->size();\n+inline void __write(FILE* __f, const __stack_t __stack)\n+{\n+  if (!__stack) {\n+    return;\n+  }\n+\n+  __stack_npt::const_iterator __it;\n+  for (__it = __stack->begin(); __it != __stack->end(); ++__it) {\n+    fprintf(__f, \"%p \", *__it);\n   }\n+}\n \n-  inline void __write(FILE* __f, const __stack_t __stack)\n+/** @brief Hash function for summary trace using call stack as index.  */\n+class __stack_hash \n+{\n+ public:\n+  size_t operator()(const __stack_t __s) const\n   {\n-    if (!__stack)\n-      return;\n+    if (!__s) {\n+      return 0;\n+    }\n \n+    uintptr_t __index = 0;\n     __stack_npt::const_iterator __it;\n-    for (__it = __stack->begin(); __it != __stack->end(); ++__it)\n-      fprintf(__f, \"%p \", *__it);\n+    for (__it = __s->begin(); __it != __s->end(); ++__it) {\n+      __index += reinterpret_cast<uintptr_t>(*__it);\n+    } \n+    return __index;\n   }\n \n-  /** @brief Hash function for summary trace using call stack as index.  */\n-  class __stack_hash\n+  bool operator() (const __stack_t __stack1, const __stack_t __stack2) const\n   {\n-  public:\n-    size_t operator()(const __stack_t __s) const\n-    {\n-      if (!__s)\n-\treturn 0;\n-      \n-      uintptr_t __index = 0;\n-      __stack_npt::const_iterator __it;\n-      for (__it = __s->begin(); __it != __s->end(); ++__it) \n-\t{\n-\t  __index += reinterpret_cast<uintptr_t>(*__it);\n-\t}\n-      return __index;\n-    }\n+    if (!__stack1 && !__stack2) return true;\n+    if (!__stack1 || !__stack2) return false;\n+    if (__stack1->size() != __stack2->size()) return false;\n \n-    bool operator() (const __stack_t __stack1, const __stack_t __stack2) const\n-    {\n-      if (!__stack1 && !__stack2) return true;\n-      if (!__stack1 || !__stack2) return false;\n-      if (__stack1->size() != __stack2->size()) return false;\n+    size_t __byte_size = __stack1->size() * sizeof(__stack_npt::value_type);\n+    return memcmp(&(*__stack1)[0], &(*__stack2)[0], __byte_size) == 0;\n+  }\n+};\n \n-      size_t __byte_size = __stack1->size() * sizeof(__stack_npt::value_type);\n-      return memcmp(&(*__stack1)[0], &(*__stack2)[0], __byte_size) == 0;\n-    }\n-  };\n+/** @brief Base class for a line in the object table.  */\n+class __object_info_base\n+{\n+ public:\n+  __object_info_base() {}\n+  __object_info_base(__stack_t __stack);\n+  __object_info_base(const __object_info_base& o);\n+  virtual ~__object_info_base() {}\n+  bool __is_valid() const { return _M_valid; }\n+  __stack_t __stack() const { return _M_stack; }\n+  virtual void __write(FILE* f) const = 0;\n+\n+ protected:\n+  __stack_t _M_stack;\n+  bool _M_valid;\n+};\n+\n+inline __object_info_base::__object_info_base(__stack_t __stack)\n+{\n+  _M_stack = __stack;\n+  _M_valid = true;\n+}\n \n-  /** @brief Base class for a line in the object table.  */\n-  class __object_info_base\n-  {\n-  public:\n-    __object_info_base() { }\n-    __object_info_base(__stack_t __stack);\n-    __object_info_base(const __object_info_base& o);\n-    virtual ~__object_info_base() { }\n-    bool __is_valid() const { return _M_valid; }\n-    __stack_t __stack() const { return _M_stack; }\n-    virtual void __write(FILE* f) const = 0;\n-\n-  protected:\n-    __stack_t _M_stack;\n-    bool _M_valid;\n-  };\n-\n-  inline __object_info_base::__object_info_base(__stack_t __stack)\n-  {\n-    _M_stack = __stack;\n-    _M_valid = true;\n-  }\n+inline __object_info_base::__object_info_base(const __object_info_base& __o)\n+{\n+  _M_stack = __o._M_stack;\n+  _M_valid = __o._M_valid;\n+}\n \n-  inline __object_info_base::__object_info_base(const __object_info_base& __o)\n-  {\n-    _M_stack = __o._M_stack;\n-    _M_valid = __o._M_valid;\n-  }\n+/** @brief Base class for a line in the stack table.  */\n+template<typename __object_info>\n+class __stack_info_base\n+{\n+ public:\n+  __stack_info_base() {}\n+  __stack_info_base(const __object_info& __info) = 0;\n+  virtual ~__stack_info_base() {}\n+  void __merge(const __object_info& __info) = 0;\n+  virtual float __magnitude() const = 0;\n+  virtual const char* __get_id() const = 0;\n+};\n \n-  /** @brief Base class for a line in the stack table.  */\n-  template<typename __object_info>\n-    class __stack_info_base\n-    {\n-    public:\n-      __stack_info_base() { }\n-      __stack_info_base(const __object_info& __info) = 0;\n-      virtual ~__stack_info_base() { }\n-      void __merge(const __object_info& __info) = 0;\n-      virtual float __magnitude() const = 0;\n-      virtual const char* __get_id() const = 0;\n-    };\n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_NODE_H */"}, {"sha": "540c3e4bf0c13609c2bfdf26d63a0b1f74f2471d", "filename": "libstdc++-v3/include/profile/impl/profiler_state.h", "status": "modified", "additions": 26, "deletions": 64, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -37,72 +37,34 @@\n #ifndef _GLIBCXX_PROFILE_PROFILER_STATE_H\n #define _GLIBCXX_PROFILE_PROFILER_STATE_H 1\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-#include <cstdio>\n-#else\n-#include <stdio.h>\n-#endif\n-\n namespace __gnu_profile\n {\n-  /** @brief Profiling mode on/off state.  */\n-  template<int _Unused=0>\n-    class __state\n-    {\n-    private:\n-      enum __state_type { __ON, __OFF, __INVALID };\n-\n-      __state_type \t\t_M_state;\n-\n-    public:\n-      static __state<_Unused>* \t_S_diag_state;\n-\n-      __state() : _M_state(__INVALID) { }\n-      ~__state() { }\n-\n-      bool __is_on() { return _M_state == __ON; }\n-      bool __is_off() { return _M_state == __OFF; }\n-      bool __is_invalid() { return _M_state == __INVALID; }\n-      void __turn_on() { _M_state = __ON; }\n-      void __turn_off() { _M_state = __OFF; }\n-    };\n-\n-  template<int _Unused>\n-    __state<_Unused>* __state<_Unused>::_S_diag_state = NULL;\n-\n-  inline bool \n-  __is_on()\n-  {\n-    return __state<0>::_S_diag_state && __state<0>::_S_diag_state->__is_on();\n-  }\n-\n-  inline bool \n-  __is_off()\n-  {\n-    return __state<0>::_S_diag_state && __state<0>::_S_diag_state->__is_off();\n-  }\n-\n-  inline bool \n-  __is_invalid()\n-  {\n-    return (!__state<0>::_S_diag_state || __state<0>::_S_diag_state->__is_invalid());\n-  }\n-\n-  inline void \n-  __turn_on()\n-  {\n-    if (!__state<0>::_S_diag_state)\n-      __state<0>::_S_diag_state = new __state<0>();\n-    __state<0>::_S_diag_state->__turn_on();\n-  }\n-\n-  inline void \n-  __turn_off()\n-  {\n-    if (!__state<0>::_S_diag_state)\n-      __state<0>::_S_diag_state = new __state<0>();\n-    __state<0>::_S_diag_state->__turn_off();\n-  }\n+\n+enum __state_type { __ON, __OFF, __INVALID };\n+\n+_GLIBCXX_PROFILE_DEFINE_DATA(__state_type, __state, __INVALID);\n+\n+inline bool __turn(__state_type __s)\n+{\n+  return (_GLIBCXX_PROFILE_DATA(__state)\n+          == __sync_val_compare_and_swap(&_GLIBCXX_PROFILE_DATA(__state),\n+                                         __INVALID, __s));\n+}\n+\n+inline bool __turn_on()\n+{ return __turn(__ON); }\n+\n+inline bool __turn_off()\n+{ return __turn(__OFF); }\n+\n+inline bool __is_on()\n+{ return _GLIBCXX_PROFILE_DATA(__state) == __ON; }\n+\n+inline bool __is_off()\n+{ return _GLIBCXX_PROFILE_DATA(__state) == __OFF; }\n+\n+inline bool __is_invalid()\n+{ return _GLIBCXX_PROFILE_DATA(__state) == __INVALID; }\n \n } // end namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_STATE_H */"}, {"sha": "75126774d5b0646a5f44a5613ada093f0b6d8bbc", "filename": "libstdc++-v3/include/profile/impl/profiler_trace.h", "status": "modified", "additions": 556, "deletions": 465, "changes": 1021, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -54,9 +54,17 @@\n #endif\n \n #include <algorithm>\n+#include <fstream>\n+#include <string>\n #include <utility>\n \n-#if defined _GLIBCXX_PROFILE_THREADS && defined HAVE_TLS\n+#if (defined _GLIBCXX_PROFILE_THREADS) && !(defined _GLIBCXX_HAVE_TLS)\n+#error You do not seem to have TLS support, which is required by the profile \\\n+  mode.  If your program is not multithreaded, recompile with \\\n+  -D_GLIBCXX_PROFILE_NO_THREADS\n+#endif\n+\n+#if defined _GLIBCXX_PROFILE_THREADS && defined _GLIBCXX_HAVE_TLS\n #include <pthread.h>\n #endif\n \n@@ -65,528 +73,611 @@\n \n namespace __gnu_profile\n {\n-#if defined _GLIBCXX_PROFILE_THREADS && defined HAVE_TLS\n+\n+#if defined _GLIBCXX_PROFILE_THREADS && defined _GLIBCXX_HAVE_TLS\n #define _GLIBCXX_IMPL_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n-  typedef pthread_mutex_t __mutex_t;\n-\n-  /** @brief Pthread mutex wrapper.  */\n-  template<int _Unused=0>\n-    class __mutex \n-    {\n-    public:\n-      static __mutex_t __global_lock;\n-      static void __lock(__mutex_t& __m) { pthread_mutex_lock(&__m); }\n-      static void __unlock(__mutex_t& __m) { pthread_mutex_unlock(&__m); }\n-    };\n+typedef pthread_mutex_t __mutex_t;\n+/** @brief Pthread mutex wrapper.  */\n+_GLIBCXX_PROFILE_DEFINE_DATA(__mutex_t, __global_lock, \n+                             PTHREAD_MUTEX_INITIALIZER);\n+inline void __lock(__mutex_t& __m) { pthread_mutex_lock(&__m); }\n+inline void __unlock(__mutex_t& __m) { pthread_mutex_unlock(&__m); }\n #else\n+typedef int __mutex_t;\n+/** @brief Mock mutex interface.  */\n #define _GLIBCXX_IMPL_MUTEX_INITIALIZER 0\n-  typedef int __mutex_t;\n-\n-  /** @brief Mock mutex interface.  */\n-  template<int _Unused=0>\n-    class __mutex \n-    {\n-    public:\n-      static __mutex_t __global_lock;\n-      static void __lock(__mutex_t& __m) { }\n-      static void __unlock(__mutex_t& __m) { }\n-    };\n+_GLIBCXX_PROFILE_DEFINE_DATA(__mutex_t, __global_lock, 0);\n+inline void __lock(__mutex_t& __m) {}\n+inline void __unlock(__mutex_t& __m) {}\n #endif\n \n-  template<int _Unused>\n-    __mutex_t __mutex<_Unused>::__global_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n+/** @brief Representation of a warning.  */\n+struct __warning_data\n+{\n+  float __magnitude;\n+  __stack_t __context;\n+  const char* __warning_id;\n+  const char* __warning_message;\n+  __warning_data();\n+  __warning_data(float __m, __stack_t __c, const char* __id, \n+                 const char* __msg);\n+  bool operator>(const struct __warning_data& other) const;\n+};\n+\n+inline __warning_data::__warning_data()\n+    : __magnitude(0.0), __context(NULL), __warning_id(NULL),\n+      __warning_message(NULL)\n+{\n+}\n \n-  /** @brief Representation of a warning.  */\n-  struct __warning_data\n-  {\n-    float __magnitude;\n-    __stack_t __context;\n-    const char* __warning_id;\n-    const char* __warning_message;\n-    __warning_data();\n-    __warning_data(float __m, __stack_t __c, const char* __id,\n-\t\t   const char* __msg);\n-    bool operator>(const struct __warning_data& other) const;\n-  };\n-\n-  inline __warning_data::__warning_data()\n-  : __magnitude(0.0), __context(NULL), __warning_id(NULL),\n-    __warning_message(NULL)\n-  { }\n-\n-  inline __warning_data::__warning_data(float __m, __stack_t __c,\n-\t\t\t\t\tconst char* __id, const char* __msg)\n-  : __magnitude(__m), __context(__c), __warning_id(__id),\n-    __warning_message(__msg)\n-  { }\n-\n-  inline bool \n-  __warning_data::operator>(const struct __warning_data& other) const\n-  { return __magnitude > other.__magnitude; }\n-\n-  typedef std::_GLIBCXX_STD_PR::vector<__warning_data> __warning_vector_t;\n-\n-  // Defined in profiler_<diagnostic name>.h.\n-  class __trace_hash_func;\n-  class __trace_hashtable_size;\n-  class __trace_map2umap;\n-  class __trace_vector_size;\n-  class __trace_vector_to_list;\n-  void __trace_vector_size_init();\n-  void __trace_hashtable_size_init();\n-  void __trace_hash_func_init();\n-  void __trace_vector_to_list_init();\n-  void __trace_map_to_unordered_map_init();\n-  void __trace_vector_size_report(FILE*, __warning_vector_t&);\n-  void __trace_hashtable_size_report(FILE*, __warning_vector_t&);\n-  void __trace_hash_func_report(FILE*, __warning_vector_t&);\n-  void __trace_vector_to_list_report(FILE*, __warning_vector_t&);\n-  void __trace_map_to_unordered_map_report(FILE*, __warning_vector_t&);\n-\n-  // Utility functions.\n-  inline size_t \n-  __max(size_t __a, size_t __b) { return __a >= __b ? __a : __b; }\n-\n-  inline size_t \n-  __min(size_t __a, size_t __b)  { return __a <= __b ? __a : __b; }\n-\n-  /** @brief Storage for diagnostic table entries.  Has only static fields.  */\n-  template<int _Unused=0>\n-    class __tables\n-    {\n-    public:\n-      static __trace_hash_func*        \t_S_hash_func;\n-      static __trace_hashtable_size* \t_S_hashtable_size;\n-      static __trace_map2umap* \t\t_S_map2umap;\n-      static __trace_vector_size* \t_S_vector_size;\n-      static __trace_vector_to_list* \t_S_vector_to_list;\n-    };\n-\n-  template<int _Unused>\n-    __trace_hash_func* __tables<_Unused>::_S_hash_func = NULL;\n-\n-  template<int _Unused>\n-    __trace_hashtable_size* __tables<_Unused>::_S_hashtable_size = NULL;\n-\n-  template<int _Unused>\n-    __trace_map2umap* __tables<_Unused>::_S_map2umap = NULL;\n-\n-  template<int _Unused>\n-    __trace_vector_size* __tables<_Unused>::_S_vector_size = NULL;\n-\n-  template<int _Unused>\n-    __trace_vector_to_list* __tables<_Unused>::_S_vector_to_list = NULL;\n-\n-  /** @brief Storage for user defined parameters.  Has only static fields.  */\n-  template<int _Unused=0>\n-    class __settings \n-    {\n-    public:\n-      static const char* \t_S_trace_file_name;\n-      static size_t \t\t_S_max_warn_count;\n-      static size_t \t\t_S_max_stack_depth;\n-      static size_t \t\t_S_max_mem;\n-  };\n-\n-  template<int _Unused>\n-    const char* __settings<_Unused>::_S_trace_file_name =\n-    _GLIBCXX_PROFILE_TRACE_PATH_ROOT;\n-\n-  template<int _Unused>\n-    size_t __settings<_Unused>::_S_max_warn_count =\n-    _GLIBCXX_PROFILE_MAX_WARN_COUNT;\n-\n-  template<int _Unused>\n-    size_t __settings<_Unused>::_S_max_stack_depth =\n-    _GLIBCXX_PROFILE_MAX_STACK_DEPTH;\n-\n-  template<int _Unused>\n-    size_t __settings<_Unused>::_S_max_mem =\n-    _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC;\n-\n-  inline size_t \n-  __stack_max_depth() { return __settings<0>::_S_max_stack_depth; }\n-\n-  inline size_t \n-  __max_mem() { return __settings<0>::_S_max_mem; }\n-\n-  /** @brief Base class for all trace producers.  */\n-  template<typename __object_info, typename __stack_info>\n-    class __trace_base\n-    {\n-    public:\n-      __trace_base();\n-      virtual ~__trace_base() { }\n-      \n-      void __add_object(__object_t object, __object_info __info);\n-      __object_info* __get_object_info(__object_t __object);\n-      void __retire_object(__object_t __object);\n-      void __write(FILE* f);\n-      void __collect_warnings(__warning_vector_t& warnings);\n-      \n-      void __lock_object_table();\n-      void __lock_stack_table();\n-      void __unlock_object_table();\n-      void __unlock_stack_table();\n-      \n-    private:\n-      __mutex_t __object_table_lock;\n-      __mutex_t __stack_table_lock;\n-      typedef _GLIBCXX_IMPL_UNORDERED_MAP<__object_t,\n-\t\t\t\t\t  __object_info> __object_table_t;\n-      typedef _GLIBCXX_IMPL_UNORDERED_MAP<__stack_t, __stack_info, __stack_hash,\n-\t\t\t\t\t  __stack_hash> __stack_table_t;\n-      __object_table_t __object_table;\n-      __stack_table_t __stack_table;\n-      size_t __stack_table_byte_size;\n-      \n-    protected:\n-      const char* __id;\n-    };\n-  \n-  template<typename __object_info, typename __stack_info>\n-    void \n-    __trace_base<__object_info, __stack_info>::__collect_warnings(__warning_vector_t& warnings)\n-    {\n-      typename __stack_table_t::iterator __i = __stack_table.begin();\n-      for ( ; __i != __stack_table.end(); ++__i)\n-\t{\n-\t  warnings.push_back(__warning_data((*__i).second.__magnitude(),\n-\t\t\t\t\t    (*__i).first,\n-\t\t\t\t\t    __id,\n-\t\t\t\t\t    (*__i).second.__advice()));\n-\t}\n-    }\n+inline __warning_data::__warning_data(float __m, __stack_t __c, \n+                                      const char* __id, const char* __msg)\n+    : __magnitude(__m), __context(__c), __warning_id(__id),\n+      __warning_message(__msg)\n+{\n+}\n \n-  template<typename __object_info, typename __stack_info>\n-    void \n-    __trace_base<__object_info, __stack_info>::__lock_object_table()\n-    { __mutex<0>::__lock(this->__object_table_lock); }\n-\n-  template<typename __object_info, typename __stack_info>\n-    void\n-    __trace_base<__object_info, __stack_info>::__lock_stack_table()\n-    { __mutex<0>::__lock(this->__stack_table_lock); }\n-\n-  template<typename __object_info, typename __stack_info>\n-    void __trace_base<__object_info, __stack_info>::__unlock_object_table()\n-    { __mutex<0>::__unlock(this->__object_table_lock); }\n-\n-  template<typename __object_info, typename __stack_info>\n-    void __trace_base<__object_info, __stack_info>::__unlock_stack_table()\n-    { __mutex<0>::__unlock(this->__stack_table_lock); }\n-\n-  template<typename __object_info, typename __stack_info>\n-    __trace_base<__object_info, __stack_info>::__trace_base()\n-    {\n-      // Do not pick the initial size too large, as we don't know which\n-      // diagnostics are more active.\n-      __object_table.rehash(10000);\n-      __stack_table.rehash(10000);\n-      __stack_table_byte_size = 0;\n-      __id = NULL;\n-      __stack_table_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n-      __object_table_lock = __stack_table_lock;\n-    }\n+inline bool __warning_data::operator>(const struct __warning_data& other) const\n+{\n+  return __magnitude > other.__magnitude;\n+}\n+\n+typedef std::_GLIBCXX_STD_PR::vector<__warning_data> __warning_vector_t;\n+\n+// Defined in profiler_<diagnostic name>.h.\n+class __trace_hash_func;\n+class __trace_hashtable_size;\n+class __trace_map2umap;\n+class __trace_vector_size;\n+class __trace_vector_to_list;\n+class __trace_list_to_slist; \n+class __trace_list_to_vector; \n+void __trace_vector_size_init();\n+void __trace_hashtable_size_init();\n+void __trace_hash_func_init();\n+void __trace_vector_to_list_init();\n+void __trace_list_to_slist_init();  \n+void __trace_list_to_vector_init();  \n+void __trace_map_to_unordered_map_init();\n+void __trace_vector_size_report(FILE*, __warning_vector_t&);\n+void __trace_hashtable_size_report(FILE*, __warning_vector_t&);\n+void __trace_hash_func_report(FILE*, __warning_vector_t&);\n+void __trace_vector_to_list_report(FILE*, __warning_vector_t&);\n+void __trace_list_to_slist_report(FILE*, __warning_vector_t&); \n+void __trace_list_to_vector_report(FILE*, __warning_vector_t&);\n+void __trace_map_to_unordered_map_report(FILE*, __warning_vector_t&);\n+\n+// Utility functions.\n+inline size_t __max(size_t __a, size_t __b)\n+{\n+  return __a >= __b ? __a : __b;\n+}\n \n-  template<typename __object_info, typename __stack_info>\n-    void \n-    __trace_base<__object_info, __stack_info>::__add_object(__object_t __object, __object_info __info)\n+inline size_t __min(size_t __a, size_t __b)\n+{\n+  return __a <= __b ? __a : __b;\n+}\n+\n+struct __cost_factor\n+{\n+  const char* __env_var;\n+  float __value;\n+};\n+\n+typedef std::_GLIBCXX_STD_PR::vector<__cost_factor*> __cost_factor_vector;\n+\n+_GLIBCXX_PROFILE_DEFINE_DATA(__trace_hash_func*, _S_hash_func, NULL);\n+_GLIBCXX_PROFILE_DEFINE_DATA(__trace_hashtable_size*, _S_hashtable_size, NULL);\n+_GLIBCXX_PROFILE_DEFINE_DATA(__trace_map2umap*, _S_map2umap, NULL);\n+_GLIBCXX_PROFILE_DEFINE_DATA(__trace_vector_size*, _S_vector_size, NULL);\n+_GLIBCXX_PROFILE_DEFINE_DATA(__trace_vector_to_list*, _S_vector_to_list, NULL);\n+_GLIBCXX_PROFILE_DEFINE_DATA(__trace_list_to_slist*, _S_list_to_slist, NULL); \n+_GLIBCXX_PROFILE_DEFINE_DATA(__trace_list_to_vector*, _S_list_to_vector, NULL);\n+\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_shift_cost_factor, \n+                             {\"__vector_shift_cost_factor\", 1.0});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_iterate_cost_factor,\n+                             {\"__vector_iterate_cost_factor\", 1.0});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __vector_resize_cost_factor,\n+                             {\"__vector_resize_cost_factor\", 1.0}); \n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_shift_cost_factor,\n+                             {\"__list_shift_cost_factor\", 0.0});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_iterate_cost_factor,\n+                             {\"__list_iterate_cost_factor\", 10.0}); \n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __list_resize_cost_factor,\n+                             {\"__list_resize_cost_factor\", 0.0}); \n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_insert_cost_factor,\n+                             {\"__map_insert_cost_factor\", 1.5});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_erase_cost_factor,\n+                             {\"__map_erase_cost_factor\", 1.5});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_find_cost_factor,\n+                             {\"__map_find_cost_factor\", 1});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __map_iterate_cost_factor,\n+                             {\"__map_iterate_cost_factor\", 2.3});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_insert_cost_factor,\n+                             {\"__umap_insert_cost_factor\", 12.0});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_erase_cost_factor,\n+                             {\"__umap_erase_cost_factor\", 12.0});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_find_cost_factor,\n+                             {\"__umap_find_cost_factor\", 10.0});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor, __umap_iterate_cost_factor,\n+                             {\"__umap_iterate_cost_factor\", 1.7});\n+_GLIBCXX_PROFILE_DEFINE_DATA(__cost_factor_vector*, __cost_factors, NULL);\n+\n+_GLIBCXX_PROFILE_DEFINE_DATA(const char*, _S_trace_file_name,\n+                             _GLIBCXX_PROFILE_TRACE_PATH_ROOT);\n+_GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_warn_count,\n+                             _GLIBCXX_PROFILE_MAX_WARN_COUNT);\n+_GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_stack_depth,\n+                             _GLIBCXX_PROFILE_MAX_STACK_DEPTH);\n+_GLIBCXX_PROFILE_DEFINE_DATA(size_t, _S_max_mem,\n+                             _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC);\n+\n+inline size_t __stack_max_depth()\n+{\n+  return _GLIBCXX_PROFILE_DATA(_S_max_stack_depth);\n+}\n+\n+inline size_t __max_mem()\n+{\n+  return _GLIBCXX_PROFILE_DATA(_S_max_mem);\n+}\n+\n+/** @brief Base class for all trace producers.  */\n+template <typename __object_info, typename __stack_info>\n+class __trace_base\n+{\n+ public:\n+  __trace_base();\n+  virtual ~__trace_base() {}\n+\n+  void __add_object(__object_t object, __object_info __info);\n+  __object_info* __get_object_info(__object_t __object);\n+  void __retire_object(__object_t __object);\n+  void __write(FILE* f);\n+  void __collect_warnings(__warning_vector_t& __warnings);\n+\n+  void __lock_object_table();\n+  void __lock_stack_table();\n+  void __unlock_object_table();\n+  void __unlock_stack_table();\n+\n+ private:\n+  __mutex_t __object_table_lock;\n+  __mutex_t __stack_table_lock;\n+  typedef _GLIBCXX_IMPL_UNORDERED_MAP<__object_t, \n+                                      __object_info> __object_table_t;\n+  typedef _GLIBCXX_IMPL_UNORDERED_MAP<__stack_t, __stack_info, __stack_hash, \n+                                      __stack_hash> __stack_table_t;\n+  __object_table_t __object_table;\n+  __stack_table_t __stack_table;\n+  size_t __stack_table_byte_size;\n+\n+ protected:\n+  const char* __id;\n+};\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__collect_warnings(\n+    __warning_vector_t& __warnings)\n+{\n+  typename __stack_table_t::iterator __i = __stack_table.begin();\n+  for ( ; __i != __stack_table.end(); ++__i )\n   {\n-    typedef typename __object_table_t::value_type value_type;\n-    if (__max_mem() == 0\n-\t|| __object_table.size() * sizeof(__object_info) <= __max_mem()) \n-      {\n-\t__lock_object_table();\n-\t__object_table.insert(value_type(__object, __info));\n-      __unlock_object_table();\n-    }\n+    __warnings.push_back(__warning_data((*__i).second.__magnitude(), \n+                                        (*__i).first, \n+                                        __id,\n+                                        (*__i).second.__advice()));\n   }\n+}\n \n-  template<typename __object_info, typename __stack_info>\n-    __object_info* \n-   __trace_base<__object_info, __stack_info>::__get_object_info(__object_t __object)\n-  {\n-    // XXX: Revisit this to see if we can decrease mutex spans.\n-    // Without this mutex, the object table could be rehashed during an\n-    // insertion on another thread, which could result in a segfault.\n-    __lock_object_table();\n-    typename __object_table_t::iterator __object_it =\n-      __object_table.find(__object);\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__lock_object_table()\n+{\n+  __lock(this->__object_table_lock);\n+}\n \n-    if (__object_it == __object_table.end())\n-      {\n-\t__unlock_object_table();\n-\treturn NULL;\n-      } \n-    else \n-      {\n-\t__unlock_object_table();\n-\treturn &__object_it->second;\n-      }\n-  }\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__lock_stack_table()\n+{\n+  __lock(this->__stack_table_lock);\n+}\n \n-  template<typename __object_info, typename __stack_info>\n-    void \n-    __trace_base<__object_info, __stack_info>::__retire_object(__object_t __object)\n-  {\n-    __lock_object_table();\n-    __lock_stack_table();\n-    typename __object_table_t::iterator __object_it =\n-      __object_table.find(__object);\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__unlock_object_table()\n+{\n+  __unlock(this->__object_table_lock);\n+}\n \n-    if (__object_it != __object_table.end())\n-      {\n-\tconst __object_info& __info = __object_it->second;\n-\tconst __stack_t& __stack = __info.__stack();\n-\ttypename __stack_table_t::iterator __stack_it =\n-\t__stack_table.find(__stack);\n-\n-\tif (__stack_it == __stack_table.end()) \n-\t  {\n-\t    // First occurence of this call context.\n-\t    if (__max_mem() == 0 || __stack_table_byte_size < __max_mem()) \n-\t      {\n-\t\t__stack_table_byte_size +=\n-\t\t  (sizeof(__instruction_address_t) * __size(__stack)\n-\t\t   + sizeof(__stack) + sizeof(__stack_info));\n-\t\t__stack_table.insert(make_pair(__stack, __stack_info(__info)));\n-\t      }\n-\t  } \n-\telse \n-\t  {\n-\t    // Merge object info into info summary for this call context.\n-\t    __stack_it->second.__merge(__info);\n-\t    delete __stack;\n-\t  }\n-\t__object_table.erase(__object);\n-      }\n-    __unlock_stack_table();\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__unlock_stack_table()\n+{\n+  __unlock(this->__stack_table_lock);\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+__trace_base<__object_info, __stack_info>::__trace_base()\n+{\n+  // Do not pick the initial size too large, as we don't know which diagnostics\n+  // are more active.\n+  __object_table.rehash(10000);\n+  __stack_table.rehash(10000);\n+  __stack_table_byte_size = 0;\n+  __id = NULL;\n+  __object_table_lock = __stack_table_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n+}\n+\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__add_object(\n+    __object_t __object, __object_info __info)\n+{\n+  if (__max_mem() == 0 \n+      || __object_table.size() * sizeof(__object_info) <= __max_mem()) {\n+    __lock_object_table();\n+    __object_table.insert(\n+        typename __object_table_t::value_type(__object, __info));\n     __unlock_object_table();\n   }\n+}\n \n-  template<typename __object_info, typename __stack_info>\n-  void \n-  __trace_base<__object_info, __stack_info>::__write(FILE* __f)\n-  {\n-    typename __stack_table_t::iterator __it;\n-\n-    for (__it = __stack_table.begin(); __it != __stack_table.end(); __it++) \n-      {\n-\tif (__it->second.__is_valid()) \n-\t  {\n-\t    fprintf(__f, __id);\n-\t    fprintf(__f, \"|\");\n-\t    __gnu_profile::__write(__f, __it->first);\n-\t    fprintf(__f, \"|\");\n-\t    __it->second.__write(__f);\n-\t  }\n-      }\n+template <typename __object_info, typename __stack_info>\n+__object_info* __trace_base<__object_info, __stack_info>::__get_object_info(\n+    __object_t __object)\n+{\n+  // XXX: Revisit this to see if we can decrease mutex spans.\n+  // Without this mutex, the object table could be rehashed during an\n+  // insertion on another thread, which could result in a segfault.\n+  __lock_object_table();\n+  typename __object_table_t::iterator __object_it = \n+      __object_table.find(__object);\n+  if (__object_it == __object_table.end()){\n+    __unlock_object_table();\n+    return NULL;\n+  } else {\n+    __unlock_object_table();\n+    return &__object_it->second;\n   }\n+}\n \n-  inline size_t \n-  __env_to_size_t(const char* __env_var, size_t __default_value)\n-  {\n-    char* __env_value = getenv(__env_var);\n-    if (__env_value) \n-      {\n-\tlong int __converted_value = strtol(__env_value, NULL, 10);\n-\tif (errno || __converted_value < 0) \n-\t  {\n-\t    fprintf(stderr, \"Bad value for environment variable '%s'.\",\n-\t\t    __env_var);\n-\t    abort();\n-\t  } \n-\telse \n-\t  {\n-\t    return static_cast<size_t>(__converted_value);\n-\t  }\n-      } \n-    else \n-      {\n-\treturn __default_value;\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__retire_object(\n+    __object_t __object)\n+{\n+  __lock_object_table();\n+  __lock_stack_table();\n+  typename __object_table_t::iterator __object_it =\n+      __object_table.find(__object);\n+  if (__object_it != __object_table.end()){\n+    const __object_info& __info = __object_it->second;\n+    const __stack_t& __stack = __info.__stack();\n+    typename __stack_table_t::iterator __stack_it = \n+        __stack_table.find(__stack);\n+    if (__stack_it == __stack_table.end()) {\n+      // First occurence of this call context.\n+      if (__max_mem() == 0 || __stack_table_byte_size < __max_mem()) {\n+        __stack_table_byte_size += \n+            (sizeof(__instruction_address_t) * __size(__stack)\n+             + sizeof(__stack) + sizeof(__stack_info));\n+        __stack_table.insert(make_pair(__stack, __stack_info(__info)));\n       }\n+    } else {\n+      // Merge object info into info summary for this call context.\n+      __stack_it->second.__merge(__info);\n+      delete __stack;\n+    }\n+    __object_table.erase(__object);\n   }\n+  __unlock_stack_table();\n+  __unlock_object_table();\n+}\n \n-  inline void \n-  __set_max_stack_trace_depth()\n-  {\n-    __settings<0>::_S_max_stack_depth = __env_to_size_t(_GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR, __settings<0>::_S_max_stack_depth);\n+template <typename __object_info, typename __stack_info>\n+void __trace_base<__object_info, __stack_info>::__write(FILE* __f)\n+{\n+  typename __stack_table_t::iterator __it;\n+\n+  for (__it = __stack_table.begin(); __it != __stack_table.end(); __it++) {\n+    if (__it->second.__is_valid()) {\n+      fprintf(__f, __id);\n+      fprintf(__f, \"|\");\n+      __gnu_profile::__write(__f, __it->first);\n+      fprintf(__f, \"|\");\n+      __it->second.__write(__f);\n+    }\n   }\n+}\n \n-  inline void \n-  __set_max_mem()\n-  {\n-    __settings<0>::_S_max_mem = __env_to_size_t(_GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR, __settings<0>::_S_max_mem);\n+inline size_t __env_to_size_t(const char* __env_var, size_t __default_value)\n+{\n+  char* __env_value = getenv(__env_var);\n+  if (__env_value) {\n+    long int __converted_value = strtol(__env_value, NULL, 10);\n+    if (errno || __converted_value < 0) {\n+      fprintf(stderr, \"Bad value for environment variable '%s'.\\n\", __env_var);\n+      abort();\n+    } else {\n+      return static_cast<size_t>(__converted_value);\n+    }\n+  } else {\n+    return __default_value;\n   }\n+}\n \n-  inline int \n-  __log_magnitude(float f)\n-  {\n-    const float log_base = 10.0;\n-    int result = 0;\n-    int sign = 1;\n-    if (f < 0) \n-      {\n-\tf = -f;\n-\tsign = -1;\n-      }\n-    while (f > log_base) \n-      {\n-\t++result;\n-\tf /= 10.0;\n-      }\n-    return sign * result;\n+inline void __set_max_stack_trace_depth()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_max_stack_depth) = __env_to_size_t(\n+      _GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR,\n+      _GLIBCXX_PROFILE_DATA(_S_max_stack_depth));\n+}\n+\n+inline void __set_max_mem()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_max_mem) = __env_to_size_t(\n+      _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR,\n+      _GLIBCXX_PROFILE_DATA(_S_max_mem));\n+}\n+\n+inline int __log_magnitude(float f)\n+{\n+  const float log_base = 10.0;\n+  int result = 0;\n+  int sign = 1;\n+  if (f < 0) {\n+    f = -f;\n+    sign = -1;\n   }\n+  while (f > log_base) {\n+    ++result;\n+    f /= 10.0;\n+  }\n+  return sign * result;\n+}\n \n-  struct __warn\n+struct __warn\n+{\n+  FILE* __file;\n+  __warn(FILE* __f) { __file = __f; }\n+  void operator() (const __warning_data& __info)\n   {\n-    FILE* __file;\n-\n-    __warn(FILE* __f) { __file = __f; }\n-\n-    void operator() (const __warning_data& __info)\n-    {\n-      fprintf(__file,  __info.__warning_id);\n-      fprintf(__file, \": improvement = %d\", \n-\t      __log_magnitude(__info.__magnitude));\n-      fprintf(__file, \": call stack = \");\n-      __gnu_profile::__write(__file, __info.__context);\n-      fprintf(__file, \": advice = %s\\n\", __info.__warning_message);\n-    }\n-  };\n+    fprintf(__file,  __info.__warning_id);\n+    fprintf(__file, \": improvement = %d\", __log_magnitude(__info.__magnitude));\n+    fprintf(__file, \": call stack = \");\n+    __gnu_profile::__write(__file, __info.__context);\n+    fprintf(__file, \": advice = %s\\n\", __info.__warning_message);\n+    free(\n+        const_cast<void*>(\n+            reinterpret_cast<const void*>(__info.__warning_message)));\n+  }\n+};\n \n-  inline FILE* \n-  __open_output_file(const char* extension)\n-  {\n-    // The path is made of _S_trace_file_name + \".\" + extension.\n-    size_t root_len = strlen(__settings<0>::_S_trace_file_name);\n-    size_t ext_len = strlen(extension);\n-    char* file_name = new char[root_len + 1 + ext_len + 1];\n-    char* p = file_name;\n-    memcpy(file_name, __settings<0>::_S_trace_file_name, root_len);\n-    *(file_name + root_len) = '.';\n-    memcpy(file_name + root_len + 1, extension, ext_len + 1);\n-    FILE* out_file = fopen(file_name, \"w\");\n-    if (out_file) \n-      return out_file;\n-    else \n-      {\n-\tfprintf(stderr, \"Could not open trace file '%s'.\", file_name);\n-\tabort();\n-      }\n+inline FILE* __open_output_file(const char* extension)\n+{\n+  // The path is made of _S_trace_file_name + \".\" + extension.\n+  size_t root_len = strlen(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n+  size_t ext_len = strlen(extension);\n+  char* file_name = new char[root_len + 1 + ext_len + 1];\n+  memcpy(file_name, _GLIBCXX_PROFILE_DATA(_S_trace_file_name), root_len);\n+  *(file_name + root_len) = '.';\n+  memcpy(file_name + root_len + 1, extension, ext_len + 1);\n+  FILE* out_file = fopen(file_name, \"w\");\n+  if (out_file) {\n+    return out_file;\n+  } else {\n+    fprintf(stderr, \"Could not open trace file '%s'.\\n\", file_name);\n+    abort();\n   }\n+}\n+\n+/** @brief Final report method, registered with \"atexit\".\n+ *\n+ * This can also be called directly by user code, including signal handlers.\n+ * It is protected against deadlocks by the reentrance guard in profiler.h.\n+ * However, when called from a signal handler that triggers while within\n+ * __gnu_profile (under the guarded zone), no output will be produced.\n+ */\n+inline void __report(void)\n+{\n+  __lock(_GLIBCXX_PROFILE_DATA(__global_lock));\n \n-  /** @brief Final report method, registered with \"atexit\".\n-   *\n-   * This can also be called directly by user code, including signal handlers.\n-   * It is protected against deadlocks by the reentrance guard in profiler.h.\n-   * However, when called from a signal handler that triggers while within\n-   * __gnu_profile (under the guarded zone), no output will be produced.\n-   */\n-  inline void \n-  __report(void)\n-  {\n-    __mutex<0>::__lock(__mutex<0>::__global_lock);\n+  __warning_vector_t __warnings;\n \n-    __warning_vector_t __warnings;\n+  FILE* __raw_file = __open_output_file(\"raw\");\n+  __trace_vector_size_report(__raw_file, __warnings);\n+  __trace_hashtable_size_report(__raw_file, __warnings);\n+  __trace_hash_func_report(__raw_file, __warnings);\n+  __trace_vector_to_list_report(__raw_file, __warnings);\n+  __trace_list_to_slist_report(__raw_file, __warnings);\n+  __trace_list_to_vector_report(__raw_file, __warnings);\n+  __trace_map_to_unordered_map_report(__raw_file, __warnings);\n+  fclose(__raw_file);\n \n-    FILE* __raw_file = __open_output_file(\"raw\");\n-    __trace_vector_size_report(__raw_file, __warnings);\n-    __trace_hashtable_size_report(__raw_file, __warnings);\n-    __trace_hash_func_report(__raw_file, __warnings);\n-    __trace_vector_to_list_report(__raw_file, __warnings);\n-    __trace_map_to_unordered_map_report(__raw_file, __warnings);\n-    fclose(__raw_file);\n+  // Sort data by magnitude.\n+  // XXX: instead of sorting, should collect only top N for better performance.\n+  size_t __cutoff = __min(_GLIBCXX_PROFILE_DATA(_S_max_warn_count),\n+                          __warnings.size());\n \n-    // Sort data by magnitude.\n+  std::sort(__warnings.begin(), __warnings.end(),\n+            std::greater<__warning_vector_t::value_type>());\n+  __warnings.resize(__cutoff);\n \n-    // XXX: instead of sorting, should collect only top N for better\n-    // performance.\n-    size_t __cutoff = __min(__settings<0>::_S_max_warn_count,\n-\t\t\t    __warnings.size());\n+  FILE* __warn_file = __open_output_file(\"txt\");\n+  std::for_each(__warnings.begin(), __warnings.end(), __warn(__warn_file));\n+  fclose(__warn_file);\n \n-    std::sort(__warnings.begin(), __warnings.end(),\n-\t      std::greater<__warning_vector_t::value_type>());\n-    __warnings.resize(__cutoff);\n+  __unlock(_GLIBCXX_PROFILE_DATA(__global_lock));\n+}\n \n-    FILE* __warn_file = __open_output_file(\"txt\");\n-    std::for_each(__warnings.begin(), __warnings.end(), __warn(__warn_file));\n-    fclose(__warn_file);\n+inline void __set_trace_path()\n+{\n+  char* __env_trace_file_name = getenv(_GLIBCXX_PROFILE_TRACE_ENV_VAR);\n \n-    __mutex<0>::__unlock(__mutex<0>::__global_lock);\n+  if (__env_trace_file_name) { \n+    _GLIBCXX_PROFILE_DATA(_S_trace_file_name) = __env_trace_file_name; \n   }\n \n-  inline void \n-  __set_trace_path()\n-  {\n-    char* __env_trace_file_name = getenv(_GLIBCXX_PROFILE_TRACE_ENV_VAR);\n+  // Make sure early that we can create the trace file.\n+  fclose(__open_output_file(\"txt\"));\n+}\n \n-    if (__env_trace_file_name) \n-      __settings<0>::_S_trace_file_name = __env_trace_file_name;\n+inline void __set_max_warn_count()\n+{\n+  char* __env_max_warn_count_str = getenv(\n+      _GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR);\n \n-    // Make sure early that we can create the trace file.\n-    fclose(__open_output_file(\"txt\"));\n+  if (__env_max_warn_count_str) {\n+    _GLIBCXX_PROFILE_DATA(_S_max_warn_count) = static_cast<size_t>(\n+        atoi(__env_max_warn_count_str));\n   }\n+}\n \n-  inline void \n-  __set_max_warn_count()\n-  {\n-    char* __env_max_warn_count_str = getenv(_GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR);\n+inline void __read_cost_factors()\n+{\n+  std::string __conf_file_name(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));\n+  __conf_file_name += \".conf\";\n+\n+  std::ifstream __conf_file(__conf_file_name.c_str());\n+\n+  if (__conf_file.is_open()) {\n+    std::string __line;\n+\n+    while (getline(__conf_file, __line)) {\n+      std::string::size_type __i = __line.find_first_not_of(\" \\t\\n\\v\");\n \n-    if (__env_max_warn_count_str) \n-      {\n-\tint i = atoi(__env_max_warn_count_str);\n-\t__settings<0>::_S_max_warn_count = static_cast<size_t>(i);\n+      if (__line.length() <= 0 || __line[__i] == '#') {\n+        // Skip empty lines or comments.\n+        continue;\n+      }\n+\n+      // Trim.\n+      __line.erase(std::remove(__line.begin(), __line.end(), ' '), \n+                   __line.end());\n+      std::string::size_type __pos = __line.find(\"=\");\n+      std::string __factor_name = __line.substr(0, __pos);\n+      std::string::size_type __end = __line.find_first_of(\";\\n\");\n+      std::string __factor_value = __line.substr(__pos + 1, __end - __pos);\n+\n+      setenv(__factor_name.c_str(), __factor_value.c_str(), 0);\n     }\n+  } \n+}\n+\n+struct __cost_factor_writer\n+{\n+  FILE* __file;\n+  __cost_factor_writer(FILE* __f) : __file(__f) {}\n+  void operator() (const __cost_factor* __factor)\n+  {\n+    fprintf(__file, \"%s = %f\\n\", __factor->__env_var, __factor->__value);\n   }\n+};\n \n-  inline void \n-  __profcxx_init_unconditional()\n+inline void __write_cost_factors()\n+{\n+  FILE* __file = __open_output_file(\"conf.out\");\n+  std::for_each(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin(),\n+                _GLIBCXX_PROFILE_DATA(__cost_factors)->end(),\n+                __cost_factor_writer(__file));\n+  fclose(__file);\n+}\n+\n+struct __cost_factor_setter\n+{\n+  void operator() (__cost_factor* __factor)\n   {\n-    __mutex<0>::__lock(__mutex<0>::__global_lock);\n+    char* __env_cost_factor;\n+    if (__env_cost_factor = getenv(__factor->__env_var))\n+      __factor->__value = atof(__env_cost_factor);\n+  }\n+};\n+\n+inline void __set_cost_factors()\n+{\n+  _GLIBCXX_PROFILE_DATA(__cost_factors) = new __cost_factor_vector;\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__vector_resize_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__list_shift_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__list_resize_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__map_erase_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__map_find_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__map_iterate_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__umap_find_cost_factor));\n+  _GLIBCXX_PROFILE_DATA(__cost_factors)->push_back(\n+      &_GLIBCXX_PROFILE_DATA(__umap_iterate_cost_factor));\n+  std::for_each(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin(),\n+                _GLIBCXX_PROFILE_DATA(__cost_factors)->end(),\n+                __cost_factor_setter());\n+}\n+\n+inline void __profcxx_init_unconditional()\n+{\n+  __lock(_GLIBCXX_PROFILE_DATA(__global_lock));\n+\n+  if (__is_invalid()) {\n \n     __set_max_warn_count();\n \n-    if (__is_invalid()) \n-      {\n-      if (__settings<0>::_S_max_warn_count == 0) \n-\t{\n-\t  __turn_off();\n-\t} \n-      else \n-\t{\n-\t__set_max_stack_trace_depth();\n-\t__set_max_mem();\n-\t__set_trace_path();\n-\n-\t__trace_vector_size_init();\n-\t__trace_hashtable_size_init();\n-\t__trace_hash_func_init();\n-\t__trace_vector_to_list_init();\n-\t__trace_map_to_unordered_map_init();\n-\n-\tatexit(__report);\n-\n-\t__turn_on();\n-\t}\n-      }\n+    if (_GLIBCXX_PROFILE_DATA(_S_max_warn_count) == 0) {\n+\n+      __turn_off();\n+\n+    } else {\n+\n+      __set_max_stack_trace_depth();\n+      __set_max_mem();\n+      __set_trace_path();\n+      __read_cost_factors(); \n+      __set_cost_factors();\n+      __write_cost_factors();\n+\n+      __trace_vector_size_init();\n+      __trace_hashtable_size_init();\n+      __trace_hash_func_init();\n+      __trace_vector_to_list_init();\n+      __trace_list_to_slist_init(); \n+      __trace_list_to_vector_init();\n+      __trace_map_to_unordered_map_init();\n+\n+      atexit(__report);\n+\n+      __turn_on();\n \n-    __mutex<0>::__unlock(__mutex<0>::__global_lock);\n+    }\n   }\n \n-  /** @brief This function must be called by each instrumentation point.\n-   *\n-   * The common path is inlined fully.\n-   */\n-  inline bool \n-  __profcxx_init(void)\n-  {\n-    if (__is_invalid())\n-      __profcxx_init_unconditional();\n-    return __is_on();\n+  __unlock(_GLIBCXX_PROFILE_DATA(__global_lock));\n+}\n+\n+/** @brief This function must be called by each instrumentation point.\n+ *\n+ * The common path is inlined fully.\n+ */\n+inline bool __profcxx_init(void)\n+{\n+  if (__is_invalid()) {\n+    __profcxx_init_unconditional();\n   }\n \n+  return __is_on();\n+}\n+\n } // namespace __gnu_profile\n \n #endif /* _GLIBCXX_PROFILE_PROFILER_TRACE_H */"}, {"sha": "8d630e4d90b5fc2d569de36996c54e17a41e8b0e", "filename": "libstdc++-v3/include/profile/impl/profiler_vector_size.h", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -54,49 +54,51 @@\n \n namespace __gnu_profile\n {\n-  /** @brief Hashtable size instrumentation trace producer.  */\n-  class __trace_vector_size : public __trace_container_size\n-  {\n-  public:\n-    __trace_vector_size() : __trace_container_size() { __id = \"vector-size\"; }\n-  };\n-\n-  // Initialization and report.\n-  inline void \n-  __trace_vector_size_init()\n-  { __tables<0>::_S_vector_size = new __trace_vector_size(); }\n-\n-  inline void \n-  __trace_vector_size_report(FILE* __f, __warning_vector_t& __warnings)\n-  {\n-    if (__tables<0>::_S_vector_size) \n-      {\n-\t__tables<0>::_S_vector_size->__collect_warnings(__warnings);\n-\t__tables<0>::_S_vector_size->__write(__f);\n-      }\n-  }\n \n-  // Implementations of instrumentation hooks.\n-  inline void \n-  __trace_vector_size_construct(const void* __obj, size_t __num)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_size->__insert(__obj, __get_stack(), __num);\n-  }\n+/** @brief Hashtable size instrumentation trace producer.  */\n+class __trace_vector_size : public __trace_container_size\n+{\n+ public:\n+  __trace_vector_size() : __trace_container_size() { __id = \"vector-size\"; }\n+};\n \n-  inline void \n-  __trace_vector_size_destruct(const void* __obj, size_t __num, size_t __inum)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_size->__destruct(__obj, __num, __inum);\n-  }\n+inline void __trace_vector_size_init()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_vector_size) = new __trace_vector_size();\n+}\n \n-  inline void\n-  __trace_vector_size_resize(const void* __obj, size_t __from, size_t __to)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_size->__resize(__obj, __from, __to);\n+inline void __trace_vector_size_report(FILE* __f, \n+                                       __warning_vector_t& __warnings)\n+{\n+  if (_GLIBCXX_PROFILE_DATA(_S_vector_size)) {\n+    _GLIBCXX_PROFILE_DATA(_S_vector_size)->__collect_warnings(__warnings);\n+    _GLIBCXX_PROFILE_DATA(_S_vector_size)->__write(__f);\n   }\n+}\n+\n+inline void __trace_vector_size_construct(const void* __obj, size_t __num)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_size)->__insert(__obj, __get_stack(), __num);\n+}\n+\n+inline void __trace_vector_size_destruct(const void* __obj, size_t __num,\n+                                         size_t __inum)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_size)->__destruct(__obj, __num, __inum);\n+}\n+\n+inline void __trace_vector_size_resize(const void* __obj, size_t __from,\n+                                       size_t __to)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_size)->__resize(__obj, __from, __to);\n+}\n+\n } // namespace __gnu_profile\n \n #endif /* _GLIBCXX_PROFILE_PROFILER_VECTOR_SIZE_H */"}, {"sha": "d4113da8b4e4d9722a85bdba1738cc919ea25827", "filename": "libstdc++-v3/include/profile/impl/profiler_vector_to_list.h", "status": "modified", "additions": 265, "deletions": 238, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -28,8 +28,8 @@\n // reasons why the executable file might be covered by the GNU General\n // Public License.\n \n-/** @file profile/impl/profiler_trace.h\n- *  @brief Data structures to represent profiling traces.\n+/** @file profile/impl/profiler_vector_to_list.h\n+ *  @brief diagnostics for vector to list.\n  */\n \n // Written by Lixia Liu and Silvius Rus.\n@@ -52,258 +52,285 @@\n \n namespace __gnu_profile\n {\n-  /** @brief A vector-to-list instrumentation line in the object table.  */\n-  class __vector2list_info: public __object_info_base\n-  {\n-  public:\n-    __vector2list_info()\n-    :_M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n-     _M_vector_cost(0), _M_valid(true) { }\n-\n-    __vector2list_info(__stack_t __stack)\n-    : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n-      _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true) { } \n-\n-    virtual ~__vector2list_info() { }\n-    __vector2list_info(const __vector2list_info& __o);\n-\n-    void __merge(const __vector2list_info& __o);\n-    void __write(FILE* __f) const;\n-    float __magnitude() const { return _M_vector_cost - _M_list_cost; }\n-    const char* __advice() const { return \"change std::vector to std::list\"; }\n-\n-    size_t __shift_count() { return _M_shift_count; }\n-    size_t __iterate()   { return _M_iterate; }\n-    float __list_cost() { return _M_list_cost; }\n-    size_t __resize() { return _M_resize; }\n-    void __set_list_cost(float __lc) { _M_list_cost = __lc; }\n-    void __set_vector_cost(float __vc) { _M_vector_cost = __vc; }\n-    bool __is_valid() { return _M_valid; }\n-    void __set_invalid() { _M_valid = false; }\n-\n-    void __opr_insert(size_t __pos, size_t __num);\n-    void __opr_iterate(size_t __num) { _M_iterate += __num; }\n-    void __resize(size_t __from, size_t __to);\n-\n-  private:\n-    size_t _M_shift_count;\n-    size_t _M_iterate;\n-    size_t _M_resize;\n-    float _M_list_cost;\n-    float _M_vector_cost;\n-    bool  _M_valid;\n-  };\n-\n-  inline __vector2list_info::__vector2list_info(const __vector2list_info& __o)\n-  : __object_info_base(__o)\n-  {\n-    _M_shift_count  = __o._M_shift_count;\n-    _M_iterate      = __o._M_iterate;\n-    _M_vector_cost  = __o._M_vector_cost;\n-    _M_list_cost    = __o._M_list_cost;\n-    _M_valid        = __o._M_valid;\n-    _M_resize       = __o._M_resize;\n-  }\n \n-  inline void \n-  __vector2list_info::__merge(const __vector2list_info& __o)\n-  {\n-    _M_shift_count  += __o._M_shift_count;\n-    _M_iterate      += __o._M_iterate;\n-    _M_vector_cost  += __o._M_vector_cost;\n-    _M_list_cost    += __o._M_list_cost;\n-    _M_valid        &= __o._M_valid;\n-    _M_resize       += __o._M_resize;\n-  }\n+/** @brief A vector-to-list instrumentation line in the object table.  */\n+class __vector2list_info: public __object_info_base\n+{\n+ public:\n+  __vector2list_info()\n+      :_M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n+       _M_vector_cost(0), _M_valid(true) {}\n+  __vector2list_info(__stack_t __stack)\n+      : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n+        _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true) {} \n+  virtual ~__vector2list_info() {}\n+  __vector2list_info(const __vector2list_info& __o);\n+  void __merge(const __vector2list_info& __o);\n+  void __write(FILE* __f) const;\n+  float __magnitude() const { return _M_vector_cost - _M_list_cost; }\n+  const char* __advice() const \n+  { return strdup(\"change std::vector to std::list\"); }\n+\n+  size_t __shift_count() { return _M_shift_count; }\n+  size_t __iterate()   { return _M_iterate; }\n+  float __list_cost() { return _M_list_cost; }\n+  size_t __resize() { return _M_resize; }\n+  void __set_list_cost(float __lc) { _M_list_cost = __lc; }\n+  void __set_vector_cost(float __vc) { _M_vector_cost = __vc; }\n+  bool __is_valid() { return _M_valid; }\n+  void __set_invalid() { _M_valid = false; }\n+\n+  void __opr_insert(size_t __pos, size_t __num);\n+  void __opr_iterate(size_t __num);\n+  void __resize(size_t __from, size_t __to);\n+  void __opr_find(size_t __size);\n+\n+private:\n+  size_t _M_shift_count;\n+  size_t _M_iterate;\n+  size_t _M_resize;\n+  float _M_list_cost;\n+  float _M_vector_cost;\n+  bool  _M_valid;\n+};\n+\n+inline __vector2list_info::__vector2list_info(const __vector2list_info& __o)\n+    : __object_info_base(__o)\n+{\n+  _M_shift_count  = __o._M_shift_count;\n+  _M_iterate      = __o._M_iterate;\n+  _M_vector_cost  = __o._M_vector_cost;\n+  _M_list_cost    = __o._M_list_cost;\n+  _M_valid        = __o._M_valid;\n+  _M_resize       = __o._M_resize;\n+}\n+\n+inline void __vector2list_info::__merge(const __vector2list_info& __o)\n+{\n+  _M_shift_count  += __o._M_shift_count;\n+  _M_iterate      += __o._M_iterate;\n+  _M_vector_cost  += __o._M_vector_cost;\n+  _M_list_cost    += __o._M_list_cost;\n+  _M_valid        &= __o._M_valid;\n+  _M_resize       += __o._M_resize;\n+}\n+\n+inline void __vector2list_info::__opr_insert(size_t __pos, size_t __num)\n+{\n+  _M_shift_count += __num - __pos;\n+}\n \n-  inline void \n-  __vector2list_info::__opr_insert(size_t __pos, size_t __num)\n-  { _M_shift_count += __num - __pos; }\n-\n-  inline void \n-  __vector2list_info::__resize(size_t __from, size_t __to)\n-  { _M_resize += __from; }\n-\n-  /** @brief A vector-to-list instrumentation line in the stack table.  */\n-  class __vector2list_stack_info: public __vector2list_info \n-  {\n-  public:\n-    __vector2list_stack_info(const __vector2list_info& __o) \n-    : __vector2list_info(__o) { }\n-  };\n-\n-  /** @brief Vector-to-list instrumentation producer.  */\n-  class __trace_vector_to_list\n-  : public __trace_base<__vector2list_info, __vector2list_stack_info> \n-  {\n-  public:\n-    __trace_vector_to_list();\n-    ~__trace_vector_to_list() { }\n-\n-    // Insert a new node at construct with object, callstack and initial size. \n-    void __insert(__object_t __obj, __stack_t __stack);\n-\n-    // Call at destruction/clean to set container final size.\n-    void __destruct(const void* __obj);\n-\n-    // Find the node in the live map.\n-    __vector2list_info* __find(const void* __obj);\n-\n-    // Collect cost of operations.\n-    void __opr_insert(const void* __obj, size_t __pos, size_t __num);\n-    void __opr_iterate(const void* __obj, size_t __num);\n-    void __invalid_operator(const void* __obj);\n-    void __resize(const void* __obj, size_t __from, size_t __to);\n-    float __vector_cost(size_t __shift, size_t __iterate, size_t __resize);\n-    float __list_cost(size_t __shift, size_t __iterate, size_t __resize);\n-  };\n-\n-  inline __trace_vector_to_list::__trace_vector_to_list()\n-  : __trace_base<__vector2list_info, __vector2list_stack_info>()\n-  { __id = \"vector-to-list\"; }\n-\n-  inline void \n-  __trace_vector_to_list::__insert(__object_t __obj, __stack_t __stack)\n-  { __add_object(__obj, __vector2list_info(__stack)); }\n-\n-  inline void \n-  __vector2list_info::__write(FILE* __f) const\n-  {\n-    fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\", _M_shift_count, _M_resize, \n-\t    _M_iterate, _M_vector_cost, _M_list_cost);\n-  }\n+inline void __vector2list_info::__resize(size_t __from, size_t __to)\n+{\n+  _M_resize += __from;\n+}\n \n-  // Cost model.  \n-  //  Vector operation cost:\n-  //   - Cost per shift: 1\n-  //   - Cost per access: 1\n-  //   - Cost per resize: 1\n-  //  List operation cost:\n-  //   - Cost per shift: 0\n-  //   - Cost per access: 10\n-  //   - Cost per resize: 0\n-  // XXX: get this from the cost model database instead.\n-  inline float \n-  __trace_vector_to_list::__vector_cost(size_t __shift, size_t __iterate,\n-\t\t\t\t\tsize_t __resize)\n-  { return __shift * 1 + __iterate * 1 + __resize * 1; }\n-\n-  inline float \n-  __trace_vector_to_list::__list_cost(size_t __shift, size_t __iterate,\n-\t\t\t\t      size_t __resize)\n-  { return __shift * 0 + __iterate * 10 + __resize * 0; }\n-\n-  inline void \n-  __trace_vector_to_list::__destruct(const void* __obj)\n-  {\n-    if (!__is_on())\n-      return;\n-\n-    __vector2list_info* __res = __get_object_info(__obj);\n-    if (!__res)\n-      return;\n-\n-    float __vc = __vector_cost(__res->__shift_count(), __res->__iterate(),\n-\t\t\t       __res->__resize());\n-    float __lc = __list_cost(__res->__shift_count(), __res->__iterate(),\n-\t\t\t     __res->__resize());\n-    __res->__set_vector_cost(__vc);\n-    __res->__set_list_cost(__lc);\n-\n-    __retire_object(__obj);\n-  }\n+inline void __vector2list_info::__opr_iterate(size_t __num)\n+{ \n+  _M_iterate += __num; \n+}\n \n-  inline void \n-  __trace_vector_to_list::__opr_insert(const void* __obj, size_t __pos, \n-\t\t\t\t       size_t __num)\n-  {\n-    __vector2list_info* __res = __get_object_info(__obj);\n-    if (__res)\n-      __res->__opr_insert(__pos, __num);\n-  }\n+inline void __vector2list_info::__opr_find(size_t __size)\n+{\n+  // Use average case complexity.\n+  _M_iterate += 3.0 / 4.0 * __size;\n+}\n+\n+/** @brief A vector-to-list instrumentation line in the stack table.  */\n+class __vector2list_stack_info: public __vector2list_info {\n+ public:\n+  __vector2list_stack_info(const __vector2list_info& __o) \n+      : __vector2list_info(__o) {}\n+};\n+\n+/** @brief Vector-to-list instrumentation producer.  */\n+class __trace_vector_to_list\n+    : public __trace_base<__vector2list_info, __vector2list_stack_info> \n+{\n+ public:\n+  __trace_vector_to_list();\n+  ~__trace_vector_to_list() {}\n+\n+  // Insert a new node at construct with object, callstack and initial size. \n+  void __insert(__object_t __obj, __stack_t __stack);\n+  // Call at destruction/clean to set container final size.\n+  void __destruct(const void* __obj);\n+\n+  // Find the node in the live map.\n+  __vector2list_info* __find(const void* __obj);\n+\n+  // Collect cost of operations.\n+  void __opr_insert(const void* __obj, size_t __pos, size_t __num);\n+  void __opr_iterate(const void* __obj, size_t __num);\n+  void __invalid_operator(const void* __obj);\n+  void __resize(const void* __obj, size_t __from, size_t __to);\n+  float __vector_cost(size_t __shift, size_t __iterate, size_t __resize);\n+  float __list_cost(size_t __shift, size_t __iterate, size_t __resize);\n+  void __opr_find(const void* __obj, size_t __size);\n+};\n+\n+inline __trace_vector_to_list::__trace_vector_to_list()\n+    : __trace_base<__vector2list_info, __vector2list_stack_info>()\n+{\n+  __id = \"vector-to-list\";\n+}\n \n-  inline void \n-  __trace_vector_to_list::__opr_iterate(const void* __obj, size_t __num)\n-  {\n-    __vector2list_info* __res = __get_object_info(__obj);\n-    if (__res)\n-      __res->__opr_iterate(__num);\n-  }\n+inline void __trace_vector_to_list::__insert(__object_t __obj,\n+                                             __stack_t __stack)\n+{\n+  __add_object(__obj, __vector2list_info(__stack));\n+}\n \n-  inline void \n-  __trace_vector_to_list::__invalid_operator(const void* __obj)\n-  {\n-    __vector2list_info* __res = __get_object_info(__obj);\n-    if (__res)\n-      __res->__set_invalid();\n-  }\n+inline void __vector2list_info::__write(FILE* __f) const\n+{\n+  fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\",\n+          _M_shift_count, _M_resize, _M_iterate, _M_vector_cost, _M_list_cost);\n+}\n \n-  inline void \n-  __trace_vector_to_list::__resize(const void* __obj, size_t __from, \n-\t\t\t\t   size_t __to)\n-  {\n-    __vector2list_info* __res = __get_object_info(__obj);\n-    if (__res)\n-      __res->__resize(__from, __to);\n-  }\n+inline float __trace_vector_to_list::__vector_cost(size_t __shift, \n+                                                   size_t __iterate,\n+                                                   size_t __resize)\n+{\n+  return (\n+      __shift * _GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor).__value\n+      + __iterate * _GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor).__value\n+      + __resize * _GLIBCXX_PROFILE_DATA(__vector_resize_cost_factor).__value\n+      );\n+}\n+\n+inline float __trace_vector_to_list::__list_cost(size_t __shift, \n+                                                 size_t __iterate,\n+                                                 size_t __resize)\n+{\n+  return (\n+      __shift * _GLIBCXX_PROFILE_DATA(__list_shift_cost_factor).__value\n+      + __iterate * _GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor).__value\n+      + __resize * _GLIBCXX_PROFILE_DATA(__list_resize_cost_factor).__value);\n+}\n \n+inline void __trace_vector_to_list::__destruct(const void* __obj)\n+{\n+  if (!__is_on())\n+    return;\n \n-  // Initialization and report.\n-  inline void \n-  __trace_vector_to_list_init()\n-  { __tables<0>::_S_vector_to_list = new __trace_vector_to_list(); }\n+ __vector2list_info* __res = __get_object_info(__obj);\n+  if (!__res)\n+    return;\n \n-  inline void \n-  __trace_vector_to_list_report(FILE* __f, __warning_vector_t& __warnings)\n-  {\n-    if (__tables<0>::_S_vector_to_list) \n-      {\n-\t__tables<0>::_S_vector_to_list->__collect_warnings(__warnings);\n-\t__tables<0>::_S_vector_to_list->__write(__f);\n-      }\n-  }\n+  float __vc = __vector_cost(__res->__shift_count(), __res->__iterate(),\n+                             __res->__resize());\n+  float __lc = __list_cost(__res->__shift_count(), __res->__iterate(),\n+                           __res->__resize());\n+  __res->__set_vector_cost(__vc);\n+  __res->__set_list_cost(__lc);\n \n-  // Implementations of instrumentation hooks.\n-  inline void \n-  __trace_vector_to_list_construct(const void* __obj)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_to_list->__insert(__obj, __get_stack());\n-  }\n+  __retire_object(__obj);\n+}\n \n-  inline void \n-  __trace_vector_to_list_destruct(const void* __obj)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_to_list->__destruct(__obj);\n-  }\n+inline void __trace_vector_to_list::__opr_insert(const void* __obj, \n+                                                 size_t __pos, size_t __num)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__opr_insert(__pos, __num);\n+}\n \n-  inline void \n-  __trace_vector_to_list_insert(const void* __obj, size_t __pos, size_t __num)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_to_list->__opr_insert(__obj, __pos, __num);\n-  }\n+inline void __trace_vector_to_list::__opr_iterate(const void* __obj,\n+                                                  size_t __num)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__opr_iterate(__num);\n+}\n \n-  inline void \n-  __trace_vector_to_list_iterate(const void* __obj, size_t __num)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_to_list->__opr_iterate(__obj, __num);\n-  }\n+inline void __trace_vector_to_list::__invalid_operator(const void* __obj)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__set_invalid();\n+}\n \n-  inline void \n-  __trace_vector_to_list_invalid_operator(const void* __obj)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_to_list->__invalid_operator(__obj);\n-  }\n+inline void __trace_vector_to_list::__resize(const void* __obj, size_t __from, \n+                                             size_t __to)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__resize(__from, __to);\n+}\n+\n+inline void __trace_vector_to_list::__opr_find(const void* __obj,\n+                                               size_t __size)\n+{\n+  __vector2list_info* __res = __get_object_info(__obj);\n+  if (__res)\n+    __res->__opr_find(__size);\n+}\n+\n+inline void __trace_vector_to_list_init()\n+{\n+  _GLIBCXX_PROFILE_DATA(_S_vector_to_list) = new __trace_vector_to_list();\n+}\n \n-  inline void \n-  __trace_vector_to_list_resize(const void* __obj, size_t __from, size_t __to)\n-  {\n-    if (!__profcxx_init()) return;\n-    __tables<0>::_S_vector_to_list->__resize(__obj, __from, __to);\n+inline void __trace_vector_to_list_report(FILE* __f, \n+                                          __warning_vector_t& __warnings)\n+{\n+  if (_GLIBCXX_PROFILE_DATA(_S_vector_to_list)) {\n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__collect_warnings(__warnings);\n+    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__write(__f);\n   }\n+}\n+\n+inline void __trace_vector_to_list_construct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__insert(__obj, __get_stack());\n+}\n+\n+inline void __trace_vector_to_list_destruct(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__destruct(__obj);\n+}\n+\n+inline void __trace_vector_to_list_insert(const void* __obj, \n+                                          size_t __pos, size_t __num)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_insert(__obj, __pos, __num);\n+}\n+\n+\n+inline void __trace_vector_to_list_iterate(const void* __obj, size_t __num = 1)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_iterate(__obj, __num);\n+}\n+\n+inline void __trace_vector_to_list_invalid_operator(const void* __obj)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__invalid_operator(__obj);\n+}\n+\n+inline void __trace_vector_to_list_resize(const void* __obj, \n+                                          size_t __from, size_t __to)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__resize(__obj, __from, __to);\n+}\n+\n+inline void __trace_vector_to_list_find(const void* __obj, size_t __size)\n+{\n+  if (!__profcxx_init()) return;\n+\n+  _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__opr_find(__obj, __size);\n+}\n+\n } // namespace __gnu_profile\n #endif /* _GLIBCXX_PROFILE_PROFILER_VECTOR_TO_LIST_H */"}, {"sha": "8e077481f343669c6fc36f6b40160ba7d7046e7d", "filename": "libstdc++-v3/include/profile/iterator_tracker.h", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fiterator_tracker.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fiterator_tracker.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fiterator_tracker.h?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -0,0 +1,273 @@\n+#ifndef _GLIBCXX_PROFILE_ITERATOR_TRACKER\n+#define _GLIBCXX_PROFILE_ITERATOR_TRACKER 1\n+\n+#include <ext/type_traits.h>\n+\n+namespace std\n+{\n+namespace __profile\n+{\n+\n+template<typename _Iterator, typename _Sequence>\n+class __iterator_tracker \n+{\n+  typedef __iterator_tracker _Self;\n+  // The underlying iterator\n+  _Iterator _M_current;\n+  // The underlying data structure\n+  const _Sequence* _M_ds;\n+  typedef std::iterator_traits<_Iterator> _Traits;\n+\n+ public:\n+  typedef _Iterator\t\t              _Base_iterator;\n+  typedef typename _Traits::iterator_category iterator_category; \n+  typedef typename _Traits::value_type        value_type;\n+  typedef typename _Traits::difference_type   difference_type;\n+  typedef typename _Traits::reference         reference;\n+  typedef typename _Traits::pointer           pointer;\n+\n+  __iterator_tracker() : _M_current(), _M_ds(0) { }\n+  __iterator_tracker(const _Iterator& __i, const _Sequence* seq) \n+      : _M_current(__i), _M_ds(seq) { }\n+  __iterator_tracker(const __iterator_tracker& __x) \n+      : _M_current(__x._M_current), _M_ds(__x._M_ds) { }\n+  template<typename _MutableIterator>\n+  __iterator_tracker(const __iterator_tracker<_MutableIterator, typename __gnu_cxx::__enable_if<(std::__are_same<_MutableIterator, typename _Sequence::iterator::_Base_iterator>::__value), _Sequence>::__type>& __x)\n+      :  _M_current(__x.base()), _M_ds(__x._M_get_sequence()) { }\n+\n+  _Iterator\n+  base() const { return _M_current; }\n+  /**\n+   * @brief Conversion to underlying non-debug iterator to allow\n+   * better interaction with non-profile containers.\n+   */\n+  operator _Iterator() const { return _M_current; }\n+\n+  pointer\n+  operator->() const { return &*_M_current; }\n+\n+  __iterator_tracker&\n+  operator++()\n+  {\n+    _M_ds->_M_profile_iterate();\n+    ++_M_current;\n+    return *this;\n+  }\n+\n+  __iterator_tracker&\n+  operator++(int)\n+  {\n+    _M_ds->_M_profile_iterate();\n+    __iterator_tracker __tmp(*this);\n+    ++_M_current;\n+    return __tmp;\n+  }\n+\n+  __iterator_tracker&\n+  operator--()\n+  {\n+    _M_ds->_M_profile_iterate(1);\n+    --_M_current;\n+    return *this;\n+  }\n+\n+  __iterator_tracker&\n+  operator--(int)\n+  {\n+    _M_ds->_M_profile_iterate(1);\n+    __iterator_tracker __tmp(*this);\n+    --_M_current;\n+    return __tmp;\n+  }\n+\n+  __iterator_tracker&\n+  operator=(const __iterator_tracker& __x)\n+  {\n+    _M_current = __x._M_current;\n+    return *this;\n+  }\n+\n+  reference\n+  operator*() const\n+  {\n+    return *_M_current;\n+  }\n+\n+ // ------ Random access iterator requirements ------\n+  reference\n+  operator[](const difference_type& __n) const \n+  {\n+    return _M_current[__n];\n+  }\n+\n+  __iterator_tracker&\n+  operator+=(const difference_type& __n)\n+  {\n+    _M_current += __n;\n+    return *this;\n+  }\n+\n+  __iterator_tracker\n+  operator+(const difference_type& __n) const\n+  {\n+    __iterator_tracker __tmp(*this);\n+    __tmp += __n;\n+    return __tmp;\n+  }\n+\n+  __iterator_tracker&\n+  operator-=(const difference_type& __n)\n+  {\n+    _M_current += -__n;\n+    return *this;\n+  }\n+\n+  __iterator_tracker\n+  operator-(const difference_type& __n) const\n+  {\n+    __iterator_tracker __tmp(*this);\n+    __tmp -= __n;\n+    return __tmp;\n+  }\n+\n+  void\n+  _M_find()\n+  {\n+    _M_ds->_M_profile_find();\n+  }\n+\n+  const _Sequence*\n+  _M_get_sequence() const\n+  {\n+    return static_cast<const _Sequence*>(_M_ds);\n+  }\n+};\n+\n+template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+inline bool\n+operator==(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,\n+           const __iterator_tracker<_IteratorR, _Sequence>& __rhs)\n+{\n+  return __lhs.base() == __rhs.base();\n+}\n+\n+template<typename _Iterator, typename _Sequence>\n+inline bool\n+operator==(const __iterator_tracker<_Iterator, _Sequence>& __lhs,\n+           const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n+{\n+  return __lhs.base() == __rhs.base();\n+}\n+\n+template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+inline bool\n+operator!=(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,\n+           const __iterator_tracker<_IteratorR, _Sequence>& __rhs)\n+{\n+  return __lhs.base() != __rhs.base();\n+}\n+\n+template<typename _Iterator, typename _Sequence>\n+inline bool\n+operator!=(const __iterator_tracker<_Iterator, _Sequence>& __lhs,\n+               const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n+{\n+  return __lhs.base() != __rhs.base();\n+}\n+\n+template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+inline bool\n+operator<(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,\n+          const __iterator_tracker<_IteratorR, _Sequence>& __rhs)\n+{\n+  return __lhs.base() < __rhs.base();\n+}\n+\n+template<typename _Iterator, typename _Sequence>\n+inline bool\n+operator<(const __iterator_tracker<_Iterator, _Sequence>& __lhs,\n+          const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n+{\n+  return __lhs.base() < __rhs.base();\n+}\n+\n+template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+inline bool\n+operator<=(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,\n+           const __iterator_tracker<_IteratorR, _Sequence>& __rhs)\n+{\n+  return __lhs.base() <= __rhs.base();\n+}\n+\n+template<typename _Iterator, typename _Sequence>\n+inline bool\n+operator<=(const __iterator_tracker<_Iterator, _Sequence>& __lhs,\n+           const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n+{\n+  return __lhs.base() <= __rhs.base();\n+}\n+\n+template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+inline bool\n+operator>(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,\n+          const __iterator_tracker<_IteratorR, _Sequence>& __rhs)\n+{\n+  return __lhs.base() > __rhs.base();\n+}\n+\n+template<typename _Iterator, typename _Sequence>\n+inline bool\n+operator>(const __iterator_tracker<_Iterator, _Sequence>& __lhs,\n+          const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n+{\n+  return __lhs.base() > __rhs.base();\n+}\n+\n+template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+inline bool\n+operator>=(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,\n+           const __iterator_tracker<_IteratorR, _Sequence>& __rhs)\n+{\n+  return __lhs.base() >= __rhs.base();\n+}\n+\n+template<typename _Iterator, typename _Sequence>\n+inline bool\n+operator>=(const __iterator_tracker<_Iterator, _Sequence>& __lhs,\n+           const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n+{\n+  return __lhs.base() >= __rhs.base();\n+}\n+\n+// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+// According to the resolution of DR179 not only the various comparison\n+// operators but also operator- must accept mixed iterator/const_iterator\n+// parameters.\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+  inline typename __iterator_tracker<_IteratorL, _Sequence>::difference_type\n+  operator-(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,\n+            const __iterator_tracker<_IteratorR, _Sequence>& __rhs)\n+{\n+  return __lhs.base() - __rhs.base();\n+}\n+\n+template<typename _Iterator, typename _Sequence>\n+inline typename __iterator_tracker<_Iterator, _Sequence>::difference_type\n+operator-(const __iterator_tracker<_Iterator, _Sequence>& __lhs,\n+          const __iterator_tracker<_Iterator, _Sequence>& __rhs)\n+{\n+  return __lhs.base() - __rhs.base();\n+}\n+\n+template<typename _Iterator, typename _Sequence>\n+inline __iterator_tracker<_Iterator, _Sequence>\n+operator+(typename __iterator_tracker<_Iterator,_Sequence>::difference_type\n+          __n,\n+          const __iterator_tracker<_Iterator, _Sequence>& __i)\n+{\n+  return __i + __n;\n+}\n+\t\t\n+}  // namespace __profile\n+}  // namespace std\n+#endif"}, {"sha": "01edd2919f67a9bdb6abb1c8b78e7b90982f8f95", "filename": "libstdc++-v3/include/profile/list", "status": "modified", "additions": 147, "deletions": 52, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -30,13 +30,15 @@\n #define _GLIBCXX_PROFILE_LIST 1\n \n #include <list>\n+#include <profile/base.h> \n+#include <profile/iterator_tracker.h> \n \n namespace std\n {\n namespace __profile\n {\n-  /// Class std::list wrapper with performance instrumentation.\n-  template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n+  /** @brief List wrapper with performance instrumentation.  */\n+template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n     class list\n     : public _GLIBCXX_STD_D::list<_Tp, _Allocator>\n     {\n@@ -46,8 +48,10 @@ namespace __profile\n       typedef typename _Base::reference             reference;\n       typedef typename _Base::const_reference       const_reference;\n \n-      typedef typename _Base::iterator              iterator;\n-      typedef typename _Base::const_iterator        const_iterator;\n+      typedef __iterator_tracker<typename _Base::iterator, list>        \n+\t\t\t\t                    iterator;\n+      typedef __iterator_tracker<typename _Base::const_iterator, list>  \n+                                                    const_iterator;\n \n       typedef typename _Base::size_type             size_type;\n       typedef typename _Base::difference_type       difference_type;\n@@ -61,35 +65,60 @@ namespace __profile\n \n       // 23.2.2.1 construct/copy/destroy:\n       explicit list(const _Allocator& __a = _Allocator())\n-      : _Base(__a) { }\n+      : _Base(__a) \n+      { \n+        __profcxx_list_construct(this); \t// list2slist\n+        __profcxx_list_construct2(this); \t// list2vector\n+      }\n \n       explicit list(size_type __n, const _Tp& __value = _Tp(),\n \t\t    const _Allocator& __a = _Allocator())\n-      : _Base(__n, __value, __a) { }\n+      : _Base(__n, __value, __a) \n+      { \n+        __profcxx_list_construct(this); \n+        __profcxx_list_construct2(this); \n+      }\n \n       template<class _InputIterator>\n       list(_InputIterator __first, _InputIterator __last,\n \t   const _Allocator& __a = _Allocator())\n       : _Base(__first, __last, __a)\n-      { }\n+      {\t \n+        __profcxx_list_construct(this); \n+        __profcxx_list_construct2(this); \n+      }\n \n       list(const list& __x)\n-      : _Base(__x) { }\n+      : _Base(__x) \n+      { \n+        __profcxx_list_construct(this); \n+        __profcxx_list_construct2(this); \n+      }\n \n       list(const _Base& __x)\n-      : _Base(__x) { }\n+      : _Base(__x) \n+      { \t\n+        __profcxx_list_construct(this); \n+        __profcxx_list_construct2(this); \n+      }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       list(list&& __x)\n       : _Base(std::forward<list>(__x))\n-      { }\n+      { \n+        __profcxx_list_construct(this); \n+        __profcxx_list_construct2(this); \n+      }\n \n       list(initializer_list<value_type> __l,\n            const allocator_type& __a = allocator_type())\n         : _Base(__l, __a) { }\n #endif\n \n-      ~list() { }\n+      ~list() { \n+        __profcxx_list_destruct(this); \n+        __profcxx_list_destruct2(this); \n+      }\n \n       list&\n       operator=(const list& __x)\n@@ -118,7 +147,7 @@ namespace __profile\n \n       void\n       assign(initializer_list<value_type> __l)\n-      { _Base::assign(__l); }\n+      {\t_Base::assign(__l); }\n #endif\n \n       template<class _InputIterator>\n@@ -128,34 +157,46 @@ namespace __profile\n \n       void\n       assign(size_type __n, const _Tp& __t)\n-      { _Base::assign(__n, __t); }\n+      {\t_Base::assign(__n, __t); }\n \n       using _Base::get_allocator;\n \n       // iterators:\n       iterator\n       begin()\n-      { return iterator(_Base::begin()); }\n+      { return iterator(_Base::begin(), this); }\n \n       const_iterator\n       begin() const\n-      { return const_iterator(_Base::begin()); }\n+      { return const_iterator(_Base::begin(), this); }\n \n       iterator\n       end()\n-      { return iterator(_Base::end()); }\n+      {\n+        __profcxx_list_rewind(this);\n+        return iterator(_Base::end(), this);\n+      }\n \n       const_iterator\n       end() const\n-      { return const_iterator(_Base::end()); }\n+      {\n+        __profcxx_list_rewind(this);\n+        return const_iterator(_Base::end(), this);\n+      }\n \n       reverse_iterator\n       rbegin()\n-      { return reverse_iterator(end()); }\n+      {\n+        __profcxx_list_rewind(this);\n+        return reverse_iterator(end());\n+      }\n \n       const_reverse_iterator\n       rbegin() const\n-      { return const_reverse_iterator(end()); }\n+      { \n+        __profcxx_list_rewind(this);\n+        return const_reverse_iterator(end());\n+      }\n \n       reverse_iterator\n       rend()\n@@ -168,11 +209,11 @@ namespace __profile\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       const_iterator\n       cbegin() const\n-      { return const_iterator(_Base::begin()); }\n+      { return const_iterator(_Base::begin(), this); }\n \n       const_iterator\n       cend() const\n-      { return const_iterator(_Base::end()); }\n+      { return const_iterator(_Base::end(), this); }\n \n       const_reverse_iterator\n       crbegin() const\n@@ -203,14 +244,26 @@ namespace __profile\n \n       reference\n       back()\n-      { return _Base::back(); }\n+      {\n+        __profcxx_list_rewind(this);\n+\treturn _Base::back();\n+      }\n \n       const_reference\n       back() const\n-      { return _Base::back(); }\n+      {\n+        __profcxx_list_rewind(this);\n+\treturn _Base::back();\n+      }\n \n       // 23.2.2.3 modifiers:\n-      using _Base::push_front;\n+      void\n+      push_front(const value_type& __x)\n+      {\n+        __profcxx_list_invalid_operator(this);\n+        __profcxx_list_operation(this);\n+        _Base::push_front(__x);\n+      }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       using _Base::emplace_front;\n@@ -219,7 +272,7 @@ namespace __profile\n       void\n       pop_front()\n       {\n-\titerator __victim = begin();\n+        __profcxx_list_operation(this);\n \t_Base::pop_front();\n       }\n \n@@ -235,61 +288,78 @@ namespace __profile\n \titerator __victim = end();\n \t--__victim;\n \t_Base::pop_back();\n+        __profcxx_list_rewind(this);\n       }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       template<typename... _Args>\n         iterator\n         emplace(iterator __position, _Args&&... __args)\n \t{\n-\t  return iterator(_Base::emplace(__position,\n-\t\t\t\t\tstd::forward<_Args>(__args)...));\n+\t  return iterator(_Base::emplace(__position.base(),\n+                                         std::forward<_Args>(__args)...));\n \t}\n #endif\n \n       iterator\n       insert(iterator __position, const _Tp& __x)\n-      { return iterator(_Base::insert(__position, __x)); }\n+      {\n+        _M_profile_insert(this, __position, size());\n+        return iterator(_Base::insert(__position.base(), __x), this);\n+      }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       iterator\n       insert(iterator __position, _Tp&& __x)\n-      { return emplace(__position, std::move(__x)); }\n+      { \n+        _M_profile_insert(this, __position, size());\n+        return iterator(_Base::emplace(__position.base(), std::move(__x)),\n+                        this); \n+      }\n \n       void\n-      insert(iterator __p, initializer_list<value_type> __l)\n-      { _Base::insert(__p, __l); }\n+      insert(iterator __position, initializer_list<value_type> __l)\n+      {\n+        _M_profile_insert(this, __position, size());\n+        _Base::insert(__position.base(), __l);\n+      }\n #endif\n \n       void\n       insert(iterator __position, size_type __n, const _Tp& __x)\n-      { _Base::insert(__position, __n, __x); }\n+      {\n+        _M_profile_insert(this, __position, size());\n+\t_Base::insert(__position.base(), __n, __x);\n+      }\n \n       template<class _InputIterator>\n         void\n         insert(iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n-        { _Base::insert(__position, __first, __last); }\n+      {\n+        _M_profile_insert(this, __position, size());\n+        _Base::insert(__position.base(), __first, __last);\n+      }\n \n       iterator\n       erase(iterator __position)\n-      { return iterator(_Base::erase(__position)); }\n+      {\treturn iterator(_Base::erase(__position.base()), this); }\n \n       iterator\n       erase(iterator __position, iterator __last)\n       {\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 151. can't currently clear() empty container\n-\treturn iterator(_Base::erase(__position, __last));\n+\treturn iterator(_Base::erase(__position.base(), __last.base()), this);\n       }\n \n       void\n       swap(list& __x)\n-      { _Base::swap(__x); }\n+      {\t_Base::swap(__x); }\n \n       void\n       clear()\n-      { _Base::clear(); }\n+      {\t_Base::clear(); }\n \n       // 23.2.2.4 list operations:\n       void\n@@ -306,6 +376,12 @@ namespace __profile\n       { this->splice(__position, std::move(__x)); }\n #endif\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      void\n+      splice(iterator __position, list& __x, iterator __i)\n+      { this->splice(__position, std::move(__x), __i); }\n+#endif\n+\n       void\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       splice(iterator __position, list&& __x, iterator __i)\n@@ -317,16 +393,10 @@ namespace __profile\n \t// after implementing the relevant bits of N1599.\n \n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t_Base::splice(__position, _GLIBCXX_MOVE(__x._M_base()),\n-\t\t      __i);\n+\t_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),\n+\t\t      __i.base());\n       }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      void\n-      splice(iterator __position, list& __x, iterator __i)\n-      { this->splice(__position, std::move(__x), __i); }\n-#endif\n-\n       void\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       splice(iterator __position, list&& __x, iterator __first,\n@@ -339,8 +409,8 @@ namespace __profile\n \t// We used to perform the splice_alloc check:  not anymore, redundant\n \t// after implementing the relevant bits of N1599.\n \n-\t_Base::splice(__position, _GLIBCXX_MOVE(__x._M_base()),\n-\t\t      __first, __last);\n+\t_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),\n+\t\t      __first.base(), __last.base());\n       }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n@@ -352,7 +422,7 @@ namespace __profile\n       void\n       remove(const _Tp& __value)\n       {\n-\tfor (iterator __x = begin(); __x != _Base::end(); )\n+\tfor (iterator __x = begin(); __x != end(); )\n \t  {\n \t    if (*__x == __value)\n \t      __x = erase(__x);\n@@ -365,8 +435,9 @@ namespace __profile\n         void\n         remove_if(_Predicate __pred)\n         {\n-\t  for (iterator __x = begin(); __x != _Base::end(); )\n+\t  for (iterator __x = begin(); __x != end(); )\n \t    {\n+              __profcxx_list_operation(this);\n \t      if (__pred(*__x))\n \t\t__x = erase(__x);\n \t      else\n@@ -384,6 +455,7 @@ namespace __profile\n \titerator __next = __first;\n \twhile (++__next != __last)\n \t  {\n+            __profcxx_list_operation(this);\n \t    if (*__first == *__next)\n \t      erase(__next);\n \t    else\n@@ -403,6 +475,7 @@ namespace __profile\n \t  iterator __next = __first;\n \t  while (++__next != __last)\n \t    {\n+              __profcxx_list_operation(this);\n \t      if (__binary_pred(*__first, *__next))\n \t\terase(__next);\n \t      else\n@@ -421,15 +494,15 @@ namespace __profile\n \t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t// 300. list::merge() specification incomplete\n \tif (this != &__x)\n-\t  _Base::merge(_GLIBCXX_MOVE(__x._M_base()));\n+\t  { _Base::merge(_GLIBCXX_MOVE(__x._M_base())); }\n       }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       void\n       merge(list& __x)\n       { this->merge(std::move(__x)); }\n #endif\n- \n+\n       template<class _Compare>\n         void\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n@@ -441,7 +514,7 @@ namespace __profile\n \t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t  // 300. list::merge() specification incomplete\n \t  if (this != &__x)\n-\t    _Base::merge(_GLIBCXX_MOVE(__x._M_base()), __comp);\n+\t    { _Base::merge(_GLIBCXX_MOVE(__x._M_base()), __comp); }\n \t}\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n@@ -466,6 +539,28 @@ namespace __profile\n       const _Base&\n       _M_base() const { return *this; }\n \n+      inline void _M_profile_find() const \n+      { }\n+\n+      inline void _M_profile_iterate(int __rewind = 0) const \n+      {\n+        __profcxx_list_operation(this);\n+        __profcxx_list_iterate(this); \n+        if (__rewind)\n+          __profcxx_list_rewind(this);\n+      }\n+\n+    private:\n+      size_type _M_profile_insert(void* obj, iterator __pos, size_type __size)\n+      {\n+        size_type __shift = 0;\n+        typename _Base::iterator __it = __pos.base();\n+        for ( ; __it!=_Base::end(); __it++)\n+          __shift++;\n+        __profcxx_list_rewind(this);\n+        __profcxx_list_operation(this);\n+        __profcxx_list_insert(this, __shift, __size);\n+      }\n     };\n \n   template<typename _Tp, typename _Alloc>"}, {"sha": "ba4d5e70cd5a4aa8afb6b49005911732bfdf7063", "filename": "libstdc++-v3/include/profile/vector", "status": "modified", "additions": 116, "deletions": 23, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fvector?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -37,12 +37,12 @@\n #include <vector>\n #include <utility>\n #include <profile/base.h>\n+#include <profile/iterator_tracker.h>\n \n namespace std\n {\n namespace __profile\n {\n-  /// Class std::vector wrapper with performance instrumentation.\n   template<typename _Tp,\n \t   typename _Allocator = std::allocator<_Tp> >\n     class vector\n@@ -54,17 +54,21 @@ namespace __profile\n       typedef typename _Base::reference             reference;\n       typedef typename _Base::const_reference       const_reference;\n \n-      typedef typename _Base::iterator iterator;\n-      typedef typename _Base::const_iterator const_iterator;\n+      typedef __iterator_tracker<typename _Base::iterator, vector>\n+                                                    iterator;\n+      typedef __iterator_tracker<typename _Base::const_iterator, vector>\n+\t\t\t\t                    const_iterator;\n \n       typedef typename _Base::size_type             size_type;\n       typedef typename _Base::difference_type       difference_type;\n \n-      typedef _Tp\t\t\t\t                    value_type;\n-      typedef _Allocator\t\t\t                allocator_type;\n+      typedef _Tp\t\t\t\t    value_type;\n+      typedef _Allocator\t\t\t    allocator_type;\n       typedef typename _Base::pointer               pointer;\n       typedef typename _Base::const_pointer         const_pointer;\n-\n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      \n       _Base&\n       _M_base()       { return *this; }\n \n@@ -158,6 +162,58 @@ namespace __profile\n       using _Base::assign;\n       using _Base::get_allocator;\n \n+\n+      // iterators:\n+      iterator\n+      begin()\n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      begin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator\n+      end()\n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator\n+      end() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      reverse_iterator\n+      rbegin()\n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator\n+      rend()\n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      const_iterator\n+      cbegin() const\n+      { return const_iterator(_Base::begin(), this); }\n+\n+      const_iterator\n+      cend() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      const_reverse_iterator\n+      crbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      const_reverse_iterator\n+      crend() const\n+      { return const_reverse_iterator(begin()); }\n+#endif\n+\n       // 23.2.4.2 capacity:\n       using _Base::size;\n       using _Base::max_size;\n@@ -243,43 +299,52 @@ namespace __profile\n       iterator\n       insert(iterator __position, const _Tp& __x)\n       {\n-        __profcxx_vector_insert(this,  __position-_Base::begin(), this->size());\n+        __profcxx_vector_insert(this, __position.base() - _Base::begin(),\n+                                this->size());\n         size_type __old_size = this->capacity();\n-\ttypename _Base::iterator __res = _Base::insert(__position,__x);\n+\ttypename _Base::iterator __res = _Base::insert(__position.base(), __x);\n         _M_profile_resize(this, __old_size, this->capacity());\n-\treturn __res;\n+\treturn iterator(__res, this);\n       }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n       iterator\n       insert(iterator __position, _Tp&& __x)\n       {\n-        __profcxx_vector_insert(this,  __position-_Base::begin(), this->size());\n+        __profcxx_vector_insert(this, __position.base() - _Base::begin(),\n+                                this->size());\n         size_type __old_size = this->capacity();\n-\ttypename _Base::iterator __res = _Base::insert(__position,__x);\n+\ttypename _Base::iterator __res = _Base::insert(__position.base(), __x);\n         _M_profile_resize(this, __old_size, this->capacity());\n-\treturn __res;\n+\treturn iterator(__res, this);\n       }\n \n       void\n       insert(iterator __position, initializer_list<value_type> __l)\n       { this->insert(__position, __l.begin(), __l.end()); }\n #endif\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n       void\n+      swap(vector&& __x)\n+      {\n+        _Base::swap(__x);\n+      }\n+#endif\n \n+      void\n       swap(vector& __x)\n       {\n         _Base::swap(__x);\n       }\n \n-\n       void\n       insert(iterator __position, size_type __n, const _Tp& __x)\n       {\n-        __profcxx_vector_insert(this,  __position-_Base::begin(), this->size());\n+        __profcxx_vector_insert(this, __position.base() - _Base::begin(),\n+                                this->size());\n         size_type __old_size = this->capacity();\n-\t    _Base::insert(__position, __n, __x);\n+        _Base::insert(__position, __n, __x);\n         _M_profile_resize(this, __old_size, this->capacity());\n       }\n \n@@ -288,12 +353,31 @@ namespace __profile\n       insert(iterator __position,\n              _InputIterator __first, _InputIterator __last)\n       {\n-        __profcxx_vector_insert(this,  __position-_Base::begin(), this->size());\n+        __profcxx_vector_insert(this, __position.base()-_Base::begin(),\n+                                this->size());\n         size_type __old_size = this->capacity();\n         _Base::insert(__position, __first, __last);\n         _M_profile_resize(this, __old_size, this->capacity());\n       }\n \n+\n+      iterator\n+      erase(iterator __position)\n+      {\n+\ttypename _Base::iterator __res = _Base::erase(__position.base());\n+\treturn iterator(__res, this);\n+      }\n+\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\ttypename _Base::iterator __res = _Base::erase(__first.base(),\n+                                                      __last.base());\n+\treturn iterator(__res, this);\n+      }\n+\n       void\n       clear()\n       {\n@@ -302,17 +386,14 @@ namespace __profile\n         _Base::clear();\n       }\n \n-      // iterators:\n-      iterator\n-      begin()\n+      inline void _M_profile_find() const \n       { \n-        return _Base::begin(); \n+        __profcxx_vector_find(this, size()); \n       }\n \n-      const_iterator\n-      begin() const\n+      inline void _M_profile_iterate(int __rewind = 0) const \n       { \n-        return _Base::begin(); \n+        __profcxx_vector_iterate(this); \n       }\n \n     private:\n@@ -367,6 +448,18 @@ namespace __profile\n     swap(vector<_Tp, _Alloc>& __lhs, vector<_Tp, _Alloc>& __rhs)\n     { __lhs.swap(__rhs); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(vector<_Tp, _Alloc>&& __lhs, vector<_Tp, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(vector<_Tp, _Alloc>& __lhs, vector<_Tp, _Alloc>&& __rhs)\n+    { __lhs.swap(__rhs); }\n+#endif\n+\n } // namespace __profile\n   using _GLIBCXX_STD_D::_S_word_bit;\n } // namespace std"}, {"sha": "5dc58a667ede9897cb8b22e343aa9797b2f73259", "filename": "libstdc++-v3/testsuite/ext/throw_allocator/deallocate_global.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fthrow_allocator%2Fdeallocate_global.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fthrow_allocator%2Fdeallocate_global.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fthrow_allocator%2Fdeallocate_global.cc?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -28,7 +28,9 @@ typedef std::char_traits<char_t> traits_t;\n typedef __gnu_cxx::throw_allocator_random<char_t> allocator_t;\n typedef std::basic_string<char_t, traits_t, allocator_t> string_t;  \n \n+#ifndef _GLIBCXX_PROFILE\n string_t s(\"bayou bend\");\n+#endif\n \n int main()\n {"}, {"sha": "0b22a76aa157ba243b17ee2d23268d2a4fdb6baf", "filename": "libstdc++-v3/testsuite/ext/throw_allocator/deallocate_local.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fthrow_allocator%2Fdeallocate_local.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1360f5702b28237af3c00a517492a8faf78f494/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fthrow_allocator%2Fdeallocate_local.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fthrow_allocator%2Fdeallocate_local.cc?ref=a1360f5702b28237af3c00a517492a8faf78f494", "patch": "@@ -29,12 +29,15 @@ typedef std::basic_string<char_t, traits_t, allocator_t> string_t;\n \n int main()\n {\n+#ifndef _GLIBCXX_PROFILE\n   {\n     string_t s;\n     s += \"bayou bend\";\n   }\n+#endif\n \n   if (__gnu_test::counter::count() != 0)\n     throw std::runtime_error(\"count not zero\");\n+\n   return 0;\n }"}]}