{"sha": "28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhmNGVjMDFlOThmMmM1Y2M1MTY1Mzc1ODAyOWNhMWEzZmU4ZDU2ZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-07-22T11:04:58Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-07-22T11:04:58Z"}, "message": "Break out builtin function expansion from expr.c\n\nFrom-SVN: r28217", "tree": {"sha": "a844d63f6072a3417f000ed9414059a8906e15ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a844d63f6072a3417f000ed9414059a8906e15ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/comments", "author": null, "committer": null, "parents": [{"sha": "89d68df8d6f01ad5836d385d87c82f2528f729a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89d68df8d6f01ad5836d385d87c82f2528f729a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89d68df8d6f01ad5836d385d87c82f2528f729a3"}], "stats": {"total": 4191, "additions": 2239, "deletions": 1952}, "files": [{"sha": "81580cb47bee81d4a6c1e025b3346a6c7ecefef1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "patch": "@@ -1,3 +1,18 @@\n+Thu Jul 22 11:25:20 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* builtins.c: New file.\n+\t* expr.c (saveregs_value, apply_args_value):  Delete definition,\n+\tmoved into builtins.c.\n+\t(string_constant): No longer static.\n+\t(get_pointer_alignment, c_strlen, get_memory_rtx, expand_builtin,\n+\tapply_args_size, apply_result_size, result_vector,\n+\texpand_builtin_apply_args, expand_builtin_apply,\n+\texpand_builtin_return): Delete functions, moved into builtins.c.\n+\t(INCOMING_REGNO, OUTGOING_REGNO): Delete unused macros.\n+\t* expr.h (saveregs_value, apply_args_value): Declare variables.\n+\t(expand_builtin, string_constant): Declare functions.\n+\t* Makefile.in: Update to build builtin.o.\n+\n Wed Jul 21 12:37:34 IDT 1999 Vladik Goytin (goytin@yahoo.com)\n \n \t* config/arm/aout.h (ASM_OUTPUT_SECTION_NAME): New macro: Support"}, {"sha": "141e4728a15b864b0419227eb35d5c566a7fa3ea", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "patch": "@@ -673,8 +673,8 @@ SCHED_CFLAGS = @sched_cflags@\n \n # Language-independent object files.\n OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n- function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o \\\n- intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o real.o \\\n+ function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o real.o \\\n+ builtins.o intl.o varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o genrtl.o \\\n  dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o gcse.o \\\n  integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o varray.o \\\n  regclass.o regmove.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n@@ -1484,6 +1484,10 @@ except.o : except.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n expr.o : expr.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h function.h \\\n    $(REGS_H) insn-flags.h insn-codes.h $(EXPR_H) insn-config.h $(RECOG_H) \\\n    output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h except.h\n+builtins.o : builtins.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n+   function.h $(REGS_H) insn-flags.h insn-codes.h $(EXPR_H) insn-config.h \\\n+   $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n+   except.h\n calls.o : calls.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h $(EXPR_H) \\\n    insn-flags.h $(REGS_H) toplev.h output.h\n expmed.o : expmed.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h  \\"}, {"sha": "0a833fcac875d4c82ac0c98829b2c6369eb17d9e", "filename": "gcc/builtins.c", "status": "added", "additions": 2198, "deletions": 0, "changes": 2198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "patch": "@@ -0,0 +1,2198 @@\n+/* Expand builtin functions.\n+   Copyright (C) 1988, 92-98, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"machmode.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"obstack.h\"\n+#include \"flags.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n+#include \"insn-flags.h\"\n+#include \"insn-codes.h\"\n+#include \"insn-config.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"typeclass.h\"\n+#include \"defaults.h\"\n+#include \"toplev.h\"\n+\n+#define CALLED_AS_BUILT_IN(NODE) \\\n+   (!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), \"__builtin_\", 10))\n+\n+#define CEIL(x,y) (((x) + (y) - 1) / (y))\n+\n+/* Register mappings for target machines without register windows.  */\n+#ifndef INCOMING_REGNO\n+#define INCOMING_REGNO(OUT) (OUT)\n+#endif\n+#ifndef OUTGOING_REGNO\n+#define OUTGOING_REGNO(IN) (IN)\n+#endif\n+\n+/* Nonzero means __builtin_saveregs has already been done in this function.\n+   The value is the pseudoreg containing the value __builtin_saveregs\n+   returned.  */\n+rtx saveregs_value;\n+\n+/* Similarly for __builtin_apply_args.  */\n+rtx apply_args_value;\n+\n+static int get_pointer_alignment\tPROTO((tree, unsigned));\n+static tree c_strlen\t\t\tPROTO((tree));\n+static rtx get_memory_rtx\t\tPROTO((tree));\n+static int apply_args_size\t\tPROTO((void));\n+static int apply_result_size\t\tPROTO((void));\n+static rtx result_vector\t\tPROTO((int, rtx));\n+static rtx expand_builtin_apply_args\tPROTO((void));\n+static rtx expand_builtin_apply_args_1\tPROTO((void));\n+static rtx expand_builtin_apply\t\tPROTO((rtx, rtx, rtx));\n+static void expand_builtin_return\tPROTO((rtx));\n+static rtx expand_builtin_classify_type\tPROTO((tree));\n+static rtx expand_builtin_mathfn\tPROTO((tree, rtx, rtx));\n+static rtx expand_builtin_constant_p\tPROTO((tree));\n+static rtx expand_builtin_saveregs\tPROTO((tree, rtx, int));\n+static rtx expand_builtin_args_info\tPROTO((tree));\n+static rtx expand_builtin_next_arg\tPROTO((tree));\n+static rtx expand_builtin_memcmp\tPROTO((tree, tree, rtx));\n+static rtx expand_builtin_strcmp\tPROTO((tree, rtx));\n+static rtx expand_builtin_memcpy\tPROTO((tree));\n+static rtx expand_builtin_strcpy\tPROTO((tree));\n+static rtx expand_builtin_memset\tPROTO((tree));\n+static rtx expand_builtin_strlen\tPROTO((tree, rtx, enum machine_mode));\n+static rtx expand_builtin_alloca\tPROTO((tree, rtx));\n+static rtx expand_builtin_ffs\t\tPROTO((tree, rtx, rtx));\n+static rtx expand_builtin_frame_address\tPROTO((tree));\n+\n+/* Return the alignment in bits of EXP, a pointer valued expression.\n+   But don't return more than MAX_ALIGN no matter what.\n+   The alignment returned is, by default, the alignment of the thing that\n+   EXP points to (if it is not a POINTER_TYPE, 0 is returned).\n+\n+   Otherwise, look at the expression to see if we can do better, i.e., if the\n+   expression is actually pointing at an object whose alignment is tighter.  */\n+\n+static int\n+get_pointer_alignment (exp, max_align)\n+     tree exp;\n+     unsigned max_align;\n+{\n+  unsigned align, inner;\n+\n+  if (TREE_CODE (TREE_TYPE (exp)) != POINTER_TYPE)\n+    return 0;\n+\n+  align = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n+  align = MIN (align, max_align);\n+\n+  while (1)\n+    {\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase NOP_EXPR:\n+\tcase CONVERT_EXPR:\n+\tcase NON_LVALUE_EXPR:\n+\t  exp = TREE_OPERAND (exp, 0);\n+\t  if (TREE_CODE (TREE_TYPE (exp)) != POINTER_TYPE)\n+\t    return align;\n+\t  inner = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n+\t  align = MIN (inner, max_align);\n+\t  break;\n+\n+\tcase PLUS_EXPR:\n+\t  /* If sum of pointer + int, restrict our maximum alignment to that\n+\t     imposed by the integer.  If not, we can't do any better than\n+\t     ALIGN.  */\n+\t  if (TREE_CODE (TREE_OPERAND (exp, 1)) != INTEGER_CST)\n+\t    return align;\n+\n+\t  while (((TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)) * BITS_PER_UNIT)\n+\t\t  & (max_align - 1))\n+\t\t != 0)\n+\t    max_align >>= 1;\n+\n+\t  exp = TREE_OPERAND (exp, 0);\n+\t  break;\n+\n+\tcase ADDR_EXPR:\n+\t  /* See what we are pointing at and look at its alignment.  */\n+\t  exp = TREE_OPERAND (exp, 0);\n+\t  if (TREE_CODE (exp) == FUNCTION_DECL)\n+\t    align = FUNCTION_BOUNDARY;\n+\t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n+\t    align = DECL_ALIGN (exp);\n+#ifdef CONSTANT_ALIGNMENT\n+\t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')\n+\t    align = CONSTANT_ALIGNMENT (exp, align);\n+#endif\n+\t  return MIN (align, max_align);\n+\n+\tdefault:\n+\t  return align;\n+\t}\n+    }\n+}\n+\n+/* Compute the length of a C string.  TREE_STRING_LENGTH is not the right\n+   way, because it could contain a zero byte in the middle.\n+   TREE_STRING_LENGTH is the size of the character array, not the string.\n+\n+   Unfortunately, string_constant can't access the values of const char\n+   arrays with initializers, so neither can we do so here.  */\n+\n+static tree\n+c_strlen (src)\n+     tree src;\n+{\n+  tree offset_node;\n+  int offset, max;\n+  char *ptr;\n+\n+  src = string_constant (src, &offset_node);\n+  if (src == 0)\n+    return 0;\n+  max = TREE_STRING_LENGTH (src);\n+  ptr = TREE_STRING_POINTER (src);\n+  if (offset_node && TREE_CODE (offset_node) != INTEGER_CST)\n+    {\n+      /* If the string has an internal zero byte (e.g., \"foo\\0bar\"), we can't\n+\t compute the offset to the following null if we don't know where to\n+\t start searching for it.  */\n+      int i;\n+      for (i = 0; i < max; i++)\n+\tif (ptr[i] == 0)\n+\t  return 0;\n+      /* We don't know the starting offset, but we do know that the string\n+\t has no internal zero bytes.  We can assume that the offset falls\n+\t within the bounds of the string; otherwise, the programmer deserves\n+\t what he gets.  Subtract the offset from the length of the string,\n+\t and return that.  */\n+      /* This would perhaps not be valid if we were dealing with named\n+         arrays in addition to literal string constants.  */\n+      return size_binop (MINUS_EXPR, size_int (max), offset_node);\n+    }\n+\n+  /* We have a known offset into the string.  Start searching there for\n+     a null character.  */\n+  if (offset_node == 0)\n+    offset = 0;\n+  else\n+    {\n+      /* Did we get a long long offset?  If so, punt.  */\n+      if (TREE_INT_CST_HIGH (offset_node) != 0)\n+\treturn 0;\n+      offset = TREE_INT_CST_LOW (offset_node);\n+    }\n+  /* If the offset is known to be out of bounds, warn, and call strlen at\n+     runtime.  */\n+  if (offset < 0 || offset > max)\n+    {\n+      warning (\"offset outside bounds of constant string\");\n+      return 0;\n+    }\n+  /* Use strlen to search for the first zero byte.  Since any strings\n+     constructed with build_string will have nulls appended, we win even\n+     if we get handed something like (char[4])\"abcd\".\n+\n+     Since OFFSET is our starting index into the string, no further\n+     calculation is needed.  */\n+  return size_int (strlen (ptr + offset));\n+}\n+\n+/* Given TEM, a pointer to a stack frame, follow the dynamic chain COUNT\n+   times to get the address of either a higher stack frame, or a return\n+   address located within it (depending on FNDECL_CODE).  */\n+rtx\n+expand_builtin_return_addr (fndecl_code, count, tem)\n+     enum built_in_function fndecl_code;\n+     int count;\n+     rtx tem;\n+{\n+  int i;\n+\n+  /* Some machines need special handling before we can access\n+     arbitrary frames.  For example, on the sparc, we must first flush\n+     all register windows to the stack.  */\n+#ifdef SETUP_FRAME_ADDRESSES\n+  if (count > 0)\n+    SETUP_FRAME_ADDRESSES ();\n+#endif\n+\n+  /* On the sparc, the return address is not in the frame, it is in a\n+     register.  There is no way to access it off of the current frame\n+     pointer, but it can be accessed off the previous frame pointer by\n+     reading the value from the register window save area.  */\n+#ifdef RETURN_ADDR_IN_PREVIOUS_FRAME\n+  if (fndecl_code == BUILT_IN_RETURN_ADDRESS)\n+    count--;\n+#endif\n+\n+  /* Scan back COUNT frames to the specified frame.  */\n+  for (i = 0; i < count; i++)\n+    {\n+      /* Assume the dynamic chain pointer is in the word that the\n+\t frame address points to, unless otherwise specified.  */\n+#ifdef DYNAMIC_CHAIN_ADDRESS\n+      tem = DYNAMIC_CHAIN_ADDRESS (tem);\n+#endif\n+      tem = memory_address (Pmode, tem);\n+      tem = copy_to_reg (gen_rtx_MEM (Pmode, tem));\n+    }\n+\n+  /* For __builtin_frame_address, return what we've got.  */\n+  if (fndecl_code == BUILT_IN_FRAME_ADDRESS)\n+    return tem;\n+\n+  /* For __builtin_return_address, Get the return address from that\n+     frame.  */\n+#ifdef RETURN_ADDR_RTX\n+  tem = RETURN_ADDR_RTX (count, tem);\n+#else\n+  tem = memory_address (Pmode,\n+\t\t\tplus_constant (tem, GET_MODE_SIZE (Pmode)));\n+  tem = gen_rtx_MEM (Pmode, tem);\n+#endif\n+  return tem;\n+}\n+\n+/* __builtin_setjmp is passed a pointer to an array of five words (not\n+   all will be used on all machines).  It operates similarly to the C\n+   library function of the same name, but is more efficient.  Much of\n+   the code below (and for longjmp) is copied from the handling of\n+   non-local gotos.\n+\n+   NOTE: This is intended for use by GNAT and the exception handling\n+   scheme in the compiler and will only work in the method used by\n+   them.  */\n+\n+rtx\n+expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n+     rtx buf_addr;\n+     rtx target;\n+     rtx first_label, next_label;\n+{\n+  rtx lab1 = gen_label_rtx ();\n+  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+  enum machine_mode value_mode;\n+  rtx stack_save;\n+\n+  value_mode = TYPE_MODE (integer_type_node);\n+\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  buf_addr = convert_memory_address (Pmode, buf_addr);\n+#endif\n+\n+  buf_addr = force_reg (Pmode, buf_addr);\n+\n+  if (target == 0 || GET_CODE (target) != REG\n+      || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+    target = gen_reg_rtx (value_mode);\n+\n+  emit_queue ();\n+\n+  /* We store the frame pointer and the address of lab1 in the buffer\n+     and use the rest of it for the stack save area, which is\n+     machine-dependent.  */\n+\n+#ifndef BUILTIN_SETJMP_FRAME_VALUE\n+#define BUILTIN_SETJMP_FRAME_VALUE virtual_stack_vars_rtx\n+#endif\n+\n+  emit_move_insn (gen_rtx_MEM (Pmode, buf_addr),\n+\t\t  BUILTIN_SETJMP_FRAME_VALUE);\n+  emit_move_insn (validize_mem\n+\t\t  (gen_rtx_MEM (Pmode,\n+\t\t\t\tplus_constant (buf_addr,\n+\t\t\t\t\t       GET_MODE_SIZE (Pmode)))),\n+\t\t  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, lab1)));\n+\n+  stack_save = gen_rtx_MEM (sa_mode,\n+\t\t\t    plus_constant (buf_addr,\n+\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n+  emit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n+\n+  /* If there is further processing to do, do it.  */\n+#ifdef HAVE_builtin_setjmp_setup\n+  if (HAVE_builtin_setjmp_setup)\n+    emit_insn (gen_builtin_setjmp_setup (buf_addr));\n+#endif\n+\n+  /* Set TARGET to zero and branch to the first-time-through label.  */\n+  emit_move_insn (target, const0_rtx);\n+  emit_jump_insn (gen_jump (first_label));\n+  emit_barrier ();\n+  emit_label (lab1);\n+\n+  /* Tell flow about the strange goings on.  Putting `lab1' on\n+     `nonlocal_goto_handler_labels' to indicates that function\n+     calls may traverse the arc back to this label.  */\n+\n+  current_function_has_nonlocal_label = 1;\n+  nonlocal_goto_handler_labels =\n+    gen_rtx_EXPR_LIST (VOIDmode, lab1, nonlocal_goto_handler_labels);\n+\n+  /* Clobber the FP when we get here, so we have to make sure it's\n+     marked as used by this function.  */\n+  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+\n+  /* Mark the static chain as clobbered here so life information\n+     doesn't get messed up for it.  */\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, static_chain_rtx));\n+\n+  /* Now put in the code to restore the frame pointer, and argument\n+     pointer, if needed.  The code below is from expand_end_bindings\n+     in stmt.c; see detailed documentation there.  */\n+#ifdef HAVE_nonlocal_goto\n+  if (! HAVE_nonlocal_goto)\n+#endif\n+    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n+\n+#if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+  if (fixed_regs[ARG_POINTER_REGNUM])\n+    {\n+#ifdef ELIMINABLE_REGS\n+      size_t i;\n+      static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;\n+\n+      for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)\n+\tif (elim_regs[i].from == ARG_POINTER_REGNUM\n+\t    && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n+\t  break;\n+\n+      if (i == sizeof elim_regs / sizeof elim_regs [0])\n+#endif\n+\t{\n+\t  /* Now restore our arg pointer from the address at which it\n+\t     was saved in our stack frame.\n+\t     If there hasn't be space allocated for it yet, make\n+\t     some now.  */\n+\t  if (arg_pointer_save_area == 0)\n+\t    arg_pointer_save_area\n+\t      = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n+\t  emit_move_insn (virtual_incoming_args_rtx,\n+\t\t\t  copy_to_reg (arg_pointer_save_area));\n+\t}\n+    }\n+#endif\n+\n+#ifdef HAVE_builtin_setjmp_receiver\n+  if (HAVE_builtin_setjmp_receiver)\n+    emit_insn (gen_builtin_setjmp_receiver (lab1));\n+  else\n+#endif\n+#ifdef HAVE_nonlocal_goto_receiver\n+    if (HAVE_nonlocal_goto_receiver)\n+      emit_insn (gen_nonlocal_goto_receiver ());\n+    else\n+#endif\n+      {\n+\t; /* Nothing */\n+      }\n+\n+  /* Set TARGET, and branch to the next-time-through label.  */\n+  emit_move_insn (target, const1_rtx);\n+  emit_jump_insn (gen_jump (next_label));\n+  emit_barrier ();\n+\n+  return target;\n+}\n+\n+/* __builtin_longjmp is passed a pointer to an array of five words (not\n+   all will be used on all machines).  It operates similarly to the C\n+   library function of the same name, but is more efficient.  Much of\n+   the code below is copied from the handling of non-local gotos.\n+\n+   NOTE: This is intended for use by GNAT and the exception handling\n+   scheme in the compiler and will only work in the method used by\n+   them.  */\n+\n+void\n+expand_builtin_longjmp (buf_addr, value)\n+     rtx buf_addr, value;\n+{\n+  rtx fp, lab, stack;\n+  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+\n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  buf_addr = convert_memory_address (Pmode, buf_addr);\n+#endif\n+  buf_addr = force_reg (Pmode, buf_addr);\n+\n+  /* We used to store value in static_chain_rtx, but that fails if pointers\n+     are smaller than integers.  We instead require that the user must pass\n+     a second argument of 1, because that is what builtin_setjmp will\n+     return.  This also makes EH slightly more efficient, since we are no\n+     longer copying around a value that we don't care about.  */\n+  if (value != const1_rtx)\n+    abort ();\n+\n+#ifdef HAVE_builtin_longjmp\n+  if (HAVE_builtin_longjmp)\n+    emit_insn (gen_builtin_longjmp (buf_addr));\n+  else\n+#endif\n+    {\n+      fp = gen_rtx_MEM (Pmode, buf_addr);\n+      lab = gen_rtx_MEM (Pmode, plus_constant (buf_addr,\n+\t\t\t\t\t       GET_MODE_SIZE (Pmode)));\n+\n+      stack = gen_rtx_MEM (sa_mode, plus_constant (buf_addr,\n+\t\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n+\n+      /* Pick up FP, label, and SP from the block and jump.  This code is\n+\t from expand_goto in stmt.c; see there for detailed comments.  */\n+#if HAVE_nonlocal_goto\n+      if (HAVE_nonlocal_goto)\n+\t/* We have to pass a value to the nonlocal_goto pattern that will\n+\t   get copied into the static_chain pointer, but it does not matter\n+\t   what that value is, because builtin_setjmp does not use it.  */\n+\temit_insn (gen_nonlocal_goto (value, fp, stack, lab));\n+      else\n+#endif\n+\t{\n+\t  lab = copy_to_reg (lab);\n+\n+\t  emit_move_insn (hard_frame_pointer_rtx, fp);\n+\t  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n+\n+\t  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+\t  emit_indirect_jump (lab);\n+\t}\n+    }\n+}\n+\n+/* Get a MEM rtx for expression EXP which can be used in a string instruction\n+   (cmpstrsi, movstrsi, ..).  */\n+static rtx\n+get_memory_rtx (exp)\n+     tree exp;\n+{\n+  rtx mem;\n+  int is_aggregate;\n+\n+  mem = gen_rtx_MEM (BLKmode,\n+\t\t     memory_address (BLKmode,\n+\t\t\t\t     expand_expr (exp, NULL_RTX,\n+\t\t\t\t\t\t  ptr_mode, EXPAND_SUM)));\n+\n+  RTX_UNCHANGING_P (mem) = TREE_READONLY (exp);\n+\n+  /* Figure out the type of the object pointed to.  Set MEM_IN_STRUCT_P\n+     if the value is the address of a structure or if the expression is\n+     cast to a pointer to structure type.  */\n+  is_aggregate = 0;\n+\n+  while (TREE_CODE (exp) == NOP_EXPR)\n+    {\n+      tree cast_type = TREE_TYPE (exp);\n+      if (TREE_CODE (cast_type) == POINTER_TYPE\n+\t  && AGGREGATE_TYPE_P (TREE_TYPE (cast_type)))\n+\t{\n+\t  is_aggregate = 1;\n+\t  break;\n+\t}\n+      exp = TREE_OPERAND (exp, 0);\n+    }\n+\n+  if (is_aggregate == 0)\n+    {\n+      tree type;\n+\n+      if (TREE_CODE (exp) == ADDR_EXPR)\n+\t/* If this is the address of an object, check whether the\n+\t   object is an array.  */\n+\ttype = TREE_TYPE (TREE_OPERAND (exp, 0));\n+      else\n+\ttype = TREE_TYPE (TREE_TYPE (exp));\n+      is_aggregate = AGGREGATE_TYPE_P (type);\n+    }\n+\n+  MEM_SET_IN_STRUCT_P (mem, is_aggregate);\n+  return mem;\n+}\n+\f\n+/* Built-in functions to perform an untyped call and return.  */\n+\n+/* For each register that may be used for calling a function, this\n+   gives a mode used to copy the register's value.  VOIDmode indicates\n+   the register is not used for calling a function.  If the machine\n+   has register windows, this gives only the outbound registers.\n+   INCOMING_REGNO gives the corresponding inbound register.  */\n+static enum machine_mode apply_args_mode[FIRST_PSEUDO_REGISTER];\n+\n+/* For each register that may be used for returning values, this gives\n+   a mode used to copy the register's value.  VOIDmode indicates the\n+   register is not used for returning values.  If the machine has\n+   register windows, this gives only the outbound registers.\n+   INCOMING_REGNO gives the corresponding inbound register.  */\n+static enum machine_mode apply_result_mode[FIRST_PSEUDO_REGISTER];\n+\n+/* For each register that may be used for calling a function, this\n+   gives the offset of that register into the block returned by\n+   __builtin_apply_args.  0 indicates that the register is not\n+   used for calling a function.  */\n+static int apply_args_reg_offset[FIRST_PSEUDO_REGISTER];\n+\n+/* Return the offset of register REGNO into the block returned by \n+   __builtin_apply_args.  This is not declared static, since it is\n+   needed in objc-act.c.  */\n+\n+int \n+apply_args_register_offset (regno)\n+     int regno;\n+{\n+  apply_args_size ();\n+\n+  /* Arguments are always put in outgoing registers (in the argument\n+     block) if such make sense.  */\n+#ifdef OUTGOING_REGNO\n+  regno = OUTGOING_REGNO(regno);\n+#endif\n+  return apply_args_reg_offset[regno];\n+}\n+\n+/* Return the size required for the block returned by __builtin_apply_args,\n+   and initialize apply_args_mode.  */\n+\n+static int\n+apply_args_size ()\n+{\n+  static int size = -1;\n+  int align, regno;\n+  enum machine_mode mode;\n+\n+  /* The values computed by this function never change.  */\n+  if (size < 0)\n+    {\n+      /* The first value is the incoming arg-pointer.  */\n+      size = GET_MODE_SIZE (Pmode);\n+\n+      /* The second value is the structure value address unless this is\n+\t passed as an \"invisible\" first argument.  */\n+      if (struct_value_rtx)\n+\tsize += GET_MODE_SIZE (Pmode);\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (FUNCTION_ARG_REGNO_P (regno))\n+\t  {\n+\t    /* Search for the proper mode for copying this register's\n+\t       value.  I'm not sure this is right, but it works so far.  */\n+\t    enum machine_mode best_mode = VOIDmode;\n+\n+\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t\t mode != VOIDmode;\n+\t\t mode = GET_MODE_WIDER_MODE (mode))\n+\t      if (HARD_REGNO_MODE_OK (regno, mode)\n+\t\t  && HARD_REGNO_NREGS (regno, mode) == 1)\n+\t\tbest_mode = mode;\n+\n+\t    if (best_mode == VOIDmode)\n+\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+\t\t   mode != VOIDmode;\n+\t\t   mode = GET_MODE_WIDER_MODE (mode))\n+\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n+\t\t    && (mov_optab->handlers[(int) mode].insn_code\n+\t\t\t!= CODE_FOR_nothing))\n+\t\t  best_mode = mode;\n+\n+\t    mode = best_mode;\n+\t    if (mode == VOIDmode)\n+\t      abort ();\n+\n+\t    align = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\t    if (size % align != 0)\n+\t      size = CEIL (size, align) * align;\n+\t    apply_args_reg_offset[regno] = size;\n+\t    size += GET_MODE_SIZE (mode);\n+\t    apply_args_mode[regno] = mode;\n+\t  }\n+\telse\n+\t  {\n+\t    apply_args_mode[regno] = VOIDmode;\n+\t    apply_args_reg_offset[regno] = 0;\n+\t  }\n+    }\n+  return size;\n+}\n+\n+/* Return the size required for the block returned by __builtin_apply,\n+   and initialize apply_result_mode.  */\n+\n+static int\n+apply_result_size ()\n+{\n+  static int size = -1;\n+  int align, regno;\n+  enum machine_mode mode;\n+\n+  /* The values computed by this function never change.  */\n+  if (size < 0)\n+    {\n+      size = 0;\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (FUNCTION_VALUE_REGNO_P (regno))\n+\t  {\n+\t    /* Search for the proper mode for copying this register's\n+\t       value.  I'm not sure this is right, but it works so far.  */\n+\t    enum machine_mode best_mode = VOIDmode;\n+\n+\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t\t mode != TImode;\n+\t\t mode = GET_MODE_WIDER_MODE (mode))\n+\t      if (HARD_REGNO_MODE_OK (regno, mode))\n+\t\tbest_mode = mode;\n+\n+\t    if (best_mode == VOIDmode)\n+\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+\t\t   mode != VOIDmode;\n+\t\t   mode = GET_MODE_WIDER_MODE (mode))\n+\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n+\t\t    && (mov_optab->handlers[(int) mode].insn_code\n+\t\t\t!= CODE_FOR_nothing))\n+\t\t  best_mode = mode;\n+\n+\t    mode = best_mode;\n+\t    if (mode == VOIDmode)\n+\t      abort ();\n+\n+\t    align = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\t    if (size % align != 0)\n+\t      size = CEIL (size, align) * align;\n+\t    size += GET_MODE_SIZE (mode);\n+\t    apply_result_mode[regno] = mode;\n+\t  }\n+\telse\n+\t  apply_result_mode[regno] = VOIDmode;\n+\n+      /* Allow targets that use untyped_call and untyped_return to override\n+\t the size so that machine-specific information can be stored here.  */\n+#ifdef APPLY_RESULT_SIZE\n+      size = APPLY_RESULT_SIZE;\n+#endif\n+    }\n+  return size;\n+}\n+\n+#if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)\n+/* Create a vector describing the result block RESULT.  If SAVEP is true,\n+   the result block is used to save the values; otherwise it is used to\n+   restore the values.  */\n+\n+static rtx\n+result_vector (savep, result)\n+     int savep;\n+     rtx result;\n+{\n+  int regno, size, align, nelts;\n+  enum machine_mode mode;\n+  rtx reg, mem;\n+  rtx *savevec = (rtx *) alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n+  \n+  size = nelts = 0;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((mode = apply_result_mode[regno]) != VOIDmode)\n+      {\n+\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\tif (size % align != 0)\n+\t  size = CEIL (size, align) * align;\n+\treg = gen_rtx_REG (mode, savep ? regno : INCOMING_REGNO (regno));\n+\tmem = change_address (result, mode,\n+\t\t\t      plus_constant (XEXP (result, 0), size));\n+\tsavevec[nelts++] = (savep\n+\t\t\t    ? gen_rtx_SET (VOIDmode, mem, reg)\n+\t\t\t    : gen_rtx_SET (VOIDmode, reg, mem));\n+\tsize += GET_MODE_SIZE (mode);\n+      }\n+  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nelts, savevec));\n+}\n+#endif /* HAVE_untyped_call or HAVE_untyped_return */\n+\n+/* Save the state required to perform an untyped call with the same\n+   arguments as were passed to the current function.  */\n+\n+static rtx\n+expand_builtin_apply_args_1 ()\n+{\n+  rtx registers;\n+  int size, align, regno;\n+  enum machine_mode mode;\n+\n+  /* Create a block where the arg-pointer, structure value address,\n+     and argument registers can be saved.  */\n+  registers = assign_stack_local (BLKmode, apply_args_size (), -1);\n+\n+  /* Walk past the arg-pointer and structure value address.  */\n+  size = GET_MODE_SIZE (Pmode);\n+  if (struct_value_rtx)\n+    size += GET_MODE_SIZE (Pmode);\n+\n+  /* Save each register used in calling a function to the block.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((mode = apply_args_mode[regno]) != VOIDmode)\n+      {\n+\trtx tem;\n+\n+\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\tif (size % align != 0)\n+\t  size = CEIL (size, align) * align;\n+\n+\ttem = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n+\n+#ifdef STACK_REGS\n+        /* For reg-stack.c's stack register household.\n+\t   Compare with a similar piece of code in function.c.  */\n+\n+        emit_insn (gen_rtx_USE (mode, tem));\n+#endif\n+\n+\temit_move_insn (change_address (registers, mode,\n+\t\t\t\t\tplus_constant (XEXP (registers, 0),\n+\t\t\t\t\t\t       size)),\n+\t\t\ttem);\n+\tsize += GET_MODE_SIZE (mode);\n+      }\n+\n+  /* Save the arg pointer to the block.  */\n+  emit_move_insn (change_address (registers, Pmode, XEXP (registers, 0)),\n+\t\t  copy_to_reg (virtual_incoming_args_rtx));\n+  size = GET_MODE_SIZE (Pmode);\n+\n+  /* Save the structure value address unless this is passed as an\n+     \"invisible\" first argument.  */\n+  if (struct_value_incoming_rtx)\n+    {\n+      emit_move_insn (change_address (registers, Pmode,\n+\t\t\t\t      plus_constant (XEXP (registers, 0),\n+\t\t\t\t\t\t     size)),\n+\t\t      copy_to_reg (struct_value_incoming_rtx));\n+      size += GET_MODE_SIZE (Pmode);\n+    }\n+\n+  /* Return the address of the block.  */\n+  return copy_addr_to_reg (XEXP (registers, 0));\n+}\n+\n+/* __builtin_apply_args returns block of memory allocated on\n+   the stack into which is stored the arg pointer, structure\n+   value address, static chain, and all the registers that might\n+   possibly be used in performing a function call.  The code is\n+   moved to the start of the function so the incoming values are\n+   saved.  */\n+static rtx\n+expand_builtin_apply_args ()\n+{\n+  /* Don't do __builtin_apply_args more than once in a function.\n+     Save the result of the first call and reuse it.  */\n+  if (apply_args_value != 0)\n+    return apply_args_value;\n+  {\n+    /* When this function is called, it means that registers must be\n+       saved on entry to this function.  So we migrate the\n+       call to the first insn of this function.  */\n+    rtx temp;\n+    rtx seq;\n+\n+    start_sequence ();\n+    temp = expand_builtin_apply_args_1 ();\n+    seq = get_insns ();\n+    end_sequence ();\n+\n+    apply_args_value = temp;\n+\n+    /* Put the sequence after the NOTE that starts the function.\n+       If this is inside a SEQUENCE, make the outer-level insn\n+       chain current, so the code is placed at the start of the\n+       function.  */\n+    push_topmost_sequence ();\n+    emit_insns_before (seq, NEXT_INSN (get_insns ()));\n+    pop_topmost_sequence ();\n+    return temp;\n+  }\n+}\n+\n+/* Perform an untyped call and save the state required to perform an\n+   untyped return of whatever value was returned by the given function.  */\n+\n+static rtx\n+expand_builtin_apply (function, arguments, argsize)\n+     rtx function, arguments, argsize;\n+{\n+  int size, align, regno;\n+  enum machine_mode mode;\n+  rtx incoming_args, result, reg, dest, call_insn;\n+  rtx old_stack_level = 0;\n+  rtx call_fusage = 0;\n+\n+  /* Create a block where the return registers can be saved.  */\n+  result = assign_stack_local (BLKmode, apply_result_size (), -1);\n+\n+  /* ??? The argsize value should be adjusted here.  */\n+\n+  /* Fetch the arg pointer from the ARGUMENTS block.  */\n+  incoming_args = gen_reg_rtx (Pmode);\n+  emit_move_insn (incoming_args,\n+\t\t  gen_rtx_MEM (Pmode, arguments));\n+#ifndef STACK_GROWS_DOWNWARD\n+  incoming_args = expand_binop (Pmode, sub_optab, incoming_args, argsize,\n+\t\t\t\tincoming_args, 0, OPTAB_LIB_WIDEN);\n+#endif\n+\n+  /* Perform postincrements before actually calling the function.  */\n+  emit_queue ();\n+\n+  /* Push a new argument block and copy the arguments.  */\n+  do_pending_stack_adjust ();\n+\n+  /* Save the stack with nonlocal if available */\n+#ifdef HAVE_save_stack_nonlocal\n+  if (HAVE_save_stack_nonlocal)\n+    emit_stack_save (SAVE_NONLOCAL, &old_stack_level, NULL_RTX);\n+  else\n+#endif\n+    emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\n+  /* Push a block of memory onto the stack to store the memory arguments.\n+     Save the address in a register, and copy the memory arguments.  ??? I\n+     haven't figured out how the calling convention macros effect this,\n+     but it's likely that the source and/or destination addresses in\n+     the block copy will need updating in machine specific ways.  */\n+  dest = allocate_dynamic_stack_space (argsize, 0, 0);\n+  emit_block_move (gen_rtx_MEM (BLKmode, dest),\n+\t\t   gen_rtx_MEM (BLKmode, incoming_args),\n+\t\t   argsize,\n+\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+\n+  /* Refer to the argument block.  */\n+  apply_args_size ();\n+  arguments = gen_rtx_MEM (BLKmode, arguments);\n+\n+  /* Walk past the arg-pointer and structure value address.  */\n+  size = GET_MODE_SIZE (Pmode);\n+  if (struct_value_rtx)\n+    size += GET_MODE_SIZE (Pmode);\n+\n+  /* Restore each of the registers previously saved.  Make USE insns\n+     for each of these registers for use in making the call.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((mode = apply_args_mode[regno]) != VOIDmode)\n+      {\n+\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\tif (size % align != 0)\n+\t  size = CEIL (size, align) * align;\n+\treg = gen_rtx_REG (mode, regno);\n+\temit_move_insn (reg,\n+\t\t\tchange_address (arguments, mode,\n+\t\t\t\t\tplus_constant (XEXP (arguments, 0),\n+\t\t\t\t\t\t       size)));\n+\n+\tuse_reg (&call_fusage, reg);\n+\tsize += GET_MODE_SIZE (mode);\n+      }\n+\n+  /* Restore the structure value address unless this is passed as an\n+     \"invisible\" first argument.  */\n+  size = GET_MODE_SIZE (Pmode);\n+  if (struct_value_rtx)\n+    {\n+      rtx value = gen_reg_rtx (Pmode);\n+      emit_move_insn (value,\n+\t\t      change_address (arguments, Pmode,\n+\t\t\t\t      plus_constant (XEXP (arguments, 0),\n+\t\t\t\t\t\t     size)));\n+      emit_move_insn (struct_value_rtx, value);\n+      if (GET_CODE (struct_value_rtx) == REG)\n+\t  use_reg (&call_fusage, struct_value_rtx);\n+      size += GET_MODE_SIZE (Pmode);\n+    }\n+\n+  /* All arguments and registers used for the call are set up by now!  */\n+  function = prepare_call_address (function, NULL_TREE, &call_fusage, 0);\n+\n+  /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n+     and we don't want to load it into a register as an optimization,\n+     because prepare_call_address already did it if it should be done.  */\n+  if (GET_CODE (function) != SYMBOL_REF)\n+    function = memory_address (FUNCTION_MODE, function);\n+\n+  /* Generate the actual call instruction and save the return value.  */\n+#ifdef HAVE_untyped_call\n+  if (HAVE_untyped_call)\n+    emit_call_insn (gen_untyped_call (gen_rtx_MEM (FUNCTION_MODE, function),\n+\t\t\t\t      result, result_vector (1, result)));\n+  else\n+#endif\n+#ifdef HAVE_call_value\n+  if (HAVE_call_value)\n+    {\n+      rtx valreg = 0;\n+\n+      /* Locate the unique return register.  It is not possible to\n+\t express a call that sets more than one return register using\n+\t call_value; use untyped_call for that.  In fact, untyped_call\n+\t only needs to save the return registers in the given block.  */\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif ((mode = apply_result_mode[regno]) != VOIDmode)\n+\t  {\n+\t    if (valreg)\n+\t      abort (); /* HAVE_untyped_call required.  */\n+\t    valreg = gen_rtx_REG (mode, regno);\n+\t  }\n+\n+      emit_call_insn (gen_call_value (valreg,\n+\t\t\t\t      gen_rtx_MEM (FUNCTION_MODE, function),\n+\t\t\t\t      const0_rtx, NULL_RTX, const0_rtx));\n+\n+      emit_move_insn (change_address (result, GET_MODE (valreg),\n+\t\t\t\t      XEXP (result, 0)),\n+\t\t      valreg);\n+    }\n+  else\n+#endif\n+    abort ();\n+\n+  /* Find the CALL insn we just emitted.  */\n+  for (call_insn = get_last_insn ();\n+       call_insn && GET_CODE (call_insn) != CALL_INSN;\n+       call_insn = PREV_INSN (call_insn))\n+    ;\n+\n+  if (! call_insn)\n+    abort ();\n+\n+  /* Put the register usage information on the CALL.  If there is already\n+     some usage information, put ours at the end.  */\n+  if (CALL_INSN_FUNCTION_USAGE (call_insn))\n+    {\n+      rtx link;\n+\n+      for (link = CALL_INSN_FUNCTION_USAGE (call_insn); XEXP (link, 1) != 0;\n+\t   link = XEXP (link, 1))\n+\t;\n+\n+      XEXP (link, 1) = call_fusage;\n+    }\n+  else\n+    CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n+\n+  /* Restore the stack.  */\n+#ifdef HAVE_save_stack_nonlocal\n+  if (HAVE_save_stack_nonlocal)\n+    emit_stack_restore (SAVE_NONLOCAL, old_stack_level, NULL_RTX);\n+  else\n+#endif\n+    emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n+\n+  /* Return the address of the result block.  */\n+  return copy_addr_to_reg (XEXP (result, 0));\n+}\n+\n+/* Perform an untyped return.  */\n+\n+static void\n+expand_builtin_return (result)\n+     rtx result;\n+{\n+  int size, align, regno;\n+  enum machine_mode mode;\n+  rtx reg;\n+  rtx call_fusage = 0;\n+\n+  apply_result_size ();\n+  result = gen_rtx_MEM (BLKmode, result);\n+\n+#ifdef HAVE_untyped_return\n+  if (HAVE_untyped_return)\n+    {\n+      emit_jump_insn (gen_untyped_return (result, result_vector (0, result)));\n+      emit_barrier ();\n+      return;\n+    }\n+#endif\n+\n+  /* Restore the return value and note that each value is used.  */\n+  size = 0;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((mode = apply_result_mode[regno]) != VOIDmode)\n+      {\n+\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\tif (size % align != 0)\n+\t  size = CEIL (size, align) * align;\n+\treg = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n+\temit_move_insn (reg,\n+\t\t\tchange_address (result, mode,\n+\t\t\t\t\tplus_constant (XEXP (result, 0),\n+\t\t\t\t\t\t       size)));\n+\n+\tpush_to_sequence (call_fusage);\n+\temit_insn (gen_rtx_USE (VOIDmode, reg));\n+\tcall_fusage = get_insns ();\n+\tend_sequence ();\n+\tsize += GET_MODE_SIZE (mode);\n+      }\n+\n+  /* Put the USE insns before the return.  */\n+  emit_insns (call_fusage);\n+\n+  /* Return whatever values was restored by jumping directly to the end\n+     of the function.  */\n+  expand_null_return ();\n+}\n+\n+/* Expand a call to __builtin_classify_type with arguments found in\n+   ARGLIST.  */\n+static rtx\n+expand_builtin_classify_type (arglist)\n+     tree arglist;\n+{\n+  if (arglist != 0)\n+    {\n+      tree type = TREE_TYPE (TREE_VALUE (arglist));\n+      enum tree_code code = TREE_CODE (type);\n+      if (code == VOID_TYPE)\n+\treturn GEN_INT (void_type_class);\n+      if (code == INTEGER_TYPE)\n+\treturn GEN_INT (integer_type_class);\n+      if (code == CHAR_TYPE)\n+\treturn GEN_INT (char_type_class);\n+      if (code == ENUMERAL_TYPE)\n+\treturn GEN_INT (enumeral_type_class);\n+      if (code == BOOLEAN_TYPE)\n+\treturn GEN_INT (boolean_type_class);\n+      if (code == POINTER_TYPE)\n+\treturn GEN_INT (pointer_type_class);\n+      if (code == REFERENCE_TYPE)\n+\treturn GEN_INT (reference_type_class);\n+      if (code == OFFSET_TYPE)\n+\treturn GEN_INT (offset_type_class);\n+      if (code == REAL_TYPE)\n+\treturn GEN_INT (real_type_class);\n+      if (code == COMPLEX_TYPE)\n+\treturn GEN_INT (complex_type_class);\n+      if (code == FUNCTION_TYPE)\n+\treturn GEN_INT (function_type_class);\n+      if (code == METHOD_TYPE)\n+\treturn GEN_INT (method_type_class);\n+      if (code == RECORD_TYPE)\n+\treturn GEN_INT (record_type_class);\n+      if (code == UNION_TYPE || code == QUAL_UNION_TYPE)\n+\treturn GEN_INT (union_type_class);\n+      if (code == ARRAY_TYPE)\n+\t{\n+\t  if (TYPE_STRING_FLAG (type))\n+\t    return GEN_INT (string_type_class);\n+\t  else\n+\t    return GEN_INT (array_type_class);\n+\t}\n+      if (code == SET_TYPE)\n+\treturn GEN_INT (set_type_class);\n+      if (code == FILE_TYPE)\n+\treturn GEN_INT (file_type_class);\n+      if (code == LANG_TYPE)\n+\treturn GEN_INT (lang_type_class);\n+    }\n+  return GEN_INT (no_type_class);\n+}\n+\n+/* Expand expression EXP, which is a call to __builtin_constant_p.  */\n+static rtx\n+expand_builtin_constant_p (exp)\n+     tree exp;\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum machine_mode value_mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  if (arglist == 0)\n+    return const0_rtx;\n+  else\n+    {\n+      tree arg = TREE_VALUE (arglist);\n+      rtx tmp;\n+\n+      /* We return 1 for a numeric type that's known to be a constant\n+\t value at compile-time or for an aggregate type that's a\n+\t literal constant.  */\n+      STRIP_NOPS (arg);\n+\n+      /* If we know this is a constant, emit the constant of one.  */\n+      if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'c'\n+\t  || (TREE_CODE (arg) == CONSTRUCTOR\n+\t      && TREE_CONSTANT (arg))\n+\t  || (TREE_CODE (arg) == ADDR_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (arg, 0)) == STRING_CST))\n+\treturn const1_rtx;\n+\n+      /* If we aren't going to be running CSE or this expression\n+\t has side effects, show we don't know it to be a constant.\n+\t Likewise if it's a pointer or aggregate type since in those\n+\t case we only want literals, since those are only optimized\n+\t when generating RTL, not later.  */\n+      if (TREE_SIDE_EFFECTS (arg) || cse_not_expected\n+\t  || AGGREGATE_TYPE_P (TREE_TYPE (arg))\n+\t  || POINTER_TYPE_P (TREE_TYPE (arg)))\n+\treturn const0_rtx;\n+\n+      /* Otherwise, emit (constant_p_rtx (ARG)) and let CSE get a\n+\t chance to see if it can deduce whether ARG is constant.  */\n+\n+      tmp = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n+      tmp = gen_rtx_CONSTANT_P_RTX (value_mode, tmp);\n+      return tmp;\n+    }\n+}\n+\n+/* Expand a call to one of the builtin math functions (sin, cos, or sqrt).\n+   Return 0 if a normal call should be emitted rather than expanding the\n+   function in-line.  EXP is the expression that is a call to the builtin\n+   function; if convenient, the result should be placed in TARGET.\n+   SUBTARGET may be used as the target for computing one of EXP's operands.  */\n+static rtx\n+expand_builtin_mathfn (exp, target, subtarget)\n+     tree exp;\n+     rtx target, subtarget;\n+{\n+  optab builtin_optab;  \n+  rtx op0, insns;\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+\n+  if (arglist == 0\n+      /* Arg could be wrong type if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != REAL_TYPE)\n+    return 0;\n+\n+  /* Stabilize and compute the argument.  */\n+  if (TREE_CODE (TREE_VALUE (arglist)) != VAR_DECL\n+      && TREE_CODE (TREE_VALUE (arglist)) != PARM_DECL)\n+    {\n+      exp = copy_node (exp);\n+      arglist = copy_node (arglist);\n+      TREE_OPERAND (exp, 1) = arglist;\n+      TREE_VALUE (arglist) = save_expr (TREE_VALUE (arglist));\n+    }\n+  op0 = expand_expr (TREE_VALUE (arglist), subtarget, VOIDmode, 0);\n+\n+  /* Make a suitable register to place result in.  */\n+  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\n+  emit_queue ();\n+  start_sequence ();\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+     case BUILT_IN_SIN:\n+      builtin_optab = sin_optab; break;\n+     case BUILT_IN_COS:\n+      builtin_optab = cos_optab; break;\n+     case BUILT_IN_FSQRT:\n+      builtin_optab = sqrt_optab; break;\n+     default:\n+      abort ();\n+    }\n+\n+  /* Compute into TARGET.\n+     Set TARGET to wherever the result comes back.  */\n+  target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n+\t\t\tbuiltin_optab, op0, target, 0);\n+\n+  /* If we were unable to expand via the builtin, stop the\n+     sequence (without outputting the insns) and return 0, causing\n+     a call to the library function.  */\n+  if (target == 0)\n+    {\n+      end_sequence ();\n+      return 0;\n+    }\n+\n+  /* Check the results by default.  But if flag_fast_math is turned on,\n+     then assume sqrt will always be called with valid arguments.  */\n+\n+  if (flag_errno_math && ! flag_fast_math)\n+    {\n+      rtx lab1;\n+\n+      /* Don't define the builtin FP instructions\n+\t if your machine is not IEEE.  */\n+      if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n+\tabort ();\n+\n+      lab1 = gen_label_rtx ();\n+\n+      /* Test the result; if it is NaN, set errno=EDOM because\n+\t the argument was not in the domain.  */\n+      emit_cmp_and_jump_insns (target, target, EQ, 0, GET_MODE (target),\n+\t\t\t       0, 0, lab1);\n+\n+#ifdef TARGET_EDOM\n+\t{\n+#ifdef GEN_ERRNO_RTX\n+\t  rtx errno_rtx = GEN_ERRNO_RTX;\n+#else\n+\t  rtx errno_rtx\n+\t    = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n+#endif\n+\n+\t  emit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n+\t}\n+#else\n+      /* We can't set errno=EDOM directly; let the library call do it.\n+\t Pop the arguments right away in case the call gets deleted.  */\n+      NO_DEFER_POP;\n+      expand_call (exp, target, 0);\n+      OK_DEFER_POP;\n+#endif\n+\n+      emit_label (lab1);\n+    }\n+\n+  /* Output the entire sequence.  */\n+  insns = get_insns ();\n+  end_sequence ();\n+  emit_insns (insns);\n+ \n+  return target;\n+}\n+\n+/* Expand expression EXP which is a call to the strlen builtin.  Return 0\n+   if we failed the caller should emit a normal call, otherwise\n+   try to get the result in TARGET, if convenient (and in mode MODE if that's\n+   convenient).  */\n+static rtx\n+expand_builtin_strlen (exp, target, mode)\n+     tree exp;\n+     rtx target;\n+     enum machine_mode mode;\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum machine_mode value_mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  if (arglist == 0\n+      /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n+    return 0;\n+  else\n+    {\n+      tree src = TREE_VALUE (arglist);\n+      tree len = c_strlen (src);\n+\n+      int align\n+\t= get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+\n+      rtx result, src_rtx, char_rtx;\n+      enum machine_mode insn_mode = value_mode, char_mode;\n+      enum insn_code icode;\n+\n+      /* If the length is known, just return it.  */\n+      if (len != 0)\n+\treturn expand_expr (len, target, mode, EXPAND_MEMORY_USE_BAD);\n+\n+      /* If SRC is not a pointer type, don't do this operation inline.  */\n+      if (align == 0)\n+\treturn 0;\n+\n+      /* Call a function if we can't compute strlen in the right mode.  */\n+\n+      while (insn_mode != VOIDmode)\n+\t{\n+\t  icode = strlen_optab->handlers[(int) insn_mode].insn_code;\n+\t  if (icode != CODE_FOR_nothing)\n+\t    return 0;\n+\n+\t  insn_mode = GET_MODE_WIDER_MODE (insn_mode);\n+\t}\n+      if (insn_mode == VOIDmode)\n+\treturn 0;\n+\n+      /* Make a place to write the result of the instruction.  */\n+      result = target;\n+      if (! (result != 0\n+\t     && GET_CODE (result) == REG\n+\t     && GET_MODE (result) == insn_mode\n+\t     && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n+\tresult = gen_reg_rtx (insn_mode);\n+\n+      /* Make sure the operands are acceptable to the predicates.  */\n+\n+      if (! (*insn_operand_predicate[(int)icode][0]) (result, insn_mode))\n+\tresult = gen_reg_rtx (insn_mode);\n+      src_rtx = memory_address (BLKmode,\n+\t\t\t\texpand_expr (src, NULL_RTX, ptr_mode,\n+\t\t\t\t\t     EXPAND_NORMAL));\n+\n+      if (! (*insn_operand_predicate[(int)icode][1]) (src_rtx, Pmode))\n+\tsrc_rtx = copy_to_mode_reg (Pmode, src_rtx);\n+\n+      /* Check the string is readable and has an end.  */\n+      if (current_function_check_memory_usage)\n+\temit_library_call (chkr_check_str_libfunc, 1, VOIDmode, 2,\n+\t\t\t   src_rtx, Pmode,\n+\t\t\t   GEN_INT (MEMORY_USE_RO),\n+\t\t\t   TYPE_MODE (integer_type_node));\n+\n+      char_rtx = const0_rtx;\n+      char_mode = insn_operand_mode[(int)icode][2];\n+      if (! (*insn_operand_predicate[(int)icode][2]) (char_rtx, char_mode))\n+\tchar_rtx = copy_to_mode_reg (char_mode, char_rtx);\n+\n+      emit_insn (GEN_FCN (icode) (result,\n+\t\t\t\t  gen_rtx_MEM (BLKmode, src_rtx),\n+\t\t\t\t  char_rtx, GEN_INT (align)));\n+\n+      /* Return the value in the proper mode for this function.  */\n+      if (GET_MODE (result) == value_mode)\n+\treturn result;\n+      else if (target != 0)\n+\t{\n+\t  convert_move (target, result, 0);\n+\t  return target;\n+\t}\n+      else\n+\treturn convert_to_mode (value_mode, result, 0);\n+    }\n+}\n+\n+/* Expand a call to the memcpy builtin, with arguments in ARGLIST.  */\n+static rtx\n+expand_builtin_memcpy (arglist)\n+     tree arglist;\n+{\n+  if (arglist == 0\n+      /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+      || TREE_CHAIN (arglist) == 0\n+      || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))\n+\t  != POINTER_TYPE)\n+      || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n+      || (TREE_CODE (TREE_TYPE (TREE_VALUE\n+\t\t\t\t(TREE_CHAIN (TREE_CHAIN (arglist)))))\n+\t  != INTEGER_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree dest = TREE_VALUE (arglist);\n+      tree src = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+      int src_align\n+\t= get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+      int dest_align\n+\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+      rtx dest_mem, src_mem, dest_addr, len_rtx;\n+\n+      /* If either SRC or DEST is not a pointer type, don't do\n+\t this operation in-line.  */\n+      if (src_align == 0 || dest_align == 0)\n+\treturn 0;\n+\n+      dest_mem = get_memory_rtx (dest);\n+      src_mem = get_memory_rtx (src);\n+      len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+\n+      /* Just copy the rights of SRC to the rights of DEST.  */\n+      if (current_function_check_memory_usage)\n+\temit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n+\t\t\t   XEXP (dest_mem, 0), Pmode,\n+\t\t\t   XEXP (src_mem, 0), Pmode,\n+\t\t\t   len_rtx, TYPE_MODE (sizetype));\n+\n+      /* Copy word part most expediently.  */\n+      dest_addr\n+\t= emit_block_move (dest_mem, src_mem, len_rtx,\n+\t\t\t   MIN (src_align, dest_align));\n+\n+      if (dest_addr == 0)\n+\tdest_addr = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\n+      return dest_addr;\n+    }\n+}\n+\n+/* Expand expression EXP, which is a call to the strcpy builtin.  Return 0\n+   if we failed the caller should emit a normal call.  */\n+static rtx\n+expand_builtin_strcpy (exp)\n+     tree exp;\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  rtx result;\n+\n+  if (arglist == 0\n+      /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+      || TREE_CHAIN (arglist) == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE)\n+    return 0;\n+  else\n+    {\n+      tree len = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)));\n+\n+      if (len == 0)\n+\treturn 0;\n+\n+      len = size_binop (PLUS_EXPR, len, integer_one_node);\n+\n+      chainon (arglist, build_tree_list (NULL_TREE, len));\n+    }\n+  result = expand_builtin_memcpy (arglist);\n+  if (! result)\n+    TREE_CHAIN (TREE_CHAIN (arglist)) = 0;\n+  return result;\n+}\n+\n+/* Expand expression EXP, which is a call to the memset builtin.  Return 0\n+   if we failed the caller should emit a normal call.  */\n+static rtx\n+expand_builtin_memset (exp)\n+     tree exp;\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+\n+  if (arglist == 0\n+      /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+      || TREE_CHAIN (arglist) == 0\n+      || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))\n+\t  != INTEGER_TYPE)\n+      || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n+      || (INTEGER_TYPE\n+\t  != (TREE_CODE (TREE_TYPE\n+\t\t\t (TREE_VALUE\n+\t\t\t  (TREE_CHAIN (TREE_CHAIN (arglist))))))))\n+    return 0;\n+  else\n+    {\n+      tree dest = TREE_VALUE (arglist);\n+      tree val = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+      int dest_align\n+\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+      rtx dest_mem, dest_addr, len_rtx;\n+\n+      /* If DEST is not a pointer type, don't do this \n+\t operation in-line.  */\n+      if (dest_align == 0)\n+\treturn 0;\n+\n+      /* If the arguments have side-effects, then we can only evaluate\n+\t them at most once.  The following code evaluates them twice if\n+\t they are not constants because we break out to expand_call\n+\t in that case.  They can't be constants if they have side-effects\n+\t so we can check for that first.  Alternatively, we could call\n+\t save_expr to make multiple evaluation safe.  */\n+      if (TREE_SIDE_EFFECTS (val) || TREE_SIDE_EFFECTS (len))\n+\treturn 0;\n+\n+      /* If VAL is not 0, don't do this operation in-line. */\n+      if (expand_expr (val, NULL_RTX, VOIDmode, 0) != const0_rtx)\n+\treturn 0;\n+\n+      /* If LEN does not expand to a constant, don't do this\n+\t operation in-line.  */\n+      len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+      if (GET_CODE (len_rtx) != CONST_INT)\n+\treturn 0;\n+\n+      dest_mem = get_memory_rtx (dest);\n+\t   \n+      /* Just check DST is writable and mark it as readable.  */\n+      if (current_function_check_memory_usage)\n+\temit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n+\t\t\t   XEXP (dest_mem, 0), Pmode,\n+\t\t\t   len_rtx, TYPE_MODE (sizetype),\n+\t\t\t   GEN_INT (MEMORY_USE_WO),\n+\t\t\t   TYPE_MODE (integer_type_node));\n+\n+\n+      dest_addr = clear_storage (dest_mem, len_rtx, dest_align);\n+\n+      if (dest_addr == 0)\n+\tdest_addr = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\n+      return dest_addr;\n+    }\n+}\n+\n+#ifdef HAVE_cmpstrsi\n+/* Expand expression EXP, which is a call to the memcmp or the strcmp builtin.\n+   ARGLIST is the argument list for this call.  Return 0 if we failed and the\n+   caller should emit a normal call, otherwise try to get the result in\n+   TARGET, if convenient.  */\n+static rtx\n+expand_builtin_memcmp (exp, arglist, target)\n+     tree exp;\n+     tree arglist;\n+     rtx target;\n+{\n+  /* If we need to check memory accesses, call the library function.  */\n+  if (current_function_check_memory_usage)\n+    return 0;\n+\n+  if (arglist == 0\n+      /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+      || TREE_CHAIN (arglist) == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE\n+      || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))))) != INTEGER_TYPE)\n+    return 0;\n+  else if (!HAVE_cmpstrsi)\n+    return 0;\n+\n+  {\n+    enum machine_mode mode;\n+    tree arg1 = TREE_VALUE (arglist);\n+    tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+    tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+    rtx result;\n+\n+    int arg1_align\n+      = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+    int arg2_align\n+      = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n+    enum machine_mode insn_mode\n+      = insn_operand_mode[(int) CODE_FOR_cmpstrsi][0];\n+\n+    /* If we don't have POINTER_TYPE, call the function.  */\n+    if (arg1_align == 0 || arg2_align == 0)\n+      return 0;\n+\n+    /* Make a place to write the result of the instruction.  */\n+    result = target;\n+    if (! (result != 0\n+\t   && GET_CODE (result) == REG && GET_MODE (result) == insn_mode\n+\t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n+      result = gen_reg_rtx (insn_mode);\n+\n+    emit_insn (gen_cmpstrsi (result, get_memory_rtx (arg1),\n+\t\t\t     get_memory_rtx (arg2),\n+\t\t\t     expand_expr (len, NULL_RTX, VOIDmode, 0),\n+\t\t\t     GEN_INT (MIN (arg1_align, arg2_align))));\n+\n+    /* Return the value in the proper mode for this function.  */\n+    mode = TYPE_MODE (TREE_TYPE (exp));\n+    if (GET_MODE (result) == mode)\n+      return result;\n+    else if (target != 0)\n+      {\n+\tconvert_move (target, result, 0);\n+\treturn target;\n+      }\n+    else\n+      return convert_to_mode (mode, result, 0);\n+  }\n+}\n+\n+/* Expand expression EXP, which is a call to the strcmp builtin.  Return 0\n+   if we failed the caller should emit a normal call, otherwise try to get\n+   the result in TARGET, if convenient.  */\n+static rtx\n+expand_builtin_strcmp (exp, target)\n+     tree exp;\n+     rtx target;\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+\n+  /* If we need to check memory accesses, call the library function.  */\n+  if (current_function_check_memory_usage)\n+    return 0;\n+\n+  if (arglist == 0\n+      /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+      || TREE_CHAIN (arglist) == 0\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE)\n+    return 0;\n+  else if (!HAVE_cmpstrsi)\n+    return 0;\n+  {\n+    tree arg1 = TREE_VALUE (arglist);\n+    tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+    tree len, len2;\n+    rtx result;\n+    len = c_strlen (arg1);\n+    if (len)\n+      len = size_binop (PLUS_EXPR, integer_one_node, len);\n+    len2 = c_strlen (arg2);\n+    if (len2)\n+      len2 = size_binop (PLUS_EXPR, integer_one_node, len2);\n+\n+    /* If we don't have a constant length for the first, use the length\n+       of the second, if we know it.  We don't require a constant for\n+       this case; some cost analysis could be done if both are available\n+       but neither is constant.  For now, assume they're equally cheap.\n+\n+       If both strings have constant lengths, use the smaller.  This\n+       could arise if optimization results in strcpy being called with\n+       two fixed strings, or if the code was machine-generated.  We should\n+       add some code to the `memcmp' handler below to deal with such\n+       situations, someday.  */\n+    if (!len || TREE_CODE (len) != INTEGER_CST)\n+      {\n+\tif (len2)\n+\t  len = len2;\n+\telse if (len == 0)\n+\t  return 0;\n+      }\n+    else if (len2 && TREE_CODE (len2) == INTEGER_CST)\n+      {\n+\tif (tree_int_cst_lt (len2, len))\n+\t  len = len2;\n+      }\n+\n+    chainon (arglist, build_tree_list (NULL_TREE, len));\n+    result = expand_builtin_memcmp (exp, arglist, target);\n+    if (! result)\n+      TREE_CHAIN (TREE_CHAIN (arglist)) = 0;\n+    return result;\n+  }\n+}\n+#endif\n+\n+/* Expand expression EXP, which is a call to __builtin_saveregs,\n+   generating the result in TARGET, if that's convenient.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+static rtx\n+expand_builtin_saveregs (exp, target, ignore)\n+     tree exp;\n+     rtx target;\n+     int ignore;\n+{\n+  enum machine_mode value_mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  /* Don't do __builtin_saveregs more than once in a function.\n+     Save the result of the first call and reuse it.  */\n+  if (saveregs_value != 0)\n+    return saveregs_value;\n+  {\n+    /* When this function is called, it means that registers must be\n+       saved on entry to this function.  So we migrate the\n+       call to the first insn of this function.  */\n+    rtx temp;\n+    rtx seq;\n+\n+    /* Now really call the function.  `expand_call' does not call\n+       expand_builtin, so there is no danger of infinite recursion here.  */\n+    start_sequence ();\n+\n+#ifdef EXPAND_BUILTIN_SAVEREGS\n+    /* Do whatever the machine needs done in this case.  */\n+    temp = EXPAND_BUILTIN_SAVEREGS (arglist);\n+#else\n+    /* The register where the function returns its value\n+       is likely to have something else in it, such as an argument.\n+       So preserve that register around the call.  */\n+\n+    if (value_mode != VOIDmode)\n+      {\n+\trtx valreg = hard_libcall_value (value_mode);\n+\trtx saved_valreg = gen_reg_rtx (value_mode);\n+\n+\temit_move_insn (saved_valreg, valreg);\n+\ttemp = expand_call (exp, target, ignore);\n+\temit_move_insn (valreg, saved_valreg);\n+      }\n+    else\n+      /* Generate the call, putting the value in a pseudo.  */\n+      temp = expand_call (exp, target, ignore);\n+#endif\n+\n+    seq = get_insns ();\n+    end_sequence ();\n+\n+    saveregs_value = temp;\n+\n+    /* Put the sequence after the NOTE that starts the function.\n+       If this is inside a SEQUENCE, make the outer-level insn\n+       chain current, so the code is placed at the start of the\n+       function.  */\n+    push_topmost_sequence ();\n+    emit_insns_before (seq, NEXT_INSN (get_insns ()));\n+    pop_topmost_sequence ();\n+    return temp;\n+  }\n+}\n+\n+/* __builtin_args_info (N) returns word N of the arg space info\n+   for the current function.  The number and meanings of words\n+   is controlled by the definition of CUMULATIVE_ARGS.  */\n+static rtx\n+expand_builtin_args_info (exp)\n+     tree exp;\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  int nwords = sizeof (CUMULATIVE_ARGS) / sizeof (int);\n+  int *word_ptr = (int *) &current_function_args_info;\n+#if 0\t\n+  /* These are used by the code below that is if 0'ed away */\n+  int i;\n+  tree type, elts, result;\n+#endif\n+\n+  if (sizeof (CUMULATIVE_ARGS) % sizeof (int) != 0)\n+    fatal (\"CUMULATIVE_ARGS type defined badly; see %s, line %d\",\n+\t   __FILE__, __LINE__);\n+\n+  if (arglist != 0)\n+    {\n+      tree arg = TREE_VALUE (arglist);\n+      if (TREE_CODE (arg) != INTEGER_CST)\n+\terror (\"argument of `__builtin_args_info' must be constant\");\n+      else\n+\t{\n+\t  int wordnum = TREE_INT_CST_LOW (arg);\n+\n+\t  if (wordnum < 0 || wordnum >= nwords || TREE_INT_CST_HIGH (arg))\n+\t    error (\"argument of `__builtin_args_info' out of range\");\n+\t  else\n+\t    return GEN_INT (word_ptr[wordnum]);\n+\t}\n+    }\n+  else\n+    error (\"missing argument in `__builtin_args_info'\");\n+\n+  return const0_rtx;\n+\n+#if 0\n+  for (i = 0; i < nwords; i++)\n+    elts = tree_cons (NULL_TREE, build_int_2 (word_ptr[i], 0));\n+\n+  type = build_array_type (integer_type_node,\n+\t\t\t   build_index_type (build_int_2 (nwords, 0)));\n+  result = build (CONSTRUCTOR, type, NULL_TREE, nreverse (elts));\n+  TREE_CONSTANT (result) = 1;\n+  TREE_STATIC (result) = 1;\n+  result = build (INDIRECT_REF, build_pointer_type (type), result);\n+  TREE_CONSTANT (result) = 1;\n+  return expand_expr (result, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD);\n+#endif\n+}\n+\n+/* Expand expression EXP, which is a call to __builtin_next_arg.  */\n+static rtx\n+expand_builtin_next_arg (exp)\n+     tree exp;\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree fntype = TREE_TYPE (current_function_decl);\n+\n+  if ((TYPE_ARG_TYPES (fntype) == 0\n+       || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t   == void_type_node))\n+      && ! current_function_varargs)\n+    {\n+      error (\"`va_start' used in function with fixed args\");\n+      return const0_rtx;\n+    }\n+\n+  if (arglist)\n+    {\n+      tree last_parm = tree_last (DECL_ARGUMENTS (current_function_decl));\n+      tree arg = TREE_VALUE (arglist);\n+\n+      /* Strip off all nops for the sake of the comparison.  This\n+\t is not quite the same as STRIP_NOPS.  It does more.  \n+\t We must also strip off INDIRECT_EXPR for C++ reference\n+\t parameters.  */\n+      while (TREE_CODE (arg) == NOP_EXPR\n+\t     || TREE_CODE (arg) == CONVERT_EXPR\n+\t     || TREE_CODE (arg) == NON_LVALUE_EXPR\n+\t     || TREE_CODE (arg) == INDIRECT_REF)\n+\targ = TREE_OPERAND (arg, 0);\n+      if (arg != last_parm)\n+\twarning (\"second parameter of `va_start' not last named argument\");\n+    }\n+  else if (! current_function_varargs)\n+    /* Evidently an out of date version of <stdarg.h>; can't validate\n+       va_start's second argument, but can still work as intended.  */\n+    warning (\"`__builtin_next_arg' called without an argument\");\n+\n+  return expand_binop (Pmode, add_optab,\n+\t\t       current_function_internal_arg_pointer,\n+\t\t       current_function_arg_offset_rtx,\n+\t\t       NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+}\n+\n+/* Expand a call to one of the builtin functions __builtin_frame_address or\n+   __builtin_return_address.  */\n+static rtx\n+expand_builtin_frame_address (exp)\n+     tree exp;\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+\n+  /* The argument must be a nonnegative integer constant.\n+     It counts the number of frames to scan up the stack.\n+     The value is the return address saved in that frame.  */\n+  if (arglist == 0)\n+    /* Warning about missing arg was already issued.  */\n+    return const0_rtx;\n+  else if (TREE_CODE (TREE_VALUE (arglist)) != INTEGER_CST\n+\t   || tree_int_cst_sgn (TREE_VALUE (arglist)) < 0)\n+    {\n+      if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n+\terror (\"invalid arg to `__builtin_frame_address'\");\n+      else\n+\terror (\"invalid arg to `__builtin_return_address'\");\n+      return const0_rtx;\n+    }\n+  else\n+    {\n+      rtx tem = expand_builtin_return_addr (DECL_FUNCTION_CODE (fndecl),\n+\t\t\t\t\t    TREE_INT_CST_LOW (TREE_VALUE (arglist)),\n+\t\t\t\t\t    hard_frame_pointer_rtx);\n+\n+      /* Some ports cannot access arbitrary stack frames.  */\n+      if (tem == NULL)\n+\t{\n+\t  if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n+\t    warning (\"unsupported arg to `__builtin_frame_address'\");\n+\t  else\n+\t    warning (\"unsupported arg to `__builtin_return_address'\");\n+\t  return const0_rtx;\n+\t}\n+\n+      /* For __builtin_frame_address, return what we've got.  */\n+      if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n+\treturn tem;\n+\n+      if (GET_CODE (tem) != REG\n+\t  && ! CONSTANT_P (tem))\n+\ttem = copy_to_mode_reg (Pmode, tem);\n+      return tem;\n+    }\n+}\n+\n+/* Expand a call to the alloca builtin, with arguments ARGLIST.  Return 0 if\n+   we failed and the caller should emit a normal call, otherwise try to get\n+   the result in TARGET, if convenient.  */\n+static rtx\n+expand_builtin_alloca (arglist, target)\n+     tree arglist;\n+     rtx target;\n+{\n+  rtx op0;\n+\n+  if (arglist == 0\n+      /* Arg could be non-integer if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != INTEGER_TYPE)\n+    return 0;\n+\n+  /* Compute the argument.  */\n+  op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n+\n+  /* Allocate the desired space.  */\n+  return allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n+}\n+\n+/* Expand a call to the ffs builtin.  The arguments are in ARGLIST.\n+   Return 0 if a normal call should be emitted rather than expanding the\n+   function in-line.  If convenient, the result should be placed in TARGET.\n+   SUBTARGET may be used as the target for computing one of EXP's operands.  */\n+static rtx\n+expand_builtin_ffs (arglist, target, subtarget)\n+     tree arglist;\n+     rtx target, subtarget;\n+{\n+  rtx op0;\n+  if (arglist == 0\n+      /* Arg could be non-integer if user redeclared this fcn wrong.  */\n+      || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != INTEGER_TYPE)\n+    return 0;\n+\n+  /* Compute the argument.  */\n+  op0 = expand_expr (TREE_VALUE (arglist), subtarget, VOIDmode, 0);\n+  /* Compute ffs, into TARGET if possible.\n+     Set TARGET to wherever the result comes back.  */\n+  target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n+\t\t\tffs_optab, op0, target, 1);\n+  if (target == 0)\n+    abort ();\n+  return target;\n+}\n+\f\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+rtx\n+expand_builtin (exp, target, subtarget, mode, ignore)\n+     tree exp;\n+     rtx target;\n+     rtx subtarget;\n+     enum machine_mode mode;\n+     int ignore;\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  /* When not optimizing, generate calls to library functions for a certain\n+     set of builtins.  */\n+  if (! optimize && ! CALLED_AS_BUILT_IN (fndecl)\n+      && (fcode == BUILT_IN_SIN || fcode == BUILT_IN_COS\n+\t  || fcode == BUILT_IN_FSQRT || fcode == BUILT_IN_MEMSET\n+\t  || fcode == BUILT_IN_MEMCPY || fcode == BUILT_IN_MEMCMP\n+\t  || fcode == BUILT_IN_STRLEN || fcode == BUILT_IN_STRCPY\n+\t  || fcode == BUILT_IN_STRCMP || fcode == BUILT_IN_FFS))\n+    return expand_call (exp, target, ignore);\n+\n+  switch (fcode)\n+    {\n+    case BUILT_IN_ABS:\n+    case BUILT_IN_LABS:\n+    case BUILT_IN_FABS:\n+      /* build_function_call changes these into ABS_EXPR.  */\n+      abort ();\n+\n+    case BUILT_IN_SIN:\n+    case BUILT_IN_COS:\n+      /* Treat these like sqrt, but only if the user asks for them.  */\n+      if (! flag_fast_math)\n+\tbreak;\n+    case BUILT_IN_FSQRT:\n+      target = expand_builtin_mathfn (exp, target, subtarget);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_FMOD:\n+      break;\n+\n+    case BUILT_IN_APPLY_ARGS:\n+      return expand_builtin_apply_args ();\n+\n+      /* __builtin_apply (FUNCTION, ARGUMENTS, ARGSIZE) invokes\n+\t FUNCTION with a copy of the parameters described by\n+\t ARGUMENTS, and ARGSIZE.  It returns a block of memory\n+\t allocated on the stack into which is stored all the registers\n+\t that might possibly be used for returning the result of a\n+\t function.  ARGUMENTS is the value returned by\n+\t __builtin_apply_args.  ARGSIZE is the number of bytes of\n+\t arguments that must be copied.  ??? How should this value be\n+\t computed?  We'll also need a safe worst case value for varargs\n+\t functions.  */\n+    case BUILT_IN_APPLY:\n+      if (arglist == 0\n+\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+\t  || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n+\t  || TREE_CHAIN (arglist) == 0\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE\n+\t  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))))) != INTEGER_TYPE)\n+\treturn const0_rtx;\n+      else\n+\t{\n+\t  int i;\n+\t  tree t;\n+\t  rtx ops[3];\n+\n+\t  for (t = arglist, i = 0; t; t = TREE_CHAIN (t), i++)\n+\t    ops[i] = expand_expr (TREE_VALUE (t), NULL_RTX, VOIDmode, 0);\n+\n+\t  return expand_builtin_apply (ops[0], ops[1], ops[2]);\n+\t}\n+\n+      /* __builtin_return (RESULT) causes the function to return the\n+\t value described by RESULT.  RESULT is address of the block of\n+\t memory returned by __builtin_apply.  */\n+    case BUILT_IN_RETURN:\n+      if (arglist\n+\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+\t  && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE)\n+\texpand_builtin_return (expand_expr (TREE_VALUE (arglist),\n+\t\t\t\t\t    NULL_RTX, VOIDmode, 0));\n+      return const0_rtx;\n+\n+    case BUILT_IN_SAVEREGS:\n+      return expand_builtin_saveregs (exp, target, ignore);\n+\n+    case BUILT_IN_ARGS_INFO:\n+      return expand_builtin_args_info (exp);\n+\n+      /* Return the address of the first anonymous stack arg.  */\n+    case BUILT_IN_NEXT_ARG:\n+      return expand_builtin_next_arg (exp);\n+\n+    case BUILT_IN_CLASSIFY_TYPE:\n+      return expand_builtin_classify_type (arglist);\n+\n+    case BUILT_IN_CONSTANT_P:\n+      return expand_builtin_constant_p (exp);\n+\n+    case BUILT_IN_FRAME_ADDRESS:\n+    case BUILT_IN_RETURN_ADDRESS:\n+      return expand_builtin_frame_address (exp);\n+\n+    /* Returns the address of the area where the structure is returned.\n+       0 otherwise.  */\n+    case BUILT_IN_AGGREGATE_INCOMING_ADDRESS:\n+      if (arglist != 0\n+          || ! AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl)))\n+          || GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) != MEM)\n+        return const0_rtx;\n+      else\n+        return XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n+\n+    case BUILT_IN_ALLOCA:\n+      target = expand_builtin_alloca (arglist, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_FFS:\n+      target = expand_builtin_ffs (exp, target, subtarget);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_STRLEN:\n+      target = expand_builtin_strlen (exp, target, mode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_STRCPY:\n+      target = expand_builtin_strcpy (exp);\n+      if (target)\n+\treturn target;\n+      break;\n+      \n+    case BUILT_IN_MEMCPY:\n+      target = expand_builtin_memcpy (arglist);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_MEMSET:\n+      target = expand_builtin_memset (exp);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+/* These comparison functions need an instruction that returns an actual\n+   index.  An ordinary compare that just sets the condition codes\n+   is not enough.  */\n+#ifdef HAVE_cmpstrsi\n+    case BUILT_IN_STRCMP:\n+      target = expand_builtin_strcmp (exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_MEMCMP:\n+      target = expand_builtin_memcmp (exp, arglist, target);\n+      if (target)\n+\treturn target;\n+      break;\n+#else\n+    case BUILT_IN_STRCMP:\n+    case BUILT_IN_MEMCMP:\n+      break;\n+#endif\n+\n+    case BUILT_IN_SETJMP:\n+      if (arglist == 0\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n+\tbreak;\n+      else\n+\t{\n+\t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n+\t\t\t\t      VOIDmode, 0);\n+\t  rtx lab = gen_label_rtx ();\n+\t  rtx ret = expand_builtin_setjmp (buf_addr, target, lab, lab);\n+\t  emit_label (lab);\n+\t  return ret;\n+\t}\n+\n+      /* __builtin_longjmp is passed a pointer to an array of five words.\n+\t It's similar to the C library longjmp function but works with\n+\t __builtin_setjmp above.  */\n+    case BUILT_IN_LONGJMP:\n+      if (arglist == 0 || TREE_CHAIN (arglist) == 0\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n+\tbreak;\n+      else\n+\t{\n+\t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n+\t\t\t\t      VOIDmode, 0);\n+\t  rtx value = expand_expr (TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t\t   NULL_RTX, VOIDmode, 0);\n+\n+\t  if (value != const1_rtx)\n+\t    {\n+\t      error (\"__builtin_longjmp second argument must be 1\");\n+\t      return const0_rtx;\n+\t    }\n+\n+\t  expand_builtin_longjmp (buf_addr, value);\n+\t  return const0_rtx;\n+\t}\n+\n+    case BUILT_IN_TRAP:\n+#ifdef HAVE_trap\n+      if (HAVE_trap)\n+\temit_insn (gen_trap ());\n+      else\n+#endif\n+\terror (\"__builtin_trap not supported by this target\");\n+      emit_barrier ();\n+      return const0_rtx;\n+\n+      /* Various hooks for the DWARF 2 __throw routine.  */\n+    case BUILT_IN_UNWIND_INIT:\n+      expand_builtin_unwind_init ();\n+      return const0_rtx;\n+    case BUILT_IN_DWARF_CFA:\n+      return virtual_cfa_rtx;\n+#ifdef DWARF2_UNWIND_INFO\n+    case BUILT_IN_DWARF_FP_REGNUM:\n+      return expand_builtin_dwarf_fp_regnum ();\n+    case BUILT_IN_DWARF_REG_SIZE:\n+      return expand_builtin_dwarf_reg_size (TREE_VALUE (arglist), target);\n+#endif\n+    case BUILT_IN_FROB_RETURN_ADDR:\n+      return expand_builtin_frob_return_addr (TREE_VALUE (arglist));\n+    case BUILT_IN_EXTRACT_RETURN_ADDR:\n+      return expand_builtin_extract_return_addr (TREE_VALUE (arglist));\n+    case BUILT_IN_EH_RETURN:\n+      expand_builtin_eh_return (TREE_VALUE (arglist),\n+\t\t\t\tTREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t\tTREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))));\n+      return const0_rtx;\n+\n+    default:\t\t\t/* just do library call, if unknown builtin */\n+      error (\"built-in function `%s' not currently supported\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+    }\n+\n+  /* The switch statement above can drop through to cause the function\n+     to be called normally.  */\n+  return expand_call (exp, target, ignore);\n+}"}, {"sha": "8245cb8ce8eb8fca2a6438adf796bca00fcfce3d", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1948, "changes": 1949, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "patch": "@@ -104,14 +104,6 @@ int pending_stack_adjust;\n    NO_DEFER_POP and OK_DEFER_POP.  */\n int inhibit_defer_pop;\n \n-/* Nonzero means __builtin_saveregs has already been done in this function.\n-   The value is the pseudoreg containing the value __builtin_saveregs\n-   returned.  */\n-static rtx saveregs_value;\n-\n-/* Similarly for __builtin_apply_args.  */\n-static rtx apply_args_value;\n-\n /* Don't check memory usage, since code is being emitted to check a memory\n    usage.  Used when current_function_check_memory_usage is true, to avoid\n    infinite recursion.  */\n@@ -182,18 +174,6 @@ static tree init_noncopied_parts PROTO((tree, tree));\n static int safe_from_p\t\tPROTO((rtx, tree, int));\n static int fixed_type_p\t\tPROTO((tree));\n static rtx var_rtx\t\tPROTO((tree));\n-static int get_pointer_alignment PROTO((tree, unsigned));\n-static tree string_constant\tPROTO((tree, tree *));\n-static tree c_strlen\t\tPROTO((tree));\n-static rtx get_memory_rtx\tPROTO((tree));\n-static rtx expand_builtin\tPROTO((tree, rtx, rtx,\n-\t\t\t\t       enum machine_mode, int));\n-static int apply_args_size\tPROTO((void));\n-static int apply_result_size\tPROTO((void));\n-static rtx result_vector\tPROTO((int, rtx));\n-static rtx expand_builtin_apply_args PROTO((void));\n-static rtx expand_builtin_apply\tPROTO((rtx, rtx, rtx));\n-static void expand_builtin_return PROTO((rtx));\n static rtx expand_increment\tPROTO((tree, int, int));\n static void preexpand_calls\tPROTO((tree));\n static void do_jump_by_parts_greater PROTO((tree, int, rtx, rtx));\n@@ -239,14 +219,6 @@ enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n #ifndef SLOW_UNALIGNED_ACCESS\n #define SLOW_UNALIGNED_ACCESS STRICT_ALIGNMENT\n #endif\n-\n-/* Register mappings for target machines without register windows.  */\n-#ifndef INCOMING_REGNO\n-#define INCOMING_REGNO(OUT) (OUT)\n-#endif\n-#ifndef OUTGOING_REGNO\n-#define OUTGOING_REGNO(IN) (IN)\n-#endif\n \f\n /* This is run once per compilation to set up which modes can be used\n    directly in memory and to initialize the block move optab.  */\n@@ -8287,82 +8259,11 @@ expand_expr (exp, target, tmode, modifier)\n     abort ();\n   return temp;\n }\n-\n-\n-\f\n-/* Return the alignment in bits of EXP, a pointer valued expression.\n-   But don't return more than MAX_ALIGN no matter what.\n-   The alignment returned is, by default, the alignment of the thing that\n-   EXP points to (if it is not a POINTER_TYPE, 0 is returned).\n-\n-   Otherwise, look at the expression to see if we can do better, i.e., if the\n-   expression is actually pointing at an object whose alignment is tighter.  */\n-\n-static int\n-get_pointer_alignment (exp, max_align)\n-     tree exp;\n-     unsigned max_align;\n-{\n-  unsigned align, inner;\n-\n-  if (TREE_CODE (TREE_TYPE (exp)) != POINTER_TYPE)\n-    return 0;\n-\n-  align = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n-  align = MIN (align, max_align);\n-\n-  while (1)\n-    {\n-      switch (TREE_CODE (exp))\n-\t{\n-\tcase NOP_EXPR:\n-\tcase CONVERT_EXPR:\n-\tcase NON_LVALUE_EXPR:\n-\t  exp = TREE_OPERAND (exp, 0);\n-\t  if (TREE_CODE (TREE_TYPE (exp)) != POINTER_TYPE)\n-\t    return align;\n-\t  inner = TYPE_ALIGN (TREE_TYPE (TREE_TYPE (exp)));\n-\t  align = MIN (inner, max_align);\n-\t  break;\n-\n-\tcase PLUS_EXPR:\n-\t  /* If sum of pointer + int, restrict our maximum alignment to that\n-\t     imposed by the integer.  If not, we can't do any better than\n-\t     ALIGN.  */\n-\t  if (TREE_CODE (TREE_OPERAND (exp, 1)) != INTEGER_CST)\n-\t    return align;\n-\n-\t  while (((TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)) * BITS_PER_UNIT)\n-\t\t  & (max_align - 1))\n-\t\t != 0)\n-\t    max_align >>= 1;\n-\n-\t  exp = TREE_OPERAND (exp, 0);\n-\t  break;\n-\n-\tcase ADDR_EXPR:\n-\t  /* See what we are pointing at and look at its alignment.  */\n-\t  exp = TREE_OPERAND (exp, 0);\n-\t  if (TREE_CODE (exp) == FUNCTION_DECL)\n-\t    align = FUNCTION_BOUNDARY;\n-\t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd')\n-\t    align = DECL_ALIGN (exp);\n-#ifdef CONSTANT_ALIGNMENT\n-\t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')\n-\t    align = CONSTANT_ALIGNMENT (exp, align);\n-#endif\n-\t  return MIN (align, max_align);\n-\n-\tdefault:\n-\t  return align;\n-\t}\n-    }\n-}\n \f\n /* Return the tree node and offset if a given argument corresponds to\n    a string constant.  */\n \n-static tree\n+tree\n string_constant (arg, ptr_offset)\n      tree arg;\n      tree *ptr_offset;\n@@ -8399,1854 +8300,6 @@ string_constant (arg, ptr_offset)\n \n   return 0;\n }\n-\n-/* Compute the length of a C string.  TREE_STRING_LENGTH is not the right\n-   way, because it could contain a zero byte in the middle.\n-   TREE_STRING_LENGTH is the size of the character array, not the string.\n-\n-   Unfortunately, string_constant can't access the values of const char\n-   arrays with initializers, so neither can we do so here.  */\n-\n-static tree\n-c_strlen (src)\n-     tree src;\n-{\n-  tree offset_node;\n-  int offset, max;\n-  char *ptr;\n-\n-  src = string_constant (src, &offset_node);\n-  if (src == 0)\n-    return 0;\n-  max = TREE_STRING_LENGTH (src);\n-  ptr = TREE_STRING_POINTER (src);\n-  if (offset_node && TREE_CODE (offset_node) != INTEGER_CST)\n-    {\n-      /* If the string has an internal zero byte (e.g., \"foo\\0bar\"), we can't\n-\t compute the offset to the following null if we don't know where to\n-\t start searching for it.  */\n-      int i;\n-      for (i = 0; i < max; i++)\n-\tif (ptr[i] == 0)\n-\t  return 0;\n-      /* We don't know the starting offset, but we do know that the string\n-\t has no internal zero bytes.  We can assume that the offset falls\n-\t within the bounds of the string; otherwise, the programmer deserves\n-\t what he gets.  Subtract the offset from the length of the string,\n-\t and return that.  */\n-      /* This would perhaps not be valid if we were dealing with named\n-         arrays in addition to literal string constants.  */\n-      return size_binop (MINUS_EXPR, size_int (max), offset_node);\n-    }\n-\n-  /* We have a known offset into the string.  Start searching there for\n-     a null character.  */\n-  if (offset_node == 0)\n-    offset = 0;\n-  else\n-    {\n-      /* Did we get a long long offset?  If so, punt.  */\n-      if (TREE_INT_CST_HIGH (offset_node) != 0)\n-\treturn 0;\n-      offset = TREE_INT_CST_LOW (offset_node);\n-    }\n-  /* If the offset is known to be out of bounds, warn, and call strlen at\n-     runtime.  */\n-  if (offset < 0 || offset > max)\n-    {\n-      warning (\"offset outside bounds of constant string\");\n-      return 0;\n-    }\n-  /* Use strlen to search for the first zero byte.  Since any strings\n-     constructed with build_string will have nulls appended, we win even\n-     if we get handed something like (char[4])\"abcd\".\n-\n-     Since OFFSET is our starting index into the string, no further\n-     calculation is needed.  */\n-  return size_int (strlen (ptr + offset));\n-}\n-\n-rtx\n-expand_builtin_return_addr (fndecl_code, count, tem)\n-     enum built_in_function fndecl_code;\n-     int count;\n-     rtx tem;\n-{\n-  int i;\n-\n-  /* Some machines need special handling before we can access\n-     arbitrary frames.  For example, on the sparc, we must first flush\n-     all register windows to the stack.  */\n-#ifdef SETUP_FRAME_ADDRESSES\n-  if (count > 0)\n-    SETUP_FRAME_ADDRESSES ();\n-#endif\n-\n-  /* On the sparc, the return address is not in the frame, it is in a\n-     register.  There is no way to access it off of the current frame\n-     pointer, but it can be accessed off the previous frame pointer by\n-     reading the value from the register window save area.  */\n-#ifdef RETURN_ADDR_IN_PREVIOUS_FRAME\n-  if (fndecl_code == BUILT_IN_RETURN_ADDRESS)\n-    count--;\n-#endif\n-\n-  /* Scan back COUNT frames to the specified frame.  */\n-  for (i = 0; i < count; i++)\n-    {\n-      /* Assume the dynamic chain pointer is in the word that the\n-\t frame address points to, unless otherwise specified.  */\n-#ifdef DYNAMIC_CHAIN_ADDRESS\n-      tem = DYNAMIC_CHAIN_ADDRESS (tem);\n-#endif\n-      tem = memory_address (Pmode, tem);\n-      tem = copy_to_reg (gen_rtx_MEM (Pmode, tem));\n-    }\n-\n-  /* For __builtin_frame_address, return what we've got.  */\n-  if (fndecl_code == BUILT_IN_FRAME_ADDRESS)\n-    return tem;\n-\n-  /* For __builtin_return_address, Get the return address from that\n-     frame.  */\n-#ifdef RETURN_ADDR_RTX\n-  tem = RETURN_ADDR_RTX (count, tem);\n-#else\n-  tem = memory_address (Pmode,\n-\t\t\tplus_constant (tem, GET_MODE_SIZE (Pmode)));\n-  tem = gen_rtx_MEM (Pmode, tem);\n-#endif\n-  return tem;\n-}\n-\n-/* __builtin_setjmp is passed a pointer to an array of five words (not\n-   all will be used on all machines).  It operates similarly to the C\n-   library function of the same name, but is more efficient.  Much of\n-   the code below (and for longjmp) is copied from the handling of\n-   non-local gotos.\n-\n-   NOTE: This is intended for use by GNAT and the exception handling\n-   scheme in the compiler and will only work in the method used by\n-   them.  */\n-\n-rtx\n-expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n-     rtx buf_addr;\n-     rtx target;\n-     rtx first_label, next_label;\n-{\n-  rtx lab1 = gen_label_rtx ();\n-  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n-  enum machine_mode value_mode;\n-  rtx stack_save;\n-\n-  value_mode = TYPE_MODE (integer_type_node);\n-\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-  buf_addr = convert_memory_address (Pmode, buf_addr);\n-#endif\n-\n-  buf_addr = force_reg (Pmode, buf_addr);\n-\n-  if (target == 0 || GET_CODE (target) != REG\n-      || REGNO (target) < FIRST_PSEUDO_REGISTER)\n-    target = gen_reg_rtx (value_mode);\n-\n-  emit_queue ();\n-\n-  /* We store the frame pointer and the address of lab1 in the buffer\n-     and use the rest of it for the stack save area, which is\n-     machine-dependent.  */\n-\n-#ifndef BUILTIN_SETJMP_FRAME_VALUE\n-#define BUILTIN_SETJMP_FRAME_VALUE virtual_stack_vars_rtx\n-#endif\n-\n-  emit_move_insn (gen_rtx_MEM (Pmode, buf_addr),\n-\t\t  BUILTIN_SETJMP_FRAME_VALUE);\n-  emit_move_insn (validize_mem\n-\t\t  (gen_rtx_MEM (Pmode,\n-\t\t\t\tplus_constant (buf_addr,\n-\t\t\t\t\t       GET_MODE_SIZE (Pmode)))),\n-\t\t  force_reg (Pmode, gen_rtx_LABEL_REF (Pmode, lab1)));\n-\n-  stack_save = gen_rtx_MEM (sa_mode,\n-\t\t\t    plus_constant (buf_addr,\n-\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n-  emit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n-\n-  /* If there is further processing to do, do it.  */\n-#ifdef HAVE_builtin_setjmp_setup\n-  if (HAVE_builtin_setjmp_setup)\n-    emit_insn (gen_builtin_setjmp_setup (buf_addr));\n-#endif\n-\n-  /* Set TARGET to zero and branch to the first-time-through label.  */\n-  emit_move_insn (target, const0_rtx);\n-  emit_jump_insn (gen_jump (first_label));\n-  emit_barrier ();\n-  emit_label (lab1);\n-\n-  /* Tell flow about the strange goings on.  Putting `lab1' on\n-     `nonlocal_goto_handler_labels' to indicates that function\n-     calls may traverse the arc back to this label.  */\n-\n-  current_function_has_nonlocal_label = 1;\n-  nonlocal_goto_handler_labels =\n-    gen_rtx_EXPR_LIST (VOIDmode, lab1, nonlocal_goto_handler_labels);\n-\n-  /* Clobber the FP when we get here, so we have to make sure it's\n-     marked as used by this function.  */\n-  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n-\n-  /* Mark the static chain as clobbered here so life information\n-     doesn't get messed up for it.  */\n-  emit_insn (gen_rtx_CLOBBER (VOIDmode, static_chain_rtx));\n-\n-  /* Now put in the code to restore the frame pointer, and argument\n-     pointer, if needed.  The code below is from expand_end_bindings\n-     in stmt.c; see detailed documentation there.  */\n-#ifdef HAVE_nonlocal_goto\n-  if (! HAVE_nonlocal_goto)\n-#endif\n-    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n-\n-#if ARG_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-  if (fixed_regs[ARG_POINTER_REGNUM])\n-    {\n-#ifdef ELIMINABLE_REGS\n-      size_t i;\n-      static struct elims {int from, to;} elim_regs[] = ELIMINABLE_REGS;\n-\n-      for (i = 0; i < sizeof elim_regs / sizeof elim_regs[0]; i++)\n-\tif (elim_regs[i].from == ARG_POINTER_REGNUM\n-\t    && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n-\t  break;\n-\n-      if (i == sizeof elim_regs / sizeof elim_regs [0])\n-#endif\n-\t{\n-\t  /* Now restore our arg pointer from the address at which it\n-\t     was saved in our stack frame.\n-\t     If there hasn't be space allocated for it yet, make\n-\t     some now.  */\n-\t  if (arg_pointer_save_area == 0)\n-\t    arg_pointer_save_area\n-\t      = assign_stack_local (Pmode, GET_MODE_SIZE (Pmode), 0);\n-\t  emit_move_insn (virtual_incoming_args_rtx,\n-\t\t\t  copy_to_reg (arg_pointer_save_area));\n-\t}\n-    }\n-#endif\n-\n-#ifdef HAVE_builtin_setjmp_receiver\n-  if (HAVE_builtin_setjmp_receiver)\n-    emit_insn (gen_builtin_setjmp_receiver (lab1));\n-  else\n-#endif\n-#ifdef HAVE_nonlocal_goto_receiver\n-    if (HAVE_nonlocal_goto_receiver)\n-      emit_insn (gen_nonlocal_goto_receiver ());\n-    else\n-#endif\n-      {\n-\t; /* Nothing */\n-      }\n-\n-  /* Set TARGET, and branch to the next-time-through label.  */\n-  emit_move_insn (target, const1_rtx);\n-  emit_jump_insn (gen_jump (next_label));\n-  emit_barrier ();\n-\n-  return target;\n-}\n-\n-void\n-expand_builtin_longjmp (buf_addr, value)\n-     rtx buf_addr, value;\n-{\n-  rtx fp, lab, stack;\n-  enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n-\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-  buf_addr = convert_memory_address (Pmode, buf_addr);\n-#endif\n-  buf_addr = force_reg (Pmode, buf_addr);\n-\n-  /* We used to store value in static_chain_rtx, but that fails if pointers\n-     are smaller than integers.  We instead require that the user must pass\n-     a second argument of 1, because that is what builtin_setjmp will\n-     return.  This also makes EH slightly more efficient, since we are no\n-     longer copying around a value that we don't care about.  */\n-  if (value != const1_rtx)\n-    abort ();\n-\n-#ifdef HAVE_builtin_longjmp\n-  if (HAVE_builtin_longjmp)\n-    emit_insn (gen_builtin_longjmp (buf_addr));\n-  else\n-#endif\n-    {\n-      fp = gen_rtx_MEM (Pmode, buf_addr);\n-      lab = gen_rtx_MEM (Pmode, plus_constant (buf_addr,\n-\t\t\t\t\t       GET_MODE_SIZE (Pmode)));\n-\n-      stack = gen_rtx_MEM (sa_mode, plus_constant (buf_addr,\n-\t\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n-\n-      /* Pick up FP, label, and SP from the block and jump.  This code is\n-\t from expand_goto in stmt.c; see there for detailed comments.  */\n-#if HAVE_nonlocal_goto\n-      if (HAVE_nonlocal_goto)\n-\t/* We have to pass a value to the nonlocal_goto pattern that will\n-\t   get copied into the static_chain pointer, but it does not matter\n-\t   what that value is, because builtin_setjmp does not use it.  */\n-\temit_insn (gen_nonlocal_goto (value, fp, stack, lab));\n-      else\n-#endif\n-\t{\n-\t  lab = copy_to_reg (lab);\n-\n-\t  emit_move_insn (hard_frame_pointer_rtx, fp);\n-\t  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n-\n-\t  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n-\t  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n-\t  emit_indirect_jump (lab);\n-\t}\n-    }\n-}\n-\n-static rtx\n-get_memory_rtx (exp)\n-     tree exp;\n-{\n-  rtx mem;\n-  int is_aggregate;\n-\n-  mem = gen_rtx_MEM (BLKmode,\n-\t\t     memory_address (BLKmode,\n-\t\t\t\t     expand_expr (exp, NULL_RTX,\n-\t\t\t\t\t\t  ptr_mode, EXPAND_SUM)));\n-\n-  RTX_UNCHANGING_P (mem) = TREE_READONLY (exp);\n-\n-  /* Figure out the type of the object pointed to.  Set MEM_IN_STRUCT_P\n-     if the value is the address of a structure or if the expression is\n-     cast to a pointer to structure type.  */\n-  is_aggregate = 0;\n-\n-  while (TREE_CODE (exp) == NOP_EXPR)\n-    {\n-      tree cast_type = TREE_TYPE (exp);\n-      if (TREE_CODE (cast_type) == POINTER_TYPE\n-\t  && AGGREGATE_TYPE_P (TREE_TYPE (cast_type)))\n-\t{\n-\t  is_aggregate = 1;\n-\t  break;\n-\t}\n-      exp = TREE_OPERAND (exp, 0);\n-    }\n-\n-  if (is_aggregate == 0)\n-    {\n-      tree type;\n-\n-      if (TREE_CODE (exp) == ADDR_EXPR)\n-\t/* If this is the address of an object, check whether the\n-\t   object is an array.  */\n-\ttype = TREE_TYPE (TREE_OPERAND (exp, 0));\n-      else\n-\ttype = TREE_TYPE (TREE_TYPE (exp));\n-      is_aggregate = AGGREGATE_TYPE_P (type);\n-    }\n-\n-  MEM_SET_IN_STRUCT_P (mem, is_aggregate);\n-  return mem;\n-}\n-\n-\f\n-/* Expand an expression EXP that calls a built-in function,\n-   with result going to TARGET if that's convenient\n-   (and in mode MODE if that's convenient).\n-   SUBTARGET may be used as the target for computing one of EXP's operands.\n-   IGNORE is nonzero if the value is to be ignored.  */\n-\n-#define CALLED_AS_BUILT_IN(NODE) \\\n-   (!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), \"__builtin_\", 10))\n-\n-static rtx\n-expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget;\n-     enum machine_mode mode;\n-     int ignore;\n-{\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  rtx op0;\n-  rtx lab1, insns;\n-  enum machine_mode value_mode = TYPE_MODE (TREE_TYPE (exp));\n-  optab builtin_optab;\n-\n-  switch (DECL_FUNCTION_CODE (fndecl))\n-    {\n-    case BUILT_IN_ABS:\n-    case BUILT_IN_LABS:\n-    case BUILT_IN_FABS:\n-      /* build_function_call changes these into ABS_EXPR.  */\n-      abort ();\n-\n-    case BUILT_IN_SIN:\n-    case BUILT_IN_COS:\n-      /* Treat these like sqrt, but only if the user asks for them.  */\n-      if (! flag_fast_math)\n-\tbreak;\n-    case BUILT_IN_FSQRT:\n-      /* If not optimizing, call the library function.  */\n-      if (! optimize)\n-\tbreak;\n-\n-      if (arglist == 0\n-\t  /* Arg could be wrong type if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != REAL_TYPE)\n-\tbreak;\n-\n-      /* Stabilize and compute the argument.  */\n-      if (TREE_CODE (TREE_VALUE (arglist)) != VAR_DECL\n-\t  && TREE_CODE (TREE_VALUE (arglist)) != PARM_DECL)\n-\t{\n-\t  exp = copy_node (exp);\n-\t  arglist = copy_node (arglist);\n-\t  TREE_OPERAND (exp, 1) = arglist;\n-\t  TREE_VALUE (arglist) = save_expr (TREE_VALUE (arglist));\n-\t}\n-      op0 = expand_expr (TREE_VALUE (arglist), subtarget, VOIDmode, 0);\n-\n-      /* Make a suitable register to place result in.  */\n-      target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n-\n-      emit_queue ();\n-      start_sequence ();\n-\n-      switch (DECL_FUNCTION_CODE (fndecl))\n-\t{\n-\tcase BUILT_IN_SIN:\n-\t  builtin_optab = sin_optab; break;\n-\tcase BUILT_IN_COS:\n-\t  builtin_optab = cos_optab; break;\n-\tcase BUILT_IN_FSQRT:\n-\t  builtin_optab = sqrt_optab; break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-      /* Compute into TARGET.\n-\t Set TARGET to wherever the result comes back.  */\n-      target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n-\t\t\t    builtin_optab, op0, target, 0);\n-\n-      /* If we were unable to expand via the builtin, stop the\n-\t sequence (without outputting the insns) and break, causing\n-\t a call to the library function.  */\n-      if (target == 0)\n-\t{\n-\t  end_sequence ();\n-\t  break;\n-        }\n-\n-      /* Check the results by default.  But if flag_fast_math is turned on,\n-\t then assume sqrt will always be called with valid arguments.  */\n-\n-      if (flag_errno_math && ! flag_fast_math)\n-\t{\n-\t  /* Don't define the builtin FP instructions\n-\t     if your machine is not IEEE.  */\n-\t  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n-\t    abort ();\n-\n-\t  lab1 = gen_label_rtx ();\n-\n-\t  /* Test the result; if it is NaN, set errno=EDOM because\n-\t     the argument was not in the domain.  */\n-\t  emit_cmp_and_jump_insns (target, target, EQ, 0, GET_MODE (target),\n-\t\t\t\t   0, 0, lab1);\n-\n-#ifdef TARGET_EDOM\n-\t  {\n-#ifdef GEN_ERRNO_RTX\n-\t    rtx errno_rtx = GEN_ERRNO_RTX;\n-#else\n-\t    rtx errno_rtx\n-\t      = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n-#endif\n-\n-\t    emit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n-\t  }\n-#else\n-\t  /* We can't set errno=EDOM directly; let the library call do it.\n-\t     Pop the arguments right away in case the call gets deleted.  */\n-\t  NO_DEFER_POP;\n-\t  expand_call (exp, target, 0);\n-\t  OK_DEFER_POP;\n-#endif\n-\n-\t  emit_label (lab1);\n-\t}\n-\n-      /* Output the entire sequence.  */\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_insns (insns);\n- \n-      return target;\n-\n-    case BUILT_IN_FMOD:\n-      break;\n-\n-      /* __builtin_apply_args returns block of memory allocated on\n-\t the stack into which is stored the arg pointer, structure\n-\t value address, static chain, and all the registers that might\n-\t possibly be used in performing a function call.  The code is\n-\t moved to the start of the function so the incoming values are\n-\t saved.  */\n-    case BUILT_IN_APPLY_ARGS:\n-      /* Don't do __builtin_apply_args more than once in a function.\n-\t Save the result of the first call and reuse it.  */\n-      if (apply_args_value != 0)\n-\treturn apply_args_value;\n-      {\n-\t/* When this function is called, it means that registers must be\n-\t   saved on entry to this function.  So we migrate the\n-\t   call to the first insn of this function.  */\n-\trtx temp;\n-\trtx seq;\n-\n-\tstart_sequence ();\n-\ttemp = expand_builtin_apply_args ();\n-\tseq = get_insns ();\n-\tend_sequence ();\n-\n-\tapply_args_value = temp;\n-\n-\t/* Put the sequence after the NOTE that starts the function.\n-\t   If this is inside a SEQUENCE, make the outer-level insn\n-\t   chain current, so the code is placed at the start of the\n-\t   function.  */\n-\tpush_topmost_sequence ();\n-\temit_insns_before (seq, NEXT_INSN (get_insns ()));\n-\tpop_topmost_sequence ();\n-\treturn temp;\n-      }\n-\n-      /* __builtin_apply (FUNCTION, ARGUMENTS, ARGSIZE) invokes\n-\t FUNCTION with a copy of the parameters described by\n-\t ARGUMENTS, and ARGSIZE.  It returns a block of memory\n-\t allocated on the stack into which is stored all the registers\n-\t that might possibly be used for returning the result of a\n-\t function.  ARGUMENTS is the value returned by\n-\t __builtin_apply_args.  ARGSIZE is the number of bytes of\n-\t arguments that must be copied.  ??? How should this value be\n-\t computed?  We'll also need a safe worst case value for varargs\n-\t functions.  */\n-    case BUILT_IN_APPLY:\n-      if (arglist == 0\n-\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n-\t  || TREE_CHAIN (arglist) == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE\n-\t  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))))) != INTEGER_TYPE)\n-\treturn const0_rtx;\n-      else\n-\t{\n-\t  int i;\n-\t  tree t;\n-\t  rtx ops[3];\n-\n-\t  for (t = arglist, i = 0; t; t = TREE_CHAIN (t), i++)\n-\t    ops[i] = expand_expr (TREE_VALUE (t), NULL_RTX, VOIDmode, 0);\n-\n-\t  return expand_builtin_apply (ops[0], ops[1], ops[2]);\n-\t}\n-\n-      /* __builtin_return (RESULT) causes the function to return the\n-\t value described by RESULT.  RESULT is address of the block of\n-\t memory returned by __builtin_apply.  */\n-    case BUILT_IN_RETURN:\n-      if (arglist\n-\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE)\n-\texpand_builtin_return (expand_expr (TREE_VALUE (arglist),\n-\t\t\t\t\t    NULL_RTX, VOIDmode, 0));\n-      return const0_rtx;\n-\n-    case BUILT_IN_SAVEREGS:\n-      /* Don't do __builtin_saveregs more than once in a function.\n-\t Save the result of the first call and reuse it.  */\n-      if (saveregs_value != 0)\n-\treturn saveregs_value;\n-      {\n-\t/* When this function is called, it means that registers must be\n-\t   saved on entry to this function.  So we migrate the\n-\t   call to the first insn of this function.  */\n-\trtx temp;\n-\trtx seq;\n-\n-\t/* Now really call the function.  `expand_call' does not call\n-\t   expand_builtin, so there is no danger of infinite recursion here.  */\n-\tstart_sequence ();\n-\n-#ifdef EXPAND_BUILTIN_SAVEREGS\n-\t/* Do whatever the machine needs done in this case.  */\n-\ttemp = EXPAND_BUILTIN_SAVEREGS (arglist);\n-#else\n-\t/* The register where the function returns its value\n-\t   is likely to have something else in it, such as an argument.\n-\t   So preserve that register around the call.  */\n-\n-\tif (value_mode != VOIDmode)\n-\t  {\n-\t    rtx valreg = hard_libcall_value (value_mode);\n-\t    rtx saved_valreg = gen_reg_rtx (value_mode);\n-\n-\t    emit_move_insn (saved_valreg, valreg);\n-\t    temp = expand_call (exp, target, ignore);\n-\t    emit_move_insn (valreg, saved_valreg);\n-\t  }\n-\telse\n-\t  /* Generate the call, putting the value in a pseudo.  */\n-\t  temp = expand_call (exp, target, ignore);\n-#endif\n-\n-\tseq = get_insns ();\n-\tend_sequence ();\n-\n-\tsaveregs_value = temp;\n-\n-\t/* Put the sequence after the NOTE that starts the function.\n-\t   If this is inside a SEQUENCE, make the outer-level insn\n-\t   chain current, so the code is placed at the start of the\n-\t   function.  */\n-\tpush_topmost_sequence ();\n-\temit_insns_before (seq, NEXT_INSN (get_insns ()));\n-\tpop_topmost_sequence ();\n-\treturn temp;\n-      }\n-\n-      /* __builtin_args_info (N) returns word N of the arg space info\n-\t for the current function.  The number and meanings of words\n-\t is controlled by the definition of CUMULATIVE_ARGS.  */\n-    case BUILT_IN_ARGS_INFO:\n-      {\n-\tint nwords = sizeof (CUMULATIVE_ARGS) / sizeof (int);\n-\tint *word_ptr = (int *) &current_function_args_info;\n-#if 0\t\n-\t/* These are used by the code below that is if 0'ed away */\n-\tint i;\n-\ttree type, elts, result;\n-#endif\n-\n-\tif (sizeof (CUMULATIVE_ARGS) % sizeof (int) != 0)\n-\t  fatal (\"CUMULATIVE_ARGS type defined badly; see %s, line %d\",\n-\t\t __FILE__, __LINE__);\n-\n-\tif (arglist != 0)\n-\t  {\n-\t    tree arg = TREE_VALUE (arglist);\n-\t    if (TREE_CODE (arg) != INTEGER_CST)\n-\t      error (\"argument of `__builtin_args_info' must be constant\");\n-\t    else\n-\t      {\n-\t\tint wordnum = TREE_INT_CST_LOW (arg);\n-\n-\t\tif (wordnum < 0 || wordnum >= nwords || TREE_INT_CST_HIGH (arg))\n-\t\t  error (\"argument of `__builtin_args_info' out of range\");\n-\t\telse\n-\t\t  return GEN_INT (word_ptr[wordnum]);\n-\t      }\n-\t  }\n-\telse\n-\t  error (\"missing argument in `__builtin_args_info'\");\n-\n-\treturn const0_rtx;\n-\n-#if 0\n-\tfor (i = 0; i < nwords; i++)\n-\t  elts = tree_cons (NULL_TREE, build_int_2 (word_ptr[i], 0));\n-\n-\ttype = build_array_type (integer_type_node,\n-\t\t\t\t build_index_type (build_int_2 (nwords, 0)));\n-\tresult = build (CONSTRUCTOR, type, NULL_TREE, nreverse (elts));\n-\tTREE_CONSTANT (result) = 1;\n-\tTREE_STATIC (result) = 1;\n-\tresult = build (INDIRECT_REF, build_pointer_type (type), result);\n-\tTREE_CONSTANT (result) = 1;\n-\treturn expand_expr (result, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_BAD);\n-#endif\n-      }\n-\n-      /* Return the address of the first anonymous stack arg.  */\n-    case BUILT_IN_NEXT_ARG:\n-      {\n-\ttree fntype = TREE_TYPE (current_function_decl);\n-\n-\tif ((TYPE_ARG_TYPES (fntype) == 0\n-\t     || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n-\t\t == void_type_node))\n-\t    && ! current_function_varargs)\n-\t  {\n-\t    error (\"`va_start' used in function with fixed args\");\n-\t    return const0_rtx;\n-\t  }\n-\n-\tif (arglist)\n-\t  {\n-\t    tree last_parm = tree_last (DECL_ARGUMENTS (current_function_decl));\n-\t    tree arg = TREE_VALUE (arglist);\n-\n-\t    /* Strip off all nops for the sake of the comparison.  This\n-\t       is not quite the same as STRIP_NOPS.  It does more.  \n-\t       We must also strip off INDIRECT_EXPR for C++ reference\n-\t       parameters.  */\n-\t    while (TREE_CODE (arg) == NOP_EXPR\n-\t\t   || TREE_CODE (arg) == CONVERT_EXPR\n-\t\t   || TREE_CODE (arg) == NON_LVALUE_EXPR\n-\t\t   || TREE_CODE (arg) == INDIRECT_REF)\n-\t      arg = TREE_OPERAND (arg, 0);\n-\t    if (arg != last_parm)\n-\t      warning (\"second parameter of `va_start' not last named argument\");\n-\t  }\n-\telse if (! current_function_varargs)\n-\t  /* Evidently an out of date version of <stdarg.h>; can't validate\n-\t     va_start's second argument, but can still work as intended.  */\n-\t  warning (\"`__builtin_next_arg' called without an argument\");\n-      }\n-\n-      return expand_binop (Pmode, add_optab,\n-\t\t\t   current_function_internal_arg_pointer,\n-\t\t\t   current_function_arg_offset_rtx,\n-\t\t\t   NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\n-    case BUILT_IN_CLASSIFY_TYPE:\n-      if (arglist != 0)\n-\t{\n-\t  tree type = TREE_TYPE (TREE_VALUE (arglist));\n-\t  enum tree_code code = TREE_CODE (type);\n-\t  if (code == VOID_TYPE)\n-\t    return GEN_INT (void_type_class);\n-\t  if (code == INTEGER_TYPE)\n-\t    return GEN_INT (integer_type_class);\n-\t  if (code == CHAR_TYPE)\n-\t    return GEN_INT (char_type_class);\n-\t  if (code == ENUMERAL_TYPE)\n-\t    return GEN_INT (enumeral_type_class);\n-\t  if (code == BOOLEAN_TYPE)\n-\t    return GEN_INT (boolean_type_class);\n-\t  if (code == POINTER_TYPE)\n-\t    return GEN_INT (pointer_type_class);\n-\t  if (code == REFERENCE_TYPE)\n-\t    return GEN_INT (reference_type_class);\n-\t  if (code == OFFSET_TYPE)\n-\t    return GEN_INT (offset_type_class);\n-\t  if (code == REAL_TYPE)\n-\t    return GEN_INT (real_type_class);\n-\t  if (code == COMPLEX_TYPE)\n-\t    return GEN_INT (complex_type_class);\n-\t  if (code == FUNCTION_TYPE)\n-\t    return GEN_INT (function_type_class);\n-\t  if (code == METHOD_TYPE)\n-\t    return GEN_INT (method_type_class);\n-\t  if (code == RECORD_TYPE)\n-\t    return GEN_INT (record_type_class);\n-\t  if (code == UNION_TYPE || code == QUAL_UNION_TYPE)\n-\t    return GEN_INT (union_type_class);\n-\t  if (code == ARRAY_TYPE)\n-\t    {\n-\t      if (TYPE_STRING_FLAG (type))\n-\t\treturn GEN_INT (string_type_class);\n-\t      else\n-\t\treturn GEN_INT (array_type_class);\n-\t    }\n-\t  if (code == SET_TYPE)\n-\t    return GEN_INT (set_type_class);\n-\t  if (code == FILE_TYPE)\n-\t    return GEN_INT (file_type_class);\n-\t  if (code == LANG_TYPE)\n-\t    return GEN_INT (lang_type_class);\n-\t}\n-      return GEN_INT (no_type_class);\n-\n-    case BUILT_IN_CONSTANT_P:\n-      if (arglist == 0)\n-\treturn const0_rtx;\n-      else\n-\t{\n-\t  tree arg = TREE_VALUE (arglist);\n-\t  rtx tmp;\n-\n-\t  /* We return 1 for a numeric type that's known to be a constant\n-\t     value at compile-time or for an aggregate type that's a\n-\t     literal constant.  */\n-\t  STRIP_NOPS (arg);\n-\n-\t  /* If we know this is a constant, emit the constant of one.  */\n-\t  if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'c'\n-\t      || (TREE_CODE (arg) == CONSTRUCTOR\n-\t\t  && TREE_CONSTANT (arg))\n-\t      || (TREE_CODE (arg) == ADDR_EXPR\n-\t\t  && TREE_CODE (TREE_OPERAND (arg, 0)) == STRING_CST))\n-\t    return const1_rtx;\n-\n-\t  /* If we aren't going to be running CSE or this expression\n-\t     has side effects, show we don't know it to be a constant.\n-\t     Likewise if it's a pointer or aggregate type since in those\n-\t     case we only want literals, since those are only optimized\n-\t     when generating RTL, not later.  */\n-\t  if (TREE_SIDE_EFFECTS (arg) || cse_not_expected\n-\t      || AGGREGATE_TYPE_P (TREE_TYPE (arg))\n-\t      || POINTER_TYPE_P (TREE_TYPE (arg)))\n-\t    return const0_rtx;\n-\n-\t  /* Otherwise, emit (constant_p_rtx (ARG)) and let CSE get a\n-\t     chance to see if it can deduce whether ARG is constant.  */\n-\n-\t  tmp = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n-\t  tmp = gen_rtx_CONSTANT_P_RTX (value_mode, tmp);\n-\t  return tmp;\n-\t}\n-\n-    case BUILT_IN_FRAME_ADDRESS:\n-      /* The argument must be a nonnegative integer constant.\n-\t It counts the number of frames to scan up the stack.\n-\t The value is the address of that frame.  */\n-    case BUILT_IN_RETURN_ADDRESS:\n-      /* The argument must be a nonnegative integer constant.\n-\t It counts the number of frames to scan up the stack.\n-\t The value is the return address saved in that frame.  */\n-      if (arglist == 0)\n-\t/* Warning about missing arg was already issued.  */\n-\treturn const0_rtx;\n-      else if (TREE_CODE (TREE_VALUE (arglist)) != INTEGER_CST\n-\t       || tree_int_cst_sgn (TREE_VALUE (arglist)) < 0)\n-\t{\n-\t  if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n-\t    error (\"invalid arg to `__builtin_frame_address'\");\n-\t  else\n-\t    error (\"invalid arg to `__builtin_return_address'\");\n-\t  return const0_rtx;\n-\t}\n-      else\n-\t{\n-\t  rtx tem = expand_builtin_return_addr (DECL_FUNCTION_CODE (fndecl),\n-\t\t\t\t\t\tTREE_INT_CST_LOW (TREE_VALUE (arglist)),\n-\t\t\t\t\t\thard_frame_pointer_rtx);\n-\n-\t  /* Some ports cannot access arbitrary stack frames.  */\n-\t  if (tem == NULL)\n-\t    {\n-\t      if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n-\t\twarning (\"unsupported arg to `__builtin_frame_address'\");\n-\t      else\n-\t\twarning (\"unsupported arg to `__builtin_return_address'\");\n-\t      return const0_rtx;\n-\t    }\n-\n-\t  /* For __builtin_frame_address, return what we've got.  */\n-\t  if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_FRAME_ADDRESS)\n-\t    return tem;\n-\n-\t  if (GET_CODE (tem) != REG\n-\t      && ! CONSTANT_P (tem))\n-\t    tem = copy_to_mode_reg (Pmode, tem);\n-\t  return tem;\n-\t}\n-\n-    /* Returns the address of the area where the structure is returned.\n-       0 otherwise.  */\n-    case BUILT_IN_AGGREGATE_INCOMING_ADDRESS:\n-      if (arglist != 0\n-          || ! AGGREGATE_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl)))\n-          || GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) != MEM)\n-        return const0_rtx;\n-      else\n-        return XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n-\n-    case BUILT_IN_ALLOCA:\n-      if (arglist == 0\n-\t  /* Arg could be non-integer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != INTEGER_TYPE)\n-\tbreak;\n-\n-      /* Compute the argument.  */\n-      op0 = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n-\n-      /* Allocate the desired space.  */\n-      return allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT);\n-\n-    case BUILT_IN_FFS:\n-      /* If not optimizing, call the library function.  */\n-      if (!optimize && ! CALLED_AS_BUILT_IN (fndecl))\n-\tbreak;\n-\n-      if (arglist == 0\n-\t  /* Arg could be non-integer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != INTEGER_TYPE)\n-\tbreak;\n-\n-      /* Compute the argument.  */\n-      op0 = expand_expr (TREE_VALUE (arglist), subtarget, VOIDmode, 0);\n-      /* Compute ffs, into TARGET if possible.\n-\t Set TARGET to wherever the result comes back.  */\n-      target = expand_unop (TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist))),\n-\t\t\t    ffs_optab, op0, target, 1);\n-      if (target == 0)\n-\tabort ();\n-      return target;\n-\n-    case BUILT_IN_STRLEN:\n-      /* If not optimizing, call the library function.  */\n-      if (!optimize && ! CALLED_AS_BUILT_IN (fndecl))\n-\tbreak;\n-\n-      if (arglist == 0\n-\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n-\tbreak;\n-      else\n-\t{\n-\t  tree src = TREE_VALUE (arglist);\n-\t  tree len = c_strlen (src);\n-\n-\t  int align\n-\t    = get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-\n-\t  rtx result, src_rtx, char_rtx;\n-\t  enum machine_mode insn_mode = value_mode, char_mode;\n-\t  enum insn_code icode;\n-\n-\t  /* If the length is known, just return it.  */\n-\t  if (len != 0)\n-\t    return expand_expr (len, target, mode, EXPAND_MEMORY_USE_BAD);\n-\n-\t  /* If SRC is not a pointer type, don't do this operation inline.  */\n-\t  if (align == 0)\n-\t    break;\n-\n-\t  /* Call a function if we can't compute strlen in the right mode.  */\n-\n-\t  while (insn_mode != VOIDmode)\n-\t    {\n-\t      icode = strlen_optab->handlers[(int) insn_mode].insn_code;\n-\t      if (icode != CODE_FOR_nothing)\n-\t\tbreak;\n-\n-\t      insn_mode = GET_MODE_WIDER_MODE (insn_mode);\n-\t    }\n-\t  if (insn_mode == VOIDmode)\n-\t    break;\n-\n-\t  /* Make a place to write the result of the instruction.  */\n-\t  result = target;\n-\t  if (! (result != 0\n-\t\t && GET_CODE (result) == REG\n-\t\t && GET_MODE (result) == insn_mode\n-\t\t && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n-\t    result = gen_reg_rtx (insn_mode);\n-\n-\t  /* Make sure the operands are acceptable to the predicates.  */\n-\n-\t  if (! (*insn_operand_predicate[(int)icode][0]) (result, insn_mode))\n-\t    result = gen_reg_rtx (insn_mode);\n-\t  src_rtx = memory_address (BLKmode,\n-\t\t\t\t    expand_expr (src, NULL_RTX, ptr_mode,\n-\t\t\t\t\t\t EXPAND_NORMAL));\n-\n-\t  if (! (*insn_operand_predicate[(int)icode][1]) (src_rtx, Pmode))\n-\t    src_rtx = copy_to_mode_reg (Pmode, src_rtx);\n-\n-\t  /* Check the string is readable and has an end.  */\n-\t  if (current_function_check_memory_usage)\n-\t    emit_library_call (chkr_check_str_libfunc, 1, VOIDmode, 2,\n-\t\t\t       src_rtx, Pmode,\n-\t\t\t       GEN_INT (MEMORY_USE_RO),\n-\t\t\t       TYPE_MODE (integer_type_node));\n-\n-\t  char_rtx = const0_rtx;\n-\t  char_mode = insn_operand_mode[(int)icode][2];\n-\t  if (! (*insn_operand_predicate[(int)icode][2]) (char_rtx, char_mode))\n-\t    char_rtx = copy_to_mode_reg (char_mode, char_rtx);\n-\n-\t  emit_insn (GEN_FCN (icode) (result,\n-\t\t\t\t      gen_rtx_MEM (BLKmode, src_rtx),\n-\t\t\t\t      char_rtx, GEN_INT (align)));\n-\n-\t  /* Return the value in the proper mode for this function.  */\n-\t  if (GET_MODE (result) == value_mode)\n-\t    return result;\n-\t  else if (target != 0)\n-\t    {\n-\t      convert_move (target, result, 0);\n-\t      return target;\n-\t    }\n-\t  else\n-\t    return convert_to_mode (value_mode, result, 0);\n-\t}\n-\n-    case BUILT_IN_STRCPY:\n-      /* If not optimizing, call the library function.  */\n-      if (!optimize && ! CALLED_AS_BUILT_IN (fndecl))\n-\tbreak;\n-\n-      if (arglist == 0\n-\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n-\t  || TREE_CHAIN (arglist) == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE)\n-\tbreak;\n-      else\n-\t{\n-\t  tree len = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)));\n-\n-\t  if (len == 0)\n-\t    break;\n-\n-\t  len = size_binop (PLUS_EXPR, len, integer_one_node);\n-\n-\t  chainon (arglist, build_tree_list (NULL_TREE, len));\n-\t}\n-\n-      /* Drops in.  */\n-    case BUILT_IN_MEMCPY:\n-      /* If not optimizing, call the library function.  */\n-      if (!optimize && ! CALLED_AS_BUILT_IN (fndecl))\n-\tbreak;\n-\n-      if (arglist == 0\n-\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n-\t  || TREE_CHAIN (arglist) == 0\n-\t  || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))\n-\t      != POINTER_TYPE)\n-\t  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n-\t  || (TREE_CODE (TREE_TYPE (TREE_VALUE\n-\t\t\t\t    (TREE_CHAIN (TREE_CHAIN (arglist)))))\n-\t      != INTEGER_TYPE))\n-\tbreak;\n-      else\n-\t{\n-\t  tree dest = TREE_VALUE (arglist);\n-\t  tree src = TREE_VALUE (TREE_CHAIN (arglist));\n-\t  tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\n-\t  int src_align\n-\t    = get_pointer_alignment (src, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-\t  int dest_align\n-\t    = get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-\t  rtx dest_mem, src_mem, dest_addr, len_rtx;\n-\n-\t  /* If either SRC or DEST is not a pointer type, don't do\n-\t     this operation in-line.  */\n-\t  if (src_align == 0 || dest_align == 0)\n-\t    {\n-\t      if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STRCPY)\n-\t\tTREE_CHAIN (TREE_CHAIN (arglist)) = 0;\n-\t      break;\n-\t    }\n-\n-\t  dest_mem = get_memory_rtx (dest);\n-\t  src_mem = get_memory_rtx (src);\n-\t  len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n-\n-\t  /* Just copy the rights of SRC to the rights of DEST.  */\n-\t  if (current_function_check_memory_usage)\n-\t    emit_library_call (chkr_copy_bitmap_libfunc, 1, VOIDmode, 3,\n-\t\t\t       XEXP (dest_mem, 0), Pmode,\n-\t\t\t       XEXP (src_mem, 0), Pmode,\n-\t\t\t       len_rtx, TYPE_MODE (sizetype));\n-\n-\t  /* Copy word part most expediently.  */\n-\t  dest_addr\n-\t    = emit_block_move (dest_mem, src_mem, len_rtx,\n-\t\t\t       MIN (src_align, dest_align));\n-\n-\t  if (dest_addr == 0)\n-\t    dest_addr = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n-\n-\t  return dest_addr;\n-\t}\n-\n-    case BUILT_IN_MEMSET:\n-      /* If not optimizing, call the library function.  */\n-      if (!optimize && ! CALLED_AS_BUILT_IN (fndecl))\n-\tbreak;\n-\n-      if (arglist == 0\n-\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n-\t  || TREE_CHAIN (arglist) == 0\n-\t  || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))\n-\t      != INTEGER_TYPE)\n-\t  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n-\t  || (INTEGER_TYPE\n-\t      != (TREE_CODE (TREE_TYPE\n-\t\t\t     (TREE_VALUE\n-\t\t\t      (TREE_CHAIN (TREE_CHAIN (arglist))))))))\n-\tbreak;\n-      else\n-\t{\n-\t  tree dest = TREE_VALUE (arglist);\n-\t  tree val = TREE_VALUE (TREE_CHAIN (arglist));\n-\t  tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\n-\t  int dest_align\n-\t    = get_pointer_alignment (dest, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-\t  rtx dest_mem, dest_addr, len_rtx;\n-\n-\t  /* If DEST is not a pointer type, don't do this \n-\t     operation in-line.  */\n-\t  if (dest_align == 0)\n-\t    break;\n-\n-\t  /* If the arguments have side-effects, then we can only evaluate\n-\t     them at most once.  The following code evaluates them twice if\n-\t     they are not constants because we break out to expand_call\n-\t     in that case.  They can't be constants if they have side-effects\n-\t     so we can check for that first.  Alternatively, we could call\n-\t     save_expr to make multiple evaluation safe.  */\n-\t  if (TREE_SIDE_EFFECTS (val) || TREE_SIDE_EFFECTS (len))\n-\t    break;\n-\n-\t  /* If VAL is not 0, don't do this operation in-line. */\n-\t  if (expand_expr (val, NULL_RTX, VOIDmode, 0) != const0_rtx)\n-\t    break;\n-\n-\t  /* If LEN does not expand to a constant, don't do this\n-\t     operation in-line.  */\n-\t  len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n-\t  if (GET_CODE (len_rtx) != CONST_INT)\n-\t    break;\n-\n-\t  dest_mem = get_memory_rtx (dest);\n-\t   \n-\t  /* Just check DST is writable and mark it as readable.  */\n-\t  if (current_function_check_memory_usage)\n-\t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n-\t\t\t       XEXP (dest_mem, 0), Pmode,\n-\t\t\t       len_rtx, TYPE_MODE (sizetype),\n-\t\t\t       GEN_INT (MEMORY_USE_WO),\n-\t\t\t       TYPE_MODE (integer_type_node));\n-\n-\n-\t  dest_addr = clear_storage (dest_mem, len_rtx, dest_align);\n-\n-\t  if (dest_addr == 0)\n-\t    dest_addr = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n-\n-\t  return dest_addr;\n-\t}\n-\n-/* These comparison functions need an instruction that returns an actual\n-   index.  An ordinary compare that just sets the condition codes\n-   is not enough.  */\n-#ifdef HAVE_cmpstrsi\n-    case BUILT_IN_STRCMP:\n-      /* If not optimizing, call the library function.  */\n-      if (!optimize && ! CALLED_AS_BUILT_IN (fndecl))\n-\tbreak;\n-\n-      /* If we need to check memory accesses, call the library function.  */\n-      if (current_function_check_memory_usage)\n-\tbreak;\n-\n-      if (arglist == 0\n-\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n-\t  || TREE_CHAIN (arglist) == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE)\n-\tbreak;\n-      else if (!HAVE_cmpstrsi)\n-\tbreak;\n-      {\n-\ttree arg1 = TREE_VALUE (arglist);\n-\ttree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-\ttree len, len2;\n-\n-\tlen = c_strlen (arg1);\n-\tif (len)\n-\t  len = size_binop (PLUS_EXPR, integer_one_node, len);\n-\tlen2 = c_strlen (arg2);\n-\tif (len2)\n-\t  len2 = size_binop (PLUS_EXPR, integer_one_node, len2);\n-\n-\t/* If we don't have a constant length for the first, use the length\n-\t   of the second, if we know it.  We don't require a constant for\n-\t   this case; some cost analysis could be done if both are available\n-\t   but neither is constant.  For now, assume they're equally cheap.\n-\n-\t   If both strings have constant lengths, use the smaller.  This\n-\t   could arise if optimization results in strcpy being called with\n-\t   two fixed strings, or if the code was machine-generated.  We should\n-\t   add some code to the `memcmp' handler below to deal with such\n-\t   situations, someday.  */\n-\tif (!len || TREE_CODE (len) != INTEGER_CST)\n-\t  {\n-\t    if (len2)\n-\t      len = len2;\n-\t    else if (len == 0)\n-\t      break;\n-\t  }\n-\telse if (len2 && TREE_CODE (len2) == INTEGER_CST)\n-\t  {\n-\t    if (tree_int_cst_lt (len2, len))\n-\t      len = len2;\n-\t  }\n-\n-\tchainon (arglist, build_tree_list (NULL_TREE, len));\n-      }\n-\n-      /* Drops in.  */\n-    case BUILT_IN_MEMCMP:\n-      /* If not optimizing, call the library function.  */\n-      if (!optimize && ! CALLED_AS_BUILT_IN (fndecl))\n-\tbreak;\n-\n-      /* If we need to check memory accesses, call the library function.  */\n-      if (current_function_check_memory_usage)\n-\tbreak;\n-\n-      if (arglist == 0\n-\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n-\t  || TREE_CHAIN (arglist) == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE\n-\t  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))))) != INTEGER_TYPE)\n-\tbreak;\n-      else if (!HAVE_cmpstrsi)\n-\tbreak;\n-      {\n-\ttree arg1 = TREE_VALUE (arglist);\n-\ttree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-\ttree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\trtx result;\n-\n-\tint arg1_align\n-\t  = get_pointer_alignment (arg1, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-\tint arg2_align\n-\t  = get_pointer_alignment (arg2, BIGGEST_ALIGNMENT) / BITS_PER_UNIT;\n-\tenum machine_mode insn_mode\n-\t  = insn_operand_mode[(int) CODE_FOR_cmpstrsi][0];\n-\n-\t/* If we don't have POINTER_TYPE, call the function.  */\n-\tif (arg1_align == 0 || arg2_align == 0)\n-\t  {\n-\t    if (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STRCMP)\n-\t      TREE_CHAIN (TREE_CHAIN (arglist)) = 0;\n-\t    break;\n-\t  }\n-\n-\t/* Make a place to write the result of the instruction.  */\n-\tresult = target;\n-\tif (! (result != 0\n-\t       && GET_CODE (result) == REG && GET_MODE (result) == insn_mode\n-\t       && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n-\t  result = gen_reg_rtx (insn_mode);\n-\n-\temit_insn (gen_cmpstrsi (result, get_memory_rtx (arg1),\n-\t\t\t\t get_memory_rtx (arg2),\n-\t\t\t\t expand_expr (len, NULL_RTX, VOIDmode, 0),\n-\t\t\t\t GEN_INT (MIN (arg1_align, arg2_align))));\n-\n-\t/* Return the value in the proper mode for this function.  */\n-\tmode = TYPE_MODE (TREE_TYPE (exp));\n-\tif (GET_MODE (result) == mode)\n-\t  return result;\n-\telse if (target != 0)\n-\t  {\n-\t    convert_move (target, result, 0);\n-\t    return target;\n-\t  }\n-\telse\n-\t  return convert_to_mode (mode, result, 0);\n-      }\t\n-#else\n-    case BUILT_IN_STRCMP:\n-    case BUILT_IN_MEMCMP:\n-      break;\n-#endif\n-\n-    case BUILT_IN_SETJMP:\n-      if (arglist == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n-\tbreak;\n-      else\n-\t{\n-\t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n-\t\t\t\t      VOIDmode, 0);\n-\t  rtx lab = gen_label_rtx ();\n-\t  rtx ret = expand_builtin_setjmp (buf_addr, target, lab, lab);\n-\t  emit_label (lab);\n-\t  return ret;\n-\t}\n-\n-      /* __builtin_longjmp is passed a pointer to an array of five words.\n-\t It's similar to the C library longjmp function but works with\n-\t __builtin_setjmp above.  */\n-    case BUILT_IN_LONGJMP:\n-      if (arglist == 0 || TREE_CHAIN (arglist) == 0\n-\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE)\n-\tbreak;\n-      else\n-\t{\n-\t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n-\t\t\t\t      VOIDmode, 0);\n-\t  rtx value = expand_expr (TREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t\t\t   NULL_RTX, VOIDmode, 0);\n-\n-\t  if (value != const1_rtx)\n-\t    {\n-\t      error (\"__builtin_longjmp second argument must be 1\");\n-\t      return const0_rtx;\n-\t    }\n-\n-\t  expand_builtin_longjmp (buf_addr, value);\n-\t  return const0_rtx;\n-\t}\n-\n-    case BUILT_IN_TRAP:\n-#ifdef HAVE_trap\n-      if (HAVE_trap)\n-\temit_insn (gen_trap ());\n-      else\n-#endif\n-\terror (\"__builtin_trap not supported by this target\");\n-      emit_barrier ();\n-      return const0_rtx;\n-\n-      /* Various hooks for the DWARF 2 __throw routine.  */\n-    case BUILT_IN_UNWIND_INIT:\n-      expand_builtin_unwind_init ();\n-      return const0_rtx;\n-    case BUILT_IN_DWARF_CFA:\n-      return virtual_cfa_rtx;\n-#ifdef DWARF2_UNWIND_INFO\n-    case BUILT_IN_DWARF_FP_REGNUM:\n-      return expand_builtin_dwarf_fp_regnum ();\n-    case BUILT_IN_DWARF_REG_SIZE:\n-      return expand_builtin_dwarf_reg_size (TREE_VALUE (arglist), target);\n-#endif\n-    case BUILT_IN_FROB_RETURN_ADDR:\n-      return expand_builtin_frob_return_addr (TREE_VALUE (arglist));\n-    case BUILT_IN_EXTRACT_RETURN_ADDR:\n-      return expand_builtin_extract_return_addr (TREE_VALUE (arglist));\n-    case BUILT_IN_EH_RETURN:\n-      expand_builtin_eh_return (TREE_VALUE (arglist),\n-\t\t\t\tTREE_VALUE (TREE_CHAIN (arglist)),\n-\t\t\t\tTREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))));\n-      return const0_rtx;\n-\n-    default:\t\t\t/* just do library call, if unknown builtin */\n-      error (\"built-in function `%s' not currently supported\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n-    }\n-\n-  /* The switch statement above can drop through to cause the function\n-     to be called normally.  */\n-\n-  return expand_call (exp, target, ignore);\n-}\n-\f\n-/* Built-in functions to perform an untyped call and return.  */\n-\n-/* For each register that may be used for calling a function, this\n-   gives a mode used to copy the register's value.  VOIDmode indicates\n-   the register is not used for calling a function.  If the machine\n-   has register windows, this gives only the outbound registers.\n-   INCOMING_REGNO gives the corresponding inbound register.  */\n-static enum machine_mode apply_args_mode[FIRST_PSEUDO_REGISTER];\n-\n-/* For each register that may be used for returning values, this gives\n-   a mode used to copy the register's value.  VOIDmode indicates the\n-   register is not used for returning values.  If the machine has\n-   register windows, this gives only the outbound registers.\n-   INCOMING_REGNO gives the corresponding inbound register.  */\n-static enum machine_mode apply_result_mode[FIRST_PSEUDO_REGISTER];\n-\n-/* For each register that may be used for calling a function, this\n-   gives the offset of that register into the block returned by\n-   __builtin_apply_args.  0 indicates that the register is not\n-   used for calling a function.  */\n-static int apply_args_reg_offset[FIRST_PSEUDO_REGISTER];\n-\n-/* Return the offset of register REGNO into the block returned by \n-   __builtin_apply_args.  This is not declared static, since it is\n-   needed in objc-act.c.  */\n-\n-int \n-apply_args_register_offset (regno)\n-     int regno;\n-{\n-  apply_args_size ();\n-\n-  /* Arguments are always put in outgoing registers (in the argument\n-     block) if such make sense.  */\n-#ifdef OUTGOING_REGNO\n-  regno = OUTGOING_REGNO(regno);\n-#endif\n-  return apply_args_reg_offset[regno];\n-}\n-\n-/* Return the size required for the block returned by __builtin_apply_args,\n-   and initialize apply_args_mode.  */\n-\n-static int\n-apply_args_size ()\n-{\n-  static int size = -1;\n-  int align, regno;\n-  enum machine_mode mode;\n-\n-  /* The values computed by this function never change.  */\n-  if (size < 0)\n-    {\n-      /* The first value is the incoming arg-pointer.  */\n-      size = GET_MODE_SIZE (Pmode);\n-\n-      /* The second value is the structure value address unless this is\n-\t passed as an \"invisible\" first argument.  */\n-      if (struct_value_rtx)\n-\tsize += GET_MODE_SIZE (Pmode);\n-\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif (FUNCTION_ARG_REGNO_P (regno))\n-\t  {\n-\t    /* Search for the proper mode for copying this register's\n-\t       value.  I'm not sure this is right, but it works so far.  */\n-\t    enum machine_mode best_mode = VOIDmode;\n-\n-\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t\t mode != VOIDmode;\n-\t\t mode = GET_MODE_WIDER_MODE (mode))\n-\t      if (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t  && HARD_REGNO_NREGS (regno, mode) == 1)\n-\t\tbest_mode = mode;\n-\n-\t    if (best_mode == VOIDmode)\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && (mov_optab->handlers[(int) mode].insn_code\n-\t\t\t!= CODE_FOR_nothing))\n-\t\t  best_mode = mode;\n-\n-\t    mode = best_mode;\n-\t    if (mode == VOIDmode)\n-\t      abort ();\n-\n-\t    align = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n-\t    if (size % align != 0)\n-\t      size = CEIL (size, align) * align;\n-\t    apply_args_reg_offset[regno] = size;\n-\t    size += GET_MODE_SIZE (mode);\n-\t    apply_args_mode[regno] = mode;\n-\t  }\n-\telse\n-\t  {\n-\t    apply_args_mode[regno] = VOIDmode;\n-\t    apply_args_reg_offset[regno] = 0;\n-\t  }\n-    }\n-  return size;\n-}\n-\n-/* Return the size required for the block returned by __builtin_apply,\n-   and initialize apply_result_mode.  */\n-\n-static int\n-apply_result_size ()\n-{\n-  static int size = -1;\n-  int align, regno;\n-  enum machine_mode mode;\n-\n-  /* The values computed by this function never change.  */\n-  if (size < 0)\n-    {\n-      size = 0;\n-\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif (FUNCTION_VALUE_REGNO_P (regno))\n-\t  {\n-\t    /* Search for the proper mode for copying this register's\n-\t       value.  I'm not sure this is right, but it works so far.  */\n-\t    enum machine_mode best_mode = VOIDmode;\n-\n-\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t\t mode != TImode;\n-\t\t mode = GET_MODE_WIDER_MODE (mode))\n-\t      if (HARD_REGNO_MODE_OK (regno, mode))\n-\t\tbest_mode = mode;\n-\n-\t    if (best_mode == VOIDmode)\n-\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n-\t\t   mode != VOIDmode;\n-\t\t   mode = GET_MODE_WIDER_MODE (mode))\n-\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n-\t\t    && (mov_optab->handlers[(int) mode].insn_code\n-\t\t\t!= CODE_FOR_nothing))\n-\t\t  best_mode = mode;\n-\n-\t    mode = best_mode;\n-\t    if (mode == VOIDmode)\n-\t      abort ();\n-\n-\t    align = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n-\t    if (size % align != 0)\n-\t      size = CEIL (size, align) * align;\n-\t    size += GET_MODE_SIZE (mode);\n-\t    apply_result_mode[regno] = mode;\n-\t  }\n-\telse\n-\t  apply_result_mode[regno] = VOIDmode;\n-\n-      /* Allow targets that use untyped_call and untyped_return to override\n-\t the size so that machine-specific information can be stored here.  */\n-#ifdef APPLY_RESULT_SIZE\n-      size = APPLY_RESULT_SIZE;\n-#endif\n-    }\n-  return size;\n-}\n-\n-#if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)\n-/* Create a vector describing the result block RESULT.  If SAVEP is true,\n-   the result block is used to save the values; otherwise it is used to\n-   restore the values.  */\n-\n-static rtx\n-result_vector (savep, result)\n-     int savep;\n-     rtx result;\n-{\n-  int regno, size, align, nelts;\n-  enum machine_mode mode;\n-  rtx reg, mem;\n-  rtx *savevec = (rtx *) alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n-  \n-  size = nelts = 0;\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if ((mode = apply_result_mode[regno]) != VOIDmode)\n-      {\n-\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n-\tif (size % align != 0)\n-\t  size = CEIL (size, align) * align;\n-\treg = gen_rtx_REG (mode, savep ? regno : INCOMING_REGNO (regno));\n-\tmem = change_address (result, mode,\n-\t\t\t      plus_constant (XEXP (result, 0), size));\n-\tsavevec[nelts++] = (savep\n-\t\t\t    ? gen_rtx_SET (VOIDmode, mem, reg)\n-\t\t\t    : gen_rtx_SET (VOIDmode, reg, mem));\n-\tsize += GET_MODE_SIZE (mode);\n-      }\n-  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nelts, savevec));\n-}\n-#endif /* HAVE_untyped_call or HAVE_untyped_return */\n-\n-/* Save the state required to perform an untyped call with the same\n-   arguments as were passed to the current function.  */\n-\n-static rtx\n-expand_builtin_apply_args ()\n-{\n-  rtx registers;\n-  int size, align, regno;\n-  enum machine_mode mode;\n-\n-  /* Create a block where the arg-pointer, structure value address,\n-     and argument registers can be saved.  */\n-  registers = assign_stack_local (BLKmode, apply_args_size (), -1);\n-\n-  /* Walk past the arg-pointer and structure value address.  */\n-  size = GET_MODE_SIZE (Pmode);\n-  if (struct_value_rtx)\n-    size += GET_MODE_SIZE (Pmode);\n-\n-  /* Save each register used in calling a function to the block.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if ((mode = apply_args_mode[regno]) != VOIDmode)\n-      {\n-\trtx tem;\n-\n-\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n-\tif (size % align != 0)\n-\t  size = CEIL (size, align) * align;\n-\n-\ttem = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n-\n-#ifdef STACK_REGS\n-        /* For reg-stack.c's stack register household.\n-\t   Compare with a similar piece of code in function.c.  */\n-\n-        emit_insn (gen_rtx_USE (mode, tem));\n-#endif\n-\n-\temit_move_insn (change_address (registers, mode,\n-\t\t\t\t\tplus_constant (XEXP (registers, 0),\n-\t\t\t\t\t\t       size)),\n-\t\t\ttem);\n-\tsize += GET_MODE_SIZE (mode);\n-      }\n-\n-  /* Save the arg pointer to the block.  */\n-  emit_move_insn (change_address (registers, Pmode, XEXP (registers, 0)),\n-\t\t  copy_to_reg (virtual_incoming_args_rtx));\n-  size = GET_MODE_SIZE (Pmode);\n-\n-  /* Save the structure value address unless this is passed as an\n-     \"invisible\" first argument.  */\n-  if (struct_value_incoming_rtx)\n-    {\n-      emit_move_insn (change_address (registers, Pmode,\n-\t\t\t\t      plus_constant (XEXP (registers, 0),\n-\t\t\t\t\t\t     size)),\n-\t\t      copy_to_reg (struct_value_incoming_rtx));\n-      size += GET_MODE_SIZE (Pmode);\n-    }\n-\n-  /* Return the address of the block.  */\n-  return copy_addr_to_reg (XEXP (registers, 0));\n-}\n-\n-/* Perform an untyped call and save the state required to perform an\n-   untyped return of whatever value was returned by the given function.  */\n-\n-static rtx\n-expand_builtin_apply (function, arguments, argsize)\n-     rtx function, arguments, argsize;\n-{\n-  int size, align, regno;\n-  enum machine_mode mode;\n-  rtx incoming_args, result, reg, dest, call_insn;\n-  rtx old_stack_level = 0;\n-  rtx call_fusage = 0;\n-\n-  /* Create a block where the return registers can be saved.  */\n-  result = assign_stack_local (BLKmode, apply_result_size (), -1);\n-\n-  /* ??? The argsize value should be adjusted here.  */\n-\n-  /* Fetch the arg pointer from the ARGUMENTS block.  */\n-  incoming_args = gen_reg_rtx (Pmode);\n-  emit_move_insn (incoming_args,\n-\t\t  gen_rtx_MEM (Pmode, arguments));\n-#ifndef STACK_GROWS_DOWNWARD\n-  incoming_args = expand_binop (Pmode, sub_optab, incoming_args, argsize,\n-\t\t\t\tincoming_args, 0, OPTAB_LIB_WIDEN);\n-#endif\n-\n-  /* Perform postincrements before actually calling the function.  */\n-  emit_queue ();\n-\n-  /* Push a new argument block and copy the arguments.  */\n-  do_pending_stack_adjust ();\n-\n-  /* Save the stack with nonlocal if available */\n-#ifdef HAVE_save_stack_nonlocal\n-  if (HAVE_save_stack_nonlocal)\n-    emit_stack_save (SAVE_NONLOCAL, &old_stack_level, NULL_RTX);\n-  else\n-#endif\n-    emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n-\n-  /* Push a block of memory onto the stack to store the memory arguments.\n-     Save the address in a register, and copy the memory arguments.  ??? I\n-     haven't figured out how the calling convention macros effect this,\n-     but it's likely that the source and/or destination addresses in\n-     the block copy will need updating in machine specific ways.  */\n-  dest = allocate_dynamic_stack_space (argsize, 0, 0);\n-  emit_block_move (gen_rtx_MEM (BLKmode, dest),\n-\t\t   gen_rtx_MEM (BLKmode, incoming_args),\n-\t\t   argsize,\n-\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n-\n-  /* Refer to the argument block.  */\n-  apply_args_size ();\n-  arguments = gen_rtx_MEM (BLKmode, arguments);\n-\n-  /* Walk past the arg-pointer and structure value address.  */\n-  size = GET_MODE_SIZE (Pmode);\n-  if (struct_value_rtx)\n-    size += GET_MODE_SIZE (Pmode);\n-\n-  /* Restore each of the registers previously saved.  Make USE insns\n-     for each of these registers for use in making the call.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if ((mode = apply_args_mode[regno]) != VOIDmode)\n-      {\n-\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n-\tif (size % align != 0)\n-\t  size = CEIL (size, align) * align;\n-\treg = gen_rtx_REG (mode, regno);\n-\temit_move_insn (reg,\n-\t\t\tchange_address (arguments, mode,\n-\t\t\t\t\tplus_constant (XEXP (arguments, 0),\n-\t\t\t\t\t\t       size)));\n-\n-\tuse_reg (&call_fusage, reg);\n-\tsize += GET_MODE_SIZE (mode);\n-      }\n-\n-  /* Restore the structure value address unless this is passed as an\n-     \"invisible\" first argument.  */\n-  size = GET_MODE_SIZE (Pmode);\n-  if (struct_value_rtx)\n-    {\n-      rtx value = gen_reg_rtx (Pmode);\n-      emit_move_insn (value,\n-\t\t      change_address (arguments, Pmode,\n-\t\t\t\t      plus_constant (XEXP (arguments, 0),\n-\t\t\t\t\t\t     size)));\n-      emit_move_insn (struct_value_rtx, value);\n-      if (GET_CODE (struct_value_rtx) == REG)\n-\t  use_reg (&call_fusage, struct_value_rtx);\n-      size += GET_MODE_SIZE (Pmode);\n-    }\n-\n-  /* All arguments and registers used for the call are set up by now!  */\n-  function = prepare_call_address (function, NULL_TREE, &call_fusage, 0);\n-\n-  /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n-     and we don't want to load it into a register as an optimization,\n-     because prepare_call_address already did it if it should be done.  */\n-  if (GET_CODE (function) != SYMBOL_REF)\n-    function = memory_address (FUNCTION_MODE, function);\n-\n-  /* Generate the actual call instruction and save the return value.  */\n-#ifdef HAVE_untyped_call\n-  if (HAVE_untyped_call)\n-    emit_call_insn (gen_untyped_call (gen_rtx_MEM (FUNCTION_MODE, function),\n-\t\t\t\t      result, result_vector (1, result)));\n-  else\n-#endif\n-#ifdef HAVE_call_value\n-  if (HAVE_call_value)\n-    {\n-      rtx valreg = 0;\n-\n-      /* Locate the unique return register.  It is not possible to\n-\t express a call that sets more than one return register using\n-\t call_value; use untyped_call for that.  In fact, untyped_call\n-\t only needs to save the return registers in the given block.  */\n-      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-\tif ((mode = apply_result_mode[regno]) != VOIDmode)\n-\t  {\n-\t    if (valreg)\n-\t      abort (); /* HAVE_untyped_call required.  */\n-\t    valreg = gen_rtx_REG (mode, regno);\n-\t  }\n-\n-      emit_call_insn (gen_call_value (valreg,\n-\t\t\t\t      gen_rtx_MEM (FUNCTION_MODE, function),\n-\t\t\t\t      const0_rtx, NULL_RTX, const0_rtx));\n-\n-      emit_move_insn (change_address (result, GET_MODE (valreg),\n-\t\t\t\t      XEXP (result, 0)),\n-\t\t      valreg);\n-    }\n-  else\n-#endif\n-    abort ();\n-\n-  /* Find the CALL insn we just emitted.  */\n-  for (call_insn = get_last_insn ();\n-       call_insn && GET_CODE (call_insn) != CALL_INSN;\n-       call_insn = PREV_INSN (call_insn))\n-    ;\n-\n-  if (! call_insn)\n-    abort ();\n-\n-  /* Put the register usage information on the CALL.  If there is already\n-     some usage information, put ours at the end.  */\n-  if (CALL_INSN_FUNCTION_USAGE (call_insn))\n-    {\n-      rtx link;\n-\n-      for (link = CALL_INSN_FUNCTION_USAGE (call_insn); XEXP (link, 1) != 0;\n-\t   link = XEXP (link, 1))\n-\t;\n-\n-      XEXP (link, 1) = call_fusage;\n-    }\n-  else\n-    CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n-\n-  /* Restore the stack.  */\n-#ifdef HAVE_save_stack_nonlocal\n-  if (HAVE_save_stack_nonlocal)\n-    emit_stack_restore (SAVE_NONLOCAL, old_stack_level, NULL_RTX);\n-  else\n-#endif\n-    emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n-\n-  /* Return the address of the result block.  */\n-  return copy_addr_to_reg (XEXP (result, 0));\n-}\n-\n-/* Perform an untyped return.  */\n-\n-static void\n-expand_builtin_return (result)\n-     rtx result;\n-{\n-  int size, align, regno;\n-  enum machine_mode mode;\n-  rtx reg;\n-  rtx call_fusage = 0;\n-\n-  apply_result_size ();\n-  result = gen_rtx_MEM (BLKmode, result);\n-\n-#ifdef HAVE_untyped_return\n-  if (HAVE_untyped_return)\n-    {\n-      emit_jump_insn (gen_untyped_return (result, result_vector (0, result)));\n-      emit_barrier ();\n-      return;\n-    }\n-#endif\n-\n-  /* Restore the return value and note that each value is used.  */\n-  size = 0;\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if ((mode = apply_result_mode[regno]) != VOIDmode)\n-      {\n-\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n-\tif (size % align != 0)\n-\t  size = CEIL (size, align) * align;\n-\treg = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n-\temit_move_insn (reg,\n-\t\t\tchange_address (result, mode,\n-\t\t\t\t\tplus_constant (XEXP (result, 0),\n-\t\t\t\t\t\t       size)));\n-\n-\tpush_to_sequence (call_fusage);\n-\temit_insn (gen_rtx_USE (VOIDmode, reg));\n-\tcall_fusage = get_insns ();\n-\tend_sequence ();\n-\tsize += GET_MODE_SIZE (mode);\n-      }\n-\n-  /* Put the USE insns before the return.  */\n-  emit_insns (call_fusage);\n-\n-  /* Return whatever values was restored by jumping directly to the end\n-     of the function.  */\n-  expand_null_return ();\n-}\n \f\n /* Expand code for a post- or pre- increment or decrement\n    and return the RTX for the result."}, {"sha": "6bde47acb98428c90f596eab31f831e411206f89", "filename": "gcc/expr.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28f4ec01e98f2c5cc51653758029ca1a3fe8d56d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=28f4ec01e98f2c5cc51653758029ca1a3fe8d56d", "patch": "@@ -75,6 +75,14 @@ extern rtx forced_labels;\n    So we can mark them all live at the end of the function, if stupid.  */\n extern rtx save_expr_regs;\n \n+/* Nonzero means __builtin_saveregs has already been done in this function.\n+   The value is the pseudoreg containing the value __builtin_saveregs\n+   returned.  */\n+extern rtx saveregs_value;\n+\n+/* Similarly for __builtin_apply_args.  */\n+extern rtx apply_args_value;\n+\n extern int current_function_calls_alloca;\n extern int current_function_outgoing_args_size;\n \n@@ -727,6 +735,13 @@ extern rtx get_condition PROTO((rtx, rtx *));\n /* Generate a conditional trap instruction.  */\n extern rtx gen_cond_trap PROTO((enum rtx_code, rtx, rtx, rtx));\n \f\n+/* Functions from builtins.c:  */\n+#ifdef TREE_CODE\n+extern rtx expand_builtin PROTO((tree, rtx, rtx, enum machine_mode, int));\n+#endif\n+\n+extern rtx expand_builtin_setjmp PROTO((rtx, rtx, rtx, rtx));\n+\f\n /* Functions from expr.c:  */\n \n /* This is run once per compilation to set up which modes can be used\n@@ -831,8 +846,6 @@ extern rtx store_expr PROTO((tree, rtx, int));\n    Useful after calling expand_expr with 1 as sum_ok.  */\n extern rtx force_operand PROTO((rtx, rtx));\n \n-extern rtx expand_builtin_setjmp PROTO((rtx, rtx, rtx, rtx));\n-\n #ifdef TREE_CODE\n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n@@ -853,6 +866,10 @@ extern void clear_pending_stack_adjust PROTO((void));\n extern void do_pending_stack_adjust PROTO((void));\n \n #ifdef TREE_CODE\n+/* Return the tree node and offset if a given argument corresponds to\n+   a string constant.  */\n+extern tree string_constant PROTO((tree, tree *));\n+\n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n extern void jumpifnot PROTO((tree, rtx));\n "}]}