{"sha": "0e84fd1724f7651419ce17080ce51f11d29fac90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU4NGZkMTcyNGY3NjUxNDE5Y2UxNzA4MGNlNTFmMTFkMjlmYWM5MA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2016-08-02T18:01:14Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2016-08-02T18:01:14Z"}, "message": "expr.c (push_value): Only call flush_quick_stack for non-constant arguments.\n\n2016-08-02  Roger Sayle  <roger@nextmovesoftware.com>\n\n\t* expr.c (push_value): Only call flush_quick_stack for non-constant\n\targuments.\n\t(build_java_throw_out_of_bounds_exception): No longer wrap calls\n\tto _Jv_ThowBadArrayIndex in a COMPOUND_EXPR as no longer needed.\n\t(java_check_reference): Annotate COND_EXPR with __builtin_expect\n\tto indicate that calling _Jv_ThrowNullPointerException is unlikely.\n\t(build_java_arrayaccess): Construct an unlikely COND_EXPR instead\n\tof a TRUTH_ANDIF_EXPR in a COMPOUND_EXPR.  Only generate array\n\tindex MULT_EXPR when size_exp is not unity.\n\t(build_array_length_annotation): When optimizing, generate a write\n\tto the allocated array's length field to expose constant lengths\n\tto GCC's optimizers.\n\t(build_newarray): Call new build_array_length_annotation.\n\t(build_anewarray): Likewise.\n\n\t(expand_java_multianewarray): Fix whitespace.\n\t(expand_java_return): Likewise.\n\t(expand_invoke): Likewise.\n\t(load_type_state): Likewise.\n\nFrom-SVN: r238992", "tree": {"sha": "45e84193468dfea0a7a436b46208da3faed59ee9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45e84193468dfea0a7a436b46208da3faed59ee9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e84fd1724f7651419ce17080ce51f11d29fac90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e84fd1724f7651419ce17080ce51f11d29fac90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e84fd1724f7651419ce17080ce51f11d29fac90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e84fd1724f7651419ce17080ce51f11d29fac90/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a8330b7ef5aad2860cc5533a140fc6e1fd3793b"}], "stats": {"total": 141, "additions": 95, "deletions": 46}, "files": [{"sha": "87e25bcfbe693ed024ecbbf9dec7e8547daf925a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e84fd1724f7651419ce17080ce51f11d29fac90/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e84fd1724f7651419ce17080ce51f11d29fac90/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=0e84fd1724f7651419ce17080ce51f11d29fac90", "patch": "@@ -1,3 +1,25 @@\n+2016-08-02  Roger Sayle  <roger@nextmovesoftware.com>\n+\n+\t* expr.c (push_value): Only call flush_quick_stack for non-constant\n+\targuments.\n+\t(build_java_throw_out_of_bounds_exception): No longer wrap calls\n+\tto _Jv_ThowBadArrayIndex in a COMPOUND_EXPR as no longer needed.\n+\t(java_check_reference): Annotate COND_EXPR with __builtin_expect\n+\tto indicate that calling _Jv_ThrowNullPointerException is unlikely.\n+\t(build_java_arrayaccess): Construct an unlikely COND_EXPR instead\n+\tof a TRUTH_ANDIF_EXPR in a COMPOUND_EXPR.  Only generate array\n+\tindex MULT_EXPR when size_exp is not unity.\n+\t(build_array_length_annotation): When optimizing, generate a write\n+\tto the allocated array's length field to expose constant lengths\n+\tto GCC's optimizers.\n+\t(build_newarray): Call new build_array_length_annotation.\n+\t(build_anewarray): Likewise.\n+\n+\t(expand_java_multianewarray): Fix whitespace.\n+\t(expand_java_return): Likewise.\n+\t(expand_invoke): Likewise.\n+\t(load_type_state): Likewise.\n+\n 2016-07-28  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/7652"}, {"sha": "b625a1d58da53b011cc9a74f94de17ecf8bcce7d", "filename": "gcc/java/expr.c", "status": "modified", "additions": 73, "deletions": 46, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e84fd1724f7651419ce17080ce51f11d29fac90/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e84fd1724f7651419ce17080ce51f11d29fac90/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=0e84fd1724f7651419ce17080ce51f11d29fac90", "patch": "@@ -37,6 +37,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"jcf.h\"\n #include \"parse.h\"\n #include \"tree-iterator.h\"\n+#include \"tree-eh.h\"\n \n static void flush_quick_stack (void);\n static void push_value (tree);\n@@ -273,10 +274,12 @@ push_value (tree value)\n   /* If the value has a side effect, then we need to evaluate it\n      whether or not the result is used.  If the value ends up on the\n      quick stack and is then popped, this won't happen -- so we flush\n-     the quick stack.  It is safest to simply always flush, though,\n-     since TREE_SIDE_EFFECTS doesn't capture COMPONENT_REF, and for\n-     the latter we may need to strip conversions.  */\n-  flush_quick_stack ();\n+     the quick stack.  It is safest to always flush non-constant\n+     operands.  */\n+  if (! TREE_CONSTANT (value)\n+      || TREE_SIDE_EFFECTS (value)\n+      || tree_could_trap_p (value))\n+    flush_quick_stack ();\n }\n \n /* Pop a type from the type stack.\n@@ -778,19 +781,13 @@ build_java_throw_out_of_bounds_exception (tree index)\n {\n   tree node;\n \n-  /* We need to build a COMPOUND_EXPR because _Jv_ThrowBadArrayIndex()\n-     has void return type.  We cannot just set the type of the CALL_EXPR below\n-     to int_type_node because we would lose it during gimplification.  */\n+  /* _Jv_ThrowBadArrayIndex() has void return type.  */\n   gcc_assert (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (soft_badarrayindex_node))));\n   node = build_call_nary (void_type_node,\n-\t\t\t       build_address_of (soft_badarrayindex_node),\n-\t\t\t       1, index);\n+\t\t\t  build_address_of (soft_badarrayindex_node),\n+\t\t\t  1, index);\n   TREE_SIDE_EFFECTS (node) = 1;\n-\n-  node = build2 (COMPOUND_EXPR, int_type_node, node, integer_zero_node);\n-  TREE_SIDE_EFFECTS (node) = 1;\t/* Allows expansion within ANDIF */\n-\n-  return (node);\n+  return node;\n }\n \n /* Return the length of an array. Doesn't perform any checking on the nature\n@@ -833,10 +830,12 @@ java_check_reference (tree expr, int check)\n {\n   if (!flag_syntax_only && check)\n     {\n+      tree test;\n       expr = save_expr (expr);\n-      expr = build3 (COND_EXPR, TREE_TYPE (expr),\n-\t\t     build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t     expr, null_pointer_node),\n+      test = build2 (EQ_EXPR, boolean_type_node, expr, null_pointer_node);\n+      test = build_call_expr (builtin_decl_implicit (BUILT_IN_EXPECT), 2,\n+\t\t\t      test, boolean_false_node);\n+      expr = build3 (COND_EXPR, TREE_TYPE (expr), test,\n \t\t     build_call_nary (void_type_node, \n \t\t\t\t      build_address_of (soft_nullpointer_node),\n \t\t\t\t      0),\n@@ -865,7 +864,7 @@ build_java_indirect_ref (tree type, tree expr, int check)\n tree\n build_java_arrayaccess (tree array, tree type, tree index)\n {\n-  tree node, throw_expr = NULL_TREE;\n+  tree node;\n   tree data_field;\n   tree ref;\n   tree array_type = TREE_TYPE (TREE_TYPE (array));\n@@ -882,9 +881,9 @@ build_java_arrayaccess (tree array, tree type, tree index)\n     {\n       /* Generate:\n        * (unsigned jint) INDEX >= (unsigned jint) LEN\n-       *    && throw ArrayIndexOutOfBoundsException.\n+       *    ? throw ArrayIndexOutOfBoundsException : INDEX.\n        * Note this is equivalent to and more efficient than:\n-       * INDEX < 0 || INDEX >= LEN && throw ... */\n+       * INDEX < 0 || INDEX >= LEN ? throw ... : INDEX. */\n       tree test;\n       tree len = convert (unsigned_int_type_node,\n \t\t\t  build_java_array_length_access (array));\n@@ -893,19 +892,14 @@ build_java_arrayaccess (tree array, tree type, tree index)\n \t\t\t  len);\n       if (! integer_zerop (test))\n \t{\n-\t  throw_expr\n-\t    = build2 (TRUTH_ANDIF_EXPR, int_type_node, test,\n-\t\t      build_java_throw_out_of_bounds_exception (index));\n-\t  /* allows expansion within COMPOUND */\n-\t  TREE_SIDE_EFFECTS( throw_expr ) = 1;\n+\t  test = build_call_expr (builtin_decl_implicit (BUILT_IN_EXPECT), 2,\n+\t\t\t\t  test, boolean_false_node);\n+          index = build3 (COND_EXPR, int_type_node, test,\n+\t\t\t  build_java_throw_out_of_bounds_exception (index),\n+\t\t\t  index);\n \t}\n     }\n \n-  /* If checking bounds, wrap the index expr with a COMPOUND_EXPR in order\n-     to have the bounds check evaluated first. */\n-  if (throw_expr != NULL_TREE)\n-    index = build2 (COMPOUND_EXPR, int_type_node, throw_expr, index);\n-\n   data_field = lookup_field (&array_type, get_identifier (\"data\"));\n \n   ref = build3 (COMPONENT_REF, TREE_TYPE (data_field),    \n@@ -919,9 +913,11 @@ build_java_arrayaccess (tree array, tree type, tree index)\n \n   /* Multiply the index by the size of an element to obtain a byte\n      offset.  Convert the result to a pointer to the element type.  */\n-  index = build2 (MULT_EXPR, sizetype, \n-\t\t  fold_convert (sizetype, index), \n-\t\t  size_exp);\n+  index = fold_convert (sizetype, index);\n+  if (! integer_onep (size_exp))\n+    {\n+      index = build2 (MULT_EXPR, sizetype, index, size_exp);\n+    }\n \n   /* Sum the byte offset and the address of the data field.  */\n   node = fold_build_pointer_plus (node, index);\n@@ -1026,14 +1022,42 @@ build_java_check_indexed_type (tree array_node ATTRIBUTE_UNUSED,\n   return indexed_type;\n }\n \n+/* When optimizing, wrap calls to array allocation functions taking\n+   constant length arguments, in a COMPOUND_EXPR, containing an\n+   explict assignment of the .length field, for GCC's optimizers.  */\n+\n+static tree\n+build_array_length_annotation (tree call, tree length)\n+{\n+  if (optimize\n+      && TREE_CONSTANT (length)\n+      && is_array_type_p (TREE_TYPE (call)))\n+    {\n+      tree type, note;\n+      type = TREE_TYPE (call);\n+      call = save_expr (call);\n+      note = build3 (COMPONENT_REF, int_type_node,\n+\t\t     build1 (INDIRECT_REF, TREE_TYPE (type), call),\n+\t\t     lookup_field (&TREE_TYPE (type),\n+\t\t\t\t   get_identifier (\"length\")),\n+\t\t     NULL_TREE);\n+      note = build2 (MODIFY_EXPR, int_type_node, note, length);\n+      TREE_SIDE_EFFECTS (note) = 1;\n+      call = build2 (COMPOUND_EXPR, TREE_TYPE (call), note, call);\n+      TREE_SIDE_EFFECTS (call) = 1;\n+    }\n+  return call;\n+}\n+\n+\n /* newarray triggers a call to _Jv_NewPrimArray. This function should be \n    called with an integer code (the type of array to create), and the length\n    of the array to create.  */\n \n tree\n build_newarray (int atype_value, tree length)\n {\n-  tree type_arg;\n+  tree type_arg, call;\n \n   tree prim_type = decode_newarray_type (atype_value);\n   tree type\n@@ -1045,9 +1069,10 @@ build_newarray (int atype_value, tree length)\n      some work.  */\n   type_arg = build_class_ref (prim_type);\n \n-  return build_call_nary (promote_type (type),\n+  call = build_call_nary (promote_type (type),\n \t\t\t  build_address_of (soft_newarray_node),\n \t\t\t  2, type_arg, length);\n+  return build_array_length_annotation (call, length);\n }\n \n /* Generates anewarray from a given CLASS_TYPE. Gets from the stack the size\n@@ -1061,12 +1086,14 @@ build_anewarray (tree class_type, tree length)\n \t\t\t     tree_fits_shwi_p (length)\n \t\t\t     ? tree_to_shwi (length) : -1);\n \n-  return build_call_nary (promote_type (type),\n-\t\t\t  build_address_of (soft_anewarray_node),\n-\t\t\t  3,\n-\t\t\t  length,\n-\t\t\t  build_class_ref (class_type),\n-\t\t\t  null_pointer_node);\n+  tree call = build_call_nary (promote_type (type),\n+\t\t\t       build_address_of (soft_anewarray_node),\n+\t\t\t       3,\n+\t\t\t       length,\n+\t\t\t       build_class_ref (class_type),\n+\t\t\t       null_pointer_node);\n+\n+  return build_array_length_annotation (call, length);\n }\n \n /* Return a node the evaluates 'new TYPE[LENGTH]'. */\n@@ -1095,7 +1122,7 @@ expand_java_multianewarray (tree class_type, int ndim)\n   (*args)[0] = build_class_ref (class_type);\n   (*args)[1] = build_int_cst (NULL_TREE, ndim);\n \n-  for(i = ndim - 1; i >= 0; i-- )\n+  for (i = ndim - 1; i >= 0; i-- )\n     (*args)[(unsigned)(2 + i)] = pop_value (int_type_node);\n \n   (*args)[2 + ndim] = null_pointer_node;\n@@ -1274,7 +1301,7 @@ expand_java_return (tree type)\n       if (INT_TYPE_SIZE < 32\n \t  && (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (res)))\n \t      < GET_MODE_SIZE (TYPE_MODE (type))))\n-\tretval = build1(NOP_EXPR, TREE_TYPE(res), retval);\n+\tretval = build1 (NOP_EXPR, TREE_TYPE (res), retval);\n       \n       TREE_SIDE_EFFECTS (retval) = 1;\n       java_add_stmt (build1 (RETURN_EXPR, void_type_node, retval));\n@@ -2405,12 +2432,12 @@ static void\n expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n {\n   tree method_signature\n-    = COMPONENT_REF_SIGNATURE(&current_jcf->cpool, method_ref_index);\n+    = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, method_ref_index);\n   tree method_name = COMPONENT_REF_NAME (&current_jcf->cpool,\n \t\t\t\t\t method_ref_index);\n   tree self_type\n     = get_class_constant (current_jcf,\n-                          COMPONENT_REF_CLASS_INDEX(&current_jcf->cpool,\n+                          COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool,\n                           method_ref_index));\n   const char *const self_name\n     = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n@@ -2956,7 +2983,7 @@ load_type_state (int pc)\n   int i;\n   tree vec = (*type_states)[pc];\n   int cur_length = TREE_VEC_LENGTH (vec);\n-  stack_pointer = cur_length - DECL_MAX_LOCALS(current_function_decl);\n+  stack_pointer = cur_length - DECL_MAX_LOCALS (current_function_decl);\n   for (i = 0; i < cur_length; i++)\n     type_map [i] = TREE_VEC_ELT (vec, i);\n }"}]}