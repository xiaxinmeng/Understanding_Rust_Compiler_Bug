{"sha": "711b88243b220e3cd737696da51de70f32bb7d5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExYjg4MjQzYjIyMGUzY2Q3Mzc2OTZkYTUxZGU3MGYzMmJiN2Q1Yw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-18T00:59:49Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-18T00:59:49Z"}, "message": "[multiple changes]\n\n2000-02-17  Zack Weinberg  <zack@wolery.cumb.org>\n\n\t* cpphash.c: Don't include hashtab.h.  Most macro-handling code\n\tmoved to cppmacro.c.\n\t(hash_HASHNODE, eq_HASHNODE, _cpp_dump_macro_hash,\n\tdump_hash_helper): Delete.\n\t(expand_hash, higher_prime_number, _cpp_lookup_with_hash,\n\tcpp_forall_identifiers): New. Implement specialized version of\n\tVlad's expandable hash table.\n\t(cpp_lookup): Use new functions.\n\t(_cpp_init_macros, _cpp_cleanup_macros): Adjust for new\n\timplementation.\n\t* cppmacro.c: New file.\n\t* cppinit.c (dump_macros_helper): New.\n\t(cpp_finish): Iterate over the identifier table directly.\n\t* cpplex.c (parse_name): Calculate the hash of the identifier\n\twhile we scan it.  Use _cpp_lookup_with_hash when we can.\n\n\t* cpphash.h: Update prototypes.\n\t(xcnewvec, HASHSTEP): New helper macros.\n\t* cpplib.h: Update prototypes.\n\t* Makefile.in (LIBCPP_OBJS): Add cppmacro.o.\n\t(cppmacro.o): New rule.\n\t(cpphash.o): Update deps.\n\n\t* cppmain.c: Do not set pfile->printer if no_output is on.\n\n2000-02-15  Neil Booth  <neilb@earthling.net>\n\n\t* cpplib.c: Change all directive-handler functions to return\n\tvoid, not int.\n\t* cpphash.h: Update typedefs.\n\nFrom-SVN: r35113", "tree": {"sha": "a8929adb35764d62c4016b482a4cb4b619be00cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8929adb35764d62c4016b482a4cb4b619be00cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/711b88243b220e3cd737696da51de70f32bb7d5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711b88243b220e3cd737696da51de70f32bb7d5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/711b88243b220e3cd737696da51de70f32bb7d5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711b88243b220e3cd737696da51de70f32bb7d5c/comments", "author": null, "committer": null, "parents": [{"sha": "5d8fcdcb2ddbd52a35621a7880cf268c50a54027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d8fcdcb2ddbd52a35621a7880cf268c50a54027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d8fcdcb2ddbd52a35621a7880cf268c50a54027"}], "stats": {"total": 1625, "additions": 902, "deletions": 723}, "files": [{"sha": "16065e22b89b73e1198bffc63bcfdcdd21785456", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -1,3 +1,36 @@\n+2000-02-17  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpphash.c: Don't include hashtab.h.  Most macro-handling code\n+\tmoved to cppmacro.c.\n+\t(hash_HASHNODE, eq_HASHNODE, _cpp_dump_macro_hash,\n+\tdump_hash_helper): Delete.\n+\t(expand_hash, higher_prime_number, _cpp_lookup_with_hash,\n+\tcpp_forall_identifiers): New. Implement specialized version of\n+\tVlad's expandable hash table.\n+\t(cpp_lookup): Use new functions.\n+\t(_cpp_init_macros, _cpp_cleanup_macros): Adjust for new\n+\timplementation. \n+\t* cppmacro.c: New file.\n+\t* cppinit.c (dump_macros_helper): New.\n+\t(cpp_finish): Iterate over the identifier table directly.\n+\t* cpplex.c (parse_name): Calculate the hash of the identifier\n+\twhile we scan it.  Use _cpp_lookup_with_hash when we can.\n+\n+\t* cpphash.h: Update prototypes.\n+\t(xcnewvec, HASHSTEP): New helper macros.\n+\t* cpplib.h: Update prototypes.\n+\t* Makefile.in (LIBCPP_OBJS): Add cppmacro.o.\n+\t(cppmacro.o): New rule.\n+\t(cpphash.o): Update deps.\n+\n+\t* cppmain.c: Do not set pfile->printer if no_output is on.\n+\n+2000-02-15  Neil Booth  <neilb@earthling.net>\n+\n+\t* cpplib.c: Change all directive-handler functions to return\n+\tvoid, not int.\n+\t* cpphash.h: Update typedefs.\n+\n 2000-07-17  Geoffrey Keating  <geoffk@cygnus.com>\n \n \t* configure: Regenerate."}, {"sha": "6566b090f7d10e20a32a2fa151a0a66ae6c35347", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -1782,9 +1782,9 @@ PREPROCESSOR_DEFINES = \\\n   -DCROSS_INCLUDE_DIR=\\\"$(gcc_tooldir)/sys-include\\\" \\\n   -DTOOL_INCLUDE_DIR=\\\"$(gcc_tooldir)/include\\\"\n \n-LIBCPP_OBJS =\tcpplib.o cpphash.o cpperror.o cppexp.o cppfiles.o \\\n-\t\tcppinit.o cppulp.o cpplex.o cppdefault.o mkdeps.o \\\n-\t\tprefix.o version.o mbchar.o @extra_cpp_objs@\n+LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o \\\n+\t\tcpphash.o cpperror.o cppinit.o cppulp.o cppdefault.o \\\n+\t\tmkdeps.o prefix.o version.o mbchar.o @extra_cpp_objs@\n \n LIBCPP_DEPS =\tcpplib.h cpphash.h intl.h system.h\n \n@@ -1806,8 +1806,9 @@ cppulp.o:   cppulp.c   $(CONFIG_H) system.h output.h\n cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)\n cpplex.o:   cpplex.c   $(CONFIG_H) $(LIBCPP_DEPS)\n+cppmacro.o: cppmacro.c $(CONFIG_H) $(LIBCPP_DEPS)\n cpplib.o:   cpplib.c   $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n-cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H) $(HASHTAB_H)\n+cpphash.o:  cpphash.c  $(CONFIG_H) $(LIBCPP_DEPS) $(OBSTACK_H)\n cppfiles.o: cppfiles.c $(CONFIG_H) $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h\n cppinit.o:  cppinit.c  $(CONFIG_H) $(LIBCPP_DEPS) cppdefault.h \\\n \t\tmkdeps.h prefix.h output.h version.h"}, {"sha": "c26f7b54c4c2e2995e704fe2ec626d7cb17cb160", "filename": "gcc/cpphash.c", "status": "modified", "additions": 173, "deletions": 641, "changes": 814, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -1,4 +1,4 @@\n-/* Part of CPP library.  (Macro handling.)\n+/* Part of CPP library.  (Identifier and string tables.)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,\n    1999, 2000 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n@@ -27,720 +27,252 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"system.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n-#include \"hashtab.h\"\n #include \"obstack.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* This is the second argument to eq_HASHNODE.  */\n-struct hashdummy\n-{\n-  const U_CHAR *name;\n-  unsigned int hash;\n-  unsigned short length;\n-};\n+/* Initial hash table size.  (It can grow if necessary.)  This is the\n+   largest prime number smaller than 2**12. */\n+#define HASHSIZE 4093\n \n-/* Stores basic information about a macro, before it is allocated.  */\n-struct macro_info\n+/* This is the structure used for the hash table.  */\n+struct htab\n {\n-  const cpp_token *first_param;\t/* First parameter token.  */\n-  const cpp_token *first;\t/* First expansion token.  */\n-  unsigned int paramlen;\t/* Length of parameter names. */\n-  unsigned int len;\t\t/* Length of token strings.  */\n-  unsigned int ntokens;\t\t/* Number of tokens in expansion.  */\n-  short paramc;\t\t\t/* Number of parameters.  */\n-  unsigned char flags;\n+  struct cpp_hashnode **entries;\n+  size_t size;\n+  size_t nelts;\n };\n \n-/* Initial hash table size.  (It can grow if necessary - see hashtab.c.)  */\n-#define HASHSIZE 4096\n-\n-static unsigned int hash_HASHNODE PARAMS ((const void *));\n-static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n-static int dump_hash_helper\t  PARAMS ((void **, void *));\n-static void dump_funlike_macro\tPARAMS ((cpp_reader *, cpp_hashnode *));\n-static void count_params PARAMS ((cpp_reader *, struct macro_info *));\n-static int is__va_args__ PARAMS ((cpp_reader *, const cpp_token *));\n-\n-static int parse_define PARAMS((cpp_reader *, struct macro_info *));\n-static int check_macro_redefinition PARAMS((cpp_reader *, cpp_hashnode *hp,\n-\t\t\t\t\t    const cpp_toklist *));\n-static const cpp_toklist * save_expansion PARAMS((cpp_reader *,\n- \t\t\t\t\t\t  struct macro_info *));\n-static unsigned int find_param PARAMS ((const cpp_token *,\n- \t\t\t\t\tconst cpp_token *));\n-static cpp_toklist * alloc_macro PARAMS ((cpp_reader *, struct macro_info *));\n-\n-/* Calculate hash of a string of length LEN.  */\n-unsigned int\n-_cpp_calc_hash (str, len)\n-     const U_CHAR *str;\n-     size_t len;\n-{\n-  size_t n = len;\n-  unsigned int r = 0;\n-\n-  do\n-    r = r * 67 + (*str++ - 113);\n-  while (--n);\n-  return r + len;\n-}\n-\n-/* Calculate hash of a cpp_hashnode structure.  */\n-static unsigned int\n-hash_HASHNODE (x)\n-     const void *x;\n-{\n-  const cpp_hashnode *h = (const cpp_hashnode *)x;\n-  return h->hash;\n-}\n-\n-/* Compare a cpp_hashnode structure (already in the table) with a\n-   hashdummy structure (not yet in the table).  This relies on the\n-   rule that the existing entry is the first argument, the potential\n-   entry the second.  It also relies on the comparison function never\n-   being called except as a direct consequence of a call to\n-   the htab_find routines.  */\n-static int\n-eq_HASHNODE (x, y)\n-     const void *x;\n-     const void *y;\n-{\n-  const cpp_hashnode *a = (const cpp_hashnode *)x;\n-  const struct hashdummy *b = (const struct hashdummy *)y;\n-\n-  return (a->hash == b->hash\n-\t  && a->length == b->length\n-\t  && !memcmp (a->name, b->name, a->length));\n-}\n-\n-/* Find the hash node for name \"name\", of length LEN.  */\n-\n-cpp_hashnode *\n-cpp_lookup (pfile, name, len)\n-     cpp_reader *pfile;\n-     const U_CHAR *name;\n-     int len;\n-{\n-  struct hashdummy dummy;\n-  cpp_hashnode *new, **slot;\n-  unsigned int hash;\n-  U_CHAR *p;\n-\n-  dummy.name = name;\n-  dummy.length = len;\n-  dummy.hash = hash = _cpp_calc_hash (name, len);\n-\n-  slot = (cpp_hashnode **)\n-    htab_find_slot_with_hash (pfile->hashtab, (void *)&dummy, hash, INSERT);\n-  if (*slot)\n-    return *slot;\n-\n-  /* Create a new hash node.  */\n-  p = obstack_alloc (pfile->hash_ob, sizeof (cpp_hashnode) + len);\n-  new = (cpp_hashnode *)p;\n-  p += offsetof (cpp_hashnode, name);\n-\n-  new->type = T_VOID;\n-  new->length = len;\n-  new->hash = hash;\n-  new->fe_value = 0;\n-  new->value.expansion = NULL;\n-\n-  memcpy (p, name, len);\n-  p[len] = 0;\n-\n-  *slot = new;\n-  return new;\n-}\n+static void expand_hash PARAMS ((struct htab *));\n+static unsigned long higher_prime_number PARAMS ((unsigned long));\n \n /* Set up and tear down internal structures for macro expansion.  */\n void\n _cpp_init_macros (pfile)\n      cpp_reader *pfile;\n {\n-  pfile->hashtab = htab_create (HASHSIZE, hash_HASHNODE,\n-\t\t\t\teq_HASHNODE, (htab_del) _cpp_free_definition);\n   pfile->hash_ob = xnew (struct obstack);\n   obstack_init (pfile->hash_ob);\n-}\n-\n-void\n-_cpp_cleanup_macros (pfile)\n-     cpp_reader *pfile;\n-{\n-  htab_delete (pfile->hashtab);\n-  obstack_free (pfile->hash_ob, 0);\n-  free (pfile->hash_ob);\n-}\n-\n-/* Free the definition of macro H.  */\n-\n-void\n-_cpp_free_definition (h)\n-     cpp_hashnode *h;\n-{\n-  if (h->type == T_MACRO)\n-    free ((PTR) h->value.expansion);\n-  h->value.expansion = NULL;\n-}\n \n-/* Scans for a given token, returning the parameter number if found,\n-   or 0 if not found.  Scans from FIRST to TOKEN - 1 or the first\n-   CPP_CLOSE_PAREN for TOKEN.  */\n-static unsigned int\n-find_param (first, token)\n-     const cpp_token *first, *token;\n-{\n-  unsigned int param = 0;\n-\n-  for (; first < token && first->type != CPP_CLOSE_PAREN; first++)\n-    if (first->type == CPP_NAME)\n-      {\n-\tparam++;\n-\tif (first->val.node == token->val.node)\n-\t  return param;\n-      }\n+  pfile->hashtab = xobnew (pfile->hash_ob, struct htab);\n \n-  return 0;\n+  pfile->hashtab->nelts = 0;\n+  pfile->hashtab->size = HASHSIZE;\n+  pfile->hashtab->entries = xcnewvec (cpp_hashnode *, HASHSIZE);\n }\n \n-/* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n-   replacement list of a variable-arguments macro.  TOKEN is assumed\n-   to be of type CPP_NAME.  */\n-static int\n-is__va_args__ (pfile, token)\n-     cpp_reader *pfile;\n-     const cpp_token *token;\n-{\n-  if (!CPP_PEDANTIC (pfile)\n-      || token->val.node != pfile->spec_nodes->n__VA_ARGS__)\n-    return 0;\n-\n-  cpp_pedwarn_with_line (pfile, token->line, token->col,\n-       \"\\\"%s\\\" is only valid in the replacement list of a function-like macro\",\n-\t\t       token->val.node->name);\n-  return 1;\n-}\n-\n-/* Counts the parameters to a function-like macro, the length of their\n-   null-terminated names, and whether the macro is a variable-argument\n-   one.  FIRST is the token immediately after the open parenthesis,\n-   INFO stores the data.\n-\n-   On success, info->first is updated to the token after the closing\n-   parenthesis, i.e. the first token of the expansion.  Otherwise\n-   there was an error, which has been reported.  */\n-static void\n-count_params (pfile, info)\n+void\n+_cpp_cleanup_macros (pfile)\n      cpp_reader *pfile;\n-     struct macro_info *info;\n {\n-  unsigned int prev_ident = 0;\n-  const cpp_token *token;\n+  cpp_hashnode **p, **limit;\n \n-  info->paramc = 0;\n-  info->paramlen = 0;\n-  info->flags = 0;\n-  info->first = info->first_param; /* Not a ')' indicating success.  */\n-\n-  for (token = info->first_param;; token++)\n+  p = pfile->hashtab->entries;\n+  limit = p + pfile->hashtab->size;\n+  do\n     {\n-      switch (token->type)\n+      if (*p)\n \t{\n-\tdefault:\n-\t  cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t       \"illegal token in macro parameter list\");\n-\t  return;\n-\n-\tcase CPP_EOF:\n-\tmissing_paren:\n-\t  cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t       \"missing ')' in macro parameter list\");\n-\t  return;\n-\n-\tcase CPP_COMMENT:\n-\t  continue;\t\t/* Ignore -C comments.  */\n-\n-\tcase CPP_NAME:\n-\t  if (prev_ident)\n-\t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t   \"macro parameters must be comma-separated\");\n-\t      return;\n-\t    }\n-\n-\t  /* Constraint 6.10.3.5  */\n-\t  if (is__va_args__ (pfile, token))\n-\t    return;\n-\n-\t  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n-\t  if (find_param (info->first, token))\n-\t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t\t   \"duplicate macro parameter \\\"%s\\\"\",\n-\t\t\t\t   token->val.node->name);\n-\t      return;\n-\t    }\n-\n-\t  prev_ident = 1;\n-\t  info->paramc++;\n-\t  info->paramlen += token->val.node->length + 1;\n-\t  continue;\n-\n-\tcase CPP_CLOSE_PAREN:\n-\t  if (prev_ident || info->paramc == 0)\n-\t    break;\n-\n-\t  /* Fall through to pick up the error.  */\n-\tcase CPP_COMMA:\n-\t  if (!prev_ident)\n-\t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t\t   \"parameter name expected\");\n-\t      return;\n-\t    }\n-\t  prev_ident = 0;\n-\t  continue;\n-\n-\tcase CPP_ELLIPSIS:\n-\t  /* Convert ISO-style var_args to named varargs by changing\n-\t     the ellipsis into an identifier with name __VA_ARGS__.\n-\t     This simplifies other handling. */\n-\t  if (!prev_ident)\n-\t    {\n-\t      cpp_token *tok = (cpp_token *) token;\n-\n-\t      tok->type = CPP_NAME;\n-\t      tok->val.node = pfile->spec_nodes->n__VA_ARGS__;\n-\n-\t      info->paramc++;\n-\t      info->paramlen += tok->val.node->length + 1;\n-\n-\t      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n-\t\tcpp_pedwarn (pfile,\n-\t\t\t     \"C89 does not permit anon varargs macros\");\n-\t    }\n-\t  else\n-\t    {\n-\t      info->flags |= GNU_REST_ARGS;\n-\t      if (CPP_PEDANTIC (pfile))\n-\t\tcpp_pedwarn (pfile,\n-\t\t\t     \"ISO C does not permit named varargs parameters\");\n-\t    }\n-\n-\t  info->flags |= VAR_ARGS;\n-\t  token++;\n-\t  if (token->type == CPP_CLOSE_PAREN)\n-\t    break;\n-\t  goto missing_paren;\n+\t  _cpp_free_definition (*p);\n+\t  (*p)->fe_value = 0;  /* expose the node to GC */\n \t}\n-\n-      /* Success.  */\n-      info->first = token + 1;\n-      if (!pfile->save_parameter_spellings)\n-\tinfo->paramlen = 0;\n-      return;\n     }\n+  while (++p < limit);\n+\n+  free (pfile->hashtab->entries);\n+  obstack_free (pfile->hash_ob, 0);\n+  free (pfile->hash_ob);\n }\n \n-/* Parses a #define directive.  On success, returns zero, and INFO is\n-   filled in appropriately.  */\n-static int\n-parse_define (pfile, info)\n+/* The code below is a specialization of Vladimir Makarov's expandable\n+   hash tables (see libiberty/hashtab.c).  The abstraction penalty was\n+   too high to continue using the generic form.  This code knows\n+   intrinsically how to calculate a hash value, and how to compare an\n+   existing entry with a potential new one.  Also, the ability to\n+   delete members from the table has been removed.  */\n+\n+cpp_hashnode *\n+cpp_lookup (pfile, name, len)\n      cpp_reader *pfile;\n-     struct macro_info *info;\n+     const U_CHAR *name;\n+     size_t len;\n {\n-  const cpp_token *token;\n-  int prev_white = 0;\n-\n-  /* The first token after the macro's name.  */\n-  token = _cpp_get_token (pfile);\n-\n-  /* Constraint 6.10.3.5  */\n-  if (is__va_args__ (pfile, token - 1))\n-    return 1;\n-\n-  while (token->type == CPP_COMMENT)\n-    token++, prev_white = 1;\n-  prev_white |= token->flags & PREV_WHITE;\n+  size_t n = len;\n+  unsigned int r = 0;\n+  const U_CHAR *str = name;\n \n-  if (token->type == CPP_OPEN_PAREN && !prev_white)\n-    {\n-      /* A function-like macro.  */\n-      info->first_param = token + 1;\n-      count_params (pfile, info);\n-      if (info->first[-1].type != CPP_CLOSE_PAREN)\n-\treturn 1;\n-    }\n-  else\n+  do\n     {\n-      /* An object-like macro.  */\n-      info->paramc = -1;\n-      info->paramlen = 0;\n-      info->flags = 0;\n-      info->first = token;\n-      if (!prev_white && token->type != CPP_EOF)\n-\tcpp_pedwarn (pfile, \"ISO C requires whitespace after the macro name\");\n+      r = HASHSTEP (r, str);\n+      str++;\n     }\n+  while (--n);\n \n-  /* Count tokens in expansion.  We drop paste tokens, and stringize\n-     tokens, so don't count them.  */\n-  info->ntokens = info->len = 0;\n-  for (token = info->first; token->type != CPP_EOF; token++)\n-    {\n-      if (token->type == CPP_PASTE)\n-\t{\n-\t  /* Token-paste ##, can appear in both object-like and\n-\t     function-like macros, but not at the ends.  Constraint\n-\t     6.10.3.3.1 */\n-\t  if (token == info->first || token[1].type == CPP_EOF)\n-\t    {\n-\t      cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\"'##' cannot appear at either end of a macro expansion\");\n-\t      return 1;\n-\t    }\n-\t  continue;\n-\t}\n-      else if (token->type == CPP_HASH)\n-\t{\n-\t  /* Stringifying #, but a normal character in object-like\n-             macros.  Must come before a parameter name.  Constraint\n-             6.10.3.2.1.  */\n-\t  if (info->paramc >= 0)\n-\t    {\n-\t      if (token[1].type == CPP_NAME\n-\t\t  && find_param (info->first_param, token + 1))\n-\t\tcontinue;\n-\t      if (! CPP_OPTION (pfile, lang_asm))\n-\t\t{\n-\t\t  cpp_error_with_line (pfile, token->line, token->col,\n-\t\t\t       \"'#' is not followed by a macro parameter\");\n-\t\t  return 1;\n-\t\t}\n-\t    }\n-\t}\n-      else if (token->type == CPP_NAME)\n-\t{\n-\t  /* Constraint 6.10.3.5  */\n-\t  if (!(info->flags & VAR_ARGS) && is__va_args__ (pfile, token))\n-\t    return 1;\n-\t  /* It might be worth doing a check here that we aren't a\n-\t     macro argument, since we don't store the text of macro\n-\t     arguments.  This would reduce \"len\" and save space.  */\n-\t}\n-      info->ntokens++;\n-      if (TOKEN_SPELL (token) == SPELL_STRING)\n-\tinfo->len += token->val.str.len;\n-    }\n-  \n-  return 0;\n+  return _cpp_lookup_with_hash (pfile, name, len, r);\n }\n \n-/* Returns non-zero if a macro redefinition is trivial.  */\n-static int\n-check_macro_redefinition (pfile, hp, list2)\n+cpp_hashnode *\n+_cpp_lookup_with_hash (pfile, name, len, hash)\n      cpp_reader *pfile;\n-     cpp_hashnode *hp;\n-     const cpp_toklist *list2;\n+     const U_CHAR *name;\n+     size_t len;\n+     unsigned int hash;\n {\n-  const cpp_toklist *list1;\n+  unsigned int index;\n+  unsigned int hash2;\n+  size_t size;\n+  cpp_hashnode *entry;\n+  cpp_hashnode **entries;\n \n-  if (hp->type != T_MACRO)\n-    return ! pfile->done_initializing;\n+  entries = pfile->hashtab->entries;\n+  size = pfile->hashtab->size;\n \n-  /* Clear the whitespace and BOL flags of the first tokens.  They get\n-     altered during macro expansion, but is not significant here.  */\n-  list1  = hp->value.expansion;\n-  list1->tokens[0].flags &= ~(PREV_WHITE|BOL);\n-  list2->tokens[0].flags &= ~(PREV_WHITE|BOL);\n+  hash += len;\n+  index = hash % size;\n \n-  if (!_cpp_equiv_toklists (list1, list2))\n-    return 0;\n+  entry = entries[index];\n+  if (entry == NULL)\n+    goto insert;\n+  if (entry->hash == hash && entry->length == len\n+      && !memcmp (entry->name, name, len))\n+    return entry;\n \n-  if (CPP_OPTION (pfile, pedantic)\n-      && list1->paramc > 0\n-      && (list1->params_len != list2->params_len\n-\t  || memcmp (list1->namebuf, list2->namebuf, list1->params_len)))\n-    return 0;\n+  hash2 = 1 + hash % (size - 2);\n \n-  return 1;\n-}\n-\n-/* This is a dummy structure whose only purpose is getting alignment\n-   correct.  */\n-struct toklist_dummy\n-{\n-  cpp_toklist list;\n-  cpp_token first_token;\n-};\n-\n-\n-/* Allocate space to hold the token list, its tokens, their text, and\n-   the parameter names if needed.  Empty expansions are stored as a\n-   single placemarker token.\n-\n-   These are all allocated in a block together for performance\n-   reasons.  Therefore, this token list cannot be expanded like a\n-   normal token list.  Try to do so, and you lose.  */\n-static cpp_toklist *\n-alloc_macro (pfile, info)\n-     cpp_reader *pfile;\n-     struct macro_info *info;\n-{\n-  unsigned int size;\n-  struct toklist_dummy *dummy;\n-  cpp_toklist *list;\n-\n-  /* Empty macros become a single placemarker token.  */\n-  if (info->ntokens == 0)\n-    info->ntokens = 1;\n-\n-  size = sizeof (struct toklist_dummy);\n-  size += (info->ntokens - 1) * sizeof(cpp_token);\n-  size += info->len + info->paramlen;\n-\n-  dummy = (struct toklist_dummy *) xmalloc (size);\n-  list = (cpp_toklist *) dummy;\n-  \n-  /* Initialize the monster.  */\n-  list->tokens = &dummy->first_token;\n-  list->tokens_used = list->tokens_cap = info->ntokens;\n-\n-  list->namebuf = (unsigned char *) &list->tokens[info->ntokens];\n-  list->name_used = list->name_cap = info->len + info->paramlen;\n-\n-  list->directive = 0;\n-  list->line = pfile->token_list.line;\n-  list->file = pfile->token_list.file;\n-  list->params_len = info->paramlen;\n-  list->paramc = info->paramc;\n-  list->flags = info->flags;\n-\n-  return list;\n-}\n-\n-/* Copy the tokens of the expansion, beginning with info->first until\n-   CPP_EOF.  INFO contains information about the macro.\n-\n-   Change the type of macro arguments in the expansion from CPP_NAME\n-   to CPP_MACRO_ARG.  Remove #'s that represent stringification,\n-   flagging the CPP_MACRO_ARG it operates on STRINGIFY.  Remove ##'s,\n-   flagging the token on its immediate left PASTE_LEFT.  Returns the\n-   token list for the macro expansion.  */\n-static const cpp_toklist *\n-save_expansion (pfile, info)\n-     cpp_reader *pfile;\n-     struct macro_info *info;\n-{\n-  const cpp_token *token;\n-  cpp_toklist *list;\n-  cpp_token *dest;\n-  unsigned char *buf;\n-      \n-  list = alloc_macro (pfile, info);\n-  buf = list->namebuf;\n-\n-  /* Store the null-terminated parameter spellings of a macro, to\n-     provide pedantic warnings to satisfy 6.10.3.2, or for use when\n-     dumping macro definitions.  They must go first.  */\n-  if (list->params_len)\n-    for (token = info->first_param; token < info->first; token++)\n-      if (token->type == CPP_NAME)\n-\t{\n-\t  /* Copy null too.  */\n-\t  memcpy (buf, token->val.node->name, token->val.node->length + 1);\n-\t  buf += token->val.node->length + 1;\n-\t}\n-\n-  dest = list->tokens;\n-  for (token = info->first; token->type != CPP_EOF; token++)\n+  for (;;)\n     {\n-      unsigned int param_no;\n-\n-      switch (token->type)\n-\t{\n-\tcase CPP_NAME:\n-\t  if (list->paramc == -1)\n-\t    break;\n-\n-\t  /* Check if the name is a macro parameter.  */\n-\t  param_no = find_param (info->first_param, token);\n-\t  if (param_no == 0)\n-\t    break;\n-\t  dest->val.aux = param_no - 1;\n-\n-\t  dest->type = CPP_MACRO_ARG;\n-\t  if (token[-1].type == CPP_HASH)\n-\t    dest->flags = token[-1].flags | STRINGIFY_ARG;\n-\t  else\n-\t    dest->flags = token->flags;  /* Particularly PREV_WHITE.  */\n-\t  /* Turn off PREV_WHITE if we immediately follow a paste.\n-\t     That way, even if the paste turns out to be illegal, there\n-\t     will be no space between the two tokens in the output.  */\n-\t  if (token[-1].type == CPP_PASTE)\n-\t    dest->flags &= ~PREV_WHITE;\n-\t  dest++;\n-\t  continue;\n-\n-\tcase CPP_PASTE:\n-\t  dest[-1].flags |= PASTE_LEFT;\n-\t  continue;\n-\n-\tcase CPP_HASH:\n-\t  /* Stringifying #.  Constraint 6.10.3.2.1  */\n-\t  if (list->paramc >= 0 && token[1].type == CPP_NAME\n-\t      && find_param (info->first_param, token + 1))\n-\t    continue;\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      /* Copy the token.  */\n-      *dest = *token;\n-      if (TOKEN_SPELL (token) == SPELL_STRING)\n-\t{\n-\t  memcpy (buf, token->val.str.text, token->val.str.len);\n-\t  dest->val.str.text = buf;\n-\t  buf += dest->val.str.len;\n-\t}\n-      if (token[-1].type == CPP_PASTE)\n-\tdest->flags &= ~PREV_WHITE;\n-      dest++;\n+      index += hash2;\n+      if (index >= size)\n+\tindex -= size;\n+      entry = entries[index];\n+\n+      if (entry == NULL)\n+\tgoto insert;\n+      if (entry->hash == hash && entry->length == len\n+\t  && !memcmp (entry->name, name, len))\n+\treturn entry;\n     }\n \n-  /* Empty macros become a single placemarker token.  */\n-  if (dest == list->tokens)\n-    {\n-      dest->type = CPP_PLACEMARKER;\n-      dest->flags = 0;\n-    }\n+ insert:\n+  pfile->hashtab->nelts++;\n \n-  return list;\n+  /* Create a new hash node.  */\n+  {\n+    U_CHAR *p = obstack_alloc (pfile->hash_ob, sizeof (cpp_hashnode) + len);\n+    entry = (cpp_hashnode *)p;\n+    p += offsetof (cpp_hashnode, name);\n+    \n+    entry->type = T_VOID;\n+    entry->fe_value = 0;\n+    entry->length = len;\n+    entry->hash = hash;\n+    entry->value.expansion = NULL;\n+    memcpy (p, name, len);\n+    p[len] = 0;\n+\n+    entries[index] = entry;\n+  }\n+\n+  if (size * 3 <= pfile->hashtab->nelts * 4)\n+    expand_hash (pfile->hashtab);\n+\n+  return entry;\n }\n \n-/* Parse a macro and save its expansion.  Returns non-zero on success.  */\n-int\n-_cpp_create_definition (pfile, hp)\n-     cpp_reader *pfile;\n-     cpp_hashnode *hp;\n+static void\n+expand_hash (htab)\n+     struct htab *htab;\n {\n-  struct macro_info info;\n-  const cpp_toklist *list;\n+  cpp_hashnode **oentries;\n+  cpp_hashnode **olimit;\n+  cpp_hashnode **p;\n+  size_t size;\n \n-  if (parse_define (pfile, &info))\n-    return 0;\n-  list = save_expansion (pfile, &info);\n+  oentries = htab->entries;\n+  olimit = oentries + htab->size;\n \n-  /* Check for a redefinition.  Redefinition of a macro is allowed if\n-     and only if the old and new definitions are the same.\n-     (6.10.3 paragraph 2). */\n+  htab->size = size = higher_prime_number (htab->size * 2);\n+  htab->entries = xcnewvec (cpp_hashnode *, size);\n \n-  if (hp->type != T_VOID)\n+  for (p = oentries; p < olimit; p++)\n     {\n-      if (!check_macro_redefinition (pfile, hp, list))\n+      if (*p != NULL)\n \t{\n-\t  cpp_pedwarn (pfile, \"\\\"%s\\\" redefined\", hp->name);\n-\t  if (pfile->done_initializing && hp->type == T_MACRO)\n-\t    cpp_pedwarn_with_file_and_line (pfile,\n-\t\t\t\t\t    hp->value.expansion->file,\n-\t\t\t\t\t    hp->value.expansion->line, 1,\n-\t\t\t    \"this is the location of the previous definition\");\n-\t}\n-      _cpp_free_definition (hp);\n-    }\n-\n-  /* Enter definition in hash table.  */\n-  hp->type = T_MACRO;\n-  hp->value.expansion = list;\n+\t  unsigned int index;\n+\t  unsigned int hash, hash2;\n+\t  cpp_hashnode *entry = *p;\n \n-  return 1;\n-}\n+\t  hash = entry->hash;\n+\t  index = hash % size;\n \n-/* Dump the definition of macro MACRO on stdout.  The format is suitable\n-   to be read back in again. */\n+\t  if (htab->entries[index] == NULL)\n+\t    {\n+\t    insert:\n+\t      htab->entries[index] = entry;\n+\t      continue;\n+\t    }\n \n-void\n-_cpp_dump_definition (pfile, hp)\n-     cpp_reader *pfile;\n-     cpp_hashnode *hp;\n-{\n-  CPP_RESERVE (pfile, hp->length + sizeof \"#define \");\n-  CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" - 1);\n-  CPP_PUTS_Q (pfile, hp->name, hp->length);\n+\t  hash2 = 1 + hash % (size - 2);\n+\t  for (;;)\n+\t    {\n+\t      index += hash2;\n+\t      if (index >= size)\n+\t\tindex -= size;\n \n-  if (hp->type == T_MACRO)\n-    {\n-      if (hp->value.expansion->paramc >= 0)\n-\tdump_funlike_macro (pfile, hp);\n-      else\n-\t{\n-\t  const cpp_toklist *list = hp->value.expansion;\n-\t  list->tokens[0].flags &= ~BOL;\n-\t  list->tokens[0].flags |= PREV_WHITE;\n-\t  _cpp_dump_list (pfile, list, list->tokens, 1);\n+\t      if (htab->entries[index] == NULL)\n+\t\tgoto insert;\n+\t    }\n \t}\n     }\n-  else\n-    cpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n \n-  if (CPP_BUFFER (pfile) == 0 || ! pfile->done_initializing)\n-    CPP_PUTC (pfile, '\\n');\n+  free (oentries);\n }\n \n-static void\n-dump_funlike_macro (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+/* The following function returns the nearest prime number which is\n+   greater than a given source number, N. */\n+\n+static unsigned long\n+higher_prime_number (n)\n+     unsigned long n;\n {\n-  int i = 0;\n-  const cpp_toklist * list = node->value.expansion;\n-  const U_CHAR *param;\n+  unsigned long i;\n \n-  param = list->namebuf;\n-  CPP_PUTC_Q (pfile, '(');\n-  for (i = 0; i++ < list->paramc;)\n-    {\n-      unsigned int len;\n+  /* Ensure we have a larger number and then force to odd.  */\n+  n++;  \n+  n |= 0x01; \n \n-      len = ustrlen (param);\n-      CPP_PUTS (pfile, param, len);\n-      if (i < list->paramc)\n-\tCPP_PUTS(pfile, \", \", 2);\n-      else if (list->flags & VAR_ARGS)\n-\t{\n-\t  if (!ustrcmp (param, U\"__VA_ARGS__\"))\n-\t    pfile->limit -= sizeof (U\"__VA_ARGS__\") - 1;\n-\t  CPP_PUTS_Q (pfile, \"...\", 3);\n-\t}\n-      param += len + 1;\n-    }\n-  CPP_PUTC (pfile, ')');\n-  list->tokens[0].flags &= ~BOL;\n-  list->tokens[0].flags |= PREV_WHITE;\n-  _cpp_dump_list (pfile, list, list->tokens, 1);\n-}\n+  /* All odd numbers < 9 are prime.  */\n+  if (n < 9)\n+    return n;\n \n-/* Dump out the hash table.  */\n-static int\n-dump_hash_helper (h, p)\n-     void **h;\n-     void *p;\n-{\n-  cpp_hashnode *hp = (cpp_hashnode *)*h;\n-  cpp_reader *pfile = (cpp_reader *)p;\n+  /* Otherwise find the next prime using a sieve.  */\n+\n+ next:\n+  for (i = 3; i * i <= n; i += 2)\n+    if (n % i == 0)\n+      {\n+\t n += 2;\n+\t goto next;\n+       }\n \n-  if (hp->type == T_MACRO)\n-    _cpp_dump_definition (pfile, hp);\n-  return 1;\n+  return n;\n }\n \n void\n-_cpp_dump_macro_hash (pfile)\n+cpp_forall_identifiers (pfile, cb)\n      cpp_reader *pfile;\n+     int (*cb) PARAMS ((cpp_reader *, cpp_hashnode *));\n {\n-  htab_traverse (pfile->hashtab, dump_hash_helper, pfile);\n+    cpp_hashnode **p, **limit;\n+\n+  p = pfile->hashtab->entries;\n+  limit = p + pfile->hashtab->size;\n+  do\n+    {\n+      if (*p)\n+\tif ((*cb) (pfile, *p) == 0)\n+\t  break;\n+    }\n+  while (++p < limit);\n }"}, {"sha": "98fcbb67ecff661679411ee63eeb67ba17cc3d29", "filename": "gcc/cpphash.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -72,7 +72,7 @@ struct answer\n #define COMMENTS\t(1 << 3)\n \n /* Defines one #-directive, including how to handle it.  */\n-typedef int (*directive_handler) PARAMS ((cpp_reader *));\n+typedef void (*directive_handler) PARAMS ((cpp_reader *));\n struct directive\n {\n   directive_handler handler;\t/* Function to handle directive.  */\n@@ -202,18 +202,24 @@ extern unsigned char _cpp_IStable[256];\n #define CPP_WTRADITIONAL(PF) \\\n   (CPP_OPTION (PF, warn_traditional) && !CPP_IN_SYSTEM_HEADER (PF))\n \n+/* Hash step.  The hash calculation is duplicated in cpp_lookup and\n+   parse_name.  */\n+#define HASHSTEP(r, str) ((r) * 67 + (*str - 113));\n+\n /* Flags for _cpp_init_toklist.  */\n #define DUMMY_TOKEN     0\n #define NO_DUMMY_TOKEN\t1\n \n-/* In cpphash.c */\n-extern unsigned int _cpp_calc_hash\tPARAMS ((const U_CHAR *, size_t));\n+/* In cppmacro.c */\n extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n+\n+/* In cpphash.c */\n extern void _cpp_init_macros\t\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_macros\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_dump_macro_hash\tPARAMS ((cpp_reader *));\n+extern cpp_hashnode *_cpp_lookup_with_hash PARAMS ((cpp_reader*, const U_CHAR *,\n+\t\t\t\t\t\t    size_t, unsigned int));\n \n /* In cppfiles.c */\n extern void _cpp_simplify_pathname\tPARAMS ((char *));\n@@ -278,6 +284,7 @@ extern void _cpp_cleanup_stacks\tPARAMS ((cpp_reader *));\n /* Utility routines and macros.  */\n #define xnew(T)\t\t(T *) xmalloc (sizeof(T))\n #define xnewvec(T, N)\t(T *) xmalloc (sizeof(T) * (N))\n+#define xcnewvec(T, N)\t(T *) xcalloc (N, sizeof(T))\n #define xobnew(O, T)\t(T *) obstack_alloc (O, sizeof(T))\n \n /* These are inline functions instead of macros so we can get type"}, {"sha": "a58f459b8baa1028acaf0e0ad5067bfe0e143dfc", "filename": "gcc/cppinit.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -114,6 +114,7 @@ static int opt_comp\t\t\tPARAMS ((const void *, const void *));\n static void sort_options\t\tPARAMS ((void));\n #endif\n static int parse_option\t\t\tPARAMS ((const char *));\n+static int dump_macros_helper\t\tPARAMS ((cpp_reader *, cpp_hashnode *));\n \n /* Fourth argument to append_include_chain: chain to use */\n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n@@ -891,6 +892,18 @@ cpp_start_read (pfile, print, fname)\n   return 1;\n }\n \n+\n+/* Dump out the hash table.  */\n+static int\n+dump_macros_helper (pfile, hp)\n+     cpp_reader *pfile;\n+     cpp_hashnode *hp;\n+{\n+  if (hp->type == T_MACRO)\n+    _cpp_dump_definition (pfile, hp);\n+  return 1;\n+}\n+\n /* This is called at the end of preprocessing.  It pops the\n    last buffer and writes dependency output.  It should also\n    clear macro definitions, such that you could call cpp_start_read\n@@ -934,7 +947,7 @@ cpp_finish (pfile, print)\n     }\n \n   if (CPP_OPTION (pfile, dump_macros) == dump_only)\n-    _cpp_dump_macro_hash (pfile);\n+    cpp_forall_identifiers (pfile, dump_macros_helper);\n \n   /* Flush any pending output.  */\n   if (print)"}, {"sha": "a41e4eea6edffa45d519a2a7b666f9cb451b7462", "filename": "gcc/cpplex.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -1070,16 +1070,21 @@ skip_whitespace (pfile, in_directive)\n     }\n }\n \n-/* Parse (append) an identifier.  */\n+/* Parse (append) an identifier.  Calculates the hash value of the\n+   token while parsing, for performance.  The algorithm *must* match\n+   cpp_lookup().  */\n static const U_CHAR *\n parse_name (pfile, tok, cur, rlimit)\n      cpp_reader *pfile;\n      cpp_token *tok;\n      const U_CHAR *cur, *rlimit;\n {\n-  const U_CHAR *name = cur;\n+  const U_CHAR *name;\n   unsigned int len;\n+  unsigned int r;\n \n+  name = cur;\n+  r = 0;\n   while (cur < rlimit)\n     {\n       if (! is_idchar (*cur))\n@@ -1092,21 +1097,23 @@ parse_name (pfile, tok, cur, rlimit)\n \t  CPP_BUFFER (pfile)->cur = cur;\n \t  cpp_pedwarn (pfile, \"'$' character in identifier\");\n \t}\n+\n+      r = HASHSTEP (r, cur);\n       cur++;\n     }\n   len = cur - name;\n \n-  if (tok->val.node)\n+  if (tok->val.node == 0)\n+    tok->val.node = _cpp_lookup_with_hash (pfile, name, len, r);\n+  else\n     {\n       unsigned int oldlen = tok->val.node->length;\n       U_CHAR *newname = alloca (oldlen + len);\n       memcpy (newname, tok->val.node->name, oldlen);\n       memcpy (newname + oldlen, name, len);\n-      len += oldlen;\n-      name = newname;\n+      tok->val.node = cpp_lookup (pfile, newname, len + oldlen);\n     }\n \n-  tok->val.node = cpp_lookup (pfile, name, len);\n   return cur;\n }\n "}, {"sha": "adbd8d1e8aed2ea2d7160061fd2e6516d062d1b8", "filename": "gcc/cpplib.c", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -113,7 +113,7 @@ SCCS_ENTRY\t\t\t\t\t\t   /*      0 SVR2? */\n    pointers to functions returning void.  */\n \n /* Don't invoke CONCAT2 with any whitespace or K&R cc will fail. */\n-#define D(name, t, o, f) static int CONCAT2(do_,name) PARAMS ((cpp_reader *));\n+#define D(name, t, o, f) static void CONCAT2(do_,name) PARAMS ((cpp_reader *));\n DIRECTIVE_TABLE\n #undef D\n \n@@ -272,7 +272,7 @@ get_define_node (pfile)\n }\n \n /* Process a #define command.  */\n-static int\n+static void\n do_define (pfile)\n      cpp_reader *pfile;\n {\n@@ -287,11 +287,10 @@ do_define (pfile)\n \telse if (CPP_OPTION (pfile, dump_macros) == dump_names)\n \t  dump_macro_name (pfile, node);\n       }\n-  return 0;\n }\n \n /* Remove the definition of a symbol from the symbol table.  */\n-static int\n+static void\n do_undef (pfile)\n      cpp_reader *pfile;\n {\n@@ -317,8 +316,6 @@ do_undef (pfile)\n       _cpp_free_definition (node);\n       node->type = T_VOID;\n     }\n-\n-  return 0;\n }\n \n \n@@ -360,7 +357,7 @@ parse_include (pfile, dir, trail, strp, lenp, abp)\n   return 0;\n }\n \n-static int\n+static void\n do_include (pfile)\n      cpp_reader *pfile;\n {\n@@ -369,15 +366,14 @@ do_include (pfile)\n   int ab;\n \n   if (parse_include (pfile, dtable[T_INCLUDE].name, 0, &str, &len, &ab))\n-    return 0;\n+    return;\n \n   _cpp_execute_include (pfile, str, len, 0, 0, ab);\n   if (CPP_OPTION (pfile, dump_includes))\n     pass_thru_directive (pfile);\n-  return 0;\n }\n \n-static int\n+static void\n do_import (pfile)\n      cpp_reader *pfile;\n {\n@@ -394,15 +390,14 @@ do_import (pfile)\n     }\n \n   if (parse_include (pfile, dtable[T_IMPORT].name, 0, &str, &len, &ab))\n-    return 0;\n+    return;\n \n   _cpp_execute_include (pfile, str, len, 1, 0, ab);\n   if (CPP_OPTION (pfile, dump_includes))\n     pass_thru_directive (pfile);\n-  return 0;\n }\n \n-static int\n+static void\n do_include_next (pfile)\n      cpp_reader *pfile;\n {\n@@ -412,7 +407,7 @@ do_include_next (pfile)\n   int ab;\n \n   if (parse_include (pfile, dtable[T_INCLUDE_NEXT].name, 0, &str, &len, &ab))\n-    return 0;\n+    return;\n \n   /* For #include_next, skip in the search path past the dir in which\n      the current file was found.  If this is the last directory in the\n@@ -426,7 +421,7 @@ do_include_next (pfile)\n \t{\n \t  search_start = CPP_BUFFER (pfile)->inc->foundhere->next;\n \t  if (!search_start)\n-\t    return 0;\n+\t    return;\n \t}\n     }\n   else\n@@ -435,8 +430,6 @@ do_include_next (pfile)\n   _cpp_execute_include (pfile, str, len, 0, search_start, ab);\n   if (CPP_OPTION (pfile, dump_includes))\n     pass_thru_directive (pfile);\n-\n-  return 0;\n }\n \n /* Subroutine of do_line.  Read next token from PFILE without adding it to\n@@ -494,7 +487,7 @@ strtoul_for_line (str, len, nump)\n    Note that the filename string (if any) is treated as if it were an\n    include filename.  That means no escape handling.  */\n \n-static int\n+static void\n do_line (pfile)\n      cpp_reader *pfile;\n {\n@@ -552,7 +545,7 @@ do_line (pfile)\n     }\n \n   if (read_line_number (pfile, &action_number) == 0)\n-    return 0;\n+    return;\n \n   if (CPP_PEDANTIC (pfile))\n     cpp_pedwarn (pfile, \"garbage at end of #line\");\n@@ -582,10 +575,9 @@ do_line (pfile)\n       cpp_make_system_header (pfile, ip, 2);\n       read_line_number (pfile, &action_number);\n     }\n-   return 0;\n \n  done:\n-  return 0;\n+  return;\n }\n \n /*\n@@ -594,7 +586,7 @@ do_line (pfile)\n  * (We use error because it prints the filename & line#.)\n  */\n \n-static int\n+static void\n do_error (pfile)\n      cpp_reader *pfile;\n {\n@@ -605,16 +597,14 @@ do_error (pfile)\n   limit = pfile->limit;\n   pfile->limit = text;\n   cpp_error (pfile, \"%.*s\", (int)(limit - text), text);\n-\n-  return 0;\n }\n \n /*\n  * Report a warning detected by the program we are processing.\n  * Use the text of the line in the warning message, then continue.\n  */\n \n-static int\n+static void\n do_warning (pfile)\n      cpp_reader *pfile;\n {\n@@ -625,12 +615,11 @@ do_warning (pfile)\n   limit = pfile->limit;\n   pfile->limit = text;\n   cpp_warning (pfile, \"%.*s\", (int)(limit - text), text);\n-  return 0;\n }\n \n /* Report program identification.  */\n \n-static int\n+static void\n do_ident (pfile)\n      cpp_reader *pfile;\n {\n@@ -641,11 +630,10 @@ do_ident (pfile)\n       {\n \t/* Good - ship it.  */\n \tpass_thru_directive (pfile);\n-\treturn 0;\n+\treturn;\n       }\n \n   cpp_error (pfile, \"invalid #ident\");\n-  return 0;\n }\n \n /* Pragmata handling.  We handle some of these, and pass the rest on\n@@ -708,7 +696,7 @@ static int pragma_dispatch (pfile, table, node)\n   return 0;\n }\n \n-static int\n+static void\n do_pragma (pfile)\n      cpp_reader *pfile;\n {\n@@ -717,17 +705,16 @@ do_pragma (pfile)\n \n   tok = _cpp_get_token (pfile);\n   if (tok->type == CPP_EOF)\n-    return 0;\n+    return;\n   else if (tok->type != CPP_NAME)\n     {\n       cpp_error (pfile, \"malformed #pragma directive\");\n-      return 0;\n+      return;\n     }\n \n   pop = pragma_dispatch (pfile, top_pragmas, tok->val.node);\n   if (!pop)\n     pass_thru_directive (pfile);\n-  return 0;\n }\n \n static int\n@@ -900,11 +887,10 @@ do_pragma_dependency (pfile)\n \n /* Just ignore #sccs, on systems where we define it at all.  */\n #ifdef SCCS_DIRECTIVE\n-static int\n+static void\n do_sccs (pfile)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n {\n-  return 0;\n }\n #endif\n \n@@ -991,7 +977,7 @@ parse_ifdef (pfile, name)\n \n /* #ifdef is dead simple.  */\n \n-static int\n+static void\n do_ifdef (pfile)\n      cpp_reader *pfile;\n {\n@@ -1001,13 +987,12 @@ do_ifdef (pfile)\n     node = parse_ifdef (pfile, dtable[T_IFDEF].name);\n \n   push_conditional (pfile, !(node && node->type != T_VOID), T_IFDEF, 0);\n-  return 0;\n }\n \n /* #ifndef is a tad more complex, because we need to check for a\n    no-reinclusion wrapper.  */\n \n-static int\n+static void\n do_ifndef (pfile)\n      cpp_reader *pfile;\n {\n@@ -1022,13 +1007,12 @@ do_ifndef (pfile)\n \n   push_conditional (pfile, node && node->type != T_VOID,\n \t\t    T_IFNDEF, start_of_file ? node : 0);\n-  return 0;\n }\n \n /* #if is straightforward; just call _cpp_parse_expr, then conditional_skip.\n    Also, check for a reinclude preventer of the form #if !defined (MACRO).  */\n \n-static int\n+static void\n do_if (pfile)\n      cpp_reader *pfile;\n {\n@@ -1042,14 +1026,13 @@ do_if (pfile)\n       value = _cpp_parse_expr (pfile);\n     }\n   push_conditional (pfile, value == 0, T_IF, cmacro);\n-  return 0;\n }\n \n /* #else flips pfile->skipping and continues without changing\n    if_stack; this is so that the error message for missing #endif's\n    etc. will point to the original #if.  */\n \n-static int\n+static void\n do_else (pfile)\n      cpp_reader *pfile;\n {\n@@ -1059,7 +1042,7 @@ do_else (pfile)\n   if (ifs == NULL)\n     {\n       cpp_error (pfile, \"#else without #if\");\n-      return 0;\n+      return;\n     }\n   if (ifs->type == T_ELSE)\n     {\n@@ -1079,15 +1062,14 @@ do_else (pfile)\n       if (pfile->skipping < 2)\n \tpfile->skipping = ! pfile->skipping;\n     }\n-  return 0;\n }\n \n /*\n  * handle a #elif directive by not changing if_stack either.\n  * see the comment above do_else.\n  */\n \n-static int\n+static void\n do_elif (pfile)\n      cpp_reader *pfile;\n {\n@@ -1096,7 +1078,7 @@ do_elif (pfile)\n   if (ifs == NULL)\n     {\n       cpp_error (pfile, \"#elif without #if\");\n-      return 0;\n+      return;\n     }\n   if (ifs->type == T_ELSE)\n     {\n@@ -1107,21 +1089,20 @@ do_elif (pfile)\n \n   ifs->type = T_ELIF;\n   if (ifs->was_skipping)\n-    return 0;  /* Don't evaluate a nested #if */\n+    return;  /* Don't evaluate a nested #if */\n \n   if (pfile->skipping != 1)\n     {\n       pfile->skipping = 2;  /* one block succeeded, so don't do any others */\n-      return 0;\n+      return;\n     }\n \n   pfile->skipping = ! _cpp_parse_expr (pfile);\n-  return 0;\n }\n \n /* #endif pops the if stack and resets pfile->skipping.  */\n \n-static int\n+static void\n do_endif (pfile)\n      cpp_reader *pfile;\n {\n@@ -1138,7 +1119,6 @@ do_endif (pfile)\n       pfile->potential_control_macro = ifs->cmacro;\n       obstack_free (pfile->buffer_ob, ifs);\n     }\n-  return 0;\n }\n \n \n@@ -1332,7 +1312,7 @@ _cpp_find_answer (node, candidate)\n #define WARNING(msgid) do { cpp_warning(pfile, msgid); goto error; } while (0)\n #define ERROR(msgid) do { cpp_error(pfile, msgid); goto error; } while (0)\n #define ICE(msgid) do { cpp_ice(pfile, msgid); goto error; } while (0)\n-static int\n+static void\n do_assert (pfile)\n      cpp_reader *pfile;\n {\n@@ -1355,16 +1335,15 @@ do_assert (pfile)\n       node->type = T_ASSERTION;\n       node->value.answers = new_answer;\n     }\n-  return 0;\n+  return;\n \n  err:\n   cpp_warning (pfile, \"\\\"%.*s\\\" re-asserted\",\n \t       node->length - 1, node->name + 1);\n   FREE_ANSWER (new_answer);\n-  return 0;\n }\n \n-static int\n+static void\n do_unassert (pfile)\n      cpp_reader *pfile;\n {\n@@ -1404,7 +1383,6 @@ do_unassert (pfile)\n       if (answer)\n \tFREE_ANSWER (answer);\n     }\n-  return 0;\n }\n \n /* These are for -D, -U, -A.  */"}, {"sha": "80671cf5ce1787555fb139bfcb4ff162f4ccd105", "filename": "gcc/cpplib.h", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -653,6 +653,10 @@ extern void cpp_undef  PARAMS ((cpp_reader *, const char *));\n extern void cpp_unassert PARAMS ((cpp_reader *, const char *));\n \n extern void cpp_free_token_list PARAMS ((cpp_toklist *));\n+extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n+\t\t\t\t\t    const unsigned char *, long));\n+extern cpp_buffer *cpp_pop_buffer PARAMS ((cpp_reader *));\n+extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n \n /* N.B. The error-message-printer prototypes have not been nicely\n    formatted because exgettext needs to see 'msgid' on the same line\n@@ -680,8 +684,8 @@ extern void cpp_pedwarn_with_line PARAMS ((cpp_reader *, int, int, const char *m\n   ATTRIBUTE_PRINTF_4;\n extern void cpp_pedwarn_with_file_and_line PARAMS ((cpp_reader *, const char *, int, int, const char *msgid, ...))\n   ATTRIBUTE_PRINTF_5;\n-extern void cpp_error_from_errno\tPARAMS ((cpp_reader *, const char *));\n-extern void cpp_notice_from_errno\tPARAMS ((cpp_reader *, const char *));\n+extern void cpp_error_from_errno PARAMS ((cpp_reader *, const char *));\n+extern void cpp_notice_from_errno PARAMS ((cpp_reader *, const char *));\n \n /* In cpplex.c */\n extern cpp_buffer *cpp_push_buffer\tPARAMS ((cpp_reader *,\n@@ -694,16 +698,16 @@ extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const char *));\n \n /* In cpphash.c */\n-extern int cpp_defined\t\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const unsigned char *, int));\n-extern cpp_hashnode *cpp_lookup\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const unsigned char *, int));\n+extern cpp_hashnode *cpp_lookup\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t const unsigned char *, size_t));\n+extern void cpp_forall_identifiers PARAMS ((cpp_reader *,\n+\t\t\t\t\t    int (*) PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t\t     cpp_hashnode *))));\n \n /* In cppfiles.c */\n-extern int cpp_included\t\t\tPARAMS ((cpp_reader *, const char *));\n-extern int cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n-extern void cpp_make_system_header\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t cpp_buffer *, int));\n+extern int cpp_included\tPARAMS ((cpp_reader *, const char *));\n+extern int cpp_read_file PARAMS ((cpp_reader *, const char *));\n+extern void cpp_make_system_header PARAMS ((cpp_reader *, cpp_buffer *, int));\n \n #ifdef __cplusplus\n }"}, {"sha": "710dbdedaa16c97a389487d0cf64d4b08a1ae0e2", "filename": "gcc/cppmacro.c", "status": "added", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -0,0 +1,603 @@\n+/* Part of CPP library.  (Macro handling.)\n+   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n+   Written by Per Bothner, 1994.\n+   Based on CCCP program by Paul Rubin, June 1986\n+   Adapted to ANSI C, Richard Stallman, Jan 1987\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n+\n+/* Stores basic information about a macro, before it is allocated.  */\n+struct macro_info\n+{\n+  const cpp_token *first_param;\t/* First parameter token.  */\n+  const cpp_token *first;\t/* First expansion token.  */\n+  unsigned int paramlen;\t/* Length of parameter names. */\n+  unsigned int len;\t\t/* Length of token strings.  */\n+  unsigned int ntokens;\t\t/* Number of tokens in expansion.  */\n+  short paramc;\t\t\t/* Number of parameters.  */\n+  unsigned char flags;\n+};\n+\n+static void dump_funlike_macro\tPARAMS ((cpp_reader *, cpp_hashnode *));\n+static void count_params PARAMS ((cpp_reader *, struct macro_info *));\n+static int is__va_args__ PARAMS ((cpp_reader *, const cpp_token *));\n+\n+static int parse_define PARAMS((cpp_reader *, struct macro_info *));\n+static int check_macro_redefinition PARAMS((cpp_reader *, cpp_hashnode *hp,\n+\t\t\t\t\t    const cpp_toklist *));\n+static const cpp_toklist * save_expansion PARAMS((cpp_reader *,\n+ \t\t\t\t\t\t  struct macro_info *));\n+static unsigned int find_param PARAMS ((const cpp_token *,\n+ \t\t\t\t\tconst cpp_token *));\n+static cpp_toklist * alloc_macro PARAMS ((cpp_reader *, struct macro_info *));\n+\n+\n+/* Scans for a given token, returning the parameter number if found,\n+   or 0 if not found.  Scans from FIRST to TOKEN - 1 or the first\n+   CPP_CLOSE_PAREN for TOKEN.  */\n+static unsigned int\n+find_param (first, token)\n+     const cpp_token *first, *token;\n+{\n+  unsigned int param = 0;\n+\n+  for (; first < token && first->type != CPP_CLOSE_PAREN; first++)\n+    if (first->type == CPP_NAME)\n+      {\n+\tparam++;\n+\tif (first->val.node == token->val.node)\n+\t  return param;\n+      }\n+\n+  return 0;\n+}\n+\n+/* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n+   replacement list of a variable-arguments macro.  TOKEN is assumed\n+   to be of type CPP_NAME.  */\n+static int\n+is__va_args__ (pfile, token)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+{\n+  if (!CPP_PEDANTIC (pfile)\n+      || token->val.node != pfile->spec_nodes->n__VA_ARGS__)\n+    return 0;\n+\n+  cpp_pedwarn_with_line (pfile, token->line, token->col,\n+       \"\\\"%s\\\" is only valid in the replacement list of a function-like macro\",\n+\t\t       token->val.node->name);\n+  return 1;\n+}\n+\n+/* Counts the parameters to a function-like macro, the length of their\n+   null-terminated names, and whether the macro is a variable-argument\n+   one.  FIRST is the token immediately after the open parenthesis,\n+   INFO stores the data.\n+\n+   On success, info->first is updated to the token after the closing\n+   parenthesis, i.e. the first token of the expansion.  Otherwise\n+   there was an error, which has been reported.  */\n+static void\n+count_params (pfile, info)\n+     cpp_reader *pfile;\n+     struct macro_info *info;\n+{\n+  unsigned int prev_ident = 0;\n+  const cpp_token *token;\n+\n+  info->paramc = 0;\n+  info->paramlen = 0;\n+  info->flags = 0;\n+  info->first = info->first_param; /* Not a ')' indicating success.  */\n+\n+  for (token = info->first_param;; token++)\n+    {\n+      switch (token->type)\n+\t{\n+\tdefault:\n+\t  cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t       \"illegal token in macro parameter list\");\n+\t  return;\n+\n+\tcase CPP_EOF:\n+\tmissing_paren:\n+\t  cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t       \"missing ')' in macro parameter list\");\n+\t  return;\n+\n+\tcase CPP_COMMENT:\n+\t  continue;\t\t/* Ignore -C comments.  */\n+\n+\tcase CPP_NAME:\n+\t  if (prev_ident)\n+\t    {\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t   \"macro parameters must be comma-separated\");\n+\t      return;\n+\t    }\n+\n+\t  /* Constraint 6.10.3.5  */\n+\t  if (is__va_args__ (pfile, token))\n+\t    return;\n+\n+\t  /* Constraint 6.10.3.6 - duplicate parameter names.  */\n+\t  if (find_param (info->first, token))\n+\t    {\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t\t   \"duplicate macro parameter \\\"%s\\\"\",\n+\t\t\t\t   token->val.node->name);\n+\t      return;\n+\t    }\n+\n+\t  prev_ident = 1;\n+\t  info->paramc++;\n+\t  info->paramlen += token->val.node->length + 1;\n+\t  continue;\n+\n+\tcase CPP_CLOSE_PAREN:\n+\t  if (prev_ident || info->paramc == 0)\n+\t    break;\n+\n+\t  /* Fall through to pick up the error.  */\n+\tcase CPP_COMMA:\n+\t  if (!prev_ident)\n+\t    {\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t\t   \"parameter name expected\");\n+\t      return;\n+\t    }\n+\t  prev_ident = 0;\n+\t  continue;\n+\n+\tcase CPP_ELLIPSIS:\n+\t  /* Convert ISO-style var_args to named varargs by changing\n+\t     the ellipsis into an identifier with name __VA_ARGS__.\n+\t     This simplifies other handling. */\n+\t  if (!prev_ident)\n+\t    {\n+\t      cpp_token *tok = (cpp_token *) token;\n+\n+\t      tok->type = CPP_NAME;\n+\t      tok->val.node = pfile->spec_nodes->n__VA_ARGS__;\n+\n+\t      info->paramc++;\n+\t      info->paramlen += tok->val.node->length + 1;\n+\n+\t      if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, c99))\n+\t\tcpp_pedwarn (pfile,\n+\t\t\t     \"C89 does not permit anon varargs macros\");\n+\t    }\n+\t  else\n+\t    {\n+\t      info->flags |= GNU_REST_ARGS;\n+\t      if (CPP_PEDANTIC (pfile))\n+\t\tcpp_pedwarn (pfile,\n+\t\t\t     \"ISO C does not permit named varargs parameters\");\n+\t    }\n+\n+\t  info->flags |= VAR_ARGS;\n+\t  token++;\n+\t  if (token->type == CPP_CLOSE_PAREN)\n+\t    break;\n+\t  goto missing_paren;\n+\t}\n+\n+      /* Success.  */\n+      info->first = token + 1;\n+      if (!pfile->save_parameter_spellings)\n+\tinfo->paramlen = 0;\n+      return;\n+    }\n+}\n+\n+/* Parses a #define directive.  On success, returns zero, and INFO is\n+   filled in appropriately.  */\n+static int\n+parse_define (pfile, info)\n+     cpp_reader *pfile;\n+     struct macro_info *info;\n+{\n+  const cpp_token *token;\n+  int prev_white = 0;\n+\n+  /* The first token after the macro's name.  */\n+  token = _cpp_get_token (pfile);\n+\n+  /* Constraint 6.10.3.5  */\n+  if (is__va_args__ (pfile, token - 1))\n+    return 1;\n+\n+  while (token->type == CPP_COMMENT)\n+    token++, prev_white = 1;\n+  prev_white |= token->flags & PREV_WHITE;\n+\n+  if (token->type == CPP_OPEN_PAREN && !prev_white)\n+    {\n+      /* A function-like macro.  */\n+      info->first_param = token + 1;\n+      count_params (pfile, info);\n+      if (info->first[-1].type != CPP_CLOSE_PAREN)\n+\treturn 1;\n+    }\n+  else\n+    {\n+      /* An object-like macro.  */\n+      info->paramc = -1;\n+      info->paramlen = 0;\n+      info->flags = 0;\n+      info->first = token;\n+      if (!prev_white && token->type != CPP_EOF)\n+\tcpp_pedwarn (pfile, \"ISO C requires whitespace after the macro name\");\n+    }\n+\n+  /* Count tokens in expansion.  We drop paste tokens, and stringize\n+     tokens, so don't count them.  */\n+  info->ntokens = info->len = 0;\n+  for (token = info->first; token->type != CPP_EOF; token++)\n+    {\n+      if (token->type == CPP_PASTE)\n+\t{\n+\t  /* Token-paste ##, can appear in both object-like and\n+\t     function-like macros, but not at the ends.  Constraint\n+\t     6.10.3.3.1 */\n+\t  if (token == info->first || token[1].type == CPP_EOF)\n+\t    {\n+\t      cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\"'##' cannot appear at either end of a macro expansion\");\n+\t      return 1;\n+\t    }\n+\t  continue;\n+\t}\n+      else if (token->type == CPP_HASH)\n+\t{\n+\t  /* Stringifying #, but a normal character in object-like\n+             macros.  Must come before a parameter name.  Constraint\n+             6.10.3.2.1.  */\n+\t  if (info->paramc >= 0)\n+\t    {\n+\t      if (token[1].type == CPP_NAME\n+\t\t  && find_param (info->first_param, token + 1))\n+\t\tcontinue;\n+\t      if (! CPP_OPTION (pfile, lang_asm))\n+\t\t{\n+\t\t  cpp_error_with_line (pfile, token->line, token->col,\n+\t\t\t       \"'#' is not followed by a macro parameter\");\n+\t\t  return 1;\n+\t\t}\n+\t    }\n+\t}\n+      else if (token->type == CPP_NAME)\n+\t{\n+\t  /* Constraint 6.10.3.5  */\n+\t  if (!(info->flags & VAR_ARGS) && is__va_args__ (pfile, token))\n+\t    return 1;\n+\t  /* It might be worth doing a check here that we aren't a\n+\t     macro argument, since we don't store the text of macro\n+\t     arguments.  This would reduce \"len\" and save space.  */\n+\t}\n+      info->ntokens++;\n+      if (TOKEN_SPELL (token) == SPELL_STRING)\n+\tinfo->len += token->val.str.len;\n+    }\n+  \n+  return 0;\n+}\n+\n+/* Returns non-zero if a macro redefinition is trivial.  */\n+static int\n+check_macro_redefinition (pfile, hp, list2)\n+     cpp_reader *pfile;\n+     cpp_hashnode *hp;\n+     const cpp_toklist *list2;\n+{\n+  const cpp_toklist *list1;\n+\n+  if (hp->type != T_MACRO)\n+    return ! pfile->done_initializing;\n+\n+  /* Clear the whitespace and BOL flags of the first tokens.  They get\n+     altered during macro expansion, but is not significant here.  */\n+  list1  = hp->value.expansion;\n+  list1->tokens[0].flags &= ~(PREV_WHITE|BOL);\n+  list2->tokens[0].flags &= ~(PREV_WHITE|BOL);\n+\n+  if (!_cpp_equiv_toklists (list1, list2))\n+    return 0;\n+\n+  if (CPP_OPTION (pfile, pedantic)\n+      && list1->paramc > 0\n+      && (list1->params_len != list2->params_len\n+\t  || memcmp (list1->namebuf, list2->namebuf, list1->params_len)))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* This is a dummy structure whose only purpose is getting alignment\n+   correct.  */\n+struct toklist_dummy\n+{\n+  cpp_toklist list;\n+  cpp_token first_token;\n+};\n+\n+/* Allocate space to hold the token list, its tokens, their text, and\n+   the parameter names if needed.  Empty expansions are stored as a\n+   single placemarker token.\n+\n+   These are all allocated in a block together for performance\n+   reasons.  Therefore, this token list cannot be expanded like a\n+   normal token list.  Try to do so, and you lose.  */\n+static cpp_toklist *\n+alloc_macro (pfile, info)\n+     cpp_reader *pfile;\n+     struct macro_info *info;\n+{\n+  unsigned int size;\n+  struct toklist_dummy *dummy;\n+  cpp_toklist *list;\n+\n+  /* Empty macros become a single placemarker token.  */\n+  if (info->ntokens == 0)\n+    info->ntokens = 1;\n+\n+  size = sizeof (struct toklist_dummy);\n+  size += (info->ntokens - 1) * sizeof(cpp_token);\n+  size += info->len + info->paramlen;\n+\n+  dummy = (struct toklist_dummy *) xmalloc (size);\n+  list = (cpp_toklist *) dummy;\n+  \n+  /* Initialize the monster.  */\n+  list->tokens = &dummy->first_token;\n+  list->tokens_used = list->tokens_cap = info->ntokens;\n+\n+  list->namebuf = (unsigned char *) &list->tokens[info->ntokens];\n+  list->name_used = list->name_cap = info->len + info->paramlen;\n+\n+  list->directive = 0;\n+  list->line = pfile->token_list.line;\n+  list->file = pfile->token_list.file;\n+  list->params_len = info->paramlen;\n+  list->paramc = info->paramc;\n+  list->flags = info->flags;\n+\n+  return list;\n+}\n+\n+/* Free the definition of macro H.  */\n+\n+void\n+_cpp_free_definition (h)\n+     cpp_hashnode *h;\n+{\n+  if (h->type == T_MACRO)\n+    free ((PTR) h->value.expansion);\n+  h->value.expansion = NULL;\n+}\n+\n+/* Copy the tokens of the expansion, beginning with info->first until\n+   CPP_EOF.  INFO contains information about the macro.\n+\n+   Change the type of macro arguments in the expansion from CPP_NAME\n+   to CPP_MACRO_ARG.  Remove #'s that represent stringification,\n+   flagging the CPP_MACRO_ARG it operates on STRINGIFY.  Remove ##'s,\n+   flagging the token on its immediate left PASTE_LEFT.  Returns the\n+   token list for the macro expansion.  */\n+static const cpp_toklist *\n+save_expansion (pfile, info)\n+     cpp_reader *pfile;\n+     struct macro_info *info;\n+{\n+  const cpp_token *token;\n+  cpp_toklist *list;\n+  cpp_token *dest;\n+  unsigned char *buf;\n+      \n+  list = alloc_macro (pfile, info);\n+  buf = list->namebuf;\n+\n+  /* Store the null-terminated parameter spellings of a macro, to\n+     provide pedantic warnings to satisfy 6.10.3.2, or for use when\n+     dumping macro definitions.  They must go first.  */\n+  if (list->params_len)\n+    for (token = info->first_param; token < info->first; token++)\n+      if (token->type == CPP_NAME)\n+\t{\n+\t  /* Copy null too.  */\n+\t  memcpy (buf, token->val.node->name, token->val.node->length + 1);\n+\t  buf += token->val.node->length + 1;\n+\t}\n+\n+  dest = list->tokens;\n+  for (token = info->first; token->type != CPP_EOF; token++)\n+    {\n+      unsigned int param_no;\n+\n+      switch (token->type)\n+\t{\n+\tcase CPP_NAME:\n+\t  if (list->paramc == -1)\n+\t    break;\n+\n+\t  /* Check if the name is a macro parameter.  */\n+\t  param_no = find_param (info->first_param, token);\n+\t  if (param_no == 0)\n+\t    break;\n+\t  dest->val.aux = param_no - 1;\n+\n+\t  dest->type = CPP_MACRO_ARG;\n+\t  if (token[-1].type == CPP_HASH)\n+\t    dest->flags = token[-1].flags | STRINGIFY_ARG;\n+\t  else\n+\t    dest->flags = token->flags;  /* Particularly PREV_WHITE.  */\n+\t  /* Turn off PREV_WHITE if we immediately follow a paste.\n+\t     That way, even if the paste turns out to be illegal, there\n+\t     will be no space between the two tokens in the output.  */\n+\t  if (token[-1].type == CPP_PASTE)\n+\t    dest->flags &= ~PREV_WHITE;\n+\t  dest++;\n+\t  continue;\n+\n+\tcase CPP_PASTE:\n+\t  dest[-1].flags |= PASTE_LEFT;\n+\t  continue;\n+\n+\tcase CPP_HASH:\n+\t  /* Stringifying #.  Constraint 6.10.3.2.1  */\n+\t  if (list->paramc >= 0 && token[1].type == CPP_NAME\n+\t      && find_param (info->first_param, token + 1))\n+\t    continue;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      /* Copy the token.  */\n+      *dest = *token;\n+      if (TOKEN_SPELL (token) == SPELL_STRING)\n+\t{\n+\t  memcpy (buf, token->val.str.text, token->val.str.len);\n+\t  dest->val.str.text = buf;\n+\t  buf += dest->val.str.len;\n+\t}\n+      if (token[-1].type == CPP_PASTE)\n+\tdest->flags &= ~PREV_WHITE;\n+      dest++;\n+    }\n+\n+  /* Empty macros become a single placemarker token.  */\n+  if (dest == list->tokens)\n+    {\n+      dest->type = CPP_PLACEMARKER;\n+      dest->flags = 0;\n+    }\n+\n+  return list;\n+}\n+\n+/* Parse a macro and save its expansion.  Returns non-zero on success.  */\n+int\n+_cpp_create_definition (pfile, hp)\n+     cpp_reader *pfile;\n+     cpp_hashnode *hp;\n+{\n+  struct macro_info info;\n+  const cpp_toklist *list;\n+\n+  if (parse_define (pfile, &info))\n+    return 0;\n+  list = save_expansion (pfile, &info);\n+\n+  /* Check for a redefinition.  Redefinition of a macro is allowed if\n+     and only if the old and new definitions are the same.\n+     (6.10.3 paragraph 2). */\n+\n+  if (hp->type != T_VOID)\n+    {\n+      if (!check_macro_redefinition (pfile, hp, list))\n+\t{\n+\t  cpp_pedwarn (pfile, \"\\\"%s\\\" redefined\", hp->name);\n+\t  if (pfile->done_initializing && hp->type == T_MACRO)\n+\t    cpp_pedwarn_with_file_and_line (pfile,\n+\t\t\t\t\t    hp->value.expansion->file,\n+\t\t\t\t\t    hp->value.expansion->line, 1,\n+\t\t\t    \"this is the location of the previous definition\");\n+\t}\n+      _cpp_free_definition (hp);\n+    }\n+\n+  /* Enter definition in hash table.  */\n+  hp->type = T_MACRO;\n+  hp->value.expansion = list;\n+\n+  return 1;\n+}\n+\n+/* Dump the definition of macro MACRO on stdout.  The format is suitable\n+   to be read back in again. */\n+\n+void\n+_cpp_dump_definition (pfile, hp)\n+     cpp_reader *pfile;\n+     cpp_hashnode *hp;\n+{\n+  CPP_RESERVE (pfile, hp->length + sizeof \"#define \");\n+  CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" - 1);\n+  CPP_PUTS_Q (pfile, hp->name, hp->length);\n+\n+  if (hp->type == T_MACRO)\n+    {\n+      if (hp->value.expansion->paramc >= 0)\n+\tdump_funlike_macro (pfile, hp);\n+      else\n+\t{\n+\t  const cpp_toklist *list = hp->value.expansion;\n+\t  list->tokens[0].flags &= ~BOL;\n+\t  list->tokens[0].flags |= PREV_WHITE;\n+\t  _cpp_dump_list (pfile, list, list->tokens, 1);\n+\t}\n+    }\n+  else\n+    cpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n+\n+  if (CPP_BUFFER (pfile) == 0 || ! pfile->done_initializing)\n+    CPP_PUTC (pfile, '\\n');\n+}\n+\n+static void\n+dump_funlike_macro (pfile, node)\n+     cpp_reader *pfile;\n+     cpp_hashnode *node;\n+{\n+  int i = 0;\n+  const cpp_toklist * list = node->value.expansion;\n+  const U_CHAR *param;\n+\n+  param = list->namebuf;\n+  CPP_PUTC_Q (pfile, '(');\n+  for (i = 0; i++ < list->paramc;)\n+    {\n+      unsigned int len;\n+\n+      len = ustrlen (param);\n+      CPP_PUTS (pfile, param, len);\n+      if (i < list->paramc)\n+\tCPP_PUTS(pfile, \", \", 2);\n+      else if (list->flags & VAR_ARGS)\n+\t{\n+\t  if (!ustrcmp (param, U\"__VA_ARGS__\"))\n+\t    pfile->limit -= sizeof (U\"__VA_ARGS__\") - 1;\n+\t  CPP_PUTS_Q (pfile, \"...\", 3);\n+\t}\n+      param += len + 1;\n+    }\n+  CPP_PUTC (pfile, ')');\n+  list->tokens[0].flags &= ~BOL;\n+  list->tokens[0].flags |= PREV_WHITE;\n+  _cpp_dump_list (pfile, list, list->tokens, 1);\n+}"}, {"sha": "8be2a1df63e2eea61b52eb1a7da0fdef52752193", "filename": "gcc/cppmain.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/711b88243b220e3cd737696da51de70f32bb7d5c/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=711b88243b220e3cd737696da51de70f32bb7d5c", "patch": "@@ -68,7 +68,8 @@ main (argc, argv)\n   print = cpp_printer_init (pfile, &parse_out);\n   if (! print)\n     return (FATAL_EXIT_CODE);\n-  pfile->printer = print;\n+  if (! CPP_OPTION (pfile, no_output))\n+    pfile->printer = print;\n \n   if (! cpp_start_read (pfile, print, CPP_OPTION (pfile, in_fname)))\n     return (FATAL_EXIT_CODE);"}]}