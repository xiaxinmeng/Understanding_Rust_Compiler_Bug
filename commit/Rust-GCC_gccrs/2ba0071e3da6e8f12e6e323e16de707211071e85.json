{"sha": "2ba0071e3da6e8f12e6e323e16de707211071e85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJhMDA3MWUzZGE2ZThmMTJlNmUzMjNlMTZkZTcwNzIxMTA3MWU4NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-06-02T08:07:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-06-02T08:07:23Z"}, "message": "re PR tree-optimization/61346 (VRP chooses bad bounds for variable)\n\n2014-06-02  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/61346\n\t* gcc.dg/torture/pr61346.c: New testcase.\n\nFrom-SVN: r211128", "tree": {"sha": "2e1b68caf42e11c8fae3edd72e70df000b8289ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e1b68caf42e11c8fae3edd72e70df000b8289ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ba0071e3da6e8f12e6e323e16de707211071e85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba0071e3da6e8f12e6e323e16de707211071e85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ba0071e3da6e8f12e6e323e16de707211071e85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ba0071e3da6e8f12e6e323e16de707211071e85/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31815ed772cda8e1962c5335158f0525039ae4ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31815ed772cda8e1962c5335158f0525039ae4ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31815ed772cda8e1962c5335158f0525039ae4ca"}], "stats": {"total": 167, "additions": 167, "deletions": 0}, "files": [{"sha": "617a197bc53b3e6ed62275c4769cacfaccf98978", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba0071e3da6e8f12e6e323e16de707211071e85/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba0071e3da6e8f12e6e323e16de707211071e85/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ba0071e3da6e8f12e6e323e16de707211071e85", "patch": "@@ -1,3 +1,8 @@\n+2014-06-02  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/61346\n+\t* gcc.dg/torture/pr61346.c: New testcase.\n+\n 2014-06-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/sibcall-2.c: Xfail dg-final scan-assembler-not,"}, {"sha": "e27b9cac5b39ab635a28a0468558d1c2cadd26a0", "filename": "gcc/testsuite/gcc.dg/torture/pr61346.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ba0071e3da6e8f12e6e323e16de707211071e85/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr61346.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ba0071e3da6e8f12e6e323e16de707211071e85/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr61346.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr61346.c?ref=2ba0071e3da6e8f12e6e323e16de707211071e85", "patch": "@@ -0,0 +1,162 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+typedef int int32_t __attribute__ ((mode (SI)));\n+typedef int int64_t __attribute__ ((mode (DI)));\n+typedef __SIZE_TYPE__ size_t;\n+\n+struct slice\n+{\n+  unsigned char *data;\n+  int64_t len;\n+  int64_t cap;\n+};\n+\n+void fail (int32_t) __attribute__ ((noinline));\n+void\n+fail (int32_t c)\n+{\n+  if (c != 0)\n+    abort ();\n+}\n+\n+struct decode_rune_ret\n+{\n+  int32_t r;\n+  int64_t width;\n+};\n+\n+struct decode_rune_ret decode_rune (struct slice) __attribute__ ((noinline));\n+struct decode_rune_ret\n+decode_rune (struct slice s)\n+{\n+  struct decode_rune_ret dr;\n+  dr.r = s.data[0];\n+  dr.width = 1;\n+  return dr;\n+}\n+\n+_Bool is_space (int32_t) __attribute__ ((noinline));\n+_Bool\n+is_space (int32_t r)\n+{\n+  return r == ' ';\n+}\n+\n+struct ret\n+{\n+  int64_t advance;\n+  struct slice token;\n+};\n+\n+struct ret scanwords (struct slice, _Bool) __attribute__ ((noinline));\n+\n+struct ret\n+scanwords (struct slice data, _Bool ateof)\n+{\n+  int64_t advance;\n+  struct slice token;\n+  int64_t start = 0;\n+  {\n+    int64_t width;\n+    for (width = 0; start < data.len; start += width)\n+      {\n+\tint32_t r = 0;\n+\tstruct slice s;\n+\tif (start > data.cap || start < 0)\n+\t  fail (3);\n+\ts.data = data.data + (size_t) start;\n+\ts.len = data.len - start;\n+\ts.cap = data.cap - start;\n+\tstruct decode_rune_ret dr = decode_rune (s);\n+\tr = dr.r;\n+\twidth = dr.width;\n+\tif (!is_space (r))\n+\t  break;\n+      }\n+  }\n+  _Bool tmp = ateof;\n+  if (tmp != 0)\n+    goto L1;\n+  else\n+    goto L2;\n+ L1:\n+  tmp = data.len == 0;\n+ L2:\n+  if (tmp != 0)\n+    goto L11;\n+  else\n+    goto L12;\n+ L11:\n+    {\n+      struct ret r;\n+      advance = 0;\n+      token.data = 0;\n+      token.len = 0;\n+      token.cap = 0;\n+      r.advance = advance;\n+      r.token = token;\n+      return r;\n+    }\n+ L12:;\n+  int64_t width;\n+  int64_t i;\n+  for (width = 0, i = start; i < data.len; i += width)\n+    {\n+      int32_t r;\n+      struct slice s;\n+      if (i > data.cap || i < 0)\n+\tfail (3);\n+      s.data = data.data + i;\n+      s.len = data.len - i;\n+      s.cap = data.cap - i;\n+      struct decode_rune_ret dr = decode_rune (s);\n+      r = dr.r;\n+      width = dr.width;\n+      if (is_space (r))\n+\t{\n+\t  if (i < start || i > data.cap || i < 0)\n+\t    fail (3);\n+\t  if (start > data.cap || start < 0)\n+\t    fail (3);\n+\t  struct ret r;\n+\t  advance = i + width;\n+\t  token.data = data.data + (size_t) start;\n+\t  token.len = i - start;\n+\t  token.cap = data.cap - start;\n+\t  r.advance = advance;\n+\t  r.token = token;\n+\t  return r;\n+\t}\n+    }\n+  {\n+    struct ret r;\n+    advance = 0;\n+    token.data = 0;\n+    token.len = 0;\n+    token.cap = 0;\n+    r.advance = advance;\n+    r.token = token;\n+    return r;\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  unsigned char buf[1000];\n+  struct slice s;\n+  __builtin_memset (buf, 0, sizeof (buf));\n+  buf[0] = ' ';\n+  buf[1] = 'a';\n+  buf[2] = ' ';\n+  s.data = buf;\n+  s.len = 3;\n+  s.cap = sizeof (buf);\n+  struct ret r;\n+  r = scanwords (s, 1);\n+  if (r.advance != 3 || r.token.data[0] != 'a' || r.token.len != 1)\n+    abort ();\n+  return 0;\n+}"}]}