{"sha": "20acd2261e584296b4ca6dfa0ac27331d34bd590", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBhY2QyMjYxZTU4NDI5NmI0Y2E2ZGZhMGFjMjczMzFkMzRiZDU5MA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-03-27T10:48:27Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-03-27T10:48:27Z"}, "message": "vax-protos.h (vax_output_int_move, [...]): New prototypes.\n\n\t* vax-protos.h (vax_output_int_move, vax_output_int_add,\n\tvax_output_conditional_branch): New prototypes.\n\t* vax.c (vax_output_int_move, vax_output_int_add): New functions,\n\textracted from vax.md mov and add patterns.\n\t(vax_output_conditional_branch): New function to output conditional\n\tbranch instructions.\n\t* vax.md: Use mode macros for arithmetic and mov patterns.\n\tUse code macros for the jump patterns.\n\nFrom-SVN: r97111", "tree": {"sha": "356cfba427de446b7851ab8a34a74201c4524edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/356cfba427de446b7851ab8a34a74201c4524edc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20acd2261e584296b4ca6dfa0ac27331d34bd590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20acd2261e584296b4ca6dfa0ac27331d34bd590", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20acd2261e584296b4ca6dfa0ac27331d34bd590", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20acd2261e584296b4ca6dfa0ac27331d34bd590/comments", "author": null, "committer": null, "parents": [{"sha": "500d77012dc78d2f2718ace29d2f0fd46b7f1efe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500d77012dc78d2f2718ace29d2f0fd46b7f1efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/500d77012dc78d2f2718ace29d2f0fd46b7f1efe"}], "stats": {"total": 1118, "additions": 363, "deletions": 755}, "files": [{"sha": "90a003260d5bcdcdab980a96d9c7ca42584ad219", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20acd2261e584296b4ca6dfa0ac27331d34bd590/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20acd2261e584296b4ca6dfa0ac27331d34bd590/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20acd2261e584296b4ca6dfa0ac27331d34bd590", "patch": "@@ -1,3 +1,14 @@\n+2005-03-27  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* vax-protos.h (vax_output_int_move, vax_output_int_add,\n+\tvax_output_conditional_branch): New prototypes.\n+\t* vax.c (vax_output_int_move, vax_output_int_add): New functions,\n+\textracted from vax.md mov and add patterns.\n+\t(vax_output_conditional_branch): New function to output conditional\n+\tbranch instructions.\n+\t* vax.md: Use mode macros for arithmetic and mov patterns.\n+\tUse code macros for the jump patterns.\n+\n 2005-03-26  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* Makefile.in (libbackend.o): Depend on version files;\n@@ -56,7 +67,7 @@\n 2005-03-25  John David Anglin  <dave.anglin@nrc-crnc.gc.ca>\n \n \tPR target/15491\n-        * vax.c (vax_rtx_costs_1): Merge with vax_rtx_costs.\n+\t* vax.c (vax_rtx_costs_1): Merge with vax_rtx_costs.\n \t(vax_rtx_costs): Return false when passed unsupported rtx's.  Handle\n \tFLOAT_EXTEND, FLOAT_TRUNCATE and TRUNCATE.  Fix costs for POST_INC,\n \tPRE_DEC, NEG and NOT.\n@@ -284,7 +295,7 @@\n \n 2005-03-22  Richard Guenther <rguenth@tat.physik.uni-tuebingen.de>\n \t    Jan Hubicka  <jh@suse.cz>\n-\t    Steven Bosscher <stevenb@suse.de\n+\t    Steven Bosscher <stevenb@suse.de>\n \n \t* cgraphunit.c (cgraph_estimate_size_after_inlining): Compute\n \tcall cost based on argument sizes."}, {"sha": "3b07ae4653b8ffa286e3dd038038766ee5797a5c", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20acd2261e584296b4ca6dfa0ac27331d34bd590/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20acd2261e584296b4ca6dfa0ac27331d34bd590/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=20acd2261e584296b4ca6dfa0ac27331d34bd590", "patch": "@@ -26,6 +26,9 @@ extern void split_quadword_operands (rtx *, rtx *, int);\n extern void print_operand_address (FILE *, rtx);\n extern int vax_float_literal (rtx);\n extern void vax_notice_update_cc (rtx, rtx);\n+extern const char * vax_output_int_move (rtx, rtx *, enum machine_mode);\n+extern const char * vax_output_int_add (rtx, rtx *, enum machine_mode);\n+extern const char * vax_output_conditional_branch (enum rtx_code);\n #endif /* RTX_CODE */\n \n #ifdef REAL_VALUE_TYPE"}, {"sha": "995b16792037a599b8354f202c54b8111cadfa83", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20acd2261e584296b4ca6dfa0ac27331d34bd590/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20acd2261e584296b4ca6dfa0ac27331d34bd590/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=20acd2261e584296b4ca6dfa0ac27331d34bd590", "patch": "@@ -899,3 +899,201 @@ vax_notice_update_cc (rtx exp, rtx insn ATTRIBUTE_UNUSED)\n   /* Actual condition, one line up, should be that value2's address\n      depends on value1, but that is too much of a pain.  */\n }\n+\n+/* Output integer move instructions.  */\n+\n+const char *\n+vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n+\t\t     enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case SImode:\n+      if (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n+\t{\n+\t  if (push_operand (operands[0], SImode))\n+\t    return \"pushab %a1\";\n+\t  return \"movab %a1,%0\";\n+\t}\n+      if (operands[1] == const0_rtx)\n+\treturn \"clrl %0\";\n+      if (GET_CODE (operands[1]) == CONST_INT\n+\t  && (unsigned) INTVAL (operands[1]) >= 64)\n+\t{\n+\t  int i = INTVAL (operands[1]);\n+\t  if ((unsigned)(~i) < 64)\n+\t    return \"mcoml %N1,%0\";\n+\t  if ((unsigned)i < 0x100)\n+\t    return \"movzbl %1,%0\";\n+\t  if (i >= -0x80 && i < 0)\n+\t    return \"cvtbl %1,%0\";\n+\t  if ((unsigned)i < 0x10000)\n+\t    return \"movzwl %1,%0\";\n+\t  if (i >= -0x8000 && i < 0)\n+\t    return \"cvtwl %1,%0\";\n+\t}\n+      if (push_operand (operands[0], SImode))\n+\treturn \"pushl %1\";\n+      return \"movl %1,%0\";\n+\n+    case HImode:\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  int i = INTVAL (operands[1]);\n+\t  if (i == 0)\n+\t    return \"clrw %0\";\n+\t  else if ((unsigned int)i < 64)\n+\t    return \"movw %1,%0\";\n+\t  else if ((unsigned int)~i < 64)\n+\t    return \"mcomw %H1,%0\";\n+\t  else if ((unsigned int)i < 256)\n+\t    return \"movzbw %1,%0\";\n+\t}\n+      return \"movw %1,%0\";\n+\n+    case QImode:\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  int i = INTVAL (operands[1]);\n+\t  if (i == 0)\n+\t    return \"clrb %0\";\n+\t  else if ((unsigned int)~i < 64)\n+\t    return \"mcomb %B1,%0\";\n+\t}\n+      return \"movb %1,%0\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Output integer add instructions.\n+\n+   The space-time-opcode tradeoffs for addition vary by model of VAX.\n+\n+   On a VAX 3 \"movab (r1)[r2],r3\" is faster than \"addl3 r1,r2,r3\",\n+   but it not faster on other models.\n+\n+   \"movab #(r1),r2\" is usually shorter than \"addl3 #,r1,r2\", and is\n+   faster on a VAX 3, but some VAXen (e.g. VAX 9000) will stall if\n+   a register is used in an address too soon after it is set.\n+   Compromise by using movab only when it is shorter than the add\n+   or the base register in the address is one of sp, ap, and fp,\n+   which are not modified very often.  */\n+\n+const char *\n+vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n+\t\t    enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case SImode:\n+      if (rtx_equal_p (operands[0], operands[1]))\n+\t{\n+\t  if (operands[2] == const1_rtx)\n+\t    return \"incl %0\";\n+\t  if (operands[2] == constm1_rtx)\n+\t    return \"decl %0\";\n+\t  if (GET_CODE (operands[2]) == CONST_INT\n+\t      && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t    return \"subl2 $%n2,%0\";\n+\t  if (GET_CODE (operands[2]) == CONST_INT\n+\t      && (unsigned) INTVAL (operands[2]) >= 64\n+\t      && GET_CODE (operands[1]) == REG\n+\t      && ((INTVAL (operands[2]) < 32767 && INTVAL (operands[2]) > -32768)\n+\t\t   || REGNO (operands[1]) > 11))\n+\t    return \"movab %c2(%1),%0\";\n+\t  return \"addl2 %2,%0\";\n+\t}\n+\n+      if (rtx_equal_p (operands[0], operands[2]))\n+\treturn \"addl2 %1,%0\";\n+\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && INTVAL (operands[2]) < 32767\n+\t  && INTVAL (operands[2]) > -32768\n+\t  && GET_CODE (operands[1]) == REG\n+\t  && push_operand (operands[0], SImode))\n+\treturn \"pushab %c2(%1)\";\n+\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \"subl3 $%n2,%1,%0\";\n+\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) INTVAL (operands[2]) >= 64\n+\t  && GET_CODE (operands[1]) == REG\n+\t  && ((INTVAL (operands[2]) < 32767 && INTVAL (operands[2]) > -32768)\n+\t       || REGNO (operands[1]) > 11))\n+\treturn \"movab %c2(%1),%0\";\n+\n+      /* Add this if using gcc on a VAX 3xxx:\n+      if (REG_P (operands[1]) && REG_P (operands[2]))\n+\treturn \"movab (%1)[%2],%0\";\n+      */\n+      return \"addl3 %1,%2,%0\";\n+\n+    case HImode:\n+      if (rtx_equal_p (operands[0], operands[1]))\n+\t{\n+\t  if (operands[2] == const1_rtx)\n+\t    return \"incw %0\";\n+\t  if (operands[2] == constm1_rtx)\n+\t    return \"decw %0\";\n+\t  if (GET_CODE (operands[2]) == CONST_INT\n+\t      && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t    return \"subw2 $%n2,%0\";\n+\t  return \"addw2 %2,%0\";\n+\t}\n+      if (rtx_equal_p (operands[0], operands[2]))\n+\treturn \"addw2 %1,%0\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \"subw3 $%n2,%1,%0\";\n+      return \"addw3 %1,%2,%0\";\n+\n+    case QImode:\n+      if (rtx_equal_p (operands[0], operands[1]))\n+\t{\n+\t  if (operands[2] == const1_rtx)\n+\t    return \"incb %0\";\n+\t  if (operands[2] == constm1_rtx)\n+\t    return \"decb %0\";\n+\t  if (GET_CODE (operands[2]) == CONST_INT\n+\t      && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t    return \"subb2 $%n2,%0\";\n+\t  return \"addb2 %2,%0\";\n+\t}\n+      if (rtx_equal_p (operands[0], operands[2]))\n+\treturn \"addb2 %1,%0\";\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\treturn \"subb3 $%n2,%1,%0\";\n+      return \"addb3 %1,%2,%0\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Output a conditional branch.  */\n+const char *\n+vax_output_conditional_branch (enum rtx_code code)\n+{\n+  switch (code)\n+    {\n+      case EQ:  return \"jeql %l0\";\n+      case NE:  return \"jneq %l0\";\n+      case GT:  return \"jgtr %l0\";\n+      case LT:  return \"jlss %l0\";\n+      case GTU: return \"jgtru %l0\";\n+      case LTU: return \"jlssu %l0\";\n+      case GE:  return \"jgeq %l0\";\n+      case LE:  return \"jleq %l0\";\n+      case GEU: return \"jgequ %l0\";\n+      case LEU: return \"jlequ %l0\";\n+      default:\n+        gcc_unreachable ();\n+    }\n+}\n+"}, {"sha": "6b10534bf4f3ee97d8d1508321dd540b55fe360b", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 149, "deletions": 753, "changes": 902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20acd2261e584296b4ca6dfa0ac27331d34bd590/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20acd2261e584296b4ca6dfa0ac27331d34bd590/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=20acd2261e584296b4ca6dfa0ac27331d34bd590", "patch": "@@ -37,99 +37,57 @@\n   ]\n )\n \n-;; We don't want to allow a constant operand for test insns because\n-;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n-;; be folded while optimizing anyway.\n-\n-(define_insn \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"nonimmediate_operand\" \"g\"))]\n-  \"\"\n-  \"tstl %0\")\n+;; Integer modes supported on VAX, withd a mapping from machine mode\n+;; to mnemonic suffix.  DImode is always a special case.\n+(define_mode_macro VAXint [QI HI SI])\n+(define_mode_attr  isfx [(QI \"b\") (HI \"w\") (SI \"l\")])\n \n-(define_insn \"tsthi\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"nonimmediate_operand\" \"g\"))]\n-  \"\"\n-  \"tstw %0\")\n+;; Similar for float modes supported on VAX.\n+(define_mode_macro VAXfp [SF DF])\n+(define_mode_attr  fsfx [(SF \"f\") (DF \"%#\")])\n \n-(define_insn \"tstqi\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"nonimmediate_operand\" \"g\"))]\n-  \"\"\n-  \"tstb %0\")\n+;; Some ouput patterns want integer immediates with a prefix...\n+(define_mode_attr  iprefx [(QI \"B\") (HI \"H\") (SI \"N\")])\n \n-(define_insn \"tstdf\"\n-  [(set (cc0)\n-\t(match_operand:DF 0 \"general_operand\" \"gF\"))]\n-  \"\"\n-  \"tst%# %0\")\n-\n-(define_insn \"tstsf\"\n-  [(set (cc0)\n-\t(match_operand:SF 0 \"general_operand\" \"gF\"))]\n-  \"\"\n-  \"tstf %0\")\n-\n-(define_insn \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"g\")\n-\t\t (match_operand:SI 1 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"cmpl %0,%1\")\n+;; We don't want to allow a constant operand for test insns because\n+;; We don't want to allow a constant operand for test insns because\n+;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n+;; be folded while optimizing anyway.\n \n-(define_insn \"cmphi\"\n+(define_insn \"tst<mode>\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"g\")\n-\t\t (match_operand:HI 1 \"general_operand\" \"g\")))]\n+\t(match_operand:VAXint 0 \"nonimmediate_operand\" \"g\"))]\n   \"\"\n-  \"cmpw %0,%1\")\n+  \"tst<VAXint:isfx> %0\")\n \n-(define_insn \"cmpqi\"\n+(define_insn \"tst<mode>\"\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"g\")\n-\t\t (match_operand:QI 1 \"general_operand\" \"g\")))]\n+\t(match_operand:VAXfp 0 \"general_operand\" \"gF\"))]\n   \"\"\n-  \"cmpb %0,%1\")\n+  \"tst<VAXfp:fsfx> %0\")\n \n-(define_insn \"cmpdf\"\n+(define_insn \"cmp<mode>\"\n   [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"gF,gF\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"G,gF\")))]\n+\t(compare (match_operand:VAXint 0 \"nonimmediate_operand\" \"g\")\n+\t\t (match_operand:VAXint 1 \"general_operand\" \"g\")))]\n   \"\"\n-  \"@\n-   tst%# %0\n-   cmp%# %0,%1\")\n+  \"cmp<VAXint:isfx> %0,%1\")\n \n-(define_insn \"cmpsf\"\n+(define_insn \"cmp<mode>\"\n   [(set (cc0)\n-\t(compare (match_operand:SF 0 \"general_operand\" \"gF,gF\")\n-\t\t (match_operand:SF 1 \"general_operand\" \"G,gF\")))]\n+\t(compare (match_operand:VAXfp 0 \"general_operand\" \"gF,gF\")\n+\t\t (match_operand:VAXfp 1 \"general_operand\" \"G,gF\")))]\n   \"\"\n   \"@\n-   tstf %0\n-   cmpf %0,%1\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(and:SI (match_operand:SI 0 \"general_operand\" \"g\")\n-\t\t(match_operand:SI 1 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"bitl %0,%1\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(and:HI (match_operand:HI 0 \"general_operand\" \"g\")\n-\t\t(match_operand:HI 1 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"bitw %0,%1\")\n+   tst<VAXfp:fsfx> %0\n+   cmp<VAXfp:fsfx> %0,%1\")\n \n-(define_insn \"\"\n+(define_insn \"*bit<mode>\"\n   [(set (cc0)\n-\t(and:QI (match_operand:QI 0 \"general_operand\" \"g\")\n-\t\t(match_operand:QI 1 \"general_operand\" \"g\")))]\n+\t(and:VAXint (match_operand:VAXint 0 \"general_operand\" \"g\")\n+\t\t   (match_operand:VAXint 1 \"general_operand\" \"g\")))]\n   \"\"\n-  \"bitb %0,%1\")\n+  \"bit<VAXint:isfx> %0,%1\")\n \n ;; The VAX has no sCOND insns.  It does have add/subtract with carry\n ;; which could be used to implement the sltu and sgeu patterns.  However,\n@@ -139,21 +97,13 @@\n ;; and has been deleted.\n \n \f\n-(define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(match_operand:DF 1 \"general_operand\" \"G,gF\"))]\n+(define_insn \"mov<mode>\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(match_operand:VAXfp 1 \"general_operand\" \"G,gF\"))]\n   \"\"\n   \"@\n-   clr%# %0\n-   mov%# %1,%0\")\n-\n-(define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(match_operand:SF 1 \"general_operand\" \"G,gF\"))]\n-  \"\"\n-  \"@\n-   clrf %0\n-   movf %1,%0\")\n+   clr<VAXfp:fsfx> %0\n+   mov<VAXfp:fsfx> %1,%0\")\n \n ;; Some VAXen don't support this instruction.\n ;;(define_insn \"movti\"\n@@ -187,60 +137,11 @@\n ;;  Loads of constants between 64 and 128 used to be done with\n ;; \"addl3 $63,#,dst\" but this is slower than movzbl and takes as much space.\n \n-(define_insn \"movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:SI 1 \"general_operand\" \"g\"))]\n+(define_insn \"mov<mode>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+        (match_operand:VAXint 1 \"general_operand\" \"g\"))]\n   \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n-    {\n-      if (push_operand (operands[0], SImode))\n-\treturn \\\"pushab %a1\\\";\n-      return \\\"movab %a1,%0\\\";\n-    }\n-  if (operands[1] == const0_rtx)\n-    return \\\"clrl %0\\\";\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && (unsigned) INTVAL (operands[1]) >= 64)\n-    {\n-      int i = INTVAL (operands[1]);\n-      if ((unsigned)(~i) < 64)\n-\treturn \\\"mcoml %N1,%0\\\";\n-      if ((unsigned)i < 0x100)\n-\treturn \\\"movzbl %1,%0\\\";\n-      if (i >= -0x80 && i < 0)\n-\treturn \\\"cvtbl %1,%0\\\";\n-      if ((unsigned)i < 0x10000)\n-\treturn \\\"movzwl %1,%0\\\";\n-      if (i >= -0x8000 && i < 0)\n-\treturn \\\"cvtwl %1,%0\\\";\n-    }\n-  if (push_operand (operands[0], SImode))\n-    return \\\"pushl %1\\\";\n-  return \\\"movl %1,%0\\\";\n-}\")\n-\n-(define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      int i = INTVAL (operands[1]);\n-      if (i == 0)\n-\treturn \\\"clrw %0\\\";\n-      else if ((unsigned int)i < 64)\n-\treturn \\\"movw %1,%0\\\";\n-      else if ((unsigned int)~i < 64)\n-\treturn \\\"mcomw %H1,%0\\\";\n-      else if ((unsigned int)i < 256)\n-\treturn \\\"movzbw %1,%0\\\";\n-    }\n-  return \\\"movw %1,%0\\\";\n-}\")\n+  \"* return vax_output_int_move (insn, operands, <MODE>mode);\")\n \n (define_insn \"movstricthi\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+g\"))\n@@ -263,23 +164,6 @@\n   return \\\"movw %1,%0\\\";\n }\")\n \n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:QI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      int i = INTVAL (operands[1]);\n-      if (i == 0)\n-\treturn \\\"clrb %0\\\";\n-      else if ((unsigned int)~i < 64)\n-\treturn \\\"mcomb %B1,%0\\\";\n-    }\n-  return \\\"movb %1,%0\\\";\n-}\")\n-\n (define_insn \"movstrictqi\"\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+g\"))\n \t(match_operand:QI 1 \"general_operand\" \"g\"))]\n@@ -397,218 +281,38 @@\n \f\n ;; Fix-to-float conversion insns.\n \n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g\")\n-\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n+(define_insn \"float<VAXint:mode><VAXfp:mode>2\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g\")\n+\t(float:VAXfp (match_operand:VAXint 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n-  \"cvtlf %1,%0\")\n+  \"cvt<VAXint:isfx><VAXfp:fsfx> %1,%0\")\n \n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g\")\n-\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n-  \"\"\n-  \"cvtl%# %1,%0\")\n-\n-(define_insn \"floathisf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g\")\n-\t(float:SF (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n-  \"\"\n-  \"cvtwf %1,%0\")\n-\n-(define_insn \"floathidf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g\")\n-\t(float:DF (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n-  \"\"\n-  \"cvtw%# %1,%0\")\n-\n-(define_insn \"floatqisf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g\")\n-\t(float:SF (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n-  \"\"\n-  \"cvtbf %1,%0\")\n-\n-(define_insn \"floatqidf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g\")\n-\t(float:DF (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n-  \"\"\n-  \"cvtb%# %1,%0\")\n-\f\n ;; Float-to-fix conversion insns.\n \n-(define_insn \"fix_truncsfqi2\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n-\t(fix:QI (fix:SF (match_operand:SF 1 \"general_operand\" \"gF\"))))]\n-  \"\"\n-  \"cvtfb %1,%0\")\n-\n-(define_insn \"fix_truncsfhi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n-\t(fix:HI (fix:SF (match_operand:SF 1 \"general_operand\" \"gF\"))))]\n-  \"\"\n-  \"cvtfw %1,%0\")\n-\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"gF\"))))]\n-  \"\"\n-  \"cvtfl %1,%0\")\n-\n-(define_insn \"fix_truncdfqi2\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n-\t(fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"gF\"))))]\n-  \"\"\n-  \"cvt%#b %1,%0\")\n-\n-(define_insn \"fix_truncdfhi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n-\t(fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"gF\"))))]\n+(define_insn \"fix_trunc<VAXfp:mode><VAXint:mode>2\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+\t(fix:VAXint (fix:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"gF\"))))]\n   \"\"\n-  \"cvt%#w %1,%0\")\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"gF\"))))]\n-  \"\"\n-  \"cvt%#l %1,%0\")\n+  \"cvt<VAXfp:fsfx><VAXint:isfx> %1,%0\")\n \f\n ;;- All kinds of add instructions.\n \n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(plus:DF (match_operand:DF 1 \"general_operand\" \"0,gF,gF\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"gF,0,gF\")))]\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(plus:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF,gF\")\n+\t\t    (match_operand:VAXfp 2 \"general_operand\" \"gF,0,gF\")))]\n   \"\"\n   \"@\n-   add%#2 %2,%0\n-   add%#2 %1,%0\n-   add%#3 %1,%2,%0\")\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(plus:SF (match_operand:SF 1 \"general_operand\" \"0,gF,gF\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"gF,0,gF\")))]\n-  \"\"\n-  \"@\n-   addf2 %2,%0\n-   addf2 %1,%0\n-   addf3 %1,%2,%0\")\n-\n-/* The space-time-opcode tradeoffs for addition vary by model of VAX.\n-\n-   On a VAX 3 \"movab (r1)[r2],r3\" is faster than \"addl3 r1,r2,r3\",\n-   but it not faster on other models.\n-\n-   \"movab #(r1),r2\" is usually shorter than \"addl3 #,r1,r2\", and is\n-   faster on a VAX 3, but some VAXen (e.g. VAX 9000) will stall if\n-   a register is used in an address too soon after it is set.\n-   Compromise by using movab only when it is shorter than the add\n-   or the base register in the address is one of sp, ap, and fp,\n-   which are not modified very often.  */\n-\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    {\n-      if (operands[2] == const1_rtx)\n-\treturn \\\"incl %0\\\";\n-      if (operands[2] == constm1_rtx)\n-\treturn \\\"decl %0\\\";\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n-\treturn \\\"subl2 $%n2,%0\\\";\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && (unsigned) INTVAL (operands[2]) >= 64\n-\t  && GET_CODE (operands[1]) == REG\n-\t  && ((INTVAL (operands[2]) < 32767 && INTVAL (operands[2]) > -32768)\n-\t      || REGNO (operands[1]) > 11))\n-\treturn \\\"movab %c2(%1),%0\\\";\n-      return \\\"addl2 %2,%0\\\";\n-    }\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"addl2 %1,%0\\\";\n-\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) < 32767\n-      && INTVAL (operands[2]) > -32768\n-      && GET_CODE (operands[1]) == REG\n-      && push_operand (operands[0], SImode))\n-    return \\\"pushab %c2(%1)\\\";\n-\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (unsigned) (- INTVAL (operands[2])) < 64)\n-    return \\\"subl3 $%n2,%1,%0\\\";\n-\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (unsigned) INTVAL (operands[2]) >= 64\n-      && GET_CODE (operands[1]) == REG\n-      && ((INTVAL (operands[2]) < 32767 && INTVAL (operands[2]) > -32768)\n-\t  || REGNO (operands[1]) > 11))\n-    return \\\"movab %c2(%1),%0\\\";\n-\n-  /* Add this if using gcc on a VAX 3xxx:\n-  if (REG_P (operands[1]) && REG_P (operands[2]))\n-    return \\\"movab (%1)[%2],%0\\\";\n-  */\n-  return \\\"addl3 %1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand\" \"g\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    {\n-      if (operands[2] == const1_rtx)\n-\treturn \\\"incw %0\\\";\n-      if (operands[2] == constm1_rtx)\n-\treturn \\\"decw %0\\\";\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n-\treturn \\\"subw2 $%n2,%0\\\";\n-      return \\\"addw2 %2,%0\\\";\n-    }\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"addw2 %1,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (unsigned) (- INTVAL (operands[2])) < 64)\n-    return \\\"subw3 $%n2,%1,%0\\\";\n-  return \\\"addw3 %1,%2,%0\\\";\n-}\")\n+   add<VAXfp:fsfx>2 %2,%0\n+   add<VAXfp:fsfx>2 %1,%0\n+   add<VAXfp:fsfx>3 %1,%2,%0\")\n \n-(define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n-\t(plus:QI (match_operand:QI 1 \"general_operand\" \"g\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"g\")))]\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+\t(plus:VAXint (match_operand:VAXint 1 \"general_operand\" \"g\")\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"g\")))]\n   \"\"\n-  \"*\n-{\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    {\n-      if (operands[2] == const1_rtx)\n-\treturn \\\"incb %0\\\";\n-      if (operands[2] == constm1_rtx)\n-\treturn \\\"decb %0\\\";\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n-\treturn \\\"subb2 $%n2,%0\\\";\n-      return \\\"addb2 %2,%0\\\";\n-    }\n-  if (rtx_equal_p (operands[0], operands[2]))\n-    return \\\"addb2 %1,%0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (unsigned) (- INTVAL (operands[2])) < 64)\n-    return \\\"subb3 $%n2,%1,%0\\\";\n-  return \\\"addb3 %1,%2,%0\\\";\n-}\")\n+  \"* return vax_output_int_add (insn, operands, <MODE>mode);\")\n \n ;; The add-with-carry (adwc) instruction only accepts two operands.\n (define_insn \"adddi3\"\n@@ -656,50 +360,23 @@\n \f\n ;;- All kinds of subtract instructions.\n \n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0,gF\")\n-\t\t  (match_operand:DF 2 \"general_operand\" \"gF,gF\")))]\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(minus:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF\")\n+\t\t     (match_operand:VAXfp 2 \"general_operand\" \"gF,gF\")))]\n   \"\"\n   \"@\n-   sub%#2 %2,%0\n-   sub%#3 %2,%1,%0\")\n+   sub<VAXfp:fsfx>2 %2,%0\n+   sub<VAXfp:fsfx>3 %2,%1,%0\")\n \n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0,gF\")\n-\t\t  (match_operand:SF 2 \"general_operand\" \"gF,gF\")))]\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(minus:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g\")\n+\t\t     (match_operand:VAXint 2 \"general_operand\" \"g,g\")))]\n   \"\"\n   \"@\n-   subf2 %2,%0\n-   subf3 %2,%1,%0\")\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,g\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"g,g\")))]\n-  \"\"\n-  \"@\n-   subl2 %2,%0\n-   subl3 %2,%1,%0\")\n-\n-(define_insn \"subhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,g\")\n-\t\t  (match_operand:HI 2 \"general_operand\" \"g,g\")))]\n-  \"\"\n-  \"@\n-   subw2 %2,%0\n-   subw3 %2,%1,%0\")\n-\n-(define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0,g\")\n-\t\t  (match_operand:QI 2 \"general_operand\" \"g,g\")))]\n-  \"\"\n-  \"@\n-   subb2 %2,%0\n-   subb3 %2,%1,%0\")\n+   sub<VAXint:isfx>2 %2,%0\n+   sub<VAXint:isfx>3 %2,%1,%0\")\n \n ;; The subtract-with-carry (sbwc) instruction only takes two operands.\n (define_insn \"subdi3\"\n@@ -747,55 +424,25 @@\n \f\n ;;- Multiply instructions.\n \n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(mult:DF (match_operand:DF 1 \"general_operand\" \"0,gF,gF\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"gF,0,gF\")))]\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(mult:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF,gF\")\n+\t\t    (match_operand:VAXfp 2 \"general_operand\" \"gF,0,gF\")))]\n   \"\"\n   \"@\n-   mul%#2 %2,%0\n-   mul%#2 %1,%0\n-   mul%#3 %1,%2,%0\")\n+   mul<VAXfp:fsfx>2 %2,%0\n+   mul<VAXfp:fsfx>2 %1,%0\n+   mul<VAXfp:fsfx>3 %1,%2,%0\")\n \n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(mult:SF (match_operand:SF 1 \"general_operand\" \"0,gF,gF\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"gF,0,gF\")))]\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(mult:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g,g\")\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"g,0,g\")))]\n   \"\"\n   \"@\n-   mulf2 %2,%0\n-   mulf2 %1,%0\n-   mulf3 %1,%2,%0\")\n-\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(mult:SI (match_operand:SI 1 \"general_operand\" \"0,g,g\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"g,0,g\")))]\n-  \"\"\n-  \"@\n-   mull2 %2,%0\n-   mull2 %1,%0\n-   mull3 %1,%2,%0\")\n-\n-(define_insn \"mulhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,g,\")\n-\t(mult:HI (match_operand:HI 1 \"general_operand\" \"0,g,g\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"g,0,g\")))]\n-  \"\"\n-  \"@\n-   mulw2 %2,%0\n-   mulw2 %1,%0\n-   mulw3 %1,%2,%0\")\n-\n-(define_insn \"mulqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(mult:QI (match_operand:QI 1 \"general_operand\" \"0,g,g\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"g,0,g\")))]\n-  \"\"\n-  \"@\n-   mulb2 %2,%0\n-   mulb2 %1,%0\n-   mulb3 %1,%2,%0\")\n+   mul<VAXint:isfx>2 %2,%0\n+   mul<VAXint:isfx>2 %1,%0\n+   mul<VAXint:isfx>3 %1,%2,%0\")\n \n (define_insn \"mulsidi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n@@ -837,50 +484,23 @@\n \f\n ;;- Divide instructions.\n \n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"0,gF\")\n-\t\t(match_operand:DF 2 \"general_operand\" \"gF,gF\")))]\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(div:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF\")\n+\t\t   (match_operand:VAXfp 2 \"general_operand\" \"gF,gF\")))]\n   \"\"\n   \"@\n-   div%#2 %2,%0\n-   div%#3 %2,%1,%0\")\n+   div<VAXfp:fsfx>2 %2,%0\n+   div<VAXfp:fsfx>3 %2,%1,%0\")\n \n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(div:SF (match_operand:SF 1 \"general_operand\" \"0,gF\")\n-\t\t(match_operand:SF 2 \"general_operand\" \"gF,gF\")))]\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(div:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g\")\n+\t\t   (match_operand:VAXint 2 \"general_operand\" \"g,g\")))]\n   \"\"\n   \"@\n-   divf2 %2,%0\n-   divf3 %2,%1,%0\")\n-\n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(div:SI (match_operand:SI 1 \"general_operand\" \"0,g\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"g,g\")))]\n-  \"\"\n-  \"@\n-   divl2 %2,%0\n-   divl3 %2,%1,%0\")\n-\n-(define_insn \"divhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(div:HI (match_operand:HI 1 \"general_operand\" \"0,g\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"g,g\")))]\n-  \"\"\n-  \"@\n-   divw2 %2,%0\n-   divw3 %2,%1,%0\")\n-\n-(define_insn \"divqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(div:QI (match_operand:QI 1 \"general_operand\" \"0,g\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"g,g\")))]\n-  \"\"\n-  \"@\n-   divb2 %2,%0\n-   divb3 %2,%1,%0\")\n+   div<VAXint:isfx>2 %2,%0\n+   div<VAXint:isfx>3 %2,%1,%0\")\n \n ;This is left out because it is very slow;\n ;we are better off programming around the \"lack\" of this insn.\n@@ -895,10 +515,10 @@\n ;  \"ediv %2,%1,%0,%3\")\n \f\n ;; Bit-and on the VAX is done with a clear-bits insn.\n-(define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"\"))\n-\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n+(define_expand \"and<mode>3\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"\")\n+\t(and:VAXint (not:VAXint (match_operand:VAXint 1 \"general_operand\" \"\"))\n+\t\t   (match_operand:VAXint 2 \"general_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -915,223 +535,76 @@\n   if (GET_CODE (op1) == CONST_INT)\n     operands[1] = GEN_INT (~INTVAL (op1));\n   else\n-    operands[1] = expand_unop (SImode, one_cmpl_optab, op1, 0, 1);\n+    operands[1] = expand_unop (<MODE>mode, one_cmpl_optab, op1, 0, 1);\n }\")\n \n-(define_expand \"andhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"\"))\n-\t\t(match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  rtx op1 = operands[1];\n-\n-  if (GET_CODE (operands[2]) == CONST_INT && GET_CODE (op1) != CONST_INT)\n-    {\n-      operands[1] = operands[2];\n-      operands[2] = op1;\n-      op1 = operands[1];\n-    }\n-\n-  if (GET_CODE (op1) == CONST_INT)\n-    operands[1] = GEN_INT (~INTVAL (op1));\n-  else\n-    operands[1] = expand_unop (HImode, one_cmpl_optab, op1, 0, 1);\n-}\")\n-\n-(define_expand \"andqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(and:QI (not:QI (match_operand:QI 1 \"general_operand\" \"\"))\n-\t\t(match_operand:QI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  rtx op1 = operands[1];\n-\n-  if (GET_CODE (operands[2]) == CONST_INT && GET_CODE (op1) != CONST_INT)\n-    {\n-     operands[1] = operands[2];\n-     operands[2] = op1;\n-     op1 = operands[1];\n-   }\n-\n-  if (GET_CODE (op1) == CONST_INT)\n-    operands[1] = GEN_INT (~INTVAL (op1));\n-  else\n-    operands[1] = expand_unop (QImode, one_cmpl_optab, op1, 0, 1);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"g,g\"))\n-\t\t(match_operand:SI 2 \"general_operand\" \"0,g\")))]\n-  \"\"\n-  \"@\n-   bicl2 %1,%0\n-   bicl3 %1,%2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"g,g\"))\n-\t\t(match_operand:HI 2 \"general_operand\" \"0,g\")))]\n-  \"\"\n-  \"@\n-   bicw2 %1,%0\n-   bicw3 %1,%2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:QI (not:QI (match_operand:QI 1 \"general_operand\" \"g,g\"))\n-\t\t(match_operand:QI 2 \"general_operand\" \"0,g\")))]\n+(define_insn \"*and<mode>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(and:VAXint (not:VAXint (match_operand:VAXint 1 \"general_operand\" \"g,g\"))\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"0,g\")))]\n   \"\"\n   \"@\n-   bicb2 %1,%0\n-   bicb3 %1,%2,%0\")\n+   bic<VAXint:isfx>2 %1,%0\n+   bic<VAXint:isfx>3 %1,%2,%0\")\n \n ;; The following used to be needed because constant propagation can\n ;; create them starting from the bic insn patterns above.  This is no\n ;; longer a problem.  However, having these patterns allows optimization\n ;; opportunities in combine.c.\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:SI (match_operand:SI 1 \"general_operand\" \"0,g\")\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"n,n\")))]\n+(define_insn \"*and<mode>_const_int\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(and:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g\")\n+\t\t   (match_operand:VAXint 2 \"const_int_operand\" \"n,n\")))]\n   \"\"\n   \"@\n-   bicl2 %N2,%0\n-   bicl3 %N2,%1,%0\")\n+   bic<VAXint:isfx>2 %<VAXint:iprefx>2,%0\n+   bic<VAXint:isfx>3 %<VAXint:iprefx>2,%1,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:HI (match_operand:HI 1 \"general_operand\" \"0,g\")\n-\t\t(match_operand:HI 2 \"const_int_operand\" \"n,n\")))]\n-  \"\"\n-  \"@\n-   bicw2 %H2,%0\n-   bicw3 %H2,%1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:QI (match_operand:QI 1 \"general_operand\" \"0,g\")\n-\t\t(match_operand:QI 2 \"const_int_operand\" \"n,n\")))]\n-  \"\"\n-  \"@\n-   bicb2 %B2,%0\n-   bicb3 %B2,%1,%0\")\n \f\n ;;- Bit set instructions.\n \n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(ior:SI (match_operand:SI 1 \"general_operand\" \"0,g,g\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"g,0,g\")))]\n+(define_insn \"ior<mode>3\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(ior:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g,g\")\n+\t\t   (match_operand:VAXint 2 \"general_operand\" \"g,0,g\")))]\n   \"\"\n   \"@\n-   bisl2 %2,%0\n-   bisl2 %1,%0\n-   bisl3 %2,%1,%0\")\n-\n-(define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(ior:HI (match_operand:HI 1 \"general_operand\" \"0,g,g\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"g,0,g\")))]\n-  \"\"\n-  \"@\n-   bisw2 %2,%0\n-   bisw2 %1,%0\n-   bisw3 %2,%1,%0\")\n-\n-(define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(ior:QI (match_operand:QI 1 \"general_operand\" \"0,g,g\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"g,0,g\")))]\n-  \"\"\n-  \"@\n-   bisb2 %2,%0\n-   bisb2 %1,%0\n-   bisb3 %2,%1,%0\")\n+   bis<VAXint:isfx>2 %2,%0\n+   bis<VAXint:isfx>2 %1,%0\n+   bis<VAXint:isfx>3 %2,%1,%0\")\n \n ;;- xor instructions.\n \n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(xor:SI (match_operand:SI 1 \"general_operand\" \"0,g,g\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"g,0,g\")))]\n-  \"\"\n-  \"@\n-   xorl2 %2,%0\n-   xorl2 %1,%0\n-   xorl3 %2,%1,%0\")\n-\n-(define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(xor:HI (match_operand:HI 1 \"general_operand\" \"0,g,g\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"g,0,g\")))]\n+(define_insn \"xor<mode>3\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(xor:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g,g\")\n+\t\t   (match_operand:VAXint 2 \"general_operand\" \"g,0,g\")))]\n   \"\"\n   \"@\n-   xorw2 %2,%0\n-   xorw2 %1,%0\n-   xorw3 %2,%1,%0\")\n+   xor<VAXint:isfx>2 %2,%0\n+   xor<VAXint:isfx>2 %1,%0\n+   xor<VAXint:isfx>3 %2,%1,%0\")\n \n-(define_insn \"xorqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(xor:QI (match_operand:QI 1 \"general_operand\" \"0,g,g\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"g,0,g\")))]\n-  \"\"\n-  \"@\n-   xorb2 %2,%0\n-   xorb2 %1,%0\n-   xorb3 %2,%1,%0\")\n \f\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g\")\n-\t(neg:DF (match_operand:DF 1 \"general_operand\" \"gF\")))]\n-  \"\"\n-  \"mneg%# %1,%0\")\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g\")\n-\t(neg:SF (match_operand:SF 1 \"general_operand\" \"gF\")))]\n-  \"\"\n-  \"mnegf %1,%0\")\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(neg:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g\")\n+\t(neg:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"gF\")))]\n   \"\"\n-  \"mnegl %1,%0\")\n+  \"mneg<VAXfp:fsfx> %1,%0\")\n \n-(define_insn \"neghi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n-\t(neg:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n+(define_insn \"neg<mode>2\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+\t(neg:VAXint (match_operand:VAXint 1 \"general_operand\" \"g\")))]\n   \"\"\n-  \"mnegw %1,%0\")\n+  \"mneg<VAXint:isfx> %1,%0\")\n \n-(define_insn \"negqi2\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n-\t(neg:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"mnegb %1,%0\")\n-\f\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(not:SI (match_operand:SI 1 \"general_operand\" \"g\")))]\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+\t(not:VAXint (match_operand:VAXint 1 \"general_operand\" \"g\")))]\n   \"\"\n-  \"mcoml %1,%0\")\n+  \"mcom<VAXint:isfx> %1,%0\")\n \n-(define_insn \"one_cmplhi2\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n-\t(not:HI (match_operand:HI 1 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"mcomw %1,%0\")\n-\n-(define_insn \"one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n-\t(not:QI (match_operand:QI 1 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"mcomb %1,%0\")\n \f\n ;; Arithmetic right shift on the VAX works by negating the shift count,\n ;; then emitting a right shift with the shift count negated.  This means\n@@ -1525,101 +998,24 @@\n   \"\"\n   \"insv %3,%2,%1,%0\")\n \f\n+;; Unconditional jump\n (define_insn \"jump\"\n   [(set (pc)\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   \"jbr %l0\")\n \n-(define_insn \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jeql %l0\")\n-\n-(define_insn \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jneq %l0\")\n-\n-(define_insn \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jgtr %l0\")\n-\n-(define_insn \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jgtru %l0\")\n-\n-(define_insn \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jlss %l0\")\n-\n-(define_insn \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jlssu %l0\")\n-\n-(define_insn \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jgeq %l0\")\n-\n-(define_insn \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jgequ %l0\")\n-\n-(define_insn \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"jleq %l0\")\n+;; Conditional jumps\n+(define_code_macro any_cond [eq ne gt lt gtu ltu ge le geu leu])\n \n-(define_insn \"bleu\"\n+(define_insn \"b<code>\"\n   [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n+\t(if_then_else (any_cond (cc0)\n+\t\t\t\t(const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"jlequ %l0\")\n+  \"* return vax_output_conditional_branch (<CODE>);\")\n \n ;; Recognize reversed jumps.\n (define_insn \"\""}]}