{"sha": "c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3MmJiZGExYWYwZjMxNmM0YzVlOWExZDhiNGQ2NzNjM2IxYmY1OA==", "commit": {"author": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2019-02-07T14:54:15Z"}, "committer": {"name": "Matthew Malcomson", "email": "matmal01@gcc.gnu.org", "date": "2019-02-07T14:54:15Z"}, "message": "[Patch] [arm] Fix 88714, Arm LDRD/STRD peepholes.\n\nThese peepholes match a pair of SImode loads or stores that can be\nimplemented with a single LDRD or STRD instruction.\nWhen compiling for TARGET_ARM, these peepholes originally created a set\npattern in DI mode to be caught by movdi patterns.\n\nThis approach failed to take into account the possibility that the two\nmatched insns operated on memory with different aliasing information.\nThe peepholes lost the aliasing information on one of the insns, which\ncould then cause the scheduler to make an invalid transformation.\n\nThis patch changes the peepholes so they generate a PARALLEL expression\nof the two relevant loads or stores, which means the aliasing\ninformation of both is kept.  Such a PARALLEL pattern is what the\npeepholes currently produce for TARGET_THUMB2.\n\nIn order to match these new insn patterns, we add two new define_insn's.  These\ndefine_insn's use the same checks as the peepholes to find valid insns.\n\nNote that the patterns now created by the peepholes for LDRD and STRD\nare very similar to those created by the peepholes for LDM and STM.\nMany patterns could be matched by the LDM and STM define_insns, which\nmeans we rely on the order the define_insn patterns are defined in the\nmachine description, with those for LDRD/STRD defined before those for\nLDM/STM.\n\nThe difference between the peepholes for LDRD/STRD and those for LDM/STM\nare mainly that those for LDRD/STRD have some logic to ensure that the\ntwo registers are consecutive and the first one is even.\n\nBootstrapped and regtested on arm-none-linux-gnu.\nDemonstrated fix of bug 88714 by bootstrapping on armv7l.\n\n\ngcc/ChangeLog:\n\n2019-02-07  Matthew Malcomson  <matthew.malcomson@arm.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\tPR bootstrap/88714\n\t* config/arm/arm-protos.h (valid_operands_ldrd_strd,\n\tarm_count_ldrdstrd_insns): New declarations.\n\t* config/arm/arm.c (mem_ok_for_ldrd_strd): Remove broken handling of\n\tMINUS.\n\t(valid_operands_ldrd_strd): New function.\n\t(arm_count_ldrdstrd_insns): New function.\n\t* config/arm/ldrdstrd.md: Change peepholes to generate PARALLEL SImode\n\tsets instead of single DImode set and define new insns to match this.\n\ngcc/testsuite/ChangeLog:\n\n2019-02-07  Matthew Malcomson  <matthew.malcomson@arm.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\tPR bootstrap/88714\n\t* gcc.c-torture/execute/pr88714.c: New test.\n\t* gcc.dg/rtl/arm/ldrd-peepholes.c: New test.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r268644", "tree": {"sha": "ec4335dc698fef1ba45737328212801e6b2a8115", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec4335dc698fef1ba45737328212801e6b2a8115"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/comments", "author": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5eb9ac1e272c9bcdc17dd0b7d4707e70021a4483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eb9ac1e272c9bcdc17dd0b7d4707e70021a4483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eb9ac1e272c9bcdc17dd0b7d4707e70021a4483"}], "stats": {"total": 808, "additions": 666, "deletions": 142}, "files": [{"sha": "f92d2a5df490f5541a13b1921312b4fae025c6e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "patch": "@@ -1,3 +1,16 @@\n+2019-02-07  Matthew Malcomson  <matthew.malcomson@arm.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/88714\n+\t* config/arm/arm-protos.h (valid_operands_ldrd_strd,\n+\tarm_count_ldrdstrd_insns): New declarations.\n+\t* config/arm/arm.c (mem_ok_for_ldrd_strd): Remove broken handling of\n+\tMINUS.\n+\t(valid_operands_ldrd_strd): New function.\n+\t(arm_count_ldrdstrd_insns): New function.\n+\t* config/arm/ldrdstrd.md: Change peepholes to generate PARALLEL SImode\n+\tsets instead of single DImode set and define new insns to match this.\n+\n 2019-02-07  Tamar Christina  <tamar.christina@arm.com>\n \n \t* config/aarch64/aarch64-builtins.c (aarch64_fcmla_lane_builtin_data):"}, {"sha": "485bc68a618d6ae4a1640368ccb025fe2c9e1420", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "patch": "@@ -125,6 +125,7 @@ extern rtx arm_gen_store_multiple (int *, int, rtx, int, rtx, HOST_WIDE_INT *);\n extern bool offset_ok_for_ldrd_strd (HOST_WIDE_INT);\n extern bool operands_ok_ldrd_strd (rtx, rtx, rtx, HOST_WIDE_INT, bool, bool);\n extern bool gen_operands_ldrd_strd (rtx *, bool, bool, bool);\n+extern bool valid_operands_ldrd_strd (rtx *, bool);\n extern int arm_gen_movmemqi (rtx *);\n extern bool gen_movmem_ldrd_strd (rtx *);\n extern machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n@@ -146,6 +147,7 @@ extern const char *output_mov_long_double_arm_from_arm (rtx *);\n extern const char *output_move_double (rtx *, bool, int *count);\n extern const char *output_move_quad (rtx *);\n extern int arm_count_output_move_double_insns (rtx *);\n+extern int arm_count_ldrdstrd_insns (rtx *, bool);\n extern const char *output_move_vfp (rtx *operands);\n extern const char *output_move_neon (rtx *operands);\n extern int arm_attr_length_move_neon (rtx_insn *);"}, {"sha": "e9aba65c70563f23ba3049702072a59cf555b9ce", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "patch": "@@ -15574,7 +15574,7 @@ mem_ok_for_ldrd_strd (rtx mem, rtx *base, rtx *offset, HOST_WIDE_INT *align)\n       *base = addr;\n       return true;\n     }\n-  else if (GET_CODE (addr) == PLUS || GET_CODE (addr) == MINUS)\n+  else if (GET_CODE (addr) == PLUS)\n     {\n       *base = XEXP (addr, 0);\n       *offset = XEXP (addr, 1);\n@@ -15739,7 +15739,7 @@ gen_operands_ldrd_strd (rtx *operands, bool load,\n     }\n \n   /* Make sure accesses are to consecutive memory locations.  */\n-  if (gap != 4)\n+  if (gap != GET_MODE_SIZE (SImode))\n     return false;\n \n   if (!align_ok_ldrd_strd (align[0], offset))\n@@ -15820,6 +15820,55 @@ gen_operands_ldrd_strd (rtx *operands, bool load,\n }\n \n \n+/* Return true if parallel execution of the two word-size accesses provided\n+   could be satisfied with a single LDRD/STRD instruction.  Two word-size\n+   accesses are represented by the OPERANDS array, where OPERANDS[0,1] are\n+   register operands and OPERANDS[2,3] are the corresponding memory operands.\n+   */\n+bool\n+valid_operands_ldrd_strd (rtx *operands, bool load)\n+{\n+  int nops = 2;\n+  HOST_WIDE_INT offsets[2], offset, align[2];\n+  rtx base = NULL_RTX;\n+  rtx cur_base, cur_offset;\n+  int i, gap;\n+\n+  /* Check that the memory references are immediate offsets from the\n+     same base register.  Extract the base register, the destination\n+     registers, and the corresponding memory offsets.  */\n+  for (i = 0; i < nops; i++)\n+    {\n+      if (!mem_ok_for_ldrd_strd (operands[nops+i], &cur_base, &cur_offset,\n+\t\t\t\t &align[i]))\n+\treturn false;\n+\n+      if (i == 0)\n+\tbase = cur_base;\n+      else if (REGNO (base) != REGNO (cur_base))\n+\treturn false;\n+\n+      offsets[i] = INTVAL (cur_offset);\n+      if (GET_CODE (operands[i]) == SUBREG)\n+\treturn false;\n+    }\n+\n+  if (offsets[0] > offsets[1])\n+    return false;\n+\n+  gap = offsets[1] - offsets[0];\n+  offset = offsets[0];\n+\n+  /* Make sure accesses are to consecutive memory locations.  */\n+  if (gap != GET_MODE_SIZE (SImode))\n+    return false;\n+\n+  if (!align_ok_ldrd_strd (align[0], offset))\n+    return false;\n+\n+  return operands_ok_ldrd_strd (operands[0], operands[1], base, offset,\n+\t\t\t\tfalse, load);\n+}\n \n \f\n /* Print a symbolic form of X to the debug file, F.  */\n@@ -28498,6 +28547,26 @@ arm_count_output_move_double_insns (rtx *operands)\n   return count;\n }\n \n+/* Same as above, but operands are a register/memory pair in SImode.\n+   Assumes operands has the base register in position 0 and memory in position\n+   2 (which is the order provided by the arm_{ldrd,strd} patterns).  */\n+int\n+arm_count_ldrdstrd_insns (rtx *operands, bool load)\n+{\n+  int count;\n+  rtx ops[2];\n+  int regnum, memnum;\n+  if (load)\n+    regnum = 0, memnum = 1;\n+  else\n+    regnum = 1, memnum = 0;\n+  ops[regnum] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+  ops[memnum] = adjust_address (operands[2], DImode, 0);\n+  output_move_double (ops, false, &count);\n+  return count;\n+}\n+\n+\n int\n vfp3_const_double_for_fract_bits (rtx operand)\n {"}, {"sha": "cb7a6adebbc8084a2e642ff2dcbef8b3fb16f268", "filename": "gcc/config/arm/ldrdstrd.md", "status": "modified", "additions": 89, "deletions": 140, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Fconfig%2Farm%2Fldrdstrd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Fconfig%2Farm%2Fldrdstrd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fldrdstrd.md?ref=c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "patch": "@@ -23,37 +23,22 @@\n ;; The following peephole optimizations identify consecutive memory\n ;; accesses, and try to rearrange the operands to enable generation of\n ;; ldrd/strd.\n+;;\n+;; In many cases they behave in the same way that patterns in ldmstm.md behave,\n+;; but there is extra logic in gen_operands_ldrd_strd to try and ensure the\n+;; registers used are an (r<N>, r<N + 1>) pair where N is even.\n \n (define_peephole2 ; ldrd\n   [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 2 \"memory_operand\" \"\"))\n+\t(match_operand:SI 2 \"memory_operand\" \"\"))\n    (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 3 \"memory_operand\" \"\"))]\n+\t(match_operand:SI 3 \"memory_operand\" \"\"))]\n   \"TARGET_LDRD\"\n-  [(const_int 0)]\n+  [(parallel [(set (match_dup 0) (match_dup 2))\n+\t      (set (match_dup 1) (match_dup 3))])]\n {\n   if (!gen_operands_ldrd_strd (operands, true, false, false))\n     FAIL;\n-  else if (TARGET_ARM)\n-  {\n-    /* In ARM state, the destination registers of LDRD/STRD must be\n-       consecutive. We emit DImode access.  */\n-    operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-    operands[2] = adjust_address (operands[2], DImode, 0);\n-    /* Emit [(set (match_dup 0) (match_dup 2))] */\n-    emit_insn (gen_rtx_SET (operands[0], operands[2]));\n-    DONE;\n-  }\n-  else if (TARGET_THUMB2)\n-  {\n-    /* Emit the pattern:\n-       [(parallel [(set (match_dup 0) (match_dup 2))\n-                   (set (match_dup 1) (match_dup 3))])] */\n-    rtx t1 = gen_rtx_SET (operands[0], operands[2]);\n-    rtx t2 = gen_rtx_SET (operands[1], operands[3]);\n-    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, t1, t2)));\n-    DONE;\n-  }\n })\n \n (define_peephole2 ; strd\n@@ -62,117 +47,50 @@\n    (set (match_operand:SI 3 \"memory_operand\" \"\")\n \t(match_operand:SI 1 \"arm_general_register_operand\" \"\"))]\n   \"TARGET_LDRD\"\n-  [(const_int 0)]\n+  [(parallel [(set (match_dup 2) (match_dup 0))\n+\t      (set (match_dup 3) (match_dup 1))])]\n {\n   if (!gen_operands_ldrd_strd (operands, false, false, false))\n     FAIL;\n-  else if (TARGET_ARM)\n-  {\n-    /* In ARM state, the destination registers of LDRD/STRD must be\n-       consecutive. We emit DImode access.  */\n-    operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-    operands[2] = adjust_address (operands[2], DImode, 0);\n-    /* Emit [(set (match_dup 2) (match_dup 0))]  */\n-    emit_insn (gen_rtx_SET (operands[2], operands[0]));\n-    DONE;\n-  }\n-  else if (TARGET_THUMB2)\n-  {\n-    /* Emit the pattern:\n-       [(parallel [(set (match_dup 2) (match_dup 0))\n-                   (set (match_dup 3) (match_dup 1))])]  */\n-    rtx t1 = gen_rtx_SET (operands[2], operands[0]);\n-    rtx t2 = gen_rtx_SET (operands[3], operands[1]);\n-    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, t1, t2)));\n-    DONE;\n-  }\n })\n \n ;; The following peepholes reorder registers to enable LDRD/STRD.\n (define_peephole2 ; strd of constants\n   [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 4 \"const_int_operand\" \"\"))\n+\t(match_operand:SI 4 \"const_int_operand\" \"\"))\n    (set (match_operand:SI 2 \"memory_operand\" \"\")\n-        (match_dup 0))\n+\t(match_dup 0))\n    (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 5 \"const_int_operand\" \"\"))\n+\t(match_operand:SI 5 \"const_int_operand\" \"\"))\n    (set (match_operand:SI 3 \"memory_operand\" \"\")\n-        (match_dup 1))]\n+\t(match_dup 1))]\n   \"TARGET_LDRD\"\n-  [(const_int 0)]\n+  [(set (match_dup 0) (match_dup 4))\n+   (set (match_dup 1) (match_dup 5))\n+   (parallel [(set (match_dup 2) (match_dup 0))\n+\t      (set (match_dup 3) (match_dup 1))])]\n {\n   if (!gen_operands_ldrd_strd (operands, false, true, false))\n     FAIL;\n-  else if (TARGET_ARM)\n-  {\n-   rtx tmp = gen_rtx_REG (DImode, REGNO (operands[0]));\n-   operands[2] = adjust_address (operands[2], DImode, 0);\n-   /* Emit the pattern:\n-      [(set (match_dup 0) (match_dup 4))\n-      (set (match_dup 1) (match_dup 5))\n-      (set (match_dup 2) tmp)]  */\n-   emit_insn (gen_rtx_SET (operands[0], operands[4]));\n-   emit_insn (gen_rtx_SET (operands[1], operands[5]));\n-   emit_insn (gen_rtx_SET (operands[2], tmp));\n-   DONE;\n-  }\n-  else if (TARGET_THUMB2)\n-  {\n-    /* Emit the pattern:\n-       [(set (match_dup 0) (match_dup 4))\n-        (set (match_dup 1) (match_dup 5))\n-        (parallel [(set (match_dup 2) (match_dup 0))\n-                   (set (match_dup 3) (match_dup 1))])]  */\n-    emit_insn (gen_rtx_SET (operands[0], operands[4]));\n-    emit_insn (gen_rtx_SET (operands[1], operands[5]));\n-    rtx t1 = gen_rtx_SET (operands[2], operands[0]);\n-    rtx t2 = gen_rtx_SET (operands[3], operands[1]);\n-    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, t1, t2)));\n-    DONE;\n-  }\n })\n \n (define_peephole2 ; strd of constants\n   [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 4 \"const_int_operand\" \"\"))\n+\t(match_operand:SI 4 \"const_int_operand\" \"\"))\n    (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 5 \"const_int_operand\" \"\"))\n+\t(match_operand:SI 5 \"const_int_operand\" \"\"))\n    (set (match_operand:SI 2 \"memory_operand\" \"\")\n-        (match_dup 0))\n+\t(match_dup 0))\n    (set (match_operand:SI 3 \"memory_operand\" \"\")\n-        (match_dup 1))]\n+\t(match_dup 1))]\n   \"TARGET_LDRD\"\n-  [(const_int 0)]\n+  [(set (match_dup 0) (match_dup 4))\n+   (set (match_dup 1) (match_dup 5))\n+   (parallel [(set (match_dup 2) (match_dup 0))\n+\t      (set (match_dup 3) (match_dup 1))])]\n {\n   if (!gen_operands_ldrd_strd (operands, false, true, false))\n      FAIL;\n-  else if (TARGET_ARM)\n-  {\n-   rtx tmp = gen_rtx_REG (DImode, REGNO (operands[0]));\n-   operands[2] = adjust_address (operands[2], DImode, 0);\n-   /* Emit the pattern\n-      [(set (match_dup 0) (match_dup 4))\n-       (set (match_dup 1) (match_dup 5))\n-       (set (match_dup 2) tmp)]  */\n-   emit_insn (gen_rtx_SET (operands[0], operands[4]));\n-   emit_insn (gen_rtx_SET (operands[1], operands[5]));\n-   emit_insn (gen_rtx_SET (operands[2], tmp));\n-   DONE;\n-  }\n-  else if (TARGET_THUMB2)\n-  {\n-    /*  Emit the pattern:\n-        [(set (match_dup 0) (match_dup 4))\n-         (set (match_dup 1) (match_dup 5))\n-         (parallel [(set (match_dup 2) (match_dup 0))\n-                    (set (match_dup 3) (match_dup 1))])]  */\n-    emit_insn (gen_rtx_SET (operands[0], operands[4]));\n-    emit_insn (gen_rtx_SET (operands[1], operands[5]));\n-    rtx t1 = gen_rtx_SET (operands[2], operands[0]);\n-    rtx t2 = gen_rtx_SET (operands[3], operands[1]);\n-    emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, t1, t2)));\n-    DONE;\n-  }\n })\n \n ;; The following two peephole optimizations are only relevant for ARM\n@@ -181,39 +99,32 @@\n (define_peephole2 ; swap the destination registers of two loads\n \t\t  ; before a commutative operation.\n   [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 2 \"memory_operand\" \"\"))\n+\t(match_operand:SI 2 \"memory_operand\" \"\"))\n    (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 3 \"memory_operand\" \"\"))\n+\t(match_operand:SI 3 \"memory_operand\" \"\"))\n    (set (match_operand:SI 4 \"arm_general_register_operand\" \"\")\n-        (match_operator:SI 5 \"commutative_binary_operator\"\n+\t(match_operator:SI 5 \"commutative_binary_operator\"\n \t\t\t   [(match_operand 6 \"arm_general_register_operand\" \"\")\n \t\t\t    (match_operand 7 \"arm_general_register_operand\" \"\") ]))]\n   \"TARGET_LDRD && TARGET_ARM\n    && (  ((rtx_equal_p(operands[0], operands[6])) && (rtx_equal_p(operands[1], operands[7])))\n-        ||((rtx_equal_p(operands[0], operands[7])) && (rtx_equal_p(operands[1], operands[6]))))\n+\t||((rtx_equal_p(operands[0], operands[7])) && (rtx_equal_p(operands[1], operands[6]))))\n    && (peep2_reg_dead_p (3, operands[0]) || rtx_equal_p (operands[0], operands[4]))\n    && (peep2_reg_dead_p (3, operands[1]) || rtx_equal_p (operands[1], operands[4]))\"\n-  [(set (match_dup 0) (match_dup 2))\n+  [(parallel [(set (match_dup 0) (match_dup 2))\n+\t      (set (match_dup 1) (match_dup 3))])\n    (set (match_dup 4) (match_op_dup 5 [(match_dup 6) (match_dup 7)]))]\n-  {\n-    if (!gen_operands_ldrd_strd (operands, true, false, true))\n-     {\n-        FAIL;\n-     }\n-    else\n-     {\n-        operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-        operands[2] = adjust_address (operands[2], DImode, 0);\n-     }\n-   }\n-)\n+{\n+  if (!gen_operands_ldrd_strd (operands, true, false, true))\n+    FAIL;\n+})\n \n (define_peephole2 ; swap the destination registers of two loads\n \t\t  ; before a commutative operation that sets the flags.\n   [(set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 2 \"memory_operand\" \"\"))\n+\t(match_operand:SI 2 \"memory_operand\" \"\"))\n    (set (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n-        (match_operand:SI 3 \"memory_operand\" \"\"))\n+\t(match_operand:SI 3 \"memory_operand\" \"\"))\n    (parallel\n       [(set (match_operand:SI 4 \"arm_general_register_operand\" \"\")\n \t    (match_operator:SI 5 \"commutative_binary_operator\"\n@@ -225,24 +136,62 @@\n        ||((rtx_equal_p(operands[0], operands[7])) && (rtx_equal_p(operands[1], operands[6]))))\n    && (peep2_reg_dead_p (3, operands[0]) || rtx_equal_p (operands[0], operands[4]))\n    && (peep2_reg_dead_p (3, operands[1]) || rtx_equal_p (operands[1], operands[4]))\"\n-  [(set (match_dup 0) (match_dup 2))\n+  [(parallel [(set (match_dup 0) (match_dup 2))\n+\t      (set (match_dup 1) (match_dup 3))])\n    (parallel\n       [(set (match_dup 4)\n \t    (match_op_dup 5 [(match_dup 6) (match_dup 7)]))\n        (clobber (reg:CC CC_REGNUM))])]\n-  {\n-    if (!gen_operands_ldrd_strd (operands, true, false, true))\n-     {\n-        FAIL;\n-     }\n-    else\n-     {\n-        operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n-        operands[2] = adjust_address (operands[2], DImode, 0);\n-     }\n-   }\n-)\n+{\n+  if (!gen_operands_ldrd_strd (operands, true, false, true))\n+    FAIL;\n+})\n \n ;; TODO: Handle LDRD/STRD with writeback:\n ;; (a) memory operands can be POST_INC, POST_DEC, PRE_MODIFY, POST_MODIFY\n ;; (b) Patterns may be followed by an update of the base address.\n+\n+\n+;; insns matching the LDRD/STRD patterns that will get created by the above\n+;; peepholes.\n+;; We use gen_operands_ldrd_strd() with a modify argument as false so that the\n+;; operands are not changed.\n+(define_insn \"*arm_ldrd\"\n+  [(parallel [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t\t   (match_operand:SI 2 \"memory_operand\" \"m\"))\n+\t      (set (match_operand:SI 1 \"s_register_operand\" \"=r\")\n+\t\t   (match_operand:SI 3 \"memory_operand\" \"m\"))])]\n+  \"TARGET_LDRD && TARGET_ARM && reload_completed\n+  && valid_operands_ldrd_strd (operands, true)\"\n+  {\n+    rtx op[2];\n+    op[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+    op[1] = adjust_address (operands[2], DImode, 0);\n+    return output_move_double (op, true, NULL);\n+  }\n+  [(set (attr \"length\")\n+\t(symbol_ref \"arm_count_ldrdstrd_insns (operands, true) * 4\"))\n+   (set (attr \"ce_count\") (symbol_ref \"get_attr_length (insn) / 4\"))\n+   (set_attr \"type\" \"load_8\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n+\n+(define_insn \"*arm_strd\"\n+  [(parallel [(set (match_operand:SI 2 \"memory_operand\" \"=m\")\n+\t\t   (match_operand:SI 0 \"s_register_operand\" \"r\"))\n+\t      (set (match_operand:SI 3 \"memory_operand\" \"=m\")\n+\t\t   (match_operand:SI 1 \"s_register_operand\" \"r\"))])]\n+  \"TARGET_LDRD && TARGET_ARM && reload_completed\n+  && valid_operands_ldrd_strd (operands, false)\"\n+  {\n+    rtx op[2];\n+    op[0] = adjust_address (operands[2], DImode, 0);\n+    op[1] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+    return output_move_double (op, true, NULL);\n+  }\n+  [(set (attr \"length\")\n+\t(symbol_ref \"arm_count_ldrdstrd_insns (operands, false) * 4\"))\n+   (set (attr \"ce_count\") (symbol_ref \"get_attr_length (insn) / 4\"))\n+   (set_attr \"type\" \"store_8\")\n+   (set_attr \"predicable\" \"yes\")]\n+)"}, {"sha": "b27035560f7e33e4486ce1ba472adf95e5153681", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "patch": "@@ -1,3 +1,10 @@\n+2019-02-07  Matthew Malcomson  <matthew.malcomson@arm.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/88714\n+\t* gcc.c-torture/execute/pr88714.c: New test.\n+\t* gcc.dg/rtl/arm/ldrd-peepholes.c: New test.\n+\n 2019-02-07  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR/target 88850"}, {"sha": "614ad9ac4a0662ba752532270e2d687505504d48", "filename": "gcc/testsuite/gcc.c-torture/execute/pr88714.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr88714.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr88714.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr88714.c?ref=c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "patch": "@@ -0,0 +1,43 @@\n+/* PR bootstrap/88714 */\n+\n+struct S { int a, b, c; int *d; };\n+struct T { int *e, *f, *g; } *t = 0;\n+int *o = 0;\n+\n+__attribute__((noipa))\n+void bar (int *x, int y, int z, int w)\n+{\n+  if (w == -1)\n+    {\n+      if (x != 0 || y != 0 || z != 0)\n+\t__builtin_abort ();\n+    }\n+  else if (w != 0 || x != t->g || y != 0 || z != 12)\n+    __builtin_abort ();\n+}\n+\n+__attribute__((noipa)) void\n+foo (struct S *x, struct S *y, int *z, int w)\n+{\n+  *o = w;\n+  if (w)\n+    bar (0, 0, 0, -1);\n+  x->d = z;\n+  if (y->d)\n+    y->c = y->c + y->d[0];\n+  bar (t->g, 0, y->c, 0);\n+}\n+\n+int\n+main ()\n+{\n+  int a[4] = { 8, 9, 10, 11 };\n+  struct S s = { 1, 2, 3, &a[0] };\n+  struct T u = { 0, 0, &a[3] };\n+  o = &a[2];\n+  t = &u;\n+  foo (&s, &s, &a[1], 5);\n+  if (s.c != 12 || s.d != &a[1])\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "ff209c5df29765441bbe9481ac8caf7bbc6af8f7", "filename": "gcc/testsuite/gcc.dg/rtl/arm/ldrd-peepholes.c", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Farm%2Fldrd-peepholes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Farm%2Fldrd-peepholes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Farm%2Fldrd-peepholes.c?ref=c272bbda1af0f316c4c5e9a1d8b4d673c3b1bf58", "patch": "@@ -0,0 +1,441 @@\n+/* { dg-do compile } */\n+/* { dg-skip-if \"Ensure only targetting arm with TARGET_LDRD\" { *-*-* } { \"-mthumb\" } { \"\" } } */\n+/* { dg-options \"-O3 -marm -fdump-rtl-peephole2\" } */\n+\n+/*\n+   Test file contains testcases that are there to check.\n+      1) Each peephole generates the expected patterns.\n+      2) These patterns match the expected define_insns and generate ldrd/strd.\n+      2) Memory alias information is not lost in the peephole transformation.\n+\n+   I don't check the peephole pass on most of the functions here but just check\n+   the correct assembly is output.  The ldrd/strd peepholes only generate a\n+   different pattern to the ldm/stm peepholes in some specific cases, and those\n+   are checked.\n+\n+   The exceptions are tested by the crafted testcases at the end of this file\n+   that are named in the pattern foo_x[[:digit:]].\n+\n+   The first testcase (foo_mem_11) demonstrates bug 88714 is fixed by checking\n+   that both alias sets in the RTL are preserved.\n+\n+   All other testcases are only checked to see that they generate a LDRD or\n+   STRD instruction accordingly.\n+ */\n+\n+\n+/* Example of bugzilla 88714 -- memory aliasing info needs to be retained.  */\n+int __RTL (startwith (\"peephole2\")) foo_mem_11 (int *a, int *b)\n+{\n+(function \"foo_mem_11\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 101 (set (reg:SI r2)\n+\t\t      (mem/c:SI (reg:SI r0) [1 S4 A64])) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (reg:SI r3)\n+\t\t      (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [2 S4 A32])) \"/home/matmal01/test.c\":18)\n+      (cinsn 103 (set (reg:SI r0)\n+\t\t      (plus:SI (reg:SI r2) (reg:SI r3))) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+/* { dg-final { scan-rtl-dump {Function foo_mem_11.*\\(mem/c:SI[^\\n]*\\[1.*\\(mem/c:SI[^\\n]*\\n[^\\n]*\\[2.*Function foo11} \"peephole2\" } } */\n+\n+/* ldrd plain peephole2.  */\n+int __RTL (startwith (\"peephole2\")) foo11 (int *a)\n+{\n+(function \"foo11\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 101 (set (reg:SI r2)\n+\t\t      (mem/c:SI (reg:SI r0) [0 S4 A64])) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (reg:SI r3)\n+\t\t      (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])) \"/home/matmal01/test.c\":18)\n+      (cinsn 103 (set (reg:SI r0)\n+\t\t      (plus:SI (reg:SI r2) (reg:SI r3))) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+\n+/* ldrd plain peephole2, which accepts insns initially out of order.  */\n+int __RTL (startwith (\"peephole2\")) foo11_alt (int *a)\n+{\n+(function \"foo11_alt\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 102 (set (reg:SI r3)\n+\t\t      (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])) \"/home/matmal01/test.c\":18)\n+      (cinsn 101 (set (reg:SI r2)\n+\t\t      (mem/c:SI (reg:SI r0) [0 S4 A64])) \"/home/matmal01/test.c\":18)\n+      (cinsn 103 (set (reg:SI r0)\n+\t\t      (plus:SI (reg:SI r2) (reg:SI r3))) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+\n+/* strd plain peephole2.  */\n+int __RTL (startwith (\"peephole2\")) foo12 (int *a)\n+{\n+(function \"foo12\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 101 (set (mem/c:SI (reg:SI r0) [0 S4 A64])\n+\t\t      (reg:SI r2)) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])\n+\t\t      (reg:SI r3)) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+\n+/* strd of constants -- store interleaved with constant move into register.\n+   Use same register twice to ensure we use the relevant pattern.  */\n+int __RTL (startwith (\"peephole2\")) foo13 (int *a)\n+{\n+(function \"foo13\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 99  (set (reg:SI r2)\n+\t\t      (const_int 1)) \"/home/matmal01/test.c\":18)\n+      (cinsn 101 (set (mem/c:SI (reg:SI r0) [0 S4 A64])\n+\t\t      (reg:SI r2)) \"/home/matmal01/test.c\":18)\n+      (cinsn 100 (set (reg:SI r2)\n+\t\t      (const_int 0)) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])\n+\t\t      (reg:SI r2)) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+\n+/* strd of constants -- stores after constant moves into registers.\n+   Use registers out of order, is only way to avoid plain strd while hitting\n+   this pattern.  */\n+int __RTL (startwith (\"peephole2\")) foo14 (int *a)\n+{\n+(function \"foo14\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 99  (set (reg:SI r3)\n+\t\t      (const_int 1)) \"/home/matmal01/test.c\":18)\n+      (cinsn 100 (set (reg:SI r2)\n+\t\t      (const_int 0)) \"/home/matmal01/test.c\":18)\n+      (cinsn 101 (set (mem/c:SI (reg:SI r0) [0 S4 A64])\n+\t\t      (reg:SI r3)) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])\n+\t\t      (reg:SI r2)) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+\n+/* swap the destination registers of two loads before a commutative operation.\n+   Here the commutative operation is what the peephole uses to know it can\n+   swap the register loads around.  */\n+int __RTL (startwith (\"peephole2\")) foo15 (int *a)\n+{\n+(function \"foo15\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 100 (set (reg:SI r3)\n+\t\t      (mem/c:SI (reg:SI r0) [0 S4 A64])) \"/home/matmal01/test.c\":18)\n+      (cinsn 101 (set (reg:SI r2)\n+\t\t      (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (reg:SI r0)\n+\t\t      (plus:SI (reg:SI r2) (reg:SI r3))) \"/home/matmal01/test.c\":18\n+       (expr_list:REG_DEAD (reg:SI r2)\n+\t(expr_list:REG_DEAD (reg:SI r3)\n+\t (nil))))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+\n+\n+/* swap the destination registers of two loads before a commutative operation\n+   that sets the flags.  */\n+/*\n+   NOTE Can't make a testcase for this pattern since there are no insn patterns\n+   matching the parallel insn in the peephole.\n+\n+   i.e. until some define_insn is defined matching that insn that peephole can\n+   never match in real code, and in artificial RTL code any pattern that can\n+   match it will cause an ICE.\n+\n+int __RTL (startwith (\"peephole2\")) foo16 (int *a)\n+{\n+(function \"foo16\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 100 (set (reg:SI r3)\n+\t\t      (mem/c:SI (reg:SI r0) [0 S4 A64])) \"/home/matmal01/test.c\":18)\n+      (cinsn 101 (set (reg:SI r2)\n+\t\t      (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])) \"/home/matmal01/test.c\":18)\n+      (cinsn 103 (parallel\n+\t\t  [(set (reg:SI r0)\n+\t\t\t(and:SI (reg:SI r3) (reg:SI r2)))\n+\t\t  (clobber (reg:CC cc))]) \"/home/matmal01/test.c\":18\n+       (expr_list:REG_DEAD (reg:SI r2)\n+\t(expr_list:REG_DEAD (reg:SI r3)\n+\t (nil))))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+*/\n+\n+\n+/* Making patterns that will behave differently between the LDM/STM peepholes\n+   and LDRD/STRD peepholes.\n+   gen_operands_ldrd_strd() uses peep2_find_free_register() to find spare\n+   registers to use.\n+   peep2_find_free_register() only ever returns registers marked in\n+   call_used_regs, hence we make sure to leave register 2 and 3 available (as\n+   they are always on in the defaults marked by CALL_USED_REGISTERS).  */\n+\n+/* gen_operands_ldrd_strd() purposefully finds an even register to look at\n+   which would treat the following pattern differently to the stm peepholes.\n+ */\n+int __RTL (startwith (\"peephole2\")) foo_x1 (int *a)\n+{\n+(function \"foo_x1\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 99  (set (reg:SI r5)\n+\t\t      (const_int 1)) \"/home/matmal01/test.c\":18)\n+      (cinsn 101 (set (mem/c:SI (reg:SI r0) [0 S4 A64])\n+\t\t      (reg:SI r5)) \"/home/matmal01/test.c\":18)\n+      (cinsn 100 (set (reg:SI r5)\n+\t\t      (const_int 0)) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])\n+\t\t      (reg:SI r5)) \"/home/matmal01/test.c\":18\n+       (expr_list:REG_DEAD (reg:SI r5)\n+\t (nil)))\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+/* Ensure we generated a parallel that started with a set from an even register.\n+   i.e.\n+   (parallel [\n+     (set (mem\n+\t  (reg:SI <even>\n+   */\n+/* { dg-final { scan-rtl-dump {Function foo_x1.*\\(parallel \\[\\n[^\\n]*\\(set \\(mem[^\\n]*\\n[^\\n]*\\(reg:SI (?:[12])?[2468] r(?:[12])?[2468]\\).*Function foo_x2} \"peephole2\" } } */\n+\n+/* Like above gen_operands_ldrd_strd() would look to start with an even\n+   register while gen_const_stm_seq() doesn't care.  */\n+int __RTL (startwith (\"peephole2\")) foo_x2 (int *a)\n+{\n+(function \"foo_x2\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 99  (set (reg:SI r5)\n+\t\t      (const_int 1)) \"/home/matmal01/test.c\":18)\n+      (cinsn 100 (set (reg:SI r6)\n+\t\t      (const_int 0)) \"/home/matmal01/test.c\":18)\n+      (cinsn 101 (set (mem/c:SI (reg:SI r0) [0 S4 A64])\n+\t\t      (reg:SI r5)) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])\n+\t\t      (reg:SI r6)) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+/* Ensure generated parallel starts with a set from an even register (as foo_x1).  */\n+/* { dg-final { scan-rtl-dump {Function foo_x2.*\\(parallel \\[\\n[^\\n]*\\(set \\(mem[^\\n]*\\n[^\\n]*\\(reg:SI (?:[12])?[2468] r(?:[12])?[2468]\\).*Function foo_x3} \"peephole2\" } } */\n+\n+/* When storing multiple values into a register that will be used later, ldrd\n+   searches for another register to use instead of just giving up.  */\n+int __RTL (startwith (\"peephole2\")) foo_x3 (int *a)\n+{\n+(function \"foo_x3\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 99  (set (reg:SI r3)\n+\t\t      (const_int 1)) \"/home/matmal01/test.c\":18)\n+      (cinsn 101 (set (mem/c:SI (reg:SI r0) [0 S4 A64])\n+\t\t      (reg:SI r3)) \"/home/matmal01/test.c\":18)\n+      (cinsn 100 (set (reg:SI r3)\n+\t\t      (const_int 0)) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (mem/c:SI (plus:SI (reg:SI r0) (const_int 4)) [0 S4 A32])\n+\t\t      (reg:SI r3)) \"/home/matmal01/test.c\":18)\n+      (cinsn 103 (set (reg:SI r0)\n+\t\t      (plus:SI (reg:SI r0) (reg:SI r3))) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+/* Ensure generated parallel starts with a set from an even register (as foo_x1).  */\n+/* { dg-final { scan-rtl-dump {Function foo_x3.*\\(parallel \\[\\n[^\\n]*\\(set \\(mem[^\\n]*\\n[^\\n]*\\(reg:SI (?:[12])?[2468] r(?:[12])?[2468]\\).*Function foo_x4} \"peephole2\" } } */\n+\n+/* ldrd gen_peephole2_11 but using plus 8 and plus 12 in the offsets.  */\n+int __RTL (startwith (\"peephole2\")) foo_x4 (int *a)\n+{\n+(function \"foo_x4\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 101 (set (reg:SI r2)\n+\t\t      (mem/c:SI (plus:SI (reg:SI r0) (const_int 8)) [0 S4 A64])) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (reg:SI r3)\n+\t\t      (mem/c:SI (plus:SI (reg:SI r0) (const_int 12)) [0 S4 A32])) \"/home/matmal01/test.c\":18)\n+      (cinsn 103 (set (reg:SI r0)\n+\t\t      (plus:SI (reg:SI r2) (reg:SI r3))) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+/* Ensure generated parallel starts with a set from the appropriate offset from\n+   register 0.\n+(parallel [\n+\t    (set (reg:SI ...\n+\t\t(mem/c:SI (plus:SI (reg:SI 0 r0)\n+\t\t\t(const_int 8 .*\n+*/\n+/* { dg-final { scan-rtl-dump {Function foo_x4.*\\(parallel \\[\\n[^\\n]*\\(set \\(reg:SI[^\\n]*\\n *\\(mem/c:SI \\(plus:SI \\(reg:SI 0 r0\\)\\n *\\(const_int 8.*Function foo_x5} \"peephole2\" } } */\n+\n+/* strd gen_peephole2_12 but using plus 8 and plus 12 in the offsets.  */\n+int __RTL (startwith (\"peephole2\")) foo_x5 (int *a)\n+{\n+(function \"foo12\"\n+  (insn-chain\n+    (cnote 1 NOTE_INSN_DELETED)\n+    (block 2\n+      (edge-from entry (flags \"FALLTHRU\"))\n+      (cnote 3 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+      (cinsn 101 (set (mem/c:SI (plus:SI (reg:SI r0) (const_int 8)) [0 S4 A64])\n+\t\t      (reg:SI r2)) \"/home/matmal01/test.c\":18)\n+      (cinsn 102 (set (mem/c:SI (plus:SI (reg:SI r0) (const_int 12)) [0 S4 A32])\n+\t\t      (reg:SI r3)) \"/home/matmal01/test.c\":18)\n+      (edge-to exit (flags \"FALLTHRU\"))\n+    ) ;; block 2\n+  ) ;; insn-chain\n+  (crtl\n+    (return_rtx\n+      (reg/i:SI r0)\n+    ) ;; return_rtx\n+  ) ;; crtl\n+) ;; function \"main\"\n+}\n+/* Ensure generated parallel starts with a set to the appropriate offset from\n+   register 0.  */\n+/* { dg-final { scan-rtl-dump {Function foo_x5.*\\(parallel \\[\\n[^\\n]*\\(set \\(mem/c:SI \\(plus:SI \\(reg:SI 0 r0\\)\\n *\\(const_int 8.*$} \"peephole2\" } } */\n+\n+\n+/* { dg-final { scan-assembler-not \"ldm\" } } */\n+/* { dg-final { scan-assembler-not \"stm\" } } */\n+/* { dg-final { scan-assembler-times {ldrd\\tr[2468], \\[r0\\]} 4 } } */\n+/* { dg-final { scan-assembler-times {ldrd\\tr[2468], \\[r0, #8\\]} 1 } } */\n+/* { dg-final { scan-assembler-times {strd\\tr[2468], \\[r0\\]} 6 } } */\n+/* { dg-final { scan-assembler-times {strd\\tr[2468], \\[r0, #8\\]} 1 } } */"}]}