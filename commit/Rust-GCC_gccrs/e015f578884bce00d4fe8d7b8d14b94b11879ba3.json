{"sha": "e015f578884bce00d4fe8d7b8d14b94b11879ba3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAxNWY1Nzg4ODRiY2UwMGQ0ZmU4ZDdiOGQxNGI5NGIxMTg3OWJhMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2006-12-31T17:27:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-12-31T17:27:35Z"}, "message": "re PR tree-optimization/30137 (Missed folding of pointer comparison)\n\n2006-12-31  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/30137\n\t* fold-const.c (fold_comparison): Fold comparison of addresses\n\tof components.\n\n\t* testsuite/gcc.dg/pr30137-1.c: New testcase.\n\t* testsuite/gcc.dg/pr30137-2.c: Likewise.\n\nFrom-SVN: r120301", "tree": {"sha": "37fae3dae27d12d89d0e81b7873ac69ef8dd0b39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37fae3dae27d12d89d0e81b7873ac69ef8dd0b39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e015f578884bce00d4fe8d7b8d14b94b11879ba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e015f578884bce00d4fe8d7b8d14b94b11879ba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e015f578884bce00d4fe8d7b8d14b94b11879ba3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e015f578884bce00d4fe8d7b8d14b94b11879ba3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "870aa1ebe0d3e05912f763ece1ed4491282d34e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/870aa1ebe0d3e05912f763ece1ed4491282d34e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/870aa1ebe0d3e05912f763ece1ed4491282d34e2"}], "stats": {"total": 159, "additions": 159, "deletions": 0}, "files": [{"sha": "168c1959976341c9930f2d1d51afc80fcc7e7360", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e015f578884bce00d4fe8d7b8d14b94b11879ba3", "patch": "@@ -1,3 +1,9 @@\n+2006-12-31  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/30137\n+\t* fold-const.c (fold_comparison): Fold comparison of addresses\n+\tof components.\n+\n 2006-12-31  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/30322"}, {"sha": "071ddcd6e7df42c2ad7414286235db19fac11fe1", "filename": "gcc/fold-const.c", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e015f578884bce00d4fe8d7b8d14b94b11879ba3", "patch": "@@ -7988,6 +7988,110 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \treturn fold_build2 (code, type, variable, lhs);\n     }\n \n+  /* For comparisons of pointers we can decompose it to a compile time\n+     comparison of the base objects and the offsets into the object.\n+     This requires at least one operand being an ADDR_EXPR to do more\n+     than the operand_equal_p test below.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (arg0))\n+      && (TREE_CODE (arg0) == ADDR_EXPR\n+\t  || TREE_CODE (arg1) == ADDR_EXPR))\n+    {\n+      tree base0, base1, offset0 = NULL_TREE, offset1 = NULL_TREE;\n+      HOST_WIDE_INT bitsize, bitpos0 = 0, bitpos1 = 0;\n+      enum machine_mode mode;\n+      int volatilep, unsignedp;\n+      bool indirect_base0 = false;\n+\n+      /* Get base and offset for the access.  Strip ADDR_EXPR for\n+\t get_inner_reference, but put it back by stripping INDIRECT_REF\n+\t off the base object if possible.  */\n+      base0 = arg0;\n+      if (TREE_CODE (arg0) == ADDR_EXPR)\n+\t{\n+\t  base0 = get_inner_reference (TREE_OPERAND (arg0, 0),\n+\t\t\t\t       &bitsize, &bitpos0, &offset0, &mode,\n+\t\t\t\t       &unsignedp, &volatilep, false);\n+\t  if (TREE_CODE (base0) == INDIRECT_REF)\n+\t    base0 = TREE_OPERAND (base0, 0);\n+\t  else\n+\t    indirect_base0 = true;\n+\t}\n+\n+      base1 = arg1;\n+      if (TREE_CODE (arg1) == ADDR_EXPR)\n+\t{\n+\t  base1 = get_inner_reference (TREE_OPERAND (arg1, 0),\n+\t\t\t\t       &bitsize, &bitpos1, &offset1, &mode,\n+\t\t\t\t       &unsignedp, &volatilep, false);\n+\t  /* We have to make sure to have an indirect/non-indirect base1\n+\t     just the same as we did for base0.  */\n+\t  if (TREE_CODE (base1) == INDIRECT_REF\n+\t      && !indirect_base0)\n+\t    base1 = TREE_OPERAND (base1, 0);\n+\t  else if (!indirect_base0)\n+\t    base1 = NULL_TREE;\n+\t}\n+      else if (indirect_base0)\n+\tbase1 = NULL_TREE;\n+\n+      /* If we have equivalent bases we might be able to simplify.  */\n+      if (base0 && base1\n+\t  && operand_equal_p (base0, base1, 0))\n+\t{\n+\t  /* We can fold this expression to a constant if the non-constant\n+\t     offset parts are equal.  */\n+\t  if (offset0 == offset1\n+\t      || (offset0 && offset1\n+\t\t  && operand_equal_p (offset0, offset1, 0)))\n+\t    {\n+\t      switch (code)\n+\t\t{\n+\t\tcase EQ_EXPR:\n+\t\t  return build_int_cst (boolean_type_node, bitpos0 == bitpos1);\n+\t\tcase NE_EXPR:\n+\t\t  return build_int_cst (boolean_type_node, bitpos0 != bitpos1);\n+\t\tcase LT_EXPR:\n+\t\t  return build_int_cst (boolean_type_node, bitpos0 < bitpos1);\n+\t\tcase LE_EXPR:\n+\t\t  return build_int_cst (boolean_type_node, bitpos0 <= bitpos1);\n+\t\tcase GE_EXPR:\n+\t\t  return build_int_cst (boolean_type_node, bitpos0 >= bitpos1);\n+\t\tcase GT_EXPR:\n+\t\t  return build_int_cst (boolean_type_node, bitpos0 > bitpos1);\n+\t\tdefault:;\n+\t\t}\n+\t    }\n+\t  /* We can simplify the comparison to a comparison of the variable\n+\t     offset parts if the constant offset parts are equal.\n+\t     Be careful to use signed size type here because otherwise we\n+\t     mess with array offsets in the wrong way.  This is possible\n+\t     because pointer arithmetic is restricted to retain within an\n+\t     object and overflow on pointer differences is undefined as of\n+\t     6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */\n+\t  else if (bitpos0 == bitpos1)\n+\t    {\n+\t      tree signed_size_type_node;\n+\t      signed_size_type_node = signed_type_for (size_type_node);\n+\n+\t      /* By converting to signed size type we cover middle-end pointer\n+\t         arithmetic which operates on unsigned pointer types of size\n+\t         type size and ARRAY_REF offsets which are properly sign or\n+\t         zero extended from their type in case it is narrower than\n+\t         size type.  */\n+\t      if (offset0 == NULL_TREE)\n+\t\toffset0 = build_int_cst (signed_size_type_node, 0);\n+\t      else\n+\t\toffset0 = fold_convert (signed_size_type_node, offset0);\n+\t      if (offset1 == NULL_TREE)\n+\t\toffset1 = build_int_cst (signed_size_type_node, 0);\n+\t      else\n+\t\toffset1 = fold_convert (signed_size_type_node, offset1);\n+\n+\t      return fold_build2 (code, type, offset0, offset1);\n+\t    }\n+\t}\n+    }\n+\n   /* If this is a comparison of two exprs that look like an ARRAY_REF of the\n      same object, then we can fold this to a comparison of the two offsets in\n      signed size type.  This is possible because pointer arithmetic is"}, {"sha": "7b2dbcdc626312918a9d8652f84b54374a73b065", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e015f578884bce00d4fe8d7b8d14b94b11879ba3", "patch": "@@ -1,3 +1,9 @@\n+2006-12-31  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/30137\n+\t* testsuite/gcc.dg/pr30137-1.c: New testcase.\n+\t* testsuite/gcc.dg/pr30137-2.c: Likewise.\n+\n 2006-12-31  Roger Sayle  <roger@eyesopen.com>\n \n \tPR middle-end/30322"}, {"sha": "cf1b4063496e495ba21876eed6e191fdd3b94d1c", "filename": "gcc/testsuite/gcc.dg/pr30137-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30137-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30137-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30137-1.c?ref=e015f578884bce00d4fe8d7b8d14b94b11879ba3", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-w -fdump-tree-gimple\" } */\n+\n+/* Things that should not be folded.  */\n+\n+struct { long base; int tail; void * volatile ptr; } *s;\n+int foo3 (void) { return s == &s; }\n+int foo5 (void) { return s->ptr == s->ptr; }\n+\n+struct { union { int i; short s } u; } x;\n+int foo6 (void) { return x.u.i == x.u.s; }\n+\n+void **p;\n+int foo8 (void) { return p == &p; }\n+int foo9 (void) { return *p == p; }\n+int foo10 (void) { return *p == &p; }\n+int foo11 (void) { return p != &p; }\n+int foo12 (void) { return *p != p; }\n+int foo13 (void) { return *p != &p; }\n+\n+/* { dg-final { scan-tree-dump-not \"= 0;\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-not \"= 1;\" \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "53be1633b7be228810b1fde87d5a07925865c54d", "filename": "gcc/testsuite/gcc.dg/pr30137-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30137-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e015f578884bce00d4fe8d7b8d14b94b11879ba3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30137-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30137-2.c?ref=e015f578884bce00d4fe8d7b8d14b94b11879ba3", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-w -fdump-tree-gimple\" } */\n+\n+/* Things that should be folded.  */\n+\n+struct { long base; int tail; void * volatile ptr; } *s;\n+int foo1a (void) { return (s == &s->base); }\n+int foo1b (void) { return (&s->base == s); }\n+int foo2 (void) { return ((void *)s == (void *) &s->base); }\n+int foo4 (void) { return s->base == s->base; }\n+int foo5 (void) { return &s->ptr == &s->ptr; }\n+int foo6 (void) { return &s->ptr != &s->ptr; }\n+int foo7 (void) { return &s->base != &s->ptr; }\n+\n+struct { union { int i; short s } u; } x;\n+int foo8 (void) { return &x.u.i == &x.u.s; }\n+\n+/* { dg-final { scan-tree-dump-times \"= 0\" 1 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"= 1\" 7 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}]}