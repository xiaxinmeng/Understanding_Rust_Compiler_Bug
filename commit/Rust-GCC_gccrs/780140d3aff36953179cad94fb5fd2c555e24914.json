{"sha": "780140d3aff36953179cad94fb5fd2c555e24914", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgwMTQwZDNhZmYzNjk1MzE3OWNhZDk0ZmI1ZmQyYzU1NWUyNDkxNA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-04T19:33:18Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-04T19:33:18Z"}, "message": "compiler: Correct parse of for with possible composite literal.\n\nFixes, e.g., \"for first := true; first; first = false {\".\n\nFrom-SVN: r187176", "tree": {"sha": "37128e1d927cdd0fe2566f74fb85a6f2e2e7f348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37128e1d927cdd0fe2566f74fb85a6f2e2e7f348"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/780140d3aff36953179cad94fb5fd2c555e24914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780140d3aff36953179cad94fb5fd2c555e24914", "html_url": "https://github.com/Rust-GCC/gccrs/commit/780140d3aff36953179cad94fb5fd2c555e24914", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780140d3aff36953179cad94fb5fd2c555e24914/comments", "author": null, "committer": null, "parents": [{"sha": "ed4639a996cda959bf36c8fab94517a123978101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed4639a996cda959bf36c8fab94517a123978101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed4639a996cda959bf36c8fab94517a123978101"}], "stats": {"total": 72, "additions": 48, "deletions": 24}, "files": [{"sha": "fc2c229487cb1e1c9bb42beb9b880f6faa802cb1", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780140d3aff36953179cad94fb5fd2c555e24914/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780140d3aff36953179cad94fb5fd2c555e24914/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=780140d3aff36953179cad94fb5fd2c555e24914", "patch": "@@ -126,18 +126,22 @@ Parse::identifier_list(Typed_identifier_list* til)\n \n // ExpressionList = Expression { \",\" Expression } .\n \n+// If MAY_BE_COMPOSITE_LIT is true, an expression may be a composite\n+// literal.\n+\n // If MAY_BE_SINK is true, the expressions in the list may be \"_\".\n \n Expression_list*\n-Parse::expression_list(Expression* first, bool may_be_sink)\n+Parse::expression_list(Expression* first, bool may_be_sink,\n+\t\t       bool may_be_composite_lit)\n {\n   Expression_list* ret = new Expression_list();\n   if (first != NULL)\n     ret->push_back(first);\n   while (true)\n     {\n-      ret->push_back(this->expression(PRECEDENCE_NORMAL, may_be_sink, true,\n-\t\t\t\t      NULL));\n+      ret->push_back(this->expression(PRECEDENCE_NORMAL, may_be_sink,\n+\t\t\t\t      may_be_composite_lit, NULL));\n \n       const Token* token = this->peek_token();\n       if (!token->is_op(OPERATOR_COMMA))\n@@ -1425,7 +1429,7 @@ Parse::const_spec(Type** last_type, Expression_list** last_expr_list)\n   else\n     {\n       this->advance_token();\n-      expr_list = this->expression_list(NULL, false);\n+      expr_list = this->expression_list(NULL, false, true);\n       *last_type = type;\n       if (*last_expr_list != NULL)\n \tdelete *last_expr_list;\n@@ -1575,13 +1579,13 @@ Parse::var_spec(void*)\n       if (this->peek_token()->is_op(OPERATOR_EQ))\n \t{\n \t  this->advance_token();\n-\t  init = this->expression_list(NULL, false);\n+\t  init = this->expression_list(NULL, false, true);\n \t}\n     }\n   else\n     {\n       this->advance_token();\n-      init = this->expression_list(NULL, false);\n+      init = this->expression_list(NULL, false, true);\n     }\n \n   this->init_vars(&til, type, init, false, location);\n@@ -1988,6 +1992,9 @@ Parse::create_dummy_global(Type* type, Expression* init,\n // In order to support both \"a, b := 1, 0\" and \"a, b = 1, 0\" we accept\n // tuple assignments here as well.\n \n+// If MAY_BE_COMPOSITE_LIT is true, the expression on the right hand\n+// side may be a composite literal.\n+\n // If P_RANGE_CLAUSE is not NULL, then this will recognize a\n // RangeClause.\n \n@@ -1997,6 +2004,7 @@ Parse::create_dummy_global(Type* type, Expression* init,\n void\n Parse::simple_var_decl_or_assignment(const std::string& name,\n \t\t\t\t     Location location,\n+\t\t\t\t     bool may_be_composite_lit,\n \t\t\t\t     Range_clause* p_range_clause,\n \t\t\t\t     Type_switch* p_type_switch)\n {\n@@ -2053,14 +2061,15 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n \t    exprs->push_back(this->id_to_expression(p->name(),\n \t\t\t\t\t\t    p->location()));\n \n-\t  Expression_list* more_exprs = this->expression_list(NULL, true);\n+\t  Expression_list* more_exprs =\n+\t    this->expression_list(NULL, true, may_be_composite_lit);\n \t  for (Expression_list::const_iterator p = more_exprs->begin();\n \t       p != more_exprs->end();\n \t       ++p)\n \t    exprs->push_back(*p);\n \t  delete more_exprs;\n \n-\t  this->tuple_assignment(exprs, p_range_clause);\n+\t  this->tuple_assignment(exprs, may_be_composite_lit, p_range_clause);\n \t  return;\n \t}\n     }\n@@ -2076,11 +2085,12 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n \n   Expression_list* init;\n   if (p_type_switch == NULL)\n-    init = this->expression_list(NULL, false);\n+    init = this->expression_list(NULL, false, may_be_composite_lit);\n   else\n     {\n       bool is_type_switch = false;\n-      Expression* expr = this->expression(PRECEDENCE_NORMAL, false, true,\n+      Expression* expr = this->expression(PRECEDENCE_NORMAL, false,\n+\t\t\t\t\t  may_be_composite_lit,\n \t\t\t\t\t  &is_type_switch);\n       if (is_type_switch)\n \t{\n@@ -2099,7 +2109,7 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n       else\n \t{\n \t  this->advance_token();\n-\t  init = this->expression_list(expr, false);\n+\t  init = this->expression_list(expr, false, may_be_composite_lit);\n \t}\n     }\n \n@@ -3065,7 +3075,7 @@ Parse::call(Expression* func)\n   const Token* token = this->advance_token();\n   if (!token->is_op(OPERATOR_RPAREN))\n     {\n-      args = this->expression_list(NULL, false);\n+      args = this->expression_list(NULL, false, true);\n       token = this->peek_token();\n       if (token->is_op(OPERATOR_ELLIPSIS))\n \t{\n@@ -3578,6 +3588,7 @@ Parse::simple_stat(bool may_be_composite_lit, bool* return_exp,\n \t{\n \t  identifier = this->gogo_->pack_hidden_name(identifier, is_exported);\n \t  this->simple_var_decl_or_assignment(identifier, location,\n+\t\t\t\t\t      may_be_composite_lit,\n \t\t\t\t\t      p_range_clause,\n \t\t\t\t\t      (token->is_op(OPERATOR_COLONEQ)\n \t\t\t\t\t       ? p_type_switch\n@@ -3613,7 +3624,7 @@ Parse::simple_stat(bool may_be_composite_lit, bool* return_exp,\n     this->inc_dec_stat(this->verify_not_sink(exp));\n   else if (token->is_op(OPERATOR_COMMA)\n \t   || token->is_op(OPERATOR_EQ))\n-    this->assignment(exp, p_range_clause);\n+    this->assignment(exp, may_be_composite_lit, p_range_clause);\n   else if (token->is_op(OPERATOR_PLUSEQ)\n \t   || token->is_op(OPERATOR_MINUSEQ)\n \t   || token->is_op(OPERATOR_OREQ)\n@@ -3625,7 +3636,8 @@ Parse::simple_stat(bool may_be_composite_lit, bool* return_exp,\n \t   || token->is_op(OPERATOR_RSHIFTEQ)\n \t   || token->is_op(OPERATOR_ANDEQ)\n \t   || token->is_op(OPERATOR_BITCLEAREQ))\n-    this->assignment(this->verify_not_sink(exp), p_range_clause);\n+    this->assignment(this->verify_not_sink(exp), may_be_composite_lit,\n+\t\t     p_range_clause);\n   else if (return_exp != NULL)\n     return this->verify_not_sink(exp);\n   else\n@@ -3731,11 +3743,15 @@ Parse::inc_dec_stat(Expression* exp)\n \n // EXP is an expression that we have already parsed.\n \n+// If MAY_BE_COMPOSITE_LIT is true, an expression on the right hand\n+// side may be a composite literal.\n+\n // If RANGE_CLAUSE is not NULL, then this will recognize a\n // RangeClause.\n \n void\n-Parse::assignment(Expression* expr, Range_clause* p_range_clause)\n+Parse::assignment(Expression* expr, bool may_be_composite_lit,\n+\t\t  Range_clause* p_range_clause)\n {\n   Expression_list* vars;\n   if (!this->peek_token()->is_op(OPERATOR_COMMA))\n@@ -3746,20 +3762,24 @@ Parse::assignment(Expression* expr, Range_clause* p_range_clause)\n   else\n     {\n       this->advance_token();\n-      vars = this->expression_list(expr, true);\n+      vars = this->expression_list(expr, true, may_be_composite_lit);\n     }\n \n-  this->tuple_assignment(vars, p_range_clause);\n+  this->tuple_assignment(vars, may_be_composite_lit, p_range_clause);\n }\n \n // An assignment statement.  LHS is the list of expressions which\n // appear on the left hand side.\n \n+// If MAY_BE_COMPOSITE_LIT is true, an expression on the right hand\n+// side may be a composite literal.\n+\n // If RANGE_CLAUSE is not NULL, then this will recognize a\n // RangeClause.\n \n void\n-Parse::tuple_assignment(Expression_list* lhs, Range_clause* p_range_clause)\n+Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n+\t\t\tRange_clause* p_range_clause)\n {\n   const Token* token = this->peek_token();\n   if (!token->is_op(OPERATOR_EQ)\n@@ -3791,7 +3811,8 @@ Parse::tuple_assignment(Expression_list* lhs, Range_clause* p_range_clause)\n       return;\n     }\n \n-  Expression_list* vals = this->expression_list(NULL, false);\n+  Expression_list* vals = this->expression_list(NULL, false,\n+\t\t\t\t\t\tmay_be_composite_lit);\n \n   // We've parsed everything; check for errors.\n   if (lhs == NULL || vals == NULL)\n@@ -3960,7 +3981,7 @@ Parse::return_stat()\n   this->advance_token();\n   Expression_list* vals = NULL;\n   if (this->expression_may_start_here())\n-    vals = this->expression_list(NULL, false);\n+    vals = this->expression_list(NULL, false, true);\n   this->gogo_->add_statement(Statement::make_return_statement(vals, location));\n \n   if (vals == NULL\n@@ -4321,7 +4342,7 @@ Parse::expr_switch_case(bool* is_default)\n   if (token->is_keyword(KEYWORD_CASE))\n     {\n       this->advance_token();\n-      return this->expression_list(NULL, false);\n+      return this->expression_list(NULL, false, true);\n     }\n   else if (token->is_keyword(KEYWORD_DEFAULT))\n     {"}, {"sha": "3139f7e890810e57c81d59d08619734c7140f4b9", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780140d3aff36953179cad94fb5fd2c555e24914/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780140d3aff36953179cad94fb5fd2c555e24914/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=780140d3aff36953179cad94fb5fd2c555e24914", "patch": "@@ -162,7 +162,8 @@ class Parse\n \n   // Parser nonterminals.\n   void identifier_list(Typed_identifier_list*);\n-  Expression_list* expression_list(Expression*, bool may_be_sink);\n+  Expression_list* expression_list(Expression*, bool may_be_sink,\n+\t\t\t\t   bool may_be_composite_lit);\n   bool qualified_ident(std::string*, Named_object**);\n   Type* type();\n   bool type_may_start_here();\n@@ -207,6 +208,7 @@ class Parse\n \t\t\t bool is_coloneq, bool type_from_init, bool* is_new);\n   Named_object* create_dummy_global(Type*, Expression*, Location);\n   void simple_var_decl_or_assignment(const std::string&, Location,\n+\t\t\t\t     bool may_be_composite_lit,\n \t\t\t\t     Range_clause*, Type_switch*);\n   void function_decl();\n   Typed_identifier* receiver();\n@@ -239,8 +241,9 @@ class Parse\n   void expression_stat(Expression*);\n   void send_stmt(Expression*);\n   void inc_dec_stat(Expression*);\n-  void assignment(Expression*, Range_clause*);\n-  void tuple_assignment(Expression_list*, Range_clause*);\n+  void assignment(Expression*, bool may_be_composite_lit, Range_clause*);\n+  void tuple_assignment(Expression_list*, bool may_be_composite_lit,\n+\t\t\tRange_clause*);\n   void send();\n   void go_or_defer_stat();\n   void return_stat();"}]}