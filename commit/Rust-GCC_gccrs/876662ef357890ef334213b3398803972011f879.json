{"sha": "876662ef357890ef334213b3398803972011f879", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc2NjYyZWYzNTc4OTBlZjMzNDIxM2IzMzk4ODAzOTcyMDExZjg3OQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-09-13T15:28:38Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1992-09-13T15:28:38Z"}, "message": "(several patterns): Make sure # of attribute alternatives match # of constraint alternatives.\n\n(several patterns): Make sure # of attribute alternatives\nmatch # of constraint alternatives.\nReturn assembler output template instead of calling output_asm_insn.\nDon't write to operands[n] for n >= max operand number in the\npattern, use xoperands instead.\n(casesi): Rewrite.  Used to be buggy and slow.\n(and-not patterns): Make them canonical.  Put operands in the right order.\n(negsi2): Don't use @ for just one output template.\n(movstrsi): Change `!= 4' => `< 4' in test for alignment.\n(adddi3): Extend to handle CONST_INT.\n(ior-with-immediate optimizer): New pattern.\n(and-with-immediate optimizer): New pattern.\n(sCC, bCC expanders): Remove constraints.\n(high:DI recognizer): Add return \\\"\\\".\n\nFrom-SVN: r2113", "tree": {"sha": "ca73eae040635bb52f48b6de7b6fe396f371c03f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca73eae040635bb52f48b6de7b6fe396f371c03f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/876662ef357890ef334213b3398803972011f879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876662ef357890ef334213b3398803972011f879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/876662ef357890ef334213b3398803972011f879", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/876662ef357890ef334213b3398803972011f879/comments", "author": null, "committer": null, "parents": [{"sha": "a9ab5e000d251d62b9b48062750a651e64af3360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ab5e000d251d62b9b48062750a651e64af3360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9ab5e000d251d62b9b48062750a651e64af3360"}], "stats": {"total": 259, "additions": 148, "deletions": 111}, "files": [{"sha": "270559182e96811fddbbcbe090ee6a3fe08aa60f", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 148, "deletions": 111, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/876662ef357890ef334213b3398803972011f879/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/876662ef357890ef334213b3398803972011f879/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=876662ef357890ef334213b3398803972011f879", "patch": "@@ -1,7 +1,7 @@\n ;;- Machine description for HP PA-RISC architecture for GNU C compiler\n ;;   Copyright (C) 1992 Free Software Foundation, Inc.\n ;;   Contributed by the Center for Software Science at the University\n-;;   of Utah. \n+;;   of Utah.\n \n ;; This file is part of GNU CC.\n \n@@ -71,8 +71,8 @@\n \n ;; Floating point conditional branch delay slot description.\n (define_delay (eq_attr \"type\" \"fbranch\")\n-  [(eq_attr \"in_branch_delay\" \"true\") \n-   (eq_attr \"in_branch_delay\" \"true\") \n+  [(eq_attr \"in_branch_delay\" \"true\")\n+   (eq_attr \"in_branch_delay\" \"true\")\n    (nil)])\n \n ;; Integer conditional branch delay slot description.\n@@ -133,7 +133,7 @@\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n \n-;; We generate RTL for comparisons and branches by having the cmpxx \n+;; We generate RTL for comparisons and branches by having the cmpxx\n ;; patterns store away the operands.  Then, the scc and bcc patterns\n ;; emit RTL for both the compare and the branch.\n ;;\n@@ -226,7 +226,7 @@\n }\")\n \n (define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ne:CC (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n@@ -243,7 +243,7 @@\n }\")\n \n (define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(lt:CC (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n@@ -260,7 +260,7 @@\n }\")\n \n (define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(gt:CC (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n@@ -277,7 +277,7 @@\n }\")\n \n (define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(le:CC (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n@@ -294,7 +294,7 @@\n }\")\n \n (define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ge:CC (match_dup 1)\n \t       (match_dup 2)))]\n   \"\"\n@@ -311,7 +311,7 @@\n }\")\n \n (define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ltu:CC (match_dup 1)\n \t        (match_dup 2)))]\n   \"\"\n@@ -324,7 +324,7 @@\n }\")\n \n (define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(gtu:CC (match_dup 1)\n \t        (match_dup 2)))]\n   \"\"\n@@ -337,7 +337,7 @@\n }\")\n \n (define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(leu:CC (match_dup 1)\n \t        (match_dup 2)))]\n   \"\"\n@@ -350,7 +350,7 @@\n }\")\n \n (define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(geu:CC (match_dup 1)\n \t        (match_dup 2)))]\n   \"\"\n@@ -379,12 +379,11 @@\n     {\n       if (!(GET_CODE (operands[3]) == EQ || GET_CODE (operands[3]) == NE))\n \tPUT_CODE (operands[3], reverse_relop (GET_CODE (operands[3])));\n-      output_asm_insn (\\\"comiclr,%N3 %2,%1,%0\\;ldi 1,%0\\\", operands);\n-      return \\\"\\\";\n+      return \\\"comiclr,%N3 %2,%1,%0\\;ldi 1,%0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"binary\")\n-   (set_attr \"length\" \"2\")])\n+  [(set_attr \"type\" \"binary,binary\")\n+   (set_attr \"length\" \"2,2\")])\n \n ;; Conditionals\n \n@@ -575,10 +574,9 @@\n       if (!(comp_code == EQ || comp_code == NE))\n \tPUT_CODE (operands[3], reverse_relop (comp_code));\n       if (get_attr_length (insn) == 1)\n-\toutput_asm_insn (\\\"comib,%C3 %2,%1,%0%#\\\", operands);\n+\treturn \\\"comib,%C3 %2,%1,%0%#\\\";\n       else\n-\toutput_asm_insn (\\\"comiclr,%N3 %2,%1,0\\;bl %0,0%#\\\", operands);\n-      return \\\"\\\";\n+\treturn \\\"comiclr,%N3 %2,%1,0\\;bl %0,0%#\\\";\n     }\n }\"\n [(set_attr \"type\" \"cbranch\")\n@@ -609,10 +607,9 @@\n       if (!(comp_code == EQ || comp_code == NE))\n \tPUT_CODE (operands[3], reverse_relop (comp_code));\n       if (get_attr_length (insn) == 1)\n-\toutput_asm_insn (\\\"comib,%N3 %2,%1,%0%#\\\", operands);\n+\treturn \\\"comib,%N3 %2,%1,%0%#\\\";\n       else\n-\toutput_asm_insn (\\\"comiclr,%C3 %2,%1,0%#\\;bl %0,0%#\\\", operands);\n-      return \\\"\\\";\n+\treturn \\\"comiclr,%C3 %2,%1,0%#\\;bl %0,0%#\\\";\n     }\n }\"\n [(set_attr \"type\" \"cbranch\")\n@@ -738,11 +735,15 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"zdepi_operand\" \"n\"))]\n+\t(match_operand:SI 1 \"depi_cint_operand\" \"n\"))]\n   \"\"\n   \"*\n {\n-  return output_zdepi (operands);\n+  rtx xoperands[4];\n+  xoperands[0] = operands[0];\n+  compute_xdepi_operands_from_integer (INTVAL (operands[1]), xoperands);\n+  output_asm_insn (\\\"zdepi %1,%2,%3,%0\\\", xoperands);\n+  return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n@@ -755,7 +756,7 @@\n   \"@\n    addil L'%G2,%1\n    ldil L'%G2,%0\\;add %0,%1,%0\"\n-  [(set_attr \"type\" \"binary\")\n+  [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"length\" \"1,2\")])\n \n (define_split\n@@ -849,11 +850,15 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(match_operand:HI 1 \"zdepi_operand\" \"n\"))]\n+\t(match_operand:HI 1 \"depi_cint_operand\" \"n\"))]\n   \"\"\n   \"*\n {\n-  return output_zdepi (operands);\n+  rtx xoperands[4];\n+  xoperands[0] = operands[0];\n+  compute_xdepi_operands_from_integer (INTVAL (operands[1]), xoperands);\n+  output_asm_insn (\\\"zdepi %1,%2,%3,%0\\\", xoperands);\n+  return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n@@ -919,11 +924,11 @@\n   \"\"\n   \"\n {\n-  /* If the blocks are not word-aligned and rather big (>16 items),\n+  /* If the blocks are not at least word-aligned and rather big (>16 items),\n      or the size is indeterminate, don't inline the copy code.  A\n      procedure call is better since it can check the alignment at\n      runtime and make the optimal decisions.  */\n-     if (INTVAL (operands[3]) != 4\n+     if (INTVAL (operands[3]) < 4\n \t && (GET_CODE (operands[2]) != CONST_INT\n \t     || (INTVAL (operands[2]) / INTVAL (operands[3]) > 16)))\n        FAIL;\n@@ -949,7 +954,7 @@\n    (use (match_operand:SI 5 \"const_int_operand\" \"n,n\"))] ;alignment\n   \"\"\n   \"* return output_block_move (operands, !which_alternative);\"\n-  [(set_attr \"type\" \"multi\")])\n+  [(set_attr \"type\" \"multi,multi\")])\n \f\n ;; Floating point move insns\n \n@@ -1029,6 +1034,7 @@\n \toutput_asm_insn (\\\"ldo -1(0),%0\\\", operands);\n       else\n \toutput_asm_insn (\\\"ldo 0(0),%0\\\", operands);\n+      return \\\"\\\";\n     }\n   else if (GET_CODE (op1) == CONST_DOUBLE)\n     {\n@@ -1039,6 +1045,7 @@\n       operands[0] = operand_subword (op0, 0, 0, DImode);\n       operands[1] = gen_rtx (CONST_INT, VOIDmode, CONST_DOUBLE_HIGH (op1));\n       output_asm_insn (singlemove_string (operands), operands);\n+      return \\\"\\\";\n     }\n   else\n     abort ();\n@@ -1169,7 +1176,7 @@\n    extru %1,31,8,%0\n    ldb%M1 %1,%0\"\n   [(set_attr \"type\" \"unary,load\")\n-   (set_attr \"length\" \"1\")])\n+   (set_attr \"length\" \"1,1\")])\n \n (define_expand \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -1201,7 +1208,7 @@\n    extru %1,31,8,%0\n    ldb%M1 %1,%0\"\n   [(set_attr \"type\" \"unary,load\")\n-   (set_attr \"length\" \"1\")])\n+   (set_attr \"length\" \"1,1\")])\n \f\n ;;- sign extension instructions\n ;; Note that the one starting from HImode comes before those for QImode\n@@ -1323,11 +1330,21 @@\n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"register_operand\" \"r\")))]\n+\t\t (match_operand:DI 2 \"arith11_operand\" \"rI\")))]\n   \"\"\n-  \"add %R1,%R2,%R0\\;addc %1,%2,%0\"\n-  [(set_attr \"type\" \"binary\")\n-   (set_attr \"length\" \"2\")])\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[2]) >= 0)\n+\treturn \\\"addi %R2,%R1,%R0\\;addc %1,0,%0\\\";\n+      else\n+\treturn \\\"addi %R2,%R1,%R0\\;subb %1,0,%0\\\";\n+    }\n+  else\n+    return \\\"add %R2,%R1,%R0\\;addc %2,%1,%0\\\";\n+}\"\n+  [(set_attr \"length\" \"2\")])\n \n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -1497,7 +1514,7 @@\n   emit_move_insn (operands[0], gen_rtx (REG, SImode, 29));\n   DONE;\n }\")\n- \n+\n (define_insn \"\"\n   [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n    (clobber (match_scratch:SI 0 \"=a\"))\n@@ -1575,27 +1592,26 @@\n   [(set_attr \"length\" \"2\")])\n \n (define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r,0\")\n+\t\t(match_operand:SI 2 \"and_operand\" \"rO,P\")))]\n   \"\"\n-  \"and %1,%2,%0\")\n+  \"* output_and (operands); \")\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(and:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t(not:DI (match_operand:DI 2 \"register_operand\" \"r\"))))]\n+\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n   \"\"\n   \"andcm %2,%1,%0\\;andcm %R2,%R1,%R0\"\n   [(set_attr \"length\" \"2\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t(not:SI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"andcm %1,%2,%0\")\n-\n+  \"andcm %2,%1,%0\")\n \n (define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -1619,11 +1635,11 @@\n   [(set_attr \"length\" \"2\")])\n \n (define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r,0\")\n+\t\t(match_operand:SI 2 \"ior_operand\" \"r,n\")))]\n   \"\"\n-  \"or %1,%2,%0\")\n+  \"* output_ior (operands); \")\n \n (define_expand \"xordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -1665,8 +1681,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"@\n-   sub 0,%1,%0\"\n+  \"sub 0,%1,%0\"\n   [(set_attr \"type\" \"unary\")])\n \n (define_expand \"one_cmpldi2\"\n@@ -1681,7 +1696,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(not:DI (match_operand:DI 1 \"arith_double_operand\" \"r\")))]\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n   \"\"\n   \"uaddcm 0,%1,%0\\;uaddcm 0,%R1,%R0\"\n   [(set_attr \"type\" \"unary\")\n@@ -1879,11 +1894,15 @@\n  \"\"\n  \"*\n {\n-  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n-                         32 - (INTVAL (operands[2]) & 31));\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-                         31 - (INTVAL (operands[2]) & 31));\n-  return \\\"zdep %1,%2,%3,%0\\\";\n+  rtx xoperands[4];\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[1];\n+  xoperands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  31 - (INTVAL (operands[2]) & 31));\n+  xoperands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  32 - (INTVAL (operands[2]) & 31));\n+  output_asm_insn (\\\"zdep %1,%2,%3,%0\\\", xoperands);\n+  return \\\"\\\";\n }\")\n \n (define_insn \"\"\n@@ -1926,11 +1945,15 @@\n  \"\"\n  \"*\n {\n-  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n-                         32 - (INTVAL (operands[2]) & 31));\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-                         31 - (INTVAL (operands[2]) & 31));\n-  return \\\"extrs %1,%2,%3,%0\\\";\n+  rtx xoperands[4];\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[1];\n+  xoperands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  31 - (INTVAL (operands[2]) & 31));\n+  xoperands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  32 - (INTVAL (operands[2]) & 31));\n+  output_asm_insn (\\\"extrs %1,%2,%3,%0\\\", xoperands);\n+  return \\\"\\\";\n }\")\n \n (define_insn \"\"\n@@ -1973,11 +1996,15 @@\n  \"\"\n  \"*\n {\n-  operands[3] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t 32 - (INTVAL (operands[2]) & 31));\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t 31 - (INTVAL (operands[2]) & 31));\n-  return \\\"extru %1,%2,%3,%0\\\";\n+  rtx xoperands[4];\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[1];\n+  xoperands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  31 - (INTVAL (operands[2]) & 31));\n+  xoperands[3] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t  32 - (INTVAL (operands[2]) & 31));\n+  output_asm_insn (\\\"extru %1,%2,%3,%0\\\", xoperands);\n+  return \\\"\\\";\n }\")\n \n (define_insn \"\"\n@@ -1996,59 +2023,69 @@\n   \"bl%* %l0,0\"\n   [(set_attr \"type\" \"branch\")])\n \n-(define_insn \"casesi\"\n+;; Subroutines of \"casesi\".\n+;; operand 0 is index\n+;; operand 1 is the minimum bound\n+;; operand 2 is the maximum bound - minimum bound + 1\n+;; operand 3 is CODE_LABEL for the table;\n+;; operand 4 is the CODE_LABEL to go to if index out of range.\n+\n+(define_expand \"casesi\"\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"const_int_operand\" \"\")\n+   (match_operand:SI 2 \"const_int_operand\" \"\")\n+   (match_operand 3 \"\" \"\")\n+   (match_operand 4 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) != REG)\n+    operands[0] = force_reg (SImode, operands[0]);\n+\n+  if (operands[1] != const0_rtx)\n+    {\n+      rtx reg = gen_reg_rtx (SImode);\n+\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, -INTVAL (operands[1]));\n+      if (!INT_14_BITS (operands[1]))\n+\toperands[1] = force_reg (SImode, operands[1]);\n+      emit_insn (gen_addsi3 (reg, operands[0], operands[1]));\n+\n+      operands[0] = reg;\n+    }\n+\n+  if (!INT_11_BITS (operands[2]))\n+    operands[2] = force_reg (SImode, operands[2]);\n+\n+  emit_insn (gen_casesi0 (operands[0], operands[2],\n+\t\t\t  operands[3], operands[4]));\n+  DONE;\n+}\")\n+\n+(define_insn \"casesi0\"\n   [(set (pc)\n-\t(if_then_else (leu (minus:SI\n-\t\t\t    (match_operand:SI 0 \"general_operand\" \"r\")\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"rI\"))\n-\t\t\t   (match_operand:SI 2 \"general_operand\" \"rI\"))\n-\t\t      (plus:SI (mem:SI (plus:SI (pc)\n-\t\t\t\t\t\t(minus:SI (match_dup 0)\n-\t\t\t\t\t\t\t  (match_dup 1))))\n-\t\t\t       (label_ref (match_operand 3 \"\" \"\")))\n+\t(if_then_else (leu (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 1 \"arith11_operand\" \"rI\"))\n+\t\t      (plus:SI (mem:SI (plus:SI (pc) (match_dup 0)))\n+\t\t\t       (label_ref (match_operand 2 \"\" \"\")))\n \t\t      (pc)))\n-   (use (label_ref (match_operand 4 \"\" \"\")))\n-   (clobber (match_scratch:SI 5 \"=&r\"))]\n+   (use (label_ref (match_operand 3 \"\" \"\")))]\n   \"\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t INTVAL (operands[1]) + INTVAL (operands[2]));\n-\t  if (!INT_11_BITS (operands[2]))\n-\t    {\n-\t      output_asm_insn (\\\"ldo %2(0),%5\\\", operands);\n-\t      operands[2] = operands[5];\n-\t    }\n-\t}\n-      else\n-\toutput_asm_insn (\\\"ldo %1(%2),%2\\\", operands);\n-      output_asm_insn (\\\"addi,< %n1,%0,0\\\", operands);\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, ~INTVAL (operands[1]));\n+      return \\\"addi,uv %1,%0,0\\;blr,n %0,0\\;b,n %l3\\\";\n     }\n   else\n     {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  output_asm_insn (\\\"ldo %2(%1),%5\\\", operands);\n-\t  operands[2] = operands[5];\n-\t}\n-      output_asm_insn (\\\"sub,< %0,%1,0\\\", operands);\n+      return \\\"sub,>> %0,%1,0\\;blr,n %0,0\\;b,n %l3\\\";\n     }\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    output_asm_insn (\\\"addi,<= %n2,%0,0\\\", operands);\n-  else\n-    output_asm_insn (\\\"sub,<= %0,%2,0\\\", operands);\n-  output_asm_insn (\\\"b,n %l4\\\", operands);\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    output_asm_insn (\\\"ldo %n1(%0),%5\\\", operands);\n-  else output_asm_insn (\\\"sub %0,%1,%5\\\", operands);\n-  return \\\"blr %5,0\\;nop\\\";\n }\"\n-[(set_attr \"length\" \"7\")])\n-  \n+ [(set_attr \"length\" \"3\")])\n+\n+\n ;; Need nops for the calls because execution is supposed to continue\n ;; past; we don't want to nullify an instruction that we need.\n ;;- jump to subroutine"}]}