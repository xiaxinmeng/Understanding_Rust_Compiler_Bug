{"sha": "b963aad8ed40cbb3742ef333617e6c727353f64e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk2M2FhZDhlZDQwY2JiMzc0MmVmMzMzNjE3ZTZjNzI3MzUzZjY0ZQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-04-12T19:15:59Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-04-12T19:15:59Z"}, "message": "std_bitset.h: Doxygenate std::bitset<>.\n\n2002-04-12  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* include/std/std_bitset.h:  Doxygenate std::bitset<>.  Clean up\n\ttrailing spaces, indentation, and macro names.  Make exception\n\tmessages more informative.\n\nFrom-SVN: r52233", "tree": {"sha": "81a5b874e692f75dd3c3b15d3e5a51038951d3ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81a5b874e692f75dd3c3b15d3e5a51038951d3ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b963aad8ed40cbb3742ef333617e6c727353f64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b963aad8ed40cbb3742ef333617e6c727353f64e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b963aad8ed40cbb3742ef333617e6c727353f64e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b963aad8ed40cbb3742ef333617e6c727353f64e/comments", "author": null, "committer": null, "parents": [{"sha": "0339d2395be26ee053e1b4b4a277510cf5ea7d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0339d2395be26ee053e1b4b4a277510cf5ea7d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0339d2395be26ee053e1b4b4a277510cf5ea7d83"}], "stats": {"total": 764, "additions": 497, "deletions": 267}, "files": [{"sha": "b552f4f68220b3fd63b104ac0db5206b4a500395", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b963aad8ed40cbb3742ef333617e6c727353f64e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b963aad8ed40cbb3742ef333617e6c727353f64e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b963aad8ed40cbb3742ef333617e6c727353f64e", "patch": "@@ -1,3 +1,9 @@\n+2002-04-12  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* include/std/std_bitset.h:  Doxygenate std::bitset<>.  Clean up\n+\ttrailing spaces, indentation, and macro names.  Make exception\n+\tmessages more informative.\n+\n 2002-04-11  Richard Henderson  <rth@redhat.com>\n \n \t* include/bits/fstream.tcc (basic_filebuf<>::open): Fix & ordering."}, {"sha": "bda3899f481cd03ef7cc4075ba00a890c8880a31", "filename": "libstdc++-v3/include/std/std_bitset.h", "status": "modified", "additions": 491, "deletions": 267, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b963aad8ed40cbb3742ef333617e6c727353f64e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b963aad8ed40cbb3742ef333617e6c727353f64e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h?ref=b963aad8ed40cbb3742ef333617e6c727353f64e", "patch": "@@ -38,257 +38,255 @@\n  * in supporting documentation.  Silicon Graphics makes no\n  * representations about the suitability of this software for any\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n- */ \n+ */\n \n /** @file bitset\n  *  This is a Standard C++ Library header.  You should @c #include this header\n  *  in your programs, rather than any of the \"st[dl]_*.h\" implementation files.\n  */\n \n-#ifndef __GLIBCPP_BITSET\n-#define __GLIBCPP_BITSET\n+#ifndef _GLIBCPP_BITSET_H\n+#define _GLIBCPP_BITSET_H\n \n #pragma GCC system_header\n \n-// A bitset of size N has N % (sizeof(unsigned long) * CHAR_BIT) unused \n-// bits.  (They are the high- order bits in the highest word.)  It is\n-// a class invariant of class bitset<> that those unused bits are\n-// always zero.\n-\n-// Most of the actual code isn't contained in bitset<> itself, but in the \n-// base class _Base_bitset.  The base class works with whole words, not with\n-// individual bits.  This allows us to specialize _Base_bitset for the\n-// important special case where the bitset is only a single word.\n-\n #include <cstddef>     // for size_t\n #include <cstring>     // for memset\n #include <string>\n-#include <bits/functexcept.h>   // for invalid_argument, out_of_range, \n-\t\t\t         // overflow_error\n+#include <bits/functexcept.h>   // for invalid_argument, out_of_range,\n+                                // overflow_error\n #include <ostream>     // for ostream (operator<<)\n #include <istream>     // for istream (operator>>)\n \n+\n #define _GLIBCPP_BITSET_BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))\n-#define __BITSET_WORDS(__n) \\\n+#define _GLIBCPP_BITSET_WORDS(__n) \\\n  ((__n) < 1 ? 1 : ((__n) + _GLIBCPP_BITSET_BITS_PER_WORD - 1)/_GLIBCPP_BITSET_BITS_PER_WORD)\n \n namespace std\n {\n   extern unsigned char \t_S_bit_count[256];\n   extern unsigned char \t_S_first_one[256];\n \n-  // Base class: general case.\n+  /**\n+   *  @if maint\n+   *  Base class, general case.  It is a class inveriant that _Nw will be\n+   *  nonnegative.\n+   *\n+   *  See documentation for bitset.\n+   *  @endif\n+  */\n   template<size_t _Nw>\n-    struct _Base_bitset \n+    struct _Base_bitset\n     {\n       typedef unsigned long _WordT;\n \n-      // 0 is the least significant word.\n-      _WordT \t\t_M_w[_Nw];                \n-      \n+      /// 0 is the least significant word.\n+      _WordT \t\t_M_w[_Nw];\n+\n       _Base_bitset() { _M_do_reset(); }\n-      _Base_bitset(unsigned long __val) \n+      _Base_bitset(unsigned long __val)\n       {\n \t_M_do_reset();\n \t_M_w[0] = __val;\n       }\n \n-      static size_t \n+      static size_t\n       _S_whichword(size_t __pos )\n       { return __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }\n \n-      static size_t \n+      static size_t\n       _S_whichbyte(size_t __pos )\n       { return (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }\n \n-      static size_t \n+      static size_t\n       _S_whichbit(size_t __pos )\n       { return __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }\n \n-      static _WordT \n+      static _WordT\n       _S_maskbit(size_t __pos )\n       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n-      _WordT& \n-      _M_getword(size_t __pos)       \n+      _WordT&\n+      _M_getword(size_t __pos)\n       { return _M_w[_S_whichword(__pos)]; }\n \n-      _WordT  \n-      _M_getword(size_t __pos) const \n+      _WordT\n+      _M_getword(size_t __pos) const\n       { return _M_w[_S_whichword(__pos)]; }\n \n-      _WordT& \n+      _WordT&\n       _M_hiword() { return _M_w[_Nw - 1]; }\n \n-      _WordT  \n+      _WordT\n       _M_hiword() const { return _M_w[_Nw - 1]; }\n \n-      void \n-      _M_do_and(const _Base_bitset<_Nw>& __x) \n+      void\n+      _M_do_and(const _Base_bitset<_Nw>& __x)\n       {\n-\tfor (size_t __i = 0; __i < _Nw; __i++) \n+\tfor (size_t __i = 0; __i < _Nw; __i++)\n \t  _M_w[__i] &= __x._M_w[__i];\n       }\n \n-      void \n-      _M_do_or(const _Base_bitset<_Nw>& __x) \n+      void\n+      _M_do_or(const _Base_bitset<_Nw>& __x)\n       {\n-\tfor (size_t __i = 0; __i < _Nw; __i++) \n+\tfor (size_t __i = 0; __i < _Nw; __i++)\n \t  _M_w[__i] |= __x._M_w[__i];\n       }\n \n-      void \n-      _M_do_xor(const _Base_bitset<_Nw>& __x) \n+      void\n+      _M_do_xor(const _Base_bitset<_Nw>& __x)\n       {\n \tfor (size_t __i = 0; __i < _Nw; __i++)\n \t  _M_w[__i] ^= __x._M_w[__i];\n       }\n \n-      void \n+      void\n       _M_do_left_shift(size_t __shift);\n \n-      void \n+      void\n       _M_do_right_shift(size_t __shift);\n-      \n-      void \n-      _M_do_flip() \n+\n+      void\n+      _M_do_flip()\n       {\n-\tfor (size_t __i = 0; __i < _Nw; __i++) \n+\tfor (size_t __i = 0; __i < _Nw; __i++)\n \t  _M_w[__i] = ~_M_w[__i];\n       }\n \n-      void \n-      _M_do_set() \n+      void\n+      _M_do_set()\n       {\n \tfor (size_t __i = 0; __i < _Nw; __i++)\n \t  _M_w[__i] = ~static_cast<_WordT>(0);\n       }\n \n-      void \n+      void\n       _M_do_reset() { memset(_M_w, 0, _Nw * sizeof(_WordT)); }\n \n-      bool \n-      _M_is_equal(const _Base_bitset<_Nw>& __x) const \n+      bool\n+      _M_is_equal(const _Base_bitset<_Nw>& __x) const\n       {\n-\tfor (size_t __i = 0; __i < _Nw; ++__i) \n+\tfor (size_t __i = 0; __i < _Nw; ++__i)\n \t  {\n \t    if (_M_w[__i] != __x._M_w[__i])\n \t      return false;\n \t  }\n \treturn true;\n       }\n \n-      bool \n-      _M_is_any() const \n+      bool\n+      _M_is_any() const\n       {\n-\tfor (size_t __i = 0; __i < _Nw; __i++) \n+\tfor (size_t __i = 0; __i < _Nw; __i++)\n \t  {\n \t    if (_M_w[__i] != static_cast<_WordT>(0))\n \t      return true;\n \t  }\n \treturn false;\n       }\n \n-      size_t \n-      _M_do_count() const \n+      size_t\n+      _M_do_count() const\n       {\n \tsize_t __result = 0;\n \tconst unsigned char* __byte_ptr = (const unsigned char*)_M_w;\n \tconst unsigned char* __end_ptr = (const unsigned char*)(_M_w + _Nw);\n-\t\n-\twhile ( __byte_ptr < __end_ptr ) \n+\n+\twhile ( __byte_ptr < __end_ptr )\n \t  {\n \t    __result += _S_bit_count[*__byte_ptr];\n \t    __byte_ptr++;\n \t  }\n \treturn __result;\n       }\n \n-      unsigned long \n-      _M_do_to_ulong() const; \n+      unsigned long\n+      _M_do_to_ulong() const;\n \n       // find first \"on\" bit\n-      size_t \n+      size_t\n       _M_do_find_first(size_t __not_found) const;\n \n       // find the next \"on\" bit that follows \"prev\"\n-      size_t \n+      size_t\n       _M_do_find_next(size_t __prev, size_t __not_found) const;\n     };\n \n   // Definitions of non-inline functions from _Base_bitset.\n   template<size_t _Nw>\n-    void \n-    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) \n+    void\n+    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift)\n     {\n-      if (__shift != 0) \n+      if (__shift != 0)\n \t{\n \t  const size_t __wshift = __shift / _GLIBCPP_BITSET_BITS_PER_WORD;\n \t  const size_t __offset = __shift % _GLIBCPP_BITSET_BITS_PER_WORD;\n-\t  \n+\n \t  if (__offset == 0)\n \t    for (size_t __n = _Nw - 1; __n >= __wshift; --__n)\n \t      _M_w[__n] = _M_w[__n - __wshift];\n-\t  else \n+\t  else\n \t    {\n \t      const size_t __sub_offset = _GLIBCPP_BITSET_BITS_PER_WORD - __offset;\n \t      for (size_t __n = _Nw - 1; __n > __wshift; --__n)\n-\t\t_M_w[__n] = (_M_w[__n - __wshift] << __offset) | \n+\t\t_M_w[__n] = (_M_w[__n - __wshift] << __offset) |\n \t\t  (_M_w[__n - __wshift - 1] >> __sub_offset);\n \t      _M_w[__wshift] = _M_w[0] << __offset;\n \t    }\n-\t  \n+\n \t  fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));\n \t}\n     }\n-  \n+\n   template<size_t _Nw>\n-    void \n-    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) \n+    void\n+    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift)\n     {\n-      if (__shift != 0) \n+      if (__shift != 0)\n \t{\n \t  const size_t __wshift = __shift / _GLIBCPP_BITSET_BITS_PER_WORD;\n \t  const size_t __offset = __shift % _GLIBCPP_BITSET_BITS_PER_WORD;\n \t  const size_t __limit = _Nw - __wshift - 1;\n-\t  \n+\n \t  if (__offset == 0)\n \t    for (size_t __n = 0; __n <= __limit; ++__n)\n \t      _M_w[__n] = _M_w[__n + __wshift];\n-\t  else \n+\t  else\n \t    {\n \t      const size_t __sub_offset = _GLIBCPP_BITSET_BITS_PER_WORD - __offset;\n \t      for (size_t __n = 0; __n < __limit; ++__n)\n \t\t_M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n \t\t  (_M_w[__n + __wshift + 1] << __sub_offset);\n \t      _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n \t    }\n-\t  \n+\n \t  fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));\n \t}\n     }\n \n   template<size_t _Nw>\n-    unsigned long \n+    unsigned long\n     _Base_bitset<_Nw>::_M_do_to_ulong() const\n     {\n-      for (size_t __i = 1; __i < _Nw; ++__i) \n-\tif (_M_w[__i]) \n-\t  __throw_overflow_error(\"bitset\");\n+      for (size_t __i = 1; __i < _Nw; ++__i)\n+\tif (_M_w[__i])\n+\t  __throw_overflow_error(\"bitset -- too large to fit in unsigned long\");\n       return _M_w[0];\n     }\n \n   template<size_t _Nw>\n-    size_t \n-    _Base_bitset<_Nw>::_M_do_find_first(size_t __not_found) const \n+    size_t\n+    _Base_bitset<_Nw>::_M_do_find_first(size_t __not_found) const\n     {\n-      for (size_t __i = 0; __i < _Nw; __i++ ) \n+      for (size_t __i = 0; __i < _Nw; __i++ )\n \t{\n \t  _WordT __thisword = _M_w[__i];\n-\t  if ( __thisword != static_cast<_WordT>(0) ) \n+\t  if ( __thisword != static_cast<_WordT>(0) )\n \t    {\n \t      // find byte within word\n-\t      for (size_t __j = 0; __j < sizeof(_WordT); __j++ ) \n+\t      for (size_t __j = 0; __j < sizeof(_WordT); __j++ )\n \t\t{\n \t\t  unsigned char __this_byte\n \t\t    = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n@@ -307,22 +305,22 @@ namespace std\n   template<size_t _Nw>\n     size_t\n     _Base_bitset<_Nw>::_M_do_find_next(size_t __prev, size_t __not_found) const\n-    { \n+    {\n       // make bound inclusive\n       ++__prev;\n-      \n+\n       // check out of bounds\n       if ( __prev >= _Nw * _GLIBCPP_BITSET_BITS_PER_WORD )\n \treturn __not_found;\n-      \n+\n       // search first word\n       size_t __i = _S_whichword(__prev);\n       _WordT __thisword = _M_w[__i];\n-      \n+\n       // mask off bits below bound\n       __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n-      \n-      if ( __thisword != static_cast<_WordT>(0) ) \n+\n+      if ( __thisword != static_cast<_WordT>(0) )\n \t{\n \t  // find byte within word\n \t  // get first byte into place\n@@ -334,175 +332,248 @@ namespace std\n \t      if ( __this_byte )\n \t\treturn __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +\n \t\t  _S_first_one[__this_byte];\n-\t      \n+\n \t      __thisword >>= CHAR_BIT;\n \t    }\n \t}\n-      \n+\n       // check subsequent words\n       __i++;\n-      for ( ; __i < _Nw; __i++ ) \n+      for ( ; __i < _Nw; __i++ )\n \t{\n \t  __thisword = _M_w[__i];\n-\t  if ( __thisword != static_cast<_WordT>(0) ) \n+\t  if ( __thisword != static_cast<_WordT>(0) )\n \t    {\n \t      // find byte within word\n-\t      for (size_t __j = 0; __j < sizeof(_WordT); __j++ ) \n+\t      for (size_t __j = 0; __j < sizeof(_WordT); __j++ )\n \t\t{\n \t\t  unsigned char __this_byte\n \t\t    = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n \t\t  if ( __this_byte )\n \t\t    return __i*_GLIBCPP_BITSET_BITS_PER_WORD + __j*CHAR_BIT +\n \t\t      _S_first_one[__this_byte];\n-\t\t  \n+\n \t\t  __thisword >>= CHAR_BIT;\n \t\t}\n \t    }\n \t}\n       // not found, so return an indication of failure.\n       return __not_found;\n     } // end _M_do_find_next\n-  \n \n-  // Base class: specialization for a single word.\n-  template<> \n-    struct _Base_bitset<1> \n+\n+  /**\n+   *  @if maint\n+   *  Base class, specialization for a single word.\n+   *\n+   *  See documentation for bitset.\n+   *  @endif\n+  */\n+  template<>\n+    struct _Base_bitset<1>\n     {\n       typedef unsigned long _WordT;\n       _WordT _M_w;\n \n       _Base_bitset( void ) : _M_w(0) {}\n       _Base_bitset(unsigned long __val) : _M_w(__val) {}\n \n-      static size_t \n+      static size_t\n       _S_whichword(size_t __pos )\n       { return __pos / _GLIBCPP_BITSET_BITS_PER_WORD; }\n \n-      static size_t \n+      static size_t\n       _S_whichbyte(size_t __pos )\n       { return (__pos % _GLIBCPP_BITSET_BITS_PER_WORD) / CHAR_BIT; }\n \n-      static size_t \n+      static size_t\n       _S_whichbit(size_t __pos )\n       {  return __pos % _GLIBCPP_BITSET_BITS_PER_WORD; }\n \n-      static _WordT \n+      static _WordT\n       _S_maskbit(size_t __pos )\n       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n-      _WordT& \n+      _WordT&\n       _M_getword(size_t) { return _M_w; }\n \n-      _WordT  \n+      _WordT\n       _M_getword(size_t) const { return _M_w; }\n \n-      _WordT& \n+      _WordT&\n       _M_hiword() { return _M_w; }\n \n-      _WordT  \n+      _WordT\n       _M_hiword() const { return _M_w; }\n \n-      void \n+      void\n       _M_do_and(const _Base_bitset<1>& __x) { _M_w &= __x._M_w; }\n \n-      void \n+      void\n       _M_do_or(const _Base_bitset<1>& __x)  { _M_w |= __x._M_w; }\n \n-      void \n+      void\n       _M_do_xor(const _Base_bitset<1>& __x) { _M_w ^= __x._M_w; }\n \n-      void \n+      void\n       _M_do_left_shift(size_t __shift) { _M_w <<= __shift; }\n \n-      void \n+      void\n       _M_do_right_shift(size_t __shift) { _M_w >>= __shift; }\n \n-      void \n+      void\n       _M_do_flip() { _M_w = ~_M_w; }\n \n-      void \n+      void\n       _M_do_set() { _M_w = ~static_cast<_WordT>(0); }\n \n-      void \n+      void\n       _M_do_reset() { _M_w = 0; }\n \n-      bool \n+      bool\n       _M_is_equal(const _Base_bitset<1>& __x) const\n       { return _M_w == __x._M_w; }\n \n-      bool \n+      bool\n       _M_is_any() const { return _M_w != 0; }\n \n-      size_t \n-      _M_do_count() const \n+      size_t\n+      _M_do_count() const\n       {\n \tsize_t __result = 0;\n \tconst unsigned char* __byte_ptr = (const unsigned char*)&_M_w;\n \tconst unsigned char* __end_ptr\n \t  = ((const unsigned char*)&_M_w)+sizeof(_M_w);\n-\twhile ( __byte_ptr < __end_ptr ) \n+\twhile ( __byte_ptr < __end_ptr )\n \t  {\n \t    __result += _S_bit_count[*__byte_ptr];\n \t    __byte_ptr++;\n \t  }\n \treturn __result;\n       }\n \n-      unsigned long \n+      unsigned long\n       _M_do_to_ulong() const { return _M_w; }\n \n-      size_t \n+      size_t\n       _M_do_find_first(size_t __not_found) const;\n \n       // find the next \"on\" bit that follows \"prev\"\n       size_t\n-      _M_do_find_next(size_t __prev, size_t __not_found) const; \n+      _M_do_find_next(size_t __prev, size_t __not_found) const;\n     };\n \n   // Helper class to zero out the unused high-order bits in the highest word.\n-  template<size_t _Extrabits> \n-    struct _Sanitize \n+  template<size_t _Extrabits>\n+    struct _Sanitize\n     {\n       static void _S_do_sanitize(unsigned long& __val)\n       { __val &= ~((~static_cast<unsigned long>(0)) << _Extrabits); }\n     };\n \n-  template<> \n-    struct _Sanitize<0> \n+  template<>\n+    struct _Sanitize<0>\n     { static void _S_do_sanitize(unsigned long) { } };\n \n-  // Class bitset.\n-  // _Nb may be any nonzero number of type size_t.\n+  /**\n+   *  @brief  The %bitset class represents a @e fixed-size sequence of bits.\n+   *\n+   *  @ingroup Containers\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>.\n+   *\n+   *  The template argument, @a _Nb, may be any nonzero number of type\n+   *  size_t.\n+   *\n+   *  A %bitset of size N has N % (sizeof(unsigned long) * CHAR_BIT) unused\n+   *  bits.  (They are the high-order bits in the highest word.)  It is\n+   *  a class invariant that those unused bits are always zero.\n+   *\n+   *  If you think of %bitset as \"a simple array of bits,\" be aware that\n+   *  your mental picture is reversed:  a %bitset behaves the same way as\n+   *  bits in integers do, with the bit at index 0 in the \"least significant\n+   *  / right-hand\" position, and the bit at index N-1 in the \"most\n+   *  significant / left-hand\" position.  Thus, unlike other containers, a\n+   *  %bitset's index \"counts from right to left,\" to put it very loosely.\n+   *\n+   *  This behavior is preserved when translating to and from strings.  For\n+   *  example, the first line of the following program probably prints\n+   *  \"b('a') is 0001100001\" on a modern ASCII system.\n+   *\n+   *  @code\n+   *     #include <bitset>\n+   *     #include <iostream>\n+   *     #include <sstream>\n+   *\n+   *     using namespace std;\n+   *\n+   *     int main()\n+   *     {\n+   *         long         a = 'a';\n+   *         bitset<10>   b(a);\n+   *\n+   *         cout << \"b('a') is \" << b << endl;\n+   *\n+   *         ostringstream s;\n+   *         s << b;\n+   *         string  str = s.str();\n+   *         cout << \"index 3 in the string is \" << str[3] << \" but\\n\"\n+   *              << \"index 3 in the bitset is \" << b[3] << endl;\n+   *     }\n+   *  @endcode\n+   *\n+   *  Also see http://gcc.gnu.org/onlinedocs/libstdc++/ext/sgiexts.html#ch23\n+   *\n+   *  @if maint\n+   *  Most of the actual code isn't contained in %bitset<> itself, but in the\n+   *  base class _Base_bitset.  The base class works with whole words, not with\n+   *  individual bits.  This allows us to specialize _Base_bitset for the\n+   *  important special case where the %bitset is only a single word.\n+   *\n+   *  Extra confusion can result due to the fact that the storage for\n+   *  _Base_bitset @e is a regular array, and is indexed as such.  This is\n+   *  carefully encapsulated.\n+   *  @endif\n+  */\n   template<size_t _Nb>\n-    class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n+    class bitset : private _Base_bitset<_GLIBCPP_BITSET_WORDS(_Nb)>\n   {\n   private:\n-    typedef _Base_bitset<__BITSET_WORDS(_Nb)> _Base;\n+    typedef _Base_bitset<_GLIBCPP_BITSET_WORDS(_Nb)> _Base;\n     typedef unsigned long _WordT;\n-    \n-    void \n-    _M_do_sanitize() \n+\n+    void\n+    _M_do_sanitize()\n     {\n-    _Sanitize<_Nb%_GLIBCPP_BITSET_BITS_PER_WORD>::_S_do_sanitize(this->_M_hiword());\n+      _Sanitize<_Nb%_GLIBCPP_BITSET_BITS_PER_WORD>::\n+          _S_do_sanitize(this->_M_hiword());\n     }\n \n   public:\n-    // bit reference:\n-    class reference;\n-    friend class reference;\n-    \n-    class reference \n+    /**\n+     *  This encapsulates the concept of a single bit.  An instance of this\n+     *  class is a proxy for an actual bit; this way the individual bit\n+     *  operations are done as faster word-size bitwise instructions.\n+     *\n+     *  Most users will never need to use this class directly; conversions\n+     *  to and from bool are automatic and should be transparent.  Overloaded\n+     *  operators help to preserve the illusion.\n+     *\n+     *  (On a typical system, this \"bit %reference\" is 64 times the size of\n+     *  an actual bit.  Ha.)\n+    */\n+    class reference\n     {\n       friend class bitset;\n-      \n+\n       _WordT *_M_wp;\n       size_t _M_bpos;\n-      \n+\n       // left undefined\n       reference();\n-      \n+\n     public:\n-      reference( bitset& __b, size_t __pos ) \n+      reference(bitset& __b, size_t __pos)\n       {\n \t_M_wp = &__b._M_getword(__pos);\n \t_M_bpos = _Base::_S_whichbit(__pos);\n@@ -511,19 +582,19 @@ namespace std\n       ~reference() { }\n \n       // for b[i] = __x;\n-      reference& \n-      operator=(bool __x) \n+      reference&\n+      operator=(bool __x)\n       {\n \tif ( __x )\n \t  *_M_wp |= _Base::_S_maskbit(_M_bpos);\n \telse\n \t  *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n \treturn *this;\n       }\n-      \n+\n       // for b[i] = b[__j];\n-      reference& \n-      operator=(const reference& __j) \n+      reference&\n+      operator=(const reference& __j)\n       {\n \tif ( (*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)) )\n \t  *_M_wp |= _Base::_S_maskbit(_M_bpos);\n@@ -533,7 +604,7 @@ namespace std\n       }\n \n       // flips the bit\n-      bool \n+      bool\n       operator~() const\n       { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n \n@@ -542,88 +613,131 @@ namespace std\n       { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n \n       // for b[i].flip();\n-      reference& \n-      flip() \n+      reference&\n+      flip()\n       {\n \t*_M_wp ^= _Base::_S_maskbit(_M_bpos);\n \treturn *this;\n       }\n     };\n-    \n+    friend class reference;\n+\n     // 23.3.5.1 constructors:\n+    /// All bits set to zero.\n     bitset() { }\n \n-    bitset(unsigned long __val) : _Base_bitset<__BITSET_WORDS(_Nb)>(__val) \n+    /// Initial bits bitwise-copied from a single word (others set to zero).\n+    bitset(unsigned long __val) : _Base(__val)\n     { _M_do_sanitize(); }\n \n+    /**\n+     *  @brief  Use a subset of a string.\n+     *  @param  s  A string of '0' and '1' characters.\n+     *  @param  pos  Index of the first character in @a s to use; defaults\n+     *               to zero.\n+     *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.\n+     *  @throw  std::invalid_argument  If a character appears in the string\n+     *                                 which is neither '0' nor '1'.\n+    */\n     template<class _CharT, class _Traits, class _Alloc>\n       explicit bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n-\t\t      size_t __pos = 0) : _Base() \n+\t\t      size_t __pos = 0) : _Base()\n       {\n-\tif (__pos > __s.size()) \n-\t  __throw_out_of_range(\"bitset\");\n+\tif (__pos > __s.size())\n+\t  __throw_out_of_range(\"bitset -- initial position is larger than \"\n+\t                       \"the string itself\");\n \t_M_copy_from_string(__s, __pos,\n \t\t\t    basic_string<_CharT, _Traits, _Alloc>::npos);\n       }\n \n+    /**\n+     *  @brief  Use a subset of a string.\n+     *  @param  s  A string of '0' and '1' characters.\n+     *  @param  pos  Index of the first character in @a s to use.\n+     *  @param  n    The number of characters to copy.\n+     *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.\n+     *  @throw  std::invalid_argument  If a character appears in the string\n+     *                                 which is neither '0' nor '1'.\n+    */\n     template<class _CharT, class _Traits, class _Alloc>\n       bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n-\t     size_t __pos, size_t __n) : _Base() \n+\t     size_t __pos, size_t __n) : _Base()\n       {\n-\tif (__pos > __s.size()) \n-\t  __throw_out_of_range(\"bitset\");\n+\tif (__pos > __s.size())\n+\t  __throw_out_of_range(\"bitset -- initial position is larger than \"\n+\t                       \"the string itself\");\n \t_M_copy_from_string(__s, __pos, __n);\n       }\n \n     // 23.3.5.2 bitset operations:\n-    bitset<_Nb>& \n-    operator&=(const bitset<_Nb>& __rhs) \n+    //@{\n+    /**\n+     *  @brief  Operations on bitsets.\n+     *  @param  rhs  A same-sized bitset.\n+     *\n+     *  These should be self-explanatory.\n+    */\n+    bitset<_Nb>&\n+    operator&=(const bitset<_Nb>& __rhs)\n     {\n       this->_M_do_and(__rhs);\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    operator|=(const bitset<_Nb>& __rhs) \n+    bitset<_Nb>&\n+    operator|=(const bitset<_Nb>& __rhs)\n     {\n       this->_M_do_or(__rhs);\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    operator^=(const bitset<_Nb>& __rhs) \n+    bitset<_Nb>&\n+    operator^=(const bitset<_Nb>& __rhs)\n     {\n       this->_M_do_xor(__rhs);\n       return *this;\n     }\n-\n-    bitset<_Nb>& \n-    operator<<=(size_t __pos) \n+    //@}\n+\n+    //@{\n+    /**\n+     *  @brief  Operations on bitsets.\n+     *  @param  pos  The number of places to shift.\n+     *\n+     *  These should be self-explanatory.\n+    */\n+    bitset<_Nb>&\n+    operator<<=(size_t __pos)\n     {\n       this->_M_do_left_shift(__pos);\n       this->_M_do_sanitize();\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    operator>>=(size_t __pos) \n+    bitset<_Nb>&\n+    operator>>=(size_t __pos)\n     {\n       this->_M_do_right_shift(__pos);\n       this->_M_do_sanitize();\n       return *this;\n     }\n-\n-    // Extension:\n-    // Versions of single-bit set, reset, flip, test with no range checking.\n-    bitset<_Nb>& \n-    _Unchecked_set(size_t __pos) \n+    //@}\n+\n+    //@{\n+    /**\n+     *  These versions of single-bit set, reset, flip, and test are\n+     *  extensions from the SGI version.  They do no range checking.\n+     *  @ingroup SGIextensions\n+    */\n+    bitset<_Nb>&\n+    _Unchecked_set(size_t __pos)\n     {\n       this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    _Unchecked_set(size_t __pos, int __val) \n+    bitset<_Nb>&\n+    _Unchecked_set(size_t __pos, int __val)\n     {\n       if (__val)\n \tthis->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n@@ -632,95 +746,157 @@ namespace std\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    _Unchecked_reset(size_t __pos) \n+    bitset<_Nb>&\n+    _Unchecked_reset(size_t __pos)\n     {\n       this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    _Unchecked_flip(size_t __pos) \n+    bitset<_Nb>&\n+    _Unchecked_flip(size_t __pos)\n     {\n       this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n       return *this;\n     }\n \n-    bool \n-    _Unchecked_test(size_t __pos) const \n+    bool\n+    _Unchecked_test(size_t __pos) const\n     {\n-      return (this->_M_getword(__pos) & _Base::_S_maskbit(__pos)) \n+      return (this->_M_getword(__pos) & _Base::_S_maskbit(__pos))\n \t!= static_cast<_WordT>(0);\n     }\n+    //@}\n \n     // Set, reset, and flip.\n-    bitset<_Nb>& \n-    set() \n+    /**\n+     *  @brief Sets every bit to true.\n+    */\n+    bitset<_Nb>&\n+    set()\n     {\n       this->_M_do_set();\n       this->_M_do_sanitize();\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    set(size_t __pos, bool __val = true) \n+    /**\n+     *  @brief Sets a given bit to a particular value.\n+     *  @param  pos  The index of the bit.\n+     *  @param  val  Either true or false, defaults to true.\n+     *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+    */\n+    bitset<_Nb>&\n+    set(size_t __pos, bool __val = true)\n     {\n       if (__pos >= _Nb)\n-\t__throw_out_of_range(\"bitset\");\n+\t__throw_out_of_range(\"bitset -- set() argument too large\");\n       return _Unchecked_set(__pos, __val);\n     }\n \n-    bitset<_Nb>& \n-    reset() \n+    /**\n+     *  @brief Sets every bit to false.\n+    */\n+    bitset<_Nb>&\n+    reset()\n     {\n       this->_M_do_reset();\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    reset(size_t __pos) \n+    /**\n+     *  @brief Sets a given bit to false.\n+     *  @param  pos  The index of the bit.\n+     *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+     *\n+     *  Same as writing @c set(pos,false).\n+    */\n+    bitset<_Nb>&\n+    reset(size_t __pos)\n     {\n       if (__pos >= _Nb)\n-\t__throw_out_of_range(\"bitset\");\n+\t__throw_out_of_range(\"bitset -- reset() argument too large\");\n       return _Unchecked_reset(__pos);\n     }\n \n-    bitset<_Nb>& \n-    flip() \n+    /**\n+     *  @brief Toggles every bit to its opposite value.\n+    */\n+    bitset<_Nb>&\n+    flip()\n     {\n       this->_M_do_flip();\n       this->_M_do_sanitize();\n       return *this;\n     }\n \n-    bitset<_Nb>& \n-    flip(size_t __pos) \n+    /**\n+     *  @brief Toggles a given bit to its opposite value.\n+     *  @param  pos  The index of the bit.\n+     *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+    */\n+    bitset<_Nb>&\n+    flip(size_t __pos)\n     {\n       if (__pos >= _Nb)\n-\t__throw_out_of_range(\"bitset\");\n+\t__throw_out_of_range(\"bitset -- flip() argument too large\");\n       return _Unchecked_flip(__pos);\n     }\n \n-    bitset<_Nb> \n+    /// See the no-argument flip().\n+    bitset<_Nb>\n     operator~() const { return bitset<_Nb>(*this).flip(); }\n \n-    // element access:\n-    //for b[i];\n-    // _GLIBCPP_RESOLVE_LIB_DEFECTS Note that this implementation already\n-    // resolves DR 11 (items 1 and 2), but does not do the range-checking\n-    // required by that DR's resolution.  -pme\n-    reference \n+    //@{\n+    /**\n+     *  @brief  Array-indexing support.\n+     *  @param  pos  Index into the %bitset.\n+     *  @return  A bool for a 'const %bitset'.  For non-const bitsets, an\n+     *           instance of the reference proxy class.\n+     *  @note  These operators do no range checking and throw no exceptions,\n+     *         as required by DR 11 to the standard.\n+     *\n+     *  @if maint\n+     *  _GLIBCPP_RESOLVE_LIB_DEFECTS Note that this implementation already\n+     *  resolves DR 11 (items 1 and 2), but does not do the range-checking\n+     *  required by that DR's resolution.  -pme\n+     *  The DR has since been changed:  range-checking is a precondition\n+     *  (users' responsibility), and these functions must not throw.  -pme\n+     *  @endif\n+    */\n+    reference\n     operator[](size_t __pos) { return reference(*this,__pos); }\n \n-    bool \n+    bool\n     operator[](size_t __pos) const { return _Unchecked_test(__pos); }\n-\n-    unsigned long \n+    //@}\n+\n+    /**\n+     *  @brief Retuns a numerical interpretation of the %bitset.\n+     *  @return  The integral equivalent of the bits.\n+     *  @throw  std::overflow_error  If there are too many bits to be\n+     *                               represented in an @c unsigned @c long.\n+    */\n+    unsigned long\n     to_ulong() const { return this->_M_do_to_ulong(); }\n \n+    /**\n+     *  @brief Retuns a character interpretation of the %bitset.\n+     *  @return  The string equivalent of the bits.\n+     *\n+     *  Note the ordering of the bits:  decreasing character positions\n+     *  correspond to increasing bit positions (see the main class notes for\n+     *  an example).\n+     *\n+     *  Also note that you must specify the string's template parameters\n+     *  explicitly.  Given a bitset @c bs and a string @s:\n+     *  @code\n+     *     s = bs.to_string<char,char_traits<char>,allocator<char> >();\n+     *  @endcode\n+    */\n     template<class _CharT, class _Traits, class _Alloc>\n-      basic_string<_CharT, _Traits, _Alloc> \n-      to_string() const \n+      basic_string<_CharT, _Traits, _Alloc>\n+      to_string() const\n       {\n \tbasic_string<_CharT, _Traits, _Alloc> __result;\n \t_M_copy_to_string(__result);\n@@ -729,166 +905,213 @@ namespace std\n \n     // Helper functions for string operations.\n     template<class _CharT, class _Traits, class _Alloc>\n-      void \n+      void\n       _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n                           size_t, size_t);\n \n     template<class _CharT, class _Traits, class _Alloc>\n-      void \n+      void\n       _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n \n-    size_t \n+    /// Returns the number of bits which are set.\n+    size_t\n     count() const { return this->_M_do_count(); }\n \n-    size_t \n+    /// Returns the total number of bits.\n+    size_t\n     size() const { return _Nb; }\n \n-    bool \n-    operator==(const bitset<_Nb>& __rhs) const \n+    //@{\n+    /// These comparisons for equality/inequality are, well, @e bitwise.\n+    bool\n+    operator==(const bitset<_Nb>& __rhs) const\n     { return this->_M_is_equal(__rhs); }\n \n-    bool \n-    operator!=(const bitset<_Nb>& __rhs) const \n+    bool\n+    operator!=(const bitset<_Nb>& __rhs) const\n     { return !this->_M_is_equal(__rhs); }\n-\n-    bool \n-    test(size_t __pos) const \n+    //@}\n+\n+    /**\n+     *  @brief Tests the value of a bit.\n+     *  @param  pos  The index of a bit.\n+     *  @return  The value at @a pos.\n+     *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+    */\n+    bool\n+    test(size_t __pos) const\n     {\n       if (__pos >= _Nb)\n-\t__throw_out_of_range(\"bitset\");\n+\t__throw_out_of_range(\"bitset -- test() argument too large\");\n       return _Unchecked_test(__pos);\n     }\n \n-    bool \n+    /**\n+     *  @brief Tests whether any of the bits are on.\n+     *  @return  True if at least one bit is set.\n+    */\n+    bool\n     any() const { return this->_M_is_any(); }\n \n-    bool \n+    /**\n+     *  @brief Tests whether any of the bits are on.\n+     *  @return  True if none of the bits are set.\n+    */\n+    bool\n     none() const { return !this->_M_is_any(); }\n \n-    bitset<_Nb> \n+    //@{\n+    /// Self-explanatory.\n+    bitset<_Nb>\n     operator<<(size_t __pos) const\n     { return bitset<_Nb>(*this) <<= __pos; }\n \n-    bitset<_Nb> \n+    bitset<_Nb>\n     operator>>(size_t __pos) const\n     { return bitset<_Nb>(*this) >>= __pos; }\n+    //@}\n \n-    // EXTENSIONS: bit-find operations.  These operations are\n-    // experimental, and are subject to change or removal in future\n-    // versions.\n-\n-    // find the index of the first \"on\" bit\n-    size_t \n-    _Find_first() const \n+    /**\n+     *  @brief  Finds the index of the first \"on\" bit.\n+     *  @ingroup SGIextensions\n+     *  @sa  _Find_next\n+    */\n+    size_t\n+    _Find_first() const\n     { return this->_M_do_find_first(_Nb); }\n \n-    // find the index of the next \"on\" bit after prev\n-    size_t \n-    _Find_next(size_t __prev ) const \n+    /**\n+     *  @brief  Finds the index of the next \"on\" bit after prev.\n+     *  @param  prev  Where to start searching.\n+     *  @ingroup SGIextensions\n+     *  @sa  _Find_first\n+    */\n+    size_t\n+    _Find_next(size_t __prev ) const\n     { return this->_M_do_find_next(__prev, _Nb); }\n   };\n \n   // Definitions of non-inline member functions.\n   template<size_t _Nb>\n     template<class _CharT, class _Traits, class _Alloc>\n-    void \n+    void\n     bitset<_Nb>::_M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s, size_t __pos, size_t __n)\n-    {  \n+    {\n       reset();\n       const size_t __nbits = min(_Nb, min(__n, __s.size() - __pos));\n-      for (size_t __i = 0; __i < __nbits; ++__i) \n+      for (size_t __i = 0; __i < __nbits; ++__i)\n \t{\n-\t  switch(__s[__pos + __nbits - __i - 1]) \n+\t  switch(__s[__pos + __nbits - __i - 1])\n \t    {\n \t    case '0':\n \t      break;\n \t    case '1':\n \t      set(__i);\n \t      break;\n \t    default:\n-\t      __throw_invalid_argument(\"bitset\");\n+\t      __throw_invalid_argument(\"bitset -- string contains characters \"\n+\t                               \"which are neither 0 nor 1\");\n \t    }\n \t}\n     }\n \n   template<size_t _Nb>\n     template<class _CharT, class _Traits, class _Alloc>\n-    void \n+    void\n     bitset<_Nb>::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const\n     {\n       __s.assign(_Nb, '0');\n-      for (size_t __i = 0; __i < _Nb; ++__i) \n+      for (size_t __i = 0; __i < _Nb; ++__i)\n \tif (_Unchecked_test(__i))\n \t  __s[_Nb - 1 - __i] = '1';\n     }\n \n   // 23.3.5.3 bitset operations:\n+  //@{\n+  /**\n+   *  @brief  Global bitwise operations on bitsets.\n+   *  @param  x  A bitset.\n+   *  @param  y  A bitset of the same size as @a x.\n+   *  @return  A new bitset.\n+   *\n+   *  These should be self-explanatory.\n+  */\n   template<size_t _Nb>\n-    inline bitset<_Nb> \n-    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) \n+    inline bitset<_Nb>\n+    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n     {\n       bitset<_Nb> __result(__x);\n       __result &= __y;\n       return __result;\n     }\n \n   template<size_t _Nb>\n-    inline bitset<_Nb> \n-    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) \n+    inline bitset<_Nb>\n+    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n     {\n       bitset<_Nb> __result(__x);\n       __result |= __y;\n       return __result;\n     }\n \n   template <size_t _Nb>\n-    inline bitset<_Nb> \n-    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) \n+    inline bitset<_Nb>\n+    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n     {\n       bitset<_Nb> __result(__x);\n       __result ^= __y;\n       return __result;\n     }\n-\n+  //@}\n+\n+  //@{\n+  /**\n+   *  @brief Global I/O operators for bitsets.\n+   *\n+   *  Direct I/O between streams and bitsets is supported.  Output is\n+   *  straightforward.  Input will skip whitespace, only accept '0' and '1'\n+   *  characters, and will only extract as many digits as the %bitset will\n+   *  hold.\n+  */\n   template<class _CharT, class _Traits, size_t _Nb>\n     basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n     {\n       typedef typename _Traits::char_type char_type;\n       basic_string<_CharT, _Traits> __tmp;\n       __tmp.reserve(_Nb);\n-      \n+\n       // Skip whitespace\n       typename basic_istream<_CharT, _Traits>::sentry __sentry(__is);\n-      if (__sentry) \n+      if (__sentry)\n \t{\n \t  basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();\n-\t  for (size_t __i = 0; __i < _Nb; ++__i) \n+\t  for (size_t __i = 0; __i < _Nb; ++__i)\n \t    {\n \t      static typename _Traits::int_type __eof = _Traits::eof();\n-\t      \n+\n \t      typename _Traits::int_type __c1 = __buf->sbumpc();\n-\t      if (_Traits::eq_int_type(__c1, __eof)) \n+\t      if (_Traits::eq_int_type(__c1, __eof))\n \t\t{\n \t\t  __is.setstate(ios_base::eofbit);\n \t\t  break;\n \t\t}\n-\t      else \n+\t      else\n \t\t{\n \t\t  char_type __c2 = _Traits::to_char_type(__c1);\n \t\t  char_type __c  = __is.narrow(__c2, '*');\n-\t\t  \n+\n \t\t  if (__c == '0' || __c == '1')\n \t\t    __tmp.push_back(__c);\n-\t\t  else if (_Traits::eq_int_type(__buf->sputbackc(__c2), \n-\t\t\t\t\t\t__eof)) \n+\t\t  else if (_Traits::eq_int_type(__buf->sputbackc(__c2),\n+\t\t\t\t\t\t__eof))\n \t\t    {\n \t\t      __is.setstate(ios_base::failbit);\n \t\t      break;\n \t\t    }\n \t\t}\n \t    }\n-\t  \n+\n \t  if (__tmp.empty())\n \t    __is.setstate(ios_base::failbit);\n \t  else\n@@ -906,8 +1129,9 @@ namespace std\n       __x._M_copy_to_string(__tmp);\n       return __os << __tmp;\n     }\n+  //@}\n } // namespace std\n \n-#undef __BITSET_WORDS\n+#undef _GLIBCPP_BITSET_WORDS\n \n-#endif \n+#endif /* _GLIBCPP_BITSET_H */"}]}