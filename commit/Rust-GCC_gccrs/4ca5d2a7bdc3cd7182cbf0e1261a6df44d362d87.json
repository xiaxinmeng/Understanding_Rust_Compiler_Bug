{"sha": "4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNhNWQyYTdiZGMzY2Q3MTgyY2JmMGUxMjYxYTZkZjQ0ZDM2MmQ4Nw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-08T21:47:59Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-08T21:47:59Z"}, "message": "In gcc/objc/: 2010-11-08 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/objc/:\n2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc-act.c (lookup_property): When checking categories, also\n        check the protocols attached to each.\n        (objc_add_property_declaration): Determine the\n        PROPERTY_SETTER_NAME and PROPERTY_GETTER_NAME here.  Tidied up\n        error message.  Search for an existing property declaration with\n        the same name which would be inherited from the class hiearchy,\n        and produce an error if it has incompatible attributes.\n        (check_methods): Changed second parameter.  If the method is a\n        getter or setter for a property, do not warn if it is inherited as\n        opposed to implemented directly in the class.\n        (check_protocol): Updated calls to check_methods.\n        (finish_class): Do not determine the PROPERTY_SETTER_NAME and\n        PROPERTY_GETTER_NAME here; this is now done earlier, in\n        objc_add_property_declaration.\n        * objc-act.h (CLASS_NAME, CLASS_SUPER_NAME): Added comments.\n\nIn gcc/testsuite/:\n2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/property/at-property-5.m: Updated test.       \n        * objc.dg/property/at-property-16.m: New.\n        * objc.dg/property/at-property-17.m: New.\n        * objc.dg/property/at-property-18.m: New.\n        * objc.dg/property/at-property-19.m: New.       \n        * objc.dg/property/dotsyntax-12.m: New\n        * objc.dg/protocol-inheritance-1.m: New.\n        * objc.dg/protocol-inheritance-2.m: New.\n        * obj-c++.dg/property/at-property-5.mm: Updated test.\n        * obj-c++.dg/property/at-property-16.mm: New.\n        * obj-c++.dg/property/at-property-17.mm: New.\n        * obj-c++.dg/property/at-property-18.mm: New.\n        * obj-c++.dg/property/at-property-19.mm: New.   \n        * obj-c++.dg/protocol-inheritance-1.mm: New.\n        * obj-c++.dg/protocol-inheritance-2.mm: New.\n        * obj-c++.dg/property/dotsyntax-12.mm: New.\n\nFrom-SVN: r166455", "tree": {"sha": "72d4b2840a0a7f5a7ea5a6b60455d56effeabd73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72d4b2840a0a7f5a7ea5a6b60455d56effeabd73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e115cec97350099177071bb16b3efcbbacc9445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e115cec97350099177071bb16b3efcbbacc9445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e115cec97350099177071bb16b3efcbbacc9445"}], "stats": {"total": 1572, "additions": 1384, "deletions": 188}, "files": [{"sha": "93c9f3e544a95a4306e30873fbd1fb40ab0ccca6", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -1,3 +1,21 @@\n+2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-act.c (lookup_property): When checking categories, also\n+\tcheck the protocols attached to each.\n+\t(objc_add_property_declaration): Determine the\n+\tPROPERTY_SETTER_NAME and PROPERTY_GETTER_NAME here.  Tidied up\n+\terror message.  Search for an existing property declaration with\n+\tthe same name which would be inherited from the class hiearchy,\n+\tand produce an error if it has incompatible attributes.\n+\t(check_methods): Changed second parameter.  If the method is a\n+\tgetter or setter for a property, do not warn if it is inherited as\n+\topposed to implemented directly in the class.\n+\t(check_protocol): Updated calls to check_methods.\n+\t(finish_class): Do not determine the PROPERTY_SETTER_NAME and\n+\tPROPERTY_GETTER_NAME here; this is now done earlier, in\n+\tobjc_add_property_declaration.\n+\t* objc-act.h (CLASS_NAME, CLASS_SUPER_NAME): Added comments.\n+\t\n 2010-11-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tFixed using the Objective-C 2.0 syntax with self and super."}, {"sha": "db41dcab0aca5e3773fac78fe76d42d1035b864c", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 363, "deletions": 186, "changes": 549, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -829,6 +829,78 @@ objc_set_method_opt (bool optional)\n     }\n }\n \n+/* This routine looks for a given PROPERTY in a list of CLASS, CATEGORY, or\n+   PROTOCOL.  */\n+static tree\n+lookup_property_in_list (tree chain, tree property)\n+{\n+  tree x;\n+  for (x = CLASS_PROPERTY_DECL (chain); x; x = TREE_CHAIN (x))\n+    if (PROPERTY_NAME (x) == property)\n+      return x;\n+  return NULL_TREE;\n+}\n+\n+/* This routine looks for a given PROPERTY in the tree chain of RPROTO_LIST. */\n+static tree lookup_property_in_protocol_list (tree rproto_list, tree property)\n+{\n+  tree rproto, x;\n+  for (rproto = rproto_list; rproto; rproto = TREE_CHAIN (rproto))\n+    {\n+      tree p = TREE_VALUE (rproto);\n+      if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n+\t{\n+\t  if ((x = lookup_property_in_list (p, property)))\n+\t    return x;\n+\t  if (PROTOCOL_LIST (p))\n+\t    return lookup_property_in_protocol_list (PROTOCOL_LIST (p), property);\n+\t}\n+      else\n+\t{\n+\t  ; /* An identifier...if we could not find a protocol.  */\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* This routine looks up the PROPERTY in current INTERFACE, its categories and up the\n+   chain of interface hierarchy.  */\n+static tree\n+lookup_property (tree interface_type, tree property)\n+{\n+  tree inter = interface_type;\n+  while (inter)\n+    {\n+      tree x, category;\n+      if ((x = lookup_property_in_list (inter, property)))\n+\treturn x;\n+      /* Failing that, look for the property in each category of the class.  */\n+      category = inter;\n+      while ((category = CLASS_CATEGORY_LIST (category)))\n+\t{\n+\t  if ((x = lookup_property_in_list (category, property)))\n+\t    return x;\n+\n+\t  /* When checking a category, also check the protocols\n+\t     attached with the category itself.  */\n+\t  if (CLASS_PROTOCOL_LIST (category)\n+\t      && (x = lookup_property_in_protocol_list\n+\t\t  (CLASS_PROTOCOL_LIST (category), property)))\n+\t    return x;\n+\t}\n+\n+      /*  Failing to find in categories, look for property in protocol list. */\n+      if (CLASS_PROTOCOL_LIST (inter) \n+\t  && (x = lookup_property_in_protocol_list\n+\t      (CLASS_PROTOCOL_LIST (inter), property)))\n+\treturn x;\n+      \n+      /* Failing that, climb up the inheritance hierarchy.  */\n+      inter = lookup_interface (CLASS_SUPER_NAME (inter));\n+    }\n+  return inter;\n+}\n+\n /* This routine is called by the parser when a\n    @property... declaration is found.  'decl' is the declaration of\n    the property (type/identifier), and the other arguments represent\n@@ -920,19 +992,6 @@ objc_add_property_declaration (location_t location, tree decl,\n   /* At this point we know that we are either in an interface, a\n      category, or a protocol.  */\n \n-  if (parsed_property_setter_ident)\n-    {\n-      /* The setter should be terminated by ':', but the parser only\n-\t gives us an identifier without ':'.  So, we need to add ':'\n-\t at the end.  */\n-      const char *parsed_setter = IDENTIFIER_POINTER (parsed_property_setter_ident);\n-      size_t length = strlen (parsed_setter);\n-      char *final_setter = (char *)alloca (length + 2);\n-\n-      sprintf (final_setter, \"%s:\", parsed_setter);\n-      parsed_property_setter_ident = get_identifier (final_setter);\n-    }\n-\n   /* Check that the property does not have an initial value specified.\n      This should never happen as the parser doesn't allow this, but\n      it's just in case.  */\n@@ -984,8 +1043,39 @@ objc_add_property_declaration (location_t location, tree decl,\n       && !objc_type_valid_for_messaging (TREE_TYPE (decl), true))\n     error_at (location, \"%<copy%> attribute is only valid for Objective-C objects\");\n \n+  /* Now determine the final property getter and setter names.  They\n+     will be stored in the PROPERTY_DECL, from which they'll always be\n+     extracted and used.  */\n+\n+  /* Adjust, or fill in, setter and getter names.  We overwrite the\n+     parsed_property_setter_ident and parsed_property_getter_ident\n+     with the final setter and getter identifiers that will be\n+     used.  */\n+  if (parsed_property_setter_ident)\n+    {\n+      /* The setter should be terminated by ':', but the parser only\n+\t gives us an identifier without ':'.  So, we need to add ':'\n+\t at the end.  */\n+      const char *parsed_setter = IDENTIFIER_POINTER (parsed_property_setter_ident);\n+      size_t length = strlen (parsed_setter);\n+      char *final_setter = (char *)alloca (length + 2);\n+\n+      sprintf (final_setter, \"%s:\", parsed_setter);\n+      parsed_property_setter_ident = get_identifier (final_setter);\n+    }\n+  else\n+    {\n+      if (!property_readonly)\n+\tparsed_property_setter_ident = get_identifier (objc_build_property_setter_name \n+\t\t\t\t\t\t       (DECL_NAME (decl)));\n+    }\n+\n+  if (!parsed_property_getter_ident)\n+    parsed_property_getter_ident = DECL_NAME (decl);\n+\n   /* Check for duplicate property declarations.  We first check the\n-     immediate context for a property with the same name.  */\n+     immediate context for a property with the same name.  Any such\n+     declarations are an error.  */\n   for (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n     {\n       if (PROPERTY_NAME (x) == DECL_NAME (decl))\n@@ -995,14 +1085,126 @@ objc_add_property_declaration (location_t location, tree decl,\n \t  error_at (location, \"redeclaration of property %qD\", decl);\n \n \t  if (original_location != UNKNOWN_LOCATION)\n-\t    inform (original_location, \"originally declared here\");\n+\t    inform (original_location, \"originally specified here\");\n \t  return;\n       }\n     }\n \n-  /* TODO: Shall we check here for other property declaractions (in\n-     the superclass, other categories or protocols) with the same name\n-     and conflicting types ?  */\n+  /* We now need to check for existing property declarations (in the\n+     superclass, other categories or protocols) and check that the new\n+     declaration is not in conflict with existing ones.  */\n+\n+  /* Search for a previous, existing declaration of a property with\n+     the same name in superclasses, protocols etc.  If one is found,\n+     it will be in the 'x' variable.  */\n+  x = NULL_TREE;\n+\n+  /* Note that, for simplicity, the following may search again the\n+     local context.  That's Ok as nothing will be found (else we'd\n+     have thrown an error above); it's only a little inefficient, but\n+     the code is simpler.  */\n+  switch (TREE_CODE (objc_interface_context))\n+    {\n+    case CLASS_INTERFACE_TYPE:\n+      /* Look up the property in the current @interface (which will\n+\t find nothing), then its protocols and categories and\n+\t superclasses.  */\n+      x = lookup_property (objc_interface_context, DECL_NAME (decl));\n+      break;\n+    case CATEGORY_INTERFACE_TYPE:\n+      /* Look up the property in the main @interface, then protocols\n+\t and categories (one of them is ours, and will find nothing)\n+\t and superclasses.  */\n+      x = lookup_property (lookup_interface (CLASS_NAME (objc_interface_context)),\n+\t\t\t   DECL_NAME (decl));\n+      break;\n+    case PROTOCOL_INTERFACE_TYPE:\n+      /* Looks up the property in any protocols attached to the\n+\t current protocol.  */\n+      if (PROTOCOL_LIST (objc_interface_context))\n+\t{\n+\t  x = lookup_property_in_protocol_list (PROTOCOL_LIST (objc_interface_context),\n+\t\t\t\t\t\tDECL_NAME (decl));\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (x != NULL_TREE)\n+    {\n+      /* An existing property was found; check that it has the same\n+\t types, or it is compatible.  */\n+      location_t original_location = DECL_SOURCE_LOCATION (x);\n+\t  \n+      if (PROPERTY_NONATOMIC (x) != parsed_property_nonatomic)\n+\t{\n+\t  error_at (location, \"'nonatomic' attribute of property %qD conflicts with previous declaration\", decl);\n+      \n+\t  if (original_location != UNKNOWN_LOCATION)\n+\t    inform (original_location, \"originally specified here\");\n+\t  return;\n+\t}\n+\n+      if (PROPERTY_GETTER_NAME (x) != parsed_property_getter_ident)\n+\t{\n+\t  error_at (location, \"'getter' attribute of property %qD conflicts with previous declaration\", decl);\n+      \n+\t  if (original_location != UNKNOWN_LOCATION)\n+\t    inform (original_location, \"originally specified here\");\n+\t  return;\n+\t}\n+\n+      /* We can only compare the setter names if both the old and new property have a setter.  */\n+      if (!property_readonly  &&  !PROPERTY_READONLY(x))\n+\t{\n+\t  if (PROPERTY_SETTER_NAME (x) != parsed_property_setter_ident)\n+\t    {\n+\t      error_at (location, \"'setter' attribute of property %qD conflicts with previous declaration\", decl);\n+\t      \n+\t      if (original_location != UNKNOWN_LOCATION)\n+\t\tinform (original_location, \"originally specified here\");\n+\t      return;\n+\t    }\n+\t}\n+\n+      if (PROPERTY_ASSIGN_SEMANTICS (x) != property_assign_semantics)\n+\t{\n+\t  error_at (location, \"assign semantics attributes of property %qD conflict with previous declaration\", decl);\n+      \n+\t  if (original_location != UNKNOWN_LOCATION)\n+\t    inform (original_location, \"originally specified here\");\n+\t  return;\n+\t}\n+\n+      /* It's ok to have a readonly property that becomes a readwrite, but not vice versa.  */\n+      if (PROPERTY_READONLY (x) == 0  &&  property_readonly == 1)\n+\t{\n+\t  error_at (location, \"'readonly' attribute of property %qD conflicts with previous declaration\", decl);\n+      \n+\t  if (original_location != UNKNOWN_LOCATION)\n+\t    inform (original_location, \"originally specified here\");\n+\t  return;\n+\t}\n+\n+      if (property_readonly)\n+\t{\n+\t  /* If the property is readonly, it is Ok if the property\n+\t     type is a specialization of the previously declared one.\n+\t     Eg, the superclass returns 'NSArray' while the subclass\n+\t     returns 'NSMutableArray'.  */\n+\t  \n+\t  /* TODO: Check that the types are the same, or more specialized.  */\n+\t  ;\n+\t}\n+      else\n+\t{\n+\t  /* Else, the types must match exactly.  */\n+\n+\t  /* TODO: Check that property types are identical.  */\n+\t  ;\n+\t}\n+    }\n \n   /* Create a PROPERTY_DECL node.  */\n   property_decl = make_node (PROPERTY_DECL);\n@@ -1022,74 +1224,18 @@ objc_add_property_declaration (location_t location, tree decl,\n   PROPERTY_IVAR_NAME (property_decl) = NULL_TREE;\n   PROPERTY_DYNAMIC (property_decl) = 0;\n \n+  /* Note that PROPERTY_GETTER_NAME is always set for all\n+     PROPERTY_DECLs, and PROPERTY_SETTER_NAME is always set for all\n+     PROPERTY_DECLs where PROPERTY_READONLY == 0.  Any time we deal\n+     with a getter or setter, we should get the PROPERTY_DECL and use\n+     PROPERTY_GETTER_NAME and PROPERTY_SETTER_NAME to know the correct\n+     names.  */\n+\n   /* Add the PROPERTY_DECL to the list of properties for the class.  */\n   TREE_CHAIN (property_decl) = CLASS_PROPERTY_DECL (objc_interface_context);\n   CLASS_PROPERTY_DECL (objc_interface_context) = property_decl;\n }\n \n-/* This routine looks for a given PROPERTY in a list of CLASS, CATEGORY, or\n-   PROTOCOL.  */\n-static tree\n-lookup_property_in_list (tree chain, tree property)\n-{\n-  tree x;\n-  for (x = CLASS_PROPERTY_DECL (chain); x; x = TREE_CHAIN (x))\n-    if (PROPERTY_NAME (x) == property)\n-      return x;\n-  return NULL_TREE;\n-}\n-\n-/* This routine looks for a given PROPERTY in the tree chain of RPROTO_LIST. */\n-static tree lookup_property_in_protocol_list (tree rproto_list, tree property)\n-{\n-  tree rproto, x;\n-  for (rproto = rproto_list; rproto; rproto = TREE_CHAIN (rproto))\n-    {\n-      tree p = TREE_VALUE (rproto);\n-      if (TREE_CODE (p) == PROTOCOL_INTERFACE_TYPE)\n-\t{\n-\t  if ((x = lookup_property_in_list (p, property)))\n-\t    return x;\n-\t  if (PROTOCOL_LIST (p))\n-\t    return lookup_property_in_protocol_list (PROTOCOL_LIST (p), property);\n-\t}\n-      else\n-\t{\n-\t  ; /* An identifier...if we could not find a protocol.  */\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* This routine looks up the PROPERTY in current INTERFACE, its categories and up the\n-   chain of interface hierarchy.  */\n-static tree\n-lookup_property (tree interface_type, tree property)\n-{\n-  tree inter = interface_type;\n-  while (inter)\n-    {\n-      tree x, category;\n-      if ((x = lookup_property_in_list (inter, property)))\n-\treturn x;\n-      /* Failing that, look for the property in each category of the class.  */\n-      category = inter;\n-      while ((category = CLASS_CATEGORY_LIST (category)))\n-\tif ((x = lookup_property_in_list (category, property)))\n-\t  return x;\n-\n-      /*  Failing to find in categories, look for property in protocol list. */\n-      if (CLASS_PROTOCOL_LIST (inter) \n-\t  && (x = lookup_property_in_protocol_list (\n-\t\t    CLASS_PROTOCOL_LIST (inter), property)))\n-\treturn x;\n-      \n-      /* Failing that, climb up the inheritance hierarchy.  */\n-      inter = lookup_interface (CLASS_SUPER_NAME (inter));\n-    }\n-  return inter;\n-}\n-\n /* This is a subroutine of objc_maybe_build_component_ref.  Search the\n    list of methods in the interface (and, failing that, the local list\n    in the implementation, and failing that, the protocol list)\n@@ -1295,7 +1441,10 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t    t = TREE_OPERAND (t, 0);\n \t  \n \t  if (t == UOBJC_SUPER_decl)\n-\t    interface_type = lookup_interface (CLASS_SUPER_NAME (implementation_template));\n+\t    {\n+\t      /* TODO: Check if this is correct also for 'super' in categories.  */\n+\t      interface_type = lookup_interface (CLASS_SUPER_NAME (implementation_template));\n+\t    }\n \t  else if (t == self_decl)\n \t    interface_type = lookup_interface (CLASS_NAME (implementation_template));\n \n@@ -8564,38 +8713,101 @@ objc_is_public (tree expr, tree identifier)\n   return 1;\n }\n \f\n-/* Make sure all entries in CHAIN are also in LIST.  */\n+/* Make sure all methods in CHAIN (a list of method declarations from\n+   an @interface or a @protocol) are in IMPLEMENTATION (the\n+   implementation context).  This is used to check for example that\n+   all methods declared in an @interface were implemented in an\n+   @implementation.\n+\n+   Some special methods (property setters/getters) are special and if\n+   they are not found in IMPLEMENTATION, we look them up in its\n+   superclasses.  */\n \n static int\n-check_methods (tree chain, tree list, int mtype)\n+check_methods (tree chain, tree implementation, int mtype)\n {\n   int first = 1;\n+  tree list;\n+\n+  if (mtype == (int)'+')\n+    list = CLASS_CLS_METHODS (implementation);\n+  else\n+    list = CLASS_NST_METHODS (implementation);\n \n   while (chain)\n     {\n       /* If the method is associated with a dynamic property, then it\n \t is Ok not to have the method implementation, as it will be\n \t generated dynamically at runtime.  */\n       tree property = METHOD_PROPERTY_CONTEXT (chain);\n-      if (property != NULL_TREE  &&  PROPERTY_DYNAMIC (property))\n+      if (property != NULL_TREE && PROPERTY_DYNAMIC (property))\n \t{\n \t  chain = TREE_CHAIN (chain); /* next method...  */\n \t  continue;\n \t}\n \n       if (!lookup_method (list, chain))\n \t{\n+\t  /* If the method is a property setter/getter, we'll still\n+\t     allow it to be missing if it is implemented by\n+\t     'interface' or any of its superclasses.  */\n+\t  if (property)\n+\t    {\n+\t      /* Note that since this is a property getter/setter, it\n+\t\t is obviously an instance method.  */\n+\t      tree interface = NULL_TREE;\n+\n+\t      /* For a category, first check the main class\n+\t\t @interface.  */\n+\t      if (TREE_CODE (implementation) == CATEGORY_IMPLEMENTATION_TYPE)\n+\t\t{\n+\t\t  interface = lookup_interface (CLASS_NAME (implementation));\n+\n+\t\t  /* If the method is found in the main class, it's Ok.  */\n+\t\t  if (lookup_method (CLASS_NST_METHODS (interface), chain))\n+\t\t    {\n+\t\t      chain = DECL_CHAIN (chain);\n+\t\t      continue;\t\t      \n+\t\t    }\n+\n+\t\t  /* Else, get the superclass.  */\n+\t\t  if (CLASS_SUPER_NAME (interface))\n+\t\t    interface = lookup_interface (CLASS_SUPER_NAME (interface));\n+\t\t  else\n+\t\t    interface = NULL_TREE;\n+\t\t}\n+\n+\t      /* Get the superclass for classes.  */\n+\t      if (TREE_CODE (implementation) == CLASS_IMPLEMENTATION_TYPE)\n+\t\t{\n+\t\t  if (CLASS_SUPER_NAME (implementation))\n+\t\t    interface = lookup_interface (CLASS_SUPER_NAME (implementation));\n+\t\t  else\n+\t\t    interface = NULL_TREE;\n+\t\t}\n+\n+\t      /* Now, interface is the superclass, if any; go check it.  */\n+\t      if (interface)\n+\t\t{\n+\t\t  if (lookup_method_static (interface, chain, 0))\n+\t\t    {\n+\t\t      chain = DECL_CHAIN (chain);\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      /* Else, fall through - warn.  */\n+\t    }\n \t  if (first)\n \t    {\n-\t      switch (TREE_CODE (objc_implementation_context))\n+\t      switch (TREE_CODE (implementation))\n \t\t{\n \t\tcase CLASS_IMPLEMENTATION_TYPE:\n \t\t  warning (0, \"incomplete implementation of class %qE\",\n-\t\t\t   CLASS_NAME (objc_implementation_context));\n+\t\t\t   CLASS_NAME (implementation));\n \t\t  break;\n \t\tcase CATEGORY_IMPLEMENTATION_TYPE:\n \t\t  warning (0, \"incomplete implementation of category %qE\",\n-\t\t\t   CLASS_SUPER_NAME (objc_implementation_context));\n+\t\t\t   CLASS_SUPER_NAME (implementation));\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n@@ -8733,10 +8945,10 @@ check_protocol (tree p, const char *type, tree name)\n       if (warn_protocol)\n \t{\n \t  f1 = check_methods (PROTOCOL_CLS_METHODS (p),\n-\t\t\t      CLASS_CLS_METHODS (objc_implementation_context),\n+\t\t\t      objc_implementation_context,\n \t\t\t      '+');\n \t  f2 = check_methods (PROTOCOL_NST_METHODS (p),\n-\t\t\t      CLASS_NST_METHODS (objc_implementation_context),\n+\t\t\t      objc_implementation_context,\n \t\t\t      '-');\n \t}\n       else\n@@ -9829,9 +10041,9 @@ finish_class (tree klass)\n \t  {\n \t    /* Ensure that all method listed in the interface contain bodies.  */\n \t    check_methods (CLASS_CLS_METHODS (implementation_template),\n-\t\t\t   CLASS_CLS_METHODS (objc_implementation_context), '+');\n+\t\t\t   objc_implementation_context, '+');\n \t    check_methods (CLASS_NST_METHODS (implementation_template),\n-\t\t\t   CLASS_NST_METHODS (objc_implementation_context), '-');\n+\t\t\t   objc_implementation_context, '-');\n \n \t    if (CLASS_PROTOCOL_LIST (implementation_template))\n \t      check_protocols (CLASS_PROTOCOL_LIST (implementation_template),\n@@ -9848,12 +10060,12 @@ finish_class (tree klass)\n \t  {\n \t    /* Generate what needed for property; setters, getters, etc. */\n \t    objc_gen_property_data (implementation_template, category);\n-\t    \n+\n \t    /* Ensure all method listed in the interface contain bodies.  */\n \t    check_methods (CLASS_CLS_METHODS (category),\n-\t\t\t   CLASS_CLS_METHODS (objc_implementation_context), '+');\n+\t\t\t   objc_implementation_context, '+');\n \t    check_methods (CLASS_NST_METHODS (category),\n-\t\t\t   CLASS_NST_METHODS (objc_implementation_context), '-');\n+\t\t\t   objc_implementation_context, '-');\n \t    \n \t    if (CLASS_PROTOCOL_LIST (category))\n \t      check_protocols (CLASS_PROTOCOL_LIST (category),\n@@ -9870,104 +10082,69 @@ finish_class (tree klass)\n \ttree x;\n \tfor (x = CLASS_PROPERTY_DECL (objc_interface_context); x; x = TREE_CHAIN (x))\n \t  {\n-\t    /* Store the getter name that we used into the property.\n-\t       It is used to generate the right getter calls;\n-\t       moreover, when a @synthesize is processed, it copies\n-\t       everything from the property, including the\n-\t       PROPERTY_GETTER_NAME.  We want to be sure that\n-\t       @synthesize will get exactly the right\n-\t       PROPERTY_GETTER_NAME.  */\n-\t    if (PROPERTY_GETTER_NAME (x) == NULL_TREE)\n-\t      PROPERTY_GETTER_NAME (x) = PROPERTY_NAME (x);\n-\n \t    /* Now we check that the appropriate getter is declared,\n \t       and if not, we declare one ourselves.  */\n-\t    {\n-\t      tree getter_decl = lookup_method (CLASS_NST_METHODS (klass),\n-\t\t\t\t\t\tPROPERTY_GETTER_NAME (x));\n-\t      \n-\t      if (getter_decl)\n-\t\t{\n-\t\t  /* TODO: Check that the declaration is consistent with the property.  */\n-\t\t  ;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Generate an instance method declaration for the\n-\t\t     getter; for example \"- (id) name;\".  In general\n-\t\t     it will be of the form\n-\t\t     -(type)property_getter_name;  */\n-\t\t  tree rettype = build_tree_list (NULL_TREE, TREE_TYPE (x));\n-\t\t  getter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n-\t\t\t\t\t\t   rettype, PROPERTY_GETTER_NAME (x), \n-\t\t\t\t\t\t   NULL_TREE, false);\n-\t\t  objc_add_method (objc_interface_context, getter_decl, false, false);\n-\t\t  METHOD_PROPERTY_CONTEXT (getter_decl) = x;\n-\t\t}\n-\t    }\n+\t    tree getter_decl = lookup_method (CLASS_NST_METHODS (klass),\n+\t\t\t\t\t      PROPERTY_GETTER_NAME (x));\n+\t    \n+\t    if (getter_decl)\n+\t      {\n+\t\t/* TODO: Check that the declaration is consistent with the property.  */\n+\t\t;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Generate an instance method declaration for the\n+\t\t   getter; for example \"- (id) name;\".  In general it\n+\t\t   will be of the form\n+\t\t   -(type)property_getter_name;  */\n+\t\ttree rettype = build_tree_list (NULL_TREE, TREE_TYPE (x));\n+\t\tgetter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t\t\t\t\t rettype, PROPERTY_GETTER_NAME (x), \n+\t\t\t\t\t\t NULL_TREE, false);\n+\t\tobjc_add_method (objc_interface_context, getter_decl, false, false);\n+\t\tMETHOD_PROPERTY_CONTEXT (getter_decl) = x;\n+\t      }\n \n \t    if (PROPERTY_READONLY (x) == 0)\n \t      {\n-\t\t/* Store the setter name that we used into the\n-\t\t   property.  It is used when generating setter calls;\n-\t\t   moreover, when a @synthesize is processed, it\n-\t\t   copies everything from the property, including the\n-\t\t   PROPERTY_SETTER_NAME.  We want to be sure that\n-\t\t   @synthesize will get exactly the right\n-\t\t   PROPERTY_SETTER_NAME.  */\n-\t\tif (PROPERTY_SETTER_NAME (x) == NULL_TREE)\n-\t\t  PROPERTY_SETTER_NAME (x) = get_identifier (objc_build_property_setter_name \n-\t\t\t\t\t\t\t     (PROPERTY_NAME (x)));\n-\n \t\t/* Now we check that the appropriate setter is declared,\n \t\t   and if not, we declare on ourselves.  */\n-\t\t{\n-\t\t  tree setter_decl = lookup_method (CLASS_NST_METHODS (klass), \n-\t\t\t\t\t\t    PROPERTY_SETTER_NAME (x));\n-\t\t  \n-\t\t  if (setter_decl)\n-\t\t    {\n-\t\t      /* TODO: Check that the declaration is consistent with the property.  */\n-\t\t      ;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* The setter name is something like 'setName:'.\n-\t\t\t We need the substring 'setName' to build the\n-\t\t\t method declaration due to how the declaration\n-\t\t\t works.  TODO: build_method_decl() will then\n-\t\t\t generate back 'setName:' from 'setName'; it\n-\t\t\t would be more efficient to hook into\n-\t\t\t there.  */\n-\t\t      const char *full_setter_name = IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (x));\n-\t\t      size_t length = strlen (full_setter_name);\n-\t\t      char *setter_name = (char *) alloca (length);\n-\t\t      tree ret_type, selector, arg_type, arg_name;\n-\n-\t\t      strcpy (setter_name, full_setter_name);\n-\t\t      setter_name[length - 1] = '\\0';\n-\t\t      ret_type = build_tree_list (NULL_TREE, void_type_node);\n-\t\t      arg_type = build_tree_list (NULL_TREE, TREE_TYPE (x));\n-\t\t      arg_name = get_identifier (\"_value\");\n-\t\t      selector = objc_build_keyword_decl (get_identifier (setter_name),\n-\t\t\t\t\t\t\t  arg_type, arg_name, NULL);\n-\t\t      setter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n-\t\t\t\t\t\t       ret_type, selector,\n-\t\t\t\t\t\t       build_tree_list (NULL_TREE, NULL_TREE),\n-\t\t\t\t\t\t       false);\n-\t\t      objc_add_method (objc_interface_context, setter_decl, false, false);\n-\t\t      METHOD_PROPERTY_CONTEXT (setter_decl) = x;\n-\t\t    }\n-\t\t}\n-\n-\t    /* Note how at this point (once an @interface or @protocol\n-\t       have been processed), PROPERTY_GETTER_NAME is always\n-\t       set for all PROPERTY_DECLs, and PROPERTY_SETTER_NAME is\n-\t       always set for all PROPERTY_DECLs where\n-\t       PROPERTY_READONLY == 0.  Any time we deal with a getter\n-\t       or setter, we should get the PROPERTY_DECL and use\n-\t       PROPERTY_GETTER_NAME and PROPERTY_SETTER_NAME to know\n-\t       the correct names.  */\n+\t\ttree setter_decl = lookup_method (CLASS_NST_METHODS (klass), \n+\t\t\t\t\t\t  PROPERTY_SETTER_NAME (x));\n+\t\t\n+\t\tif (setter_decl)\n+\t\t  {\n+\t\t    /* TODO: Check that the declaration is consistent with the property.  */\n+\t\t    ;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* The setter name is something like 'setName:'.\n+\t\t       We need the substring 'setName' to build the\n+\t\t       method declaration due to how the declaration\n+\t\t       works.  TODO: build_method_decl() will then\n+\t\t       generate back 'setName:' from 'setName'; it\n+\t\t       would be more efficient to hook into there.  */\n+\t\t    const char *full_setter_name = IDENTIFIER_POINTER (PROPERTY_SETTER_NAME (x));\n+\t\t    size_t length = strlen (full_setter_name);\n+\t\t    char *setter_name = (char *) alloca (length);\n+\t\t    tree ret_type, selector, arg_type, arg_name;\n+\t\t    \n+\t\t    strcpy (setter_name, full_setter_name);\n+\t\t    setter_name[length - 1] = '\\0';\n+\t\t    ret_type = build_tree_list (NULL_TREE, void_type_node);\n+\t\t    arg_type = build_tree_list (NULL_TREE, TREE_TYPE (x));\n+\t\t    arg_name = get_identifier (\"_value\");\n+\t\t    selector = objc_build_keyword_decl (get_identifier (setter_name),\n+\t\t\t\t\t\t\targ_type, arg_name, NULL);\n+\t\t    setter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t\t\t\t\t     ret_type, selector,\n+\t\t\t\t\t\t     build_tree_list (NULL_TREE, NULL_TREE),\n+\t\t\t\t\t\t     false);\n+\t\t    objc_add_method (objc_interface_context, setter_decl, false, false);\n+\t\t    METHOD_PROPERTY_CONTEXT (setter_decl) = x;\n+\t\t  }\t       \n \t      }\n \t  }\n \tbreak;"}, {"sha": "91717081ff88863193659ce047112b0c8ddaf841", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -144,7 +144,10 @@ typedef enum objc_property_assign_semantics {\n /* CLASS_INTERFACE_TYPE, CLASS_IMPLEMENTATION_TYPE,\n    CATEGORY_INTERFACE_TYPE, CATEGORY_IMPLEMENTATION_TYPE,\n    PROTOCOL_INTERFACE_TYPE */\n+/* CLASS_NAME is the name of the class.  */\n #define CLASS_NAME(CLASS) ((CLASS)->type.name)\n+/* CLASS_SUPER_NAME is the name of the superclass, or, in the case of\n+   categories, it is the name of the category itself.  */\n #define CLASS_SUPER_NAME(CLASS) (TYPE_CHECK (CLASS)->type.context)\n #define CLASS_IVARS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 0)\n #define CLASS_RAW_IVARS(CLASS) TREE_VEC_ELT (TYPE_LANG_SLOT_1 (CLASS), 1)"}, {"sha": "97b3f51ddd4939c0ed5b5ac13c1b3c7630380f91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -1,3 +1,22 @@\n+2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/property/at-property-5.m: Updated test.\t\n+\t* objc.dg/property/at-property-16.m: New.\n+\t* objc.dg/property/at-property-17.m: New.\n+\t* objc.dg/property/at-property-18.m: New.\n+\t* objc.dg/property/at-property-19.m: New.\t\n+\t* objc.dg/property/dotsyntax-12.m: New.\n+\t* objc.dg/protocol-inheritance-1.m: New.\n+\t* objc.dg/protocol-inheritance-2.m: New.\n+\t* obj-c++.dg/property/at-property-5.mm: Updated test.\n+\t* obj-c++.dg/property/at-property-16.mm: New.\n+\t* obj-c++.dg/property/at-property-17.mm: New.\n+\t* obj-c++.dg/property/at-property-18.mm: New.\n+\t* obj-c++.dg/property/at-property-19.mm: New.\t\n+\t* obj-c++.dg/protocol-inheritance-1.mm: New.\n+\t* obj-c++.dg/protocol-inheritance-2.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-12.mm: New.\n+\t\n 2010-11-08  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/expr/overflow1.C: New."}, {"sha": "ca8a68c373d7ea22e9a0521745d7048a3e53ff20", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-16.mm", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-16.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-16.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-16.mm?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,54 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that if you have a property declared in a class and a\n+   sub-class, the attributes match.  */\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property (assign) id a;\n+@property (retain) id b;\n+@property int c;\n+@property (nonatomic) int d;\n+@property int e;\n+@property int f;\n+@property int g;\n+@property (readonly) int h;\n+@property (readonly,getter=getMe) int i;\n+@end\n+\n+@interface MyClass : MyRootClass\n+@property (assign) id a;\n+@property (retain) id b;\n+@property int c;\n+@property (nonatomic) int d;\n+@property int e;\n+@property int f;\n+@property int g;\n+@property (readonly) int h;\n+@property (readonly,getter=getMe) int i;\n+@end\n+/* FIXME - there is a problem with the testuite in running the following test.  The compiler generates the messages, but the testsuite still complains.  */\n+@interface MyClass2 : MyRootClass\n+/* @property (retain) id a; */         /*  dg-error \"assign semantics attributes of property .a. conflict with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 13  */\n+/* @property (assign) id b; */         /*  dg-error \"assign semantics attributes of property .b. conflict with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 14  */\n+/* @property (nonatomic) int c; */     /*  dg-error \".nonatomic. attribute of property .c. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 15  */\n+/* @property int d; */                 /*  dg-error \".nonatomic. attribute of property .d. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 16  */\n+/* @property (setter=setX:) int e; */  /*  dg-error \".setter. attribute of property .e. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 17  */\n+/* @property (getter=x) int f; */      /*  dg-error \".getter. attribute of property .f. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 18  */\n+/* @property (readonly) int g; */      /*  dg-error \".readonly. attribute of property .g. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 19  */\n+@property (readwrite) int h;     /* Ok */\n+/* @property (readonly) int i; */      /*  dg-error \".getter. attribute of property .i. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 21  */\n+@end"}, {"sha": "efb62d6f70d98198d3c3c88321c9697875d36956", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-17.mm", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-17.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-17.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-17.mm?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,98 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that if you have a property declared in a class, with\n+   getters/setters in the superclass, there are no warnings.  */\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int myCount;\n+  int myCount2;\n+  int myCount3;\n+}\n+- (int)count;\n+- (void)setCount: (int)number;\n+- (int)count2;\n+- (void)setCount2: (int)number;\n+- (int)count3;\n+@end\n+\n+@implementation MyRootClass\n+- (int) count\n+{\n+  return myCount;\n+}\n+- (void) setCount: (int)number\n+{\n+  myCount = number;\n+}\n+- (int) count2\n+{\n+  return myCount2;\n+}\n+- (void) setCount2: (int)number\n+{\n+  myCount2 = number;\n+}\n+- (int) count3\n+{\n+  return myCount3;\n+}\n+@end\n+\n+\n+\n+/* Try with a subclass.  */\n+@interface MyClass : MyRootClass\n+@property int count;\n+@end\n+\n+@implementation MyClass\n+@end /* No warnings.  */\n+\n+\n+\n+/* Try with a category.  */\n+@interface MyRootClass (count)\n+@property int count;\n+@end\n+\n+@implementation MyRootClass (count)\n+@end /* No warnings.  */\n+\n+\n+\n+/* Try with a category of a subclass.  */\n+@interface MyClass2 : MyClass\n+@end\n+\n+@implementation MyClass2\n+@end\n+\n+@interface MyClass2 (count2)\n+@property int count2;\n+@end\n+\n+@implementation MyClass2 (count2)\n+@end /* No warnings.  */\n+\n+\n+\n+/* Now, try with a category of a subclass, but with a missing setter,\n+   which should generate a warning.  */\n+@interface MyClass3 : MyClass\n+@end\n+\n+@implementation MyClass3\n+@end\n+\n+@interface MyClass3 (count3)\n+@property int count3;\n+@end\n+\n+@implementation MyClass3 (count3)\n+@end /* { dg-warning \"incomplete implementation\" } */\n+/* { dg-warning \"method definition for .-setCount3:. not found\" \"\" { target *-*-* } 97 } */"}, {"sha": "482e1ff759d5b4b0c7fad6ca0af71ab19dd58e43", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-18.mm", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-18.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-18.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-18.mm?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,47 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that if you have a property declared in a class and a\n+   category, the attributes match.  This is almost the same as\n+   at-property-16.m, but for a category.  It is a separate file\n+   because it is difficult to test multiple messages for the same\n+   line.  */\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property (assign) id a;\n+@property (retain) id b;\n+@property int c;\n+@property (nonatomic) int d;\n+@property int e;\n+@property int f;\n+@property int g;\n+@property (readonly) int h;\n+@property (readonly,getter=getMe) int i;\n+@property (nonatomic) float j;\n+@end\n+/* FIXME - there is a problem with the testuite in running the following test.  The compiler generates the messages, but the testsuite still complains.  */\n+@interface MyRootClass (Category)\n+/*@property (retain) id a; */        /*  dg-error \"assign semantics attributes of property .a. conflict with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 16  */\n+/*@property (assign) id b;  */       /*  dg-error \"assign semantics attributes of property .b. conflict with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 17  */\n+/*@property (nonatomic) int c; */     /*  dg-error \".nonatomic. attribute of property .c. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 18  */\n+/*@property int d; */                /*  dg-error \".nonatomic. attribute of property .d. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 19  */\n+/*@property (setter=setX:) int e; */ /*  dg-error \".setter. attribute of property .e. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 20  */\n+/*@property (getter=x) int f; */     /*  dg-error \".getter. attribute of property .f. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 21  */\n+/*@property (readonly) int g; */      /*  dg-error \".readonly. attribute of property .g. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 22  */\n+@property (readwrite) int h;    /* Ok */\n+/*@property (readonly) int i; */     /*  dg-error \".getter. attribute of property .i. conflicts with previous declaration\"  */\n+                                 /*  dg-message \"originally specified here\" \"\" { target *-*-* } 24  */\n+@property (nonatomic) float j;   /* Ok */\n+@end"}, {"sha": "be898e21815b1fc4eb5b42bc0d812605d2869bc6", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-19.mm", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-19.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-19.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-19.mm?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,74 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test looking up a @property in a protocol of a category of a superclass.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+/* Use a different getter/setter, so that the only way to compile\n+   object.count is to find the actual @property.  */\n+@protocol count\n+@property (getter=number, setter=setNumber:) int count;\n+@end\n+\n+@interface MySubClass : MyRootClass\n+- (int) testMe;\n+@end\n+\n+@interface MySubClass (Category) <count>\n+@end\n+\n+@implementation MySubClass (Category)\n+- (int) number\n+{\n+  return a;\n+}\n+- (void) setNumber: (int)count\n+{\n+  a = count;\n+}\n+@end\n+\n+@implementation MySubClass\n+- (int) testMe\n+{\n+  self.count = 400;\n+  if (self.count != 400)\n+    abort ();             \n+\n+  return self.count;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.count = 44;\n+  if (object.count != 44)\n+    abort ();\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "7ccf4c974d2bc441c69f46af1baf339cb1761194", "filename": "gcc/testsuite/obj-c++.dg/property/at-property-5.mm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fat-property-5.mm?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -32,7 +32,7 @@ @interface MyRootClass\n /* FIXME - there is a problem with the testuite in running the following test.  The compiler\n    generates the messages, but the testsuite still complains.  */\n /*@property (retain) id property_e;*/ /*  dg-error \"redeclaration of property .property_e.\"  */\n-   \t\t\t          /*  dg-message \"originally declared here\" \"\" { target *-*-* } 26  */\n+   \t\t\t          /*  dg-message \"originally specified here\" \"\" { target *-*-* } 26  */\n @end\n \n @property id test; /* { dg-error \"misplaced .@property. Objective-C.. construct\" } */"}, {"sha": "20882f909ae1bacd55fd10b1981a2bbb13df7284", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-12.mm", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-12.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-12.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-12.mm?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,105 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test looking up a setter or getter which are in a protocol attached\n+   to a category of a superclass.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol count\n+- (int) count;\n+- (void) setCount: (int)count;\n+@end\n+\n+@protocol classCount\n++ (int) classCount;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@interface MyRootClass (Category) <count, classCount>\n+@end\n+\n+@implementation MyRootClass (Category)\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+@end\n+\n+@interface MySubClass : MyRootClass\n++ (int) testMe;\n+- (int) testMe;\n+@end\n+\n+@implementation MySubClass\n+- (int) testMe\n+{\n+  self.count = 400;\n+  if (self.count != 400)\n+    abort ();             \n+\n+  return self.count;\n+}\n++ (int) testMe\n+{\n+  self.classCount = 4000;\n+  if (self.classCount != 4000)\n+    abort ();\n+\n+  return self.classCount;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.count = 44;\n+  if (object.count != 44)\n+    abort ();\n+\n+  MySubClass.classCount = 40;\n+  if (MySubClass.classCount != 40)\n+    abort ();\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  if ([MySubClass testMe] != 4000)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "6c23a4663df8e8c4db3d6f39293f01a844a4cb89", "filename": "gcc/testsuite/obj-c++.dg/protocol-inheritance-1.mm", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-inheritance-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-inheritance-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-inheritance-1.mm?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,54 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wno-protocol\" } */\n+\n+#include <objc/objc.h>\n+\n+/* Test the -Wno-protocol flag.  With this, at a class is accepted\n+   (with no warnings) as conforming to a protocol even if some\n+   protocol methods are implemented in the superclass.  */\n+\n+@protocol MyProtocol\n+- (int)method;\n+@end\n+\n+@protocol MyProtocol2\n+- (int)method2;\n+@end\n+\n+/* The superclass implements the method required by the protocol.  */\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+- (int)method;\n+@end\n+\n+@implementation MyRootClass\n+- (int)method\n+{\n+  return 23;\n+}\n+@end\n+\n+/* The subclass inherits the method (does not implement it directly)\n+   but that still makes it conform to the protocol.  No warnings.  */\n+@interface MySubClass : MyRootClass <MyProtocol>\n+@end\n+\n+@implementation MySubClass\n+@end /* No warnings here.  */\n+\n+\n+/* The subclass instead does not inherit the method method2 (and does\n+   not implement it directly) so it does not conform to the\n+   protocol MyProtocol2.  */\n+@interface MySubClass2 : MyRootClass <MyProtocol2>\n+@end\n+\n+@implementation MySubClass2\n+@end /* Warnings here, below.  */\n+\n+/* { dg-warning \"incomplete implementation of class .MySubClass2.\" \"\" { target *-*-* } 50 } */\n+/* { dg-warning \"method definition for .\\\\-method2. not found\" \"\" { target *-*-* } 50 } */\n+/* { dg-warning \"class .MySubClass2. does not fully implement the .MyProtocol2. protocol\" \"\" { target *-*-* } 50 } */"}, {"sha": "d769949451e0612cc34f802d8bd2bafd24dac360", "filename": "gcc/testsuite/obj-c++.dg/protocol-inheritance-2.mm", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-inheritance-2.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-inheritance-2.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fprotocol-inheritance-2.mm?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,57 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test standard warnings when a class conforms to a protocol but some\n+   methods are implemented in the superclass.  Use -Wno-protocol to\n+   turn these off.  */\n+\n+@protocol MyProtocol\n+- (int)method;\n+@end\n+\n+@protocol MyProtocol2\n+- (int)method2;\n+@end\n+\n+/* The superclass implements the method required by the protocol.  */\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+- (int)method;\n+@end\n+\n+@implementation MyRootClass\n+- (int)method\n+{\n+  return 23;\n+}\n+@end\n+\n+/* The subclass inherits the method (does not implement it directly)\n+   and unless -Wno-protocol is used, we emit a warning.  */\n+@interface MySubClass : MyRootClass <MyProtocol>\n+@end\n+\n+@implementation MySubClass\n+@end\n+\n+/* { dg-warning \"incomplete implementation of class .MySubClass.\" \"\" { target *-*-* } 39 } */\n+/* { dg-warning \"method definition for .\\\\-method. not found\" \"\" { target *-*-* } 39 } */\n+/* { dg-warning \"class .MySubClass. does not fully implement the .MyProtocol. protocol\" \"\" { target *-*-* } 39 } */\n+\n+\n+/* The subclass instead does not inherit the method method2 (and does\n+   not implement it directly) so it does not conform to the\n+   protocol MyProtocol2.  */\n+@interface MySubClass2 : MyRootClass <MyProtocol2>\n+@end\n+\n+@implementation MySubClass2\n+@end /* Warnings here, below.  */\n+\n+/* { dg-warning \"incomplete implementation of class .MySubClass2.\" \"\" { target *-*-* } 53 } */\n+/* { dg-warning \"method definition for .\\\\-method2. not found\" \"\" { target *-*-* } 53 } */\n+/* { dg-warning \"class .MySubClass2. does not fully implement the .MyProtocol2. protocol\" \"\" { target *-*-* } 53 } */"}, {"sha": "f40225dea674108230e8ebe9b4c0c84158353489", "filename": "gcc/testsuite/objc.dg/property/at-property-16.m", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-16.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-16.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-16.m?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,55 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that if you have a property declared in a class and a\n+   sub-class, the attributes match.  */\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property (assign) id a;\n+@property (retain) id b;\n+@property int c;\n+@property (nonatomic) int d;\n+@property int e;\n+@property int f;\n+@property int g;\n+@property (readonly) int h;\n+@property (readonly,getter=getMe) int i;\n+@end\n+\n+@interface MyClass : MyRootClass\n+@property (assign) id a;\n+@property (retain) id b;\n+@property int c;\n+@property (nonatomic) int d;\n+@property int e;\n+@property int f;\n+@property int g;\n+@property (readonly) int h;\n+@property (readonly,getter=getMe) int i;\n+@end\n+\n+@interface MyClass2 : MyRootClass\n+@property (retain) id a;         /* { dg-error \"assign semantics attributes of property .a. conflict with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 13 } */\n+@property (assign) id b;         /* { dg-error \"assign semantics attributes of property .b. conflict with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 14 } */\n+@property (nonatomic) int c;     /* { dg-error \".nonatomic. attribute of property .c. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 15 } */\n+@property int d;                 /* { dg-error \".nonatomic. attribute of property .d. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 16 } */\n+@property (setter=setX:) int e;  /* { dg-error \".setter. attribute of property .e. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 17 } */\n+@property (getter=x) int f;      /* { dg-error \".getter. attribute of property .f. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 18 } */\n+@property (readonly) int g;      /* { dg-error \".readonly. attribute of property .g. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 19 } */\n+@property (readwrite) int h;     /* Ok */\n+@property (readonly) int i;      /* { dg-error \".getter. attribute of property .i. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 21 } */\n+@end\n+"}, {"sha": "efb62d6f70d98198d3c3c88321c9697875d36956", "filename": "gcc/testsuite/objc.dg/property/at-property-17.m", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-17.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-17.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-17.m?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,98 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that if you have a property declared in a class, with\n+   getters/setters in the superclass, there are no warnings.  */\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int myCount;\n+  int myCount2;\n+  int myCount3;\n+}\n+- (int)count;\n+- (void)setCount: (int)number;\n+- (int)count2;\n+- (void)setCount2: (int)number;\n+- (int)count3;\n+@end\n+\n+@implementation MyRootClass\n+- (int) count\n+{\n+  return myCount;\n+}\n+- (void) setCount: (int)number\n+{\n+  myCount = number;\n+}\n+- (int) count2\n+{\n+  return myCount2;\n+}\n+- (void) setCount2: (int)number\n+{\n+  myCount2 = number;\n+}\n+- (int) count3\n+{\n+  return myCount3;\n+}\n+@end\n+\n+\n+\n+/* Try with a subclass.  */\n+@interface MyClass : MyRootClass\n+@property int count;\n+@end\n+\n+@implementation MyClass\n+@end /* No warnings.  */\n+\n+\n+\n+/* Try with a category.  */\n+@interface MyRootClass (count)\n+@property int count;\n+@end\n+\n+@implementation MyRootClass (count)\n+@end /* No warnings.  */\n+\n+\n+\n+/* Try with a category of a subclass.  */\n+@interface MyClass2 : MyClass\n+@end\n+\n+@implementation MyClass2\n+@end\n+\n+@interface MyClass2 (count2)\n+@property int count2;\n+@end\n+\n+@implementation MyClass2 (count2)\n+@end /* No warnings.  */\n+\n+\n+\n+/* Now, try with a category of a subclass, but with a missing setter,\n+   which should generate a warning.  */\n+@interface MyClass3 : MyClass\n+@end\n+\n+@implementation MyClass3\n+@end\n+\n+@interface MyClass3 (count3)\n+@property int count3;\n+@end\n+\n+@implementation MyClass3 (count3)\n+@end /* { dg-warning \"incomplete implementation\" } */\n+/* { dg-warning \"method definition for .-setCount3:. not found\" \"\" { target *-*-* } 97 } */"}, {"sha": "58b1d6a07ccd835808fc4d3c33aed55378f24af2", "filename": "gcc/testsuite/objc.dg/property/at-property-18.m", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-18.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-18.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-18.m?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,47 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test that if you have a property declared in a class and a\n+   category, the attributes match.  This is almost the same as\n+   at-property-16.m, but for a category.  It is a separate file\n+   because it is difficult to test multiple messages for the same\n+   line.  */\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+@property (assign) id a;\n+@property (retain) id b;\n+@property int c;\n+@property (nonatomic) int d;\n+@property int e;\n+@property int f;\n+@property int g;\n+@property (readonly) int h;\n+@property (readonly,getter=getMe) int i;\n+@property (nonatomic) float j;\n+@end\n+\n+@interface MyRootClass (Category)\n+@property (retain) id a;         /* { dg-error \"assign semantics attributes of property .a. conflict with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 16 } */\n+@property (assign) id b;         /* { dg-error \"assign semantics attributes of property .b. conflict with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 17 } */\n+@property (nonatomic) int c;     /* { dg-error \".nonatomic. attribute of property .c. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 18 } */\n+@property int d;                 /* { dg-error \".nonatomic. attribute of property .d. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 19 } */\n+@property (setter=setX:) int e;  /* { dg-error \".setter. attribute of property .e. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 20 } */\n+@property (getter=x) int f;      /* { dg-error \".getter. attribute of property .f. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 21 } */\n+@property (readonly) int g;      /* { dg-error \".readonly. attribute of property .g. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 22 } */\n+@property (readwrite) int h;     /* Ok */\n+@property (readonly) int i;      /* { dg-error \".getter. attribute of property .i. conflicts with previous declaration\" } */\n+                                 /* { dg-message \"originally specified here\" \"\" { target *-*-* } 24 } */\n+@property (nonatomic) float j;   /* Ok */\n+@end"}, {"sha": "be898e21815b1fc4eb5b42bc0d812605d2869bc6", "filename": "gcc/testsuite/objc.dg/property/at-property-19.m", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-19.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-19.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-19.m?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,74 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, October 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test looking up a @property in a protocol of a category of a superclass.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+/* Use a different getter/setter, so that the only way to compile\n+   object.count is to find the actual @property.  */\n+@protocol count\n+@property (getter=number, setter=setNumber:) int count;\n+@end\n+\n+@interface MySubClass : MyRootClass\n+- (int) testMe;\n+@end\n+\n+@interface MySubClass (Category) <count>\n+@end\n+\n+@implementation MySubClass (Category)\n+- (int) number\n+{\n+  return a;\n+}\n+- (void) setNumber: (int)count\n+{\n+  a = count;\n+}\n+@end\n+\n+@implementation MySubClass\n+- (int) testMe\n+{\n+  self.count = 400;\n+  if (self.count != 400)\n+    abort ();             \n+\n+  return self.count;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.count = 44;\n+  if (object.count != 44)\n+    abort ();\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "bd8949b7f587d65213a22c86f520d547522890b1", "filename": "gcc/testsuite/objc.dg/property/at-property-5.m", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fat-property-5.m?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -28,7 +28,7 @@ @interface MyRootClass\n @property (retain) id property_g;\n @property (retain) id property_h;\n @property (retain) id property_e; /* { dg-error \"redeclaration of property .property_e.\" } */\n-   \t\t\t          /* { dg-message \"originally declared here\" \"\" { target *-*-* } 26 } */\n+   \t\t\t          /* { dg-message \"originally specified here\" \"\" { target *-*-* } 26 } */\n @end\n \n @property id test; /* { dg-error \"property declaration not in .interface or .protocol context\" } */"}, {"sha": "20882f909ae1bacd55fd10b1981a2bbb13df7284", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-12.m", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-12.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-12.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-12.m?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,105 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+/* { dg-xfail-run-if \"Needs OBJC2 ABI\" { *-*-darwin* && { lp64 && { ! objc2 } } } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* Test looking up a setter or getter which are in a protocol attached\n+   to a category of a superclass.  */\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int c;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+  int a;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n+@end\n+\n+@protocol count\n+- (int) count;\n+- (void) setCount: (int)count;\n+@end\n+\n+@protocol classCount\n++ (int) classCount;\n++ (void) setClassCount: (int)count;\n+@end\n+\n+@interface MyRootClass (Category) <count, classCount>\n+@end\n+\n+@implementation MyRootClass (Category)\n+- (int) count\n+{\n+  return a;\n+}\n+- (void) setCount: (int)count\n+{\n+  a = count;\n+}\n++ (int) classCount\n+{\n+  return c;\n+}\n++ (void) setClassCount: (int)count\n+{\n+  c = count;\n+}\n+@end\n+\n+@interface MySubClass : MyRootClass\n++ (int) testMe;\n+- (int) testMe;\n+@end\n+\n+@implementation MySubClass\n+- (int) testMe\n+{\n+  self.count = 400;\n+  if (self.count != 400)\n+    abort ();             \n+\n+  return self.count;\n+}\n++ (int) testMe\n+{\n+  self.classCount = 4000;\n+  if (self.classCount != 4000)\n+    abort ();\n+\n+  return self.classCount;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MySubClass *object = [[MySubClass alloc] init];\n+\n+  object.count = 44;\n+  if (object.count != 44)\n+    abort ();\n+\n+  MySubClass.classCount = 40;\n+  if (MySubClass.classCount != 40)\n+    abort ();\n+\n+  if ([object testMe] != 400)\n+    abort ();\n+\n+  if ([MySubClass testMe] != 4000)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "6c23a4663df8e8c4db3d6f39293f01a844a4cb89", "filename": "gcc/testsuite/objc.dg/protocol-inheritance-1.m", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-inheritance-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-inheritance-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-inheritance-1.m?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,54 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wno-protocol\" } */\n+\n+#include <objc/objc.h>\n+\n+/* Test the -Wno-protocol flag.  With this, at a class is accepted\n+   (with no warnings) as conforming to a protocol even if some\n+   protocol methods are implemented in the superclass.  */\n+\n+@protocol MyProtocol\n+- (int)method;\n+@end\n+\n+@protocol MyProtocol2\n+- (int)method2;\n+@end\n+\n+/* The superclass implements the method required by the protocol.  */\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+- (int)method;\n+@end\n+\n+@implementation MyRootClass\n+- (int)method\n+{\n+  return 23;\n+}\n+@end\n+\n+/* The subclass inherits the method (does not implement it directly)\n+   but that still makes it conform to the protocol.  No warnings.  */\n+@interface MySubClass : MyRootClass <MyProtocol>\n+@end\n+\n+@implementation MySubClass\n+@end /* No warnings here.  */\n+\n+\n+/* The subclass instead does not inherit the method method2 (and does\n+   not implement it directly) so it does not conform to the\n+   protocol MyProtocol2.  */\n+@interface MySubClass2 : MyRootClass <MyProtocol2>\n+@end\n+\n+@implementation MySubClass2\n+@end /* Warnings here, below.  */\n+\n+/* { dg-warning \"incomplete implementation of class .MySubClass2.\" \"\" { target *-*-* } 50 } */\n+/* { dg-warning \"method definition for .\\\\-method2. not found\" \"\" { target *-*-* } 50 } */\n+/* { dg-warning \"class .MySubClass2. does not fully implement the .MyProtocol2. protocol\" \"\" { target *-*-* } 50 } */"}, {"sha": "d769949451e0612cc34f802d8bd2bafd24dac360", "filename": "gcc/testsuite/objc.dg/protocol-inheritance-2.m", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-inheritance-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-inheritance-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fprotocol-inheritance-2.m?ref=4ca5d2a7bdc3cd7182cbf0e1261a6df44d362d87", "patch": "@@ -0,0 +1,57 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+#include <objc/objc.h>\n+\n+/* Test standard warnings when a class conforms to a protocol but some\n+   methods are implemented in the superclass.  Use -Wno-protocol to\n+   turn these off.  */\n+\n+@protocol MyProtocol\n+- (int)method;\n+@end\n+\n+@protocol MyProtocol2\n+- (int)method2;\n+@end\n+\n+/* The superclass implements the method required by the protocol.  */\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n+- (int)method;\n+@end\n+\n+@implementation MyRootClass\n+- (int)method\n+{\n+  return 23;\n+}\n+@end\n+\n+/* The subclass inherits the method (does not implement it directly)\n+   and unless -Wno-protocol is used, we emit a warning.  */\n+@interface MySubClass : MyRootClass <MyProtocol>\n+@end\n+\n+@implementation MySubClass\n+@end\n+\n+/* { dg-warning \"incomplete implementation of class .MySubClass.\" \"\" { target *-*-* } 39 } */\n+/* { dg-warning \"method definition for .\\\\-method. not found\" \"\" { target *-*-* } 39 } */\n+/* { dg-warning \"class .MySubClass. does not fully implement the .MyProtocol. protocol\" \"\" { target *-*-* } 39 } */\n+\n+\n+/* The subclass instead does not inherit the method method2 (and does\n+   not implement it directly) so it does not conform to the\n+   protocol MyProtocol2.  */\n+@interface MySubClass2 : MyRootClass <MyProtocol2>\n+@end\n+\n+@implementation MySubClass2\n+@end /* Warnings here, below.  */\n+\n+/* { dg-warning \"incomplete implementation of class .MySubClass2.\" \"\" { target *-*-* } 53 } */\n+/* { dg-warning \"method definition for .\\\\-method2. not found\" \"\" { target *-*-* } 53 } */\n+/* { dg-warning \"class .MySubClass2. does not fully implement the .MyProtocol2. protocol\" \"\" { target *-*-* } 53 } */"}]}