{"sha": "cdf6119dad04dd912a8c3863880ee764f5ba3ba9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RmNjExOWRhZDA0ZGQ5MTJhOGMzODYzODgwZWU3NjRmNWJhM2JhOQ==", "commit": {"author": {"name": "James Norris", "email": "jnorris@codesourcery.com", "date": "2016-01-12T17:03:03Z"}, "committer": {"name": "James Norris", "email": "jnorris@gcc.gnu.org", "date": "2016-01-12T17:03:03Z"}, "message": "* libgomp.texi: Updates for OpenACC.\n\nFrom-SVN: r232283", "tree": {"sha": "abdfc3c2f0c238a0a4902f6035a6ab26f605e50f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abdfc3c2f0c238a0a4902f6035a6ab26f605e50f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdf6119dad04dd912a8c3863880ee764f5ba3ba9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf6119dad04dd912a8c3863880ee764f5ba3ba9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdf6119dad04dd912a8c3863880ee764f5ba3ba9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf6119dad04dd912a8c3863880ee764f5ba3ba9/comments", "author": null, "committer": null, "parents": [{"sha": "5342156c7a5cede074f9334ca27a373e9802bd59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5342156c7a5cede074f9334ca27a373e9802bd59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5342156c7a5cede074f9334ca27a373e9802bd59"}], "stats": {"total": 1290, "additions": 1290, "deletions": 0}, "files": [{"sha": "5918752c3ea749dde9329de0392adc1a1ae362ac", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf6119dad04dd912a8c3863880ee764f5ba3ba9/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf6119dad04dd912a8c3863880ee764f5ba3ba9/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=cdf6119dad04dd912a8c3863880ee764f5ba3ba9", "patch": "@@ -1,3 +1,7 @@\n+2016-01-12  James Norris  <jnorris@codesourcery.com>\n+\n+\t* libgomp.texi: Updates for OpenACC.\n+\n 2016-01-11  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* plugin/plugin-nvptx.c (link_ptx): Do not set CU_JIT_TARGET."}, {"sha": "987ee5f04f36cf6a04f5efca15580a997cf0bb20", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1286, "deletions": 0, "changes": 1286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf6119dad04dd912a8c3863880ee764f5ba3ba9/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf6119dad04dd912a8c3863880ee764f5ba3ba9/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=cdf6119dad04dd912a8c3863880ee764f5ba3ba9", "patch": "@@ -99,6 +99,16 @@ changed to GNU Offloading and Multi Processing Runtime Library.\n                                interface.\n * Environment Variables::      Influencing runtime behavior with environment \n                                variables.\n+* Enabling OpenACC::           How to enable OpenACC for your\n+                               applications.\n+* OpenACC Runtime Library Routines:: The OpenACC runtime application\n+                               programming interface.\n+* OpenACC Environment Variables:: Influencing OpenACC runtime behavior with\n+                               environment variables.\n+* CUDA Streams Usage::         Notes on the implementation of\n+                               asynchronous operations.\n+* OpenACC Library Interoperability:: OpenACC library interoperability with the\n+                               NVIDIA CUBLAS library.\n * The libgomp ABI::            Notes on the external ABI presented by libgomp.\n * Reporting Bugs::             How to report bugs in the GNU Offloading and\n                                Multi Processing Runtime Library.\n@@ -1789,6 +1799,1272 @@ pools available and their worker threads run at priority four.\n \n \n \n+@c ---------------------------------------------------------------------\n+@c Enabling OpenACC\n+@c ---------------------------------------------------------------------\n+\n+@node Enabling OpenACC\n+@chapter Enabling OpenACC\n+\n+To activate the OpenACC extensions for C/C++ and Fortran, the compile-time \n+flag @option{-fopenacc} must be specified.  This enables the OpenACC directive\n+@code{#pragma acc} in C/C++ and @code{!$accp} directives in free form,\n+@code{c$acc}, @code{*$acc} and @code{!$acc} directives in fixed form,\n+@code{!$} conditional compilation sentinels in free form and @code{c$},\n+@code{*$} and @code{!$} sentinels in fixed form, for Fortran.  The flag also\n+arranges for automatic linking of the OpenACC runtime library \n+(@ref{OpenACC Runtime Library Routines}).\n+\n+A complete description of all OpenACC directives accepted may be found in \n+the @uref{http://www.openacc.org/, OpenACC} Application Programming\n+Interface manual, version 2.0.\n+\n+Note that this is an experimental feature and subject to\n+change in future versions of GCC.  See\n+@uref{https://gcc.gnu.org/wiki/OpenACC} for more information.\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c OpenACC Runtime Library Routines\n+@c ---------------------------------------------------------------------\n+\n+@node OpenACC Runtime Library Routines\n+@chapter OpenACC Runtime Library Routines\n+\n+The runtime routines described here are defined by section 3 of the OpenACC\n+specifications in version 2.0.\n+They have C linkage, and do not throw exceptions.\n+Generally, they are available only for the host, with the exception of\n+@code{acc_on_device}, which is available for both the host and the\n+acceleration device.\n+\n+@menu\n+* acc_get_num_devices::         Get number of devices for the given device\n+                                type.\n+* acc_set_device_type::         Set type of device accelerator to use.\n+* acc_get_device_type::         Get type of device accelerator to be used.\n+* acc_set_device_num::          Set device number to use.\n+* acc_get_device_num::          Get device number to be used.\n+* acc_async_test::              Tests for completion of a specific asynchronous\n+                                operation.\n+* acc_async_test_all::          Tests for completion of all asychronous\n+                                operations.\n+* acc_wait::                    Wait for completion of a specific asynchronous\n+                                operation.\n+* acc_wait_all::                Waits for completion of all asyncrhonous\n+                                operations.\n+* acc_wait_all_async::          Wait for completion of all asynchronous\n+                                operations.\n+* acc_wait_async::              Wait for completion of asynchronous operations.\n+* acc_init::                    Initialize runtime for a specific device type.\n+* acc_shutdown::                Shuts down the runtime for a specific device\n+                                type.\n+* acc_on_device::               Whether executing on a particular device\n+* acc_malloc::                  Allocate device memory.\n+* acc_free::                    Free device memory.\n+* acc_copyin::                  Allocate device memory and copy host memory to\n+                                it.\n+* acc_present_or_copyin::       If the data is not present on the device,\n+                                allocate device memory and copy from host\n+                                memory.\n+* acc_create::                  Allocate device memory and map it to host\n+                                memory.\n+* acc_present_or_create::       If the data is not present on the device,\n+                                allocate device memory and map it to host\n+                                memory.\n+* acc_copyout::                 Copy device memory to host memory.\n+* acc_delete::                  Free device memory.\n+* acc_update_device::           Update device memory from mapped host memory.\n+* acc_update_self::             Update host memory from mapped device memory.\n+* acc_map_data::                Map previously allocated device memory to host\n+                                memory.\n+* acc_unmap_data::              Unmap device memory from host memory.\n+* acc_deviceptr::               Get device pointer associated with specific\n+                                host address.\n+* acc_hostptr::                 Get host pointer associated with specific\n+                                device address.\n+* acc_is_present::              Indiciate whether host variable / array is\n+                                present on device.\n+* acc_memcpy_to_device::        Copy host memory to device memory.\n+* acc_memcpy_from_device::      Copy device memory to host memory.\n+\n+API routines for target platforms.\n+\n+* acc_get_current_cuda_device:: Get CUDA device handle.\n+* acc_get_current_cuda_context::Get CUDA context handle.\n+* acc_get_cuda_stream::         Get CUDA stream handle.\n+* acc_set_cuda_stream::         Set CUDA stream handle.\n+@end menu\n+\n+\n+\n+@node acc_get_num_devices\n+@section @code{acc_get_num_devices} -- Get number of devices for given device type\n+@table @asis\n+@item @emph{Description}\n+This function returns a value indicating the number of devices available\n+for the device type specified in @var{devicetype}. \n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int acc_get_num_devices(acc_device_t devicetype);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{integer function acc_get_num_devices(devicetype)}\n+@item                  @tab @code{integer(kind=acc_device_kind) devicetype}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.1.\n+@end table\n+\n+\n+\n+@node acc_set_device_type\n+@section @code{acc_set_device_type} -- Set type of device accelerator to use.\n+@table @asis\n+@item @emph{Description}\n+This function indicates to the runtime library which device typr, specified\n+in @var{devicetype}, to use when executing a parallel or kernels region. \n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_set_device_type(acc_device_t devicetype);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_set_device_type(devicetype)}\n+@item                   @tab @code{integer(kind=acc_device_kind) devicetype}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.2.\n+@end table\n+\n+\n+\n+@node acc_get_device_type\n+@section @code{acc_get_device_type} -- Get type of device accelerator to be used.\n+@table @asis\n+@item @emph{Description}\n+This function returns what device type will be used when executing a\n+parallel or kernels region.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_device_t acc_get_device_type(void);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{function acc_get_device_type(void)}\n+@item                  @tab @code{integer(kind=acc_device_kind) acc_get_device_type}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.3.\n+@end table\n+\n+\n+\n+@node acc_set_device_num\n+@section @code{acc_set_device_num} -- Set device number to use.\n+@table @asis\n+@item @emph{Description}\n+This function will indicate to the runtime which device number,\n+specified by @var{num}, associated with the specifed device\n+type @var{devicetype}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_set_device_num(int num, acc_device_t devicetype);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_set_device_num(devicenum, devicetype)}\n+@item                   @tab @code{integer devicenum}\n+@item                   @tab @code{integer(kind=acc_device_kind) devicetype}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.4.\n+@end table\n+\n+\n+\n+@node acc_get_device_num\n+@section @code{acc_get_device_num} -- Get device number to be used.\n+@table @asis\n+@item @emph{Description}\n+This function returns which device number associated with the specified device\n+type @var{devicetype}, will be used when executing a parallel or kernels\n+region.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int acc_get_device_num(acc_device_t devicetype);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{function acc_get_device_num(devicetype)}\n+@item                   @tab @code{integer(kind=acc_device_kind) devicetype}\n+@item                   @tab @code{integer acc_get_device_num}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.5.\n+@end table\n+\n+\n+\n+@node acc_async_test\n+@section @code{acc_async_test} -- Test for completion of a specific asynchronous operation.\n+@table @asis\n+@item @emph{Description}\n+This function tests for completion of the asynchrounous operation specified\n+in @var{arg}. In C/C++, a non-zero value will be returned to indicate\n+the specified asynchronous operation has completed. While Fortran will return\n+a @code{true}. If the asynchrounous operation has not completed, C/C++ returns\n+a zero and Fortran returns a @code{false}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int acc_async_test(int arg);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{function acc_async_test(arg)}\n+@item                   @tab @code{integer(kind=acc_handle_kind) arg}\n+@item                   @tab @code{logical acc_async_test}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.6.\n+@end table\n+\n+\n+\n+@node acc_async_test_all\n+@section @code{acc_async_test_all} -- Tests for completion of all asynchronous operations.\n+@table @asis\n+@item @emph{Description}\n+This function tests for completion of all asynchrounous operations.\n+In C/C++, a non-zero value will be returned to indicate all asynchronous\n+operations have completed. While Fortran will return a @code{true}. If\n+any asynchronous operation has not completed, C/C++ returns a zero and\n+Fortran returns a @code{false}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int acc_async_test_all(void);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{function acc_async_test()}\n+@item                   @tab @code{logical acc_get_device_num}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.7.\n+@end table\n+\n+\n+\n+@node acc_wait\n+@section @code{acc_wait} -- Wait for completion of a specific asynchronous operation.\n+@table @asis\n+@item @emph{Description}\n+This function waits for completion of the asynchronous operation\n+specified in @var{arg}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_wait(arg);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_wait(arg)}\n+@item                   @tab @code{integer(acc_handle_kind) arg}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.8.\n+@end table\n+\n+\n+\n+@node acc_wait_all\n+@section @code{acc_wait_all} -- Waits for completion of all asynchronous operations.\n+@table @asis\n+@item @emph{Description}\n+This function waits for the completion of all asynchronous operations.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_wait_all(void);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_wait_async()}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.10.\n+@end table\n+\n+\n+\n+@node acc_wait_all_async\n+@section @code{acc_wait_all_async} -- Wait for completion of all asynchronous operations.\n+@table @asis\n+@item @emph{Description}\n+This function enqueues a wait operation on the queue @var{async} for any\n+and all asynchronous operations that have been previously enqueued on\n+any queue.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_wait_all_async(int async);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_wait_all_async(async)}\n+@item                   @tab @code{integer(acc_handle_kind) async}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.11.\n+@end table\n+\n+\n+\n+@node acc_wait_async\n+@section @code{acc_wait_async} -- Wait for completion of asynchronous operations.\n+@table @asis\n+@item @emph{Description}\n+This function enqueues a wait operation on queue @var{async} for any and all\n+asynchronous operations enqueued on queue @var{arg}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_wait_async(int arg, int async);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_wait_async(arg, async)}\n+@item                   @tab @code{integer(acc_handle_kind) arg, async}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.9.\n+@end table\n+\n+\n+\n+@node acc_init\n+@section @code{acc_init} -- Initialize runtime for a specific device type.\n+@table @asis\n+@item @emph{Description}\n+This function initializes the runtime for the device type specified in\n+@var{devicetype}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_init(acc_device_t devicetype);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_init(devicetype)}\n+@item                   @tab @code{integer(acc_device_kind) devicetype}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.12.\n+@end table\n+\n+\n+\n+@node acc_shutdown\n+@section @code{acc_shutdown} -- Shuts down the runtime for a specific device type.\n+@table @asis\n+@item @emph{Description}\n+This function shuts down the runtime for the device type specified in\n+@var{devicetype}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_shutdown(acc_device_t devicetype);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_shutdown(devicetype)}\n+@item                   @tab @code{integer(acc_device_kind) devicetype}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.13.\n+@end table\n+\n+\n+\n+@node acc_on_device\n+@section @code{acc_on_device} -- Whether executing on a particular device\n+@table @asis\n+@item @emph{Description}:\n+This function returns whether the program is executing on a particular\n+device specified in @var{devicetype}. In C/C++ a non-zero value is\n+returned to indicate the device is execiting on the specified device type.\n+In Fortran, @code{true} will be returned. If the program is not executing\n+on the specified device type C/C++ will return a zero, while Fortran will\n+return @code{false}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_on_device(acc_device_t devicetype);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{function acc_on_device(devicetype)}\n+@item                   @tab @code{integer(acc_device_kind) devicetype}\n+@item                   @tab @code{logical acc_on_device}\n+@end multitable\n+\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.14.\n+@end table\n+\n+\n+\n+@node acc_malloc\n+@section @code{acc_malloc} -- Allocate device memory.\n+@table @asis\n+@item @emph{Description}\n+This function allocates @var{len} bytes of device memory. It returns\n+the device address of the allocated memory.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{d_void* acc_malloc(size_t len);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.15.\n+@end table\n+\n+\n+\n+@node acc_free\n+@section @code{acc_free} -- Free device memory.\n+@table @asis\n+@item @emph{Description}\n+Free previously allocated device memory at the device address @code{a}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_free(d_void *a);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.16.\n+@end table\n+\n+\n+\n+@node acc_copyin\n+@section @code{acc_copyin} -- Allocate device memory and copy host memory to it.\n+@table @asis\n+@item @emph{Description}\n+In C/C++, this function allocates @var{len} bytes of device memory\n+and maps it to the specified host address in @var{a}. The device\n+address of the newly allocated device memory is returned.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a\n+variable or array element and @var{len} specifies the length in bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void *acc_copyin(h_void *a, size_t len);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_copyin(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_copyin(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.17.\n+@end table\n+\n+\n+\n+@node acc_present_or_copyin\n+@section @code{acc_present_or_copyin} -- If the data is not present on the device, allocate device memory and copy from host memory.\n+@table @asis\n+@item @emph{Description}\n+This function tests if the host data specifed by @var{a} and of length\n+@var{len} is present or not. If it is not present, then device memory\n+will be allocated and the host memory copied. The device address of\n+the newly allocated device memory is returned.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a variable or\n+array element and @var{len} specifies the length in bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void *acc_present_or_copyin(h_void *a, size_t len);}\n+@item @emph{Prototype}: @tab @code{void *acc_pcopyin(h_void *a, size_t len);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_present_or_copyin(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_present_or_copyin(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@item @emph{Interface}: @tab @code{subroutine acc_pcopyin(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_pcopyin(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.18.\n+@end table\n+\n+\n+\n+@node acc_create\n+@section @code{acc_create} -- Allocate device memory and map it to host memory.\n+@table @asis\n+@item @emph{Description}\n+This function allocates device memory and maps it to host memory specified\n+by the host address @var{a} with a length of @var{len} bytes. In C/C++,\n+the function returns the device address of the allocated device memory.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a variable or\n+array element and @var{len} specifies the length in bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void *acc_create(h_void *a, size_t len);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_create(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_create(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.19.\n+@end table\n+\n+\n+\n+@node acc_present_or_create\n+@section @code{acc_present_or_create} -- If the data is not present on the device, allocate device memory and map it to host memory.\n+@table @asis\n+@item @emph{Description}\n+This function tests if the host data specifed by @var{a} and of length\n+@var{len} is present or not. If it is not present, then device memory\n+will be allocated and mapped to host memory. In C/C++, the device address\n+of the newly allocated device memory is returned.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a variable or\n+array element and @var{len} specifies the length in bytes.\n+\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void *acc_present_or_create(h_void *a, size_t len)}\n+@item @emph{Prototype}: @tab @code{void *acc_pcreate(h_void *a, size_t len)}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_present_or_create(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_present_or_create(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@item @emph{Interface}: @tab @code{subroutine acc_pcreate(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_pcreate(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.20.\n+@end table\n+\n+\n+\n+@node acc_copyout\n+@section @code{acc_copyout} -- Copy device memory to host memory.\n+@table @asis\n+@item @emph{Description}\n+This function copies mapped device memory to host memory which is specified\n+by host address @var{a} for a length @var{len} bytes in C/C++.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a variable or\n+array element and @var{len} specifies the length in bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_copyout(h_void *a, size_t len);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_copyout(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_copyout(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.21.\n+@end table\n+\n+\n+\n+@node acc_delete\n+@section @code{acc_delete} -- Free device memory.\n+@table @asis\n+@item @emph{Description}\n+This function frees previously allocated device memory specified by\n+the device address @var{a} and the length of @var{len} bytes.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a variable or\n+array element and @var{len} specifies the length in bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_delete(h_void *a, size_t len);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_delete(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_delete(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.22.\n+@end table\n+\n+\n+\n+@node acc_update_device\n+@section @code{acc_update_device} -- Update device memory from mapped host memory.\n+@table @asis\n+@item @emph{Description}\n+This function updates the device copy from the previously mapped host memory.\n+The host memory is specified with the host address @var{a} and a length of\n+@var{len} bytes.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a variable or\n+array element and @var{len} specifies the length in bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_update_device(h_void *a, size_t len);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_update_device(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_update_device(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.23.\n+@end table\n+\n+\n+\n+@node acc_update_self\n+@section @code{acc_update_self} -- Update host memory from mapped device memory.\n+@table @asis\n+@item @emph{Description}\n+This function updates the host copy from the previously mapped device memory.\n+The host memory is specified with the host address @var{a} and a length of\n+@var{len} bytes.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a variable or\n+array element and @var{len} specifies the length in bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_update_self(h_void *a, size_t len);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{subroutine acc_update_self(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item @emph{Interface}: @tab @code{subroutine acc_update_self(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.24.\n+@end table\n+\n+\n+\n+@node acc_map_data\n+@section @code{acc_map_data} -- Map previously allocated device memory to host memory.\n+@table @asis\n+@item @emph{Description}\n+This function maps previously allocated device and host memory. The device\n+memory is specified with the device address @var{d}. The host memory is\n+specified with the host address @var{h} and a length of @var{len}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_map_data(h_void *h, d_void *d, size_t len);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.25.\n+@end table\n+\n+\n+\n+@node acc_unmap_data\n+@section @code{acc_unmap_data} -- Unmap device memory from host memory.\n+@table @asis\n+@item @emph{Description}\n+This function unmaps previously mapped device and host memory. The latter\n+specified by @var{h}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_unmap_data(h_void *h);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.26.\n+@end table\n+\n+\n+\n+@node acc_deviceptr\n+@section @code{acc_deviceptr} -- Get device pointer associated with specific host address.\n+@table @asis\n+@item @emph{Description}\n+This function returns the device address that has been mapped to the\n+host address specified by @var{h}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void *acc_deviceptr(h_void *h);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.27.\n+@end table\n+\n+\n+\n+@node acc_hostptr\n+@section @code{acc_hostptr} -- Get host pointer associated with specific device address.\n+@table @asis\n+@item @emph{Description}\n+This function returns the host address that has been mapped to the\n+device address specified by @var{d}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void *acc_hostptr(d_void *d);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.28.\n+@end table\n+\n+\n+\n+@node acc_is_present\n+@section @code{acc_is_present} -- Indicate whether host variable / array is present on device.\n+@table @asis\n+@item @emph{Description}\n+This function indicates whether the specified host address in @var{a} and a\n+length of @var{len} bytes is present on the device. In C/C++, a non-zero\n+value is returned to indicate the presence of the mapped memory on the\n+device. A zero is returned to indicate the memory is not mapped on the\n+device.\n+\n+In Fortran, two (2) forms are supported. In the first form, @var{a} specifies\n+a contiguous array section. The second form @var{a} specifies a variable or\n+array element and @var{len} specifies the length in bytes. If the host\n+memory is mapped to device memory, then a @code{true} is returned. Otherwise,\n+a @code{false} is return to indicate the mapped memory is not present.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{int acc_is_present(h_void *a, size_t len);}\n+@end multitable\n+\n+@item @emph{Fortran}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Interface}: @tab @code{function acc_is_present(a)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{logical acc_is_present}\n+@item @emph{Interface}: @tab @code{function acc_is_present(a, len)}\n+@item                   @tab @code{type, dimension(:[,:]...) :: a}\n+@item                   @tab @code{integer len}\n+@item                   @tab @code{logical acc_is_present}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.29.\n+@end table\n+\n+\n+\n+@node acc_memcpy_to_device\n+@section @code{acc_memcpy_to_device} -- Copy host memory to device memory.\n+@table @asis\n+@item @emph{Description}\n+This function copies host memory specified by host address of @var{src} to\n+device memory specified by the device address @var{dest} for a length of\n+@var{bytes} bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_memcpy_to_device(d_void *dest, h_void *src, size_t bytes);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.30.\n+@end table\n+\n+\n+\n+@node acc_memcpy_from_device\n+@section @code{acc_memcpy_from_device} -- Copy device memory to host memory.\n+@table @asis\n+@item @emph{Description}\n+This function copies host memory specified by host address of @var{src} from\n+device memory specified by the device address @var{dest} for a length of\n+@var{bytes} bytes.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_memcpy_from_device(d_void *dest, h_void *src, size_t bytes);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+3.2.31.\n+@end table\n+\n+\n+\n+@node acc_get_current_cuda_device\n+@section @code{acc_get_current_cuda_device} -- Get CUDA device handle.\n+@table @asis\n+@item @emph{Description}\n+This function returns the CUDA device handle. This handle is the same\n+as used by the CUDA Runtime or Driver API's.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{void *acc_get_current_cuda_device(void);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+A.2.1.1.\n+@end table\n+\n+\n+\n+@node acc_get_current_cuda_context\n+@section @code{acc_get_current_cuda_context} -- Get CUDA context handle.\n+@table @asis\n+@item @emph{Description}\n+This function returns the CUDA context handle. This handle is the same\n+as used by the CUDA Runtime or Driver API's.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_get_current_cuda_context(void);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+A.2.1.2.\n+@end table\n+\n+\n+\n+@node acc_get_cuda_stream\n+@section @code{acc_get_cuda_stream} -- Get CUDA stream handle.\n+@table @asis\n+@item @emph{Description}\n+This function returns the CUDA stream handle. This handle is the same\n+as used by the CUDA Runtime or Driver API's.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_get_cuda_stream(void);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+A.2.1.3.\n+@end table\n+\n+\n+\n+@node acc_set_cuda_stream\n+@section @code{acc_set_cuda_stream} -- Set CUDA stream handle.\n+@table @asis\n+@item @emph{Description}\n+This function associates the stream handle specified by @var{stream} with\n+the asynchronous value specified by @var{async}.\n+\n+@item @emph{C/C++}:\n+@multitable @columnfractions .20 .80\n+@item @emph{Prototype}: @tab @code{acc_set_cuda_stream(int async void *stream);}\n+@end multitable\n+\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+A.2.1.4.\n+@end table\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c OpenACC Environment Variables\n+@c ---------------------------------------------------------------------\n+\n+@node OpenACC Environment Variables\n+@chapter OpenACC Environment Variables\n+\n+The variables @env{ACC_DEVICE_TYPE} and @env{ACC_DEVICE_NUM}\n+are defined by section 4 of the OpenACC specification in version 2.0.\n+The variable @env{GCC_ACC_NOTIFY} is used for diagnostic purposes.\n+\n+@menu\n+* ACC_DEVICE_TYPE::\n+* ACC_DEVICE_NUM::\n+* GCC_ACC_NOTIFY::\n+@end menu\n+\n+\n+\n+@node ACC_DEVICE_TYPE\n+@section @code{ACC_DEVICE_TYPE}\n+@table @asis\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+4.1.\n+@end table\n+\n+\n+\n+@node ACC_DEVICE_NUM\n+@section @code{ACC_DEVICE_NUM}\n+@table @asis\n+@item @emph{Reference}:\n+@uref{http://www.openacc.org/, OpenACC specification v2.0}, section\n+4.2.\n+@end table\n+\n+\n+\n+@node GCC_ACC_NOTIFY\n+@section @code{GCC_ACC_NOTIFY}\n+@table @asis\n+@item @emph{Description}:\n+Print debug information pertaining to the accelerator.\n+@end table\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c CUDA Streams Usage\n+@c ---------------------------------------------------------------------\n+\n+@node CUDA Streams Usage\n+@chapter CUDA Streams Usage\n+\n+This applies to the @code{nvptx} plugin only.\n+\n+The library provides elements that perform asynchronous movement of\n+data and asynchronous operation of computing constructs.  This\n+asynchronous functionality is implemented by making use of CUDA\n+streams@footnote{See \"Stream Management\" in \"CUDA Driver API\",\n+TRM-06703-001, Version 5.5, for additional information}.\n+\n+The primary means by that the asychronous functionality is accessed\n+is through the use of those OpenACC directives which make use of the\n+@code{async} and @code{wait} clauses.  When the @code{async} clause is\n+first used with a directive, it creates a CUDA stream.  If an\n+@code{async-argument} is used with the @code{async} clause, then the\n+stream is associated with the specified @code{async-argument}.\n+\n+Following the creation of an association between a CUDA stream and the\n+@code{async-argument} of an @code{async} clause, both the @code{wait}\n+clause and the @code{wait} directive can be used.  When either the\n+clause or directive is used after stream creation, it creates a\n+rendezvous point whereby execution waits until all operations\n+associated with the @code{async-argument}, that is, stream, have\n+completed.\n+\n+Normally, the management of the streams that are created as a result of\n+using the @code{async} clause, is done without any intervention by the\n+caller.  This implies the association between the @code{async-argument}\n+and the CUDA stream will be maintained for the lifetime of the program.\n+However, this association can be changed through the use of the library\n+function @code{acc_set_cuda_stream}.  When the function\n+@code{acc_set_cuda_stream} is called, the CUDA stream that was\n+originally associated with the @code{async} clause will be destroyed.\n+Caution should be taken when changing the association as subsequent\n+references to the @code{async-argument} refer to a different\n+CUDA stream.\n+\n+\n+\n+@c ---------------------------------------------------------------------\n+@c OpenACC Library Interoperability\n+@c ---------------------------------------------------------------------\n+\n+@node OpenACC Library Interoperability\n+@chapter OpenACC Library Interoperability\n+\n+@section Introduction\n+\n+The OpenACC library uses the CUDA Driver API, and may interact with\n+programs that use the Runtime library directly, or another library\n+based on the Runtime library, e.g., CUBLAS@footnote{See section 2.26,\n+\"Interactions with the CUDA Driver API\" in\n+\"CUDA Runtime API\", Version 5.5, and section 2.27, \"VDPAU\n+Interoperability\", in \"CUDA Driver API\", TRM-06703-001, Version 5.5,\n+for additional information on library interoperability.}.\n+This chapter describes the use cases and what changes are\n+required in order to use both the OpenACC library and the CUBLAS and Runtime\n+libraries within a program.\n+\n+@section First invocation: NVIDIA CUBLAS library API\n+\n+In this first use case (see below), a function in the CUBLAS library is called\n+prior to any of the functions in the OpenACC library. More specifically, the\n+function @code{cublasCreate()}.\n+\n+When invoked, the function initializes the library and allocates the\n+hardware resources on the host and the device on behalf of the caller. Once\n+the initialization and allocation has completed, a handle is returned to the\n+caller. The OpenACC library also requires initialization and allocation of\n+hardware resources. Since the CUBLAS library has already allocated the\n+hardware resources for the device, all that is left to do is to initialize\n+the OpenACC library and acquire the hardware resources on the host.\n+\n+Prior to calling the OpenACC function that initializes the library and\n+allocate the host hardware resources, you need to acquire the device number\n+that was allocated during the call to @code{cublasCreate()}. The invoking of the\n+runtime library function @code{cudaGetDevice()} accomplishes this. Once\n+acquired, the device number is passed along with the device type as\n+parameters to the OpenACC library function @code{acc_set_device_num()}.\n+\n+Once the call to @code{acc_set_device_num()} has completed, the OpenACC\n+library uses the  context that was created during the call to\n+@code{cublasCreate()}. In other words, both libraries will be sharing the\n+same context.\n+\n+@smallexample\n+    /* Create the handle */\n+    s = cublasCreate(&h);\n+    if (s != CUBLAS_STATUS_SUCCESS)\n+    @{\n+        fprintf(stderr, \"cublasCreate failed %d\\n\", s);\n+        exit(EXIT_FAILURE);\n+    @}\n+\n+    /* Get the device number */\n+    e = cudaGetDevice(&dev);\n+    if (e != cudaSuccess)\n+    @{\n+        fprintf(stderr, \"cudaGetDevice failed %d\\n\", e);\n+        exit(EXIT_FAILURE);\n+    @}\n+\n+    /* Initialize OpenACC library and use device 'dev' */\n+    acc_set_device_num(dev, acc_device_nvidia);\n+\n+@end smallexample\n+@center Use Case 1 \n+\n+@section First invocation: OpenACC library API\n+\n+In this second use case (see below), a function in the OpenACC library is\n+called prior to any of the functions in the CUBLAS library. More specificially,\n+the function @code{acc_set_device_num()}.\n+\n+In the use case presented here, the function @code{acc_set_device_num()}\n+is used to both initialize the OpenACC library and allocate the hardware\n+resources on the host and the device. In the call to the function, the\n+call parameters specify which device to use and what device\n+type to use, i.e., @code{acc_device_nvidia}. It should be noted that this\n+is but one method to initialize the OpenACC library and allocate the\n+appropriate hardware resources. Other methods are available through the\n+use of environment variables and these will be discussed in the next section.\n+\n+Once the call to @code{acc_set_device_num()} has completed, other OpenACC\n+functions can be called as seen with multiple calls being made to\n+@code{acc_copyin()}. In addition, calls can be made to functions in the\n+CUBLAS library. In the use case a call to @code{cublasCreate()} is made\n+subsequent to the calls to @code{acc_copyin()}.\n+As seen in the previous use case, a call to @code{cublasCreate()}\n+initializes the CUBLAS library and allocates the hardware resources on the\n+host and the device.  However, since the device has already been allocated,\n+@code{cublasCreate()} will only initialize the CUBLAS library and allocate\n+the appropriate hardware resources on the host. The context that was created\n+as part of the OpenACC initialization is shared with the CUBLAS library,\n+similarly to the first use case.\n+\n+@smallexample\n+    dev = 0;\n+\n+    acc_set_device_num(dev, acc_device_nvidia);\n+\n+    /* Copy the first set to the device */\n+    d_X = acc_copyin(&h_X[0], N * sizeof (float));\n+    if (d_X == NULL)\n+    @{ \n+        fprintf(stderr, \"copyin error h_X\\n\");\n+        exit(EXIT_FAILURE);\n+    @}\n+\n+    /* Copy the second set to the device */\n+    d_Y = acc_copyin(&h_Y1[0], N * sizeof (float));\n+    if (d_Y == NULL)\n+    @{ \n+        fprintf(stderr, \"copyin error h_Y1\\n\");\n+        exit(EXIT_FAILURE);\n+    @}\n+\n+    /* Create the handle */\n+    s = cublasCreate(&h);\n+    if (s != CUBLAS_STATUS_SUCCESS)\n+    @{\n+        fprintf(stderr, \"cublasCreate failed %d\\n\", s);\n+        exit(EXIT_FAILURE);\n+    @}\n+\n+    /* Perform saxpy using CUBLAS library function */\n+    s = cublasSaxpy(h, N, &alpha, d_X, 1, d_Y, 1);\n+    if (s != CUBLAS_STATUS_SUCCESS)\n+    @{\n+        fprintf(stderr, \"cublasSaxpy failed %d\\n\", s);\n+        exit(EXIT_FAILURE);\n+    @}\n+\n+    /* Copy the results from the device */\n+    acc_memcpy_from_device(&h_Y1[0], d_Y, N * sizeof (float));\n+\n+@end smallexample\n+@center Use Case 2\n+\n+@section OpenACC library and environment variables\n+\n+There are two environment variables associated with the OpenACC library\n+that may be used to control the device type and device number:\n+@env{ACC_DEVICE_TYPE} and @env{ACC_DEVICE_NUM}, respecively. These two\n+environement variables can be used as an alternative to calling\n+@code{acc_set_device_num()}. As seen in the second use case, the device\n+type and device number were specified using @code{acc_set_device_num()}.\n+If however, the aforementioned environment variables were set, then the\n+call to @code{acc_set_device_num()} would not be required.\n+\n+\n+The use of the environment variables is only relevant when an OpenACC function\n+is called prior to a call to @code{cudaCreate()}. If @code{cudaCreate()}\n+is called prior to a call to an OpenACC function, then you must call\n+@code{acc_set_device_num()}@footnote{More complete information\n+about @env{ACC_DEVICE_TYPE} and @env{ACC_DEVICE_NUM} can be found in\n+sections 4.1 and 4.2 of the @uref{http://www.openacc.org/, OpenACC}\n+Application Programming Interface\u201d, Version 2.0.}\n+\n+\n+\n @c ---------------------------------------------------------------------\n @c The libgomp ABI\n @c ---------------------------------------------------------------------\n@@ -1814,6 +3090,7 @@ presented by libgomp.  Only maintainers should need them.\n * Implementing ORDERED construct::\n * Implementing SECTIONS construct::\n * Implementing SINGLE construct::\n+* Implementing OpenACC's PARALLEL construct::\n @end menu\n \n \n@@ -2178,6 +3455,15 @@ becomes\n \n \n \n+@node Implementing OpenACC's PARALLEL construct\n+@section Implementing OpenACC's PARALLEL construct\n+\n+@smallexample\n+  void GOACC_parallel ()\n+@end smallexample\n+\n+\n+\n @c ---------------------------------------------------------------------\n @c Reporting Bugs\n @c ---------------------------------------------------------------------"}]}