{"sha": "4a5121b59a5b1960d3e0a2803b03a3e5c2ad29d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE1MTIxYjU5YTViMTk2MGQzZTBhMjgwM2IwM2EzZTVjMmFkMjlkMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-10-19T16:29:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-10-19T16:29:32Z"}, "message": "Initial revision\n\nFrom-SVN: r16070", "tree": {"sha": "5a2c8374a4dc2321eed6aec593283133e90dcc1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a2c8374a4dc2321eed6aec593283133e90dcc1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a5121b59a5b1960d3e0a2803b03a3e5c2ad29d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a5121b59a5b1960d3e0a2803b03a3e5c2ad29d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a5121b59a5b1960d3e0a2803b03a3e5c2ad29d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a5121b59a5b1960d3e0a2803b03a3e5c2ad29d3/comments", "author": null, "committer": null, "parents": [{"sha": "d1485032c8ae427d2090b32d8dfc50e207f64fd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1485032c8ae427d2090b32d8dfc50e207f64fd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1485032c8ae427d2090b32d8dfc50e207f64fd9"}], "stats": {"total": 314, "additions": 314, "deletions": 0}, "files": [{"sha": "3ffda1ab528e4fcb23e700f7832d2ad55f862659", "filename": "gcc/prefix.c", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5121b59a5b1960d3e0a2803b03a3e5c2ad29d3/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5121b59a5b1960d3e0a2803b03a3e5c2ad29d3/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=4a5121b59a5b1960d3e0a2803b03a3e5c2ad29d3", "patch": "@@ -0,0 +1,314 @@\n+/* Utility to update paths from internal to external forms.\n+   Copyright (C) 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, Inc., 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* This file contains routines to update a path, both to canonicalize\n+   the directory format and to handle any prefix translation.\n+\n+   This file must be compiled with -DPREFIX= to specify the \"prefix\"\n+   value used by configure.  If a filename does not begin with this\n+   prefix, it will not be affected other than by directory canonicalization.\n+\n+   Each caller of 'update_path' may specify both a filename and\n+   a translation prefix and consist of the name of the package that contains\n+   the file (\"@GCC\", \"@BINUTIL\", \"@GNU\", etc).\n+\n+   If the prefix is not specified, the filename will only undergo\n+   directory canonicalization.\n+\n+   If it is specified, the string given by PREFIX will be replaced\n+   by the specified prefix (with a '@' in front unless the prefix begins\n+   with a '$') and further translation will be done as follows\n+   until none of the two conditions below are met:\n+\n+   1) If the filename begins with '@', the string between the '@' and\n+   the end of the name or the first '/' or directory separator will\n+   be considered a \"key\" and looked up as follows:\n+\n+   -- If this is a Win32 OS, then the Registry will be examined for\n+      an entry of \"key\" in \n+\n+      HKEY_LOCAL_MACHINE\\SOFTWARE\\Free Software Foundation\\\n+\n+      if found, that value will be used.\n+\n+   -- If not found (or not a Win32 OS), the environment variable\n+      key_ROOT (the value of \"key\" concatenated with the constant \"_ROOT\")\n+      is tried.  If that fails, then PREFIX (see above) is used.\n+\n+   2) If the filename begins with a '$', the rest of the string up\n+   to the end or the first '/' or directory separator will be used\n+   as an environment variable, whose value will be returned.\n+\n+   Once all this is done, any '/' will be converted to DIR_SEPARATOR,\n+   if they are different. \n+\n+   NOTE:  using resolve_keyed_path under Win32 requires linking with\n+   advapi32.dll.  */\n+\n+\n+#include \"config.h\"\n+#include \"gansidecl.h\"\n+#include \"stdarg.h\"\n+\n+#ifdef _WIN32\n+#include <windows.h>\n+#endif\n+\n+static char *get_key_value\tPROTO((char *));\n+static char *translate_name\tPROTO((char *));\n+static char *concat\t\tPVPROTO((char *, ...));\n+static char *save_string\tPROTO((char *, int));\n+\n+#ifdef _WIN32\n+static char *lookup_key\t\tPROTO((char *));\n+static HKEY reg_key = (HKEY) INVALID_HANDLE_VALUE;\n+#endif\n+\n+extern char *getenv ();\n+\n+/* Given KEY, as above, return its value.  */\n+\n+static char *\n+get_key_value (key)\n+     char *key;\n+{\n+  char *prefix = 0;\n+\n+#ifdef _WIN32\n+  prefix = lookup_key (key);\n+#endif\n+\n+  if (prefix == 0)\n+    prefix = getenv (concat (key, \"_ROOT\", NULL_PTR));\n+\n+  if (prefix == 0)\n+    prefix = PREFIX;\n+\n+  return prefix;\n+}\n+\n+/* Concatenate a sequence of strings, returning the result.\n+\n+   This function is based on the one in libiberty.  */\n+\n+static char *\n+concat VPROTO((char *first, ...))\n+{\n+  register int length;\n+  register char *newstr;\n+  register char *end;\n+  register char *arg;\n+  va_list args;\n+#ifndef __STDC__\n+  char *first;\n+#endif\n+\n+  /* First compute the size of the result and get sufficient memory.  */\n+\n+  VA_START (args, first);\n+#ifndef __STDC__\n+  first = va_arg (args, char *);\n+#endif\n+\n+  arg = first;\n+  length = 0;\n+\n+  while (arg != 0)\n+    {\n+      length += strlen (arg);\n+      arg = va_arg (args, char *);\n+    }\n+\n+  newstr = (char *) malloc (length + 1);\n+  va_end (args);\n+\n+  /* Now copy the individual pieces to the result string.  */\n+\n+  VA_START (args, first);\n+#ifndef __STDC__\n+  first = va_arg (args, char *);\n+#endif\n+\n+  end = newstr;\n+  arg = first;\n+  while (arg != 0)\n+    {\n+      while (*arg)\n+\t*end++ = *arg++;\n+      arg = va_arg (args, char *);\n+    }\n+  *end = '\\000';\n+  va_end (args);\n+\n+  return (newstr);\n+}\n+\n+/* Return a copy of a string that has been placed in the heap.  */\n+\n+static char *\n+save_string (s, len)\n+     char *s;\n+     int len;\n+{\n+  register char *result = (char *) malloc (len + 1);\n+\n+  bcopy (s, result, len);\n+  result[len] = 0;\n+  return result;\n+}\n+\n+#ifdef _WIN32\n+\n+/* Look up \"key\" in the registry, as above.  */\n+\n+static char *\n+lookup_key (key)\n+     char *key;\n+{\n+  char *dst;\n+  DWORD size;\n+  DWORD type;\n+  LONG res;\n+\n+  if (reg_key == (HKEY) INVALID_HANDLE_VALUE)\n+    {\n+      res = RegOpenKeyExA (HKEY_LOCAL_MACHINE, \"SOFTWARE\", 0,\n+\t\t\t   KEY_READ, &reg_key);\n+\n+      if (res == ERROR_SUCCESS)\n+\tres = RegOpenKeyExA (reg_key, \"Free Software Foundation\", 0,\n+\t\t\t     KEY_READ, &reg_key);\n+\n+      if (res != ERROR_SUCCESS)\n+        {\n+          reg_key = (HKEY) INVALID_HANDLE_VALUE;\n+          return 0;\n+        }\n+    }\n+\n+  size = 32;\n+  dst = (char *) malloc (size);\n+\n+  res = RegQueryValueExA (reg_key, key, 0, &type, dst, &size);\n+  if (res == ERROR_MORE_DATA && type == REG_SZ)\n+    {\n+      dst = (char *) realloc (dst, size);\n+      res = RegQueryValueExA (reg_key, key, 0, &type, dst, &size);\n+    }\n+\n+  if (type != REG_SZ || res != ERROR_SUCCESS)\n+    {\n+      free (dst);\n+      dst = 0;\n+    }\n+\n+  return dst;\n+}\n+#endif\n+\n+/* If NAME starts with a '@' or '$', apply the translation rules above\n+   and return a new name.  Otherwise, return the given name.  */\n+\n+static char *\n+translate_name (name)\n+     char *name;\n+{\n+  char code = name[0];\n+  char *key, *prefix;\n+  int keylen;\n+\n+  if (code != '@' && code != '$')\n+    return name;\n+\n+  for (keylen = 0;\n+       (name[keylen + 1] != 0 && name[keylen + 1] != '/'\n+#ifdef DIR_SEPARATOR\n+\t&& name[keylen + 1] != DIR_SEPARATOR\n+#endif\n+\t);\n+       keylen++)\n+    ;\n+\n+  key = alloca (keylen + 1);\n+  strncpy (key, &name[1], keylen);\n+  key[keylen] = 0;\n+\n+  name = &name[keylen + 1];\n+\n+  if (code == '@')\n+    {\n+      prefix = get_key_value (key);\n+      if (prefix == 0)\n+\tprefix = PREFIX;\n+    }\n+  else\n+    {\n+      prefix = getenv (key);\n+      if (prefix == 0)\n+\tprefix = concat (\"$\", key, NULL_PTR);\n+    }\n+\n+  /* Remove any trailing directory separator from what we got.  */\n+  if (prefix[strlen (prefix) - 1] == '/'\n+#ifdef DIR_SEPARATOR\n+      || prefix[strlen (prefix) - 1] == DIR_SEPARATOR\n+#endif\n+      )\n+    {\n+      prefix = save_string (prefix, strlen (prefix));\n+      prefix[strlen (prefix) - 1] = 0;\n+    }\n+\n+  return concat (prefix, name, NULL_PTR);\n+}\n+\n+/* Update PATH using KEY if PATH starts with PREFIX.  */\n+\n+char *\n+update_path (path, key)\n+     char *path;\n+     char *key;\n+{\n+  if (! strncmp (path, PREFIX, strlen (PREFIX)) && key != 0)\n+    {\n+      if (key[0] != '$')\n+\tkey = concat (\"@\", key, NULL_PTR);\n+\n+      path = concat (key, &path[strlen (PREFIX)], NULL_PTR);\n+\n+      while (path[0] == '@' || path[0] == '$')\n+\tpath = translate_name (path);\n+    }\n+      \n+#ifdef DIR_SEPARATOR\n+  if (DIR_SEPARATOR != '/')\n+    {\n+      int i;\n+      int len = strlen (path);\n+\n+      path = save_string (path, len);\n+      for (i = 0; i < len; i++)\n+\tif (path[i] == '/')\n+\t  path[i] = DIR_SEPARATOR;\n+    }\n+#endif\n+\n+  return path;\n+}"}]}