{"sha": "7a6303e53b4d2328eb43c933f2cbd7f53526962c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E2MzAzZTUzYjRkMjMyOGViNDNjOTMzZjJjYmQ3ZjUzNTI2OTYyYw==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2021-01-20T17:09:19Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-05-07T09:28:56Z"}, "message": "[Ada] Implement aspect No_Controlled_Parts\n\ngcc/ada/\n\n\t* aspects.ads: Add entries to register\n\tAspect_No_Controlled_Parts.\n\t* freeze.adb (Check_No_Controlled_Parts_Violations): Added to\n\tcheck requirements of aspect No_Controlled_Parts after a type\n\thas been frozen.\n\t(Freeze_Entity): Add call to\n\tCheck_No_Controlled_Parts_Violations.\n\t(Find_Aspect_No_Controlled_Parts): Created to obtain the aspect\n\tspecification for No_Controlled_Parts on a given type when\n\tpresent.\n\t(Find_Aspect_No_Controlled_Parts_Value): Protect against invalid\n\tvalue.\n\t(Has_Aspect_No_Controlled_Parts): Created as a prediate function\n\tto check if No_Controlled_Parts has been specified on a type for\n\tGet_Anacestor_Types_With_Specification.\n\t(Get_Aspect_No_Controlled_Parts_Value): Created to obtain the\n\tvalue of the aspect No_Controlled_Parts when specified on a\n\tgiven type.\n\t(Get_Generic_Formal_Types_In_Hierarchy): Created to collect\n\tformal types in a given type's hierarchy.\n\t(Get_Types_With_Aspect_In_Hierarchy): Created to collect types\n\tin a given type's hierarchy with No_Controlled_Parts specified.\n\t* sem_ch13.adb (Analyze_One_Aspect): Add processing for\n\tNo_Controlled_Parts, and fix error in check for allowed pragmas\n\tfor formal types.\n\t(Check_Expr_Is_OK_Static_Expression): Created to enforce\n\tchecking of static expressions in the same vein as\n\tAnalyze_Pragma.Check_Expr_OK_Static_Expression.\n\t* sem_util.adb (Collect_Types_In_Hierarchy): Created to collect\n\ttypes in a given type's hierarchy that match a given predicate\n\tfunction.\n\t* sem_util.ads: Fix typo.\n\t* snames.ads-tmpl: Add entry for No_Controlled_Parts.", "tree": {"sha": "a5b357b10e5436fc0284fbbdde7900183383af05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5b357b10e5436fc0284fbbdde7900183383af05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a6303e53b4d2328eb43c933f2cbd7f53526962c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6303e53b4d2328eb43c933f2cbd7f53526962c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a6303e53b4d2328eb43c933f2cbd7f53526962c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6303e53b4d2328eb43c933f2cbd7f53526962c/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb246154cdeb518b8e8a584032afbda4d381a03b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb246154cdeb518b8e8a584032afbda4d381a03b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb246154cdeb518b8e8a584032afbda4d381a03b"}], "stats": {"total": 569, "additions": 568, "deletions": 1}, "files": [{"sha": "8e64543eee6cfe3be159027fd1a935cb38c69880", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=7a6303e53b4d2328eb43c933f2cbd7f53526962c", "patch": "@@ -116,6 +116,7 @@ package Aspects is\n       Aspect_Max_Entry_Queue_Length,\n       Aspect_Max_Queue_Length,              -- GNAT\n       Aspect_No_Caching,                    -- GNAT\n+      Aspect_No_Controlled_Parts,\n       Aspect_Object_Size,                   -- GNAT\n       Aspect_Obsolescent,                   -- GNAT\n       Aspect_Output,\n@@ -403,6 +404,7 @@ package Aspects is\n       Aspect_Max_Entry_Queue_Length     => Expression,\n       Aspect_Max_Queue_Length           => Expression,\n       Aspect_No_Caching                 => Optional_Expression,\n+      Aspect_No_Controlled_Parts        => Optional_Expression,\n       Aspect_Object_Size                => Expression,\n       Aspect_Obsolescent                => Optional_Expression,\n       Aspect_Output                     => Name,\n@@ -505,6 +507,7 @@ package Aspects is\n       Aspect_Max_Entry_Queue_Length       => False,\n       Aspect_Max_Queue_Length             => False,\n       Aspect_No_Caching                   => False,\n+      Aspect_No_Controlled_Parts          => False,\n       Aspect_Object_Size                  => True,\n       Aspect_Obsolescent                  => False,\n       Aspect_Output                       => False,\n@@ -666,6 +669,7 @@ package Aspects is\n       Aspect_Max_Entry_Queue_Length       => Name_Max_Entry_Queue_Length,\n       Aspect_Max_Queue_Length             => Name_Max_Queue_Length,\n       Aspect_No_Caching                   => Name_No_Caching,\n+      Aspect_No_Controlled_Parts          => Name_No_Controlled_Parts,\n       Aspect_No_Elaboration_Code_All      => Name_No_Elaboration_Code_All,\n       Aspect_No_Inline                    => Name_No_Inline,\n       Aspect_No_Return                    => Name_No_Return,\n@@ -960,6 +964,7 @@ package Aspects is\n       Aspect_Max_Entry_Queue_Length       => Never_Delay,\n       Aspect_Max_Queue_Length             => Never_Delay,\n       Aspect_No_Caching                   => Never_Delay,\n+      Aspect_No_Controlled_Parts          => Never_Delay,\n       Aspect_No_Elaboration_Code_All      => Never_Delay,\n       Aspect_No_Tagged_Streams            => Never_Delay,\n       Aspect_Obsolescent                  => Never_Delay,"}, {"sha": "061e3836497b4f170aba8844682a745645359fe1", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=7a6303e53b4d2328eb43c933f2cbd7f53526962c", "patch": "@@ -2192,6 +2192,11 @@ package body Freeze is\n       --  which is the current instance type can only be applied when the type\n       --  is limited.\n \n+      procedure Check_No_Controlled_Parts_Violations (Typ : Entity_Id);\n+      --  Check that Typ does not violate the semantics of aspect\n+      --  No_Controlled_Parts when it is specified on Typ or one of its\n+      --  ancestors.\n+\n       procedure Check_Suspicious_Convention (Rec_Type : Entity_Id);\n       --  Give a warning for pragma Convention with language C or C++ applied\n       --  to a discriminated record type. This is suppressed for the unchecked\n@@ -2412,6 +2417,361 @@ package body Freeze is\n          end if;\n       end Check_Current_Instance;\n \n+      ------------------------------------------\n+      -- Check_No_Controlled_Parts_Violations --\n+      ------------------------------------------\n+\n+      procedure Check_No_Controlled_Parts_Violations (Typ : Entity_Id) is\n+\n+         function Find_Aspect_No_Controlled_Parts\n+           (Typ : Entity_Id) return Node_Id;\n+         --  Search for aspect No_Controlled_Parts on a given type. When\n+         --  the aspect is not explicity specified Empty is returned.\n+\n+         function Get_Aspect_No_Controlled_Parts_Value\n+           (Typ : Entity_Id) return Entity_Id;\n+         --  Obtain the value for the No_Controlled_Parts aspect on a given\n+         --  type. When the aspect is not explicitly specified Empty is\n+         --  returned.\n+\n+         function Has_Aspect_No_Controlled_Parts\n+           (Typ : Entity_Id) return Boolean;\n+         --  Predicate function which identifies whether No_Controlled_Parts\n+         --  is explicitly specified on a given type.\n+\n+         -------------------------------------\n+         -- Find_Aspect_No_Controlled_Parts --\n+         -------------------------------------\n+\n+         function Find_Aspect_No_Controlled_Parts\n+           (Typ : Entity_Id) return Node_Id\n+         is\n+            Partial_View : constant Entity_Id :=\n+              Incomplete_Or_Partial_View (Typ);\n+\n+            Aspect_Spec : Entity_Id :=\n+              Find_Aspect (Typ, Aspect_No_Controlled_Parts);\n+            Curr_Aspect_Spec : Entity_Id;\n+         begin\n+\n+            --  Examine Typ's associated node, when present, since aspect\n+            --  specifications do not get transferred when nodes get rewritten.\n+\n+            --  For example, this can happen in the expansion of array types\n+\n+            if No (Aspect_Spec)\n+              and then Present (Associated_Node_For_Itype (Typ))\n+              and then Nkind (Associated_Node_For_Itype (Typ))\n+                         = N_Full_Type_Declaration\n+            then\n+               Aspect_Spec :=\n+                 Find_Aspect\n+                   (Id => Defining_Identifier\n+                            (Associated_Node_For_Itype (Typ)),\n+                    A  => Aspect_No_Controlled_Parts);\n+            end if;\n+\n+            --  Examine aspects specifications on private type declarations\n+\n+            --  Should Find_Aspect be improved to handle this case ???\n+\n+            if No (Aspect_Spec)\n+              and then Present (Partial_View)\n+              and then Present\n+                         (Aspect_Specifications\n+                           (Declaration_Node\n+                             (Partial_View)))\n+            then\n+               Curr_Aspect_Spec :=\n+                 First\n+                   (Aspect_Specifications\n+                     (Declaration_Node\n+                       (Partial_View)));\n+\n+               --  Search through aspects present on the private type\n+\n+               while Present (Curr_Aspect_Spec) loop\n+                  if Get_Aspect_Id (Curr_Aspect_Spec)\n+                       = Aspect_No_Controlled_Parts\n+                  then\n+                     Aspect_Spec := Curr_Aspect_Spec;\n+                     exit;\n+                  end if;\n+\n+                  Next (Curr_Aspect_Spec);\n+               end loop;\n+\n+            end if;\n+\n+            --  When errors are posted on the aspect return Empty\n+\n+            if Error_Posted (Aspect_Spec) then\n+               return Empty;\n+            end if;\n+\n+            return Aspect_Spec;\n+         end Find_Aspect_No_Controlled_Parts;\n+\n+         ------------------------------------------\n+         -- Get_Aspect_No_Controlled_Parts_Value --\n+         ------------------------------------------\n+\n+         function Get_Aspect_No_Controlled_Parts_Value\n+           (Typ : Entity_Id) return Entity_Id\n+         is\n+            Aspect_Spec : constant Entity_Id :=\n+              Find_Aspect_No_Controlled_Parts (Typ);\n+         begin\n+\n+            --  Return the value of the aspect when present\n+\n+            if Present (Aspect_Spec) then\n+\n+               --  No expression is the same as True\n+\n+               if No (Expression (Aspect_Spec)) then\n+                  return Standard_True;\n+               end if;\n+\n+               --  Assume its expression has already been constant folded into\n+               --  a Boolean value and return its value.\n+\n+               return Entity (Expression (Aspect_Spec));\n+            end if;\n+\n+            --  Otherwise, the aspect is not specified - so return Empty\n+\n+            return Empty;\n+         end Get_Aspect_No_Controlled_Parts_Value;\n+\n+         ------------------------------------\n+         -- Has_Aspect_No_Controlled_Parts --\n+         ------------------------------------\n+\n+         function Has_Aspect_No_Controlled_Parts\n+           (Typ : Entity_Id) return Boolean\n+         is (Present (Find_Aspect_No_Controlled_Parts (Typ)));\n+\n+         --  Generic instances\n+\n+         -------------------------------------------\n+         -- Get_Generic_Formal_Types_In_Hierarchy --\n+         -------------------------------------------\n+\n+         function Get_Generic_Formal_Types_In_Hierarchy\n+           is new Collect_Types_In_Hierarchy (Predicate => Is_Generic_Formal);\n+         --  Return a list of all types within a given type's hierarchy which\n+         --  are generic formals.\n+\n+         ----------------------------------------\n+         -- Get_Types_With_Aspect_In_Hierarchy --\n+         ----------------------------------------\n+\n+         function Get_Types_With_Aspect_In_Hierarchy\n+           is new Collect_Types_In_Hierarchy\n+                    (Predicate => Has_Aspect_No_Controlled_Parts);\n+         --  Returns a list of all types within a given type's hierarchy which\n+         --  have the aspect No_Controlled_Parts specified.\n+\n+         --  Local declarations\n+\n+         Types_With_Aspect : Elist_Id :=\n+           Get_Types_With_Aspect_In_Hierarchy (Typ);\n+\n+         Aspect_Value     : Entity_Id;\n+         Curr_Value       : Entity_Id;\n+         Curr_Typ_Elmt    : Elmt_Id;\n+         Curr_Body_Elmt   : Elmt_Id;\n+         Curr_Formal_Elmt : Elmt_Id;\n+         Gen_Bodies       : Elist_Id;\n+         Gen_Formals      : Elist_Id;\n+         Scop             : Entity_Id;\n+\n+      --  Start of processing for Check_No_Controlled_Parts_Violations\n+\n+      begin\n+         --  There are no types with No_Controlled_Parts specified, so there\n+         --  is nothing to check.\n+\n+         if Is_Empty_Elmt_List (Types_With_Aspect)\n+           or else not Comes_From_Source (Typ)\n+         then\n+            return;\n+         end if;\n+\n+         --  Obtain the aspect value for No_Controlled_Parts for comparison\n+\n+         Aspect_Value :=\n+           Get_Aspect_No_Controlled_Parts_Value\n+             (Node (First_Elmt (Types_With_Aspect)));\n+\n+         --  When the value is True and there are controlled parts or the type\n+         --  itself is controlled, trigger the appropriate error.\n+\n+         if Aspect_Value = Standard_True\n+           and then (Is_Controlled (Typ)\n+                      or else Has_Controlled_Component (Typ))\n+         then\n+            Error_Msg_N\n+              (\"aspect No_Controlled_Parts applied to controlled type &\", Typ);\n+         end if;\n+\n+         --  Move through Types_With_Aspect - checking that the value specified\n+         --  for their corresponding No_Controlled_Parts aspects do not\n+         --  override each other.\n+\n+         Curr_Typ_Elmt := First_Elmt (Types_With_Aspect);\n+         while Present (Curr_Typ_Elmt) loop\n+            Curr_Value :=\n+              Get_Aspect_No_Controlled_Parts_Value (Node (Curr_Typ_Elmt));\n+\n+            --  Compare the aspect value against the current type\n+\n+            if Curr_Value /= Aspect_Value then\n+               Error_Msg_NE\n+                 (\"cannot override aspect No_Controlled_Parts of \"\n+                   & \"ancestor type &\", Typ, Node (Curr_Typ_Elmt));\n+               return;\n+            end if;\n+\n+            Next_Elmt (Curr_Typ_Elmt);\n+         end loop;\n+\n+         --  Issue an error if the aspect applies to a type declared inside a\n+         --  generic body and if said type derives from or has a component of\n+         --  a generic formal type - since those are considered to be both\n+         --  controlled and have aspect No_Controlled_Parts specified as False\n+         --  by default (RM H.4.1(4/5)).\n+\n+         --  We do not check tagged types since deriving from a formal type\n+         --  within an enclosing generic unit is already illegal\n+         --  (RM 3.9.1 (4/2)).\n+\n+         if Aspect_Value = Standard_True\n+           and then In_Generic_Body (Typ)\n+           and then not Is_Tagged_Type (Typ)\n+         then\n+            Gen_Bodies  := New_Elmt_List;\n+            Gen_Formals :=\n+              Get_Generic_Formal_Types_In_Hierarchy\n+                (Typ                => Typ,\n+                 Examine_Components => True);\n+\n+            --  Climb scopes collecting generic bodies\n+\n+            Scop := Scope (Typ);\n+            while Present (Scop) and then Scop /= Standard_Standard loop\n+\n+               --  Generic package body\n+\n+               if Ekind (Scop) = E_Generic_Package\n+                 and then In_Package_Body (Scop)\n+               then\n+                  Append_Elmt (Scop, Gen_Bodies);\n+\n+               --  Generic subprogram body\n+\n+               elsif Is_Generic_Subprogram (Scop) then\n+                  Append_Elmt (Scop, Gen_Bodies);\n+               end if;\n+\n+               Scop := Scope (Scop);\n+            end loop;\n+\n+            --  Warn about the improper use of No_Controlled_Parts on a type\n+            --  declaration deriving from or that has a component of a generic\n+            --  formal type within the formal type's corresponding generic\n+            --  body by moving through all formal types in Typ's hierarchy and\n+            --  checking if they are formals in any of the enclosing generic\n+            --  bodies.\n+\n+            --  However, a special exception gets made for formal types which\n+            --  derive from a type which has No_Controlled_Parts True.\n+\n+            --  For example:\n+\n+            --  generic\n+            --     type Form is private;\n+            --  package G is\n+            --     type Type_A is new Form with No_Controlled_Parts; --  OK\n+            --  end;\n+            --\n+            --  package body G is\n+            --     type Type_B is new Form with No_Controlled_Parts; --  ERROR\n+            --  end;\n+\n+            --  generic\n+            --     type Form is private;\n+            --  package G is\n+            --     type Type_A is record C : Form; end record\n+            --       with No_Controlled_Parts;                       --  OK\n+            --  end;\n+            --\n+            --  package body G is\n+            --     type Type_B is record C : Form; end record\n+            --       with No_Controlled_Parts;                       --  ERROR\n+            --  end;\n+\n+            --  type Root is tagged null record with No_Controlled_Parts;\n+            --\n+            --  generic\n+            --     type Form is new Root with private;\n+            --  package G is\n+            --     type Type_A is record C : Form; end record\n+            --       with No_Controlled_Parts;                       --  OK\n+            --  end;\n+            --\n+            --  package body G is\n+            --     type Type_B is record C : Form; end record\n+            --       with No_Controlled_Parts;                       --  OK\n+            --  end;\n+\n+            Curr_Formal_Elmt := First_Elmt (Gen_Formals);\n+            while Present (Curr_Formal_Elmt) loop\n+\n+               Curr_Body_Elmt := First_Elmt (Gen_Bodies);\n+               while Present (Curr_Body_Elmt) loop\n+\n+                  --  Obtain types in the formal type's hierarchy which have\n+                  --  the aspect specified.\n+\n+                  Types_With_Aspect :=\n+                    Get_Types_With_Aspect_In_Hierarchy\n+                      (Node (Curr_Formal_Elmt));\n+\n+                  --  We found a type declaration in a generic body where both\n+                  --  No_Controlled_Parts is true and one of its ancestors is a\n+                  --  generic formal type.\n+\n+                  if Scope (Node (Curr_Formal_Elmt)) =\n+                       Node (Curr_Body_Elmt)\n+\n+                    --  Check that no ancestors of the formal type have\n+                    --  No_Controlled_Parts True before issuing the error.\n+\n+                    and then (Is_Empty_Elmt_List (Types_With_Aspect)\n+                               or else\n+                                 Get_Aspect_No_Controlled_Parts_Value\n+                                   (Node (First_Elmt (Types_With_Aspect)))\n+                                  = Standard_False)\n+                  then\n+                     Error_Msg_Node_1 := Typ;\n+                     Error_Msg_Node_2 := Node (Curr_Formal_Elmt);\n+                     Error_Msg\n+                       (\"aspect No_Controlled_Parts cannot be applied to \"\n+                         & \"type & which has an ancestor or component of \"\n+                         & \"formal type & within the formal type's \"\n+                         & \"corresponding generic body\", Sloc (Typ));\n+                  end if;\n+\n+                  Next_Elmt (Curr_Body_Elmt);\n+               end loop;\n+\n+               Next_Elmt (Curr_Formal_Elmt);\n+            end loop;\n+         end if;\n+      end Check_No_Controlled_Parts_Violations;\n+\n       ---------------------------------\n       -- Check_Suspicious_Convention --\n       ---------------------------------\n@@ -6801,6 +7161,16 @@ package body Freeze is\n             end;\n          end if;\n \n+         --  Verify at this point that No_Controlled_Parts, when specified on\n+         --  the current type or one of its ancestors, has not been overridden\n+         --  and that no violation of the aspect has occurred.\n+\n+         --  It is important that we perform the checks here after the type has\n+         --  been processed because if said type depended on a private type it\n+         --  will not have been marked controlled.\n+\n+         Check_No_Controlled_Parts_Violations (E);\n+\n          --  End of freeze processing for type entities\n       end if;\n "}, {"sha": "e77a835166f173b32f9a004917a31cd37b57e9f4", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=7a6303e53b4d2328eb43c933f2cbd7f53526962c", "patch": "@@ -1816,6 +1816,13 @@ package body Sem_Ch13 is\n       Aspect := First (L);\n       Aspect_Loop : while Present (Aspect) loop\n          Analyze_One_Aspect : declare\n+\n+            Aspect_Exit : exception;\n+            --  This exception is used to exit aspect processing completely. It\n+            --  is used when an error is detected, and no further processing is\n+            --  required. It is also used if an earlier error has left the tree\n+            --  in a state where the aspect should not be processed.\n+\n             Expr : constant Node_Id    := Expression (Aspect);\n             Id   : constant Node_Id    := Identifier (Aspect);\n             Loc  : constant Source_Ptr := Sloc (Aspect);\n@@ -1854,6 +1861,17 @@ package body Sem_Ch13 is\n             procedure Analyze_Aspect_Static;\n             --  Ada 202x (AI12-0075): Perform analysis of aspect Static\n \n+            procedure Check_Expr_Is_OK_Static_Expression\n+              (Expr : Node_Id;\n+               Typ  : Entity_Id := Empty);\n+            --  Check the specified expression Expr to make sure that it is a\n+            --  static expression of the given type (i.e. it will be analyzed\n+            --  and resolved using this type, which can be any valid argument\n+            --  to Resolve, e.g. Any_Integer is OK). If not, give an error\n+            --  and raise Aspect_Exit. If Typ is left Empty, then any static\n+            --  expression is allowed. Includes checking that the expression\n+            --  does not raise Constraint_Error.\n+\n             function Make_Aitem_Pragma\n               (Pragma_Argument_Associations : List_Id;\n                Pragma_Name                  : Name_Id) return Node_Id;\n@@ -2711,6 +2729,42 @@ package body Sem_Ch13 is\n                end if;\n             end Analyze_Aspect_Yield;\n \n+            ----------------------------------------\n+            -- Check_Expr_Is_OK_Static_Expression --\n+            ----------------------------------------\n+\n+            procedure Check_Expr_Is_OK_Static_Expression\n+              (Expr : Node_Id;\n+               Typ  : Entity_Id := Empty)\n+            is\n+            begin\n+               if Present (Typ) then\n+                  Analyze_And_Resolve (Expr, Typ);\n+               else\n+                  Analyze_And_Resolve (Expr);\n+               end if;\n+\n+               --  An expression cannot be considered static if its resolution\n+               --  failed or if it's erroneous. Stop the analysis of the\n+               --  related aspect.\n+\n+               if Etype (Expr) = Any_Type or else Error_Posted (Expr) then\n+                  raise Aspect_Exit;\n+\n+               elsif Is_OK_Static_Expression (Expr) then\n+                  return;\n+\n+               --  Finally, we have a real error\n+\n+               else\n+                  Error_Msg_Name_1 := Nam;\n+                  Flag_Non_Static_Expr\n+                    (\"entity for aspect% must be a static expression\",\n+                     Expr);\n+                  raise Aspect_Exit;\n+               end if;\n+            end Check_Expr_Is_OK_Static_Expression;\n+\n             -----------------------\n             -- Make_Aitem_Pragma --\n             -----------------------\n@@ -2874,7 +2928,10 @@ package body Sem_Ch13 is\n                --  versions of the language. Allowed for them only for\n                --  shared variable control aspects.\n \n-               if Nkind (N) = N_Formal_Type_Declaration then\n+               --  Original node is used in case expansion rewrote the node -\n+               --  as is the case with generic derived types.\n+\n+               if Nkind (Original_Node (N)) = N_Formal_Type_Declaration then\n                   if Ada_Version < Ada_2020 then\n                      Error_Msg_N\n                        (\"aspect % not allowed for formal type declaration\",\n@@ -3883,6 +3940,32 @@ package body Sem_Ch13 is\n                   Insert_Pragma (Aitem);\n                   goto Continue;\n \n+               --  No_Controlled_Parts\n+\n+               when Aspect_No_Controlled_Parts =>\n+\n+                  --  Check appropriate type argument\n+\n+                  if not Is_Type (E) then\n+                     Error_Msg_N\n+                       (\"aspect % can only be applied to types\", E);\n+                  end if;\n+\n+                  --  Disallow subtypes\n+\n+                  if Nkind (Declaration_Node (E)) = N_Subtype_Declaration then\n+                     Error_Msg_N\n+                       (\"aspect % cannot be applied to subtypes\", E);\n+                  end if;\n+\n+                  --  Resolve the expression to a boolean\n+\n+                  if Present (Expr) then\n+                     Check_Expr_Is_OK_Static_Expression (Expr, Any_Boolean);\n+                  end if;\n+\n+                  goto Continue;\n+\n                --  Obsolescent\n \n                when Aspect_Obsolescent => declare\n@@ -4860,6 +4943,8 @@ package body Sem_Ch13 is\n                   end if;\n                end;\n             end if;\n+         exception\n+            when Aspect_Exit => null;\n          end Analyze_One_Aspect;\n \n          Next (Aspect);\n@@ -10996,6 +11081,7 @@ package body Sem_Ch13 is\n             | Aspect_Max_Entry_Queue_Length\n             | Aspect_Max_Queue_Length\n             | Aspect_No_Caching\n+            | Aspect_No_Controlled_Parts\n             | Aspect_Obsolescent\n             | Aspect_Part_Of\n             | Aspect_Post"}, {"sha": "b2049d516a4589652e077a4731fbcac4e5bfad07", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7a6303e53b4d2328eb43c933f2cbd7f53526962c", "patch": "@@ -6654,6 +6654,99 @@ package body Sem_Util is\n       return N;\n    end Compile_Time_Constraint_Error;\n \n+   --------------------------------\n+   -- Collect_Types_In_Hierarchy --\n+   --------------------------------\n+\n+   function Collect_Types_In_Hierarchy\n+     (Typ                : Entity_Id;\n+      Examine_Components : Boolean := False) return Elist_Id\n+   is\n+      Results : Elist_Id;\n+\n+      procedure Process_Type (Typ : Entity_Id);\n+      --  Collect type Typ if it satisfies function Predicate. Do so for its\n+      --  parent type, base type, progenitor types, and any component types.\n+\n+      ------------------\n+      -- Process_Type --\n+      ------------------\n+\n+      procedure Process_Type (Typ : Entity_Id) is\n+         Comp       : Entity_Id;\n+         Iface_Elmt : Elmt_Id;\n+\n+      begin\n+         if not Is_Type (Typ) or else Error_Posted (Typ) then\n+            return;\n+         end if;\n+\n+         --  Collect the current type if it satisfies the predicate\n+\n+         if Predicate (Typ) then\n+            Append_Elmt (Typ, Results);\n+         end if;\n+\n+         --  Process component types\n+\n+         if Examine_Components then\n+\n+            --  Examine components and discriminants\n+\n+            if Is_Concurrent_Type (Typ)\n+              or else Is_Incomplete_Or_Private_Type (Typ)\n+              or else Is_Record_Type (Typ)\n+              or else Has_Discriminants (Typ)\n+            then\n+               Comp := First_Component_Or_Discriminant (Typ);\n+\n+               while Present (Comp) loop\n+                  Process_Type (Etype (Comp));\n+\n+                  Next_Component_Or_Discriminant (Comp);\n+               end loop;\n+\n+            --  Examine array components\n+\n+            elsif Ekind (Typ) = E_Array_Type then\n+               Process_Type (Component_Type (Typ));\n+            end if;\n+         end if;\n+\n+         --  Examine parent type\n+\n+         if Etype (Typ) /= Typ then\n+            Process_Type (Etype (Typ));\n+         end if;\n+\n+         --  Examine base type\n+\n+         if Base_Type (Typ) /= Typ then\n+            Process_Type (Base_Type (Typ));\n+         end if;\n+\n+         --  Examine interfaces\n+\n+         if Is_Record_Type (Typ)\n+           and then Present (Interfaces (Typ))\n+         then\n+            Iface_Elmt := First_Elmt (Interfaces (Typ));\n+            while Present (Iface_Elmt) loop\n+               Process_Type (Node (Iface_Elmt));\n+\n+               Next_Elmt (Iface_Elmt);\n+            end loop;\n+         end if;\n+      end Process_Type;\n+\n+   --  Start of processing for Collect_Types_In_Hierarchy\n+\n+   begin\n+      Results := New_Elmt_List;\n+      Process_Type (Typ);\n+      return Results;\n+   end Collect_Types_In_Hierarchy;\n+\n    -----------------------\n    -- Conditional_Delay --\n    -----------------------"}, {"sha": "1c60c9f832b0c8f644e451b2fdb2585356529094", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7a6303e53b4d2328eb43c933f2cbd7f53526962c", "patch": "@@ -581,6 +581,18 @@ package Sem_Util is\n    --  emitted immediately after the main message (and before output of any\n    --  message indicating that Constraint_Error will be raised).\n \n+   generic\n+      with function Predicate (Typ : Entity_Id) return Boolean;\n+   function Collect_Types_In_Hierarchy\n+     (Typ                : Entity_Id;\n+      Examine_Components : Boolean := False) return Elist_Id;\n+   --  Inspect the ancestor and progenitor types of Typ and Typ itself -\n+   --  collecting those for which function Predicate is True. The resulting\n+   --  list is ordered in a type-to-ultimate-ancestor fashion.\n+\n+   --  When Examine_Components is True, components types in the hierarchy also\n+   --  get collected.\n+\n    procedure Conditional_Delay (New_Ent, Old_Ent : Entity_Id);\n    --  Sets the Has_Delayed_Freeze flag of New_Ent if the Delayed_Freeze flag\n    --  of Old_Ent is set and Old_Ent has not yet been Frozen (i.e. Is_Frozen is"}, {"sha": "706a56216c08d5297a20354aad161e00a7364a93", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6303e53b4d2328eb43c933f2cbd7f53526962c/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=7a6303e53b4d2328eb43c933f2cbd7f53526962c", "patch": "@@ -145,6 +145,7 @@ package Snames is\n    Name_Exclusive_Functions            : constant Name_Id := N + $;\n    Name_Full_Access_Only               : constant Name_Id := N + $;\n    Name_Integer_Literal                : constant Name_Id := N + $;\n+   Name_No_Controlled_Parts            : constant Name_Id := N + $;\n    Name_Real_Literal                   : constant Name_Id := N + $;\n    Name_Relaxed_Initialization         : constant Name_Id := N + $;\n    Name_Stable_Properties              : constant Name_Id := N + $;"}]}