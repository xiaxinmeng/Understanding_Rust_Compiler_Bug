{"sha": "4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJkZDQ0YzRiYzVlYzJmMzY1NWU0N2NjNTZhM2FkZTU1ZmVkMmQyNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-18T13:57:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-18T13:57:33Z"}, "message": "tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): Remove cond_expr_stmt_list argument and do not gimplify the built expression.\n\n2013-03-18  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):\n\tRemove cond_expr_stmt_list argument and do not gimplify the\n\tbuilt expression.\n\t(vect_loop_versioning): Adjust.\n\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref):\n\tCleanup to use less temporaries.\n\t(vect_create_data_ref_ptr): Cleanup.\n\nFrom-SVN: r196782", "tree": {"sha": "83d518cdd9f48913018203d9dd9b560d818a6f4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83d518cdd9f48913018203d9dd9b560d818a6f4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38c56a5b2121ab8f12e153e02cea4da777689ce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c56a5b2121ab8f12e153e02cea4da777689ce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c56a5b2121ab8f12e153e02cea4da777689ce4"}], "stats": {"total": 135, "additions": 53, "deletions": 82}, "files": [{"sha": "7cdca5fc88ace06f02576d8b64e44bff5cda3251", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "patch": "@@ -1,3 +1,13 @@\n+2013-03-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):\n+\tRemove cond_expr_stmt_list argument and do not gimplify the\n+\tbuilt expression.\n+\t(vect_loop_versioning): Adjust.\n+\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref):\n+\tCleanup to use less temporaries.\n+\t(vect_create_data_ref_ptr): Cleanup.\n+\n 2013-03-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/56635"}, {"sha": "a4ad4f754a883de65556e14e06d0ecc503fb4dba", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 33, "deletions": 67, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "patch": "@@ -3470,19 +3470,16 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  tree data_ref_base = unshare_expr (DR_BASE_ADDRESS (dr));\n+  tree data_ref_base;\n   const char *base_name;\n-  tree data_ref_base_var;\n-  tree vec_stmt;\n-  tree addr_base, addr_expr;\n+  tree addr_base;\n   tree dest;\n   gimple_seq seq = NULL;\n-  tree base_offset = unshare_expr (DR_OFFSET (dr));\n-  tree init = unshare_expr (DR_INIT (dr));\n+  tree base_offset;\n+  tree init;\n   tree vect_ptr_type;\n   tree step = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  tree base;\n \n   if (loop_vinfo && loop && loop != (gimple_bb (stmt))->loop_father)\n     {\n@@ -3494,6 +3491,12 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n       base_offset = unshare_expr (STMT_VINFO_DR_OFFSET (stmt_info));\n       init = unshare_expr (STMT_VINFO_DR_INIT (stmt_info));\n     }\n+  else\n+    {\n+      data_ref_base = unshare_expr (DR_BASE_ADDRESS (dr));\n+      base_offset = unshare_expr (DR_OFFSET (dr));\n+      init = unshare_expr (DR_INIT (dr));\n+    }\n \n   if (loop_vinfo)\n     base_name = get_name (data_ref_base);\n@@ -3504,29 +3507,17 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n       base_name = get_name (DR_REF (dr));\n     }\n \n-  data_ref_base_var = create_tmp_var (TREE_TYPE (data_ref_base), \"batmp\");\n-  data_ref_base = force_gimple_operand (data_ref_base, &seq, true,\n-\t\t\t\t\tdata_ref_base_var);\n-  gimple_seq_add_seq (new_stmt_list, seq);\n-\n   /* Create base_offset */\n   base_offset = size_binop (PLUS_EXPR,\n \t\t\t    fold_convert (sizetype, base_offset),\n \t\t\t    fold_convert (sizetype, init));\n-  dest = create_tmp_var (sizetype, \"base_off\");\n-  base_offset = force_gimple_operand (base_offset, &seq, true, dest);\n-  gimple_seq_add_seq (new_stmt_list, seq);\n \n   if (offset)\n     {\n-      tree tmp = create_tmp_var (sizetype, \"offset\");\n-\n       offset = fold_build2 (MULT_EXPR, sizetype,\n \t\t\t    fold_convert (sizetype, offset), step);\n       base_offset = fold_build2 (PLUS_EXPR, sizetype,\n \t\t\t\t base_offset, offset);\n-      base_offset = force_gimple_operand (base_offset, &seq, false, tmp);\n-      gimple_seq_add_seq (new_stmt_list, seq);\n     }\n \n   /* base + base_offset */\n@@ -3540,34 +3531,26 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n     }\n \n   vect_ptr_type = build_pointer_type (STMT_VINFO_VECTYPE (stmt_info));\n-  base = get_base_address (DR_REF (dr));\n-  if (base\n-      && TREE_CODE (base) == MEM_REF)\n-    vect_ptr_type\n-      = build_qualified_type (vect_ptr_type,\n-\t\t\t      TYPE_QUALS (TREE_TYPE (TREE_OPERAND (base, 0))));\n-\n-  vec_stmt = fold_convert (vect_ptr_type, addr_base);\n-  addr_expr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n-                                     base_name);\n-  vec_stmt = force_gimple_operand (vec_stmt, &seq, false, addr_expr);\n+  addr_base = fold_convert (vect_ptr_type, addr_base);\n+  dest = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var, base_name);\n+  addr_base = force_gimple_operand (addr_base, &seq, false, dest);\n   gimple_seq_add_seq (new_stmt_list, seq);\n \n   if (DR_PTR_INFO (dr)\n-      && TREE_CODE (vec_stmt) == SSA_NAME)\n+      && TREE_CODE (addr_base) == SSA_NAME)\n     {\n-      duplicate_ssa_name_ptr_info (vec_stmt, DR_PTR_INFO (dr));\n+      duplicate_ssa_name_ptr_info (addr_base, DR_PTR_INFO (dr));\n       if (offset)\n-\tmark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (vec_stmt));\n+\tmark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (addr_base));\n     }\n \n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"created \");\n-      dump_generic_expr (MSG_NOTE, TDF_SLIM, vec_stmt);\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, addr_base);\n     }\n \n-  return vec_stmt;\n+  return addr_base;\n }\n \n \n@@ -3647,7 +3630,6 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n   gimple incr;\n   tree step;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n-  tree base;\n \n   gcc_assert (TREE_CODE (aggr_type) == ARRAY_TYPE\n \t      || TREE_CODE (aggr_type) == VECTOR_TYPE);\n@@ -3699,53 +3681,37 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_BASE_OBJECT (dr));\n     }\n \n-  /* (1) Create the new aggregate-pointer variable.  */\n-  aggr_ptr_type = build_pointer_type (aggr_type);\n-  base = get_base_address (DR_REF (dr));\n-  if (base\n-      && TREE_CODE (base) == MEM_REF)\n-    aggr_ptr_type\n-      = build_qualified_type (aggr_ptr_type,\n-\t\t\t      TYPE_QUALS (TREE_TYPE (TREE_OPERAND (base, 0))));\n-  aggr_ptr = vect_get_new_vect_var (aggr_ptr_type, vect_pointer_var, base_name);\n-\n-  /* Vector and array types inherit the alias set of their component\n+  /* (1) Create the new aggregate-pointer variable.\n+     Vector and array types inherit the alias set of their component\n      type by default so we need to use a ref-all pointer if the data\n      reference does not conflict with the created aggregated data\n      reference because it is not addressable.  */\n-  if (!alias_sets_conflict_p (get_deref_alias_set (aggr_ptr),\n+  bool need_ref_all = false;\n+  if (!alias_sets_conflict_p (get_alias_set (aggr_type),\n \t\t\t      get_alias_set (DR_REF (dr))))\n-    {\n-      aggr_ptr_type\n-\t= build_pointer_type_for_mode (aggr_type,\n-\t\t\t\t       TYPE_MODE (aggr_ptr_type), true);\n-      aggr_ptr = vect_get_new_vect_var (aggr_ptr_type, vect_pointer_var,\n-\t\t\t\t\tbase_name);\n-    }\n-\n+    need_ref_all = true;\n   /* Likewise for any of the data references in the stmt group.  */\n   else if (STMT_VINFO_GROUP_SIZE (stmt_info) > 1)\n     {\n       gimple orig_stmt = STMT_VINFO_GROUP_FIRST_ELEMENT (stmt_info);\n       do\n \t{\n-\t  tree lhs = gimple_assign_lhs (orig_stmt);\n-\t  if (!alias_sets_conflict_p (get_deref_alias_set (aggr_ptr),\n-\t\t\t\t      get_alias_set (lhs)))\n+\t  stmt_vec_info sinfo = vinfo_for_stmt (orig_stmt);\n+\t  struct data_reference *sdr = STMT_VINFO_DATA_REF (sinfo);\n+\t  if (!alias_sets_conflict_p (get_alias_set (aggr_type),\n+\t\t\t\t      get_alias_set (DR_REF (sdr))))\n \t    {\n-\t      aggr_ptr_type\n-\t\t= build_pointer_type_for_mode (aggr_type,\n-\t\t\t\t\t       TYPE_MODE (aggr_ptr_type), true);\n-\t      aggr_ptr\n-\t\t= vect_get_new_vect_var (aggr_ptr_type, vect_pointer_var,\n-\t\t\t\t\t base_name);\n+\t      need_ref_all = true;\n \t      break;\n \t    }\n-\n-\t  orig_stmt = STMT_VINFO_GROUP_NEXT_ELEMENT (vinfo_for_stmt (orig_stmt));\n+\t  orig_stmt = STMT_VINFO_GROUP_NEXT_ELEMENT (sinfo);\n \t}\n       while (orig_stmt);\n     }\n+  aggr_ptr_type = build_pointer_type_for_mode (aggr_type, ptr_mode,\n+\t\t\t\t\t       need_ref_all);\n+  aggr_ptr = vect_get_new_vect_var (aggr_ptr_type, vect_pointer_var, base_name);\n+\n \n   /* Note: If the dataref is in an inner-loop nested in LOOP, and we are\n      vectorizing LOOP (i.e., outer-loop vectorization), we need to create two"}, {"sha": "ff7d53f25914e30688efbd15bfcd11c890a8072b", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "patch": "@@ -2271,20 +2271,14 @@ vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n \n    Output:\n    COND_EXPR - conditional expression.\n-   COND_EXPR_STMT_LIST - statements needed to construct the conditional\n-                         expression.\n-\n \n    The returned value is the conditional expression to be used in the if\n    statement that controls which version of the loop gets executed at runtime.\n */\n \n static void\n-vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n-\t\t\t\t   tree * cond_expr,\n-\t\t\t\t   gimple_seq * cond_expr_stmt_list)\n+vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n {\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   vec<ddr_p>  may_alias_ddrs =\n     LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n   int vect_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n@@ -2333,12 +2327,14 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \t  dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_b));\n \t}\n \n-      addr_base_a =\n-        vect_create_addr_base_for_vector_ref (stmt_a, cond_expr_stmt_list,\n-\t\t\t\t\t      NULL_TREE, loop);\n-      addr_base_b =\n-        vect_create_addr_base_for_vector_ref (stmt_b, cond_expr_stmt_list,\n-\t\t\t\t\t      NULL_TREE, loop);\n+      addr_base_a\n+\t= fold_build_pointer_plus (DR_BASE_ADDRESS (dr_a),\n+\t\t\t\t   size_binop (PLUS_EXPR, DR_OFFSET (dr_a),\n+\t\t\t\t\t       DR_INIT (dr_a)));\n+      addr_base_b\n+\t= fold_build_pointer_plus (DR_BASE_ADDRESS (dr_b),\n+\t\t\t\t   size_binop (PLUS_EXPR, DR_OFFSET (dr_b),\n+\t\t\t\t\t       DR_INIT (dr_b)));\n \n       if (!operand_equal_p (DR_STEP (dr_a), DR_STEP (dr_b), 0))\n \tlength_factor = scalar_loop_iters;\n@@ -2435,8 +2431,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \t\t\t\t       &cond_expr_stmt_list);\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))\n-    vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr,\n-\t\t\t\t       &cond_expr_stmt_list);\n+    vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr);\n \n   cond_expr = force_gimple_operand_1 (cond_expr, &gimplify_stmt_list,\n \t\t\t\t      is_gimple_condexpr, NULL_TREE);"}]}