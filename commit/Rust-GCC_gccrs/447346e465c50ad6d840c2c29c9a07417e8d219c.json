{"sha": "447346e465c50ad6d840c2c29c9a07417e8d219c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ3MzQ2ZTQ2NWM1MGFkNmQ4NDBjMmMyOWM5YTA3NDE3ZThkMjE5Yw==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2018-03-06T21:43:03Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2018-03-06T21:43:03Z"}, "message": "re PR libstdc++/84601 (std::optional<std::pair<int, int>> is not assignment copyable)\n\nPR libstdc++/84601\n* include/std/optional (_Optional_payload): Split into multiple\nspecializations that can handle different cases of trivial or\nnon-trivial assignment operators.\n* testsuite/20_util/optional/84601.cc: New.\n* testsuite/20_util/optional/cons/value_neg.cc: Adjust.\n\nFrom-SVN: r258304", "tree": {"sha": "56cf39d2d50ac52cbb5d0f09f3d1202d629673e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56cf39d2d50ac52cbb5d0f09f3d1202d629673e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/447346e465c50ad6d840c2c29c9a07417e8d219c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447346e465c50ad6d840c2c29c9a07417e8d219c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/447346e465c50ad6d840c2c29c9a07417e8d219c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/447346e465c50ad6d840c2c29c9a07417e8d219c/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dc23505191d6ac79af9d403e7c543addd760ebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc23505191d6ac79af9d403e7c543addd760ebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dc23505191d6ac79af9d403e7c543addd760ebd"}], "stats": {"total": 457, "additions": 428, "deletions": 29}, "files": [{"sha": "b0b3a956ace8a0582944b4e81d420cf974e9bb09", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447346e465c50ad6d840c2c29c9a07417e8d219c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447346e465c50ad6d840c2c29c9a07417e8d219c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=447346e465c50ad6d840c2c29c9a07417e8d219c", "patch": "@@ -1,3 +1,12 @@\n+2018-03-06  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tPR libstdc++/84601\n+\t* include/std/optional (_Optional_payload): Split into multiple\n+\tspecializations that can handle different cases of trivial or\n+\tnon-trivial assignment operators.\n+\t* testsuite/20_util/optional/84601.cc: New.\n+\t* testsuite/20_util/optional/cons/value_neg.cc: Adjust.\n+\n 2018-03-02  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/84671"}, {"sha": "0aa20dd94374588d2f435e6a1d51a8f3a535f67b", "filename": "libstdc++-v3/include/std/optional", "status": "modified", "additions": 394, "deletions": 26, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447346e465c50ad6d840c2c29c9a07417e8d219c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447346e465c50ad6d840c2c29c9a07417e8d219c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=447346e465c50ad6d840c2c29c9a07417e8d219c", "patch": "@@ -98,11 +98,135 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }\n \n \n-  // Payload for constexpr optionals.\n+  // Payload for optionals with non-trivial destructor.\n   template <typename _Tp,\n \t    bool /*_HasTrivialDestructor*/ =\n-\t      is_trivially_destructible<_Tp>::value>\n+\t      is_trivially_destructible<_Tp>::value,\n+\t    bool /*_HasTrivialCopyAssignment*/ =\n+\t      is_trivially_copy_assignable<_Tp>::value,\n+\t    bool /*_HasTrivialMoveAssignment*/ =\n+\t      is_trivially_move_assignable<_Tp>::value>\n     struct _Optional_payload\n+    {\n+      constexpr _Optional_payload()\n+\t: _M_empty() {}\n+\n+      template <typename... _Args>\n+      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...),\n+\t  _M_engaged(true) {}\n+\n+      template<typename _Up, typename... _Args>\n+      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t\t  _Args&&... __args)\n+\t: _M_payload(__il, std::forward<_Args>(__args)...),\n+\t  _M_engaged(true) {}\n+      constexpr\n+      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n+\t: _Optional_payload(__other)\n+      {}\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n+\t: _Optional_payload(std::move(__other))\n+      {}\n+\n+      constexpr _Optional_payload(const _Optional_payload& __other)\n+      {\n+\tif (__other._M_engaged)\n+\t  this->_M_construct(__other._M_payload);\n+      }\n+\n+      constexpr _Optional_payload(_Optional_payload&& __other)\n+      {\n+\tif (__other._M_engaged)\n+\t  this->_M_construct(std::move(__other._M_payload));\n+      }\n+\n+      _Optional_payload&\n+      operator=(const _Optional_payload& __other)\n+      {\n+        if (this->_M_engaged && __other._M_engaged)\n+          this->_M_get() = __other._M_get();\n+        else\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(__other._M_get());\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n+      }\n+\n+      _Optional_payload&\n+      operator=(_Optional_payload&& __other)\n+      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n+\t\t      is_nothrow_move_assignable<_Tp>>())\n+      {\n+\tif (this->_M_engaged && __other._M_engaged)\n+\t  this->_M_get() = std::move(__other._M_get());\n+\telse\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(std::move(__other._M_get()));\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n+      }\n+\n+      using _Stored_type = remove_const_t<_Tp>;\n+      struct _Empty_byte { };\n+      union {\n+          _Empty_byte _M_empty;\n+          _Stored_type _M_payload;\n+      };\n+      bool _M_engaged = false;\n+\n+      ~_Optional_payload()\n+      {\n+        if (_M_engaged)\n+          _M_payload.~_Stored_type();\n+      }\n+\n+      template<typename... _Args>\n+        void\n+        _M_construct(_Args&&... __args)\n+        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        {\n+          ::new ((void *) std::__addressof(this->_M_payload))\n+            _Stored_type(std::forward<_Args>(__args)...);\n+          this->_M_engaged = true;\n+        }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+\t_M_get() noexcept\n+      {\n+\treturn this->_M_payload;\n+      }\n+\n+      constexpr const _Tp&\n+\t_M_get() const noexcept\n+      {\n+\treturn this->_M_payload;\n+      }\n+\n+      // _M_reset is a 'safe' operation with no precondition.\n+      void\n+      _M_reset() noexcept\n+      {\n+\tif (this->_M_engaged)\n+\t  {\n+\t    this->_M_engaged = false;\n+\t    this->_M_payload.~_Stored_type();\n+\t  }\n+      }\n+    };\n+\n+  // Payload for constexpr optionals.\n+  template <typename _Tp>\n+    struct _Optional_payload<_Tp, true, true, true>\n     {\n       constexpr _Optional_payload()\n \t: _M_empty(), _M_engaged(false) {}\n@@ -161,44 +285,294 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool _M_engaged;\n     };\n \n-  // Payload for optionals with non-trivial destructor.\n+  // Payload for optionals with non-trivial copy assignment.\n   template <typename _Tp>\n-    struct _Optional_payload<_Tp, false>\n+    struct _Optional_payload<_Tp, true, false, true>\n     {\n       constexpr _Optional_payload()\n-\t: _M_empty() {}\n+\t: _M_empty(), _M_engaged(false) {}\n \n-      template <typename... _Args>\n+      template<typename... _Args>\n       constexpr _Optional_payload(in_place_t, _Args&&... __args)\n \t: _M_payload(std::forward<_Args>(__args)...),\n+\t  _M_engaged(true)\n+      {}\n+\n+      template<typename _Up, typename... _Args>\n+      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t\t  _Args&&... __args)\n+\t: _M_payload(__il, std::forward<_Args>(__args)...),\n \t  _M_engaged(true) {}\n \n+      template <class _Up> struct __ctor_tag {};\n+\n+      constexpr _Optional_payload(__ctor_tag<bool>,\n+\t\t\t\t  const _Tp& __other)\n+\t: _M_payload(__other),\n+\t  _M_engaged(true)\n+      {}\n+\n+      constexpr _Optional_payload(__ctor_tag<void>)\n+\t: _M_empty(), _M_engaged(false)\n+      {}\n+\n+      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n+\t: _M_payload(std::move(__other)),\n+\t  _M_engaged(true)\n+      {}\n+\n+      constexpr _Optional_payload(bool __engaged,\n+\t\t\t\t  const _Optional_payload& __other)\n+\t: _Optional_payload(__engaged ?\n+\t\t\t    _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t      __other._M_payload) :\n+\t\t\t    _Optional_payload(__ctor_tag<void>{}))\n+      {}\n+\n+      constexpr _Optional_payload(bool __engaged,\n+\t\t\t\t  _Optional_payload&& __other)\n+\t: _Optional_payload(__engaged\n+\t\t\t    ? _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t\tstd::move(__other._M_payload))\n+\t\t\t    : _Optional_payload(__ctor_tag<void>{}))\n+      {}\n+\n+      _Optional_payload(const _Optional_payload&) = default;\n+      _Optional_payload(_Optional_payload&&) = default;\n+\n+      _Optional_payload&\n+      operator=(const _Optional_payload& __other)\n+      {\n+        if (this->_M_engaged && __other._M_engaged)\n+          this->_M_get() = __other._M_get();\n+        else\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(__other._M_get());\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n+      }\n+\n+      _Optional_payload&\n+      operator=(_Optional_payload&& __other) = default;\n+\n+      using _Stored_type = remove_const_t<_Tp>;\n+      struct _Empty_byte { };\n+      union {\n+          _Empty_byte _M_empty;\n+          _Stored_type _M_payload;\n+      };\n+      bool _M_engaged;\n+\n+      template<typename... _Args>\n+        void\n+        _M_construct(_Args&&... __args)\n+        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        {\n+          ::new ((void *) std::__addressof(this->_M_payload))\n+            _Stored_type(std::forward<_Args>(__args)...);\n+          this->_M_engaged = true;\n+        }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+\t_M_get() noexcept\n+      {\n+\treturn this->_M_payload;\n+      }\n+\n+      constexpr const _Tp&\n+\t_M_get() const noexcept\n+      {\n+\treturn this->_M_payload;\n+      }\n+\n+      // _M_reset is a 'safe' operation with no precondition.\n+      void\n+      _M_reset() noexcept\n+      {\n+\tif (this->_M_engaged)\n+\t  {\n+\t    this->_M_engaged = false;\n+\t    this->_M_payload.~_Stored_type();\n+\t  }\n+      }\n+    };\n+\n+  // Payload for optionals with non-trivial move assignment.\n+  template <typename _Tp>\n+    struct _Optional_payload<_Tp, true, true, false>\n+    {\n+      constexpr _Optional_payload()\n+\t: _M_empty(), _M_engaged(false) {}\n+\n+      template<typename... _Args>\n+      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...),\n+\t  _M_engaged(true)\n+      {}\n+\n       template<typename _Up, typename... _Args>\n       constexpr _Optional_payload(std::initializer_list<_Up> __il,\n \t\t\t\t  _Args&&... __args)\n \t: _M_payload(__il, std::forward<_Args>(__args)...),\n \t  _M_engaged(true) {}\n-      constexpr\n-      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n-\t: _Optional_payload(__other)\n+\n+      template <class _Up> struct __ctor_tag {};\n+\n+      constexpr _Optional_payload(__ctor_tag<bool>,\n+\t\t\t\t  const _Tp& __other)\n+\t: _M_payload(__other),\n+\t  _M_engaged(true)\n       {}\n \n-      constexpr\n-      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n-\t: _Optional_payload(std::move(__other))\n+      constexpr _Optional_payload(__ctor_tag<void>)\n+\t: _M_empty(), _M_engaged(false)\n       {}\n \n-      constexpr _Optional_payload(const _Optional_payload& __other)\n+      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n+\t: _M_payload(std::move(__other)),\n+\t  _M_engaged(true)\n+      {}\n+\n+      constexpr _Optional_payload(bool __engaged,\n+\t\t\t\t  const _Optional_payload& __other)\n+\t: _Optional_payload(__engaged ?\n+\t\t\t    _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t      __other._M_payload) :\n+\t\t\t    _Optional_payload(__ctor_tag<void>{}))\n+      {}\n+\n+      constexpr _Optional_payload(bool __engaged,\n+\t\t\t\t  _Optional_payload&& __other)\n+\t: _Optional_payload(__engaged\n+\t\t\t    ? _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t\tstd::move(__other._M_payload))\n+\t\t\t    : _Optional_payload(__ctor_tag<void>{}))\n+      {}\n+\n+      _Optional_payload(const _Optional_payload&) = default;\n+      _Optional_payload(_Optional_payload&&) = default;\n+\n+      _Optional_payload&\n+      operator=(const _Optional_payload& __other) = default;\n+\n+      _Optional_payload&\n+      operator=(_Optional_payload&& __other)\n+      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n+\t\t      is_nothrow_move_assignable<_Tp>>())\n       {\n-\tif (__other._M_engaged)\n-\t  this->_M_construct(__other._M_payload);\n+\tif (this->_M_engaged && __other._M_engaged)\n+\t  this->_M_get() = std::move(__other._M_get());\n+\telse\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(std::move(__other._M_get()));\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n       }\n \n-      constexpr _Optional_payload(_Optional_payload&& __other)\n+      using _Stored_type = remove_const_t<_Tp>;\n+      struct _Empty_byte { };\n+      union {\n+          _Empty_byte _M_empty;\n+          _Stored_type _M_payload;\n+      };\n+      bool _M_engaged;\n+\n+      template<typename... _Args>\n+        void\n+        _M_construct(_Args&&... __args)\n+        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        {\n+          ::new ((void *) std::__addressof(this->_M_payload))\n+            _Stored_type(std::forward<_Args>(__args)...);\n+          this->_M_engaged = true;\n+        }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+\t_M_get() noexcept\n       {\n-\tif (__other._M_engaged)\n-\t  this->_M_construct(std::move(__other._M_payload));\n+\treturn this->_M_payload;\n+      }\n+\n+      constexpr const _Tp&\n+\t_M_get() const noexcept\n+      {\n+\treturn this->_M_payload;\n+      }\n+\n+      // _M_reset is a 'safe' operation with no precondition.\n+      void\n+      _M_reset() noexcept\n+      {\n+\tif (this->_M_engaged)\n+\t  {\n+\t    this->_M_engaged = false;\n+\t    this->_M_payload.~_Stored_type();\n+\t  }\n       }\n+    };\n+\n+  // Payload for optionals with non-trivial copy and move assignment.\n+  template <typename _Tp>\n+    struct _Optional_payload<_Tp, true, false, false>\n+    {\n+      constexpr _Optional_payload()\n+\t: _M_empty(), _M_engaged(false) {}\n+\n+      template<typename... _Args>\n+      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...),\n+\t  _M_engaged(true)\n+      {}\n+\n+      template<typename _Up, typename... _Args>\n+      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t\t  _Args&&... __args)\n+\t: _M_payload(__il, std::forward<_Args>(__args)...),\n+\t  _M_engaged(true) {}\n+\n+      template <class _Up> struct __ctor_tag {};\n+\n+      constexpr _Optional_payload(__ctor_tag<bool>,\n+\t\t\t\t  const _Tp& __other)\n+\t: _M_payload(__other),\n+\t  _M_engaged(true)\n+      {}\n+\n+      constexpr _Optional_payload(__ctor_tag<void>)\n+\t: _M_empty(), _M_engaged(false)\n+      {}\n+\n+      constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n+\t: _M_payload(std::move(__other)),\n+\t  _M_engaged(true)\n+      {}\n+\n+      constexpr _Optional_payload(bool __engaged,\n+\t\t\t\t  const _Optional_payload& __other)\n+\t: _Optional_payload(__engaged ?\n+\t\t\t    _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t      __other._M_payload) :\n+\t\t\t    _Optional_payload(__ctor_tag<void>{}))\n+      {}\n+\n+      constexpr _Optional_payload(bool __engaged,\n+\t\t\t\t  _Optional_payload&& __other)\n+\t: _Optional_payload(__engaged\n+\t\t\t    ? _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t\tstd::move(__other._M_payload))\n+\t\t\t    : _Optional_payload(__ctor_tag<void>{}))\n+      {}\n+\n+      _Optional_payload(const _Optional_payload&) = default;\n+      _Optional_payload(_Optional_payload&&) = default;\n \n       _Optional_payload&\n       operator=(const _Optional_payload& __other)\n@@ -238,13 +612,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           _Empty_byte _M_empty;\n           _Stored_type _M_payload;\n       };\n-      bool _M_engaged = false;\n-\n-      ~_Optional_payload()\n-      {\n-        if (_M_engaged)\n-          _M_payload.~_Stored_type();\n-      }\n+      bool _M_engaged;\n \n       template<typename... _Args>\n         void\n@@ -280,7 +648,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n       }\n     };\n-  \n+\n   template<typename _Tp, typename _Dp>\n     class _Optional_base_impl\n     {"}, {"sha": "e86d39e277d56fca7ee943cd48a9463e38f5f26e", "filename": "libstdc++-v3/testsuite/20_util/optional/84601.cc", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447346e465c50ad6d840c2c29c9a07417e8d219c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2F84601.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447346e465c50ad6d840c2c29c9a07417e8d219c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2F84601.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2F84601.cc?ref=447346e465c50ad6d840c2c29c9a07417e8d219c", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+#include <optional>\n+\n+using pair_t = std::pair<int, int>;\n+using opt_t = std::optional<pair_t>;\n+\n+static_assert(std::is_copy_constructible_v<opt_t::value_type>);\n+static_assert(std::is_copy_assignable_v<opt_t::value_type>);\n+\n+static_assert(std::is_copy_assignable_v<opt_t>); // assertion fails.\n+\n+class A\n+{\n+  void f(const opt_t& opt)\n+  {\n+    _opt = opt;\n+  }\n+\n+  opt_t _opt;\n+};"}, {"sha": "ae55ab233f1e5339f1ee6d4e205add406c94bcf5", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/value_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/447346e465c50ad6d840c2c29c9a07417e8d219c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/447346e465c50ad6d840c2c29c9a07417e8d219c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc?ref=447346e465c50ad6d840c2c29c9a07417e8d219c", "patch": "@@ -37,8 +37,8 @@ int main()\n     std::optional<std::unique_ptr<int>> oup2 = new int;  // { dg-error \"conversion\" }\n     struct U { explicit U(std::in_place_t); };\n     std::optional<U> ou(std::in_place); // { dg-error \"no matching\" }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 647 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 657 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 714 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 1015 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 1025 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 1082 }\n   }\n }"}]}