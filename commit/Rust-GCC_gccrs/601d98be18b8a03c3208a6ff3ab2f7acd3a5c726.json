{"sha": "601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAxZDk4YmUxOGI4YTAzYzMyMDhhNmZmM2FiMmY3YWNkM2E1YzcyNg==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-07-25T19:31:37Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2010-07-25T19:31:37Z"}, "message": "re PR fortran/40628 (Assignment using \"= trim(string)\": Optimize \"trim\" away)\n\n2010-07-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/40628\n\t* Make-lang.in:  Add fortran/frontend-passes.o.\n\t* gfortran.h:  Add prototype for gfc_run_passes.\n\t* resolve.c (gfc_resolve):  Call gfc_run_passes.\n\t* frontend-passes.c:  New file.\n\n2010-07-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/40628\n\t* trim_optimize_1.f90:  New test.\n\t* character_comparision_1.f90:  New test.\n\nFrom-SVN: r162519", "tree": {"sha": "21e794be955d43e92f8a910c846f86e5d1678f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21e794be955d43e92f8a910c846f86e5d1678f2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "html_url": "https://github.com/Rust-GCC/gccrs/commit/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/comments", "author": null, "committer": null, "parents": [{"sha": "32e4257f245d08512da2121e85ba56d107739a63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e4257f245d08512da2121e85ba56d107739a63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32e4257f245d08512da2121e85ba56d107739a63"}], "stats": {"total": 510, "additions": 509, "deletions": 1}, "files": [{"sha": "f29ccca6aaa41a6acab9bee2b5caddba916c7f64", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "patch": "@@ -1,3 +1,11 @@\n+2010-07-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/40628\n+\t* Make-lang.in:  Add fortran/frontend-passes.o.\n+\t* gfortran.h:  Add prototype for gfc_run_passes.\n+\t* resolve.c (gfc_resolve):  Call gfc_run_passes.\n+\t* frontend-passes.c:  New file.\n+\n 2010-07-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/42852"}, {"sha": "02b4c952d9c0607823aa52cca2484a784ce27141", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "patch": "@@ -66,7 +66,7 @@ F95_OBJS = $(F95_PARSER_OBJS) $(FORTRAN_TARGET_OBJS) \\\n     fortran/trans.o fortran/trans-array.o fortran/trans-common.o \\\n     fortran/trans-const.o fortran/trans-decl.o fortran/trans-expr.o \\\n     fortran/trans-intrinsic.o fortran/trans-io.o fortran/trans-openmp.o \\\n-    fortran/trans-stmt.o fortran/trans-types.o\n+    fortran/trans-stmt.o fortran/trans-types.o fortran/frontend-passes.o\n \n fortran_OBJS = $(F95_OBJS) gfortranspec.o\n "}, {"sha": "83251cc9e69207491faa4e4c5a54380b3ce368e2", "filename": "gcc/fortran/frontend-passes.c", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "patch": "@@ -0,0 +1,435 @@\n+/* Pass manager for Fortran front end.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"gfortran.h\"\n+#include \"arith.h\"\n+#include \"flags.h\"\n+\n+/* Forward declarations.  */\n+\n+static void strip_function_call (gfc_expr *);\n+static void optimize_assignment (gfc_code *);\n+static void optimize_expr_0 (gfc_expr *);\n+static bool optimize_expr (gfc_expr *);\n+static bool optimize_op (gfc_expr *);\n+static bool optimize_equality (gfc_expr *, bool);\n+static void optimize_code (gfc_code *);\n+static void optimize_code_node (gfc_code *);\n+static void optimize_actual_arglist (gfc_actual_arglist *);\n+\n+/* Entry point - run all passes for a namespace.  So far, only an\n+   optimization pass is run.  */\n+\n+void\n+gfc_run_passes (gfc_namespace * ns)\n+{\n+  if (optimize)\n+    optimize_code (ns->code);\n+}\n+\n+static void\n+optimize_code (gfc_code *c)\n+{\n+  for (; c; c = c->next)\n+    optimize_code_node (c);\n+}\n+\n+\n+/* Do the optimizations for a code node.  */\n+\n+static void\n+optimize_code_node (gfc_code *c)\n+{\n+\n+  gfc_forall_iterator *fa;\n+  gfc_code *d;\n+  gfc_alloc *a;\n+\n+  switch (c->op)\n+    {\n+    case EXEC_ASSIGN:\n+      optimize_assignment (c);\n+      break;\n+\n+    case EXEC_CALL:\n+    case EXEC_ASSIGN_CALL:\n+    case EXEC_CALL_PPC:\n+      optimize_actual_arglist (c->ext.actual);\n+      break;\n+\n+    case EXEC_ARITHMETIC_IF:\n+      optimize_expr_0 (c->expr1);\n+      break;\n+\n+    case EXEC_PAUSE:\n+    case EXEC_RETURN:\n+    case EXEC_ERROR_STOP:\n+    case EXEC_STOP:\n+    case EXEC_COMPCALL:\n+      optimize_expr_0 (c->expr1);\n+      break;\n+\n+    case EXEC_SYNC_ALL:\n+    case EXEC_SYNC_MEMORY:\n+    case EXEC_SYNC_IMAGES:\n+      optimize_expr_0 (c->expr2);\n+      break;\n+\n+    case EXEC_IF:\n+      d = c->block;\n+      optimize_expr_0 (d->expr1);\n+      optimize_code (d->next);\n+\n+      for (d = d->block; d; d = d->block)\n+\t{\n+\t  optimize_expr_0 (d->expr1);\n+\n+\t  optimize_code (d->next);\n+\t}\n+\n+\n+      break;\n+\n+    case EXEC_SELECT:\n+    case EXEC_SELECT_TYPE:\n+      d = c->block;\n+\n+      optimize_expr_0 (c->expr1);\n+\n+      for (; d; d = d->block)\n+\toptimize_code (d->next);\n+\n+      break;\n+\n+    case EXEC_WHERE:\n+      d = c->block;\n+      optimize_expr_0 (d->expr1);\n+      optimize_code (d->next);\n+\n+      for (d = d->block; d; d = d->block)\n+\t{\n+\t  optimize_expr_0 (d->expr1);\n+\t  optimize_code (d->next);\n+\t}\n+      break;\n+\n+    case EXEC_FORALL:\n+\n+      for (fa = c->ext.forall_iterator; fa; fa = fa->next)\n+\t{\n+\t  optimize_expr_0 (fa->start);\n+\t  optimize_expr_0 (fa->end);\n+\t  optimize_expr_0 (fa->stride);\n+\t}\n+\n+      if (c->expr1 != NULL)\n+\t  optimize_expr_0 (c->expr1);\n+\n+      optimize_code (c->block->next);\n+\n+      break;\n+\n+    case EXEC_CRITICAL:\n+      optimize_code (c->block->next);\n+      break;\n+\n+    case EXEC_DO:\n+      optimize_expr_0 (c->ext.iterator->start);\n+      optimize_expr_0 (c->ext.iterator->end);\n+      optimize_expr_0 (c->ext.iterator->step);\n+      optimize_code (c->block->next);\n+\n+      break;\n+\n+    case EXEC_DO_WHILE:\n+      optimize_expr_0 (c->expr1);\n+      optimize_code (c->block->next);\n+      break;\n+\n+\n+    case EXEC_ALLOCATE:\n+      for (a = c->ext.alloc.list; a; a = a->next)\n+\t  optimize_expr_0 (a->expr);\n+      break;\n+\n+      /* Todo:  Some of these may need to be optimized, as well.  */\n+    case EXEC_WRITE:\n+    case EXEC_READ:\n+    case EXEC_OPEN:\n+    case EXEC_INQUIRE:\n+    case EXEC_REWIND:\n+    case EXEC_ENDFILE:\n+    case EXEC_BACKSPACE:\n+    case EXEC_CLOSE:\n+    case EXEC_WAIT:\n+    case EXEC_TRANSFER:\n+    case EXEC_FLUSH:\n+    case EXEC_IOLENGTH:\n+    case EXEC_END_PROCEDURE:\n+    case EXEC_NOP:\n+    case EXEC_CONTINUE:\n+    case EXEC_ENTRY:\n+    case EXEC_INIT_ASSIGN:\n+    case EXEC_LABEL_ASSIGN:\n+    case EXEC_POINTER_ASSIGN:\n+    case EXEC_GOTO:\n+    case EXEC_CYCLE:\n+    case EXEC_EXIT:\n+    case EXEC_BLOCK:\n+    case EXEC_END_BLOCK:\n+    case EXEC_OMP_ATOMIC:\n+    case EXEC_OMP_BARRIER:\n+    case EXEC_OMP_CRITICAL:\n+    case EXEC_OMP_FLUSH:\n+    case EXEC_OMP_DO:\n+    case EXEC_OMP_MASTER:\n+    case EXEC_OMP_ORDERED:\n+    case EXEC_OMP_PARALLEL:\n+    case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_SECTIONS:\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n+    case EXEC_OMP_SECTIONS:\n+    case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_TASK:\n+    case EXEC_OMP_TASKWAIT:\n+    case EXEC_OMP_WORKSHARE:\n+    case EXEC_DEALLOCATE:\n+      \n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+\n+    }\n+}\n+\n+/* Optimizations for an assignment.  */\n+\n+static void\n+optimize_assignment (gfc_code * c)\n+{\n+  gfc_expr *lhs, *rhs;\n+\n+  lhs = c->expr1;\n+  rhs = c->expr2;\n+\n+  /* Optimize away a = trim(b), where a is a character variable.  */\n+\n+  if (lhs->ts.type == BT_CHARACTER)\n+    {\n+      if (rhs->expr_type == EXPR_FUNCTION &&\n+\t  rhs->value.function.isym &&\n+\t  rhs->value.function.isym->id == GFC_ISYM_TRIM)\n+\t{\n+\t  strip_function_call (rhs);\n+\t  optimize_assignment (c);\n+\t  return;\n+\t}\n+    }\n+\n+  /* All direct optimizations have been done.  Now it's time\n+     to optimize the rhs.  */\n+\n+  optimize_expr_0 (rhs);\n+}\n+\n+\n+/* Remove an unneeded function call, modifying the expression.\n+   This replaces the function call with the value of its\n+   first argument.  The rest of the argument list is freed.  */\n+\n+static void\n+strip_function_call (gfc_expr *e)\n+{\n+  gfc_expr *e1;\n+  gfc_actual_arglist *a;\n+\n+  a = e->value.function.actual;\n+\n+  /* We should have at least one argument.  */\n+  gcc_assert (a->expr != NULL);\n+\n+  e1 = a->expr;\n+\n+  /* Free the remaining arglist, if any.  */\n+  if (a->next)\n+    gfc_free_actual_arglist (a->next);\n+\n+  /* Graft the argument expression onto the original function.  */\n+  *e = *e1;\n+  gfc_free (e1);\n+\n+}\n+\n+/* Top-level optimization of expressions.  Calls gfc_simplify_expr if\n+   optimize_expr succeeds in doing something.\n+   TODO: Optimization of multiple function occurrence to come here.  */\n+\n+static void\n+optimize_expr_0 (gfc_expr * e)\n+{\n+  if (optimize_expr (e))\n+    gfc_simplify_expr (e, 0);\n+\n+  return;\n+}\n+\n+/* Recursive optimization of expressions.\n+ TODO:  Make this handle many more things.  */\n+\n+static bool\n+optimize_expr (gfc_expr *e)\n+{\n+  bool ret;\n+\n+  if (e == NULL)\n+    return false;\n+\n+  ret = false;\n+\n+  switch (e->expr_type)\n+    {\n+    case EXPR_OP:\n+      return optimize_op (e);\n+      break;\n+\n+    case EXPR_FUNCTION:\n+      optimize_actual_arglist (e->value.function.actual);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Recursive optimization of operators.  */\n+\n+static bool\n+optimize_op (gfc_expr *e)\n+{\n+\n+  gfc_intrinsic_op op;\n+\n+  op = e->value.op.op;\n+\n+  switch (op)\n+    {\n+    case INTRINSIC_EQ:\n+    case INTRINSIC_EQ_OS:\n+    case INTRINSIC_GE:\n+    case INTRINSIC_GE_OS:\n+    case INTRINSIC_LE:\n+    case INTRINSIC_LE_OS:\n+      return optimize_equality (e, true);\n+      break;\n+\n+    case INTRINSIC_NE:\n+    case INTRINSIC_NE_OS:\n+    case INTRINSIC_GT:\n+    case INTRINSIC_GT_OS:\n+    case INTRINSIC_LT:\n+    case INTRINSIC_LT_OS:\n+      return optimize_equality (e, false);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return false;\n+}\n+\n+/* Optimize expressions for equality.  */\n+\n+static bool\n+optimize_equality (gfc_expr *e, bool equal)\n+{\n+\n+  gfc_expr *op1, *op2;\n+  bool change;\n+\n+  op1 = e->value.op.op1;\n+  op2 = e->value.op.op2;\n+\n+  /* Strip off unneeded TRIM calls from string comparisons.  */\n+\n+  change = false;\n+\n+  if (op1->expr_type == EXPR_FUNCTION \n+      && op1->value.function.isym\n+      && op1->value.function.isym->id == GFC_ISYM_TRIM)\n+    {\n+      strip_function_call (op1);\n+      change = true;\n+    }\n+\n+  if (op2->expr_type == EXPR_FUNCTION \n+      && op2->value.function.isym\n+      && op2->value.function.isym->id == GFC_ISYM_TRIM)\n+    {\n+      strip_function_call (op2);\n+      change = true;\n+    }\n+\n+  if (change)\n+    {\n+      optimize_equality (e, equal);\n+      return true;\n+    }\n+\n+  /* Check for direct comparison between identical variables.\n+     TODO: Handle cases with identical refs.  */\n+  if (op1->expr_type == EXPR_VARIABLE\n+      && op2->expr_type == EXPR_VARIABLE\n+      && op1->symtree == op2->symtree\n+      && op1->ref == NULL && op2->ref == NULL\n+      && op1->ts.type != BT_REAL && op2->ts.type != BT_REAL\n+      && op1->ts.type != BT_COMPLEX && op2->ts.type !=BT_COMPLEX)\n+    {\n+      /* Replace the expression by a constant expression.  The typespec\n+\t and where remains the way it is.  */\n+      gfc_free (op1);\n+      gfc_free (op2);\n+      e->expr_type = EXPR_CONSTANT;\n+      e->value.logical = equal;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Optimize a call list.  Right now, this just goes through the actual\n+   arg list and optimizes each expression in turn.  */\n+\n+static void\n+optimize_actual_arglist (gfc_actual_arglist *a)\n+{\n+\n+  for (; a; a = a->next)\n+    {\n+      if (a->expr != NULL)\n+\toptimize_expr_0 (a->expr);\n+    }\n+  \n+  return;\n+}"}, {"sha": "bb056e2e531ee39348eceae5d9a592b65af23c0f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "patch": "@@ -2842,4 +2842,8 @@ gfc_symtree* gfc_get_tbp_symtree (gfc_symtree**, const char*);\n \n #define CLASS_DATA(sym) sym->ts.u.derived->components\n \n+/* frontend-passes.c */\n+\n+void gfc_run_passes (gfc_namespace *);\n+\n #endif /* GCC_GFORTRAN_H  */"}, {"sha": "fb9aadc4806a97f4800317e54a48c9315e8d1e59", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "patch": "@@ -13081,4 +13081,6 @@ gfc_resolve (gfc_namespace *ns)\n   gfc_current_ns = old_ns;\n   cs_base = old_cs_base;\n   ns->resolved = 1;\n+\n+  gfc_run_passes (ns);\n }"}, {"sha": "1489b66cd9386f4a280764838b79e4ba71efa44d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "patch": "@@ -1,3 +1,9 @@\n+2010-07-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/40628\n+\t* trim_optimize_1.f90:  New test.\n+\t* character_comparision_1.f90:  New test.\n+\n 2010-07-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/42852"}, {"sha": "d34af304da59b4b7c315a6154142b45b966161b3", "filename": "gcc/testsuite/gfortran.dg/character_comparison_1.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcharacter_comparison_1.f90?ref=601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+program main\n+  implicit none\n+  character(len=4) :: c\n+  integer :: n\n+  integer :: i\n+  common /foo/ i\n+\n+  n = 0\n+  i = 0\n+  c = 'abcd'\n+  n = n + 1 ; if (c == c) call yes\n+  n = n + 1 ; if (c >= c) call yes\n+  n = n + 1 ; if (c <= c) call yes\n+  n = n + 1 ; if (c .eq. c) call yes\n+  n = n + 1 ; if (c .ge. c) call yes\n+  n = n + 1 ; if (c .le. c) call yes\n+  if (c /= c) call abort\n+  if (c > c) call abort\n+  if (c < c) call abort\n+  if (c .ne. c) call abort\n+  if (c .gt. c) call abort\n+  if (c .lt. c) call abort\n+  if (n /= i) call abort\n+end program main\n+\n+subroutine yes\n+  implicit none\n+  common /foo/ i\n+  integer :: i\n+  i = i + 1\n+end subroutine yes\n+\n+! { dg-final { scan-tree-dump-times \"gfortran_compare_string\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}, {"sha": "26aa5cd94e043e385e63bd2f5c78d01abee894be", "filename": "gcc/testsuite/gfortran.dg/trim_optimize_1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/601d98be18b8a03c3208a6ff3ab2f7acd3a5c726/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftrim_optimize_1.f90?ref=601d98be18b8a03c3208a6ff3ab2f7acd3a5c726", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+! PR 40628 - optimize unnecessary TRIMs on assignment\n+program main\n+  character(len=3) :: a\n+  character(len=4) :: b,c\n+  b = 'abcd'\n+  a = trim(b)\n+  c = trim(trim(a))\n+  if (a /= 'abc') call abort\n+  if (c /= 'abc') call abort\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"memmove\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"string_trim\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}