{"sha": "b3bb64567494f669b77919d1be9c0e5034703083", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNiYjY0NTY3NDk0ZjY2OWI3NzkxOWQxYmU5YzBlNTAzNDcwMzA4Mw==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-07-17T04:55:25Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2001-07-17T04:55:25Z"}, "message": "unix.h (ASM_OUTPUT_MI_THUNK): Fix output format for x86-64 pic support.\n\n        * config/i386/unix.h (ASM_OUTPUT_MI_THUNK): Fix output format for\n        x86-64 pic support.\n\n        * lcm.c (optimize_mode_switching): Avoid warning for unused\n        variable if !NORMAL_MODE\n\n        * flow.c (try_crossjump_to_edge): Remove unused variable.\n\nFrom-SVN: r44062", "tree": {"sha": "f456ad6c679005d9c61bd3b40403502f19d75172", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f456ad6c679005d9c61bd3b40403502f19d75172"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3bb64567494f669b77919d1be9c0e5034703083", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3bb64567494f669b77919d1be9c0e5034703083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3bb64567494f669b77919d1be9c0e5034703083", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3bb64567494f669b77919d1be9c0e5034703083/comments", "author": null, "committer": null, "parents": [{"sha": "b8d0bbf763efb8f7b41d52296167985b77cf5938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d0bbf763efb8f7b41d52296167985b77cf5938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8d0bbf763efb8f7b41d52296167985b77cf5938"}], "stats": {"total": 84, "additions": 47, "deletions": 37}, "files": [{"sha": "47b29c5b8892eb5d7e5d943d8401866353c7cab9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3bb64567494f669b77919d1be9c0e5034703083/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3bb64567494f669b77919d1be9c0e5034703083/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3bb64567494f669b77919d1be9c0e5034703083", "patch": "@@ -1,3 +1,13 @@\n+2001-07-17  Andreas Jaeger  <aj@suse.de>\n+\n+\t* config/i386/unix.h (ASM_OUTPUT_MI_THUNK): Fix output format for\n+\tx86-64 pic support.\n+\n+\t* lcm.c (optimize_mode_switching): Avoid warning for unused\n+\tvariable if !NORMAL_MODE\n+\n+\t* flow.c (try_crossjump_to_edge): Remove unused variable.\n+\n 2001-07-16  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* inclhack.def (ultrix_atexit_param): New hack to fix ultrix 4.3\n@@ -68,14 +78,14 @@ Mon Jul 16 18:07:07 2001  J\"orn Rennecke <amylaar@redhat.com>\n \n 2001-07-16  Daniel Berlin  <dan@cgsoftware.com>\n \n-\t* gcse.c: Update comment at top. \n+\t* gcse.c: Update comment at top.\n \tUpdate comment on mem handling.\n \tmem_last_set, mem_first_set, mem_set_in_block: gone.\n \tDeclaration of reg_set_info: gone.\n \t(oprs_unchanged_p): Don't use mem_*set_* anymore. They are\n \tpointless with load_killed_in_block_p (they are *more*\n \tconservative then it, not less, and less accurate).\n-\t(oprs_not_set_p): Ditto.\t\n+\t(oprs_not_set_p): Ditto.\n \t(alloc_gcse_mem): Don't allocate mem_set_in_block\n \t(free_gcse_mem): Don't free it, either.\n \t(record_last_mem_set_info): Update comment in front, remove\n@@ -85,13 +95,13 @@ Mon Jul 16 18:07:07 2001  J\"orn Rennecke <amylaar@redhat.com>\n \tmem_*set_* references.\n \t(reset_opr_set_tables): Remove mem_*set_* references.\n \t(mark_call): Ditto.\n-\t(mark_set): Ditto.  Also remove double sets of bitmaps for REG's.\t\n+\t(mark_set): Ditto.  Also remove double sets of bitmaps for REG's.\n \t(mark_clobber): Ditto (on both parts, we double set here too).\n \t(expr_killed_p): Remove mem_set_in_block test.\n \t(compute_transp): Remove mem_set_in_block test.\n \n \t* ssa-ccp.c: (optimize_unexecutable_edges): Add note about removal\n-\tof edge, and removal of phi alternative to dump file. \n+\tof edge, and removal of phi alternative to dump file.\n \t(ssa_ccp_substitute_constants): Add note about register now being\n \tconstant, and which uses were replaced in what insns to dump file.\n "}, {"sha": "63c68cb4e4230654027e2df4d87a725530bdd48c", "filename": "gcc/config/i386/unix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3bb64567494f669b77919d1be9c0e5034703083/gcc%2Fconfig%2Fi386%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3bb64567494f669b77919d1be9c0e5034703083/gcc%2Fconfig%2Fi386%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Funix.h?ref=b3bb64567494f669b77919d1be9c0e5034703083", "patch": "@@ -128,7 +128,7 @@ do {\t\t\t\t\t\t\t\t\t    \\\n     {\t\t\t\t\t\t\t\t\t    \\\n       fprintf (FILE, \"\\tjmp *\");\t\t\t\t\t    \\\n       assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t    \\\n-      fprintf (FILE, \"@GOTPCREL(%RIP)\\n\");\t\t\t\t    \\\n+      fprintf (FILE, \"@GOTPCREL(%%RIP)\\n\");\t\t\t\t    \\\n     }\t\t\t\t\t\t\t\t\t    \\\n   else\t\t\t\t\t\t\t\t\t    \\\n     {\t\t\t\t\t\t\t\t\t    \\"}, {"sha": "6e6c2b61d0b965564b136eb81296772be37d44fc", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3bb64567494f669b77919d1be9c0e5034703083/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3bb64567494f669b77919d1be9c0e5034703083/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b3bb64567494f669b77919d1be9c0e5034703083", "patch": "@@ -3452,7 +3452,6 @@ try_crossjump_to_edge (mode, e1, e2)\n   rtx newpos1, newpos2;\n   rtx first, last;\n   edge s;\n-  rtx note;\n   rtx label;\n   rtx barrier;\n "}, {"sha": "d90fd4f9680e8832a53c9af486c869c2245cceb4", "filename": "gcc/lcm.c", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3bb64567494f669b77919d1be9c0e5034703083/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3bb64567494f669b77919d1be9c0e5034703083/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=b3bb64567494f669b77919d1be9c0e5034703083", "patch": "@@ -19,7 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n /* These routines are meant to be used by various optimization\n-   passes which can be modeled as lazy code motion problems. \n+   passes which can be modeled as lazy code motion problems.\n    Including, but not limited to:\n \n \t* Traditional partial redundancy elimination.\n@@ -95,8 +95,8 @@ static void compute_rev_insert_delete\tPARAMS ((struct edge_list *edge_list,\n \f\n /* Edge based lcm routines.  */\n \n-/* Compute expression anticipatability at entrance and exit of each block. \n-   This is done based on the flow graph, and not on the pred-succ lists.  \n+/* Compute expression anticipatability at entrance and exit of each block.\n+   This is done based on the flow graph, and not on the pred-succ lists.\n    Other than that, its pretty much identical to compute_antinout.  */\n \n static void\n@@ -128,7 +128,7 @@ compute_antinout_edge (antloc, transp, antin, antout)\n       *qin++ = BASIC_BLOCK (bb);\n       BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n     }\n-  \n+\n   qin = worklist;\n   qend = &worklist[n_basic_blocks];\n   qlen = n_basic_blocks;\n@@ -189,7 +189,7 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n      sbitmap *antin, *antout, *avout, *kill, *earliest;\n {\n   sbitmap difference, temp_bitmap;\n-  int x, num_edges; \n+  int x, num_edges;\n   basic_block pred, succ;\n \n   num_edges = NUM_EDGES (edge_list);\n@@ -213,8 +213,8 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n \t    sbitmap_zero (earliest[x]);\n \t  else\n \t    {\n-\t      sbitmap_difference (difference, antin[succ->index], \n-\t      \t\t\t  avout[pred->index]);\n+\t      sbitmap_difference (difference, antin[succ->index],\n+\t\t\t\t  avout[pred->index]);\n \t      sbitmap_not (temp_bitmap, antout[pred->index]);\n \t      sbitmap_a_and_b_or_c (earliest[x], difference,\n \t\t\t\t    kill[pred->index], temp_bitmap);\n@@ -254,7 +254,7 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n      EXIT block are handled in the normal fashion inside the loop.  However,\n      the insertion/deletion computation needs LATERIN(EXIT), so we have\n      to compute it.  */\n- \n+\n static void\n compute_laterin (edge_list, earliest, antloc, later, laterin)\n      struct edge_list *edge_list;\n@@ -369,7 +369,7 @@ compute_insert_delete (edge_list, antloc, later, laterin,\n \n   for (x = 0; x < n_basic_blocks; x++)\n     sbitmap_difference (delete[x], antloc[x], laterin[x]);\n-     \n+\n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n       basic_block b = INDEX_EDGE_SUCC_BB (edge_list, x);\n@@ -490,7 +490,7 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n \n void\n compute_available (avloc, kill, avout, avin)\n-     sbitmap *avloc, *kill, *avout, *avin;  \n+     sbitmap *avloc, *kill, *avout, *avin;\n {\n   int bb;\n   edge e;\n@@ -513,7 +513,7 @@ compute_available (avloc, kill, avout, avin)\n       *qin++ = BASIC_BLOCK (bb);\n       BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n     }\n-  \n+\n   qin = worklist;\n   qend = &worklist[n_basic_blocks];\n   qlen = n_basic_blocks;\n@@ -571,14 +571,14 @@ compute_available (avloc, kill, avout, avin)\n /* Compute the farthest vector for edge based lcm.  */\n \n static void\n-compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin, \n+compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,\n \t\t  kill, farthest)\n      struct edge_list *edge_list;\n      int n_exprs;\n      sbitmap *st_avout, *st_avin, *st_antin, *kill, *farthest;\n {\n   sbitmap difference, temp_bitmap;\n-  int x, num_edges; \n+  int x, num_edges;\n   basic_block pred, succ;\n \n   num_edges = NUM_EDGES (edge_list);\n@@ -598,10 +598,10 @@ compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,\n \t    sbitmap_zero (farthest[x]);\n \t  else\n \t    {\n-\t      sbitmap_difference (difference, st_avout[pred->index], \n+\t      sbitmap_difference (difference, st_avout[pred->index],\n \t\t\t\t  st_antin[succ->index]);\n \t      sbitmap_not (temp_bitmap, st_avin[succ->index]);\n-\t      sbitmap_a_and_b_or_c (farthest[x], difference, \n+\t      sbitmap_a_and_b_or_c (farthest[x], difference,\n \t\t\t\t    kill[succ->index], temp_bitmap);\n \t    }\n \t}\n@@ -656,7 +656,7 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n       *tos++ = b;\n       b->aux = b;\n     }\n- \n+\n   /* Iterate until the worklist is empty.  */\n   while (tos != worklist)\n     {\n@@ -710,7 +710,7 @@ compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n \n   for (x = 0; x < n_basic_blocks; x++)\n     sbitmap_difference (delete[x], st_avloc[x], nearerout[x]);\n-     \n+\n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n       basic_block b = INDEX_EDGE_PRED_BB (edge_list, x);\n@@ -721,13 +721,13 @@ compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n     }\n }\n \n-/* Given local properties TRANSP, ST_AVLOC, ST_ANTLOC, KILL return the \n+/* Given local properties TRANSP, ST_AVLOC, ST_ANTLOC, KILL return the\n    insert and delete vectors for edge based reverse LCM.  Returns an\n    edgelist which is used to map the insert vector to what edge\n    an expression should be inserted on.  */\n \n struct edge_list *\n-pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill, \n+pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n \t\t  insert, delete)\n      FILE *file ATTRIBUTE_UNUSED;\n      int n_exprs;\n@@ -783,7 +783,7 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n \n   /* Compute farthestness.  */\n   farthest = sbitmap_vector_alloc (num_edges, n_exprs);\n-  compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin, \n+  compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,\n \t\t    kill, farthest);\n \n #ifdef LCM_DEBUG_INFO\n@@ -806,7 +806,7 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n #ifdef LCM_DEBUG_INFO\n   if (file)\n     {\n-      dump_sbitmap_vector (file, \"nearerout\", \"\", nearerout, \n+      dump_sbitmap_vector (file, \"nearerout\", \"\", nearerout,\n \t\t\t   n_basic_blocks + 1);\n       dump_sbitmap_vector (file, \"nearer\", \"\", nearer, num_edges);\n     }\n@@ -855,13 +855,13 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n    More details are located in the code for optimize_mode_switching().  */\n \n /* This structure contains the information for each insn which requires\n-   either single or double mode to be set.  \n+   either single or double mode to be set.\n    MODE is the mode this insn must be executed in.\n    INSN_PTR is the insn to be executed (may be the note that marks the\n    beginning of a basic block).\n    BBNUM is the flow graph basic block this insn occurs in.\n    NEXT is the next insn in the same basic block.  */\n-struct seginfo \n+struct seginfo\n {\n   int mode;\n   rtx insn_ptr;\n@@ -914,7 +914,7 @@ new_seginfo (mode, insn, bb, regs_live)\n   return ptr;\n }\n \n-/* Add a seginfo element to the end of a list.  \n+/* Add a seginfo element to the end of a list.\n    HEAD is a pointer to the list beginning.\n    INFO is the structure to be linked in.  */\n \n@@ -1013,7 +1013,6 @@ optimize_mode_switching (file)\n {\n   rtx insn;\n   int bb, e;\n-  edge eg;\n   int need_commit = 0;\n   sbitmap *kill;\n   struct edge_list *edge_list;\n@@ -1087,7 +1086,7 @@ optimize_mode_switching (file)\n \n \t  REG_SET_TO_HARD_REG_SET (live_now,\n \t\t\t\t   BASIC_BLOCK (bb)->global_live_at_start);\n-\t  for (insn = BLOCK_HEAD (bb); \n+\t  for (insn = BLOCK_HEAD (bb);\n \t       insn != NULL && insn != NEXT_INSN (BLOCK_END (bb));\n \t       insn = NEXT_INSN (insn))\n \t    {\n@@ -1130,6 +1129,8 @@ optimize_mode_switching (file)\n \n \tif (mode != no_mode)\n \t  {\n+\t    edge eg;\n+\n \t    for (eg = ENTRY_BLOCK_PTR->succ; eg; eg = eg->succ_next)\n \t      {\n \t\tbb = eg->dest->index;\n@@ -1175,7 +1176,7 @@ optimize_mode_switching (file)\n \t{\n \t  int m = current_mode[j] = MODE_PRIORITY_TO_MODE (entity_map[j], i);\n \t  struct bb_info *info = bb_info[j];\n-\t  \n+\n \t  for (bb = 0 ; bb < n_basic_blocks; bb++)\n \t    {\n \t      if (info[bb].seginfo->mode == m)\n@@ -1281,7 +1282,7 @@ optimize_mode_switching (file)\n   VARRAY_POP (basic_block_info);\n   EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n #endif\n-  \n+\n   /* Now output the remaining mode sets in all the segments.  */\n   for (j = n_entities - 1; j >= 0; j--)\n     {\n@@ -1322,7 +1323,7 @@ optimize_mode_switching (file)\n \t\t  insert_insn_on_edge (mode_set, eg);\n \t\t}\n \t    }\n-\t  \n+\n \t}\n #endif\n \n@@ -1345,7 +1346,7 @@ optimize_mode_switching (file)\n \t\t      && (NOTE_LINE_NUMBER (ptr->insn_ptr)\n \t\t\t  == NOTE_INSN_BASIC_BLOCK))\n \t\t    emit_block_insn_after (mode_set, ptr->insn_ptr,\n-    \t\t                           BASIC_BLOCK (ptr->bbnum));\n+\t\t                           BASIC_BLOCK (ptr->bbnum));\n \t\t  else\n \t\t    emit_block_insn_before (mode_set, ptr->insn_ptr,\n \t\t\t\t\t    BASIC_BLOCK (ptr->bbnum));\n@@ -1359,7 +1360,7 @@ optimize_mode_switching (file)\n     }\n \n   /* Finished. Free up all the things we've allocated.  */\n-  \n+\n   sbitmap_vector_free (kill);\n   sbitmap_vector_free (antic);\n   sbitmap_vector_free (transp);"}]}