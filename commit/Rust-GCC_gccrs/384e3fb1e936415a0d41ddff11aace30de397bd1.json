{"sha": "384e3fb1e936415a0d41ddff11aace30de397bd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg0ZTNmYjFlOTM2NDE1YTBkNDFkZGZmMTFhYWNlMzBkZTM5N2JkMQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2014-07-31T12:53:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T12:53:19Z"}, "message": "decl.c, [...]: Add handling of Inline_Always pragma.\n\n\t* gcc-interface/decl.c, gcc-interface/trans.c,  \n\tgcc-interface/gigi.h: Add handling of Inline_Always pragma.  \n\nCo-Authored-By: Eric Botcazou <ebotcazou@adacore.com>\n\nFrom-SVN: r213354", "tree": {"sha": "82a86b9f430697c1df00bc053d9117c3df94ea3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82a86b9f430697c1df00bc053d9117c3df94ea3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/384e3fb1e936415a0d41ddff11aace30de397bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/384e3fb1e936415a0d41ddff11aace30de397bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/384e3fb1e936415a0d41ddff11aace30de397bd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/384e3fb1e936415a0d41ddff11aace30de397bd1/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f087ea4445c639926873179da29955c3a968ddc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f087ea4445c639926873179da29955c3a968ddc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f087ea4445c639926873179da29955c3a968ddc7"}], "stats": {"total": 83, "additions": 56, "deletions": 27}, "files": [{"sha": "6b89f7f65ccf636b7c5a56d77367e674620a605d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/384e3fb1e936415a0d41ddff11aace30de397bd1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/384e3fb1e936415a0d41ddff11aace30de397bd1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=384e3fb1e936415a0d41ddff11aace30de397bd1", "patch": "@@ -7,6 +7,7 @@\n \t* gnat_ugn.texi: Document --test-duration option for gnattest.\n \n 2014-07-31  Javier Miranda  <miranda@adacore.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* opt.ads (Back_End_Inlining): New variable which controls\n \tactivation of inlining by back-end expansion.\n@@ -26,6 +27,8 @@\n \t* fe.h Import Back_End_Inlining variable.\n \t* gcc-interface/utils.c (create_subprog_decl): If Back_End_Inlining is\n \tenabled then declare attribute \"always inline\"\n+\t* gcc-interface/decl.c, gcc-interface/trans.c,\n+\tgcc-interface/gigi.h: Add handling of Inline_Always pragma.\n \n 2014-07-31  Robert Dewar  <dewar@adacore.com>\n "}, {"sha": "795eea3a04f3610af9fe4269931bd578cd3c2c2d", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/384e3fb1e936415a0d41ddff11aace30de397bd1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/384e3fb1e936415a0d41ddff11aace30de397bd1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=384e3fb1e936415a0d41ddff11aace30de397bd1", "patch": "@@ -4146,7 +4146,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tenum inline_status_t inline_status\n \t  = Has_Pragma_No_Inline (gnat_entity)\n \t    ? is_suppressed\n-\t    : (Is_Inlined (gnat_entity) ? is_enabled : is_disabled);\n+\t    : Has_Pragma_Inline_Always (gnat_entity)\n+\t      ? is_required\n+\t      : (Is_Inlined (gnat_entity) ? is_enabled : is_disabled);\n \tbool public_flag = Is_Public (gnat_entity) || imported_p;\n \tbool extern_flag\n \t  = (Is_Public (gnat_entity) && !definition) || imported_p;\n@@ -4701,6 +4703,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \telse\n \t  {\n+\t    /* ??? When only the spec of a package is provided, downgrade\n+\t       is_required to is_enabled to avoid issuing an error later.  */\n+\t    if (inline_status == is_required)\n+\t      {\n+\t\tNode_Id gnat_body = Parent (Declaration_Node (gnat_entity));\n+\t\tif (Nkind (gnat_body) != N_Subprogram_Body\n+\t\t    && No (Corresponding_Body (gnat_body)))\n+\t\t  inline_status = is_enabled;\n+\t      }\n+\n \t    if (has_stub)\n \t      {\n \t\tgnu_stub_name = gnu_ext_name;\n@@ -5178,8 +5190,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t The language rules ensure the parent type is already frozen here.  */\n       if (Is_Derived_Type (gnat_entity) && !type_annotate_only)\n \t{\n-\t  tree gnu_parent_type = gnat_to_gnu_type (Etype (gnat_entity));\n-\t  relate_alias_sets (gnu_type, gnu_parent_type,\n+\t  Entity_Id gnat_parent_type = Underlying_Type (Etype (gnat_entity));\n+\t  /* For packed array subtypes, the implementation type is used.  */\n+\t  if (kind == E_Array_Subtype\n+\t      && Present (Packed_Array_Impl_Type (gnat_parent_type)))\n+\t    gnat_parent_type = Packed_Array_Impl_Type (gnat_parent_type);\n+\t  relate_alias_sets (gnu_type, gnat_to_gnu_type (gnat_parent_type),\n \t\t\t     Is_Composite_Type (gnat_entity)\n \t\t\t     ? ALIAS_SET_COPY : ALIAS_SET_SUPERSET);\n \t}"}, {"sha": "0e4befbab737ec35c48c0384a7c079bfb11c7b4f", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/384e3fb1e936415a0d41ddff11aace30de397bd1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/384e3fb1e936415a0d41ddff11aace30de397bd1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=384e3fb1e936415a0d41ddff11aace30de397bd1", "patch": "@@ -5051,6 +5051,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   const bool body_p = (Nkind (gnat_unit) == N_Package_Body\n \t\t       || Nkind (gnat_unit) == N_Subprogram_Body);\n   const Entity_Id gnat_unit_entity = Defining_Entity (gnat_unit);\n+  Entity_Id gnat_entity;\n   Node_Id gnat_pragma;\n   /* Make the decl for the elaboration procedure.  */\n   tree gnu_elab_proc_decl\n@@ -5099,33 +5100,31 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   /* Process the unit itself.  */\n   add_stmt (gnat_to_gnu (gnat_unit));\n \n-  /* If we can inline, generate code for all the inlined subprograms.  */\n-  if (optimize)\n+  /* Generate code for all the inlined subprograms.  */\n+  for (gnat_entity = First_Inlined_Subprogram (gnat_node);\n+       Present (gnat_entity);\n+       gnat_entity = Next_Inlined_Subprogram (gnat_entity))\n     {\n-      Entity_Id gnat_entity;\n+      Node_Id gnat_body;\n \n-      for (gnat_entity = First_Inlined_Subprogram (gnat_node);\n-\t   Present (gnat_entity);\n-\t   gnat_entity = Next_Inlined_Subprogram (gnat_entity))\n-\t{\n-\t  Node_Id gnat_body = Parent (Declaration_Node (gnat_entity));\n+      /* Without optimization, process only the required subprograms.  */\n+      if (!optimize && !Has_Pragma_Inline_Always (gnat_entity))\n+\tcontinue;\n \n-\t  if (Nkind (gnat_body) != N_Subprogram_Body)\n-\t    {\n-\t      /* ??? This really should always be present.  */\n-\t      if (No (Corresponding_Body (gnat_body)))\n-\t\tcontinue;\n-\t      gnat_body\n-\t\t= Parent (Declaration_Node (Corresponding_Body (gnat_body)));\n-\t    }\n+      gnat_body = Parent (Declaration_Node (gnat_entity));\n+      if (Nkind (gnat_body) != N_Subprogram_Body)\n+\t{\n+\t  /* ??? This happens when only the spec of a package is provided.  */\n+\t  if (No (Corresponding_Body (gnat_body)))\n+\t    continue;\n \n-\t  if (Present (gnat_body))\n-\t    {\n-\t      /* Define the entity first so we set DECL_EXTERNAL.  */\n-\t      gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n-\t      add_stmt (gnat_to_gnu (gnat_body));\n-\t    }\n+\t  gnat_body\n+\t    = Parent (Declaration_Node (Corresponding_Body (gnat_body)));\n \t}\n+\n+      /* Define the entity first so we set DECL_EXTERNAL.  */\n+      gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n+      add_stmt (gnat_to_gnu (gnat_body));\n     }\n \n   /* Process any pragmas and actions following the unit.  */\n@@ -5818,8 +5817,18 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))),\n \t\t   gnat_temp);\n \n-\t    gnu_result = build_binary_op (ARRAY_REF, NULL_TREE,\n-\t\t\t\t\t  gnu_result, gnu_expr);\n+\t    gnu_result\n+\t      = build_binary_op (ARRAY_REF, NULL_TREE, gnu_result, gnu_expr);\n+\n+\t    /* Array accesses are bound-checked so they cannot trap, but this\n+\t       is valid only if they are not hoisted ahead of the check.  We\n+\t       need to mark them as no-trap to get decent loop optimizations\n+\t       in the presence of -fnon-call-exceptions, so we do it when we\n+\t       know that the original expression had no side-effects.  */\n+\t    if (TREE_CODE (gnu_result) == ARRAY_REF\n+\t\t&& !(Nkind (gnat_temp) == N_Identifier\n+\t\t     && Ekind (Entity (gnat_temp)) == E_Constant))\n+\t      TREE_THIS_NOTRAP (gnu_result) = 1;\n \t  }\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -9349,6 +9358,7 @@ set_gnu_expr_location_from_node (tree node, Node_Id gnat_node)\n     {\n     CASE_CONVERT:\n     case NON_LVALUE_EXPR:\n+    case SAVE_EXPR:\n       break;\n \n     case COMPOUND_EXPR:"}]}