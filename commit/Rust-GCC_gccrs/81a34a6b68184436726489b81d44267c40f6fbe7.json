{"sha": "81a34a6b68184436726489b81d44267c40f6fbe7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFhMzRhNmI2ODE4NDQzNjcyNjQ4OWI4MWQ0NDI2N2M0MGY2ZmJlNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-07T00:21:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-07T00:21:44Z"}, "message": "Use satisfaction with nested requirements.\n\ngcc/cp/\n\n2019-11-06  Andrew Sutton  <asutton@lock3software.com>\n\n\t* constraint.cc (build_parameter_mapping): Use\n\tcurrent_template_parms when the declaration is not available.\n\t(norm_info::norm_info) Make explicit.\n\t(normalize_constraint_expression): Factor into a separate overload\n\tthat takes arguments, and use that in the original function.\n\t(tsubst_nested_requirement): Use satisfy_constraint instead of\n\ttrying to evaluate this as a constant expression.\n\t(finish_nested_requirement): Keep the normalized constraint and the\n\toriginal normalization arguments with the requirement.\n\t(diagnose_nested_requirement): Use satisfy_constraint. Tentatively\n\timplement more comprehensive diagnostics, but do not enable.\n\t* parser.c (cp_parser_requires_expression): Relax requirement that\n\trequires-expressions can live only inside templates.\n\t* pt.c (any_template_parm_r): Look into type of PARM_DECL.\n\n2019-11-06  Jason Merrill  <jason@redhat.com>\n\n\t* pt.c (use_pack_expansion_extra_args_p): Still do substitution if\n\tall packs are simple pack expansions.\n\t(add_extra_args): Check that the extra args aren't dependent.\n\ngcc/testsuite/\n\t* lib/prune.exp: Ignore \"in requirements\" in diagnostics.\n\t* g++.dg/cpp2a/requires-18.C: New test.\n\t* g++.dg/cpp2a/requires-19.C: New test.\n\nFrom-SVN: r277900", "tree": {"sha": "515b593df7589864ce653e94ad2328ffcdd2b507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/515b593df7589864ce653e94ad2328ffcdd2b507"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81a34a6b68184436726489b81d44267c40f6fbe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a34a6b68184436726489b81d44267c40f6fbe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81a34a6b68184436726489b81d44267c40f6fbe7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a34a6b68184436726489b81d44267c40f6fbe7/comments", "author": null, "committer": null, "parents": [{"sha": "67568e1ad4d5623ac2c238b10fddf0faaa1fa70c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67568e1ad4d5623ac2c238b10fddf0faaa1fa70c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67568e1ad4d5623ac2c238b10fddf0faaa1fa70c"}], "stats": {"total": 313, "additions": 256, "deletions": 57}, "files": [{"sha": "cf3e00a843c043177c10b05de087bd9ed7a8d86c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=81a34a6b68184436726489b81d44267c40f6fbe7", "patch": "@@ -1,3 +1,27 @@\n+2019-11-06  Jason Merrill  <jason@redhat.com>\n+\n+\t* pt.c (use_pack_expansion_extra_args_p): Still do substitution if\n+\tall packs are simple pack expansions.\n+\t(add_extra_args): Check that the extra args aren't dependent.\n+\n+2019-11-06  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tUse satisfaction with nested requirements.\n+\t* constraint.cc (build_parameter_mapping): Use\n+\tcurrent_template_parms when the declaration is not available.\n+\t(norm_info::norm_info) Make explicit.\n+\t(normalize_constraint_expression): Factor into a separate overload\n+\tthat takes arguments, and use that in the original function.\n+\t(tsubst_nested_requirement): Use satisfy_constraint instead of\n+\ttrying to evaluate this as a constant expression.\n+\t(finish_nested_requirement): Keep the normalized constraint and the\n+\toriginal normalization arguments with the requirement.\n+\t(diagnose_nested_requirement): Use satisfy_constraint. Tentatively\n+\timplement more comprehensive diagnostics, but do not enable.\n+\t* parser.c (cp_parser_requires_expression): Relax requirement that\n+\trequires-expressions can live only inside templates.\n+\t* pt.c (any_template_parm_r): Look into type of PARM_DECL.\n+\n 2019-11-06  Jason Merrill  <jason@redhat.com>\n \n \tC++20 NB CA378 - Remove constrained non-template functions."}, {"sha": "00b59a9086812479315f2661a09744e6ce011b4f", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=81a34a6b68184436726489b81d44267c40f6fbe7", "patch": "@@ -98,6 +98,8 @@ struct subst_info\n   tree in_decl;\n };\n \n+static tree satisfy_constraint (tree, tree, subst_info);\n+\n /* True if T is known to be some type other than bool. Note that this\n    is false for dependent types and errors.  */\n \n@@ -564,6 +566,15 @@ build_parameter_mapping (tree expr, tree args, tree decl)\n       tree parms = DECL_TEMPLATE_PARMS (decl);\n       depth = TREE_INT_CST_LOW (TREE_PURPOSE (parms));\n     }\n+  else if (current_template_parms)\n+    {\n+      /* TODO: This should probably be the only case, but because the\n+\t point of declaration of concepts is currently set after the\n+\t initializer, the template parameter lists are not available\n+\t when normalizing concept definitions, hence the case above.  */\n+      depth = TMPL_PARMS_DEPTH (current_template_parms);\n+    }\n+\n   tree parms = find_template_parameters (expr, depth);\n   tree map = map_arguments (parms, args);\n   return map;\n@@ -592,7 +603,7 @@ parameter_mapping_equivalent_p (tree t1, tree t2)\n \n struct norm_info : subst_info\n {\n-  norm_info(tsubst_flags_t complain)\n+  explicit norm_info (tsubst_flags_t complain)\n     : subst_info (tf_warning_or_error | complain, NULL_TREE),\n       context()\n   {}\n@@ -872,6 +883,20 @@ normalize_nontemplate_requirements (tree decl, bool diag = false)\n   return get_normalized_constraints_from_decl (decl, diag);\n }\n \n+/* Normalize an EXPR as a constraint using ARGS.  */\n+\n+static tree\n+normalize_constraint_expression (tree expr, tree args, bool diag = false)\n+{\n+  if (!expr || expr == error_mark_node)\n+    return expr;\n+  ++processing_template_decl;\n+  norm_info info (diag ? tf_norm : tf_none);\n+  tree norm = get_normalized_constraints (expr, args, info);\n+  --processing_template_decl;\n+  return norm;\n+}\n+\n /* Normalize an EXPR as a constraint.  */\n \n static tree\n@@ -891,11 +916,7 @@ normalize_constraint_expression (tree expr, bool diag = false)\n   else\n     args = NULL_TREE;\n \n-  ++processing_template_decl;\n-  norm_info info (diag ? tf_norm : tf_none);\n-  tree norm = get_normalized_constraints (expr, args, info);\n-  --processing_template_decl;\n-  return norm;\n+  return normalize_constraint_expression (expr, args, diag);\n }\n \n /* 17.4.1.2p2. Two constraints are identical if they are formed\n@@ -1930,33 +1951,14 @@ tsubst_compound_requirement (tree t, tree args, subst_info info)\n static tree\n tsubst_nested_requirement (tree t, tree args, subst_info info)\n {\n-  tree t0 = TREE_OPERAND (t, 0);\n-  tree expr = tsubst_expr (t0, args, info.complain, info.in_decl, false);\n-  if (expr == error_mark_node)\n-    return error_mark_node;\n-\n-  /* Ensure that concrete results are satisfied.  */\n-  if (!uses_template_parms (args))\n-    {\n-      /* FIXME satisfy_constraint_expression (t0, args, info) */\n-\n-      /* [17.4.1.2] ... lvalue-to-value conversion is performed as necessary,\n-         and EXPR shall be a constant expression of type bool.  */\n-      tree result = force_rvalue (expr, tf_error);\n-      if (result == error_mark_node)\n-        return error_mark_node;\n-\n-      /* FIXME: The expression must have boolean type.  */\n-      if (cv_unqualified (TREE_TYPE (result)) != boolean_type_node)\n-        return error_mark_node;\n-\n-      /* Compute the value of the expression.  */\n-      result = satisfaction_value (cxx_constant_value (result));\n-      if (result == error_mark_node || result == boolean_false_node)\n-        return error_mark_node;\n-    }\n+  gcc_assert (!uses_template_parms (args));\n \n-  return finish_nested_requirement (EXPR_LOCATION (t), expr);\n+  /* Ensure that we're in an evaluation context prior to satisfaction.  */\n+  tree norm = TREE_VALUE (TREE_TYPE (t));\n+  tree result = satisfy_constraint (norm, args, info);\n+  if (result != boolean_true_node)\n+    return error_mark_node;\n+  return result;\n }\n \n /* Substitute ARGS into the requirement T.  */\n@@ -2385,7 +2387,7 @@ satisfaction_value (tree t)\n tree\n get_mapped_args (tree map)\n {\n-  /* If there's no map, then there are no arguments.  */\n+  /* No map, no arguments.  */\n   if (!map)\n     return NULL_TREE;\n \n@@ -2419,7 +2421,7 @@ get_mapped_args (tree map)\n       list[index] = TREE_PURPOSE (p);\n     }\n \n-  /* Build the actual argument list.  */\n+  /* Build the new argument list.  */\n   tree args = make_tree_vec (lists.length ());\n   for (unsigned i = 0; i != lists.length (); ++i)\n     {\n@@ -2453,8 +2455,7 @@ satisfy_atom (tree t, tree args, subst_info info)\n      removed before returning.  */\n   diagnosing_failed_constraint failure (t, args, info.noisy ());\n \n-  /* Instantiate the parameter mapping, so that we map directly to\n-     the arguments provided to the instantiation.  */\n+  /* Instantiate the parameter mapping.  */\n   tree map = tsubst_parameter_mapping (ATOMIC_CONSTR_MAP (t), args, quiet);\n   if (map == error_mark_node)\n     {\n@@ -2550,10 +2551,6 @@ satisfy_constraint (tree t, tree args, subst_info info)\n   /* We need to check access during satisfaction.  */\n   deferring_access_check_sentinel acs (dk_no_deferred);\n \n-  /* Avoid early exit in tsubst and tsubst_copy from null args.  */\n-  if (args == NULL_TREE)\n-    args = make_tree_vec (1);\n-\n   return satisfy_constraint_r (t, args, info);\n }\n \n@@ -2808,7 +2805,16 @@ finish_compound_requirement (location_t loc, tree expr, tree type, bool noexcept\n tree\n finish_nested_requirement (location_t loc, tree expr)\n {\n-  tree r = build_nt (NESTED_REQ, expr);\n+  /* Save the normalized constraint and complete set of normalization\n+     arguments with the requirement.  We keep the complete set of arguments\n+     around for re-normalization during diagnostics.  */\n+  tree args = current_template_parms\n+    ? template_parms_to_args (current_template_parms) : NULL_TREE;\n+  tree norm = normalize_constraint_expression (expr, args, false);\n+  tree info = build_tree_list (args, norm);\n+\n+  /* Build the constraint, saving its normalization as its type.  */\n+  tree r = build1 (NESTED_REQ, info, expr);\n   SET_EXPR_LOCATION (r, loc);\n   return r;\n }\n@@ -3169,15 +3175,21 @@ diagnose_type_requirement (tree req, tree args, tree in_decl)\n static void\n diagnose_nested_requirement (tree req, tree args)\n {\n-  tree expr = TREE_OPERAND (req, 0);\n-  if (constraints_satisfied_p (expr, args))\n+  /* Quietly check for satisfaction first. We can elaborate details\n+     later if needed.  */\n+  tree norm = TREE_VALUE (TREE_TYPE (req));\n+  subst_info info (tf_none, NULL_TREE);\n+  tree result = satisfy_constraint (norm, args, info);\n+  if (result == boolean_true_node)\n     return;\n+\n+  tree expr = TREE_OPERAND (req, 0);\n   location_t loc = cp_expr_location (expr);\n   inform (loc, \"nested requirement %qE is not satisfied\", expr);\n \n   /* TODO: Replay the substitution to diagnose the error?  */\n   // subst_info noisy (tf_warning_or_error, NULL_TREE);\n-  // constraints_satisfied_p (expr, args, noisy);\n+  // satisfy_constraint (norm, args, info);\n }\n \n static void"}, {"sha": "7138aebebced53b0d36f00703c66811c02110b8c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=81a34a6b68184436726489b81d44267c40f6fbe7", "patch": "@@ -27347,17 +27347,6 @@ cp_parser_requires_expression (cp_parser *parser)\n   gcc_assert (cp_lexer_next_token_is_keyword (parser->lexer, RID_REQUIRES));\n   location_t loc = cp_lexer_consume_token (parser->lexer)->location;\n \n-  /* A requires-expression shall appear only within a concept\n-     definition or a requires-clause.\n-\n-     TODO: Implement this diagnostic correctly. */\n-  if (!processing_template_decl)\n-    {\n-      error_at (loc, \"a requires expression cannot appear outside a template\");\n-      cp_parser_skip_to_end_of_statement (parser);\n-      return error_mark_node;\n-    }\n-\n   /* This is definitely a requires-expression.  */\n   cp_parser_commit_to_tentative_parse (parser);\n "}, {"sha": "c8df1d090bc251d0109e94619c9b48a7f120021e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=81a34a6b68184436726489b81d44267c40f6fbe7", "patch": "@@ -10402,6 +10402,13 @@ any_template_parm_r (tree t, void *data)\n       if (TREE_TYPE (t))\n         WALK_SUBTREE (TREE_TYPE (t));\n       break;\n+\n+    case PARM_DECL:\n+      /* A parameter or constraint variable may also depend on a template\n+\t parameter without explicitly naming it.  */\n+      WALK_SUBTREE (TREE_TYPE (t));\n+      break;\n+\n     default:\n       break;\n     }\n@@ -12071,7 +12078,23 @@ use_pack_expansion_extra_args_p (tree parm_packs,\n   if (parm_packs == NULL_TREE)\n     return false;\n   else if (has_empty_arg)\n-    return true;\n+    {\n+      /* If all the actual packs are pack expansions, we can still\n+\t subsitute directly.  */\n+      for (tree p = parm_packs; p; p = TREE_CHAIN (p))\n+\t{\n+\t  tree a = TREE_VALUE (p);\n+\t  if (TREE_CODE (a) == ARGUMENT_PACK_SELECT)\n+\t    a = ARGUMENT_PACK_SELECT_FROM_PACK (a);\n+\t  a = ARGUMENT_PACK_ARGS (a);\n+\t  if (TREE_VEC_LENGTH (a) == 1)\n+\t    a = TREE_VEC_ELT (a, 0);\n+\t  if (PACK_EXPANSION_P (a))\n+\t    continue;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n \n   bool has_expansion_arg = false;\n   for (int i = 0 ; i < arg_pack_len; ++i)\n@@ -12551,7 +12574,22 @@ add_extra_args (tree extra, tree args)\n       gcc_assert (!TREE_PURPOSE (extra));\n       extra = TREE_VALUE (extra);\n     }\n-  return add_to_template_args (extra, args);\n+#if 1\n+  /* I think we should always be able to substitute dependent args into the\n+     pattern.  If that turns out to be incorrect in some cases, enable the\n+     alternate code (and add complain/in_decl parms to this function).  */\n+  gcc_checking_assert (!uses_template_parms (extra));\n+#else\n+  if (!uses_template_parms (extra))\n+    {\n+      gcc_unreachable ();\n+      extra = tsubst_template_args (extra, args, complain, in_decl);\n+      args = add_outermost_template_args (args, extra);\n+    }\n+  else\n+#endif\n+    args = add_to_template_args (extra, args);\n+  return args;\n }\n \n /* Substitute ARGS into T, which is an pack expansion"}, {"sha": "9d9d0d9f50850e7f37556b3dd33c74cb276ef9bd", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires18.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C?ref=81a34a6b68184436726489b81d44267c40f6fbe7", "patch": "@@ -0,0 +1,77 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept integer = __is_same_as(T, int);\n+\n+template<typename T>\n+concept subst = requires (T x) { requires true; };\n+\n+template<typename T>\n+concept c1 = requires { requires integer<T> || subst<T&>; }; // { dg-message \"in requirements\" }\n+\n+static_assert(requires { requires true; });\n+static_assert(requires { requires false; }); // { dg-error \"static assertion failed\" }\n+static_assert(requires { requires integer<int>; });\n+static_assert(requires { requires integer<void>; }); // { dg-error \"static assertion failed\" }\n+static_assert(requires { requires c1<int>; });\n+static_assert(requires { requires c1<bool>; });\n+static_assert(requires { requires c1<void>; }); // { dg-error \"static assertion failed\" }\n+static_assert(requires { requires subst<void&>; }); // { dg-error \"cannot declare|failed\" }\n+\n+static_assert(c1<int>);\n+static_assert(c1<bool>);\n+static_assert(c1<void>); // { dg-error \"static assertion failed\" }\n+\n+template<c1 T>\n+void f1() { }\n+\n+template<typename T>\n+  requires requires { requires integer<T> || subst<T&>; } // { dg-message \"in requirements\" }\n+void f2();\n+\n+template<typename T>\n+struct data\n+{\n+  template<c1 U>\n+  void f1() {}\n+\n+  template<typename U>\n+    requires requires { requires integer<U> || subst<U&>; } // { dg-message in requirements\" }\n+  void f2() {}\n+\n+  static_assert(requires { requires subst<T&>; }); // { dg-error \"forming reference|failed\" }\n+\n+  template<typename U>\n+  constexpr bool test()\n+  {\n+    if constexpr (requires { requires subst<U&>; }) // { dg-error \"forming reference\" }\n+      return true;\n+    else\n+      return false;\n+  }\n+};\n+\n+void test()\n+{\n+  f1<int>();\n+  f1<bool>();\n+  f1<void>(); // { dg-error \"unsatisfied\" }\n+\n+  f2<int>();\n+  f2<bool>();\n+  f2<void>(); // { dg-error \"unsatisfied\" }\n+\n+  data<char> x;\n+  x.f1<int>();\n+  x.f1<bool>();\n+  x.f1<void>(); // { dg-error \"no matching function\" }\n+  x.f2<int>();\n+  x.f2<bool>();\n+  x.f2<void>(); // { dg-error \"no matching function\" }\n+\n+  data<void> fail;\n+\n+  data<int> t;\n+  static_assert(t.test<int>());\n+  static_assert(t.test<void>()); // { dg-error \"static assertion failed\" }\n+}"}, {"sha": "071a838f754f007159ec69df938188733b1abae3", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires19.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires19.C?ref=81a34a6b68184436726489b81d44267c40f6fbe7", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename T>\n+concept check_c = false;\n+\n+template<typename T>\n+concept c1 = requires (T x) {\n+ requires check_c<decltype(x)>;\n+};\n+\n+template<c1 T>\n+void f1() { }\n+\n+template<typename T>\n+void f2(T x) requires requires { requires check_c<decltype(x)>; } { }\n+\n+\n+template<typename T>\n+constexpr bool check_f() { return false; }\n+\n+template<typename T>\n+concept c2 = requires (T x) {\n+ requires check_f<decltype(x)>();\n+};\n+\n+template<c2 T>\n+void f3() { }\n+\n+template<typename T>\n+void f4(T x) requires requires { requires check_f<decltype(x)>(); } { }\n+\n+\n+template<typename T>\n+constexpr bool check_v = false;\n+\n+template<typename T>\n+concept c3 = requires (T x) {\n+ requires check_v<decltype(x)>;\n+};\n+\n+template<c3 T>\n+void f5() { }\n+\n+template<typename T>\n+void f6(T x) requires requires { requires check_v<decltype(x)>; } { }\n+\n+\n+void test()\n+{\n+  f1<int>(); // { dg-error \"unsatisfied\" }\n+  f2(0); // { dg-error \"unsatisfied\" }\n+\n+  f3<int>(); // { dg-error \"unsatisfied\" }\n+  f4(0); // { dg-error \"unsatisfied\" }\n+\n+  f5<int>(); // { dg-error \"unsatisfied\" }\n+  f6(0); // { dg-error \"unsatisfied\" }\n+}"}, {"sha": "ae556cad73b9f9b5269a551f628a8296200abcbf", "filename": "gcc/testsuite/lib/prune.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Ftestsuite%2Flib%2Fprune.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81a34a6b68184436726489b81d44267c40f6fbe7/gcc%2Ftestsuite%2Flib%2Fprune.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fprune.exp?ref=81a34a6b68184436726489b81d44267c40f6fbe7", "patch": "@@ -36,6 +36,7 @@ proc prune_gcc_output { text } {\n     regsub -all \"(^|\\n)\\[^\\n\\]*:   (recursively )?required \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*:   . skipping \\[0-9\\]* instantiation contexts \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*:   in constexpr expansion \\[^\\n\\]*\" $text \"\" text\n+    regsub -all \"(^|\\n)\\[^\\n\\]*:   in requirements \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)    inlined from \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)collect2: error: ld returned \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)collect: re(compiling|linking)\\[^\\n\\]*\" $text \"\" text"}]}