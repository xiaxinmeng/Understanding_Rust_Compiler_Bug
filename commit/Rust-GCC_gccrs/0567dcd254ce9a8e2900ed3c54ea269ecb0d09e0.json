{"sha": "0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU2N2RjZDI1NGNlOWE4ZTI5MDBlZDNjNTRlYTI2OWVjYjBkMDllMA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2015-04-15T14:46:22Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2015-04-15T14:46:22Z"}, "message": "constexpr.c (use_new_call): Remove #define.\n\n\t* constexpr.c (use_new_call): Remove #define.\n\t(lookup_parameter_binding): Remove function.\n\t(cxx_bind_parameters_in_call): Remove unused code.\n\t(cxx_eval_call_expression): Likewise.\n\t(cxx_eval_constant_expression): Likewise.\n\nFrom-SVN: r222126", "tree": {"sha": "1d38274a741f121259e24fbd6db2194679dcaca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d38274a741f121259e24fbd6db2194679dcaca0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5141ed426365a752343b2a8961d7b578f255b769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5141ed426365a752343b2a8961d7b578f255b769", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5141ed426365a752343b2a8961d7b578f255b769"}], "stats": {"total": 210, "additions": 77, "deletions": 133}, "files": [{"sha": "15a1b8baf059d46b94f7b929016efe7a20bf8d1a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0", "patch": "@@ -1,3 +1,11 @@\n+2015-04-15  Marek Polacek  <polacek@redhat.com>\n+\n+\t* constexpr.c (use_new_call): Remove #define.\n+\t(lookup_parameter_binding): Remove function.\n+\t(cxx_bind_parameters_in_call): Remove unused code.\n+\t(cxx_eval_call_expression): Likewise.\n+\t(cxx_eval_constant_expression): Likewise.\n+\n 2015-04-14  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \t* tree.c (replace_placeholders_t): Remove unused type."}, {"sha": "60f0a790f858fe6d45db3f5d25b447da7dedb3b8", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 69, "deletions": 133, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=0567dcd254ce9a8e2900ed3c54ea269ecb0d09e0", "patch": "@@ -1000,16 +1000,6 @@ get_nth_callarg (tree t, int n)\n     }\n }\n \n-/* Look up the binding of the function parameter T in a constexpr\n-   function call context CALL.  */\n-\n-static tree\n-lookup_parameter_binding (const constexpr_call *call, tree t)\n-{\n-  tree b = purpose_member (t, call->bindings);\n-  return TREE_VALUE (b);\n-}\n-\n /* Attempt to evaluate T which represents a call to a builtin function.\n    We assume here that all builtin functions evaluate to scalar types\n    represented by _CST nodes.  */\n@@ -1054,10 +1044,6 @@ adjust_temp_type (tree type, tree temp)\n   return cp_fold_convert (type, temp);\n }\n \n-/* True if we want to use the new handling of constexpr calls based on\n-   DECL_SAVED_TREE.  */\n-#define use_new_call true\n-\n /* Subroutine of cxx_eval_call_expression.\n    We are processing a call expression (either CALL_EXPR or\n    AGGR_INIT_EXPR) in the context of CTX.  Evaluate\n@@ -1090,18 +1076,6 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t  x = cp_build_addr_expr (x, tf_warning_or_error);\n \t}\n       bool lval = false;\n-      if (parms && DECL_BY_REFERENCE (parms) && !use_new_call)\n-\t{\n-\t  /* cp_genericize made this a reference for argument passing, but\n-\t     we don't want to treat it like one for C++11 constexpr\n-\t     evaluation.  C++14 constexpr evaluation uses the genericized\n-\t     DECL_SAVED_TREE.  */\n-\t  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n-\t  gcc_assert (TREE_CODE (TREE_TYPE (x)) == REFERENCE_TYPE);\n-\t  type = TREE_TYPE (type);\n-\t  x = convert_from_reference (x);\n-\t  lval = true;\n-\t}\n       arg = cxx_eval_constant_expression (ctx, x, lval,\n \t\t\t\t\t  non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n@@ -1336,113 +1310,88 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n     {\n       if (!result || result == error_mark_node)\n \t{\n-\t  if (!use_new_call)\n+\t  if (DECL_SAVED_TREE (fun) == NULL_TREE\n+\t      && (DECL_CONSTRUCTOR_P (fun) || DECL_DESTRUCTOR_P (fun)))\n+\t    /* The maybe-in-charge 'tor had its DECL_SAVED_TREE\n+\t       cleared, try a clone.  */\n+\t    for (fun = DECL_CHAIN (fun);\n+\t\t fun && DECL_CLONED_FUNCTION_P (fun);\n+\t\t fun = DECL_CHAIN (fun))\n+\t      if (DECL_SAVED_TREE (fun))\n+\t\tbreak;\n+\t  gcc_assert (DECL_SAVED_TREE (fun));\n+\t  tree parms, res;\n+\n+\t  /* Unshare the whole function body.  */\n+\t  tree body = copy_fn (fun, parms, res);\n+\n+\t  /* Associate the bindings with the remapped parms.  */\n+\t  tree bound = new_call.bindings;\n+\t  tree remapped = parms;\n+\t  while (bound)\n \t    {\n-\t      new_ctx.call = &new_call;\n-\t      result = (cxx_eval_constant_expression\n-\t\t\t(&new_ctx, new_call.fundef->body,\n-\t\t\t lval,\n-\t\t\t non_constant_p, overflow_p));\n+\t      tree oparm = TREE_PURPOSE (bound);\n+\t      tree arg = TREE_VALUE (bound);\n+\t      gcc_assert (DECL_NAME (remapped) == DECL_NAME (oparm));\n+\t      ctx->values->put (remapped, arg);\n+\t      bound = TREE_CHAIN (bound);\n+\t      remapped = DECL_CHAIN (remapped);\n \t    }\n-\t  else\n+\t  /* Add the RESULT_DECL to the values map, too.  */\n+\t  tree slot = NULL_TREE;\n+\t  if (DECL_BY_REFERENCE (res))\n \t    {\n-\t      if (DECL_SAVED_TREE (fun) == NULL_TREE\n-\t\t  && (DECL_CONSTRUCTOR_P (fun) || DECL_DESTRUCTOR_P (fun)))\n-\t\t/* The maybe-in-charge 'tor had its DECL_SAVED_TREE\n-\t\t   cleared, try a clone.  */\n-\t\tfor (fun = DECL_CHAIN (fun);\n-\t\t     fun && DECL_CLONED_FUNCTION_P (fun);\n-\t\t     fun = DECL_CHAIN (fun))\n-\t\t  if (DECL_SAVED_TREE (fun))\n-\t\t    break;\n-\t      gcc_assert (DECL_SAVED_TREE (fun));\n-\t      tree parms, res;\n+\t      slot = AGGR_INIT_EXPR_SLOT (t);\n+\t      tree addr = build_address (slot);\n+\t      addr = build_nop (TREE_TYPE (res), addr);\n+\t      ctx->values->put (res, addr);\n+\t      ctx->values->put (slot, NULL_TREE);\n+\t    }\n+\t  else\n+\t    ctx->values->put (res, NULL_TREE);\n \n-\t      /* Unshare the whole function body.  */\n-\t      tree body = copy_fn (fun, parms, res);\n+\t  tree jump_target = NULL_TREE;\n+\t  cxx_eval_constant_expression (ctx, body,\n+\t\t\t\t\tlval, non_constant_p, overflow_p,\n+\t\t\t\t\t&jump_target);\n \n-\t      /* Associate the bindings with the remapped parms.  */\n-\t      tree bound = new_call.bindings;\n-\t      tree remapped = parms;\n-\t      while (bound)\n-\t\t{\n-\t\t  tree oparm = TREE_PURPOSE (bound);\n-\t\t  tree arg = TREE_VALUE (bound);\n-\t\t  gcc_assert (DECL_NAME (remapped) == DECL_NAME (oparm));\n-\t\t  ctx->values->put (remapped, arg);\n-\t\t  bound = TREE_CHAIN (bound);\n-\t\t  remapped = DECL_CHAIN (remapped);\n-\t\t}\n-\t      /* Add the RESULT_DECL to the values map, too.  */\n-\t      tree slot = NULL_TREE;\n-\t      if (DECL_BY_REFERENCE (res))\n-\t\t{\n-\t\t  slot = AGGR_INIT_EXPR_SLOT (t);\n-\t\t  tree addr = build_address (slot);\n-\t\t  addr = build_nop (TREE_TYPE (res), addr);\n-\t\t  ctx->values->put (res, addr);\n-\t\t  ctx->values->put (slot, NULL_TREE);\n-\t\t}\n-\t      else\n-\t\tctx->values->put (res, NULL_TREE);\n-\n-\t      tree jump_target = NULL_TREE;\n-\t      cxx_eval_constant_expression (ctx, body,\n-\t\t\t\t\t    lval, non_constant_p, overflow_p,\n-\t\t\t\t\t    &jump_target);\n-\n-\t      if (DECL_CONSTRUCTOR_P (fun))\n-\t\t/* This can be null for a subobject constructor call, in\n-\t\t   which case what we care about is the initialization\n-\t\t   side-effects rather than the value.  We could get at the\n-\t\t   value by evaluating *this, but we don't bother; there's\n-\t\t   no need to put such a call in the hash table.  */\n-\t\tresult = lval ? ctx->object : ctx->ctor;\n-\t      else if (VOID_TYPE_P (TREE_TYPE (res)))\n-\t\tresult = void_node;\n-\t      else\n+\t  if (DECL_CONSTRUCTOR_P (fun))\n+\t    /* This can be null for a subobject constructor call, in\n+\t       which case what we care about is the initialization\n+\t       side-effects rather than the value.  We could get at the\n+\t       value by evaluating *this, but we don't bother; there's\n+\t       no need to put such a call in the hash table.  */\n+\t    result = lval ? ctx->object : ctx->ctor;\n+\t  else if (VOID_TYPE_P (TREE_TYPE (res)))\n+\t    result = void_node;\n+\t  else\n+\t    {\n+\t      result = *ctx->values->get (slot ? slot : res);\n+\t      if (result == NULL_TREE && !*non_constant_p)\n \t\t{\n-\t\t  result = *ctx->values->get (slot ? slot : res);\n-\t\t  if (result == NULL_TREE && !*non_constant_p)\n-\t\t    {\n-\t\t      if (!ctx->quiet)\n-\t\t\terror (\"constexpr call flows off the end \"\n-\t\t\t       \"of the function\");\n-\t\t      *non_constant_p = true;\n-\t\t    }\n+\t\t  if (!ctx->quiet)\n+\t\t    error (\"constexpr call flows off the end \"\n+\t\t\t   \"of the function\");\n+\t\t  *non_constant_p = true;\n \t\t}\n-\n-\t      /* Remove the parms/result from the values map.  Is it worth\n-\t\t bothering to do this when the map itself is only live for\n-\t\t one constexpr evaluation?  If so, maybe also clear out\n-\t\t other vars from call, maybe in BIND_EXPR handling?  */\n-\t      ctx->values->remove (res);\n-\t      if (slot)\n-\t\tctx->values->remove (slot);\n-\t      for (tree parm = parms; parm; parm = TREE_CHAIN (parm))\n-\t\tctx->values->remove (parm);\n \t    }\n+\n+\t  /* Remove the parms/result from the values map.  Is it worth\n+\t     bothering to do this when the map itself is only live for\n+\t     one constexpr evaluation?  If so, maybe also clear out\n+\t     other vars from call, maybe in BIND_EXPR handling?  */\n+\t  ctx->values->remove (res);\n+\t  if (slot)\n+\t    ctx->values->remove (slot);\n+\t  for (tree parm = parms; parm; parm = TREE_CHAIN (parm))\n+\t    ctx->values->remove (parm);\n \t}\n \n       if (result == error_mark_node)\n \t*non_constant_p = true;\n       if (*non_constant_p)\n \tresult = error_mark_node;\n-      else if (result)\n-\t{\n-\t  /* If this was a call to initialize an object, set the type of\n-\t     the CONSTRUCTOR to the type of that object.  */\n-\t  if (DECL_CONSTRUCTOR_P (fun) && !use_new_call)\n-\t    {\n-\t      tree ob_arg = get_nth_callarg (t, 0);\n-\t      STRIP_NOPS (ob_arg);\n-\t      gcc_assert (TYPE_PTR_P (TREE_TYPE (ob_arg))\n-\t\t\t  && CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (ob_arg))));\n-\t      result = adjust_temp_type (TREE_TYPE (TREE_TYPE (ob_arg)),\n-\t\t\t\t\t result);\n-\t    }\n-\t}\n-      else\n+      else if (!result)\n \tresult = void_node;\n       if (entry)\n \tentry->result = result;\n@@ -3048,10 +2997,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       return t;\n \n     case PARM_DECL:\n-      if (!use_new_call && ctx\n-\t  && ctx->call && DECL_CONTEXT (t) == ctx->call->fundef->decl)\n-\tr = lookup_parameter_binding (ctx->call, t);\n-      else if (lval && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n+      if (lval && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n \t/* glvalue use.  */;\n       else if (tree *p = ctx->values->get (r))\n \tr = *p;\n@@ -3148,16 +3094,6 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case INIT_EXPR:\n-      if (!use_new_call)\n-\t{\n-\t  /* In C++11 constexpr evaluation we are looking for the value,\n-\t     not the side-effect of the initialization.  */\n-\t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\t    false,\n-\t\t\t\t\t    non_constant_p, overflow_p);\n-\t  break;\n-\t}\n-      /* else fall through */\n     case MODIFY_EXPR:\n       r = cxx_eval_store_expression (ctx, t, lval,\n \t\t\t\t     non_constant_p, overflow_p);"}]}