{"sha": "e8037d57d481fa2e962a527b6dbe76828b6945a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwMzdkNTdkNDgxZmEyZTk2MmE1MjdiNmRiZTc2ODI4YjY5NDVhMg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-05-12T02:33:33Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-05-12T02:33:33Z"}, "message": "cpplib.c (line_for_error): Make it work; add extra parameter.\n\n* cpplib.c (line_for_error):  Make it work; add extra parameter.\n(skip_quoted_string, cpp_get_token):  Update calls to line_for_error.\n(macroexpand):  Remember initial line so we can report it if the\ncall is unterminated.  Also, simplify error logic slightly.\n(do_include):  Cast alloca return value, to avoid pcc warning.\n\nFrom-SVN: r9635", "tree": {"sha": "1c212eea34cb934a7954919a97a90631c626c929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c212eea34cb934a7954919a97a90631c626c929"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8037d57d481fa2e962a527b6dbe76828b6945a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8037d57d481fa2e962a527b6dbe76828b6945a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8037d57d481fa2e962a527b6dbe76828b6945a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8037d57d481fa2e962a527b6dbe76828b6945a2/comments", "author": null, "committer": null, "parents": [{"sha": "8f4686fad562f43e21804ac20d8096d62c36b4c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4686fad562f43e21804ac20d8096d62c36b4c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4686fad562f43e21804ac20d8096d62c36b4c6"}], "stats": {"total": 73, "additions": 32, "deletions": 41}, "files": [{"sha": "f0411a3783de16b5df850c9d27ac3ead3957c412", "filename": "gcc/cpplib.c", "status": "modified", "additions": 32, "deletions": 41, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8037d57d481fa2e962a527b6dbe76828b6945a2/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8037d57d481fa2e962a527b6dbe76828b6945a2/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=e8037d57d481fa2e962a527b6dbe76828b6945a2", "patch": "@@ -512,7 +512,7 @@ skip_quoted_string (pfile, first, start_line)\n       c = GETC ();\n       if (c == EOF)\n \t{\n-\t  cpp_error_with_line (pfile, line_for_error (start_line),\n+\t  cpp_error_with_line (pfile, line_for_error (pfile, start_line),\n \t\t\t       \"unterminated string or character constant\");\n #if 0\n \t  cpp_error_with_line (pfile, multiline_string_line,\n@@ -536,7 +536,7 @@ skip_quoted_string (pfile, first, start_line)\n \t    }\n \t  if (CPP_PEDANTIC (pfile) || first == '\\'')\n \t    {\n-\t      cpp_error_with_line (pfile, line_for_error (start_line),\n+\t      cpp_error_with_line (pfile, line_for_error (pfile, start_line),\n \t\t\t\t   \"unterminated string or character constant\");\n \t      FORWARD(-1);\n \t      break;\n@@ -2707,6 +2707,7 @@ macroexpand (pfile, hp)\n   int nargs;\n   DEFINITION *defn = hp->value.defn;\n   register U_CHAR *xbuf;\n+  long start_line, start_col;\n   int xbuf_len;\n   struct argdata *args;\n   long old_written = CPP_WRITTEN (pfile);\n@@ -2728,12 +2729,12 @@ macroexpand (pfile, hp)\n #endif\n \n   pfile->output_escapes++;\n-  \n+  cpp_buf_line_and_col (CPP_BUFFER (pfile), &start_line, &start_col);\n+\n   nargs = defn->nargs;\n \n   if (nargs >= 0)\n     {\n-      char *parse_error = 0;\n       enum cpp_token token;\n \n       args = (struct argdata *) alloca ((nargs + 1) * sizeof (struct argdata));\n@@ -2772,13 +2773,9 @@ macroexpand (pfile, hp)\n \t    token = macarg (pfile, 0);\n \t  if (token == CPP_EOF || token == CPP_POP)\n \t    {\n-\t      parse_error = \"unterminated macro call\";\n-#if 1\n-\t      cpp_error_with_line (pfile, line_for_error (0), parse_error);\n-#else\n-\t      cpp_error_with_line (pfile, line_for_error (start_line), parse_error);\n-#endif\n-\t      break;\n+\t      cpp_error_with_line (pfile, line_for_error (pfile, start_line),\n+\t\t\t\t   \"unterminated macro call\");\n+\t      return;\n \t    }\n \t  i++;\n \t} while (token == CPP_COMMA);\n@@ -2801,8 +2798,7 @@ macroexpand (pfile, hp)\n       rest_zero = 0;\n       if (nargs == 0 && i > 0)\n \t{\n-\t  if (! parse_error)\n-\t    cpp_error (pfile, \"arguments given to macro `%s'\", hp->name);\n+\t  cpp_error (pfile, \"arguments given to macro `%s'\", hp->name);\n \t}\n       else if (i < nargs)\n \t{\n@@ -2812,8 +2808,6 @@ macroexpand (pfile, hp)\n \t  /* the rest args token is allowed to absorb 0 tokens */\n \t  else if (i == nargs - 1 && defn->rest_args)\n \t    rest_zero = 1;\n-\t  else if (parse_error)\n-\t    ;\n \t  else if (i == 0)\n \t    cpp_error (pfile, \"macro `%s' used without args\", hp->name);\n \t  else if (i == 1)\n@@ -2824,9 +2818,8 @@ macroexpand (pfile, hp)\n       }\n       else if (i > nargs)\n \t{\n-\t  if (! parse_error)\n-\t    cpp_error (pfile,\n-\t\t       \"macro `%s' used with too many (%d) args\", hp->name, i);\n+\t  cpp_error (pfile,\n+\t\t     \"macro `%s' used with too many (%d) args\", hp->name, i);\n \t}\n     }\n \n@@ -3461,8 +3454,8 @@ do_include (pfile, keyword, unused1, unused2)\n \n \t\t      if (searchptr->fname[0] == 0)\n \t\t\tcontinue;\n-\t\t      p = alloca (strlen (searchptr->fname)\n-\t\t\t\t   + strlen (fname) + 2);\n+\t\t      p = (char *) alloca (strlen (searchptr->fname)\n+\t\t\t\t\t   + strlen (fname) + 2);\n \t\t      strcpy (p, searchptr->fname);\n \t\t      strcat (p, \"/\");\n \t\t      strcat (p, fname);\n@@ -4716,7 +4709,8 @@ cpp_get_token (pfile)\n \t    goto randomchar;\n \t  if (c == EOF)\n \t    {\n-\t      cpp_error_with_line (pfile, line_for_error (pfile->start_line),\n+\t      cpp_error_with_line (pfile,\n+\t\t\t\t   line_for_error (pfile, pfile->start_line),\n \t\t\t\t   \"unterminated comment\");\n \t      goto handle_eof;\n \t    }\n@@ -4847,7 +4841,8 @@ cpp_get_token (pfile)\n #if 0\n \t\t  if (!CPP_TRADITIONAL (pfile))\n \t\t    {\n-\t\t      cpp_error_with_line (pfile, line_for_error (start_line),\n+\t\t      cpp_error_with_line (pfile,\n+\t\t\t\t\t   line_for_error (pfile, start_line),\n \t\t\t      \"unterminated string or character constant\");\n \t\t      cpp_error_with_line (pfile, multiline_string_line,\n \t\t\t\t \"possible real start of unterminated constant\");\n@@ -4867,14 +4862,15 @@ cpp_get_token (pfile)\n #if 0\n \t\t  if (c == '\\'')\n \t\t    {\n-\t\t      cpp_error_with_line (pfile, line_for_error (start_line),\n-\t\t\t\t     \"unterminated character constant\");\n+\t\t      cpp_error_with_line (pfile,\n+\t\t\t\t\t   line_for_error (pfile, start_line),\n+\t\t\t\t\t   \"unterminated character constant\");\n \t\t      goto while2end;\n \t\t    }\n \t\t  if (CPP_PEDANTIC (pfile) && multiline_string_line == 0)\n \t\t    {\n \t\t      cpp_pedwarn_with_line (pfile,\n-\t\t\t\t\t     line_for_error (start_line),\n+\t\t\t\t\t     line_for_error (pfile, start_line),\n \t\t\t       \"string constant runs past end of line\");\n \t\t    }\n \t\t  if (multiline_string_line == 0)\n@@ -7281,25 +7277,20 @@ savestring (input)\n    In that case, we return the lineno of the innermost file.  */\n \n static int\n-line_for_error (line)\n+line_for_error (pfile, line)\n+     cpp_reader *pfile;\n      int line;\n {\n-#if 0\n-  int i;\n-  int line1 = line;\n+  long line1 = line, col;\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n \n-  for (i = indepth; i >= 0; ) {\n-    if (instack[i].fname != 0)\n-      return line1;\n-    i--;\n-    if (i < 0)\n-      return 0;\n-    line1 = instack[i].lineno;\n-  }\n-  abort ();\n-  /*NOTREACHED*/\n-#endif\n-  return 0;\n+  while (ip != CPP_NULL_BUFFER (pfile))\n+    {\n+      if (ip->fname != NULL)\n+\treturn line1;\n+      ip = CPP_PREV_BUFFER (ip);\n+      cpp_buf_line_and_col (ip, &line1, &col);\n+    }\n }\n \f\n /* Initialize PMARK to remember the current position of PFILE. */"}]}