{"sha": "1a80d6b87d81c3f336ab199a901cf80ae349c335", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4MGQ2Yjg3ZDgxYzNmMzM2YWIxOTlhOTAxY2Y4MGFlMzQ5YzMzNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-11-26T10:18:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-11-26T10:18:50Z"}, "message": "re PR tree-optimization/68128 (A huge regression in Parboil v2.5 OpenMP CUTCP test (2.5 times lower performance))\n\n\tPR tree-optimization/68128\n\t* tree.h (OMP_CLAUSE_SHARED_READONLY): Define.\n\t* gimplify.c: Include gimple-walk.h.\n\t(enum gimplify_omp_var_data): Add GOVD_WRITTEN.\n\t(omp_notice_variable): Set flags to n->value if n already\n\texists in target region, but we need to jump to do_outer.\n\t(omp_shared_to_firstprivate_optimizable_decl_p,\n\tomp_mark_stores, omp_find_stores_op, omp_find_stores_stmt): New\n\tfunctions.\n\t(gimplify_adjust_omp_clauses_1): Set OMP_CLAUSE_SHARED_READONLY\n\ton OMP_CLAUSE_SHARED if it is a scalar non-addressable that is\n\tnot modified in the body.  Call omp_mark_stores for outer\n\tcontexts on OMP_CLAUSE_SHARED clauses if they could be written\n\tin the body or on OMP_CLAUSE_LASTPRIVATE.\n\t(gimplify_adjust_omp_clauses): Add body argument, call\n\tomp_find_stores_{stmt,op} on the body through walk_gimple_seq.\n\tSet OMP_CLAUSE_SHARED_READONLY\n\ton OMP_CLAUSE_SHARED if it is a scalar non-addressable that is\n\tnot modified in the body.  Call omp_mark_stores for outer\n\tcontexts on OMP_CLAUSE_SHARED clauses if they could be written\n\tin the body or on OMP_CLAUSE_LASTPRIVATE or on OMP_CLAUSE_LINEAR\n\twithout OMP_CLAUSE_LINEAR_NO_COPYOUT or on OMP_CLAUSE_REDUCTION.\n\t(gimplify_oacc_cache, gimplify_omp_parallel, gimplify_omp_task,\n\tgimplify_omp_for, gimplify_omp_workshare, gimplify_omp_target_update,\n\tgimplify_expr): Adjust gimplify_adjust_omp_clauses callers.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Clear OMP_CLAUSE_SHARED_READONLY on\n\tnon-local vars or local vars referenced from nested routines.\n\t* omp-low.c (scan_sharing_clauses): For OMP_CLAUSE_SHARED_READONLY\n\tattempt to optimize it into OMP_CLAUSE_FIRSTPRIVATE.  Even for\n\tTREE_READONLY, don't call use_pointer_for_field with non-NULL\n\tsecond argument until we are sure we are keeping OMP_CLAUSE_SHARED.\n\n\t* gcc.dg/gomp/pr68128-1.c: New test.\n\t* gcc.dg/gomp/pr68128-2.c: New test.\n\nFrom-SVN: r230932", "tree": {"sha": "85be78539b8853a0e9fa3ba945ad098e66357002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85be78539b8853a0e9fa3ba945ad098e66357002"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a80d6b87d81c3f336ab199a901cf80ae349c335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a80d6b87d81c3f336ab199a901cf80ae349c335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a80d6b87d81c3f336ab199a901cf80ae349c335", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a80d6b87d81c3f336ab199a901cf80ae349c335/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a37a22da2d9304489f6e4b91d0a357c25e0a0a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37a22da2d9304489f6e4b91d0a357c25e0a0a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a37a22da2d9304489f6e4b91d0a357c25e0a0a79"}], "stats": {"total": 480, "additions": 467, "deletions": 13}, "files": [{"sha": "c021524d79f53e67eb820766edc0d1cf1367feec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a80d6b87d81c3f336ab199a901cf80ae349c335", "patch": "@@ -1,3 +1,38 @@\n+2015-11-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/68128\n+\t* tree.h (OMP_CLAUSE_SHARED_READONLY): Define.\n+\t* gimplify.c: Include gimple-walk.h.\n+\t(enum gimplify_omp_var_data): Add GOVD_WRITTEN.\n+\t(omp_notice_variable): Set flags to n->value if n already\n+\texists in target region, but we need to jump to do_outer.\n+\t(omp_shared_to_firstprivate_optimizable_decl_p,\n+\tomp_mark_stores, omp_find_stores_op, omp_find_stores_stmt): New\n+\tfunctions.\n+\t(gimplify_adjust_omp_clauses_1): Set OMP_CLAUSE_SHARED_READONLY\n+\ton OMP_CLAUSE_SHARED if it is a scalar non-addressable that is\n+\tnot modified in the body.  Call omp_mark_stores for outer\n+\tcontexts on OMP_CLAUSE_SHARED clauses if they could be written\n+\tin the body or on OMP_CLAUSE_LASTPRIVATE.\n+\t(gimplify_adjust_omp_clauses): Add body argument, call\n+\tomp_find_stores_{stmt,op} on the body through walk_gimple_seq.\n+\tSet OMP_CLAUSE_SHARED_READONLY\n+\ton OMP_CLAUSE_SHARED if it is a scalar non-addressable that is\n+\tnot modified in the body.  Call omp_mark_stores for outer\n+\tcontexts on OMP_CLAUSE_SHARED clauses if they could be written\n+\tin the body or on OMP_CLAUSE_LASTPRIVATE or on OMP_CLAUSE_LINEAR\n+\twithout OMP_CLAUSE_LINEAR_NO_COPYOUT or on OMP_CLAUSE_REDUCTION.\n+\t(gimplify_oacc_cache, gimplify_omp_parallel, gimplify_omp_task,\n+\tgimplify_omp_for, gimplify_omp_workshare, gimplify_omp_target_update,\n+\tgimplify_expr): Adjust gimplify_adjust_omp_clauses callers.\n+\t* tree-nested.c (convert_nonlocal_omp_clauses,\n+\tconvert_local_omp_clauses): Clear OMP_CLAUSE_SHARED_READONLY on\n+\tnon-local vars or local vars referenced from nested routines.\n+\t* omp-low.c (scan_sharing_clauses): For OMP_CLAUSE_SHARED_READONLY\n+\tattempt to optimize it into OMP_CLAUSE_FIRSTPRIVATE.  Even for\n+\tTREE_READONLY, don't call use_pointer_for_field with non-NULL\n+\tsecond argument until we are sure we are keeping OMP_CLAUSE_SHARED.\n+\n 2015-11-26  Paolo Bonzini <bonzini@gnu.org>\n \n \t* doc/implement-c.texi (Integers Implementation): Make GCC's promises"}, {"sha": "7fff12f13ee0758c813503ebe80abcd849999b4e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 180, "deletions": 10, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1a80d6b87d81c3f336ab199a901cf80ae349c335", "patch": "@@ -56,7 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cilk.h\"\n #include \"gomp-constants.h\"\n #include \"tree-dump.h\"\n-\n+#include \"gimple-walk.h\"\n #include \"langhooks-def.h\"\t/* FIXME: for lhd_set_decl_assembler_name */\n #include \"builtins.h\"\n \n@@ -87,6 +87,9 @@ enum gimplify_omp_var_data\n   /* Flag for GOVD_MAP, if it is always, to or always, tofrom mapping.  */\n   GOVD_MAP_ALWAYS_TO = 65536,\n \n+  /* Flag for shared vars that are or might be stored to in the region.  */\n+  GOVD_WRITTEN = 131072,\n+\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n \t\t\t   | GOVD_LOCAL)\n@@ -6153,7 +6156,8 @@ omp_notice_variable (struct gimplify_omp_ctx *ctx, tree decl, bool in_code)\n \t  /* If nothing changed, there's nothing left to do.  */\n \t  if ((n->value & flags) == flags)\n \t    return ret;\n-\t  n->value |= flags;\n+\t  flags |= n->value;\n+\t  n->value = flags;\n \t}\n       goto do_outer;\n     }\n@@ -7384,6 +7388,123 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n     delete struct_map_to_clause;\n }\n \n+/* Return true if DECL is a candidate for shared to firstprivate\n+   optimization.  We only consider non-addressable scalars, not\n+   too big, and not references.  */\n+\n+static bool\n+omp_shared_to_firstprivate_optimizable_decl_p (tree decl)\n+{\n+  if (TREE_ADDRESSABLE (decl))\n+    return false;\n+  tree type = TREE_TYPE (decl);\n+  if (!is_gimple_reg_type (type)\n+      || TREE_CODE (type) == REFERENCE_TYPE\n+      || TREE_ADDRESSABLE (type))\n+    return false;\n+  /* Don't optimize too large decls, as each thread/task will have\n+     its own.  */\n+  HOST_WIDE_INT len = int_size_in_bytes (type);\n+  if (len == -1 || len > 4 * POINTER_SIZE / BITS_PER_UNIT)\n+    return false;\n+  if (lang_hooks.decls.omp_privatize_by_reference (decl))\n+    return false;\n+  return true;\n+}\n+\n+/* Helper function of omp_find_stores_op and gimplify_adjust_omp_clauses*.\n+   For omp_shared_to_firstprivate_optimizable_decl_p decl mark it as\n+   GOVD_WRITTEN in outer contexts.  */\n+\n+static void\n+omp_mark_stores (struct gimplify_omp_ctx *ctx, tree decl)\n+{\n+  for (; ctx; ctx = ctx->outer_context)\n+    {\n+      splay_tree_node n = splay_tree_lookup (ctx->variables,\n+\t\t\t\t\t     (splay_tree_key) decl);\n+      if (n == NULL)\n+\tcontinue;\n+      else if (n->value & GOVD_SHARED)\n+\t{\n+\t  n->value |= GOVD_WRITTEN;\n+\t  return;\n+\t}\n+      else if (n->value & GOVD_DATA_SHARE_CLASS)\n+\treturn;\n+    }\n+}\n+\n+/* Helper callback for walk_gimple_seq to discover possible stores\n+   to omp_shared_to_firstprivate_optimizable_decl_p decls and set\n+   GOVD_WRITTEN if they are GOVD_SHARED in some outer context\n+   for those.  */\n+\n+static tree\n+omp_find_stores_op (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+\n+  *walk_subtrees = 0;\n+  if (!wi->is_lhs)\n+    return NULL_TREE;\n+\n+  tree op = *tp;\n+  do\n+    {\n+      if (handled_component_p (op))\n+\top = TREE_OPERAND (op, 0);\n+      else if ((TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n+\t       && TREE_CODE (TREE_OPERAND (op, 0)) == ADDR_EXPR)\n+\top = TREE_OPERAND (TREE_OPERAND (op, 0), 0);\n+      else\n+\tbreak;\n+    }\n+  while (1);\n+  if (!DECL_P (op) || !omp_shared_to_firstprivate_optimizable_decl_p (op))\n+    return NULL_TREE;\n+\n+  omp_mark_stores (gimplify_omp_ctxp, op);\n+  return NULL_TREE;\n+}\n+\n+/* Helper callback for walk_gimple_seq to discover possible stores\n+   to omp_shared_to_firstprivate_optimizable_decl_p decls and set\n+   GOVD_WRITTEN if they are GOVD_SHARED in some outer context\n+   for those.  */\n+\n+static tree\n+omp_find_stores_stmt (gimple_stmt_iterator *gsi_p,\n+\t\t      bool *handled_ops_p,\n+\t\t      struct walk_stmt_info *wi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi_p);\n+  switch (gimple_code (stmt))\n+    {\n+    /* Don't recurse on OpenMP constructs for which\n+       gimplify_adjust_omp_clauses already handled the bodies,\n+       except handle gimple_omp_for_pre_body.  */\n+    case GIMPLE_OMP_FOR:\n+      *handled_ops_p = true;\n+      if (gimple_omp_for_pre_body (stmt))\n+\twalk_gimple_seq (gimple_omp_for_pre_body (stmt),\n+\t\t\t omp_find_stores_stmt, omp_find_stores_op, wi);\n+      break;\n+    case GIMPLE_OMP_PARALLEL:\n+    case GIMPLE_OMP_TASK:\n+    case GIMPLE_OMP_SECTIONS:\n+    case GIMPLE_OMP_SINGLE:\n+    case GIMPLE_OMP_TARGET:\n+    case GIMPLE_OMP_TEAMS:\n+    case GIMPLE_OMP_CRITICAL:\n+      *handled_ops_p = true;\n+      break;\n+    default:\n+      break;\n+    }\n+  return NULL_TREE;\n+}\n+\n struct gimplify_adjust_omp_clauses_data\n {\n   tree *list_p;\n@@ -7455,13 +7576,22 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n   else\n     gcc_unreachable ();\n \n+  if (((flags & GOVD_LASTPRIVATE)\n+       || (code == OMP_CLAUSE_SHARED && (flags & GOVD_WRITTEN)))\n+      && omp_shared_to_firstprivate_optimizable_decl_p (decl))\n+    omp_mark_stores (gimplify_omp_ctxp->outer_context, decl);\n+\n   clause = build_omp_clause (input_location, code);\n   OMP_CLAUSE_DECL (clause) = decl;\n   OMP_CLAUSE_CHAIN (clause) = *list_p;\n   if (private_debug)\n     OMP_CLAUSE_PRIVATE_DEBUG (clause) = 1;\n   else if (code == OMP_CLAUSE_PRIVATE && (flags & GOVD_PRIVATE_OUTER_REF))\n     OMP_CLAUSE_PRIVATE_OUTER_REF (clause) = 1;\n+  else if (code == OMP_CLAUSE_SHARED\n+\t   && (flags & GOVD_WRITTEN) == 0\n+\t   && omp_shared_to_firstprivate_optimizable_decl_p (decl))\n+    OMP_CLAUSE_SHARED_READONLY (clause) = 1;\n   else if (code == OMP_CLAUSE_MAP && (flags & GOVD_MAP_0LEN_ARRAY) != 0)\n     {\n       tree nc = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n@@ -7562,12 +7692,26 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n }\n \n static void\n-gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n+gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t\t\t     enum tree_code code)\n {\n   struct gimplify_omp_ctx *ctx = gimplify_omp_ctxp;\n   tree c, decl;\n \n+  if (body)\n+    {\n+      struct gimplify_omp_ctx *octx;\n+      for (octx = ctx; octx; octx = octx->outer_context)\n+\tif ((octx->region_type & (ORT_PARALLEL | ORT_TASK | ORT_TEAMS)) != 0)\n+\t  break;\n+      if (octx)\n+\t{\n+\t  struct walk_stmt_info wi;\n+\t  memset (&wi, 0, sizeof (wi));\n+\t  walk_gimple_seq (body, omp_find_stores_stmt,\n+\t\t\t   omp_find_stores_op, &wi);\n+\t}\n+    }\n   while ((c = *list_p) != NULL)\n     {\n       splay_tree_node n;\n@@ -7594,6 +7738,18 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n \t\t  OMP_CLAUSE_SET_CODE (c, OMP_CLAUSE_PRIVATE);\n \t\t  OMP_CLAUSE_PRIVATE_DEBUG (c) = 1;\n \t\t}\n+\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED\n+\t\t  && (n->value & GOVD_WRITTEN) == 0\n+\t\t  && DECL_P (decl)\n+\t\t  && omp_shared_to_firstprivate_optimizable_decl_p (decl))\n+\t\tOMP_CLAUSE_SHARED_READONLY (c) = 1;\n+\t      else if (DECL_P (decl)\n+\t\t       && ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED\n+\t\t\t    && (n->value & GOVD_WRITTEN) != 1)\n+\t\t\t   || (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n+\t\t\t       && !OMP_CLAUSE_LINEAR_NO_COPYOUT (c)))\n+\t\t       && omp_shared_to_firstprivate_optimizable_decl_p (decl))\n+\t\tomp_mark_stores (gimplify_omp_ctxp->outer_context, decl);\n \t    }\n \t  break;\n \n@@ -7620,6 +7776,11 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n \t\t\t\"%<lastprivate%> clauses on %<distribute%> \"\n \t\t\t\"construct\");\n \t    }\n+\t  if (!remove\n+\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n+\t      && DECL_P (decl)\n+\t      && omp_shared_to_firstprivate_optimizable_decl_p (decl))\n+\t    omp_mark_stores (gimplify_omp_ctxp->outer_context, decl);\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -7800,6 +7961,11 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p,\n \t  break;\n \n \tcase OMP_CLAUSE_REDUCTION:\n+\t  decl = OMP_CLAUSE_DECL (c);\n+\t  if (DECL_P (decl)\n+\t      && omp_shared_to_firstprivate_optimizable_decl_p (decl))\n+\t    omp_mark_stores (gimplify_omp_ctxp->outer_context, decl);\n+\t  break;\n \tcase OMP_CLAUSE_COPYIN:\n \tcase OMP_CLAUSE_COPYPRIVATE:\n \tcase OMP_CLAUSE_IF:\n@@ -7876,7 +8042,8 @@ gimplify_oacc_cache (tree *expr_p, gimple_seq *pre_p)\n \n   gimplify_scan_omp_clauses (&OACC_CACHE_CLAUSES (expr), pre_p, ORT_ACC,\n \t\t\t     OACC_CACHE);\n-  gimplify_adjust_omp_clauses (pre_p, &OACC_CACHE_CLAUSES (expr), OACC_CACHE);\n+  gimplify_adjust_omp_clauses (pre_p, NULL, &OACC_CACHE_CLAUSES (expr),\n+\t\t\t       OACC_CACHE);\n \n   /* TODO: Do something sensible with this information.  */\n \n@@ -8023,7 +8190,7 @@ gimplify_omp_parallel (tree *expr_p, gimple_seq *pre_p)\n   else\n     pop_gimplify_context (NULL);\n \n-  gimplify_adjust_omp_clauses (pre_p, &OMP_PARALLEL_CLAUSES (expr),\n+  gimplify_adjust_omp_clauses (pre_p, body, &OMP_PARALLEL_CLAUSES (expr),\n \t\t\t       OMP_PARALLEL);\n \n   g = gimple_build_omp_parallel (body,\n@@ -8060,7 +8227,8 @@ gimplify_omp_task (tree *expr_p, gimple_seq *pre_p)\n   else\n     pop_gimplify_context (NULL);\n \n-  gimplify_adjust_omp_clauses (pre_p, &OMP_TASK_CLAUSES (expr), OMP_TASK);\n+  gimplify_adjust_omp_clauses (pre_p, body, &OMP_TASK_CLAUSES (expr),\n+\t\t\t       OMP_TASK);\n \n   g = gimple_build_omp_task (body,\n \t\t\t     OMP_TASK_CLAUSES (expr),\n@@ -8782,7 +8950,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \tTREE_OPERAND (TREE_OPERAND (t, 1), 0) = var;\n       }\n \n-  gimplify_adjust_omp_clauses (pre_p, &OMP_FOR_CLAUSES (orig_for_stmt),\n+  gimplify_adjust_omp_clauses (pre_p, for_body,\n+\t\t\t       &OMP_FOR_CLAUSES (orig_for_stmt),\n \t\t\t       TREE_CODE (orig_for_stmt));\n \n   int kind;\n@@ -9236,7 +9405,8 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n     }\n   else\n     gimplify_and_add (OMP_BODY (expr), &body);\n-  gimplify_adjust_omp_clauses (pre_p, &OMP_CLAUSES (expr), TREE_CODE (expr));\n+  gimplify_adjust_omp_clauses (pre_p, body, &OMP_CLAUSES (expr),\n+\t\t\t       TREE_CODE (expr));\n \n   switch (TREE_CODE (expr))\n     {\n@@ -9313,7 +9483,7 @@ gimplify_omp_target_update (tree *expr_p, gimple_seq *pre_p)\n     }\n   gimplify_scan_omp_clauses (&OMP_STANDALONE_CLAUSES (expr), pre_p,\n \t\t\t     ort, TREE_CODE (expr));\n-  gimplify_adjust_omp_clauses (pre_p, &OMP_STANDALONE_CLAUSES (expr),\n+  gimplify_adjust_omp_clauses (pre_p, NULL, &OMP_STANDALONE_CLAUSES (expr),\n \t\t\t       TREE_CODE (expr));\n   stmt = gimple_build_omp_target (NULL, kind, OMP_STANDALONE_CLAUSES (expr));\n \n@@ -10426,7 +10596,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      case OMP_CRITICAL:\n \t\tgimplify_scan_omp_clauses (&OMP_CRITICAL_CLAUSES (*expr_p),\n \t\t\t\t\t   pre_p, ORT_WORKSHARE, OMP_CRITICAL);\n-\t\tgimplify_adjust_omp_clauses (pre_p,\n+\t\tgimplify_adjust_omp_clauses (pre_p, body,\n \t\t\t\t\t     &OMP_CRITICAL_CLAUSES (*expr_p),\n \t\t\t\t\t     OMP_CRITICAL);\n \t\tg = gimple_build_omp_critical (body,"}, {"sha": "0b44588b5a175ab0059a14f0e7c80e2d1d86ede3", "filename": "gcc/omp-low.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1a80d6b87d81c3f336ab199a901cf80ae349c335", "patch": "@@ -1852,14 +1852,18 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t     the receiver side will use them directly.  */\n \t  if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))\n \t    break;\n-\t  by_ref = use_pointer_for_field (decl, ctx);\n \t  if (OMP_CLAUSE_SHARED_FIRSTPRIVATE (c))\n-\t    break;\n-\t  if (! TREE_READONLY (decl)\n+\t    {\n+\t      use_pointer_for_field (decl, ctx);\n+\t      break;\n+\t    }\n+\t  by_ref = use_pointer_for_field (decl, NULL);\n+\t  if ((! TREE_READONLY (decl) && !OMP_CLAUSE_SHARED_READONLY (c))\n \t      || TREE_ADDRESSABLE (decl)\n \t      || by_ref\n \t      || is_reference (decl))\n \t    {\n+\t      by_ref = use_pointer_for_field (decl, ctx);\n \t      install_var_field (decl, by_ref, 3, ctx);\n \t      install_var_local (decl, ctx);\n \t      break;"}, {"sha": "6e55cc29ede5b99fd00d605d633c470670fc9bcb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a80d6b87d81c3f336ab199a901cf80ae349c335", "patch": "@@ -1,3 +1,9 @@\n+2015-11-26  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/68128\n+\t* gcc.dg/gomp/pr68128-1.c: New test.\n+\t* gcc.dg/gomp/pr68128-2.c: New test.\n+\n 2015-11-26  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR rtl-optimization/67226"}, {"sha": "36823c2af0aa9b6734cc54a5a9eba4c252d7fc67", "filename": "gcc/testsuite/gcc.dg/gomp/pr68128-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr68128-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr68128-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr68128-1.c?ref=1a80d6b87d81c3f336ab199a901cf80ae349c335", "patch": "@@ -0,0 +1,32 @@\n+/* PR tree-optimization/68128 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -fopenmp -fdump-tree-vect-details\" } */\n+/* { dg-additional-options \"-mavx\" { target i?86-*-* x86_64-*-* } } */\n+\n+/* Make sure the following loop is vectorized even when not using\n+   firstprivate variables for scalar vars that are not modified\n+   in the parallel region.  */\n+\n+void\n+foo (float *u, float v, float w, float x, float y, float z, float t)\n+{\n+  int i, j, k, l;\n+  float a, *b, c, s, e;\n+#pragma omp parallel for private (i, j, k, l, a, b, c, s, e)\n+  for (j = 0; j < 1024; j++)\n+    {\n+      k = j * 64;\n+      l = j * 64 + 63;\n+      a = v + j * w;\n+      b = u + j * 64;\n+      for (i = k; i <= l; i++, b++, a += w)\n+\t{\n+\t  c = a * a + y;\n+\t  s = (1.f - c * x) * (1.f - c * x);\n+\t  e = t * (1 / __builtin_sqrtf (c)) * s;\n+\t  *b += (c < z ? e : 0);\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"note: vectorized 1 loops in function\" \"vect\" { target i?86-*-* x86_64-*-* } } } */"}, {"sha": "58a07e9efdd12e1443159779372a20a22fa9346f", "filename": "gcc/testsuite/gcc.dg/gomp/pr68128-2.c", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr68128-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr68128-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr68128-2.c?ref=1a80d6b87d81c3f336ab199a901cf80ae349c335", "patch": "@@ -0,0 +1,198 @@\n+/* PR tree-optimization/68128 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp -fdump-tree-omplower\" } */\n+\n+extern int omp_get_thread_num (void);\n+extern int omp_get_ancestor_thread_num (int);\n+\n+void b1 (int, int);\n+\n+int\n+f1 (void)\n+{\n+  int a1 = 1;\n+  unsigned char a2 = 2;\n+  unsigned long a3 = 3;\n+  long long a4 = 4;\n+  short a5 = 5;\n+  char a6 = 6;\n+  #pragma omp parallel shared (a1, a2, a3)\n+  {\n+    if (omp_get_thread_num () == 0)\n+      {\n+\ta1 = a2;\n+\ta4 = a5;\n+      }\n+    b1 (a2, a6);\n+    #pragma omp barrier\n+    if (omp_get_thread_num () == 1)\n+      {\n+\ta1 += a3;\n+\ta4 += a6;\n+      }\n+  }\n+  return a1 + a2 + a3 + a4 + a5 + a6;\n+}\n+\n+/* { dg-final { scan-tree-dump \"shared\\\\(a1\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(a2\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(a3\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a4\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(a5\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(a6\\\\)\" \"omplower\" } } */\n+\n+struct S { int a, b; };\n+\n+void b2 (int *, int *, int, int, struct S, struct S);\n+\n+void\n+f2 (void)\n+{\n+  struct S a7 = { 7, 7 }, a8 = { 8, 8 };\n+  int a9 = 9, a10 = 10;\n+  short a11[2] = { 11, 11 };\n+  char a12[1] = { 12 };\n+  #pragma omp parallel shared (a7, a9, a11)\n+  {\n+    b2 (&a9, &a10, a11[1], a12[0], a7, a8);\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump \"shared\\\\(a7\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a8\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a9\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a10\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a11\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a12\\\\)\" \"omplower\" } } */\n+\n+void b3 (_Complex float, _Complex float);\n+\n+_Complex float\n+f3 (void)\n+{\n+  _Complex float a13 = 13.0f, a14 = 14.0f, a15 = 15.0f, a16 = 16.0f;\n+  #pragma omp parallel shared (a13, a15)\n+  {\n+    #pragma omp parallel shared (a14)\n+    {\n+      if (omp_get_thread_num () == 0 && omp_get_ancestor_thread_num (1) == 1)\n+\t__imag__ a13 = __real__ a15;\n+      else if (omp_get_thread_num () == 1 && omp_get_ancestor_thread_num (1) == 0)\n+\t__real__ a14 = __imag__ a16;\n+      b3 (a15, a16);\n+    }\n+  }\n+  return a13 + a14 + a15 + a16;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(a13\\\\)\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(a14\\\\)\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"firstprivate\\\\(a15\\\\)\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"firstprivate\\\\(a16\\\\)\" 2 \"omplower\" } } */\n+\n+int\n+f4 (void)\n+{\n+  int a17 = 17, a18 = 18, a19 = 19, a20 = 20, a21 = 21, a22 = 22, a23 = 23, a24 = 0, a25 = 0, a26 = 0;\n+  int i;\n+  #pragma omp task shared (a17)\n+  b1 (a17, a18);\n+  b1 (a17, a18);\n+  #pragma omp taskwait\n+  #pragma omp parallel shared (a19)\n+  {\n+    #pragma omp task shared (a19)\n+    {\n+      a19 = 1;\n+    }\n+    #pragma omp task shared (a20)\n+    a20 = a21;\n+    #pragma omp for firstprivate (a25) lastprivate (a22) linear (a23:2) reduction (+:a24) private (a26)\n+    for (i = 0; i < 10; i++)\n+      {\n+\ta26 = i;\n+\ta22 = a26 + 7;\n+\ta23 += 2;\n+\ta24 += i;\n+\ta25++;\n+      }\n+  }\n+  return a22 + a23 + a24 + a25 + a26;\n+}\n+\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(a17\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"firstprivate\\\\(a18\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(a19\\\\)\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(a20\\\\)\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"firstprivate\\\\(a21\\\\)\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"lastprivate\\\\(a22\\\\)\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(a22\\\\)\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"linear\\\\(a23:2\\\\)\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(a23\\\\)\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"reduction\\\\(.:a24\\\\)\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"shared\\\\(a24\\\\)\" 1 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"firstprivate\\\\(a25\\\\)\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"private\\\\(a26\\\\)\" 1 \"omplower\" } } */\n+\n+void\n+f5 (void)\n+{\n+  int a27 = 27, a28 = 28, a29 = 29, a30 = 30;\n+  #pragma omp target data map (tofrom: a27, a28)\n+  {\n+    #pragma omp target map (tofrom: a27)\n+    a27++;\n+    #pragma omp parallel shared (a27, a28)\n+    {\n+      #pragma omp critical\n+      {\n+\t/* This might modify a27 for non-shared memory offloading.  */\n+\t#pragma omp target update to (a27)\n+\t#pragma omp target map (always, from: a28) private (a30)\n+\t{\n+\t  a28++;\n+\t  a29++;\n+\t  a30 = a29;\n+\t}\n+      }\n+      #pragma omp barrier\n+      b1 (a27, a28);\n+    }\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump \"shared\\\\(a27\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a28\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"firstprivate\\\\(a29\\\\)\" 2 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"private\\\\(a30\\\\)\" 1 \"omplower\" } } */\n+\n+int\n+f6 (void)\n+{\n+  int a31 = 31, a32 = 32, a33 = 33, a34 = 34;\n+  #pragma omp parallel\n+  {\n+    #pragma omp sections\n+    {\n+      #pragma omp section\n+      {\n+\ta31 = 9;\n+      }\n+      #pragma omp section\n+      {\n+\tint i = 10;\n+\t__builtin_memcpy (&a32, &i, sizeof (int));\n+      }\n+    }\n+    #pragma omp single\n+    a33 = 11;\n+    #pragma omp atomic\n+    a34++;\n+  }\n+  return a31 + a32 + a33 + a34;\n+}\n+\n+/* { dg-final { scan-tree-dump \"shared\\\\(a31\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a32\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a33\\\\)\" \"omplower\" } } */\n+/* { dg-final { scan-tree-dump \"shared\\\\(a34\\\\)\" \"omplower\" } } */"}, {"sha": "6bc5016ff669dcf053f381095fd7cff6823e9c1c", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=1a80d6b87d81c3f336ab199a901cf80ae349c335", "patch": "@@ -1081,6 +1081,8 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t    break;\n \t  if (decl_function_context (decl) != info->context)\n \t    {\n+\t      if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_SHARED)\n+\t\tOMP_CLAUSE_SHARED_READONLY (clause) = 0;\n \t      bitmap_set_bit (new_suppress, DECL_UID (decl));\n \t      OMP_CLAUSE_DECL (clause) = get_nonlocal_debug_decl (info, decl);\n \t      if (OMP_CLAUSE_CODE (clause) != OMP_CLAUSE_PRIVATE)\n@@ -1732,6 +1734,8 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \t      tree field = lookup_field_for_decl (info, decl, NO_INSERT);\n \t      if (field)\n \t\t{\n+\t\t  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_SHARED)\n+\t\t    OMP_CLAUSE_SHARED_READONLY (clause) = 0;\n \t\t  bitmap_set_bit (new_suppress, DECL_UID (decl));\n \t\t  OMP_CLAUSE_DECL (clause)\n \t\t    = get_local_debug_decl (info, decl, field);"}, {"sha": "0c1602ee7def4ad59dfc8164fef3edf4296f432c", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a80d6b87d81c3f336ab199a901cf80ae349c335/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1a80d6b87d81c3f336ab199a901cf80ae349c335", "patch": "@@ -1453,6 +1453,11 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_SHARED_FIRSTPRIVATE(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SHARED)->base.public_flag)\n \n+/* True on a SHARED clause if a scalar is not modified in the body and\n+   thus could be optimized as firstprivate.  */\n+#define OMP_CLAUSE_SHARED_READONLY(NODE) \\\n+  TREE_PRIVATE (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SHARED))\n+\n #define OMP_CLAUSE_IF_MODIFIER(NODE)\t\\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_IF)->omp_clause.subcode.if_modifier)\n "}]}