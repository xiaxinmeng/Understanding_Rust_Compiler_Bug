{"sha": "1be4878116a2be82552bd59c3c1c9adcac3d106b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJlNDg3ODExNmEyYmU4MjU1MmJkNTljM2MxYzlhZGNhYzNkMTA2Yg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2020-11-18T22:09:46Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-11-18T22:09:46Z"}, "message": "Fix middle-end/85811: Introduce tree_expr_maybe_non_p et al.\n\nThe motivation for this patch is PR middle-end/85811, a wrong-code\nregression entitled \"Invalid optimization with fmax, fabs and nan\".\nThe optimization involves assuming max(x,y) is non-negative if (say)\ny is non-negative, i.e. max(x,2.0).  Unfortunately, this is an invalid\nassumption in the presence of NaNs.  Hence max(x,+qNaN), with IEEE fmax\nsemantics will always return x even though the qNaN is non-negative.\nWorse, max(x,2.0) may return a negative value if x is -sNaN.\n\nI'll quote Joseph Myers (many thanks) who describes things clearly as:\n> (a) When both arguments are NaNs, the return value should be a qNaN,\n> but sometimes it is an sNaN if at least one argument is an sNaN.\n> (b) Under TS 18661-1 semantics, if either argument is an sNaN then the\n> result should be a qNaN (whereas if one argument is a qNaN and the\n> other is not a NaN, the result should be the non-NaN argument).\n> Various implementations treat sNaNs like qNaNs here.\n\nUnder this logic, the tree_expr_nonnegative_p for IEEE fmax should be:\n\n    CASE_CFN_FMAX:\n    CASE_CFN_FMAX_FN:\n      /* Usually RECURSE (arg0) || RECURSE (arg1) but NaNs complicate\n         things.  In the presence of sNaNs, we're only guaranteed to be\n         non-negative if both operands are non-negative.  In the presence\n         of qNaNs, we're non-negative if either operand is non-negative\n         and can't be a qNaN, or if both operands are non-negative.  */\n      if (tree_expr_maybe_signaling_nan_p (arg0) ||\n          tree_expr_maybe_signaling_nan_p (arg1))\n        return RECURSE (arg0) && RECURSE (arg1);\n      return RECURSE (arg0) ? (!tree_expr_maybe_nan_p (arg0)\n                              || RECURSE (arg1))\n                            : (RECURSE (arg1)\n                              && !tree_expr_maybe_nan_p (arg1));\n\nWhich indeed resolves the wrong code in the PR.  The infrastructure that\nmakes this possible are the two new functions tree_expr_maybe_nan_p and\ntree_expr_maybe_signaling_nan_p which test whether a value may potentially\nbe a NaN or a signaling NaN respectively.  In fact, this patch adds seven\nnew predicates to the middle-end:\n\nbool tree_expr_finite_p (const_tree);\nbool tree_expr_infinite_p (const_tree);\nbool tree_expr_maybe_infinite_p (const_tree);\nbool tree_expr_signaling_nan_p (const_tree);\nbool tree_expr_maybe_signaling_nan_p (const_tree);\nbool tree_expr_nan_p (const_tree);\nbool tree_expr_maybe_nan_p (const_tree);\n\nThese functions correspond to the \"must\" and \"may\" operators in modal logic,\nand allow us to triage expressions in the middle-end; definitely a NaN,\ndefinitely not a NaN, and unknown at compile-time, etc.  A prime example of\nthe utility of these functions is that a IEEE floating point value promoted\nfrom an integer type can't be a NaN or infinite.  Hence (double)i+0.0 where\ni is an integer can be simplified to (double)i even with -fsignaling-nans.\nCurrently in GCC optimizations are enabled/disabled based on whether the\nexpression's type supports NaNs or sNaNs; with these new predicates they\ncan be controlled by whether the actual operands may or may not be NaNs.\n\nHaving added these extremely useful helper functions to the middle-end,\nI couldn't help by use then in a few places in fold-const.c, builtins.c\nand match.pd.  In the near term, these can/should be used in places\nwhere the tree optimizers test for HONOR_NANS, HONOR_INFINITIES or\nHONOR_SNANS, or explicitly test whether a REAL_CST is a NaN or Inf.\nIn the longer term (I'm not volunteering) these predicates could perhaps\nbe hooked into the middle-end's SSA chaining and/or VRP machinery,\nallowing finiteness to propagated around the CFG, much like we\ncurrently propagate value ranges.\n\nThis patch has been tested on x86_64-pc-linux-gnu with a \"make bootstrap\"\nand \"make -k check\".\nOk for mainline?\n\n2020-08-15  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\tPR middle-end/85811\n\t* fold-const.c (tree_expr_finite_p): New function to test whether\n\ta tree expression must be finite, i.e. not a FP NaN or infinity.\n\t(tree_expr_infinite_p):  New function to test whether a tree\n\texpression must be infinite, i.e. a FP infinity.\n\t(tree_expr_maybe_infinite_p): New function to test whether a tree\n\texpression may be infinite, i.e. a FP infinity.\n\t(tree_expr_signaling_nan_p): New function to test whether a tree\n\texpression must evaluate to a signaling NaN (sNaN).\n\t(tree_expr_maybe_signaling_nan_p): New function to test whether a\n\ttree expression may be a signaling NaN (sNaN).\n\t(tree_expr_nan_p): New function to test whether a tree expression\n\tmust evaluate to a (quiet or signaling) NaN.\n\t(tree_expr_maybe_nan_p): New function to test whether a tree\n\texpression me be a (quiet or signaling) NaN.\n\n\t(tree_binary_nonnegative_warnv_p) [MAX_EXPR]: In the presence\n\tof NaNs, MAX_EXPR is only guaranteed to be non-negative, if both\n\toperands are non-negative.\n\t(tree_call_nonnegative_warnv_p) [CASE_CFN_FMAX,CASE_CFN_FMAX_FN]:\n\tIn the presence of signaling NaNs, fmax is only guaranteed to be\n\tnon-negative if both operands are negative.  In the presence of\n\tquiet NaNs, fmax is non-negative if either operand is non-negative\n\tand not a qNaN, or both operands are non-negative.\n\n\t* fold-const.h (tree_expr_finite_p, tree_expr_infinite_p,\n\ttree_expr_maybe_infinite_p, tree_expr_signaling_nan_p,\n\ttree_expr_maybe_signaling_nan_p, tree_expr_nan_p,\n\ttree_expr_maybe_nan_p): Prototype new functions here.\n\n\t* builtins.c (fold_builtin_classify) [BUILT_IN_ISINF]: Fold to\n\ta constant if argument is known to be (or not to be) an Infinity.\n\t[BUILT_IN_ISFINITE]: Fold to a constant if argument is known to\n\tbe (or not to be) finite.\n\t[BUILT_IN_ISNAN]: Fold to a constant if argument is known to be\n\t(or not to be) a NaN.\n\t(fold_builtin_fpclassify): Check tree_expr_maybe_infinite_p and\n\ttree_expr_maybe_nan_p instead of HONOR_INFINITIES and HONOR_NANS\n\trespectively.\n\t(fold_builtin_unordered_cmp): Fold UNORDERED_EXPR to a constant\n\twhen its arguments are known to be (or not be) NaNs.  Check\n\ttree_expr_maybe_nan_p instead of HONOR_NANS when choosing between\n\tunordered and regular forms of comparison operators.\n\n\t* match.pd (ordered(x,y)->true/false): Constant fold ORDERED_EXPR\n\tif its operands are known to be (or not to be) NaNs.\n\t(unordered(x,y)->true/false): Constant fold UNORDERED_EXPR if its\n\toperands are known to be (or not to be) NaNs.\n\t(sqrt(x)*sqrt(x)->x): Check tree_expr_maybe_signaling_nan_p instead\n\tof HONOR_SNANS.\n\ngcc/testsuite/ChangeLog\n\tPR middle-end/85811\n\t* gcc.dg/pr85811.c: New test.\n\t* gcc.dg/fold-isfinite-1.c: New test.\n\t* gcc.dg/fold-isfinite-2.c: New test.\n\t* gcc.dg/fold-isinf-1.c: New test.\n\t* gcc.dg/fold-isinf-2.c: New test.\n\t* gcc.dg/fold-isnan-1.c: New test.\n\t* gcc.dg/fold-isnan-2.c: New test.", "tree": {"sha": "15a92c04605feb114dfaba18cc7fa93048dc080a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15a92c04605feb114dfaba18cc7fa93048dc080a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1be4878116a2be82552bd59c3c1c9adcac3d106b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be4878116a2be82552bd59c3c1c9adcac3d106b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be4878116a2be82552bd59c3c1c9adcac3d106b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be4878116a2be82552bd59c3c1c9adcac3d106b/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "579d235ddcf50070fbba5fc3b3354aafb4b4b1fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579d235ddcf50070fbba5fc3b3354aafb4b4b1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579d235ddcf50070fbba5fc3b3354aafb4b4b1fb"}], "stats": {"total": 456, "additions": 443, "deletions": 13}, "files": [{"sha": "a75b24c549288536205cb67a91f2cbdd2125a3ee", "filename": "gcc/builtins.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -10691,9 +10691,10 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n   switch (builtin_index)\n     {\n     case BUILT_IN_ISINF:\n-      if (!HONOR_INFINITIES (arg))\n+      if (tree_expr_infinite_p (arg))\n+\treturn omit_one_operand_loc (loc, type, integer_one_node, arg);\n+      if (!tree_expr_maybe_infinite_p (arg))\n \treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n-\n       return NULL_TREE;\n \n     case BUILT_IN_ISINF_SIGN:\n@@ -10729,14 +10730,16 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n       }\n \n     case BUILT_IN_ISFINITE:\n-      if (!HONOR_NANS (arg)\n-\t  && !HONOR_INFINITIES (arg))\n+      if (tree_expr_finite_p (arg))\n \treturn omit_one_operand_loc (loc, type, integer_one_node, arg);\n-\n+      if (tree_expr_nan_p (arg) || tree_expr_infinite_p (arg))\n+\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n       return NULL_TREE;\n \n     case BUILT_IN_ISNAN:\n-      if (!HONOR_NANS (arg))\n+      if (tree_expr_nan_p (arg))\n+\treturn omit_one_operand_loc (loc, type, integer_one_node, arg);\n+      if (!tree_expr_maybe_nan_p (arg))\n \treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n \n       {\n@@ -10810,7 +10813,7 @@ fold_builtin_fpclassify (location_t loc, tree *args, int nargs)\n \t\t     arg, build_real (type, r));\n   res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp, fp_normal, res);\n \n-  if (HONOR_INFINITIES (mode))\n+  if (tree_expr_maybe_infinite_p (arg))\n     {\n       real_inf (&r);\n       tmp = fold_build2_loc (loc, EQ_EXPR, integer_type_node, arg,\n@@ -10819,7 +10822,7 @@ fold_builtin_fpclassify (location_t loc, tree *args, int nargs)\n \t\t\t fp_infinite, res);\n     }\n \n-  if (HONOR_NANS (mode))\n+  if (tree_expr_maybe_nan_p (arg))\n     {\n       tmp = fold_build2_loc (loc, ORDERED_EXPR, integer_type_node, arg, arg);\n       res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp, res, fp_nan);\n@@ -10867,12 +10870,15 @@ fold_builtin_unordered_cmp (location_t loc, tree fndecl, tree arg0, tree arg1,\n \n   if (unordered_code == UNORDERED_EXPR)\n     {\n-      if (!HONOR_NANS (arg0))\n+      if (tree_expr_nan_p (arg0) || tree_expr_nan_p (arg1))\n+\treturn omit_two_operands_loc (loc, type, integer_one_node, arg0, arg1);\n+      if (!tree_expr_maybe_nan_p (arg0) && !tree_expr_maybe_nan_p (arg1))\n \treturn omit_two_operands_loc (loc, type, integer_zero_node, arg0, arg1);\n       return fold_build2_loc (loc, UNORDERED_EXPR, type, arg0, arg1);\n     }\n \n-  code = HONOR_NANS (arg0) ? unordered_code : ordered_code;\n+  code = (tree_expr_maybe_nan_p (arg0) || tree_expr_maybe_nan_p (arg1))\n+\t ? unordered_code : ordered_code;\n   return fold_build1_loc (loc, TRUTH_NOT_EXPR, type,\n \t\t      fold_build2_loc (loc, code, type, arg0, arg1));\n }"}, {"sha": "31c48daf3dda7c19bfda44a2e0d2eafbea52c1c9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 260, "deletions": 2, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -13701,6 +13701,248 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n     }\n }\n \n+/* Return true if expression X cannot be (or contain) a NaN or infinity.\n+   This function returns true for integer expressions, and returns\n+   false if uncertain.  */\n+\n+bool\n+tree_expr_finite_p (const_tree x)\n+{\n+  machine_mode mode = element_mode (x);\n+  if (!HONOR_NANS (mode) && !HONOR_INFINITIES (mode))\n+    return true;\n+  switch (TREE_CODE (x))\n+    {\n+    case REAL_CST:\n+      return real_isfinite (TREE_REAL_CST_PTR (x));\n+    case COMPLEX_CST:\n+      return tree_expr_finite_p (TREE_REALPART (x))\n+\t     && tree_expr_finite_p (TREE_IMAGPART (x));\n+    case FLOAT_EXPR:\n+      return true;\n+    case ABS_EXPR:\n+    case CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case NEGATE_EXPR:\n+    case SAVE_EXPR:\n+      return tree_expr_finite_p (TREE_OPERAND (x, 0));\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      return tree_expr_finite_p (TREE_OPERAND (x, 0))\n+\t     && tree_expr_finite_p (TREE_OPERAND (x, 1));\n+    case COND_EXPR:\n+      return tree_expr_finite_p (TREE_OPERAND (x, 1))\n+\t     && tree_expr_finite_p (TREE_OPERAND (x, 2));\n+    case CALL_EXPR:\n+      switch (get_call_combined_fn (x))\n+\t{\n+\tCASE_CFN_FABS:\n+\t  return tree_expr_finite_p (CALL_EXPR_ARG (x, 0));\n+\tCASE_CFN_FMAX:\n+\tCASE_CFN_FMIN:\n+\t  return tree_expr_finite_p (CALL_EXPR_ARG (x, 0))\n+\t\t && tree_expr_finite_p (CALL_EXPR_ARG (x, 1));\n+\tdefault:\n+\t  return false;\n+\t}\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true if expression X evaluates to an infinity.\n+   This function returns false for integer expressions.  */\n+\n+bool\n+tree_expr_infinite_p (const_tree x)\n+{\n+  if (!HONOR_INFINITIES (x))\n+    return false;\n+  switch (TREE_CODE (x))\n+    {\n+    case REAL_CST:\n+      return real_isinf (TREE_REAL_CST_PTR (x));\n+    case ABS_EXPR:\n+    case NEGATE_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case SAVE_EXPR:\n+      return tree_expr_infinite_p (TREE_OPERAND (x, 0));\n+    case COND_EXPR:\n+      return tree_expr_infinite_p (TREE_OPERAND (x, 1))\n+\t     && tree_expr_infinite_p (TREE_OPERAND (x, 2));\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true if expression X could evaluate to an infinity.\n+   This function returns false for integer expressions, and returns\n+   true if uncertain.  */\n+\n+bool\n+tree_expr_maybe_infinite_p (const_tree x)\n+{\n+  if (!HONOR_INFINITIES (x))\n+    return false;\n+  switch (TREE_CODE (x))\n+    {\n+    case REAL_CST:\n+      return real_isinf (TREE_REAL_CST_PTR (x));\n+    case FLOAT_EXPR:\n+      return false;\n+    case ABS_EXPR:\n+    case NEGATE_EXPR:\n+      return tree_expr_maybe_infinite_p (TREE_OPERAND (x, 0));\n+    case COND_EXPR:\n+      return tree_expr_maybe_infinite_p (TREE_OPERAND (x, 1))\n+\t     || tree_expr_maybe_infinite_p (TREE_OPERAND (x, 2));\n+    default:\n+      return true;\n+    }\n+}\n+\n+/* Return true if expression X evaluates to a signaling NaN.\n+   This function returns false for integer expressions.  */\n+\n+bool\n+tree_expr_signaling_nan_p (const_tree x)\n+{\n+  if (!HONOR_SNANS (x))\n+    return false;\n+  switch (TREE_CODE (x))\n+    {\n+    case REAL_CST:\n+      return real_issignaling_nan (TREE_REAL_CST_PTR (x));\n+    case NON_LVALUE_EXPR:\n+    case SAVE_EXPR:\n+      return tree_expr_signaling_nan_p (TREE_OPERAND (x, 0));\n+    case COND_EXPR:\n+      return tree_expr_signaling_nan_p (TREE_OPERAND (x, 1))\n+\t     && tree_expr_signaling_nan_p (TREE_OPERAND (x, 2));\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true if expression X could evaluate to a signaling NaN.\n+   This function returns false for integer expressions, and returns\n+   true if uncertain.  */\n+\n+bool\n+tree_expr_maybe_signaling_nan_p (const_tree x)\n+{\n+  if (!HONOR_SNANS (x))\n+    return false;\n+  switch (TREE_CODE (x))\n+    {\n+    case REAL_CST:\n+      return real_issignaling_nan (TREE_REAL_CST_PTR (x));\n+    case FLOAT_EXPR:\n+      return false;\n+    case ABS_EXPR:\n+    case CONVERT_EXPR:\n+    case NEGATE_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case SAVE_EXPR:\n+      return tree_expr_maybe_signaling_nan_p (TREE_OPERAND (x, 0));\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      return tree_expr_maybe_signaling_nan_p (TREE_OPERAND (x, 0))\n+\t     || tree_expr_maybe_signaling_nan_p (TREE_OPERAND (x, 1));\n+    case COND_EXPR:\n+      return tree_expr_maybe_signaling_nan_p (TREE_OPERAND (x, 1))\n+\t     || tree_expr_maybe_signaling_nan_p (TREE_OPERAND (x, 2));\n+    case CALL_EXPR:\n+      switch (get_call_combined_fn (x))\n+\t{\n+\tCASE_CFN_FABS:\n+\t  return tree_expr_maybe_signaling_nan_p (CALL_EXPR_ARG (x, 0));\n+\tCASE_CFN_FMAX:\n+\tCASE_CFN_FMIN:\n+\t  return tree_expr_maybe_signaling_nan_p (CALL_EXPR_ARG (x, 0))\n+\t\t || tree_expr_maybe_signaling_nan_p (CALL_EXPR_ARG (x, 1));\n+\tdefault:\n+\t  return true;\n+\t}\n+    default:\n+      return true;\n+    }\n+}\n+\n+/* Return true if expression X evaluates to a NaN.\n+   This function returns false for integer expressions.  */\n+\n+bool\n+tree_expr_nan_p (const_tree x)\n+{\n+  if (!HONOR_NANS (x))\n+    return false;\n+  switch (TREE_CODE (x))\n+    {\n+    case REAL_CST:\n+      return real_isnan (TREE_REAL_CST_PTR (x));\n+    case NON_LVALUE_EXPR:\n+    case SAVE_EXPR:\n+      return tree_expr_nan_p (TREE_OPERAND (x, 0));\n+    case COND_EXPR:\n+      return tree_expr_nan_p (TREE_OPERAND (x, 1))\n+\t     && tree_expr_nan_p (TREE_OPERAND (x, 2));\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true if expression X could evaluate to a NaN.\n+   This function returns false for integer expressions, and returns\n+   true if uncertain.  */\n+\n+bool\n+tree_expr_maybe_nan_p (const_tree x)\n+{\n+  if (!HONOR_NANS (x))\n+    return false;\n+  switch (TREE_CODE (x))\n+    {\n+    case REAL_CST:\n+      return real_isnan (TREE_REAL_CST_PTR (x));\n+    case FLOAT_EXPR:\n+      return false;\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+      return !tree_expr_finite_p (TREE_OPERAND (x, 0))\n+\t     || !tree_expr_finite_p (TREE_OPERAND (x, 1));\n+    case ABS_EXPR:\n+    case CONVERT_EXPR:\n+    case NEGATE_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case SAVE_EXPR:\n+      return tree_expr_maybe_nan_p (TREE_OPERAND (x, 0));\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      return tree_expr_maybe_nan_p (TREE_OPERAND (x, 0))\n+\t     || tree_expr_maybe_nan_p (TREE_OPERAND (x, 1));\n+    case COND_EXPR:\n+      return tree_expr_maybe_nan_p (TREE_OPERAND (x, 1))\n+\t     || tree_expr_maybe_nan_p (TREE_OPERAND (x, 2));\n+    case CALL_EXPR:\n+      switch (get_call_combined_fn (x))\n+\t{\n+\tCASE_CFN_FABS:\n+\t  return tree_expr_maybe_nan_p (CALL_EXPR_ARG (x, 0));\n+\tCASE_CFN_FMAX:\n+\tCASE_CFN_FMIN:\n+\t  return tree_expr_maybe_nan_p (CALL_EXPR_ARG (x, 0))\n+\t\t || tree_expr_maybe_nan_p (CALL_EXPR_ARG (x, 1));\n+\tdefault:\n+\t  return true;\n+\t}\n+    default:\n+      return true;\n+    }\n+}\n+\n #define tree_expr_nonnegative_warnv_p(X, Y) \\\n   _Pragma (\"GCC error \\\"Use RECURSE for recursive calls\\\"\") 0\n \n@@ -13878,7 +14120,13 @@ tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n       return false;\n \n     case BIT_AND_EXPR:\n+      return RECURSE (op0) || RECURSE (op1);\n+\n     case MAX_EXPR:\n+      /* Usually RECURSE (op0) || RECURSE (op1) but NaNs complicate\n+\t things.  */\n+      if (tree_expr_maybe_nan_p (op0) || tree_expr_maybe_nan_p (op1))\n+\treturn RECURSE (op0) && RECURSE (op1);\n       return RECURSE (op0) || RECURSE (op1);\n \n     case BIT_IOR_EXPR:\n@@ -14038,8 +14286,18 @@ tree_call_nonnegative_warnv_p (tree type, combined_fn fn, tree arg0, tree arg1,\n \n     CASE_CFN_FMAX:\n     CASE_CFN_FMAX_FN:\n-      /* True if the 1st OR 2nd arguments are nonnegative.  */\n-      return RECURSE (arg0) || RECURSE (arg1);\n+      /* Usually RECURSE (arg0) || RECURSE (arg1) but NaNs complicate\n+\t things.  In the presence of sNaNs, we're only guaranteed to be\n+\t non-negative if both operands are non-negative.  In the presence\n+\t of qNaNs, we're non-negative if either operand is non-negative\n+\t and can't be a qNaN, or if both operands are non-negative.  */\n+      if (tree_expr_maybe_signaling_nan_p (arg0) ||\n+\t  tree_expr_maybe_signaling_nan_p (arg1))\n+        return RECURSE (arg0) && RECURSE (arg1);\n+      return RECURSE (arg0) ? (!tree_expr_maybe_nan_p (arg0)\n+\t\t\t       || RECURSE (arg1))\n+\t\t\t    : (RECURSE (arg1)\n+\t\t\t       && !tree_expr_maybe_nan_p (arg1));\n \n     CASE_CFN_FMIN:\n     CASE_CFN_FMIN_FN:"}, {"sha": "e833019475f625b2ca13c3788bdba35a2186bf49", "filename": "gcc/fold-const.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -186,6 +186,13 @@ extern tree non_lvalue_loc (location_t, tree);\n extern bool tree_expr_nonzero_p (tree);\n extern bool tree_expr_nonnegative_p (tree);\n extern bool tree_expr_nonnegative_warnv_p (tree, bool *, int = 0);\n+extern bool tree_expr_finite_p (const_tree);\n+extern bool tree_expr_infinite_p (const_tree);\n+extern bool tree_expr_maybe_infinite_p (const_tree);\n+extern bool tree_expr_signaling_nan_p (const_tree);\n+extern bool tree_expr_maybe_signaling_nan_p (const_tree);\n+extern bool tree_expr_nan_p (const_tree);\n+extern bool tree_expr_maybe_nan_p (const_tree);\n extern tree make_range (tree, int *, tree *, tree *, bool *);\n extern tree make_range_step (location_t, enum tree_code, tree, tree, tree,\n \t\t\t     tree *, tree *, int *, bool *);"}, {"sha": "cbb4bf0b32dea59abfd4bf7502ef4332ef3b8404", "filename": "gcc/match.pd", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -4932,6 +4932,24 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    { constant_boolean_node (cmp == ORDERED_EXPR || cmp == LTGT_EXPR\n \t\t\t    ? false : true, type); })))\n \n+/* Fold UNORDERED if either operand must be NaN, or neither can be.  */\n+(simplify\n+  (unordered @0 @1)\n+  (switch\n+    (if (tree_expr_nan_p (@0) || tree_expr_nan_p (@1))\n+\t{ constant_boolean_node (true, type); })\n+    (if (!tree_expr_maybe_nan_p (@0) && !tree_expr_maybe_nan_p (@1))\n+\t{ constant_boolean_node (false, type); })))\n+\n+/* Fold ORDERED if either operand must be NaN, or neither can be.  */\n+(simplify\n+  (ordered @0 @1)\n+  (switch\n+    (if (tree_expr_nan_p (@0) || tree_expr_nan_p (@1))\n+\t{ constant_boolean_node (false, type); })\n+    (if (!tree_expr_maybe_nan_p (@0) && !tree_expr_maybe_nan_p (@1))\n+\t{ constant_boolean_node (true, type); })))\n+\n /* bool_var != 0 becomes bool_var.  */\n (simplify\n  (ne @0 integer_zerop)\n@@ -5063,7 +5081,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  /* Simplify sqrt(x) * sqrt(x) -> x.  */\n  (simplify\n   (mult (SQRT_ALL@1 @0) @1)\n-  (if (!HONOR_SNANS (type))\n+  (if (!tree_expr_maybe_signaling_nan_p (@0))\n    @0))\n \n  (for op (plus minus)"}, {"sha": "2ea0192e863fd681a321834a5945e50bee2f13d9", "filename": "gcc/testsuite/gcc.dg/fold-isfinite-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isfinite-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isfinite-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isfinite-1.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target inf } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int foo(int x)\n+{\n+  return __builtin_finite((double)x);\n+}\n+\n+int foof(int x)\n+{\n+  return __builtin_finitef((float)x);\n+}\n+\n+int fool(int x)\n+{\n+  return __builtin_finitel((long double)x);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_finite\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" u> \" 0 \"optimized\" } } */"}, {"sha": "ff70d8d3dc258b88932cd4dce98e0e944e27b8e3", "filename": "gcc/testsuite/gcc.dg/fold-isfinite-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isfinite-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isfinite-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isfinite-2.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target inf } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int foo(unsigned int x)\n+{\n+  return __builtin_finite((double)x);\n+}\n+\n+int foof(unsigned int x)\n+{\n+  return __builtin_finitef((float)x);\n+}\n+\n+int fool(unsigned int x)\n+{\n+  return __builtin_finitel((long double)x);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_finite\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" u> \" 0 \"optimized\" } } */"}, {"sha": "485816ef7efd072f19d607337b6821f0a8841302", "filename": "gcc/testsuite/gcc.dg/fold-isinf-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isinf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isinf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isinf-1.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target inf } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int foo(int x)\n+{\n+  return __builtin_isinf((double)x);\n+}\n+\n+int foof(int x)\n+{\n+  return __builtin_isinff((float)x);\n+}\n+\n+int fool(int x)\n+{\n+  return __builtin_isinfl((long double)x);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_isinf\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" u<= \" 0 \"optimized\" } } */"}, {"sha": "a236ca10310fbf6acc20017e94085824b0004d11", "filename": "gcc/testsuite/gcc.dg/fold-isinf-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isinf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isinf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isinf-2.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target inf } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int foo(unsigned int x)\n+{\n+  return __builtin_isinf((double)x);\n+}\n+\n+int foof(unsigned int x)\n+{\n+  return __builtin_isinff((float)x);\n+}\n+\n+int fool(unsigned int x)\n+{\n+  return __builtin_isinfl((long double)x);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_isinf\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" u<= \" 0 \"optimized\" } } */"}, {"sha": "05ee930f93b8549e64bca6653e372702680ecbbe", "filename": "gcc/testsuite/gcc.dg/fold-isnan-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isnan-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isnan-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isnan-1.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target inf } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int foo(int x)\n+{\n+  return __builtin_isnan((double)x);\n+}\n+\n+int foof(int x)\n+{\n+  return __builtin_isnanf((float)x);\n+}\n+\n+int fool(int x)\n+{\n+  return __builtin_isnanl((long double)x);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_isnan\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" unord \" 0 \"optimized\" } } */"}, {"sha": "32b8833711f9e41e68f67be482a09975b64d4377", "filename": "gcc/testsuite/gcc.dg/fold-isnan-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isnan-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isnan-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-isnan-2.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target inf } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int foo(unsigned int x)\n+{\n+  return __builtin_isnan((double)x);\n+}\n+\n+int foof(unsigned int x)\n+{\n+  return __builtin_isnanf((float)x);\n+}\n+\n+int fool(unsigned int x)\n+{\n+  return __builtin_isnanl((long double)x);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_isnan\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \" unord \" 0 \"optimized\" } } */"}, {"sha": "868f66c32a114677250e0a5b8f504220917fbe5d", "filename": "gcc/testsuite/gcc.dg/pr85811.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85811.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be4878116a2be82552bd59c3c1c9adcac3d106b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85811.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85811.c?ref=1be4878116a2be82552bd59c3c1c9adcac3d106b", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+#include <stdio.h>\n+\n+int main() {\n+  const double negval = -1.0;\n+  const double nanval = 0.0 / 0.0;\n+  const double val = __builtin_fmax(negval, nanval);\n+  const double absval = __builtin_fabs(val);\n+  printf(\"fabs(%.16e) = %.16e\\n\", val, absval);\n+  return absval >= 0 ? 0 : 1;\n+}\n+\n+/* We hope not to see:  printf (\"fabs(%.16e) = %.16e\\n\", val_4, val_4); */\n+/* { dg-final { scan-tree-dump-not \"val_\\[0-9\\]*, val_\\[0-9\\]*\" \"optimized\" } } */"}]}