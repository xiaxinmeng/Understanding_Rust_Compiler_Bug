{"sha": "ab38481ceff08c995ade3e88eccee6ab92914a44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIzODQ4MWNlZmYwOGM5OTVhZGUzZTg4ZWNjZWU2YWI5MjkxNGE0NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-04-28T13:04:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-04-28T13:04:48Z"}, "message": "ipa-cp.c (perform_estimation_of_a_value): Turn time to sreal.\n\n\n\t* ipa-cp.c (perform_estimation_of_a_value): Turn time to sreal.\n\t(estimate_local_effects): Likewise.\n\t* ipa-inline.c (compute_inlined_call_time, want_inline_small_function_p,\n\tedge_badness, inline_small_functions, dump_overall_stats): LIkewise.\n\t* ipa-inline.h (edge_growth_cache_entry, estimate_time_after_inlining,\n\testimate_ipcp_clone_size_and_time, do_estimate_edge_time,\n\tdo_estimate_edge_time, estimate_edge_time): Likewise.\n\t* ipa-inline-analysis.c (estimate_node_size_and_time,\n\testimate_ipcp_clone_size_and_time, do_estimate_edge_time): Likewise.\n\t(estimate_time_after_inlining): Remove.\n\nFrom-SVN: r247380", "tree": {"sha": "605e718598b0f75578b041856d9df7946d8b7787", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/605e718598b0f75578b041856d9df7946d8b7787"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab38481ceff08c995ade3e88eccee6ab92914a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab38481ceff08c995ade3e88eccee6ab92914a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab38481ceff08c995ade3e88eccee6ab92914a44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab38481ceff08c995ade3e88eccee6ab92914a44/comments", "author": null, "committer": null, "parents": [{"sha": "b26f45f0694604745bbb3d269cacecefd28b4faf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26f45f0694604745bbb3d269cacecefd28b4faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b26f45f0694604745bbb3d269cacecefd28b4faf"}], "stats": {"total": 116, "additions": 53, "deletions": 63}, "files": [{"sha": "977517eabd86f3d1b49f6e39803e76f75fdeaf55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab38481ceff08c995ade3e88eccee6ab92914a44", "patch": "@@ -1,3 +1,16 @@\n+2017-04-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-cp.c (perform_estimation_of_a_value): Turn time to sreal.\n+\t(estimate_local_effects): Likewise.\n+\t* ipa-inline.c (compute_inlined_call_time, want_inline_small_function_p,\n+\tedge_badness, inline_small_functions, dump_overall_stats): LIkewise.\n+\t* ipa-inline.h (edge_growth_cache_entry, estimate_time_after_inlining,\n+\testimate_ipcp_clone_size_and_time, do_estimate_edge_time,\n+\tdo_estimate_edge_time, estimate_edge_time): Likewise.\n+\t* ipa-inline-analysis.c (estimate_node_size_and_time,\n+\testimate_ipcp_clone_size_and_time, do_estimate_edge_time): Likewise.\n+\t(estimate_time_after_inlining): Remove.\n+\t\n 2017-04-28  Martin Liska  <mliska@suse.cz>\n \n \t* doc/gcov.texi: Enhance documentation of gcov."}, {"sha": "26ae8fcd2aa25ca57028057ebbe45316eaa4b1c6", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ab38481ceff08c995ade3e88eccee6ab92914a44", "patch": "@@ -2792,16 +2792,20 @@ static void\n perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n \t\t\t       vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t       vec<ipa_agg_jump_function_p> known_aggs_ptrs,\n-\t\t\t       int base_time, int removable_params_cost,\n+\t\t\t       sreal base_time, int removable_params_cost,\n \t\t\t       int est_move_cost, ipcp_value_base *val)\n {\n-  int time, size, time_benefit;\n+  int size, time_benefit;\n+  sreal time;\n   inline_hints hints;\n \n   estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n \t\t\t\t     known_aggs_ptrs, &size, &time,\n \t\t\t\t     &hints);\n-  time_benefit = base_time - time\n+  base_time -= time;\n+  if (base_time > 65535)\n+    base_time = 65535;\n+  time_benefit = base_time.to_int ()\n     + devirtualization_time_bonus (node, known_csts, known_contexts,\n \t\t\t\t   known_aggs_ptrs)\n     + hint_time_bonus (hints)\n@@ -2832,15 +2836,15 @@ estimate_local_effects (struct cgraph_node *node)\n   vec<ipa_agg_jump_function> known_aggs;\n   vec<ipa_agg_jump_function_p> known_aggs_ptrs;\n   bool always_const;\n-  int base_time = inline_summaries->get (node)->time.to_int ();\n+  sreal base_time = inline_summaries->get (node)->time.to_int ();\n   int removable_params_cost;\n \n   if (!count || !ipcp_versionable_function_p (node))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nEstimating effects for %s/%i, base_time: %i.\\n\",\n-\t     node->name (), node->order, base_time);\n+    fprintf (dump_file, \"\\nEstimating effects for %s/%i, base_time: %f.\\n\",\n+\t     node->name (), node->order, base_time.to_double ());\n \n   always_const = gather_context_independent_values (info, &known_csts,\n \t\t\t\t\t\t    &known_contexts, &known_aggs,\n@@ -2853,7 +2857,8 @@ estimate_local_effects (struct cgraph_node *node)\n     {\n       struct caller_statistics stats;\n       inline_hints hints;\n-      int time, size;\n+      sreal time;\n+      int size;\n \n       init_caller_stats (&stats);\n       node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats,\n@@ -2867,7 +2872,7 @@ estimate_local_effects (struct cgraph_node *node)\n \n       if (dump_file)\n \tfprintf (dump_file, \" - context independent values, size: %i, \"\n-\t\t \"time_benefit: %i\\n\", size, base_time - time);\n+\t\t \"time_benefit: %f\\n\", size, (base_time - time).to_double ());\n \n       if (size <= 0 || node->local.local)\n \t{\n@@ -2878,7 +2883,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t    fprintf (dump_file, \"     Decided to specialize for all \"\n \t\t     \"known contexts, code not going to grow.\\n\");\n \t}\n-      else if (good_cloning_opportunity_p (node, base_time - time,\n+      else if (good_cloning_opportunity_p (node, (base_time - time).to_int (),\n \t\t\t\t\t   stats.freq_sum, stats.count_sum,\n \t\t\t\t\t   size))\n \t{"}, {"sha": "e211d32fb58e3d5461e6c57637b1e6add6ca0113", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=ab38481ceff08c995ade3e88eccee6ab92914a44", "patch": "@@ -3260,7 +3260,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     vec<tree> known_vals,\n \t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n-\t\t\t     int *ret_size, int *ret_min_size, int *ret_time,\n+\t\t\t     int *ret_size, int *ret_min_size, sreal *ret_time,\n \t\t\t     inline_hints *ret_hints,\n \t\t\t     vec<inline_param_summary>\n \t\t\t     inline_param_summary)\n@@ -3336,14 +3336,14 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t\tknown_vals, known_contexts, known_aggs);\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n-  time = RDIV (time, INLINE_TIME_SCALE);\n+  time = time / INLINE_TIME_SCALE;\n   size = RDIV (size, INLINE_SIZE_SCALE);\n   min_size = RDIV (min_size, INLINE_SIZE_SCALE);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\n   size:%i time:%f\\n\", (int) size, time.to_double ());\n   if (ret_time)\n-    *ret_time = time.to_int ();\n+    *ret_time = time;\n   if (ret_size)\n     *ret_size = size;\n   if (ret_min_size)\n@@ -3365,7 +3365,7 @@ estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t\t   vec<ipa_polymorphic_call_context>\n \t\t\t\t   known_contexts,\n \t\t\t\t   vec<ipa_agg_jump_function_p> known_aggs,\n-\t\t\t\t   int *ret_size, int *ret_time,\n+\t\t\t\t   int *ret_size, sreal *ret_time,\n \t\t\t\t   inline_hints *hints)\n {\n   clause_t clause;\n@@ -3800,10 +3800,10 @@ simple_edge_hints (struct cgraph_edge *edge)\n    When caching, also update the cache entry.  Compute both time and\n    size, since we always need both metrics eventually.  */\n \n-int\n+sreal\n do_estimate_edge_time (struct cgraph_edge *edge)\n {\n-  int time;\n+  sreal time;\n   int size;\n   inline_hints hints;\n   struct cgraph_node *callee;\n@@ -3845,7 +3845,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n       inline_summaries->get (edge->callee)->min_size = min_size;\n       if ((int) edge_growth_cache.length () <= edge->uid)\n \tedge_growth_cache.safe_grow_cleared (symtab->edges_max_uid);\n-      edge_growth_cache[edge->uid].time = time + (time >= 0);\n+      edge_growth_cache[edge->uid].time = time;\n \n       edge_growth_cache[edge->uid].size = size + (size >= 0);\n       hints |= simple_edge_hints (edge);\n@@ -3933,26 +3933,6 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   return hints;\n }\n \n-\n-/* Estimate self time of the function NODE after inlining EDGE.  */\n-\n-int\n-estimate_time_after_inlining (struct cgraph_node *node,\n-\t\t\t      struct cgraph_edge *edge)\n-{\n-  struct inline_edge_summary *es = inline_edge_summary (edge);\n-  if (!es->predicate || !false_predicate_p (es->predicate))\n-    {\n-      sreal time =\n-\tinline_summaries->get (node)->time + estimate_edge_time (edge);\n-      if (time < 0)\n-\ttime = 0;\n-      return time.to_int ();\n-    }\n-  return inline_summaries->get (node)->time.to_int ();\n-}\n-\n-\n /* Estimate the size of NODE after inlining EDGE which should be an\n    edge to either NODE or a call inlined into NODE.  */\n "}, {"sha": "2bbe46a97d2faa838fcfcef5360c619ad83a6a76", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ab38481ceff08c995ade3e88eccee6ab92914a44", "patch": "@@ -663,13 +663,12 @@ compute_uninlined_call_time (struct inline_summary *callee_info,\n \n inline sreal\n compute_inlined_call_time (struct cgraph_edge *edge,\n-\t\t\t   int edge_time)\n+\t\t\t   sreal time)\n {\n   cgraph_node *caller = (edge->caller->global.inlined_to \n \t\t\t ? edge->caller->global.inlined_to\n \t\t\t : edge->caller);\n   sreal caller_time = inline_summaries->get (caller)->time;\n-  sreal time = edge_time;\n \n   if (edge->count && caller->count)\n     time *= (sreal)edge->count / caller->count;\n@@ -753,14 +752,6 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       int growth = estimate_edge_growth (e);\n       inline_hints hints = estimate_edge_hints (e);\n       bool big_speedup = big_speedup_p (e);\n-/*\n-\tfprintf (stderr, \"%i %i %i\\n\",growth,hints,big_speedup);\n-\tdump_inline_summary (stderr, e->caller->global.inlined_to ? e->caller->global.inlined_to : e->caller);\n-\tdump_inline_summary (stderr, e->callee);\n-  sreal time = compute_uninlined_call_time (inline_summaries->get (e->callee),\n-\t\t\t\t\t    e);\n-  sreal inlined_time = compute_inlined_call_time (e, estimate_edge_time (e));\n- fprintf (stderr, \"%f %f\\n\", time.to_double (), inlined_time.to_double ());*/\n \n       if (growth <= 0)\n \t;\n@@ -1019,7 +1010,8 @@ static sreal\n edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   sreal badness;\n-  int growth, edge_time;\n+  int growth;\n+  sreal edge_time;\n   struct cgraph_node *callee = edge->callee->ultimate_alias_target ();\n   struct inline_summary *callee_info = inline_summaries->get (callee);\n   inline_hints hints;\n@@ -1033,7 +1025,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n   gcc_checking_assert (edge_time >= 0);\n   /* FIXME: -1 to care of rounding issues should go away once cache is migrated.\n      to sreals.  */\n-  gcc_checking_assert (edge_time - 1 <= callee_info->time);\n+  gcc_checking_assert (edge_time <= callee_info->time);\n   gcc_checking_assert (growth <= callee_info->size);\n \n   if (dump)\n@@ -1043,9 +1035,9 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t       edge->caller->order,\n \t       xstrdup_for_dump (callee->name ()),\n \t       edge->callee->order);\n-      fprintf (dump_file, \"      size growth %i, time %i \",\n+      fprintf (dump_file, \"      size growth %i, time %f \",\n \t       growth,\n-\t       edge_time);\n+\t       edge_time.to_double ());\n       dump_inline_hints (dump_file, hints);\n       if (big_speedup_p (edge))\n \tfprintf (dump_file, \" big_speedup\");\n@@ -1883,7 +1875,7 @@ inline_small_functions (void)\n       sreal cached_badness = edge_badness (edge, false);\n  \n       int old_size_est = estimate_edge_size (edge);\n-      int old_time_est = estimate_edge_time (edge);\n+      sreal old_time_est = estimate_edge_time (edge);\n       int old_hints_est = estimate_edge_hints (edge);\n \n       reset_edge_growth_cache (edge);\n@@ -2250,20 +2242,20 @@ inline_to_all_callers (struct cgraph_node *node, void *data)\n static void\n dump_overall_stats (void)\n {\n-  int64_t sum_weighted = 0, sum = 0;\n+  sreal sum_weighted = 0, sum = 0;\n   struct cgraph_node *node;\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (!node->global.inlined_to\n \t&& !node->alias)\n       {\n-\tint time = inline_summaries->get (node)->time.to_double ();\n+\tsreal time = inline_summaries->get (node)->time;\n \tsum += time;\n \tsum_weighted += time * node->count;\n       }\n   fprintf (dump_file, \"Overall time estimate: \"\n-\t   \"%\" PRId64\" weighted by profile: \"\n-\t   \"%\" PRId64\"\\n\", sum, sum_weighted);\n+\t   \"%f weighted by profile: \"\n+\t   \"%f\\n\", sum.to_double (), sum_weighted.to_double ());\n }\n \n /* Output some useful stats about inlining.  */"}, {"sha": "8acf4d7ce5584b27a49b30d4a7ec0afd079f291c", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab38481ceff08c995ade3e88eccee6ab92914a44/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=ab38481ceff08c995ade3e88eccee6ab92914a44", "patch": "@@ -232,7 +232,8 @@ extern vec<inline_edge_summary_t> inline_edge_summary_vec;\n \n struct edge_growth_cache_entry\n {\n-  int time, size;\n+  sreal time;\n+  int size;\n   inline_hints hints;\n };\n \n@@ -249,19 +250,18 @@ void inline_write_summary (void);\n void inline_free_summary (void);\n void inline_analyze_function (struct cgraph_node *node);\n void initialize_inline_failed (struct cgraph_edge *);\n-int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n \t\t\t\t\tvec<tree>,\n \t\t\t\t\tvec<ipa_polymorphic_call_context>,\n \t\t\t\t\tvec<ipa_agg_jump_function_p>,\n-\t\t\t\t\tint *, int *, inline_hints *);\n+\t\t\t\t\tint *, sreal *, inline_hints *);\n int estimate_growth (struct cgraph_node *);\n bool growth_likely_positive (struct cgraph_node *, int);\n void inline_merge_summary (struct cgraph_edge *edge);\n void inline_update_overall_summary (struct cgraph_node *node);\n int do_estimate_edge_size (struct cgraph_edge *edge);\n-int do_estimate_edge_time (struct cgraph_edge *edge);\n+sreal do_estimate_edge_time (struct cgraph_edge *edge);\n inline_hints do_estimate_edge_hints (struct cgraph_edge *edge);\n void initialize_growth_caches (void);\n void free_growth_caches (void);\n@@ -314,14 +314,14 @@ estimate_edge_growth (struct cgraph_edge *edge)\n /* Return estimated callee runtime increase after inlining\n    EDGE.  */\n \n-static inline int\n+static inline sreal\n estimate_edge_time (struct cgraph_edge *edge)\n {\n-  int ret;\n+  sreal ret;\n   if ((int)edge_growth_cache.length () <= edge->uid\n-      || !(ret =  edge_growth_cache[edge->uid].time))\n+      || !edge_growth_cache[edge->uid].size)\n     return do_estimate_edge_time (edge);\n-  return ret - (ret > 0);\n+  return edge_growth_cache[edge->uid].time;\n }\n \n "}]}