{"sha": "2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU4NmJhNGJkYWFhNDc0MTNiOWMwM2ZmMTY0ZDkyNmZlNTJmOGRjMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-04-18T13:02:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-04-18T13:02:00Z"}, "message": "re PR tree-optimization/39804 (internal compiler error: in propagate_necessity, at tree-ssa-dce.c:754)\n\n2009-04-18  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/39804\n\t* tree-ssa-ccp.c (fold_stmt_1): New function factored from ...\n\t(fold_stmt): ... this and ...\n\t(fold_stmt_inplace): ... this.\n\t(fold_stmt_1): Fold references in calls and asms.\n\t* tree-cfg.c (remove_useless_stmts_cond): Use fold_stmt.\n\n\t* gcc.target/i386/pr39804.c: New testcase.\n\nFrom-SVN: r146314", "tree": {"sha": "c7477e42aa4ab8005b7012179ea47e216674f598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7477e42aa4ab8005b7012179ea47e216674f598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1eefab17a500e1978e50bdd05c565ed3c607f6b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eefab17a500e1978e50bdd05c565ed3c607f6b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eefab17a500e1978e50bdd05c565ed3c607f6b3"}], "stats": {"total": 171, "additions": 113, "deletions": 58}, "files": [{"sha": "19806f5544618c6df97781022878e3010bdc0446", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "patch": "@@ -1,3 +1,12 @@\n+2009-04-18  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/39804\n+\t* tree-ssa-ccp.c (fold_stmt_1): New function factored from ...\n+\t(fold_stmt): ... this and ...\n+\t(fold_stmt_inplace): ... this.\n+\t(fold_stmt_1): Fold references in calls and asms.\n+\t* tree-cfg.c (remove_useless_stmts_cond): Use fold_stmt.\n+\n 2009-04-18  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* tree-vrp.c (ssa_name_nonzero_p): Remove."}, {"sha": "846725e1daa6be4529c8029947f3dd8f34f899f6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "patch": "@@ -1,3 +1,8 @@\n+2009-04-18  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/39804\n+\t* gcc.target/i386/pr39804.c: New testcase.\n+\n 2009-04-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc.target/i386/pr39496.c: Compile with -mtune=i686."}, {"sha": "3ff2479084f84802a54f58c694cd83540f5e46e3", "filename": "gcc/testsuite/gcc.target/i386/pr39804.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39804.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39804.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr39804.c?ref=2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O\" } */\n+\n+typedef unsigned char u8;\n+struct __large_struct { unsigned long buf[100]; };\n+static inline __attribute__((always_inline)) unsigned long\n+__copy_from_user_inatomic(void *to, const void *from, unsigned long n)\n+{\n+  unsigned long ret = 0;\n+  asm volatile(\"1:\tmov\"\"b\"\" %2,%\"\"b\"\"1\\n\" \"2:\\n\"\n+\t       \".section .fixup,\\\"ax\\\"\\n\"\n+\t       \"3:\tmov %3,%0\\n\"\n+\t       \"\txor\"\"b\"\" %\"\"b\"\"1,%\"\"b\"\"1\\n\"\n+\t       \"\tjmp 2b\\n\"\n+\t       \".previous\\n\"\n+\t       \" .section __ex_table,\\\"a\\\"\\n\"\n+\t       \" \" \".balign 4\" \" \" \"\\n\"\n+\t       \" \" \".long\" \" \" \"1b\" \",\" \"3b\" \"\\n\"\n+\t       \" .previous\\n\"\n+\t       : \"=r\" (ret), \"=q\"(*(u8 *)to)\n+\t       : \"m\" ((*(struct __large_struct *)(from))), \"i\" (1), \"0\" (ret));\n+  return ret;\n+}\n+void romchecksum(const unsigned char *rom, unsigned char c)\n+{\n+  unsigned char sum;\n+  for (sum = 0;\n+       !__copy_from_user_inatomic(&(c), ( typeof(c) *)(rom++), sizeof(c));)\n+    sum += c;\n+}"}, {"sha": "d4aa935e1f69ffe3d0c79f845e15ee6c1122f0aa", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "patch": "@@ -1574,7 +1574,8 @@ remove_useless_stmts_cond (gimple_stmt_iterator *gsi, struct rus_data *data)\n   gimple stmt = gsi_stmt (*gsi);\n \n   /* The folded result must still be a conditional statement.  */\n-  fold_stmt_inplace (stmt);\n+  fold_stmt (gsi);\n+  gcc_assert (gsi_stmt (*gsi) == stmt);\n \n   data->may_branch = true;\n "}, {"sha": "9cf2f83546b70a2618395d6c4de4618b3d2f53cd", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 66, "deletions": 57, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2586ba4bdaaa47413b9c03ff164d926fe52f8dc1/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=2586ba4bdaaa47413b9c03ff164d926fe52f8dc1", "patch": "@@ -2836,43 +2836,81 @@ fold_gimple_call (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n-/* Fold the statement pointed to by GSI.  In some cases, this function may\n-   replace the whole statement with a new one.  Returns true iff folding\n-   makes any changes.\n-   The statement pointed to by GSI should be in valid gimple form but may\n-   be in unfolded state as resulting from for example constant propagation\n-   which can produce *&x = 0.  */\n+/* Worker for both fold_stmt and fold_stmt_inplace.  The INPLACE argument\n+   distinguishes both cases.  */\n \n-bool\n-fold_stmt (gimple_stmt_iterator *gsi)\n+static bool\n+fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace)\n {\n   bool changed = false;\n   gimple stmt = gsi_stmt (*gsi);\n+  unsigned i;\n \n   /* Fold the main computation performed by the statement.  */\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_ASSIGN:\n       {\n+\tunsigned old_num_ops = gimple_num_ops (stmt);\n \ttree new_rhs = fold_gimple_assign (gsi);\n-\tif (new_rhs != NULL_TREE)\n+\tif (new_rhs != NULL_TREE\n+\t    && (!inplace\n+\t\t|| get_gimple_rhs_num_ops (TREE_CODE (new_rhs)) < old_num_ops))\n \t  {\n \t    gimple_assign_set_rhs_from_tree (gsi, new_rhs);\n \t    changed = true;\n \t  }\n \tbreak;\n       }\n+\n     case GIMPLE_COND:\n       changed |= fold_gimple_cond (stmt);\n       break;\n+\n     case GIMPLE_CALL:\n+      /* Fold *& in call arguments.  */\n+      for (i = 0; i < gimple_call_num_args (stmt); ++i)\n+\tif (REFERENCE_CLASS_P (gimple_call_arg (stmt, i)))\n+\t  {\n+\t    tree tmp = maybe_fold_reference (gimple_call_arg (stmt, i), false);\n+\t    if (tmp)\n+\t      {\n+\t\tgimple_call_set_arg (stmt, i, tmp);\n+\t\tchanged = true;\n+\t      }\n+\t  }\n       /* The entire statement may be replaced in this case.  */\n-      changed |= fold_gimple_call (gsi);\n+      if (!inplace)\n+\tchanged |= fold_gimple_call (gsi);\n       break;\n \n-    default:\n-      return changed;\n+    case GIMPLE_ASM:\n+      /* Fold *& in asm operands.  */\n+      for (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\t{\n+\t  tree link = gimple_asm_output_op (stmt, i);\n+\t  tree op = TREE_VALUE (link);\n+\t  if (REFERENCE_CLASS_P (op)\n+\t      && (op = maybe_fold_reference (op, true)) != NULL_TREE)\n+\t    {\n+\t      TREE_VALUE (link) = op;\n+\t      changed = true;\n+\t    }\n+\t}\n+      for (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\t{\n+\t  tree link = gimple_asm_input_op (stmt, i);\n+\t  tree op = TREE_VALUE (link);\n+\t  if (REFERENCE_CLASS_P (op)\n+\t      && (op = maybe_fold_reference (op, false)) != NULL_TREE)\n+\t    {\n+\t      TREE_VALUE (link) = op;\n+\t      changed = true;\n+\t    }\n+\t}\n       break;\n+\n+    default:;\n     }\n \n   stmt = gsi_stmt (*gsi);\n@@ -2895,6 +2933,19 @@ fold_stmt (gimple_stmt_iterator *gsi)\n   return changed;\n }\n \n+/* Fold the statement pointed to by GSI.  In some cases, this function may\n+   replace the whole statement with a new one.  Returns true iff folding\n+   makes any changes.\n+   The statement pointed to by GSI should be in valid gimple form but may\n+   be in unfolded state as resulting from for example constant propagation\n+   which can produce *&x = 0.  */\n+\n+bool\n+fold_stmt (gimple_stmt_iterator *gsi)\n+{\n+  return fold_stmt_1 (gsi, false);\n+}\n+\n /* Perform the minimal folding on statement STMT.  Only operations like\n    *&x created by constant propagation are handled.  The statement cannot\n    be replaced with a new one.  Return true if the statement was\n@@ -2906,51 +2957,9 @@ fold_stmt (gimple_stmt_iterator *gsi)\n bool\n fold_stmt_inplace (gimple stmt)\n {\n-  gimple_stmt_iterator si;\n-  bool changed = false;\n-\n-  /* Fold the main computation performed by the statement.  */\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_ASSIGN:\n-      {\n-\tunsigned old_num_ops;\n-\ttree new_rhs;\n-\told_num_ops = gimple_num_ops (stmt);\n-\tsi = gsi_for_stmt (stmt);\n-\tnew_rhs = fold_gimple_assign (&si);\n-\tif (new_rhs != NULL_TREE\n-\t    && get_gimple_rhs_num_ops (TREE_CODE (new_rhs)) < old_num_ops)\n-\t  {\n-\t    gimple_assign_set_rhs_from_tree (&si, new_rhs);\n-\t    changed = true;\n-\t  }\n-\tgcc_assert (gsi_stmt (si) == stmt);\n-\tbreak;\n-      }\n-    case GIMPLE_COND:\n-      changed |= fold_gimple_cond (stmt);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Fold *& on the lhs.  */\n-  if (gimple_has_lhs (stmt))\n-    {\n-      tree lhs = gimple_get_lhs (stmt);\n-      if (lhs && REFERENCE_CLASS_P (lhs))\n-\t{\n-\t  tree new_lhs = maybe_fold_reference (lhs, true);\n-\t  if (new_lhs)\n-\t    {\n-\t      gimple_set_lhs (stmt, new_lhs);\n-\t      changed = true;\n-\t    }\n-\t}\n-    }\n-\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  bool changed = fold_stmt_1 (&gsi, true);\n+  gcc_assert (gsi_stmt (gsi) == stmt);\n   return changed;\n }\n "}]}