{"sha": "254110c201b31e3d35bfe1f53e94f447f915c898", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU0MTEwYzIwMWIzMWUzZDM1YmZlMWY1M2U5NGY0NDdmOTE1Yzg5OA==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-06-23T02:24:13Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-06-23T02:24:13Z"}, "message": "Complete this set of changes to make the Sparc\n\tbackend completely gen_rtx clean.\n\nFrom-SVN: r20669", "tree": {"sha": "911815c7ecd769442ae3555005d584745521b073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/911815c7ecd769442ae3555005d584745521b073"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/254110c201b31e3d35bfe1f53e94f447f915c898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/254110c201b31e3d35bfe1f53e94f447f915c898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/254110c201b31e3d35bfe1f53e94f447f915c898", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/254110c201b31e3d35bfe1f53e94f447f915c898/comments", "author": null, "committer": null, "parents": [{"sha": "519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519ebd1eecb18d95a75b8e4e3e5c063c4b82608b"}], "stats": {"total": 235, "additions": 118, "deletions": 117}, "files": [{"sha": "ab4cacf915ad27ac931759d18309546744e59c7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254110c201b31e3d35bfe1f53e94f447f915c898/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254110c201b31e3d35bfe1f53e94f447f915c898/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=254110c201b31e3d35bfe1f53e94f447f915c898", "patch": "@@ -5,7 +5,8 @@ Mon Jun 22 23:57:31 1998  David S. Miller <davem@pierdol.cobaltmicro.com>\n \tsubdi3, negdi2, call, call_value, untyped_return, nonlocal_goto,\n \tsplits and peepholes): Change remaining generic gen_rtx calls to\n \tspecific genrtl ones.\n-\n+\t* config/sparc/sparc.c: Likewise.\n+\t\n Mon Jun 22 22:21:46 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* gcc.c (handle_braces): Recognize | between options as an or."}, {"sha": "4bdaaae22d704af150de3e691ab364e2f88aa1e5", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254110c201b31e3d35bfe1f53e94f447f915c898/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254110c201b31e3d35bfe1f53e94f447f915c898/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=254110c201b31e3d35bfe1f53e94f447f915c898", "patch": "@@ -1039,24 +1039,24 @@ gen_compare_reg (code, x, y)\n \t  prev_args[reg][1] = y;\n \t  next_fcc_reg = (next_fcc_reg + 1) & 3;\n \t}\n-      cc_reg = gen_rtx (REG, mode, reg + SPARC_FIRST_V9_FCC_REG);\n+      cc_reg = gen_rtx_REG (mode, reg + SPARC_FIRST_V9_FCC_REG);\n     }\n #else\n     cc_reg = gen_reg_rtx (mode);\n #endif /* ! experiment */\n   else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-    cc_reg = gen_rtx (REG, mode, SPARC_FCC_REG);\n+    cc_reg = gen_rtx_REG (mode, SPARC_FCC_REG);\n   else\n-    cc_reg = gen_rtx (REG, mode, SPARC_ICC_REG);\n+    cc_reg = gen_rtx_REG (mode, SPARC_ICC_REG);\n \n   if (TARGET_V8PLUS && mode == CCXmode)\n     {\n       emit_insn (gen_cmpdi_v8plus (x, y));\n     }\n   else\n     {\n-      emit_insn (gen_rtx (SET, VOIDmode, cc_reg,\n-\t\t\t  gen_rtx (COMPARE, mode, x, y)));\n+      emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n+\t\t\t  gen_rtx_COMPARE (mode, x, y)));\n     }\n \n   return cc_reg;\n@@ -1123,28 +1123,28 @@ gen_v9_scc (compare_code, operands)\n \t  && GET_MODE (operands[0]) == DImode\n \t  && GET_MODE (op0) == DImode)\n \t{\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operands[0], op0));\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t      gen_rtx (IF_THEN_ELSE, DImode,\n-\t\t\t\t       gen_rtx (compare_code, DImode,\n-\t\t\t\t\t\top0, const0_rtx),\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operands[0], op0));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t      gen_rtx_IF_THEN_ELSE (DImode,\n+\t\t\t\t       gen_rtx_fmt_ee (compare_code, DImode,\n+\t\t\t\t\t\t       op0, const0_rtx),\n \t\t\t\t       const1_rtx,\n \t\t\t\t       operands[0])));\n \t  return 1;\n \t}\n \n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0], const0_rtx));\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], const0_rtx));\n       if (GET_MODE (op0) != DImode)\n \t{\n \t  temp = gen_reg_rtx (DImode);\n \t  convert_move (temp, op0, 0);\n \t}\n       else\n \ttemp = op0;\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t  gen_rtx (IF_THEN_ELSE, GET_MODE (operands[0]),\n-\t\t\t\t   gen_rtx (compare_code, DImode,\n-\t\t\t\t\t    temp, const0_rtx),\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t\t   gen_rtx_fmt_ee (compare_code, DImode,\n+\t\t\t\t\t\t   temp, const0_rtx),\n \t\t\t\t   const1_rtx,\n \t\t\t\t   operands[0])));\n       return 1;\n@@ -1163,12 +1163,12 @@ gen_v9_scc (compare_code, operands)\n \t  default :\n \t    abort ();\n \t}\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0], const0_rtx));\n-      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n-\t\t\t  gen_rtx (IF_THEN_ELSE, GET_MODE (operands[0]),\n-\t\t\t\t   gen_rtx (compare_code,\n-\t\t\t\t\t    GET_MODE (operands[1]),\n-\t\t\t\t\t    operands[1], const0_rtx),\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], const0_rtx));\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t  gen_rtx_IF_THEN_ELSE (GET_MODE (operands[0]),\n+\t\t\t\t   gen_rtx_fmt_ee (compare_code,\n+\t\t\t\t\t\t   GET_MODE (operands[1]),\n+\t\t\t\t\t\t   operands[1], const0_rtx),\n \t\t\t\t    const1_rtx, operands[0])));\n       return 1;\n     }\n@@ -1183,12 +1183,12 @@ emit_v9_brxx_insn (code, op0, label)\n      enum rtx_code code;\n      rtx op0, label;\n {\n-  emit_jump_insn (gen_rtx (SET, VOIDmode,\n+  emit_jump_insn (gen_rtx_SET (VOIDmode,\n \t\t\t   pc_rtx,\n-\t\t\t   gen_rtx (IF_THEN_ELSE, VOIDmode,\n-\t\t\t\t    gen_rtx (code, GET_MODE (op0),\n-\t\t\t\t\t     op0, const0_rtx),\n-\t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, label),\n+\t\t\t   gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t    gen_rtx_fmt_ee (code, GET_MODE (op0),\n+\t\t\t\t\t\t    op0, const0_rtx),\n+\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label),\n \t\t\t\t    pc_rtx)));\n }\n \f\n@@ -1470,15 +1470,15 @@ legitimize_pic_address (orig, mode, reg)\n       else\n \taddress = orig;\n \n-      pic_ref = gen_rtx (MEM, Pmode,\n-\t\t\t gen_rtx (PLUS, Pmode,\n+      pic_ref = gen_rtx_MEM (Pmode,\n+\t\t\t gen_rtx_PLUS (Pmode,\n \t\t\t\t  pic_offset_table_rtx, address));\n       current_function_uses_pic_offset_table = 1;\n       RTX_UNCHANGING_P (pic_ref) = 1;\n       insn = emit_move_insn (reg, pic_ref);\n       /* Put a REG_EQUAL note on this insn, so that it can be optimized\n \t by loop.  */\n-      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig,\n \t\t\t\t  REG_NOTES (insn));\n       return reg;\n     }\n@@ -1517,7 +1517,7 @@ legitimize_pic_address (orig, mode, reg)\n \t    /* If we reach here, then something is seriously wrong.  */\n \t    abort ();\n \t}\n-      return gen_rtx (PLUS, Pmode, base, offset);\n+      return gen_rtx_PLUS (Pmode, base, offset);\n     }\n   else if (GET_CODE (orig) == LABEL_REF)\n     /* ??? Why do we do this?  */\n@@ -1578,8 +1578,8 @@ finalize_pic ()\n \n   /* Initialize every time through, since we can't easily\n      know this to be permanent.  */\n-  global_offset_table = gen_rtx (SYMBOL_REF, Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-  get_pc_symbol = gen_rtx (SYMBOL_REF, Pmode, get_pc_symbol_name);\n+  global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+  get_pc_symbol = gen_rtx_SYMBOL_REF (Pmode, get_pc_symbol_name);\n   flag_pic = 0;\n \n   emit_insn_after (pic_setup_code (), get_insns ());\n@@ -1596,7 +1596,7 @@ finalize_pic ()\n      since setjmp/longjmp can cause life info to screw up.\n      ??? In the case where we don't obey regdecls, this is not sufficient\n      since we may not fall out the bottom.  */\n-  emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n+  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n }\n \f\n /* Emit insns to move operands[1] into operands[0].\n@@ -1638,7 +1638,7 @@ emit_move_sequence (operands, mode)\n \t  || GET_CODE (operand1) == MEM)\n \t{\n \t  /* Run this case quickly.  */\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operand1));\n \t  return 1;\n \t}\n     }\n@@ -1648,7 +1648,7 @@ emit_move_sequence (operands, mode)\n \t  || (operand1 == const0_rtx && ! TARGET_LIVE_G0))\n \t{\n \t  /* Run this case quickly.  */\n-\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operand0, operand1));\n \t  return 1;\n \t}\n       if (! reload_in_progress)\n@@ -1727,10 +1727,10 @@ emit_move_sequence (operands, mode)\n \t  if (TARGET_ARCH64 && mode == DImode)\n \t    emit_insn (gen_sethi_di_sp64 (temp, operand1));\n \t  else\n-\t    emit_insn (gen_rtx (SET, VOIDmode, temp,\n-\t\t\t\tgen_rtx (HIGH, mode, operand1)));\n+\t    emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t\tgen_rtx_HIGH (mode, operand1)));\n \n-\t  operands[1] = gen_rtx (LO_SUM, mode, temp, operand1);\n+\t  operands[1] = gen_rtx_LO_SUM (mode, temp, operand1);\n \t}\n     }\n \n@@ -1983,14 +1983,14 @@ output_move_double (operands)\n      operands in OPERANDS to be suitable for the low-numbered word.  */\n \n   if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx (REG, SImode, REGNO (op0) + 1);\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (op0) + 1);\n   else if (optype0 == OFFSOP)\n     latehalf[0] = adj_offsettable_operand (op0, 4);\n   else\n     latehalf[0] = op0;\n \n   if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx (REG, SImode, REGNO (op1) + 1);\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (op1) + 1);\n   else if (optype1 == OFFSOP)\n     latehalf[1] = adj_offsettable_operand (op1, 4);\n   else if (optype1 == CNSTOP)\n@@ -2100,7 +2100,7 @@ output_move_double (operands)\n \t  xops[0] = latehalf[0];\n \t  xops[1] = op0;\n \t  output_asm_insn (\"add %1,%0,%1\", xops);\n-\t  operands[1] = gen_rtx (MEM, DImode, op0);\n+\t  operands[1] = gen_rtx_MEM (DImode, op0);\n \t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n \t  addreg1 = 0;\n \t  highest_first = 1;\n@@ -2203,17 +2203,17 @@ output_move_quad (operands)\n \n   if (optype0 == REGOP)\n     {\n-      wordpart[0][0] = gen_rtx (REG, word_mode, REGNO (op0) + 0);\n+      wordpart[0][0] = gen_rtx_REG (word_mode, REGNO (op0) + 0);\n       if (TARGET_ARCH64 && FP_REG_P (op0) \n \t  && REGNO (op0) < SPARC_FIRST_V9_FP_REG)\n-\twordpart[1][0] = gen_rtx (REG, word_mode, REGNO (op0) + 2);\n+\twordpart[1][0] = gen_rtx_REG (word_mode, REGNO (op0) + 2);\n       else\n-\twordpart[1][0] = gen_rtx (REG, word_mode, REGNO (op0) + 1);\n+\twordpart[1][0] = gen_rtx_REG (word_mode, REGNO (op0) + 1);\n \n       if (TARGET_ARCH32)\n \t{\n-\t  wordpart[2][0] = gen_rtx (REG, word_mode, REGNO (op0) + 2);\n-\t  wordpart[3][0] = gen_rtx (REG, word_mode, REGNO (op0) + 3);\n+\t  wordpart[2][0] = gen_rtx_REG (word_mode, REGNO (op0) + 2);\n+\t  wordpart[3][0] = gen_rtx_REG (word_mode, REGNO (op0) + 3);\n \t}\n   \n       /* Loading into a register which overlaps a register used in the\n@@ -2260,7 +2260,7 @@ output_move_quad (operands)\n \t      output_asm_insn (\"add %0, %1, %2\", temp);\n \t      load_late_half[0] = 0;\n \t      load_late_half[1] = 1;\n-\t      op1 = gen_rtx (MEM, TFmode, wordpart[3][0]);\n+\t      op1 = gen_rtx_MEM (TFmode, wordpart[3][0]);\n \t      operands[1] = op1;\n \t      optype1 = OFFSOP;\n \t    }\n@@ -2301,17 +2301,17 @@ output_move_quad (operands)\n \n   if (optype1 == REGOP)\n     {\n-      wordpart[0][1] = gen_rtx (REG, word_mode, REGNO (op1) + 0);\n+      wordpart[0][1] = gen_rtx_REG (word_mode, REGNO (op1) + 0);\n       if (TARGET_ARCH64 && FP_REG_P (op1)\n \t  && REGNO (op1) < SPARC_FIRST_V9_FP_REG)\n-\twordpart[1][1] = gen_rtx (REG, word_mode, REGNO (op1) + 2);\n+\twordpart[1][1] = gen_rtx_REG (word_mode, REGNO (op1) + 2);\n       else\n-\twordpart[1][1] = gen_rtx (REG, word_mode, REGNO (op1) + 1);\n+\twordpart[1][1] = gen_rtx_REG (word_mode, REGNO (op1) + 1);\n \n       if (TARGET_ARCH32)\n \t{\n-\t  wordpart[2][1] = gen_rtx (REG, word_mode, REGNO (op1) + 2);\n-\t  wordpart[3][1] = gen_rtx (REG, word_mode, REGNO (op1) + 3);\n+\t  wordpart[2][1] = gen_rtx_REG (word_mode, REGNO (op1) + 2);\n+\t  wordpart[3][1] = gen_rtx_REG (word_mode, REGNO (op1) + 3);\n \t}\n     }\n   else if (optype1 == OFFSOP)\n@@ -2468,7 +2468,7 @@ output_move_quad (operands)\n \t      int fix = offset - i * 4;\n \n \t      /* Back up to the appropriate place. */\n-\t      temp[1] = gen_rtx (CONST_INT, VOIDmode, -fix);\n+\t      temp[1] = gen_rtx_CONST_INT (VOIDmode, -fix);\n \t      if (addreg0)\n \t\t{\n \t\t  temp[0] = addreg0;\n@@ -2483,7 +2483,7 @@ output_move_quad (operands)\n \t\t\t       wordpart[i]);\n \t      /* Don't modify the register that's the destination of the\n \t\t move. */\n-\t      temp[0] = gen_rtx (CONST_INT, VOIDmode, -(offset - fix));\n+\t      temp[0] = gen_rtx_CONST_INT (VOIDmode, -(offset - fix));\n \t      if (addreg0 && REGNO (addreg0) != REGNO (wordpart[i][0]))\n \t\t{\n \t\t  temp[1] = addreg0;\n@@ -2500,7 +2500,7 @@ output_move_quad (operands)\n \t}\n       if (offset)\n \t{\n-\t  temp[1] = gen_rtx (CONST_INT, VOIDmode, -offset);\n+\t  temp[1] = gen_rtx_CONST_INT (VOIDmode, -offset);\n \t  /* Undo the adds we just did.  */\n \t  if (addreg0)\n \t    {\n@@ -3757,9 +3757,9 @@ output_function_epilogue (file, size, leaf_function)\n \t  /* If we wound up with things in our delay slot, flush them here.  */\n \t  if (current_function_epilogue_delay_list)\n \t    {\n-\t      rtx insn = emit_jump_insn_after (gen_rtx (RETURN, VOIDmode),\n+\t      rtx insn = emit_jump_insn_after (gen_rtx_RETURN (VOIDmode),\n \t\t\t\t\t       get_last_insn ());\n-\t      PATTERN (insn) = gen_rtx (PARALLEL, VOIDmode,\n+\t      PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t\t\tgen_rtvec (2,\n \t\t\t\t\t\t   PATTERN (XEXP (current_function_epilogue_delay_list, 0)),\n \t\t\t\t\t\t   PATTERN (insn)));\n@@ -4148,9 +4148,9 @@ function_arg_record_value_3 (bitpos, parms)\n   do\n     {\n       regno = parms->regbase + this_slotno;\n-      reg = gen_rtx (REG, mode, regno);\n+      reg = gen_rtx_REG (mode, regno);\n       XVECEXP (parms->ret, 0, parms->nregs)\n-\t= gen_rtx (EXPR_LIST, VOIDmode, reg, GEN_INT (intoffset));\n+\t= gen_rtx_EXPR_LIST (VOIDmode, reg, GEN_INT (intoffset));\n \n       this_slotno += 1;\n       intoffset = (intoffset | (UNITS_PER_WORD-1)) + 1;\n@@ -4201,12 +4201,12 @@ function_arg_record_value_2 (type, startbitpos, parms)\n \n \t      function_arg_record_value_3 (bitpos, parms);\n \n-\t      reg = gen_rtx (REG, DECL_MODE (field),\n+\t      reg = gen_rtx_REG (DECL_MODE (field),\n \t\t\t         (SPARC_FP_ARG_FIRST + this_slotno * 2\n \t\t\t          + (DECL_MODE (field) == SFmode\n \t\t\t\t     && (bitpos & 32) != 0)));\n \t      XVECEXP (parms->ret, 0, parms->nregs)\n-\t\t= gen_rtx (EXPR_LIST, VOIDmode, reg,\n+\t\t= gen_rtx_EXPR_LIST (VOIDmode, reg,\n \t\t\t   GEN_INT (bitpos / BITS_PER_UNIT));\n \t      parms->nregs += 1;\n \t    }\n@@ -4263,7 +4263,7 @@ function_arg_record_value (type, slotno, named, regbase)\n \t     anyway so the rest of gcc doesn't go nuts.  Returning a PARALLEL\n \t     leads to breakage due to the fact that there are zero bytes to\n \t     load.  */\n-\t  return gen_rtx (REG, DImode, regbase);\n+\t  return gen_rtx_REG (DImode, regbase);\n \t}\n       else\n \t{\n@@ -4277,7 +4277,7 @@ function_arg_record_value (type, slotno, named, regbase)\n   if (nregs == 0)\n     abort();\n \n-  parms.ret = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (nregs));\n+  parms.ret = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nregs));\n \n   /* Fill in the entries.  */\n   parms.nregs = 0;\n@@ -4328,7 +4328,7 @@ function_arg (cum, mode, type, named, incoming_p)\n \n   if (TARGET_ARCH32)\n     {\n-      reg = gen_rtx (REG, mode, regno);\n+      reg = gen_rtx_REG (mode, regno);\n       return reg;\n     }\n \n@@ -4340,7 +4340,7 @@ function_arg (cum, mode, type, named, incoming_p)\n        || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n       && SPARC_FP_REG_P (regno))\n     {\n-      reg = gen_rtx (REG, mode, regno);\n+      reg = gen_rtx_REG (mode, regno);\n       if (cum->prototype_p || cum->libcall_p)\n \t{\n \t  /* \"* 2\" because fp reg numbers are recorded in 4 byte\n@@ -4351,11 +4351,11 @@ function_arg (cum, mode, type, named, incoming_p)\n \t     value in the reg but reserve space on the stack.  That's an\n \t     optimization, and is deferred [for a bit].  */\n \t  if ((regno - SPARC_FP_ARG_FIRST) >= SPARC_INT_ARG_MAX * 2)\n-\t    return gen_rtx (PARALLEL, mode,\n+\t    return gen_rtx_PARALLEL (mode,\n \t\t\t    gen_rtvec (2,\n-\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t\tNULL_RTX, const0_rtx),\n-\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode,\n+\t\t\t\t       gen_rtx_EXPR_LIST (VOIDmode,\n \t\t\t\t\t\treg, const0_rtx)));\n \t  else\n #else\n@@ -4420,12 +4420,12 @@ function_arg (cum, mode, type, named, incoming_p)\n \tabort ();\n \n       mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 0);\n-      reg = gen_rtx (REG, mode, regno);\n+      reg = gen_rtx_REG (mode, regno);\n     }\n   else\n     {\n       /* Scalar or complex int.  */\n-      reg = gen_rtx (REG, mode, regno);\n+      reg = gen_rtx_REG (mode, regno);\n     }\n \n   return reg;\n@@ -4657,7 +4657,7 @@ function_value (type, mode, incoming_p)\n   else\n     regno = BASE_OUTGOING_VALUE_REG (mode);\n \n-  return gen_rtx (REG, mode, regno);\n+  return gen_rtx_REG (mode, regno);\n }\n \n /* Do what is necessary for `va_start'.  The argument is ignored.\n@@ -4674,15 +4674,15 @@ sparc_builtin_saveregs (arglist)\n   int regno;\n \n   for (regno = first_reg; regno < NPARM_REGS (word_mode); regno++)\n-    emit_move_insn (gen_rtx (MEM, word_mode,\n-\t\t\t     gen_rtx (PLUS, Pmode,\n+    emit_move_insn (gen_rtx_MEM (word_mode,\n+\t\t\t     gen_rtx_PLUS (Pmode,\n \t\t\t\t      frame_pointer_rtx,\n \t\t\t\t      GEN_INT (STACK_POINTER_OFFSET\n \t\t\t\t\t       + UNITS_PER_WORD * regno))),\n-\t\t    gen_rtx (REG, word_mode,\n+\t\t    gen_rtx_REG (word_mode,\n \t\t\t     BASE_INCOMING_ARG_REG (word_mode) + regno));\n \n-  address = gen_rtx (PLUS, Pmode,\n+  address = gen_rtx_PLUS (Pmode,\n \t\t     frame_pointer_rtx,\n \t\t     GEN_INT (STACK_POINTER_OFFSET\n \t\t\t      + UNITS_PER_WORD * first_reg));\n@@ -5706,27 +5706,27 @@ sparc_initialize_trampoline (tramp, fnaddr, cxt)\n \t\t\t     size_int (10), 0, 1);\n   rtx low_cxt = expand_and (cxt, GEN_INT (0x3ff), 0);\n   rtx low_fn = expand_and (fnaddr, GEN_INT (0x3ff), 0);\n-  rtx g1_sethi = gen_rtx (HIGH, SImode, GEN_INT (0x03000000));\n-  rtx g2_sethi = gen_rtx (HIGH, SImode, GEN_INT (0x05000000));\n-  rtx g1_ori = gen_rtx (HIGH, SImode, GEN_INT (0x82106000));\n-  rtx g2_ori = gen_rtx (HIGH, SImode, GEN_INT (0x8410A000));\n+  rtx g1_sethi = gen_rtx_HIGH (SImode, GEN_INT (0x03000000));\n+  rtx g2_sethi = gen_rtx_HIGH (SImode, GEN_INT (0x05000000));\n+  rtx g1_ori = gen_rtx_HIGH (SImode, GEN_INT (0x82106000));\n+  rtx g2_ori = gen_rtx_HIGH (SImode, GEN_INT (0x8410A000));\n   rtx tem = gen_reg_rtx (SImode);\n   emit_move_insn (tem, g1_sethi);\n   emit_insn (gen_iorsi3 (high_fn, high_fn, tem));\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 0)), high_fn);\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 0)), high_fn);\n   emit_move_insn (tem, g1_ori);\n   emit_insn (gen_iorsi3 (low_fn, low_fn, tem));\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 4)), low_fn);\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 4)), low_fn);\n   emit_move_insn (tem, g2_sethi);\n   emit_insn (gen_iorsi3 (high_cxt, high_cxt, tem));\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 8)), high_cxt);\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 8)), high_cxt);\n   emit_move_insn (tem, g2_ori);\n   emit_insn (gen_iorsi3 (low_cxt, low_cxt, tem));\n-  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (tramp, 16)), low_cxt);\n-  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, SImode, tramp))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, SImode,\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 16)), low_cxt);\n+  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (SImode, tramp))));\n+  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (SImode,\n \t\t\t\t\t       plus_constant (tramp, 8)))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, SImode,\n+  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (SImode,\n \t\t\t\t\t       plus_constant (tramp, 16)))));\n }\n \n@@ -5738,16 +5738,16 @@ void\n sparc64_initialize_trampoline (tramp, fnaddr, cxt)\n      rtx tramp, fnaddr, cxt;\n {\n-  emit_move_insn (gen_rtx (MEM, DImode, plus_constant (tramp, 24)), cxt);\n-  emit_move_insn (gen_rtx (MEM, DImode, plus_constant (tramp, 32)), fnaddr);\n-  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, DImode, tramp))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, DImode,\n+  emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, 24)), cxt);\n+  emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, 32)), fnaddr);\n+  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode, tramp))));\n+  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode,\n \t\t\t\t\t       plus_constant (tramp, 8)))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, DImode,\n+  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode,\n \t\t\t\t\t       plus_constant (tramp, 16)))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, DImode,\n+  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode,\n \t\t\t\t\t       plus_constant (tramp, 24)))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx (MEM, DImode,\n+  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode,\n \t\t\t\t\t       plus_constant (tramp, 32)))));\n }\n \f"}, {"sha": "a8fb8f82d93e882bf95a74783607bdfc27b0fd2c", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/254110c201b31e3d35bfe1f53e94f447f915c898/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/254110c201b31e3d35bfe1f53e94f447f915c898/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=254110c201b31e3d35bfe1f53e94f447f915c898", "patch": "@@ -2701,14 +2701,14 @@\n       && GET_MODE (sparc_compare_op0) == DImode\n       && v9_regcmp_p (code))\n     {\n-      operands[1] = gen_rtx (code, DImode,\n+      operands[1] = gen_rtx_fmt_ee (code, DImode,\n \t\t\t     sparc_compare_op0, sparc_compare_op1);\n     }\n   else\n     {\n       rtx cc_reg = gen_compare_reg (code,\n \t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n-      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n     }\n }\")\n \n@@ -2731,14 +2731,14 @@\n       && GET_MODE (sparc_compare_op0) == DImode\n       && v9_regcmp_p (code))\n     {\n-      operands[1] = gen_rtx (code, DImode,\n+      operands[1] = gen_rtx_fmt_ee (code, DImode,\n \t\t\t     sparc_compare_op0, sparc_compare_op1);\n     }\n   else\n     {\n       rtx cc_reg = gen_compare_reg (code,\n \t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n-      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n     }\n }\")\n \n@@ -2816,14 +2816,14 @@\n       && GET_MODE (sparc_compare_op0) == DImode\n       && v9_regcmp_p (code))\n     {\n-      operands[1] = gen_rtx (code, DImode,\n+      operands[1] = gen_rtx_fmt_ee (code, DImode,\n \t\t\t     sparc_compare_op0, sparc_compare_op1);\n     }\n   else\n     {\n       rtx cc_reg = gen_compare_reg (code,\n \t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n-      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n     }\n }\")\n \n@@ -2846,14 +2846,14 @@\n       && GET_MODE (sparc_compare_op0) == DImode\n       && v9_regcmp_p (code))\n     {\n-      operands[1] = gen_rtx (code, DImode,\n+      operands[1] = gen_rtx_fmt_ee (code, DImode,\n \t\t\t     sparc_compare_op0, sparc_compare_op1);\n     }\n   else\n     {\n       rtx cc_reg = gen_compare_reg (code,\n \t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n-      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n     }\n }\")\n \n@@ -2876,14 +2876,14 @@\n       && GET_MODE (sparc_compare_op0) == DImode\n       && v9_regcmp_p (code))\n     {\n-      operands[1] = gen_rtx (code, DImode,\n+      operands[1] = gen_rtx_fmt_ee (code, DImode,\n \t\t\t     sparc_compare_op0, sparc_compare_op1);\n     }\n   else\n     {\n       rtx cc_reg = gen_compare_reg (code,\n \t\t\t\t    sparc_compare_op0, sparc_compare_op1);\n-      operands[1] = gen_rtx (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n     }\n }\")\n \n@@ -3146,7 +3146,7 @@\n       operand1 = XEXP (operand1, 0);\n     }\n \n-  emit_insn (gen_ashlsi3 (temp, gen_rtx (SUBREG, SImode, operand1,\n+  emit_insn (gen_ashlsi3 (temp, gen_rtx_SUBREG (SImode, operand1,\n \t\t\t\t\t op1_subword),\n \t\t\t  shift_16));\n   emit_insn (gen_lshrsi3 (operand0, temp, shift_16));\n@@ -3688,7 +3688,7 @@ return \\\"srl %1,0,%0\\\";\n \t\t\t\t   gen_rtx_PLUS (DImode, operands[1],\n \t\t\t\t\t\t operands[2])),\n \t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_raw_REG (SImode, SPARC_ICC_REG)))));\n+\t\t\t\t   gen_rtx_REG (SImode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n@@ -3872,7 +3872,7 @@ return \\\"srl %1,0,%0\\\";\n \t\t\t\t   gen_rtx_MINUS (DImode, operands[1],\n \t\t\t\t\t\t  operands[2])),\n \t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_raw_REG (SImode, SPARC_ICC_REG)))));\n+\t\t\t\t   gen_rtx_REG (SImode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n@@ -4948,7 +4948,7 @@ return \\\"srl %1,0,%0\\\";\n \t\t\t  gen_rtx_SET (VOIDmode, operand0,\n \t\t\t\t   gen_rtx_NEG (DImode, operand1)),\n \t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_raw_REG (SImode, SPARC_ICC_REG)))));\n+\t\t\t\t   gen_rtx_REG (SImode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n@@ -5628,15 +5628,15 @@ if (! TARGET_ARCH64)\n \t\t\t\t\tXEXP (operands[0], 0)),\n \t\t\t       GEN_INT (INTVAL (operands[3]) & 0xfff),\n \t\t\t       gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\tgen_rtx_raw_REG (Pmode, 15)))));\n+\t\t\t\t\tgen_rtx_REG (Pmode, 15)))));\n       else\n \temit_jump_insn\n \t  (gen_rtx_PARALLEL (VOIDmode,\n \t\t    gen_rtvec (2,\n \t\t\t       gen_rtx_SET (VOIDmode, pc_rtx,\n \t\t\t\t\tXEXP (operands[0], 0)),\n \t\t\t       gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\tgen_rtx_raw_REG (Pmode, 15)))));\n+\t\t\t\t\tgen_rtx_REG (Pmode, 15)))));\n       goto finish_call;\n     }\n \n@@ -5660,13 +5660,13 @@ if (! TARGET_ARCH64)\n \t\tgen_rtvec (3, gen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx),\n \t\t\t   GEN_INT (INTVAL (operands[3]) & 0xfff),\n \t\t\t   gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t    gen_rtx_raw_REG (Pmode, 15)))));\n+\t\t\t\t    gen_rtx_REG (Pmode, 15)))));\n   else\n     emit_call_insn\n       (gen_rtx_PARALLEL (VOIDmode,\n \t\tgen_rtvec (2, gen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx),\n \t\t\t   gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t    gen_rtx_raw_REG (Pmode, 15)))));\n+\t\t\t\t    gen_rtx_REG (Pmode, 15)))));\n \n  finish_call:\n #if 0\n@@ -5799,7 +5799,7 @@ if (! TARGET_ARCH64)\n   vec = gen_rtvec (2,\n \t\t   gen_rtx_SET (VOIDmode, operands[0],\n \t\t\t    gen_rtx_CALL (VOIDmode, fn_rtx, nregs_rtx)),\n-\t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_raw_REG (Pmode, 15)));\n+\t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)));\n \n   emit_call_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n \n@@ -5891,13 +5891,13 @@ if (! TARGET_ARCH64)\n   \"\"\n   \"\n {\n-  rtx valreg1 = gen_rtx_raw_REG (DImode, 24);\n-  rtx valreg2 = gen_rtx_raw_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);\n+  rtx valreg1 = gen_rtx_REG (DImode, 24);\n+  rtx valreg2 = gen_rtx_REG (TARGET_ARCH64 ? TFmode : DFmode, 32);\n   rtx result = operands[0];\n \n   if (! TARGET_ARCH64)\n     {\n-      rtx rtnreg = gen_rtx_raw_REG (SImode, (leaf_function ? 15 : 31));\n+      rtx rtnreg = gen_rtx_REG (SImode, (leaf_function ? 15 : 31));\n       rtx value = gen_reg_rtx (SImode);\n \n       /* Fetch the instruction where we will return to and see if it's an unimp\n@@ -5999,7 +5999,7 @@ if (! TARGET_ARCH64)\n \n   /* Find the containing function's current nonlocal goto handler,\n      which will do any cleanups and then jump to the label.  */\n-  labreg = gen_rtx_raw_REG (Pmode, 8);\n+  labreg = gen_rtx_REG (Pmode, 8);\n   emit_move_insn (labreg, lab);\n \n   /* Restore %fp from stack pointer value for containing function."}]}