{"sha": "f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk4Y2ZkM2M0MmQxYWNhMjI0YmZlNDYzZjU4NTJkMWFlMWU1YmQyZQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T22:01:46Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T22:01:46Z"}, "message": "trans.h (struct gfc_ss, [...]): Move field expr from the former struct to the latter.\n\n\t* trans.h (struct gfc_ss, struct gfc_ss_info): Move field expr from\n\tthe former struct to the latter.\n\t* trans-array.c\n\t(gfc_get_array_ss, gfc_get_scalar_ss,\n\tgfc_trans_constant_array_constructor, gfc_trans_array_constructor,\n\tgfc_add_loop_ss_code, gfc_conv_ss_descriptor,\n\tgfc_trans_array_bound_check, gfc_conv_array_index_offset,\n\tgfc_conv_scalarized_array_ref, gfc_conv_ss_startstride,\n\tgfc_could_be_alias, gfc_conv_resolve_dependencies,\n\tgfc_conv_loop_setup, gfc_conv_expr_descriptor,\n\tgfc_alloc_allocatable_for_assignment): Update references to expr and\n\tfactor common reference chains where possible.\n\t* trans-const.c (gfc_conv_constant): Ditto.\n\t* trans-expr.c (gfc_conv_variable, gfc_conv_procedure_call,\n\tgfc_conv_array_constructor_expr, gfc_conv_expr,\n\tgfc_conv_expr_reference): Ditto.\n\t* trans-intrinsic.c (trans_this_image, gfc_conv_intrinsic_bound,\n\tgfc_conv_intrinsic_cobound, gfc_conv_intrinsic_funcall,\n\tgfc_add_intrinsic_ss_code): Ditto.\n\t* trans-stmt.c (gfc_conv_elemental_dependencies): Ditto.\n\nFrom-SVN: r180868", "tree": {"sha": "96892ec4c807893a7f05a894d6de0ca185078393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96892ec4c807893a7f05a894d6de0ca185078393"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/comments", "author": null, "committer": null, "parents": [{"sha": "bcc4d4e089f5371278a50f8c8827f00a2523854d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc4d4e089f5371278a50f8c8827f00a2523854d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc4d4e089f5371278a50f8c8827f00a2523854d"}], "stats": {"total": 269, "additions": 167, "deletions": 102}, "files": [{"sha": "c16bc6d690d6b3fcd6ffa78efb110104b36c7e2f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "patch": "@@ -1,3 +1,26 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans.h (struct gfc_ss, struct gfc_ss_info): Move field expr from\n+\tthe former struct to the latter.\n+\t* trans-array.c\n+\t(gfc_get_array_ss, gfc_get_scalar_ss,\n+\tgfc_trans_constant_array_constructor, gfc_trans_array_constructor,\n+\tgfc_add_loop_ss_code, gfc_conv_ss_descriptor,\n+\tgfc_trans_array_bound_check, gfc_conv_array_index_offset,\n+\tgfc_conv_scalarized_array_ref, gfc_conv_ss_startstride,\n+\tgfc_could_be_alias, gfc_conv_resolve_dependencies,\n+\tgfc_conv_loop_setup, gfc_conv_expr_descriptor,\n+\tgfc_alloc_allocatable_for_assignment): Update references to expr and\n+\tfactor common reference chains where possible.\n+\t* trans-const.c (gfc_conv_constant): Ditto.\n+\t* trans-expr.c (gfc_conv_variable, gfc_conv_procedure_call,\n+\tgfc_conv_array_constructor_expr, gfc_conv_expr,\n+\tgfc_conv_expr_reference): Ditto.\n+\t* trans-intrinsic.c (trans_this_image, gfc_conv_intrinsic_bound,\n+\tgfc_conv_intrinsic_cobound, gfc_conv_intrinsic_funcall,\n+\tgfc_add_intrinsic_ss_code): Ditto.\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies): Ditto.\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans.h (struct gfc_ss_info): New struct."}, {"sha": "65f7aded2d6904702a617f2fede2acbfb45080d0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 120, "deletions": 83, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "patch": "@@ -533,11 +533,11 @@ gfc_get_array_ss (gfc_ss *next, gfc_expr *expr, int dimen, gfc_ss_type type)\n \n   ss_info = gfc_get_ss_info ();\n   ss_info->type = type;\n+  ss_info->expr = expr;\n \n   ss = gfc_get_ss ();\n   ss->info = ss_info;\n   ss->next = next;\n-  ss->expr = expr;\n   ss->dimen = dimen;\n   for (i = 0; i < ss->dimen; i++)\n     ss->dim[i] = i;\n@@ -581,11 +581,11 @@ gfc_get_scalar_ss (gfc_ss *next, gfc_expr *expr)\n \n   ss_info = gfc_get_ss_info ();\n   ss_info->type = GFC_SS_SCALAR;\n+  ss_info->expr = expr;\n \n   ss = gfc_get_ss ();\n   ss->info = ss_info;\n   ss->next = next;\n-  ss->expr = expr;\n \n   return ss;\n }\n@@ -1882,7 +1882,7 @@ trans_constant_array_constructor (gfc_ss * ss, tree type)\n   tree tmp;\n   int i;\n \n-  tmp = gfc_build_constant_array_constructor (ss->expr, type);\n+  tmp = gfc_build_constant_array_constructor (ss->info->expr, type);\n \n   info = &ss->data.info;\n \n@@ -1953,42 +1953,45 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n   bool dynamic;\n   bool old_first_len, old_typespec_chararray_ctor;\n   tree old_first_len_val;\n+  gfc_expr *expr;\n \n   /* Save the old values for nested checking.  */\n   old_first_len = first_len;\n   old_first_len_val = first_len_val;\n   old_typespec_chararray_ctor = typespec_chararray_ctor;\n \n+  expr = ss->info->expr;\n+\n   /* Do bounds-checking here and in gfc_trans_array_ctor_element only if no\n      typespec was given for the array constructor.  */\n-  typespec_chararray_ctor = (ss->expr->ts.u.cl\n-\t\t\t     && ss->expr->ts.u.cl->length_from_typespec);\n+  typespec_chararray_ctor = (expr->ts.u.cl\n+\t\t\t     && expr->ts.u.cl->length_from_typespec);\n \n   if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n-      && ss->expr->ts.type == BT_CHARACTER && !typespec_chararray_ctor)\n+      && expr->ts.type == BT_CHARACTER && !typespec_chararray_ctor)\n     {  \n       first_len_val = gfc_create_var (gfc_charlen_type_node, \"len\");\n       first_len = true;\n     }\n \n   gcc_assert (ss->dimen == loop->dimen);\n \n-  c = ss->expr->value.constructor;\n-  if (ss->expr->ts.type == BT_CHARACTER)\n+  c = expr->value.constructor;\n+  if (expr->ts.type == BT_CHARACTER)\n     {\n       bool const_string;\n       \n       /* get_array_ctor_strlen walks the elements of the constructor, if a\n \t typespec was given, we already know the string length and want the one\n \t specified there.  */\n-      if (typespec_chararray_ctor && ss->expr->ts.u.cl->length\n-\t  && ss->expr->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n+      if (typespec_chararray_ctor && expr->ts.u.cl->length\n+\t  && expr->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n \t{\n \t  gfc_se length_se;\n \n \t  const_string = false;\n \t  gfc_init_se (&length_se, NULL);\n-\t  gfc_conv_expr_type (&length_se, ss->expr->ts.u.cl->length,\n+\t  gfc_conv_expr_type (&length_se, expr->ts.u.cl->length,\n \t\t\t      gfc_charlen_type_node);\n \t  ss->string_length = length_se.expr;\n \t  gfc_add_block_to_block (&loop->pre, &length_se.pre);\n@@ -2002,26 +2005,26 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss, locus * where)\n \t and not end up here.  */\n       gcc_assert (ss->string_length);\n \n-      ss->expr->ts.u.cl->backend_decl = ss->string_length;\n+      expr->ts.u.cl->backend_decl = ss->string_length;\n \n-      type = gfc_get_character_type_len (ss->expr->ts.kind, ss->string_length);\n+      type = gfc_get_character_type_len (expr->ts.kind, ss->string_length);\n       if (const_string)\n \ttype = build_pointer_type (type);\n     }\n   else\n-    type = gfc_typenode_for_spec (&ss->expr->ts);\n+    type = gfc_typenode_for_spec (&expr->ts);\n \n   /* See if the constructor determines the loop bounds.  */\n   dynamic = false;\n \n-  if (ss->expr->shape && loop->dimen > 1 && loop->to[0] == NULL_TREE)\n+  if (expr->shape && loop->dimen > 1 && loop->to[0] == NULL_TREE)\n     {\n       /* We have a multidimensional parameter.  */\n       int n;\n-      for (n = 0; n < ss->expr->rank; n++)\n+      for (n = 0; n < expr->rank; n++)\n       {\n \tloop->from[n] = gfc_index_zero_node;\n-\tloop->to[n] = gfc_conv_mpz_to_tree (ss->expr->shape [n],\n+\tloop->to[n] = gfc_conv_mpz_to_tree (expr->shape [n],\n \t\t\t\t\t    gfc_index_integer_kind);\n \tloop->to[n] = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t  \t       gfc_array_index_type,\n@@ -2166,6 +2169,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t\t      locus * where)\n {\n   gfc_se se;\n+  gfc_ss_info *ss_info;\n+  gfc_expr *expr;\n   int n;\n \n   /* TODO: This can generate bad code if there are ordering dependencies,\n@@ -2176,16 +2181,19 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n     {\n       gcc_assert (ss);\n \n-      switch (ss->info->type)\n+      ss_info = ss->info;\n+      expr = ss_info->expr;\n+\n+      switch (ss_info->type)\n \t{\n \tcase GFC_SS_SCALAR:\n \t  /* Scalar expression.  Evaluate this now.  This includes elemental\n \t     dimension indices, but not array section bounds.  */\n \t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr (&se, ss->expr);\n+\t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&loop->pre, &se.pre);\n \n-\t  if (ss->expr->ts.type != BT_CHARACTER)\n+\t  if (expr->ts.type != BT_CHARACTER)\n \t    {\n \t      /* Move the evaluation of scalar expressions outside the\n \t\t scalarization loop, except for WHERE assignments.  */\n@@ -2206,7 +2214,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  /* Scalar argument to elemental procedure.  Evaluate this\n \t     now.  */\n \t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr (&se, ss->expr);\n+\t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&loop->post, &se.post);\n \n@@ -2227,7 +2235,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \tcase GFC_SS_VECTOR:\n \t  /* Get the vector's descriptor and store it in SS.  */\n \t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr_descriptor (&se, ss->expr, gfc_walk_expr (ss->expr));\n+\t  gfc_conv_expr_descriptor (&se, expr, gfc_walk_expr (expr));\n \t  gfc_add_block_to_block (&loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&loop->post, &se.post);\n \t  ss->data.info.descriptor = se.expr;\n@@ -2243,20 +2251,20 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \t  gfc_init_se (&se, NULL);\n \t  se.loop = loop;\n \t  se.ss = ss;\n-\t  gfc_conv_expr (&se, ss->expr);\n+\t  gfc_conv_expr (&se, expr);\n \t  gfc_add_block_to_block (&loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&loop->post, &se.post);\n \t  ss->string_length = se.string_length;\n \t  break;\n \n \tcase GFC_SS_CONSTRUCTOR:\n-\t  if (ss->expr->ts.type == BT_CHARACTER\n-\t\t&& ss->string_length == NULL\n-\t\t&& ss->expr->ts.u.cl\n-\t\t&& ss->expr->ts.u.cl->length)\n+\t  if (expr->ts.type == BT_CHARACTER\n+\t      && ss->string_length == NULL\n+\t      && expr->ts.u.cl\n+\t      && expr->ts.u.cl->length)\n \t    {\n \t      gfc_init_se (&se, NULL);\n-\t      gfc_conv_expr_type (&se, ss->expr->ts.u.cl->length,\n+\t      gfc_conv_expr_type (&se, expr->ts.u.cl->length,\n \t\t\t\t  gfc_charlen_type_node);\n \t      ss->string_length = se.expr;\n \t      gfc_add_block_to_block (&loop->pre, &se.pre);\n@@ -2284,13 +2292,16 @@ static void\n gfc_conv_ss_descriptor (stmtblock_t * block, gfc_ss * ss, int base)\n {\n   gfc_se se;\n+  gfc_ss_info *ss_info;\n   tree tmp;\n \n+  ss_info = ss->info;\n+\n   /* Get the descriptor for the array to be scalarized.  */\n-  gcc_assert (ss->expr->expr_type == EXPR_VARIABLE);\n+  gcc_assert (ss_info->expr->expr_type == EXPR_VARIABLE);\n   gfc_init_se (&se, NULL);\n   se.descriptor_only = 1;\n-  gfc_conv_expr_lhs (&se, ss->expr);\n+  gfc_conv_expr_lhs (&se, ss_info->expr);\n   gfc_add_block_to_block (block, &se.pre);\n   ss->data.info.descriptor = se.expr;\n   ss->string_length = se.string_length;\n@@ -2473,7 +2484,7 @@ trans_array_bound_check (gfc_se * se, gfc_ss *ss, tree index, int n,\n   index = gfc_evaluate_now (index, &se->pre);\n \n   /* We find a name for the error message.  */\n-  name = ss->expr->symtree->n.sym->name;\n+  name = ss->info->expr->symtree->n.sym->name;\n   gcc_assert (name != NULL);\n \n   if (TREE_CODE (descriptor) == VAR_DECL)\n@@ -2624,10 +2635,10 @@ conv_array_index_offset (gfc_se * se, gfc_ss * ss, int dim, int i,\n \t Use the stride returned by the function call and stored in\n \t the descriptor for the temporary.  */ \n       if (se->ss && se->ss->info->type == GFC_SS_FUNCTION\n-\t    && se->ss->expr\n-\t    && se->ss->expr->symtree\n-\t    && se->ss->expr->symtree->n.sym->result\n-\t    && se->ss->expr->symtree->n.sym->result->attr.pointer)\n+\t  && se->ss->info->expr\n+\t  && se->ss->info->expr->symtree\n+\t  && se->ss->info->expr->symtree->n.sym->result\n+\t  && se->ss->info->expr->symtree->n.sym->result->attr.pointer)\n \tstride = gfc_conv_descriptor_stride_get (info->descriptor,\n \t\t\t\t\t\t gfc_rank_cst[dim]);\n \n@@ -2655,9 +2666,11 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n   tree index;\n   tree tmp;\n   gfc_ss *ss;\n+  gfc_expr *expr;\n   int n;\n \n   ss = se->ss;\n+  expr = ss->info->expr;\n   info = &ss->data.info;\n   if (ar)\n     n = se->loop->order[0];\n@@ -2671,11 +2684,10 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n     index = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n \t\t\t     index, info->offset);\n \n-  if (se->ss->expr && is_subref_array (se->ss->expr))\n-    decl = se->ss->expr->symtree->n.sym->backend_decl;\n+  if (expr && is_subref_array (expr))\n+    decl = expr->symtree->n.sym->backend_decl;\n \n-  tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t info->data);\n+  tmp = build_fold_indirect_ref_loc (input_location, info->data);\n   se->expr = gfc_build_array_ref (tmp, index, decl);\n }\n \n@@ -3305,7 +3317,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \n \t/* As usual, lbound and ubound are exceptions!.  */\n \tcase GFC_SS_INTRINSIC:\n-\t  switch (ss->expr->value.function.isym->id)\n+\t  switch (ss->info->expr->value.function.isym->id)\n \t    {\n \t    case GFC_ISYM_LBOUND:\n \t    case GFC_ISYM_UBOUND:\n@@ -3332,14 +3344,18 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n   /* Loop over all the SS in the chain.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n+      gfc_ss_info *ss_info;\n       gfc_array_info *info;\n+      gfc_expr *expr;\n \n+      ss_info = ss->info;\n+      expr = ss_info->expr;\n       info = &ss->data.info;\n \n-      if (ss->expr && ss->expr->shape && !info->shape)\n-\tinfo->shape = ss->expr->shape;\n+      if (expr && expr->shape && !info->shape)\n+\tinfo->shape = expr->shape;\n \n-      switch (ss->info->type)\n+      switch (ss_info->type)\n \t{\n \tcase GFC_SS_SECTION:\n \t  /* Get the descriptor for the array.  */\n@@ -3350,7 +3366,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  break;\n \n \tcase GFC_SS_INTRINSIC:\n-\t  switch (ss->expr->value.function.isym->id)\n+\t  switch (expr->value.function.isym->id)\n \t    {\n \t    /* Fall through to supply start and stride.  */\n \t    case GFC_ISYM_LBOUND:\n@@ -3401,14 +3417,23 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n       for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n \t{\n \t  stmtblock_t inner;\n+\t  gfc_ss_info *ss_info;\n+\t  gfc_expr *expr;\n+\t  locus *expr_loc;\n+\t  const char *expr_name;\n \n-\t  if (ss->info->type != GFC_SS_SECTION)\n+\t  ss_info = ss->info;\n+\t  if (ss_info->type != GFC_SS_SECTION)\n \t    continue;\n \n \t  /* Catch allocatable lhs in f2003.  */\n \t  if (gfc_option.flag_realloc_lhs && ss->is_alloc_lhs)\n \t    continue;\n \n+\t  expr = ss_info->expr;\n+\t  expr_loc = &expr->where;\n+\t  expr_name = expr->symtree->name;\n+\n \t  gfc_start_block (&inner);\n \n \t  /* TODO: range checking for mapped dimensions.  */\n@@ -3434,9 +3459,9 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n \t\t\t\t     info->stride[dim], gfc_index_zero_node);\n \t      asprintf (&msg, \"Zero stride is not allowed, for dimension %d \"\n-\t\t\t\"of array '%s'\", dim + 1, ss->expr->symtree->name);\n+\t\t\t\"of array '%s'\", dim + 1, expr_name);\n \t      gfc_trans_runtime_check (true, false, tmp, &inner,\n-\t\t\t\t       &ss->expr->where, msg);\n+\t\t\t\t       expr_loc, msg);\n \t      free (msg);\n \n \t      desc = ss->data.info.descriptor;\n@@ -3493,14 +3518,14 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t\t\t\t  non_zerosized, tmp2);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t    \"outside of expected range (%%ld:%%ld)\",\n-\t\t\t    dim + 1, ss->expr->symtree->name);\n+\t\t\t    dim + 1, expr_name);\n \t\t  gfc_trans_runtime_check (true, false, tmp, &inner,\n-\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t\t\t\t   expr_loc, msg,\n \t\t     fold_convert (long_integer_type_node, info->start[dim]),\n \t\t     fold_convert (long_integer_type_node, lbound),\n \t\t     fold_convert (long_integer_type_node, ubound));\n \t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n-\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t\t\t\t   expr_loc, msg,\n \t\t     fold_convert (long_integer_type_node, info->start[dim]),\n \t\t     fold_convert (long_integer_type_node, lbound),\n \t\t     fold_convert (long_integer_type_node, ubound));\n@@ -3515,9 +3540,9 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t\t\t\t boolean_type_node, non_zerosized, tmp);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t    \"below lower bound of %%ld\",\n-\t\t\t    dim + 1, ss->expr->symtree->name);\n+\t\t\t    dim + 1, expr_name);\n \t\t  gfc_trans_runtime_check (true, false, tmp, &inner,\n-\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t\t\t\t   expr_loc, msg,\n \t\t     fold_convert (long_integer_type_node, info->start[dim]),\n \t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  free (msg);\n@@ -3547,14 +3572,14 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t\t\t\t  boolean_type_node, non_zerosized, tmp3);\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t    \"outside of expected range (%%ld:%%ld)\",\n-\t\t\t    dim + 1, ss->expr->symtree->name);\n+\t\t\t    dim + 1, expr_name);\n \t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n-\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t\t\t\t   expr_loc, msg,\n \t\t     fold_convert (long_integer_type_node, tmp),\n \t\t     fold_convert (long_integer_type_node, ubound), \n \t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  gfc_trans_runtime_check (true, false, tmp3, &inner,\n-\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t\t\t\t   expr_loc, msg,\n \t\t     fold_convert (long_integer_type_node, tmp),\n \t\t     fold_convert (long_integer_type_node, ubound), \n \t\t     fold_convert (long_integer_type_node, lbound));\n@@ -3564,9 +3589,9 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t{\n \t\t  asprintf (&msg, \"Index '%%ld' of dimension %d of array '%s' \"\n \t\t\t    \"below lower bound of %%ld\",\n-\t\t\t    dim + 1, ss->expr->symtree->name);\n+\t\t\t    dim + 1, expr_name);\n \t\t  gfc_trans_runtime_check (true, false, tmp2, &inner,\n-\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t\t\t\t   expr_loc, msg,\n \t\t     fold_convert (long_integer_type_node, tmp),\n \t\t     fold_convert (long_integer_type_node, lbound));\n \t\t  free (msg);\n@@ -3593,10 +3618,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t\t\t\t  boolean_type_node, tmp, size[n]);\n \t\t  asprintf (&msg, \"Array bound mismatch for dimension %d \"\n \t\t\t    \"of array '%s' (%%ld/%%ld)\",\n-\t\t\t    dim + 1, ss->expr->symtree->name);\n+\t\t\t    dim + 1, expr_name);\n \n \t\t  gfc_trans_runtime_check (true, false, tmp3, &inner,\n-\t\t\t\t\t   &ss->expr->where, msg,\n+\t\t\t\t\t   expr_loc, msg,\n \t\t\tfold_convert (long_integer_type_node, tmp),\n \t\t\tfold_convert (long_integer_type_node, size[n]));\n \n@@ -3610,10 +3635,10 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \n \t  /* For optional arguments, only check bounds if the argument is\n \t     present.  */\n-\t  if (ss->expr->symtree->n.sym->attr.optional\n-\t      || ss->expr->symtree->n.sym->attr.not_always_present)\n+\t  if (expr->symtree->n.sym->attr.optional\n+\t      || expr->symtree->n.sym->attr.not_always_present)\n \t    tmp = build3_v (COND_EXPR,\n-\t\t\t    gfc_conv_expr_present (ss->expr->symtree->n.sym),\n+\t\t\t    gfc_conv_expr_present (expr->symtree->n.sym),\n \t\t\t    tmp, build_empty_stmt (input_location));\n \n \t  gfc_add_expr_to_block (&block, tmp);\n@@ -3666,12 +3691,16 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n {\n   gfc_ref *lref;\n   gfc_ref *rref;\n+  gfc_expr *lexpr, *rexpr;\n   gfc_symbol *lsym;\n   gfc_symbol *rsym;\n   bool lsym_pointer, lsym_target, rsym_pointer, rsym_target;\n \n-  lsym = lss->expr->symtree->n.sym;\n-  rsym = rss->expr->symtree->n.sym;\n+  lexpr = lss->info->expr;\n+  rexpr = rss->info->expr;\n+\n+  lsym = lexpr->symtree->n.sym;\n+  rsym = rexpr->symtree->n.sym;\n \n   lsym_pointer = lsym->attr.pointer;\n   lsym_target = lsym->attr.target;\n@@ -3689,7 +3718,7 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n   /* For derived types we must check all the component types.  We can ignore\n      array references as these will have the same base type as the previous\n      component ref.  */\n-  for (lref = lss->expr->ref; lref != lss->data.info.ref; lref = lref->next)\n+  for (lref = lexpr->ref; lref != lss->data.info.ref; lref = lref->next)\n     {\n       if (lref->type != REF_COMPONENT)\n \tcontinue;\n@@ -3709,7 +3738,7 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n \t    return 1;\n \t}\n \n-      for (rref = rss->expr->ref; rref != rss->data.info.ref;\n+      for (rref = rexpr->ref; rref != rss->data.info.ref;\n \t   rref = rref->next)\n \t{\n \t  if (rref->type != REF_COMPONENT)\n@@ -3744,7 +3773,7 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n   lsym_pointer = lsym->attr.pointer;\n   lsym_target = lsym->attr.target;\n \n-  for (rref = rss->expr->ref; rref != rss->data.info.ref; rref = rref->next)\n+  for (rref = rexpr->ref; rref != rss->data.info.ref; rref = rref->next)\n     {\n       if (rref->type != REF_COMPONENT)\n \tbreak;\n@@ -3780,29 +3809,34 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n   gfc_ss *ss;\n   gfc_ref *lref;\n   gfc_ref *rref;\n+  gfc_expr *dest_expr;\n+  gfc_expr *ss_expr;\n   int nDepend = 0;\n   int i, j;\n \n   loop->temp_ss = NULL;\n+  dest_expr = dest->info->expr;\n \n   for (ss = rss; ss != gfc_ss_terminator; ss = ss->next)\n     {\n       if (ss->info->type != GFC_SS_SECTION)\n \tcontinue;\n \n-      if (dest->expr->symtree->n.sym != ss->expr->symtree->n.sym)\n+      ss_expr = ss->info->expr;\n+\n+      if (dest_expr->symtree->n.sym != ss_expr->symtree->n.sym)\n \t{\n \t  if (gfc_could_be_alias (dest, ss)\n-\t\t|| gfc_are_equivalenced_arrays (dest->expr, ss->expr))\n+\t      || gfc_are_equivalenced_arrays (dest_expr, ss_expr))\n \t    {\n \t      nDepend = 1;\n \t      break;\n \t    }\n \t}\n       else\n \t{\n-\t  lref = dest->expr->ref;\n-\t  rref = ss->expr->ref;\n+\t  lref = dest_expr->ref;\n+\t  rref = ss_expr->ref;\n \n \t  nDepend = gfc_dep_resolver (lref, rref, &loop->reverse[0]);\n \n@@ -3861,7 +3895,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n \n   if (nDepend == 1)\n     {\n-      tree base_type = gfc_typenode_for_spec (&dest->expr->ts);\n+      tree base_type = gfc_typenode_for_spec (&dest_expr->ts);\n       if (GFC_ARRAY_TYPE_P (base_type)\n \t  || GFC_DESCRIPTOR_TYPE_P (base_type))\n \tbase_type = gfc_get_element_type (base_type);\n@@ -3949,7 +3983,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop, locus * where)\n \t\t can be determined at compile time.  Prefer not to otherwise,\n \t\t since the general case involves realloc, and it's better to\n \t\t avoid that overhead if possible.  */\n-\t      base = ss->expr->value.constructor;\n+\t      base = ss->info->expr->value.constructor;\n \t      dynamic[n] = gfc_get_array_constructor_size (&i, base);\n \t      if (!dynamic[n] || !loopspec[n])\n \t\tloopspec[n] = ss;\n@@ -5739,6 +5773,7 @@ void\n gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n {\n   gfc_ss_type ss_type;\n+  gfc_ss_info *ss_info;\n   gfc_loopinfo loop;\n   gfc_array_info *info;\n   int need_tmp;\n@@ -5750,12 +5785,14 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   tree offset;\n   int full;\n   bool subref_array_target = false;\n-  gfc_expr *arg;\n+  gfc_expr *arg, *ss_expr;\n \n   gcc_assert (ss != NULL);\n   gcc_assert (ss != gfc_ss_terminator);\n \n-  ss_type = ss->info->type;\n+  ss_info = ss->info;\n+  ss_type = ss_info->type;\n+  ss_expr = ss_info->expr;\n \n   /* Special case things we know we can pass easily.  */\n   switch (expr->expr_type)\n@@ -5765,7 +5802,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t Otherwise we need to copy it into a temporary.  */\n \n       gcc_assert (ss_type == GFC_SS_SECTION);\n-      gcc_assert (ss->expr == expr);\n+      gcc_assert (ss_expr == expr);\n       info = &ss->data.info;\n \n       /* Get the descriptor for the array.  */\n@@ -5843,7 +5880,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n       if (se->direct_byref)\n \t{\n-\t  gcc_assert (ss_type == GFC_SS_FUNCTION && ss->expr == expr);\n+\t  gcc_assert (ss_type == GFC_SS_FUNCTION && ss_expr == expr);\n \n \t  /* For pointer assignments pass the descriptor directly.  */\n \t  if (se->ss == NULL)\n@@ -5855,9 +5892,9 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  return;\n \t}\n \n-      if (ss->expr != expr || ss_type != GFC_SS_FUNCTION)\n+      if (ss_expr != expr || ss_type != GFC_SS_FUNCTION)\n \t{\n-\t  if (ss->expr != expr)\n+\t  if (ss_expr != expr)\n \t    /* Elemental function.  */\n \t    gcc_assert ((expr->value.function.esym != NULL\n \t\t\t && expr->value.function.esym->attr.elemental)\n@@ -7211,11 +7248,11 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       /* Find the ss for the lhs.  */\n       lss = loop->ss;\n       for (; lss && lss != gfc_ss_terminator; lss = lss->loop_chain)\n-\tif (lss->expr && lss->expr->expr_type == EXPR_VARIABLE)\n+\tif (lss->info->expr && lss->info->expr->expr_type == EXPR_VARIABLE)\n \t  break;\n       if (lss == gfc_ss_terminator)\n \treturn NULL_TREE;\n-      expr1 = lss->expr;\n+      expr1 = lss->info->expr;\n     }\n \n   /* Bail out if this is not a valid allocate on assignment.  */\n@@ -7226,7 +7263,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   /* Find the ss for the lhs.  */\n   lss = loop->ss;\n   for (; lss && lss != gfc_ss_terminator; lss = lss->loop_chain)\n-    if (lss->expr == expr1)\n+    if (lss->info->expr == expr1)\n       break;\n \n   if (lss == gfc_ss_terminator)\n@@ -7236,7 +7273,7 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n      ss's for the operands. Any one of these will do.  */\n   rss = loop->ss;\n   for (; rss && rss != gfc_ss_terminator; rss = rss->loop_chain)\n-    if (rss->expr != expr1 && rss != loop->temp_ss)\n+    if (rss->info->expr != expr1 && rss != loop->temp_ss)\n       break;\n \n   if (expr2 && rss == gfc_ss_terminator)"}, {"sha": "0cf27190d95f217f708691c7d2e41bbb3a4854b3", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "patch": "@@ -385,9 +385,12 @@ gfc_conv_constant (gfc_se * se, gfc_expr * expr)\n   ss = se->ss;\n   if (ss != NULL)\n     {\n+      gfc_ss_info *ss_info;\n+\n+      ss_info = ss->info;\n       gcc_assert (ss != gfc_ss_terminator);\n-      gcc_assert (ss->info->type == GFC_SS_SCALAR);\n-      gcc_assert (se->ss->expr == expr);\n+      gcc_assert (ss_info->type == GFC_SS_SCALAR);\n+      gcc_assert (ss_info->expr == expr);\n \n       se->expr = se->ss->data.scalar.expr;\n       se->string_length = se->ss->string_length;"}, {"sha": "2e620adc787e91cce0503b4ace1b3a5492217f8a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "patch": "@@ -613,6 +613,7 @@ conv_parent_component_references (gfc_se * se, gfc_ref * ref)\n static void\n gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n {\n+  gfc_ss *ss;\n   gfc_ref *ref;\n   gfc_symbol *sym;\n   tree parent_decl = NULL_TREE;\n@@ -622,11 +623,12 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n   bool entry_master;\n \n   sym = expr->symtree->n.sym;\n-  if (se->ss != NULL)\n+  ss = se->ss;\n+  if (ss != NULL)\n     {\n       /* Check that something hasn't gone horribly wrong.  */\n-      gcc_assert (se->ss != gfc_ss_terminator);\n-      gcc_assert (se->ss->expr == expr);\n+      gcc_assert (ss != gfc_ss_terminator);\n+      gcc_assert (ss->info->expr == expr);\n \n       /* A scalarized term.  We already know the descriptor.  */\n       se->expr = se->ss->data.info.descriptor;\n@@ -3604,8 +3606,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  callee_alloc = comp->attr.allocatable || comp->attr.pointer;\n \t  gfc_trans_create_temp_array (&se->pre, &se->post, se->loop, se->ss,\n \t\t\t\t       tmp, NULL_TREE, false,\n-\t\t\t\t       !comp->attr.pointer,\n-\t\t\t\t       callee_alloc, &se->ss->expr->where);\n+\t\t\t\t       !comp->attr.pointer, callee_alloc,\n+\t\t\t\t       &se->ss->info->expr->where);\n \n \t  /* Pass the temporary as the first argument.  */\n \t  result = info->descriptor;\n@@ -3640,8 +3642,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  callee_alloc = sym->attr.allocatable || sym->attr.pointer;\n \t  gfc_trans_create_temp_array (&se->pre, &se->post, se->loop, se->ss,\n \t\t\t\t       tmp, NULL_TREE, false,\n-\t\t\t\t       !sym->attr.pointer,\n-\t\t\t\t       callee_alloc, &se->ss->expr->where);\n+\t\t\t\t       !sym->attr.pointer, callee_alloc,\n+\t\t\t\t       &se->ss->info->expr->where);\n \n \t  /* Pass the temporary as the first argument.  */\n \t  result = info->descriptor;\n@@ -4243,7 +4245,7 @@ gfc_conv_array_constructor_expr (gfc_se * se, gfc_expr * expr)\n \n   ss = se->ss;\n   gcc_assert (ss != NULL && ss != gfc_ss_terminator);\n-  gcc_assert (ss->expr == expr && ss->info->type == GFC_SS_CONSTRUCTOR);\n+  gcc_assert (ss->info->expr == expr && ss->info->type == GFC_SS_CONSTRUCTOR);\n \n   gfc_conv_tmp_array_ref (se);\n }\n@@ -4827,7 +4829,7 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n   gfc_ss *ss;\n \n   ss = se->ss;\n-  if (ss && ss->expr == expr\n+  if (ss && ss->info->expr == expr\n       && (ss->info->type == GFC_SS_SCALAR\n \t  || ss->info->type == GFC_SS_REFERENCE))\n     {\n@@ -4957,7 +4959,7 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n   tree var;\n \n   ss = se->ss;\n-  if (ss && ss->expr == expr\n+  if (ss && ss->info->expr == expr\n       && ss->info->type == GFC_SS_REFERENCE)\n     {\n       /* Returns a reference to the scalar evaluated outside the loop"}, {"sha": "ef9360b2fbae6c730d454f37e777ff8f9ec1735d", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "patch": "@@ -1004,7 +1004,7 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n       gcc_assert (!expr->value.function.actual->next->expr);\n       gcc_assert (corank > 0);\n       gcc_assert (se->loop->dimen == 1);\n-      gcc_assert (se->ss->expr == expr);\n+      gcc_assert (se->ss->info->expr == expr);\n \n       dim_arg = se->loop->loopvar[0];\n       dim_arg = fold_build2_loc (input_location, PLUS_EXPR,\n@@ -1321,7 +1321,7 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       /* Create an implicit second parameter from the loop variable.  */\n       gcc_assert (!arg2->expr);\n       gcc_assert (se->loop->dimen == 1);\n-      gcc_assert (se->ss->expr == expr);\n+      gcc_assert (se->ss->info->expr == expr);\n       gfc_advance_se_ss_chain (se);\n       bound = se->loop->loopvar[0];\n       bound = fold_build2_loc (input_location, MINUS_EXPR,\n@@ -1515,7 +1515,7 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n       gcc_assert (!arg2->expr);\n       gcc_assert (corank > 0);\n       gcc_assert (se->loop->dimen == 1);\n-      gcc_assert (se->ss->expr == expr);\n+      gcc_assert (se->ss->info->expr == expr);\n \n       bound = se->loop->loopvar[0];\n       bound = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n@@ -2323,7 +2323,7 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n   gfc_symbol *sym;\n   VEC(tree,gc) *append_args;\n \n-  gcc_assert (!se->ss || se->ss->expr == expr);\n+  gcc_assert (!se->ss || se->ss->info->expr == expr);\n \n   if (se->ss)\n     gcc_assert (expr->rank > 0);\n@@ -6800,7 +6800,7 @@ walk_inline_intrinsic_function (gfc_ss * ss, gfc_expr * expr)\n void\n gfc_add_intrinsic_ss_code (gfc_loopinfo * loop ATTRIBUTE_UNUSED, gfc_ss * ss)\n {\n-  switch (ss->expr->value.function.isym->id)\n+  switch (ss->info->expr->value.function.isym->id)\n     {\n     case GFC_ISYM_UBOUND:\n     case GFC_ISYM_LBOUND:"}, {"sha": "936a4ee64f218b482903f1492f4effe3d7e615d7", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "patch": "@@ -220,7 +220,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n       info = NULL;\n       for (ss = loopse->ss; ss && ss != gfc_ss_terminator; ss = ss->next)\n \t{\n-\t  if (ss->expr != e)\n+\t  if (ss->info->expr != e)\n \t    continue;\n \t  info = &ss->data.info;\n \t  break;"}, {"sha": "592236016e6c0896d19e462ffc085736b26a2780", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=f98cfd3c42d1aca224bfe463f5852d1ae1e5bd2e", "patch": "@@ -186,6 +186,7 @@ gfc_ss_type;\n typedef struct gfc_ss_info\n {\n   gfc_ss_type type;\n+  gfc_expr *expr;\n }\n gfc_ss_info;\n \n@@ -204,7 +205,6 @@ typedef struct gfc_ss\n {\n   gfc_ss_info *info;\n \n-  gfc_expr *expr;\n   tree string_length;\n   union\n   {"}]}