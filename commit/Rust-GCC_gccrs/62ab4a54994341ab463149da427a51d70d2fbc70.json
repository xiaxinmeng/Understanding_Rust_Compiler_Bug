{"sha": "62ab4a54994341ab463149da427a51d70d2fbc70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJhYjRhNTQ5OTQzNDFhYjQ2MzE0OWRhNDI3YTUxZDcwZDJmYmM3MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2005-09-09T06:22:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-09-09T06:22:28Z"}, "message": "re PR fortran/21104 (Segmentation fault on correct code)\n\n\tPR fortran/21104\n\t* trans.h (gfc_interface_sym_mapping, gfc_interface_mapping): Moved\n\tfrom trans-expr.c.\n\t(gfc_init_interface_mapping, gfc_free_interface_mapping)\n\t(gfc_add_interface_mapping, gfc_finish_interface_mapping)\n\t(gfc_apply_interface_mapping): Declare.\n\t* trans-array.h (gfc_set_loop_bounds_from_array_spec): Declare.\n\t(gfc_trans_allocate_temp_array): Add pre and post block arguments.\n\t* trans-array.c (gfc_set_loop_bounds_from_array_spec): New function.\n\t(gfc_trans_allocate_array_storage): Replace loop argument with\n\tseparate pre and post blocks.\n\t(gfc_trans_allocate_temp_array): Add pre and post block arguments.\n\tUpdate call to gfc_trans_allocate_array_storage.\n\t(gfc_trans_array_constructor, gfc_conv_loop_setup): Adjust for new\n\tinterface to gfc_trans_allocate_temp_array.\n\t* trans-expr.c (gfc_interface_sym_mapping, gfc_interface_mapping):\n\tMoved to trans.h.\n\t(gfc_init_interface_mapping, gfc_free_interface_mapping)\n\t(gfc_add_interface_mapping, gfc_finish_interface_mapping)\n\t(gfc_apply_interface_mapping): Make extern.\n\t(gfc_conv_function_call): Build an interface mapping for array\n\treturn values too.  Call gfc_set_loop_bounds_from_array_spec.\n\tAdjust call to gfc_trans_allocate_temp_array so that code is\n\tadded to SE rather than LOOP.\n\nFrom-SVN: r104075", "tree": {"sha": "ca11fbf9511e837a2b37b79ebad342b1aacc05a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca11fbf9511e837a2b37b79ebad342b1aacc05a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62ab4a54994341ab463149da427a51d70d2fbc70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ab4a54994341ab463149da427a51d70d2fbc70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62ab4a54994341ab463149da427a51d70d2fbc70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ab4a54994341ab463149da427a51d70d2fbc70/comments", "author": null, "committer": null, "parents": [{"sha": "ec25720ba36c2017367b2939cbf1a002694313ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec25720ba36c2017367b2939cbf1a002694313ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec25720ba36c2017367b2939cbf1a002694313ab"}], "stats": {"total": 381, "additions": 288, "deletions": 93}, "files": [{"sha": "22e74efd8c140f55d96b1536eb5e1d8ccd437e30", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -1,3 +1,30 @@\n+2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/21104\n+\t* trans.h (gfc_interface_sym_mapping, gfc_interface_mapping): Moved\n+\tfrom trans-expr.c.\n+\t(gfc_init_interface_mapping, gfc_free_interface_mapping)\n+\t(gfc_add_interface_mapping, gfc_finish_interface_mapping)\n+\t(gfc_apply_interface_mapping): Declare.\n+\t* trans-array.h (gfc_set_loop_bounds_from_array_spec): Declare.\n+\t(gfc_trans_allocate_temp_array): Add pre and post block arguments.\n+\t* trans-array.c (gfc_set_loop_bounds_from_array_spec): New function.\n+\t(gfc_trans_allocate_array_storage): Replace loop argument with\n+\tseparate pre and post blocks.\n+\t(gfc_trans_allocate_temp_array): Add pre and post block arguments.\n+\tUpdate call to gfc_trans_allocate_array_storage.\n+\t(gfc_trans_array_constructor, gfc_conv_loop_setup): Adjust for new\n+\tinterface to gfc_trans_allocate_temp_array.\n+\t* trans-expr.c (gfc_interface_sym_mapping, gfc_interface_mapping):\n+\tMoved to trans.h.\n+\t(gfc_init_interface_mapping, gfc_free_interface_mapping)\n+\t(gfc_add_interface_mapping, gfc_finish_interface_mapping)\n+\t(gfc_apply_interface_mapping): Make extern.\n+\t(gfc_conv_function_call): Build an interface mapping for array\n+\treturn values too.  Call gfc_set_loop_bounds_from_array_spec.\n+\tAdjust call to gfc_trans_allocate_temp_array so that code is\n+\tadded to SE rather than LOOP.\n+\n 2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR fortran/12840"}, {"sha": "4eac13dcfc27bdfad7906db4adbecfb9baf58ce7", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 68, "deletions": 19, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -433,17 +433,64 @@ gfc_trans_static_array_pointer (gfc_symbol * sym)\n }\n \n \n+/* If the bounds of SE's loop have not yet been set, see if they can be\n+   determined from array spec AS, which is the array spec of a called\n+   function.  MAPPING maps the callee's dummy arguments to the values\n+   that the caller is passing.  Add any initialization and finalization\n+   code to SE.  */\n+\n+void\n+gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping * mapping,\n+\t\t\t\t     gfc_se * se, gfc_array_spec * as)\n+{\n+  int n, dim;\n+  gfc_se tmpse;\n+  tree lower;\n+  tree upper;\n+  tree tmp;\n+\n+  if (as && as->type == AS_EXPLICIT)\n+    for (dim = 0; dim < se->loop->dimen; dim++)\n+      {\n+\tn = se->loop->order[dim];\n+\tif (se->loop->to[n] == NULL_TREE)\n+\t  {\n+\t    /* Evaluate the lower bound.  */\n+\t    gfc_init_se (&tmpse, NULL);\n+\t    gfc_apply_interface_mapping (mapping, &tmpse, as->lower[dim]);\n+\t    gfc_add_block_to_block (&se->pre, &tmpse.pre);\n+\t    gfc_add_block_to_block (&se->post, &tmpse.post);\n+\t    lower = tmpse.expr;\n+\n+\t    /* ...and the upper bound.  */\n+\t    gfc_init_se (&tmpse, NULL);\n+\t    gfc_apply_interface_mapping (mapping, &tmpse, as->upper[dim]);\n+\t    gfc_add_block_to_block (&se->pre, &tmpse.pre);\n+\t    gfc_add_block_to_block (&se->post, &tmpse.post);\n+\t    upper = tmpse.expr;\n+\n+\t    /* Set the upper bound of the loop to UPPER - LOWER.  */\n+\t    tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, upper, lower);\n+\t    tmp = gfc_evaluate_now (tmp, &se->pre);\n+\t    se->loop->to[n] = tmp;\n+\t  }\n+      }\n+}\n+\n+\n /* Generate code to allocate an array temporary, or create a variable to\n    hold the data.  If size is NULL zero the descriptor so that so that the\n    callee will allocate the array.  Also generates code to free the array\n    afterwards.\n \n+   Initialization code is added to PRE and finalization code to POST.\n    DYNAMIC is true if the caller may want to extend the array later\n    using realloc.  This prevents us from putting the array on the stack.  */\n \n static void\n-gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n-\t\t\t\t  tree size, tree nelem, bool dynamic)\n+gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n+\t\t\t\t  gfc_ss_info * info, tree size, tree nelem,\n+\t\t\t\t  bool dynamic)\n {\n   tree tmp;\n   tree args;\n@@ -455,7 +502,7 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n   if (size == NULL_TREE || integer_zerop (size))\n     {\n       /* A callee allocated array.  */\n-      gfc_conv_descriptor_data_set (&loop->pre, desc, null_pointer_node);\n+      gfc_conv_descriptor_data_set (pre, desc, null_pointer_node);\n       onstack = FALSE;\n     }\n   else\n@@ -474,7 +521,7 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \t\t\t\t  tmp);\n \t  tmp = gfc_create_var (tmp, \"A\");\n \t  tmp = gfc_build_addr_expr (NULL, tmp);\n-\t  gfc_conv_descriptor_data_set (&loop->pre, desc, tmp);\n+\t  gfc_conv_descriptor_data_set (pre, desc, tmp);\n \t}\n       else\n \t{\n@@ -488,16 +535,16 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n \t  else\n \t    gcc_unreachable ();\n \t  tmp = gfc_build_function_call (tmp, args);\n-\t  tmp = gfc_evaluate_now (tmp, &loop->pre);\n-\t  gfc_conv_descriptor_data_set (&loop->pre, desc, tmp);\n+\t  tmp = gfc_evaluate_now (tmp, pre);\n+\t  gfc_conv_descriptor_data_set (pre, desc, tmp);\n \t}\n     }\n   info->data = gfc_conv_descriptor_data_get (desc);\n \n   /* The offset is zero because we create temporaries with a zero\n      lower bound.  */\n   tmp = gfc_conv_descriptor_offset (desc);\n-  gfc_add_modify_expr (&loop->pre, tmp, gfc_index_zero_node);\n+  gfc_add_modify_expr (pre, tmp, gfc_index_zero_node);\n \n   if (!onstack)\n     {\n@@ -506,7 +553,7 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n       tmp = fold_convert (pvoid_type_node, tmp);\n       tmp = gfc_chainon_list (NULL_TREE, tmp);\n       tmp = gfc_build_function_call (gfor_fndecl_internal_free, tmp);\n-      gfc_add_expr_to_block (&loop->post, tmp);\n+      gfc_add_expr_to_block (post, tmp);\n     }\n }\n \n@@ -518,10 +565,11 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n    Also fills in the descriptor, data and offset fields of info if known.\n    Returns the size of the array, or NULL for a callee allocated array.\n \n-   DYNAMIC is as for gfc_trans_allocate_array_storage.  */\n+   PRE, POST and DYNAMIC are as for gfc_trans_allocate_array_storage.  */\n \n tree\n-gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n+gfc_trans_allocate_temp_array (stmtblock_t * pre, stmtblock_t * post,\n+\t\t\t       gfc_loopinfo * loop, gfc_ss_info * info,\n \t\t\t       tree eltype, bool dynamic)\n {\n   tree type;\n@@ -565,7 +613,7 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n \n   /* Fill in the array dtype.  */\n   tmp = gfc_conv_descriptor_dtype (desc);\n-  gfc_add_modify_expr (&loop->pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n+  gfc_add_modify_expr (pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n \n   /*\n      Fill in the bounds and stride.  This is a packed array, so:\n@@ -596,19 +644,19 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n         \n       /* Store the stride and bound components in the descriptor.  */\n       tmp = gfc_conv_descriptor_stride (desc, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (&loop->pre, tmp, size);\n+      gfc_add_modify_expr (pre, tmp, size);\n \n       tmp = gfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (&loop->pre, tmp, gfc_index_zero_node);\n+      gfc_add_modify_expr (pre, tmp, gfc_index_zero_node);\n \n       tmp = gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]);\n-      gfc_add_modify_expr (&loop->pre, tmp, loop->to[n]);\n+      gfc_add_modify_expr (pre, tmp, loop->to[n]);\n \n       tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t loop->to[n], gfc_index_one_node);\n \n       size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, tmp);\n-      size = gfc_evaluate_now (size, &loop->pre);\n+      size = gfc_evaluate_now (size, pre);\n     }\n \n   /* Get the size of the array.  */\n@@ -617,7 +665,7 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n     size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n \n-  gfc_trans_allocate_array_storage (loop, info, size, nelem, dynamic);\n+  gfc_trans_allocate_array_storage (pre, post, info, size, nelem, dynamic);\n \n   if (info->dimen > loop->temp_dim)\n     loop->temp_dim = info->dimen;\n@@ -1278,7 +1326,8 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n       mpz_clear (size);\n     }\n \n-  gfc_trans_allocate_temp_array (loop, &ss->data.info, type, dynamic);\n+  gfc_trans_allocate_temp_array (&loop->pre, &loop->post, loop,\n+\t\t\t\t &ss->data.info, type, dynamic);\n \n   desc = ss->data.info.descriptor;\n   offset = gfc_index_zero_node;\n@@ -2727,8 +2776,8 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n       memset (&loop->temp_ss->data.info, 0, sizeof (gfc_ss_info));\n       loop->temp_ss->type = GFC_SS_SECTION;\n       loop->temp_ss->data.info.dimen = n;\n-      gfc_trans_allocate_temp_array (loop, &loop->temp_ss->data.info,\n-\t\t\t\t     tmp, false);\n+      gfc_trans_allocate_temp_array (&loop->pre, &loop->post, loop,\n+\t\t\t\t     &loop->temp_ss->data.info, tmp, false);\n     }\n \n   for (n = 0; n < loop->temp_dim; n++)"}, {"sha": "af990a9061cab207622da7ac19e44d3c41766b6a", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -26,8 +26,13 @@ tree gfc_array_deallocate (tree, tree);\n    se, which should contain an expression for the array descriptor.  */\n void gfc_array_allocate (gfc_se *, gfc_ref *, tree);\n \n+/* Allow the bounds of a loop to be set from a callee's array spec.  */\n+void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,\n+\t\t\t\t\t  gfc_se *, gfc_array_spec *);\n+\n /* Generate code to allocate a temporary array.  */\n-tree gfc_trans_allocate_temp_array (gfc_loopinfo *, gfc_ss_info *, tree, bool);\n+tree gfc_trans_allocate_temp_array (stmtblock_t *, stmtblock_t *,\n+\t\t\t\t    gfc_loopinfo *, gfc_ss_info *, tree, bool);\n \n /* Generate function entry code for allocation of compiler allocated array\n    variables.  */"}, {"sha": "ceabb578e67392ccd0495ed624261c5b6cf5e57a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 16, "deletions": 73, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -41,6 +41,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"trans-stmt.h\"\n \n static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr);\n+static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n+\t\t\t\t\t\t gfc_expr *);\n \n /* Copy the scalarization loop variables.  */\n \n@@ -1075,73 +1077,9 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n }\n \n \n-/* This group of functions allows a caller to evaluate an expression from\n-   the callee's interface.  It establishes a mapping between the interface's\n-   dummy arguments and the caller's actual arguments, then applies that\n-   mapping to a given gfc_expr.\n-\n-   You can initialize a mapping structure like so:\n-\n-       gfc_interface_mapping mapping;\n-       ...\n-       gfc_init_interface_mapping (&mapping);\n-\n-   You should then evaluate each actual argument into a temporary\n-   gfc_se structure, here called \"se\", and map the result to the\n-   dummy argument's symbol, here called \"sym\":\n-\n-       gfc_add_interface_mapping (&mapping, sym, &se);\n-\n-   After adding all mappings, you should call:\n-\n-       gfc_finish_interface_mapping (&mapping, pre, post);\n-\n-   where \"pre\" and \"post\" are statement blocks for initialization\n-   and finalization code respectively.  You can then evaluate an\n-   interface expression \"expr\" as follows:\n-\n-       gfc_apply_interface_mapping (&mapping, se, expr);\n-\n-   Once you've evaluated all expressions, you should free\n-   the mapping structure with:\n-\n-       gfc_free_interface_mapping (&mapping); */\n-\n-\n-/* This structure represents a mapping from OLD to NEW, where OLD is a\n-   dummy argument symbol and NEW is a symbol that represents the value\n-   of an actual argument.  Mappings are linked together using NEXT\n-   (in no particular order).  */\n-typedef struct gfc_interface_sym_mapping\n-{\n-  struct gfc_interface_sym_mapping *next;\n-  gfc_symbol *old;\n-  gfc_symtree *new;\n-}\n-gfc_interface_sym_mapping;\n-\n-\n-/* This structure is used by callers to evaluate an expression from\n-   a callee's interface.  */\n-typedef struct gfc_interface_mapping\n-{\n-  /* Maps the interface's dummy arguments to the values that the caller\n-     is passing.  The whole list is owned by this gfc_interface_mapping.  */\n-  gfc_interface_sym_mapping *syms;\n-\n-  /* A list of gfc_charlens that were needed when creating copies of\n-     expressions.  The whole list is owned by this gfc_interface_mapping.  */\n-  gfc_charlen *charlens;\n-}\n-gfc_interface_mapping;\n-\n-\n-static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n-\t\t\t\t\t\t gfc_expr *);\n-\n /* Initialize MAPPING.  */\n \n-static void\n+void\n gfc_init_interface_mapping (gfc_interface_mapping * mapping)\n {\n   mapping->syms = NULL;\n@@ -1151,7 +1089,7 @@ gfc_init_interface_mapping (gfc_interface_mapping * mapping)\n \n /* Free all memory held by MAPPING (but not MAPPING itself).  */\n \n-static void\n+void\n gfc_free_interface_mapping (gfc_interface_mapping * mapping)\n {\n   gfc_interface_sym_mapping *sym;\n@@ -1258,7 +1196,7 @@ gfc_set_interface_mapping_bounds (stmtblock_t * block, tree type, tree desc)\n    in SE.  The caller may still use se->expr and se->string_length after\n    calling this function.  */\n \n-static void\n+void\n gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n \t\t\t   gfc_symbol * sym, gfc_se * se)\n {\n@@ -1359,7 +1297,7 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n    the length of each argument, adding any initialization code to PRE and\n    any finalization code to POST.  */\n \n-static void\n+void\n gfc_finish_interface_mapping (gfc_interface_mapping * mapping,\n \t\t\t      stmtblock_t * pre, stmtblock_t * post)\n {\n@@ -1503,7 +1441,7 @@ gfc_apply_interface_mapping_to_expr (gfc_interface_mapping * mapping,\n /* Evaluate interface expression EXPR using MAPPING.  Store the result\n    in SE.  */\n \n-static void\n+void\n gfc_apply_interface_mapping (gfc_interface_mapping * mapping,\n \t\t\t     gfc_se * se, gfc_expr * expr)\n {\n@@ -1571,8 +1509,9 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n     info = NULL;\n \n   gfc_init_interface_mapping (&mapping);\n-  need_interface_mapping = (sym->ts.type == BT_CHARACTER\n-\t\t\t    && sym->ts.cl->length->expr_type != EXPR_CONSTANT);\n+  need_interface_mapping = ((sym->ts.type == BT_CHARACTER\n+\t\t\t     && sym->ts.cl->length->expr_type != EXPR_CONSTANT)\n+\t\t\t    || sym->attr.dimension);\n   formal = sym->formal;\n   /* Evaluate the arguments.  */\n   for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n@@ -1678,7 +1617,6 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \n       len = cl.backend_decl;\n     }\n-  gfc_free_interface_mapping (&mapping);\n \n   byref = gfc_return_by_reference (sym);\n   if (byref)\n@@ -1693,8 +1631,12 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t  tmp = gfc_typenode_for_spec (&ts);\n \t  info->dimen = se->loop->dimen;\n \n+\t  /* Evaluate the bounds of the result, if known.  */\n+\t  gfc_set_loop_bounds_from_array_spec (&mapping, se, sym->result->as);\n+\n \t  /* Allocate a temporary to store the result.  */\n-\t  gfc_trans_allocate_temp_array (se->loop, info, tmp, false);\n+\t  gfc_trans_allocate_temp_array (&se->pre, &se->post,\n+\t\t\t\t\t se->loop, info, tmp, false);\n \n \t  /* Zero the first stride to indicate a temporary.  */\n \t  tmp = gfc_conv_descriptor_stride (info->descriptor, gfc_rank_cst[0]);\n@@ -1745,6 +1687,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n       if (ts.type == BT_CHARACTER)\n \tretargs = gfc_chainon_list (retargs, len);\n     }\n+  gfc_free_interface_mapping (&mapping);\n \n   /* Add the return arguments.  */\n   arglist = chainon (retargs, arglist);"}, {"sha": "e2f252629cfb98061d9a390d9a0d27c5fd5b4613", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -572,4 +572,74 @@ struct lang_decl\t\tGTY(())\n                                           arg1, arg2)\n #define build3_v(code, arg1, arg2, arg3) build3(code, void_type_node, \\\n                                                 arg1, arg2, arg3)\n+\n+/* This group of functions allows a caller to evaluate an expression from\n+   the callee's interface.  It establishes a mapping between the interface's\n+   dummy arguments and the caller's actual arguments, then applies that\n+   mapping to a given gfc_expr.\n+\n+   You can initialize a mapping structure like so:\n+\n+       gfc_interface_mapping mapping;\n+       ...\n+       gfc_init_interface_mapping (&mapping);\n+\n+   You should then evaluate each actual argument into a temporary\n+   gfc_se structure, here called \"se\", and map the result to the\n+   dummy argument's symbol, here called \"sym\":\n+\n+       gfc_add_interface_mapping (&mapping, sym, &se);\n+\n+   After adding all mappings, you should call:\n+\n+       gfc_finish_interface_mapping (&mapping, pre, post);\n+\n+   where \"pre\" and \"post\" are statement blocks for initialization\n+   and finalization code respectively.  You can then evaluate an\n+   interface expression \"expr\" as follows:\n+\n+       gfc_apply_interface_mapping (&mapping, se, expr);\n+\n+   Once you've evaluated all expressions, you should free\n+   the mapping structure with:\n+\n+       gfc_free_interface_mapping (&mapping); */\n+\n+\n+/* This structure represents a mapping from OLD to NEW, where OLD is a\n+   dummy argument symbol and NEW is a symbol that represents the value\n+   of an actual argument.  Mappings are linked together using NEXT\n+   (in no particular order).  */\n+typedef struct gfc_interface_sym_mapping\n+{\n+  struct gfc_interface_sym_mapping *next;\n+  gfc_symbol *old;\n+  gfc_symtree *new;\n+}\n+gfc_interface_sym_mapping;\n+\n+\n+/* This structure is used by callers to evaluate an expression from\n+   a callee's interface.  */\n+typedef struct gfc_interface_mapping\n+{\n+  /* Maps the interface's dummy arguments to the values that the caller\n+     is passing.  The whole list is owned by this gfc_interface_mapping.  */\n+  gfc_interface_sym_mapping *syms;\n+\n+  /* A list of gfc_charlens that were needed when creating copies of\n+     expressions.  The whole list is owned by this gfc_interface_mapping.  */\n+  gfc_charlen *charlens;\n+}\n+gfc_interface_mapping;\n+\n+void gfc_init_interface_mapping (gfc_interface_mapping *);\n+void gfc_free_interface_mapping (gfc_interface_mapping *);\n+void gfc_add_interface_mapping (gfc_interface_mapping *,\n+\t\t\t\tgfc_symbol *, gfc_se *);\n+void gfc_finish_interface_mapping (gfc_interface_mapping *,\n+\t\t\t\t   stmtblock_t *, stmtblock_t *);\n+void gfc_apply_interface_mapping (gfc_interface_mapping *,\n+\t\t\t\t  gfc_se *, gfc_expr *);\n+\n #endif /* GFC_TRANS_H */"}, {"sha": "605044055da07daca9d3cd5754d30b990c733d9b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -1,3 +1,10 @@\n+2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/21104\n+\t* gfortran.dg/array_alloc_1.f90,\n+\t* gfortran.dg/array_alloc_2.f90,\n+\t* gfortran.dg/array_alloc_3.f90: New tests.\n+\n 2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR fortran/12840"}, {"sha": "86e69e0afd68ad27b8ca33f9aac17a5fca56e752", "filename": "gcc/testsuite/gfortran.dg/array_alloc_1.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_1.f90?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -0,0 +1,21 @@\n+! PR 21104.  Make sure that either f() or its caller will allocate\n+! the array data.  We've decided to make the caller allocate it.\n+! { dg-do run }\n+program main\n+  implicit none\n+  call test (f ())\n+contains\n+  subroutine test (x)\n+    integer, dimension (10) :: x\n+    integer :: i\n+    do i = 1, 10\n+      if (x (i) .ne. i * 100) call abort\n+    end do\n+  end subroutine test\n+\n+  function f\n+    integer, dimension (10) :: f\n+    integer :: i\n+    forall (i = 1:10) f (i) = i * 100\n+  end function f\n+end program main"}, {"sha": "5381bf46e678597935cb6784690746957d5052ce", "filename": "gcc/testsuite/gfortran.dg/array_alloc_2.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_2.f90?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -0,0 +1,38 @@\n+! Like array_alloc_1.f90, but check cases in which the array length is\n+! not a literal constant.\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n = 100\n+  call test (n, f1 ())\n+  call test (47, f2 (50))\n+  call test (n, f3 (f1 ()))\n+contains\n+  subroutine test (expected, x)\n+    integer, dimension (:) :: x\n+    integer :: i, expected\n+    if (size (x, 1) .ne. expected) call abort\n+    do i = 1, expected\n+      if (x (i) .ne. i * 100) call abort\n+    end do\n+  end subroutine test\n+\n+  function f1\n+    integer, dimension (n) :: f1\n+    integer :: i\n+    forall (i = 1:n) f1 (i) = i * 100\n+  end function f1\n+\n+  function f2 (howmuch)\n+    integer :: i, howmuch\n+    integer, dimension (4:howmuch) :: f2\n+    forall (i = 4:howmuch) f2 (i) = i * 100 - 300\n+  end function f2\n+\n+  function f3 (x)\n+    integer, dimension (:) :: x\n+    integer, dimension (size (x, 1)) :: f3\n+    integer :: i\n+    forall (i = 1:size(x)) f3 (i) = i * 100\n+  end function f3\n+end program main"}, {"sha": "5e27297b13c099c235b7306aa3f499e16d4ed0cd", "filename": "gcc/testsuite/gfortran.dg/array_alloc_3.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab4a54994341ab463149da427a51d70d2fbc70/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_alloc_3.f90?ref=62ab4a54994341ab463149da427a51d70d2fbc70", "patch": "@@ -0,0 +1,35 @@\n+! Like array_alloc_1.f90, but check multi-dimensional arrays.\n+! { dg-do run }\n+program main\n+  implicit none\n+  call test ((/ 3, 4, 5 /), f ((/ 3, 4, 5 /)))\n+contains\n+  subroutine test (expected, x)\n+    integer, dimension (:,:,:) :: x\n+    integer, dimension (3) :: expected\n+    integer :: i, i1, i2, i3\n+    do i = 1, 3\n+      if (size (x, i) .ne. expected (i)) call abort\n+    end do\n+    do i1 = 1, expected (1)\n+      do i2 = 1, expected (2)\n+        do i3 = 1, expected (3)\n+          if (x (i1, i2, i3) .ne. i1 + i2 * 10 + i3 * 100) call abort\n+        end do\n+      end do\n+    end do\n+  end subroutine test\n+\n+  function f (x)\n+    integer, dimension (3) :: x\n+    integer, dimension (x(1), x(2), x(3)) :: f\n+    integer :: i1, i2, i3\n+    do i1 = 1, x(1)\n+      do i2 = 1, x(2)\n+        do i3 = 1, x(3)\n+          f (i1, i2, i3) = i1 + i2 * 10 + i3 * 100\n+        end do\n+      end do\n+    end do\n+  end function f\n+end program main"}]}