{"sha": "fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFkY2YzMTM0NTU3Yjk0ZTFlNTJiOGQ5ZDZhYTk1ZTJlYzI0NDNlZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-25T09:26:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-25T09:26:07Z"}, "message": "[multiple changes]\n\n2009-06-25  Emmanuel Briot  <briot@adacore.com>\n\n\t* gnatcmd.adb, prj-proc.adb, make.adb, prj.adb, prj.ads, prj-nmsc.adb,\n\tprj-util.adb, prj-env.adb, prj-env.ads: Merge handling of naming_data\n\tbetween gnatmake and gprbuild.\n\t(Naming_Data): Removed, no longer used\n\t(Naming_Table, Project_Tree_Ref.Namings): Removed, since this is only\n\tneeded locally in one subprogram, no need to store forever in the\n\tstructure.\n\t(Check_Naming_Scheme, Check_Package_Naming): Merged, since they play\n\ta similar role.\n\t(Body_Suffix_Of, Body_Suffix_Id_Of, Register_Default_Naming_Scheme,\n\tSame_Naming_Scheme, Set_Body_Suffix, Set_Spec_Suffix, Spec_Suffix_Of,\n\tSpec_Suffix_Id_Of): removed, no longer used.\n\n2009-06-25  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_res.adb (Resolve_Allocator): Skip test requiring exact match of\n\ttypes on qualified expression in calls to imported C++ constructors.\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): Add missing support for\n\timported C++ constructors.\n\n2009-06-25  Sergey Rybin  <rybin@adacore.com>\n\n\t* vms_data.ads: Add qualifier for new gnatcheck '-t' option.\n\nFrom-SVN: r148937", "tree": {"sha": "116462c37d01ba1b6c932ed55b7db566a03c056d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/116462c37d01ba1b6c932ed55b7db566a03c056d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/comments", "author": null, "committer": null, "parents": [{"sha": "5b900a4520087e5e38fe938e55932e6bd779d1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b900a4520087e5e38fe938e55932e6bd779d1e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b900a4520087e5e38fe938e55932e6bd779d1e9"}], "stats": {"total": 1583, "additions": 570, "deletions": 1013}, "files": [{"sha": "5e92642f334c46cd9bc8f8836ac87aab4d3fa8c7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -1,3 +1,30 @@\n+2009-06-25  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* gnatcmd.adb, prj-proc.adb, make.adb, prj.adb, prj.ads, prj-nmsc.adb,\n+\tprj-util.adb, prj-env.adb, prj-env.ads: Merge handling of naming_data\n+\tbetween gnatmake and gprbuild.\n+\t(Naming_Data): Removed, no longer used\n+\t(Naming_Table, Project_Tree_Ref.Namings): Removed, since this is only\n+\tneeded locally in one subprogram, no need to store forever in the\n+\tstructure.\n+\t(Check_Naming_Scheme, Check_Package_Naming): Merged, since they play\n+\ta similar role.\n+\t(Body_Suffix_Of, Body_Suffix_Id_Of, Register_Default_Naming_Scheme,\n+\tSame_Naming_Scheme, Set_Body_Suffix, Set_Spec_Suffix, Spec_Suffix_Of,\n+\tSpec_Suffix_Id_Of): removed, no longer used.\n+\n+2009-06-25  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Allocator): Skip test requiring exact match of\n+\ttypes on qualified expression in calls to imported C++ constructors.\n+\n+\t* exp_ch4.adb (Expand_Allocator_Expression): Add missing support for\n+\timported C++ constructors.\n+\n+2009-06-25  Sergey Rybin  <rybin@adacore.com>\n+\n+\t* vms_data.ads: Add qualifier for new gnatcheck '-t' option.\n+\n 2009-06-25  Vincent Celier  <celier@adacore.com>\n \n \t* s-os_lib.adb (Normalize_Pathname.Get_Directory): If directory\n@@ -12,6 +39,7 @@\n 2009-06-25  Quentin Ochem  <ochem@adacore.com>\n \n \t* prj.ads (Unit_Index): Now general access type.\n+\n 2009-06-25  Pascal Obry  <obry@adacore.com>\n \n \t* a-stwise.adb, a-stzsea.adb: Fix confusion between 'Length and 'Last."}, {"sha": "a4a6bc3d84bb817ef6fd825c55c6157cc4cf53fe", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -572,6 +572,57 @@ package body Exp_Ch4 is\n    begin\n       if Is_Tagged_Type (T) or else Needs_Finalization (T) then\n \n+         if Is_CPP_Constructor_Call (Exp) then\n+\n+            --  Generate:\n+            --  Pnnn : constant ptr_T := new (T); Init (Pnnn.all,...); Pnnn\n+\n+            --  Allocate the object with no expression\n+\n+            Node := Relocate_Node (N);\n+            Set_Expression (Node,\n+              New_Reference_To (Root_Type (Etype (Exp)), Loc));\n+\n+            --  Avoid its expansion to avoid generating a call to the default\n+            --  C++ constructor\n+\n+            Set_Analyzed (Node);\n+\n+            Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n+\n+            Insert_Action (N,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To (PtrT, Loc),\n+                Expression          => Node));\n+\n+            Apply_Accessibility_Check (Temp);\n+\n+            --  Locate the enclosing list to insert the C++ constructor call\n+\n+            declare\n+               P : Node_Id := Parent (Node);\n+\n+            begin\n+               while not Is_List_Member (P) loop\n+                  P := Parent (P);\n+               end loop;\n+\n+               Insert_List_After_And_Analyze (P,\n+                 Build_Initialization_Call (Loc,\n+                   Id_Ref => Make_Explicit_Dereference (Loc,\n+                               New_Reference_To (Temp, Loc)),\n+                   Typ => Root_Type (Etype (Exp)),\n+                   Constructor_Ref => Exp));\n+            end;\n+\n+            Rewrite (N, New_Reference_To (Temp, Loc));\n+            Analyze_And_Resolve (N, PtrT);\n+\n+            return;\n+         end if;\n+\n          --  Ada 2005 (AI-318-02): If the initialization expression is a call\n          --  to a build-in-place function, then access to the allocated object\n          --  must be passed to the function. Currently we limit such functions"}, {"sha": "86f534da594d855ff781d0f19c0eec5d4b77516a", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -662,8 +662,7 @@ procedure GNATCmd is\n \n    function Configuration_Pragmas_File return Path_Name_Type is\n    begin\n-      Prj.Env.Create_Config_Pragmas_File\n-        (Project, Project, Project_Tree, Include_Config_Files => False);\n+      Prj.Env.Create_Config_Pragmas_File (Project, Project_Tree);\n       return Project.Config_File_Name;\n    end Configuration_Pragmas_File;\n \n@@ -2122,6 +2121,8 @@ begin\n                File_Index : Integer := 0;\n                Dir_Index  : Integer := 0;\n                Last       : constant Integer := Last_Switches.Last;\n+               Lang       : constant Language_Ptr :=\n+                 Get_Language_From_Name (Project, \"ada\");\n \n             begin\n                for Index in 1 .. Last loop\n@@ -2138,7 +2139,7 @@ begin\n                --  indicate to gnatstub the name of the body file with\n                --  a -o switch.\n \n-               if Body_Suffix_Id_Of (Project_Tree, Name_Ada, Project.Naming) /=\n+               if Lang.Config.Naming_Data.Body_Suffix /=\n                     Prj.Default_Ada_Spec_Suffix\n                then\n                   if File_Index /= 0 then\n@@ -2148,18 +2149,15 @@ begin\n                         Last : Natural := Spec'Last;\n \n                      begin\n-                        Get_Name_String\n-                          (Spec_Suffix_Id_Of\n-                             (Project_Tree, Name_Ada, Project.Naming));\n+                        Get_Name_String (Lang.Config.Naming_Data.Spec_Suffix);\n \n                         if Spec'Length > Name_Len\n                           and then Spec (Last - Name_Len + 1 .. Last) =\n                                                   Name_Buffer (1 .. Name_Len)\n                         then\n                            Last := Last - Name_Len;\n                            Get_Name_String\n-                             (Body_Suffix_Id_Of\n-                                (Project_Tree, Name_Ada, Project.Naming));\n+                             (Lang.Config.Naming_Data.Body_Suffix);\n                            Last_Switches.Increment_Last;\n                            Last_Switches.Table (Last_Switches.Last) :=\n                              new String'(\"-o\");"}, {"sha": "8d7e6de374ad484f9f7508af2a17ef6626cefd5c", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -644,7 +644,7 @@ package body Make is\n      (Source_File      : File_Name_Type;\n       Source_File_Name : String;\n       Source_Index     : Int;\n-      Naming           : Naming_Data;\n+      Project          : Project_Id;\n       In_Package       : Package_Id;\n       Allow_ALI        : Boolean) return Variable_Value;\n    --  Return the switches for the source file in the specified package of a\n@@ -1274,7 +1274,7 @@ package body Make is\n              (Source_File      => Name_Find,\n               Source_File_Name => File_Name,\n               Source_Index     => Index,\n-              Naming           => Main_Project.Naming,\n+              Project          => Main_Project,\n               In_Package       => The_Package,\n               Allow_ALI        => Program = Binder or else Program = Linker);\n \n@@ -2388,7 +2388,7 @@ package body Make is\n                       (Source_File      => Source_File,\n                        Source_File_Name => Source_File_Name,\n                        Source_Index     => Source_Index,\n-                       Naming           => Arguments_Project.Naming,\n+                       Project          => Arguments_Project,\n                        In_Package       => Compiler_Package,\n                        Allow_ALI        => False);\n \n@@ -3750,7 +3750,7 @@ package body Make is\n \n    begin\n       Prj.Env.Create_Config_Pragmas_File\n-        (For_Project, Main_Project, Project_Tree);\n+        (For_Project, Project_Tree);\n \n       if For_Project.Config_File_Name /= No_Path then\n          Temporary_Config_File := For_Project.Config_File_Temp;\n@@ -4235,6 +4235,8 @@ package body Make is\n                File_Name : constant String := Base_Name (Main);\n                --  The simple file name of the current main\n \n+               Lang : Language_Ptr;\n+\n             begin\n                exit when Main = \"\";\n \n@@ -4256,18 +4258,18 @@ package body Make is\n                   --  is the actual path of a source of a project.\n \n                   if Main /= File_Name then\n+                     Lang := Get_Language_From_Name (Main_Project, \"ada\");\n+\n                      Real_Path :=\n                        Locate_Regular_File\n-                         (Main &\n-                          Body_Suffix_Of\n-                            (Project_Tree, \"ada\", Main_Project.Naming),\n+                         (Main & Get_Name_String\n+                              (Lang.Config.Naming_Data.Body_Suffix),\n                           \"\");\n                      if Real_Path = null then\n                         Real_Path :=\n                           Locate_Regular_File\n-                            (Main &\n-                             Spec_Suffix_Of\n-                               (Project_Tree, \"ada\", Main_Project.Naming),\n+                            (Main & Get_Name_String\n+                                 (Lang.Config.Naming_Data.Spec_Suffix),\n                              \"\");\n                      end if;\n \n@@ -8122,10 +8124,12 @@ package body Make is\n      (Source_File      : File_Name_Type;\n       Source_File_Name : String;\n       Source_Index     : Int;\n-      Naming           : Naming_Data;\n+      Project          : Project_Id;\n       In_Package       : Package_Id;\n       Allow_ALI        : Boolean) return Variable_Value\n    is\n+      Lang : constant Language_Ptr := Get_Language_From_Name (Project, \"ada\");\n+\n       Switches : Variable_Value;\n \n       Defaults : constant Array_Element_Id :=\n@@ -8156,14 +8160,17 @@ package body Make is\n \n       --  Check also without the suffix\n \n-      if Switches = Nil_Variable_Value then\n+      if Switches = Nil_Variable_Value\n+        and then Lang /= null\n+      then\n          declare\n+            Naming : Lang_Naming_Data renames Lang.Config.Naming_Data;\n             Name        : String (1 .. Source_File_Name'Length + 3);\n             Last        : Positive := Source_File_Name'Length;\n             Spec_Suffix : constant String :=\n-                            Spec_Suffix_Of (Project_Tree, \"ada\", Naming);\n+              Get_Name_String (Naming.Spec_Suffix);\n             Body_Suffix : constant String :=\n-                            Body_Suffix_Of (Project_Tree, \"ada\", Naming);\n+              Get_Name_String (Naming.Body_Suffix);\n             Truncated   : Boolean := False;\n \n          begin"}, {"sha": "3478676be81c26f8cab243e9730d738fb04f236c", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 151, "deletions": 147, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -32,8 +32,6 @@ with Tempdir;\n \n package body Prj.Env is\n \n-   Default_Naming    : constant Naming_Id := Naming_Table.First;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -387,27 +385,30 @@ package body Prj.Env is\n \n    procedure Create_Config_Pragmas_File\n      (For_Project          : Project_Id;\n-      Main_Project         : Project_Id;\n-      In_Tree              : Project_Tree_Ref;\n-      Include_Config_Files : Boolean := True)\n+      In_Tree              : Project_Tree_Ref)\n    is\n-      pragma Unreferenced (Main_Project);\n-      pragma Unreferenced (Include_Config_Files);\n+      type Naming_Id is new Nat;\n+      package Naming_Table is new GNAT.Dynamic_Tables\n+        (Table_Component_Type => Lang_Naming_Data,\n+         Table_Index_Type     => Naming_Id,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 5,\n+         Table_Increment      => 100);\n+      Default_Naming : constant Naming_Id := Naming_Table.First;\n+      Namings        : Naming_Table.Instance;\n+      --  Table storing the naming data for gnatmake/gprmake\n \n       File_Name : Path_Name_Type  := No_Path;\n       File      : File_Descriptor := Invalid_FD;\n \n       Current_Unit : Unit_Index := Units_Htable.Get_First (In_Tree.Units_HT);\n \n-      First_Project : Project_List;\n-\n-      Current_Project : Project_List;\n       Current_Naming  : Naming_Id;\n \n       Status : Boolean;\n       --  For call to Close\n \n-      procedure Check (Project : Project_Id);\n+      procedure Check (Project : Project_Id; State : in out Integer);\n       --  Recursive procedure that put in the config pragmas file any non\n       --  standard naming schemes, if it is not already in the file, then call\n       --  itself for any imported project.\n@@ -432,7 +433,11 @@ package body Prj.Env is\n       -- Check --\n       -----------\n \n-      procedure Check (Project : Project_Id) is\n+      procedure Check (Project : Project_Id; State : in out Integer) is\n+         pragma Unreferenced (State);\n+         Lang   : constant Language_Ptr :=\n+           Get_Language_From_Name (Project, \"ada\");\n+         Naming : Lang_Naming_Data;\n       begin\n          if Current_Verbosity = High then\n             Write_Str (\"Checking project file \"\"\");\n@@ -441,115 +446,85 @@ package body Prj.Env is\n             Write_Eol;\n          end if;\n \n-         --  Is this project in the list of the visited project?\n-\n-         Current_Project := First_Project;\n-         while Current_Project /= null\n-           and then Current_Project.Project /= Project\n-         loop\n-            Current_Project := Current_Project.Next;\n-         end loop;\n-\n-         --  If it is not, put it in the list, and visit it\n-\n-         if Current_Project = null then\n-            First_Project := new Project_List_Element'\n-              (Project => Project,\n-               Next    => First_Project);\n-\n-            --  Is the naming scheme of this project one that we know?\n-\n-            Current_Naming := Default_Naming;\n-            while Current_Naming <=\n-                    Naming_Table.Last (In_Tree.Private_Part.Namings)\n-              and then not Same_Naming_Scheme\n-              (Left => In_Tree.Private_Part.Namings.Table (Current_Naming),\n-               Right => Project.Naming) loop\n-               Current_Naming := Current_Naming + 1;\n-            end loop;\n+         if Lang = null then\n+            if Current_Verbosity = High then\n+               Write_Str (\"Languages does not contain Ada, nothing to do\");\n+            end if;\n+            return;\n+         end if;\n \n-            --  If we don't know it, add it\n+         Naming := Lang.Config.Naming_Data;\n \n-            if Current_Naming >\n-                 Naming_Table.Last (In_Tree.Private_Part.Namings)\n-            then\n-               Naming_Table.Increment_Last (In_Tree.Private_Part.Namings);\n-               In_Tree.Private_Part.Namings.Table\n-                 (Naming_Table.Last (In_Tree.Private_Part.Namings)) :=\n-                    Project.Naming;\n+         --  Is the naming scheme of this project one that we know?\n \n-               --  We need a temporary file to be created\n+         Current_Naming := Default_Naming;\n+         while Current_Naming <= Naming_Table.Last (Namings)\n+           and then Namings.Table (Current_Naming).Dot_Replacement =\n+              Naming.Dot_Replacement\n+           and then Namings.Table (Current_Naming).Casing =\n+              Naming.Casing\n+           and then Namings.Table (Current_Naming).Separate_Suffix =\n+              Naming.Separate_Suffix\n+         loop\n+            Current_Naming := Current_Naming + 1;\n+         end loop;\n \n-               Check_Temp_File;\n+         --  If we don't know it, add it\n \n-               --  Put the SFN pragmas for the naming scheme\n+         if Current_Naming > Naming_Table.Last (Namings) then\n+            Naming_Table.Increment_Last (Namings);\n+            Namings.Table (Naming_Table.Last (Namings)) := Naming;\n \n-               --  Spec\n+            --  We need a temporary file to be created\n \n-               Put_Line\n-                 (File, \"pragma Source_File_Name_Project\");\n-               Put_Line\n-                 (File, \"  (Spec_File_Name  => \"\"*\" &\n-                  Spec_Suffix_Of (In_Tree, \"ada\", Project.Naming) &\n-                  \"\"\",\");\n-               Put_Line\n-                 (File, \"   Casing          => \" &\n-                  Image (Project.Naming.Casing) & \",\");\n-               Put_Line\n-                 (File, \"   Dot_Replacement => \"\"\" &\n-                 Namet.Get_Name_String (Project.Naming.Dot_Replacement) &\n-                  \"\"\");\");\n-\n-               --  and body\n+            Check_Temp_File;\n \n+            --  Put the SFN pragmas for the naming scheme\n+\n+            --  Spec\n+\n+            Put_Line\n+              (File, \"pragma Source_File_Name_Project\");\n+            Put_Line\n+              (File, \"  (Spec_File_Name  => \"\"*\" &\n+               Get_Name_String (Naming.Spec_Suffix) & \"\"\",\");\n+            Put_Line\n+              (File, \"   Casing          => \" &\n+               Image (Naming.Casing) & \",\");\n+            Put_Line\n+              (File, \"   Dot_Replacement => \"\"\" &\n+               Get_Name_String (Naming.Dot_Replacement) & \"\"\");\");\n+\n+            --  and body\n+\n+            Put_Line\n+              (File, \"pragma Source_File_Name_Project\");\n+            Put_Line\n+              (File, \"  (Body_File_Name  => \"\"*\" &\n+               Get_Name_String (Naming.Body_Suffix) & \"\"\",\");\n+            Put_Line\n+              (File, \"   Casing          => \" &\n+               Image (Naming.Casing) & \",\");\n+            Put_Line\n+              (File, \"   Dot_Replacement => \"\"\" &\n+               Get_Name_String (Naming.Dot_Replacement) &\n+               \"\"\");\");\n+\n+            --  and maybe separate\n+\n+            if Naming.Body_Suffix /= Naming.Separate_Suffix then\n+               Put_Line (File, \"pragma Source_File_Name_Project\");\n                Put_Line\n-                 (File, \"pragma Source_File_Name_Project\");\n-               Put_Line\n-                 (File, \"  (Body_File_Name  => \"\"*\" &\n-                  Body_Suffix_Of (In_Tree, \"ada\", Project.Naming) &\n-                  \"\"\",\");\n+                 (File, \"  (Subunit_File_Name  => \"\"*\" &\n+                  Get_Name_String (Naming.Separate_Suffix) & \"\"\",\");\n                Put_Line\n                  (File, \"   Casing          => \" &\n-                  Image (Project.Naming.Casing) & \",\");\n+                  Image (Naming.Casing) & \",\");\n                Put_Line\n                  (File, \"   Dot_Replacement => \"\"\" &\n-                  Namet.Get_Name_String (Project.Naming.Dot_Replacement) &\n+                  Get_Name_String (Naming.Dot_Replacement) &\n                   \"\"\");\");\n-\n-               --  and maybe separate\n-\n-               if Body_Suffix_Of (In_Tree, \"ada\", Project.Naming) /=\n-                  Get_Name_String (Project.Naming.Separate_Suffix)\n-               then\n-                  Put_Line\n-                    (File, \"pragma Source_File_Name_Project\");\n-                  Put_Line\n-                    (File, \"  (Subunit_File_Name  => \"\"*\" &\n-                     Namet.Get_Name_String (Project.Naming.Separate_Suffix) &\n-                     \"\"\",\");\n-                  Put_Line\n-                    (File, \"   Casing          => \" &\n-                     Image (Project.Naming.Casing) &\n-                     \",\");\n-                  Put_Line\n-                    (File, \"   Dot_Replacement => \"\"\" &\n-                     Namet.Get_Name_String (Project.Naming.Dot_Replacement) &\n-                     \"\"\");\");\n-               end if;\n-            end if;\n-\n-            if Project.Extends /= No_Project then\n-               Check (Project.Extends);\n             end if;\n-\n-            declare\n-               Current : Project_List := Project.Imported_Projects;\n-            begin\n-               while Current /= null loop\n-                  Check (Current.Project);\n-                  Current := Current.Next;\n-               end loop;\n-            end;\n          end if;\n       end Check;\n \n@@ -660,18 +635,20 @@ package body Prj.Env is\n          end if;\n       end Put_Line;\n \n+      procedure Check_Imported_Projects is new For_Every_Project_Imported\n+        (Integer, Check);\n+      Dummy : Integer := 0;\n+\n    --  Start of processing for Create_Config_Pragmas_File\n \n    begin\n       if not For_Project.Config_Checked then\n \n-         --  Remove any memory of processed naming schemes, if any\n-\n-         Naming_Table.Set_Last (In_Tree.Private_Part.Namings, Default_Naming);\n+         Naming_Table.Init (Namings);\n \n          --  Check the naming schemes\n \n-         Check (For_Project);\n+         Check_Imported_Projects (For_Project, Dummy, Imported_First => False);\n \n          --  Visit all the units and process those that need an SFN pragma\n \n@@ -830,23 +807,24 @@ package body Prj.Env is\n               and then Source.Path.Name /= No_Path\n               and then\n                 (Source.Language.Config.Kind = File_Based\n-                 or else Source.Unit /= No_Unit_Index)\n+                  or else Source.Unit /= No_Unit_Index)\n             then\n                if Source.Unit /= No_Unit_Index then\n                   Get_Name_String (Source.Unit.Name);\n \n                   if Get_Mode = Ada_Only then\n+\n                      --  ??? Mapping_Spec_Suffix could be set in the case of\n                      --  gnatmake as well\n-                     Name_Len := Name_Len + 1;\n-                     Name_Buffer (Name_Len) := '%';\n-                     Name_Len := Name_Len + 1;\n+\n+                     Add_Char_To_Name_Buffer ('%');\n \n                      if Source.Kind = Spec then\n-                        Name_Buffer (Name_Len) := 's';\n+                        Add_Char_To_Name_Buffer ('s');\n                      else\n-                        Name_Buffer (Name_Len) := 'b';\n+                        Add_Char_To_Name_Buffer ('b');\n                      end if;\n+\n                   else\n                      case Source.Kind is\n                         when Spec =>\n@@ -997,45 +975,59 @@ package body Prj.Env is\n       The_Project   : Project_Id := Project;\n       Original_Name : String := Name;\n \n-      Extended_Spec_Name : String :=\n-                             Name &\n-                             Spec_Suffix_Of (In_Tree, \"ada\", Project.Naming);\n-      Extended_Body_Name : String :=\n-                             Name &\n-                             Body_Suffix_Of (In_Tree, \"ada\", Project.Naming);\n+      Lang   : constant Language_Ptr :=\n+        Get_Language_From_Name (Project, \"ada\");\n \n       Unit              : Unit_Index;\n       The_Original_Name : Name_Id;\n       The_Spec_Name     : Name_Id;\n       The_Body_Name     : Name_Id;\n \n    begin\n+      --  ??? Same block in Project_Od\n       Canonical_Case_File_Name (Original_Name);\n       Name_Len := Original_Name'Length;\n       Name_Buffer (1 .. Name_Len) := Original_Name;\n       The_Original_Name := Name_Find;\n \n-      Canonical_Case_File_Name (Extended_Spec_Name);\n-      Name_Len := Extended_Spec_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := Extended_Spec_Name;\n-      The_Spec_Name := Name_Find;\n+      if Lang /= null then\n+         declare\n+            Naming : constant Lang_Naming_Data := Lang.Config.Naming_Data;\n+            Extended_Spec_Name : String :=\n+              Name & Namet.Get_Name_String (Naming.Spec_Suffix);\n+            Extended_Body_Name : String :=\n+              Name & Namet.Get_Name_String (Naming.Body_Suffix);\n+         begin\n+            Canonical_Case_File_Name (Extended_Spec_Name);\n+            Name_Len := Extended_Spec_Name'Length;\n+            Name_Buffer (1 .. Name_Len) := Extended_Spec_Name;\n+            The_Spec_Name := Name_Find;\n+\n+            Canonical_Case_File_Name (Extended_Body_Name);\n+            Name_Len := Extended_Body_Name'Length;\n+            Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n+            The_Body_Name := Name_Find;\n+         end;\n \n-      Canonical_Case_File_Name (Extended_Body_Name);\n-      Name_Len := Extended_Body_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n-      The_Body_Name := Name_Find;\n+      else\n+         Name_Len := Name'Length;\n+         Name_Buffer (1 .. Name_Len) := Name;\n+         Canonical_Case_File_Name (Name_Buffer);\n+         The_Spec_Name := Name_Find;\n+         The_Body_Name := The_Spec_Name;\n+      end if;\n \n       if Current_Verbosity = High then\n          Write_Str  (\"Looking for file name of \"\"\");\n          Write_Str  (Name);\n          Write_Char ('\"');\n          Write_Eol;\n          Write_Str  (\"   Extended Spec Name = \"\"\");\n-         Write_Str  (Extended_Spec_Name);\n+         Write_Str  (Get_Name_String (The_Spec_Name));\n          Write_Char ('\"');\n          Write_Eol;\n          Write_Str  (\"   Extended Body Name = \"\"\");\n-         Write_Str  (Extended_Body_Name);\n+         Write_Str  (Get_Name_String (The_Body_Name));\n          Write_Char ('\"');\n          Write_Eol;\n       end if;\n@@ -1103,7 +1095,7 @@ package body Prj.Env is\n                              (Unit.File_Names (Impl).Path.Name);\n \n                         else\n-                           return Extended_Body_Name;\n+                           return Get_Name_String (The_Body_Name);\n                         end if;\n \n                      else\n@@ -1167,7 +1159,7 @@ package body Prj.Env is\n                            return Get_Name_String\n                              (Unit.File_Names (Spec).Path.Name);\n                         else\n-                           return Extended_Spec_Name;\n+                           return Get_Name_String (The_Spec_Name);\n                         end if;\n \n                      else\n@@ -1442,10 +1434,8 @@ package body Prj.Env is\n \n       Original_Name : String := Name;\n \n-      Extended_Spec_Name : String :=\n-        Name & Spec_Suffix_Of (In_Tree, \"ada\", Main_Project.Naming);\n-      Extended_Body_Name : String :=\n-        Name & Body_Suffix_Of (In_Tree, \"ada\", Main_Project.Naming);\n+      Lang : constant Language_Ptr :=\n+        Get_Language_From_Name (Main_Project, \"ada\");\n \n       Unit : Unit_Index;\n \n@@ -1455,20 +1445,34 @@ package body Prj.Env is\n       The_Body_Name     : File_Name_Type;\n \n    begin\n+      --  ??? Same block in File_Name_Of_Library_Unit_Body\n       Canonical_Case_File_Name (Original_Name);\n       Name_Len := Original_Name'Length;\n       Name_Buffer (1 .. Name_Len) := Original_Name;\n       The_Original_Name := Name_Find;\n \n-      Canonical_Case_File_Name (Extended_Spec_Name);\n-      Name_Len := Extended_Spec_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := Extended_Spec_Name;\n-      The_Spec_Name := Name_Find;\n-\n-      Canonical_Case_File_Name (Extended_Body_Name);\n-      Name_Len := Extended_Body_Name'Length;\n-      Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n-      The_Body_Name := Name_Find;\n+      if Lang /= null then\n+         declare\n+            Naming : Lang_Naming_Data renames Lang.Config.Naming_Data;\n+            Extended_Spec_Name : String :=\n+              Name & Namet.Get_Name_String (Naming.Spec_Suffix);\n+            Extended_Body_Name : String :=\n+              Name & Namet.Get_Name_String (Naming.Body_Suffix);\n+         begin\n+            Canonical_Case_File_Name (Extended_Spec_Name);\n+            Name_Len := Extended_Spec_Name'Length;\n+            Name_Buffer (1 .. Name_Len) := Extended_Spec_Name;\n+            The_Spec_Name := Name_Find;\n+\n+            Canonical_Case_File_Name (Extended_Body_Name);\n+            Name_Len := Extended_Body_Name'Length;\n+            Name_Buffer (1 .. Name_Len) := Extended_Body_Name;\n+            The_Body_Name := Name_Find;\n+         end;\n+      else\n+         The_Spec_Name := The_Original_Name;\n+         The_Body_Name := The_Original_Name;\n+      end if;\n \n       Unit := Units_Htable.Get_First (In_Tree.Units_HT);\n "}, {"sha": "8104e3419760155fa38c2ca9c99f7c0480157ef3", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -63,16 +63,9 @@ package Prj.Env is\n \n    procedure Create_Config_Pragmas_File\n      (For_Project          : Project_Id;\n-      Main_Project         : Project_Id;\n-      In_Tree              : Project_Tree_Ref;\n-      Include_Config_Files : Boolean := True);\n+      In_Tree              : Project_Tree_Ref);\n    --  If there needs to have SFN pragmas, either for non standard naming\n-   --  schemes or for individual units, or (when Include_Config_Files is True)\n-   --  if Global_Configuration_Pragmas has been specified in package gnatmake\n-   --  of the main project, or if Local_Configuration_Pragmas has been\n-   --  specified in package Compiler of the main project, build (if needed)\n-   --  a temporary file that contains all configuration pragmas, and specify\n-   --  the configuration pragmas file in the project data.\n+   --  schemes or for individual units.\n \n    procedure Create_New_Path_File\n      (In_Tree   : Project_Tree_Ref;"}, {"sha": "f4a1894971ee91b2c4c77620b227363ef8b79829", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 257, "deletions": 348, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -273,13 +273,14 @@ package body Prj.Nmsc is\n    procedure Check_Ada_Name (Name : String; Unit : out Name_Id);\n    --  Check that a name is a valid Ada unit name\n \n-   procedure Check_Naming_Schemes\n+   procedure Check_Package_Naming\n      (Project        : Project_Id;\n       In_Tree        : Project_Tree_Ref;\n       Is_Config_File : Boolean;\n       Bodies         : out Array_Element_Id;\n       Specs          : out Array_Element_Id);\n-   --  Check the naming scheme part of Data.\n+   --  Check the naming scheme part of Data, and initialize the naming scheme\n+   --  data in the config of the various languages.\n    --  Is_Config_File should be True if Project is a config file (.cgpr)\n    --  This also returns the naming scheme exceptions for unit-based\n    --  languages (Bodies and Specs are associative arrays mapping individual\n@@ -314,12 +315,6 @@ package body Prj.Nmsc is\n    --  Current_Dir should represent the current directory, and is passed for\n    --  efficiency to avoid system calls to recompute it.\n \n-   procedure Check_Package_Naming\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref);\n-   --  Check package Naming of project Project in project tree In_Tree and\n-   --  modify its data Data accordingly.\n-\n    procedure Check_Programming_Languages\n      (In_Tree : Project_Tree_Ref;\n       Project : Project_Id);\n@@ -482,11 +477,7 @@ package body Prj.Nmsc is\n \n    procedure Compute_Unit_Name\n      (File_Name       : File_Name_Type;\n-      Dot_Replacement : File_Name_Type;\n-      Separate_Suffix : File_Name_Type;\n-      Body_Suffix     : File_Name_Type;\n-      Spec_Suffix     : File_Name_Type;\n-      Casing          : Casing_Type;\n+      Naming          : Lang_Naming_Data;\n       Kind            : out Source_Kind;\n       Unit            : out Name_Id;\n       In_Tree         : Project_Tree_Ref);\n@@ -497,7 +488,7 @@ package body Prj.Nmsc is\n    procedure Get_Unit\n      (In_Tree             : Project_Tree_Ref;\n       Canonical_File_Name : File_Name_Type;\n-      Naming              : Naming_Data;\n+      Project             : Project_Id;\n       Exception_Id        : out Ada_Naming_Exception_Id;\n       Unit_Name           : out Name_Id;\n       Unit_Kind           : out Spec_Or_Body);\n@@ -910,11 +901,9 @@ package body Prj.Nmsc is\n          Show_Source_Dirs (Project, In_Tree);\n       end if;\n \n-      Check_Package_Naming (Project, In_Tree);\n-\n       Extending := Project.Extends /= No_Project;\n \n-      Check_Naming_Schemes (Project, In_Tree, Is_Config_File, Bodies, Specs);\n+      Check_Package_Naming (Project, In_Tree, Is_Config_File, Bodies, Specs);\n \n       if Get_Mode = Ada_Only then\n          Prepare_Ada_Naming_Exceptions (Bodies, In_Tree, Impl);\n@@ -2409,7 +2398,7 @@ package body Prj.Nmsc is\n       Lang_Index := Project.Languages;\n       while Lang_Index /= No_Language_Index loop\n          --  For all languages, Compiler_Driver needs to be specified. This is\n-         --  only necessary if we do intend to compiler (not in GPS for\n+         --  only necessary if we do intend to compile (not in GPS for\n          --  instance)\n \n          if Compiler_Driver_Mandatory\n@@ -2698,10 +2687,10 @@ package body Prj.Nmsc is\n    end Check_And_Normalize_Unit_Names;\n \n    --------------------------\n-   -- Check_Naming_Schemes --\n+   -- Check_Package_Naming --\n    --------------------------\n \n-   procedure Check_Naming_Schemes\n+   procedure Check_Package_Naming\n      (Project        : Project_Id;\n       In_Tree        : Project_Tree_Ref;\n       Is_Config_File : Boolean;\n@@ -2712,6 +2701,9 @@ package body Prj.Nmsc is\n                    Util.Value_Of (Name_Naming, Project.Decl.Packages, In_Tree);\n       Naming    : Package_Element;\n \n+      Ada_Body_Suffix_Loc : Source_Ptr := No_Location;\n+      Ada_Spec_Suffix_Loc : Source_Ptr := No_Location;\n+\n       procedure Check_Naming_Ada_Only;\n       --  Does Check_Naming_Schemes processing in Ada_Only mode.\n       --  If there is a package Naming, puts in Data.Naming the contents of\n@@ -2737,6 +2729,9 @@ package body Prj.Nmsc is\n       --  In Multi_Lang mode, process the naming exceptions for the two types\n       --  of languages we can have.\n \n+      procedure Initialize_Naming_Data;\n+      --  Initialize internal naming data for the various languages\n+\n       ------------------\n       -- Check_Common --\n       ------------------\n@@ -3122,129 +3117,98 @@ package body Prj.Nmsc is\n       ---------------------------\n \n       procedure Check_Naming_Ada_Only is\n+         Ada : constant Language_Ptr :=\n+           Get_Language_From_Name (Project, \"ada\");\n+\n          Casing_Defined : Boolean;\n-         Spec_Suffix    : File_Name_Type;\n-         Body_Suffix    : File_Name_Type;\n          Sep_Suffix_Loc : Source_Ptr;\n \n-         Ada_Spec_Suffix : constant Variable_Value :=\n-           Prj.Util.Value_Of\n-             (Index     => Name_Ada,\n-              Src_Index => 0,\n-              In_Array  => Project.Naming.Spec_Suffix,\n-              In_Tree   => In_Tree);\n-\n-         Ada_Body_Suffix : constant Variable_Value :=\n-           Prj.Util.Value_Of\n-             (Index     => Name_Ada,\n-              Src_Index => 0,\n-              In_Array  => Project.Naming.Body_Suffix,\n-              In_Tree   => In_Tree);\n-\n       begin\n-         --  The default value of separate suffix should be the same as the\n-         --  body suffix, so we need to compute that first.\n-\n-         if Ada_Body_Suffix.Kind = Single\n-           and then Length_Of_Name (Ada_Body_Suffix.Value) /= 0\n-         then\n-            Body_Suffix := Canonical_Case_File_Name (Ada_Body_Suffix.Value);\n-            Project.Naming.Separate_Suffix := Body_Suffix;\n-            Set_Body_Suffix (In_Tree, \"ada\", Project.Naming, Body_Suffix);\n-\n-         else\n-            Body_Suffix := Default_Ada_Body_Suffix;\n-            Project.Naming.Separate_Suffix := Body_Suffix;\n-            Set_Body_Suffix (In_Tree, \"ada\", Project.Naming, Body_Suffix);\n+         if Ada = null then\n+            --  No language, thus nothing to do\n+            return;\n          end if;\n \n-         Write_Attr (\"Body_Suffix\", Get_Name_String (Body_Suffix));\n+         declare\n+            Data : Lang_Naming_Data renames Ada.Config.Naming_Data;\n+         begin\n+            --  The default value of separate suffix should be the same as the\n+            --  body suffix, so we need to compute that first.\n \n-         --  We'll need the dot replacement below, so compute it now\n+            Data.Separate_Suffix := Data.Body_Suffix;\n+            Write_Attr (\"Body_Suffix\", Get_Name_String (Data.Body_Suffix));\n \n-         Check_Common\n-           (Dot_Replacement => Project.Naming.Dot_Replacement,\n-            Casing          => Project.Naming.Casing,\n-            Casing_Defined  => Casing_Defined,\n-            Separate_Suffix => Project.Naming.Separate_Suffix,\n-            Sep_Suffix_Loc  => Sep_Suffix_Loc);\n+            --  We'll need the dot replacement below, so compute it now\n \n-         Bodies := Util.Value_Of (Name_Body, Naming.Decl.Arrays, In_Tree);\n+            Check_Common\n+              (Dot_Replacement => Data.Dot_Replacement,\n+               Casing          => Data.Casing,\n+               Casing_Defined  => Casing_Defined,\n+               Separate_Suffix => Data.Separate_Suffix,\n+               Sep_Suffix_Loc  => Sep_Suffix_Loc);\n \n-         if Bodies /= No_Array_Element then\n-            Check_And_Normalize_Unit_Names\n-              (Project, In_Tree, Bodies, \"Naming.Bodies\");\n-         end if;\n+            Bodies := Util.Value_Of (Name_Body, Naming.Decl.Arrays, In_Tree);\n \n-         Specs := Util.Value_Of (Name_Spec, Naming.Decl.Arrays, In_Tree);\n+            if Bodies /= No_Array_Element then\n+               Check_And_Normalize_Unit_Names\n+                 (Project, In_Tree, Bodies, \"Naming.Bodies\");\n+            end if;\n \n-         if Specs /= No_Array_Element then\n-            Check_And_Normalize_Unit_Names\n-              (Project, In_Tree, Specs, \"Naming.Specs\");\n-         end if;\n+            Specs := Util.Value_Of (Name_Spec, Naming.Decl.Arrays, In_Tree);\n \n-         --  Check Spec_Suffix\n+            if Specs /= No_Array_Element then\n+               Check_And_Normalize_Unit_Names\n+                 (Project, In_Tree, Specs, \"Naming.Specs\");\n+            end if;\n \n-         if Ada_Spec_Suffix.Kind = Single\n-           and then Length_Of_Name (Ada_Spec_Suffix.Value) /= 0\n-         then\n-            Spec_Suffix := Canonical_Case_File_Name (Ada_Spec_Suffix.Value);\n-            Set_Spec_Suffix (In_Tree, \"ada\", Project.Naming, Spec_Suffix);\n+            --  Check Spec_Suffix\n \n-            if Is_Illegal_Suffix\n-                 (Spec_Suffix, Project.Naming.Dot_Replacement)\n-            then\n-               Err_Vars.Error_Msg_File_1 := Spec_Suffix;\n+            if Is_Illegal_Suffix (Data.Spec_Suffix, Data.Dot_Replacement) then\n+               Err_Vars.Error_Msg_File_1 := Data.Spec_Suffix;\n                Error_Msg\n                  (Project, In_Tree,\n                   \"{ is illegal for Spec_Suffix\",\n-                  Ada_Spec_Suffix.Location);\n+                  Ada_Spec_Suffix_Loc);\n             end if;\n \n-         else\n-            Spec_Suffix := Default_Ada_Spec_Suffix;\n-            Set_Spec_Suffix (In_Tree, \"ada\", Project.Naming, Spec_Suffix);\n-         end if;\n-\n-         Write_Attr (\"Spec_Suffix\", Get_Name_String (Spec_Suffix));\n+            Write_Attr (\"Spec_Suffix\", Get_Name_String (Data.Spec_Suffix));\n \n-         --  Check Body_Suffix\n+            --  Check Body_Suffix\n \n-         if Is_Illegal_Suffix\n-              (Body_Suffix, Project.Naming.Dot_Replacement)\n-         then\n-            Err_Vars.Error_Msg_File_1 := Body_Suffix;\n-            Error_Msg\n-              (Project, In_Tree,\n-               \"{ is illegal for Body_Suffix\",\n-               Ada_Body_Suffix.Location);\n-         end if;\n+            if Is_Illegal_Suffix (Data.Body_Suffix, Data.Dot_Replacement) then\n+               Err_Vars.Error_Msg_File_1 := Data.Body_Suffix;\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"{ is illegal for Body_Suffix\",\n+                  Ada_Body_Suffix_Loc);\n+            end if;\n \n-         --  Spec_Suffix cannot be equal to Body_Suffix or Separate_Suffix,\n-         --  since that would cause a clear ambiguity. Note that we do allow a\n-         --  Spec_Suffix to have the same termination as one of these, which\n-         --  causes a potential ambiguity, but we resolve that my matching the\n-         --  longest possible suffix.\n+            --  Spec_Suffix cannot be equal to Body_Suffix or Separate_Suffix,\n+            --  since that would cause a clear ambiguity. Note that we do allow\n+            --  a Spec_Suffix to have the same termination as one of these,\n+            --  which causes a potential ambiguity, but we resolve that my\n+            --  matching the longest possible suffix.\n \n-         if Spec_Suffix = Body_Suffix then\n-            Error_Msg\n-              (Project, In_Tree,\n-               \"Body_Suffix (\"\"\" &\n-               Get_Name_String (Body_Suffix) &\n-               \"\"\") cannot be the same as Spec_Suffix.\",\n-               Ada_Body_Suffix.Location);\n-         end if;\n+            if Data.Spec_Suffix = Data.Body_Suffix then\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"Body_Suffix (\"\"\" &\n+                  Get_Name_String (Data.Body_Suffix) &\n+                  \"\"\") cannot be the same as Spec_Suffix.\",\n+                  Ada_Body_Suffix_Loc);\n+            end if;\n \n-         if Body_Suffix /= Project.Naming.Separate_Suffix\n-           and then Spec_Suffix = Project.Naming.Separate_Suffix\n-         then\n-            Error_Msg\n-              (Project, In_Tree,\n-               \"Separate_Suffix (\"\"\" &\n-               Get_Name_String (Project.Naming.Separate_Suffix) &\n-               \"\"\") cannot be the same as Spec_Suffix.\",\n-               Sep_Suffix_Loc);\n-         end if;\n+            if Data.Body_Suffix /= Data.Separate_Suffix\n+              and then Data.Spec_Suffix = Data.Separate_Suffix\n+            then\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"Separate_Suffix (\"\"\" &\n+                  Get_Name_String (Data.Separate_Suffix) &\n+                  \"\"\") cannot be the same as Spec_Suffix.\",\n+                  Sep_Suffix_Loc);\n+            end if;\n+         end;\n       end Check_Naming_Ada_Only;\n \n       -----------------------------\n@@ -3375,10 +3339,92 @@ package body Prj.Nmsc is\n          end loop;\n       end Check_Naming_Multi_Lang;\n \n+      ----------------------------\n+      -- Initialize_Naming_Data --\n+      ----------------------------\n+\n+      procedure Initialize_Naming_Data is\n+         Specs  : Array_Element_Id :=\n+           Util.Value_Of\n+             (Name_Spec_Suffix,\n+              Naming.Decl.Arrays,\n+              In_Tree);\n+         Impls  : Array_Element_Id :=\n+           Util.Value_Of\n+             (Name_Body_Suffix,\n+              Naming.Decl.Arrays,\n+              In_Tree);\n+         Lang    : Language_Ptr;\n+         Lang_Name : Name_Id;\n+         Value   : Variable_Value;\n+\n+      begin\n+         --  At this stage, the project already contains the default\n+         --  extensions for the various languages. We now merge those\n+         --  suffixes read in the user project, and they override the\n+         --  default\n+\n+         while Specs /= No_Array_Element loop\n+            Lang_Name := In_Tree.Array_Elements.Table (Specs).Index;\n+            Lang := Get_Language_From_Name\n+              (Project, Name => Get_Name_String (Lang_Name));\n+\n+            if Lang = null then\n+               if Current_Verbosity = High then\n+                  Write_Line\n+                    (\"Ignoring spec naming data for \"\n+                     & Get_Name_String (Lang_Name)\n+                     & \" since language is not defined for this project\");\n+               end if;\n+            else\n+               Value := In_Tree.Array_Elements.Table (Specs).Value;\n+\n+               if Lang.Name = Name_Ada then\n+                  Ada_Spec_Suffix_Loc := Value.Location;\n+               end if;\n+\n+               if Value.Kind = Single then\n+                  Lang.Config.Naming_Data.Spec_Suffix :=\n+                    Canonical_Case_File_Name (Value.Value);\n+               end if;\n+            end if;\n+\n+            Specs := In_Tree.Array_Elements.Table (Specs).Next;\n+         end loop;\n+\n+         while Impls /= No_Array_Element loop\n+            Lang_Name := In_Tree.Array_Elements.Table (Impls).Index;\n+            Lang := Get_Language_From_Name\n+              (Project, Name => Get_Name_String (Lang_Name));\n+\n+            if Lang = null then\n+               if Current_Verbosity = High then\n+                  Write_Line\n+                    (\"Ignoring impl naming data for \"\n+                     & Get_Name_String (Lang_Name)\n+                     & \" since language is not defined for this project\");\n+               end if;\n+            else\n+               Value := In_Tree.Array_Elements.Table (Impls).Value;\n+\n+               if Lang.Name = Name_Ada then\n+                  Ada_Body_Suffix_Loc := Value.Location;\n+               end if;\n+\n+               if Value.Kind = Single then\n+                  Lang.Config.Naming_Data.Body_Suffix :=\n+                    Canonical_Case_File_Name (Value.Value);\n+               end if;\n+            end if;\n+\n+            Impls := In_Tree.Array_Elements.Table (Impls).Next;\n+         end loop;\n+      end Initialize_Naming_Data;\n+\n    --  Start of processing for Check_Naming_Schemes\n \n    begin\n-      Specs := No_Array_Element;\n+      Specs  := No_Array_Element;\n       Bodies := No_Array_Element;\n \n       --  No Naming package or parsing a configuration file? nothing to do\n@@ -3387,17 +3433,20 @@ package body Prj.Nmsc is\n          Naming := In_Tree.Packages.Table (Naming_Id);\n \n          if Current_Verbosity = High then\n-            Write_Line (\"Checking package Naming.\");\n+            Write_Line (\"Checking package Naming for project \"\n+                        & Get_Name_String (Project.Name));\n          end if;\n \n+         Initialize_Naming_Data;\n+\n          case Get_Mode is\n             when Ada_Only =>\n                Check_Naming_Ada_Only;\n             when Multi_Language =>\n                Check_Naming_Multi_Lang;\n          end case;\n       end if;\n-   end Check_Naming_Schemes;\n+   end Check_Package_Naming;\n \n    ------------------------------\n    -- Check_Library_Attributes --\n@@ -4091,154 +4140,6 @@ package body Prj.Nmsc is\n       end if;\n    end Check_Library_Attributes;\n \n-   --------------------------\n-   -- Check_Package_Naming --\n-   --------------------------\n-\n-   procedure Check_Package_Naming\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref)\n-   is\n-      Naming_Id : constant Package_Id :=\n-                   Util.Value_Of (Name_Naming, Project.Decl.Packages, In_Tree);\n-\n-      Naming    : Package_Element;\n-\n-   begin\n-      --  If there is a package Naming, we will put in Data.Naming\n-      --  what is in this package Naming.\n-\n-      if Naming_Id /= No_Package then\n-         Naming := In_Tree.Packages.Table (Naming_Id);\n-\n-         if Current_Verbosity = High then\n-            Write_Line (\"Checking \"\"Naming\"\".\");\n-         end if;\n-\n-         --  Check Spec_Suffix\n-\n-         declare\n-            Spec_Suffixs : Array_Element_Id :=\n-                             Util.Value_Of\n-                               (Name_Spec_Suffix,\n-                                Naming.Decl.Arrays,\n-                                In_Tree);\n-\n-            Suffix  : Array_Element_Id;\n-            Element : Array_Element;\n-            Suffix2 : Array_Element_Id;\n-\n-         begin\n-            --  If some suffixes have been specified, we make sure that\n-            --  for each language for which a default suffix has been\n-            --  specified, there is a suffix specified, either the one\n-            --  in the project file or if there were none, the default.\n-\n-            if Spec_Suffixs /= No_Array_Element then\n-               Suffix := Project.Naming.Spec_Suffix;\n-\n-               while Suffix /= No_Array_Element loop\n-                  Element :=\n-                    In_Tree.Array_Elements.Table (Suffix);\n-                  Suffix2 := Spec_Suffixs;\n-\n-                  while Suffix2 /= No_Array_Element loop\n-                     exit when In_Tree.Array_Elements.Table\n-                                (Suffix2).Index = Element.Index;\n-                     Suffix2 := In_Tree.Array_Elements.Table\n-                                 (Suffix2).Next;\n-                  end loop;\n-\n-                  --  There is a registered default suffix, but no\n-                  --  suffix specified in the project file.\n-                  --  Add the default to the array.\n-\n-                  if Suffix2 = No_Array_Element then\n-                     Array_Element_Table.Increment_Last\n-                       (In_Tree.Array_Elements);\n-                     In_Tree.Array_Elements.Table\n-                       (Array_Element_Table.Last\n-                          (In_Tree.Array_Elements)) :=\n-                       (Index                => Element.Index,\n-                        Src_Index            => Element.Src_Index,\n-                        Index_Case_Sensitive => False,\n-                        Value                => Element.Value,\n-                        Next                 => Spec_Suffixs);\n-                     Spec_Suffixs := Array_Element_Table.Last\n-                                       (In_Tree.Array_Elements);\n-                  end if;\n-\n-                  Suffix := Element.Next;\n-               end loop;\n-\n-               --  Put the resulting array as the Spec suffixes\n-\n-               Project.Naming.Spec_Suffix := Spec_Suffixs;\n-            end if;\n-         end;\n-\n-         --  Check Body_Suffix\n-\n-         declare\n-            Impl_Suffixs : Array_Element_Id :=\n-                             Util.Value_Of\n-                               (Name_Body_Suffix,\n-                                Naming.Decl.Arrays,\n-                                In_Tree);\n-\n-            Suffix  : Array_Element_Id;\n-            Element : Array_Element;\n-            Suffix2 : Array_Element_Id;\n-\n-         begin\n-            --  If some suffixes have been specified, we make sure that\n-            --  for each language for which a default suffix has been\n-            --  specified, there is a suffix specified, either the one\n-            --  in the project file or if there were none, the default.\n-\n-            if Impl_Suffixs /= No_Array_Element then\n-               Suffix := Project.Naming.Body_Suffix;\n-               while Suffix /= No_Array_Element loop\n-                  Element :=\n-                    In_Tree.Array_Elements.Table (Suffix);\n-\n-                  Suffix2 := Impl_Suffixs;\n-                  while Suffix2 /= No_Array_Element loop\n-                     exit when In_Tree.Array_Elements.Table\n-                                (Suffix2).Index = Element.Index;\n-                     Suffix2 := In_Tree.Array_Elements.Table\n-                                  (Suffix2).Next;\n-                  end loop;\n-\n-                  --  There is a registered default suffix, but no suffix was\n-                  --  specified in the project file. Add default to the array.\n-\n-                  if Suffix2 = No_Array_Element then\n-                     Array_Element_Table.Increment_Last\n-                       (In_Tree.Array_Elements);\n-                     In_Tree.Array_Elements.Table\n-                       (Array_Element_Table.Last\n-                          (In_Tree.Array_Elements)) :=\n-                       (Index                => Element.Index,\n-                        Src_Index            => Element.Src_Index,\n-                        Index_Case_Sensitive => False,\n-                        Value                => Element.Value,\n-                        Next                 => Impl_Suffixs);\n-                     Impl_Suffixs := Array_Element_Table.Last\n-                                       (In_Tree.Array_Elements);\n-                  end if;\n-\n-                  Suffix := Element.Next;\n-               end loop;\n-\n-               --  Put the resulting array as the implementation suffixes\n-\n-               Project.Naming.Body_Suffix := Impl_Suffixs;\n-            end if;\n-         end;\n-      end if;\n-   end Check_Package_Naming;\n-\n    ---------------------------------\n    -- Check_Programming_Languages --\n    ---------------------------------\n@@ -4251,8 +4152,53 @@ package body Prj.Nmsc is\n       Def_Lang    : Variable_Value := Nil_Variable_Value;\n       Def_Lang_Id : Name_Id;\n \n+      procedure Add_Language (Name, Display_Name : Name_Id);\n+      --  Add a new language to the list of languages for the project.\n+      --  Nothing is done if the language has already been defined\n+\n+      procedure Add_Language (Name, Display_Name : Name_Id) is\n+         Lang : Language_Ptr := Project.Languages;\n+      begin\n+         while Lang /= No_Language_Index loop\n+            if Name = Lang.Name then\n+               return;\n+            end if;\n+\n+            Lang := Lang.Next;\n+         end loop;\n+\n+         Lang              := new Language_Data'(No_Language_Data);\n+         Lang.Next         := Project.Languages;\n+         Project.Languages := Lang;\n+         Lang.Name := Name;\n+         Lang.Display_Name := Display_Name;\n+\n+         if Name = Name_Ada then\n+            Lang.Config.Kind := Unit_Based;\n+            Lang.Config.Dependency_Kind := ALI_File;\n+\n+            if Get_Mode = Ada_Only then\n+               --  Create a default config for Ada (since there is no\n+               --  configuration file to create it for us)\n+               --  ??? We should do as GPS does and create a dummy config\n+               --  file\n+\n+               Lang.Config.Naming_Data :=\n+                 (Dot_Replacement => File_Name_Type\n+                    (First_Name_Id + Character'Pos ('-')),\n+                  Casing          => All_Lower_Case,\n+                  Separate_Suffix => Default_Ada_Body_Suffix,\n+                  Spec_Suffix     => Default_Ada_Spec_Suffix,\n+                  Body_Suffix     => Default_Ada_Body_Suffix);\n+            end if;\n+\n+         else\n+            Lang.Config.Kind := File_Based;\n+         end if;\n+      end Add_Language;\n+\n    begin\n-      Project.Languages := No_Language_Index;\n+      Project.Languages := null;\n       Languages :=\n         Prj.Util.Value_Of (Name_Languages, Project.Decl.Attributes, In_Tree);\n       Def_Lang :=\n@@ -4296,27 +4242,17 @@ package body Prj.Nmsc is\n             end if;\n \n             if Def_Lang_Id /= No_Name then\n-               Project.Languages := new Language_Data'(No_Language_Data);\n-               Project.Languages.Name := Def_Lang_Id;\n                Get_Name_String (Def_Lang_Id);\n                Name_Buffer (1) := GNAT.Case_Util.To_Upper (Name_Buffer (1));\n-               Project.Languages.Display_Name := Name_Find;\n-\n-               if Def_Lang_Id = Name_Ada then\n-                  Project.Languages.Config.Kind := Unit_Based;\n-                  Project.Languages.Config.Dependency_Kind := ALI_File;\n-               else\n-                  Project.Languages.Config.Kind := File_Based;\n-               end if;\n+               Add_Language\n+                 (Name         => Def_Lang_Id,\n+                  Display_Name => Name_Find);\n             end if;\n \n          else\n             declare\n                Current           : String_List_Id := Languages.Values;\n                Element           : String_Element;\n-               Lang_Name         : Name_Id;\n-               Index             : Language_Ptr;\n-               NL_Id             : Language_Ptr;\n \n             begin\n                --  If there are no languages declared, there are no sources\n@@ -4340,34 +4276,10 @@ package body Prj.Nmsc is\n                      Element := In_Tree.String_Elements.Table (Current);\n                      Get_Name_String (Element.Value);\n                      To_Lower (Name_Buffer (1 .. Name_Len));\n-                     Lang_Name := Name_Find;\n \n-                     --  If the language was not already specified (duplicates\n-                     --  are simply ignored).\n-\n-                     NL_Id := Project.Languages;\n-                     while NL_Id /= No_Language_Index loop\n-                        exit when Lang_Name = NL_Id.Name;\n-                        NL_Id := NL_Id.Next;\n-                     end loop;\n-\n-                     if NL_Id = No_Language_Index then\n-                        Index := new Language_Data'(No_Language_Data);\n-                        Index.Name := Lang_Name;\n-                        Index.Display_Name := Element.Value;\n-                        Index.Next := Project.Languages;\n-\n-                        if Lang_Name = Name_Ada then\n-                           Index.Config.Kind := Unit_Based;\n-                           Index.Config.Dependency_Kind := ALI_File;\n-\n-                        else\n-                           Index.Config.Kind := File_Based;\n-                           Index.Config.Dependency_Kind := None;\n-                        end if;\n-\n-                        Project.Languages := Index;\n-                     end if;\n+                     Add_Language\n+                       (Name         => Name_Find,\n+                        Display_Name => Element.Value);\n \n                      Current := Element.Next;\n                   end loop;\n@@ -6115,36 +6027,32 @@ package body Prj.Nmsc is\n \n    procedure Compute_Unit_Name\n      (File_Name       : File_Name_Type;\n-      Dot_Replacement : File_Name_Type;\n-      Separate_Suffix : File_Name_Type;\n-      Body_Suffix     : File_Name_Type;\n-      Spec_Suffix     : File_Name_Type;\n-      Casing          : Casing_Type;\n+      Naming          : Lang_Naming_Data;\n       Kind            : out Source_Kind;\n       Unit            : out Name_Id;\n       In_Tree         : Project_Tree_Ref)\n    is\n       Filename : constant String := Get_Name_String (File_Name);\n       Last     : Integer := Filename'Last;\n       Sep_Len  : constant Integer :=\n-                   Integer (Length_Of_Name (Separate_Suffix));\n+                   Integer (Length_Of_Name (Naming.Separate_Suffix));\n       Body_Len : constant Integer :=\n-                   Integer (Length_Of_Name (Body_Suffix));\n+                   Integer (Length_Of_Name (Naming.Body_Suffix));\n       Spec_Len : constant Integer :=\n-                   Integer (Length_Of_Name (Spec_Suffix));\n+                   Integer (Length_Of_Name (Naming.Spec_Suffix));\n \n       Standard_GNAT : constant Boolean :=\n-                        Spec_Suffix = Default_Ada_Spec_Suffix\n+                        Naming.Spec_Suffix = Default_Ada_Spec_Suffix\n                           and then\n-                        Body_Suffix = Default_Ada_Body_Suffix;\n+                        Naming.Body_Suffix = Default_Ada_Body_Suffix;\n \n       Unit_Except : Unit_Exception;\n       Masked      : Boolean  := False;\n    begin\n       Unit := No_Name;\n       Kind := Spec;\n \n-      if Dot_Replacement = No_File then\n+      if Naming.Dot_Replacement = No_File then\n          if Current_Verbosity = High then\n             Write_Line (\"  No dot_replacement specified\");\n          end if;\n@@ -6154,22 +6062,22 @@ package body Prj.Nmsc is\n       --  Choose the longest suffix that matches. If there are several matches,\n       --  give priority to specs, then bodies, then separates.\n \n-      if Separate_Suffix /= Body_Suffix\n-        and then Suffix_Matches (Filename, Separate_Suffix)\n+      if Naming.Separate_Suffix /= Naming.Body_Suffix\n+        and then Suffix_Matches (Filename, Naming.Separate_Suffix)\n       then\n          Last := Filename'Last - Sep_Len;\n          Kind := Sep;\n       end if;\n \n       if Filename'Last - Body_Len <= Last\n-        and then Suffix_Matches (Filename, Body_Suffix)\n+        and then Suffix_Matches (Filename, Naming.Body_Suffix)\n       then\n          Last := Natural'Min (Last, Filename'Last - Body_Len);\n          Kind := Impl;\n       end if;\n \n       if Filename'Last - Spec_Len <= Last\n-        and then Suffix_Matches (Filename, Spec_Suffix)\n+        and then Suffix_Matches (Filename, Naming.Spec_Suffix)\n       then\n          Last := Natural'Min (Last, Filename'Last - Spec_Len);\n          Kind := Spec;\n@@ -6185,7 +6093,7 @@ package body Prj.Nmsc is\n       --  Check that the casing matches\n \n       if File_Names_Case_Sensitive then\n-         case Casing is\n+         case Naming.Casing is\n             when All_Lower_Case =>\n                for J in Filename'First .. Last loop\n                   if Is_Letter (Filename (J))\n@@ -6219,7 +6127,8 @@ package body Prj.Nmsc is\n       --  be any dot in the name.\n \n       declare\n-         Dot_Repl : constant String := Get_Name_String (Dot_Replacement);\n+         Dot_Repl : constant String :=\n+           Get_Name_String (Naming.Dot_Replacement);\n \n       begin\n          if Dot_Repl /= \".\" then\n@@ -6345,7 +6254,7 @@ package body Prj.Nmsc is\n    procedure Get_Unit\n      (In_Tree             : Project_Tree_Ref;\n       Canonical_File_Name : File_Name_Type;\n-      Naming              : Naming_Data;\n+      Project             : Project_Id;\n       Exception_Id        : out Ada_Naming_Exception_Id;\n       Unit_Name           : out Name_Id;\n       Unit_Kind           : out Spec_Or_Body)\n@@ -6354,6 +6263,7 @@ package body Prj.Nmsc is\n                    Ada_Naming_Exceptions.Get (Canonical_File_Name);\n       VMS_Name : File_Name_Type;\n       Kind     : Source_Kind;\n+      Lang     : Language_Ptr;\n \n    begin\n       if Info_Id = No_Ada_Naming_Exception\n@@ -6377,21 +6287,24 @@ package body Prj.Nmsc is\n \n       else\n          Exception_Id := No_Ada_Naming_Exception;\n-         Compute_Unit_Name\n-           (File_Name       => Canonical_File_Name,\n-            Dot_Replacement => Naming.Dot_Replacement,\n-            Separate_Suffix => Naming.Separate_Suffix,\n-            Body_Suffix     => Body_Suffix_Id_Of (In_Tree, Name_Ada, Naming),\n-            Spec_Suffix     => Spec_Suffix_Id_Of (In_Tree, Name_Ada, Naming),\n-            Casing          => Naming.Casing,\n-            Kind            => Kind,\n-            Unit            => Unit_Name,\n-            In_Tree         => In_Tree);\n+         Lang := Get_Language_From_Name (Project, \"ada\");\n \n-         case Kind is\n-            when Spec       => Unit_Kind := Spec;\n-            when Impl | Sep => Unit_Kind := Impl;\n-         end case;\n+         if Lang = null then\n+            Unit_Name := No_Name;\n+            Unit_Kind := Spec;\n+         else\n+            Compute_Unit_Name\n+              (File_Name       => Canonical_File_Name,\n+               Naming          => Lang.Config.Naming_Data,\n+               Kind            => Kind,\n+               Unit            => Unit_Name,\n+               In_Tree         => In_Tree);\n+\n+            case Kind is\n+               when Spec       => Unit_Kind := Spec;\n+               when Impl | Sep => Unit_Kind := Impl;\n+            end case;\n+         end if;\n       end if;\n    end Get_Unit;\n \n@@ -7286,11 +7199,7 @@ package body Prj.Nmsc is\n                if not Header_File then\n                   Compute_Unit_Name\n                     (File_Name       => File_Name,\n-                     Dot_Replacement => Config.Naming_Data.Dot_Replacement,\n-                     Separate_Suffix => Config.Naming_Data.Separate_Suffix,\n-                     Body_Suffix     => Config.Naming_Data.Body_Suffix,\n-                     Spec_Suffix     => Config.Naming_Data.Spec_Suffix,\n-                     Casing          => Config.Naming_Data.Casing,\n+                     Naming          => Config.Naming_Data,\n                      Kind            => Kind,\n                      Unit            => Unit,\n                      In_Tree         => In_Tree);\n@@ -8219,7 +8128,7 @@ package body Prj.Nmsc is\n       Get_Unit\n         (In_Tree             => In_Tree,\n          Canonical_File_Name => Canonical_File,\n-         Naming              => Project.Naming,\n+         Project             => Project,\n          Exception_Id        => Exception_Id,\n          Unit_Name           => Unit_Name,\n          Unit_Kind           => Unit_Kind);"}, {"sha": "4c45642bf0df01ed68cc11572bba52c8aafdcbda", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -2336,6 +2336,7 @@ package body Prj.Proc is\n \n    begin\n       Error_Report := Report_Error;\n+\n       Success := True;\n \n       if Project /= No_Project then\n@@ -2581,7 +2582,7 @@ package body Prj.Proc is\n                return;\n             end if;\n \n-            Project := new Project_Data'(Empty_Project (In_Tree));\n+            Project := new Project_Data'(Empty_Project);\n             In_Tree.Projects := new Project_List_Element'\n               (Project => Project,\n                Next    => In_Tree.Projects);"}, {"sha": "5e36fcd71e6882b585b10ebb236e01b99e6ab12c", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -134,7 +134,7 @@ package body Prj.Util is\n \n       Executable_Suffix_Name : Name_Id := No_Name;\n \n-      Naming : constant Naming_Data := Project.Naming;\n+      Lang   : Language_Ptr;\n \n       Spec_Suffix : Name_Id := No_Name;\n       Body_Suffix : Name_Id := No_Name;\n@@ -143,46 +143,43 @@ package body Prj.Util is\n       Body_Suffix_Length : Natural := 0;\n \n       procedure Get_Suffixes\n-        (B_Suffix : String;\n-         S_Suffix : String);\n+        (B_Suffix : File_Name_Type;\n+         S_Suffix : File_Name_Type);\n       --  Get the non empty suffixes in variables Spec_Suffix and Body_Suffix\n \n       ------------------\n       -- Get_Suffixes --\n       ------------------\n \n       procedure Get_Suffixes\n-        (B_Suffix : String;\n-         S_Suffix : String)\n+        (B_Suffix : File_Name_Type;\n+         S_Suffix : File_Name_Type)\n       is\n       begin\n-         if B_Suffix'Length > 0 then\n-            Name_Len := B_Suffix'Length;\n-            Name_Buffer (1 .. Name_Len) := B_Suffix;\n-            Body_Suffix := Name_Find;\n-            Body_Suffix_Length := B_Suffix'Length;\n+         if B_Suffix /= No_File then\n+            Body_Suffix := Name_Id (B_Suffix);\n+            Body_Suffix_Length := Natural (Length_Of_Name (Body_Suffix));\n          end if;\n \n-         if S_Suffix'Length > 0 then\n-            Name_Len := S_Suffix'Length;\n-            Name_Buffer (1 .. Name_Len) := S_Suffix;\n-            Spec_Suffix := Name_Find;\n-            Spec_Suffix_Length := S_Suffix'Length;\n+         if S_Suffix /= No_File then\n+            Spec_Suffix := Name_Id (S_Suffix);\n+            Spec_Suffix_Length := Natural (Length_Of_Name (Spec_Suffix));\n          end if;\n       end Get_Suffixes;\n \n    --  Start of processing for Executable_Of\n \n    begin\n       if Ada_Main then\n-         Get_Suffixes\n-           (B_Suffix => Body_Suffix_Of (In_Tree, \"ada\", Naming),\n-            S_Suffix => Spec_Suffix_Of (In_Tree, \"ada\", Naming));\n-\n+         Lang := Get_Language_From_Name (Project, \"ada\");\n       elsif Language /= \"\" then\n+         Lang := Get_Language_From_Name (Project, Language);\n+      end if;\n+\n+      if Lang /= null then\n          Get_Suffixes\n-           (B_Suffix => Body_Suffix_Of (In_Tree, Language, Naming),\n-            S_Suffix => Spec_Suffix_Of (In_Tree, Language, Naming));\n+           (B_Suffix => Lang.Config.Naming_Data.Body_Suffix,\n+            S_Suffix => Lang.Config.Naming_Data.Spec_Suffix);\n       end if;\n \n       if Builder_Package /= No_Package then\n@@ -217,15 +214,17 @@ package body Prj.Util is\n                Truncated : Boolean := False;\n \n             begin\n-               if Last > Natural (Length_Of_Name (Body_Suffix))\n+               if Body_Suffix /= No_Name\n+                 and then Last > Natural (Length_Of_Name (Body_Suffix))\n                  and then Name (Last - Body_Suffix_Length + 1 .. Last) =\n                             Get_Name_String (Body_Suffix)\n                then\n                   Truncated := True;\n                   Last := Last - Body_Suffix_Length;\n                end if;\n \n-               if not Truncated\n+               if Spec_Suffix /= No_Name\n+                 and then not Truncated\n                  and then Last > Spec_Suffix_Length\n                  and then Name (Last - Spec_Suffix_Length + 1 .. Last) =\n                             Get_Name_String (Spec_Suffix)"}, {"sha": "ec7eeaa090364da7f440e332281a485e832868cc", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 3, "deletions": 364, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -64,17 +64,6 @@ package body Prj is\n \n    Initialized : Boolean := False;\n \n-   Standard_Dot_Replacement : constant File_Name_Type :=\n-                                File_Name_Type\n-                                  (First_Name_Id + Character'Pos ('-'));\n-\n-   Std_Naming_Data : constant Naming_Data :=\n-                       (Dot_Replacement           => Standard_Dot_Replacement,\n-                        Casing                    => All_Lower_Case,\n-                        Spec_Suffix               => No_Array_Element,\n-                        Body_Suffix               => No_Array_Element,\n-                        Separate_Suffix           => No_File);\n-\n    Project_Empty : constant Project_Data :=\n                      (Qualifier                      => Unspecified,\n                       Externally_Built               => False,\n@@ -108,8 +97,7 @@ package body Prj is\n                       Exec_Directory                 => No_Path_Information,\n                       Extends                        => No_Project,\n                       Extended_By                    => No_Project,\n-                      Naming                         => Std_Naming_Data,\n-                      Languages      => No_Language_Index,\n+                      Languages                      => No_Language_Index,\n                       Decl                           => No_Declarations,\n                       Imported_Projects              => null,\n                       All_Imported_Projects          => null,\n@@ -187,67 +175,6 @@ package body Prj is\n       Last := Last + S'Length;\n    end Add_To_Buffer;\n \n-   -----------------------\n-   -- Body_Suffix_Id_Of --\n-   -----------------------\n-\n-   function Body_Suffix_Id_Of\n-     (In_Tree     : Project_Tree_Ref;\n-      Language_Id : Name_Id;\n-      Naming      : Naming_Data) return File_Name_Type\n-   is\n-      Element_Id : Array_Element_Id;\n-      Element    : Array_Element;\n-\n-   begin\n-      --  ??? This seems to be only for Ada_Only mode...\n-      Element_Id := Naming.Body_Suffix;\n-      while Element_Id /= No_Array_Element loop\n-         Element := In_Tree.Array_Elements.Table (Element_Id);\n-\n-         if Element.Index = Language_Id then\n-            return File_Name_Type (Element.Value.Value);\n-         end if;\n-\n-         Element_Id := Element.Next;\n-      end loop;\n-\n-      return No_File;\n-   end Body_Suffix_Id_Of;\n-\n-   --------------------\n-   -- Body_Suffix_Of --\n-   --------------------\n-\n-   function Body_Suffix_Of\n-     (In_Tree  : Project_Tree_Ref;\n-      Language : String;\n-      Naming   : Naming_Data) return String\n-   is\n-      Language_Id : Name_Id;\n-      Element_Id  : Array_Element_Id;\n-      Element     : Array_Element;\n-\n-   begin\n-      Name_Len := 0;\n-      Add_Str_To_Name_Buffer (Language);\n-      To_Lower (Name_Buffer (1 .. Name_Len));\n-      Language_Id := Name_Find;\n-\n-      Element_Id := Naming.Body_Suffix;\n-      while Element_Id /= No_Array_Element loop\n-         Element := In_Tree.Array_Elements.Table (Element_Id);\n-\n-         if Element.Index = Language_Id then\n-            return Get_Name_String (Element.Value.Value);\n-         end if;\n-\n-         Element_Id := Element.Next;\n-      end loop;\n-\n-      return \"\";\n-   end Body_Suffix_Of;\n-\n    -----------------------------\n    -- Default_Ada_Body_Suffix --\n    -----------------------------\n@@ -322,15 +249,10 @@ package body Prj is\n    -- Empty_Project --\n    -------------------\n \n-   function Empty_Project (Tree : Project_Tree_Ref) return Project_Data is\n-      Value : Project_Data;\n-\n+   function Empty_Project return Project_Data is\n    begin\n       Prj.Initialize (Tree => No_Project_Tree);\n-      Value := Project_Empty;\n-      Value.Naming := Tree.Private_Part.Default_Naming;\n-\n-      return Value;\n+      return Project_Empty;\n    end Empty_Project;\n \n    ------------------\n@@ -690,110 +612,6 @@ package body Prj is\n       Temp_Files.Table (Temp_Files.Last) := Path;\n    end Record_Temp_File;\n \n-   ------------------------------------\n-   -- Register_Default_Naming_Scheme --\n-   ------------------------------------\n-\n-   procedure Register_Default_Naming_Scheme\n-     (Language            : Name_Id;\n-      Default_Spec_Suffix : File_Name_Type;\n-      Default_Body_Suffix : File_Name_Type;\n-      In_Tree             : Project_Tree_Ref)\n-   is\n-      Lang    : Name_Id;\n-      Suffix  : Array_Element_Id;\n-      Found   : Boolean := False;\n-      Element : Array_Element;\n-\n-   begin\n-      --  Get the language name in small letters\n-\n-      Get_Name_String (Language);\n-      Name_Buffer (1 .. Name_Len) := To_Lower (Name_Buffer (1 .. Name_Len));\n-      Lang := Name_Find;\n-\n-      --  Look for an element of the spec suffix array indexed by the language\n-      --  name. If one is found, put the default value.\n-\n-      Suffix := In_Tree.Private_Part.Default_Naming.Spec_Suffix;\n-      Found := False;\n-      while Suffix /= No_Array_Element and then not Found loop\n-         Element := In_Tree.Array_Elements.Table (Suffix);\n-\n-         if Element.Index = Lang then\n-            Found := True;\n-            Element.Value.Value := Name_Id (Default_Spec_Suffix);\n-            In_Tree.Array_Elements.Table (Suffix) := Element;\n-\n-         else\n-            Suffix := Element.Next;\n-         end if;\n-      end loop;\n-\n-      --  If none can be found, create a new one\n-\n-      if not Found then\n-         Element :=\n-           (Index     => Lang,\n-            Src_Index => 0,\n-            Index_Case_Sensitive => False,\n-            Value => (Project  => No_Project,\n-                      Kind     => Single,\n-                      Location => No_Location,\n-                      Default  => False,\n-                      Value    => Name_Id (Default_Spec_Suffix),\n-                      Index    => 0),\n-            Next  => In_Tree.Private_Part.Default_Naming.Spec_Suffix);\n-         Array_Element_Table.Increment_Last (In_Tree.Array_Elements);\n-         In_Tree.Array_Elements.Table\n-           (Array_Element_Table.Last (In_Tree.Array_Elements)) :=\n-            Element;\n-         In_Tree.Private_Part.Default_Naming.Spec_Suffix :=\n-           Array_Element_Table.Last (In_Tree.Array_Elements);\n-      end if;\n-\n-      --  Look for an element of the body suffix array indexed by the language\n-      --  name. If one is found, put the default value.\n-\n-      Suffix := In_Tree.Private_Part.Default_Naming.Body_Suffix;\n-      Found := False;\n-      while Suffix /= No_Array_Element and then not Found loop\n-         Element := In_Tree.Array_Elements.Table (Suffix);\n-\n-         if Element.Index = Lang then\n-            Found := True;\n-            Element.Value.Value := Name_Id (Default_Body_Suffix);\n-            In_Tree.Array_Elements.Table (Suffix) := Element;\n-\n-         else\n-            Suffix := Element.Next;\n-         end if;\n-      end loop;\n-\n-      --  If none can be found, create a new one\n-\n-      if not Found then\n-         Element :=\n-           (Index     => Lang,\n-            Src_Index => 0,\n-            Index_Case_Sensitive => False,\n-            Value => (Project  => No_Project,\n-                      Kind     => Single,\n-                      Location => No_Location,\n-                      Default  => False,\n-                      Value    => Name_Id (Default_Body_Suffix),\n-                      Index    => 0),\n-            Next  => In_Tree.Private_Part.Default_Naming.Body_Suffix);\n-         Array_Element_Table.Increment_Last\n-           (In_Tree.Array_Elements);\n-         In_Tree.Array_Elements.Table\n-           (Array_Element_Table.Last (In_Tree.Array_Elements))\n-             := Element;\n-         In_Tree.Private_Part.Default_Naming.Body_Suffix :=\n-           Array_Element_Table.Last (In_Tree.Array_Elements);\n-      end if;\n-   end Register_Default_Naming_Scheme;\n-\n    ----------\n    -- Free --\n    ----------\n@@ -955,7 +773,6 @@ package body Prj is\n \n          --  Private part\n \n-         Naming_Table.Free      (Tree.Private_Part.Namings);\n          Path_File_Table.Free   (Tree.Private_Part.Path_Files);\n          Source_Path_Table.Free (Tree.Private_Part.Source_Paths);\n          Object_Path_Table.Free (Tree.Private_Part.Object_Paths);\n@@ -992,24 +809,11 @@ package body Prj is\n \n       --  Private part table\n \n-      Naming_Table.Init             (Tree.Private_Part.Namings);\n-      Naming_Table.Increment_Last   (Tree.Private_Part.Namings);\n-      Tree.Private_Part.Namings.Table\n-        (Naming_Table.Last (Tree.Private_Part.Namings)) := Std_Naming_Data;\n       Path_File_Table.Init        (Tree.Private_Part.Path_Files);\n       Source_Path_Table.Init      (Tree.Private_Part.Source_Paths);\n       Object_Path_Table.Init      (Tree.Private_Part.Object_Paths);\n-      Tree.Private_Part.Default_Naming := Std_Naming_Data;\n \n       if Current_Mode = Ada_Only then\n-         Register_Default_Naming_Scheme\n-           (Language            => Name_Ada,\n-            Default_Spec_Suffix => Default_Ada_Spec_Suffix,\n-            Default_Body_Suffix => Default_Ada_Body_Suffix,\n-            In_Tree             => Tree);\n-         Tree.Private_Part.Default_Naming.Separate_Suffix :=\n-           Default_Ada_Body_Suffix;\n-\n          Tree.Private_Part.Current_Source_Path_File := No_Path;\n          Tree.Private_Part.Current_Object_Path_File := No_Path;\n          Tree.Private_Part.Ada_Path_Length := 0;\n@@ -1019,57 +823,6 @@ package body Prj is\n       end if;\n    end Reset;\n \n-   ------------------------\n-   -- Same_Naming_Scheme --\n-   ------------------------\n-\n-   function Same_Naming_Scheme\n-     (Left, Right : Naming_Data) return Boolean\n-   is\n-   begin\n-      return Left.Dot_Replacement = Right.Dot_Replacement\n-        and then Left.Casing = Right.Casing\n-        and then Left.Separate_Suffix = Right.Separate_Suffix;\n-   end Same_Naming_Scheme;\n-\n-   ---------------------\n-   -- Set_Body_Suffix --\n-   ---------------------\n-\n-   procedure Set_Body_Suffix\n-     (In_Tree  : Project_Tree_Ref;\n-      Language : String;\n-      Naming   : in out Naming_Data;\n-      Suffix   : File_Name_Type)\n-   is\n-      Language_Id : Name_Id;\n-      Element     : Array_Element;\n-\n-   begin\n-      Name_Len := 0;\n-      Add_Str_To_Name_Buffer (Language);\n-      To_Lower (Name_Buffer (1 .. Name_Len));\n-      Language_Id := Name_Find;\n-\n-      Element :=\n-        (Index                => Language_Id,\n-         Src_Index            => 0,\n-         Index_Case_Sensitive => False,\n-         Value                =>\n-           (Kind     => Single,\n-            Project  => No_Project,\n-            Location => No_Location,\n-            Default  => False,\n-            Value    => Name_Id (Suffix),\n-            Index    => 0),\n-         Next                 => Naming.Body_Suffix);\n-\n-      Array_Element_Table.Increment_Last (In_Tree.Array_Elements);\n-      Naming.Body_Suffix :=\n-         Array_Element_Table.Last (In_Tree.Array_Elements);\n-      In_Tree.Array_Elements.Table (Naming.Body_Suffix) := Element;\n-   end Set_Body_Suffix;\n-\n    --------------\n    -- Set_Mode --\n    --------------\n@@ -1088,120 +841,6 @@ package body Prj is\n       end case;\n    end Set_Mode;\n \n-   ---------------------\n-   -- Set_Spec_Suffix --\n-   ---------------------\n-\n-   procedure Set_Spec_Suffix\n-     (In_Tree  : Project_Tree_Ref;\n-      Language : String;\n-      Naming   : in out Naming_Data;\n-      Suffix   : File_Name_Type)\n-   is\n-      Language_Id : Name_Id;\n-      Element     : Array_Element;\n-\n-   begin\n-      Name_Len := 0;\n-      Add_Str_To_Name_Buffer (Language);\n-      To_Lower (Name_Buffer (1 .. Name_Len));\n-      Language_Id := Name_Find;\n-\n-      Element :=\n-        (Index                => Language_Id,\n-         Src_Index            => 0,\n-         Index_Case_Sensitive => False,\n-         Value                =>\n-           (Kind     => Single,\n-            Project  => No_Project,\n-            Location => No_Location,\n-            Default  => False,\n-            Value    => Name_Id (Suffix),\n-            Index    => 0),\n-         Next                 => Naming.Spec_Suffix);\n-\n-      Array_Element_Table.Increment_Last (In_Tree.Array_Elements);\n-      Naming.Spec_Suffix :=\n-        Array_Element_Table.Last (In_Tree.Array_Elements);\n-      In_Tree.Array_Elements.Table (Naming.Spec_Suffix) := Element;\n-   end Set_Spec_Suffix;\n-\n-   -----------------------\n-   -- Spec_Suffix_Id_Of --\n-   -----------------------\n-\n-   function Spec_Suffix_Id_Of\n-     (In_Tree     : Project_Tree_Ref;\n-      Language_Id : Name_Id;\n-      Naming      : Naming_Data) return File_Name_Type\n-   is\n-      Element_Id : Array_Element_Id;\n-      Element    : Array_Element;\n-\n-   begin\n-      Element_Id := Naming.Spec_Suffix;\n-      while Element_Id /= No_Array_Element loop\n-         Element := In_Tree.Array_Elements.Table (Element_Id);\n-\n-         if Element.Index = Language_Id then\n-            return File_Name_Type (Element.Value.Value);\n-         end if;\n-\n-         Element_Id := Element.Next;\n-      end loop;\n-\n-      return No_File;\n-   end Spec_Suffix_Id_Of;\n-\n-   --------------------\n-   -- Spec_Suffix_Of --\n-   --------------------\n-\n-   function Spec_Suffix_Of\n-     (In_Tree  : Project_Tree_Ref;\n-      Language : String;\n-      Naming   : Naming_Data) return String\n-   is\n-      Language_Id : Name_Id;\n-      Element_Id  : Array_Element_Id;\n-      Element     : Array_Element;\n-\n-   begin\n-      Name_Len := 0;\n-      Add_Str_To_Name_Buffer (Language);\n-      To_Lower (Name_Buffer (1 .. Name_Len));\n-      Language_Id := Name_Find;\n-\n-      Element_Id := Naming.Spec_Suffix;\n-      while Element_Id /= No_Array_Element loop\n-         Element := In_Tree.Array_Elements.Table (Element_Id);\n-\n-         if Element.Index = Language_Id then\n-            return Get_Name_String (Element.Value.Value);\n-         end if;\n-\n-         Element_Id := Element.Next;\n-      end loop;\n-\n-      return \"\";\n-   end Spec_Suffix_Of;\n-\n-   --------------------------\n-   -- Standard_Naming_Data --\n-   --------------------------\n-\n-   function Standard_Naming_Data\n-     (Tree : Project_Tree_Ref := No_Project_Tree) return Naming_Data\n-   is\n-   begin\n-      if Tree = No_Project_Tree then\n-         Prj.Initialize (Tree => No_Project_Tree);\n-         return Std_Naming_Data;\n-      else\n-         return Tree.Private_Part.Default_Naming;\n-      end if;\n-   end Standard_Naming_Data;\n-\n    -------------------\n    -- Switches_Name --\n    -------------------"}, {"sha": "22280252ec50b909e426b7a33a56894b3b33bc8c", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 9, "deletions": 97, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -830,61 +830,6 @@ package Prj is\n \n    --  The following record contains data for a naming scheme\n \n-   type Naming_Data is record\n-\n-      Dot_Replacement : File_Name_Type := No_File;\n-      --  The string to replace '.' in the source file name (for Ada)\n-\n-      Casing : Casing_Type := All_Lower_Case;\n-      --  The casing of the source file name (for Ada)\n-\n-      Spec_Suffix : Array_Element_Id := No_Array_Element;\n-      --  The string to append to the unit name for the\n-      --  source file name of a spec.\n-      --  Indexed by the programming language.\n-\n-      Body_Suffix : Array_Element_Id := No_Array_Element;\n-      --  The string to append to the unit name for the\n-      --  source file name of a body.\n-      --  Indexed by the programming language.\n-\n-      Separate_Suffix : File_Name_Type := No_File;\n-      --  String to append to unit name for source file name of an Ada subunit\n-\n-   end record;\n-\n-   function Spec_Suffix_Of\n-     (In_Tree  : Project_Tree_Ref;\n-      Language : String;\n-      Naming   : Naming_Data) return String;\n-\n-   function Spec_Suffix_Id_Of\n-     (In_Tree     : Project_Tree_Ref;\n-      Language_Id : Name_Id;\n-      Naming      : Naming_Data) return File_Name_Type;\n-\n-   procedure Set_Spec_Suffix\n-     (In_Tree  : Project_Tree_Ref;\n-      Language : String;\n-      Naming   : in out Naming_Data;\n-      Suffix   : File_Name_Type);\n-\n-   function Body_Suffix_Id_Of\n-     (In_Tree     : Project_Tree_Ref;\n-      Language_Id : Name_Id;\n-      Naming      : Naming_Data) return File_Name_Type;\n-\n-   function Body_Suffix_Of\n-     (In_Tree  : Project_Tree_Ref;\n-      Language : String;\n-      Naming   : Naming_Data) return String;\n-\n-   procedure Set_Body_Suffix\n-     (In_Tree  : Project_Tree_Ref;\n-      Language : String;\n-      Naming   : in out Naming_Data;\n-      Suffix   : File_Name_Type);\n-\n    function Get_Object_Directory\n      (Project             : Project_Id;\n       Including_Libraries : Boolean;\n@@ -906,18 +851,6 @@ package Prj is\n    --  Returns the ultimate extending project of project Proj. If project Proj\n    --  is not extended, returns Proj.\n \n-   function Standard_Naming_Data\n-     (Tree : Project_Tree_Ref := No_Project_Tree) return Naming_Data;\n-   pragma Inline (Standard_Naming_Data);\n-   --  The standard GNAT naming scheme when Tree is No_Project_Tree.\n-   --  Otherwise, return the default naming scheme for the project tree Tree,\n-   --  which must have been Initialized.\n-\n-   function Same_Naming_Scheme\n-     (Left, Right : Naming_Data) return Boolean;\n-   --  Returns True if Left and Right are the same naming scheme\n-   --  not considering Specs and Bodies.\n-\n    type Project_List_Element;\n    type Project_List is access all Project_List_Element;\n    type Project_List_Element is record\n@@ -1121,9 +1054,6 @@ package Prj is\n       Location : Source_Ptr := No_Location;\n       --  The location in the project file source of the reserved word project\n \n-      Naming : Naming_Data := Standard_Naming_Data;\n-      --  The naming scheme of this project file\n-\n       ---------------\n       -- Languages --\n       ---------------\n@@ -1305,9 +1235,9 @@ package Prj is\n \n    end record;\n \n-   function Empty_Project (Tree : Project_Tree_Ref) return Project_Data;\n-   --  Return the representation of an empty project in project Tree tree.\n-   --  The project tree Tree must have been Initialized and/or Reset.\n+   function Empty_Project return Project_Data;\n+   --  Return the representation of an empty project.\n+   --  In Ada-only mode, the Ada language is also partly initialized\n \n    function Is_Extending\n      (Extending : Project_Id;\n@@ -1410,18 +1340,6 @@ package Prj is\n    --  This procedure resets all the tables that are used when processing a\n    --  project file tree. Initialize must be called before the call to Reset.\n \n-   procedure Register_Default_Naming_Scheme\n-     (Language            : Name_Id;\n-      Default_Spec_Suffix : File_Name_Type;\n-      Default_Body_Suffix : File_Name_Type;\n-      In_Tree             : Project_Tree_Ref);\n-   --  Register the default suffixes for a given language. These extensions\n-   --  will be ignored if the user has specified a new naming scheme in a\n-   --  project file.\n-   --\n-   --  Otherwise, this information will be automatically added to Naming_Data\n-   --  when a project is processed, in the lists Spec_Suffix and Body_Suffix.\n-\n    package Project_Boolean_Htable is new Simple_HTable\n      (Header_Num => Header_Num,\n       Element    => Boolean,\n@@ -1531,16 +1449,6 @@ private\n       Last : in out Natural);\n    --  Append a String to the Buffer\n \n-   type Naming_Id is new Nat;\n-\n-   package Naming_Table is new GNAT.Dynamic_Tables\n-     (Table_Component_Type => Naming_Data,\n-      Table_Index_Type     => Naming_Id,\n-      Table_Low_Bound      => 1,\n-      Table_Initial        => 5,\n-      Table_Increment      => 100);\n-   --  Table storing the naming data for gnatmake/gprmake\n-\n    package Path_File_Table is new GNAT.Dynamic_Tables\n      (Table_Component_Type => Path_Name_Type,\n       Table_Index_Type     => Natural,\n@@ -1567,26 +1475,28 @@ private\n    --  A table to store the object dirs, before creating the object path file\n \n    type Private_Project_Tree_Data is record\n-      Namings        : Naming_Table.Instance;\n       Path_Files     : Path_File_Table.Instance;\n       Source_Paths   : Source_Path_Table.Instance;\n       Object_Paths   : Object_Path_Table.Instance;\n-      Default_Naming : Naming_Data;\n \n       Current_Source_Path_File : Path_Name_Type := No_Path;\n       --  Current value of project source path file env var. Used to avoid\n       --  setting the env var to the same value.\n+      --  gnatmake only\n \n       Current_Object_Path_File : Path_Name_Type := No_Path;\n       --  Current value of project object path file env var. Used to avoid\n       --  setting the env var to the same value.\n+      --  gnatmake only\n \n       Ada_Path_Buffer : String_Access := new String (1 .. 1024);\n       --  A buffer where values for ADA_INCLUDE_PATH and ADA_OBJECTS_PATH are\n       --  stored.\n+      --  gnatmake only\n \n       Ada_Path_Length : Natural := 0;\n       --  Index of the last valid character in Ada_Path_Buffer\n+      --  gnatmake only\n \n       Ada_Prj_Include_File_Set : Boolean := False;\n       Ada_Prj_Objects_File_Set : Boolean := False;\n@@ -1596,8 +1506,10 @@ private\n       --  effect on most platforms, except on VMS where the logical names are\n       --  deassigned, thus avoiding the pollution of the environment of the\n       --  caller.\n+      --  gnatmake only\n \n       Fill_Mapping_File : Boolean := True;\n+      --  gnatmake only\n \n    end record;\n    --  Type to represent the part of a project tree which is private to the"}, {"sha": "47b88c3338a5248082ad754538f16f7f60699676", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -3979,9 +3979,17 @@ package body Sem_Res is\n          Check_Unset_Reference (Expression (E));\n \n          --  A qualified expression requires an exact match of the type,\n-         --  class-wide matching is not allowed.\n+         --  class-wide matching is not allowed. We skip this test in a call\n+         --  to a CPP constructor because in such case, although the function\n+         --  profile indicates that it returns a class-wide type, the object\n+         --  returned by the C++ constructor has a concrete type.\n \n-         if (Is_Class_Wide_Type (Etype (Expression (E)))\n+         if Is_Class_Wide_Type (Etype (Expression (E)))\n+           and then Is_CPP_Constructor_Call (Expression (E))\n+         then\n+            null;\n+\n+         elsif (Is_Class_Wide_Type (Etype (Expression (E)))\n               or else Is_Class_Wide_Type (Etype (E)))\n            and then Base_Type (Etype (Expression (E))) /= Base_Type (Etype (E))\n          then"}, {"sha": "07047c71b5b5e59ea9c7a55cb46262866c740130", "filename": "gcc/ada/vms_data.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fvms_data.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef/gcc%2Fada%2Fvms_data.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_data.ads?ref=fadcf3134557b94e1e52b8d9d6aa95e2ec2443ef", "patch": "@@ -820,6 +820,13 @@ package VMS_Data is\n    --\n    --   Work quietly, only output warnings and errors.\n \n+   S_Check_Time  : aliased constant S := \"/TIME \"                        &\n+                                            \"-t\";\n+   --        /NOTIME (D)\n+   --        /QUIET\n+   --\n+   --   Print  out execution time\n+\n    S_Check_Sections : aliased constant S := \"/SECTIONS=\"                   &\n                                             \"DEFAULT \"                     &\n                                                \"-s123 \"                    &\n@@ -893,6 +900,7 @@ package VMS_Data is\n                        S_Check_Mess     'Access,\n                        S_Check_Project  'Access,\n                        S_Check_Quiet    'Access,\n+                       S_Check_Time     'Access,\n                        S_Check_Sections 'Access,\n                        S_Check_Short    'Access,\n                        S_Check_Subdirs  'Access,"}]}