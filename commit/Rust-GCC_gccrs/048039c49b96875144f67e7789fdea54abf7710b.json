{"sha": "048039c49b96875144f67e7789fdea54abf7710b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ4MDM5YzQ5Yjk2ODc1MTQ0ZjY3ZTc3ODlmZGVhNTRhYmY3NzEwYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-08-03T12:00:49Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-08-03T12:00:49Z"}, "message": "aarch64: Add -mtune=neoverse-512tvb\n\nThis patch adds an option to tune for Neoverse cores that have\na total vector bandwidth of 512 bits (4x128 for Advanced SIMD\nand a vector-length-dependent equivalent for SVE).  This is intended\nto be a compromise between tuning aggressively for a single core like\nNeoverse V1 (which can be too narrow) and tuning for AArch64 cores\nin general (which can be too wide).\n\n-mcpu=neoverse-512tvb is equivalent to -mcpu=neoverse-v1\n-mtune=neoverse-512tvb.\n\ngcc/\n\t* doc/invoke.texi: Document -mtune=neoverse-512tvb and\n\t-mcpu=neoverse-512tvb.\n\t* config/aarch64/aarch64-cores.def (neoverse-512tvb): New entry.\n\t* config/aarch64/aarch64-tune.md: Regenerate.\n\t* config/aarch64/aarch64.c (neoverse512tvb_sve_vector_cost)\n\t(neoverse512tvb_sve_issue_info, neoverse512tvb_vec_issue_info)\n\t(neoverse512tvb_vector_cost, neoverse512tvb_tunings): New structures.\n\t(aarch64_adjust_body_cost_sve): Handle -mtune=neoverse-512tvb.\n\t(aarch64_adjust_body_cost): Likewise.", "tree": {"sha": "66aa1cc477b2c9289b5a5990dac0d9401d52a32d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66aa1cc477b2c9289b5a5990dac0d9401d52a32d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/048039c49b96875144f67e7789fdea54abf7710b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048039c49b96875144f67e7789fdea54abf7710b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/048039c49b96875144f67e7789fdea54abf7710b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/048039c49b96875144f67e7789fdea54abf7710b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9690309baf8294b0512b55b133bc102dc0dac5b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9690309baf8294b0512b55b133bc102dc0dac5b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9690309baf8294b0512b55b133bc102dc0dac5b5"}], "stats": {"total": 214, "additions": 202, "deletions": 12}, "files": [{"sha": "b2aa1670561e7a1fc3037554db709d96ed0d13b8", "filename": "gcc/config/aarch64/aarch64-cores.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048039c49b96875144f67e7789fdea54abf7710b/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048039c49b96875144f67e7789fdea54abf7710b/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def?ref=048039c49b96875144f67e7789fdea54abf7710b", "patch": "@@ -139,6 +139,7 @@ AARCH64_CORE(\"thunderx3t110\",  thunderx3t110,  thunderx3t110, 8_3A,  AARCH64_FL_\n /* Arm ('A') cores.  */\n AARCH64_CORE(\"zeus\", zeus, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)\n AARCH64_CORE(\"neoverse-v1\", neoversev1, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoversev1, 0x41, 0xd40, -1)\n+AARCH64_CORE(\"neoverse-512tvb\", neoverse512tvb, cortexa57, 8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_SVE | AARCH64_FL_RCPC | AARCH64_FL_I8MM | AARCH64_FL_BF16 | AARCH64_FL_F16 | AARCH64_FL_PROFILE | AARCH64_FL_SSBS | AARCH64_FL_RNG, neoverse512tvb, INVALID_IMP, INVALID_CORE, -1)\n \n /* Qualcomm ('Q') cores. */\n AARCH64_CORE(\"saphira\",     saphira,    saphira,    8_4A,  AARCH64_FL_FOR_ARCH8_4 | AARCH64_FL_CRYPTO | AARCH64_FL_RCPC, saphira,   0x51, 0xC01, -1)"}, {"sha": "e491c29d31aaa3e738b93ce9a7a09b5171728046", "filename": "gcc/config/aarch64/aarch64-tune.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048039c49b96875144f67e7789fdea54abf7710b/gcc%2Fconfig%2Faarch64%2Faarch64-tune.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048039c49b96875144f67e7789fdea54abf7710b/gcc%2Fconfig%2Faarch64%2Faarch64-tune.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-tune.md?ref=048039c49b96875144f67e7789fdea54abf7710b", "patch": "@@ -1,5 +1,5 @@\n ;; -*- buffer-read-only: t -*-\n ;; Generated automatically by gentune.sh from aarch64-cores.def\n (define_attr \"tune\"\n-\t\"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa78,cortexa78ae,cortexa78c,cortexa65,cortexa65ae,cortexx1,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55,cortexr82\"\n+\t\"cortexa34,cortexa35,cortexa53,cortexa57,cortexa72,cortexa73,thunderx,thunderxt88p1,thunderxt88,octeontx,octeontxt81,octeontxt83,thunderxt81,thunderxt83,emag,xgene1,falkor,qdf24xx,exynosm1,phecda,thunderx2t99p1,vulcan,thunderx2t99,cortexa55,cortexa75,cortexa76,cortexa76ae,cortexa77,cortexa78,cortexa78ae,cortexa78c,cortexa65,cortexa65ae,cortexx1,ares,neoversen1,neoversee1,octeontx2,octeontx2t98,octeontx2t96,octeontx2t93,octeontx2f95,octeontx2f95n,octeontx2f95mm,a64fx,tsv110,thunderx3t110,zeus,neoversev1,neoverse512tvb,saphira,neoversen2,cortexa57cortexa53,cortexa72cortexa53,cortexa73cortexa35,cortexa73cortexa53,cortexa75cortexa55,cortexa76cortexa55,cortexr82\"\n \t(const (symbol_ref \"((enum attr_tune) aarch64_tune)\")))"}, {"sha": "f80de2ca8971086d6a4bf3aa7793d0cda953b5c8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 177, "deletions": 7, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048039c49b96875144f67e7789fdea54abf7710b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048039c49b96875144f67e7789fdea54abf7710b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=048039c49b96875144f67e7789fdea54abf7710b", "patch": "@@ -1842,6 +1842,136 @@ static const struct tune_params neoversev1_tunings =\n   &generic_prefetch_tune\n };\n \n+static const sve_vec_cost neoverse512tvb_sve_vector_cost =\n+{\n+  {\n+    2, /* int_stmt_cost  */\n+    2, /* fp_stmt_cost  */\n+    4, /* ld2_st2_permute_cost  */\n+    5, /* ld3_st3_permute_cost  */\n+    5, /* ld4_st4_permute_cost  */\n+    3, /* permute_cost  */\n+    /* Theoretically, a reduction involving 15 scalar ADDs could\n+       complete in ~5 cycles and would have a cost of 15.  Assume that\n+       [SU]ADDV completes in 11 cycles and so give it a cost of 15 + 6.  */\n+    21, /* reduc_i8_cost  */\n+    /* Likewise for 7 scalar ADDs (~3 cycles) vs. 9: 7 + 6.  */\n+    13, /* reduc_i16_cost  */\n+    /* Likewise for 3 scalar ADDs (~2 cycles) vs. 8: 3 + 6.  */\n+    9, /* reduc_i32_cost  */\n+    /* Likewise for 1 scalar ADD (1 cycle) vs. 8: 1 + 7.  */\n+    8, /* reduc_i64_cost  */\n+    /* Theoretically, a reduction involving 7 scalar FADDs could\n+       complete in ~6 cycles and would have a cost of 14.  Assume that\n+       FADDV completes in 8 cycles and so give it a cost of 14 + 2.  */\n+    16, /* reduc_f16_cost  */\n+    /* Likewise for 3 scalar FADDs (~4 cycles) vs. 6: 6 + 2.  */\n+    8, /* reduc_f32_cost  */\n+    /* Likewise for 1 scalar FADD (2 cycles) vs. 4: 2 + 2.  */\n+    4, /* reduc_f64_cost  */\n+    2, /* store_elt_extra_cost  */\n+    /* This value is just inherited from the Cortex-A57 table.  */\n+    8, /* vec_to_scalar_cost  */\n+    /* This depends very much on what the scalar value is and\n+       where it comes from.  E.g. some constants take two dependent\n+       instructions or a load, while others might be moved from a GPR.\n+       4 seems to be a reasonable compromise in practice.  */\n+    4, /* scalar_to_vec_cost  */\n+    4, /* align_load_cost  */\n+    4, /* unalign_load_cost  */\n+    /* Although stores generally have a latency of 2 and compete for the\n+       vector pipes, in practice it's better not to model that.  */\n+    1, /* unalign_store_cost  */\n+    1  /* store_cost  */\n+  },\n+  3, /* clast_cost  */\n+  10, /* fadda_f16_cost  */\n+  6, /* fadda_f32_cost  */\n+  4, /* fadda_f64_cost  */\n+  /* A strided Advanced SIMD x64 load would take two parallel FP loads\n+     (6 cycles) plus an insertion (2 cycles).  Assume a 64-bit SVE gather\n+     is 1 cycle more.  The Advanced SIMD version is costed as 2 scalar loads\n+     (cost 8) and a vec_construct (cost 2).  Add a full vector operation\n+     (cost 2) to that, to avoid the difference being lost in rounding.\n+\n+     There is no easy comparison between a strided Advanced SIMD x32 load\n+     and an SVE 32-bit gather, but cost an SVE 32-bit gather as 1 vector\n+     operation more than a 64-bit gather.  */\n+  14, /* gather_load_x32_cost  */\n+  12, /* gather_load_x64_cost  */\n+  3 /* scatter_store_elt_cost  */\n+};\n+\n+static const aarch64_sve_vec_issue_info neoverse512tvb_sve_issue_info =\n+{\n+  {\n+    {\n+      3, /* loads_per_cycle  */\n+      2, /* stores_per_cycle  */\n+      4, /* general_ops_per_cycle  */\n+      0, /* fp_simd_load_general_ops  */\n+      1 /* fp_simd_store_general_ops  */\n+    },\n+    2, /* ld2_st2_general_ops  */\n+    2, /* ld3_st3_general_ops  */\n+    3 /* ld4_st4_general_ops  */\n+  },\n+  2, /* pred_ops_per_cycle  */\n+  2, /* while_pred_ops  */\n+  2, /* int_cmp_pred_ops  */\n+  1, /* fp_cmp_pred_ops  */\n+  1, /* gather_scatter_pair_general_ops  */\n+  1 /* gather_scatter_pair_pred_ops  */\n+};\n+\n+static const aarch64_vec_issue_info neoverse512tvb_vec_issue_info =\n+{\n+  &neoversev1_scalar_issue_info,\n+  &neoversev1_advsimd_issue_info,\n+  &neoverse512tvb_sve_issue_info\n+};\n+\n+static const struct cpu_vector_cost neoverse512tvb_vector_cost =\n+{\n+  1, /* scalar_int_stmt_cost  */\n+  2, /* scalar_fp_stmt_cost  */\n+  4, /* scalar_load_cost  */\n+  1, /* scalar_store_cost  */\n+  1, /* cond_taken_branch_cost  */\n+  1, /* cond_not_taken_branch_cost  */\n+  &neoversev1_advsimd_vector_cost, /* advsimd  */\n+  &neoverse512tvb_sve_vector_cost, /* sve  */\n+  &neoverse512tvb_vec_issue_info /* issue_info  */\n+};\n+\n+static const struct tune_params neoverse512tvb_tunings =\n+{\n+  &cortexa76_extra_costs,\n+  &neoversev1_addrcost_table,\n+  &generic_regmove_cost,\n+  &neoverse512tvb_vector_cost,\n+  &generic_branch_cost,\n+  &generic_approx_modes,\n+  SVE_128 | SVE_256, /* sve_width  */\n+  4, /* memmov_cost  */\n+  3, /* issue_rate  */\n+  (AARCH64_FUSE_AES_AESMC | AARCH64_FUSE_CMP_BRANCH), /* fusible_ops  */\n+  \"32:16\",\t/* function_align.  */\n+  \"4\",\t\t/* jump_align.  */\n+  \"32:16\",\t/* loop_align.  */\n+  2,\t/* int_reassoc_width.  */\n+  4,\t/* fp_reassoc_width.  */\n+  2,\t/* vec_reassoc_width.  */\n+  2,\t/* min_div_recip_mul_sf.  */\n+  2,\t/* min_div_recip_mul_df.  */\n+  0,\t/* max_case_values.  */\n+  tune_params::AUTOPREFETCHER_WEAK,\t/* autoprefetcher_model.  */\n+  (AARCH64_EXTRA_TUNE_CSE_SVE_VL_CONSTANTS\n+   | AARCH64_EXTRA_TUNE_USE_NEW_VECTOR_COSTS\n+   | AARCH64_EXTRA_TUNE_MATCHED_VECTOR_THROUGHPUT),\t/* tune_flags.  */\n+  &generic_prefetch_tune\n+};\n+\n static const struct tune_params neoversen2_tunings =\n {\n   &cortexa76_extra_costs,\n@@ -15569,10 +15699,32 @@ aarch64_adjust_body_cost_sve (const aarch64_vector_costs *costs,\n {\n   /* Estimate the minimum number of cycles per iteration needed to issue\n      non-predicate operations.  */\n-  fractional_cost sve_nonpred_cycles_per_iter\n+  fractional_cost sve_nonpred_issue_cycles_per_iter\n     = aarch64_estimate_min_cycles_per_iter (&costs->sve_ops,\n \t\t\t\t\t    issue_info->sve);\n \n+  /* Estimate the minimum number of cycles per iteration needed to rename\n+     SVE instructions.\n+\n+     ??? For now this is done inline rather than via cost tables, since it\n+     isn't clear how it should be parameterized for the general case.  */\n+  fractional_cost sve_rename_cycles_per_iter = 0;\n+  if (issue_info == &neoverse512tvb_vec_issue_info)\n+    /* + 1 for an addition.  We've already counted a general op for each\n+       store, so we don't need to account for stores separately.  The branch\n+       reads no registers and so does not need to be counted either.\n+\n+       ??? This value is very much on the pessimistic side, but seems to work\n+       pretty well in practice.  */\n+    sve_rename_cycles_per_iter\n+      = { costs->sve_ops.general_ops\n+\t  + costs->sve_ops.loads\n+\t  + costs->sve_ops.pred_ops + 1, 5 };\n+\n+  /* Combine the rename and non-predicate issue limits into a single value.  */\n+  fractional_cost sve_nonpred_cycles_per_iter\n+    = std::max (sve_nonpred_issue_cycles_per_iter, sve_rename_cycles_per_iter);\n+\n   /* Separately estimate the minimum number of cycles per iteration needed\n      to issue the predicate operations.  */\n   fractional_cost sve_pred_issue_cycles_per_iter\n@@ -15588,14 +15740,17 @@ aarch64_adjust_body_cost_sve (const aarch64_vector_costs *costs,\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"  estimated cycles per iteration = %f\\n\",\n \t\t       sve_cycles_per_iter.as_double ());\n-      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t       \"  estimated cycles per iteration for non-predicate\"\n-\t\t       \" operations = %f\\n\",\n-\t\t       sve_nonpred_cycles_per_iter.as_double ());\n       if (costs->sve_ops.pred_ops)\n-\tdump_printf_loc (MSG_NOTE, vect_location, \"  estimated cycles per\"\n-\t\t\t \" iteration for predicate operations = %d\\n\",\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"    predicate issue = %f\\n\",\n \t\t\t sve_pred_issue_cycles_per_iter.as_double ());\n+      if (costs->sve_ops.pred_ops || sve_rename_cycles_per_iter)\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"    non-predicate issue = %f\\n\",\n+\t\t\t sve_nonpred_issue_cycles_per_iter.as_double ());\n+      if (sve_rename_cycles_per_iter)\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"    rename = %f\\n\",\n+\t\t\t sve_rename_cycles_per_iter.as_double ());\n     }\n \n   /* If the scalar version of the loop could issue at least as\n@@ -15770,6 +15925,21 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n \t\t\t\t\tadvsimd_cycles_per_iter,\n \t\t\t\t\tcould_use_advsimd, orig_body_cost,\n \t\t\t\t\t&body_cost, &should_disparage);\n+\n+      if (aarch64_tune_params.vec_costs == &neoverse512tvb_vector_cost)\n+\t{\n+\t  /* Also take Neoverse V1 tuning into account, doubling the\n+\t     scalar and Advanced SIMD estimates to account for the\n+\t     doubling in SVE vector length.  */\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Neoverse V1 estimate:\\n\");\n+\t  aarch64_adjust_body_cost_sve (costs, &neoversev1_vec_issue_info,\n+\t\t\t\t\tscalar_cycles_per_iter * 2,\n+\t\t\t\t\tadvsimd_cycles_per_iter * 2,\n+\t\t\t\t\tcould_use_advsimd, orig_body_cost,\n+\t\t\t\t\t&body_cost, &should_disparage);\n+\t}\n     }\n \n   /* Decide whether to stick to latency-based costs or whether to try to"}, {"sha": "65bb9981f023481dc8c6e243e00e5aee046672d0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/048039c49b96875144f67e7789fdea54abf7710b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/048039c49b96875144f67e7789fdea54abf7710b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=048039c49b96875144f67e7789fdea54abf7710b", "patch": "@@ -18407,10 +18407,10 @@ performance of the code.  Permissible values for this option are:\n @samp{cortex-a65}, @samp{cortex-a65ae}, @samp{cortex-a34},\n @samp{cortex-a78}, @samp{cortex-a78ae}, @samp{cortex-a78c},\n @samp{ares}, @samp{exynos-m1}, @samp{emag}, @samp{falkor},\n-@samp{neoverse-e1}, @samp{neoverse-n1}, @samp{neoverse-n2},\n-@samp{neoverse-v1}, @samp{qdf24xx}, @samp{saphira},\n-@samp{phecda}, @samp{xgene1}, @samp{vulcan}, @samp{octeontx},\n-@samp{octeontx81},  @samp{octeontx83},\n+@samp{neoverse-512tvb}, @samp{neoverse-e1}, @samp{neoverse-n1},\n+@samp{neoverse-n2}, @samp{neoverse-v1}, @samp{qdf24xx},\n+@samp{saphira}, @samp{phecda}, @samp{xgene1}, @samp{vulcan},\n+@samp{octeontx}, @samp{octeontx81},  @samp{octeontx83},\n @samp{octeontx2}, @samp{octeontx2t98}, @samp{octeontx2t96}\n @samp{octeontx2t93}, @samp{octeontx2f95}, @samp{octeontx2f95n},\n @samp{octeontx2f95mm},\n@@ -18428,6 +18428,15 @@ The values @samp{cortex-a57.cortex-a53}, @samp{cortex-a72.cortex-a53},\n @samp{cortex-a75.cortex-a55}, @samp{cortex-a76.cortex-a55} specify that GCC\n should tune for a big.LITTLE system.\n \n+The value @samp{neoverse-512tvb} specifies that GCC should tune\n+for Neoverse cores that (a) implement SVE and (b) have a total vector\n+bandwidth of 512 bits per cycle.  In other words, the option tells GCC to\n+tune for Neoverse cores that can execute 4 128-bit Advanced SIMD arithmetic\n+instructions a cycle and that can execute an equivalent number of SVE\n+arithmetic instructions per cycle (2 for 256-bit SVE, 4 for 128-bit SVE).\n+This is more general than tuning for a specific core like Neoverse V1\n+but is more specific than the default tuning described below.\n+\n Additionally on native AArch64 GNU/Linux systems the value\n @samp{native} tunes performance to the host system.  This option has no effect\n if the compiler is unable to recognize the processor of the host system.\n@@ -18457,6 +18466,16 @@ by @option{-mtune}).  Where this option is used in conjunction\n with @option{-march} or @option{-mtune}, those options take precedence\n over the appropriate part of this option.\n \n+@option{-mcpu=neoverse-512tvb} is special in that it does not refer\n+to a specific core, but instead refers to all Neoverse cores that\n+(a) implement SVE and (b) have a total vector bandwidth of 512 bits\n+a cycle.  Unless overridden by @option{-march},\n+@option{-mcpu=neoverse-512tvb} generates code that can run on a\n+Neoverse V1 core, since Neoverse V1 is the first Neoverse core with\n+these properties.  Unless overridden by @option{-mtune},\n+@option{-mcpu=neoverse-512tvb} tunes code in the same way as for\n+@option{-mtune=neoverse-512tvb}.\n+\n @item -moverride=@var{string}\n @opindex moverride\n Override tuning decisions made by the back-end in response to a"}]}