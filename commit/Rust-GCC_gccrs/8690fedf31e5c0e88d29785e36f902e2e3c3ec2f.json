{"sha": "8690fedf31e5c0e88d29785e36f902e2e3c3ec2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY5MGZlZGYzMWU1YzBlODhkMjk3ODVlMzZmOTAyZTJlM2MzZWMyZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-09T16:20:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-09T16:20:56Z"}, "message": "(cmphf): Addd Base Reg with Offset address mode (LB,STB,..)\n\n(cmphf): Addd Base Reg with Offset address mode (LB,STB,..)\n(movqi,movhi,movhf,addqi3,addhf3,subqi3,subhf3,mulqihi3): Likewise.\n(mulhf3,divhf3,andqi3,iorqi3): Likewise.\n(define_peephole): Remove the Base mode peepholes. Replace the\nspecial addqi define_insn for \"LIM Ra,sym,Rb\" by a define_peephole.\n(ashlqi3): Took out futile 0th alternative.\n(lshrqi3, lshrhi3, ashrqi3, ahsrhi3): Correct case of non-constant\nshift count.\n\nFrom-SVN: r10575", "tree": {"sha": "7aa82e1034f31f2013b50743a7dae0ad56556bce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7aa82e1034f31f2013b50743a7dae0ad56556bce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8690fedf31e5c0e88d29785e36f902e2e3c3ec2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8690fedf31e5c0e88d29785e36f902e2e3c3ec2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8690fedf31e5c0e88d29785e36f902e2e3c3ec2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8690fedf31e5c0e88d29785e36f902e2e3c3ec2f/comments", "author": null, "committer": null, "parents": [{"sha": "67ca0b229bc378fe7b434b1a25c493f9562c9b2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ca0b229bc378fe7b434b1a25c493f9562c9b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67ca0b229bc378fe7b434b1a25c493f9562c9b2c"}], "stats": {"total": 334, "additions": 181, "deletions": 153}, "files": [{"sha": "62332dcffc49efaadb14399447dadb30e2a1d161", "filename": "gcc/config/1750a/1750a.md", "status": "modified", "additions": 181, "deletions": 153, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8690fedf31e5c0e88d29785e36f902e2e3c3ec2f/gcc%2Fconfig%2F1750a%2F1750a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8690fedf31e5c0e88d29785e36f902e2e3c3ec2f/gcc%2Fconfig%2F1750a%2F1750a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.md?ref=8690fedf31e5c0e88d29785e36f902e2e3c3ec2f", "patch": "@@ -234,11 +234,12 @@\n \n (define_insn \"cmphf\"\n  [(set (cc0)\n-       (compare (match_operand:HF 0 \"general_operand\" \"r,r\")\n-                (match_operand:HF 1 \"general_operand\" \"r,m\")))]\n+       (compare (match_operand:HF 0 \"general_operand\" \"r,z,r\")\n+                (match_operand:HF 1 \"general_operand\" \"r,Q,m\")))]\n  \"\"\n  \"@\n    fcr r%0,r%1\n+   fcb %Q1\n    fc  r%0,%1 \")\n \n (define_insn \"cmptqf\"\n@@ -367,8 +368,8 @@\n ;; 16-bit moves\n \n (define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,r,r,m,m\")\n-        (match_operand:QI 1 \"general_operand\"  \"O,I,J,M,i,r,m,r,K\"))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,r,t,r,Q,m,m\")\n+        (match_operand:QI 1 \"general_operand\"  \"O,I,J,M,i,r,Q,m,t,r,K\"))]\n   \"\"\n   \"@\n      xorr r%0,r%0\n@@ -377,7 +378,9 @@\n      lim  r%0,%1  ; 'M' constraint\n      lim  r%0,%1  ; 'i' constraint\n      lr   r%0,r%1\n+     lb   %Q1\n      l    r%0,%1\n+     stb  %Q0\n      st   r%1,%0\n      stc  %1,%0   \")\n \n@@ -418,13 +421,15 @@\n   \")\n \n (define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,m\")\n-        (match_operand:HI 1 \"general_operand\"  \"r,m,r\"))]\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,z,r,Q,m\")\n+        (match_operand:HI 1 \"general_operand\"  \"r,Q,m,z,r\"))]\n   \"\"\n   \"@\n-    dlr r%0,r%1\n-    dl  r%0,%1\n-    dst r%1,%0 \")\n+    dlr  r%0,r%1\n+    dlb  %Q1\n+    dl   r%0,%1\n+    dstb %Q0\n+    dst  r%1,%0 \")\n \n \n ;; Single-Float moves are *same* as HImode moves:\n@@ -440,13 +445,15 @@\n ;    dst r%1,%0 \")\n \n (define_insn \"movhf\"\n-  [(set (match_operand:HF 0 \"general_operand\" \"=r,r,m\")\n-        (match_operand:HF 1 \"general_operand\"  \"r,m,r\"))]\n+  [(set (match_operand:HF 0 \"general_operand\" \"=r,z,r,Q,m\")\n+        (match_operand:HF 1 \"general_operand\"  \"r,Q,m,z,r\"))]\n   \"\"\n   \"@\n-    dlr r%0,r%1\n-    dl  r%0,%1\n-    dst r%1,%0 \")\n+    dlr  r%0,r%1\n+    dlb  %Q1\n+    dl   r%0,%1\n+    dstb %Q0\n+    dst  r%1,%0 \")\n \n \n ;; Longfloat moves\n@@ -475,19 +482,10 @@\n \n ;; single integer\n \n-;; Use \"LIM Ra,sym,Rb\" for adding a symbol value to a register and\n-;; transferring the result to a different register.\n-;(define_insn \"\"\n-;  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-;        (plus:QI (match_operand:QI 1 \"register_operand\" \"b\")\n-;                 (match_operand:QI 2 \"immediate_operand\"  \"i\")))]\n-;   \"REGNO(operands[0]) != REGNO(operands[1])\"\n-;   \"lim r%0,%2,r%1 ;md special addqi\")\n-\n (define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,r,m,m\")\n-        (plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0,0,0,0\")\n-                 (match_operand:QI 2 \"general_operand\"  \"I,J,i,r,m,I,J\")))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,t,r,m,m\")\n+        (plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0,0,0,0,0\")\n+                 (match_operand:QI 2 \"general_operand\"  \"I,J,i,r,Q,m,I,J\")))]\n   \"\"\n   \"*\n     switch (which_alternative)\n@@ -504,10 +502,12 @@\n         case 3:\n           return \\\"ar r%0,r%2\\\";\n         case 4:\n-          return \\\"a r%0,%2\\\";\n+          return \\\"ab %Q2\\\";\n         case 5:\n-          return \\\"incm %2,%0\\\";\n+          return \\\"a r%0,%2\\\";\n         case 6:\n+          return \\\"incm %2,%0\\\";\n+        case 7:\n           return \\\"decm %J2,%0\\\";\n       } \")\n \n@@ -522,36 +522,38 @@\n     da  r%0,%2 \")\n \n (define_insn \"addhf3\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (plus:HF (match_operand:HF 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:HF 2 \"general_operand\" \"m,r\")))]\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,z,r\")\n+        (plus:HF (match_operand:HF 1 \"register_operand\" \"%0,0,0\")\n+                 (match_operand:HF 2 \"general_operand\" \"r,Q,m\")))]\n   \"\"\n   \"@\n-    fa  r%0,%2\n-    far r%0,r%2 \")\n+    far r%0,r%2\n+    fab %Q2\n+    fa  r%0,%2 \")\n \n (define_insn \"addtqf3\"\n   [(set (match_operand:TQF 0 \"register_operand\" \"=r,r\")\n         (plus:TQF (match_operand:TQF 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:TQF 2 \"general_operand\" \"m,r\")))]\n+                 (match_operand:TQF 2 \"general_operand\" \"r,m\")))]\n   \"\"\n   \"@\n-    efa  r%0,%2\n-    efar r%0,r%2 \")\n+    efar r%0,r%2\n+    efa  r%0,%2 \")\n \n \n ;; subtract instructions\n \n ;; single integer\n (define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,r,m\")\n-        (minus:QI (match_operand:QI 1 \"general_operand\" \"0,0,0,0,0\")\n-                  (match_operand:QI 2 \"general_operand\"  \"I,i,r,m,I\")))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,t,r,m\")\n+        (minus:QI (match_operand:QI 1 \"general_operand\" \"0,0,0,0,0,0\")\n+                  (match_operand:QI 2 \"general_operand\"  \"I,i,r,Q,m,I\")))]\n   \"\"\n   \"@\n     sisp r%0,%2\n     sim  r%0,%2\n     sr   r%0,r%2\n+    sbb  %Q2\n     s    r%0,%2\n     decm %2,%0 \")\n \n@@ -566,12 +568,13 @@\n     ds  r%0,%2 \")\n \n (define_insn \"subhf3\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (minus:HF (match_operand:HF 1 \"register_operand\" \"0,0\")\n-                  (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,z,r\")\n+        (minus:HF (match_operand:HF 1 \"register_operand\" \"0,0,0\")\n+                  (match_operand:HF 2 \"general_operand\" \"r,Q,m\")))]\n   \"\"\n   \"@\n     fsr r%0,r%2\n+    fsb %Q2\n     fs  r%0,%2 \")\n \n (define_insn \"subtqf3\"\n@@ -601,13 +604,14 @@\n \n ; 32-bit product\n (define_insn \"mulqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n-        (mult:HI (match_operand:QI 1 \"register_operand\" \"%0,0,0\")\n-                 (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,t,r\")\n+        (mult:HI (match_operand:QI 1 \"register_operand\" \"%0,0,0,0\")\n+                 (match_operand:QI 2 \"general_operand\" \"M,r,Q,m\")))]\n   \"\"\n   \"@\n     mim r%0,%1\n     mr  r%0,r%2\n+    mb  %Q2\n     m   r%0,%2 \")\n \n (define_insn \"mulhi3\"\n@@ -622,12 +626,13 @@\n ; not available on 1750: \"umulhi3\",\"umulhisi3\",\"umulsi3\" (unsigned multiply's)\n \n (define_insn \"mulhf3\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (mult:HF (match_operand:HF 1 \"register_operand\" \"%0,0\")\n-                 (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,z,r\")\n+        (mult:HF (match_operand:HF 1 \"register_operand\" \"%0,0,0\")\n+                 (match_operand:HF 2 \"general_operand\" \"r,Q,m\")))]\n   \"\"\n   \"@\n     fmr r%0,r%2\n+    fmb %Q2\n     fm  r%0,%2 \")\n \n (define_insn \"multqf3\"\n@@ -694,12 +699,13 @@\n     dd  r%0,%2 \")\n \n (define_insn \"divhf3\"\n-  [(set (match_operand:HF 0 \"register_operand\" \"=r,r\")\n-        (div:HF (match_operand:HF 1 \"register_operand\" \"0,0\")\n-                (match_operand:HF 2 \"general_operand\" \"r,m\")))]\n+  [(set (match_operand:HF 0 \"register_operand\" \"=r,z,r\")\n+        (div:HF (match_operand:HF 1 \"register_operand\" \"0,0,0\")\n+                (match_operand:HF 2 \"general_operand\" \"r,Q,m\")))]\n   \"\"\n   \"@\n     fdr r%0,r%2\n+    fdb %Q2\n     fd  r%0,%2 \")\n \n (define_insn \"divtqf3\"\n@@ -773,13 +779,14 @@\n ;; AND\n \n (define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r\")\n-        (and:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0\")\n-                (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,t,r\")\n+        (and:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0\")\n+                (match_operand:QI 2 \"general_operand\" \"M,r,Q,m\")))]\n   \"\"\n   \"@\n     andm r%0,%2\n     andr r%0,r%2\n+    andb %Q2\n     and  r%0,%2 \")\n \n ; This sets incorrect condition codes. See notice_update_cc()\n@@ -793,13 +800,14 @@\n ;; OR\n \n (define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r\")\n-        (ior:QI  (match_operand:QI 1 \"general_operand\" \"%0,0,0\")\n-                (match_operand:QI 2 \"general_operand\" \"M,r,m\")))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,t,r\")\n+        (ior:QI  (match_operand:QI 1 \"general_operand\" \"%0,0,0,0\")\n+                 (match_operand:QI 2 \"general_operand\" \"M,r,Q,m\")))]\n   \"\"\n   \"@\n     orim r%0,%2\n     orr  r%0,r%2\n+    orb  %Q2\n     or   r%0,%2 \")\n \n ; This sets incorrect condition codes. See notice_update_cc()\n@@ -870,12 +878,11 @@\n \n ; (What to the 1750 is logical-shift-left, GCC likes to call \"arithmetic\")\n (define_insn \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n-        (ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0,0\")\n-                   (match_operand:QI 2 \"general_operand\" \"O,I,r\")))]\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+        (ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+                   (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n   \"\"\n   \"@\n-    ; optimized away an SLL r%0,0\n     sll r%0,%2\n     slr r%0,r%2 \")\n \n@@ -888,41 +895,113 @@\n      dsll r%0,%2\n      dslr r%0,r%2 \")\n \n-(define_insn \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-        (lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n-                     (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+;; Right shift by a variable shiftcount works by negating the shift count,\n+;; then emitting a right shift with the shift count negated.  This means\n+;; that all actual shift counts in the RTL will be positive.  This \n+;; prevents converting shifts to ZERO_EXTRACTs with negative positions,\n+;; which isn't valid.\n+(define_expand \"lshrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"g\")))]\n   \"\"\n-  \"@\n-    srl r%0,%2\n-    neg r%2,r%2\\;slr    r%0,r%2 \")\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+}\")\n \n-(define_insn \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-                     (match_operand:QI 2 \"general_operand\" \"L,r\")))]\n-  \"\"                        ; the 'L' constraint is a slight imprecise...\n-  \"@\n-    dsrl r%0,%2\n-    neg  r%2,r%2\\;dslr   r%0,r%2 \")\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"I\")))]\n+  \"\"\n+  \"srl r%0,%1\")\n \n-(define_insn \"ashrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-        (ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n-                     (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n   \"\"\n-  \"@\n-     sra r%0,%2\n-     neg r%2,r%2\\;sar    r%0,r%2 \")\n+  \"slr r%0,r%2 \")\n \n-(define_insn \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-        (ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-                     (match_operand:QI 2 \"general_operand\" \"I,r\")))]\n+;; Same thing for HImode.\n+(define_expand \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"g\")))]\n   \"\"\n-  \"@\n-     dsra r%0,%2\n-     neg  r%2,r%2\\;dsar   r%0,r%2 \")\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"L\")))]\n+  \"\"\n+  \"dsrl r%0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"dslr r%0,r%2 \")\n+\n+;; Same applies for arithmetic shift right.\n+(define_expand \"ashrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"I\")))]\n+  \"\"\n+  \"sra r%0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"sar r%0,r%2 \")\n+\n+;; HImode arithmetic shift right.\n+(define_expand \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, QImode, negate_rtx (QImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"immediate_operand\" \"L\")))]\n+  \"\"\n+  \"dsra r%0,%1\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (neg:QI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+  \"\"\n+  \"dsar r%0,r%2 \")\n \n \n ;; rotate instructions\n@@ -969,7 +1048,7 @@\n ;********************\n \n ;; Bit field instructions, general cases.\n-;; \"o,d\" constraint causes a nonoffsettable memref to match the \"o\"\n+;; \"o,d\" constraint causes a nonoffsetable memref to match the \"o\"\n ;; so that its address is reloaded.\n \n ;; (define_insn \"extv\" ...\n@@ -1275,77 +1354,26 @@\n   \"INTVAL(operands[2]) == -1\"\n   \"soj r%0,%3\")\n \n-;; Load Base\n+;; Combine a Load Register with subsequent increment/decrement into a LIM\n (define_peephole \n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (mem:QI (plus:QI (match_operand:QI 1 \"register_operand\" \"x\")\n-                         (match_operand:QI 2 \"immediate_operand\" \"L\"))))\n-   ]\n-  \"REGNO(operands[0]) == 2 && REGNO(operands[1]) >= 12\n-    && INTVAL(operands[2]) <= 255\"\n-  \"lb r%1,%2\")\n-\n-;; Double Load Base\n-(define_peephole \n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (mem:HI (plus:QI (match_operand:QI 1 \"register_operand\" \"x\")\n-                         (match_operand:QI 2 \"immediate_operand\" \"L\"))))\n-   ]\n-  \"REGNO(operands[0]) == 0 && REGNO(operands[1]) >= 12\n-    && INTVAL(operands[2]) <= 255\"\n-  \"dlb r%1,%2\")\n-\n-(define_peephole \n-  [(set (match_operand:HF 0 \"register_operand\" \"=r\")\n-        (mem:HF (plus:QI (match_operand:QI 1 \"register_operand\" \"x\")\n-                         (match_operand:QI 2 \"immediate_operand\" \"L\"))))\n-   ]\n-  \"REGNO(operands[0]) == 0 && REGNO(operands[1]) >= 12\n-    && INTVAL(operands[2]) <= 255\"\n-  \"dlb r%1,%2\")\n-\n-;; Store Base\n-(define_peephole \n-  [(set (mem:QI (plus:QI (match_operand:QI 0 \"register_operand\" \"x\")\n-                         (match_operand:QI 1 \"immediate_operand\" \"L\")))\n-\t(match_operand:QI 2 \"register_operand\" \"r\"))\n-   ]\n-  \"REGNO(operands[2]) == 2 && REGNO(operands[0]) >= 12\n-    && INTVAL(operands[1]) <= 255\"\n-  \"stb r%0,%1\")\n-\n-;; Double Store Base\n-(define_peephole \n-  [(set (mem:HI (plus:QI (match_operand:QI 0 \"register_operand\" \"x\")\n-                         (match_operand:QI 1 \"immediate_operand\" \"L\")))\n-\t(match_operand:HI 2 \"register_operand\" \"r\"))\n-   ]\n-  \"REGNO(operands[2]) == 0 && REGNO(operands[0]) >= 12\n-    && INTVAL(operands[1]) <= 255\"\n-  \"dstb r%0,%1\")\n-\n-(define_peephole \n-  [(set (mem:HF (plus:QI (match_operand:QI 0 \"register_operand\" \"x\")\n-                         (match_operand:QI 1 \"immediate_operand\" \"L\")))\n-\t(match_operand:HF 2 \"register_operand\" \"r\"))\n-   ]\n-  \"REGNO(operands[2]) == 0 && REGNO(operands[0]) >= 12\n-    && INTVAL(operands[1]) <= 255\"\n-  \"dstb r%0,%1\")\n+        (match_operand:QI 1 \"register_operand\" \"b\"))\n+   (set (match_dup 0)\n+        (plus:QI (match_dup 0)\n+                 (match_operand:QI 2 \"immediate_operand\" \"i\")))]\n+  \"REGNO(operands[1]) > 0\"\n+  \"lim r%0,%2,r%1  ; LR,inc/dec peephole\")\n \n ;; Eliminate the redundant load in a store/load sequence\n (define_peephole \n   [(set (mem:QI (plus:QI (match_operand:QI 0 \"register_operand\" \"r\")\n-                         (match_operand:QI 1 \"immediate_operand\" \"i\")))\n+\t\t\t  (match_operand:QI 1 \"immediate_operand\" \"i\")))\n \t(match_operand:QI 2 \"register_operand\" \"r\"))\n    (set (match_operand:QI 3 \"register_operand\" \"=r\")\n-\t(mem:QI (plus:QI (match_operand:QI 4 \"register_operand\" \"r\")\n-\t\t\t (match_operand:QI 5 \"immediate_operand\" \"i\"))))\n+\t(mem:QI (plus:QI (match_dup 0)\n+\t\t\t (match_dup 1))))\n    ]\n-  \"REGNO(operands[2]) == REGNO(operands[3]) &&\n-   REGNO(operands[0]) == REGNO(operands[4]) &&\n-   INTVAL(operands[1]) == INTVAL(operands[5])\"\n+  \"REGNO(operands[2]) == REGNO(operands[3])\"\n   \"st r%2,%1,r%0  ; eliminated previous redundant load\")\n \n ;;;End.\n-"}]}