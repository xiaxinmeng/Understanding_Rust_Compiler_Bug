{"sha": "e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEyOWQ5M2E3YjFlZGE2ZWU3MzRmZmY3YWExZjhiYzYwZTViYTdlMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2004-01-23T21:05:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2004-01-23T21:05:21Z"}, "message": "re PR target/1532 (-O3 generates (obviously) redundant tests and jumps)\n\n\tPR gcc/1532\n\t* cse.c (cse_change_cc_mode): New static function.\n\t(cse_change_cc_mode_insns, cse_cc_succs): Likewise.\n\t(cse_condition_code_reg): New function.\n\t* rtl.h (cse_condition_code_reg): Declare.\n\t* toplev.c (rest_of_handle_cse2): Call cse_condition_code_reg.\n\t* target.h (struct gcc_target): Add fixed_condition_code_regs and\n\tcc_modes_compatible.\n\t* target-def.h (TARGET_FIXED_CONDITION_CODE_REGS): Define.\n\t(TARGET_CC_MODES_COMPATIBLE): Define.\n\t(TARGET_INITIALIZER): Add new initializers.\n\t* targhooks.c (default_cc_modes_compatible): New function.\n\t* targhooks.c (default_cc_modes_compatible): Declare.\n\t* hooks.c (hook_bool_intp_intp_false): New function.\n\t* hooks.h (hook_bool_intp_intp_false): Declare.\n\t* config/i386/i386.c (TARGET_FIXED_CONDITION_CODE_REGS): Define.\n\t(TARGET_CC_MODES_COMPATIBLE): Define.\n\t(ix86_fixed_condition_code_regs): New static function.\n\t(ix86_cc_modes_compatible): Likewise.\n\t* doc/tm.texi (Condition Code): Document new hooks.\n\nFrom-SVN: r76454", "tree": {"sha": "1957c990b77f48c80e149663c064a9f71d8e783a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1957c990b77f48c80e149663c064a9f71d8e783a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/comments", "author": null, "committer": null, "parents": [{"sha": "f6c930a38a5633c4880f572feaddfce14b45951b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6c930a38a5633c4880f572feaddfce14b45951b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6c930a38a5633c4880f572feaddfce14b45951b"}], "stats": {"total": 493, "additions": 488, "deletions": 5}, "files": [{"sha": "48a9f84f99c5f0eada3c67c906a86bd96494e767", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -1,3 +1,26 @@\n+2004-01-23  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\tPR gcc/1532\n+\t* cse.c (cse_change_cc_mode): New static function.\n+\t(cse_change_cc_mode_insns, cse_cc_succs): Likewise.\n+\t(cse_condition_code_reg): New function.\n+\t* rtl.h (cse_condition_code_reg): Declare.\n+\t* toplev.c (rest_of_handle_cse2): Call cse_condition_code_reg.\n+\t* target.h (struct gcc_target): Add fixed_condition_code_regs and\n+\tcc_modes_compatible.\n+\t* target-def.h (TARGET_FIXED_CONDITION_CODE_REGS): Define.\n+\t(TARGET_CC_MODES_COMPATIBLE): Define.\n+\t(TARGET_INITIALIZER): Add new initializers.\n+\t* targhooks.c (default_cc_modes_compatible): New function.\n+\t* targhooks.c (default_cc_modes_compatible): Declare.\n+\t* hooks.c (hook_bool_intp_intp_false): New function.\n+\t* hooks.h (hook_bool_intp_intp_false): Declare.\n+\t* config/i386/i386.c (TARGET_FIXED_CONDITION_CODE_REGS): Define.\n+\t(TARGET_CC_MODES_COMPATIBLE): Define.\n+\t(ix86_fixed_condition_code_regs): New static function.\n+\t(ix86_cc_modes_compatible): Likewise.\n+\t* doc/tm.texi (Condition Code): Document new hooks.\n+\n 2004-01-23  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* fixinc/inclhack.def (bad_lval): Renamed to ..."}, {"sha": "79102cfefdb9149b648d54a6582d2313d015bcfe", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used for code generation on IA-32.\n    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003 Free Software Foundation, Inc.\n+   2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -793,6 +793,9 @@ static rtx maybe_get_pool_constant (rtx);\n static rtx ix86_expand_int_compare (enum rtx_code, rtx, rtx);\n static enum rtx_code ix86_prepare_fp_compare_args (enum rtx_code, rtx *,\n \t\t\t\t\t\t   rtx *);\n+static bool ix86_fixed_condition_code_regs (unsigned int *, unsigned int *);\n+static enum machine_mode ix86_cc_modes_compatible (enum machine_mode,\n+\t\t\t\t\t\t   enum machine_mode);\n static rtx get_thread_pointer (int);\n static rtx legitimize_tls_address (rtx, enum tls_model, int);\n static void get_pc_thunk_name (char [32], unsigned int);\n@@ -1010,6 +1013,11 @@ static void init_ext_80387_constants (void);\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST ix86_address_cost\n \n+#undef TARGET_FIXED_CONDITION_CODE_REGS\n+#define TARGET_FIXED_CONDITION_CODE_REGS ix86_fixed_condition_code_regs\n+#undef TARGET_CC_MODES_COMPATIBLE\n+#define TARGET_CC_MODES_COMPATIBLE ix86_cc_modes_compatible\n+\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG ix86_reorg\n \n@@ -8723,6 +8731,64 @@ ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n     }\n }\n \n+/* Return the fixed registers used for condition codes.  */\n+\n+static bool\n+ix86_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n+{\n+  *p1 = FLAGS_REG;\n+  *p2 = FPSR_REG;\n+  return true;\n+}\n+\n+/* If two condition code modes are compatible, return a condition code\n+   mode which is compatible with both.  Otherwise, return\n+   VOIDmode.  */\n+\n+static enum machine_mode\n+ix86_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n+{\n+  if (m1 == m2)\n+    return m1;\n+\n+  if (GET_MODE_CLASS (m1) != MODE_CC || GET_MODE_CLASS (m2) != MODE_CC)\n+    return VOIDmode;\n+\n+  if ((m1 == CCGCmode && m2 == CCGOCmode)\n+      || (m1 == CCGOCmode && m2 == CCGCmode))\n+    return CCGCmode;\n+\n+  switch (m1)\n+    {\n+    default:\n+      abort ();\n+\n+    case CCmode:\n+    case CCGCmode:\n+    case CCGOCmode:\n+    case CCNOmode:\n+    case CCZmode:\n+      switch (m2)\n+\t{\n+\tdefault:\n+\t  return VOIDmode;\n+\n+\tcase CCmode:\n+\tcase CCGCmode:\n+\tcase CCGOCmode:\n+\tcase CCNOmode:\n+\tcase CCZmode:\n+\t  return CCmode;\n+\t}\n+\n+    case CCFPmode:\n+    case CCFPUmode:\n+      /* These are only compatible with themselves, which we already\n+\t checked above.  */\n+      return VOIDmode;\n+    }\n+}\n+\n /* Return true if we should use an FCOMI instruction for this fp comparison.  */\n \n int"}, {"sha": "1ec01f9793a782c40083f019d9e8c9de07a2aa2c", "filename": "gcc/cse.c", "status": "modified", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -658,6 +658,9 @@ static void flush_hash_table (void);\n static bool insn_live_p (rtx, int *);\n static bool set_live_p (rtx, rtx, int *);\n static bool dead_libcall_p (rtx, int *);\n+static int cse_change_cc_mode (rtx *, void *);\n+static void cse_change_cc_mode_insns (rtx, rtx, rtx);\n+static enum machine_mode cse_cc_succs (basic_block, rtx, rtx, bool);\n \f\n /* Nonzero if X has the form (PLUS frame-pointer integer).  We check for\n    virtual regs here because the simplify_*_operation routines are called\n@@ -7665,3 +7668,316 @@ delete_trivially_dead_insns (rtx insns, int nreg)\n   timevar_pop (TV_DELETE_TRIVIALLY_DEAD);\n   return ndead;\n }\n+\n+/* This function is called via for_each_rtx.  The argument, NEWREG, is\n+   a condition code register with the desired mode.  If we are looking\n+   at the same register in a different mode, replace it with\n+   NEWREG.  */\n+\n+static int\n+cse_change_cc_mode (rtx *loc, void *data)\n+{\n+  rtx newreg = (rtx) data;\n+\n+  if (*loc\n+      && GET_CODE (*loc) == REG\n+      && REGNO (*loc) == REGNO (newreg)\n+      && GET_MODE (*loc) != GET_MODE (newreg))\n+    {\n+      *loc = newreg;\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+/* Change the mode of any reference to the register REGNO (NEWREG) to\n+   GET_MODE (NEWREG), starting at START.  Stop before END.  Stop at\n+   any instruction after START which modifies NEWREG.  */\n+\n+static void\n+cse_change_cc_mode_insns (rtx start, rtx end, rtx newreg)\n+{\n+  rtx insn;\n+\n+  for (insn = start; insn != end; insn = NEXT_INSN (insn))\n+    {\n+      if (! INSN_P (insn))\n+\tcontinue;\n+\n+      if (insn != start && reg_set_p (newreg, insn))\n+\treturn;\n+\n+      for_each_rtx (&PATTERN (insn), cse_change_cc_mode, newreg);\n+      for_each_rtx (&REG_NOTES (insn), cse_change_cc_mode, newreg);\n+    }\n+}\n+\n+/* BB is a basic block which finishes with CC_REG as a condition code\n+   register which is set to CC_SRC.  Look through the successors of BB\n+   to find blocks which have a single predecessor (i.e., this one),\n+   and look through those blocks for an assignment to CC_REG which is\n+   equivalent to CC_SRC.  CAN_CHANGE_MODE indicates whether we are\n+   permitted to change the mode of CC_SRC to a compatible mode.  This\n+   returns VOIDmode if no equivalent assignments were found.\n+   Otherwise it returns the mode which CC_SRC should wind up with.\n+\n+   The main complexity in this function is handling the mode issues.\n+   We may have more than one duplicate which we can eliminate, and we\n+   try to find a mode which will work for multiple duplicates.  */\n+\n+static enum machine_mode\n+cse_cc_succs (basic_block bb, rtx cc_reg, rtx cc_src, bool can_change_mode)\n+{\n+  bool found_equiv;\n+  enum machine_mode mode;\n+  unsigned int insn_count;\n+  edge e;\n+  rtx insns[2];\n+  enum machine_mode modes[2];\n+  rtx last_insns[2];\n+  unsigned int i;\n+  rtx newreg;\n+\n+  /* We expect to have two successors.  Look at both before picking\n+     the final mode for the comparison.  If we have more successors\n+     (i.e., some sort of table jump, although that seems unlikely),\n+     then we require all beyond the first two to use the same\n+     mode.  */\n+\n+  found_equiv = false;\n+  mode = GET_MODE (cc_src);\n+  insn_count = 0;\n+  for (e = bb->succ; e; e = e->succ_next)\n+    {\n+      rtx insn;\n+      rtx end;\n+\n+      if (e->flags & EDGE_COMPLEX)\n+\tcontinue;\n+\n+      if (! e->dest->pred\n+\t  || e->dest->pred->pred_next\n+\t  || e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      end = NEXT_INSN (BB_END (e->dest));\n+      for (insn = BB_HEAD (e->dest); insn != end; insn = NEXT_INSN (insn))\n+\t{\n+\t  rtx set;\n+\n+\t  if (! INSN_P (insn))\n+\t    continue;\n+\n+\t  /* If CC_SRC is modified, we have to stop looking for\n+\t     something which uses it.  */\n+\t  if (modified_in_p (cc_src, insn))\n+\t    break;\n+\n+\t  /* Check whether INSN sets CC_REG to CC_SRC.  */\n+\t  set = single_set (insn);\n+\t  if (set\n+\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REGNO (SET_DEST (set)) == REGNO (cc_reg))\n+\t    {\n+\t      bool found;\n+\t      enum machine_mode set_mode;\n+\t      enum machine_mode comp_mode;\n+\n+\t      found = false;\n+\t      set_mode = GET_MODE (SET_SRC (set));\n+\t      comp_mode = set_mode;\n+\t      if (rtx_equal_p (cc_src, SET_SRC (set)))\n+\t\tfound = true;\n+\t      else if (GET_CODE (cc_src) == COMPARE\n+\t\t       && GET_CODE (SET_SRC (set)) == COMPARE\n+\t\t       && GET_MODE (cc_src) != set_mode\n+\t\t       && rtx_equal_p (XEXP (cc_src, 0),\n+\t\t\t\t       XEXP (SET_SRC (set), 0))\n+\t\t       && rtx_equal_p (XEXP (cc_src, 1),\n+\t\t\t\t       XEXP (SET_SRC (set), 1)))\n+\t\t\t   \n+\t\t{\n+\t\t  comp_mode = (*targetm.cc_modes_compatible) (mode, set_mode);\n+\t\t  if (comp_mode != VOIDmode\n+\t\t      && (can_change_mode || comp_mode == mode))\n+\t\t    found = true;\n+\t\t}\n+\n+\t      if (found)\n+\t\t{\n+\t\t  found_equiv = true;\n+\t\t  if (insn_count < sizeof insns / sizeof insn[0])\n+\t\t    {\n+\t\t      insns[insn_count] = insn;\n+\t\t      modes[insn_count] = set_mode;\n+\t\t      last_insns[insn_count] = end;\n+\t\t      ++insn_count;\n+\n+\t\t      /* Sanity check.  */\n+\t\t      if (! can_change_mode && mode != comp_mode)\n+\t\t\tabort ();\n+\n+\t\t      mode = comp_mode;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (set_mode != mode)\n+\t\t\tbreak;\n+\t\t      /* INSN sets CC_REG to a value equal to CC_SRC\n+\t\t\t with the right mode.  We can simply delete\n+\t\t\t it.  */\n+\t\t      delete_insn (insn);\n+\t\t    }\n+\n+\t\t  /* We found an instruction to delete.  Keep looking,\n+\t\t     in the hopes of finding a three-way jump.  */\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* We found an instruction which sets the condition\n+\t\t code, so don't look any farther.  */\n+\t      break;\n+\t    }\n+\n+\t  /* If INSN sets CC_REG in some other way, don't look any\n+\t     farther.  */\n+\t  if (reg_set_p (cc_reg, insn))\n+\t    break;\n+\t}\n+\n+      /* If we fell off the bottom of the block, we can keep looking\n+\t through successors.  We pass CAN_CHANGE_MODE as false because\n+\t we aren't prepared to handle compatibility between the\n+\t further blocks and this block.  */\n+      if (insn == end)\n+\t{\n+\t  if (cse_cc_succs (e->dest, cc_reg, cc_src, false) != VOIDmode)\n+\t    found_equiv = true;\n+\t}\n+    }\n+\n+  if (! found_equiv)\n+    return VOIDmode;\n+\n+  /* Now INSN_COUNT is the number of instructions we found which set\n+     CC_REG to a value equivalent to CC_SRC.  The instructions are in\n+     INSNS.  The modes used by those instructions are in MODES.  */\n+\n+  newreg = NULL_RTX;\n+  for (i = 0; i < insn_count; ++i)\n+    {\n+      if (modes[i] != mode)\n+\t{\n+\t  /* We need to change the mode of CC_REG in INSNS[i] and\n+\t     subsequent instructions.  */\n+\t  if (! newreg)\n+\t    {\n+\t      if (GET_MODE (cc_reg) == mode)\n+\t\tnewreg = cc_reg;\n+\t      else\n+\t\tnewreg = gen_rtx_REG (mode, REGNO (cc_reg));\n+\t    }\n+\t  cse_change_cc_mode_insns (NEXT_INSN (insns[i]), last_insns[i],\n+\t\t\t\t    newreg);\n+\t}\n+\n+      delete_insn (insns[i]);\n+    }\n+\n+  return mode;\n+}\n+\n+/* If we have a fixed condition code register (or two), walk through\n+   the instructions and try to eliminate duplicate assignments.  */\n+\n+void\n+cse_condition_code_reg (void)\n+{\n+  unsigned int cc_regno_1;\n+  unsigned int cc_regno_2;\n+  rtx cc_reg_1;\n+  rtx cc_reg_2;\n+  basic_block bb;\n+\n+  if (! (*targetm.fixed_condition_code_regs) (&cc_regno_1, &cc_regno_2))\n+    return;\n+\n+  cc_reg_1 = gen_rtx_REG (CCmode, cc_regno_1);\n+  if (cc_regno_2 != INVALID_REGNUM)\n+    cc_reg_2 = gen_rtx_REG (CCmode, cc_regno_2);\n+  else\n+    cc_reg_2 = NULL_RTX;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx last_insn;\n+      rtx cc_reg;\n+      rtx insn;\n+      rtx cc_src_insn;\n+      rtx cc_src;\n+      enum machine_mode mode;\n+\n+      /* Look for blocks which end with a conditional jump based on a\n+\t condition code register.  Then look for the instruction which\n+\t sets the condition code register.  Then look through the\n+\t successor blocks for instructions which set the condition\n+\t code register to the same value.  There are other possible\n+\t uses of the condition code register, but these are by far the\n+\t most common and the ones which we are most likely to be able\n+\t to optimize.  */\n+\n+      last_insn = BB_END (bb);\n+      if (GET_CODE (last_insn) != JUMP_INSN)\n+\tcontinue;\n+\n+      if (reg_referenced_p (cc_reg_1, PATTERN (last_insn)))\n+\tcc_reg = cc_reg_1;\n+      else if (cc_reg_2 && reg_referenced_p (cc_reg_2, PATTERN (last_insn)))\n+\tcc_reg = cc_reg_2;\n+      else\n+\tcontinue;\n+\n+      cc_src_insn = NULL_RTX;\n+      cc_src = NULL_RTX;\n+      for (insn = PREV_INSN (last_insn);\n+\t   insn && insn != PREV_INSN (BB_HEAD (bb));\n+\t   insn = PREV_INSN (insn))\n+\t{\n+\t  rtx set;\n+\n+\t  if (! INSN_P (insn))\n+\t    continue;\n+\t  set = single_set (insn);\n+\t  if (set\n+\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REGNO (SET_DEST (set)) == REGNO (cc_reg))\n+\t    {\n+\t      cc_src_insn = insn;\n+\t      cc_src = SET_SRC (set);\n+\t      break;\n+\t    }\n+\t  else if (reg_set_p (cc_reg, insn))\n+\t    break;\n+\t}\n+\n+      if (! cc_src_insn)\n+\tcontinue;\n+\n+      if (modified_between_p (cc_src, cc_src_insn, NEXT_INSN (last_insn)))\n+\tcontinue;\n+\n+      /* Now CC_REG is a condition code register used for a\n+\t conditional jump at the end of the block, and CC_SRC, in\n+\t CC_SRC_INSN, is the value to which that condition code\n+\t register is set, and CC_SRC is still meaningful at the end of\n+\t the basic block.  */\n+\n+      mode = cse_cc_succs (bb, cc_reg, cc_src, true);\n+      if (mode != GET_MODE (cc_src) && mode != VOIDmode)\n+\t{\n+\t  PUT_MODE (cc_src, mode);\n+\t  cse_change_cc_mode_insns (cc_src_insn, NEXT_INSN (last_insn),\n+\t\t\t\t    gen_rtx_REG (mode, REGNO (cc_reg)));\n+\t}\n+    }\n+}"}, {"sha": "8f1dfa7233d20d497898cf948eb6ec8ddba34005", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -5177,6 +5177,34 @@ follows:\n @end smallexample\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_FIXED_CONDITION_CODE_REGS (unsigned int *, unsigned int *)\n+On targets which do not use @code{(cc0)}, and which use a hard\n+register rather than a pseudo-register to hold condition codes, the\n+regular CSE passes are often not able to identify cases in which the\n+hard register is set to a common value.  Use this hook to enable a\n+small pass which optimizes such cases.  This hook should return true\n+to enable this pass, and it should set the integers to which its\n+arguments point to the hard register numbers used for condition codes.\n+When there is only one such register, as is true on most systems, the\n+integer pointed to by the second argument should be set to\n+@code{INVALID_REGNUM}.\n+\n+The default version of this hook returns false.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} enum machine_mode TARGET_CC_MODES_COMPATIBLE (enum machine_mode, enum machine_mode)\n+On targets which use multiple condition code modes in class\n+@code{MODE_CC}, it is sometimes the case that a comparison can be\n+validly done in more than one mode.  On such a system, define this\n+target hook to take two mode arguments and to return a mode in which\n+both comparisons may be validly done.  If there is no such mode,\n+return @code{VOIDmode}.\n+\n+The default version of this hook checks whether the modes are the\n+same.  If they are, it returns that mode.  If they are different, it\n+returns @code{VOIDmode}.\n+@end deftypefn\n+\n @node Costs\n @section Describing Relative Costs of Operations\n @cindex costs of instructions"}, {"sha": "a8cd665a45faf6a3224de4f8a0bb2c6e41978981", "filename": "gcc/hooks.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -1,5 +1,5 @@\n /* General-purpose hooks.\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -176,6 +176,13 @@ hook_bool_rtx_false (rtx a ATTRIBUTE_UNUSED)\n   return false;\n }\n \n+bool\n+hook_bool_uintp_uintp_false (unsigned int *a ATTRIBUTE_UNUSED,\n+\t\t\t     unsigned int *b ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n bool\n hook_bool_rtx_int_int_intp_false (rtx a ATTRIBUTE_UNUSED,\n \t\t\t\t  int b ATTRIBUTE_UNUSED,"}, {"sha": "583b504bffe23ff86287760bc864884d624780eb", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -1,5 +1,5 @@\n /* General-purpose hooks.\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -31,6 +31,7 @@ extern bool hook_bool_tree_hwi_hwi_tree_false (tree, HOST_WIDE_INT, HOST_WIDE_IN\n extern bool hook_bool_tree_hwi_hwi_tree_true (tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t       tree);\n extern bool hook_bool_rtx_false (rtx);\n+extern bool hook_bool_uintp_uintp_false (unsigned int *, unsigned int *);\n extern bool hook_bool_rtx_int_int_intp_false (rtx, int, int, int *);\n extern bool hook_bool_constcharptr_size_t_false (const char *, size_t);\n "}, {"sha": "f093a00666ed58947525498865ddcc740e162781", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -2013,6 +2013,7 @@ extern int cse_main (rtx, int, int, FILE *);\n #endif\n extern void cse_end_of_basic_block (rtx, struct cse_basic_block_data *,\n \t\t\t\t    int, int, int);\n+extern void cse_condition_code_reg (void);\n \n /* In jump.c */\n extern int comparison_dominates_p (enum rtx_code, enum rtx_code);"}, {"sha": "321cd08a2c149fdc86c65fddc1aa945687291abc", "filename": "gcc/target-def.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -1,5 +1,5 @@\n /* Default initializers for a generic GCC target.\n-   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -314,6 +314,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_ENCODE_SECTION_INFO default_encode_section_info\n #endif\n \n+#define TARGET_FIXED_CONDITION_CODE_REGS hook_bool_uintp_uintp_false\n+\n+#define TARGET_CC_MODES_COMPATIBLE default_cc_modes_compatible\n+\n #define TARGET_MACHINE_DEPENDENT_REORG 0\n \n #define TARGET_BUILD_BUILTIN_VA_LIST std_build_builtin_va_list\n@@ -380,6 +384,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_RTX_COSTS,\t\t\t\t\\\n   TARGET_ADDRESS_COST,\t\t\t\t\\\n   TARGET_DWARF_REGISTER_SPAN,                   \\\n+  TARGET_FIXED_CONDITION_CODE_REGS,\t\t\\\n+  TARGET_CC_MODES_COMPATIBLE,\t\t\t\\\n   TARGET_MACHINE_DEPENDENT_REORG,\t\t\\\n   TARGET_BUILD_BUILTIN_VA_LIST,\t\t\t\\\n   TARGET_GET_PCH_VALIDITY,\t\t\t\\"}, {"sha": "21a12f0ec3a99e652e94cf0987cef21abcddf17e", "filename": "gcc/target.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -377,6 +377,23 @@ struct gcc_target\n      hook should return NULL_RTX.  */\n   rtx (* dwarf_register_span) (rtx);\n \n+  /* Fetch the fixed register(s) which hold condition codes, for\n+     targets where it makes sense to look for duplicate assignments to\n+     the condition codes.  This should return true if there is such a\n+     register, false otherwise.  The arguments should be set to the\n+     fixed register numbers.  Up to two condition code registers are\n+     supported.  If there is only one for this target, the int pointed\n+     at by the second argument should be set to -1.  */\n+  bool (* fixed_condition_code_regs) (unsigned int *, unsigned int *);\n+\n+  /* If two condition code modes are compatible, return a condition\n+     code mode which is compatible with both, such that a comparison\n+     done in the returned mode will work for both of the original\n+     modes.  If the condition code modes are not compatible, return\n+     VOIDmode.  */\n+  enum machine_mode (* cc_modes_compatible) (enum machine_mode,\n+\t\t\t\t\t     enum machine_mode);\n+\n   /* Do machine-dependent code transformations.  Called just before\n      delayed-branch scheduling.  */\n   void (* machine_dependent_reorg) (void);"}, {"sha": "308ada6057c0d3d327e4a12da8ad7bda30dc29b3", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -70,6 +70,14 @@ default_external_libcall (rtx fun ATTRIBUTE_UNUSED)\n #endif\n }\n \n+enum machine_mode\n+default_cc_modes_compatible (enum machine_mode m1, enum machine_mode m2)\n+{\n+  if (m1 == m2)\n+    return m1;\n+  return VOIDmode;\n+}\n+\n bool\n default_promote_function_args (tree fntype ATTRIBUTE_UNUSED)\n {"}, {"sha": "63525fe04b70b9a4a44889c2dffdfb5e72087802", "filename": "gcc/targhooks.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -1,5 +1,5 @@\n /* Default target hook functions.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -20,6 +20,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n extern void default_external_libcall (rtx);\n \n+extern enum machine_mode default_cc_modes_compatible (enum machine_mode,\n+\t\t\t\t\t\t      enum machine_mode);\n+\n extern bool default_promote_function_args (tree);\n extern bool default_promote_function_return (tree);\n extern bool default_promote_prototypes (tree);"}, {"sha": "4d16201c177b78841107f0ec1c1976267925b4fb", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e129d93a7b1eda6ee734fff7aa1f8bc60e5ba7e2", "patch": "@@ -2902,6 +2902,13 @@ rest_of_handle_cse2 (tree decl, rtx insns)\n     dump_flow_info (rtl_dump_file);\n   /* CFG is no longer maintained up-to-date.  */\n   tem = cse_main (insns, max_reg_num (), 1, rtl_dump_file);\n+\n+  /* Run a pass to eliminate duplicated assignments to condition code\n+     registers.  We have to run this after bypass_jumps, because it\n+     makes it harder for that pass to determine whether a jump can be\n+     bypassed safely.  */\n+  cse_condition_code_reg ();\n+\n   purge_all_dead_edges (0);\n   delete_trivially_dead_insns (insns, max_reg_num ());\n "}]}