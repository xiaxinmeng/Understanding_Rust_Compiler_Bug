{"sha": "142439c50cfd7e3a2ef609cbd754541152814f95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQyNDM5YzUwY2ZkN2UzYTJlZjYwOWNiZDc1NDU0MTE1MjgxNGY5NQ==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@gmail.com", "date": "2018-03-05T02:27:30Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-03-05T02:27:30Z"}, "message": "[NDS32] Implment setmem pattern.\n\ngcc/\n\t* config/nds32/nds32-protos.h (nds32_expand_setmem): Declare.\n\t* config/nds32/nds32-multiple.md (setmemsi): Define.\n\t* config/nds32/nds32-memory-manipulation.c\n\t(nds32_gen_dup_4_byte_to_word_value): New.\n\t(emit_setmem_word_loop): New.\n\t(emit_setmem_byte_loop): New.\n\t(nds32_expand_setmem_loop): New.\n\t(nds32_expand_setmem_loop_v3m): New.\n\t(nds32_expand_setmem_unroll): New.\n\t(nds32_expand_setmem): New.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r258239", "tree": {"sha": "4201140bee89011f0b161b268edefa49f171704c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4201140bee89011f0b161b268edefa49f171704c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/142439c50cfd7e3a2ef609cbd754541152814f95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142439c50cfd7e3a2ef609cbd754541152814f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/142439c50cfd7e3a2ef609cbd754541152814f95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142439c50cfd7e3a2ef609cbd754541152814f95/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9322e1aa5ce42c88a1e6e56dc2c69f441bf0e597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9322e1aa5ce42c88a1e6e56dc2c69f441bf0e597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9322e1aa5ce42c88a1e6e56dc2c69f441bf0e597"}], "stats": {"total": 459, "additions": 456, "deletions": 3}, "files": [{"sha": "4daf25f2a624ad1520adcdffa57cd336279067ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142439c50cfd7e3a2ef609cbd754541152814f95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142439c50cfd7e3a2ef609cbd754541152814f95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=142439c50cfd7e3a2ef609cbd754541152814f95", "patch": "@@ -1,7 +1,21 @@\n+2018-03-05  Kito Cheng  <kito.cheng@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32-protos.h (nds32_expand_setmem): Declare.\n+\t* config/nds32/nds32-multiple.md (setmemsi): Define.\n+\t* config/nds32/nds32-memory-manipulation.c\n+\t(nds32_gen_dup_4_byte_to_word_value): New.\n+\t(emit_setmem_word_loop): New.\n+\t(emit_setmem_byte_loop): New.\n+\t(nds32_expand_setmem_loop): New.\n+\t(nds32_expand_setmem_loop_v3m): New.\n+\t(nds32_expand_setmem_unroll): New.\n+\t(nds32_expand_setmem): New.\n+\n 2018-03-04  Kito Cheng  <kito.cheng@gmail.com>\n \t    Chung-Ju Wu  <jasonwucj@gmail.com>\n \n-\t*config/nds32/nds32-memory-manipulation.c\n+\t* config/nds32/nds32-memory-manipulation.c\n \t(nds32_emit_load_store): New.\n \t(nds32_emit_post_inc_load_store): New.\n \t(nds32_emit_mem_move): New.\n@@ -12,9 +26,9 @@\n \t(nds32_expand_movmemsi_unroll): New.\n \t(nds32_expand_movmemqi): Rename ...\n \t(nds32_expand_movmemsi): ... to this.\n-\t*config/nds32/nds32-multiple.md (movmemqi): Rename ...\n+\t* config/nds32/nds32-multiple.md (movmemqi): Rename ...\n \t(movmemsi): ... to this.\n-\t*config/nds32/nds32-protos.h (nds32_expand_movmemqi): Rename ...\n+\t* config/nds32/nds32-protos.h (nds32_expand_movmemqi): Rename ...\n \t(nds32_expand_movmemsi): ... to this.\n \n 2018-03-04  Kito Cheng  <kito.cheng@gmail.com>"}, {"sha": "13ac8c1cfc8c86fb2bcc9e0a2a1657c5671f8318", "filename": "gcc/config/nds32/nds32-memory-manipulation.c", "status": "modified", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142439c50cfd7e3a2ef609cbd754541152814f95/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142439c50cfd7e3a2ef609cbd754541152814f95/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c?ref=142439c50cfd7e3a2ef609cbd754541152814f95", "patch": "@@ -428,6 +428,425 @@ nds32_expand_movmemsi (rtx dstmem, rtx srcmem, rtx total_bytes, rtx alignment)\n   return false;\n }\n \n+/* ------------------------------------------------------------------------ */\n+\n+/* Auxiliary function for expand setmem pattern.  */\n+\n+static rtx\n+nds32_gen_dup_4_byte_to_word_value (rtx value)\n+{\n+  rtx value4word = gen_reg_rtx (SImode);\n+\n+  gcc_assert (GET_MODE (value) == QImode || CONST_INT_P (value));\n+\n+  if (CONST_INT_P (value))\n+    {\n+      unsigned HOST_WIDE_INT val = UINTVAL (value) & GET_MODE_MASK(QImode);\n+      rtx new_val = gen_int_mode (val | (val << 8)\n+\t\t\t\t  | (val << 16) | (val << 24), SImode);\n+      /* Just calculate at here if it's constant value.  */\n+      emit_move_insn (value4word, new_val);\n+    }\n+  else\n+    {\n+      /* ! prepare word\n+\t andi    $tmp1, $value, 0xff       ! $tmp1  <- 0x000000ab\n+\t slli    $tmp2, $tmp1, 8           ! $tmp2  <- 0x0000ab00\n+\t or      $tmp3, $tmp1, $tmp2       ! $tmp3  <- 0x0000abab\n+\t slli    $tmp4, $tmp3, 16          ! $tmp4  <- 0xabab0000\n+\t or      $val4word, $tmp3, $tmp4   ! $value4word  <- 0xabababab  */\n+\n+      rtx tmp1, tmp2, tmp3, tmp4, final_value;\n+      tmp1 = expand_binop (SImode, and_optab, value,\n+\t\t\t   gen_int_mode (0xff, SImode),\n+\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n+      tmp2 = expand_binop (SImode, ashl_optab, tmp1,\n+\t\t\t   gen_int_mode (8, SImode),\n+\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n+      tmp3 = expand_binop (SImode, ior_optab, tmp1, tmp2,\n+\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n+      tmp4 = expand_binop (SImode, ashl_optab, tmp3,\n+\t\t\t   gen_int_mode (16, SImode),\n+\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n+\n+      final_value = expand_binop (SImode, ior_optab, tmp3, tmp4,\n+\t\t\t\t  NULL_RTX, 0, OPTAB_WIDEN);\n+      emit_move_insn (value4word, final_value);\n+    }\n+\n+  return value4word;\n+}\n+\n+static rtx\n+emit_setmem_word_loop (rtx itr, rtx size, rtx value)\n+{\n+  rtx word_mode_label = gen_label_rtx ();\n+  rtx word_mode_end_label = gen_label_rtx ();\n+  rtx byte_mode_size = gen_reg_rtx (SImode);\n+  rtx byte_mode_size_tmp = gen_reg_rtx (SImode);\n+  rtx word_mode_end = gen_reg_rtx (SImode);\n+  rtx size_for_word = gen_reg_rtx (SImode);\n+\n+  /* and     $size_for_word, $size, #~3  */\n+  size_for_word = expand_binop (SImode, and_optab, size,\n+\t\t\t\tgen_int_mode (~3, SImode),\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\n+  emit_move_insn (byte_mode_size, size);\n+\n+  /* beqz    $size_for_word, .Lbyte_mode_entry  */\n+  emit_cmp_and_jump_insns (size_for_word, const0_rtx, EQ, NULL,\n+\t\t\t   SImode, 1, word_mode_end_label);\n+  /* add     $word_mode_end, $dst, $size_for_word  */\n+  word_mode_end = expand_binop (Pmode, add_optab, itr, size_for_word,\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\n+  /* andi    $byte_mode_size, $size, 3  */\n+  byte_mode_size_tmp = expand_binop (SImode, and_optab, size, GEN_INT (3),\n+\t\t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n+\n+  emit_move_insn (byte_mode_size, byte_mode_size_tmp);\n+\n+  /* .Lword_mode:  */\n+  emit_label (word_mode_label);\n+  /*   ! word-mode set loop\n+       smw.bim $value4word, [$dst_itr], $value4word, 0\n+       bne     $word_mode_end, $dst_itr, .Lword_mode  */\n+  emit_insn (gen_unaligned_store_update_base_w (itr,\n+\t\t\t\t\t\titr,\n+\t\t\t\t\t\tvalue));\n+  emit_cmp_and_jump_insns (word_mode_end, itr, NE, NULL,\n+\t\t\t   Pmode, 1, word_mode_label);\n+\n+  emit_label (word_mode_end_label);\n+\n+  return byte_mode_size;\n+}\n+\n+static rtx\n+emit_setmem_byte_loop (rtx itr, rtx size, rtx value, bool need_end)\n+{\n+  rtx end  = gen_reg_rtx (Pmode);\n+  rtx byte_mode_label = gen_label_rtx ();\n+  rtx end_label = gen_label_rtx ();\n+\n+  value = force_reg (QImode, value);\n+\n+  if (need_end)\n+    end = expand_binop (Pmode, add_optab, itr, size,\n+\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+  /*   beqz    $byte_mode_size, .Lend\n+       add     $byte_mode_end, $dst_itr, $byte_mode_size  */\n+  emit_cmp_and_jump_insns (size, const0_rtx, EQ, NULL,\n+\t\t\t   SImode, 1, end_label);\n+\n+  if (!need_end)\n+    end = expand_binop (Pmode, add_optab, itr, size,\n+\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\n+  /* .Lbyte_mode:  */\n+  emit_label (byte_mode_label);\n+\n+  /*   ! byte-mode set loop\n+       sbi.bi  $value, [$dst_itr] ,1\n+       bne     $byte_mode_end, $dst_itr, .Lbyte_mode */\n+  nds32_emit_post_inc_load_store (value, itr, QImode, false);\n+\n+  emit_cmp_and_jump_insns (end, itr, NE, NULL,\n+\t\t\t   Pmode, 1, byte_mode_label);\n+  /* .Lend: */\n+  emit_label (end_label);\n+\n+  if (need_end)\n+    return end;\n+  else\n+    return NULL_RTX;\n+}\n+\n+static bool\n+nds32_expand_setmem_loop (rtx dstmem, rtx size, rtx value)\n+{\n+  rtx value4word;\n+  rtx value4byte;\n+  rtx dst;\n+  rtx byte_mode_size;\n+\n+  /* Emit loop version of setmem.\n+     memset:\n+       ! prepare word\n+       andi    $tmp1, $val, 0xff               ! $tmp1  <- 0x000000ab\n+       slli    $tmp2, $tmp1, 8                 ! $tmp2  <- 0x0000ab00\n+       or      $tmp3, $val, $tmp2              ! $tmp3  <- 0x0000abab\n+       slli    $tmp4, $tmp3, 16                ! $tmp4  <- 0xabab0000\n+       or      $val4word, $tmp3, $tmp4         ! $value4word  <- 0xabababab\n+\n+       and     $size_for_word, $size, #-4\n+       beqz    $size_for_word, .Lword_mode_end\n+\n+       add     $word_mode_end, $dst, $size_for_word\n+       andi    $byte_mode_size, $size, 3\n+\n+     .Lword_mode:\n+       ! word-mode set loop\n+       smw.bim $value4word, [$dst], $value4word, 0\n+       bne     $word_mode_end, $dst, .Lword_mode\n+\n+     .Lword_mode_end:\n+       beqz    $byte_mode_size, .Lend\n+       add     $byte_mode_end, $dst, $byte_mode_size\n+\n+     .Lbyte_mode:\n+       ! byte-mode set loop\n+       sbi.bi  $value4word, [$dst] ,1\n+       bne     $byte_mode_end, $dst, .Lbyte_mode\n+     .Lend: */\n+\n+  dst = copy_to_mode_reg (SImode, XEXP (dstmem, 0));\n+\n+  /* ! prepare word\n+     andi    $tmp1, $value, 0xff             ! $tmp1  <- 0x000000ab\n+     slli    $tmp2, $tmp1, 8                 ! $tmp2  <- 0x0000ab00\n+     or      $tmp3, $tmp1, $tmp2             ! $tmp3  <- 0x0000abab\n+     slli    $tmp4, $tmp3, 16                ! $tmp4  <- 0xabab0000\n+     or      $val4word, $tmp3, $tmp4         ! $value4word  <- 0xabababab  */\n+  value4word = nds32_gen_dup_4_byte_to_word_value (value);\n+\n+  /*   and     $size_for_word, $size, #-4\n+       beqz    $size_for_word, .Lword_mode_end\n+\n+       add     $word_mode_end, $dst, $size_for_word\n+       andi    $byte_mode_size, $size, 3\n+\n+     .Lword_mode:\n+       ! word-mode set loop\n+       smw.bim $value4word, [$dst], $value4word, 0\n+       bne     $word_mode_end, $dst, .Lword_mode\n+     .Lword_mode_end:  */\n+  byte_mode_size = emit_setmem_word_loop (dst, size, value4word);\n+\n+  /*   beqz    $byte_mode_size, .Lend\n+       add     $byte_mode_end, $dst, $byte_mode_size\n+\n+     .Lbyte_mode:\n+       ! byte-mode set loop\n+       sbi.bi  $value, [$dst] ,1\n+       bne     $byte_mode_end, $dst, .Lbyte_mode\n+     .Lend: */\n+\n+  value4byte = simplify_gen_subreg (QImode, value4word, SImode,\n+\t\t\t\t    subreg_lowpart_offset (QImode, SImode));\n+\n+  emit_setmem_byte_loop (dst, byte_mode_size, value4byte, false);\n+\n+  return true;\n+}\n+\n+static bool\n+nds32_expand_setmem_loop_v3m (rtx dstmem, rtx size, rtx value)\n+{\n+  rtx base_reg = copy_to_mode_reg (Pmode, XEXP (dstmem, 0));\n+  rtx need_align_bytes = gen_reg_rtx (SImode);\n+  rtx last_2_bit = gen_reg_rtx (SImode);\n+  rtx byte_loop_base = gen_reg_rtx (SImode);\n+  rtx byte_loop_size = gen_reg_rtx (SImode);\n+  rtx remain_size = gen_reg_rtx (SImode);\n+  rtx new_base_reg;\n+  rtx value4byte, value4word;\n+  rtx byte_mode_size;\n+  rtx last_byte_loop_label = gen_label_rtx ();\n+\n+  size = force_reg (SImode, size);\n+\n+  value4word = nds32_gen_dup_4_byte_to_word_value (value);\n+  value4byte = simplify_gen_subreg (QImode, value4word, SImode, 0);\n+\n+  emit_move_insn (byte_loop_size, size);\n+  emit_move_insn (byte_loop_base, base_reg);\n+\n+  /* Jump to last byte loop if size is less than 16.  */\n+  emit_cmp_and_jump_insns (size, gen_int_mode (16, SImode), LE, NULL,\n+\t\t\t   SImode, 1, last_byte_loop_label);\n+\n+  /* Make sure align to 4 byte first since v3m can't unalign access.  */\n+  emit_insn (gen_andsi3 (last_2_bit,\n+\t\t\t base_reg,\n+\t\t\t gen_int_mode (0x3, SImode)));\n+\n+  emit_insn (gen_subsi3 (need_align_bytes,\n+\t\t\t gen_int_mode (4, SImode),\n+\t\t\t last_2_bit));\n+\n+  /* Align to 4 byte. */\n+  new_base_reg = emit_setmem_byte_loop (base_reg,\n+\t\t\t\t\tneed_align_bytes,\n+\t\t\t\t\tvalue4byte,\n+\t\t\t\t\ttrue);\n+\n+  /* Calculate remain size. */\n+  emit_insn (gen_subsi3 (remain_size, size, need_align_bytes));\n+\n+  /* Set memory word by word. */\n+  byte_mode_size = emit_setmem_word_loop (new_base_reg,\n+\t\t\t\t\t  remain_size,\n+\t\t\t\t\t  value4word);\n+\n+  emit_move_insn (byte_loop_base, new_base_reg);\n+  emit_move_insn (byte_loop_size, byte_mode_size);\n+\n+  emit_label (last_byte_loop_label);\n+\n+  /* And set memory for remain bytes. */\n+  emit_setmem_byte_loop (byte_loop_base, byte_loop_size, value4byte, false);\n+  return true;\n+}\n+\n+static bool\n+nds32_expand_setmem_unroll (rtx dstmem, rtx size, rtx value,\n+\t\t\t    rtx align ATTRIBUTE_UNUSED,\n+\t\t\t    rtx expected_align ATTRIBUTE_UNUSED,\n+\t\t\t    rtx expected_size ATTRIBUTE_UNUSED)\n+{\n+  unsigned maximum_regs, maximum_bytes, start_regno, regno;\n+  rtx value4word;\n+  rtx dst_base_reg, new_base_reg;\n+  unsigned HOST_WIDE_INT remain_bytes, remain_words, prepare_regs, fill_per_smw;\n+  unsigned HOST_WIDE_INT real_size;\n+\n+  if (TARGET_REDUCED_REGS)\n+    {\n+      maximum_regs  = 4;\n+      maximum_bytes = 64;\n+      start_regno   = 2;\n+    }\n+  else\n+    {\n+      maximum_regs  = 8;\n+      maximum_bytes = 128;\n+      start_regno   = 16;\n+    }\n+\n+  real_size = UINTVAL (size) & GET_MODE_MASK(SImode);\n+\n+  if (!(CONST_INT_P (size) && real_size <= maximum_bytes))\n+    return false;\n+\n+  remain_bytes = real_size;\n+\n+  gcc_assert (GET_MODE (value) == QImode || CONST_INT_P (value));\n+\n+  value4word = nds32_gen_dup_4_byte_to_word_value (value);\n+\n+  prepare_regs = remain_bytes / UNITS_PER_WORD;\n+\n+  dst_base_reg = copy_to_mode_reg (SImode, XEXP (dstmem, 0));\n+\n+  if (prepare_regs > maximum_regs)\n+    prepare_regs = maximum_regs;\n+\n+  fill_per_smw = prepare_regs * UNITS_PER_WORD;\n+\n+  regno = start_regno;\n+  switch (prepare_regs)\n+    {\n+    case 2:\n+    default:\n+      {\n+\trtx reg0 = gen_rtx_REG (SImode, regno);\n+\trtx reg1 = gen_rtx_REG (SImode, regno+1);\n+\tunsigned last_regno = start_regno + prepare_regs - 1;\n+\n+\temit_move_insn (reg0, value4word);\n+\temit_move_insn (reg1, value4word);\n+\trtx regd = gen_rtx_REG (DImode, regno);\n+\tregno += 2;\n+\n+\t/* Try to utilize movd44!  */\n+\twhile (regno <= last_regno)\n+\t  {\n+\t    if ((regno + 1) <=last_regno)\n+\t      {\n+\t\trtx reg = gen_rtx_REG (DImode, regno);\n+\t\temit_move_insn (reg, regd);\n+\t\tregno += 2;\n+\t      }\n+\t    else\n+\t      {\n+\t\trtx reg = gen_rtx_REG (SImode, regno);\n+\t\temit_move_insn (reg, reg0);\n+\t\tregno += 1;\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+    case 1:\n+      {\n+\trtx reg = gen_rtx_REG (SImode, regno++);\n+\temit_move_insn (reg, value4word);\n+      }\n+      break;\n+    case 0:\n+      break;\n+    }\n+\n+  if (fill_per_smw)\n+    for (;remain_bytes >= fill_per_smw;remain_bytes -= fill_per_smw)\n+      {\n+\temit_insn (nds32_expand_store_multiple (start_regno, prepare_regs,\n+\t\t\t\t\t\tdst_base_reg, dstmem,\n+\t\t\t\t\t\ttrue, &new_base_reg));\n+\tdst_base_reg = new_base_reg;\n+\tdstmem = gen_rtx_MEM (SImode, dst_base_reg);\n+      }\n+\n+  remain_words = remain_bytes / UNITS_PER_WORD;\n+\n+  if (remain_words)\n+    {\n+      emit_insn (nds32_expand_store_multiple (start_regno, remain_words,\n+\t\t\t\t\t      dst_base_reg, dstmem,\n+\t\t\t\t\t      true, &new_base_reg));\n+      dst_base_reg = new_base_reg;\n+      dstmem = gen_rtx_MEM (SImode, dst_base_reg);\n+    }\n+\n+  remain_bytes = remain_bytes - (remain_words * UNITS_PER_WORD);\n+\n+  if (remain_bytes)\n+    {\n+      value = simplify_gen_subreg (QImode, value4word, SImode,\n+\t\t\t\t   subreg_lowpart_offset(QImode, SImode));\n+      int offset = 0;\n+      for (;remain_bytes;--remain_bytes, ++offset)\n+\t{\n+\t  nds32_emit_load_store (value, dstmem, QImode, offset, false);\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+bool\n+nds32_expand_setmem (rtx dstmem, rtx size, rtx value, rtx align,\n+\t\t     rtx expected_align,\n+\t\t     rtx expected_size)\n+{\n+  bool align_to_4_bytes = (INTVAL (align) & 3) == 0;\n+\n+  /* Only expand at O3 */\n+  if (optimize_size || optimize < 3)\n+    return false;\n+\n+  if (TARGET_ISA_V3M && !align_to_4_bytes)\n+    return nds32_expand_setmem_loop_v3m (dstmem, size, value);\n+\n+  if (nds32_expand_setmem_unroll (dstmem, size, value,\n+\t\t\t\t  align, expected_align, expected_size))\n+    return true;\n+\n+  return nds32_expand_setmem_loop (dstmem, size, value);\n+}\n+\n+/* ------------------------------------------------------------------------ */\n \n /* Functions to expand load_multiple and store_multiple.\n    They are auxiliary extern functions to help create rtx template."}, {"sha": "66880c2fd9d999896c4d0e3bb7b4d2d70b24616e", "filename": "gcc/config/nds32/nds32-multiple.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142439c50cfd7e3a2ef609cbd754541152814f95/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142439c50cfd7e3a2ef609cbd754541152814f95/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-multiple.md?ref=142439c50cfd7e3a2ef609cbd754541152814f95", "patch": "@@ -3749,3 +3749,22 @@\n })\n \n ;; ------------------------------------------------------------------------\n+\n+(define_expand \"setmemsi\"\n+   [(use (match_operand:BLK 0 \"memory_operand\"))\n+    (use (match_operand:SI 1 \"nds32_reg_constant_operand\"))\n+    (use (match_operand:QI 2 \"nonmemory_operand\"))\n+    (use (match_operand 3 \"const_int_operand\"))\n+    (use (match_operand:SI 4 \"const_int_operand\"))\n+    (use (match_operand:SI 5 \"const_int_operand\"))]\n+  \"\"\n+{\n+ if (nds32_expand_setmem (operands[0], operands[1],\n+\t\t\t  operands[2], operands[3],\n+\t\t\t  operands[4], operands[5]))\n+   DONE;\n+\n+ FAIL;\n+})\n+\n+;; ------------------------------------------------------------------------"}, {"sha": "075206ed208d773aae4604c297e7bf960cbe1e86", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/142439c50cfd7e3a2ef609cbd754541152814f95/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/142439c50cfd7e3a2ef609cbd754541152814f95/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=142439c50cfd7e3a2ef609cbd754541152814f95", "patch": "@@ -69,6 +69,7 @@ extern bool nds32_valid_smw_lwm_base_p (rtx);\n extern rtx nds32_expand_load_multiple (int, int, rtx, rtx, bool, rtx *);\n extern rtx nds32_expand_store_multiple (int, int, rtx, rtx, bool, rtx *);\n extern bool nds32_expand_movmemsi (rtx, rtx, rtx, rtx);\n+extern bool nds32_expand_setmem (rtx, rtx, rtx, rtx, rtx, rtx);\n \n /* Auxiliary functions for expand unalign load instruction.  */\n "}]}