{"sha": "f08545a8f225fe7adfbfab9a652bb8c325494d3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA4NTQ1YThmMjI1ZmU3YWRmYmZhYjlhNjUyYmI4YzMyNTQ5NGQzYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-09-10T23:45:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-09-10T23:45:05Z"}, "message": "c-objc-common.c (c_cannot_inline_tree_fn): Warn on why function is not inlinable; do not check the body.\n\n\n\t* c-objc-common.c (c_cannot_inline_tree_fn): Warn\n\ton why function is not inlinable; do not check\n\tthe body.\n\t(inline_forbidden_p): Move to...\n\t* tree-inline.c (inline_forbidden_p_1): ... here; Add warnings;\n\tdeal with alloca, longjmp.\n\t(inline_forbidden_p): New static function.\n\t(find_alloca_call_1, find_alloca_call, find_builtin_longjmp_call_1,\n\tfind_builtin_longjmp_call): Kill.\n\nFrom-SVN: r71283", "tree": {"sha": "240ef70cc4d941a711b2312423640e7e93085f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/240ef70cc4d941a711b2312423640e7e93085f12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f08545a8f225fe7adfbfab9a652bb8c325494d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08545a8f225fe7adfbfab9a652bb8c325494d3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f08545a8f225fe7adfbfab9a652bb8c325494d3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f08545a8f225fe7adfbfab9a652bb8c325494d3c/comments", "author": null, "committer": null, "parents": [{"sha": "25c84396dd1bfb44ff5365d8ff512f1233101dfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c84396dd1bfb44ff5365d8ff512f1233101dfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c84396dd1bfb44ff5365d8ff512f1233101dfd"}], "stats": {"total": 362, "additions": 184, "deletions": 178}, "files": [{"sha": "3a68a0515cd77fde09c506b8fedbefe4b2bb1423", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08545a8f225fe7adfbfab9a652bb8c325494d3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08545a8f225fe7adfbfab9a652bb8c325494d3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f08545a8f225fe7adfbfab9a652bb8c325494d3c", "patch": "@@ -1,3 +1,15 @@\n+Thu Sep 11 01:21:05 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* c-objc-common.c (c_cannot_inline_tree_fn): Warn\n+\ton why function is not inlinable; do not check\n+\tthe body.\n+\t(inline_forbidden_p): Move to...\n+\t* tree-inline.c (inline_forbidden_p_1): ... here; Add warnings;\n+\tdeal with alloca, longjmp.\n+\t(inline_forbidden_p): New static function.\n+\t(find_alloca_call_1, find_alloca_call, find_builtin_longjmp_call_1,\n+\tfind_builtin_longjmp_call): Kill.\n+\n 2003-09-10  Richard Henderson  <rth@redhat.com>\n \n \t* cgraph.h (struct cgraph_node): Rename lowered to analyzed."}, {"sha": "172346b2aeca5c866c588c03dc585515deed4175", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 39, "deletions": 115, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08545a8f225fe7adfbfab9a652bb8c325494d3c/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08545a8f225fe7adfbfab9a652bb8c325494d3c/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=f08545a8f225fe7adfbfab9a652bb8c325494d3c", "patch": "@@ -40,7 +40,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cgraph.h\"\n \n static bool c_tree_printer (pretty_printer *, text_info *);\n-static tree inline_forbidden_p (tree *, int *, void *);\n static tree start_cdtor (int);\n static void finish_cdtor (tree);\n \n@@ -65,110 +64,45 @@ c_disregard_inline_limits (tree fn)\n   return DECL_DECLARED_INLINE_P (fn) && DECL_EXTERNAL (fn);\n }\n \n-static tree\n-inline_forbidden_p (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t    void *fn)\n-{\n-  tree node = *nodep;\n-  tree t;\n-\n-  switch (TREE_CODE (node))\n-    {\n-    case CALL_EXPR:\n-      t = get_callee_fndecl (node);\n-\n-      if (! t)\n-\tbreak;\n-\n-      /* We cannot inline functions that call setjmp.  */\n-      if (setjmp_call_p (t))\n-\treturn node;\n-\n-      switch (DECL_FUNCTION_CODE (t))\n-\t{\n-\t  /* We cannot inline functions that take a variable number of\n-\t     arguments.  */\n-\tcase BUILT_IN_VA_START:\n-\tcase BUILT_IN_STDARG_START:\n-#if 0\n-\t  /* Functions that need information about the address of the\n-             caller can't (shouldn't?) be inlined.  */\n-\tcase BUILT_IN_RETURN_ADDRESS:\n-#endif\n-\t  return node;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      break;\n-\n-    case DECL_STMT:\n-      /* We cannot inline functions that contain other functions.  */\n-      if (TREE_CODE (TREE_OPERAND (node, 0)) == FUNCTION_DECL\n-\t  && DECL_INITIAL (TREE_OPERAND (node, 0)))\n-\treturn node;\n-      break;\n-\n-    case GOTO_STMT:\n-    case GOTO_EXPR:\n-      t = TREE_OPERAND (node, 0);\n-\n-      /* We will not inline a function which uses computed goto.  The\n-\t addresses of its local labels, which may be tucked into\n-\t global storage, are of course not constant across\n-\t instantiations, which causes unexpected behavior.  */\n-      if (TREE_CODE (t) != LABEL_DECL)\n-\treturn node;\n-\n-      /* We cannot inline a nested function that jumps to a nonlocal\n-         label.  */\n-      if (TREE_CODE (t) == LABEL_DECL\n-\t  && !DECL_FILE_SCOPE_P (t) && DECL_CONTEXT (t) != fn)\n-\treturn node;\n-\n-      break;\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-      /* We cannot inline a function of the form\n-\n-\t   void F (int i) { struct S { int ar[i]; } s; }\n-\n-\t Attempting to do so produces a catch-22 in tree-inline.c.\n-\t If walk_tree examines the TYPE_FIELDS chain of RECORD_TYPE/\n-\t UNION_TYPE nodes, then it goes into infinite recursion on a\n-\t structure containing a pointer to its own type.  If it doesn't,\n-\t then the type node for S doesn't get adjusted properly when\n-\t F is inlined, and we abort in find_function_data.  */\n-      for (t = TYPE_FIELDS (node); t; t = TREE_CHAIN (t))\n-\tif (variably_modified_type_p (TREE_TYPE (t)))\n-\t  return node;\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n int\n c_cannot_inline_tree_fn (tree *fnp)\n {\n   tree fn = *fnp;\n   tree t;\n+  bool do_warning = (warn_inline\n+\t\t     && DECL_INLINE (fn)\n+\t\t     && DECL_DECLARED_INLINE_P (fn)\n+\t\t     && !DECL_IN_SYSTEM_HEADER (fn));\n \n   if (flag_really_no_inline\n       && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL)\n-    return 1;\n+    {\n+      if (do_warning)\n+\twarning (\"%Hfunction '%F' can never be inlined because it \"\n+\t\t \"is supressed using -fno-inline\",\n+\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+      goto cannot_inline;\n+    }\n \n   /* Don't auto-inline anything that might not be bound within\n      this unit of translation.  */\n   if (!DECL_DECLARED_INLINE_P (fn) && !(*targetm.binds_local_p) (fn))\n-    goto cannot_inline;\n+    {\n+      if (do_warning)\n+\twarning (\"%Hfunction '%F' can never be inlined because it might not \"\n+\t\t \"be bound within this unit of translation\",\n+\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+      goto cannot_inline;\n+    }\n \n   if (! function_attribute_inlinable_p (fn))\n-    goto cannot_inline;\n+    {\n+      if (do_warning)\n+\twarning (\"%Hfunction '%F' can never be inlined because it uses \"\n+\t\t \"attributes conflicting with inlining\",\n+\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+      goto cannot_inline;\n+    }\n \n   /* If a function has pending sizes, we must not defer its\n      compilation, and we can't inline it as a tree.  */\n@@ -178,39 +112,29 @@ c_cannot_inline_tree_fn (tree *fnp)\n       put_pending_sizes (t);\n \n       if (t)\n-\tgoto cannot_inline;\n+\t{\n+\t  if (do_warning)\n+\t    warning (\"%Hfunction '%F' can never be inlined because it has \"\n+\t\t     \"pending sizes\",\n+\t\t     &DECL_SOURCE_LOCATION (fn), fn);\n+\t  goto cannot_inline;\n+\t}\n     }\n \n   if (! DECL_FILE_SCOPE_P (fn))\n     {\n       /* If a nested function has pending sizes, we may have already\n          saved them.  */\n       if (DECL_LANG_SPECIFIC (fn)->pending_sizes)\n-\tgoto cannot_inline;\n-    }\n-  else\n-    {\n-      /* We rely on the fact that this function is called upfront,\n-\t just before we start expanding a function.  If FN is active\n-\t (i.e., it's the current_function_decl or a parent thereof),\n-\t we have to walk FN's saved tree.  Otherwise, we can safely\n-\t assume we have done it before and, if we didn't mark it as\n-\t uninlinable (in which case we wouldn't have been called), it\n-\t is inlinable.  Unfortunately, this strategy doesn't work for\n-\t nested functions, because they're only expanded as part of\n-\t their enclosing functions, so the inlinability test comes in\n-\t late.  */\n-      t = current_function_decl;\n-\n-      while (t && t != fn)\n-\tt = DECL_CONTEXT (t);\n-      if (! t)\n-\treturn 0;\n+\t{\n+\t  if (do_warning)\n+\t    warning (\"%Hnested function '%F' can never be inlined because it \"\n+\t\t     \"has possibly saved pending sizes\",\n+\t\t     &DECL_SOURCE_LOCATION (fn), fn);\n+\t  goto cannot_inline;\n+\t}\n     }\n \n-  if (walk_tree (&DECL_SAVED_TREE (fn), inline_forbidden_p, fn, NULL))\n-    goto cannot_inline;\n-\n   return 0;\n \n  cannot_inline:"}, {"sha": "43e98483089fe68d364d192623ef6bf0a9ede6cd", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 133, "deletions": 63, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f08545a8f225fe7adfbfab9a652bb8c325494d3c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f08545a8f225fe7adfbfab9a652bb8c325494d3c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f08545a8f225fe7adfbfab9a652bb8c325494d3c", "patch": "@@ -128,10 +128,6 @@ static tree initialize_inlined_parameters (inline_data *, tree, tree, tree);\n static void remap_block (tree *, tree, inline_data *);\n static tree add_stmt_to_compound (tree, tree, tree);\n #endif /* INLINER_FOR_JAVA */\n-static tree find_alloca_call_1 (tree *, int *, void *);\n-static tree find_alloca_call (tree);\n-static tree find_builtin_longjmp_call_1 (tree *, int *, void *);\n-static tree find_builtin_longjmp_call (tree);\n \n /* Remap DECL during the copying of the BLOCK tree for the function.  */\n \n@@ -880,50 +876,148 @@ tree_inlinable_function_p (tree fn)\n   return inlinable_function_p (fn);\n }\n \n-/* If *TP is possibly call to alloca, return nonzero.  */\n-static tree\n-find_alloca_call_1 (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t    void *data ATTRIBUTE_UNUSED)\n-{\n-  if (alloca_call_p (*tp))\n-    return *tp;\n-  return NULL;\n-}\n+static const char *inline_forbidden_reason;\n \n-/* Return subexpression representing possible alloca call, if any.  */\n static tree\n-find_alloca_call (tree exp)\n+inline_forbidden_p_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t    void *fn)\n {\n-  location_t saved_loc = input_location;\n-  tree ret = walk_tree_without_duplicates\n-\t\t(&exp, find_alloca_call_1, NULL);\n-  input_location = saved_loc;\n-  return ret;\n-}\n+  tree node = *nodep;\n+  tree t;\n \n-static tree\n-find_builtin_longjmp_call_1 (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t\t     void *data ATTRIBUTE_UNUSED)\n-{\n-  tree exp = *tp, decl;\n+  switch (TREE_CODE (node))\n+    {\n+    case CALL_EXPR:\n+      /* Refuse to inline alloca call unless user explicitly forced so as this\n+\t may change program's memory overhead drastically when the function\n+\t using alloca is called in loop.  In GCC present in SPEC2000 inlining\n+\t into schedule_block cause it to require 2GB of ram instead of 256MB.  */\n+      if (alloca_call_p (node)\n+\t  && !lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)))\n+\t{\n+\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n+\t\t\t\t    \"because it uses alloca (override using \"\n+\t\t\t\t    \"the always_inline attribute)\";\n+\t  return node;\n+\t}\n+      t = get_callee_fndecl (node);\n+      if (! t)\n+\tbreak;\n+\n+\n+      /* We cannot inline functions that call setjmp.  */\n+      if (setjmp_call_p (t))\n+\t{\n+\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined\"\n+\t\t\t\t    \" because it uses setjmp\";\n+\t  return node;\n+\t}\n \n-  if (TREE_CODE (exp) == CALL_EXPR\n-      && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-      && (decl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t  TREE_CODE (decl) == FUNCTION_DECL)\n-      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n-      && DECL_FUNCTION_CODE (decl) == BUILT_IN_LONGJMP)\n-    return decl;\n+      switch (DECL_FUNCTION_CODE (t))\n+\t{\n+\t  /* We cannot inline functions that take a variable number of\n+\t     arguments.  */\n+\tcase BUILT_IN_VA_START:\n+\tcase BUILT_IN_STDARG_START:\n+\t  {\n+\t    inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n+\t\t\t\t      \"because it uses variable argument lists\";\n+\t    return node;\n+\t  }\n+\tcase BUILT_IN_LONGJMP:\n+\t  {\n+\t    /* We can't inline functions that call __builtin_longjmp at all.\n+\t       The non-local goto machinery really requires the destination\n+\t       be in a different function.  If we allow the function calling\n+\t       __builtin_longjmp to be inlined into the function calling\n+\t       __builtin_setjmp, Things will Go Awry.  */\n+\t    /* ??? Need front end help to identify \"regular\" non-local goto.  */\n+            if (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL)\n+\t      {\n+\t\tinline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n+\t\t\t\t\t  \"because it uses setjmp-longjmp \"\n+\t\t\t\t\t  \"exception handling\";\n+\t        return node;\n+\t      }\n+\t  }\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n \n-  return NULL;\n+#ifndef INLINER_FOR_JAVA\n+    case DECL_STMT:\n+      /* We cannot inline functions that contain other functions.  */\n+      if (TREE_CODE (TREE_OPERAND (node, 0)) == FUNCTION_DECL\n+\t  && DECL_INITIAL (TREE_OPERAND (node, 0)))\n+\t{\n+\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n+\t\t\t\t    \"because it contains a nested function\";\n+\t  return node;\n+\t}\n+      break;\n+\n+    case GOTO_STMT:\n+    case GOTO_EXPR:\n+      t = TREE_OPERAND (node, 0);\n+\n+      /* We will not inline a function which uses computed goto.  The\n+\t addresses of its local labels, which may be tucked into\n+\t global storage, are of course not constant across\n+\t instantiations, which causes unexpected behavior.  */\n+      if (TREE_CODE (t) != LABEL_DECL)\n+\t{\n+\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n+\t\t\t\t    \"because it contains a nonlocal label\";\n+\t  return node;\n+\t}\n+\n+      /* We cannot inline a nested function that jumps to a nonlocal\n+         label.  */\n+      if (TREE_CODE (t) == LABEL_DECL && DECL_CONTEXT (t) != fn)\n+\t{\n+\t  inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n+\t\t\t\t    \"because it contains a nonlocal goto\";\n+\t  return node;\n+\t}\n+\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      /* We cannot inline a function of the form\n+\n+\t   void F (int i) { struct S { int ar[i]; } s; }\n+\n+\t Attempting to do so produces a catch-22.\n+\t If walk_tree examines the TYPE_FIELDS chain of RECORD_TYPE/\n+\t UNION_TYPE nodes, then it goes into infinite recursion on a\n+\t structure containing a pointer to its own type.  If it doesn't,\n+\t then the type node for S doesn't get adjusted properly when\n+\t F is inlined, and we abort in find_function_data.  */\n+      for (t = TYPE_FIELDS (node); t; t = TREE_CHAIN (t))\n+\tif (variably_modified_type_p (TREE_TYPE (t)))\n+\t  {\n+\t    inline_forbidden_reason = \"%Hfunction '%F' can never be inlined \"\n+\t\t\t\t      \"because it uses variable sized variables\";\n+\t    return node;\n+\t  }\n+#endif\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n }\n \n+/* Return subexpression representing possible alloca call, if any.  */\n static tree\n-find_builtin_longjmp_call (tree exp)\n+inline_forbidden_p (tree fndecl)\n {\n   location_t saved_loc = input_location;\n   tree ret = walk_tree_without_duplicates\n-\t\t(&exp, find_builtin_longjmp_call_1, NULL);\n+\t\t(&DECL_SAVED_TREE (fndecl), inline_forbidden_p_1, fndecl);\n   input_location = saved_loc;\n   return ret;\n }\n@@ -935,8 +1029,6 @@ static bool\n inlinable_function_p (tree fn)\n {\n   bool inlinable = true;\n-  bool calls_builtin_longjmp = false;\n-  bool calls_alloca = false;\n \n   /* If we've already decided this function shouldn't be inlined,\n      there's no need to check again.  */\n@@ -980,24 +1072,7 @@ inlinable_function_p (tree fn)\n     inlinable = false;\n #endif /* INLINER_FOR_JAVA */\n \n-  /* We can't inline functions that call __builtin_longjmp at all.\n-     The non-local goto machinery really requires the destination\n-     be in a different function.  If we allow the function calling\n-     __builtin_longjmp to be inlined into the function calling\n-     __builtin_setjmp, Things will Go Awry.  */\n-  /* ??? Need front end help to identify \"regular\" non-local goto.  */\n-  else if (find_builtin_longjmp_call (DECL_SAVED_TREE (fn)))\n-    calls_builtin_longjmp = true;\n-\n-  /* Refuse to inline alloca call unless user explicitly forced so as this\n-     may change program's memory overhead drastically when the function\n-     using alloca is called in loop.  In GCC present in SPEC2000 inlining\n-     into schedule_block cause it to require 2GB of ram instead of 256MB.  */\n-  else if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL\n-\t   && find_alloca_call (DECL_SAVED_TREE (fn)))\n-    calls_alloca = true;\n-\n-  if (calls_builtin_longjmp || calls_alloca)\n+  else if (inline_forbidden_p (fn))\n     {\n       /* See if we should warn about uninlinable functions.  Previously,\n \t some of these warnings would be issued while trying to expand\n@@ -1012,13 +1087,8 @@ inlinable_function_p (tree fn)\n \t\t\t && DECL_DECLARED_INLINE_P (fn)\n \t\t\t && !DECL_IN_SYSTEM_HEADER (fn));\n \n-      if (do_warning && calls_builtin_longjmp)\n-\twarning (\"%Hfunction '%F' can never be inlined because it uses \"\n-\t\t \"setjmp-longjmp exception handling\",\n-\t\t &DECL_SOURCE_LOCATION (fn), fn);\n-      if (do_warning && calls_alloca)\n-\twarning (\"%Hfunction '%F' can never be inlined because it uses \"\n-\t\t \"setjmp-longjmp exception handling\",\n+      if (do_warning)\n+\twarning (inline_forbidden_reason,\n \t\t &DECL_SOURCE_LOCATION (fn), fn);\n \n       inlinable = false;"}]}