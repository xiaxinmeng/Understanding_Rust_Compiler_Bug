{"sha": "1e718ec51a223d65a09757b999202390871b778d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU3MThlYzUxYTIyM2Q2NWEwOTc1N2I5OTkyMDIzOTA4NzFiNzc4ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-10T14:39:15Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-09-10T14:41:53Z"}, "message": "libstdc++: Reduce monotonic_buffer_resource overallocation [PR 96942]\n\nThe primary reason for this change is to reduce the size of buffers\nallocated by std::pmr::monotonic_buffer_resource. Previously, a new\nbuffer would always add the size of the linked list node (11 bytes) and\nthen round up to the next power of two. This results in a huge increase\nif the expected size of the next buffer is already a power of two. For\nexample, if the resource is constructed with a desired initial size of\n4096 the first buffer it allocates will be std::bit_ceil(4096+11) which\nis 8192.  If the user has carefully selected the initial size to match\ntheir expected memory requirements then allocating double that amount\nwastes a lot of memory.\n\nAfter this patch the allocated size will be rounded up to a 64-byte\nboundary, instead of to a power of two. This means for an initial size\nof 4096 only 4160 bytes get allocated.\n\nPreviously only the base-2 logarithm of the size was stored, which could\nbe stored in a single 8-bit integer. Now that the size isn't always a\npower of two we need to use more bits to store it. As the size is always\na multiple of 64 the low six bits are not needed, and so we can use the\nsame approach that the pool resources already use of storing the base-2\nlogarithm of the alignment in the low bits that are not used for the\nsize. To avoid code duplication, a new aligned_size<N> helper class is\nintroduced by this patch, which is then used by both the pool resources'\nbig_block type and the monotonic_buffer_resource::_Chunk type.\n\nOriginally the big_block type used two bit-fields to store the size and\nalignment in the space of a single size_t member. The aligned_size type\nuses a single size_t member and uses masks and bitwise operations to\nmanipulate the size and alignment values. This results in better code\nthan the old version, because the bit-fields weren't optimally ordered\nfor little endian architectures, so the alignment was actually stored in\nthe high bits, not the unused low bits, requiring additional shifts to\ncalculate the values. Using bitwise operations directly avoids needing\nto reorder the bit-fields depending on the endianness.\n\nWhile adapting the _Chunk and big_block types to use aligned_size<N> I\nalso added checks for size overflows (technically, unsigned wraparound).\nThe memory resources now ensure that when they require an allocation\nthat is too large to represent in size_t they will request SIZE_MAX\nbytes from the upstream resource, rather than requesting a small value\nthat results from wrapround. The testsuite is enhanced to verify this.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/96942\n\t* include/std/memory_resource (monotonic_buffer_resource::do_allocate):\n\tUse __builtin_expect when checking if a new buffer needs to be\n\tallocated from the upstream resource, and for checks for edge\n\tcases like zero sized buffers and allocations.\n\t* src/c++17/memory_resource.cc (aligned_size): New class template.\n\t(aligned_ceil): New helper function to round up to a given\n\talignment.\n\t(monotonic_buffer_resource::chunk): Replace _M_size and _M_align\n\twith an aligned_size member. Remove _M_canary member. Change _M_next\n\tto pointer instead of unaligned buffer.\n\t(monotonic_buffer_resource::chunk::allocate): Round up to multiple\n\tof 64 instead of to power of two. Check for size overflow. Remove\n\tredundant check for minimum required alignment.\n\t(monotonic_buffer_resource::chunk::release): Adjust for changes\n\tto data members.\n\t(monotonic_buffer_resource::_M_new_buffer): Use aligned_ceil.\n\t(big_block): Replace _M_size and _M_align with aligned_size\n\tmember.\n\t(big_block::big_block): Check for size overflow.\n\t(big_block::size, big_block::align): Adjust to use aligned_size.\n\t(big_block::alloc_size): Use aligned_ceil.\n\t(munge_options): Use aligned_ceil.\n\t(__pool_resource::allocate): Use big_block::align for alignment.\n\t* testsuite/20_util/monotonic_buffer_resource/allocate.cc: Check\n\tupstream resource gets expected values for impossible sizes.\n\t* testsuite/20_util/unsynchronized_pool_resource/allocate.cc:\n\tLikewise. Adjust checks for expected alignment in existing test.", "tree": {"sha": "92190db08a2fadf244970c2aef02f5846f298d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92190db08a2fadf244970c2aef02f5846f298d80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e718ec51a223d65a09757b999202390871b778d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e718ec51a223d65a09757b999202390871b778d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e718ec51a223d65a09757b999202390871b778d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e718ec51a223d65a09757b999202390871b778d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f40866967d69079fdde293feb32d2eb52cb93cc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40866967d69079fdde293feb32d2eb52cb93cc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40866967d69079fdde293feb32d2eb52cb93cc8"}], "stats": {"total": 272, "additions": 203, "deletions": 69}, "files": [{"sha": "3db22978294e08d75df6029ddc53267ddbde3062", "filename": "libstdc++-v3/include/std/memory_resource", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e718ec51a223d65a09757b999202390871b778d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e718ec51a223d65a09757b999202390871b778d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory_resource?ref=1e718ec51a223d65a09757b999202390871b778d", "patch": "@@ -636,11 +636,11 @@ namespace pmr\n     void*\n     do_allocate(size_t __bytes, size_t __alignment) override\n     {\n-      if (__bytes == 0)\n+      if (__builtin_expect(__bytes == 0, false))\n \t__bytes = 1; // Ensures we don't return the same pointer twice.\n \n       void* __p = std::align(__alignment, __bytes, _M_current_buf, _M_avail);\n-      if (!__p)\n+      if (__builtin_expect(__p == nullptr, false))\n \t{\n \t  _M_new_buffer(__bytes, __alignment);\n \t  __p = _M_current_buf;\n@@ -671,7 +671,7 @@ namespace pmr\n     static size_t\n     _S_next_bufsize(size_t __buffer_size) noexcept\n     {\n-      if (__buffer_size == 0)\n+      if (__builtin_expect(__buffer_size == 0, false))\n \t__buffer_size = 1;\n       return __buffer_size * _S_growth_factor;\n     }"}, {"sha": "392d72ef32df472ffefa5f5be58824625407dbd2", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 91, "deletions": 65, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e718ec51a223d65a09757b999202390871b778d/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e718ec51a223d65a09757b999202390871b778d/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=1e718ec51a223d65a09757b999202390871b778d", "patch": "@@ -175,6 +175,47 @@ namespace pmr\n   // versions will not use this symbol.\n   monotonic_buffer_resource::~monotonic_buffer_resource() { release(); }\n \n+  namespace {\n+\n+  // aligned_size<N> stores the size and alignment of a memory allocation.\n+  // The size must be a multiple of N, leaving the low log2(N) bits free\n+  // to store the base-2 logarithm of the alignment.\n+  // For example, allocate(1024, 32) is stored as 1024 + log2(32) = 1029.\n+  template<unsigned N>\n+  struct aligned_size\n+  {\n+    // N must be a power of two\n+    static_assert( std::__popcount(N) == 1 );\n+\n+    static constexpr size_t _S_align_mask = N - 1;\n+    static constexpr size_t _S_size_mask = ~_S_align_mask;\n+\n+    constexpr\n+    aligned_size(size_t sz, size_t align) noexcept\n+    : value(sz | (std::__bit_width(align) - 1u))\n+    {\n+      __glibcxx_assert(size() == sz); // sz must be a multiple of N\n+    }\n+\n+    constexpr size_t\n+    size() const noexcept\n+    { return value & _S_size_mask; }\n+\n+    constexpr size_t\n+    alignment() const noexcept\n+    { return size_t(1) << (value & _S_align_mask); }\n+\n+    size_t value; // size | log2(alignment)\n+  };\n+\n+  // Round n up to a multiple of alignment, which must be a power of two.\n+  constexpr size_t aligned_ceil(size_t n, size_t alignment)\n+  {\n+    return (n + alignment - 1) & ~(alignment - 1);\n+  }\n+\n+  } // namespace\n+\n   // Memory allocated by the upstream resource is managed in a linked list\n   // of _Chunk objects. A _Chunk object recording the size and alignment of\n   // the allocated block and a pointer to the previous chunk is placed\n@@ -189,23 +230,26 @@ namespace pmr\n     allocate(memory_resource* __r, size_t __size, size_t __align,\n \t     _Chunk*& __head)\n     {\n-      __size = std::__bit_ceil(__size + sizeof(_Chunk));\n+      const size_t __orig_size = __size;\n+\n+      // Add space for the _Chunk object and round up to 64 bytes.\n+      __size = aligned_ceil(__size + sizeof(_Chunk), 64);\n \n-      if constexpr (alignof(_Chunk) > 1)\n+      // Check for unsigned wraparound\n+      if (__size < __orig_size) [[unlikely]]\n \t{\n-\t  // PR libstdc++/90046\n-\t  // For targets like epiphany-elf where alignof(_Chunk) != 1\n-\t  // ensure that the last sizeof(_Chunk) bytes in the buffer\n-\t  // are suitably-aligned for a _Chunk.\n-\t  // This should be unnecessary, because the caller already\n-\t  // passes in max(__align, alignof(max_align_t)).\n-\t  if (__align < alignof(_Chunk))\n-\t    __align = alignof(_Chunk);\n+\t  // monotonic_buffer_resource::do_allocate is not allowed to throw.\n+\t  // If the required size is too large for size_t then ask the\n+\t  // upstream resource for an impossibly large size and alignment.\n+\t  __size = -1;\n+\t  __align = ~(size_t(-1) >> 1);\n \t}\n \n       void* __p = __r->allocate(__size, __align);\n \n       // Add a chunk defined by (__p, __size, __align) to linked list __head.\n+      // We know the end of the buffer is suitably-aligned for a _Chunk\n+      // because the caller ensured __align is at least alignof(max_align_t).\n       void* const __back = (char*)__p + __size - sizeof(_Chunk);\n       __head = ::new(__back) _Chunk(__size, __align, __head);\n       return { __p, __size - sizeof(_Chunk) };\n@@ -220,41 +264,28 @@ namespace pmr\n       while (__next)\n \t{\n \t  _Chunk* __ch = __next;\n-\t  __builtin_memcpy(&__next, __ch->_M_next, sizeof(_Chunk*));\n-\n-\t  __glibcxx_assert(__ch->_M_canary != 0);\n-\t  __glibcxx_assert(__ch->_M_canary == (__ch->_M_size|__ch->_M_align));\n-\n-\t  if (__ch->_M_canary != (__ch->_M_size | __ch->_M_align))\n-\t    return; // buffer overflow detected!\n-\n-\t  size_t __size = (size_t)1 << __ch->_M_size;\n-\t  size_t __align = (size_t)1 << __ch->_M_align;\n+\t  __next = __ch->_M_next;\n+\t  size_t __size = __ch->_M_size.size();\n+\t  size_t __align = __ch->_M_size.alignment();\n \t  void* __start = (char*)(__ch + 1) - __size;\n \t  __r->deallocate(__start, __size, __align);\n \t}\n     }\n \n   private:\n     _Chunk(size_t __size, size_t __align, _Chunk* __next) noexcept\n-    : _M_size(std::__bit_width(__size) - 1),\n-      _M_align(std::__bit_width(__align) - 1)\n-    {\n-      __builtin_memcpy(_M_next, &__next, sizeof(__next));\n-      _M_canary = _M_size | _M_align;\n-    }\n+    : _M_size(__size, __align), _M_next(__next)\n+    { }\n \n-    unsigned char _M_canary;\n-    unsigned char _M_size;\n-    unsigned char _M_align;\n-    unsigned char _M_next[sizeof(_Chunk*)];\n+    aligned_size<64> _M_size;\n+    _Chunk* _M_next;\n   };\n \n   void\n   monotonic_buffer_resource::_M_new_buffer(size_t bytes, size_t alignment)\n   {\n     const size_t n = std::max(bytes, _M_next_bufsiz);\n-    const size_t m = std::max(alignment, alignof(std::max_align_t));\n+    const size_t m = aligned_ceil(alignment, alignof(std::max_align_t));\n     auto [p, size] = _Chunk::allocate(_M_upstream, n, m, _M_head);\n     _M_current_buf = p;\n     _M_avail = size;\n@@ -550,49 +581,43 @@ namespace pmr\n   // An oversized allocation that doesn't fit in a pool.\n   struct big_block\n   {\n-    // Alignment must be a power-of-two so we only need to use enough bits\n-    // to store the power, not the actual value:\n-    static constexpr unsigned _S_alignbits\n-      = std::__bit_width((unsigned)numeric_limits<size_t>::digits - 1);\n-    // Use the remaining bits to store the size:\n-    static constexpr unsigned _S_sizebits\n-      = numeric_limits<size_t>::digits - _S_alignbits;\n-    // The maximum value that can be stored in _S_size\n-    static constexpr size_t all_ones = size_t(-1) >> _S_alignbits;\n-    // The minimum size of a big block (smaller sizes will be rounded up).\n-    static constexpr size_t min = 1u << _S_alignbits;\n+    // The minimum size of a big block.\n+    // All big_block allocations will be a multiple of this value.\n+    // Use bit_ceil to get a power of two even for e.g. 20-bit size_t.\n+    static constexpr size_t min = __bit_ceil(numeric_limits<size_t>::digits);\n \n+    constexpr\n     big_block(size_t bytes, size_t alignment)\n-    : _M_size(alloc_size(bytes) >> _S_alignbits),\n-      _M_align_exp(std::__bit_width(alignment) - 1u)\n-    { }\n+    : _M_size(alloc_size(bytes), alignment)\n+    {\n+      // Check for unsigned wraparound\n+      if (size() < bytes) [[unlikely]]\n+\t{\n+\t  // (sync|unsync)_pool_resource::do_allocate is not allowed to throw.\n+\t  // If the required size is too large for size_t then ask the\n+\t  // upstream resource for an impossibly large size and alignment.\n+\t  _M_size.value = -1;\n+\t}\n+    }\n \n     void* pointer = nullptr;\n-    size_t _M_size : numeric_limits<size_t>::digits - _S_alignbits;\n-    size_t _M_align_exp : _S_alignbits;\n+    aligned_size<min> _M_size;\n \n     size_t size() const noexcept\n     {\n-      // If all bits are set in _M_size it means the maximum possible size:\n-      if (__builtin_expect(_M_size == (size_t(-1) >> _S_alignbits), false))\n-\treturn (size_t)-1;\n-      else\n-\treturn _M_size << _S_alignbits;\n+      if (_M_size.value == size_t(-1)) [[unlikely]]\n+\treturn size_t(-1);\n+      return _M_size.size();\n     }\n \n-    size_t align() const noexcept { return size_t(1) << _M_align_exp; }\n+    size_t align() const noexcept\n+    { return _M_size.alignment(); }\n \n     // Calculate size to be allocated instead of requested number of bytes.\n     // The requested value will be rounded up to a multiple of big_block::min,\n-    // so the low _S_alignbits bits are all zero and don't need to be stored.\n+    // so the low bits are all zero and can be used to hold the alignment.\n     static constexpr size_t alloc_size(size_t bytes) noexcept\n-    {\n-      const size_t s = bytes + min - 1u;\n-      if (__builtin_expect(s < bytes, false))\n-\treturn size_t(-1); // addition wrapped past zero, return max value\n-      else\n-\treturn s & ~(min - 1u);\n-    }\n+    { return aligned_ceil(bytes, min); }\n \n     friend bool operator<(void* p, const big_block& b) noexcept\n     { return less<void*>{}(p, b.pointer); }\n@@ -895,9 +920,8 @@ namespace pmr\n       {\n \t// Round to preferred granularity\n \tstatic_assert(std::__has_single_bit(pool_sizes[0]));\n-\tconstexpr size_t mask = pool_sizes[0] - 1;\n-\topts.largest_required_pool_block += mask;\n-\topts.largest_required_pool_block &= ~mask;\n+\topts.largest_required_pool_block\n+\t  = aligned_ceil(opts.largest_required_pool_block, pool_sizes[0]);\n       }\n \n     if (opts.largest_required_pool_block < big_block::min)\n@@ -964,7 +988,9 @@ namespace pmr\n     auto& b = _M_unpooled.emplace_back(bytes, alignment);\n     __try {\n       // N.B. need to allocate b.size(), which might be larger than bytes.\n-      void* p = resource()->allocate(b.size(), alignment);\n+      // Also use b.align() instead of alignment parameter, which will be\n+      // an impossibly large value if (bytes+bookkeeping) > SIZE_MAX.\n+      void* p = resource()->allocate(b.size(), b.align());\n       b.pointer = p;\n       if (_M_unpooled.size() > 1)\n \t{"}, {"sha": "637bdf1b30ec461b8b0d8e78266ea706a24e7024", "filename": "libstdc++-v3/testsuite/20_util/monotonic_buffer_resource/allocate.cc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e718ec51a223d65a09757b999202390871b778d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fallocate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e718ec51a223d65a09757b999202390871b778d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fallocate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmonotonic_buffer_resource%2Fallocate.cc?ref=1e718ec51a223d65a09757b999202390871b778d", "patch": "@@ -210,6 +210,51 @@ test06()\n   }\n }\n \n+void\n+test07()\n+{\n+  // Custom exception thrown on expected allocation failure.\n+  struct very_bad_alloc : std::bad_alloc { };\n+\n+  struct careful_resource : __gnu_test::memory_resource\n+  {\n+    void* do_allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+      // pmr::monotonic_buffer_resource::do_allocate is not allowed to\n+      // throw an exception when asked for an allocation it can't satisfy.\n+      // The libstdc++ implementation will ask upstream to allocate\n+      // bytes=SIZE_MAX and alignment=bit_floor(SIZE_MAX) instead of throwing.\n+      // Verify that we got those values:\n+      if (bytes != std::numeric_limits<std::size_t>::max())\n+\tVERIFY( !\"upstream allocation should request maximum number of bytes\" );\n+      if (alignment != (1 + std::numeric_limits<std::size_t>::max() / 2))\n+\tVERIFY( !\"upstream allocation should request maximum alignment\" );\n+\n+      // A successful failure:\n+      throw very_bad_alloc();\n+    }\n+  };\n+\n+  careful_resource cr;\n+  std::pmr::monotonic_buffer_resource mbr(&cr);\n+  try\n+  {\n+    // Try to allocate a ridiculous size:\n+    void* p = mbr.allocate(std::size_t(-2), 1);\n+    // Should not reach here!\n+    VERIFY( !\"attempt to allocate SIZE_MAX-1 should not have succeeded\" );\n+    throw p;\n+  }\n+  catch (const very_bad_alloc&)\n+  {\n+    // Should catch this exception from careful_resource::do_allocate\n+  }\n+  catch (const std::bad_alloc&)\n+  {\n+    VERIFY( !\"monotonic_buffer_resource::do_allocate is not allowed to throw\" );\n+  }\n+}\n+\n int\n main()\n {\n@@ -219,4 +264,5 @@ main()\n   test04();\n   test05();\n   test06();\n+  test07();\n }"}, {"sha": "2775e1260ea1704fd5d1ca89322821e1fb7eb472", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/allocate.cc", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e718ec51a223d65a09757b999202390871b778d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e718ec51a223d65a09757b999202390871b778d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Fallocate.cc?ref=1e718ec51a223d65a09757b999202390871b778d", "patch": "@@ -189,7 +189,16 @@ test06()\n       if (bytes < expected_size)\n \tthrow bad_size();\n       else if (align != expected_alignment)\n-\tthrow bad_alignment();\n+      {\n+\tif (bytes == std::numeric_limits<std::size_t>::max()\n+\t    && align == (1 + std::numeric_limits<std::size_t>::max() / 2))\n+\t{\n+\t  // Pool resources request bytes=SIZE_MAX && align=bit_floor(SIZE_MAX)\n+\t  // when they are unable to meet an allocation request.\n+\t}\n+\telse\n+\t  throw bad_alignment();\n+      }\n       // Else just throw, don't really try to allocate:\n       throw std::bad_alloc();\n     }\n@@ -239,6 +248,58 @@ test06()\n   }\n }\n \n+void\n+test07()\n+{\n+  // Custom exception thrown on expected allocation failure.\n+  struct very_bad_alloc : std::bad_alloc { };\n+\n+  struct careful_resource : __gnu_test::memory_resource\n+  {\n+    void* do_allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+      // Need to allow normal allocations for the pool resource's internal\n+      // data structures:\n+      if (alignment < 1024)\n+\treturn __gnu_test::memory_resource::do_allocate(bytes, alignment);\n+\n+      // pmr::unsynchronized_pool_resource::do_allocate is not allowed to\n+      // throw an exception when asked for an allocation it can't satisfy.\n+      // The libstdc++ implementation will ask upstream to allocate\n+      // bytes=SIZE_MAX and alignment=bit_floor(SIZE_MAX) instead of throwing.\n+      // Verify that we got those values:\n+      if (bytes != std::numeric_limits<size_t>::max())\n+\tVERIFY( !\"upstream allocation should request SIZE_MAX bytes\" );\n+      if (alignment != (1 + std::numeric_limits<size_t>::max() / 2))\n+\tVERIFY( !\"upstream allocation should request SIZE_MAX/2 alignment\" );\n+\n+      // A successful failure:\n+      throw very_bad_alloc();\n+    }\n+  };\n+\n+  careful_resource cr;\n+  std::pmr::unsynchronized_pool_resource upr(&cr);\n+  try\n+  {\n+    // Try to allocate a ridiculous size (and use a large extended alignment\n+    // so that careful_resource::do_allocate can distinguish this allocation\n+    // from any required for the pool resource's internal data structures):\n+    void* p = upr.allocate(std::size_t(-2), 1024);\n+    // Should not reach here!\n+    VERIFY( !\"attempt to allocate SIZE_MAX-1 should not have succeeded\" );\n+    throw p;\n+  }\n+  catch (const very_bad_alloc&)\n+  {\n+    // Should catch this exception from careful_resource::do_allocate\n+  }\n+  catch (const std::bad_alloc&)\n+  {\n+    VERIFY( !\"unsynchronized_pool_resource::do_allocate is not allowed to throw\" );\n+  }\n+}\n+\n int\n main()\n {\n@@ -248,4 +309,5 @@ main()\n   test04();\n   test05();\n   test06();\n+  test07();\n }"}]}