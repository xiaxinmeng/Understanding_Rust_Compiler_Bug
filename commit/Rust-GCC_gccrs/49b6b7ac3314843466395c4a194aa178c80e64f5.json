{"sha": "49b6b7ac3314843466395c4a194aa178c80e64f5", "node_id": "C_kwDOANBUbNoAKDQ5YjZiN2FjMzMxNDg0MzQ2NjM5NWM0YTE5NGFhMTc4YzgwZTY0ZjU", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-12-20T16:09:11Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-12-20T16:09:11Z"}, "message": "c++: NTTP object wrapper substitution fixes [PR103346, ...]\n\nThis patch fixes some issues with substitution into a C++20 template\nparameter object wrapper:\n\n* The first testcase demonstrates a situation where the same_type_p\n  assert in relevant case of tsubst_copy doesn't hold, because (partial)\n  substitution of {int,} into the wrapper's TREE_TYPE yields A<int> but\n  substitution into the underlying TEMPLATE_PARM_INDEX is a nop due to\n  tsubst's level==1/tf_partial early exit tests, hence TREE_TYPE in the\n  latter case remains A<T>.  So this patch just gets rid of the assert;\n  the type mismatch doesn't seem to be a problem in practice.\n\n* In the second testcase, dependent substitution into the underlying\n  TEMPLATE_PARM_INDEX yields a CALL_EXPR with empty TREE_TYPE, which\n  tsubst_copy doesn't expect.  This patch fixes this by handling empty\n  TREE_TYPE the same way as a non-const TREE_TYPE.  Moreover, after\n  this substitution we're left with a VIEW_CONVERT_EXPR wrapping a\n  CALL_EXPR instead of a TEMPLATE_PARM_INDEX, which during the subsequent\n  non-dependent substitution tsubst_copy doesn't expect either.  So\n  this patch also relaxes tsubst_copy to accept such VIEW_CONVERT_EXPR\n  too.\n\n* In the third testcase, we end up never resolving the call to\n  f.modify() because tsubst_copy doesn't do overload resolution.\n  This patch fixes this by moving the handling of these\n  VIEW_CONVERT_EXPR wrappers from tsubst_copy to tsubst_copy_and_build.\n  For good measure tsubst_copy_and_build should also handle\n  REF_PARENTHESIZED_P wrappers instead of delegating to tsubst_copy.\n\n\tPR c++/103346\n\tPR c++/104278\n\tPR c++/102553\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (tsubst_copy) <case VIEW_CONVERT_EXPR>: Move the\n\thandling of C++20 template parameter object wrappers to ...\n\t(tsubst_copy_and_build) <case VIEW_CONVERT_EXPR>: ... here.\n\tAccept non-TEMPLATE_PARM_INDEX inner operand.  Handle empty\n\tTREE_TYPE on substituted inner operand.  Remove same_type_p\n\tassert.  Also handle REF_PARENTHESIZED_P VIEW_CONVERT_EXPRs.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/nontype-class52a.C: New test.\n\t* g++.dg/cpp2a/nontype-class53.C: New test.\n\t* g++.dg/cpp2a/nontype-class54.C: New test.\n\t* g++.dg/cpp2a/nontype-class55.C: New test.", "tree": {"sha": "72467648d5a3621aa22f50f9bb987f3f69d26ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72467648d5a3621aa22f50f9bb987f3f69d26ece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49b6b7ac3314843466395c4a194aa178c80e64f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b6b7ac3314843466395c4a194aa178c80e64f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49b6b7ac3314843466395c4a194aa178c80e64f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49b6b7ac3314843466395c4a194aa178c80e64f5/comments", "author": null, "committer": null, "parents": [{"sha": "0bdd2261c254f08b0f4437c156b79711d68c6e7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bdd2261c254f08b0f4437c156b79711d68c6e7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bdd2261c254f08b0f4437c156b79711d68c6e7f"}], "stats": {"total": 152, "additions": 117, "deletions": 35}, "files": [{"sha": "83da1ba1bf5adaf3ea2dcf8f77cbf40a6d6a5d88", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=49b6b7ac3314843466395c4a194aa178c80e64f5", "patch": "@@ -17338,42 +17338,16 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t      return maybe_wrap_with_location (op0, EXPR_LOCATION (t));\n \t    }\n \t  tree op = TREE_OPERAND (t, 0);\n-\t  if (code == VIEW_CONVERT_EXPR\n-\t      && TREE_CODE (op) == TEMPLATE_PARM_INDEX)\n-\t    {\n-\t      /* Wrapper to make a C++20 template parameter object const.  */\n-\t      op = tsubst_copy (op, args, complain, in_decl);\n-\t      if (!CP_TYPE_CONST_P (TREE_TYPE (op)))\n-\t\t{\n-\t\t  /* The template argument is not const, presumably because\n-\t\t     it is still dependent, and so not the const template parm\n-\t\t     object.  */\n-\t\t  tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\t\t  gcc_checking_assert (same_type_ignoring_top_level_qualifiers_p\n-\t\t\t\t       (type, TREE_TYPE (op)));\n-\t\t  if (TREE_CODE (op) == CONSTRUCTOR\n-\t\t      || TREE_CODE (op) == IMPLICIT_CONV_EXPR)\n-\t\t    {\n-\t\t      /* Don't add a wrapper to these.  */\n-\t\t      op = copy_node (op);\n-\t\t      TREE_TYPE (op) = type;\n-\t\t    }\n-\t\t  else\n-\t\t    /* Do add a wrapper otherwise (in particular, if op is\n-\t\t       another TEMPLATE_PARM_INDEX).  */\n-\t\t    op = build1 (code, type, op);\n-\t\t}\n-\t      return op;\n-\t    }\n \t  /* force_paren_expr can also create a VIEW_CONVERT_EXPR.  */\n-\t  else if (code == VIEW_CONVERT_EXPR && REF_PARENTHESIZED_P (t))\n+\t  if (code == VIEW_CONVERT_EXPR && REF_PARENTHESIZED_P (t))\n \t    {\n \t      op = tsubst_copy (op, args, complain, in_decl);\n \t      op = build1 (code, TREE_TYPE (op), op);\n \t      REF_PARENTHESIZED_P (op) = true;\n \t      return op;\n \t    }\n-\t  /* We shouldn't see any other uses of these in templates.  */\n+\t  /* We shouldn't see any other uses of these in templates\n+\t     (tsubst_copy_and_build handles C++20 tparm object wrappers).  */\n \t  gcc_unreachable ();\n \t}\n \n@@ -21636,12 +21610,42 @@ tsubst_copy_and_build (tree t,\n \n     case NON_LVALUE_EXPR:\n     case VIEW_CONVERT_EXPR:\n-      if (location_wrapper_p (t))\n-\t/* We need to do this here as well as in tsubst_copy so we get the\n-\t   other tsubst_copy_and_build semantics for a PARM_DECL operand.  */\n-\tRETURN (maybe_wrap_with_location (RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t\t\t  EXPR_LOCATION (t)));\n-      /* fallthrough.  */\n+      {\n+\ttree op = RECUR (TREE_OPERAND (t, 0));\n+\n+\tif (location_wrapper_p (t))\n+\t  /* We need to do this here as well as in tsubst_copy so we get the\n+\t     other tsubst_copy_and_build semantics for a PARM_DECL operand.  */\n+\t  RETURN (maybe_wrap_with_location (op, EXPR_LOCATION (t)));\n+\n+\tgcc_checking_assert (TREE_CODE (t) == VIEW_CONVERT_EXPR);\n+\tif (REF_PARENTHESIZED_P (t))\n+\t  /* force_paren_expr can also create a VIEW_CONVERT_EXPR.  */\n+\t  RETURN (finish_parenthesized_expr (op));\n+\n+\t/* Otherwise, we're dealing with a wrapper to make a C++20 template\n+\t   parameter object const.  */\n+\tif (TREE_TYPE (op) == NULL_TREE\n+\t    || !CP_TYPE_CONST_P (TREE_TYPE (op)))\n+\t  {\n+\t    /* The template argument is not const, presumably because\n+\t       it is still dependent, and so not the const template parm\n+\t       object.  */\n+\t    tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\t    if (TREE_CODE (op) == CONSTRUCTOR\n+\t\t|| TREE_CODE (op) == IMPLICIT_CONV_EXPR)\n+\t      {\n+\t\t/* Don't add a wrapper to these.  */\n+\t\top = copy_node (op);\n+\t\tTREE_TYPE (op) = type;\n+\t      }\n+\t    else\n+\t      /* Do add a wrapper otherwise (in particular, if op is\n+\t\t another TEMPLATE_PARM_INDEX).  */\n+\t      op = build1 (VIEW_CONVERT_EXPR, type, op);\n+\t  }\n+\tRETURN (op);\n+      }\n \n     default:\n       /* Handle Objective-C++ constructs, if appropriate.  */"}, {"sha": "ae5d5df70aca86d3849c920d0f6115590a23bf71", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class52a.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class52a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class52a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class52a.C?ref=49b6b7ac3314843466395c4a194aa178c80e64f5", "patch": "@@ -0,0 +1,15 @@\n+// A version of nontype-class52.C where explicit template arguments are\n+// given in the call to f (which during deduction need to be partially\n+// substituted into the NTTP object V in f's signature).\n+// { dg-do compile { target c++20 } }\n+\n+template<class> struct A { };\n+\n+template<auto> struct B { };\n+\n+template<class T, A<T> V> void f(B<V>);\n+\n+int main() {\n+  constexpr A<int> a;\n+  f<int>(B<a>{});\n+}"}, {"sha": "9a6398c5f57e68a8d894ece83c708aa1fec4472e", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class53.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class53.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class53.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class53.C?ref=49b6b7ac3314843466395c4a194aa178c80e64f5", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/103346\n+// { dg-do compile { target c++20 } }\n+\n+struct Item {};\n+\n+template<class T, T... ts>\n+struct Sequence { };\n+\n+template<Item... items>\n+using ItemSequence = Sequence<Item, items...>;\n+\n+template<Item... items>\n+constexpr auto f() {\n+  constexpr auto l = [](Item item) { return item; };\n+  return ItemSequence<l(items)...>{};\n+}\n+\n+using ty0 = decltype(f<>());\n+using ty0 = ItemSequence<>;\n+\n+using ty1 = decltype(f<{}>());\n+using ty1 = ItemSequence<{}>;\n+\n+using ty3 = decltype(f<{}, {}, {}>());\n+using ty3 = ItemSequence<{}, {}, {}>;"}, {"sha": "8127b1f54267257d8369f5abd5df938fe8303f50", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class54.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class54.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class54.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class54.C?ref=49b6b7ac3314843466395c4a194aa178c80e64f5", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/104278\n+// { dg-do compile { target c++20 } }\n+\n+struct foo {\n+  int value;\n+  constexpr foo modify() const { return { value + 1 }; }\n+};\n+\n+template<foo f, bool Enable = f.value & 1>\n+struct bar {\n+  static void run() { }\n+};\n+\n+template<foo f>\n+struct qux {\n+  static void run() {\n+    bar<f.modify()>::run();\n+  }\n+};\n+\n+int main() {\n+  qux<foo{}>::run();\n+}"}, {"sha": "afcb3d6449542c4616226070bce162f74cdcf50e", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class55.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class55.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49b6b7ac3314843466395c4a194aa178c80e64f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class55.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class55.C?ref=49b6b7ac3314843466395c4a194aa178c80e64f5", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/102553\n+// { dg-do compile { target c++20 } }\n+\n+struct s1{};\n+template<int> inline constexpr s1 ch{};\n+\n+template<s1 f> struct s2{};\n+template<s1 f> using alias1 = s2<f>;\n+\n+template<class T>\n+void general(int n) {\n+  alias1<ch<1>>{};\n+}\n+\n+template void general<int>(int);"}]}