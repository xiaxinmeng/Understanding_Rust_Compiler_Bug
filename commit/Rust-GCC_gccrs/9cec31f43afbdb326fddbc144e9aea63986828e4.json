{"sha": "9cec31f43afbdb326fddbc144e9aea63986828e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNlYzMxZjQzYWZiZGIzMjZmZGRiYzE0NGU5YWVhNjM5ODY4MjhlNA==", "commit": {"author": {"name": "Martin Liska", "email": "marxin.liska@gmail.com", "date": "2013-12-17T22:20:12Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2013-12-17T22:20:12Z"}, "message": "Time profile-based function reordering (phase 2).\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r206070", "tree": {"sha": "3ad29a01dabd9e49f49f9ebdc04f7655721d6300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ad29a01dabd9e49f49f9ebdc04f7655721d6300"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cec31f43afbdb326fddbc144e9aea63986828e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cec31f43afbdb326fddbc144e9aea63986828e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cec31f43afbdb326fddbc144e9aea63986828e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cec31f43afbdb326fddbc144e9aea63986828e4/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14407011d62da724e88ac0cb30390d3f8fda2b9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14407011d62da724e88ac0cb30390d3f8fda2b9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14407011d62da724e88ac0cb30390d3f8fda2b9f"}], "stats": {"total": 163, "additions": 148, "deletions": 15}, "files": [{"sha": "2c10c04358d861df726aba6b630ccbec7812bdf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -1,3 +1,14 @@\n+2013-12-18  Martin Liska  <marxin.liska@gmail.com>\n+\t    Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphunit.c (node_cmp): New function.\n+\t(expand_all_functions): Function ordering added.\n+\t* common.opt: New profile based function reordering flag introduced.\n+\t* lto-partition.c: Support for time profile added.\n+\t* lto.c: Likewise.\n+\t* predict.c (handle_missing_profiles): Time profile handled in\n+\t  missing profiles.\n+\n 2013-12-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/59523"}, {"sha": "28f51162bba98f9b9862e8a55050b43160806304", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -1831,6 +1831,23 @@ expand_function (struct cgraph_node *node)\n   ipa_remove_all_references (&node->ref_list);\n }\n \n+/* Node comparer that is responsible for the order that corresponds\n+   to time when a function was launched for the first time.  */\n+\n+static int\n+node_cmp (const void *pa, const void *pb)\n+{\n+  const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n+  const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n+\n+  /* Functions with time profile must be before these without profile.  */\n+  if (!a->tp_first_run || !b->tp_first_run)\n+    return a->tp_first_run - b->tp_first_run;\n+\n+  return a->tp_first_run != b->tp_first_run\n+\t ? b->tp_first_run - a->tp_first_run\n+\t : b->order - a->order;\n+}\n \n /* Expand all functions that must be output.\n \n@@ -1847,6 +1864,7 @@ expand_all_functions (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n+  unsigned int expanded_func_count = 0, profiled_func_count = 0;\n   int order_pos, new_order_pos = 0;\n   int i;\n \n@@ -1859,20 +1877,39 @@ expand_all_functions (void)\n     if (order[i]->process)\n       order[new_order_pos++] = order[i];\n \n+  if (flag_profile_reorder_functions)\n+    qsort (order, new_order_pos, sizeof (struct cgraph_node *), node_cmp);\n+\n   for (i = new_order_pos - 1; i >= 0; i--)\n     {\n       node = order[i];\n+\n       if (node->process)\n \t{\n+     expanded_func_count++;\n+     if(node->tp_first_run)\n+       profiled_func_count++;\n+\n+    if (cgraph_dump_file)\n+      fprintf (cgraph_dump_file, \"Time profile order in expand_all_functions:%s:%d\\n\", node->asm_name (), node->tp_first_run);\n+\n \t  node->process = 0;\n \t  expand_function (node);\n \t}\n     }\n+\n+    if (dump_file)\n+      fprintf (dump_file, \"Expanded functions with time profile (%s):%u/%u\\n\",\n+               main_input_filename, profiled_func_count, expanded_func_count);\n+\n+  if (cgraph_dump_file && flag_profile_reorder_functions)\n+    fprintf (cgraph_dump_file, \"Expanded functions with time profile:%u/%u\\n\",\n+             profiled_func_count, expanded_func_count);\n+\n   cgraph_process_new_functions ();\n   free_gimplify_stack ();\n \n   free (order);\n-\n }\n \n /* This is used to sort the node types by the cgraph order number.  */\n@@ -2194,6 +2231,7 @@ compile (void)\n #endif\n \n   cgraph_state = CGRAPH_STATE_EXPANSION;\n+\n   if (!flag_toplevel_reorder)\n     output_in_order ();\n   else"}, {"sha": "ea323fdc9c38c95d8f3a345e09eda6368fc24883", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -1712,6 +1712,10 @@ fprofile-report\n Common Report Var(profile_report)\n Report on consistency of profile\n \n+fprofile-reorder-functions\n+Common Report Var(flag_profile_reorder_functions)\n+Enable function reordering that improves code placement\n+\n frandom-seed\n Common Var(common_deferred_options) Defer\n "}, {"sha": "4267c89dc060ca4394f9751d5d638c213035c516", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -3621,9 +3621,16 @@ darwin_function_section (tree decl, enum node_frequency freq,\n      unlikely executed (this happens especially with function splitting\n      where we can split away unnecessary parts of static constructors).  */\n   if (startup && freq != NODE_FREQUENCY_UNLIKELY_EXECUTED)\n-    return (weak)\n-\t    ? darwin_sections[text_startup_coal_section]\n-\t    : darwin_sections[text_startup_section];\n+  {\n+    /* If we do have a profile or(and) LTO phase is executed, we do not need\n+       these ELF section.  */\n+    if (!in_lto_p || !flag_profile_values)\n+      return (weak)\n+\t      ? darwin_sections[text_startup_coal_section]\n+\t      : darwin_sections[text_startup_section];\n+    else\n+      return text_section;\n+  }\n \n   /* Similarly for exit.  */\n   if (exit && freq != NODE_FREQUENCY_UNLIKELY_EXECUTED)\n@@ -3640,10 +3647,15 @@ darwin_function_section (tree decl, enum node_frequency freq,\n \t\t: darwin_sections[text_cold_section];\n \tbreak;\n       case NODE_FREQUENCY_HOT:\n-\treturn (weak)\n-\t\t? darwin_sections[text_hot_coal_section]\n-\t\t: darwin_sections[text_hot_section];\n-\tbreak;\n+      {\n+        /* If we do have a profile or(and) LTO phase is executed, we do not need\n+           these ELF section.  */\n+        if (!in_lto_p || !flag_profile_values)\n+          return (weak)\n+                  ? darwin_sections[text_hot_coal_section]\n+                  : darwin_sections[text_hot_section];\n+        break;\n+      }\n       default:\n \treturn (weak)\n \t\t? darwin_sections[text_coal_section]"}, {"sha": "99ec1d2dce6f2ab86e2fb4d8cc34fb3d254bde9f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -394,7 +394,7 @@ Objective-C and Objective-C++ Dialects}.\n -fprefetch-loop-arrays -fprofile-report @gol\n -fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol\n -fprofile-generate=@var{path} @gol\n--fprofile-use -fprofile-use=@var{path} -fprofile-values @gol\n+-fprofile-use -fprofile-use=@var{path} -fprofile-values -fprofile-reorder-functions @gol\n -freciprocal-math -free -frename-registers -freorder-blocks @gol\n -freorder-blocks-and-partition -freorder-functions @gol\n -frerun-cse-after-loop -freschedule-modulo-scheduled-loops @gol\n@@ -9071,6 +9071,14 @@ from profiling values of expressions for usage in optimizations.\n \n Enabled with @option{-fprofile-generate} and @option{-fprofile-use}.\n \n+@item -fprofile-reoder-functions\n+@opindex fprofile-reorder-functions\n+Function reordering based on profile instrumentation collects\n+first time of execution of a function and orders these functions\n+in ascending order.\n+\n+Enabled with @option{-fprofile-use}.\n+\n @item -fvpt\n @opindex fvpt\n If combined with @option{-fprofile-arcs}, this option instructs the compiler"}, {"sha": "43758b6db7ae36ef4a22f358180b26d14e38a269", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -1234,6 +1234,10 @@ split_function (struct split_point *split_point)\n \t\t\t\t     !split_part_return_p,\n \t\t\t\t     split_point->split_bbs,\n \t\t\t\t     split_point->entry_bb, \"part\");\n+\n+  /* Let's take a time profile for splitted function.  */\n+  node->tp_first_run = cur_node->tp_first_run + 1;\n+\n   /* For usual cloning it is enough to clear builtin only when signature\n      changes.  For partial inlining we however can not expect the part\n      of builtin implementation to have same semantic as the whole.  */"}, {"sha": "66416268f571b014f518b7a25284c7978b139d84", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -655,6 +655,11 @@ ipa_merge_profiles (struct cgraph_node *dst,\n     return;\n   if (src->frequency < dst->frequency)\n     src->frequency = dst->frequency;\n+\n+  /* Time profiles are merged.  */\n+  if (dst->tp_first_run > src->tp_first_run && src->tp_first_run)\n+    dst->tp_first_run = src->tp_first_run;\n+\n   if (!dst->count)\n     return;\n   if (cgraph_dump_file)"}, {"sha": "5e0335ea5a4646f4229e8858bbcbb42ea78b29c1", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -286,9 +286,11 @@ add_symbol_to_partition (ltrans_partition part, symtab_node *node)\n \n      Be lax about comdats; they may or may not be duplicated and we may\n      end up in need to duplicate keyed comdat because it has unkeyed alias.  */\n+\n   gcc_assert (get_symbol_class (node) == SYMBOL_DUPLICATE\n \t      || DECL_COMDAT (node->decl)\n \t      || !symbol_partitioned_p (node));\n+\n   add_symbol_to_partition_1 (part, node);\n }\n \n@@ -401,6 +403,25 @@ node_cmp (const void *pa, const void *pb)\n {\n   const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n   const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n+\n+  /* Profile reorder flag enables function reordering based on first execution\n+     of a function. All functions with profile are placed in ascending\n+     order at the beginning.  */\n+\n+  if (flag_profile_reorder_functions)\n+  {\n+    /* Functions with time profile are sorted in ascending order.  */\n+    if (a->tp_first_run && b->tp_first_run)\n+      return a->tp_first_run != b->tp_first_run\n+\t? a->tp_first_run - b->tp_first_run\n+        : a->order - b->order;\n+\n+    /* Functions with time profile are sorted before the functions\n+       that do not have the profile.  */\n+    if (a->tp_first_run || b->tp_first_run)\n+      return b->tp_first_run - a->tp_first_run;\n+  }\n+\n   return b->order - a->order;\n }\n \n@@ -487,10 +508,13 @@ lto_balanced_map (void)\n      get better about minimizing the function bounday, but until that\n      things works smoother if we order in source order.  */\n   qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n+\n+  if (cgraph_dump_file)\n+    for(i = 0; i < n_nodes; i++)\n+      fprintf (cgraph_dump_file, \"Balanced map symbol order:%s:%u\\n\", order[i]->name (), order[i]->tp_first_run);\n+\n   if (!flag_toplevel_reorder)\n     {\n-      qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n-\n       FOR_EACH_VARIABLE (vnode)\n \tif (get_symbol_class (vnode) == SYMBOL_PARTITION)\n \t  n_varpool_nodes++;\n@@ -855,7 +879,7 @@ may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node *node)\n    of the same name in partition ENCODER (or in whole compilation unit if\n    ENCODER is NULL) and if so, mangle the statics.  Always mangle all\n    conflicting statics, so we reduce changes of silently miscompiling\n-   asm statemnets referring to them by symbol name.  */\n+   asm statements referring to them by symbol name.  */\n \n static void\n rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)"}, {"sha": "8e5eeb3d11f0fd7b145a4a19de538eed30fc4560", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -2503,9 +2503,12 @@ lto_wpa_write_files (void)\n   /* Sort partitions by size so small ones are compiled last.\n      FIXME: Even when not reordering we may want to output one list for parallel make\n      and other for final link command.  */\n-  ltrans_partitions.qsort (flag_toplevel_reorder\n+\n+  if (!flag_profile_reorder_functions || !flag_profile_use)\n+    ltrans_partitions.qsort (flag_toplevel_reorder\n \t\t\t   ? cmp_partitions_size\n \t\t\t   : cmp_partitions_order);\n+\n   for (i = 0; i < n_sets; i++)\n     {\n       size_t len;"}, {"sha": "5be03faa703508afd00c11c6c03e9ddf974447d0", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -1710,6 +1710,8 @@ common_handle_option (struct gcc_options *opts,\n \topts->x_flag_vect_cost_model = VECT_COST_MODEL_DYNAMIC;\n       if (!opts_set->x_flag_tree_loop_distribute_patterns)\n \topts->x_flag_tree_loop_distribute_patterns = value;\n+      if (!opts_set->x_flag_profile_reorder_functions)\n+\topts->x_flag_profile_reorder_functions = value;\n       /* Indirect call profiling should do all useful transformations\n  \t speculative devirtualization does.  */\n       if (!opts_set->x_flag_devirtualize_speculatively"}, {"sha": "1826a0699ecdc946c876aa9616412c02562e30ff", "filename": "gcc/predict.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -2839,12 +2839,24 @@ handle_missing_profiles (void)\n     {\n       struct cgraph_edge *e;\n       gcov_type call_count = 0;\n+      gcov_type max_tp_first_run = 0;\n       struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n \n       if (node->count)\n         continue;\n       for (e = node->callers; e; e = e->next_caller)\n+      {\n         call_count += e->count;\n+\n+\tif (e->caller->tp_first_run > max_tp_first_run)\n+\t  max_tp_first_run = e->caller->tp_first_run;\n+      }\n+\n+      /* If time profile is missing, let assign the maximum that comes from\n+\t caller functions.  */\n+      if (!node->tp_first_run && max_tp_first_run)\n+\tnode->tp_first_run = max_tp_first_run + 1;\n+\n       if (call_count\n           && fn && fn->cfg\n           && (call_count * unlikely_count_fraction >= profile_info->runs))"}, {"sha": "1d2c03e6fbba79ceb0759ebf3c26519ff14ca789", "filename": "gcc/varasm.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cec31f43afbdb326fddbc144e9aea63986828e4/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=9cec31f43afbdb326fddbc144e9aea63986828e4", "patch": "@@ -552,7 +552,14 @@ default_function_section (tree decl, enum node_frequency freq,\n      unlikely executed (this happens especially with function splitting\n      where we can split away unnecessary parts of static constructors.  */\n   if (startup && freq != NODE_FREQUENCY_UNLIKELY_EXECUTED)\n-    return get_named_text_section (decl, \".text.startup\", NULL);\n+  {\n+    /* If we do have a profile or(and) LTO phase is executed, we do not need\n+       these ELF section.  */\n+    if (!in_lto_p || !flag_profile_values)\n+      return get_named_text_section (decl, \".text.startup\", NULL);\n+    else\n+      return NULL;\n+  }\n \n   /* Similarly for exit.  */\n   if (exit && freq != NODE_FREQUENCY_UNLIKELY_EXECUTED)\n@@ -564,7 +571,10 @@ default_function_section (tree decl, enum node_frequency freq,\n       case NODE_FREQUENCY_UNLIKELY_EXECUTED:\n \treturn get_named_text_section (decl, \".text.unlikely\", NULL);\n       case NODE_FREQUENCY_HOT:\n-\treturn get_named_text_section (decl, \".text.hot\", NULL);\n+        /* If we do have a profile or(and) LTO phase is executed, we do not need\n+           these ELF section.  */\n+        if (!in_lto_p || !flag_profile_values)\n+          return get_named_text_section (decl, \".text.hot\", NULL);\n       default:\n \treturn NULL;\n     }"}]}