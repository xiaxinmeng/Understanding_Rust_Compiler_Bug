{"sha": "467e9f383c34a368d41814d64691faa1d34b9819", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY3ZTlmMzgzYzM0YTM2OGQ0MTgxNGQ2NDY5MWZhYTFkMzRiOTgxOQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2019-06-03T02:20:33Z"}, "committer": {"name": "Hongtao Liu", "email": "liuhongt@gcc.gnu.org", "date": "2019-06-03T02:20:33Z"}, "message": "re PR target/89750 (Wrong code for _mm_comi_round_ss)\n\n2019-05-06  H.J. Lu  <hongjiu.lu@intel.com>\n\t    Hongtao Liu  <hongtao.liu@intel.com>\n\n\tPR target/89750\n\tPR target/86444\n\t* config/i386/i386-expand.c (ix86_expand_sse_comi_round):\n\tModified, original implementation isn't correct.\n\n2019-05-06  H.J. Lu  <hongjiu.lu@intel.com>\n\t    Hongtao Liu  <hongtao.liu@intel.com>\n\n\tPR target/89750\n\tPR target/86444\n\t* gcc.target/i386/avx512f-vcomisd-2.c: New.\n\t* gcc.target/i386/avx512f-vcomisd-2.c: Likewise.\n\nCo-Authored-By: Hongtao Liu <hongtao.liu@intel.com>\n\nFrom-SVN: r271853", "tree": {"sha": "5f3d8721e84808d13796700e8c21999bd5635045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f3d8721e84808d13796700e8c21999bd5635045"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/467e9f383c34a368d41814d64691faa1d34b9819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467e9f383c34a368d41814d64691faa1d34b9819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/467e9f383c34a368d41814d64691faa1d34b9819", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467e9f383c34a368d41814d64691faa1d34b9819/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4bd0426702998a83b02fcd0d23b30a4f8c2ec089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd0426702998a83b02fcd0d23b30a4f8c2ec089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bd0426702998a83b02fcd0d23b30a4f8c2ec089"}], "stats": {"total": 373, "additions": 358, "deletions": 15}, "files": [{"sha": "3563d6dd37522ac5aa1348d780eed071007d9223", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=467e9f383c34a368d41814d64691faa1d34b9819", "patch": "@@ -2576,6 +2576,14 @@ Fix test-suite.\n \t* tree-ssa-phiopt.c (two_value_replacement): Fix a typo in parameter\n \tdetection.\n \n+2019-05-06  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Hongtao Liu  <hongtao.liu@intel.com>\n+\n+\tPR target/89750\n+\tPR target/86444\n+\t* config/i386/i386-expand.c (ix86_expand_sse_comi_round):\n+\tModified, original implementation isn't correct.\n+\n 2019-05-06  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000.md (FIRST_ALTIVEC_REGNO, LAST_ALTIVEC_REGNO)"}, {"sha": "01ac5ea3f5452c3de4d65e286a58601f5f393288", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 134, "deletions": 15, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=467e9f383c34a368d41814d64691faa1d34b9819", "patch": "@@ -10007,17 +10007,23 @@ ix86_expand_sse_comi_round (const struct builtin_description *d,\n   const struct insn_data_d *insn_p = &insn_data[icode];\n   machine_mode mode0 = insn_p->operand[0].mode;\n   machine_mode mode1 = insn_p->operand[1].mode;\n-  enum rtx_code comparison = UNEQ;\n-  bool need_ucomi = false;\n \n   /* See avxintrin.h for values.  */\n-  enum rtx_code comi_comparisons[32] =\n+  static const enum rtx_code comparisons[32] =\n     {\n-      UNEQ, GT, GE, UNORDERED, LTGT, UNLE, UNLT, ORDERED, UNEQ, UNLT,\n-      UNLE, LT, LTGT, GE, GT, LT, UNEQ, GT, GE, UNORDERED, LTGT, UNLE,\n-      UNLT, ORDERED, UNEQ, UNLT, UNLE, LT, LTGT, GE, GT, LT\n+      EQ, LT, LE, UNORDERED, NE, UNGE, UNGT, ORDERED,\n+      UNEQ, UNLT, UNLE, UNORDERED, LTGT, GE, GT, ORDERED,\n+      EQ, LT, LE, UNORDERED, NE, UNGE, UNGT, ORDERED,\n+      UNEQ, UNLT, UNLE, UNORDERED, LTGT, GE, GT, ORDERED\n     };\n-  bool need_ucomi_values[32] =\n+  static const bool ordereds[32] =\n+    {\n+      true,  true,  true,  false, false, false, false, true,\n+      false, false, false, true,  true,  true,  true,  false,\n+      true,  true,  true,  false, false, false, false, true,\n+      false, false, false, true,  true,  true,  true,  false\n+    };\n+  static const bool non_signalings[32] =\n     {\n       true,  false, false, true,  true,  false, false, true,\n       true,  false, false, true,  true,  false, false, true,\n@@ -10042,16 +10048,94 @@ ix86_expand_sse_comi_round (const struct builtin_description *d,\n       return const0_rtx;\n     }\n \n-  comparison = comi_comparisons[INTVAL (op2)];\n-  need_ucomi = need_ucomi_values[INTVAL (op2)];\n-\n   if (VECTOR_MODE_P (mode0))\n     op0 = safe_vector_operand (op0, mode0);\n   if (VECTOR_MODE_P (mode1))\n     op1 = safe_vector_operand (op1, mode1);\n \n+  enum rtx_code comparison = comparisons[INTVAL (op2)];\n+  bool ordered = ordereds[INTVAL (op2)];\n+  bool non_signaling = non_signalings[INTVAL (op2)];\n+  rtx const_val = const0_rtx;\n+\n+  bool check_unordered = false;\n+  machine_mode mode = CCFPmode;\n+  switch (comparison)\n+    {\n+    case ORDERED:\n+      if (!ordered)\n+\t{\n+\t  /* NB: Use CCSmode/NE for _CMP_TRUE_UQ/_CMP_TRUE_US.  */\n+\t  if (!non_signaling)\n+\t    ordered = true;\n+\t  mode = CCSmode;\n+\t}\n+      else\n+\t{\n+\t  /* NB: Use CCPmode/NE for _CMP_ORD_Q/_CMP_ORD_S.  */\n+\t  if (non_signaling)\n+\t    ordered = false;\n+\t  mode = CCPmode;\n+\t}\n+      comparison = NE;\n+      break;\n+    case UNORDERED:\n+      if (ordered)\n+\t{\n+\t  /* NB: Use CCSmode/EQ for _CMP_FALSE_OQ/_CMP_FALSE_OS.  */\n+\t  if (non_signaling)\n+\t    ordered = false;\n+\t  mode = CCSmode;\n+\t}\n+      else\n+\t{\n+\t  /* NB: Use CCPmode/NE for _CMP_UNORD_Q/_CMP_UNORD_S.  */\n+\t  if (!non_signaling)\n+\t    ordered = true;\n+\t  mode = CCPmode;\n+\t}\n+      comparison = EQ;\n+      break;\n+\n+    case LE:\t/* -> GE  */\n+    case LT:\t/* -> GT  */\n+    case UNGE:\t/* -> UNLE  */\n+    case UNGT:\t/* -> UNLT  */\n+      std::swap (op0, op1);\n+      comparison = swap_condition (comparison);\n+      /* FALLTHRU */\n+    case GT:\n+    case GE:\n+    case UNEQ:\n+    case UNLT:\n+    case UNLE:\n+    case LTGT:\n+      /* These are supported by CCFPmode.  NB: Use ordered/signaling\n+\t COMI or unordered/non-signaling UCOMI.  Both set ZF, PF, CF\n+\t with NAN operands.  */\n+      if (ordered == non_signaling)\n+\tordered = !ordered;\n+      break;\n+    case EQ:\n+      /* NB: COMI/UCOMI will set ZF with NAN operands.  Use CCZmode for\n+\t _CMP_EQ_OQ/_CMP_EQ_OS.  */\n+      check_unordered = true;\n+      mode = CCZmode;\n+      break;\n+    case NE:\n+      /* NB: COMI/UCOMI will set ZF with NAN operands.  Use CCZmode for\n+\t _CMP_NEQ_UQ/_CMP_NEQ_US.  */\n+      gcc_assert (!ordered);\n+      check_unordered = true;\n+      mode = CCZmode;\n+      const_val = const1_rtx;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n   target = gen_reg_rtx (SImode);\n-  emit_move_insn (target, const0_rtx);\n+  emit_move_insn (target, const_val);\n   target = gen_rtx_SUBREG (QImode, target, 0);\n \n   if ((optimize && !register_operand (op0, mode0))\n@@ -10061,10 +10145,14 @@ ix86_expand_sse_comi_round (const struct builtin_description *d,\n       || !insn_p->operand[1].predicate (op1, mode1))\n     op1 = copy_to_mode_reg (mode1, op1);\n \n-  if (need_ucomi)\n-    icode = icode == CODE_FOR_sse_comi_round\n-\t\t     ? CODE_FOR_sse_ucomi_round\n-\t\t     : CODE_FOR_sse2_ucomi_round;\n+  /*\n+     1. COMI: ordered and signaling.\n+     2. UCOMI: unordered and non-signaling.\n+   */\n+  if (non_signaling)\n+    icode = (icode == CODE_FOR_sse_comi_round\n+\t     ? CODE_FOR_sse_ucomi_round\n+\t     : CODE_FOR_sse2_ucomi_round);\n \n   pat = GEN_FCN (icode) (op0, op1, op3);\n   if (! pat)\n@@ -10086,11 +10174,42 @@ ix86_expand_sse_comi_round (const struct builtin_description *d,\n     }\n \n   emit_insn (pat);\n+\n+  rtx_code_label *label = NULL;\n+\n+  /* NB: For ordered EQ or unordered NE, check ZF alone isn't sufficient\n+     with NAN operands.  */\n+  if (check_unordered)\n+    {\n+      gcc_assert (comparison == EQ || comparison == NE);\n+\n+      rtx flag = gen_rtx_REG (CCFPmode, FLAGS_REG);\n+      label = gen_label_rtx ();\n+      rtx tmp = gen_rtx_fmt_ee (UNORDERED, VOIDmode, flag, const0_rtx);\n+      tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t\t  pc_rtx);\n+      emit_jump_insn (gen_rtx_SET (pc_rtx, tmp));\n+    }\n+\n+  /* NB: Set CCFPmode and check a different CCmode which is in subset\n+     of CCFPmode.  */\n+  if (GET_MODE (set_dst) != mode)\n+    {\n+      gcc_assert (mode == CCAmode || mode == CCCmode\n+\t\t  || mode == CCOmode || mode == CCPmode\n+\t\t  || mode == CCSmode || mode == CCZmode);\n+      set_dst = gen_rtx_REG (mode, FLAGS_REG);\n+    }\n+\n   emit_insn (gen_rtx_SET (gen_rtx_STRICT_LOW_PART (VOIDmode, target),\n \t\t\t  gen_rtx_fmt_ee (comparison, QImode,\n \t\t\t\t\t  set_dst,\n \t\t\t\t\t  const0_rtx)));\n \n+  if (label)\n+    emit_label (label);\n+\n   return SUBREG_REG (target);\n }\n "}, {"sha": "d3705be7d7cc5bfc76fe72d419f7f69925641fc3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=467e9f383c34a368d41814d64691faa1d34b9819", "patch": "@@ -1563,6 +1563,14 @@\n \toptimization.\n \t* gcc.dg/tree-ssa/pr88676-2.c: New testcase.\n \n+2019-05-06  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Hongtao Liu  <hongtao.liu@intel.com>\n+\n+\tPR target/89750\n+\tPR target/86444\n+\t* gcc.target/i386/avx512f-vcomisd-2.c: New.\n+\t* gcc.target/i386/avx512f-vcomisd-2.c: Likewise.\n+\n 2019-05-06  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/90290"}, {"sha": "a84580e29c56032c17243636da9e5e9ebd0dab81", "filename": "gcc/testsuite/gcc.target/i386/avx512f-vcomisd-2.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vcomisd-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vcomisd-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vcomisd-2.c?ref=467e9f383c34a368d41814d64691faa1d34b9819", "patch": "@@ -0,0 +1,104 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-options \"-O2 -mavx512f\" } */\n+\n+#include \"avx512f-check.h\"\n+\n+static inline void __attribute__ ((__always_inline__))\n+check_cmp (double s1, double s2, const int imm, int expected)\n+{\n+  __m128d source1 = _mm_load_sd (&s1);\n+  __m128d source2 = _mm_load_sd (&s2);\n+  int res = _mm_comi_round_sd (source1, source2, imm,\n+\t\t\t       _MM_FROUND_NO_EXC);\n+  if (expected != res)\n+    abort();\n+}\n+\n+static void\n+do_check (double s1, double s2)\n+{\n+  check_cmp (s1, s2, _CMP_EQ_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 == s2);\n+  check_cmp (s1, s2, _CMP_LT_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 < s2);\n+  check_cmp (s1, s2, _CMP_LE_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 <= s2);\n+  check_cmp (s1, s2, _CMP_UNORD_Q,\n+\t     __builtin_isunordered (s1, s2));\n+  check_cmp (s1, s2, _CMP_NEQ_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 != s2);\n+  check_cmp (s1, s2, _CMP_NLT_US,\n+\t     __builtin_isunordered (s1, s2) || s1 >= s2);\n+  check_cmp (s1, s2, _CMP_NLE_US,\n+\t     __builtin_isunordered (s1, s2) || s1 > s2);\n+  check_cmp (s1, s2, _CMP_ORD_Q,\n+\t     !__builtin_isunordered (s1, s2));\n+  check_cmp (s1, s2, _CMP_EQ_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 == s2);\n+  check_cmp (s1, s2, _CMP_NGE_US,\n+\t     __builtin_isunordered (s1, s2) || s1 < s2);\n+  check_cmp (s1, s2, _CMP_NGT_US,\n+\t     __builtin_isunordered (s1, s2) || s1 <= s2);\n+  check_cmp (s1, s2, _CMP_FALSE_OQ, 0);\n+  check_cmp (s1, s2, _CMP_NEQ_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 != s2);\n+  check_cmp (s1, s2, _CMP_GE_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 >= s2);\n+  check_cmp (s1, s2, _CMP_GT_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 > s2);\n+  check_cmp (s1, s2, _CMP_TRUE_UQ, 1);\n+  check_cmp (s1, s2, _CMP_EQ_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 == s2);\n+  check_cmp (s1, s2, _CMP_LT_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 < s2);\n+  check_cmp (s1, s2, _CMP_LE_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 <= s2);\n+  check_cmp (s1, s2, _CMP_UNORD_S,\n+\t     __builtin_isunordered (s1, s2));\n+  check_cmp (s1, s2, _CMP_NEQ_US,\n+\t     __builtin_isunordered (s1, s2) || s1 != s2);\n+  check_cmp (s1, s2, _CMP_NLT_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 >= s2);\n+  check_cmp (s1, s2, _CMP_NLE_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 > s2);\n+  check_cmp (s1, s2, _CMP_ORD_S, !__builtin_isunordered (s1, s2));\n+  check_cmp (s1, s2, _CMP_EQ_US,\n+\t     __builtin_isunordered (s1, s2) || s1 == s2);\n+  check_cmp (s1, s2, _CMP_NGE_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 < s2);\n+  check_cmp (s1, s2, _CMP_NGT_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 <= s2);\n+  check_cmp (s1, s2, _CMP_FALSE_OS, 0);\n+  check_cmp (s1, s2, _CMP_NEQ_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 != s2);\n+  check_cmp (s1, s2, _CMP_GE_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 >= s2);\n+  check_cmp (s1, s2, _CMP_GT_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 > s2);\n+  check_cmp (s1, s2, _CMP_TRUE_US, 1);\n+}\n+\n+static void\n+avx512f_test (void)\n+{\n+  struct\n+    {\n+      double x1;\n+      double x2;\n+    }\n+  inputs[] =\n+    {\n+      { 4.3, 2.18 },\n+      { -4.3, 3.18 },\n+      { __builtin_nan (\"\"), -5.8 },\n+      { -4.8, __builtin_nans (\"\") },\n+      { 3.8, __builtin_nans (\"\") },\n+      { 4.2, 4.2 },\n+      { __builtin_nan (\"\"), __builtin_nans (\"\") },\n+    };\n+  int i;\n+\n+  for (i = 0; i < sizeof (inputs) / sizeof (inputs[0]); i++)\n+    do_check (inputs[i].x1, inputs[i].x2);\n+}"}, {"sha": "381a8b4661e5c7fefb4310b504cc1a26e42520f2", "filename": "gcc/testsuite/gcc.target/i386/avx512f-vcomiss-2.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vcomiss-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/467e9f383c34a368d41814d64691faa1d34b9819/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vcomiss-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-vcomiss-2.c?ref=467e9f383c34a368d41814d64691faa1d34b9819", "patch": "@@ -0,0 +1,104 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target avx512f } */\n+/* { dg-options \"-O2 -mavx512f\" } */\n+\n+#include \"avx512f-check.h\"\n+\n+static inline void __attribute__ ((__always_inline__))\n+check_cmp (float s1, float s2, const int imm, int expected)\n+{\n+  __m128 source1 = _mm_load_ss (&s1);\n+  __m128 source2 = _mm_load_ss (&s2);\n+  int res = _mm_comi_round_ss (source1, source2, imm,\n+\t\t\t       _MM_FROUND_NO_EXC);\n+  if (expected != res)\n+    abort();\n+}\n+\n+static void\n+do_check (float s1, float s2)\n+{\n+  check_cmp (s1, s2, _CMP_EQ_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 == s2);\n+  check_cmp (s1, s2, _CMP_LT_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 < s2);\n+  check_cmp (s1, s2, _CMP_LE_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 <= s2);\n+  check_cmp (s1, s2, _CMP_UNORD_Q,\n+\t     __builtin_isunordered (s1, s2));\n+  check_cmp (s1, s2, _CMP_NEQ_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 != s2);\n+  check_cmp (s1, s2, _CMP_NLT_US,\n+\t     __builtin_isunordered (s1, s2) || s1 >= s2);\n+  check_cmp (s1, s2, _CMP_NLE_US,\n+\t     __builtin_isunordered (s1, s2) || s1 > s2);\n+  check_cmp (s1, s2, _CMP_ORD_Q,\n+\t     !__builtin_isunordered (s1, s2));\n+  check_cmp (s1, s2, _CMP_EQ_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 == s2);\n+  check_cmp (s1, s2, _CMP_NGE_US,\n+\t     __builtin_isunordered (s1, s2) || s1 < s2);\n+  check_cmp (s1, s2, _CMP_NGT_US,\n+\t     __builtin_isunordered (s1, s2) || s1 <= s2);\n+  check_cmp (s1, s2, _CMP_FALSE_OQ, 0);\n+  check_cmp (s1, s2, _CMP_NEQ_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 != s2);\n+  check_cmp (s1, s2, _CMP_GE_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 >= s2);\n+  check_cmp (s1, s2, _CMP_GT_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 > s2);\n+  check_cmp (s1, s2, _CMP_TRUE_UQ, 1);\n+  check_cmp (s1, s2, _CMP_EQ_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 == s2);\n+  check_cmp (s1, s2, _CMP_LT_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 < s2);\n+  check_cmp (s1, s2, _CMP_LE_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 <= s2);\n+  check_cmp (s1, s2, _CMP_UNORD_S,\n+\t     __builtin_isunordered (s1, s2));\n+  check_cmp (s1, s2, _CMP_NEQ_US,\n+\t     __builtin_isunordered (s1, s2) || s1 != s2);\n+  check_cmp (s1, s2, _CMP_NLT_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 >= s2);\n+  check_cmp (s1, s2, _CMP_NLE_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 > s2);\n+  check_cmp (s1, s2, _CMP_ORD_S, !__builtin_isunordered (s1, s2));\n+  check_cmp (s1, s2, _CMP_EQ_US,\n+\t     __builtin_isunordered (s1, s2) || s1 == s2);\n+  check_cmp (s1, s2, _CMP_NGE_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 < s2);\n+  check_cmp (s1, s2, _CMP_NGT_UQ,\n+\t     __builtin_isunordered (s1, s2) || s1 <= s2);\n+  check_cmp (s1, s2, _CMP_FALSE_OS, 0);\n+  check_cmp (s1, s2, _CMP_NEQ_OS,\n+\t     !__builtin_isunordered (s1, s2) && s1 != s2);\n+  check_cmp (s1, s2, _CMP_GE_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 >= s2);\n+  check_cmp (s1, s2, _CMP_GT_OQ,\n+\t     !__builtin_isunordered (s1, s2) && s1 > s2);\n+  check_cmp (s1, s2, _CMP_TRUE_US, 1);\n+}\n+\n+static void\n+avx512f_test (void)\n+{\n+  struct\n+    {\n+      float x1;\n+      float x2;\n+    }\n+  inputs[] =\n+    {\n+      { 4.3, 2.18 },\n+      { -4.3, 3.18 },\n+      { __builtin_nanf (\"\"), -5.8 },\n+      { -4.8, __builtin_nansf (\"\") },\n+      { 3.8, __builtin_nansf (\"\") },\n+      { 4.2, 4.2 },\n+      { __builtin_nanf (\"\"), __builtin_nansf (\"\") },\n+    };\n+  int i;\n+\n+  for (i = 0; i < sizeof (inputs) / sizeof (inputs[0]); i++)\n+    do_check (inputs[i].x1, inputs[i].x2);\n+}"}]}