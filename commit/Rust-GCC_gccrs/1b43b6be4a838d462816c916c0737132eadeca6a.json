{"sha": "1b43b6be4a838d462816c916c0737132eadeca6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI0M2I2YmU0YTgzOGQ0NjI4MTZjOTE2YzA3MzcxMzJlYWRlY2E2YQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2001-02-09T00:32:11Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-02-09T00:32:11Z"}, "message": "Make-lang.in (JAVA_OBJS): Added java/mangle_name.o\n\n2001-02-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* Make-lang.in (JAVA_OBJS): Added java/mangle_name.o\n\t(JVGENMAIN_OBJS): Likewise.\n\t* java-tree.h (append_gpp_mangled_name): New prototype.\n\t* jcf-parse.c (ggc_mark_jcf): Argument now `void *.'\n\tRemoved cast calling `gcc_add_root.'\n\t* jvgenmain.c (mangle_obstack): New global, initialized.\n\t(main): Use it.\n\t(do_mangle_class): Constify local `ptr.'\n\tRemoved macro `MANGLE_NAME.' Removed cast in `for.' Call\n\tappend_gpp_mangle_name and update `count' if necessary.\n\tUse `mangle_obstack.'\n\t* mangle.c (append_unicode_mangled_name): Removed.\n\t(append_gpp_mangled_name): Likewise.\n\t(unicode_mangling_length): Likewise.\n\t(mangle_member_name): Return type set to `void.'\n\t(mangle_field_decl): Don't append `U' in escaped names.\n\t(mangle_method_decl): Likewise.\n\t(mangle_member_name): Just use `append_gpp_mangled_name.'\n\t* mangle_name.c: New file.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-02/msg00492.html)\n\nFrom-SVN: r39552", "tree": {"sha": "63a7dd46d1f2e24a7f154e95b10330dd27796201", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63a7dd46d1f2e24a7f154e95b10330dd27796201"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b43b6be4a838d462816c916c0737132eadeca6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b43b6be4a838d462816c916c0737132eadeca6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b43b6be4a838d462816c916c0737132eadeca6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b43b6be4a838d462816c916c0737132eadeca6a/comments", "author": null, "committer": null, "parents": [{"sha": "8da6d80e8706bcdffc8b07c5a57ad820e9651f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da6d80e8706bcdffc8b07c5a57ad820e9651f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da6d80e8706bcdffc8b07c5a57ad820e9651f2a"}], "stats": {"total": 406, "additions": 264, "deletions": 142}, "files": [{"sha": "83bc2a9a5538be9e7017336252d0eabff2a0f1df", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=1b43b6be4a838d462816c916c0737132eadeca6a", "patch": "@@ -1,3 +1,25 @@\n+2001-02-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* Make-lang.in (JAVA_OBJS): Added java/mangle_name.o\n+\t(JVGENMAIN_OBJS): Likewise.\n+\t* java-tree.h (append_gpp_mangled_name): New prototype.\t\n+\t* jcf-parse.c (ggc_mark_jcf): Argument now `void *.'\n+\tRemoved cast calling `gcc_add_root.'\n+\t* jvgenmain.c (mangle_obstack): New global, initialized.\n+\t(main): Use it.\n+\t(do_mangle_class): Constify local `ptr.'\n+\tRemoved macro `MANGLE_NAME.' Removed cast in `for.' Call\n+\tappend_gpp_mangle_name and update `count' if necessary.\n+\tUse `mangle_obstack.'\n+\t* mangle.c (append_unicode_mangled_name): Removed.\n+\t(append_gpp_mangled_name): Likewise.\n+\t(unicode_mangling_length): Likewise.\n+\t(mangle_member_name): Return type set to `void.'\n+\t(mangle_field_decl): Don't append `U' in escaped names.\n+\t(mangle_method_decl): Likewise.\n+\t(mangle_member_name): Just use `append_gpp_mangled_name.'\n+\t* mangle_name.c: New file.\n+\n 2001-02-07  Per Bothner  <per@bothner.com>\n \n \t* check-init.c (check_init):  Fix TRY_FINALLY_EXPR logic."}, {"sha": "cf69d2f823ee03faf38cda7e88ff57b36ab138fc", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=1b43b6be4a838d462816c916c0737132eadeca6a", "patch": "@@ -100,6 +100,7 @@ $(srcdir)/java/keyword.h: $(srcdir)/java/keyword.gperf\n JAVA_OBJS = java/parse.o java/class.o java/decl.o java/expr.o \\\n   java/constants.o java/lang.o java/typeck.o java/except.o java/verify.o \\\n   java/zextract.o java/jcf-io.o java/jcf-parse.o java/mangle.o \\\n+  java/mangle_name.o \\\n   java/jcf-write.o java/buffer.o java/check-init.o java/jcf-depend.o \\\n   java/jcf-path.o java/xref.o java/boehm.o mkdeps.o\n \n@@ -111,7 +112,7 @@ JVSCAN_OBJS = java/parse-scan.o java/jv-scan.o version.o\n JCFDUMP_OBJS = java/jcf-dump.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \\\n \t\tjava/zextract.o errors.o version.o mkdeps.o\n \n-JVGENMAIN_OBJS = java/jvgenmain.o\n+JVGENMAIN_OBJS = java/jvgenmain.o java/mangle_name.o\n \n # Use loose warnings for this front end.\n java-warn ="}, {"sha": "e1a0347d0e89bd3fc832b0340f99a4c771360f38", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=1b43b6be4a838d462816c916c0737132eadeca6a", "patch": "@@ -1115,6 +1115,7 @@ extern tree java_mangle_class_field PARAMS ((struct obstack *, tree));\n extern tree java_mangle_class_field_from_string PARAMS ((struct obstack *, char *));\n extern tree java_mangle_vtable PARAMS ((struct obstack *, tree));\n extern const char *lang_printable_name_wls PARAMS ((tree, int));\n+extern void append_gpp_mangled_name PARAMS ((const char *, int));\n \n /* We use ARGS_SIZE_RTX to indicate that gcc/expr.h has been included\n    to declare `enum expand_modifier'. */"}, {"sha": "414ccded13ad7a92476838ce861b592e83c22c8a", "filename": "gcc/java/jvgenmain.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2Fjvgenmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2Fjvgenmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvgenmain.c?ref=1b43b6be4a838d462816c916c0737132eadeca6a", "patch": "@@ -34,7 +34,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n static char * do_mangle_classname PARAMS ((const char *string));\n \n-struct obstack name_obstack;\n+struct obstack  name_obstack;\n+struct obstack *mangle_obstack = &name_obstack;\n \n void\n gcc_obstack_init (obstack)\n@@ -92,7 +93,7 @@ main (int argc, const char **argv)\n \n   classname = argv[i];\n \n-  gcc_obstack_init (&name_obstack);\n+  gcc_obstack_init (mangle_obstack);\n   mangled_classname = do_mangle_classname (classname);\n \n   if (i < argc - 1 && strcmp (argv[i + 1], \"-\") != 0)\n@@ -150,30 +151,22 @@ static char *\n do_mangle_classname (string)\n      const char *string;\n {\n-  char *ptr;\n+  const char *ptr;\n   int count = 0;\n \n-#define MANGLE_NAME()\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    char buffer [128];\t\t\t\t\t\t\\\n-    sprintf (buffer, \"%d\", count);\t\t\t\t\\\n-    obstack_grow (&name_obstack, buffer, strlen (buffer));\t\\\n-    obstack_grow (&name_obstack, & ptr [-count], count);\t\\\n-    count = 0;\t\t\t\t\t\t\t\\\n-  }\n-\n   obstack_grow (&name_obstack, \"_ZN\", 3);\n \n-  for (ptr = (char *)string; *ptr; ptr++ )\n+  for (ptr = string; *ptr; ptr++ )\n     {\n       if (ptr[0] == '.')\n \t{\n-\t  MANGLE_NAME ();\n+\t  append_gpp_mangled_name (&ptr [-count], count);\n+\t  count = 0;\n \t}\n       else\n \tcount++;\n     }\n-  MANGLE_NAME ();\n-  obstack_grow0 (&name_obstack, \"6class$E\", 8);\n-  return obstack_finish (&name_obstack);\n+  append_gpp_mangled_name (&ptr [-count], count);\n+  obstack_grow (mangle_obstack, \"6class$E\", 8);\n+  return obstack_finish (mangle_obstack);\n }"}, {"sha": "b78e242da18c2be2af8dd36e14471c929bb04755", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 6, "deletions": 124, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=1b43b6be4a838d462816c916c0737132eadeca6a", "patch": "@@ -56,10 +56,7 @@ static void init_mangling PARAMS ((struct obstack *));\n static tree finish_mangling PARAMS ((void));\n static void compression_table_add PARAMS ((tree));\n \n-static void append_unicode_mangled_name PARAMS ((const char *, int));\n-static void append_gpp_mangled_name PARAMS ((const char *, int));\n-static int  unicode_mangling_length PARAMS ((const char *, int));\n-static int  mangle_member_name PARAMS ((tree));\n+static void mangle_member_name PARAMS ((tree));\n \n /* We use an incoming obstack, always to be provided to the interface\n    functions. */\n@@ -122,19 +119,14 @@ static void\n mangle_field_decl (decl)\n      tree decl;\n {\n-  tree name = DECL_NAME (decl);\n-  int field_name_needs_escapes = 0;\n-\n   /* Mangle the name of the this the field belongs to */\n   mangle_record_type (DECL_CONTEXT (decl), /* from_pointer = */ 0);\n   \n   /* Mangle the name of the field */\n-  field_name_needs_escapes = mangle_member_name (name);\n+  mangle_member_name (DECL_NAME (decl));\n \n   /* Terminate the mangled name */\n   obstack_1grow (mangle_obstack, 'E');\n-  if (field_name_needs_escapes)\n-    obstack_1grow (mangle_obstack, 'U');\n }\n \n /* This mangles a method decl, first mangling its name and then all\n@@ -146,7 +138,6 @@ mangle_method_decl (mdecl)\n {\n   tree method_name = DECL_NAME (mdecl);\n   tree arglist;\n-  int method_name_needs_escapes = 0;\n \n   /* Mangle the name of the type that contains mdecl */\n   mangle_record_type (DECL_CONTEXT (mdecl), /* from_pointer = */ 0);\n@@ -166,7 +157,7 @@ mangle_method_decl (mdecl)\n \tobstack_grow (mangle_obstack, \"C1\", 2);\n     }\n   else\n-    method_name_needs_escapes = mangle_member_name (method_name);\n+    mangle_member_name (method_name);\n   obstack_1grow (mangle_obstack, 'E');\n \n   /* We mangled type.methodName. Now onto the arguments. */\n@@ -183,31 +174,18 @@ mangle_method_decl (mdecl)\n       for (arg = arglist; arg != end_params_node;  arg = TREE_CHAIN (arg))\n \tmangle_type (TREE_VALUE (arg));\n     }\n-\n-  /* Terminate the mangled name */\n-  if (method_name_needs_escapes)\n-    obstack_1grow (mangle_obstack, 'U');\n }\n \n /* This mangles a member name, like a function name or a field\n    name. Handle cases were `name' is a C++ keyword.  Return a non zero\n    value if unicode encoding was required.  */\n \n-static int\n+static void\n mangle_member_name (name)\n      tree name;\n {\n-  const char * name_string = IDENTIFIER_POINTER (name);\n-  int len = IDENTIFIER_LENGTH (name);\n-  int to_return = 0;\n-\n-  if (unicode_mangling_length (name_string, len) > 0)\n-    {\n-      append_unicode_mangled_name (name_string, len);\n-      to_return = 1;\n-    }\n-  else\n-    append_gpp_mangled_name (name_string, len);\n+  append_gpp_mangled_name (IDENTIFIER_POINTER (name),\n+\t\t\t   IDENTIFIER_LENGTH (name));\n \n   /* If NAME happens to be a C++ keyword, add `$' or `.' or `_'. */\n   if (cxx_keyword_p (IDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name)))\n@@ -222,102 +200,6 @@ mangle_member_name (name)\n #endif /* NO_DOT_IN_LABEL */\n #endif /* NO_DOLLAR_IN_LABEL */\n     }\n-\n-  return to_return;\n-}\n-\n-/* Assuming (NAME, LEN) is a Utf8-encoding string, calculate\n-   the length of the string as mangled (a la g++) including Unicode escapes.\n-   If no escapes are needed, return 0. */\n-\n-static int\n-unicode_mangling_length (name, len)\n-     const char *name; \n-     int len; \n-{\n-  const unsigned char *ptr;\n-  const unsigned char *limit = (const unsigned char *)name + len;\n-  int need_escapes = 0;\n-  int num_chars = 0;\n-  int underscores = 0;\n-  for (ptr = (const unsigned char *) name;  ptr < limit;  )\n-    {\n-      int ch = UTF8_GET(ptr, limit);\n-      if (ch < 0)\n-\terror (\"internal error - invalid Utf8 name\");\n-      if (ch >= '0' && ch <= '9')\n-\tneed_escapes += num_chars == 0;\n-      else if (ch == '_')\n-\tunderscores++;\n-      else if (ch != '$' && (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z'))\n-\tneed_escapes++;\n-      num_chars++;\n-    }\n-  if (need_escapes)\n-    return num_chars + 4 * (need_escapes + underscores);\n-  else\n-    return 0;\n-}\n-\n-/* Assuming (NAME, LEN) is a Utf8-encoding string, emit the string\n-   appropriately mangled (with Unicode escapes) to OBSTACK. */\n-\n-static void\n-append_unicode_mangled_name (name, len)\n-     const char *name;\n-     int len;\n-{\n-  const unsigned char *ptr;\n-  const unsigned char *limit = (const unsigned char *)name + len;\n-  for (ptr = (const unsigned char *) name;  ptr < limit;  )\n-    {\n-      int ch = UTF8_GET(ptr, limit);\n-      int emit_escape;\n-      if (ch < 0)\n-\t{\n-\t  error (\"internal error - bad Utf8 string\");\n-\t  break;\n-\t}\n-      if (ch >= '0' && ch <= '9')\n-\temit_escape = (ptr == (const unsigned char *) name);\n-      else\n-\temit_escape = (ch < 'a' || ch > 'z') && (ch < 'A' || ch > 'Z');\n-      if (emit_escape)\n-\t{\n-\t  char buf[6];\n-\t  sprintf (buf, \"_%04x\", ch);\n-\t  obstack_grow (mangle_obstack, buf, 5);\n-\t}\n-      else\n-\t{\n-\t  obstack_1grow (mangle_obstack, ch);\n-\t}\n-    }\n-}\n-\n-/* Assuming (NAME, LEN) is a Utf8-encoding string, emit the string\n-   appropriately mangled (with Unicode escapes if needed) to OBSTACK. */\n-\n-static void\n-append_gpp_mangled_name (name, len)\n-     const char *name;\n-     int len;\n-{\n-  int encoded_len = unicode_mangling_length (name, len);\n-  int needs_escapes = encoded_len > 0;\n-  char buf[6];\n-  if (needs_escapes)\n-    {\n-      sprintf (buf, \"U%d\", encoded_len);\n-      obstack_grow (mangle_obstack, buf, strlen(buf));\n-      append_unicode_mangled_name (name, len);\n-    }\n-  else\n-    {\n-      sprintf (buf, \"%d\", len);\n-      obstack_grow (mangle_obstack, buf, strlen(buf));\n-      obstack_grow (mangle_obstack, name, len);\n-    }\n }\n \n /* Append the mangled name of TYPE onto OBSTACK.  */"}, {"sha": "b074f1ed212c0a4d36f62cdd182ef068f8323051", "filename": "gcc/java/mangle_name.c", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2Fmangle_name.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b43b6be4a838d462816c916c0737132eadeca6a/gcc%2Fjava%2Fmangle_name.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle_name.c?ref=1b43b6be4a838d462816c916c0737132eadeca6a", "patch": "@@ -0,0 +1,223 @@\n+/* Shared functions related to mangling names for the GNU compiler\n+   for the Java(TM) language.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA. \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Alexandre Petit-Bianco <apbianco@cygnus.com> */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"jcf.h\"\n+#include \"tree.h\"\n+#include \"java-tree.h\"\n+#include \"obstack.h\"\n+#include \"toplev.h\"\n+#include \"obstack.h\"\n+\n+static void append_unicode_mangled_name PARAMS ((const char *, int));\n+#ifndef HAVE_AS_UTF8\n+static int  unicode_mangling_length PARAMS ((const char *, int));\n+#endif\n+\n+extern struct obstack *mangle_obstack;\n+\n+/* If the assembler doesn't support UTF8 in symbol names, some\n+   characters might need to be escaped.  */\n+\n+#ifndef HAVE_AS_UTF8\n+\n+/* Assuming (NAME, LEN) is a Utf8-encoding string, emit the string\n+   appropriately mangled (with Unicode escapes if needed) to\n+   MANGLE_OBSTACK.  Note that `java', `lang' and `Object' are used so\n+   frequently that they could be cached.  */\n+\n+void\n+append_gpp_mangled_name (name, len)\n+     const char *name;\n+     int len;\n+{\n+  int encoded_len = unicode_mangling_length (name, len);\n+  int needs_escapes = encoded_len > 0;\n+  char buf[6];\n+\n+  sprintf (buf, \"%d\", (needs_escapes ? encoded_len : len));\n+  obstack_grow (mangle_obstack, buf, strlen (buf));\n+\n+  if (needs_escapes)\n+    append_unicode_mangled_name (name, len);\n+  else\n+    obstack_grow (mangle_obstack, name, len);\n+}\n+\n+/* Assuming (NAME, LEN) is a Utf8-encoded string, emit the string\n+   appropriately mangled (with Unicode escapes) to MANGLE_OBSTACK.\n+   Characters needing an escape are encoded `__UNN_' to `__UNNNN_', in\n+   which case `__U' will be mangled `__U_'. `$' is mangled `$' or\n+   __U24_ according to NO_DOLLAR_IN_LABEL.  */\n+\n+static void\n+append_unicode_mangled_name (name, len)\n+     const char *name;\n+     int len;\n+{\n+  const unsigned char *ptr;\n+  const unsigned char *limit = (const unsigned char *)name + len;\n+  int uuU = 0;\n+  for (ptr = (const unsigned char *) name;  ptr < limit;  )\n+    {\n+      int ch = UTF8_GET(ptr, limit);\n+\n+      if ((ch >= '0' && ch <= '9')\n+#ifndef NO_DOLLAR_IN_LABEL\n+\t  || ch == '$'\n+#endif\n+\t  || (ch >= 'a' && ch <= 'z')\n+\t  || (ch >= 'A' && ch <= 'Z' && ch != 'U'))\n+\tobstack_1grow (mangle_obstack, ch);\n+      /* Everything else needs encoding */\n+      else\n+\t{\n+\t  char buf [9];\n+\t  if (ch == '_' || ch == 'U')\n+\t    {\n+\t      /* Prepare to recognize __U */\n+\t      if (ch == '_' && (uuU < 3))\n+\t\t{\n+\t\t  uuU++;\n+\t\t  obstack_1grow (mangle_obstack, ch);\n+\t\t}\n+\t      /* We recognize __U that we wish to encode\n+                 __U_. Finish the encoding. */\n+\t      else if (ch == 'U' && (uuU == 2))\n+\t\t{\n+\t\t  uuU = 0;\n+\t\t  obstack_grow (mangle_obstack, \"U_\", 2);\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  sprintf (buf, \"__U%x_\", ch);\n+\t  obstack_grow (mangle_obstack, buf, strlen (buf));\n+\t  uuU = 0;\n+\t}\n+    }\n+}\n+\n+/* Assuming (NAME, LEN) is a Utf8-encoding string, calculate the\n+   length of the string as mangled (a la g++) including Unicode\n+   escapes.  If no escapes are needed, return 0.  */\n+\n+static int\n+unicode_mangling_length (name, len)\n+     const char *name; \n+     int len; \n+{\n+  const unsigned char *ptr;\n+  const unsigned char *limit = (const unsigned char *)name + len;\n+  int need_escapes = 0;\t\t/* Whether we need an escape or not */\n+  int num_chars = 0;\t\t/* Number of characters in the mangled name */\n+  int uuU = 0;\t\t\t/* Help us to find __U. 0: '_', 1: '__' */\n+  for (ptr = (const unsigned char *) name;  ptr < limit;  )\n+    {\n+      int ch = UTF8_GET(ptr, limit);\n+\n+      if (ch < 0)\n+\terror (\"internal error - invalid Utf8 name\");\n+      if ((ch >= '0' && ch <= '9')\n+#ifndef NO_DOLLAR_IN_LABEL\n+\t  || ch == '$'\n+#endif\n+\t  || (ch >= 'a' && ch <= 'z')\n+\t  || (ch >= 'A' && ch <= 'Z' && ch != 'U'))\n+\tnum_chars++;\n+      /* Everything else needs encoding */\n+      else\n+\t{\n+\t  int encoding_length = 2;\n+\n+\t  if (ch == '_' || ch == 'U')\n+\t    {\n+\t      /* Prepare to recognize __U */\n+\t      if (ch == '_' && (uuU < 3))\n+\t\t{\n+\t\t  num_chars++;\n+\t\t  uuU++;\n+\t\t}\n+\t      /* We recognize __U that we wish to encode __U_ */\n+\t      else if (ch == 'U' && (uuU == 2))\n+\t\t{\n+\t\t  num_chars += 2;\n+\t\t  need_escapes = 1;\n+\t\t  uuU = 0;\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  \n+\t  if (ch > 0xff)\n+\t    encoding_length++;\n+\t  if (ch > 0xfff)\n+\t    encoding_length++;\n+\t  \n+\t  num_chars += (4 + encoding_length);\n+\t  need_escapes = 1;\n+\t  uuU = 0;\n+\t}\n+    }\n+  if (need_escapes)\n+    return num_chars;\n+  else\n+    return 0;\n+}\n+\n+#else\n+\n+/* The assembler supports UTF8, we don't use escapes. Mangling is\n+   simply <N>NAME. <N> is the number of UTF8 encoded characters that\n+   are found in NAME. Note that `java', `lang' and `Object' are used\n+   so frequently that they could be cached.  */\n+\n+void\n+append_gpp_mangled_name (name, len)\n+     const char *name;\n+     int len;\n+{\n+  const unsigned char *ptr;\n+  const unsigned char *limit = (const unsigned char *)name + len;\n+  int encoded_len;\n+  char buf [6];\n+  \n+  /* Compute the length of the string we wish to mangle. */\n+  for (encoded_len =  0, ptr = (const unsigned char *) name;\n+       ptr < limit; encoded_len++)\n+    {\n+      int ch = UTF8_GET(ptr, limit);\n+\n+      if (ch < 0)\n+\terror (\"internal error - invalid Utf8 name\");\n+    }\n+\n+  sprintf (buf, \"%d\", encoded_len);\n+  obstack_grow (mangle_obstack, buf, strlen (buf));\n+  obstack_grow (mangle_obstack, name, len);\n+}\n+\n+#endif /* HAVE_AS_UTF8 */"}]}