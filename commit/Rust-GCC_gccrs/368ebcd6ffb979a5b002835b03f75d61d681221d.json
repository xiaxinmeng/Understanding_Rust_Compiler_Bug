{"sha": "368ebcd6ffb979a5b002835b03f75d61d681221d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY4ZWJjZDZmZmI5NzlhNWIwMDI4MzViMDNmNzVkNjFkNjgxMjIxZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-10-05T13:34:45Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-10-05T13:34:45Z"}, "message": "fold-const.c: Follow spelling conventions.\n\n\t* fold-const.c: Follow spelling conventions.\n\t* function.c: Likewise.\n\t* config/c4x/c4x.h: Likewise.\n\t* config/c4x/c4x.md: Likewise.\n\t* config/frv/frv.md: Likewise.\n\t* config/rs6000/aix.h: Likewise.\n\t* config/rs6000/linux64.h: Likewise.\n\t* config/xtensa/xtensa.c: Likewise.\n\nFrom-SVN: r72111", "tree": {"sha": "f344e155c2b5c7aac595a92de8716b906a1ef740", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f344e155c2b5c7aac595a92de8716b906a1ef740"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/368ebcd6ffb979a5b002835b03f75d61d681221d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/368ebcd6ffb979a5b002835b03f75d61d681221d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/368ebcd6ffb979a5b002835b03f75d61d681221d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/368ebcd6ffb979a5b002835b03f75d61d681221d/comments", "author": null, "committer": null, "parents": [{"sha": "0ee55ad88a745b42dc1466c5ae6360f83ba3c628", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee55ad88a745b42dc1466c5ae6360f83ba3c628", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee55ad88a745b42dc1466c5ae6360f83ba3c628"}], "stats": {"total": 27, "additions": 19, "deletions": 8}, "files": [{"sha": "66d15f84637abf4d3c9011647a86b27f02d2f80e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -1,3 +1,14 @@\n+2003-10-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* fold-const.c: Follow spelling conventions.\n+\t* function.c: Likewise.\n+\t* config/c4x/c4x.h: Likewise.\n+\t* config/c4x/c4x.md: Likewise.\n+\t* config/frv/frv.md: Likewise.\n+\t* config/rs6000/aix.h: Likewise.\n+\t* config/rs6000/linux64.h: Likewise.\n+\t* config/xtensa/xtensa.c: Likewise.\n+\n 2003-10-05  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* c-pretty-print.c: Fix comment formatting."}, {"sha": "37d0c9b42dd471fb0e1d214f5ffcd4a82eda2bfd", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -777,7 +777,7 @@ enum reg_class\n    the register arguments (R2,R3), respectively.  I'm reluctant to define\n    this macro since it stomps on many potential optimizations.  Ideally\n    it should have a register class argument so that not all the register\n-   classes gets penalised for the sake of a naughty few...  For long\n+   classes gets penalized for the sake of a naughty few...  For long\n    double arithmetic we need two additional registers that we can use as\n    spill registers.  */\n "}, {"sha": "5755177454a10dc1175a8d3a51c7f7ebde95c749", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -476,7 +476,7 @@\n ;\n ; C4x FUNCTIONAL UNITS\n ;\n-; Define functional units for instruction scheduling to minimise\n+; Define functional units for instruction scheduling to minimize\n ; pipeline conflicts.\n ;\n ; With the C3x, an external memory write (with no wait states) takes"}, {"sha": "ce5ce8bac25a8ddcc48216474fcfdb135a97c572", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -304,7 +304,7 @@\n \n ;; Instruction type\n \n-;; The table below summarises the types of media instruction and their\n+;; The table below summarizes the types of media instruction and their\n ;; scheduling classification.  Headings are:\n \n ;; Type:\tthe name of the define_attr type"}, {"sha": "97897b88ca71963df7d76b19d8e04163cd34f227", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -155,7 +155,7 @@\n    layout treating the parameter area as any other block of memory,\n    then map the reg param area to registers, i.e., pad upward, which\n    is the way IBM Compilers for AIX behave.\n-   Setting both of the following defines results in this behaviour.  */\n+   Setting both of the following defines results in this behavior.  */\n #define AGGREGATE_PADDING_FIXED 1\n #define AGGREGATES_PAD_UPWARD_ALWAYS 1\n "}, {"sha": "4c1b878a011a6567a06544b6dc786c20e8573d97", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -241,7 +241,7 @@\n    reasonably assume that they follow the normal rules for structure\n    layout treating the parameter area as any other block of memory,\n    then map the reg param area to registers.  ie. pad updard.\n-   Setting both of the following defines results in this behaviour.\n+   Setting both of the following defines results in this behavior.\n    Setting just the first one will result in aggregates that fit in a\n    doubleword being padded downward, and others being padded upward.\n    Not a bad idea as this results in struct { int x; } being passed"}, {"sha": "68a2bd7663eba5dd29d0c45f5f2a59e9c0b9efe0", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -1724,7 +1724,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type)\n \n \n /* Return an RTL expression containing the register for the given mode,\n-   or 0 if the argument is to be passed on the stack.  INCOMING_P is non-zero\n+   or 0 if the argument is to be passed on the stack.  INCOMING_P is nonzero\n    if this is an incoming argument to the current function.  */\n \n rtx"}, {"sha": "92b885cc0c4e12e9f2186731d23452037d75394c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -3098,7 +3098,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \n \t      in_p = n_in_p, low = n_low, high = n_high;\n \n-\t      /* If the high bound is missing, but we have a non-zero low\n+\t      /* If the high bound is missing, but we have a nonzero low\n \t\t bound, reverse the range so it goes from zero to the low bound\n \t\t minus 1.  */\n \t      if (high == 0 && low && ! integer_zerop (low))"}, {"sha": "bd76c5cd1e10284d0dcded33da314a47b3db3d2f", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/368ebcd6ffb979a5b002835b03f75d61d681221d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=368ebcd6ffb979a5b002835b03f75d61d681221d", "patch": "@@ -4530,7 +4530,7 @@ assign_parms (tree fndecl)\n \n \t\t Internally, gcc assumes that the argument pointer is\n \t\t aligned to STACK_BOUNDARY bits.  This is used both for\n-\t\t alignment optimisations (see init_emit) and to locate\n+\t\t alignment optimizations (see init_emit) and to locate\n \t\t arguments that are aligned to more than PARM_BOUNDARY\n \t\t bits.  We must preserve this invariant by rounding\n \t\t CURRENT_FUNCTION_PRETEND_ARGS_SIZE up to a stack"}]}