{"sha": "49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "node_id": "C_kwDOANBUbNoAKDQ5YWQ0ZDJjMzAzODdlYzkxNmIxNmRkYzFlMjM1YmNiNWU1M2IzYjI", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2021-12-06T18:57:32Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-11T22:39:54Z"}, "message": "Prepare library for REAL(KIND=17).\n\nThis prepares the library side for REAL(KIND=17).  It is\nnot yet tested, but at least compiles cleanly on POWER 9\nand x86_64.\n\n2021-10-19  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* Makefile.am: Add _r17 and _c17 files.  Build them\n\twith -mabi=ieeelongdouble on POWER.\n\t* Makefile.in: Regenerate.\n\t* configure: Regenerate.\n\t* configure.ac: New flag HAVE_REAL_17.\n\t* kinds-override.h: (HAVE_GFC_REAL_17): New macro.\n\t(HAVE_GFC_COMPLEX_17): New macro.\n\t(GFC_REAL_17_HUGE): New macro.\n\t(GFC_REAL_17_LITERAL_SUFFIX): New macro.\n\t(GFC_REAL_17_LITERAL): New macro.\n\t(GFC_REAL_17_DIGITS): New macro.\n\t(GFC_REAL_17_RADIX): New macro.\n\t* libgfortran.h\t(POWER_IEEE128): New macro.\n\t(gfc_array_r17): Typedef.\n\t(GFC_DTYPE_REAL_17): New macro.\n\t(GFC_DTYPE_COMPLEX_17): New macro.\n\t(__acoshieee128): Prototype.\n\t(__acosieee128): Prototype.\n\t(__asinhieee128): Prototype.\n\t(__asinieee128): Prototype.\n\t(__atan2ieee128): Prototype.\n\t(__atanhieee128): Prototype.\n\t(__atanieee128): Prototype.\n\t(__coshieee128): Prototype.\n\t(__cosieee128): Prototype.\n\t(__erfieee128): Prototype.\n\t(__expieee128): Prototype.\n\t(__fabsieee128): Prototype.\n\t(__jnieee128): Prototype.\n\t(__log10ieee128): Prototype.\n\t(__logieee128): Prototype.\n\t(__powieee128): Prototype.\n\t(__sinhieee128): Prototype.\n\t(__sinieee128): Prototype.\n\t(__sqrtieee128): Prototype.\n\t(__tanhieee128): Prototype.\n\t(__tanieee128): Prototype.\n\t(__ynieee128): Prototype.\n\t* m4/mtype.m4: Make a bit more readable. Add KIND=17.\n\t* generated/_abs_c17.F90: New file.\n\t* generated/_abs_r17.F90: New file.\n\t* generated/_acos_r17.F90: New file.\n\t* generated/_acosh_r17.F90: New file.\n\t* generated/_aimag_c17.F90: New file.\n\t* generated/_aint_r17.F90: New file.\n\t* generated/_anint_r17.F90: New file.\n\t* generated/_asin_r17.F90: New file.\n\t* generated/_asinh_r17.F90: New file.\n\t* generated/_atan2_r17.F90: New file.\n\t* generated/_atan_r17.F90: New file.\n\t* generated/_atanh_r17.F90: New file.\n\t* generated/_conjg_c17.F90: New file.\n\t* generated/_cos_c17.F90: New file.\n\t* generated/_cos_r17.F90: New file.\n\t* generated/_cosh_r17.F90: New file.\n\t* generated/_dim_r17.F90: New file.\n\t* generated/_exp_c17.F90: New file.\n\t* generated/_exp_r17.F90: New file.\n\t* generated/_log10_r17.F90: New file.\n\t* generated/_log_c17.F90: New file.\n\t* generated/_log_r17.F90: New file.\n\t* generated/_mod_r17.F90: New file.\n\t* generated/_sign_r17.F90: New file.\n\t* generated/_sin_c17.F90: New file.\n\t* generated/_sin_r17.F90: New file.\n\t* generated/_sinh_r17.F90: New file.\n\t* generated/_sqrt_c17.F90: New file.\n\t* generated/_sqrt_r17.F90: New file.\n\t* generated/_tan_r17.F90: New file.\n\t* generated/_tanh_r17.F90: New file.\n\t* generated/bessel_r17.c: New file.\n\t* generated/cshift0_c17.c: New file.\n\t* generated/cshift0_r17.c: New file.\n\t* generated/cshift1_16_c17.c: New file.\n\t* generated/cshift1_16_r17.c: New file.\n\t* generated/cshift1_4_c17.c: New file.\n\t* generated/cshift1_4_r17.c: New file.\n\t* generated/cshift1_8_c17.c: New file.\n\t* generated/cshift1_8_r17.c: New file.\n\t* generated/findloc0_c17.c: New file.\n\t* generated/findloc0_r17.c: New file.\n\t* generated/findloc1_c17.c: New file.\n\t* generated/findloc1_r17.c: New file.\n\t* generated/in_pack_c17.c: New file.\n\t* generated/in_pack_r17.c: New file.\n\t* generated/in_unpack_c17.c: New file.\n\t* generated/in_unpack_r17.c: New file.\n\t* generated/matmul_c17.c: New file.\n\t* generated/matmul_r17.c: New file.\n\t* generated/matmulavx128_c17.c: New file.\n\t* generated/matmulavx128_r17.c: New file.\n\t* generated/maxloc0_16_r17.c: New file.\n\t* generated/maxloc0_4_r17.c: New file.\n\t* generated/maxloc0_8_r17.c: New file.\n\t* generated/maxloc1_16_r17.c: New file.\n\t* generated/maxloc1_4_r17.c: New file.\n\t* generated/maxloc1_8_r17.c: New file.\n\t* generated/maxval_r17.c: New file.\n\t* generated/minloc0_16_r17.c: New file.\n\t* generated/minloc0_4_r17.c: New file.\n\t* generated/minloc0_8_r17.c: New file.\n\t* generated/minloc1_16_r17.c: New file.\n\t* generated/minloc1_4_r17.c: New file.\n\t* generated/minloc1_8_r17.c: New file.\n\t* generated/minval_r17.c: New file.\n\t* generated/norm2_r17.c: New file.\n\t* generated/pack_c17.c: New file.\n\t* generated/pack_r17.c: New file.\n\t* generated/pow_c17_i16.c: New file.\n\t* generated/pow_c17_i4.c: New file.\n\t* generated/pow_c17_i8.c: New file.\n\t* generated/pow_r17_i16.c: New file.\n\t* generated/pow_r17_i4.c: New file.\n\t* generated/pow_r17_i8.c: New file.\n\t* generated/product_c17.c: New file.\n\t* generated/product_r17.c: New file.\n\t* generated/reshape_c17.c: New file.\n\t* generated/reshape_r17.c: New file.\n\t* generated/spread_c17.c: New file.\n\t* generated/spread_r17.c: New file.\n\t* generated/sum_c17.c: New file.\n\t* generated/sum_r17.c: New file.\n\t* generated/unpack_c17.c: New file.\n\t* generated/unpack_r17.c: New file.", "tree": {"sha": "981b8805239e35c9094a5f75155be37d20c1d847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/981b8805239e35c9094a5f75155be37d20c1d847"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/comments", "author": null, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db8d94a0570dc1f3de10c9eb9fe6e91df804272b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db8d94a0570dc1f3de10c9eb9fe6e91df804272b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db8d94a0570dc1f3de10c9eb9fe6e91df804272b"}], "stats": {"total": 27657, "additions": 27465, "deletions": 192}, "files": [{"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "Makefile.am", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/Makefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/Makefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.am?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "71139abcf69133e67fcb07afae943041dc60c137", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 144, "deletions": 54, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -243,7 +243,8 @@ i_bessel_c= \\\n $(srcdir)/generated/bessel_r4.c \\\n $(srcdir)/generated/bessel_r8.c \\\n $(srcdir)/generated/bessel_r10.c \\\n-$(srcdir)/generated/bessel_r16.c\n+$(srcdir)/generated/bessel_r16.c \\\n+$(srcdir)/generated/bessel_r17.c\n \n i_count_c= \\\n $(srcdir)/generated/count_1_l.c \\\n@@ -283,10 +284,12 @@ $(srcdir)/generated/findloc0_r4.c \\\n $(srcdir)/generated/findloc0_r8.c \\\n $(srcdir)/generated/findloc0_r10.c \\\n $(srcdir)/generated/findloc0_r16.c \\\n+$(srcdir)/generated/findloc0_r17.c \\\n $(srcdir)/generated/findloc0_c4.c \\\n $(srcdir)/generated/findloc0_c8.c \\\n $(srcdir)/generated/findloc0_c10.c \\\n-$(srcdir)/generated/findloc0_c16.c\n+$(srcdir)/generated/findloc0_c16.c \\\n+$(srcdir)/generated/findloc0_c17.c\n \n i_findloc0s_c= \\\n $(srcdir)/generated/findloc0_s1.c \\\n@@ -302,10 +305,12 @@ $(srcdir)/generated/findloc1_r4.c \\\n $(srcdir)/generated/findloc1_r8.c \\\n $(srcdir)/generated/findloc1_r10.c \\\n $(srcdir)/generated/findloc1_r16.c \\\n+$(srcdir)/generated/findloc1_r17.c \\\n $(srcdir)/generated/findloc1_c4.c \\\n $(srcdir)/generated/findloc1_c8.c \\\n $(srcdir)/generated/findloc1_c10.c \\\n-$(srcdir)/generated/findloc1_c16.c\n+$(srcdir)/generated/findloc1_c16.c \\\n+$(srcdir)/generated/findloc1_c17.c\n \n i_findloc1s_c= \\\n $(srcdir)/generated/findloc1_s1.c \\\n@@ -342,7 +347,10 @@ $(srcdir)/generated/maxloc0_8_r10.c \\\n $(srcdir)/generated/maxloc0_16_r10.c \\\n $(srcdir)/generated/maxloc0_4_r16.c \\\n $(srcdir)/generated/maxloc0_8_r16.c \\\n-$(srcdir)/generated/maxloc0_16_r16.c\n+$(srcdir)/generated/maxloc0_16_r16.c \\\n+$(srcdir)/generated/maxloc0_4_r17.c \\\n+$(srcdir)/generated/maxloc0_8_r17.c \\\n+$(srcdir)/generated/maxloc0_16_r17.c\n \n i_maxloc0s_c = \\\n $(srcdir)/generated/maxloc0_4_s1.c \\\n@@ -379,7 +387,10 @@ $(srcdir)/generated/maxloc1_8_r10.c \\\n $(srcdir)/generated/maxloc1_16_r10.c \\\n $(srcdir)/generated/maxloc1_4_r16.c \\\n $(srcdir)/generated/maxloc1_8_r16.c \\\n-$(srcdir)/generated/maxloc1_16_r16.c\n+$(srcdir)/generated/maxloc1_16_r16.c \\\n+$(srcdir)/generated/maxloc1_4_r17.c \\\n+$(srcdir)/generated/maxloc1_8_r17.c \\\n+$(srcdir)/generated/maxloc1_16_r17.c\n \n i_maxloc1s_c= \\\n $(srcdir)/generated/maxloc1_4_s1.c \\\n@@ -406,7 +417,8 @@ $(srcdir)/generated/maxval_i16.c \\\n $(srcdir)/generated/maxval_r4.c \\\n $(srcdir)/generated/maxval_r8.c \\\n $(srcdir)/generated/maxval_r10.c \\\n-$(srcdir)/generated/maxval_r16.c\n+$(srcdir)/generated/maxval_r16.c \\\n+$(srcdir)/generated/maxval_r17.c\n \n i_maxval0s_c=\\\n $(srcdir)/generated/maxval0_s1.c \\\n@@ -443,7 +455,10 @@ $(srcdir)/generated/minloc0_8_r10.c \\\n $(srcdir)/generated/minloc0_16_r10.c \\\n $(srcdir)/generated/minloc0_4_r16.c \\\n $(srcdir)/generated/minloc0_8_r16.c \\\n-$(srcdir)/generated/minloc0_16_r16.c\n+$(srcdir)/generated/minloc0_16_r16.c \\\n+$(srcdir)/generated/minloc0_4_r17.c \\\n+$(srcdir)/generated/minloc0_8_r17.c \\\n+$(srcdir)/generated/minloc0_16_r17.c\n \n i_minloc0s_c = \\\n $(srcdir)/generated/minloc0_4_s1.c \\\n@@ -480,7 +495,10 @@ $(srcdir)/generated/minloc1_8_r10.c \\\n $(srcdir)/generated/minloc1_16_r10.c \\\n $(srcdir)/generated/minloc1_4_r16.c \\\n $(srcdir)/generated/minloc1_8_r16.c \\\n-$(srcdir)/generated/minloc1_16_r16.c\n+$(srcdir)/generated/minloc1_16_r16.c \\\n+$(srcdir)/generated/minloc1_4_r17.c \\\n+$(srcdir)/generated/minloc1_8_r17.c \\\n+$(srcdir)/generated/minloc1_16_r17.c\n \n i_minloc1s_c= \\\n $(srcdir)/generated/minloc1_4_s1.c \\\n@@ -507,7 +525,8 @@ $(srcdir)/generated/minval_i16.c \\\n $(srcdir)/generated/minval_r4.c \\\n $(srcdir)/generated/minval_r8.c \\\n $(srcdir)/generated/minval_r10.c \\\n-$(srcdir)/generated/minval_r16.c\n+$(srcdir)/generated/minval_r16.c \\\n+$(srcdir)/generated/minval_r17.c\n \n i_minval0s_c=\\\n $(srcdir)/generated/minval0_s1.c \\\n@@ -521,7 +540,8 @@ i_norm2_c= \\\n $(srcdir)/generated/norm2_r4.c \\\n $(srcdir)/generated/norm2_r8.c \\\n $(srcdir)/generated/norm2_r10.c \\\n-$(srcdir)/generated/norm2_r16.c\n+$(srcdir)/generated/norm2_r16.c \\\n+$(srcdir)/generated/norm2_r17.c\n \n i_parity_c = \\\n $(srcdir)/generated/parity_l1.c \\\n@@ -540,10 +560,12 @@ $(srcdir)/generated/sum_r4.c \\\n $(srcdir)/generated/sum_r8.c \\\n $(srcdir)/generated/sum_r10.c \\\n $(srcdir)/generated/sum_r16.c \\\n+$(srcdir)/generated/sum_r17.c \\\n $(srcdir)/generated/sum_c4.c \\\n $(srcdir)/generated/sum_c8.c \\\n $(srcdir)/generated/sum_c10.c \\\n-$(srcdir)/generated/sum_c16.c\n+$(srcdir)/generated/sum_c16.c \\\n+$(srcdir)/generated/sum_c17.c\n \n i_product_c= \\\n $(srcdir)/generated/product_i1.c \\\n@@ -555,10 +577,12 @@ $(srcdir)/generated/product_r4.c \\\n $(srcdir)/generated/product_r8.c \\\n $(srcdir)/generated/product_r10.c \\\n $(srcdir)/generated/product_r16.c \\\n+$(srcdir)/generated/product_r17.c \\\n $(srcdir)/generated/product_c4.c \\\n $(srcdir)/generated/product_c8.c \\\n $(srcdir)/generated/product_c10.c \\\n-$(srcdir)/generated/product_c16.c\n+$(srcdir)/generated/product_c16.c \\\n+$(srcdir)/generated/product_c17.c\n \n i_matmul_c= \\\n $(srcdir)/generated/matmul_i1.c \\\n@@ -570,10 +594,12 @@ $(srcdir)/generated/matmul_r4.c \\\n $(srcdir)/generated/matmul_r8.c \\\n $(srcdir)/generated/matmul_r10.c \\\n $(srcdir)/generated/matmul_r16.c \\\n+$(srcdir)/generated/matmul_r17.c \\\n $(srcdir)/generated/matmul_c4.c \\\n $(srcdir)/generated/matmul_c8.c \\\n $(srcdir)/generated/matmul_c10.c \\\n-$(srcdir)/generated/matmul_c16.c\n+$(srcdir)/generated/matmul_c16.c \\\n+$(srcdir)/generated/matmul_c17.c\n \n i_matmulavx128_c= \\\n $(srcdir)/generated/matmulavx128_i1.c \\\n@@ -585,10 +611,12 @@ $(srcdir)/generated/matmulavx128_r4.c \\\n $(srcdir)/generated/matmulavx128_r8.c \\\n $(srcdir)/generated/matmulavx128_r10.c \\\n $(srcdir)/generated/matmulavx128_r16.c \\\n+$(srcdir)/generated/matmulavx128_r17.c \\\n $(srcdir)/generated/matmulavx128_c4.c \\\n $(srcdir)/generated/matmulavx128_c8.c \\\n $(srcdir)/generated/matmulavx128_c10.c \\\n-$(srcdir)/generated/matmulavx128_c16.c\n+$(srcdir)/generated/matmulavx128_c16.c \\\n+$(srcdir)/generated/matmulavx128_c17.c\n \n i_matmull_c= \\\n $(srcdir)/generated/matmul_l4.c \\\n@@ -610,10 +638,12 @@ $(srcdir)/generated/reshape_r4.c \\\n $(srcdir)/generated/reshape_r8.c \\\n $(srcdir)/generated/reshape_r10.c \\\n $(srcdir)/generated/reshape_r16.c \\\n+$(srcdir)/generated/reshape_r17.c \\\n $(srcdir)/generated/reshape_c4.c \\\n $(srcdir)/generated/reshape_c8.c \\\n $(srcdir)/generated/reshape_c10.c \\\n-$(srcdir)/generated/reshape_c16.c\n+$(srcdir)/generated/reshape_c16.c \\\n+$(srcdir)/generated/reshape_c17.c\n \n i_eoshift1_c= \\\n $(srcdir)/generated/eoshift1_4.c \\\n@@ -635,10 +665,12 @@ $(srcdir)/generated/cshift0_r4.c \\\n $(srcdir)/generated/cshift0_r8.c \\\n $(srcdir)/generated/cshift0_r10.c \\\n $(srcdir)/generated/cshift0_r16.c \\\n+$(srcdir)/generated/cshift0_r17.c \\\n $(srcdir)/generated/cshift0_c4.c \\\n $(srcdir)/generated/cshift0_c8.c \\\n $(srcdir)/generated/cshift0_c10.c \\\n-$(srcdir)/generated/cshift0_c16.c\n+$(srcdir)/generated/cshift0_c16.c \\\n+$(srcdir)/generated/cshift0_c17.c\n \n i_cshift1_c= \\\n $(srcdir)/generated/cshift1_4.c \\\n@@ -655,10 +687,12 @@ $(srcdir)/generated/cshift1_4_r4.c \\\n $(srcdir)/generated/cshift1_4_r8.c \\\n $(srcdir)/generated/cshift1_4_r10.c \\\n $(srcdir)/generated/cshift1_4_r16.c \\\n+$(srcdir)/generated/cshift1_4_r17.c \\\n $(srcdir)/generated/cshift1_4_c4.c \\\n $(srcdir)/generated/cshift1_4_c8.c \\\n $(srcdir)/generated/cshift1_4_c10.c \\\n $(srcdir)/generated/cshift1_4_c16.c \\\n+$(srcdir)/generated/cshift1_4_c17.c \\\n $(srcdir)/generated/cshift1_8_i1.c \\\n $(srcdir)/generated/cshift1_8_i2.c \\\n $(srcdir)/generated/cshift1_8_i4.c \\\n@@ -668,10 +702,12 @@ $(srcdir)/generated/cshift1_8_r4.c \\\n $(srcdir)/generated/cshift1_8_r8.c \\\n $(srcdir)/generated/cshift1_8_r10.c \\\n $(srcdir)/generated/cshift1_8_r16.c \\\n+$(srcdir)/generated/cshift1_8_r17.c \\\n $(srcdir)/generated/cshift1_8_c4.c \\\n $(srcdir)/generated/cshift1_8_c8.c \\\n $(srcdir)/generated/cshift1_8_c10.c \\\n $(srcdir)/generated/cshift1_8_c16.c \\\n+$(srcdir)/generated/cshift1_8_c17.c \\\n $(srcdir)/generated/cshift1_16_i1.c \\\n $(srcdir)/generated/cshift1_16_i2.c \\\n $(srcdir)/generated/cshift1_16_i4.c \\\n@@ -681,10 +717,12 @@ $(srcdir)/generated/cshift1_16_r4.c \\\n $(srcdir)/generated/cshift1_16_r8.c \\\n $(srcdir)/generated/cshift1_16_r10.c \\\n $(srcdir)/generated/cshift1_16_r16.c \\\n+$(srcdir)/generated/cshift1_16_r17.c \\\n $(srcdir)/generated/cshift1_16_c4.c \\\n $(srcdir)/generated/cshift1_16_c8.c \\\n $(srcdir)/generated/cshift1_16_c10.c \\\n-$(srcdir)/generated/cshift1_16_c16.c\n+$(srcdir)/generated/cshift1_16_c16.c \\\n+$(srcdir)/generated/cshift1_16_c17.c\n \n in_pack_c = \\\n $(srcdir)/generated/in_pack_i1.c \\\n@@ -696,10 +734,12 @@ $(srcdir)/generated/in_pack_r4.c \\\n $(srcdir)/generated/in_pack_r8.c \\\n $(srcdir)/generated/in_pack_r10.c \\\n $(srcdir)/generated/in_pack_r16.c \\\n+$(srcdir)/generated/in_pack_r17.c \\\n $(srcdir)/generated/in_pack_c4.c \\\n $(srcdir)/generated/in_pack_c8.c \\\n $(srcdir)/generated/in_pack_c10.c \\\n-$(srcdir)/generated/in_pack_c16.c\n+$(srcdir)/generated/in_pack_c16.c \\\n+$(srcdir)/generated/in_pack_c17.c\n \n in_unpack_c = \\\n $(srcdir)/generated/in_unpack_i1.c \\\n@@ -711,42 +751,50 @@ $(srcdir)/generated/in_unpack_r4.c \\\n $(srcdir)/generated/in_unpack_r8.c \\\n $(srcdir)/generated/in_unpack_r10.c \\\n $(srcdir)/generated/in_unpack_r16.c \\\n+$(srcdir)/generated/in_unpack_r17.c \\\n $(srcdir)/generated/in_unpack_c4.c \\\n $(srcdir)/generated/in_unpack_c8.c \\\n $(srcdir)/generated/in_unpack_c10.c \\\n-$(srcdir)/generated/in_unpack_c16.c\n+$(srcdir)/generated/in_unpack_c16.c \\\n+$(srcdir)/generated/in_unpack_c17.c\n \n i_pow_c = \\\n $(srcdir)/generated/pow_i4_i4.c \\\n $(srcdir)/generated/pow_i8_i4.c \\\n $(srcdir)/generated/pow_i16_i4.c \\\n $(srcdir)/generated/pow_r16_i4.c \\\n+$(srcdir)/generated/pow_r17_i4.c \\\n $(srcdir)/generated/pow_c4_i4.c \\\n $(srcdir)/generated/pow_c8_i4.c \\\n $(srcdir)/generated/pow_c10_i4.c \\\n $(srcdir)/generated/pow_c16_i4.c \\\n+$(srcdir)/generated/pow_c17_i4.c \\\n $(srcdir)/generated/pow_i4_i8.c \\\n $(srcdir)/generated/pow_i8_i8.c \\\n $(srcdir)/generated/pow_i16_i8.c \\\n $(srcdir)/generated/pow_r4_i8.c \\\n $(srcdir)/generated/pow_r8_i8.c \\\n $(srcdir)/generated/pow_r10_i8.c \\\n $(srcdir)/generated/pow_r16_i8.c \\\n+$(srcdir)/generated/pow_r17_i8.c \\\n $(srcdir)/generated/pow_c4_i8.c \\\n $(srcdir)/generated/pow_c8_i8.c \\\n $(srcdir)/generated/pow_c10_i8.c \\\n $(srcdir)/generated/pow_c16_i8.c \\\n+$(srcdir)/generated/pow_c17_i8.c \\\n $(srcdir)/generated/pow_i4_i16.c \\\n $(srcdir)/generated/pow_i8_i16.c \\\n $(srcdir)/generated/pow_i16_i16.c \\\n $(srcdir)/generated/pow_r4_i16.c \\\n $(srcdir)/generated/pow_r8_i16.c \\\n $(srcdir)/generated/pow_r10_i16.c \\\n $(srcdir)/generated/pow_r16_i16.c \\\n+$(srcdir)/generated/pow_r17_i16.c \\\n $(srcdir)/generated/pow_c4_i16.c \\\n $(srcdir)/generated/pow_c8_i16.c \\\n $(srcdir)/generated/pow_c10_i16.c \\\n-$(srcdir)/generated/pow_c16_i16.c\n+$(srcdir)/generated/pow_c16_i16.c \\\n+$(srcdir)/generated/pow_c17_i16.c\n \n i_pack_c = \\\n $(srcdir)/generated/pack_i1.c \\\n@@ -758,10 +806,12 @@ $(srcdir)/generated/pack_r4.c \\\n $(srcdir)/generated/pack_r8.c \\\n $(srcdir)/generated/pack_r10.c \\\n $(srcdir)/generated/pack_r16.c \\\n+$(srcdir)/generated/pack_r17.c \\\n $(srcdir)/generated/pack_c4.c \\\n $(srcdir)/generated/pack_c8.c \\\n $(srcdir)/generated/pack_c10.c \\\n-$(srcdir)/generated/pack_c16.c\n+$(srcdir)/generated/pack_c16.c \\\n+$(srcdir)/generated/pack_c17.c\n \n i_unpack_c = \\\n $(srcdir)/generated/unpack_i1.c \\\n@@ -773,10 +823,12 @@ $(srcdir)/generated/unpack_r4.c \\\n $(srcdir)/generated/unpack_r8.c \\\n $(srcdir)/generated/unpack_r10.c \\\n $(srcdir)/generated/unpack_r16.c \\\n+$(srcdir)/generated/unpack_r17.c \\\n $(srcdir)/generated/unpack_c4.c \\\n $(srcdir)/generated/unpack_c8.c \\\n $(srcdir)/generated/unpack_c10.c \\\n-$(srcdir)/generated/unpack_c16.c\n+$(srcdir)/generated/unpack_c16.c \\\n+$(srcdir)/generated/unpack_c17.c\n \n i_spread_c = \\\n $(srcdir)/generated/spread_i1.c \\\n@@ -788,157 +840,186 @@ $(srcdir)/generated/spread_r4.c \\\n $(srcdir)/generated/spread_r8.c \\\n $(srcdir)/generated/spread_r10.c \\\n $(srcdir)/generated/spread_r16.c \\\n+$(srcdir)/generated/spread_r17.c \\\n $(srcdir)/generated/spread_c4.c \\\n $(srcdir)/generated/spread_c8.c \\\n $(srcdir)/generated/spread_c10.c \\\n-$(srcdir)/generated/spread_c16.c \n+$(srcdir)/generated/spread_c16.c \\\n+$(srcdir)/generated/spread_c17.c\n \n i_isobinding_c = \\\n $(srcdir)/runtime/ISO_Fortran_binding.c\n \n m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n-    m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n-    m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n-    m4/matmul.m4 m4/matmull.m4 m4/ifunction_logical.m4 \\\n-    m4/ctrig.m4 m4/cexp.m4 m4/chyp.m4 m4/mtype.m4 \\\n-    m4/specific.m4 m4/specific2.m4 m4/head.m4 m4/shape.m4 m4/reshape.m4 \\\n-    m4/eoshift1.m4 m4/eoshift3.m4 \\\n-    m4/pow.m4 \\\n-    m4/misc_specifics.m4 m4/pack.m4 \\\n-    m4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4 \\\n-    m4/iall.m4 m4/iany.m4 m4/iparity.m4 m4/iforeach-s.m4 m4/findloc0.m4 \\\n-    m4/findloc0s.m4 m4/ifindloc0.m4 m4/findloc1.m4 m4/ifindloc1.m4 \\\n-    m4/findloc2s.m4 m4/ifindloc2.m4\n+\tm4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n+\tm4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n+\tm4/matmul.m4 m4/matmull.m4 m4/ifunction_logical.m4 \\\n+\tm4/ctrig.m4 m4/cexp.m4 m4/chyp.m4 m4/mtype.m4 \\\n+\tm4/specific.m4 m4/specific2.m4 m4/head.m4 m4/shape.m4 m4/reshape.m4 \\\n+\tm4/eoshift1.m4 m4/eoshift3.m4 \\\n+\tm4/pow.m4 \\\n+\tm4/misc_specifics.m4 m4/pack.m4 \\\n+\tm4/unpack.m4 m4/spread.m4 m4/bessel.m4 m4/norm2.m4 m4/parity.m4 \\\n+\tm4/iall.m4 m4/iany.m4 m4/iparity.m4 m4/iforeach-s.m4 m4/findloc0.m4 \\\n+\tm4/findloc0s.m4 m4/ifindloc0.m4 m4/findloc1.m4 m4/ifindloc1.m4 \\\n+\tm4/findloc2s.m4 m4/ifindloc2.m4\n \n gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n-    $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n-    $(i_product_c) $(i_sum_c) $(i_bessel_c) $(i_iall_c) $(i_iany_c) \\\n-    $(i_iparity_c) $(i_norm2_c) $(i_parity_c) \\\n-    $(i_matmul_c) $(i_matmull_c) $(i_shape_c) $(i_eoshift1_c) \\\n-    $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n-    $(i_pow_c) $(i_pack_c) $(i_unpack_c) $(i_matmulavx128_c) \\\n-    $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n-    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n-    include/ISO_Fortran_binding.h \\\n-    $(i_cshift1a_c) $(i_maxloc0s_c) $(i_minloc0s_c) $(i_maxloc1s_c) \\\n-    $(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c) $(i_maxvals_c) \\\n-    $(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c) \\\n-    $(i_findloc0_c) $(i_findloc0s_c) $(i_findloc1_c) $(i_findloc1s_c) \\\n-    $(i_findloc2s_c) $(i_isobinding_c)\n+\t$(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n+\t$(i_product_c) $(i_sum_c) $(i_bessel_c) $(i_iall_c) $(i_iany_c) \\\n+\t$(i_iparity_c) $(i_norm2_c) $(i_parity_c) \\\n+\t$(i_matmul_c) $(i_matmull_c) $(i_shape_c) $(i_eoshift1_c) \\\n+\t$(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n+\t$(i_pow_c) $(i_pack_c) $(i_unpack_c) $(i_matmulavx128_c) \\\n+\t$(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n+\t$(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h fpu-target.inc \\\n+\tinclude/ISO_Fortran_binding.h \\\n+\t$(i_cshift1a_c) $(i_maxloc0s_c) $(i_minloc0s_c) $(i_maxloc1s_c) \\\n+\t$(i_minloc1s_c) $(i_maxloc2s_c) $(i_minloc2s_c) $(i_maxvals_c) \\\n+\t$(i_maxval0s_c) $(i_minval0s_c) $(i_maxval1s_c) $(i_minval1s_c) \\\n+\t$(i_findloc0_c) $(i_findloc0s_c) $(i_findloc1_c) $(i_findloc1s_c) \\\n+\t$(i_findloc2s_c) $(i_isobinding_c)\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n $(srcdir)/generated/_abs_c4.F90 \\\n $(srcdir)/generated/_abs_c8.F90 \\\n $(srcdir)/generated/_abs_c10.F90 \\\n $(srcdir)/generated/_abs_c16.F90 \\\n+$(srcdir)/generated/_abs_c17.F90 \\\n $(srcdir)/generated/_abs_i4.F90 \\\n $(srcdir)/generated/_abs_i8.F90 \\\n $(srcdir)/generated/_abs_i16.F90 \\\n $(srcdir)/generated/_abs_r4.F90 \\\n $(srcdir)/generated/_abs_r8.F90 \\\n $(srcdir)/generated/_abs_r10.F90 \\\n $(srcdir)/generated/_abs_r16.F90 \\\n+$(srcdir)/generated/_abs_r17.F90 \\\n $(srcdir)/generated/_aimag_c4.F90 \\\n $(srcdir)/generated/_aimag_c8.F90 \\\n $(srcdir)/generated/_aimag_c10.F90 \\\n $(srcdir)/generated/_aimag_c16.F90 \\\n+$(srcdir)/generated/_aimag_c17.F90 \\\n $(srcdir)/generated/_exp_r4.F90 \\\n $(srcdir)/generated/_exp_r8.F90 \\\n $(srcdir)/generated/_exp_r10.F90 \\\n $(srcdir)/generated/_exp_r16.F90 \\\n+$(srcdir)/generated/_exp_r17.F90 \\\n $(srcdir)/generated/_exp_c4.F90 \\\n $(srcdir)/generated/_exp_c8.F90 \\\n $(srcdir)/generated/_exp_c10.F90 \\\n $(srcdir)/generated/_exp_c16.F90 \\\n+$(srcdir)/generated/_exp_c17.F90 \\\n $(srcdir)/generated/_log_r4.F90 \\\n $(srcdir)/generated/_log_r8.F90 \\\n $(srcdir)/generated/_log_r10.F90 \\\n $(srcdir)/generated/_log_r16.F90 \\\n+$(srcdir)/generated/_log_r17.F90 \\\n $(srcdir)/generated/_log_c4.F90 \\\n $(srcdir)/generated/_log_c8.F90 \\\n $(srcdir)/generated/_log_c10.F90 \\\n $(srcdir)/generated/_log_c16.F90 \\\n+$(srcdir)/generated/_log_c17.F90 \\\n $(srcdir)/generated/_log10_r4.F90 \\\n $(srcdir)/generated/_log10_r8.F90 \\\n $(srcdir)/generated/_log10_r10.F90 \\\n $(srcdir)/generated/_log10_r16.F90 \\\n+$(srcdir)/generated/_log10_r17.F90 \\\n $(srcdir)/generated/_sqrt_r4.F90 \\\n $(srcdir)/generated/_sqrt_r8.F90 \\\n $(srcdir)/generated/_sqrt_r10.F90 \\\n $(srcdir)/generated/_sqrt_r16.F90 \\\n+$(srcdir)/generated/_sqrt_r17.F90 \\\n $(srcdir)/generated/_sqrt_c4.F90 \\\n $(srcdir)/generated/_sqrt_c8.F90 \\\n $(srcdir)/generated/_sqrt_c10.F90 \\\n $(srcdir)/generated/_sqrt_c16.F90 \\\n+$(srcdir)/generated/_sqrt_c17.F90 \\\n $(srcdir)/generated/_asin_r4.F90 \\\n $(srcdir)/generated/_asin_r8.F90 \\\n $(srcdir)/generated/_asin_r10.F90 \\\n $(srcdir)/generated/_asin_r16.F90 \\\n+$(srcdir)/generated/_asin_r17.F90 \\\n $(srcdir)/generated/_asinh_r4.F90 \\\n $(srcdir)/generated/_asinh_r8.F90 \\\n $(srcdir)/generated/_asinh_r10.F90 \\\n $(srcdir)/generated/_asinh_r16.F90 \\\n+$(srcdir)/generated/_asinh_r17.F90 \\\n $(srcdir)/generated/_acos_r4.F90 \\\n $(srcdir)/generated/_acos_r8.F90 \\\n $(srcdir)/generated/_acos_r10.F90 \\\n $(srcdir)/generated/_acos_r16.F90 \\\n+$(srcdir)/generated/_acos_r17.F90 \\\n $(srcdir)/generated/_acosh_r4.F90 \\\n $(srcdir)/generated/_acosh_r8.F90 \\\n $(srcdir)/generated/_acosh_r10.F90 \\\n $(srcdir)/generated/_acosh_r16.F90 \\\n+$(srcdir)/generated/_acosh_r17.F90 \\\n $(srcdir)/generated/_atan_r4.F90 \\\n $(srcdir)/generated/_atan_r8.F90 \\\n $(srcdir)/generated/_atan_r10.F90 \\\n $(srcdir)/generated/_atan_r16.F90 \\\n+$(srcdir)/generated/_atan_r17.F90 \\\n $(srcdir)/generated/_atanh_r4.F90 \\\n $(srcdir)/generated/_atanh_r8.F90 \\\n $(srcdir)/generated/_atanh_r10.F90 \\\n $(srcdir)/generated/_atanh_r16.F90 \\\n+$(srcdir)/generated/_atanh_r17.F90 \\\n $(srcdir)/generated/_sin_r4.F90 \\\n $(srcdir)/generated/_sin_r8.F90 \\\n $(srcdir)/generated/_sin_r10.F90 \\\n $(srcdir)/generated/_sin_r16.F90 \\\n+$(srcdir)/generated/_sin_r17.F90 \\\n $(srcdir)/generated/_sin_c4.F90 \\\n $(srcdir)/generated/_sin_c8.F90 \\\n $(srcdir)/generated/_sin_c10.F90 \\\n $(srcdir)/generated/_sin_c16.F90 \\\n+$(srcdir)/generated/_sin_c17.F90 \\\n $(srcdir)/generated/_cos_r4.F90 \\\n $(srcdir)/generated/_cos_r8.F90 \\\n $(srcdir)/generated/_cos_r10.F90 \\\n $(srcdir)/generated/_cos_r16.F90 \\\n+$(srcdir)/generated/_cos_r17.F90 \\\n $(srcdir)/generated/_cos_c4.F90 \\\n $(srcdir)/generated/_cos_c8.F90 \\\n $(srcdir)/generated/_cos_c10.F90 \\\n $(srcdir)/generated/_cos_c16.F90 \\\n+$(srcdir)/generated/_cos_c17.F90 \\\n $(srcdir)/generated/_tan_r4.F90 \\\n $(srcdir)/generated/_tan_r8.F90 \\\n $(srcdir)/generated/_tan_r10.F90 \\\n $(srcdir)/generated/_tan_r16.F90 \\\n+$(srcdir)/generated/_tan_r17.F90 \\\n $(srcdir)/generated/_sinh_r4.F90 \\\n $(srcdir)/generated/_sinh_r8.F90 \\\n $(srcdir)/generated/_sinh_r10.F90 \\\n $(srcdir)/generated/_sinh_r16.F90 \\\n+$(srcdir)/generated/_sinh_r17.F90 \\\n $(srcdir)/generated/_cosh_r4.F90 \\\n $(srcdir)/generated/_cosh_r8.F90 \\\n $(srcdir)/generated/_cosh_r10.F90 \\\n $(srcdir)/generated/_cosh_r16.F90 \\\n+$(srcdir)/generated/_cosh_r17.F90 \\\n $(srcdir)/generated/_tanh_r4.F90 \\\n $(srcdir)/generated/_tanh_r8.F90 \\\n $(srcdir)/generated/_tanh_r10.F90 \\\n $(srcdir)/generated/_tanh_r16.F90 \\\n+$(srcdir)/generated/_tanh_r17.F90 \\\n $(srcdir)/generated/_conjg_c4.F90 \\\n $(srcdir)/generated/_conjg_c8.F90 \\\n $(srcdir)/generated/_conjg_c10.F90 \\\n $(srcdir)/generated/_conjg_c16.F90 \\\n+$(srcdir)/generated/_conjg_c17.F90 \\\n $(srcdir)/generated/_aint_r4.F90 \\\n $(srcdir)/generated/_aint_r8.F90 \\\n $(srcdir)/generated/_aint_r10.F90 \\\n $(srcdir)/generated/_aint_r16.F90 \\\n+$(srcdir)/generated/_aint_r17.F90 \\\n $(srcdir)/generated/_anint_r4.F90 \\\n $(srcdir)/generated/_anint_r8.F90 \\\n $(srcdir)/generated/_anint_r10.F90 \\\n-$(srcdir)/generated/_anint_r16.F90\n+$(srcdir)/generated/_anint_r16.F90 \\\n+$(srcdir)/generated/_anint_r17.F90\n \n gfor_built_specific2_src= \\\n $(srcdir)/generated/_sign_i4.F90 \\\n@@ -948,24 +1029,28 @@ $(srcdir)/generated/_sign_r4.F90 \\\n $(srcdir)/generated/_sign_r8.F90 \\\n $(srcdir)/generated/_sign_r10.F90 \\\n $(srcdir)/generated/_sign_r16.F90 \\\n+$(srcdir)/generated/_sign_r17.F90 \\\n $(srcdir)/generated/_dim_i4.F90 \\\n $(srcdir)/generated/_dim_i8.F90 \\\n $(srcdir)/generated/_dim_i16.F90 \\\n $(srcdir)/generated/_dim_r4.F90 \\\n $(srcdir)/generated/_dim_r8.F90 \\\n $(srcdir)/generated/_dim_r10.F90 \\\n $(srcdir)/generated/_dim_r16.F90 \\\n+$(srcdir)/generated/_dim_r17.F90 \\\n $(srcdir)/generated/_atan2_r4.F90 \\\n $(srcdir)/generated/_atan2_r8.F90 \\\n $(srcdir)/generated/_atan2_r10.F90 \\\n $(srcdir)/generated/_atan2_r16.F90 \\\n+$(srcdir)/generated/_atan2_r17.F90 \\\n $(srcdir)/generated/_mod_i4.F90 \\\n $(srcdir)/generated/_mod_i8.F90 \\\n $(srcdir)/generated/_mod_i16.F90 \\\n $(srcdir)/generated/_mod_r4.F90 \\\n $(srcdir)/generated/_mod_r8.F90 \\\n $(srcdir)/generated/_mod_r10.F90 \\\n-$(srcdir)/generated/_mod_r16.F90\n+$(srcdir)/generated/_mod_r16.F90 \\\n+$(srcdir)/generated/_mod_r17.F90\n \n gfor_misc_specifics = $(srcdir)/generated/misc_specifics.F90\n \n@@ -991,6 +1076,11 @@ $(patsubst %.c,%.lo,$(notdir $(i_matmull_c))): AM_CFLAGS += -funroll-loops\n $(patsubst %.F90,%.lo,$(patsubst %.f90,%.lo,$(notdir $(gfor_specific_src)))): AM_FCFLAGS += -fallow-leading-underscore\n selected_real_kind.lo selected_int_kind.lo: AM_FCFLAGS += -fallow-leading-underscore\n \n+# Build *_r17.F90 and *_c17.F90 with additional -mabi=ieeelongdouble on powerpc64le-linux.\n+if HAVE_REAL_17\n+$(patsubst %.F90,%.lo,$(filter %_r17.F90 %_c17.F90,$(notdir $(gfor_specific_src)))): AM_FCFLAGS += -mabi=ieeelongdouble\n+endif\n+\n if IEEE_SUPPORT\n # Add flags for IEEE modules\n $(patsubst %.F90,%.lo,$(notdir $(gfor_ieee_src))): AM_FCFLAGS += -Wno-unused-dummy-argument -Wno-c-binding-type -ffree-line-length-0 -fallow-leading-underscore -fsignaling-nans\n@@ -1012,10 +1102,10 @@ ieee_arithmetic.mod: ieee_arithmetic.lo\n \t:\n \n BUILT_SOURCES=$(gfor_built_src) $(gfor_built_specific_src) \\\n-    $(gfor_built_specific2_src) $(gfor_misc_specifics)\n+\t$(gfor_built_specific2_src) $(gfor_misc_specifics)\n \n prereq_SRC = $(gfor_src) $(gfor_built_src) $(gfor_io_src) \\\n-    $(gfor_helper_src) $(gfor_ieee_src) $(gfor_io_headers) $(gfor_specific_src)\n+\t$(gfor_helper_src) $(gfor_ieee_src) $(gfor_io_headers) $(gfor_specific_src)\n \n if onestep\n # dummy sources for libtool\n@@ -1048,7 +1138,7 @@ libgfortran_la_SOURCES = $(prereq_SRC)\n \n endif\n \n-I_M4_DEPS=m4/iparm.m4\n+I_M4_DEPS=m4/iparm.m4 m4/mtype.m4\n I_M4_DEPS0=$(I_M4_DEPS) m4/iforeach.m4\n I_M4_DEPS1=$(I_M4_DEPS) m4/ifunction.m4\n I_M4_DEPS2=$(I_M4_DEPS) m4/ifunction_logical.m4"}, {"sha": "2c7d59ab13835a1246f9470e6446981a9105139d", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 761, "deletions": 128, "changes": 889, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "cc32e06b483e86f326c5801ce24a6a756aaa00b3", "filename": "libgfortran/configure", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -692,6 +692,8 @@ LIBGFOR_USE_SYMVER_FALSE\n LIBGFOR_USE_SYMVER_TRUE\n AM_CFLAGS\n AM_FCFLAGS\n+HAVE_REAL_17_FALSE\n+HAVE_REAL_17_TRUE\n toolexeclibdir\n toolexecdir\n EGREP\n@@ -5984,6 +5986,7 @@ fi\n \n \n # Add -Wall -fno-repack-arrays -fno-underscoring if we are using GCC.\n+have_real_17=no\n if test \"x$GCC\" = \"xyes\"; then\n   AM_FCFLAGS=\"-I . -Wall -Werror -fimplicit-none -fno-repack-arrays -fno-underscoring\"\n   ## We like to use C11 and C99 routines when available.  This makes\n@@ -5993,6 +5996,40 @@ if test \"x$GCC\" = \"xyes\"; then\n   ## Compile the following tests with the same system header contents\n   ## that we'll encounter when compiling our own source files.\n   CFLAGS=\"-std=gnu11 $CFLAGS\"\n+\n+  case x$target in\n+    xpowerpc64le*-linux*)\n+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#if __SIZEOF_LONG_DOUBLE__ != 16\n+\t\t\t   #error long double is double\n+\t\t\t   #endif\n+int\n+main ()\n+{\n+(void) 0;\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_cpp \"$LINENO\"; then :\n+  AM_FCFLAGS=\"$AM_FCFLAGS -mabi=ibmlongdouble\";\n+\t AM_CFLAGS=\"$AM_CFLAGS -mabi=ibmlongdouble\";\n+\t CFLAGS=\"$CFLAGS -mabi=ibmlongdouble\";\n+\t have_real_17=yes\n+fi\n+rm -f conftest.err conftest.i conftest.$ac_ext\n+      ;;\n+    *)\n+      ;;\n+  esac\n+fi\n+ if test \"x$have_real_17\" != xno; then\n+  HAVE_REAL_17_TRUE=\n+  HAVE_REAL_17_FALSE='#'\n+else\n+  HAVE_REAL_17_TRUE='#'\n+  HAVE_REAL_17_FALSE=\n fi\n \n # Add CET specific flags if CET is enabled\n@@ -12728,7 +12765,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12731 \"configure\"\n+#line 12769 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12834,7 +12871,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12837 \"configure\"\n+#line 12875 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -27093,7 +27130,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n   CFLAGS=\"$ac_save_CFLAGS\"\n \n \n-# Check wether we support AVX2 extensions\n+# Check whether we support AVX2 extensions\n \n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"-O2 -mavx2\"\n@@ -27123,7 +27160,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n   CFLAGS=\"$ac_save_CFLAGS\"\n \n \n-# Check wether we support AVX512f extensions\n+# Check whether we support AVX512f extensions\n \n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"-O2 -mavx512f\"\n@@ -27522,6 +27559,10 @@ if test -z \"${am__fastdepCC_TRUE}\" && test -z \"${am__fastdepCC_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"am__fastdepCC\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${HAVE_REAL_17_TRUE}\" && test -z \"${HAVE_REAL_17_FALSE}\"; then\n+  as_fn_error $? \"conditional \\\"HAVE_REAL_17\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${LIBGFOR_USE_SYMVER_TRUE}\" && test -z \"${LIBGFOR_USE_SYMVER_FALSE}\"; then\n   as_fn_error $? \"conditional \\\"LIBGFOR_USE_SYMVER\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "97439a805d55533a02be9b0e1406350fbec3e0c9", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -145,6 +145,7 @@ AC_SUBST(CFLAGS)\n AM_PROG_CC_C_O\n \n # Add -Wall -fno-repack-arrays -fno-underscoring if we are using GCC.\n+have_real_17=no\n if test \"x$GCC\" = \"xyes\"; then\n   AM_FCFLAGS=\"-I . -Wall -Werror -fimplicit-none -fno-repack-arrays -fno-underscoring\"\n   ## We like to use C11 and C99 routines when available.  This makes\n@@ -154,8 +155,24 @@ if test \"x$GCC\" = \"xyes\"; then\n   ## Compile the following tests with the same system header contents\n   ## that we'll encounter when compiling our own source files.\n   CFLAGS=\"-std=gnu11 $CFLAGS\"\n-fi\n \n+  case x$target in\n+    xpowerpc64le*-linux*)\n+      AC_PREPROC_IFELSE(\n+        [AC_LANG_PROGRAM([[#if __SIZEOF_LONG_DOUBLE__ != 16\n+\t\t\t   #error long double is double\n+\t\t\t   #endif]],\n+                         [[(void) 0;]])],\n+        [AM_FCFLAGS=\"$AM_FCFLAGS -mabi=ibmlongdouble\";\n+\t AM_CFLAGS=\"$AM_CFLAGS -mabi=ibmlongdouble\";\n+\t CFLAGS=\"$CFLAGS -mabi=ibmlongdouble\";\n+\t have_real_17=yes])\n+      ;;\n+    *)\n+      ;;\n+  esac\n+fi\n+AM_CONDITIONAL([HAVE_REAL_17], [test \"x$have_real_17\" != xno])\n # Add CET specific flags if CET is enabled\n GCC_CET_FLAGS(CET_FLAGS)\n AM_FCFLAGS=\"$AM_FCFLAGS $CET_FLAGS\"\n@@ -665,10 +682,10 @@ LIBGFOR_CHECK_CRLF\n # Check whether we support AVX extensions\n LIBGFOR_CHECK_AVX\n \n-# Check wether we support AVX2 extensions\n+# Check whether we support AVX2 extensions\n LIBGFOR_CHECK_AVX2\n \n-# Check wether we support AVX512f extensions\n+# Check whether we support AVX512f extensions\n LIBGFOR_CHECK_AVX512F\n \n # Check for FMA3 extensions"}, {"sha": "3c186a298b7291579b663cf681d50b0e8a40dc37", "filename": "libgfortran/generated/_abs_c17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_abs_c17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_abs_c17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_c17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+#ifdef HAVE_CABS_17\n+\n+elemental function _gfortran_specific__abs_c17 (parm)\n+   complex (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__abs_c17\n+\n+   _gfortran_specific__abs_c17 = abs (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "bc8f3eb7a2ec7e9977ec2c894dd5f16aa73055b3", "filename": "libgfortran/generated/_abs_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_abs_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_abs_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_abs_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_FABS_17\n+\n+elemental function _gfortran_specific__abs_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__abs_r17\n+\n+   _gfortran_specific__abs_r17 = abs (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "f9e928c5d20cdb136cde738d11a9e4c76d27b368", "filename": "libgfortran/generated/_acos_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_acos_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_acos_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_acos_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_ACOS_17\n+\n+elemental function _gfortran_specific__acos_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__acos_r17\n+\n+   _gfortran_specific__acos_r17 = acos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "4508691c4ea8eebd5b73722e4aeda7b8ef8f3034", "filename": "libgfortran/generated/_acosh_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_acosh_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_acosh_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_acosh_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_ACOSH_17\n+\n+elemental function _gfortran_specific__acosh_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__acosh_r17\n+\n+   _gfortran_specific__acosh_r17 = acosh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "b5a84fa0a786aa9ee4f987b081ef10d6c9b459ec", "filename": "libgfortran/generated/_aimag_c17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_aimag_c17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_aimag_c17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_aimag_c17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+\n+elemental function _gfortran_specific__aimag_c17 (parm)\n+   complex (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__aimag_c17\n+\n+   _gfortran_specific__aimag_c17 = aimag (parm)\n+end function\n+\n+\n+#endif"}, {"sha": "4e73b24946da62b0deac8c85f201b52c3dab54b7", "filename": "libgfortran/generated/_aint_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_aint_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_aint_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_aint_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_TRUNC_17\n+\n+elemental function _gfortran_specific__aint_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__aint_r17\n+\n+   _gfortran_specific__aint_r17 = aint (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "6b60e11e6079bf6a934b8124e349a5085305eb5c", "filename": "libgfortran/generated/_anint_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_anint_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_anint_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_anint_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_ROUND_17\n+\n+elemental function _gfortran_specific__anint_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__anint_r17\n+\n+   _gfortran_specific__anint_r17 = anint (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "120be0494c5a47665bf2961dc724161ee2be6552", "filename": "libgfortran/generated/_asin_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_asin_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_asin_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_asin_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_ASIN_17\n+\n+elemental function _gfortran_specific__asin_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__asin_r17\n+\n+   _gfortran_specific__asin_r17 = asin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "64f18d2198f8c73864e5be1558ae3ff06349b337", "filename": "libgfortran/generated/_asinh_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_asinh_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_asinh_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_asinh_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_ASINH_17\n+\n+elemental function _gfortran_specific__asinh_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__asinh_r17\n+\n+   _gfortran_specific__asinh_r17 = asinh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "f0fc9b88648b8487c23a3b31da021bc328fb13a2", "filename": "libgfortran/generated/_atan2_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_atan2_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_atan2_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan2_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+#ifdef HAVE_ATAN2_17\n+\n+elemental function _gfortran_specific__atan2_r17 (p1, p2)\n+   real (kind=17), intent (in) :: p1, p2\n+   real (kind=17) :: _gfortran_specific__atan2_r17\n+\n+   _gfortran_specific__atan2_r17 = atan2 (p1, p2)\n+end function\n+\n+#endif\n+\n+#endif"}, {"sha": "a8b0bbd2d7126272661d6800c1487031fba224d1", "filename": "libgfortran/generated/_atan_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_atan_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_atan_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atan_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_ATAN_17\n+\n+elemental function _gfortran_specific__atan_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__atan_r17\n+\n+   _gfortran_specific__atan_r17 = atan (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "dc4d8a306d2eb308cdb46e9e80dae6a5c0d5645c", "filename": "libgfortran/generated/_atanh_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_atanh_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_atanh_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_atanh_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_ATANH_17\n+\n+elemental function _gfortran_specific__atanh_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__atanh_r17\n+\n+   _gfortran_specific__atanh_r17 = atanh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "86a237c644210393f2d338b29f432518926d2875", "filename": "libgfortran/generated/_conjg_c17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_conjg_c17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_conjg_c17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_conjg_c17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+\n+elemental function _gfortran_specific__conjg_17 (parm)\n+   complex (kind=17), intent (in) :: parm\n+   complex (kind=17) :: _gfortran_specific__conjg_17\n+\n+   _gfortran_specific__conjg_17 = conjg (parm)\n+end function\n+\n+\n+#endif"}, {"sha": "8d50ac8f556d0829b3d856cd5702feaf29fc67d3", "filename": "libgfortran/generated/_cos_c17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_cos_c17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_cos_c17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_c17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+#ifdef HAVE_CCOS_17\n+\n+elemental function _gfortran_specific__cos_c17 (parm)\n+   complex (kind=17), intent (in) :: parm\n+   complex (kind=17) :: _gfortran_specific__cos_c17\n+\n+   _gfortran_specific__cos_c17 = cos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "fde038e15b987591a53cae9fffd01044844babd5", "filename": "libgfortran/generated/_cos_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_cos_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_cos_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cos_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_COS_17\n+\n+elemental function _gfortran_specific__cos_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__cos_r17\n+\n+   _gfortran_specific__cos_r17 = cos (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "c8fe7c8dbb6673678d074474ccf54a645b071ab5", "filename": "libgfortran/generated/_cosh_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_cosh_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_cosh_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_cosh_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_COSH_17\n+\n+elemental function _gfortran_specific__cosh_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__cosh_r17\n+\n+   _gfortran_specific__cosh_r17 = cosh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "d4b78c17dc508f1731861e0b806f657b136e66af", "filename": "libgfortran/generated/_dim_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_dim_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_dim_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_dim_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+\n+\n+elemental function _gfortran_specific__dim_r17 (p1, p2)\n+   real (kind=17), intent (in) :: p1, p2\n+   real (kind=17) :: _gfortran_specific__dim_r17\n+\n+   _gfortran_specific__dim_r17 = dim (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "a2672a4ab986316f503dbddae7ecba770cca8013", "filename": "libgfortran/generated/_exp_c17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_exp_c17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_exp_c17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_c17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+#ifdef HAVE_CEXP_17\n+\n+elemental function _gfortran_specific__exp_c17 (parm)\n+   complex (kind=17), intent (in) :: parm\n+   complex (kind=17) :: _gfortran_specific__exp_c17\n+\n+   _gfortran_specific__exp_c17 = exp (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "14cac70375abf58f4d21186e17c079bb2f2f1a83", "filename": "libgfortran/generated/_exp_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_exp_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_exp_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_exp_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_EXP_17\n+\n+elemental function _gfortran_specific__exp_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__exp_r17\n+\n+   _gfortran_specific__exp_r17 = exp (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "ef3481af2730a0fbc6db9df54883cd7fd00d31f5", "filename": "libgfortran/generated/_log10_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_log10_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_log10_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log10_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_LOG10_17\n+\n+elemental function _gfortran_specific__log10_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__log10_r17\n+\n+   _gfortran_specific__log10_r17 = log10 (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "65c758dad4cbb72d3ad62ccd3397c10e06b9cd22", "filename": "libgfortran/generated/_log_c17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_log_c17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_log_c17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_c17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+#ifdef HAVE_CLOG_17\n+\n+elemental function _gfortran_specific__log_c17 (parm)\n+   complex (kind=17), intent (in) :: parm\n+   complex (kind=17) :: _gfortran_specific__log_c17\n+\n+   _gfortran_specific__log_c17 = log (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "95cc9efeebd6b52d41dd43806bc5cd39a95445a0", "filename": "libgfortran/generated/_log_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_log_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_log_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_log_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_LOG_17\n+\n+elemental function _gfortran_specific__log_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__log_r17\n+\n+   _gfortran_specific__log_r17 = log (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "23973950a3b84a9f34390524b10d84ca3600e80d", "filename": "libgfortran/generated/_mod_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_mod_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_mod_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_mod_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+\n+\n+elemental function _gfortran_specific__mod_r17 (p1, p2)\n+   real (kind=17), intent (in) :: p1, p2\n+   real (kind=17) :: _gfortran_specific__mod_r17\n+\n+   _gfortran_specific__mod_r17 = mod (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "d8afb5ec599101f97a260fa3e6d2f8176fa7e24c", "filename": "libgfortran/generated/_sign_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sign_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sign_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sign_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+\n+\n+elemental function _gfortran_specific__sign_r17 (p1, p2)\n+   real (kind=17), intent (in) :: p1, p2\n+   real (kind=17) :: _gfortran_specific__sign_r17\n+\n+   _gfortran_specific__sign_r17 = sign (p1, p2)\n+end function\n+\n+\n+\n+#endif"}, {"sha": "6453ec708388c116edc2adcf89c4e53a0372f33b", "filename": "libgfortran/generated/_sin_c17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sin_c17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sin_c17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_c17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+#ifdef HAVE_CSIN_17\n+\n+elemental function _gfortran_specific__sin_c17 (parm)\n+   complex (kind=17), intent (in) :: parm\n+   complex (kind=17) :: _gfortran_specific__sin_c17\n+\n+   _gfortran_specific__sin_c17 = sin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "8632c4d7a80a26ec619e567c24b266335e027d6f", "filename": "libgfortran/generated/_sin_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sin_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sin_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sin_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_SIN_17\n+\n+elemental function _gfortran_specific__sin_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__sin_r17\n+\n+   _gfortran_specific__sin_r17 = sin (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "bfe0f2a2bf674f82fa5ca319322b8fef352c98ca", "filename": "libgfortran/generated/_sinh_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sinh_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sinh_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sinh_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_SINH_17\n+\n+elemental function _gfortran_specific__sinh_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__sinh_r17\n+\n+   _gfortran_specific__sinh_r17 = sinh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "5878b87c421e2c7d5e6c1a1928616c27a082c878", "filename": "libgfortran/generated/_sqrt_c17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sqrt_c17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sqrt_c17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_c17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+#ifdef HAVE_CSQRT_17\n+\n+elemental function _gfortran_specific__sqrt_c17 (parm)\n+   complex (kind=17), intent (in) :: parm\n+   complex (kind=17) :: _gfortran_specific__sqrt_c17\n+\n+   _gfortran_specific__sqrt_c17 = sqrt (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "01c3a04a6d4ccb49aa88987d1d7e0396e7c5d550", "filename": "libgfortran/generated/_sqrt_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sqrt_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_sqrt_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_sqrt_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_SQRT_17\n+\n+elemental function _gfortran_specific__sqrt_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__sqrt_r17\n+\n+   _gfortran_specific__sqrt_r17 = sqrt (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "01f1bfa921ac7b7a2df3538088aeea3e888badcf", "filename": "libgfortran/generated/_tan_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_tan_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_tan_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tan_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_TAN_17\n+\n+elemental function _gfortran_specific__tan_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__tan_r17\n+\n+   _gfortran_specific__tan_r17 = tan (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "e04aae384992480d32df4465147c35938fec33d0", "filename": "libgfortran/generated/_tanh_r17.F90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_tanh_r17.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2F_tanh_r17.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2F_tanh_r17.F90?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,46 @@\n+!   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+!   Contributed by Paul Brook <paul@nowt.org>\n+!\n+!This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+!\n+!GNU libgfortran is free software; you can redistribute it and/or\n+!modify it under the terms of the GNU General Public\n+!License as published by the Free Software Foundation; either\n+!version 3 of the License, or (at your option) any later version.\n+\n+!GNU libgfortran is distributed in the hope that it will be useful,\n+!but WITHOUT ANY WARRANTY; without even the implied warranty of\n+!MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+!GNU General Public License for more details.\n+!\n+!Under Section 7 of GPL version 3, you are granted additional\n+!permissions described in the GCC Runtime Library Exception, version\n+!3.1, as published by the Free Software Foundation.\n+!\n+!You should have received a copy of the GNU General Public License and\n+!a copy of the GCC Runtime Library Exception along with this program;\n+!see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+!<http://www.gnu.org/licenses/>.\n+!\n+!This file is machine generated.\n+\n+\n+\n+\n+\n+#include \"config.h\"\n+#include \"kinds.inc\"\n+#include \"c99_protos.inc\"\n+\n+#if defined (HAVE_GFC_REAL_17)\n+#ifdef HAVE_TANH_17\n+\n+elemental function _gfortran_specific__tanh_r17 (parm)\n+   real (kind=17), intent (in) :: parm\n+   real (kind=17) :: _gfortran_specific__tanh_r17\n+\n+   _gfortran_specific__tanh_r17 = tanh (parm)\n+end function\n+\n+#endif\n+#endif"}, {"sha": "cca2623e4b2b0c39ba017bfd660e2e40f3316ad3", "filename": "libgfortran/generated/bessel_r17.c", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fbessel_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fbessel_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fbessel_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,186 @@\n+/* Implementation of the BESSEL_JN and BESSEL_YN transformational\n+   function using a recurrence algorithm.\n+   Copyright (C) 2010-2022 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+\n+#if defined(POWER_IEEE128)\n+#define MATHFUNC(funcname) __ ## funcname ## ieee128\n+#else\n+#define MATHFUNC(funcname) funcname ## q\n+#endif\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+\n+\n+#if 1 /* FIXME: figure this out later.  */\n+extern void bessel_jn_r17 (gfc_array_r17 * const restrict ret, int n1,\n+\t\t\t\t     int n2, GFC_REAL_17 x);\n+export_proto(bessel_jn_r17);\n+\n+void\n+bessel_jn_r17 (gfc_array_r17 * const restrict ret, int n1, int n2, GFC_REAL_17 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_17 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->base_addr == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_17));\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  (long int) GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0))\n+    {\n+      ret->base_addr[0] = 1;\n+      for (i = 1; i <= n2-n1; i++)\n+        ret->base_addr[i*stride] = 0;\n+      return;\n+    }\n+\n+  last1 = MATHFUNC(jn) (n2, x);\n+  ret->base_addr[(n2-n1)*stride] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = MATHFUNC(jn) (n2 - 1, x);\n+  ret->base_addr[(n2-n1-1)*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = GFC_REAL_17_LITERAL(2.)/x;\n+\n+  for (i = n2-n1-2; i >= 0; i--)\n+    {\n+      ret->base_addr[i*stride] = x2rev * (i+1+n1) * last2 - last1;\n+      last1 = last2;\n+      last2 = ret->base_addr[i*stride];\n+    }\n+}\n+\n+#endif\n+\n+#if 1 /* FIXME: figure this out later.  */\n+extern void bessel_yn_r17 (gfc_array_r17 * const restrict ret,\n+\t\t\t\t     int n1, int n2, GFC_REAL_17 x);\n+export_proto(bessel_yn_r17);\n+\n+void\n+bessel_yn_r17 (gfc_array_r17 * const restrict ret, int n1, int n2,\n+\t\t\t GFC_REAL_17 x)\n+{\n+  int i;\n+  index_type stride;\n+\n+  GFC_REAL_17 last1, last2, x2rev;\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (ret->base_addr == NULL)\n+    {\n+      size_t size = n2 < n1 ? 0 : n2-n1+1; \n+      GFC_DIMENSION_SET(ret->dim[0], 0, size-1, 1);\n+      ret->base_addr = xmallocarray (size, sizeof (GFC_REAL_17));\n+      ret->offset = 0;\n+    }\n+\n+  if (unlikely (n2 < n1))\n+    return;\n+\n+  if (unlikely (compile_options.bounds_check)\n+      && GFC_DESCRIPTOR_EXTENT(ret,0) != (n2-n1+1))\n+    runtime_error(\"Incorrect extent in return value of BESSEL_JN \"\n+\t\t  \"(%ld vs. %ld)\", (long int) n2-n1,\n+\t\t  (long int) GFC_DESCRIPTOR_EXTENT(ret,0));\n+\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  if (unlikely (x == 0))\n+    {\n+      for (i = 0; i <= n2-n1; i++)\n+#if defined(GFC_REAL_17_INFINITY)\n+        ret->base_addr[i*stride] = -GFC_REAL_17_INFINITY;\n+#else\n+        ret->base_addr[i*stride] = -GFC_REAL_17_HUGE;\n+#endif\n+      return;\n+    }\n+\n+  last1 = MATHFUNC(yn) (n1, x);\n+  ret->base_addr[0] = last1;\n+\n+  if (n1 == n2)\n+    return;\n+\n+  last2 = MATHFUNC(yn) (n1 + 1, x);\n+  ret->base_addr[1*stride] = last2;\n+\n+  if (n1 + 1 == n2)\n+    return;\n+\n+  x2rev = GFC_REAL_17_LITERAL(2.)/x;\n+\n+  for (i = 2; i <= n2 - n1; i++)\n+    {\n+#if defined(GFC_REAL_17_INFINITY)\n+      if (unlikely (last2 == -GFC_REAL_17_INFINITY))\n+\t{\n+\t  ret->base_addr[i*stride] = -GFC_REAL_17_INFINITY;\n+\t}\n+      else\n+#endif\n+\t{\n+\t  ret->base_addr[i*stride] = x2rev * (i-1+n1) * last2 - last1;\n+\t  last1 = last2;\n+\t  last2 = ret->base_addr[i*stride];\n+\t}\n+    }\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "73de471cac05b556704ce9427101e8d3fe3acf3a", "filename": "libgfortran/generated/cshift0_c17.c", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift0_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift0_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,242 @@\n+/* Helper function for cshift functions.\n+   Copyright (C) 2008-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+void\n+cshift0_c17 (gfc_array_c17 *ret, const gfc_array_c17 *array, ptrdiff_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_17 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_17 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n+    {\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+    }\n+\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+\n+  /* Avoid the costly modulo for trivially in-bound shifts.  */\n+  if (shift < 0 || shift >= len)\n+    {\n+      shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n+      if (shift < 0)\n+\tshift += len;\n+    }\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_COMPLEX_17);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_COMPLEX_17);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_COMPLEX_17 *dest = rptr;\n+\t  const GFC_COMPLEX_17 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "670f2b7b3a0d9d4c9be3ce47dea61a88fbc23614", "filename": "libgfortran/generated/cshift0_r17.c", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift0_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift0_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,242 @@\n+/* Helper function for cshift functions.\n+   Copyright (C) 2008-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+void\n+cshift0_r17 (gfc_array_r17 *ret, const gfc_array_r17 *array, ptrdiff_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_17 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_17 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  bool do_blocked;\n+  index_type r_ex, a_ex;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  r_ex = 1;\n+  a_ex = 1;\n+\n+  if (which > 0)\n+    {\n+      /* Test if both ret and array are contiguous.  */\n+      do_blocked = true;\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+      for (n = 0; n < dim; n ++)\n+\t{\n+\t  index_type rs, as;\n+\t  rs = GFC_DESCRIPTOR_STRIDE (ret, n);\n+\t  if (rs != r_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  as = GFC_DESCRIPTOR_STRIDE (array, n);\n+\t  if (as != a_ex)\n+\t    {\n+\t      do_blocked = false;\n+\t      break;\n+\t    }\n+\t  r_ex *= GFC_DESCRIPTOR_EXTENT (ret, n);\n+\t  a_ex *= GFC_DESCRIPTOR_EXTENT (array, n);\n+\t}\n+    }\n+  else\n+    do_blocked = false;\n+\n+  n = 0;\n+\n+  if (do_blocked)\n+    {\n+      /* For contiguous arrays, use the relationship that\n+\n+         dimension(n1,n2,n3) :: a, b\n+\t b = cshift(a,sh,3)\n+\n+         can be dealt with as if\n+\n+\t dimension(n1*n2*n3) :: an, bn\n+\t bn = cshift(a,sh*n1*n2,1)\n+\n+\t we can used a more blocked algorithm for dim>1.  */\n+      sstride[0] = 1;\n+      rstride[0] = 1;\n+      roffset = 1;\n+      soffset = 1;\n+      len = GFC_DESCRIPTOR_STRIDE(array, which)\n+\t* GFC_DESCRIPTOR_EXTENT(array, which);      \n+      shift *= GFC_DESCRIPTOR_STRIDE(array, which);\n+      for (dim = which + 1; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  count[n] = 0;\n+\t  extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t  rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t  sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t  n++;\n+\t}\n+      dim = GFC_DESCRIPTOR_RANK (array) - which;\n+    }\n+  else\n+    {\n+      for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+\t{\n+\t  if (dim == which)\n+\t    {\n+\t      roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      if (roffset == 0)\n+\t\troffset = 1;\n+\t      soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      if (soffset == 0)\n+\t\tsoffset = 1;\n+\t      len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n] = 0;\n+\t      extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+\t      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+\t      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\t      n++;\n+\t    }\n+\t}\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+      if (rstride[0] == 0)\n+\trstride[0] = 1;\n+\n+      dim = GFC_DESCRIPTOR_RANK (array);\n+    }\n+\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+\n+  /* Avoid the costly modulo for trivially in-bound shifts.  */\n+  if (shift < 0 || shift >= len)\n+    {\n+      shift = len == 0 ? 0 : shift % (ptrdiff_t)len;\n+      if (shift < 0)\n+\tshift += len;\n+    }\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_REAL_17);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_REAL_17);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_REAL_17 *dest = rptr;\n+\t  const GFC_REAL_17 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "d646f6d0e7d9f91ebced270f4c2018ad1c496430", "filename": "libgfortran/generated/cshift1_16_c17.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_16_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_16_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_17) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_c17 (gfc_array_c17 * const restrict ret,\n+\t\tconst gfc_array_c17 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_17 *rptr;\n+  GFC_COMPLEX_17 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_17 *sptr;\n+  const GFC_COMPLEX_17 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_17);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_17);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "fe3fa273bc937616758da2a9cf09e0772245c394", "filename": "libgfortran/generated/cshift1_16_r17.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_16_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_16_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift1_16_r17 (gfc_array_r17 * const restrict ret,\n+\t\tconst gfc_array_r17 * const restrict array,\n+\t\tconst gfc_array_i16 * const restrict h,\n+\t\tconst GFC_INTEGER_16 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_17 *rptr;\n+  GFC_REAL_17 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_17 *sptr;\n+  const GFC_REAL_17 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_16 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_16 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_17);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_17);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "c01f02dc1da4cefc7bd576a0680f4112a59ef1e3", "filename": "libgfortran/generated/cshift1_4_c17.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_4_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_4_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_17) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_c17 (gfc_array_c17 * const restrict ret,\n+\t\tconst gfc_array_c17 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_17 *rptr;\n+  GFC_COMPLEX_17 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_17 *sptr;\n+  const GFC_COMPLEX_17 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_17);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_17);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "7262627f97a602472f13deb4754d84aa6eeb1f8d", "filename": "libgfortran/generated/cshift1_4_r17.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_4_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_4_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift1_4_r17 (gfc_array_r17 * const restrict ret,\n+\t\tconst gfc_array_r17 * const restrict array,\n+\t\tconst gfc_array_i4 * const restrict h,\n+\t\tconst GFC_INTEGER_4 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_17 *rptr;\n+  GFC_REAL_17 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_17 *sptr;\n+  const GFC_REAL_17 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_4 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_4 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_17);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_17);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "85610a5f0fb96afceed4101366ef2a6bcee697d0", "filename": "libgfortran/generated/cshift1_8_c17.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_8_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_8_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_17) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_c17 (gfc_array_c17 * const restrict ret,\n+\t\tconst gfc_array_c17 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_17 *rptr;\n+  GFC_COMPLEX_17 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_17 *sptr;\n+  const GFC_COMPLEX_17 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_COMPLEX_17);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_COMPLEX_17);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "cc58d3cb7f04d53db1ff61348c5cadcd75f653bb", "filename": "libgfortran/generated/cshift1_8_r17.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_8_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fcshift1_8_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,193 @@\n+/* Implementation of the CSHIFT intrinsic.\n+   Copyright (C) 2017-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift1_8_r17 (gfc_array_r17 * const restrict ret,\n+\t\tconst gfc_array_r17 * const restrict array,\n+\t\tconst gfc_array_i8 * const restrict h,\n+\t\tconst GFC_INTEGER_8 * const restrict pwhich)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_17 *rptr;\n+  GFC_REAL_17 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_17 *sptr;\n+  const GFC_REAL_17 *src;\n+  /* h.* indicates the shift array.  */\n+  index_type hstride[GFC_MAX_DIMENSIONS];\n+  index_type hstride0;\n+  const GFC_INTEGER_8 *hptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type rs_ex[GFC_MAX_DIMENSIONS];\n+  index_type ss_ex[GFC_MAX_DIMENSIONS];\n+  index_type hs_ex[GFC_MAX_DIMENSIONS];\n+\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+  int which;\n+  GFC_INTEGER_8 sh;\n+\n+  /* Bounds checking etc is already done by the caller.  */\n+\n+  if (pwhich)\n+    which = *pwhich - 1;\n+  else\n+    which = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = GFC_DESCRIPTOR_EXTENT(array,dim);\n+          rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+          sstride[n] = GFC_DESCRIPTOR_STRIDE(array,dim);\n+          hstride[n] = GFC_DESCRIPTOR_STRIDE(h,n);\n+\t  rs_ex[n] = rstride[n] * extent[n];\n+\t  ss_ex[n] = sstride[n] * extent[n];\n+\t  hs_ex[n] = hstride[n] * extent[n];\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+  if (hstride[0] == 0)\n+    hstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  hstride0 = hstride[0];\n+  rptr = ret->base_addr;\n+  sptr = array->base_addr;\n+  hptr = h->base_addr;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+      sh = *hptr;\n+      /* Normal case should be -len < sh < len; try to\n+         avoid the expensive remainder operation if possible.  */\n+      if (sh < 0)\n+        sh += len;\n+      if (unlikely(sh >= len || sh < 0))\n+\t{\n+ \t  sh = sh % len;\n+\t  if (sh < 0)\n+            sh += len;\n+\t}\n+      src = &sptr[sh * soffset];\n+      dest = rptr;\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = sh * sizeof (GFC_REAL_17);\n+\t  size_t len2 = (len - sh) * sizeof (GFC_REAL_17);\n+\t  memcpy (rptr, sptr + sh, len2);\n+\t  memcpy (rptr + (len - sh), sptr, len1);\n+\t}\n+      else\n+        {\n+\t  for (n = 0; n < len - sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < sh; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      hptr += hstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          rptr -= rs_ex[n];\n+          sptr -= ss_ex[n];\n+\t  hptr -= hs_ex[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+\t      hptr += hstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "2d8d25715eda93ba5538a41dc70ee639ebc0bfc9", "filename": "libgfortran/generated/findloc0_c17.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Ffindloc0_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Ffindloc0_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+extern void findloc0_c17 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_c17);\n+\n+void\n+findloc0_c17 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_17 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_c17 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_c17);\n+\n+void\n+mfindloc0_c17 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_17 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_c17 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_c17);\n+\n+void\n+sfindloc0_c17 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      findloc0_c17 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "cdac81db142a68e56a9b990c9ee7d9bfff04a05e", "filename": "libgfortran/generated/findloc0_r17.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Ffindloc0_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Ffindloc0_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_17)\n+extern void findloc0_r17 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_r17);\n+\n+void\n+findloc0_r17 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_17 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_r17 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_r17);\n+\n+void\n+mfindloc0_r17 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_17 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_r17 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_r17);\n+\n+void\n+sfindloc0_r17 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      findloc0_r17 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "3021eb41754e5303b2e066b570a6bbb2def62bcd", "filename": "libgfortran/generated/findloc1_c17.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Ffindloc1_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Ffindloc1_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+extern void findloc1_c17 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_c17);\n+\n+extern void\n+findloc1_c17 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_17 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_17 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_c17 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_c17);\n+\n+extern void\n+mfindloc1_c17 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_c17 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_c17);\n+\n+extern void\n+sfindloc1_c17 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c17 * const restrict array, GFC_COMPLEX_17 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      findloc1_c17 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "e32fd6947d731e21949a923626844b425d4e030a", "filename": "libgfortran/generated/findloc1_r17.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Ffindloc1_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Ffindloc1_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_17)\n+extern void findloc1_r17 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_r17);\n+\n+extern void\n+findloc1_r17 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_r17 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_r17);\n+\n+extern void\n+mfindloc1_r17 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_r17 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_r17);\n+\n+extern void\n+sfindloc1_r17 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r17 * const restrict array, GFC_REAL_17 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      findloc1_r17 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "fcc655212d0cbb6dbbb7cec8f9ed84c6e7a4ddf8", "filename": "libgfortran/generated/in_pack_c17.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fin_pack_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fin_pack_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,116 @@\n+/* Helper function for repacking arrays.\n+   Copyright (C) 2003-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_COMPLEX_17 *\n+internal_pack_c17 (gfc_array_c17 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_COMPLEX_17 *src;\n+  GFC_COMPLEX_17 * restrict dest;\n+  GFC_COMPLEX_17 *destptr;\n+  int packed;\n+\n+  /* TODO: Investigate how we can figure out if this is a temporary\n+     since the stride=0 thing has been removed from the frontend.  */\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (index_type n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->base_addr;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = xmallocarray (ssize, sizeof (GFC_COMPLEX_17));\n+  dest = destptr;\n+  src = source->base_addr;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      index_type n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif\n+"}, {"sha": "759094c5e465a743720a1feb55ca2d5985c30874", "filename": "libgfortran/generated/in_pack_r17.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fin_pack_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fin_pack_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_pack_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,116 @@\n+/* Helper function for repacking arrays.\n+   Copyright (C) 2003-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+/* Allocates a block of memory with internal_malloc if the array needs\n+   repacking.  */\n+\n+GFC_REAL_17 *\n+internal_pack_r17 (gfc_array_r17 * source)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type ssize;\n+  const GFC_REAL_17 *src;\n+  GFC_REAL_17 * restrict dest;\n+  GFC_REAL_17 *destptr;\n+  int packed;\n+\n+  /* TODO: Investigate how we can figure out if this is a temporary\n+     since the stride=0 thing has been removed from the frontend.  */\n+\n+  dim = GFC_DESCRIPTOR_RANK (source);\n+  ssize = 1;\n+  packed = 1;\n+  for (index_type n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n+      if (extent[n] <= 0)\n+        {\n+          /* Do nothing.  */\n+          packed = 1;\n+          break;\n+        }\n+\n+      if (ssize != stride[n])\n+        packed = 0;\n+\n+      ssize *= extent[n];\n+    }\n+\n+  if (packed)\n+    return source->base_addr;\n+\n+  /* Allocate storage for the destination.  */\n+  destptr = xmallocarray (ssize, sizeof (GFC_REAL_17));\n+  dest = destptr;\n+  src = source->base_addr;\n+  stride0 = stride[0];\n+\n+\n+  while (src)\n+    {\n+      /* Copy the data.  */\n+      *(dest++) = *src;\n+      /* Advance to the next element.  */\n+      src += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      index_type n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              src = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              src += stride[n];\n+            }\n+        }\n+    }\n+  return destptr;\n+}\n+\n+#endif\n+"}, {"sha": "9d74b3060afc527f6fc981f1d6d7658405d1680a", "filename": "libgfortran/generated/in_unpack_c17.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fin_unpack_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fin_unpack_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,104 @@\n+/* Helper function for repacking arrays.\n+   Copyright (C) 2003-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+void\n+internal_unpack_c17 (gfc_array_c17 * d, const GFC_COMPLEX_17 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_COMPLEX_17 * restrict dest;\n+\n+  dest = d->base_addr;\n+  if (src == dest || !src)\n+    return;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (index_type n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+\n+      if (dsize == stride[n])\n+\tdsize *= extent[n];\n+      else\n+\tdsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_COMPLEX_17));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      index_type n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "574215183c8ba4a9cfd96158710308d4af088237", "filename": "libgfortran/generated/in_unpack_r17.c", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fin_unpack_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fin_unpack_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fin_unpack_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,104 @@\n+/* Helper function for repacking arrays.\n+   Copyright (C) 2003-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+void\n+internal_unpack_r17 (gfc_array_r17 * d, const GFC_REAL_17 * src)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type stride[GFC_MAX_DIMENSIONS];\n+  index_type stride0;\n+  index_type dim;\n+  index_type dsize;\n+  GFC_REAL_17 * restrict dest;\n+\n+  dest = d->base_addr;\n+  if (src == dest || !src)\n+    return;\n+\n+  dim = GFC_DESCRIPTOR_RANK (d);\n+  dsize = 1;\n+  for (index_type n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      stride[n] = GFC_DESCRIPTOR_STRIDE(d,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(d,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+\n+      if (dsize == stride[n])\n+\tdsize *= extent[n];\n+      else\n+\tdsize = 0;\n+    }\n+\n+  if (dsize != 0)\n+    {\n+      memcpy (dest, src, dsize * sizeof (GFC_REAL_17));\n+      return;\n+    }\n+\n+  stride0 = stride[0];\n+\n+  while (dest)\n+    {\n+      /* Copy the data.  */\n+      *dest = *(src++);\n+      /* Advance to the next element.  */\n+      dest += stride0;\n+      count[0]++;\n+      /* Advance to the next source element.  */\n+      index_type n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          dest -= stride[n] * extent[n];\n+          n++;\n+          if (n == dim)\n+            {\n+              dest = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              dest += stride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "a1a7d42f2e3e2966ce89f1056616173edde7cfda", "filename": "libgfortran/generated/matmul_c17.c", "status": "added", "additions": 3013, "deletions": 0, "changes": 3013, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmatmul_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmatmul_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "db7f05b524a6778e81320789767ac6484758f0d4", "filename": "libgfortran/generated/matmul_r17.c", "status": "added", "additions": 3013, "deletions": 0, "changes": 3013, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmatmul_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmatmul_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "79cfe5b4b2dc204a9e61a75523cf11b25b37053c", "filename": "libgfortran/generated/matmulavx128_c17.c", "status": "added", "additions": 1186, "deletions": 0, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmatmulavx128_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmatmulavx128_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,1186 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_COMPLEX_17 *, const GFC_COMPLEX_17 *,\n+                          const int *, const GFC_COMPLEX_17 *, const int *,\n+                          const GFC_COMPLEX_17 *, GFC_COMPLEX_17 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_c17_avx128_fma3 (gfc_array_c17 * const restrict retarray, \n+\tgfc_array_c17 * const restrict a, gfc_array_c17 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_c17_avx128_fma3);\n+void\n+matmul_c17_avx128_fma3 (gfc_array_c17 * const restrict retarray, \n+\tgfc_array_c17 * const restrict a, gfc_array_c17 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_17 * restrict abase;\n+  const GFC_COMPLEX_17 * restrict bbase;\n+  GFC_COMPLEX_17 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_17));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 2 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"Incorrect extent in argument B in MATMUL intrinsic \"\n+\t\t       \"in dimension 1: is %ld, should be %ld\",\n+\t\t       (long int) GFC_DESCRIPTOR_EXTENT(b,0), (long int) count);\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_17 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  const char *transa, *transb;\n+\t  if (try_blas & 2)\n+\t    transa = \"C\";\n+\t  else\n+\t    transa = axstride == 1 ? \"N\" : \"T\";\n+\n+\t  if (try_blas & 4)\n+\t    transb = \"C\";\n+\t  else\n+\t    transb = bxstride == 1 ? \"N\" : \"T\";\n+\n+\t  gemm (transa, transb , &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1\n+      && GFC_DESCRIPTOR_RANK (b) != 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_17 *a, *b;\n+      GFC_COMPLEX_17 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_17 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_17 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_17)0;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim, a_sz;\n+      if (aystride == 1)\n+        a_sz = rystride;\n+      else\n+        a_sz = a_dim1;\n+\n+      t1_dim = a_sz * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_17));\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_17 *restrict abase_x;\n+\t  const GFC_COMPLEX_17 *restrict bbase_y;\n+\t  GFC_COMPLEX_17 *restrict dest_y;\n+\t  GFC_COMPLEX_17 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_17) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_17 *restrict bbase_y;\n+\t  GFC_COMPLEX_17 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_17) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_17 *restrict bbase_y;\n+      GFC_COMPLEX_17 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_17) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_17)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_17 *restrict abase_x;\n+      const GFC_COMPLEX_17 *restrict bbase_y;\n+      GFC_COMPLEX_17 *restrict dest_y;\n+      GFC_COMPLEX_17 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_17) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_c17_avx128_fma4 (gfc_array_c17 * const restrict retarray, \n+\tgfc_array_c17 * const restrict a, gfc_array_c17 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_c17_avx128_fma4);\n+void\n+matmul_c17_avx128_fma4 (gfc_array_c17 * const restrict retarray, \n+\tgfc_array_c17 * const restrict a, gfc_array_c17 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_COMPLEX_17 * restrict abase;\n+  const GFC_COMPLEX_17 * restrict bbase;\n+  GFC_COMPLEX_17 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_17));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 2 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"Incorrect extent in argument B in MATMUL intrinsic \"\n+\t\t       \"in dimension 1: is %ld, should be %ld\",\n+\t\t       (long int) GFC_DESCRIPTOR_EXTENT(b,0), (long int) count);\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_17 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  const char *transa, *transb;\n+\t  if (try_blas & 2)\n+\t    transa = \"C\";\n+\t  else\n+\t    transa = axstride == 1 ? \"N\" : \"T\";\n+\n+\t  if (try_blas & 4)\n+\t    transb = \"C\";\n+\t  else\n+\t    transb = bxstride == 1 ? \"N\" : \"T\";\n+\n+\t  gemm (transa, transb , &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1\n+      && GFC_DESCRIPTOR_RANK (b) != 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_17 *a, *b;\n+      GFC_COMPLEX_17 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_17 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_COMPLEX_17 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_17)0;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim, a_sz;\n+      if (aystride == 1)\n+        a_sz = rystride;\n+      else\n+        a_sz = a_dim1;\n+\n+      t1_dim = a_sz * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_COMPLEX_17));\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_COMPLEX_17 *restrict abase_x;\n+\t  const GFC_COMPLEX_17 *restrict bbase_y;\n+\t  GFC_COMPLEX_17 *restrict dest_y;\n+\t  GFC_COMPLEX_17 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_COMPLEX_17) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_COMPLEX_17 *restrict bbase_y;\n+\t  GFC_COMPLEX_17 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_COMPLEX_17) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_COMPLEX_17 *restrict bbase_y;\n+      GFC_COMPLEX_17 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_COMPLEX_17) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_COMPLEX_17)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else\n+    {\n+      const GFC_COMPLEX_17 *restrict abase_x;\n+      const GFC_COMPLEX_17 *restrict bbase_y;\n+      GFC_COMPLEX_17 *restrict dest_y;\n+      GFC_COMPLEX_17 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_COMPLEX_17) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "a3a04806a5cd9e7a8faab5756d4127b3eaa7a94b", "filename": "libgfortran/generated/matmulavx128_r17.c", "status": "added", "additions": 1186, "deletions": 0, "changes": 1186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmatmulavx128_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmatmulavx128_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmulavx128_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,1186 @@\n+/* Implementation of the MATMUL intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>.\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+#include <assert.h>\n+\n+\n+/* These are the specific versions of matmul with -mprefer-avx128.  */\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+/* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n+   passed to us by the front-end, in which case we call it for large\n+   matrices.  */\n+\n+typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n+                          const int *, const GFC_REAL_17 *, const GFC_REAL_17 *,\n+                          const int *, const GFC_REAL_17 *, const int *,\n+                          const GFC_REAL_17 *, GFC_REAL_17 *, const int *,\n+                          int, int);\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA3) && defined(HAVE_AVX128)\n+void\n+matmul_r17_avx128_fma3 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict a, gfc_array_r17 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma\")));\n+internal_proto(matmul_r17_avx128_fma3);\n+void\n+matmul_r17_avx128_fma3 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict a, gfc_array_r17 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_17 * restrict abase;\n+  const GFC_REAL_17 * restrict bbase;\n+  GFC_REAL_17 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_17));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 2 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"Incorrect extent in argument B in MATMUL intrinsic \"\n+\t\t       \"in dimension 1: is %ld, should be %ld\",\n+\t\t       (long int) GFC_DESCRIPTOR_EXTENT(b,0), (long int) count);\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_17 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  const char *transa, *transb;\n+\t  if (try_blas & 2)\n+\t    transa = \"C\";\n+\t  else\n+\t    transa = axstride == 1 ? \"N\" : \"T\";\n+\n+\t  if (try_blas & 4)\n+\t    transb = \"C\";\n+\t  else\n+\t    transb = bxstride == 1 ? \"N\" : \"T\";\n+\n+\t  gemm (transa, transb , &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1\n+      && GFC_DESCRIPTOR_RANK (b) != 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_17 *a, *b;\n+      GFC_REAL_17 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_17 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_17 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_17)0;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim, a_sz;\n+      if (aystride == 1)\n+        a_sz = rystride;\n+      else\n+        a_sz = a_dim1;\n+\n+      t1_dim = a_sz * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_17));\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_17 *restrict abase_x;\n+\t  const GFC_REAL_17 *restrict bbase_y;\n+\t  GFC_REAL_17 *restrict dest_y;\n+\t  GFC_REAL_17 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_17) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_17 *restrict bbase_y;\n+\t  GFC_REAL_17 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_17) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_17 *restrict bbase_y;\n+      GFC_REAL_17 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_17) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_17)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else\n+    {\n+      const GFC_REAL_17 *restrict abase_x;\n+      const GFC_REAL_17 *restrict bbase_y;\n+      GFC_REAL_17 *restrict dest_y;\n+      GFC_REAL_17 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_17) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#if defined(HAVE_AVX) && defined(HAVE_FMA4) && defined(HAVE_AVX128)\n+void\n+matmul_r17_avx128_fma4 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict a, gfc_array_r17 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm) __attribute__((__target__(\"avx,fma4\")));\n+internal_proto(matmul_r17_avx128_fma4);\n+void\n+matmul_r17_avx128_fma4 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict a, gfc_array_r17 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm)\n+{\n+  const GFC_REAL_17 * restrict abase;\n+  const GFC_REAL_17 * restrict bbase;\n+  GFC_REAL_17 * restrict dest;\n+\n+  index_type rxstride, rystride, axstride, aystride, bxstride, bystride;\n+  index_type x, y, n, count, xcount, ycount;\n+\n+  assert (GFC_DESCRIPTOR_RANK (a) == 2\n+          || GFC_DESCRIPTOR_RANK (b) == 2);\n+\n+/* C[xcount,ycount] = A[xcount, count] * B[count,ycount]\n+\n+   Either A or B (but not both) can be rank 1:\n+\n+   o One-dimensional argument A is implicitly treated as a row matrix\n+     dimensioned [1,count], so xcount=1.\n+\n+   o One-dimensional argument B is implicitly treated as a column matrix\n+     dimensioned [count, 1], so ycount=1.\n+*/\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1, 1);\n+        }\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+        }\n+      else\n+        {\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(a,0) - 1, 1);\n+\n+          GFC_DIMENSION_SET(retarray->dim[1], 0,\n+\t                    GFC_DESCRIPTOR_EXTENT(b,1) - 1,\n+\t\t\t    GFC_DESCRIPTOR_EXTENT(retarray,0));\n+        }\n+\n+      retarray->base_addr\n+\t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_17));\n+      retarray->offset = 0;\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 1 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Array bound mismatch for dimension 2 of \"\n+\t    \t\t   \"array (%ld/%ld) \",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n+    {\n+      /* One-dimensional result may be addressed in the code below\n+\t either as a row or a column matrix. We want both cases to\n+\t work. */\n+      rxstride = rystride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+    }\n+  else\n+    {\n+      rxstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+      rystride = GFC_DESCRIPTOR_STRIDE(retarray,1);\n+    }\n+\n+\n+  if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      /* Treat it as a a row matrix A[1,count]. */\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = 1;\n+\n+      xcount = 1;\n+      count = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+  else\n+    {\n+      axstride = GFC_DESCRIPTOR_STRIDE(a,0);\n+      aystride = GFC_DESCRIPTOR_STRIDE(a,1);\n+\n+      count = GFC_DESCRIPTOR_EXTENT(a,1);\n+      xcount = GFC_DESCRIPTOR_EXTENT(a,0);\n+    }\n+\n+  if (count != GFC_DESCRIPTOR_EXTENT(b,0))\n+    {\n+      if (count > 0 || GFC_DESCRIPTOR_EXTENT(b,0) > 0)\n+\truntime_error (\"Incorrect extent in argument B in MATMUL intrinsic \"\n+\t\t       \"in dimension 1: is %ld, should be %ld\",\n+\t\t       (long int) GFC_DESCRIPTOR_EXTENT(b,0), (long int) count);\n+    }\n+\n+  if (GFC_DESCRIPTOR_RANK (b) == 1)\n+    {\n+      /* Treat it as a column matrix B[count,1] */\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+\n+      /* bystride should never be used for 1-dimensional b.\n+         The value is only used for calculation of the\n+         memory by the buffer.  */\n+      bystride = 256;\n+      ycount = 1;\n+    }\n+  else\n+    {\n+      bxstride = GFC_DESCRIPTOR_STRIDE(b,0);\n+      bystride = GFC_DESCRIPTOR_STRIDE(b,1);\n+      ycount = GFC_DESCRIPTOR_EXTENT(b,1);\n+    }\n+\n+  abase = a->base_addr;\n+  bbase = b->base_addr;\n+  dest = retarray->base_addr;\n+\n+  /* Now that everything is set up, we perform the multiplication\n+     itself.  */\n+\n+#define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n+\n+  if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n+      && (bxstride == 1 || bystride == 1)\n+      && (((float) xcount) * ((float) ycount) * ((float) count)\n+          > POW3(blas_limit)))\n+    {\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_17 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n+\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n+\t{\n+\t  assert (gemm != NULL);\n+\t  const char *transa, *transb;\n+\t  if (try_blas & 2)\n+\t    transa = \"C\";\n+\t  else\n+\t    transa = axstride == 1 ? \"N\" : \"T\";\n+\n+\t  if (try_blas & 4)\n+\t    transb = \"C\";\n+\t  else\n+\t    transb = bxstride == 1 ? \"N\" : \"T\";\n+\n+\t  gemm (transa, transb , &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n+\t}\n+    }\n+\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1\n+      && GFC_DESCRIPTOR_RANK (b) != 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_17 *a, *b;\n+      GFC_REAL_17 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_17 f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+      GFC_REAL_17 *t1;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_17)0;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Adjust size of t1 to what is needed.  */\n+      index_type t1_dim, a_sz;\n+      if (aystride == 1)\n+        a_sz = rystride;\n+      else\n+        a_sz = a_dim1;\n+\n+      t1_dim = a_sz * 256 + b_dim1;\n+      if (t1_dim > 65536)\n+\tt1_dim = 65536;\n+\n+      t1 = malloc (t1_dim * sizeof(GFC_REAL_17));\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n+\t{\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n+\t    {\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n+\t\t{\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      free(t1);\n+      return;\n+    }\n+  else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n+    {\n+      if (GFC_DESCRIPTOR_RANK (a) != 1)\n+\t{\n+\t  const GFC_REAL_17 *restrict abase_x;\n+\t  const GFC_REAL_17 *restrict bbase_y;\n+\t  GFC_REAL_17 *restrict dest_y;\n+\t  GFC_REAL_17 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      dest_y = &dest[y*rystride];\n+\t      for (x = 0; x < xcount; x++)\n+\t\t{\n+\t\t  abase_x = &abase[x*axstride];\n+\t\t  s = (GFC_REAL_17) 0;\n+\t\t  for (n = 0; n < count; n++)\n+\t\t    s += abase_x[n] * bbase_y[n];\n+\t\t  dest_y[x] = s;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  const GFC_REAL_17 *restrict bbase_y;\n+\t  GFC_REAL_17 s;\n+\n+\t  for (y = 0; y < ycount; y++)\n+\t    {\n+\t      bbase_y = &bbase[y*bystride];\n+\t      s = (GFC_REAL_17) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase[n*axstride] * bbase_y[n];\n+\t      dest[y*rystride] = s;\n+\t    }\n+\t}\n+    }\n+  else if (GFC_DESCRIPTOR_RANK (a) == 1)\n+    {\n+      const GFC_REAL_17 *restrict bbase_y;\n+      GFC_REAL_17 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  s = (GFC_REAL_17) 0;\n+\t  for (n = 0; n < count; n++)\n+\t    s += abase[n*axstride] * bbase_y[n*bxstride];\n+\t  dest[y*rxstride] = s;\n+\t}\n+    }\n+  else if (axstride < aystride)\n+    {\n+      for (y = 0; y < ycount; y++)\n+\tfor (x = 0; x < xcount; x++)\n+\t  dest[x*rxstride + y*rystride] = (GFC_REAL_17)0;\n+\n+      for (y = 0; y < ycount; y++)\n+\tfor (n = 0; n < count; n++)\n+\t  for (x = 0; x < xcount; x++)\n+\t    /* dest[x,y] += a[x,n] * b[n,y] */\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n+    }\n+  else\n+    {\n+      const GFC_REAL_17 *restrict abase_x;\n+      const GFC_REAL_17 *restrict bbase_y;\n+      GFC_REAL_17 *restrict dest_y;\n+      GFC_REAL_17 s;\n+\n+      for (y = 0; y < ycount; y++)\n+\t{\n+\t  bbase_y = &bbase[y*bystride];\n+\t  dest_y = &dest[y*rystride];\n+\t  for (x = 0; x < xcount; x++)\n+\t    {\n+\t      abase_x = &abase[x*axstride];\n+\t      s = (GFC_REAL_17) 0;\n+\t      for (n = 0; n < count; n++)\n+\t\ts += abase_x[n*aystride] * bbase_y[n*bxstride];\n+\t      dest_y[x*rxstride] = s;\n+\t    }\n+\t}\n+    }\n+}\n+#undef POW3\n+#undef min\n+#undef max\n+\n+#endif\n+\n+#endif\n+"}, {"sha": "0bd627c5303a722c9906215b9b81b74206bc357a", "filename": "libgfortran/generated/maxloc0_16_r17.c", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc0_16_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc0_16_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_16_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,408 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void maxloc0_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4);\n+export_proto(maxloc0_16_r17);\n+\n+void\n+maxloc0_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_17 *base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+    GFC_REAL_17 maxval;\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+    int fast = 0;\n+#endif\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    maxval = -GFC_REAL_17_INFINITY;\n+#else\n+    maxval = -GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+#endif\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void mmaxloc0_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n+export_proto(mmaxloc0_16_r17);\n+\n+void\n+mmaxloc0_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_REAL_17 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+\n+  if (mask == NULL)\n+    {\n+      maxloc0_16_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_REAL_17 maxval;\n+   int fast = 0;\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    maxval = -GFC_REAL_17_INFINITY;\n+#else\n+    maxval = -GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+        if (back)\n+\t  do\n+\t    {\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(smaxloc0_16_r17);\n+\n+void\n+smaxloc0_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      maxloc0_16_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "cff16c77ce3120ad10348b936e9fd204067cd25b", "filename": "libgfortran/generated/maxloc0_4_r17.c", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc0_4_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc0_4_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_4_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,408 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void maxloc0_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4);\n+export_proto(maxloc0_4_r17);\n+\n+void\n+maxloc0_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_17 *base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+    GFC_REAL_17 maxval;\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+    int fast = 0;\n+#endif\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    maxval = -GFC_REAL_17_INFINITY;\n+#else\n+    maxval = -GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+#endif\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void mmaxloc0_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n+export_proto(mmaxloc0_4_r17);\n+\n+void\n+mmaxloc0_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_REAL_17 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+\n+  if (mask == NULL)\n+    {\n+      maxloc0_4_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_REAL_17 maxval;\n+   int fast = 0;\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    maxval = -GFC_REAL_17_INFINITY;\n+#else\n+    maxval = -GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+        if (back)\n+\t  do\n+\t    {\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(smaxloc0_4_r17);\n+\n+void\n+smaxloc0_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      maxloc0_4_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "910ac655438e845731728ea7356416c3348fddb6", "filename": "libgfortran/generated/maxloc0_8_r17.c", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc0_8_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc0_8_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc0_8_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,408 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void maxloc0_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4);\n+export_proto(maxloc0_8_r17);\n+\n+void\n+maxloc0_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_17 *base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+    GFC_REAL_17 maxval;\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+    int fast = 0;\n+#endif\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    maxval = -GFC_REAL_17_INFINITY;\n+#else\n+    maxval = -GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base >= maxval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+#endif\n+        if (back)\n+      \t  do\n+            {\n+\t      if (unlikely (*base >= maxval))\n+\t       {\n+\t         maxval = *base;\n+\t      \t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t     base += sstride[0];\n+\t   }\n+         while (++count[0] != extent[0]);\n+       else\n+         do\n+\t   {\n+\t     if (unlikely (*base > maxval))\n+\t       {\n+\t         maxval = *base;\n+\t\t for (n = 0; n < rank; n++)\n+\t\t   dest[n * dstride] = count[n] + 1;\n+\t       }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void mmaxloc0_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n+export_proto(mmaxloc0_8_r17);\n+\n+void\n+mmaxloc0_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_REAL_17 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+\n+  if (mask == NULL)\n+    {\n+      maxloc0_8_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_REAL_17 maxval;\n+   int fast = 0;\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    maxval = -GFC_REAL_17_INFINITY;\n+#else\n+    maxval = -GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base >= maxval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      maxval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+        if (back)\n+\t  do\n+\t    {\n+\t      if (*mbase && *base >= maxval)\n+\t        {\n+\t          maxval = *base;\n+\t          for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (*mbase && unlikely (*base > maxval))\n+\t        {\n+\t\t  maxval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t        }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+\n+extern void smaxloc0_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(smaxloc0_8_r17);\n+\n+void\n+smaxloc0_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      maxloc0_8_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MAXLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "31f06e24d58959f4e651a73f6ba1f9348a498516", "filename": "libgfortran/generated/maxloc1_16_r17.c", "status": "added", "additions": 607, "deletions": 0, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc1_16_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc1_16_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,607 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_16)\n+\n+#define HAVE_BACK_ARG 1\n+\n+\n+extern void maxloc1_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n+export_proto(maxloc1_16_r17);\n+\n+void\n+maxloc1_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+\tGFC_REAL_17 maxval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tmaxval = -GFC_REAL_17_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_17_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+#else\n+\t    n = 0;\n+#endif\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+\t\tif (back ? *src >= maxval : *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n+export_proto(mmaxloc1_16_r17);\n+\n+void\n+mmaxloc1_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_r17 (retarray, array, pdim, back);\n+#else\n+      maxloc1_16_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tGFC_REAL_17 maxval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tmaxval = -GFC_REAL_17_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_17_HUGE;\n+#endif\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n+export_proto(smaxloc1_16_r17);\n+\n+void\n+smaxloc1_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_16_r17 (retarray, array, pdim, back);\n+#else\n+      maxloc1_16_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "de825c52e342820bd3923733a56ef43eed9f75f8", "filename": "libgfortran/generated/maxloc1_4_r17.c", "status": "added", "additions": 607, "deletions": 0, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc1_4_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc1_4_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,607 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_4)\n+\n+#define HAVE_BACK_ARG 1\n+\n+\n+extern void maxloc1_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n+export_proto(maxloc1_4_r17);\n+\n+void\n+maxloc1_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+\tGFC_REAL_17 maxval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tmaxval = -GFC_REAL_17_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_17_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+#else\n+\t    n = 0;\n+#endif\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+\t\tif (back ? *src >= maxval : *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n+export_proto(mmaxloc1_4_r17);\n+\n+void\n+mmaxloc1_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_r17 (retarray, array, pdim, back);\n+#else\n+      maxloc1_4_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tGFC_REAL_17 maxval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tmaxval = -GFC_REAL_17_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_17_HUGE;\n+#endif\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n+export_proto(smaxloc1_4_r17);\n+\n+void\n+smaxloc1_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_4_r17 (retarray, array, pdim, back);\n+#else\n+      maxloc1_4_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "666e3a61bc43ed5205e94d076b14823930224022", "filename": "libgfortran/generated/maxloc1_8_r17.c", "status": "added", "additions": 607, "deletions": 0, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc1_8_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxloc1_8_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,607 @@\n+/* Implementation of the MAXLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_8)\n+\n+#define HAVE_BACK_ARG 1\n+\n+\n+extern void maxloc1_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n+export_proto(maxloc1_8_r17);\n+\n+void\n+maxloc1_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+\tGFC_REAL_17 maxval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tmaxval = -GFC_REAL_17_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_17_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+     \t     for (n = 0; n < len; n++, src += delta)\n+\t       {\n+\t\tif (*src >= maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+#else\n+\t    n = 0;\n+#endif\n+\t    for (; n < len; n++, src += delta)\n+\t      {\n+\t\tif (back ? *src >= maxval : *src > maxval)\n+\t\t  {\n+\t\t    maxval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t  }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxloc1_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n+export_proto(mmaxloc1_8_r17);\n+\n+void\n+mmaxloc1_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_r17 (retarray, array, pdim, back);\n+#else\n+      maxloc1_8_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tGFC_REAL_17 maxval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tmaxval = -GFC_REAL_17_INFINITY;\n+#else\n+\tmaxval = -GFC_REAL_17_HUGE;\n+#endif\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src >= maxval)\n+#endif\n+\t\t      {\n+\t\t\tmaxval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src >= maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t        {\n+\t\t  if (*msrc && unlikely (*src > maxval))\n+\t\t    {\n+\t\t      maxval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxloc1_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n+export_proto(smaxloc1_8_r17);\n+\n+void\n+smaxloc1_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      maxloc1_8_r17 (retarray, array, pdim, back);\n+#else\n+      maxloc1_8_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "aafdfae8b61fb40f70ac463ef6c02dee8cdd01dd", "filename": "libgfortran/generated/maxval_r17.c", "status": "added", "additions": 578, "deletions": 0, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxval_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fmaxval_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,578 @@\n+/* Implementation of the MAXVAL intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_REAL_17)\n+\n+\n+extern void maxval_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict);\n+export_proto(maxval_r17);\n+\n+void\n+maxval_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_REAL_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MAXVAL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_REAL_17 result;\n+      src = base;\n+      {\n+\n+#if defined (GFC_REAL_17_INFINITY)\n+\tresult = -GFC_REAL_17_INFINITY;\n+#else\n+\tresult = -GFC_REAL_17_HUGE;\n+#endif\n+\tif (len <= 0)\n+\t  *dest = -GFC_REAL_17_HUGE;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\tif (*src >= result)\n+\t\t  break;\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      result = GFC_REAL_17_QUIET_NAN;\n+\t    else for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src > result)\n+\t\t  result = *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mmaxval_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(mmaxval_r17);\n+\n+void\n+mmaxval_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_17 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      maxval_r17 (retarray, array, pdim, back);\n+#else\n+      maxval_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MAXVAL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MAXVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MAXVAL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_REAL_17 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+#if defined (GFC_REAL_17_INFINITY)\n+\tresult = -GFC_REAL_17_INFINITY;\n+#else\n+\tresult = -GFC_REAL_17_HUGE;\n+#endif\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\tint non_empty_p = 0;\n+#endif\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+#if defined (GFC_REAL_17_INFINITY) || defined (GFC_REAL_17_QUIET_NAN)\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\t    non_empty_p = 1;\n+\t\t    if (*src >= result)\n+#endif\n+\t\t      break;\n+\t\t  }\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\tresult = non_empty_p ? GFC_REAL_17_QUIET_NAN : -GFC_REAL_17_HUGE;\n+#else\n+\t\tresult = -GFC_REAL_17_HUGE;\n+#endif\n+\t      }\n+\t    else for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+#endif\n+\t\tif (*msrc && *src > result)\n+\t\t  result = *src;\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void smaxval_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(smaxval_r17);\n+\n+void\n+smaxval_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      maxval_r17 (retarray, array, pdim, back);\n+#else\n+      maxval_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MAXVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MAXVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MAXVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = -GFC_REAL_17_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "e6a77c4f4b65015f2978f9ad9c962d038f986138", "filename": "libgfortran/generated/minloc0_16_r17.c", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc0_16_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc0_16_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_16_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,407 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_16)\n+\n+\n+extern void minloc0_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4);\n+export_proto(minloc0_16_r17);\n+\n+void\n+minloc0_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_17 *base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+    GFC_REAL_17 minval;\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+    int fast = 0;\n+#endif\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    minval = GFC_REAL_17_INFINITY;\n+#else\n+    minval = GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base <= minval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+#endif\n+      if (back)\n+\tdo\n+\t  {\n+\t    if (unlikely (*base <= minval))\n+\t      {\n+\t\tminval = *base;\n+\t\tfor (n = 0; n < rank; n++)\n+\t\t  dest[n * dstride] = count[n] + 1;\n+\t      }\n+\t    base += sstride[0];\n+\t  }\n+\twhile (++count[0] != extent[0]);\n+      else\n+\tdo\n+\t  {\n+\t    if (unlikely (*base < minval))\n+\t      {\n+\t\tminval = *base;\n+\t\tfor (n = 0; n < rank; n++)\n+\t\t  dest[n * dstride] = count[n] + 1;\n+\t      }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void mminloc0_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n+export_proto(mminloc0_16_r17);\n+\n+void\n+mminloc0_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_16 *dest;\n+  const GFC_REAL_17 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+\n+  if (mask == NULL)\n+    {\n+      minloc0_16_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_REAL_17 minval;\n+   int fast = 0;\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    minval = GFC_REAL_17_INFINITY;\n+#else\n+    minval = GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base <= minval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      minval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+        else\n+        if (back)\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n+\t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void sminloc0_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sminloc0_16_r17);\n+\n+void\n+sminloc0_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_16 *dest;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      minloc0_16_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_16));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "7718d5c07e559d5e20bcef139213b8b81d399bf1", "filename": "libgfortran/generated/minloc0_4_r17.c", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc0_4_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc0_4_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_4_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,407 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_4)\n+\n+\n+extern void minloc0_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4);\n+export_proto(minloc0_4_r17);\n+\n+void\n+minloc0_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_17 *base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+    GFC_REAL_17 minval;\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+    int fast = 0;\n+#endif\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    minval = GFC_REAL_17_INFINITY;\n+#else\n+    minval = GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base <= minval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+#endif\n+      if (back)\n+\tdo\n+\t  {\n+\t    if (unlikely (*base <= minval))\n+\t      {\n+\t\tminval = *base;\n+\t\tfor (n = 0; n < rank; n++)\n+\t\t  dest[n * dstride] = count[n] + 1;\n+\t      }\n+\t    base += sstride[0];\n+\t  }\n+\twhile (++count[0] != extent[0]);\n+      else\n+\tdo\n+\t  {\n+\t    if (unlikely (*base < minval))\n+\t      {\n+\t\tminval = *base;\n+\t\tfor (n = 0; n < rank; n++)\n+\t\t  dest[n * dstride] = count[n] + 1;\n+\t      }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void mminloc0_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n+export_proto(mminloc0_4_r17);\n+\n+void\n+mminloc0_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_4 *dest;\n+  const GFC_REAL_17 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+\n+  if (mask == NULL)\n+    {\n+      minloc0_4_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_REAL_17 minval;\n+   int fast = 0;\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    minval = GFC_REAL_17_INFINITY;\n+#else\n+    minval = GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base <= minval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      minval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+        else\n+        if (back)\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n+\t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void sminloc0_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sminloc0_4_r17);\n+\n+void\n+sminloc0_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_4 *dest;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      minloc0_4_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_4));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "8c8f8bd5dbc37cdbb79d24a597767ae1d73fa4d1", "filename": "libgfortran/generated/minloc0_8_r17.c", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc0_8_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc0_8_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc0_8_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,407 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_8)\n+\n+\n+extern void minloc0_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4);\n+export_proto(minloc0_8_r17);\n+\n+void\n+minloc0_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_17 *base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 1;\n+  {\n+\n+    GFC_REAL_17 minval;\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+    int fast = 0;\n+#endif\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    minval = GFC_REAL_17_INFINITY;\n+#else\n+    minval = GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*base <= minval)\n+\t\t{\n+\t\t  fast = 1;\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t  break;\n+\t\t}\n+\t      base += sstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+      else\n+#endif\n+      if (back)\n+\tdo\n+\t  {\n+\t    if (unlikely (*base <= minval))\n+\t      {\n+\t\tminval = *base;\n+\t\tfor (n = 0; n < rank; n++)\n+\t\t  dest[n * dstride] = count[n] + 1;\n+\t      }\n+\t    base += sstride[0];\n+\t  }\n+\twhile (++count[0] != extent[0]);\n+      else\n+\tdo\n+\t  {\n+\t    if (unlikely (*base < minval))\n+\t      {\n+\t\tminval = *base;\n+\t\tfor (n = 0; n < rank; n++)\n+\t\t  dest[n * dstride] = count[n] + 1;\n+\t      }\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void mminloc0_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, gfc_array_l1 * const restrict,\n+\tGFC_LOGICAL_4);\n+export_proto(mminloc0_8_r17);\n+\n+void\n+mminloc0_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  GFC_INTEGER_8 *dest;\n+  const GFC_REAL_17 *base;\n+  GFC_LOGICAL_1 *mbase;\n+  int rank;\n+  index_type n;\n+  int mask_kind;\n+\n+\n+  if (mask == NULL)\n+    {\n+      minloc0_8_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank - 1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t  \"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      count[n] = 0;\n+      if (extent[n] <= 0)\n+\t{\n+\t  /* Set the return value.  */\n+\t  for (n = 0; n < rank; n++)\n+\t    dest[n * dstride] = 0;\n+\t  return;\n+\t}\n+    }\n+\n+  base = array->base_addr;\n+\n+  /* Initialize the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+  {\n+\n+  GFC_REAL_17 minval;\n+   int fast = 0;\n+\n+#if defined(GFC_REAL_17_INFINITY)\n+    minval = GFC_REAL_17_INFINITY;\n+#else\n+    minval = GFC_REAL_17_HUGE;\n+#endif\n+  while (base)\n+    {\n+\t  /* Implementation start.  */\n+\n+      if (unlikely (!fast))\n+\t{\n+\t  do\n+\t    {\n+\t      if (*mbase)\n+\t\t{\n+#if defined(GFC_REAL_17_QUIET_NAN)\n+\t\t  if (unlikely (dest[0] == 0))\n+\t\t    for (n = 0; n < rank; n++)\n+\t\t      dest[n * dstride] = count[n] + 1;\n+\t\t  if (*base <= minval)\n+#endif\n+\t\t    {\n+\t\t      fast = 1;\n+\t\t      minval = *base;\n+\t\t      for (n = 0; n < rank; n++)\n+\t\t\tdest[n * dstride] = count[n] + 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      base += sstride[0];\n+\t      mbase += mstride[0];\n+\t    }\n+\t  while (++count[0] != extent[0]);\n+\t  if (likely (fast))\n+\t    continue;\n+\t}\n+        else\n+        if (back)\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base <= minval)))\n+\t        {\n+\t      \t  minval = *base;\n+\t      \t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t    \t}\n+\t\tbase += sstride[0];\n+\t    }\n+\t    while (++count[0] != extent[0]);\n+\telse\n+\t  do\n+\t    {\n+\t      if (unlikely (*mbase && (*base < minval)))\n+\t\t{\n+\t\t  minval = *base;\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\t\t}\n+\t  /* Implementation end.  */\n+\t  /* Advance to the next element.  */\n+\t  base += sstride[0];\n+\t  mbase += mstride[0];\n+\t}\n+      while (++count[0] != extent[0]);\n+      n = 0;\n+      do\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t    }\n+\t}\n+      while (count[n] == extent[n]);\n+    }\n+  }\n+}\n+\n+extern void sminloc0_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sminloc0_8_r17);\n+\n+void\n+sminloc0_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array,\n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type n;\n+  GFC_INTEGER_8 *dest;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      minloc0_8_r17 (retarray, array, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (GFC_INTEGER_8));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"MINLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+#endif"}, {"sha": "95f17e04bd442d4953c515feb11bb16ee6eba127", "filename": "libgfortran/generated/minloc1_16_r17.c", "status": "added", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc1_16_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc1_16_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,617 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_16)\n+\n+#define HAVE_BACK_ARG 1\n+\n+\n+extern void minloc1_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n+export_proto(minloc1_16_r17);\n+\n+void\n+minloc1_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      {\n+\n+\tGFC_REAL_17 minval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tminval = GFC_REAL_17_INFINITY;\n+#else\n+\tminval = GFC_REAL_17_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n+\t\tif (*src <= minval)\n+\t\t  {\n+\t\t    minval = *src;\n+\t\t    result = (GFC_INTEGER_16)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+#else\n+\t    n = 0;\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16) n + 1;\n+\t\t    }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n+export_proto(mminloc1_16_r17);\n+\n+void\n+mminloc1_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_r17 (retarray, array, pdim, back);\n+#else\n+      minloc1_16_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_16 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tGFC_REAL_17 minval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tminval = GFC_REAL_17_INFINITY;\n+#else\n+\tminval = GFC_REAL_17_HUGE;\n+#endif\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\tGFC_INTEGER_16 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_16)n + 1;\n+\t\t    if (*src <= minval)\n+#endif\n+\t\t      {\n+\t\t\tminval = *src;\n+\t\t\tresult = (GFC_INTEGER_16)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_16)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n+\t\t  {\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_16) n + 1;\n+\t\t      }\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_16_r17 (gfc_array_i16 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n+export_proto(sminloc1_16_r17);\n+\n+void\n+sminloc1_16_r17 (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_16 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_16_r17 (retarray, array, pdim, back);\n+#else\n+      minloc1_16_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_16));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "4deb31798f785deb9fc7e3557ed098f821de03f2", "filename": "libgfortran/generated/minloc1_4_r17.c", "status": "added", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc1_4_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc1_4_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,617 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_4)\n+\n+#define HAVE_BACK_ARG 1\n+\n+\n+extern void minloc1_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n+export_proto(minloc1_4_r17);\n+\n+void\n+minloc1_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      {\n+\n+\tGFC_REAL_17 minval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tminval = GFC_REAL_17_INFINITY;\n+#else\n+\tminval = GFC_REAL_17_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n+\t\tif (*src <= minval)\n+\t\t  {\n+\t\t    minval = *src;\n+\t\t    result = (GFC_INTEGER_4)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+#else\n+\t    n = 0;\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4) n + 1;\n+\t\t    }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n+export_proto(mminloc1_4_r17);\n+\n+void\n+mminloc1_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_r17 (retarray, array, pdim, back);\n+#else\n+      minloc1_4_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_4 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tGFC_REAL_17 minval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tminval = GFC_REAL_17_INFINITY;\n+#else\n+\tminval = GFC_REAL_17_HUGE;\n+#endif\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\tGFC_INTEGER_4 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_4)n + 1;\n+\t\t    if (*src <= minval)\n+#endif\n+\t\t      {\n+\t\t\tminval = *src;\n+\t\t\tresult = (GFC_INTEGER_4)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_4)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n+\t\t  {\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_4) n + 1;\n+\t\t      }\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_4_r17 (gfc_array_i4 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n+export_proto(sminloc1_4_r17);\n+\n+void\n+sminloc1_4_r17 (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_4 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_4_r17 (retarray, array, pdim, back);\n+#else\n+      minloc1_4_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_4));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "4237bb3aff27cad19e00e9d89f298fb5584f77bc", "filename": "libgfortran/generated/minloc1_8_r17.c", "status": "added", "additions": 617, "deletions": 0, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc1_8_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminloc1_8_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,617 @@\n+/* Implementation of the MINLOC intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_8)\n+\n+#define HAVE_BACK_ARG 1\n+\n+\n+extern void minloc1_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict, GFC_LOGICAL_4 back);\n+export_proto(minloc1_8_r17);\n+\n+void\n+minloc1_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      {\n+\n+\tGFC_REAL_17 minval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tminval = GFC_REAL_17_INFINITY;\n+#else\n+\tminval = GFC_REAL_17_HUGE;\n+#endif\n+\tresult = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+     \t   for (n = 0; n < len; n++, src += delta)\n+\t     {\n+\t\tif (*src <= minval)\n+\t\t  {\n+\t\t    minval = *src;\n+\t\t    result = (GFC_INTEGER_8)n + 1;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+#else\n+\t    n = 0;\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t    else\n+\t      for (; n < len; n++, src += delta)\n+\t        {\n+\t\t  if (unlikely (*src < minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8) n + 1;\n+\t\t    }\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminloc1_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict, GFC_LOGICAL_4 back);\n+export_proto(mminloc1_8_r17);\n+\n+void\n+mminloc1_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_r17 (retarray, array, pdim, back);\n+#else\n+      minloc1_8_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINLOC intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINLOC\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_INTEGER_8 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+\tGFC_REAL_17 minval;\n+#if defined (GFC_REAL_17_INFINITY)\n+\tminval = GFC_REAL_17_INFINITY;\n+#else\n+\tminval = GFC_REAL_17_HUGE;\n+#endif\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\tGFC_INTEGER_8 result2 = 0;\n+#endif\n+\tresult = 0;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\t    if (!result2)\n+\t\t      result2 = (GFC_INTEGER_8)n + 1;\n+\t\t    if (*src <= minval)\n+#endif\n+\t\t      {\n+\t\t\tminval = *src;\n+\t\t\tresult = (GFC_INTEGER_8)n + 1;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t    if (unlikely (n >= len))\n+\t      result = result2;\n+\t    else\n+#endif\n+\t    if (back)\n+\t      for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      \t{\n+\t\t  if (*msrc && unlikely (*src <= minval))\n+\t\t    {\n+\t\t      minval = *src;\n+\t\t      result = (GFC_INTEGER_8)n + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t        for (; n < len; n++, src += delta, msrc += mdelta)\n+\t\t  {\n+\t\t    if (*msrc && unlikely (*src < minval))\n+\t\t      {\n+\t\t        minval = *src;\n+\t\t\tresult = (GFC_INTEGER_8) n + 1;\n+\t\t      }\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminloc1_8_r17 (gfc_array_i8 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *, GFC_LOGICAL_4 back);\n+export_proto(sminloc1_8_r17);\n+\n+void\n+sminloc1_8_r17 (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_INTEGER_8 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      minloc1_8_r17 (retarray, array, pdim, back);\n+#else\n+      minloc1_8_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_INTEGER_8));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINLOC intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 0;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "970500340ae4813116cd47d63096d8c8c9e3cd5e", "filename": "libgfortran/generated/minval_r17.c", "status": "added", "additions": 578, "deletions": 0, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminval_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fminval_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,578 @@\n+/* Implementation of the MINVAL intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_REAL_17)\n+\n+\n+extern void minval_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict);\n+export_proto(minval_r17);\n+\n+void\n+minval_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_REAL_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"MINVAL\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_REAL_17 result;\n+      src = base;\n+      {\n+\n+#if defined (GFC_REAL_17_INFINITY)\n+\tresult = GFC_REAL_17_INFINITY;\n+#else\n+\tresult = GFC_REAL_17_HUGE;\n+#endif\n+\tif (len <= 0)\n+\t  *dest = GFC_REAL_17_HUGE;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\tif (*src <= result)\n+\t\t  break;\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      result = GFC_REAL_17_QUIET_NAN;\n+\t    else for (; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\t\tif (*src < result)\n+\t\t  result = *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mminval_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(mminval_r17);\n+\n+void\n+mminval_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_17 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      minval_r17 (retarray, array, pdim, back);\n+#else\n+      minval_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in MINVAL intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"MINVAL\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"MINVAL\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_REAL_17 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+#if defined (GFC_REAL_17_INFINITY)\n+\tresult = GFC_REAL_17_INFINITY;\n+#else\n+\tresult = GFC_REAL_17_HUGE;\n+#endif\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\tint non_empty_p = 0;\n+#endif\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+#if defined (GFC_REAL_17_INFINITY) || defined (GFC_REAL_17_QUIET_NAN)\n+\t\tif (*msrc)\n+\t\t  {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\t    non_empty_p = 1;\n+\t\t    if (*src <= result)\n+#endif\n+\t\t      break;\n+\t\t  }\n+\t      }\n+\t    if (unlikely (n >= len))\n+\t      {\n+#if defined (GFC_REAL_17_QUIET_NAN)\n+\t\tresult = non_empty_p ? GFC_REAL_17_QUIET_NAN : GFC_REAL_17_HUGE;\n+#else\n+\t\tresult = GFC_REAL_17_HUGE;\n+#endif\n+\t      }\n+\t    else for (; n < len; n++, src += delta, msrc += mdelta)\n+\t      {\n+#endif\n+\t\tif (*msrc && *src < result)\n+\t\t  result = *src;\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sminval_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sminval_r17);\n+\n+void\n+sminval_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      minval_r17 (retarray, array, pdim, back);\n+#else\n+      minval_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in MINVAL intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" MINVAL intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" MINVAL intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = GFC_REAL_17_HUGE;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "d8a0fb7ee477f74f043560206e14522ad387edc7", "filename": "libgfortran/generated/norm2_r17.c", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fnorm2_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fnorm2_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fnorm2_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,219 @@\n+/* Implementation of the NORM2 intrinsic\n+   Copyright (C) 2010-2022 Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus  <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_REAL_17) && 1 /* FIXME: figure this out later.  */ && 1 /* FIXME: figure this out later.  */\n+\n+#if defined(POWER_IEEE128)\n+#define MATHFUNC(funcname) __ ## funcname ## ieee128\n+#else\n+#define MATHFUNC(funcname) funcname ## q\n+#endif\n+\n+\n+extern void norm2_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict);\n+export_proto(norm2_r17);\n+\n+void\n+norm2_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_REAL_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in NORM intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" NORM intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"NORM\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_REAL_17 result;\n+      src = base;\n+      {\n+\n+\tGFC_REAL_17 scale;\n+\tresult = 0;\n+\tscale = 1;\n+\tif (len <= 0)\n+\t  *dest = 0;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+\t  if (*src != 0)\n+\t    {\n+\t      GFC_REAL_17 absX, val;\n+\t      absX = MATHFUNC(fabs) (*src);\n+\t      if (scale < absX)\n+\t\t{\n+\t\t  val = scale / absX;\n+\t\t  result = 1 + result * val * val;\n+\t\t  scale = absX;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  val = absX / scale;\n+\t\t  result += val * val;\n+\t\t}\n+\t    }\n+\t      }\n+\t    result = scale * MATHFUNC(sqrt) (result);\n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+#endif"}, {"sha": "2084c5303b357156a6a6ea65ff748a178745f07d", "filename": "libgfortran/generated/pack_c17.c", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpack_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpack_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,257 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_c17 (gfc_array_c17 *ret, const gfc_array_c17 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_c17 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_COMPLEX_17 * restrict rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_COMPLEX_17 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  mptr = mask->base_addr;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->base_addr;\n+\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = GFC_DESCRIPTOR_EXTENT(vector,0);\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n+\t}\n+      else\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n+\n+      if (ret->base_addr == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n+\n+\t  ret->offset = 0;\n+\n+\t  /* xmallocarray allocates a single byte for zero size.  */\n+\t  ret->base_addr = xmallocarray (total, sizeof (GFC_COMPLEX_17));\n+\n+\t  if (total == 0)\n+\t    return;\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(ret,0);\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = GFC_DESCRIPTOR_STRIDE(ret,0);\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->base_addr;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = GFC_DESCRIPTOR_EXTENT(vector,0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->base_addr + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "ce95011468517e8b655877701985c9059a8d4b5a", "filename": "libgfortran/generated/pack_r17.c", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpack_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpack_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,257 @@\n+/* Specific implementation of the PACK intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+/* PACK is specified as follows:\n+\n+   13.14.80 PACK (ARRAY, MASK, [VECTOR])\n+\n+   Description: Pack an array into an array of rank one under the\n+   control of a mask.\n+\n+   Class: Transformational function.\n+\n+   Arguments:\n+      ARRAY   may be of any type. It shall not be scalar.\n+      MASK    shall be of type LOGICAL. It shall be conformable with ARRAY.\n+      VECTOR  (optional) shall be of the same type and type parameters\n+              as ARRAY. VECTOR shall have at least as many elements as\n+              there are true elements in MASK. If MASK is a scalar\n+              with the value true, VECTOR shall have at least as many\n+              elements as there are in ARRAY.\n+\n+   Result Characteristics: The result is an array of rank one with the\n+   same type and type parameters as ARRAY. If VECTOR is present, the\n+   result size is that of VECTOR; otherwise, the result size is the\n+   number /t/ of true elements in MASK unless MASK is scalar with the\n+   value true, in which case the result size is the size of ARRAY.\n+\n+   Result Value: Element /i/ of the result is the element of ARRAY\n+   that corresponds to the /i/th true element of MASK, taking elements\n+   in array element order, for /i/ = 1, 2, ..., /t/. If VECTOR is\n+   present and has size /n/ > /t/, element /i/ of the result has the\n+   value VECTOR(/i/), for /i/ = /t/ + 1, ..., /n/.\n+\n+   Examples: The nonzero elements of an array M with the value\n+   | 0 0 0 |\n+   | 9 0 0 | may be \"gathered\" by the function PACK. The result of\n+   | 0 0 7 |\n+   PACK (M, MASK = M.NE.0) is [9,7] and the result of PACK (M, M.NE.0,\n+   VECTOR = (/ 2,4,6,8,10,12 /)) is [9,7,6,8,10,12].\n+\n+There are two variants of the PACK intrinsic: one, where MASK is\n+array valued, and the other one where MASK is scalar.  */\n+\n+void\n+pack_r17 (gfc_array_r17 *ret, const gfc_array_r17 *array,\n+\t       const gfc_array_l1 *mask, const gfc_array_r17 *vector)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride0;\n+  GFC_REAL_17 * restrict rptr;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  const GFC_REAL_17 *sptr;\n+  /* m.* indicates the mask array.  */\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride0;\n+  const GFC_LOGICAL_1 *mptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  int zero_sized;\n+  index_type n;\n+  index_type dim;\n+  index_type nelem;\n+  index_type total;\n+  int mask_kind;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+\n+  mptr = mask->base_addr;\n+\n+  /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n+     and using shifting to address size and endian issues.  */\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    {\n+      /*  Do not convert a NULL pointer as we use test for NULL below.  */\n+      if (mptr)\n+\tmptr = GFOR_POINTER_TO_L1 (mptr, mask_kind);\n+    }\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  zero_sized = 0;\n+  for (n = 0; n < dim; n++)\n+    {\n+      count[n] = 0;\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      if (extent[n] <= 0)\n+       zero_sized = 1;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (mstride[0] == 0)\n+    mstride[0] = mask_kind;\n+\n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->base_addr;\n+\n+  if (ret->base_addr == NULL || unlikely (compile_options.bounds_check))\n+    {\n+      /* Count the elements, either for allocating memory or\n+\t for bounds checking.  */\n+\n+      if (vector != NULL)\n+\t{\n+\t  /* The return array will have as many\n+\t     elements as there are in VECTOR.  */\n+\t  total = GFC_DESCRIPTOR_EXTENT(vector,0);\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n+\t}\n+      else\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n+\n+      if (ret->base_addr == NULL)\n+\t{\n+\t  /* Setup the array descriptor.  */\n+\t  GFC_DIMENSION_SET(ret->dim[0], 0, total-1, 1);\n+\n+\t  ret->offset = 0;\n+\n+\t  /* xmallocarray allocates a single byte for zero size.  */\n+\t  ret->base_addr = xmallocarray (total, sizeof (GFC_REAL_17));\n+\n+\t  if (total == 0)\n+\t    return;\n+\t}\n+      else \n+\t{\n+\t  /* We come here because of range checking.  */\n+\t  index_type ret_extent;\n+\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(ret,0);\n+\t  if (total != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return value of PACK intrinsic;\"\n+\t\t\t   \" is %ld, should be %ld\", (long int) total,\n+\t\t\t   (long int) ret_extent);\n+\t}\n+    }\n+\n+  rstride0 = GFC_DESCRIPTOR_STRIDE(ret,0);\n+  if (rstride0 == 0)\n+    rstride0 = 1;\n+  sstride0 = sstride[0];\n+  mstride0 = mstride[0];\n+  rptr = ret->base_addr;\n+\n+  while (sptr && mptr)\n+    {\n+      /* Test this element.  */\n+      if (*mptr)\n+        {\n+          /* Add it.  */\n+\t  *rptr = *sptr;\n+          rptr += rstride0;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      mptr += mstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          mptr -= mstride[n] * extent[n];\n+          n++;\n+          if (n >= dim)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              mptr += mstride[n];\n+            }\n+        }\n+    }\n+\n+  /* Add any remaining elements from VECTOR.  */\n+  if (vector)\n+    {\n+      n = GFC_DESCRIPTOR_EXTENT(vector,0);\n+      nelem = ((rptr - ret->base_addr) / rstride0);\n+      if (n > nelem)\n+        {\n+          sstride0 = GFC_DESCRIPTOR_STRIDE(vector,0);\n+          if (sstride0 == 0)\n+            sstride0 = 1;\n+\n+          sptr = vector->base_addr + sstride0 * nelem;\n+          n -= nelem;\n+          while (n--)\n+            {\n+\t      *rptr = *sptr;\n+              rptr += rstride0;\n+              sptr += sstride0;\n+            }\n+        }\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "c7dccf57c6b68b34ae4c7b42981ace8069f62658", "filename": "libgfortran/generated/pow_c17_i16.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_c17_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_c17_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpow_c17_i16.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,75 @@\n+/* Support routines for the intrinsic power (**) operator.\n+   Copyright (C) 2004-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+/* Use Binary Method to calculate the powi. This is not an optimal but\n+   a simple and reasonable arithmetic. See section 4.6.3, \"Evaluation of\n+   Powers\" of Donald E. Knuth, \"Seminumerical Algorithms\", Vol. 2, \"The Art\n+   of Computer Programming\", 3rd Edition, 1998.  */\n+\n+#if defined (HAVE_GFC_COMPLEX_17) && defined (HAVE_GFC_INTEGER_16)\n+\n+GFC_COMPLEX_17 pow_c17_i16 (GFC_COMPLEX_17 a, GFC_INTEGER_16 b);\n+export_proto(pow_c17_i16);\n+\n+GFC_COMPLEX_17\n+pow_c17_i16 (GFC_COMPLEX_17 a, GFC_INTEGER_16 b)\n+{\n+  GFC_COMPLEX_17 pow, x;\n+  GFC_INTEGER_16 n;\n+  GFC_UINTEGER_16 u;\n+  \n+  n = b;\n+  x = a;\n+  pow = 1;\n+  if (n != 0)\n+    {\n+      if (n < 0)\n+\t{\n+\n+\t  u = -n;\n+\t  x = pow / x;\n+\t}\n+      else\n+\t{\n+\t   u = n;\n+\t}\n+      for (;;)\n+\t{\n+\t  if (u & 1)\n+\t    pow *= x;\n+\t  u >>= 1;\n+\t  if (u)\n+\t    x *= x;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  return pow;\n+}\n+\n+#endif"}, {"sha": "74d092ac73459665cd2d13e5f8b837a0190f48aa", "filename": "libgfortran/generated/pow_c17_i4.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_c17_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_c17_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpow_c17_i4.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,75 @@\n+/* Support routines for the intrinsic power (**) operator.\n+   Copyright (C) 2004-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+/* Use Binary Method to calculate the powi. This is not an optimal but\n+   a simple and reasonable arithmetic. See section 4.6.3, \"Evaluation of\n+   Powers\" of Donald E. Knuth, \"Seminumerical Algorithms\", Vol. 2, \"The Art\n+   of Computer Programming\", 3rd Edition, 1998.  */\n+\n+#if defined (HAVE_GFC_COMPLEX_17) && defined (HAVE_GFC_INTEGER_4)\n+\n+GFC_COMPLEX_17 pow_c17_i4 (GFC_COMPLEX_17 a, GFC_INTEGER_4 b);\n+export_proto(pow_c17_i4);\n+\n+GFC_COMPLEX_17\n+pow_c17_i4 (GFC_COMPLEX_17 a, GFC_INTEGER_4 b)\n+{\n+  GFC_COMPLEX_17 pow, x;\n+  GFC_INTEGER_4 n;\n+  GFC_UINTEGER_4 u;\n+  \n+  n = b;\n+  x = a;\n+  pow = 1;\n+  if (n != 0)\n+    {\n+      if (n < 0)\n+\t{\n+\n+\t  u = -n;\n+\t  x = pow / x;\n+\t}\n+      else\n+\t{\n+\t   u = n;\n+\t}\n+      for (;;)\n+\t{\n+\t  if (u & 1)\n+\t    pow *= x;\n+\t  u >>= 1;\n+\t  if (u)\n+\t    x *= x;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  return pow;\n+}\n+\n+#endif"}, {"sha": "8dc30ee1cb4d51aed32954c278330b1976e8b226", "filename": "libgfortran/generated/pow_c17_i8.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_c17_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_c17_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpow_c17_i8.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,75 @@\n+/* Support routines for the intrinsic power (**) operator.\n+   Copyright (C) 2004-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+/* Use Binary Method to calculate the powi. This is not an optimal but\n+   a simple and reasonable arithmetic. See section 4.6.3, \"Evaluation of\n+   Powers\" of Donald E. Knuth, \"Seminumerical Algorithms\", Vol. 2, \"The Art\n+   of Computer Programming\", 3rd Edition, 1998.  */\n+\n+#if defined (HAVE_GFC_COMPLEX_17) && defined (HAVE_GFC_INTEGER_8)\n+\n+GFC_COMPLEX_17 pow_c17_i8 (GFC_COMPLEX_17 a, GFC_INTEGER_8 b);\n+export_proto(pow_c17_i8);\n+\n+GFC_COMPLEX_17\n+pow_c17_i8 (GFC_COMPLEX_17 a, GFC_INTEGER_8 b)\n+{\n+  GFC_COMPLEX_17 pow, x;\n+  GFC_INTEGER_8 n;\n+  GFC_UINTEGER_8 u;\n+  \n+  n = b;\n+  x = a;\n+  pow = 1;\n+  if (n != 0)\n+    {\n+      if (n < 0)\n+\t{\n+\n+\t  u = -n;\n+\t  x = pow / x;\n+\t}\n+      else\n+\t{\n+\t   u = n;\n+\t}\n+      for (;;)\n+\t{\n+\t  if (u & 1)\n+\t    pow *= x;\n+\t  u >>= 1;\n+\t  if (u)\n+\t    x *= x;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  return pow;\n+}\n+\n+#endif"}, {"sha": "817dd59ca3552189b25e672ea9c96fa1cf3ed0ee", "filename": "libgfortran/generated/pow_r17_i16.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_r17_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_r17_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpow_r17_i16.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,75 @@\n+/* Support routines for the intrinsic power (**) operator.\n+   Copyright (C) 2004-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+/* Use Binary Method to calculate the powi. This is not an optimal but\n+   a simple and reasonable arithmetic. See section 4.6.3, \"Evaluation of\n+   Powers\" of Donald E. Knuth, \"Seminumerical Algorithms\", Vol. 2, \"The Art\n+   of Computer Programming\", 3rd Edition, 1998.  */\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_16)\n+\n+GFC_REAL_17 pow_r17_i16 (GFC_REAL_17 a, GFC_INTEGER_16 b);\n+export_proto(pow_r17_i16);\n+\n+GFC_REAL_17\n+pow_r17_i16 (GFC_REAL_17 a, GFC_INTEGER_16 b)\n+{\n+  GFC_REAL_17 pow, x;\n+  GFC_INTEGER_16 n;\n+  GFC_UINTEGER_16 u;\n+  \n+  n = b;\n+  x = a;\n+  pow = 1;\n+  if (n != 0)\n+    {\n+      if (n < 0)\n+\t{\n+\n+\t  u = -n;\n+\t  x = pow / x;\n+\t}\n+      else\n+\t{\n+\t   u = n;\n+\t}\n+      for (;;)\n+\t{\n+\t  if (u & 1)\n+\t    pow *= x;\n+\t  u >>= 1;\n+\t  if (u)\n+\t    x *= x;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  return pow;\n+}\n+\n+#endif"}, {"sha": "16ba682e418278a1e57083814741f2dc400740dd", "filename": "libgfortran/generated/pow_r17_i4.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_r17_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_r17_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpow_r17_i4.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,75 @@\n+/* Support routines for the intrinsic power (**) operator.\n+   Copyright (C) 2004-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+/* Use Binary Method to calculate the powi. This is not an optimal but\n+   a simple and reasonable arithmetic. See section 4.6.3, \"Evaluation of\n+   Powers\" of Donald E. Knuth, \"Seminumerical Algorithms\", Vol. 2, \"The Art\n+   of Computer Programming\", 3rd Edition, 1998.  */\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_4)\n+\n+GFC_REAL_17 pow_r17_i4 (GFC_REAL_17 a, GFC_INTEGER_4 b);\n+export_proto(pow_r17_i4);\n+\n+GFC_REAL_17\n+pow_r17_i4 (GFC_REAL_17 a, GFC_INTEGER_4 b)\n+{\n+  GFC_REAL_17 pow, x;\n+  GFC_INTEGER_4 n;\n+  GFC_UINTEGER_4 u;\n+  \n+  n = b;\n+  x = a;\n+  pow = 1;\n+  if (n != 0)\n+    {\n+      if (n < 0)\n+\t{\n+\n+\t  u = -n;\n+\t  x = pow / x;\n+\t}\n+      else\n+\t{\n+\t   u = n;\n+\t}\n+      for (;;)\n+\t{\n+\t  if (u & 1)\n+\t    pow *= x;\n+\t  u >>= 1;\n+\t  if (u)\n+\t    x *= x;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  return pow;\n+}\n+\n+#endif"}, {"sha": "d7bfce1fee7688df043576f8474d81b74d5b01af", "filename": "libgfortran/generated/pow_r17_i8.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_r17_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fpow_r17_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpow_r17_i8.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,75 @@\n+/* Support routines for the intrinsic power (**) operator.\n+   Copyright (C) 2004-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+/* Use Binary Method to calculate the powi. This is not an optimal but\n+   a simple and reasonable arithmetic. See section 4.6.3, \"Evaluation of\n+   Powers\" of Donald E. Knuth, \"Seminumerical Algorithms\", Vol. 2, \"The Art\n+   of Computer Programming\", 3rd Edition, 1998.  */\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_INTEGER_8)\n+\n+GFC_REAL_17 pow_r17_i8 (GFC_REAL_17 a, GFC_INTEGER_8 b);\n+export_proto(pow_r17_i8);\n+\n+GFC_REAL_17\n+pow_r17_i8 (GFC_REAL_17 a, GFC_INTEGER_8 b)\n+{\n+  GFC_REAL_17 pow, x;\n+  GFC_INTEGER_8 n;\n+  GFC_UINTEGER_8 u;\n+  \n+  n = b;\n+  x = a;\n+  pow = 1;\n+  if (n != 0)\n+    {\n+      if (n < 0)\n+\t{\n+\n+\t  u = -n;\n+\t  x = pow / x;\n+\t}\n+      else\n+\t{\n+\t   u = n;\n+\t}\n+      for (;;)\n+\t{\n+\t  if (u & 1)\n+\t    pow *= x;\n+\t  u >>= 1;\n+\t  if (u)\n+\t    x *= x;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+  return pow;\n+}\n+\n+#endif"}, {"sha": "dee58a13d145fc825b7cd38b4127215d9e93a0f7", "filename": "libgfortran/generated/product_c17.c", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fproduct_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fproduct_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,536 @@\n+/* Implementation of the PRODUCT intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_17) && defined (HAVE_GFC_COMPLEX_17)\n+\n+\n+extern void product_c17 (gfc_array_c17 * const restrict, \n+\tgfc_array_c17 * const restrict, const index_type * const restrict);\n+export_proto(product_c17);\n+\n+void\n+product_c17 (gfc_array_c17 * const restrict retarray, \n+\tgfc_array_c17 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_17 * restrict base;\n+  GFC_COMPLEX_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in PRODUCT intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_17));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_17 * restrict src;\n+      GFC_COMPLEX_17 result;\n+      src = base;\n+      {\n+\n+  result = 1;\n+\tif (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+  result *= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mproduct_c17 (gfc_array_c17 * const restrict, \n+\tgfc_array_c17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(mproduct_c17);\n+\n+void\n+mproduct_c17 (gfc_array_c17 * const restrict retarray, \n+\tgfc_array_c17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_17 * restrict dest;\n+  const GFC_COMPLEX_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      product_c17 (retarray, array, pdim, back);\n+#else\n+      product_c17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in PRODUCT intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_17));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_COMPLEX_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_COMPLEX_17 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 1;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+  if (*msrc)\n+    result *= *src;\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sproduct_c17 (gfc_array_c17 * const restrict, \n+\tgfc_array_c17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_c17);\n+\n+void\n+sproduct_c17 (gfc_array_c17 * const restrict retarray, \n+\tgfc_array_c17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_COMPLEX_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      product_c17 (retarray, array, pdim, back);\n+#else\n+      product_c17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in PRODUCT intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_17));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "1059533153d0935ad609eb2d6c5e19839c5c2de7", "filename": "libgfortran/generated/product_r17.c", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fproduct_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fproduct_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,536 @@\n+/* Implementation of the PRODUCT intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_17) && defined (HAVE_GFC_REAL_17)\n+\n+\n+extern void product_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict);\n+export_proto(product_r17);\n+\n+void\n+product_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_17 * restrict base;\n+  GFC_REAL_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in PRODUCT intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"PRODUCT\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  base = array->base_addr;\n+  dest = retarray->base_addr;\n+\n+  continue_loop = 1;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      GFC_REAL_17 result;\n+      src = base;\n+      {\n+\n+  result = 1;\n+\tif (len <= 0)\n+\t  *dest = 1;\n+\telse\n+\t  {\n+#if ! defined HAVE_BACK_ARG\n+\t    for (n = 0; n < len; n++, src += delta)\n+\t      {\n+#endif\n+\n+  result *= *src;\n+\t      }\n+\t    \n+\t    *dest = result;\n+\t  }\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void mproduct_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tgfc_array_l1 * const restrict);\n+export_proto(mproduct_r17);\n+\n+void\n+mproduct_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tgfc_array_l1 * const restrict mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_17 * restrict dest;\n+  const GFC_REAL_17 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type rank;\n+  index_type dim;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  int mask_kind;\n+\n+  if (mask == NULL)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      product_r17 (retarray, array, pdim, back);\n+#else\n+      product_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in PRODUCT intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len <= 0)\n+    return;\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    runtime_error (\"Funny sized logical array\");\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str= GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in PRODUCT intrinsic\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t   \"return value\", \"PRODUCT\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t  \t\t\t\"MASK argument\", \"PRODUCT\");\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  base = array->base_addr;\n+\n+  while (base)\n+    {\n+      const GFC_REAL_17 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      GFC_REAL_17 result;\n+      src = base;\n+      msrc = mbase;\n+      {\n+\n+  result = 1;\n+\tfor (n = 0; n < len; n++, src += delta, msrc += mdelta)\n+\t  {\n+\n+  if (*msrc)\n+    result *= *src;\n+\t  }\n+\t*dest = result;\n+      }\n+      /* Advance to the next element.  */\n+      count[0]++;\n+      base += sstride[0];\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  base -= sstride[n] * extent[n];\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      /* Break out of the loop.  */\n+\t      base = NULL;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n];\n+\t      mbase += mstride[n];\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+extern void sproduct_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, const index_type * const restrict,\n+\tGFC_LOGICAL_4 *);\n+export_proto(sproduct_r17);\n+\n+void\n+sproduct_r17 (gfc_array_r17 * const restrict retarray, \n+\tgfc_array_r17 * const restrict array, \n+\tconst index_type * const restrict pdim, \n+\tGFC_LOGICAL_4 * mask)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  GFC_REAL_17 * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type dim;\n+\n+\n+  if (mask == NULL || *mask)\n+    {\n+#ifdef HAVE_BACK_ARG\n+      product_r17 (retarray, array, pdim, back);\n+#else\n+      product_r17 (retarray, array, pdim);\n+#endif\n+      return;\n+    }\n+  /* Make dim zero based to avoid confusion.  */\n+  dim = (*pdim) - 1;\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in PRODUCT intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+      else\n+\tretarray->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" PRODUCT intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n=0; n < rank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,n);\n+\t      if (extent[n] != ret_extent)\n+\t\truntime_error (\"Incorrect extent in return value of\"\n+\t\t\t       \" PRODUCT intrinsic in dimension %ld:\"\n+\t\t\t       \" is %ld, should be %ld\", (long int) n + 1,\n+\t\t\t       (long int) ret_extent, (long int) extent[n]);\n+\t    }\n+\t}\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+    }\n+\n+  dest = retarray->base_addr;\n+\n+  while(1)\n+    {\n+      *dest = 1;\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  /* When we get to the end of a dimension, reset it and increment\n+\t     the next dimension.  */\n+\t  count[n] = 0;\n+\t  /* We could precalculate these products, but this is a less\n+\t     frequently used path so probably not worth it.  */\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    return;\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+      \t}\n+    }\n+}\n+\n+#endif"}, {"sha": "b0d7ec8cd572794de9bf7f552c7cd8d8b6cc1cac", "filename": "libgfortran/generated/reshape_c17.c", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Freshape_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Freshape_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,366 @@\n+/* Implementation of the RESHAPE intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+typedef GFC_FULL_ARRAY_DESCRIPTOR(1, index_type) shape_type;\n+\n+\n+extern void reshape_c17 (gfc_array_c17 * const restrict, \n+\tgfc_array_c17 * const restrict, \n+\tshape_type * const restrict,\n+\tgfc_array_c17 * const restrict, \n+\tshape_type * const restrict);\n+export_proto(reshape_c17);\n+\n+void\n+reshape_c17 (gfc_array_c17 * const restrict ret, \n+\tgfc_array_c17 * const restrict source, \n+\tshape_type * const restrict shape,\n+\tgfc_array_c17 * const restrict pad, \n+\tshape_type * const restrict order)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rcount[GFC_MAX_DIMENSIONS];\n+  index_type rextent[GFC_MAX_DIMENSIONS];\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdim;\n+  index_type rsize;\n+  index_type rs;\n+  index_type rex;\n+  GFC_COMPLEX_17 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type scount[GFC_MAX_DIMENSIONS];\n+  index_type sextent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type sdim;\n+  index_type ssize;\n+  const GFC_COMPLEX_17 *sptr;\n+  /* p.* indicates the pad array.  */\n+  index_type pcount[GFC_MAX_DIMENSIONS];\n+  index_type pextent[GFC_MAX_DIMENSIONS];\n+  index_type pstride[GFC_MAX_DIMENSIONS];\n+  index_type pdim;\n+  index_type psize;\n+  const GFC_COMPLEX_17 *pptr;\n+\n+  const GFC_COMPLEX_17 *src;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = GFC_DESCRIPTOR_EXTENT(shape,0);\n+  /* rdim is always > 0; this lets the compiler optimize more and\n+   avoids a potential warning.  */\n+  GFC_ASSERT(rdim>0);\n+\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (index_type n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->base_addr[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n+\n+  if (ret->base_addr == NULL)\n+    {\n+      index_type alloc_size;\n+\n+      rs = 1;\n+      for (index_type n = 0; n < rdim; n++)\n+\t{\n+\t  rex = shape_data[n];\n+\n+\t  GFC_DIMENSION_SET(ret->dim[n], 0, rex - 1, rs);\n+\n+\t  rs *= rex;\n+\t}\n+      ret->offset = 0;\n+\n+      if (unlikely (rs < 1))\n+        alloc_size = 0;\n+      else\n+        alloc_size = rs;\n+\n+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_COMPLEX_17));\n+      ret->dtype.rank = rdim;\n+    }\n+\n+  if (shape_empty)\n+    return;\n+\n+  if (pad)\n+    {\n+      pdim = GFC_DESCRIPTOR_RANK (pad);\n+      psize = 1;\n+      pempty = 0;\n+      for (index_type n = 0; n < pdim; n++)\n+        {\n+          pcount[n] = 0;\n+          pstride[n] = GFC_DESCRIPTOR_STRIDE(pad,n);\n+          pextent[n] = GFC_DESCRIPTOR_EXTENT(pad,n);\n+          if (pextent[n] <= 0)\n+\t    {\n+\t      pempty = 1;\n+\t      pextent[n] = 0;\n+\t    }\n+\n+          if (psize == pstride[n])\n+            psize *= pextent[n];\n+          else\n+            psize = 0;\n+        }\n+      pptr = pad->base_addr;\n+    }\n+  else\n+    {\n+      pdim = 0;\n+      psize = 1;\n+      pempty = 1;\n+      pptr = NULL;\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, source_extent;\n+\n+      rs = 1;\n+      for (index_type n = 0; n < rdim; n++)\n+\t{\n+\t  rs *= shape_data[n];\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(ret,n);\n+\t  if (ret_extent != shape_data[n])\n+\t    runtime_error(\"Incorrect extent in return value of RESHAPE\"\n+\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t  (long int) ret_extent, (long int) shape_data[n]);\n+\t}\n+\n+      source_extent = 1;\n+      sdim = GFC_DESCRIPTOR_RANK (source);\n+      for (index_type n = 0; n < sdim; n++)\n+\t{\n+\t  index_type se;\n+\t  se = GFC_DESCRIPTOR_EXTENT(source,n);\n+\t  source_extent *= se > 0 ? se : 0;\n+\t}\n+\n+      if (rs > source_extent && (!pad || pempty))\n+\truntime_error(\"Incorrect size in SOURCE argument to RESHAPE\"\n+\t\t      \" intrinsic: is %ld, should be %ld\",\n+\t\t      (long int) source_extent, (long int) rs);\n+\n+      if (order)\n+\t{\n+\t  int seen[GFC_MAX_DIMENSIONS];\n+\t  index_type v;\n+\n+\t  for (index_type n = 0; n < rdim; n++)\n+\t    seen[n] = 0;\n+\n+\t  for (index_type n = 0; n < rdim; n++)\n+\t    {\n+\t      v = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+\n+\t      if (v < 0 || v >= rdim)\n+\t\truntime_error(\"Value %ld out of range in ORDER argument\"\n+\t\t\t      \" to RESHAPE intrinsic\", (long int) v + 1);\n+\n+\t      if (seen[v] != 0)\n+\t\truntime_error(\"Duplicate value %ld in ORDER argument to\"\n+\t\t\t      \" RESHAPE intrinsic\", (long int) v + 1);\n+\t\t\n+\t      seen[v] = 1;\n+\t    }\n+\t}\n+    }\n+\n+  rsize = 1;\n+  for (index_type n = 0; n < rdim; n++)\n+    {\n+      index_type dim;\n+      if (order)\n+        dim = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+      else\n+        dim = n;\n+\n+      rcount[n] = 0;\n+      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+      rextent[n] = GFC_DESCRIPTOR_EXTENT(ret,dim);\n+      if (rextent[n] < 0)\n+        rextent[n] = 0;\n+\n+      if (rextent[n] != shape_data[dim])\n+        runtime_error (\"shape and target do not conform\");\n+\n+      if (rsize == rstride[n])\n+        rsize *= rextent[n];\n+      else\n+        rsize = 0;\n+      if (rextent[n] <= 0)\n+        return;\n+    }\n+\n+  sdim = GFC_DESCRIPTOR_RANK (source);\n+\n+  /* sdim is always > 0; this lets the compiler optimize more and\n+   avoids a warning.  */\n+  GFC_ASSERT(sdim>0);\n+\n+  ssize = 1;\n+  sempty = 0;\n+  for (index_type n = 0; n < sdim; n++)\n+    {\n+      scount[n] = 0;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      sextent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n+      if (sextent[n] <= 0)\n+\t{\n+\t  sempty = 1;\n+\t  sextent[n] = 0;\n+\t}\n+\n+      if (ssize == sstride[n])\n+        ssize *= sextent[n];\n+      else\n+        ssize = 0;\n+    }\n+\n+  if (rsize != 0 && ssize != 0 && psize != 0)\n+    {\n+      rsize *= sizeof (GFC_COMPLEX_17);\n+      ssize *= sizeof (GFC_COMPLEX_17);\n+      psize *= sizeof (GFC_COMPLEX_17);\n+      reshape_packed ((char *)ret->base_addr, rsize, (char *)source->base_addr,\n+\t\t      ssize, pad ? (char *)pad->base_addr : NULL, psize);\n+      return;\n+    }\n+  rptr = ret->base_addr;\n+  src = sptr = source->base_addr;\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+\n+  if (sempty && pempty)\n+    abort ();\n+\n+  if (sempty)\n+    {\n+      /* Pretend we are using the pad array the first time around, too.  */\n+      src = pptr;\n+      sptr = pptr;\n+      sdim = pdim;\n+      for (index_type dim = 0; dim < pdim; dim++)\n+\t{\n+\t  scount[dim] = pcount[dim];\n+\t  sextent[dim] = pextent[dim];\n+\t  sstride[dim] = pstride[dim];\n+\t  sstride0 = pstride[0];\n+\t}\n+    }\n+\n+  while (rptr)\n+    {\n+      /* Select between the source and pad arrays.  */\n+      *rptr = *src;\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      src += sstride0;\n+      rcount[0]++;\n+      scount[0]++;\n+\n+      /* Advance to the next destination element.  */\n+      index_type n = 0;\n+      while (rcount[n] == rextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          rcount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * rextent[n];\n+          n++;\n+          if (n == rdim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              rcount[n]++;\n+              rptr += rstride[n];\n+            }\n+        }\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (scount[n] == sextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          scount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= sstride[n] * sextent[n];\n+          n++;\n+          if (n == sdim)\n+            {\n+              if (sptr && pad)\n+                {\n+                  /* Switch to the pad array.  */\n+                  sptr = NULL;\n+                  sdim = pdim;\n+                  for (index_type dim = 0; dim < pdim; dim++)\n+                    {\n+                      scount[dim] = pcount[dim];\n+                      sextent[dim] = pextent[dim];\n+                      sstride[dim] = pstride[dim];\n+                      sstride0 = sstride[0];\n+                    }\n+                }\n+              /* We now start again from the beginning of the pad array.  */\n+              src = pptr;\n+              break;\n+            }\n+          else\n+            {\n+              scount[n]++;\n+              src += sstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "36425ca377fa561760a4e4a02798b90aaa5fe1b7", "filename": "libgfortran/generated/reshape_r17.c", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Freshape_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Freshape_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,366 @@\n+/* Implementation of the RESHAPE intrinsic\n+   Copyright (C) 2002-2022 Free Software Foundation, Inc.\n+   Contributed by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+typedef GFC_FULL_ARRAY_DESCRIPTOR(1, index_type) shape_type;\n+\n+\n+extern void reshape_r17 (gfc_array_r17 * const restrict, \n+\tgfc_array_r17 * const restrict, \n+\tshape_type * const restrict,\n+\tgfc_array_r17 * const restrict, \n+\tshape_type * const restrict);\n+export_proto(reshape_r17);\n+\n+void\n+reshape_r17 (gfc_array_r17 * const restrict ret, \n+\tgfc_array_r17 * const restrict source, \n+\tshape_type * const restrict shape,\n+\tgfc_array_r17 * const restrict pad, \n+\tshape_type * const restrict order)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rcount[GFC_MAX_DIMENSIONS];\n+  index_type rextent[GFC_MAX_DIMENSIONS];\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdim;\n+  index_type rsize;\n+  index_type rs;\n+  index_type rex;\n+  GFC_REAL_17 *rptr;\n+  /* s.* indicates the source array.  */\n+  index_type scount[GFC_MAX_DIMENSIONS];\n+  index_type sextent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type sdim;\n+  index_type ssize;\n+  const GFC_REAL_17 *sptr;\n+  /* p.* indicates the pad array.  */\n+  index_type pcount[GFC_MAX_DIMENSIONS];\n+  index_type pextent[GFC_MAX_DIMENSIONS];\n+  index_type pstride[GFC_MAX_DIMENSIONS];\n+  index_type pdim;\n+  index_type psize;\n+  const GFC_REAL_17 *pptr;\n+\n+  const GFC_REAL_17 *src;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = GFC_DESCRIPTOR_EXTENT(shape,0);\n+  /* rdim is always > 0; this lets the compiler optimize more and\n+   avoids a potential warning.  */\n+  GFC_ASSERT(rdim>0);\n+\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (index_type n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->base_addr[n * GFC_DESCRIPTOR_STRIDE(shape,0)];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n+\n+  if (ret->base_addr == NULL)\n+    {\n+      index_type alloc_size;\n+\n+      rs = 1;\n+      for (index_type n = 0; n < rdim; n++)\n+\t{\n+\t  rex = shape_data[n];\n+\n+\t  GFC_DIMENSION_SET(ret->dim[n], 0, rex - 1, rs);\n+\n+\t  rs *= rex;\n+\t}\n+      ret->offset = 0;\n+\n+      if (unlikely (rs < 1))\n+        alloc_size = 0;\n+      else\n+        alloc_size = rs;\n+\n+      ret->base_addr = xmallocarray (alloc_size, sizeof (GFC_REAL_17));\n+      ret->dtype.rank = rdim;\n+    }\n+\n+  if (shape_empty)\n+    return;\n+\n+  if (pad)\n+    {\n+      pdim = GFC_DESCRIPTOR_RANK (pad);\n+      psize = 1;\n+      pempty = 0;\n+      for (index_type n = 0; n < pdim; n++)\n+        {\n+          pcount[n] = 0;\n+          pstride[n] = GFC_DESCRIPTOR_STRIDE(pad,n);\n+          pextent[n] = GFC_DESCRIPTOR_EXTENT(pad,n);\n+          if (pextent[n] <= 0)\n+\t    {\n+\t      pempty = 1;\n+\t      pextent[n] = 0;\n+\t    }\n+\n+          if (psize == pstride[n])\n+            psize *= pextent[n];\n+          else\n+            psize = 0;\n+        }\n+      pptr = pad->base_addr;\n+    }\n+  else\n+    {\n+      pdim = 0;\n+      psize = 1;\n+      pempty = 1;\n+      pptr = NULL;\n+    }\n+\n+  if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, source_extent;\n+\n+      rs = 1;\n+      for (index_type n = 0; n < rdim; n++)\n+\t{\n+\t  rs *= shape_data[n];\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(ret,n);\n+\t  if (ret_extent != shape_data[n])\n+\t    runtime_error(\"Incorrect extent in return value of RESHAPE\"\n+\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t  (long int) ret_extent, (long int) shape_data[n]);\n+\t}\n+\n+      source_extent = 1;\n+      sdim = GFC_DESCRIPTOR_RANK (source);\n+      for (index_type n = 0; n < sdim; n++)\n+\t{\n+\t  index_type se;\n+\t  se = GFC_DESCRIPTOR_EXTENT(source,n);\n+\t  source_extent *= se > 0 ? se : 0;\n+\t}\n+\n+      if (rs > source_extent && (!pad || pempty))\n+\truntime_error(\"Incorrect size in SOURCE argument to RESHAPE\"\n+\t\t      \" intrinsic: is %ld, should be %ld\",\n+\t\t      (long int) source_extent, (long int) rs);\n+\n+      if (order)\n+\t{\n+\t  int seen[GFC_MAX_DIMENSIONS];\n+\t  index_type v;\n+\n+\t  for (index_type n = 0; n < rdim; n++)\n+\t    seen[n] = 0;\n+\n+\t  for (index_type n = 0; n < rdim; n++)\n+\t    {\n+\t      v = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+\n+\t      if (v < 0 || v >= rdim)\n+\t\truntime_error(\"Value %ld out of range in ORDER argument\"\n+\t\t\t      \" to RESHAPE intrinsic\", (long int) v + 1);\n+\n+\t      if (seen[v] != 0)\n+\t\truntime_error(\"Duplicate value %ld in ORDER argument to\"\n+\t\t\t      \" RESHAPE intrinsic\", (long int) v + 1);\n+\t\t\n+\t      seen[v] = 1;\n+\t    }\n+\t}\n+    }\n+\n+  rsize = 1;\n+  for (index_type n = 0; n < rdim; n++)\n+    {\n+      index_type dim;\n+      if (order)\n+        dim = order->base_addr[n * GFC_DESCRIPTOR_STRIDE(order,0)] - 1;\n+      else\n+        dim = n;\n+\n+      rcount[n] = 0;\n+      rstride[n] = GFC_DESCRIPTOR_STRIDE(ret,dim);\n+      rextent[n] = GFC_DESCRIPTOR_EXTENT(ret,dim);\n+      if (rextent[n] < 0)\n+        rextent[n] = 0;\n+\n+      if (rextent[n] != shape_data[dim])\n+        runtime_error (\"shape and target do not conform\");\n+\n+      if (rsize == rstride[n])\n+        rsize *= rextent[n];\n+      else\n+        rsize = 0;\n+      if (rextent[n] <= 0)\n+        return;\n+    }\n+\n+  sdim = GFC_DESCRIPTOR_RANK (source);\n+\n+  /* sdim is always > 0; this lets the compiler optimize more and\n+   avoids a warning.  */\n+  GFC_ASSERT(sdim>0);\n+\n+  ssize = 1;\n+  sempty = 0;\n+  for (index_type n = 0; n < sdim; n++)\n+    {\n+      scount[n] = 0;\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(source,n);\n+      sextent[n] = GFC_DESCRIPTOR_EXTENT(source,n);\n+      if (sextent[n] <= 0)\n+\t{\n+\t  sempty = 1;\n+\t  sextent[n] = 0;\n+\t}\n+\n+      if (ssize == sstride[n])\n+        ssize *= sextent[n];\n+      else\n+        ssize = 0;\n+    }\n+\n+  if (rsize != 0 && ssize != 0 && psize != 0)\n+    {\n+      rsize *= sizeof (GFC_REAL_17);\n+      ssize *= sizeof (GFC_REAL_17);\n+      psize *= sizeof (GFC_REAL_17);\n+      reshape_packed ((char *)ret->base_addr, rsize, (char *)source->base_addr,\n+\t\t      ssize, pad ? (char *)pad->base_addr : NULL, psize);\n+      return;\n+    }\n+  rptr = ret->base_addr;\n+  src = sptr = source->base_addr;\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+\n+  if (sempty && pempty)\n+    abort ();\n+\n+  if (sempty)\n+    {\n+      /* Pretend we are using the pad array the first time around, too.  */\n+      src = pptr;\n+      sptr = pptr;\n+      sdim = pdim;\n+      for (index_type dim = 0; dim < pdim; dim++)\n+\t{\n+\t  scount[dim] = pcount[dim];\n+\t  sextent[dim] = pextent[dim];\n+\t  sstride[dim] = pstride[dim];\n+\t  sstride0 = pstride[0];\n+\t}\n+    }\n+\n+  while (rptr)\n+    {\n+      /* Select between the source and pad arrays.  */\n+      *rptr = *src;\n+      /* Advance to the next element.  */\n+      rptr += rstride0;\n+      src += sstride0;\n+      rcount[0]++;\n+      scount[0]++;\n+\n+      /* Advance to the next destination element.  */\n+      index_type n = 0;\n+      while (rcount[n] == rextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          rcount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * rextent[n];\n+          n++;\n+          if (n == rdim)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              rcount[n]++;\n+              rptr += rstride[n];\n+            }\n+        }\n+      /* Advance to the next source element.  */\n+      n = 0;\n+      while (scount[n] == sextent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          scount[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          src -= sstride[n] * sextent[n];\n+          n++;\n+          if (n == sdim)\n+            {\n+              if (sptr && pad)\n+                {\n+                  /* Switch to the pad array.  */\n+                  sptr = NULL;\n+                  sdim = pdim;\n+                  for (index_type dim = 0; dim < pdim; dim++)\n+                    {\n+                      scount[dim] = pcount[dim];\n+                      sextent[dim] = pextent[dim];\n+                      sstride[dim] = pstride[dim];\n+                      sstride0 = sstride[0];\n+                    }\n+                }\n+              /* We now start again from the beginning of the pad array.  */\n+              src = pptr;\n+              break;\n+            }\n+          else\n+            {\n+              scount[n]++;\n+              src += sstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+#endif"}, {"sha": "70de587116467935287691e81ad5b950426afc61", "filename": "libgfortran/generated/spread_c17.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fspread_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fspread_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,266 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright (C) 2008-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_17)\n+\n+void\n+spread_c17 (gfc_array_c17 *ret, const gfc_array_c17 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_COMPLEX_17 *rptr;\n+  GFC_COMPLEX_17 * restrict dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_COMPLEX_17 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->base_addr == NULL)\n+    {\n+\n+      size_t ub, stride;\n+\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype.rank = rrank;\n+\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  stride = rs;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ub = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = GFC_DESCRIPTOR_EXTENT(source,dim);\n+\t      sstride[dim] = GFC_DESCRIPTOR_STRIDE(source,dim);\n+\t      rstride[dim] = rs;\n+\n+\t      ub = extent[dim] - 1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t  GFC_DIMENSION_SET(ret->dim[n], 0, ub, stride);\n+\t}\n+      ret->offset = 0;\n+\n+      /* xmallocarray allocates a single byte for zero size.  */\n+      ret->base_addr = xmallocarray (rs, sizeof(GFC_COMPLEX_17));\n+      if (rs <= 0)\n+        return;\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(ret,n);\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = GFC_DESCRIPTOR_STRIDE(ret,n);\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = GFC_DESCRIPTOR_EXTENT(source,dim);\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = GFC_DESCRIPTOR_STRIDE(source,dim);\n+\t\t  rstride[dim] = GFC_DESCRIPTOR_STRIDE(ret,n);\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = GFC_DESCRIPTOR_STRIDE(ret,n);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = GFC_DESCRIPTOR_EXTENT(source,dim);\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = GFC_DESCRIPTOR_STRIDE(source,dim);\n+\t\t  rstride[dim] = GFC_DESCRIPTOR_STRIDE(ret,n);\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->base_addr;\n+  sptr = source->base_addr;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_c17 (gfc_array_c17 *ret, const GFC_COMPLEX_17 *source,\n+\t\t\tconst index_type along, const index_type ncopies)\n+{\n+  GFC_COMPLEX_17 * restrict dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->base_addr == NULL)\n+    {\n+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_COMPLEX_17));\n+      ret->offset = 0;\n+      GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (GFC_DESCRIPTOR_EXTENT(ret,0) - 1)\n+\t\t\t   / GFC_DESCRIPTOR_STRIDE(ret,0))\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->base_addr;\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  for (index_type n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "4aab77df117055d70840dc83714eb3bded46e639", "filename": "libgfortran/generated/spread_r17.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fspread_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fspread_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2", "patch": "@@ -0,0 +1,266 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright (C) 2008-2022 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_17)\n+\n+void\n+spread_r17 (gfc_array_r17 *ret, const gfc_array_r17 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_REAL_17 *rptr;\n+  GFC_REAL_17 * restrict dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_REAL_17 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->base_addr == NULL)\n+    {\n+\n+      size_t ub, stride;\n+\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype.rank = rrank;\n+\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  stride = rs;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ub = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = GFC_DESCRIPTOR_EXTENT(source,dim);\n+\t      sstride[dim] = GFC_DESCRIPTOR_STRIDE(source,dim);\n+\t      rstride[dim] = rs;\n+\n+\t      ub = extent[dim] - 1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t  GFC_DIMENSION_SET(ret->dim[n], 0, ub, stride);\n+\t}\n+      ret->offset = 0;\n+\n+      /* xmallocarray allocates a single byte for zero size.  */\n+      ret->base_addr = xmallocarray (rs, sizeof(GFC_REAL_17));\n+      if (rs <= 0)\n+        return;\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = GFC_DESCRIPTOR_EXTENT(ret,n);\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = GFC_DESCRIPTOR_STRIDE(ret,n);\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = GFC_DESCRIPTOR_EXTENT(source,dim);\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = GFC_DESCRIPTOR_STRIDE(source,dim);\n+\t\t  rstride[dim] = GFC_DESCRIPTOR_STRIDE(ret,n);\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = GFC_DESCRIPTOR_STRIDE(ret,n);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = GFC_DESCRIPTOR_EXTENT(source,dim);\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = GFC_DESCRIPTOR_STRIDE(source,dim);\n+\t\t  rstride[dim] = GFC_DESCRIPTOR_STRIDE(ret,n);\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->base_addr;\n+  sptr = source->base_addr;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_r17 (gfc_array_r17 *ret, const GFC_REAL_17 *source,\n+\t\t\tconst index_type along, const index_type ncopies)\n+{\n+  GFC_REAL_17 * restrict dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->base_addr == NULL)\n+    {\n+      ret->base_addr = xmallocarray (ncopies, sizeof (GFC_REAL_17));\n+      ret->offset = 0;\n+      GFC_DIMENSION_SET(ret->dim[0], 0, ncopies - 1, 1);\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (GFC_DESCRIPTOR_EXTENT(ret,0) - 1)\n+\t\t\t   / GFC_DESCRIPTOR_STRIDE(ret,0))\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->base_addr;\n+  stride = GFC_DESCRIPTOR_STRIDE(ret,0);\n+\n+  for (index_type n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif\n+"}, {"sha": "16514d3df03097ae25a233eb6c9a53cfc3a348bb", "filename": "libgfortran/generated/sum_c17.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fsum_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fsum_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "a11550752c69ab8a0f660a1aa949a24374f70a80", "filename": "libgfortran/generated/sum_r17.c", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fsum_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Fsum_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "c19d80263179d2afbfa45c6808f2317a94de89cb", "filename": "libgfortran/generated/unpack_c17.c", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Funpack_c17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Funpack_c17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_c17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "d09d3abbc77765fe0dbf0b603893f619d354bb23", "filename": "libgfortran/generated/unpack_r17.c", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Funpack_r17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fgenerated%2Funpack_r17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Funpack_r17.c?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "efae0d034a4fcbaf3a923c78b58f882291116f1f", "filename": "libgfortran/kinds-override.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fkinds-override.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fkinds-override.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fkinds-override.h?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "f0bd50a7176b9b600960309d766261bb956d8440", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgfortran/m4/ifunc.m4", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fm4%2Fifunc.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fm4%2Fifunc.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunc.m4?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}, {"sha": "184ca0a064f8adf7a3c8fecbb453221462713882", "filename": "libgfortran/m4/mtype.m4", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fm4%2Fmtype.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2/libgfortran%2Fm4%2Fmtype.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmtype.m4?ref=49ad4d2c30387ec916b16ddc1e235bcb5e53b3b2"}]}