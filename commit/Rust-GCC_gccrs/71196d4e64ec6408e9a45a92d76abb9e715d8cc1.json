{"sha": "71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzExOTZkNGU2NGVjNjQwOGU5YTQ1YTkyZDc2YWJiOWU3MTVkOGNjMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-10-07T11:17:55Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-10-07T11:17:55Z"}, "message": "gigi.h (gnat_useless_type_conversion): Declare.\n\n\t* gcc-interface/gigi.h (gnat_useless_type_conversion): Declare.\n\t(rest_of_subprog_body_compilation): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: For renaming,\n\ttest for useless conversions by means of gnat_useless_type_conversion.\n\t* gcc-interface/trans.c: Include bitmap.h and cgraph.h.\n\t(language_function): Add named_ret_val and other_ret_val.\n\t(f_named_ret_val): New macro.\n\t(f_other_ret_val): Likewise.\n\t(gigi): Call rest_of_subprog_body_compilation.\n\t(struct nrv_data): New structure.\n\t(is_nrv_p): New predicate.\n\t(prune_nrv_r): New helper function.\n\t(prune_nrv_in_block): New function.\n\t(finalize_nrv_r): New helper function.\n\t(finalize_nrv): New function.\n\t(return_value_ok_for_nrv_p): New predicate.\n\t(build_return_expr): If optimization is enabled, record candidates for\n\tthe Named Return Value optimization.\n\t(build_function_stub): Call rest_of_subprog_body_compilation.\n\t(Subprogram_Body_to_gnu): If optimization is enabled and there are\n\tcandidates, finalize the Named Return Value optimization.\n\tCall rest_of_subprog_body_compilation.\n\t(call_to_gnu): At the end, if a return value is needed, simplify the\n\tresult before wrapping it up in a COMPOUND_EXPR.\n\t* gcc-interface/utils.c (end_subprog_body): Split into...\n\t(rest_of_subprog_body_compilation): ...this.  New function.\n\t(gnat_useless_type_conversion): Likewise.\n\nFrom-SVN: r179650", "tree": {"sha": "8f7d2f68e499a4690bd68a1127224174cb0c17a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f7d2f68e499a4690bd68a1127224174cb0c17a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/comments", "author": null, "committer": null, "parents": [{"sha": "302b8e2a16a80114e4a4b8d3a760049e750d7167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/302b8e2a16a80114e4a4b8d3a760049e750d7167", "html_url": "https://github.com/Rust-GCC/gccrs/commit/302b8e2a16a80114e4a4b8d3a760049e750d7167"}], "stats": {"total": 416, "additions": 400, "deletions": 16}, "files": [{"sha": "d275ba34007d7daa8efb4a3e40f6ed7d0026b5b9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "patch": "@@ -1,3 +1,33 @@\n+2011-10-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (gnat_useless_type_conversion): Declare.\n+\t(rest_of_subprog_body_compilation): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: For renaming,\n+\ttest for useless conversions by means of gnat_useless_type_conversion.\n+\t* gcc-interface/trans.c: Include bitmap.h and cgraph.h.\n+\t(language_function): Add named_ret_val and other_ret_val.\n+\t(f_named_ret_val): New macro.\n+\t(f_other_ret_val): Likewise.\n+\t(gigi): Call rest_of_subprog_body_compilation.\n+\t(struct nrv_data): New structure.\n+\t(is_nrv_p): New predicate.\n+\t(prune_nrv_r): New helper function.\n+\t(prune_nrv_in_block): New function.\n+\t(finalize_nrv_r): New helper function.\n+\t(finalize_nrv): New function.\n+\t(return_value_ok_for_nrv_p): New predicate.\n+\t(build_return_expr): If optimization is enabled, record candidates for\n+\tthe Named Return Value optimization.\n+\t(build_function_stub): Call rest_of_subprog_body_compilation.\n+\t(Subprogram_Body_to_gnu): If optimization is enabled and there are\n+\tcandidates, finalize the Named Return Value optimization.\n+\tCall rest_of_subprog_body_compilation.\n+\t(call_to_gnu): At the end, if a return value is needed, simplify the\n+\tresult before wrapping it up in a COMPOUND_EXPR.\n+\t* gcc-interface/utils.c (end_subprog_body): Split into...\n+\t(rest_of_subprog_body_compilation): ...this.  New function.\n+\t(gnat_useless_type_conversion): Likewise.\n+\n 2011-10-06  Thomas Quinot  <quinot@adacore.com>\n \n \t* einfo.ads, exp_attr.adb, exp_ch3.adb, exp_ch4.adb, exp_ch7.adb,"}, {"sha": "feb353ba78312602f3f4fa3d86d3834ca1474130", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "patch": "@@ -949,10 +949,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    if ((TREE_CODE (gnu_expr) == COMPONENT_REF\n \t\t && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))\n \t\t/* Strip useless conversions around the object.  */\n-\t\t|| (TREE_CODE (gnu_expr) == NOP_EXPR\n-\t\t    && gnat_types_compatible_p\n-\t\t       (TREE_TYPE (gnu_expr),\n-\t\t\tTREE_TYPE (TREE_OPERAND (gnu_expr, 0)))))\n+\t\t|| gnat_useless_type_conversion (gnu_expr))\n \t      {\n \t\tgnu_expr = TREE_OPERAND (gnu_expr, 0);\n \t\tgnu_type = TREE_TYPE (gnu_expr);"}, {"sha": "1687fd1782b8cef8d2f4412cdfe2844fa80054d5", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "patch": "@@ -479,6 +479,9 @@ extern tree gnat_signed_type (tree type_node);\n    transparently converted to each other.  */\n extern int gnat_types_compatible_p (tree t1, tree t2);\n \n+/* Return true if EXPR is a useless type conversion.  */\n+extern bool gnat_useless_type_conversion (tree expr);\n+\n /* Return true if T, a FUNCTION_TYPE, has the specified list of flags.  */\n extern bool fntype_same_flags_p (const_tree, tree, bool, bool, bool);\n \n@@ -687,9 +690,12 @@ extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n    appearing in the subprogram.  */\n extern void begin_subprog_body (tree subprog_decl);\n \n-/* Finish the definition of the current subprogram BODY and finalize it.  */\n+/* Finish translating the current subprogram and set its BODY.  */\n extern void end_subprog_body (tree body);\n \n+/* Wrap up compilation of SUBPROG_DECL, a subprogram body.  */\n+extern void rest_of_subprog_body_compilation (tree subprog_decl);\n+\n /* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n    EXPR is an expression that we can use to locate any PLACEHOLDER_EXPRs.\n    Return a constructor for the template.  */"}, {"sha": "af7e9af9608e2d4f9467944957924e2e318aacb6", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 337, "deletions": 6, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "patch": "@@ -34,6 +34,8 @@\n #include \"libfuncs.h\"\t/* For set_stack_check_libfunc.  */\n #include \"tree-iterator.h\"\n #include \"gimple.h\"\n+#include \"bitmap.h\"\n+#include \"cgraph.h\"\n \n #include \"ada.h\"\n #include \"adadecode.h\"\n@@ -125,11 +127,19 @@ DEF_VEC_ALLOC_P(parm_attr,gc);\n \n struct GTY(()) language_function {\n   VEC(parm_attr,gc) *parm_attr_cache;\n+  bitmap named_ret_val;\n+  VEC(tree,gc) *other_ret_val;\n };\n \n #define f_parm_attr_cache \\\n   DECL_STRUCT_FUNCTION (current_function_decl)->language->parm_attr_cache\n \n+#define f_named_ret_val \\\n+  DECL_STRUCT_FUNCTION (current_function_decl)->language->named_ret_val\n+\n+#define f_other_ret_val \\\n+  DECL_STRUCT_FUNCTION (current_function_decl)->language->other_ret_val\n+\n /* A structure used to gather together information about a statement group.\n    We use this to gather related statements, for example the \"then\" part\n    of a IF.  In the case where it represents a lexical scope, we may also\n@@ -626,6 +636,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t{\n \t  begin_subprog_body (info->elab_proc);\n \t  end_subprog_body (gnu_body);\n+\t  rest_of_subprog_body_compilation (info->elab_proc);\n \t}\n     }\n \n@@ -2502,9 +2513,275 @@ establish_gnat_vms_condition_handler (void)\n   add_stmt (establish_stmt);\n }\n \n-/* Similar, but for RETURN_EXPR.  If RET_VAL is non-null, build a RETURN_EXPR\n-   around the assignment of RET_VAL to RET_OBJ.  Otherwise just build a bare\n-   RETURN_EXPR around RESULT_OBJ, which may be null in this case.  */\n+/* This page implements a form of Named Return Value optimization modelled\n+   on the C++ optimization of the same name.  The main difference is that\n+   we disregard any semantical considerations when applying it here, the\n+   counterpart being that we don't try to apply it to semantically loaded\n+   return types, i.e. types with the TREE_ADDRESSABLE flag set.\n+\n+   We consider a function body of the following GENERIC form:\n+\n+     return_type R1;\n+       [...]\n+     RETURN_EXPR [<retval> = ...]\n+       [...]\n+     RETURN_EXPR [<retval> = R1]\n+       [...]\n+     return_type Ri;\n+       [...]\n+     RETURN_EXPR [<retval> = ...]\n+       [...]\n+     RETURN_EXPR [<retval> = Ri]\n+       [...]\n+\n+   and we try to fulfill a simple criterion that would make it possible to\n+   replace one or several Ri variables with the RESULT_DECL of the function.\n+\n+   The first observation is that RETURN_EXPRs that don't directly reference\n+   any of the Ri variables on the RHS of their assignment are transparent wrt\n+   the optimization.  This is because the Ri variables aren't addressable so\n+   any transformation applied to them doesn't affect the RHS; moreover, the\n+   assignment writes the full <retval> object so existing values are entirely\n+   discarded.\n+\n+   This property can be extended to some forms of RETURN_EXPRs that reference\n+   the Ri variables, for example CONSTRUCTORs, but isn't true in the general\n+   case, in particular when function calls are involved.\n+\n+   Therefore the algorithm is as follows:\n+\n+     1. Collect the list of candidates for a Named Return Value (Ri variables\n+\ton the RHS of assignments of RETURN_EXPRs) as well as the list of the\n+\tother expressions on the RHS of such assignments.\n+\n+     2. Prune the members of the first list (candidates) that are referenced\n+\tby a member of the second list (expressions).\n+\n+     3. Extract a set of candidates with non-overlapping live ranges from the\n+\tfirst list.  These are the Named Return Values.\n+\n+     4. Adjust the relevant RETURN_EXPRs and replace the occurrences of the\n+\tNamed Return Values in the function with the RESULT_DECL.  */\n+\n+struct nrv_data\n+{\n+  bitmap nrv;\n+  tree result;\n+  struct pointer_set_t *visited;\n+};\n+\n+/* Return true if T is a Named Return Value.  */\n+\n+static inline bool\n+is_nrv_p (bitmap nrv, tree t)\n+{\n+  return TREE_CODE (t) == VAR_DECL && bitmap_bit_p (nrv, DECL_UID (t));\n+}\n+\n+/* Helper function for walk_tree, used by finalize_nrv below.  */\n+\n+static tree\n+prune_nrv_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct nrv_data *dp = (struct nrv_data *)data;\n+  tree t = *tp;\n+\n+  /* No need to walk into types or decls.  */\n+  if (IS_TYPE_OR_DECL_P (t))\n+    *walk_subtrees = 0;\n+\n+  if (is_nrv_p (dp->nrv, t))\n+    bitmap_clear_bit (dp->nrv, DECL_UID (t));\n+\n+  return NULL_TREE;\n+}\n+\n+/* Prune Named Return Values in BLOCK and return true if there is still a\n+   Named Return Value in BLOCK or one of its sub-blocks.  */\n+\n+static bool\n+prune_nrv_in_block (bitmap nrv, tree block)\n+{\n+  bool has_nrv = false;\n+  tree t;\n+\n+  /* First recurse on the sub-blocks.  */\n+  for (t = BLOCK_SUBBLOCKS (block); t; t = BLOCK_CHAIN (t))\n+    has_nrv |= prune_nrv_in_block (nrv, t);\n+\n+  /* Then make sure to keep at most one NRV per block.  */\n+  for (t = BLOCK_VARS (block); t; t = DECL_CHAIN (t))\n+    if (is_nrv_p (nrv, t))\n+      {\n+\tif (has_nrv)\n+\t  bitmap_clear_bit (nrv, DECL_UID (t));\n+\telse\n+\t  has_nrv = true;\n+      }\n+\n+  return has_nrv;\n+}\n+\n+/* Helper function for walk_tree, used by finalize_nrv below.  */\n+\n+static tree\n+finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n+{\n+  struct nrv_data *dp = (struct nrv_data *)data;\n+  tree t = *tp;\n+\n+  /* No need to walk into types.  */\n+  if (TYPE_P (t))\n+    *walk_subtrees = 0;\n+\n+  /* Change RETURN_EXPRs of NRVs to just refer to the RESULT_DECL; this is a\n+     nop, but differs from using NULL_TREE in that it indicates that we care\n+     about the value of the RESULT_DECL.  */\n+  else if (TREE_CODE (t) == RETURN_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (t, 0)) == MODIFY_EXPR)\n+    {\n+      tree ret_val = TREE_OPERAND (TREE_OPERAND (t, 0), 1), init_expr;\n+\n+      /* If this is the temporary created for a return value with variable\n+\t size in call_to_gnu, we replace the RHS with the init expression.  */\n+      if (TREE_CODE (ret_val) == COMPOUND_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (ret_val, 0)) == INIT_EXPR\n+\t  && TREE_OPERAND (TREE_OPERAND (ret_val, 0), 0)\n+\t     == TREE_OPERAND (ret_val, 1))\n+\t{\n+\t  init_expr = TREE_OPERAND (TREE_OPERAND (ret_val, 0), 1);\n+\t  ret_val = TREE_OPERAND (ret_val, 1);\n+\t}\n+      else\n+\tinit_expr = NULL_TREE;\n+\n+      /* Strip useless conversions around the return value.  */\n+      if (gnat_useless_type_conversion (ret_val))\n+\tret_val = TREE_OPERAND (ret_val, 0);\n+\n+      if (is_nrv_p (dp->nrv, ret_val))\n+\t{\n+\t  if (init_expr)\n+\t    TREE_OPERAND (TREE_OPERAND (t, 0), 1) = init_expr;\n+\t  else\n+\t    TREE_OPERAND (t, 0) = dp->result;\n+\t}\n+    }\n+\n+  /* Replace the DECL_EXPR of NRVs with an initialization of the RESULT_DECL,\n+     if needed.  */\n+  else if (TREE_CODE (t) == DECL_EXPR\n+\t   && is_nrv_p (dp->nrv, DECL_EXPR_DECL (t)))\n+    {\n+      tree var = DECL_EXPR_DECL (t), init;\n+\n+      if (DECL_INITIAL (var))\n+\t{\n+\t  init = build_binary_op (INIT_EXPR, NULL_TREE, dp->result,\n+\t\t\t\t  DECL_INITIAL (var));\n+\t  SET_EXPR_LOCATION (init, EXPR_LOCATION (t));\n+\t  DECL_INITIAL (var) = NULL_TREE;\n+\t}\n+      else\n+\tinit = build_empty_stmt (EXPR_LOCATION (t));\n+      *tp = init;\n+\n+      /* Identify the NRV to the RESULT_DECL for debugging purposes.  */\n+      SET_DECL_VALUE_EXPR (var, dp->result);\n+      DECL_HAS_VALUE_EXPR_P (var) = 1;\n+      /* ??? Kludge to avoid an assertion failure during inlining.  */\n+      DECL_SIZE (var) = bitsize_unit_node;\n+      DECL_SIZE_UNIT (var) = size_one_node;\n+    }\n+\n+  /* And replace all uses of NRVs with the RESULT_DECL.  */\n+  else if (is_nrv_p (dp->nrv, t))\n+    *tp = convert (TREE_TYPE (t), dp->result);\n+\n+  /* Avoid walking into the same tree more than once.  Unfortunately, we\n+     can't just use walk_tree_without_duplicates because it would only call\n+     us for the first occurrence of NRVs in the function body.  */\n+  if (pointer_set_insert (dp->visited, *tp))\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Finalize the Named Return Value optimization for FNDECL.  The NRV bitmap\n+   contains the candidates for Named Return Value and OTHER is a list of\n+   the other return values.  */\n+\n+static void\n+finalize_nrv (tree fndecl, bitmap nrv, VEC(tree,gc) *other)\n+{\n+  struct cgraph_node *node;\n+  struct nrv_data data;\n+  unsigned int i;\n+  tree iter;\n+\n+  /* We shouldn't be applying the optimization to return types that we aren't\n+     allowed to manipulate freely.  */\n+  gcc_assert (!TREE_ADDRESSABLE (TREE_TYPE (TREE_TYPE (fndecl))));\n+\n+  /* Prune the candidates that are referenced by other return values.  */\n+  data.nrv = nrv;\n+  data.result = NULL_TREE;\n+  data.visited = NULL;\n+  for (i = 0; VEC_iterate(tree, other, i, iter); i++)\n+    walk_tree_without_duplicates (&iter, prune_nrv_r, &data);\n+  if (bitmap_empty_p (nrv))\n+    return;\n+\n+  /* Prune also the candidates that are referenced by nested functions.  */\n+  node = cgraph_get_create_node (fndecl);\n+  for (node = node->nested; node; node = node->next_nested)\n+    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), prune_nrv_r,\n+\t\t\t\t  &data);\n+  if (bitmap_empty_p (nrv))\n+    return;\n+\n+  /* Extract a set of NRVs with non-overlapping live ranges.  */\n+  if (!prune_nrv_in_block (nrv, DECL_INITIAL (fndecl)))\n+    return;\n+\n+  /* Adjust the relevant RETURN_EXPRs and replace the occurrences of NRVs.  */\n+  data.nrv = nrv;\n+  data.result = DECL_RESULT (fndecl);\n+  data.visited = pointer_set_create ();\n+  walk_tree (&DECL_SAVED_TREE (fndecl), finalize_nrv_r, &data, NULL);\n+  pointer_set_destroy (data.visited);\n+}\n+\n+/* Return true if RET_VAL can be used as a Named Return Value for the\n+   anonymous return object RET_OBJ.  */\n+\n+static bool\n+return_value_ok_for_nrv_p (tree ret_obj, tree ret_val)\n+{\n+  if (TREE_CODE (ret_val) != VAR_DECL)\n+    return false;\n+\n+  if (TREE_THIS_VOLATILE (ret_val))\n+    return false;\n+\n+  if (DECL_CONTEXT (ret_val) != current_function_decl)\n+    return false;\n+\n+  if (TREE_STATIC (ret_val))\n+    return false;\n+\n+  if (TREE_ADDRESSABLE (ret_val))\n+    return false;\n+\n+  if (DECL_ALIGN (ret_val) > DECL_ALIGN (ret_obj))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Build a RETURN_EXPR.  If RET_VAL is non-null, build a RETURN_EXPR around\n+   the assignment of RET_VAL to RET_OBJ.  Otherwise build a bare RETURN_EXPR\n+   around RESULT_OBJ, which may be null in this case.  */\n \n static tree\n build_return_expr (tree ret_obj, tree ret_val)\n@@ -2533,6 +2810,41 @@ build_return_expr (tree ret_obj, tree ret_val)\n \tret_val = convert (operation_type, ret_val);\n \n       result_expr = build2 (MODIFY_EXPR, void_type_node, ret_obj, ret_val);\n+\n+      /* If the function returns an aggregate type, find out whether this is\n+\t a candidate for Named Return Value.  If so, record it.  Otherwise,\n+\t if this is an expression of some kind, record it elsewhere.  */\n+      if (optimize\n+\t  && AGGREGATE_TYPE_P (operation_type)\n+\t  && !TYPE_IS_FAT_POINTER_P (operation_type)\n+\t  && aggregate_value_p (operation_type, current_function_decl))\n+\t{\n+\t  /* Recognize the temporary created for a return value with variable\n+\t     size in call_to_gnu.  We want to eliminate it if possible.  */\n+\t  if (TREE_CODE (ret_val) == COMPOUND_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (ret_val, 0)) == INIT_EXPR\n+\t      && TREE_OPERAND (TREE_OPERAND (ret_val, 0), 0)\n+\t\t == TREE_OPERAND (ret_val, 1))\n+\t    ret_val = TREE_OPERAND (ret_val, 1);\n+\n+\t  /* Strip useless conversions around the return value.  */\n+\t  if (gnat_useless_type_conversion (ret_val))\n+\t    ret_val = TREE_OPERAND (ret_val, 0);\n+\n+\t  /* Now apply the test to the return value.  */\n+\t  if (return_value_ok_for_nrv_p (ret_obj, ret_val))\n+\t    {\n+\t      if (!f_named_ret_val)\n+\t\tf_named_ret_val = BITMAP_GGC_ALLOC ();\n+\t      bitmap_set_bit (f_named_ret_val, DECL_UID (ret_val));\n+\t    }\n+\n+\t  /* Note that we need not care about CONSTRUCTORs here, as they are\n+\t     totally transparent given the read-compose-write semantics of\n+\t     assignments from CONSTRUCTORs.  */\n+\t  else if (EXPR_P (ret_val))\n+\t    VEC_safe_push (tree, gc, f_other_ret_val, ret_val);\n+\t}\n     }\n   else\n     result_expr = ret_obj;\n@@ -2601,6 +2913,7 @@ build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n \n   gnat_poplevel ();\n   end_subprog_body (end_stmt_group ());\n+  rest_of_subprog_body_compilation (gnu_stub_decl);\n }\n \f\n /* Subroutine of gnat_to_gnu to process gnat_node, an N_Subprogram_Body.  We\n@@ -2855,6 +3168,18 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   if (gnu_return_var_elmt)\n     TREE_VALUE (gnu_return_var_elmt) = void_type_node;\n \n+  /* If the function returns an aggregate type and we have candidates for\n+     a Named Return Value, finalize the optimization.  */\n+  if (optimize && gnu_subprog_language->named_ret_val)\n+    {\n+      finalize_nrv (gnu_subprog_decl, gnu_subprog_language->named_ret_val,\n+\t\t    gnu_subprog_language->other_ret_val);\n+      gnu_subprog_language->named_ret_val = NULL;\n+      gnu_subprog_language->other_ret_val = NULL;\n+    }\n+\n+  rest_of_subprog_body_compilation (gnu_subprog_decl);\n+\n   /* If there is a stub associated with the function, build it now.  */\n   if (DECL_FUNCTION_STUB (gnu_subprog_decl))\n     build_function_stub (gnu_subprog_decl, gnat_subprog_id);\n@@ -3518,10 +3843,16 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n   else\n     return gnu_call;\n \n-  /* If we nevertheless need a value, make a COMPOUND_EXPR to return it.  */\n+  /* If we nevertheless need a value, make a COMPOUND_EXPR to return it.\n+     But first simplify if we have only one statement in the list.  */\n   if (returning_value)\n-    gnu_result\n-      = build_compound_expr (TREE_TYPE (gnu_call), gnu_result, gnu_call);\n+    {\n+      tree first = expr_first (gnu_result), last = expr_last (gnu_result);\n+      if (first == last)\n+\tgnu_result = first;\n+      gnu_result\n+\t= build_compound_expr (TREE_TYPE (gnu_call), gnu_result, gnu_call);\n+    }\n \n   return gnu_result;\n }"}, {"sha": "62d9d67bbe7ac0e7ffe0d0fa999bcad29262fe58", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71196d4e64ec6408e9a45a92d76abb9e715d8cc1/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=71196d4e64ec6408e9a45a92d76abb9e715d8cc1", "patch": "@@ -1958,7 +1958,7 @@ begin_subprog_body (tree subprog_decl)\n   make_decl_rtl (subprog_decl);\n }\n \n-/* Finish the definition of the current subprogram BODY and finalize it.  */\n+/* Finish translating the current subprogram and set its BODY.  */\n \n void\n end_subprog_body (tree body)\n@@ -1983,7 +1983,13 @@ end_subprog_body (tree body)\n   DECL_SAVED_TREE (fndecl) = body;\n \n   current_function_decl = DECL_CONTEXT (fndecl);\n+}\n+\n+/* Wrap up compilation of SUBPROG_DECL, a subprogram body.  */\n \n+void\n+rest_of_subprog_body_compilation (tree subprog_decl)\n+{\n   /* We cannot track the location of errors past this point.  */\n   error_gnat_node = Empty;\n \n@@ -1992,15 +1998,15 @@ end_subprog_body (tree body)\n     return;\n \n   /* Dump functions before gimplification.  */\n-  dump_function (TDI_original, fndecl);\n+  dump_function (TDI_original, subprog_decl);\n \n   /* ??? This special handling of nested functions is probably obsolete.  */\n-  if (!DECL_CONTEXT (fndecl))\n-    cgraph_finalize_function (fndecl, false);\n+  if (!DECL_CONTEXT (subprog_decl))\n+    cgraph_finalize_function (subprog_decl, false);\n   else\n     /* Register this function with cgraph just far enough to get it\n        added to our parent's nested function list.  */\n-    (void) cgraph_get_create_node (fndecl);\n+    (void) cgraph_get_create_node (subprog_decl);\n }\n \n tree\n@@ -2194,6 +2200,20 @@ gnat_types_compatible_p (tree t1, tree t2)\n   return 0;\n }\n \n+/* Return true if EXPR is a useless type conversion.  */\n+\n+bool\n+gnat_useless_type_conversion (tree expr)\n+{\n+  if (CONVERT_EXPR_P (expr)\n+      || TREE_CODE (expr) == VIEW_CONVERT_EXPR\n+      || TREE_CODE (expr) == NON_LVALUE_EXPR)\n+    return gnat_types_compatible_p (TREE_TYPE (expr),\n+\t\t\t\t    TREE_TYPE (TREE_OPERAND (expr, 0)));\n+\n+  return false;\n+}\n+\n /* Return true if T, a FUNCTION_TYPE, has the specified list of flags.  */\n \n bool"}]}