{"sha": "ad1d36bafd1f18e33bd03169af788c6467f09c4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQxZDM2YmFmZDFmMThlMzNiZDAzMTY5YWY3ODhjNjQ2N2YwOWM0ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-09-25T20:40:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-25T20:40:10Z"}, "message": "ada-tree.h (TREE_THIS_NOTRAP): Redefine.\n\n\t* gcc-interface/ada-tree.h (TREE_THIS_NOTRAP): Redefine.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Factor out common code in\n\tthe by-ref case.  Do not set TREE_READONLY on a renamed object.  Set\n\tTREE_THIS_NOTRAP on UNCONSTRAINED_ARRAY_REF nodes.\n\t(Attribute_to_gnu) <Attr_Length>: Expand the use of the parameter cache\n\tto the indirect case.\n\t* gcc-interface/utils.c (convert) <UNCONSTRAINED_ARRAY_REF>: Preserve\n\tthe TREE_THIS_NOTRAP flag.\n\nFrom-SVN: r179171", "tree": {"sha": "9f6bbde3c9bf15f76ca025d853cd82821eb0fffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f6bbde3c9bf15f76ca025d853cd82821eb0fffd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad1d36bafd1f18e33bd03169af788c6467f09c4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad1d36bafd1f18e33bd03169af788c6467f09c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad1d36bafd1f18e33bd03169af788c6467f09c4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad1d36bafd1f18e33bd03169af788c6467f09c4d/comments", "author": null, "committer": null, "parents": [{"sha": "6162cec0d9ca47c71ab3b0effe544d53ce27e3c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8"}], "stats": {"total": 115, "additions": 75, "deletions": 40}, "files": [{"sha": "eab2ec8c52a23e9f35b6491680232f7616be3b89", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1d36bafd1f18e33bd03169af788c6467f09c4d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1d36bafd1f18e33bd03169af788c6467f09c4d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ad1d36bafd1f18e33bd03169af788c6467f09c4d", "patch": "@@ -1,3 +1,14 @@\n+2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TREE_THIS_NOTRAP): Redefine.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Factor out common code in\n+\tthe by-ref case.  Do not set TREE_READONLY on a renamed object.  Set\n+\tTREE_THIS_NOTRAP on UNCONSTRAINED_ARRAY_REF nodes.\n+\t(Attribute_to_gnu) <Attr_Length>: Expand the use of the parameter cache\n+\tto the indirect case.\n+\t* gcc-interface/utils.c (convert) <UNCONSTRAINED_ARRAY_REF>: Preserve\n+\tthe TREE_THIS_NOTRAP flag.\n+\n 2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Loop_Statement_to_gnu): In the case of an"}, {"sha": "150dd8654deba1d341b9c552078176d7d4f8ea5e", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1d36bafd1f18e33bd03169af788c6467f09c4d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1d36bafd1f18e33bd03169af788c6467f09c4d/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=ad1d36bafd1f18e33bd03169af788c6467f09c4d", "patch": "@@ -426,6 +426,15 @@ do {\t\t\t\t\t\t   \\\n   SET_DECL_LANG_SPECIFIC (PARM_DECL_CHECK (NODE), X)\n \n \n+/* Flags added to ref nodes.  */\n+\n+/* Nonzero means this node will not trap.  */\n+#undef TREE_THIS_NOTRAP\n+#define TREE_THIS_NOTRAP(NODE) \\\n+  (TREE_CHECK4 (NODE, INDIRECT_REF, ARRAY_REF, UNCONSTRAINED_ARRAY_REF, \\\n+\t\tARRAY_RANGE_REF)->base.nothrow_flag)\n+\n+\n /* Fields and macros for statements.  */\n #define IS_ADA_STMT(NODE) \\\n   (STATEMENT_CLASS_P (NODE) && TREE_CODE (NODE) >= STMT_STMT)"}, {"sha": "73579861998ec57a37378d6a3d475a4bb57115f8", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1d36bafd1f18e33bd03169af788c6467f09c4d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1d36bafd1f18e33bd03169af788c6467f09c4d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=ad1d36bafd1f18e33bd03169af788c6467f09c4d", "patch": "@@ -989,8 +989,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t      && DECL_BY_COMPONENT_PTR_P (gnu_result))))\n     {\n       const bool read_only = DECL_POINTS_TO_READONLY_P (gnu_result);\n-      tree renamed_obj;\n \n+      /* First do the first dereference if needed.  */\n       if (TREE_CODE (gnu_result) == PARM_DECL\n \t  && DECL_BY_DOUBLE_REF_P (gnu_result))\n \t{\n@@ -999,42 +999,37 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t    TREE_THIS_NOTRAP (gnu_result) = 1;\n \t}\n \n+      /* If it's a PARM_DECL to foreign convention subprogram, convert it.  */\n       if (TREE_CODE (gnu_result) == PARM_DECL\n \t  && DECL_BY_COMPONENT_PTR_P (gnu_result))\n-\t{\n-\t  gnu_result\n-\t    = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t      convert (build_pointer_type (gnu_result_type),\n-\t\t\t\t       gnu_result));\n-\t  if (TREE_CODE (gnu_result) == INDIRECT_REF)\n-\t    TREE_THIS_NOTRAP (gnu_result) = 1;\n-\t}\n+\tgnu_result\n+\t  = convert (build_pointer_type (gnu_result_type), gnu_result);\n+\n+      /* If it's a CONST_DECL, return the underlying constant like below.  */\n+      else if (TREE_CODE (gnu_result) == CONST_DECL)\n+\tgnu_result = DECL_INITIAL (gnu_result);\n \n       /* If it's a renaming pointer and we are at the right binding level,\n \t we can reference the renamed object directly, since the renamed\n \t expression has been protected against multiple evaluations.  */\n-      else if (TREE_CODE (gnu_result) == VAR_DECL\n-\t       && (renamed_obj = DECL_RENAMED_OBJECT (gnu_result))\n-\t       && (!DECL_RENAMING_GLOBAL_P (gnu_result)\n-\t\t   || global_bindings_p ()))\n-\tgnu_result = renamed_obj;\n-\n-      /* Return the underlying CST for a CONST_DECL like a few lines below,\n-\t after dereferencing in this case.  */\n-      else if (TREE_CODE (gnu_result) == CONST_DECL)\n-\tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t     DECL_INITIAL (gnu_result));\n+      if (TREE_CODE (gnu_result) == VAR_DECL\n+\t  && DECL_RENAMED_OBJECT (gnu_result)\n+\t  && (!DECL_RENAMING_GLOBAL_P (gnu_result) || global_bindings_p ()))\n+\tgnu_result = DECL_RENAMED_OBJECT (gnu_result);\n \n+      /* Otherwise, do the final dereference.  */\n       else\n \t{\n \t  gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n-\t  if (TREE_CODE (gnu_result) == INDIRECT_REF\n+\n+\t  if ((TREE_CODE (gnu_result) == INDIRECT_REF\n+\t       || TREE_CODE (gnu_result) == UNCONSTRAINED_ARRAY_REF)\n \t      && No (Address_Clause (gnat_temp)))\n \t    TREE_THIS_NOTRAP (gnu_result) = 1;\n-\t}\n \n-      if (read_only)\n-\tTREE_READONLY (gnu_result) = 1;\n+\t  if (read_only)\n+\t    TREE_READONLY (gnu_result) = 1;\n+\t}\n     }\n \n   /* The GNAT tree has the type of a function as the type of its result.  Also\n@@ -1597,11 +1592,26 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t/* Make sure any implicit dereference gets done.  */\n \tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n \tgnu_prefix = maybe_unconstrained_array (gnu_prefix);\n+\n \t/* We treat unconstrained array In parameters specially.  */\n-\tif (Nkind (Prefix (gnat_node)) == N_Identifier\n-\t    && !Is_Constrained (Etype (Prefix (gnat_node)))\n-\t    && Ekind (Entity (Prefix (gnat_node))) == E_In_Parameter)\n-\t  gnat_param = Entity (Prefix (gnat_node));\n+\tif (!Is_Constrained (Etype (Prefix (gnat_node))))\n+\t  {\n+\t    Node_Id gnat_prefix = Prefix (gnat_node);\n+\n+\t    /* This is the direct case.  */\n+\t    if (Nkind (gnat_prefix) == N_Identifier\n+\t\t&& Ekind (Entity (gnat_prefix)) == E_In_Parameter)\n+\t      gnat_param = Entity (gnat_prefix);\n+\n+\t    /* This is the indirect case.  Note that we need to be sure that\n+\t       the access value cannot be null as we'll hoist the load.  */\n+\t    if (Nkind (gnat_prefix) == N_Explicit_Dereference\n+\t\t&& Nkind (Prefix (gnat_prefix)) == N_Identifier\n+\t\t&& Ekind (Entity (Prefix (gnat_prefix))) == E_In_Parameter\n+\t\t&& Can_Never_Be_Null (Entity (Prefix (gnat_prefix))))\n+\t      gnat_param = Entity (Prefix (gnat_prefix));\n+\t  }\n+\n \tgnu_type = TREE_TYPE (gnu_prefix);\n \tprefix_unused = true;\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));"}, {"sha": "de9256ae17d67bc911f9b89e2cf1e364021b600b", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad1d36bafd1f18e33bd03169af788c6467f09c4d/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad1d36bafd1f18e33bd03169af788c6467f09c4d/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=ad1d36bafd1f18e33bd03169af788c6467f09c4d", "patch": "@@ -3947,17 +3947,21 @@ convert (tree type, tree expr)\n       break;\n \n     case UNCONSTRAINED_ARRAY_REF:\n-      /* Convert this to the type of the inner array by getting the address of\n-\t the array from the template.  */\n-      expr = TREE_OPERAND (expr, 0);\n-      expr = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t     build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t  TYPE_FIELDS\n-\t\t\t\t\t\t  (TREE_TYPE (expr)),\n-\t\t\t\t\t\t  false));\n-      etype = TREE_TYPE (expr);\n-      ecode = TREE_CODE (etype);\n-      break;\n+      {\n+\t/* Convert this to the type of the inner array by getting the address\n+\t   of the array from the template.  */\n+\tconst bool no_trap = TREE_THIS_NOTRAP (expr);\n+\texpr = TREE_OPERAND (expr, 0);\n+\texpr = build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t       build_component_ref (expr, NULL_TREE,\n+\t\t\t\t\t\t    TYPE_FIELDS\n+\t\t\t\t\t\t    (TREE_TYPE (expr)),\n+\t\t\t\t\t\t    false));\n+\tTREE_THIS_NOTRAP (expr) = no_trap;\n+\tetype = TREE_TYPE (expr);\n+\tecode = TREE_CODE (etype);\n+\tbreak;\n+      }\n \n     case VIEW_CONVERT_EXPR:\n       {\n@@ -3992,8 +3996,9 @@ convert (tree type, tree expr)\n \t\t     && !TYPE_IS_FAT_POINTER_P (etype))\n \t      return convert (type, op0);\n \t  }\n+\n+\tbreak;\n       }\n-      break;\n \n     default:\n       break;"}]}