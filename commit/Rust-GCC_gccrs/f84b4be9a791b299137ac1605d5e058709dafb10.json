{"sha": "f84b4be9a791b299137ac1605d5e058709dafb10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg0YjRiZTlhNzkxYjI5OTEzN2FjMTYwNWQ1ZTA1ODcwOWRhZmIxMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-23T03:17:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-23T03:17:44Z"}, "message": "Support for friend templates.\n\n\t* typeck.c (build_x_function_call): Handle static member function\n\ttemplates like non-templates.  Handle friend templates like normal\n\tfunction templates.\n\t* pt.c (tsubst, *_PARM): Don't use orig_level.\n\t(get_bindings): Don't call add_to_template_args.\n\t(instantiate_template): Likewise.\n\t(tsubst, FUNCTION_DECL): Call add_to_template_args as appropriate.\n\t* ptree.c (print_lang_type): Print index/level for template parms.\n\t* Make-lang.in (cc1plus): Note that cc1plus depends on\n\tcp/cp-tree.h and cp/cp-tree.def.\n\t* cp-tree.def (TEMPLATE_CONST_PARM): Remove.\n\t(TEMPLATE_PARM_INDEX): New tree code, used to indicate a\n\tposition in a template parameter list.\n\t* cp-tree.h (template_parm_index): New structure, used as the tree\n\tstructure for a TEMPLATE_PARM_INDEX.\n\t(TEMPLATE_PARM_IDX): New macro.\n\t(TEMPLATE_PARM_LEVEL): Likewise.\n\t(TEMPLATE_PARM_DESCENDANTS): Likewise.\n\t(TEMPLATE_PARM_ORIG_LEVEL): Likewise.\n\t(TEMPLATE_PARM_DECL): Likewise.\n\t(TEMPLATE_TYPE_PARM_INDEX): Likewise.\n\t(TEMPLATE_TYPE_ORIG_LEVEL): Likewise.\n\t(TEMPLATE_TYPE_DECL): Likewise.\n\t(TEMPLATE_CONST_IDX): Remove.\n\t(TEMPLATE_CONST_LEVEL): Likewise.\n\t(TEMPLATE_CONST_SET_INFO): Likewise.\n\t(TEMPLATE_TYPE_SET_INFO): Likewise.\n\t(TEMPLATE_TYPE_IDX): Redefine in terms of TEMPLATE_PARM_INDEX\n\tnode.\n\t(TEMPLATE_TYPE_LEVEL): Likewise.\n\t* decl.c (decls_match): Call comp_template_parms, rather than\n\texpanding it inline.\n\t(duplicate_decls): If two template declarations are being merged,\n\tthen their TEMPLATE_INFOs should be merged as well.\n\t(grokfndecl): Save template-id information when declaring a friend\n\twith explicit template arguments.  Pass arguments to\n\tcheck_explicit_specialization via correct convention; at some\n\tpoint check_explicit_specialization changed, but these call-sites\n\tdid not.\n\t(grokdeclarator): Tidy up slightly.\n\t* decl2.c (check_classfn): Tidy up slightly.  Don't assume that\n\ttwo template functions with the same DECL_ASSEMBLER_NAME the same,\n\tsince the names are not yet mangled.\n\t* error.c (dump_decl): Use TEMPLATE_PARM_INDEX instead of\n\tTEMPLATE_CONST_PARM.\n\t(dump_expr): Likewise.  Use the TEMPLATE_PARM_DECL to get at the\n\tdecl for a non-type parameter, rather than printing `<tparm ...>'.\n\t* friend.c (is_friend): Handle TEMPLATE_DECL friends.\n\t(do_friend): Deal with template friends.\n\t* lex.c (do_pending_inlines): Call\n\tmaybe_begin_member_template_processing, rather than\n\tconditionally calling begin_member_template_processing.\n\t(process_next_inline): Likewise.  Call\n\tmaybe_end_member_template_processing, rather than\n\tconditionally calling end_member_template_processing.\n\t(do_pending_defargs): Likewise.\n\t(do_identifier): Use TEMPLATE_PARM_INDEX instead of\n\tTEMPLATE_CONST_PARM.\n\t* method.c (build_mangled_template_parm_index): New function.\n\t(build_overload_value): Use it.\n\t(build_overload_name): Likewise.\n\t* pt.c (finish_member_template_decl): Allow friend declarations.\n\t(template_class_depth): New function.\n\t(is_member_template): Rename, and modify, to become...\n\t(is_member_or_friend_template): New function.\n\t(end_member_template_processing): Rename, and modify, to become...\n\t(maybe_end_member_template_processing).\n\t(build_template_parm_index): New function.\n\t(reduce_template_parm_level): New function.\n\t(process_template_parm): Modify to use build_template_parm_index.\n\t(current_template_args): Change name to current_template_parms.\n\t(push_template_decl): Deal with friend templates.\n\t(uses_template_parms): Use TEMPLATE_PARM_INDEX instead of\n\tTEMPLATE_CONST_PARM.\n\t(tsubst_friend_function): New function.\n\t(instantiate_class_template): Generate the DECL_FRIENDLIST\n\tfor a new instantiation by using tsubst_friend_function rather\n\tthan just tsubst.\n\t(tsubst): Don't tsubst into a type which is a TEMPLATE_DECL.\n\tUse TEMPLATE_PARM_INDEX instead of TEMPLATE_CONST_PARM, and the\n\tappropriate new macros.  Use reduce_template_parm_level to\n\tgenerate lower-level template parameters.  Handle tsubst'ing into\n\tTEMPLATE_DECLS that declare TEMPLATE_TEMPLATE_PARMS.  Don't forget\n\tto tsubst the DECL_CONTEXT and DECL_CLASS_CONTEXT of newly created\n\ttemplates.  Similarly for the template parameters for a new\n\ttemplate.\n\t(tsubst_copy): Tidy up slightly.  Use TEMPLATE_PARM_INDEX instead\n\tof TEMPLATE_CONST_PARM.  Handle TYPE_DECLs by tsubsting into them.\n\t(unify): Use TEMPLATE_PARM_INDEX instead of TEMPLATE_CONST_PARM.\n\t(get_bindings): Call add_to_template_args if necessary.\n\t(instantiate_decl): Handle instantiations of friend templates.\n\t* search.c (lookup_field_1): Don't treat the TYPE_FIELDS of a\n\tTEMPLATE_TYPE_PARM as a list of fields; it's not!\n\t* spew.c (yylex): Do a little manual constant propogation to\n\tclarify the code.\n\nFrom-SVN: r18198", "tree": {"sha": "03d3aed775399d8bc5b211c2fa92f2b85529d876", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03d3aed775399d8bc5b211c2fa92f2b85529d876"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f84b4be9a791b299137ac1605d5e058709dafb10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84b4be9a791b299137ac1605d5e058709dafb10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84b4be9a791b299137ac1605d5e058709dafb10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84b4be9a791b299137ac1605d5e058709dafb10/comments", "author": null, "committer": null, "parents": [{"sha": "9e89df5017523643d7b6a5c44369bd677f909011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e89df5017523643d7b6a5c44369bd677f909011", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e89df5017523643d7b6a5c44369bd677f909011"}], "stats": {"total": 1204, "additions": 874, "deletions": 330}, "files": [{"sha": "beb54a2da118ba41df4b2a0905549e53fbec8f73", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -1,3 +1,105 @@\n+Mon Feb 23 03:04:14 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_x_function_call): Handle static member function\n+\ttemplates like non-templates.  Handle friend templates like normal\n+\tfunction templates.\n+\t* pt.c (tsubst, *_PARM): Don't use orig_level.\n+\t(get_bindings): Don't call add_to_template_args.\n+\t(instantiate_template): Likewise.\n+\t(tsubst, FUNCTION_DECL): Call add_to_template_args as appropriate.\n+\t* ptree.c (print_lang_type): Print index/level for template parms.\n+\n+Mon Feb 23 02:52:29 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* Make-lang.in (cc1plus): Note that cc1plus depends on\n+\tcp/cp-tree.h and cp/cp-tree.def.\n+\t\n+\t* cp-tree.def (TEMPLATE_CONST_PARM): Remove.\n+\t(TEMPLATE_PARM_INDEX): New tree code, used to indicate a\n+\tposition in a template parameter list.\n+\t* cp-tree.h (template_parm_index): New structure, used as the tree\n+\tstructure for a TEMPLATE_PARM_INDEX.\n+\t(TEMPLATE_PARM_IDX): New macro.\n+\t(TEMPLATE_PARM_LEVEL): Likewise.\n+\t(TEMPLATE_PARM_DESCENDANTS): Likewise.\n+\t(TEMPLATE_PARM_ORIG_LEVEL): Likewise.\n+\t(TEMPLATE_PARM_DECL): Likewise.\n+\t(TEMPLATE_TYPE_PARM_INDEX): Likewise.\n+\t(TEMPLATE_TYPE_ORIG_LEVEL): Likewise.\n+\t(TEMPLATE_TYPE_DECL): Likewise.\n+\t(TEMPLATE_CONST_IDX): Remove.\n+\t(TEMPLATE_CONST_LEVEL): Likewise.\n+\t(TEMPLATE_CONST_SET_INFO): Likewise.\n+\t(TEMPLATE_TYPE_SET_INFO): Likewise.\n+\t(TEMPLATE_TYPE_IDX): Redefine in terms of TEMPLATE_PARM_INDEX\n+\tnode.\n+\t(TEMPLATE_TYPE_LEVEL): Likewise.\n+\t* decl.c (decls_match): Call comp_template_parms, rather than\n+\texpanding it inline.\n+\t(duplicate_decls): If two template declarations are being merged,\n+\tthen their TEMPLATE_INFOs should be merged as well.\n+\t(grokfndecl): Save template-id information when declaring a friend\n+\twith explicit template arguments.  Pass arguments to\n+\tcheck_explicit_specialization via correct convention; at some\n+\tpoint check_explicit_specialization changed, but these call-sites\n+\tdid not.\n+\t(grokdeclarator): Tidy up slightly.\n+\t* decl2.c (check_classfn): Tidy up slightly.  Don't assume that\n+\ttwo template functions with the same DECL_ASSEMBLER_NAME the same,\n+\tsince the names are not yet mangled.\n+\t* error.c (dump_decl): Use TEMPLATE_PARM_INDEX instead of\n+\tTEMPLATE_CONST_PARM. \n+\t(dump_expr): Likewise.  Use the TEMPLATE_PARM_DECL to get at the\n+\tdecl for a non-type parameter, rather than printing `<tparm ...>'.\n+\t* friend.c (is_friend): Handle TEMPLATE_DECL friends.\n+\t(do_friend): Deal with template friends.\n+\t* lex.c (do_pending_inlines): Call\n+\tmaybe_begin_member_template_processing, rather than\n+\tconditionally calling begin_member_template_processing.\n+\t(process_next_inline): Likewise.  Call\n+\tmaybe_end_member_template_processing, rather than\n+\tconditionally calling end_member_template_processing.\n+\t(do_pending_defargs): Likewise.\n+\t(do_identifier): Use TEMPLATE_PARM_INDEX instead of\n+\tTEMPLATE_CONST_PARM.  \n+\t* method.c (build_mangled_template_parm_index): New function.\n+\t(build_overload_value): Use it.\n+\t(build_overload_name): Likewise.\n+\t* pt.c (finish_member_template_decl): Allow friend declarations.\n+\t(template_class_depth): New function.\n+\t(is_member_template): Rename, and modify, to become...\n+\t(is_member_or_friend_template): New function.\n+\t(end_member_template_processing): Rename, and modify, to become...\n+\t(maybe_end_member_template_processing).\n+\t(build_template_parm_index): New function.\n+\t(reduce_template_parm_level): New function.\n+\t(process_template_parm): Modify to use build_template_parm_index.\n+\t(current_template_args): Change name to current_template_parms.\n+\t(push_template_decl): Deal with friend templates.\n+\t(uses_template_parms): Use TEMPLATE_PARM_INDEX instead of\n+\tTEMPLATE_CONST_PARM.\n+\t(tsubst_friend_function): New function.\n+\t(instantiate_class_template): Generate the DECL_FRIENDLIST\n+\tfor a new instantiation by using tsubst_friend_function rather\n+\tthan just tsubst.\n+\t(tsubst): Don't tsubst into a type which is a TEMPLATE_DECL.\n+\tUse TEMPLATE_PARM_INDEX instead of TEMPLATE_CONST_PARM, and the\n+\tappropriate new macros.  Use reduce_template_parm_level to\n+\tgenerate lower-level template parameters.  Handle tsubst'ing into\n+\tTEMPLATE_DECLS that declare TEMPLATE_TEMPLATE_PARMS.  Don't forget\n+\tto tsubst the DECL_CONTEXT and DECL_CLASS_CONTEXT of newly created\n+\ttemplates.  Similarly for the template parameters for a new\n+\ttemplate.\n+\t(tsubst_copy): Tidy up slightly.  Use TEMPLATE_PARM_INDEX instead\n+\tof TEMPLATE_CONST_PARM.  Handle TYPE_DECLs by tsubsting into them.\n+\t(unify): Use TEMPLATE_PARM_INDEX instead of TEMPLATE_CONST_PARM.  \n+\t(get_bindings): Call add_to_template_args if necessary.\n+\t(instantiate_decl): Handle instantiations of friend templates.\n+\t* search.c (lookup_field_1): Don't treat the TYPE_FIELDS of a\n+\tTEMPLATE_TYPE_PARM as a list of fields; it's not!\n+\t* spew.c (yylex): Do a little manual constant propogation to\n+\tclarify the code.\n+\t\n Sun Feb 22 19:53:29 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* error.c: Include sys/types.h."}, {"sha": "6ed167830c8478cb6aeb2fe916ff40475fb93da9", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -124,7 +124,8 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/parse.y $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c \\\n  $(srcdir)/cp/repo.c\n \n-cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o\n+cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o \\\n+\t$(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def\n \tcd cp; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus\n #\f\n # Build hooks:"}, {"sha": "74d64412cb8a6e0164cc9c57da0561d4a72cd42c", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -87,23 +87,60 @@ DEFTREECODE (VEC_INIT_EXPR, \"vec_init_expr\", 'e', 3)\n  */\n DEFTREECODE (TEMPLATE_DECL, \"template_decl\", 'd', 0)\n \n+/* Index into a template parameter list.  The TEMPLATE_PARM_IDX gives\n+   the index (from 0) of the parameter, while the TEMPLATE_PARM_LEVEL\n+   gives the level (from 1) of the parameter.\n+\n+   Here's an example:\n+   \n+   template <class T> // Index 0, Level 1.\n+   struct S\n+   {\n+      template <class U, // Index 0, Level 2.\n+                class V> // Index 1, Level 2.\n+      void f();\n+   };  \n+\n+   The DESCENDANTS will be a chain of TEMPLATE_PARM_INDEXs descended\n+   from this one.  The first descendant will have the same IDX, but\n+   its LEVEL will be one less.  The TREE_CHAIN field is used to chain\n+   together the descendants.  The TEMPLATE_PARM_DECL is the\n+   declaration of this parameter, either a TYPE_DECL or CONST_DECL.\n+   The TEMPLATE_PARM_ORIG_LEVEL is the LEVEL of the most distant\n+   parent, i.e., the LEVEL that the parameter originally had when it\n+   was declared.  For example, if we instantiate S<int>, we will have:\n+\n+   struct S<int>\n+   {\n+     template <class U, // Index 0, Level 1, Orig Level 2\n+               class V> // Index 1, Level 1, Orig Level 2\n+     void f();\n+   };\n+  \n+   The LEVEL is the level of the parameter when we are worrying about\n+   the types of things; the ORIG_LEVEL is the level when we are\n+   worrying about instantiating things.  */\n+DEFTREECODE (TEMPLATE_PARM_INDEX, \"template_parm_index\", 'c', \n+\t     /* The addition of (sizeof(char*) - 1) in the next\n+\t\texpression is to ensure against the case where\n+\t\tsizeof(char*) does not evenly divide\n+\t\tsizeof(HOST_WIDE_INT).  */\n+\t     2 + ((3 * sizeof (HOST_WIDE_INT) + sizeof(char*) - 1)\n+\t\t  / sizeof (char*)))\n+\n /* Index into a template parameter list.  This parameter must be a type.\n-   Use TYPE_FIELDS to find parmlist and index.  */\n+   The TYPE_FIELDS value will be a TEMPLATE_PARM_INDEX.  */\n DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", 't', 0)\n \n /* Index into a template parameter list.  This parameter must be a type.\n    If it is used in signature of a template, TEMPLATE_INFO is NULL_TREE.\n    Otherwise it is used to declare a type like TT<int>.\n-   Use TYPE_FIELDS to find parmlist and index.  */\n+   The TYPE_FIELDS value will be a TEMPLATE_PARM_INDEX.  */\n DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", 't', 0)\n \n /* A type designated by 'typename T::t'. */\n DEFTREECODE (TYPENAME_TYPE, \"typename_type\", 't', 0)\n \n-/* Index into a template parameter list.  This parameter must not be a\n-   type.  */\n-DEFTREECODE (TEMPLATE_CONST_PARM, \"template_const_parm\", 'c', 3)\n-\n /* A thunk is a stub function.\n \n    Thunks are used to implement multiple inheritance:\n@@ -179,3 +216,9 @@ DEFTREECODE (AMBIG_CONV, \"ambig_conv\", 'e', 1)\n DEFTREECODE (RVALUE_CONV, \"rvalue_conv\", 'e', 1)\n \n DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n+\n+/*\n+Local variables:\n+mode:c\n+End:\n+*/"}, {"sha": "de6384944d199a96fd732d749579d28938f87329", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -47,6 +47,17 @@ typedef struct\n   int new_type_flag;\n } flagged_type_tree;\n \n+typedef struct \n+{\n+  char common[sizeof (struct tree_common)];\n+  struct rtx_def *rtl;\t/* Unused, but required to match up with what\n+\t\t\t   the middle-end expects.  */\n+  HOST_WIDE_INT index;\n+  HOST_WIDE_INT level;\n+  HOST_WIDE_INT orig_level;\n+  tree decl;\n+} template_parm_index;\n+\n /* To identify to the debug emitters if it should pay attention to the\n    flag `-Wtemplate-debugging'.  */\n #define HAVE_TEMPLATES 1\n@@ -1340,6 +1351,18 @@ extern int flag_new_for_scope;\n #define TYPE_WAS_ANONYMOUS(NODE) (TYPE_LANG_SPECIFIC (NODE)->type_flags.was_anonymous)\n \n /* C++: all of these are overloaded!  These apply only to TYPE_DECLs.  */\n+\n+/* The format of each node in the DECL_FRIENDLIST is as follows:\n+\n+   The TREE_PURPOSE will be the name of a function, i.e., an\n+   IDENTIFIER_NODE.  The TREE_VALUE will be itself a TREE_LIST, the\n+   list of functions with that name which are friends.  The\n+   TREE_PURPOSE of each node in this sublist will be error_mark_node,\n+   if the function was declared a friend individually, in which case\n+   the TREE_VALUE will be the function_decl.  If, however, all\n+   functions with a given name in a class were declared to be friends,\n+   the TREE_PUROSE will be the class type, and the TREE_VALUE will be\n+   NULL_TREE.  */\n #define DECL_FRIENDLIST(NODE)\t\t(DECL_INITIAL (NODE))\n \n /* The DECL_ACCESS is used to record under which context\n@@ -1352,6 +1375,17 @@ extern int flag_new_for_scope;\n #define SET_DECL_REFERENCE_SLOT(NODE,VAL) ((NODE)->decl.arguments=VAL)\n \n /* Accessor macros for C++ template decl nodes.  */\n+\n+/* The DECL_TEMPLATE_PARMS are a list.  The TREE_PURPOSE of each node\n+   indicates the level of the template parameters, with 1 being the\n+   outermost set of template parameters.  The TREE_VALUE is a vector,\n+   whose elements are the template parameters at each level.  Each\n+   element in the vector is a TREE_LIST, whose TREE_VALUE is a\n+   PARM_DECL (if the parameter is a non-type parameter), or a\n+   TYPE_DECL (if the parameter is a type parameter).  The TREE_PURPOSE\n+   is the default value, if any.  The TEMPLATE_PARM_INDEX for the\n+   parameter is avilable as the DECL_INITIAL (for a PARM_DECL) or as\n+   the TREE_TYPE (for a TYPE_DECL).  */\n #define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n #define DECL_INNERMOST_TEMPLATE_PARMS(NODE) \\\n    INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (NODE))\n@@ -1374,6 +1408,12 @@ extern int flag_new_for_scope;\n   (TREE_CODE (NODE) == TEMPLATE_DECL \\\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == FUNCTION_DECL)\n \n+/* A `primary' template is one which depends on no tbemplate parameters\n+   except those specified in its parameter list.  So, a template\n+   member of a non-template class is primary, and every global\n+   function template is primary, but a member function of a template\n+   class is not primary, neither is a member template of a template\n+   class.  */\n #define PRIMARY_TEMPLATE_P(NODE) \\\n   (TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)) == (NODE))\n \n@@ -1934,24 +1974,27 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n \n #define WANT_ARITH\t(WANT_INT | WANT_FLOAT)\n \n-/* Anatomy of a DECL_FRIENDLIST (which is a TREE_LIST):\n-   purpose = friend name (IDENTIFIER_NODE);\n-   value = TREE_LIST of FUNCTION_DECLS;\n-   chain, type = EMPTY;  */\n #define FRIEND_NAME(LIST) (TREE_PURPOSE (LIST))\n #define FRIEND_DECLS(LIST) (TREE_VALUE (LIST))\n \n+/* These macros are used to access a TEMPLATE_PARM_INDEX.  */\n+#define TEMPLATE_PARM_IDX(NODE) (((template_parm_index*) NODE)->index)\n+#define TEMPLATE_PARM_LEVEL(NODE) (((template_parm_index*) NODE)->level)\n+#define TEMPLATE_PARM_DESCENDANTS(NODE) (TREE_CHAIN (NODE))\n+#define TEMPLATE_PARM_ORIG_LEVEL(NODE) (((template_parm_index*) NODE)->orig_level)\n+#define TEMPLATE_PARM_DECL(NODE) (((template_parm_index*) NODE)->decl)\n+\n /* These macros are for accessing the fields of TEMPLATE_TYPE_PARM \n    and TEMPLATE_TEMPLATE_PARM nodes.  */\n-#define TEMPLATE_TYPE_IDX(NODE) TREE_INT_CST_LOW (TYPE_FIELDS (NODE))\n-#define TEMPLATE_TYPE_LEVEL(NODE) TREE_INT_CST_HIGH (TYPE_FIELDS (NODE))\n-#define TEMPLATE_TYPE_SET_INFO(NODE,I,L) \\\n-  (TYPE_FIELDS (NODE) = build_int_2 (I, L))\n-/* These macros are for accessing the fields of TEMPLATE_CONST_PARM nodes.  */\n-#define TEMPLATE_CONST_IDX(NODE) (TREE_INT_CST_LOW(NODE))\n-#define TEMPLATE_CONST_LEVEL(NODE) (TREE_INT_CST_HIGH(NODE))\n-#define TEMPLATE_CONST_SET_INFO(NODE,I,L) \\\n-  (TEMPLATE_CONST_IDX (NODE) = I, TEMPLATE_CONST_LEVEL (NODE) = L)\n+#define TEMPLATE_TYPE_PARM_INDEX(NODE) (TYPE_FIELDS (NODE))\n+#define TEMPLATE_TYPE_IDX(NODE) \\\n+  (TEMPLATE_PARM_IDX (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n+#define TEMPLATE_TYPE_LEVEL(NODE) \\\n+  (TEMPLATE_PARM_LEVEL (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n+#define TEMPLATE_TYPE_ORIG_LEVEL(NODE) \\\n+  (TEMPLATE_PARM_ORIG_LEVEL (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n+#define TEMPLATE_TYPE_DECL(NODE) \\\n+  (TEMPLATE_PARM_DECL (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n \n /* in lex.c  */\n /* Indexed by TREE_CODE, these tables give C-looking names to\n@@ -2336,8 +2379,8 @@ extern tree tsubst\t\t\t\tPROTO ((tree, tree, int, tree));\n extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, int, tree));\n extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, int, tree));\n extern tree tsubst_chain\t\t\tPROTO((tree, tree));\n-extern void begin_member_template_processing    PROTO((tree));\n-extern void end_member_template_processing      PROTO((void));\n+extern void maybe_begin_member_template_processing PROTO((tree));\n+extern void maybe_end_member_template_processing PROTO((tree));\n extern tree finish_member_template_decl         PROTO((tree, tree));\n extern void begin_template_parm_list\t\tPROTO((void));\n extern void begin_specialization                PROTO((void));\n@@ -2382,6 +2425,7 @@ extern int more_specialized_class\t\tPROTO((tree, tree));\n extern void do_pushlevel\t\t\tPROTO((void));\n extern int is_member_template                   PROTO((tree));\n extern int comp_template_parms                  PROTO((tree, tree));\n+extern int template_class_depth                 PROTO((tree));\n extern int processing_specialization;\n extern int processing_explicit_instantiation;\n "}, {"sha": "d05c493632897dd44547511972373a1732cd7d32", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 50, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -2311,47 +2311,15 @@ decls_match (newdecl, olddecl)\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL\n \t   && TREE_CODE (olddecl) == TEMPLATE_DECL)\n     {\n-\ttree newargs = DECL_TEMPLATE_PARMS (newdecl);\n-\ttree oldargs = DECL_TEMPLATE_PARMS (olddecl);\n-\tint i;\n-\n-\t/* Run through all the levels of template parameters, checking\n-\t   that they match.  */\n-\twhile (newargs && oldargs) \n-\t  {\n-\t    int len = TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS (newargs));\n-\n-\t    if (TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS (oldargs)) != len)\n-\t      return 0;\n-\t    \n-\t    for (i = 0; i < len; i++)\n-\t      {\n-\t\ttree newarg = \n-\t\t  TREE_VALUE (TREE_VEC_ELT \n-\t\t\t      (INNERMOST_TEMPLATE_PARMS (newargs), i));\n-\t\ttree oldarg = \n-\t\t  TREE_VALUE (TREE_VEC_ELT \n-\t\t\t      (INNERMOST_TEMPLATE_PARMS (oldargs), i));\n-\t\tif (TREE_CODE (newarg) != TREE_CODE (oldarg))\n-\t\t  return 0;\n-\t\telse if (TREE_CODE (newarg) == TYPE_DECL)\n-\t\t  /* continue */;\n-\t\telse if (! comptypes (TREE_TYPE (newarg), TREE_TYPE (oldarg), 1))\n-\t\t  return 0;\n-\t      }\n-\t    newargs = TREE_CHAIN (newargs);\n-\t    oldargs = TREE_CHAIN (oldargs);\n-\t  }\n-\n-\tif ((newargs == NULL_TREE) != (oldargs == NULL_TREE))\n-\t  /* One declaration has more levels that the other. */\n-\t  return 0;\n-\n-\tif (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n-\t  types_match = 1;\n-\telse\n-\t  types_match = decls_match (DECL_TEMPLATE_RESULT (olddecl),\n-\t\t\t\t     DECL_TEMPLATE_RESULT (newdecl));\n+      if (!comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n+\t\t\t\tDECL_TEMPLATE_PARMS (olddecl)))\n+\treturn 0;\n+      \n+      if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n+\ttypes_match = 1;\n+      else\n+\ttypes_match = decls_match (DECL_TEMPLATE_RESULT (olddecl),\n+\t\t\t\t   DECL_TEMPLATE_RESULT (newdecl));\n     }\n   else\n     {\n@@ -2760,6 +2728,7 @@ duplicate_decls (newdecl, olddecl)\n \t    cp_error (\"invalid redeclaration of %D\", newdecl);\n \t  TREE_TYPE (olddecl) = TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl));\n \t  DECL_TEMPLATE_PARMS (olddecl) = DECL_TEMPLATE_PARMS (newdecl);\n+\t  DECL_TEMPLATE_INFO (olddecl) = DECL_TEMPLATE_INFO (newdecl);\n \t}\n       return 1;\n     }\n@@ -4504,7 +4473,10 @@ make_implicit_typename (context, t)\n \n    If PREFER_TYPE is > 0, we prefer TYPE_DECLs.\n    If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)\n-   Otherwise we prefer non-TYPE_DECLs.  */\n+   Otherwise we prefer non-TYPE_DECLs.  \n+\n+   If NONCLASS is non-zero, we don't look for the NAME in class scope,\n+   using IDENTIFIER_CLASS_VALUE.  */\n \n static tree\n lookup_name_real (name, prefer_type, nonclass)\n@@ -7461,8 +7433,15 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n   if (friendp && \n       TREE_CODE (orig_declarator) == TEMPLATE_ID_EXPR)\n-    /* A friend declaration of the form friend void f<>().  */\n-    SET_DECL_IMPLICIT_INSTANTIATION (decl);\n+    {\n+      /* A friend declaration of the form friend void f<>().  Record\n+\t the information in the TEMPLATE_ID_EXPR.  */\n+      SET_DECL_IMPLICIT_INSTANTIATION (decl);\n+      DECL_TEMPLATE_INFO (decl) \n+\t= perm_tree_cons (TREE_OPERAND (orig_declarator, 0),\n+\t\t\t  TREE_OPERAND (orig_declarator, 1),\n+\t\t\t  NULL_TREE);\n+    }\n \n   /* Caller will do the rest of this.  */\n   if (check < 0)\n@@ -7485,8 +7464,8 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n       decl = check_explicit_specialization (orig_declarator, decl,\n \t\t\t\t\t    template_count, \n-\t\t\t\t\t    funcdef_flag ? 2 : \n-\t\t\t\t\t    (friendp ? 3 : 0));\n+\t\t\t\t\t    2 * (funcdef_flag != 0) + \n+\t\t\t\t\t    4 * (friendp != 0));\n \n       if (check)\n \t{\n@@ -7532,8 +7511,8 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n       decl = check_explicit_specialization (orig_declarator, decl,\n \t\t\t\t\t    template_count, \n-\t\t\t\t\t    funcdef_flag ? 2 : \n-\t\t\t\t\t    (friendp ? 3 : 0));\n+\t\t\t\t\t    2 * (funcdef_flag != 0) + \n+\t\t\t\t\t    4 * (friendp != 0));\n \n       if (ctype != NULL_TREE && check)\n \t{\n@@ -7952,10 +7931,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t\tif (TREE_CODE (fns) == IDENTIFIER_NODE)\n \t\t  dname = fns;\n-\t\telse if (really_overloaded_fn (fns))\n+\t\telse if (is_overloaded_fn (fns))\n \t\t  dname = DECL_NAME (get_first_fn (fns));\n \t\telse\n-\t\t  dname = DECL_NAME (fns);\n+\t\t  my_friendly_abort (0);\n \t      }\n \t  /* fall through */\n "}, {"sha": "c847a2782b564989b3d9ec041c5d8f2f689f757b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -1431,19 +1431,22 @@ check_classfn (ctype, function)\n \t  if (fn_name == DECL_NAME (*methods))\n \t    {\n \t    got_it:\n-\t      fndecl = *methods;\n-\t      while (fndecl)\n+\t      for (fndecl = *methods; fndecl != NULL_TREE;\n+\t\t   fndecl = DECL_CHAIN (fndecl))\n \t\t{\n-\t\t  if (DECL_ASSEMBLER_NAME (function) == DECL_ASSEMBLER_NAME (fndecl))\n+\t\t  /* The DECL_ASSEMBLER_NAME for a TEMPLATE_DECL is\n+\t\t     not mangled, so the check below does not work\n+\t\t     correctly in that case.  */\n+\t\t  if (TREE_CODE (function) != TEMPLATE_DECL\n+\t\t      && TREE_CODE (fndecl) != TEMPLATE_DECL\n+\t\t      && (DECL_ASSEMBLER_NAME (function) \n+\t\t\t  == DECL_ASSEMBLER_NAME (fndecl)))\n \t\t    return fndecl;\n-#if 0\n-\t\t  /* This doesn't work for static member functions that are\n-                     pretending to be methods.  */\n-\t\t  /* We have to do more extensive argument checking here, as\n-\t\t     the name may have been changed by asm(\"new_name\").  */\n-\t\t  if (decls_match (function, fndecl))\n-\t\t    return fndecl;\n-#else\n+\n+\t\t  /* We cannot simply call decls_match because this\n+\t\t     doesn't work for static member functions that are \n+                     pretending to be methods, and because the name\n+\t\t     may have been changed by asm(\"new_name\").  */ \n \t\t  if (DECL_NAME (function) == DECL_NAME (fndecl))\n \t\t    {\n \t\t      tree p1 = TYPE_ARG_TYPES (TREE_TYPE (function));\n@@ -1471,8 +1474,6 @@ check_classfn (ctype, function)\n \t\t\ttemplates = \n \t\t\t  scratch_tree_cons (NULL_TREE, fndecl, templates);\n \t\t    }\n-#endif\n-\t\t  fndecl = DECL_CHAIN (fndecl);\n \t\t}\n \t      break;\t\t/* loser */\n \t    }"}, {"sha": "04517814a6928aca358572451aac099488f9d9f7", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -856,7 +856,7 @@ dump_decl (t, v)\n     case CONST_DECL:\n       if ((TREE_TYPE (t) != NULL_TREE && NEXT_CODE (t) == ENUMERAL_TYPE)\n \t  || (DECL_INITIAL (t) &&\n-\t      TREE_CODE (DECL_INITIAL (t)) == TEMPLATE_CONST_PARM))\n+\t      TREE_CODE (DECL_INITIAL (t)) == TEMPLATE_PARM_INDEX))\n \tgoto general;\n       else if (DECL_NAME (t))\n \tdump_decl (DECL_NAME (t), v);\n@@ -1527,33 +1527,12 @@ dump_expr (t, nop)\n \tbreak;\n       }\n \n-    case TEMPLATE_CONST_PARM:\n+    case TEMPLATE_PARM_INDEX:\n       {\n \tint l = current_template_parms ? \n \t  list_length (current_template_parms) : 0;\n \n-\tif (l >= TEMPLATE_CONST_LEVEL (t))\n-\t  {\n-\t    int i;\n-\t    tree parms = current_template_parms;\n-\t    tree r;\n-\t    \n-\t    for (i = 0; i < l - TEMPLATE_CONST_LEVEL (t); ++i)\n-\t      {\n-\t\tparms = TREE_CHAIN (parms);\n-\t\tmy_friendly_assert (parms != NULL_TREE, 0);\n-\t      }\n-\t    \n-\t    r = TREE_VEC_ELT (TREE_VALUE (parms),\n-\t\t\t      TEMPLATE_CONST_IDX (t));\n-\t    dump_decl (TREE_VALUE (r), -1);\n-\t  }\n-\telse\n-\t  {\n-\t    OB_PUTS (\"<tparm \");\n-\t    OB_PUTI (TEMPLATE_CONST_IDX (t));\n-\t    OB_PUTS (\">\");\n-\t  }\n+\tdump_decl (TEMPLATE_PARM_DECL (t), -1);\n       }\n       break;\n "}, {"sha": "f28e049cfa4b46f1b44579cdf1a9310085822ad6", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -33,22 +33,7 @@ Boston, MA 02111-1307, USA.  */\n static void add_friend PROTO((tree, tree));\n static void add_friends PROTO((tree, tree, tree));\n \n-/* Friend data structures:\n-\n-   Lists of friend functions come from TYPE_DECL nodes.  Since all\n-   aggregate types are automatically typedef'd, these nodes are guaranteed\n-   to exist.\n-\n-   The TREE_PURPOSE of a friend list is the name of the friend,\n-   and its TREE_VALUE is another list.\n-\n-   For each element of that list, either the TREE_VALUE or the TREE_PURPOSE\n-   will be filled in, but not both.  The TREE_VALUE of that list is an\n-   individual function which is a friend.  The TREE_PURPOSE of that list\n-   indicates a type in which all functions by that name are friends.\n-\n-   Lists of friend classes come from _TYPE nodes.  Love that consistency\n-   thang.  */\n+/* Friend data structures are described in cp-tree.h.  */\n \n int\n is_friend (type, supplicant)\n@@ -83,6 +68,31 @@ is_friend (type, supplicant)\n \t\t{\n \t\t  if (ctype == TREE_PURPOSE (friends))\n \t\t    return 1;\n+\n+\t\t  if (TREE_VALUE (friends) == NULL_TREE)\n+\t\t    continue;\n+\n+\t\t  if (TREE_CODE (TREE_VALUE (friends)) == TEMPLATE_DECL)\n+\t\t    {\n+\t\t      tree t;\n+\n+\t\t      /* Perhaps this function is a specialization of\n+\t\t\t a friend template.  */\n+\t\t      for (t = supplicant;\n+\t\t\t   t != NULL_TREE;\n+\t\t\t   t = DECL_TEMPLATE_INFO (t) ? \n+\t\t\t     DECL_TI_TEMPLATE (t) : NULL_TREE)\n+\t\t\t/* FIXME: The use of comptypes here, and below, is\n+\t\t\t   bogus, since two specializations of a\n+\t\t\t   template parameter with non-type parameters\n+\t\t\t   may have the same type, but be different.  */\n+\t\t\tif (comptypes (TREE_TYPE (t),\n+\t\t\t\t       TREE_TYPE (TREE_VALUE (friends)), 1))\n+\t\t\t  return 1;\n+\n+\t\t      continue;\n+\t\t    }\n+\n \t\t  if (comptypes (TREE_TYPE (supplicant),\n \t\t\t\t TREE_TYPE (TREE_VALUE (friends)), 1))\n \t\t    return 1;\n@@ -302,9 +312,15 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n      tree quals;\n      int funcdef_flag;\n {\n+  int is_friend_template = 0;\n+\n   /* Every decl that gets here is a friend of something.  */\n   DECL_FRIEND_P (decl) = 1;\n \n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    is_friend_template = processing_template_decl >\n+      template_class_depth (current_class_type);\n+\n   if (ctype)\n     {\n       tree cname = TYPE_NAME (ctype);\n@@ -319,18 +335,21 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \n \t  /* This will set up DECL_ARGUMENTS for us.  */\n \t  grokclassfn (ctype, cname, decl, flags, quals);\n-\t  if (TYPE_SIZE (ctype) != 0)\n+\n+\t  if (is_friend_template)\n+\t    decl = DECL_TI_TEMPLATE (push_template_decl (decl));\n+\n+\t  if (TYPE_SIZE (ctype) != 0 \n+\t      && template_class_depth (ctype) == 0)\n \t    decl = check_classfn (ctype, decl);\n \n \t  if (TREE_TYPE (decl) != error_mark_node)\n \t    {\n-\t      if (TYPE_SIZE (ctype))\n+\t      if (TYPE_SIZE (ctype) || template_class_depth (ctype) > 0)\n \t\tadd_friend (current_class_type, decl);\n \t      else\n-\t\t{\n-\t\t  cp_error (\"member `%D' declared as friend before type `%T' defined\",\n-\t\t\t    decl, ctype);\n-\t\t}\n+\t\tcp_error (\"member `%D' declared as friend before type `%T' defined\",\n+\t\t\t  decl, ctype);\n \t    }\n \t}\n       else\n@@ -386,10 +405,21 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t{\n \t  /* We can call pushdecl here, because the TREE_CHAIN of this\n \t     FUNCTION_DECL is not needed for other purposes.  Don't do this\n-\t     for a template instantiation. */\n-\t  decl = pushdecl (decl);\n+\t     for a template instantiation.  */\n+\t  if (!is_friend_template)\n+\t    {  \n+\t      /* However, we don't call pushdecl() for a friend\n+\t\t function of a template class, since in general,\n+\t\t such a declaration depends on template\n+\t\t parameters.  Instead, we call pushdecl when the\n+\t\t class is instantiated.  */\n+\t      if (template_class_depth (current_class_type) == 0)\n+\t\tdecl = pushdecl (decl);\n+\t    }\n+\t  else \n+\t    decl = push_template_decl (decl); \n \n-\t  if (! funcdef_flag && ! flag_guiding_decls\n+\t  if (! funcdef_flag && ! flag_guiding_decls && ! is_friend_template\n \t      && current_template_parms && uses_template_parms (decl))\n \t    {\n \t      static int explained;\n@@ -405,8 +435,8 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t}\n \n       make_decl_rtl (decl, NULL_PTR, 1);\n-      add_friend (current_class_type, decl);\n-\n+      add_friend (current_class_type, \n+\t\t  is_friend_template ? DECL_TI_TEMPLATE (decl) : decl);\n       DECL_FRIEND_P (decl) = 1;\n     }\n   else"}, {"sha": "cf9aaa9a12d9a961caeaf584a6dd88e27dedb68f", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -1684,14 +1684,14 @@ as a @samp{Z} followed by the encoding of the type.\n \n A function template specialization (either an instantiation or an\n explicit specialization) is encoded by an @samp{H} followed by the\n-encoding of the template parameters, as described above, followed by \n-an @samp{_}, the encoding of the argument types template function (not the\n-specialization), another @samp{_}, and the return type.  (Like the\n-argument types, the return type is the return type of the function\n+encoding of the template parameters, as described above, followed by an\n+@samp{_}, the encoding of the argument types to the template function\n+(not the specialization), another @samp{_}, and the return type.  (Like\n+the argument types, the return type is the return type of the function\n template, not the specialization.)  Template parameters in the argument\n and return types are encoded by an @samp{X} for type parameters, or a\n-@samp{Y} for constant parameters, and an index indicating their position\n-in the template parameter list declaration.\n+@samp{Y} for constant parameters, an index indicating their position\n+in the template parameter list declaration, and their template depth.\n \n @subsection Arrays\n "}, {"sha": "8d6d62229c501028528014ed8b90cdb4f387a934", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -1213,8 +1213,7 @@ do_pending_inlines ()\n   context = hack_decl_function_context (t->fndecl);\n   if (context)\n     push_cp_function_context (context);\n-  if (is_member_template (t->fndecl))\n-    begin_member_template_processing (t->fndecl);\n+  maybe_begin_member_template_processing (t->fndecl);\n   if (t->len > 0)\n     {\n       feed_input (t->buf, t->len);\n@@ -1252,8 +1251,7 @@ process_next_inline (t)\n   tree context;\n   struct pending_inline *i = (struct pending_inline *) TREE_PURPOSE (t);\n   context = hack_decl_function_context (i->fndecl);  \n-  if (is_member_template (i->fndecl))\n-    end_member_template_processing ();\n+  maybe_end_member_template_processing (i->fndecl);\n   if (context)\n     pop_cp_function_context (context);\n   i = i->next;\n@@ -1276,8 +1274,7 @@ process_next_inline (t)\n       context = hack_decl_function_context (i->fndecl);\n       if (context)\n \tpush_cp_function_context (context);\n-      if (is_member_template (i->fndecl))\n-\tbegin_member_template_processing (i->fndecl);\n+      maybe_begin_member_template_processing (i->fndecl);\n       feed_input (i->buf, i->len);\n       lineno = i->lineno;\n       input_filename = i->filename;\n@@ -1891,8 +1888,7 @@ do_pending_defargs ()\n \t{\n \t  push_nested_class (TREE_PURPOSE (defarg_fns), 1);\n \t  pushlevel (0);\n-\t  if (is_member_template (defarg_fn))\n-\t    begin_member_template_processing (defarg_fn);\n+\t  maybe_begin_member_template_processing (defarg_fn);\n \n \t  if (TREE_CODE (defarg_fn) == FUNCTION_DECL)\n \t    {\n@@ -1920,8 +1916,7 @@ do_pending_defargs ()\n \t    return;\n \t  }\n \n-      if (is_member_template (defarg_fn))\n-\tend_member_template_processing ();\n+      maybe_end_member_template_processing (defarg_fn);\n       poplevel (0, 0, 0);\n       pop_nested_class (1);\n     }\n@@ -2946,7 +2941,7 @@ do_identifier (token, parsing)\n \t}\n       if (! processing_template_decl\n \t  || (DECL_INITIAL (id)\n-\t      && TREE_CODE (DECL_INITIAL (id)) == TEMPLATE_CONST_PARM))\n+\t      && TREE_CODE (DECL_INITIAL (id)) == TEMPLATE_PARM_INDEX))\n \tid = DECL_INITIAL (id);\n     }\n   else"}, {"sha": "8be513b982889826dac6c2bfd771e92a0bc241cf", "filename": "gcc/cp/method.c", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -602,6 +602,24 @@ build_overload_int (value, in_template)\n   icat (TREE_INT_CST_LOW (value));\n }\n \n+\n+/* Output S followed by a representation of the TEMPLATE_PARM_INDEX\n+   supplied in INDEX.  */\n+\n+static void \n+build_mangled_template_parm_index (s, index)\n+     char* s;\n+     tree index;\n+{\n+  OB_PUTCP (s);\n+  build_underscore_int (TEMPLATE_PARM_IDX (index));\n+  /* We use the LEVEL, not the ORIG_LEVEL, because the mangling is a\n+     representation of the function from the point of view of its\n+     type.  */\n+  build_underscore_int (TEMPLATE_PARM_LEVEL (index));\n+}\n+\n+\n static void\n build_overload_value (type, value, in_template)\n      tree type, value;\n@@ -619,11 +637,9 @@ build_overload_value (type, value, in_template)\n       numeric_output_need_bar = 0;\n     }\n \n-  if (TREE_CODE (value) == TEMPLATE_CONST_PARM)\n+  if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n     {\n-      OB_PUTC ('Y');\n-      build_underscore_int (TEMPLATE_CONST_IDX (value));\n-      build_underscore_int (TEMPLATE_CONST_LEVEL (value));\n+      build_mangled_template_parm_index (\"Y\", value);\n       return;\n     }\n \n@@ -761,13 +777,19 @@ build_overload_value (type, value, in_template)\n \t  sorry (\"template instantiation with pointer to method that is too complex\");\n \t  return;\n \t}\n-      if (TREE_CODE (value) == INTEGER_CST\n-\t  || TREE_CODE (value) == TEMPLATE_CONST_PARM)\n+      if (TREE_CODE (value) == INTEGER_CST)\n \t{\n \t  build_overload_int (value, in_template);\n \t  numeric_output_need_bar = 1;\n \t  return;\n \t}\n+      else if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n+\t{\n+\t  build_mangled_template_parm_index (\"\", value);\n+\t  numeric_output_need_bar = 1;\n+\t  return;\n+\t}\n+\n       value = TREE_OPERAND (value, 0);\n       if (TREE_CODE (value) == VAR_DECL)\n \t{\n@@ -1374,33 +1396,27 @@ process_overload_item (parmtype, extra_Gcode)\n          declaration. */\n       if (CLASSTYPE_TEMPLATE_INFO (parmtype))\n         {\n-          OB_PUTC ('t');\n-          OB_PUTC ('z');\n-          OB_PUTC ('X');\n-          build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n-          build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n-\n-          build_template_parm_names (\n-            DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (parmtype)),\n-            CLASSTYPE_TI_ARGS (parmtype));\n+\t  build_mangled_template_parm_index (\"tzX\",\n+\t\t\t\t\t     TEMPLATE_TYPE_PARM_INDEX \n+\t\t\t\t\t     (parmtype));\n+          build_template_parm_names\n+            (DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (parmtype)),\n+\t     CLASSTYPE_TI_ARGS (parmtype));\n         }\n       else\n         {\n-          OB_PUTC ('Z');\n-          OB_PUTC ('z');\n-          OB_PUTC ('X');\n-          build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n-          build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n-\n-          build_template_template_parm_names (\n-            DECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n+\t  build_mangled_template_parm_index (\"ZzX\",\n+\t\t\t\t\t     TEMPLATE_TYPE_PARM_INDEX \n+\t\t\t\t\t     (parmtype));\n+          build_template_template_parm_names\n+            (DECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n         }\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      OB_PUTC ('X');\n-      build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n-      build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n+      build_mangled_template_parm_index (\"X\", \n+\t\t\t\t\t TEMPLATE_TYPE_PARM_INDEX\n+\t\t\t\t\t (parmtype));\n       break;\n         \n     case TYPENAME_TYPE:"}, {"sha": "a50368aa6558a0a9b4ee3f50f1bb204f98c7c7b9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 475, "deletions": 142, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -86,6 +86,7 @@ static int  type_unification_real PROTO((tree, tree *, tree, tree, int*,\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n static tree convert_nontype_argument PROTO((tree, tree));\n+static int is_member_or_friend_template PROTO((tree, int));\n \n /* Do any processing required when DECL (a member template declaration\n    using TEMPLATE_PARAMETERS as its innermost parameter list) is\n@@ -109,22 +110,51 @@ finish_member_template_decl (template_parameters, decl)\n       return DECL_TI_TEMPLATE (decl);\n     }\n \n-  if (decl)\n-    return decl;\n+  return decl;\n+}\n \n-  cp_error (\"invalid member template declaration\");\n-  return NULL_TREE;\n+/* Returns the template nesting level of the indicated class TYPE.\n+   \n+   For example, in:\n+     template <class T>\n+     struct A\n+     {\n+       template <class U>\n+       struct B {};\n+     };\n+\n+   A<T>::B<U> has depth two, while A<T> has depth one.  Also,\n+   both A<T>::B<int> and A<int>::B<U> have depth one.  */\n+\n+int \n+template_class_depth (type)\n+     tree type;\n+{\n+  int depth = 0;\n+\n+  /* Note: this implementation will be broken when we have nested\n+     template classes.  Presumably we will have to wrap this if\n+     statement a loop.  */\n+  if (CLASSTYPE_TEMPLATE_INFO (type)\n+      && uses_template_parms (CLASSTYPE_TI_ARGS (type)))\n+    ++depth;\n+\n+  return depth;\n }\n \n-/* Restore the template parameter context. */\n+/* Restore the template parameter context for a member template or\n+   a friend template defined in a class definition.  */\n \n void \n-begin_member_template_processing (decl)\n+maybe_begin_member_template_processing (decl)\n      tree decl;\n {\n   tree parms;\n   int i;\n \n+  if (!is_member_or_friend_template (decl, 1))\n+    return;\n+\n   parms = DECL_INNERMOST_TEMPLATE_PARMS (DECL_TI_TEMPLATE (decl));\n \n   ++processing_template_decl;\n@@ -163,8 +193,12 @@ begin_member_template_processing (decl)\n /* Undo the effects of begin_member_template_processing. */\n \n void \n-end_member_template_processing ()\n+maybe_end_member_template_processing (decl)\n+     tree decl;\n {\n+  if (!is_member_or_friend_template (decl, 1))\n+    return;\n+\n   if (! processing_template_decl)\n     return;\n \n@@ -173,8 +207,9 @@ end_member_template_processing ()\n   poplevel (0, 0, 0);\n }\n \n-/* Returns non-zero iff T is a member template function.  We must be\n-   careful as in \n+/* Returns non-zero iff T is a member template function, or, if\n+   ALLOW_FRIEND is non-zero, a friend template function.  We must be\n+   careful as in\n \n      template <class T> class C { void f(); }\n \n@@ -187,67 +222,56 @@ end_member_template_processing ()\n    then neither C<int>::f<char> nor C<T>::f<double> is considered\n    to be a member template.  */\n \n-int\n-is_member_template (t)\n+static int\n+is_member_or_friend_template (t, allow_friend)\n      tree t;\n+     int allow_friend;\n {\n-  int r = 0;\n-\n   if (TREE_CODE (t) != FUNCTION_DECL\n       && !DECL_FUNCTION_TEMPLATE_P (t))\n     /* Anything that isn't a function or a template function is\n        certainly not a member template.  */\n     return 0;\n \n-  if ((DECL_FUNCTION_MEMBER_P (t) \n+  if (((DECL_FUNCTION_MEMBER_P (t) \n+\t|| (allow_friend && DECL_FRIEND_P (t)))\n        && !DECL_TEMPLATE_SPECIALIZATION (t))\n-      || (TREE_CODE (t) == TEMPLATE_DECL && \n-\t  DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))))\n+      || (TREE_CODE (t) == TEMPLATE_DECL \n+\t  && (DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))\n+\t      || (allow_friend\n+\t\t  && DECL_FUNCTION_TEMPLATE_P (t) \n+\t\t  && DECL_FRIEND_P (DECL_TEMPLATE_RESULT (t))\n+\t\t  && DECL_CLASS_CONTEXT (t)))))\n     {\n-      tree tmpl = NULL_TREE;\n+      tree tmpl;\n \n       if (DECL_FUNCTION_TEMPLATE_P (t))\n \ttmpl = t;\n       else if (DECL_TEMPLATE_INFO (t) \n \t       && DECL_FUNCTION_TEMPLATE_P (DECL_TI_TEMPLATE (t)))\n \ttmpl = DECL_TI_TEMPLATE (t);\n+      else\n+\ttmpl = NULL_TREE;\n+\n+      if (tmpl && \n+\t  /* If there are more levels of template parameters than\n+\t     there are template classes surrounding the declaration,\n+\t     then we have a member template.  */\n+\t  list_length (DECL_TEMPLATE_PARMS (tmpl)) > \n+\t  template_class_depth (DECL_CLASS_CONTEXT (t)))\n+\treturn 1;\n+    }\n \n-      if (tmpl) \n-\t{\n-\t  tree parms = DECL_TEMPLATE_PARMS (tmpl);\n-\t  int parm_levels = list_length (parms);\n-\t  int template_class_levels = 0;\n-\t  tree ctx = DECL_CLASS_CONTEXT (t);\n-\n-\t  /* NB - The code below does not yet handle template class\n-\t     members, e.g. \n-\t     \n-\t       template <class T> class C { template <class U> class D; }}\n-\n-\t     correctly.  In that case, the D should have level 2.  */\n-\n-\t  if (CLASSTYPE_TEMPLATE_INFO (ctx))\n-\t    {\n-\t      tree args = CLASSTYPE_TI_ARGS (ctx);\n-\t      int i;\n-\t      \n-\t      if (args == NULL_TREE)\n-\t\ttemplate_class_levels = 1;\n-\t      else \n-\t\tfor (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-\t\t  if (uses_template_parms (TREE_VEC_ELT (args, i)))\n-\t\t    {\n-\t\t      template_class_levels++;\n-\t\t      break;\n-\t\t    }\n-\t    }\n+  return 0;\n+}\n \n-\t  if (parm_levels > template_class_levels)\n-\t    r = 1;\n-\t}\n-    }\n+/* Returns non-zero iff T is a member template.  */\n \n-  return r;\n+int\n+is_member_template (t)\n+     tree t;\n+{\n+  return is_member_or_friend_template (t, 0);\n }\n \n /* Return a new template argument vector which contains all of ARGS,\n@@ -595,10 +619,6 @@ determine_specialization (template_id, decl, targs_out,\n    Returns DECL, or an equivalent declaration that should be used\n    instead. \n    \n-     0: The function is not an explicit specialization or instantiation.\n-     1: The function is an explicit specialization.\n-     2: The function is an explicit instantiation.\n-\n    FLAGS is a bitmask consisting of the following flags: \n \n    1: We are being called by finish_struct.  (We are unable to\n@@ -1004,6 +1024,57 @@ int comp_template_parms (parms1, parms2)\n }\n \n \n+/* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,\n+   ORIG_LEVEL, DECL, and TYPE.  */\n+\n+static tree\n+build_template_parm_index (index, level, orig_level, decl, type)\n+     int index;\n+     int level;\n+     int orig_level;\n+     tree decl;\n+     tree type;\n+{\n+  tree t = make_node (TEMPLATE_PARM_INDEX);\n+  TEMPLATE_PARM_IDX (t) = index;\n+  TEMPLATE_PARM_LEVEL (t) = level;\n+  TEMPLATE_PARM_ORIG_LEVEL (t) = orig_level;\n+  TEMPLATE_PARM_DECL (t) = decl;\n+  TREE_TYPE (t) = type;\n+\n+  return t;\n+}\n+\n+\n+/* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose\n+   TEMPLATE_PARM_LEVEL has been decreased by one.  If such a\n+   TEMPLATE_PARM_INDEX already exists, it is returned; otherwise, a\n+   new one is created.  */\n+\n+static tree \n+reduce_template_parm_level (index, type)\n+     tree index;\n+     tree type;\n+{\n+  if (TEMPLATE_PARM_DESCENDANTS (index) == NULL_TREE\n+      || (TEMPLATE_PARM_LEVEL (TEMPLATE_PARM_DESCENDANTS (index))\n+\t  != TEMPLATE_PARM_LEVEL (index) - 1))\n+    {\n+      tree decl \n+\t= build_decl (TREE_CODE (TEMPLATE_PARM_DECL (index)),\n+\t\t      DECL_NAME (TEMPLATE_PARM_DECL (index)),\n+\t\t      type);\n+      tree t\n+\t= build_template_parm_index (TEMPLATE_PARM_IDX (index),\n+\t\t\t\t     TEMPLATE_PARM_LEVEL (index) - 1,\n+\t\t\t\t     TEMPLATE_PARM_ORIG_LEVEL (index),\n+\t\t\t\t     decl, type);\n+      TEMPLATE_PARM_DESCENDANTS (index) = t;\n+    }\n+\n+  return TEMPLATE_PARM_DESCENDANTS (index);\n+}\n+\n /* Process information from new template parameter NEXT and append it to the\n    LIST being built.  */\n \n@@ -1015,6 +1086,7 @@ process_template_parm (list, next)\n   tree decl = 0;\n   tree defval;\n   int is_type, idx;\n+\n   parm = next;\n   my_friendly_assert (TREE_CODE (parm) == TREE_LIST, 259);\n   defval = TREE_PURPOSE (parm);\n@@ -1030,15 +1102,14 @@ process_template_parm (list, next)\n       else if (TREE_CODE (p) == TEMPLATE_DECL)\n \tidx = TEMPLATE_TYPE_IDX (TREE_TYPE (DECL_TEMPLATE_RESULT (p)));\n       else\n-\tidx = TEMPLATE_CONST_IDX (DECL_INITIAL (p));\n+\tidx = TEMPLATE_PARM_IDX (DECL_INITIAL (p));\n       ++idx;\n     }\n   else\n     idx = 0;\n \n   if (!is_type)\n     {\n-      tree tinfo = 0;\n       my_friendly_assert (TREE_CODE (TREE_PURPOSE (parm)) == TREE_LIST, 260);\n       /* is a const-param */\n       parm = grokdeclarator (TREE_VALUE (parm), TREE_PURPOSE (parm),\n@@ -1059,18 +1130,16 @@ process_template_parm (list, next)\n \t\t   || TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE))\n \tcp_pedwarn (\"`%T' is not a valid type for a template constant parameter\",\n \t\t    TREE_TYPE (parm));\n-      tinfo = make_node (TEMPLATE_CONST_PARM);\n-      my_friendly_assert (TREE_PERMANENT (tinfo), 260.5);\n       if (TREE_PERMANENT (parm) == 0)\n         {\n \t  parm = copy_node (parm);\n \t  TREE_PERMANENT (parm) = 1;\n         }\n-      TREE_TYPE (tinfo) = TREE_TYPE (parm);\n       decl = build_decl (CONST_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n-      DECL_INITIAL (decl) = tinfo;\n-      DECL_INITIAL (parm) = tinfo;\n-      TEMPLATE_CONST_SET_INFO (tinfo, idx, processing_template_decl);\n+      DECL_INITIAL (parm) = DECL_INITIAL (decl) \n+\t= build_template_parm_index (idx, processing_template_decl,\n+\t\t\t\t     processing_template_decl,\n+\t\t\t\t     decl, TREE_TYPE (parm));\n     }\n   else\n     {\n@@ -1097,7 +1166,10 @@ process_template_parm (list, next)\n       TYPE_NAME (t) = decl;\n       TYPE_STUB_DECL (t) = decl;\n       parm = decl;\n-      TEMPLATE_TYPE_SET_INFO (t, idx, processing_template_decl);\n+      TEMPLATE_TYPE_PARM_INDEX (t)\n+\t= build_template_parm_index (idx, processing_template_decl, \n+\t\t\t\t     processing_template_decl,\n+\t\t\t\t     decl, TREE_TYPE (parm));\n     }\n   SET_DECL_ARTIFICIAL (decl);\n   pushdecl (decl);\n@@ -1212,30 +1284,48 @@ build_template_decl (decl, parms)\n \n   \n /* Creates a TEMPLATE_DECL for the indicated DECL using the template\n-   parameters given by current_template_args, or reuses a previously\n-   existing one, if appropriate.  Returns the DECL, or an equivalent\n-   one, if it is replaced via a call to duplicate_decls.  */\n+   parameters given by current_template_args, or reuses a\n+   previously existing one, if appropriate.  Returns the DECL, or an\n+   equivalent one, if it is replaced via a call to duplicate_decls.  */\n \n tree\n push_template_decl (decl)\n      tree decl;\n {\n   tree tmpl;\n-  tree args = NULL_TREE;\n+  tree args;\n   tree info;\n-  tree ctx = DECL_CONTEXT (decl) ? DECL_CONTEXT (decl) : current_class_type;\n-  int primary = 0;\n-\n-  /* Kludge! */\n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl)\n-      && DECL_CLASS_CONTEXT (decl))\n-    ;\n-  /* Note that this template is a \"primary template\" */\n-  else if (! ctx \n-\t   || (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't' \n-\t       && ! CLASSTYPE_TEMPLATE_INFO (ctx))\n-      /* || (processing_template_decl > CLASSTYPE_TEMPLATE_LEVEL (ctx)) */)\n+  tree ctx;\n+  int primary;\n+  int is_friend = (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t   && DECL_FRIEND_P (decl));\n+\n+  if (is_friend)\n+    /* For a friend, we want the context of the friend function, not\n+       the type of which it is a friend.  */\n+    ctx = DECL_CONTEXT (decl);\n+  else if (DECL_REAL_CONTEXT (decl))\n+    /* In the case of a virtual function, we want the class in which\n+       it is defined.  */\n+    ctx = DECL_REAL_CONTEXT (decl);\n+  else\n+    /* Otherwise, if we're currently definining some class, the DECL\n+       is assumed to be a member of the class.  */\n+    ctx = current_class_type;\n+\n+  if ((! ctx\n+       || (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't'\n+\t   && template_class_depth (ctx) == 0))\n+      /* At this point, we know that the DECL is not a member of some\n+\t template class.  However, a friend function declared in a\n+\t template class is still not primary, since, in general it can\n+\t depend on the template parameters of the enclosing class.  */\n+      && !(is_friend\n+\t   && DECL_CLASS_CONTEXT (decl)\n+\t   && template_class_depth (DECL_CLASS_CONTEXT (decl)) > 0))\n     primary = 1;\n+  else\n+    primary = 0;\n \n   /* Partial specialization.  */\n   if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl)\n@@ -1263,19 +1353,28 @@ push_template_decl (decl)\n \n   args = current_template_args ();\n \n-  if (! ctx || TREE_CODE (ctx) == FUNCTION_DECL \n-      || TYPE_BEING_DEFINED (ctx))\n+  if (!ctx \n+      || TREE_CODE (ctx) == FUNCTION_DECL\n+      || TYPE_BEING_DEFINED (ctx)\n+      || (is_friend && !DECL_TEMPLATE_INFO (decl)))\n     {\n-      tmpl = build_template_decl (decl, current_template_parms);\n-      \n       if (DECL_LANG_SPECIFIC (decl)\n-\t  && DECL_TEMPLATE_SPECIALIZATION (decl))\n+\t  && DECL_TEMPLATE_INFO (decl)\n+\t  && DECL_TI_TEMPLATE (decl))\n+\ttmpl = DECL_TI_TEMPLATE (decl);\n+      else\n \t{\n-\t  /* A specialization of a member template of a template\n-\t     class. */\n-\t  SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n-\t  DECL_TEMPLATE_INFO (tmpl) = DECL_TEMPLATE_INFO (decl);\n-\t  DECL_TEMPLATE_INFO (decl) = NULL_TREE;\n+\t  tmpl = build_template_decl (decl, current_template_parms);\n+\t  \n+\t  if (DECL_LANG_SPECIFIC (decl)\n+\t      && DECL_TEMPLATE_SPECIALIZATION (decl))\n+\t    {\n+\t      /* A specialization of a member template of a template\n+\t\t class. */\n+\t      SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n+\t      DECL_TEMPLATE_INFO (tmpl) = DECL_TEMPLATE_INFO (decl);\n+\t      DECL_TEMPLATE_INFO (decl) = NULL_TREE;\n+\t    }\n \t}\n     }\n   else\n@@ -1325,8 +1424,7 @@ push_template_decl (decl)\n \t  \n \t  a = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n \t  t = DECL_INNERMOST_TEMPLATE_PARMS (DECL_TI_TEMPLATE (decl));\n-\t  if (TREE_VEC_LENGTH (t) \n-\t      != TREE_VEC_LENGTH (a))\n+\t  if (TREE_VEC_LENGTH (t) != TREE_VEC_LENGTH (a))\n \t    {\n \t      cp_error (\"got %d template parameters for `%#D'\",\n \t\t\tTREE_VEC_LENGTH (a), decl);\n@@ -1372,7 +1470,10 @@ push_template_decl (decl)\n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n   TREE_TYPE (tmpl) = TREE_TYPE (decl);\n \n-  if (! ctx)\n+  if (! ctx && primary)\n+    /* The check of PRIMARY ensures that we do not try to push a\n+       global template friend declared in a template class; such a\n+       thing may well depend on the template parameters of the class.  */\n     tmpl = pushdecl_top_level (tmpl);\n \n   if (primary)\n@@ -2014,6 +2115,9 @@ coerce_template_parms (parms, arglist, in_decl,\n   return vec;\n }\n \n+/* Renturns 1 iff the OLDARGS and NEWARGS are in fact identical sets\n+   of template arguments.  Returns 0 otherwise.  */\n+\n static int\n comp_template_args (oldargs, newargs)\n      tree oldargs, newargs;\n@@ -2540,7 +2644,7 @@ uses_template_parms (t)\n       /* template parm nodes */\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n-    case TEMPLATE_CONST_PARM:\n+    case TEMPLATE_PARM_INDEX:\n       return 1;\n \n       /* simple type nodes */\n@@ -2713,11 +2817,106 @@ tinst_for_decl ()\n   return p;\n }\n \n+\n+/* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the\n+   vector of template arguments, as for tsubst.\n+\n+   Returns an appropriate tsbust'd friend declaration.  */\n+\n+static tree\n+tsubst_friend_function (decl, args)\n+     tree decl;\n+     tree args;\n+{\n+  tree new_friend;\n+  \n+  if (TREE_CODE (decl) == FUNCTION_DECL \n+      && DECL_TEMPLATE_INSTANTIATION (decl)\n+      && TREE_CODE (DECL_TI_TEMPLATE (decl)) != TEMPLATE_DECL)\n+    /* This was a friend declared with an explicit template\n+       argument list, e.g.:\n+       \n+       friend void f<>(T);\n+       \n+       to indicate that f was a template instantiation, not a new\n+       function declaration.  Now, we have to figure out what\n+       instantiation of what template.  */\n+    {\n+      tree template_id;\n+      tree new_args;\n+      tree tmpl;\n+      tree tinfo;\n+\n+      template_id\n+\t= lookup_template_function (tsubst_expr (DECL_TI_TEMPLATE (decl),\n+\t\t\t\t\t\t args, \n+\t\t\t\t\t\t TREE_VEC_LENGTH (args),\n+\t\t\t\t\t\t NULL_TREE),\n+\t\t\t\t    tsubst (DECL_TI_ARGS (decl),\n+\t\t\t\t\t    args,\n+\t\t\t\t\t    TREE_VEC_LENGTH (decl),\n+\t\t\t\t\t    NULL_TREE));\n+      \n+      /* Temporarily remove the DECL_TEMPLATE_INFO so as not to\n+\t confuse tsubst.  */\n+      tinfo = DECL_TEMPLATE_INFO (decl);\n+      DECL_TEMPLATE_INFO (decl) = NULL_TREE;\n+      new_friend = tsubst (decl, args, TREE_VEC_LENGTH (args), NULL_TREE);\n+      DECL_TEMPLATE_INFO (decl) = tinfo;\n+\n+      tmpl = determine_specialization (template_id,\n+\t\t\t\t       new_friend,\n+\t\t\t\t       &new_args,\n+\t\t\t\t       0, 1);\n+      return instantiate_template (tmpl, new_args);\n+    }\n+    else\n+      new_friend = tsubst (decl, args, TREE_VEC_LENGTH (args), NULL_TREE);\n+\t\n+  /* The new_friend will look like an instantiation, to the\n+     compiler, but is not an instantiation from the point of view of\n+     the language.  For example, we might have had:\n+     \n+     template <class T> struct S {\n+       template <class U> friend void f(T, U);\n+     };\n+     \n+     Then, in S<int>, template <class U> void f(int, U) is not an\n+     instantiation of anything.  */\n+  DECL_USE_TEMPLATE (new_friend) = 0;\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    DECL_USE_TEMPLATE (DECL_TEMPLATE_RESULT (new_friend)) = 0;\n+  \n+  if (DECL_CONTEXT (new_friend) == NULL_TREE)\n+    {\n+      if (TREE_CODE (new_friend) == TEMPLATE_DECL)\n+\t/* This declaration is a `primary' template.  */\n+\tTREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (new_friend))\n+\t    = new_friend;\n+\n+\tnew_friend = pushdecl_top_level (new_friend);\n+    }\n+  else if (TYPE_SIZE (DECL_CONTEXT (new_friend)))\n+    {\n+      /* Check to see that the declaration is really present, and,\n+\t possibly obtain an improved declaration.  */\n+      tree fn = check_classfn (DECL_CONTEXT (new_friend),\n+\t\t\t       new_friend);\n+      \n+      if (fn)\n+\tnew_friend = fn;\n+    }\n+\n+  return new_friend;\n+}\n+\n+\n tree\n instantiate_class_template (type)\n      tree type;\n {\n   tree template, template_info, args, pattern, t, *field_chain;\n+  tree typedecl;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n@@ -2910,9 +3109,42 @@ instantiate_class_template (type)\n \tgrok_op_properties (t, DECL_VIRTUAL_P (t), 0);\n     }\n \n-  DECL_FRIENDLIST (TYPE_MAIN_DECL (type))\n-    = tsubst (DECL_FRIENDLIST (TYPE_MAIN_DECL (pattern)),\n-\t      args, TREE_VEC_LENGTH (args), NULL_TREE);\n+  /* Construct the DECL_FRIENDLIST for the new class type.  */\n+  typedecl = TYPE_MAIN_DECL (type);\n+  for (t = DECL_FRIENDLIST (TYPE_MAIN_DECL (pattern));\n+       t != NULL_TREE;\n+       t = TREE_CHAIN (t))\n+    {\n+      tree friends;\n+\n+      DECL_FRIENDLIST (typedecl)\n+\t= tree_cons (TREE_PURPOSE (t), NULL_TREE, \n+\t\t     DECL_FRIENDLIST (typedecl));\n+\n+      for (friends = TREE_VALUE (t);\n+\t   friends != NULL_TREE;\n+\t   friends = TREE_CHAIN (friends))\n+\t{\n+\t  if (TREE_PURPOSE (friends) == error_mark_node)\n+\t    {\n+\t      TREE_VALUE (DECL_FRIENDLIST (typedecl))\n+\t\t= tree_cons (error_mark_node, \n+\t\t\t     tsubst_friend_function (TREE_VALUE (friends),\n+\t\t\t\t\t\t     args),\n+\t\t\t     TREE_VALUE (DECL_FRIENDLIST (typedecl)));\n+\t    }\n+\t  else\n+\t    {\n+\t      TREE_VALUE (DECL_FRIENDLIST (typedecl))\n+\t\t= tree_cons (tsubst (TREE_PURPOSE (friends),\n+\t\t\t\t     args, TREE_VEC_LENGTH (args),\n+\t\t\t\t     NULL_TREE),\n+\t\t\t     NULL_TREE,\n+\t\t\t     TREE_VALUE (DECL_FRIENDLIST (typedecl)));\n+\n+\t    }\n+\t}\n+    }\n \n   {\n     tree d = CLASSTYPE_FRIEND_CLASSES (type)\n@@ -3034,6 +3266,7 @@ maybe_fold_nontype_arg (arg)\n   return arg;\n }\n \n+\n /* Take the tree structure T and replace template parameters used therein\n    with the argument vector ARGS.  NARGS is the number of args; should\n    be removed.  IN_DECL is an associated decl for diagnostics.\n@@ -3059,7 +3292,8 @@ tsubst (t, args, nargs, in_decl)\n   if (type == unknown_type_node)\n     my_friendly_abort (42);\n   if (type && TREE_CODE (t) != FUNCTION_DECL\n-      && TREE_CODE (t) != TYPENAME_TYPE)\n+      && TREE_CODE (t) != TYPENAME_TYPE\n+      && TREE_CODE (t) != TEMPLATE_DECL)\n     type = tsubst (type, args, nargs, in_decl);\n \n   switch (TREE_CODE (t))\n@@ -3141,10 +3375,11 @@ tsubst (t, args, nargs, in_decl)\n \n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n-    case TEMPLATE_CONST_PARM:\n+    case TEMPLATE_PARM_INDEX:\n       {\n \tint idx;\n \tint level;\n+\ttree r = NULL_TREE;\n \n \tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n \t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n@@ -3154,11 +3389,11 @@ tsubst (t, args, nargs, in_decl)\n \t  }\n \telse\n \t  {\n-\t    idx = TEMPLATE_CONST_IDX (t);\n-\t    level = TEMPLATE_CONST_LEVEL (t);\n+\t    idx = TEMPLATE_PARM_IDX (t);\n+\t    level = TEMPLATE_PARM_LEVEL (t);\n \t  }\n \n-\tif (TREE_VEC_LENGTH (args) > 0) \n+\tif (TREE_VEC_LENGTH (args) > 0)\n \t  {\n \t    tree arg = NULL_TREE;\n \n@@ -3212,14 +3447,32 @@ tsubst (t, args, nargs, in_decl)\n \n \t/* If we get here, we must have been looking at a parm for a\n \t   more deeply nested template.  */\n-\tmy_friendly_assert((TREE_CODE (t) == TEMPLATE_CONST_PARM \n-\t\t\t    && TEMPLATE_CONST_LEVEL (t) > 1) \n-\t\t\t   || (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n-\t\t\t       && TEMPLATE_TYPE_LEVEL (t) > 1)\n-\t\t\t   || (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n-\t\t\t       && TEMPLATE_TYPE_LEVEL (t) > 1),\n-\t\t\t   0);\n-\treturn t;\n+\tmy_friendly_assert(level > 1, 0);\n+\t\n+\t/* Make a new version of this template parameter, but with a\n+\t   lower level.  */\n+\tswitch (TREE_CODE (t))\n+\t  {\n+\t  case TEMPLATE_TYPE_PARM:\n+\t  case TEMPLATE_TEMPLATE_PARM:\n+\t    r = copy_node (t);\n+\t    TEMPLATE_TYPE_PARM_INDEX (r)\n+\t      = reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (t),\n+\t\t\t\t\t    r);\n+\t    TYPE_STUB_DECL (r) = TYPE_NAME (r) = TEMPLATE_TYPE_DECL (r);\n+\t    TYPE_MAIN_VARIANT (r) = r;\n+\t    TYPE_POINTER_TO (r) = NULL_TREE;\n+\t    break;\n+\n+\t  case TEMPLATE_PARM_INDEX:\n+\t    r = reduce_template_parm_level (t, TREE_TYPE (t));\n+\t    break;\n+\t   \n+\t  default:\n+\t    my_friendly_abort (0);\n+\t  }\n+\n+\treturn r;\n       }\n \n     case TEMPLATE_DECL:\n@@ -3230,8 +3483,22 @@ tsubst (t, args, nargs, in_decl)\n \ttree decl = DECL_TEMPLATE_RESULT (t);\n \ttree new_decl;\n \ttree parms;\n+\ttree* new_parms;\n \ttree spec;\n \n+\tif (TREE_CODE (decl) == TYPE_DECL)\n+\t  {\n+\t    if (TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TEMPLATE_PARM)\n+\t      /* There is no tsubst'ing to be done in a template template\n+\t\t parameter.  */\n+\t      return t;\n+\n+\t    /* This must be a member template class.  We don't handle\n+\t       this case yet.  */\n+\t    sorry (\"member template classes\");\n+\t    return t;\n+\t  }\n+\n \t/* We might already have an instance of this template. */\n \tspec = retrieve_specialization (t, args);\n \tif (spec != NULL_TREE)\n@@ -3247,6 +3514,10 @@ tsubst (t, args, nargs, in_decl)\n \tmy_friendly_assert (DECL_LANG_SPECIFIC (tmpl) != 0, 0);\n \tDECL_CHAIN (tmpl) = NULL_TREE;\n \tTREE_CHAIN (tmpl) = NULL_TREE;\n+\tDECL_CONTEXT (tmpl) = tsubst (DECL_CONTEXT (t),\n+\t\t\t\t      args, nargs, in_decl);\n+\tDECL_CLASS_CONTEXT (tmpl) = tsubst (DECL_CLASS_CONTEXT (t),\n+\t\t\t\t\t    args, nargs, in_decl);\n \tDECL_TEMPLATE_INFO (tmpl) = build_tree_list (t, args);\n \tnew_decl = tsubst (decl, args, nargs, in_decl);\n \tDECL_RESULT (tmpl) = new_decl;\n@@ -3258,12 +3529,38 @@ tsubst (t, args, nargs, in_decl)\n \t/* The template parameters for this new template are all the\n \t   template parameters for the old template, except the\n \t   outermost level of parameters. */\n-\tDECL_TEMPLATE_PARMS (tmpl)\n-\t  = copy_node (DECL_TEMPLATE_PARMS (tmpl));\n-\tfor (parms = DECL_TEMPLATE_PARMS (tmpl);\n+\tfor (new_parms = &DECL_TEMPLATE_PARMS (tmpl),\n+\t       parms = DECL_TEMPLATE_PARMS (t);\n \t     TREE_CHAIN (parms) != NULL_TREE;\n-\t     parms = TREE_CHAIN (parms))\n-\t  TREE_CHAIN (parms) = copy_node (TREE_CHAIN (parms));\n+\t     new_parms = &(TREE_CHAIN (*new_parms)),\n+\t       parms = TREE_CHAIN (parms))\n+\t  {\n+\t    tree new_vec = \n+\t      make_tree_vec (TREE_VEC_LENGTH (TREE_VALUE (parms)));\n+\t    int i;\n+\n+\t    for (i = 0; i < TREE_VEC_LENGTH (new_vec); ++i)\n+\t      {\n+\t\ttree default_value =\n+\t\t  TREE_PURPOSE (TREE_VEC_ELT (TREE_VALUE (parms), i));\n+\t\ttree parm_decl = \n+\t\t  TREE_VALUE (TREE_VEC_ELT (TREE_VALUE (parms), i));\n+\t\t  \n+\t\tTREE_VEC_ELT (new_vec, i)\n+\t\t  = build_tree_list (tsubst (default_value, args,\n+\t\t\t\t\t     nargs, in_decl),\n+\t\t\t\t     tsubst (parm_decl, args, nargs,\n+\t\t\t\t\t     in_decl));\n+\t\t  \n+\t      }\n+\n+\t    *new_parms = \n+\t      tree_cons (build_int_2 (0, \n+\t\t\t\t      TREE_INT_CST_HIGH \n+\t\t\t\t      (TREE_PURPOSE (parms)) - 1),\n+\t\t\t new_vec,\n+\t\t\t NULL_TREE);\n+\t  }\n \n \t/* What should we do with the specializations of this member\n \t   template?  Are they specializations of this new template,\n@@ -3330,7 +3627,8 @@ tsubst (t, args, nargs, in_decl)\n       {\n \ttree r = NULL_TREE;\n \ttree ctx;\n-\n+\ttree fullargs = args;\n+\ttree tmpl = NULL_TREE;\n \tint member;\n \n \tif (DECL_CONTEXT (t) != NULL_TREE\n@@ -3350,12 +3648,18 @@ tsubst (t, args, nargs, in_decl)\n \t    type = tsubst (type, args, nargs, in_decl);\n \t  }\n \n-\t/* Do we already have this instantiation?  */\n+\t/* If we are instantiating a specialization, get the other args.  */\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n-\t    tree tmpl = DECL_TI_TEMPLATE (t);\n-\t    tree spec = retrieve_specialization (tmpl, args);\n+\t    tree spec;\n+\n+\t    tmpl = DECL_TI_TEMPLATE (t);\n+\t    /* FIXME is this right for specializations?  */\n+\t    if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n+\t      fullargs = add_to_template_args (DECL_TI_ARGS (tmpl), args);\n \n+\t    /* Do we already have this instantiation?  */\n+\t    spec = retrieve_specialization (tmpl, fullargs);\n \t    if (spec)\n \t      return spec;\n \t  }\n@@ -3432,21 +3736,19 @@ tsubst (t, args, nargs, in_decl)\n \t\t   build_template_decl_overload since the innermost\n \t\t   template parameters are still just template\n \t\t   parameters; there are no corresponding subsitution\n-\t\t   arguments.  */\n-\t\t/* FIXME The messed up thing here is that we get here with\n-\t\t   full args and only one level of parms.  This is necessary\n-\t\t   because when we partially instantiate a member template,\n-\t\t   even though there's really only one level of parms left\n-\t\t   we re-use the parms from the original template, which\n-\t\t   have level 2.  When this is fixed we can remove the\n-\t\t   add_to_template_args from instantiate_template.  */\n-\t\ttree tparms;\n+\t\t   arguments.  We get here with full args and only one\n+\t\t   level of parms.  This is necessary because when we\n+\t\t   partially instantiate a member template, even\n+\t\t   though there's really only one level of parms, left\n+\t\t   the parms from the original template, which have\n+\t\t   level 2, may appear in the definition of the a\n+\t\t   function body.  */\n+\t\ttree tparms; \n \t\ttree targs;\n \n \t\tif (!DECL_TEMPLATE_SPECIALIZATION (tmpl)) \n \t\t  {\n \t\t    tparms = DECL_TEMPLATE_PARMS (tmpl);\n-\n \t\t    while (tparms && TREE_CHAIN (tparms) != NULL_TREE)\n \t\t      tparms = TREE_CHAIN (tparms);\n \t\t    \n@@ -3546,8 +3848,13 @@ tsubst (t, args, nargs, in_decl)\n \n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n-\t    tree tmpl = DECL_TI_TEMPLATE (t);\n-\t    tree argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n+\t    tree argvec;\n+\n+\t    /* FIXME this is ugly.  */\n+\t    if (TREE_CODE (TREE_VEC_ELT (args, 0)) != TREE_VEC)\n+\t      argvec = args;\n+\t    else\n+\t      argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n \n \t    if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n \t      {\n@@ -4112,9 +4419,10 @@ tsubst_copy (t, args, nargs, in_decl)\n     case CALL_EXPR:\n       {\n \ttree fn = TREE_OPERAND (t, 0);\n-\tif (really_overloaded_fn (fn))\n+\tif (is_overloaded_fn (fn))\n \t  fn = tsubst_copy (get_first_fn (fn), args, nargs, in_decl);\n \telse\n+\t  /* Sometimes FN is a LOOKUP_EXPR.  */\n \t  fn = tsubst_copy (fn, args, nargs, in_decl);\n \treturn build_nt\n \t  (code, fn, tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl),\n@@ -4235,14 +4543,15 @@ tsubst_copy (t, args, nargs, in_decl)\n     case INTEGER_TYPE:\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n-    case TEMPLATE_CONST_PARM:\n+    case TEMPLATE_PARM_INDEX:\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n     case OFFSET_TYPE:\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n     case ARRAY_TYPE:\n     case TYPENAME_TYPE:\n+    case TYPE_DECL:\n       return tsubst (t, args, nargs, in_decl);\n \n     case IDENTIFIER_NODE:\n@@ -4577,6 +4886,8 @@ instantiate_template (tmpl, targ_ptr)\n \n   my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 283);\n \n+  /* FIXME this won't work with member templates; we only have one level\n+     of args here.  */\n   if (DECL_FUNCTION_TEMPLATE_P (tmpl))\n     {\n       /* Check to see if we already have this specialization.  */\n@@ -4611,9 +4922,6 @@ instantiate_template (tmpl, targ_ptr)\n     }\n   targ_ptr = copy_to_permanent (targ_ptr);\n \n-  if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n-    targ_ptr = add_to_template_args (DECL_TI_ARGS (tmpl), targ_ptr);\n-\n   /* substitute template parameters */\n   fndecl = tsubst (DECL_RESULT (tmpl), targ_ptr, len, tmpl);\n \n@@ -5024,7 +5332,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \t\ttree t = TREE_VEC_ELT (parmvec, i);\n \t\tif (TREE_CODE (t) != TEMPLATE_TYPE_PARM\n \t\t    && TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM\n-\t\t    && TREE_CODE (t) != TEMPLATE_CONST_PARM)\n+\t\t    && TREE_CODE (t) != TEMPLATE_PARM_INDEX)\n \t\t  continue;\n \n \t\t/* This argument can be deduced.  */\n@@ -5048,9 +5356,9 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n       targs[idx] = arg;\n       return 0;\n \n-    case TEMPLATE_CONST_PARM:\n+    case TEMPLATE_PARM_INDEX:\n       (*nsubsts)++;\n-      idx = TEMPLATE_CONST_IDX (parm);\n+      idx = TEMPLATE_PARM_IDX (parm);\n       if (targs[idx])\n \t{\n \t  int i = cp_tree_equal (targs[idx], arg);\n@@ -5357,7 +5665,7 @@ get_bindings (fn, decl, explicit_args)\n \t\t       DECL_NTPARMS (fn),\n \t\t       NULL_TREE);\n \n-      if (!comptypes(t, TREE_TYPE (TREE_TYPE (decl)), 1))\n+      if (!comptypes (t, TREE_TYPE (TREE_TYPE (decl)), 1))\n \treturn NULL_TREE;\n \n       return targs;\n@@ -5669,6 +5977,20 @@ do_type_instantiation (t, storage)\n   }\n }\n \n+/* Return the TREE_VEC with the arguments for the innermost template header,\n+   where ARGS is either that or the VEC of VECs for all the arguments.  */\n+\n+tree\n+innermost_args (args)\n+     tree args;\n+{\n+  if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+    return TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n+  return args;\n+}\n+\n+/* Produce the definition of D, a _DECL generated from a template.  */\n+\n tree\n instantiate_decl (d)\n      tree d;\n@@ -5685,7 +6007,15 @@ instantiate_decl (d)\n   int line = lineno;\n   char *file = input_filename;\n \n-  for (td = tmpl; DECL_TEMPLATE_INSTANTIATION (td); )\n+  for (td = tmpl; \n+       DECL_TEMPLATE_INSTANTIATION (td) \n+\t /* This next clause handles friend templates defined inside\n+\t    class templates.  The friend templates are not really\n+\t    instantiations from the point of view of the language, but\n+\t    they are instantiations from the point of view of the\n+\t    compiler.  */\n+\t || (DECL_TEMPLATE_INFO (td) && !DECL_TEMPLATE_SPECIALIZATION (td)); \n+       )\n     td = DECL_TI_TEMPLATE (td);\n \n   /* In the case of a member template, decl_pattern is the partially\n@@ -5781,7 +6111,10 @@ instantiate_decl (d)\n   /* Trick tsubst into giving us a new decl in case the template changed.  */\n   save_ti = DECL_TEMPLATE_INFO (decl_pattern);\n   DECL_TEMPLATE_INFO (decl_pattern) = NULL_TREE;\n-  td = tsubst (decl_pattern, args, TREE_VEC_LENGTH (args), tmpl);\n+  /* FIXME this is ugly.  */\n+  td = tsubst (decl_pattern,\n+\t       DECL_TEMPLATE_SPECIALIZATION (decl_pattern)\n+\t       ? args : innermost_args (args), 0, tmpl);\n   SET_DECL_IMPLICIT_INSTANTIATION (td);\n   DECL_TEMPLATE_INFO (decl_pattern) = save_ti;\n "}, {"sha": "4a6ce7bfaeb68a2449a6dd9ba5fc9358d6df276f", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -66,9 +66,13 @@ print_lang_type (file, node, indent)\n      register tree node;\n      int indent;\n {\n-  if (TREE_CODE (node) == TEMPLATE_TYPE_PARM)\n+  if (TREE_CODE (node) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (node) == TEMPLATE_TEMPLATE_PARM)\n     {\n-      print_node (file, \"tinfo\", TYPE_VALUES (node), indent + 4);\n+      indent_to (file, indent + 3);\n+      fprintf (file, \"index %d level %d orig_level %d\",\n+\t       TEMPLATE_TYPE_IDX (node), TEMPLATE_TYPE_LEVEL (node),\n+\t       TEMPLATE_TYPE_ORIG_LEVEL (node));\n       return;\n     }\n "}, {"sha": "df391b52a2122d89dd2bbdcc722234a5a71399aa", "filename": "gcc/cp/search.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -794,7 +794,17 @@ static tree\n lookup_field_1 (type, name)\n      tree type, name;\n {\n-  register tree field = TYPE_FIELDS (type);\n+  register tree field;\n+\n+  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM)\n+    /* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM are not fields at all;\n+       instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,\n+       the code often worked even when we treated the index as a list\n+       of fields!)  */\n+    return NULL_TREE;\n+\n+  field = TYPE_FIELDS (type);\n \n #ifdef GATHER_STATISTICS\n   n_calls_lookup_field_1++;\n@@ -804,6 +814,7 @@ lookup_field_1 (type, name)\n #ifdef GATHER_STATISTICS\n       n_fields_searched++;\n #endif /* GATHER_STATISTICS */\n+      my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (field)) == 'd', 0);\n       if (DECL_NAME (field) == NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n \t{"}, {"sha": "b4799d42e68ebf48f6166fa147a3b9e28b1b126c", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -329,7 +329,7 @@ yylex ()\n \t    }\n \t}\n       else\n-\tlastiddecl = trrr;\n+\tlastiddecl = NULL_TREE;\n       got_scope = NULL_TREE;\n       /* and fall through to...  */\n     case IDENTIFIER_DEFN:"}, {"sha": "8fb0c9f586c4c960e9f82b820621329a8a1db1ed", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -2070,9 +2070,9 @@ cp_tree_equal (t1, t2)\n     case FUNCTION_DECL:\n       return 0;\n \n-    case TEMPLATE_CONST_PARM:\n-      return TEMPLATE_CONST_IDX (t1) == TEMPLATE_CONST_IDX (t2)\n-\t&& TEMPLATE_CONST_LEVEL (t1) == TEMPLATE_CONST_LEVEL (t2);\n+    case TEMPLATE_PARM_INDEX:\n+      return TEMPLATE_PARM_IDX (t1) == TEMPLATE_PARM_IDX (t2)\n+\t&& TEMPLATE_PARM_LEVEL (t1) == TEMPLATE_PARM_LEVEL (t2);\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:"}, {"sha": "3375f11db0f86dd3c3b9c101ee3286cb96e96114", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84b4be9a791b299137ac1605d5e058709dafb10/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f84b4be9a791b299137ac1605d5e058709dafb10", "patch": "@@ -2367,11 +2367,17 @@ build_x_function_call (function, params, decl)\n \t       || TREE_CODE (type) == METHOD_TYPE\n \t       || TYPE_PTRMEMFUNC_P (type));\n \n-  if (TREE_CODE (function) == FUNCTION_DECL\n-      && DECL_STATIC_FUNCTION_P (function))\n+  if ((TREE_CODE (function) == FUNCTION_DECL\n+       && DECL_STATIC_FUNCTION_P (function))\n+      || (TREE_CODE (function) == TEMPLATE_DECL\n+\t  && DECL_STATIC_FUNCTION_P (DECL_RESULT (function))))\n     return build_member_call\n       (DECL_CONTEXT (function), DECL_NAME (function), params);\n \n+  /* A friend template.  Make it look like a toplevel declaration.  */\n+  if (! is_method && TREE_CODE (function) == TEMPLATE_DECL)\n+    function = build_scratch_list (NULL_TREE, function);\n+\n   /* Handle methods, friends, and overloaded functions, respectively.  */\n   if (is_method)\n     {"}]}