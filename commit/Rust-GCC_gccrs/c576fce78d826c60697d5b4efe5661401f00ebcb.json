{"sha": "c576fce78d826c60697d5b4efe5661401f00ebcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU3NmZjZTc4ZDgyNmM2MDY5N2Q1YjRlZmU1NjYxNDAxZjAwZWJjYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-05-11T20:48:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-05-11T20:48:40Z"}, "message": "alpha.c (alpha_expand_block_move): Handle TImode registers used with ADDRESSOF.\n\n        * alpha.c (alpha_expand_block_move): Handle TImode registers\n        used with ADDRESSOF.\n        (alpha_expand_block_clear): Handle ADDRESSOF specially.\n\nFrom-SVN: r26892", "tree": {"sha": "9f5094000886b485e7737e6f049bf5f6cdd9a431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f5094000886b485e7737e6f049bf5f6cdd9a431"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c576fce78d826c60697d5b4efe5661401f00ebcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c576fce78d826c60697d5b4efe5661401f00ebcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c576fce78d826c60697d5b4efe5661401f00ebcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c576fce78d826c60697d5b4efe5661401f00ebcb/comments", "author": null, "committer": null, "parents": [{"sha": "a575e5d377c5cc1f020537b6315bc1a7dad2a6e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a575e5d377c5cc1f020537b6315bc1a7dad2a6e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a575e5d377c5cc1f020537b6315bc1a7dad2a6e7"}], "stats": {"total": 115, "additions": 87, "deletions": 28}, "files": [{"sha": "7812e47ca93b168203ebdbf21345fd8fc45d3ad6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c576fce78d826c60697d5b4efe5661401f00ebcb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c576fce78d826c60697d5b4efe5661401f00ebcb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c576fce78d826c60697d5b4efe5661401f00ebcb", "patch": "@@ -1,3 +1,9 @@\n+Tue May 11 20:46:37 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.c (alpha_expand_block_move): Handle TImode registers\n+\tused with ADDRESSOF.\n+\t(alpha_expand_block_clear): Handle ADDRESSOF specially.\n+\n 1999-05-11  Ulrich Drepper  <drepper@cygnus.com>\n \n \t* fixinc/fixinc.x86-linux-gnu (FD_ZERO): Remove unneccessary"}, {"sha": "52e76bab38c1f4fb112c7d2b92f0105535d62ab3", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 81, "deletions": 28, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c576fce78d826c60697d5b4efe5661401f00ebcb/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c576fce78d826c60697d5b4efe5661401f00ebcb/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=c576fce78d826c60697d5b4efe5661401f00ebcb", "patch": "@@ -1961,17 +1961,24 @@ alpha_expand_block_move (operands)\n       enum machine_mode mode;\n       tmp = XEXP (XEXP (orig_src, 0), 0);\n \n+      /* Don't use the existing register if we're reading more than\n+\t is held in the register.  Nor if there is not a mode that\n+\t handles the exact size.  */\n       mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 1);\n       if (mode != BLKmode\n-\t  && GET_MODE_SIZE (GET_MODE (tmp)) <= bytes)\n+\t  && GET_MODE_SIZE (GET_MODE (tmp)) >= bytes)\n \t{\n-\t  /* Whee!  Optimize the load to use the existing register.  */\n-\t  data_regs[nregs++] = gen_lowpart (mode, tmp);\n+\t  if (mode == TImode)\n+\t    {\n+\t      data_regs[nregs] = gen_lowpart (DImode, tmp);\n+\t      data_regs[nregs+1] = gen_highpart (DImode, tmp);\n+\t      nregs += 2;\n+\t    }\n+\t  else\n+\t    data_regs[nregs++] = gen_lowpart (mode, tmp);\n \t  goto src_done;\n \t}\n \n-      /* ??? We could potentially be copying 3 bytes or whatnot from\n-\t a wider reg.  Probably not worth worrying about.  */\n       /* No appropriate mode; fall back on memory.  */\n       orig_src = change_address (orig_src, GET_MODE (orig_src),\n \t\t\t\t copy_addr_to_reg (XEXP (orig_src, 0)));\n@@ -1988,9 +1995,9 @@ alpha_expand_block_move (operands)\n       for (i = 0; i < words; ++i)\n \t{\n \t  emit_move_insn (data_regs[nregs+i],\n-\t\t\t  change_address(orig_src, DImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_src, 0),\n-\t\t\t\t\t\t\tofs + i*8)));\n+\t\t\t  change_address (orig_src, DImode,\n+\t\t\t\t\t  plus_constant (XEXP (orig_src, 0),\n+\t\t\t\t\t\t\t ofs + i*8)));\n \t}\n \n       nregs += words;\n@@ -2007,9 +2014,9 @@ alpha_expand_block_move (operands)\n       for (i = 0; i < words; ++i)\n \t{\n \t  emit_move_insn (data_regs[nregs+i],\n-\t\t\t  change_address(orig_src, SImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_src, 0),\n-\t\t\t\t\t\t\tofs + i*4)));\n+\t\t\t  change_address (orig_src, SImode,\n+\t\t\t\t\t  plus_constant (XEXP (orig_src, 0),\n+\t\t\t\t\t\t\t ofs + i*4)));\n \t}\n \n       nregs += words;\n@@ -2023,7 +2030,8 @@ alpha_expand_block_move (operands)\n       for (i = 0; i < words+1; ++i)\n \tdata_regs[nregs+i] = gen_reg_rtx(DImode);\n \n-      alpha_expand_unaligned_load_words(data_regs+nregs, orig_src, words, ofs);\n+      alpha_expand_unaligned_load_words (data_regs + nregs, orig_src,\n+\t\t\t\t\t words, ofs);\n \n       nregs += words;\n       bytes -= words * 8;\n@@ -2092,11 +2100,40 @@ alpha_expand_block_move (operands)\n       tmp = XEXP (XEXP (orig_dst, 0), 0);\n \n       mode = mode_for_size (orig_bytes * BITS_PER_UNIT, MODE_INT, 1);\n-      if (GET_MODE (tmp) == mode && nregs == 1)\n+      if (GET_MODE (tmp) == mode)\n \t{\n-\t  emit_move_insn (tmp, data_regs[0]);\n-\t  i = 1;\n-\t  goto dst_done;\n+\t  if (nregs == 1)\n+\t    {\n+\t      emit_move_insn (tmp, data_regs[0]);\n+\t      i = 1;\n+\t      goto dst_done;\n+\t    }\n+\t  else if (nregs == 2 && mode == TImode)\n+\t    {\n+\t      /* Undo the subregging done above when copying between\n+\t\t two TImode registers.  */\n+\t      if (GET_CODE (data_regs[0]) == SUBREG\n+\t\t  && GET_MODE (SUBREG_REG (data_regs[0])) == TImode)\n+\t\t{\n+\t\t  emit_move_insn (tmp, SUBREG_REG (data_regs[0]));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx seq;\n+\n+\t\t  start_sequence ();\n+\t\t  emit_move_insn (gen_lowpart (DImode, tmp), data_regs[0]);\n+\t\t  emit_move_insn (gen_highpart (DImode, tmp), data_regs[1]);\n+\t\t  seq = gen_sequence ();\n+\t\t  end_sequence ();\n+\n+\t\t  emit_no_conflict_block (seq, tmp, data_regs[0],\n+\t\t\t\t\t  data_regs[1], NULL_RTX);\n+\t\t}\n+\n+\t      i = 2;\n+\t      goto dst_done;\n+\t    }\n \t}\n \n       /* ??? If nregs > 1, consider reconstructing the word in regs.  */\n@@ -2114,9 +2151,9 @@ alpha_expand_block_move (operands)\n     {\n       while (i < nregs && GET_MODE (data_regs[i]) == DImode)\n \t{\n-\t  emit_move_insn (change_address(orig_dst, DImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\tofs)),\n+\t  emit_move_insn (change_address (orig_dst, DImode,\n+\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\t ofs)),\n \t\t\t  data_regs[i]);\n \t  ofs += 8;\n \t  i++;\n@@ -2131,13 +2168,13 @@ alpha_expand_block_move (operands)\n \t  tmp = expand_binop (DImode, lshr_optab, data_regs[i], GEN_INT (32),\n \t\t\t      NULL_RTX, 1, OPTAB_WIDEN);\n \n-\t  emit_move_insn (change_address(orig_dst, SImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\tofs)),\n+\t  emit_move_insn (change_address (orig_dst, SImode,\n+\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\t ofs)),\n \t\t\t  gen_lowpart (SImode, data_regs[i]));\n-\t  emit_move_insn (change_address(orig_dst, SImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\tofs+4)),\n+\t  emit_move_insn (change_address (orig_dst, SImode,\n+\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\t ofs+4)),\n \t\t\t  gen_lowpart (SImode, tmp));\n \t  ofs += 8;\n \t  i++;\n@@ -2256,6 +2293,22 @@ alpha_expand_block_clear (operands)\n \t    align = 2;\n \t}\n     }\n+  else if (GET_CODE (tmp) == ADDRESSOF)\n+    {\n+      enum machine_mode mode;\n+\n+      mode = mode_for_size (bytes * BITS_PER_UNIT, MODE_INT, 1);\n+      if (GET_MODE (XEXP (tmp, 0)) == mode)\n+\t{\n+\t  emit_move_insn (XEXP (tmp, 0), const0_rtx);\n+\t  return 1;\n+\t}\n+\n+      /* No appropriate mode; fall back on memory.  */\n+      orig_dst = change_address (orig_dst, GET_MODE (orig_dst),\n+\t\t\t\t copy_addr_to_reg (tmp));\n+      align = GET_MODE_SIZE (GET_MODE (XEXP (tmp, 0)));\n+    }\n \n   /* Handle a block of contiguous words first.  */\n \n@@ -2280,9 +2333,9 @@ alpha_expand_block_clear (operands)\n \n       for (i = 0; i < words; ++i)\n \t{\n-\t  emit_move_insn (change_address(orig_dst, SImode,\n-\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n-\t\t\t\t\t\t\tofs + i*4)),\n+\t  emit_move_insn (change_address (orig_dst, SImode,\n+\t\t\t\t\t  plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\t ofs + i*4)),\n \t\t\t  const0_rtx);\n \t}\n "}]}