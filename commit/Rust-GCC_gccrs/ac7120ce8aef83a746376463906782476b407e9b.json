{"sha": "ac7120ce8aef83a746376463906782476b407e9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM3MTIwY2U4YWVmODNhNzQ2Mzc2NDYzOTA2NzgyNDc2YjQwN2U5Yg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-07-10T09:43:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-10T09:43:01Z"}, "message": "exp_util.adb: Minor code reorganization (use N_Short_Circuit)\n\n2009-07-10  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb: Minor code reorganization (use N_Short_Circuit)\n\n\t* exp_ch4.adb: Add ??? comment for conditional expressions on limited\n\ttypes.\n\n\t* checks.adb (In_Declarative_Region_Of_Subprogram_Body): New procedure,\n\treplaces Safe_To_Capture_In_Parameter_Value, and properly handles the\n\tcase of conditional expressions that may not be elaborated.\n\n\t* sem_util.adb (Safe_To_Capture_Value): Properly handle case of\n\tconditional expression where we may not execute then then or else\n\tbranches.\n\nFrom-SVN: r149468", "tree": {"sha": "bf8ec6369279befb0c1ca83ba47a811a30dadbd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf8ec6369279befb0c1ca83ba47a811a30dadbd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac7120ce8aef83a746376463906782476b407e9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7120ce8aef83a746376463906782476b407e9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7120ce8aef83a746376463906782476b407e9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7120ce8aef83a746376463906782476b407e9b/comments", "author": null, "committer": null, "parents": [{"sha": "514d0fc530d487c2f3819f59e5f2ca508f419a5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/514d0fc530d487c2f3819f59e5f2ca508f419a5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/514d0fc530d487c2f3819f59e5f2ca508f419a5d"}], "stats": {"total": 125, "additions": 88, "deletions": 37}, "files": [{"sha": "32957bc52c9dde3e8cabab7d850c3c98c2a3b4d8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ac7120ce8aef83a746376463906782476b407e9b", "patch": "@@ -1,3 +1,18 @@\n+2009-07-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb: Minor code reorganization (use N_Short_Circuit)\n+\n+\t* exp_ch4.adb: Add ??? comment for conditional expressions on limited\n+\ttypes.\n+\n+\t* checks.adb (In_Declarative_Region_Of_Subprogram_Body): New procedure,\n+\treplaces Safe_To_Capture_In_Parameter_Value, and properly handles the\n+\tcase of conditional expressions that may not be elaborated.\n+\n+\t* sem_util.adb (Safe_To_Capture_Value): Properly handle case of\n+\tconditional expression where we may not execute then then or else\n+\tbranches.\n+\n 2009-07-10  Arnaud Charlet  <charlet@adacore.com>\n \n \t* i-cexten.ads (bool): New type."}, {"sha": "7f78a5ed5d055c34de508987c9860cbd55f60a7f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=ac7120ce8aef83a746376463906782476b407e9b", "patch": "@@ -5253,31 +5253,31 @@ package body Checks is\n       Loc : constant Source_Ptr := Sloc (N);\n       Typ : constant Entity_Id  := Etype (N);\n \n-      function In_Declarative_Region_Of_Subprogram_Body return Boolean;\n-      --  Determine whether node N, a reference to an *in* parameter, is\n-      --  inside the declarative region of the current subprogram body.\n+      function Safe_To_Capture_In_Parameter_Value return Boolean;\n+      --  Determines if it is safe to capture Known_Non_Null status for an\n+      --  the entity referenced by node N. The caller ensures that N is indeed\n+      --  an entity name. It is safe to capture the non-null status for an IN\n+      --  parameter when the reference occurs within a declaration that is sure\n+      --  to be executed as part of the declarative region.\n \n       procedure Mark_Non_Null;\n       --  After installation of check, if the node in question is an entity\n       --  name, then mark this entity as non-null if possible.\n \n-      ----------------------------------------------\n-      -- In_Declarative_Region_Of_Subprogram_Body --\n-      ----------------------------------------------\n-\n-      function In_Declarative_Region_Of_Subprogram_Body return Boolean is\n+      function Safe_To_Capture_In_Parameter_Value return Boolean is\n          E     : constant Entity_Id := Entity (N);\n          S     : constant Entity_Id := Current_Scope;\n          S_Par : Node_Id;\n \n       begin\n-         pragma Assert (Ekind (E) = E_In_Parameter);\n+         if Ekind (E) /= E_In_Parameter then\n+            return False;\n+         end if;\n \n          --  Two initial context checks. We must be inside a subprogram body\n          --  with declarations and reference must not appear in nested scopes.\n \n-         if (Ekind (S) /= E_Function\n-             and then Ekind (S) /= E_Procedure)\n+         if (Ekind (S) /= E_Function and then Ekind (S) /= E_Procedure)\n            or else Scope (E) /= S\n          then\n             return False;\n@@ -5303,6 +5303,26 @@ package body Checks is\n             N_Decl := Empty;\n             while Present (P) loop\n \n+               --  If we have a short circuit form, and we are within the right\n+               --  hand expression, we return false, since the right hand side\n+               --  is not guaranteed to be elaborated.\n+\n+               if Nkind (P) in N_Short_Circuit\n+                 and then N = Right_Opnd (P)\n+               then\n+                  return False;\n+               end if;\n+\n+               --  Similarly, if we are in a conditional expression and not\n+               --  part of the condition, then we return False, since neither\n+               --  the THEN or ELSE expressions will always be elaborated.\n+\n+               if Nkind (P) = N_Conditional_Expression\n+                 and then N /= First (Expressions (P))\n+               then\n+                  return False;\n+               end if;\n+\n                --  While traversing the parent chain, we find that N\n                --  belongs to a statement, thus it may never appear in\n                --  a declarative region.\n@@ -5313,6 +5333,8 @@ package body Checks is\n                   return False;\n                end if;\n \n+               --  If we are at a declaration, record it and exit\n+\n                if Nkind (P) in N_Declaration\n                  and then Nkind (P) not in N_Subprogram_Specification\n                then\n@@ -5329,7 +5351,7 @@ package body Checks is\n \n             return List_Containing (N_Decl) = Declarations (S_Par);\n          end;\n-      end In_Declarative_Region_Of_Subprogram_Body;\n+      end Safe_To_Capture_In_Parameter_Value;\n \n       -------------------\n       -- Mark_Non_Null --\n@@ -5350,13 +5372,14 @@ package body Checks is\n             --  safe to capture the value, or in the case of an IN parameter,\n             --  which is a constant, if the check we just installed is in the\n             --  declarative region of the subprogram body. In this latter case,\n-            --  a check is decisive for the rest of the body, since we know we\n-            --  must complete all declarations before executing the body.\n+            --  a check is decisive for the rest of the body if the expression\n+            --  is sure to be elaborated, since we know we have to elaborate\n+            --  all declarations before executing the body.\n+\n+            --  Couldn't this always be part of Safe_To_Capture_Value ???\n \n             if Safe_To_Capture_Value (N, Entity (N))\n-              or else\n-                (Ekind (Entity (N)) = E_In_Parameter\n-                   and then In_Declarative_Region_Of_Subprogram_Body)\n+              or else Safe_To_Capture_In_Parameter_Value\n             then\n                Set_Is_Known_Non_Null (Entity (N));\n             end if;"}, {"sha": "87ba03793d9a5a0f63c65dbf392458cb7108536e", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ac7120ce8aef83a746376463906782476b407e9b", "patch": "@@ -3987,8 +3987,7 @@ package body Exp_Ch4 is\n \n          else pragma Assert (Expr_Value_E (Right) = Standard_False);\n             Remove_Side_Effects (Left);\n-            Rewrite\n-              (N, New_Occurrence_Of (Standard_False, Loc));\n+            Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n          end if;\n       end if;\n \n@@ -4028,6 +4027,21 @@ package body Exp_Ch4 is\n \n       --  and replace the conditional expression by a reference to Cnn\n \n+      --  ??? Note: this expansion is wrong for limited types, since it does\n+      --  a copy of a limited value. The proper fix would be to do the\n+      --  following expansion:\n+\n+      --      Cnn : access typ;\n+      --      if cond then\n+      --         <<then actions>>\n+      --         Cnn := then-expr'Unrestricted_Access;\n+      --      else\n+      --         <<else actions>>\n+      --         Cnn := else-expr'Unrestricted_Access;\n+      --      end if;\n+\n+      --  and replace the conditional expresion by a reference to Cnn.all ???\n+\n       if Present (Then_Actions (N)) or else Present (Else_Actions (N)) then\n          Cnn := Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n "}, {"sha": "1de9c6e83968af911ce7761f6b837e5a67001d70", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=ac7120ce8aef83a746376463906782476b407e9b", "patch": "@@ -255,9 +255,8 @@ package body Exp_Util is\n             --  to reset its type, since Standard.Boolean is just fine, and\n             --  such operations always do Adjust_Condition on their operands.\n \n-            elsif KP in N_Op_Boolean\n-              or else KP = N_And_Then\n-              or else KP = N_Or_Else\n+            elsif     KP in N_Op_Boolean\n+              or else KP in N_Short_Circuit\n               or else KP = N_Op_Not\n             then\n                return;\n@@ -2305,7 +2304,7 @@ package body Exp_Util is\n             --  Nothing special needs to be done for the left operand since\n             --  in that case the actions are executed unconditionally.\n \n-            when N_And_Then | N_Or_Else =>\n+            when N_Short_Circuit =>\n                if N = Right_Opnd (P) then\n \n                   --  We are now going to either append the actions to the\n@@ -4395,12 +4394,10 @@ package body Exp_Util is\n             --  are side effect free. For this purpose binary operators\n             --  include membership tests and short circuit forms\n \n-            when N_Binary_Op       |\n-                 N_Membership_Test |\n-                 N_And_Then        |\n-                 N_Or_Else         =>\n+            when N_Binary_Op | N_Membership_Test | N_Short_Circuit =>\n                return Side_Effect_Free (Left_Opnd  (N))\n-                 and then Side_Effect_Free (Right_Opnd (N));\n+                        and then\n+                      Side_Effect_Free (Right_Opnd (N));\n \n             --  An explicit dereference is side effect free only if it is\n             --  a side effect free prefixed reference."}, {"sha": "e7371b03c363a704d7ed777d3d7dc95b50e928a3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7120ce8aef83a746376463906782476b407e9b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ac7120ce8aef83a746376463906782476b407e9b", "patch": "@@ -7155,7 +7155,7 @@ package body Sem_Util is\n          when N_Assignment_Statement =>\n             return N = Name (P);\n \n-            --  Function call arguments are never lvalues\n+            --  Function call arguments are never Lvalues\n \n          when N_Function_Call =>\n             return False;\n@@ -7241,7 +7241,7 @@ package body Sem_Util is\n             end;\n \n          --  Test for appearing in a conversion that itself appears\n-         --  in an lvalue context, since this should be an lvalue.\n+         --  in an Lvalue context, since this should be an Lvalue.\n \n          when N_Type_Conversion =>\n             return Known_To_Be_Assigned (P);\n@@ -7276,8 +7276,8 @@ package body Sem_Util is\n             return N = Prefix (P)\n               and then Name_Implies_Lvalue_Prefix (Attribute_Name (P));\n \n-         --  For an expanded name, the name is an lvalue if the expanded name\n-         --  is an lvalue, but the prefix is never an lvalue, since it is just\n+         --  For an expanded name, the name is an Lvalue if the expanded name\n+         --  is an Lvalue, but the prefix is never an Lvalue, since it is just\n          --  the scope where the name is found.\n \n          when N_Expanded_Name        =>\n@@ -7304,7 +7304,7 @@ package body Sem_Util is\n             end if;\n \n          --  For an indexed component or slice, the index or slice bounds is\n-         --  never an Lvalue. The prefix is an lvalue if the indexed component\n+         --  never an Lvalue. The prefix is an Lvalue if the indexed component\n          --  or slice is an Lvalue, except if it is an access type, where we\n          --  have an implicit dereference.\n \n@@ -7414,7 +7414,7 @@ package body Sem_Util is\n             end;\n \n          --  Test for appearing in a conversion that itself appears in an\n-         --  lvalue context, since this should be an lvalue.\n+         --  Lvalue context, since this should be an Lvalue.\n \n          when N_Type_Conversion =>\n             return May_Be_Lvalue (P);\n@@ -9819,10 +9819,12 @@ package body Sem_Util is\n \n          P := Parent (N);\n          while Present (P) loop\n-            if Nkind (P) = N_If_Statement\n+            if         Nkind (P) = N_If_Statement\n               or else  Nkind (P) = N_Case_Statement\n-              or else (Nkind (P) = N_And_Then and then Desc = Right_Opnd (P))\n-              or else (Nkind (P) = N_Or_Else and then Desc = Right_Opnd (P))\n+              or else (Nkind (P) in N_Short_Circuit\n+                         and then Desc = Right_Opnd (P))\n+              or else (Nkind (P) = N_Conditional_Expression\n+                         and then Desc /= First (Expressions (P)))\n               or else  Nkind (P) = N_Exception_Handler\n               or else  Nkind (P) = N_Selective_Accept\n               or else  Nkind (P) = N_Conditional_Entry_Call"}]}