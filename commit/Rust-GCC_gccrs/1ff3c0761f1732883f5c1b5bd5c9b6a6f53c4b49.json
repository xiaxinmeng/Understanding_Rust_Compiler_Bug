{"sha": "1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmM2MwNzYxZjE3MzI4ODNmNWMxYjViZDVjOWI2YTZmNTNjNGI0OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-13T21:11:52Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-13T21:11:52Z"}, "message": "re PR c++/16518 (mutable specifier only applies to first item in declaration list)\n\n\tPR c++/16518\n\tPR c++/16337\n\t* decl.c (grokvardecl): Make declspecs parameter const.\n\t(grokdeclarator): Likewise.  Adjust accordingly.\n\t* decl.h (grokdeclarator): Adjust declaration.\n\t* parser.c (cp_parser_init_declarator): Do not clear\n\tdecl_specifiers->attributes.\n\n\tPR c++/16518\n\t* g++.dg/parse/mutable1.C: New test.\n\nFrom-SVN: r84646", "tree": {"sha": "1e862cf0788265164b6363afd1db1902f296dfd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e862cf0788265164b6363afd1db1902f296dfd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/comments", "author": null, "committer": null, "parents": [{"sha": "5549179ffbab093da7b35296973c2a287ad60f20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5549179ffbab093da7b35296973c2a287ad60f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5549179ffbab093da7b35296973c2a287ad60f20"}], "stats": {"total": 214, "additions": 110, "deletions": 104}, "files": [{"sha": "0cf8261cd05486d25bc6861e2b1f070344a11828", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "patch": "@@ -1,5 +1,13 @@\n 2004-07-13  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/16518\n+\tPR c++/16337\n+\t* decl.c (grokvardecl): Make declspecs parameter const.\n+\t(grokdeclarator): Likewise.  Adjust accordingly.\n+\t* decl.h (grokdeclarator): Adjust declaration.\n+\t* parser.c (cp_parser_init_declarator): Do not clear\n+\tdecl_specifiers->attributes.\n+\n \t* cp-tree.h (lang_identifier): Remove class_value.\n \t(IDENTIFIER_CLASS_VALUE): Remove.\n \t(pop_class_decls): Likewise."}, {"sha": "39e4d55e07ddce7a5bcbba331e9181abf9045418", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 89, "deletions": 102, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "patch": "@@ -64,7 +64,8 @@ static tree grok_reference_init (tree, tree, tree, tree *);\n static tree grokfndecl (tree, tree, tree, tree, tree, int,\n \t\t\tenum overload_flags, cp_cv_quals,\n \t\t\ttree, int, int, int, int, int, int, tree);\n-static tree grokvardecl (tree, tree, cp_decl_specifier_seq *, int, int, tree);\n+static tree grokvardecl (tree, tree, const cp_decl_specifier_seq *, \n+\t\t\t int, int, tree);\n static void record_unknown_type (tree, const char *);\n static tree builtin_function_1 (const char *, tree, tree, int,\n                                 enum built_in_class, const char *,\n@@ -5708,7 +5709,7 @@ grokfndecl (tree ctype,\n static tree\n grokvardecl (tree type,\n              tree name,\n-\t     cp_decl_specifier_seq *declspecs,\n+\t     const cp_decl_specifier_seq *declspecs,\n              int initialized,\n              int constp,\n              tree scope)\n@@ -6246,7 +6247,7 @@ check_special_function_return_type (special_function_kind sfk,\n \n tree\n grokdeclarator (const cp_declarator *declarator,\n-\t\tcp_decl_specifier_seq *declspecs,\n+\t\tconst cp_decl_specifier_seq *declspecs,\n                 enum decl_context decl_context,\n                 int initialized,\n                 tree* attrlist)\n@@ -6299,6 +6300,14 @@ grokdeclarator (const cp_declarator *declarator,\n      namespace scope.  */ \n   tree in_namespace = NULL_TREE;\n   cp_decl_spec ds;\n+  cp_storage_class storage_class;\n+  bool unsigned_p, signed_p, short_p, long_p, thread_p;\n+\n+  signed_p = declspecs->specs[(int)ds_signed];\n+  unsigned_p = declspecs->specs[(int)ds_unsigned];\n+  short_p = declspecs->specs[(int)ds_short];\n+  long_p = declspecs->specs[(int)ds_long];\n+  thread_p = declspecs->specs[(int)ds_thread];\n \n   if (decl_context == FUNCDEF)\n     funcdef_flag = 1, decl_context = NORMAL;\n@@ -6507,11 +6516,7 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n   /* No type at all: default to `int', and set DEFAULTED_INT\n      because it was not a user-defined typedef.  */\n-  if (type == NULL_TREE\n-      && (declspecs->specs[(int)ds_signed]\n-\t  || declspecs->specs[(int)ds_unsigned]\n-\t  || declspecs->specs[(int)ds_long]\n-\t  || declspecs->specs[(int)ds_short]))\n+  if (type == NULL_TREE && (signed_p || unsigned_p || long_p || short_p))\n     {\n       /* These imply 'int'.  */\n       type = integer_type_node;\n@@ -6604,40 +6609,30 @@ grokdeclarator (const cp_declarator *declarator,\n      and check for invalid combinations.  */\n \n   /* Long double is a special combination.  */\n-  if (declspecs->specs[(int)ds_long]\n-      && TYPE_MAIN_VARIANT (type) == double_type_node)\n+  if (long_p && TYPE_MAIN_VARIANT (type) == double_type_node)\n     {\n-      declspecs->specs[(int)ds_long] = 0;\n+      long_p = false;\n       type = build_qualified_type (long_double_type_node,\n \t\t\t\t   cp_type_quals (type));\n     }\n \n   /* Check all other uses of type modifiers.  */\n \n-  if (declspecs->specs[(int)ds_unsigned]\n-      || declspecs->specs[(int)ds_signed]\n-      || declspecs->specs[(int)ds_long]\n-      || declspecs->specs[(int)ds_short])\n+  if (unsigned_p || signed_p || long_p || short_p)\n     {\n       int ok = 0;\n \n       if (TREE_CODE (type) == REAL_TYPE)\n \terror (\"short, signed or unsigned invalid for `%s'\", name);\n       else if (TREE_CODE (type) != INTEGER_TYPE)\n \terror (\"long, short, signed or unsigned invalid for `%s'\", name);\n-      else if (declspecs->specs[(int)ds_long]\n-\t       && declspecs->specs[(int)ds_short])\n+      else if (long_p && short_p)\n \terror (\"long and short specified together for `%s'\", name);\n-      else if ((declspecs->specs[(int)ds_long]\n-\t\t|| declspecs->specs[(int)ds_short])\n-\t       && explicit_char)\n+      else if ((long_p || short_p) && explicit_char)\n \terror (\"long or short specified with char for `%s'\", name);\n-      else if ((declspecs->specs[(int)ds_long]\n-\t\t|| declspecs->specs[(int)ds_short])\n-\t       && TREE_CODE (type) == REAL_TYPE)\n+      else if ((long_p|| short_p) && TREE_CODE (type) == REAL_TYPE)\n \terror (\"long or short specified with floating type for `%s'\", name);\n-      else if (declspecs->specs[(int)ds_signed]\n-\t       && declspecs->specs[(int)ds_unsigned])\n+      else if (signed_p && unsigned_p)\n \terror (\"signed and unsigned given together for `%s'\", name);\n       else\n \t{\n@@ -6654,24 +6649,17 @@ grokdeclarator (const cp_declarator *declarator,\n       /* Discard the type modifiers if they are invalid.  */\n       if (! ok)\n \t{\n-\t  declspecs->specs[(int)ds_unsigned] = 0;\n-\t  declspecs->specs[(int)ds_signed] = 0;\n-\t  declspecs->specs[(int)ds_long] = 0;\n-\t  declspecs->specs[(int)ds_short] = 0;\n+\t  unsigned_p = false;\n+\t  signed_p = false;\n+\t  long_p = false;\n+\t  short_p = false;\n \t  longlong = 0;\n \t}\n     }\n \n-  if (declspecs->specs[(int)ds_complex]\n-      && TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n-    {\n-      error (\"complex invalid for `%s'\", name);\n-      declspecs->specs[(int)ds_complex] = 0;\n-    }\n-\n   /* Decide whether an integer type is signed or not.\n      Optionally treat bitfields as signed by default.  */\n-  if (declspecs->specs[(int)ds_unsigned]\n+  if (unsigned_p\n       /* [class.bit]\n \n \t It is implementation-defined whether a plain (neither\n@@ -6681,7 +6669,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t Naturally, we extend this to long long as well.  Note that\n \t this does not include wchar_t.  */\n       || (bitfield && !flag_signed_bitfields\n-\t  && !declspecs->specs[(int)ds_signed]\n+\t  && !signed_p\n \t  /* A typedef for plain `int' without `signed' can be\n \t     controlled just like plain `int', but a typedef for\n \t     `signed int' cannot be so controlled.  */\n@@ -6693,9 +6681,9 @@ grokdeclarator (const cp_declarator *declarator,\n     {\n       if (longlong)\n \ttype = long_long_unsigned_type_node;\n-      else if (declspecs->specs[(int)ds_long])\n+      else if (long_p)\n \ttype = long_unsigned_type_node;\n-      else if (declspecs->specs[(int)ds_short])\n+      else if (short_p)\n \ttype = short_unsigned_type_node;\n       else if (type == char_type_node)\n \ttype = unsigned_char_type_node;\n@@ -6704,28 +6692,26 @@ grokdeclarator (const cp_declarator *declarator,\n       else\n \ttype = unsigned_type_node;\n     }\n-  else if (declspecs->specs[(int)ds_signed]\n-\t   && type == char_type_node)\n+  else if (signed_p && type == char_type_node)\n     type = signed_char_type_node;\n   else if (longlong)\n     type = long_long_integer_type_node;\n-  else if (declspecs->specs[(int)ds_long])\n+  else if (long_p)\n     type = long_integer_type_node;\n-  else if (declspecs->specs[(int)ds_short])\n+  else if (short_p)\n     type = short_integer_type_node;\n \n   if (declspecs->specs[(int)ds_complex])\n     {\n+      if (TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n+\terror (\"complex invalid for `%s'\", name);\n       /* If we just have \"complex\", it is equivalent to\n \t \"complex double\", but if any modifiers at all are specified it is\n \t the complex form of TYPE.  E.g, \"complex short\" is\n \t \"complex short int\".  */\n \n-      if (defaulted_int && ! longlong\n-\t  && ! (declspecs->specs[(int)ds_long]\n-\t\t|| declspecs->specs[(int)ds_short]\n-\t\t|| declspecs->specs[(int)ds_signed]\n-\t\t|| declspecs->specs[(int)ds_unsigned]))\n+      else if (defaulted_int && ! longlong\n+\t       && ! (long_p || short_p || signed_p || unsigned_p))\n \ttype = complex_double_type_node;\n       else if (type == integer_type_node)\n \ttype = complex_integer_type_node;\n@@ -6762,7 +6748,8 @@ grokdeclarator (const cp_declarator *declarator,\n   virtualp = !! declspecs->specs[(int)ds_virtual];\n   explicitp = !! declspecs->specs[(int)ds_explicit];\n \n-  if (declspecs->storage_class == sc_static)\n+  storage_class = declspecs->storage_class;\n+  if (storage_class == sc_static)\n     staticp = 1 + (decl_context == FIELD);\n \n   if (virtualp && staticp == 2)\n@@ -6784,9 +6771,9 @@ grokdeclarator (const cp_declarator *declarator,\n     {\n       if (declspecs->specs[(int)ds_typedef])\n \terror (\"typedef declaration invalid in parameter declaration\");\n-      else if (declspecs->storage_class == sc_static\n-\t       || declspecs->storage_class == sc_extern\n-\t       || declspecs->specs[(int)ds_thread])\n+      else if (storage_class == sc_static\n+\t       || storage_class == sc_extern\n+\t       || thread_p)\n \terror (\"storage class specifiers invalid in parameter declarations\");\n     }\n \n@@ -6808,29 +6795,29 @@ grokdeclarator (const cp_declarator *declarator,\n      kinds of declarations (parameters, typenames, etc.).  */\n   if (declspecs->multiple_storage_classes_p)\n     error (\"multiple storage classes in declaration of `%s'\", name);\n-  else if (declspecs->specs[(int)ds_thread]\n-\t   && ((declspecs->storage_class \n-\t\t&& declspecs->storage_class != sc_extern\n-\t\t&& declspecs->storage_class != sc_static)\n+  else if (thread_p\n+\t   && ((storage_class \n+\t\t&& storage_class != sc_extern\n+\t\t&& storage_class != sc_static)\n \t       || declspecs->specs[(int)ds_typedef]))\n     {\n       error (\"multiple storage classes in declaration of `%s'\", name);\n-      declspecs->specs[(int)ds_thread] = 0;\n+      thread_p = false;\n     }\n   else if (decl_context != NORMAL \n-\t   && ((declspecs->storage_class != sc_none\n-\t\t&& declspecs->storage_class != sc_mutable)\n-\t       || declspecs->specs[(int)ds_thread]))\n+\t   && ((storage_class != sc_none\n+\t\t&& storage_class != sc_mutable)\n+\t       || thread_p))\n     {\n       if ((decl_context == PARM || decl_context == CATCHPARM)\n-\t  && (declspecs->storage_class == sc_register\n-\t      || declspecs->storage_class == sc_auto))\n+\t  && (storage_class == sc_register\n+\t      || storage_class == sc_auto))\n \t;\n       else if (declspecs->specs[(int)ds_typedef])\n \t;\n       else if (decl_context == FIELD\n \t       /* C++ allows static class elements.  */\n-\t       && declspecs->storage_class == sc_static)\n+\t       && storage_class == sc_static)\n \t/* C++ also allows inlines and signed and unsigned elements,\n \t   but in those cases we don't come in here.  */\n \t;\n@@ -6868,14 +6855,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t      else\n \t\terror (\"storage class specified for typename\");\n \t    }\n-\t  if (declspecs->storage_class == sc_register\n-\t      || declspecs->storage_class == sc_auto\n-\t      || declspecs->storage_class == sc_extern\n-\t      || declspecs->specs[(int)ds_thread])\n-\t    declspecs->storage_class = sc_none;\n+\t  if (storage_class == sc_register\n+\t      || storage_class == sc_auto\n+\t      || storage_class == sc_extern\n+\t      || thread_p)\n+\t    storage_class = sc_none;\n \t}\n     }\n-  else if (declspecs->storage_class == sc_extern && initialized \n+  else if (storage_class == sc_extern && initialized \n \t   && !funcdef_flag)\n     {\n       if (toplevel_bindings_p ())\n@@ -6888,24 +6875,24 @@ grokdeclarator (const cp_declarator *declarator,\n       else\n \terror (\"`%s' has both `extern' and initializer\", name);\n     }\n-  else if (declspecs->storage_class == sc_extern && funcdef_flag\n+  else if (storage_class == sc_extern && funcdef_flag\n \t   && ! toplevel_bindings_p ())\n     error (\"nested function `%s' declared `extern'\", name);\n   else if (toplevel_bindings_p ())\n     {\n-      if (declspecs->storage_class == sc_auto)\n+      if (storage_class == sc_auto)\n \terror (\"top-level declaration of `%s' specifies `auto'\", name);\n     }\n-  else if (declspecs->specs[(int)ds_thread]\n-\t   && declspecs->storage_class != sc_extern\n-\t   && declspecs->storage_class != sc_static)\n+  else if (thread_p\n+\t   && storage_class != sc_extern\n+\t   && storage_class != sc_static)\n     {\n       error (\"function-scope `%s' implicitly auto and declared `__thread'\",\n \t     name);\n-      declspecs->specs[(int)ds_thread] = 0;\n+      thread_p = false;\n     }\n \n-  if (declspecs->storage_class && friendp)\n+  if (storage_class && friendp)\n     error (\"storage class specifiers invalid in friend function declarations\");\n \n   if (!id_declarator)\n@@ -7334,33 +7321,33 @@ grokdeclarator (const cp_declarator *declarator,\n       explicitp = 0;\n     }\n \n-  if (declspecs->storage_class == sc_mutable)\n+  if (storage_class == sc_mutable)\n     {\n       if (decl_context != FIELD || friendp)\n         {\n \t  error (\"non-member `%s' cannot be declared `mutable'\", name);\n-\t  declspecs->storage_class = sc_none;\n+\t  storage_class = sc_none;\n         }\n       else if (decl_context == TYPENAME || declspecs->specs[(int)ds_typedef])\n \t{\n \t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n-\t  declspecs->storage_class = sc_none;\n+\t  storage_class = sc_none;\n \t}\n       else if (TREE_CODE (type) == FUNCTION_TYPE\n                || TREE_CODE (type) == METHOD_TYPE)\n         {\n \t  error (\"function `%s' cannot be declared `mutable'\", name);\n-\t  declspecs->storage_class = sc_none;\n+\t  storage_class = sc_none;\n         }\n       else if (staticp)\n \t{\n \t  error (\"static `%s' cannot be declared `mutable'\", name);\n-\t  declspecs->storage_class = sc_none;\n+\t  storage_class = sc_none;\n \t}\n       else if (type_quals & TYPE_QUAL_CONST)\n \t{\n \t  error (\"const `%s' cannot be declared `mutable'\", name);\n-\t  declspecs->storage_class = sc_none;\n+\t  storage_class = sc_none;\n \t}\n     }\n \n@@ -7440,7 +7427,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    grok_method_quals (ctype, decl, quals);\n \t}\n \n-      if (declspecs->specs[(int)ds_signed]\n+      if (signed_p\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n \n@@ -7857,10 +7844,10 @@ grokdeclarator (const cp_declarator *declarator,\n \t      {\n \t\tdecl = build_decl (FIELD_DECL, unqualified_id, type);\n \t\tDECL_NONADDRESSABLE_P (decl) = bitfield;\n-\t\tif (declspecs->storage_class == sc_mutable)\n+\t\tif (storage_class == sc_mutable)\n \t\t  {\n \t\t    DECL_MUTABLE_P (decl) = 1;\n-\t\t    declspecs->storage_class = sc_none;\n+\t\t    storage_class = sc_none;\n \t\t  }\n \t      }\n \n@@ -7882,22 +7869,22 @@ grokdeclarator (const cp_declarator *declarator,\n \telse\n \t  original_name = unqualified_id;\n \n-\tif (declspecs->storage_class == sc_auto)\n+\tif (storage_class == sc_auto)\n \t  error (\"storage class `auto' invalid for function `%s'\", name);\n-\telse if (declspecs->storage_class == sc_register)\n+\telse if (storage_class == sc_register)\n \t  error (\"storage class `register' invalid for function `%s'\", name);\n-\telse if (declspecs->specs[(int)ds_thread])\n+\telse if (thread_p)\n \t  error (\"storage class `__thread' invalid for function `%s'\", name);\n \n \t/* Function declaration not at top level.\n \t   Storage classes other than `extern' are not allowed\n \t   and `extern' makes no difference.  */\n \tif (! toplevel_bindings_p ()\n-\t    && (declspecs->storage_class == sc_static\n+\t    && (storage_class == sc_static\n \t\t|| declspecs->specs[(int)ds_inline])\n \t    && pedantic)\n \t  {\n-\t    if (declspecs->storage_class == sc_static)\n+\t    if (storage_class == sc_static)\n \t      pedwarn (\"`static' specified invalid for function `%s' declared out of global scope\", name);\n \t    else\n \t      pedwarn (\"`inline' specifier invalid for function `%s' declared out of global scope\", name);\n@@ -7919,8 +7906,8 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t/* Record presence of `static'.  */\n \tpublicp = (ctype != NULL_TREE\n-\t\t   || declspecs->storage_class == sc_extern\n-\t\t   || declspecs->storage_class != sc_static);\n+\t\t   || storage_class == sc_extern\n+\t\t   || storage_class != sc_static);\n \n \tdecl = grokfndecl (ctype, type, original_name, parms, unqualified_id,\n \t\t\t   virtualp, flags, quals, raises,\n@@ -7951,7 +7938,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    if (invalid_static)\n \t      {\n \t\tstaticp = 0;\n-\t\tdeclspecs->storage_class = sc_none;\n+\t\tstorage_class = sc_none;\n \t      }\n \t  }\n       }\n@@ -7975,30 +7962,30 @@ grokdeclarator (const cp_declarator *declarator,\n \t      {\n                 pedwarn (\"`static' may not be used when defining (as opposed to declaring) a static data member\");\n \t        staticp = 0;\n-\t\tdeclspecs->storage_class = sc_none;\n+\t\tstorage_class = sc_none;\n \t      }\n-\t    if (declspecs->storage_class == sc_register && TREE_STATIC (decl))\n+\t    if (storage_class == sc_register && TREE_STATIC (decl))\n \t      {\n \t\terror (\"static member `%D' declared `register'\", decl);\n-\t\tdeclspecs->storage_class = sc_none;\n+\t\tstorage_class = sc_none;\n \t      }\n-\t    if (declspecs->storage_class == sc_extern && pedantic)\n+\t    if (storage_class == sc_extern && pedantic)\n \t      {\n \t        pedwarn (\"cannot explicitly declare member `%#D' to have extern linkage\",\n \t\t\t    decl);\n-\t\tdeclspecs->storage_class = sc_none;\n+\t\tstorage_class = sc_none;\n \t      }\n \t  }\n       }\n \n     /* Record `register' declaration for warnings on &\n        and in case doing stupid register allocation.  */\n \n-    if (declspecs->storage_class == sc_register)\n+    if (storage_class == sc_register)\n       DECL_REGISTER (decl) = 1;\n-    else if (declspecs->storage_class == sc_extern)\n+    else if (storage_class == sc_extern)\n       DECL_THIS_EXTERN (decl) = 1;\n-    else if (declspecs->storage_class == sc_static)\n+    else if (storage_class == sc_static)\n       DECL_THIS_STATIC (decl) = 1;\n \n     /* Record constancy and volatility.  There's no need to do this"}, {"sha": "7a36c64be467c86277aa59cb75710f158dbdc2f5", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "patch": "@@ -32,7 +32,7 @@ enum decl_context\n \n /* We need this in here to get the decl_context definition.  */\n extern tree grokdeclarator (const cp_declarator *, \n-\t\t\t    cp_decl_specifier_seq *, \n+\t\t\t    const cp_decl_specifier_seq *, \n \t\t\t    enum decl_context, int, tree*);\n \n #ifdef DEBUG_CP_BINDING_LEVELS"}, {"sha": "c60158cc446a079384732e4d93b368e74eaacc22", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "patch": "@@ -10477,7 +10477,6 @@ cp_parser_init_declarator (cp_parser* parser,\n   /* Gather the attributes that were provided with the\n      decl-specifiers.  */\n   prefix_attributes = decl_specifiers->attributes;\n-  decl_specifiers->attributes = NULL_TREE;\n \n   /* Assume that this is not the declarator for a function\n      definition.  */"}, {"sha": "bbeb3247dbb1d9af367626816f644a5b7bdcba0e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "patch": "@@ -1,3 +1,8 @@\n+2004-07-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/16518\n+\t* g++.dg/parse/mutable1.C: New test.\n+\t\n 2004-07-13  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/16443"}, {"sha": "f3ac2e4a9d6f53958b853801d91a4c7f6b484088", "filename": "gcc/testsuite/g++.dg/parse/mutable1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fmutable1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fmutable1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fmutable1.C?ref=1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/16518\n+\n+struct foo { \n+  void bar() const { m1=1; m2=1;} \n+  mutable int m1,m2; \n+}; \n+ "}]}