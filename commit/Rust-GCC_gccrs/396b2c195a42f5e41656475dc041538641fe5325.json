{"sha": "396b2c195a42f5e41656475dc041538641fe5325", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk2YjJjMTk1YTQyZjVlNDE2NTY0NzVkYzA0MTUzODY0MWZlNTMyNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-04-14T14:09:57Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-04-14T14:09:57Z"}, "message": "re PR fortran/29507 ([4.2 only] INDEX in an array initialization causes ICE)\n\n2007-04-14 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/29507\n\tPR fortran/31404\n\t* expr.c (scalarize_intrinsic_call): New function to\n\tscalarize elemental intrinsic functions in initialization\n\texpressions.\n\t(check_init_expr): Detect elemental intrinsic functions\n\tin initalization expressions and call previous.\n\n\n2007-04-14 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/29507\n\tPR fortran/31404\n\t* gfortran.dg/initialization_6.f90: New test.\n\nFrom-SVN: r123815", "tree": {"sha": "71df46415f12d8ef09386f6788bd52ea907b2ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71df46415f12d8ef09386f6788bd52ea907b2ca8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/396b2c195a42f5e41656475dc041538641fe5325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396b2c195a42f5e41656475dc041538641fe5325", "html_url": "https://github.com/Rust-GCC/gccrs/commit/396b2c195a42f5e41656475dc041538641fe5325", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396b2c195a42f5e41656475dc041538641fe5325/comments", "author": null, "committer": null, "parents": [{"sha": "4d4f2837c536a578f03d4a51fe60aa7b1312ed45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4f2837c536a578f03d4a51fe60aa7b1312ed45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d4f2837c536a578f03d4a51fe60aa7b1312ed45"}], "stats": {"total": 173, "additions": 172, "deletions": 1}, "files": [{"sha": "cd70c921c14f1e94b93b4ebf0525aeff45bc6365", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b2c195a42f5e41656475dc041538641fe5325/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b2c195a42f5e41656475dc041538641fe5325/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=396b2c195a42f5e41656475dc041538641fe5325", "patch": "@@ -1,4 +1,14 @@\n-2007-04-13  Tobias Burnus  <burnus@net-b.de>\n+2007-04-14 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/29507\n+\tPR fortran/31404\n+\t* expr.c (scalarize_intrinsic_call): New function to\n+\tscalarize elemental intrinsic functions in initialization\n+\texpressions.\n+\t(check_init_expr): Detect elemental intrinsic functions\n+\tin initalization expressions and call previous.\n+\n+\t2007-04-13  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/31559\n \t* primary.c (match_variable): External functions"}, {"sha": "a408229242dbfeda0fb2f0c6d486337eb29eec8e", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b2c195a42f5e41656475dc041538641fe5325/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b2c195a42f5e41656475dc041538641fe5325/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=396b2c195a42f5e41656475dc041538641fe5325", "patch": "@@ -1574,6 +1574,128 @@ et0 (gfc_expr *e)\n \n static try check_init_expr (gfc_expr *);\n \n+\n+/* Scalarize an expression for an elemental intrinsic call.  */\n+\n+static try\n+scalarize_intrinsic_call (gfc_expr *e)\n+{\n+  gfc_actual_arglist *a, *b;\n+  gfc_constructor *args[5], *ctor, *new_ctor;\n+  gfc_expr *expr, *old;\n+  int n, i, rank[5];\n+\n+  old = gfc_copy_expr (e);\n+\n+/* Assume that the old expression carries the type information and\n+   that the first arg carries all the shape information.  */\n+  expr = gfc_copy_expr (old->value.function.actual->expr);\n+  gfc_free_constructor (expr->value.constructor);\n+  expr->value.constructor = NULL;\n+\n+  expr->ts = old->ts;\n+  expr->expr_type = EXPR_ARRAY;\n+\n+  /* Copy the array argument constructors into an array, with nulls\n+     for the scalars.  */\n+  n = 0;\n+  a = old->value.function.actual;\n+  for (; a; a = a->next)\n+    {\n+      /* Check that this is OK for an initialization expression.  */\n+      if (a->expr && check_init_expr (a->expr) == FAILURE)\n+\tgoto cleanup;\n+\n+      rank[n] = 0;\n+      if (a->expr && a->expr->rank && a->expr->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  rank[n] = a->expr->rank;\n+\t  ctor = a->expr->symtree->n.sym->value->value.constructor;\n+\t  args[n] = gfc_copy_constructor (ctor);\n+\t}\n+      else if (a->expr && a->expr->expr_type == EXPR_ARRAY)\n+\t{\n+\t  if (a->expr->rank)\n+\t    rank[n] = a->expr->rank;\n+\t  else\n+\t    rank[n] = 1;\n+\t  args[n] = gfc_copy_constructor (a->expr->value.constructor);\n+\t}\n+      else\n+\targs[n] = NULL;\n+      n++;\n+    }\n+\n+  for (i = 1; i < n; i++)\n+    if (rank[i] && rank[i] != rank[0])\n+      goto compliance;\n+\n+  /* Using the first argument as the master, step through the array\n+     calling the function for each element and advancing the array\n+     constructors together.  */\n+  ctor = args[0];\n+  new_ctor = NULL;\n+  for (; ctor; ctor = ctor->next)\n+    {\n+\t  if (expr->value.constructor == NULL)\n+\t    expr->value.constructor\n+\t\t= new_ctor = gfc_get_constructor ();\n+\t  else\n+\t    {\n+\t      new_ctor->next = gfc_get_constructor ();\n+\t      new_ctor = new_ctor->next;\n+\t    }\n+\t  new_ctor->expr = gfc_copy_expr (old);\n+\t  gfc_free_actual_arglist (new_ctor->expr->value.function.actual);\n+\t  a = NULL;\n+\t  b = old->value.function.actual;\n+\t  for (i = 0; i < n; i++)\n+\t    {\n+\t      if (a == NULL)\n+\t\tnew_ctor->expr->value.function.actual\n+\t\t\t= a = gfc_get_actual_arglist ();\n+\t      else\n+\t\t{\n+\t\t  a->next = gfc_get_actual_arglist ();\n+\t\t  a = a->next;\n+\t\t}\n+\t      if (args[i])\n+\t\ta->expr = gfc_copy_expr (args[i]->expr);\n+\t      else\n+\t\ta->expr = gfc_copy_expr (b->expr);\n+\n+\t      b = b->next;\n+\t    }\n+\n+\t  /* Simplify the function calls.  */\n+\t  if (gfc_simplify_expr (new_ctor->expr, 0) == FAILURE)\n+\t    goto cleanup;\n+\n+\t  for (i = 0; i < n; i++)\n+\t    if (args[i])\n+\t      args[i] = args[i]->next;\n+\n+\t  for (i = 1; i < n; i++)\n+\t    if (rank[i] && ((args[i] != NULL && args[0] == NULL)\n+\t\t\t || (args[i] == NULL && args[0] != NULL)))\n+\t      goto compliance;\n+    }\n+\n+  free_expr0 (e);\n+  *e = *expr;\n+  gfc_free_expr (old);\n+  return SUCCESS;\n+\n+compliance:\n+  gfc_error_now (\"elemental function arguments at %C are not compliant\");\n+\n+cleanup:\n+  gfc_free_expr (expr);\n+  gfc_free_expr (old);\n+  return FAILURE;\n+}\n+\n+\n static try\n check_intrinsic_op (gfc_expr *e, try (*check_function) (gfc_expr *))\n {\n@@ -1775,6 +1897,7 @@ check_init_expr (gfc_expr *e)\n   gfc_actual_arglist *ap;\n   match m;\n   try t;\n+  gfc_intrinsic_sym *isym;\n \n   if (e == NULL)\n     return SUCCESS;\n@@ -1802,6 +1925,16 @@ check_init_expr (gfc_expr *e)\n \t      }\n \t}\n \n+      /* Try to scalarize an elemental intrinsic function that has an\n+\t array argument.  */\n+      isym = gfc_find_function (e->symtree->n.sym->name);\n+      if (isym && isym->elemental\n+\t    && e->value.function.actual->expr->expr_type == EXPR_ARRAY)\n+\t{\n+\t  if (scalarize_intrinsic_call (e) == SUCCESS)\n+\t    break;\n+\t}\n+\n       if (t == SUCCESS)\n \t{\n \t  m = gfc_intrinsic_func_interface (e, 0);"}, {"sha": "eba3c95991f1817d5bb983db57bb1c07efecef9f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b2c195a42f5e41656475dc041538641fe5325/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b2c195a42f5e41656475dc041538641fe5325/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=396b2c195a42f5e41656475dc041538641fe5325", "patch": "@@ -1,3 +1,9 @@\n+2007-04-14 Paul Thomas <pault@gcc.gnu.org>\n+\n+\tPR fortran/29507\n+\tPR fortran/31404\n+\t* gfortran.dg/initialization_6.f90: New test.\n+\n 2007-04-14  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* gcc.c-torture/compile/pr27528.c: Require nonpic."}, {"sha": "71ef1717fd3ceaef75929253a49043389680abf9", "filename": "gcc/testsuite/gfortran.dg/initialization_6.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396b2c195a42f5e41656475dc041538641fe5325/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396b2c195a42f5e41656475dc041538641fe5325/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_6.f90?ref=396b2c195a42f5e41656475dc041538641fe5325", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! { dg-options -O2 }\n+! Tests the fix for PRs29507 and 31404, where elemental functions in\n+! initialization expressions could not be simplified with array arguments.\n+!\n+! Contributed by Steve Kargl <kargl@gcc.gnu.org >\n+!             and Vivek Rao <vivekrao4@yahoo.com>\n+!\n+  real, parameter :: a(2,2) = reshape ((/1.0, 2.0, 3.0, 4.0/), (/2,2/))\n+  real, parameter :: b(2,2) = sin (a)\n+  character(8), parameter :: oa(1:3)=(/'nint()  ', 'log10() ', 'sqrt()  '/)\n+  integer, parameter :: ob(1:3) = index(oa, '(')\n+  character(6), parameter :: ch(3) = (/\"animal\", \"person\", \"mantee\"/)\n+  character(1), parameter :: ch2(3) = (/\"n\", \"r\", \"t\"/)\n+  integer, parameter :: i(3) = index (ch, ch2)\n+  integer :: ic(1) = len_trim((/\"a\"/))\n+\n+  if (any (reshape (b, (/4/)) .ne. (/(sin(real(k)), k = 1,4)/))) call abort ()\n+  if (any (ob .ne. (/5,6,5/))) call abort ()  ! Original PR29507\n+  if (any (i .ne. (/2,3,4/))) call abort ()\n+  if (ic(1) .ne. 1) call abort ()             ! Original PR31404\n+end"}]}