{"sha": "312209c6a5ff3828335e698a9d0c872a48411fdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEyMjA5YzZhNWZmMzgyODMzNWU2OThhOWQwYzg3MmE0ODQxMWZkZg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-07-28T09:13:58Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-07-28T09:13:58Z"}, "message": "Introduce sh4a support.\n\ngcc/ChangeLog:\nIntroduce sh4a support.\n* config.gcc: Handle sh4a multilibs and cpu selection.\n* config/sh/sh.h: Likewise.  Handle sh4a command line flags.\n* config/sh/t-mlib-sh4a: New.\n* config/sh/t-mlib-sh4al: New.\n* config/sh/t-mlib-sh4a-nofpu: New.\n* config/sh/t-mlib-sh4a-single: New.\n* config/sh/t-mlib-sh4a-single-only: New.\n2004-02-20  DJ Delorie  <dj@redhat.com>\n* config/sh/sh.md (\"movua\"): Change constraint from \"m\" to \"Sua\".\n* config/sh/sh.h (EXTRA_CONSTRAINT_S): Add \"Sua\" support.\n2003-08-22  Eric Christopher  <echristo@redhat.com>\n* config/sh/sh4a.md: Update for chip errata.\n2003-08-07  Eric Christopher  <echristo@redhat.com>\n* config/sh/sh4a.md: New file. sh4a processor description.\n2003-07-08  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (TARGET_SWITCHES): Added 4al.  Adjust description\nof -m4a-nofpu.\n(SH_ASM_SPEC): Pass -dsp for -m4al, not -m4a-nofpu.\n* config/sh/t-sh (MULTILIB_MATCHES): Map -m4al to -m4a-nofpu.\n* doc/invoke.texi (SH Options): Document -m4al.\n2003-07-03  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (expand_block_move): Remove commented-out code\nchecked in by mistake.\n(sh_cannot_change_mode_class): Enable SUBREGs to be used to select\nsingle elements from SFmode vectors.\n* config/sh/sh.md (fsca): Use VEC_CONCAT to initialize the output\nregister.\n(sinsf2, cossf2, sindf2, cosdf2): Don't emit CLOBBER.\n2003-07-01  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.h (sh_fsca_sf2int, sh_fsca_df2int,\nsh_fsca_int2sf): Remove variable declarations.\n* config/sh/sh.c (sh_fsca_sf2int, sh_fsca_df2int,\nsh_fsca_int2sf): New functions.\n(sh_fsca_sf2int_rtx, sh_fsca_df2int_rtx,\nsh_fsca_int2sf_rtx): New static variables.\n* config/sh/sh-protos.h (sh_fsca_sf2int, sh_fsca_df2int,\nsh_fsca_int2sf): Declare.\n* config/sh/sh.md: Adjust.\n* doc/invoke.texi (SH Options): Document new options.\n* config/sh/lib1funcs.asm (ic_invalidate): Remove SH4a forward\ncompatibility from SH4 code.\n2003-06-27  Alexandre Oliva  <aoliva@redhat.com>\n* config/sh/sh.c (expand_block_move): Don't emit POST_INC too\nearly.\n(memory_movsrc_operand): Renamed to...\n(unaligned_load_operand): ... this.  Simplified.\n* config/sh/sh.h (PREDICATE_CODES): Adjust.\n* config/sh/sh.md (movua, extv, extzv): Likewise.  Change movua's\ninput operand to SImode, and adjust the others.  Introduce\npost-increment by peephole.\n* config/sh/sh.c (expand_block_move): Give the target address the\nsame mode as the temp reg.\n* config/sh/sh.c (expand_block_move): Use a temp reg for unaligned\ncopying.\n2003-06-26  Alexandre Oliva  <aoliva@redhat.com>\nIntroduce support for SH4a.\n* config/sh/lib1funcs.asm (ic_invalidate): Use icbi if\n__SH4A__.  Emit 4 4kb blocks and touch all of them otherwise.\n* config/sh/sh.c (sh_fsca_sf2int, sh_fsca_df2int,\nsh_fsca_int2sf): New.\n(sh_init_builtins): Initialize them.\n(print_operand): Support `d'.\n(expand_block_move): Use movua if src is misaligned.\n(memory_movsrc_operand): New.\n* config/sh/sh.h (TARGET_CPU_CPP_BUILTINS): Define __SH4A__\nand one of the SH4 macros.\n(SH4A_BIT, TARGET_SH4A_ARCH, TARGET_SH4A_FP,\nSELECT_SH4A_NOFPU, SELECT_SH4A_SINGLE_ONLY, SELECT_SH4A,\nSELECT_SH4A_SINGLE): New.\n(TARGET_NONE): Add SH4A_BIT.\n(TARGET_SWITCHES): Add 4a-single-only, 4a-single, 4a-nofpu and 4a.\n(SH_ASM_SPEC): Pass -dsp if -m4a-nofpu.\n(sh_fsca_sf2int, sh_fsca_df2int, sh_fsca_int2sf): Declare.\n(OVERRIDE_OPTIONS): Set cpu to CPU_SH4A when appropriate.\n(enum processor_type): Added PROCESSOR_SH4A.\n(PREDICATE_CODES): Add memory_movsrc_operand.\n* config/sh/sh.md: Removed unused variables.\n(attr cpu): Add sh4a.\n(attr type): Add movua, fsrra and fsca.\n(prefetch): New, for SH4.\n(ic_invalidate_line, ic_invalidate_line_sh4a): Use icbi.\n(toggle_sz): Set type to fp.\n(toggle_pr, rsqrtsf2, fsca, sinsf2, cossf2, sindf2, cosdf2): New.\n(movua, extv, extzv): New.\n* config/sh/t-sh: Add multilibs for 4a, 4a-nofpu, 4a-single\nand 4a-single-only.\ngcc/testsuite/ChangeLog:\n2003-07-06  Alexandre Oliva  <aoliva@redhat.com>\n* gcc.dg/sh4a-memmovua.c: Tweak regular expression.\n2003-07-01  Alexandre Oliva  <aoliva@redhat.com>\n* gcc.dg/sh4a-bitmovua.c: New.\n* gcc.dg/sh4a-cos.c: New.\n* gcc.dg/sh4a-cosf.c: New.\n* gcc.dg/sh4a-fprun.c: New.\n* gcc.dg/sh4a-fsrra.c: New.\n* gcc.dg/sh4a-memmovua.c: New.\n* gcc.dg/sh4a-sin.c: New.\n* gcc.dg/sh4a-sincos.c: New.\n* gcc.dg/sh4a-sincosf.c: New.\n* gcc.dg/sh4a-sinf.c: New.\nlibstdc++-v3/ChangeLog:\n2003-10-01  Eric Christopher  <echristo@redhat.com>\n* config/cpu/sh/atomicity.h (__exchange_and_add): Remove 'm'\nconstraint.\n2003-07-09  Alexandre Oliva  <aoliva@redhat.com>\n* config/cpu/sh/atomicity.h: New.  Use movli and movco on SH4a.\n\nFrom-SVN: r85257", "tree": {"sha": "2832c8ac927a0a8fe44a9bd387766c2f8b2c9081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2832c8ac927a0a8fe44a9bd387766c2f8b2c9081"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/312209c6a5ff3828335e698a9d0c872a48411fdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312209c6a5ff3828335e698a9d0c872a48411fdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/312209c6a5ff3828335e698a9d0c872a48411fdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312209c6a5ff3828335e698a9d0c872a48411fdf/comments", "author": null, "committer": null, "parents": [{"sha": "0871761b07caa5c85920d72b0bf7b282b1864a1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0871761b07caa5c85920d72b0bf7b282b1864a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0871761b07caa5c85920d72b0bf7b282b1864a1b"}], "stats": {"total": 1199, "additions": 1189, "deletions": 10}, "files": [{"sha": "ddea34766facd44f5aaab823d5ce9c72559a1bee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -1,3 +1,93 @@\n+2004-07-28  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tIntroduce sh4a support.\n+\t* config.gcc: Handle sh4a multilibs and cpu selection.\n+\t* config/sh/sh.h: Likewise.  Handle sh4a command line flags.\n+\t* config/sh/t-mlib-sh4a: New.\n+\t* config/sh/t-mlib-sh4al: New.\n+\t* config/sh/t-mlib-sh4a-nofpu: New.\n+\t* config/sh/t-mlib-sh4a-single: New.\n+\t* config/sh/t-mlib-sh4a-single-only: New.\n+\t2004-02-20  DJ Delorie  <dj@redhat.com>\n+\t* config/sh/sh.md (\"movua\"): Change constraint from \"m\" to \"Sua\".\n+\t* config/sh/sh.h (EXTRA_CONSTRAINT_S): Add \"Sua\" support.\n+\t2003-08-22  Eric Christopher  <echristo@redhat.com>\n+\t* config/sh/sh4a.md: Update for chip errata.\n+\t2003-08-07  Eric Christopher  <echristo@redhat.com>\n+\t* config/sh/sh4a.md: New file. sh4a processor description.\n+\t2003-07-08  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (TARGET_SWITCHES): Added 4al.  Adjust description\n+\tof -m4a-nofpu.\n+\t(SH_ASM_SPEC): Pass -dsp for -m4al, not -m4a-nofpu.\n+\t* config/sh/t-sh (MULTILIB_MATCHES): Map -m4al to -m4a-nofpu.\n+\t* doc/invoke.texi (SH Options): Document -m4al.\n+\t2003-07-03  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (expand_block_move): Remove commented-out code\n+\tchecked in by mistake.\n+\t(sh_cannot_change_mode_class): Enable SUBREGs to be used to select\n+\tsingle elements from SFmode vectors.\n+\t* config/sh/sh.md (fsca): Use VEC_CONCAT to initialize the output\n+\tregister.\n+\t(sinsf2, cossf2, sindf2, cosdf2): Don't emit CLOBBER.\n+\t2003-07-01  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.h (sh_fsca_sf2int, sh_fsca_df2int,\n+\tsh_fsca_int2sf): Remove variable declarations.\n+\t* config/sh/sh.c (sh_fsca_sf2int, sh_fsca_df2int,\n+\tsh_fsca_int2sf): New functions.\n+\t(sh_fsca_sf2int_rtx, sh_fsca_df2int_rtx,\n+\tsh_fsca_int2sf_rtx): New static variables.\n+\t* config/sh/sh-protos.h (sh_fsca_sf2int, sh_fsca_df2int,\n+\tsh_fsca_int2sf): Declare.\n+\t* config/sh/sh.md: Adjust.\n+\t* doc/invoke.texi (SH Options): Document new options.\n+\t* config/sh/lib1funcs.asm (ic_invalidate): Remove SH4a forward\n+\tcompatibility from SH4 code.\n+\t2003-06-27  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/sh/sh.c (expand_block_move): Don't emit POST_INC too\n+\tearly.\n+\t(memory_movsrc_operand): Renamed to...\n+\t(unaligned_load_operand): ... this.  Simplified.\n+\t* config/sh/sh.h (PREDICATE_CODES): Adjust.\n+\t* config/sh/sh.md (movua, extv, extzv): Likewise.  Change movua's\n+\tinput operand to SImode, and adjust the others.  Introduce\n+\tpost-increment by peephole.\n+\t* config/sh/sh.c (expand_block_move): Give the target address the\n+\tsame mode as the temp reg.\n+\t* config/sh/sh.c (expand_block_move): Use a temp reg for unaligned\n+\tcopying.\n+\t2003-06-26  Alexandre Oliva  <aoliva@redhat.com>\n+\tIntroduce support for SH4a.\n+\t* config/sh/lib1funcs.asm (ic_invalidate): Use icbi if\n+\t__SH4A__.  Emit 4 4kb blocks and touch all of them otherwise.\n+\t* config/sh/sh.c (sh_fsca_sf2int, sh_fsca_df2int,\n+\tsh_fsca_int2sf): New.\n+\t(sh_init_builtins): Initialize them.\n+\t(print_operand): Support `d'.\n+\t(expand_block_move): Use movua if src is misaligned.\n+\t(memory_movsrc_operand): New.\n+\t* config/sh/sh.h (TARGET_CPU_CPP_BUILTINS): Define __SH4A__\n+\tand one of the SH4 macros.\n+\t(SH4A_BIT, TARGET_SH4A_ARCH, TARGET_SH4A_FP,\n+\tSELECT_SH4A_NOFPU, SELECT_SH4A_SINGLE_ONLY, SELECT_SH4A,\n+\tSELECT_SH4A_SINGLE): New.\n+\t(TARGET_NONE): Add SH4A_BIT.\n+\t(TARGET_SWITCHES): Add 4a-single-only, 4a-single, 4a-nofpu and 4a.\n+\t(SH_ASM_SPEC): Pass -dsp if -m4a-nofpu.\n+\t(sh_fsca_sf2int, sh_fsca_df2int, sh_fsca_int2sf): Declare.\n+\t(OVERRIDE_OPTIONS): Set cpu to CPU_SH4A when appropriate.\n+\t(enum processor_type): Added PROCESSOR_SH4A.\n+\t(PREDICATE_CODES): Add memory_movsrc_operand.\n+\t* config/sh/sh.md: Removed unused variables.\n+\t(attr cpu): Add sh4a.\n+\t(attr type): Add movua, fsrra and fsca.\n+\t(prefetch): New, for SH4.\n+\t(ic_invalidate_line, ic_invalidate_line_sh4a): Use icbi.\n+\t(toggle_sz): Set type to fp.\n+\t(toggle_pr, rsqrtsf2, fsca, sinsf2, cossf2, sindf2, cosdf2): New.\n+\t(movua, extv, extzv): New.\n+\t* config/sh/t-sh: Add multilibs for 4a, 4a-nofpu, 4a-single\n+\tand 4a-single-only.\n+\n 2004-07-28  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-optimize.c (init_tree_optimization_passes): Schedule"}, {"sha": "1360b072a487c6fa47a98003f1023987a4f32d5d", "filename": "gcc/config.gcc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -1746,6 +1746,11 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \tcase `echo ${target} | sed 's/e[lb]-/-/'` in\n \tsh64*-*-netbsd*)\tsh_cpu_target=sh5-64media ;;\n \tsh64* | sh5*-*-netbsd*)\tsh_cpu_target=sh5-32media ;;\n+\tsh4a_single_only*)\tsh_cpu_target=sh4a-single-only ;;\n+\tsh4a_single*)\t\tsh_cpu_target=sh4a-single ;;\n+\tsh4a_nofpu*)\t\tsh_cpu_target=sh4a-nofpu ;;\n+\tsh4al)\t\t\tsh_cpu_target=sh4al ;;\n+\tsh4a*)\t\t\tsh_cpu_target=sh4a ;;\n \tsh4_single_only*)\tsh_cpu_target=sh4-single-only ;;\n \tsh4_single*)\t\tsh_cpu_target=sh4-single ;;\n \tsh4_nofpu*)\t\tsh_cpu_target=sh4-nofpu ;;\n@@ -1760,6 +1765,7 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \tcase $sh_cpu_default in\n \tsh5-64media-nofpu | sh5-64media | \\\n \t  sh5-32media-nofpu | sh5-32media | sh5-compact-nofpu | sh5-compact | \\\n+\t  sh4a-single-only | sh4a-single | sh4a-nofpu | sh4a | sh4al | \\\n \t  sh4-single-only | sh4-single | sh4-nofpu | sh4 | \\\n \t  sh3e | sh3 | sh2e | sh2 | sh1) ;;\n \t\"\")\tsh_cpu_default=${sh_cpu_target} ;;\n@@ -1783,6 +1789,7 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \t\tcase ${sh_multilib} in\n \t\tsh1 | sh2 | sh2e | sh3 | sh3e | \\\n \t\tsh4 | sh4-single | sh4-single-only | sh4-nofpu | \\\n+\t\tsh4a | sh4a-single | sh4a-single-only | sh4a-nofpu | sh4al | \\\n \t\tsh5-64media | sh5-64media-nofpu | \\\n \t\tsh5-32media | sh5-32media-nofpu | \\\n \t\tsh5-compact | sh5-compact-nofpu)\n@@ -2476,9 +2483,12 @@ fi\n \t\t\"\" | m1 | m2 | m2e | m3 | m3e | m4 | m4-single | m4-single-only | m4-nofpu )\n \t\t\t# OK\n \t\t\t;;\n+\t\tm4a | m4a-single | m4a-single-only | m4a-nofpu | m4al)\n+\t\t        ;;\n \t\t*)\n \t\t\techo \"Unknown CPU used in --with-cpu=$with_cpu, known values:\"  1>&2\n \t\t\techo \"m1 m2 m2e m3 m3e m4 m4-single m4-single-only m4-nofpu\" 1>&2\n+\t\t\techo \"m4a m4a-single m4a-single-only m4a-nofpu m4al\" 1>&2\n \t\t\texit 1\n \t\t\t;;\n \t\tesac"}, {"sha": "239438fd06b37711fadfd5619c41bca2974e3a79", "filename": "gcc/config/sh/lib1funcs.asm", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flib1funcs.asm?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -2036,7 +2036,34 @@ GLOBAL(ic_invalidate):\n \n \tENDFUNC(GLOBAL(ic_invalidate))\n \tENDFUNC(GLOBAL(init_trampoline))\n+#elif defined(__SH4A__)\n+\t.global GLOBAL(ic_invalidate)\n+\tFUNC(GLOBAL(ic_invalidate))\n+GLOBAL(ic_invalidate):\n+\tocbwb\t@r4\n+\tsynco\n+\trts\n+\ticbi\t@r4\n+\tENDFUNC(GLOBAL(ic_invalidate))\n #elif defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n+\t/* This assumes a direct-mapped cache, which is the case for\n+\tthe first SH4, but not for the second version of SH4, that\n+\tuses a 2-way set-associative cache, nor SH4a, that is 4-way.\n+\tSH4a fortunately offers an instruction to invalidate the\n+\tinstruction cache, and we use it above, but SH4 doesn't.\n+\tHowever, since the libraries don't contain any nested\n+\tfunctions (the only case in which GCC would emit this pattern)\n+\tand we actually emit the ic_invalidate_line_i pattern for\n+\tcache invalidation on all SH4 multilibs (even 4-nofpu, that\n+\tisn't even corevered here), and pre-SH4 cores don't have\n+\tcaches, it seems like this code is pointless, unless it's\n+\tmeant for backward binary compatibility or for userland-only\n+\tcache invalidation for say sh4-*-linux-gnu.  Such a feature\n+\tshould probably be moved into a system call, such that the\n+\tkernel could do whatever it takes to invalidate a cache line\n+\ton the core it's actually running on.  I.e., this hideous :-)\n+\tpiece of code should go away at some point.  */\n+\n \t.global GLOBAL(ic_invalidate)\n \tFUNC(GLOBAL(ic_invalidate))\n GLOBAL(ic_invalidate):"}, {"sha": "d5ddb7b20b77d3d5802fae4795e1dbbb7d211e6a", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -25,6 +25,9 @@ Boston, MA 02111-1307, USA.  */\n #define GCC_SH_PROTOS_H\n \n #ifdef RTX_CODE\n+extern rtx sh_fsca_sf2int (void);\n+extern rtx sh_fsca_df2int (void);\n+extern rtx sh_fsca_int2sf (void);\n extern struct rtx_def *prepare_scc_operands (enum rtx_code);\n \n /* Declare functions defined in sh.c and used in templates.  */"}, {"sha": "010e5dcadc3498b89d44cc5faf92034463a78e36", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 136, "deletions": 1, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -537,6 +537,7 @@ print_operand_address (FILE *stream, rtx x)\n    'T'  print the next word of a dp value - same as 'R' in big endian mode.\n    'M'  print an `x' if `m' will print `base,index'.\n    'N'  print 'r63' if the operand is (const_int 0).\n+   'd'  print a V2SF reg as dN instead of fpN.\n    'm'  print a pair `base,offset' or `base,index', for LD and ST.\n    'u'  prints the lowest 16 bits of CONST_INT, as an unsigned value.\n    'o'  output an operator.  */\n@@ -651,6 +652,13 @@ print_operand (FILE *stream, rtx x, int code)\n \t}\n       break;\n \n+    case 'd':\n+      if (GET_CODE (x) != REG || GET_MODE (x) != V2SFmode)\n+\tabort ();\n+\n+      fprintf ((stream), \"d%s\", reg_names[REGNO (x)] + 1);\n+      break;\n+      \n     case 'N':\n       if (x == CONST0_RTX (GET_MODE (x)))\n \t{\n@@ -772,9 +780,48 @@ expand_block_move (rtx *operands)\n   int constp = (GET_CODE (operands[2]) == CONST_INT);\n   int bytes = (constp ? INTVAL (operands[2]) : 0);\n \n+  if (! constp)\n+    return 0;\n+\n+  /* If we could use mov.l to move words and dest is word-aligned, we\n+     can use movua.l for loads and still generate a relatively short\n+     and efficient sequence.  */\n+  if (TARGET_SH4A_ARCH && align < 4\n+      && MEM_ALIGN (operands[0]) >= 32\n+      && can_move_by_pieces (bytes, 32))\n+    {\n+      rtx dest = copy_rtx (operands[0]);\n+      rtx src = copy_rtx (operands[1]);\n+      /* We could use different pseudos for each copied word, but\n+\t since movua can only load into r0, it's kind of\n+\t pointless.  */\n+      rtx temp = gen_reg_rtx (SImode);\n+      rtx src_addr = copy_addr_to_reg (XEXP (src, 0));\n+      int copied = 0;\n+\n+      while (copied + 4 <= bytes)\n+\t{\n+\t  rtx to = adjust_address (dest, SImode, copied);\n+\t  rtx from = adjust_automodify_address (src, SImode, src_addr, copied);\n+\n+\t  emit_insn (gen_movua (temp, from));\n+\t  emit_move_insn (src_addr, plus_constant (src_addr, 4));\n+\t  emit_move_insn (to, temp);\n+\t  copied += 4;\n+\t}\n+\n+      if (copied < bytes)\n+\tmove_by_pieces (adjust_address (dest, BLKmode, copied),\n+\t\t\tadjust_automodify_address (src, BLKmode,\n+\t\t\t\t\t\t   src_addr, copied),\n+\t\t\tbytes - copied, align, 0);\n+\n+      return 1;\n+    }\n+\n   /* If it isn't a constant number of bytes, or if it doesn't have 4 byte\n      alignment, or if it isn't a multiple of 4 bytes, then fail.  */\n-  if (! constp || align < 4 || (bytes % 4 != 0))\n+  if (align < 4 || (bytes % 4 != 0))\n     return 0;\n \n   if (TARGET_HARD_SH4)\n@@ -9397,6 +9444,11 @@ bool\n sh_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n \t\t\t     enum reg_class class)\n {\n+  /* We want to enable the use of SUBREGs as a means to\n+     VEC_SELECT a single element of a vector.  */\n+  if (to == SFmode && VECTOR_MODE_P (from) && GET_MODE_INNER (from) == SFmode)\n+    return (reg_classes_intersect_p (GENERAL_REGS, class));\n+\n   if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n     {\n       if (TARGET_LITTLE_ENDIAN)\n@@ -9821,4 +9873,87 @@ check_use_sfunc_addr (rtx insn, rtx reg)\n   abort ();\n }\n \n+/* Returns 1 if OP is a MEM that can be source of a simple move operation.  */\n+\n+int\n+unaligned_load_operand (rtx op, enum machine_mode mode)\n+{\n+  rtx inside;\n+\n+  if (GET_CODE (op) != MEM || GET_MODE (op) != mode)\n+    return 0;\n+\n+  inside = XEXP (op, 0);\n+\n+  if (GET_CODE (inside) == POST_INC)\n+    inside = XEXP (inside, 0);\n+\n+  if (GET_CODE (inside) == REG)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* This function returns a constant rtx that represents pi / 2**15 in\n+   SFmode.  it's used to scale SFmode angles, in radians, to a\n+   fixed-point signed 16.16-bit fraction of a full circle, i.e., 2*pi\n+   maps to 0x10000).  */\n+\n+static GTY(()) rtx sh_fsca_sf2int_rtx;\n+\n+rtx\n+sh_fsca_sf2int (void)\n+{\n+  if (! sh_fsca_sf2int_rtx)\n+    {\n+      REAL_VALUE_TYPE rv;\n+\n+      real_from_string (&rv, \"10430.378350470453\");\n+      sh_fsca_sf2int_rtx = const_double_from_real_value (rv, SFmode);\n+    }\n+\n+  return sh_fsca_sf2int_rtx;\n+}\n+  \n+/* This function returns a constant rtx that represents pi / 2**15 in\n+   DFmode.  it's used to scale DFmode angles, in radians, to a\n+   fixed-point signed 16.16-bit fraction of a full circle, i.e., 2*pi\n+   maps to 0x10000).  */\n+\n+static GTY(()) rtx sh_fsca_df2int_rtx;\n+\n+rtx\n+sh_fsca_df2int (void)\n+{\n+  if (! sh_fsca_df2int_rtx)\n+    {\n+      REAL_VALUE_TYPE rv;\n+\n+      real_from_string (&rv, \"10430.378350470453\");\n+      sh_fsca_df2int_rtx = const_double_from_real_value (rv, DFmode);\n+    }\n+\n+  return sh_fsca_df2int_rtx;\n+}\n+  \n+/* This function returns a constant rtx that represents 2**15 / pi in\n+   SFmode.  it's used to scale a fixed-point signed 16.16-bit fraction\n+   of a full circle back to a SFmode value, i.e., 0x10000 maps to\n+   2*pi).  */\n+\n+static GTY(()) rtx sh_fsca_int2sf_rtx;\n+\n+rtx\n+sh_fsca_int2sf (void)\n+{\n+  if (! sh_fsca_int2sf_rtx)\n+    {\n+      REAL_VALUE_TYPE rv;\n+\n+      real_from_string (&rv, \"9.587379924285257e-5\");\n+      sh_fsca_int2sf_rtx = const_double_from_real_value (rv, SFmode);\n+    }\n+\n+  return sh_fsca_int2sf_rtx;\n+}\n #include \"gt-sh.h\""}, {"sha": "71546facf9d95a17344165822589edb9cc8dde14", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -60,6 +60,13 @@ do { \\\n     case PROCESSOR_SH4: \\\n       builtin_define (TARGET_FPU_SINGLE ? \"__SH4_SINGLE__\" : \"__SH4__\"); \\\n       break; \\\n+    case PROCESSOR_SH4A: \\\n+      builtin_define (\"__SH4A__\"); \\\n+      builtin_define (TARGET_SH4 \\\n+\t\t      ? (TARGET_FPU_SINGLE ? \"__SH4_SINGLE__\" : \"__SH4__\") \\\n+\t\t      : TARGET_FPU_ANY ? \"__SH4_SINGLE_ONLY__\" \\\n+\t\t      : \"__SH4_NOFPU__\"); \\\n+      break; \\\n     case PROCESSOR_SH5: \\\n       { \\\n \tbuiltin_define_with_value (\"__SH5__\", \\\n@@ -138,6 +145,7 @@ extern int target_flags;\n #define HARD_SH4_BIT\t(1<<5)\n #define FPU_SINGLE_BIT\t(1<<7)\n #define SH4_BIT\t       \t(1<<12)\n+#define SH4A_BIT\t(1<<3)\n #define FMOVD_BIT\t(1<<4)\n #define SH5_BIT\t\t(1<<0)\n #define SPACE_BIT \t(1<<13)\n@@ -200,6 +208,14 @@ extern int target_flags;\n /* Nonzero if we should generate code using type 4 insns.  */\n #define TARGET_SH4 ((target_flags & SH4_BIT) && (target_flags & SH1_BIT))\n \n+/* Nonzero if we're generating code for the common subset of\n+   instructions present on both SH4a and SH4al-dsp.  */\n+#define TARGET_SH4A_ARCH (target_flags & SH4A_BIT)\n+\n+/* Nonzero if we're generating code for SH4a, unless the use of the\n+   FPU is disabled (which makes it compatible with SH4al-dsp).  */\n+#define TARGET_SH4A_FP (TARGET_SH4A_ARCH && TARGET_FPU_ANY)\n+\n /* Nonzero if we should generate code for a SH5 CPU (either ISA).  */\n #define TARGET_SH5 (target_flags & SH5_BIT)\n \n@@ -285,6 +301,10 @@ extern int target_flags;\n #define SELECT_SH4_SINGLE_ONLY   (HARD_SH4_BIT | SELECT_SH3E)\n #define SELECT_SH4               (SH4_BIT | SH_E_BIT | HARD_SH4_BIT | SELECT_SH3)\n #define SELECT_SH4_SINGLE        (FPU_SINGLE_BIT | SELECT_SH4)\n+#define SELECT_SH4A_NOFPU        (SH4A_BIT | SELECT_SH4_NOFPU)\n+#define SELECT_SH4A_SINGLE_ONLY  (SH4A_BIT | SELECT_SH4_SINGLE_ONLY)\n+#define SELECT_SH4A              (SH4A_BIT | SELECT_SH4)\n+#define SELECT_SH4A_SINGLE       (SH4A_BIT | SELECT_SH4_SINGLE)\n #define SELECT_SH5_64MEDIA       (SH5_BIT | SH4_BIT)\n #define SELECT_SH5_64MEDIA_NOFPU (SH5_BIT)\n #define SELECT_SH5_32MEDIA       (SH5_BIT | SH4_BIT | SH_E_BIT)\n@@ -302,6 +322,12 @@ extern int target_flags;\n #ifndef SUPPORT_SH4_NOFPU\n #define TARGET_SWITCH_SH4_NOFPU\n #endif\n+#ifndef SUPPORT_SH4A_NOFPU\n+#define TARGET_SWITCH_SH4A_NOFPU\n+#endif\n+#ifndef SUPPORT_SH4AL\n+#define TARGET_SWITCH_SH4AL\n+#endif\n #endif\n #endif\n #endif\n@@ -313,15 +339,24 @@ extern int target_flags;\n #ifndef SUPPORT_SH4_SINGLE_ONLY\n #define TARGET_SWITCH_SH4_SINGLE_ONLY\n #endif\n+#ifndef SUPPORT_SH4A_SINGLE_ONLY\n+#define TARGET_SWITCH_SH4A_SINGLE_ONLY\n+#endif\n #endif\n #endif\n \n #ifndef SUPPORT_SH4\n #define TARGET_SWITCH_SH4\n+#ifndef SUPPORT_SH4A\n+#define TARGET_SWITCH_SH4A\n+#endif\n #endif\n \n #ifndef SUPPORT_SH4_SINGLE\n #define TARGET_SWITCH_SH4_SINGLE\n+#ifndef SUPPORT_SH4A_SINGLE\n+#define TARGET_SWITCH_SH4A_SINGLE\n+#endif\n #endif\n \n #ifndef SUPPORT_SH5_64MEDIA\n@@ -342,7 +377,7 @@ extern int target_flags;\n \n /* Reset all target-selection flags.  */\n #define TARGET_NONE -(SH1_BIT | SH2_BIT | SH3_BIT | SH_E_BIT | SH4_BIT \\\n-\t\t      | HARD_SH4_BIT | FPU_SINGLE_BIT | SH5_BIT)\n+\t\t      | SH4A_BIT | HARD_SH4_BIT | FPU_SINGLE_BIT | SH5_BIT)\n \n #ifndef TARGET_SWITCH_SH1\n #define TARGET_SWITCH_SH1 \\\n@@ -389,6 +424,31 @@ extern int target_flags;\n   {\"4\",\t\tTARGET_NONE, \"\" }, \\\n   {\"4\",\t\tSELECT_SH4, \"Generate SH4 code\" },\n #endif\n+#ifndef TARGET_SWITCH_SH4A\n+#define TARGET_SWITCH_SH4A \\\n+  {\"4a\",\tTARGET_NONE, \"\" }, \\\n+  {\"4a\",\tSELECT_SH4A, \"Generate SH4a code\" },\n+#endif\n+#ifndef TARGET_SWITCH_SH4A_SINGLE_ONLY\n+#define TARGET_SWITCH_SH4A_SINGLE_ONLY \\\n+  {\"4a-single-only\",\tTARGET_NONE, \"\" },\t\\\n+  {\"4a-single-only\",\tSELECT_SH4A_SINGLE_ONLY, \"Generate only single-precision SH4a code\" },\n+#endif\n+#ifndef TARGET_SWITCH_SH4A_SINGLE\n+#define TARGET_SWITCH_SH4A_SINGLE \\\n+  {\"4a-single\",\tTARGET_NONE, \"\" },\\\n+  {\"4a-single\",\tSELECT_SH4A_SINGLE, \"Generate default single-precision SH4a code\" },\n+#endif\n+#ifndef TARGET_SWITCH_SH4A_NOFPU\n+#define TARGET_SWITCH_SH4A_NOFPU \\\n+  {\"4a-nofpu\",\tTARGET_NONE, \"\" },\\\n+  {\"4a-nofpu\",\tSELECT_SH4A_NOFPU, \"Generate SH4a FPU-less code\" },\n+#endif\n+#ifndef TARGET_SWITCH_SH4AL\n+#define TARGET_SWITCH_SH4AL \\\n+  {\"4al\",\tTARGET_NONE, \"\" },\\\n+  {\"4al\",\tSELECT_SH4A_NOFPU, \"Generate SH4al-dsp code\" },\n+#endif\n #ifndef TARGET_SWITCH_SH5_64MEDIA\n #define TARGET_SWITCH_SH5_64MEDIA \\\n   {\"5-64media\",\tTARGET_NONE, \"\" },\t\t\\\n@@ -424,6 +484,11 @@ extern int target_flags;\n   TARGET_SWITCH_SH4_SINGLE \\\n   TARGET_SWITCH_SH4_NOFPU \\\n   TARGET_SWITCH_SH4 \\\n+  TARGET_SWITCH_SH4A_SINGLE_ONLY \\\n+  TARGET_SWITCH_SH4A_SINGLE \\\n+  TARGET_SWITCH_SH4A_NOFPU \\\n+  TARGET_SWITCH_SH4A \\\n+  TARGET_SWITCH_SH4AL \\\n   TARGET_SWITCH_SH5_64MEDIA \\\n   TARGET_SWITCH_SH5_64MEDIA_NOFPU \\\n   TARGET_SWITCHES_SH5_32MEDIA \\\n@@ -497,7 +562,7 @@ extern int target_flags;\n \n #define SH_ASM_SPEC \\\n  \"%(subtarget_asm_endian_spec) %{mrelax:-relax %(subtarget_asm_relax_spec)}\\\n-%(subtarget_asm_isa_spec)\"\n+%(subtarget_asm_isa_spec) %{m4al:-dsp}\"\n \n #define ASM_SPEC SH_ASM_SPEC\n \n@@ -584,6 +649,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n       assembler_dialect = 1;\t\t\t\t\t\t\\\n       sh_cpu = CPU_SH4;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_SH4A_ARCH)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      assembler_dialect = 1;\t\t\t\t\t\t\\\n+      sh_cpu = CPU_SH4A;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_SH5)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       sh_cpu = CPU_SH5;\t\t\t\t\t\t\t\\\n@@ -2441,8 +2511,12 @@ struct sh_args {\n #define EXTRA_CONSTRAINT_Sr0(OP) \\\n   (memory_operand((OP), GET_MODE (OP)) \\\n    && ! refers_to_regno_p (R0_REG, R0_REG + 1, OP, (rtx *)0))\n+#define EXTRA_CONSTRAINT_Sua(OP) \\\n+  (memory_operand((OP), GET_MODE (OP)) \\\n+   && GET_CODE (XEXP (OP, 0)) != PLUS)\n #define EXTRA_CONSTRAINT_S(OP, STR) \\\n   ((STR)[1] == 'r' && (STR)[2] == '0' ? EXTRA_CONSTRAINT_Sr0 (OP) \\\n+   : (STR)[1] == 'u' && (STR)[2] == 'a' ? EXTRA_CONSTRAINT_Sua (OP) \\\n    : 0)\n \n #define EXTRA_CONSTRAINT_STR(OP, C, STR)\t\t\\\n@@ -3175,6 +3249,7 @@ enum processor_type {\n   PROCESSOR_SH3,\n   PROCESSOR_SH3E,\n   PROCESSOR_SH4,\n+  PROCESSOR_SH4A,\n   PROCESSOR_SH5\n };\n \n@@ -3245,6 +3320,7 @@ extern int rtx_equal_function_value_matters;\n   {\"general_extend_operand\", {SUBREG, REG, MEM, TRUNCATE}},\t\t\\\n   {\"general_movsrc_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM}}, \\\n   {\"general_movdst_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n+  {\"unaligned_load_operand\", {MEM}},\t\t\t\t\t\\\n   {\"greater_comparison_operator\", {GT,GE,GTU,GEU}},\t\t\t\\\n   {\"int_gpr_dest\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"inqhi_operand\", {TRUNCATE}},\t\t\t\t\t\\"}, {"sha": "77ba4d59d74982cce6a1fdf47b95ef1a1fbd5b97", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 210, "deletions": 4, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -161,7 +161,7 @@\n ;; Target CPU.\n \n (define_attr \"cpu\"\n- \"sh1,sh2,sh2e,sh3,sh3e,sh4,sh5\"\n+ \"sh1,sh2,sh2e,sh3,sh3e,sh4,sh4a,sh5\"\n   (const (symbol_ref \"sh_cpu_attr\")))\n \n (define_attr \"endian\" \"big,little\"\n@@ -218,6 +218,9 @@\n ;; ftrc_s\tfix_truncsfsi2_i4\n ;; dfdiv\tdouble precision floating point divide (or square root)\n ;; cwb\t\tic_invalidate_line_i\n+;; movua\tSH4a unaligned load\n+;; fsrra\tsquare root reciprocal approximate\n+;; fsca\t\tsine and cosine approximate\n ;; tls_load     load TLS related address\n ;; arith_media\tSHmedia arithmetic, logical, and shift instructions\n ;; cbranch_media SHmedia conditional branch instructions\n@@ -249,7 +252,7 @@\n ;; nil\t\tno-op move, will be deleted.\n \n (define_attr \"type\"\n- \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,fload,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fdiv,ftrc_s,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,mem_fpscr,gp_fpscr,cwb,tls_load,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n+ \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,fload,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fdiv,ftrc_s,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,mem_fpscr,gp_fpscr,cwb,movua,fsrra,fsca,tls_load,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n   (const_string \"other\"))\n \n ;; We define a new attribute namely \"insn_class\".We use\n@@ -3488,6 +3491,11 @@\n       emit_insn (gen_ic_invalidate_line_compact (operands[0], operands[1]));\n       DONE;\n     }\n+  else if (TARGET_SH4A_ARCH)\n+    {\n+      emit_insn (gen_ic_invalidate_line_sh4a (operands[0]));\n+      DONE;\n+    }\n   operands[0] = force_reg (Pmode, operands[0]);\n   operands[1] = force_reg (Pmode, GEN_INT (trunc_int_for_mode (0xf0000008,\n \t\t\t\t\t\t\t       Pmode)));\n@@ -3508,6 +3516,14 @@\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"cwb\")])\n \n+(define_insn \"ic_invalidate_line_sh4a\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t\t    UNSPEC_ICACHE)]\n+  \"TARGET_SH4A_ARCH\"\n+  \"ocbwb\\\\t@%0\\;synco\\;icbi\\\\t@%0\"\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"type\" \"cwb\")])\n+\n ;; ??? could make arg 0 an offsettable memory operand to allow to save\n ;; an add in the code that calculates the address.\n (define_insn \"ic_invalidate_line_media\"\n@@ -8151,7 +8167,19 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t(xor:PSI (reg:PSI FPSCR_REG) (const_int 1048576)))]\n   \"TARGET_SH4\"\n   \"fschg\"\n-  [(set_attr \"fp_set\" \"unknown\")])\n+  [(set_attr \"type\" \"fp\") (set_attr \"fp_set\" \"unknown\")])\n+\n+;; There's no way we can use it today, since optimize mode switching\n+;; doesn't enable us to know from which mode we're switching to the\n+;; mode it requests, to tell whether we can use a relative mode switch\n+;; (like toggle_pr) or an absolute switch (like loading fpscr from\n+;; memory).\n+(define_insn \"toggle_pr\"\n+  [(set (reg:PSI FPSCR_REG)\n+\t(xor:PSI (reg:PSI FPSCR_REG) (const_int 524288)))]\n+  \"TARGET_SH4A_FP && ! TARGET_FPU_SINGLE\"\n+  \"fpchg\"\n+  [(set_attr \"type\" \"fp\")])\n \n (define_expand \"addsf3\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"\")\n@@ -8650,6 +8678,117 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   [(set_attr \"type\" \"fdiv\")\n    (set_attr \"fp_mode\" \"single\")])\n \n+(define_insn \"rsqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"immediate_operand\" \"i\")\n+\t\t(sqrt:SF (match_operand:SF 2 \"register_operand\" \"0\"))))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4A_FP && flag_unsafe_math_optimizations\n+   && operands[1] == CONST1_RTX (SFmode)\"\n+  \"fsrra\t%0\"\n+  [(set_attr \"type\" \"fsrra\")\n+   (set_attr \"fp_mode\" \"single\")])\n+\n+(define_insn \"fsca\"\n+  [(set (match_operand:V2SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(vec_concat:V2SF\n+\t (unspec:SF [(mult:SF\n+\t\t      (float:SF (match_operand:SI 1 \"fpul_operand\" \"y\"))\n+\t\t      (match_operand:SF 2 \"immediate_operand\" \"i\"))\n+\t\t    ] UNSPEC_FSINA)\n+\t (unspec:SF [(mult:SF (float:SF (match_dup 1)) (match_dup 2))\n+\t\t    ] UNSPEC_FCOSA)))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4A_FP && flag_unsafe_math_optimizations\n+   && operands[2] == sh_fsca_int2sf ()\"\n+  \"fsca\tfpul,%d0\"\n+  [(set_attr \"type\" \"fsca\")\n+   (set_attr \"fp_mode\" \"single\")])\n+\n+(define_expand \"sinsf2\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t(unspec:SF [(match_operand:SF 1 \"fp_arith_reg_operand\" \"\")]\n+\t\t   UNSPEC_FSINA))]\n+  \"TARGET_SH4A_FP && flag_unsafe_math_optimizations\"\n+  \"\n+{\n+  rtx scaled = gen_reg_rtx (SFmode);\n+  rtx truncated = gen_reg_rtx (SImode);\n+  rtx fsca = gen_reg_rtx (V2SFmode);\n+  rtx scale_reg = force_reg (SFmode, sh_fsca_sf2int ());\n+\n+  emit_sf_insn (gen_mulsf3 (scaled, operands[1], scale_reg));\n+  emit_sf_insn (gen_fix_truncsfsi2 (truncated, scaled));\n+  emit_sf_insn (gen_fsca (fsca, truncated, sh_fsca_int2sf (),\n+\t\t\t  get_fpscr_rtx ()));\n+  emit_move_insn (operands[0], gen_rtx_SUBREG (SFmode, fsca, 0));\n+  DONE;\n+}\")\n+\n+(define_expand \"cossf2\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t(unspec:SF [(match_operand:SF 1 \"fp_arith_reg_operand\" \"\")]\n+\t\t   UNSPEC_FCOSA))]\n+  \"TARGET_SH4A_FP && flag_unsafe_math_optimizations\"\n+  \"\n+{\n+  rtx scaled = gen_reg_rtx (SFmode);\n+  rtx truncated = gen_reg_rtx (SImode);\n+  rtx fsca = gen_reg_rtx (V2SFmode);\n+  rtx scale_reg = force_reg (SFmode, sh_fsca_sf2int ());\n+\n+  emit_sf_insn (gen_mulsf3 (scaled, operands[1], scale_reg));\n+  emit_sf_insn (gen_fix_truncsfsi2 (truncated, scaled));\n+  emit_sf_insn (gen_fsca (fsca, truncated, sh_fsca_int2sf (),\n+\t\t\t  get_fpscr_rtx ()));\n+  emit_move_insn (operands[0], gen_rtx_SUBREG (SFmode, fsca, 4));\n+  DONE;\n+}\")\n+\n+(define_expand \"sindf2\"\n+  [(set (match_operand:DF 0 \"fp_arith_reg_operand\" \"\")\n+\t(unspec:DF [(match_operand:DF 1 \"fp_arith_reg_operand\" \"\")]\n+\t\t   UNSPEC_FSINA))]\n+  \"TARGET_SH4A_FP && ! TARGET_FPU_SINGLE && flag_unsafe_math_optimizations\"\n+  \"\n+{\n+  rtx scaled = gen_reg_rtx (DFmode);\n+  rtx truncated = gen_reg_rtx (SImode);\n+  rtx fsca = gen_reg_rtx (V2SFmode);\n+  rtx scale_reg = force_reg (DFmode, sh_fsca_df2int ());\n+  rtx sfresult = gen_reg_rtx (SFmode);\n+\n+  emit_df_insn (gen_muldf3 (scaled, operands[1], scale_reg));\n+  emit_df_insn (gen_fix_truncdfsi2 (truncated, scaled));\n+  emit_sf_insn (gen_fsca (fsca, truncated, sh_fsca_int2sf (),\n+\t\t\t  get_fpscr_rtx ()));\n+  emit_move_insn (sfresult, gen_rtx_SUBREG (SFmode, fsca, 0));\n+  emit_df_insn (gen_extendsfdf2 (operands[0], sfresult));\n+  DONE;\n+}\")\n+\n+(define_expand \"cosdf2\"\n+  [(set (match_operand:DF 0 \"fp_arith_reg_operand\" \"\")\n+\t(unspec:DF [(match_operand:DF 1 \"fp_arith_reg_operand\" \"\")]\n+\t\t   UNSPEC_FCOSA))]\n+  \"TARGET_SH4A_FP && ! TARGET_FPU_SINGLE && flag_unsafe_math_optimizations\"\n+  \"\n+{\n+  rtx scaled = gen_reg_rtx (DFmode);\n+  rtx truncated = gen_reg_rtx (SImode);\n+  rtx fsca = gen_reg_rtx (V2SFmode);\n+  rtx scale_reg = force_reg (DFmode, sh_fsca_df2int ());\n+  rtx sfresult = gen_reg_rtx (SFmode);\n+\n+  emit_df_insn (gen_muldf3 (scaled, operands[1], scale_reg));\n+  emit_df_insn (gen_fix_truncdfsi2 (truncated, scaled));\n+  emit_sf_insn (gen_fsca (fsca, truncated, sh_fsca_int2sf (),\n+\t\t\t  get_fpscr_rtx ()));\n+  emit_move_insn (sfresult, gen_rtx_SUBREG (SFmode, fsca, 4));\n+  emit_df_insn (gen_extendsfdf2 (operands[0], sfresult));\n+  DONE;\n+}\")\n+\n (define_expand \"abssf2\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"\")\n \t(abs:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"\")))]\n@@ -9188,6 +9327,71 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n   DONE;\n }\")\n+\n+(define_insn \"movua\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n+\t(sign_extract:SI (match_operand:SI 1 \"unaligned_load_operand\" \"Sua>\")\n+\t\t\t (const_int 32) (const_int 0)))]\n+  \"TARGET_SH4A_ARCH\"\n+  \"movua.l\t%1,%0\"\n+  [(set_attr \"type\" \"movua\")])\n+\n+;; We shouldn't need this, but cse replaces increments with references\n+;; to other regs before flow has a chance to create post_inc\n+;; addressing modes, and only postreload's cse_move2add brings the\n+;; increments back to a usable form.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extract:SI (mem:SI (match_operand:SI 1 \"register_operand\" \"\"))\n+\t\t\t (const_int 32) (const_int 0)))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 4)))]\n+  \"TARGET_SH4A_ARCH && REGNO (operands[0]) != REGNO (operands[1])\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extract:SI (mem:SI (post_inc:SI\n+\t\t\t\t  (match_operand:SI 1 \"register_operand\" \"\")))\n+\t\t\t (const_int 32) (const_int 0)))]\n+  \"\")\n+\n+(define_expand \"extv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extract:SI (match_operand:QI 1 \"unaligned_load_operand\" \"\")\n+\t\t\t (match_operand 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand 3 \"const_int_operand\" \"\")))]\n+  \"\"\n+{\n+  if (TARGET_SH4A_ARCH\n+      && INTVAL (operands[2]) == 32\n+      && INTVAL (operands[3]) == -24 * (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+      && GET_CODE (operands[1]) == MEM && MEM_ALIGN (operands[1]) < 32)\n+    {\n+      emit_insn (gen_movua (operands[0],\n+\t\t\t    adjust_address (operands[1], SImode, 0)));\n+      DONE;\n+    }\n+\n+  FAIL;\n+})\n+\n+(define_expand \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:QI 1 \"unaligned_load_operand\" \"\")\n+\t\t\t (match_operand 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand 3 \"const_int_operand\" \"\")))]\n+  \"\"\n+{\n+  if (TARGET_SH4A_ARCH\n+      && INTVAL (operands[2]) == 32\n+      && INTVAL (operands[3]) == -24 * (BITS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+      && GET_CODE (operands[1]) == MEM && MEM_ALIGN (operands[1]) < 32)\n+    {\n+      emit_insn (gen_movua (operands[0],\n+\t\t\t    adjust_address (operands[1], SImode, 0)));\n+      DONE;\n+    }\n+\n+  FAIL;\n+})\n+\n \f\n ;; -------------------------------------------------------------------------\n ;; Peepholes\n@@ -10661,9 +10865,11 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   [(prefetch (match_operand:QI 0 \"address_operand\" \"p\")\n              (match_operand:SI 1 \"const_int_operand\" \"n\")\n              (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n-  \"TARGET_SHMEDIA\"\n+  \"TARGET_SHMEDIA || TARGET_HARD_SH4\"\n   \"*\n {\n+  if (TARGET_HARD_SH4)\n+    return \\\"pref @%0\\\";\n   operands[0] = gen_rtx_MEM (QImode, operands[0]);\n   output_asm_insn (\\\"ld%M0.b    %m0,r63\\\", operands);\n   return \\\"\\\";"}, {"sha": "b9bac220559f8c4907c3c156fdd6cd6906b3a918", "filename": "gcc/config/sh/sh4a.md", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh4a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Fsh4a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4a.md?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,235 @@\n+;; Scheduling description for Renesas SH4a\n+;; Copyright (C) 2003 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GNU CC.\n+;;\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; The following description models the SH4A pipeline\n+;; using the DFA based scheduler.\n+\n+(define_automaton \"sh4a\")\n+\n+(define_cpu_unit \"sh4a_ex\"   \"sh4a\")\n+(define_cpu_unit \"sh4a_ls\"   \"sh4a\")\n+(define_cpu_unit \"sh4a_fex\"  \"sh4a\")\n+(define_cpu_unit \"sh4a_fls\"  \"sh4a\")\n+(define_cpu_unit \"sh4a_mult\" \"sh4a\")\n+(define_cpu_unit \"sh4a_fdiv\" \"sh4a\")\n+\n+;; Decoding is done on the integer pipeline like the\n+;; sh4. Define issue to be the | of the two pipelines\n+;; to control how often instructions are issued.\n+(define_reservation \"ID_or\" \"sh4a_ex|sh4a_ls\")\n+(define_reservation \"ID_and\" \"sh4a_ex+sh4a_ls\")\n+\n+\n+;; =======================================================\n+;; Locking Descriptions\n+\n+;; Sh4a_Memory access on the LS pipeline.\n+(define_cpu_unit \"sh4a_memory\" \"sh4a\")\n+\n+;; Other access on the LS pipeline.\n+(define_cpu_unit \"sh4a_load_store\" \"sh4a\")\n+\n+;;  The address calculator used for branch instructions.\n+;; This will be reserved after \"issue\" of branch instructions\n+;; and this is to make sure that no two branch instructions\n+;; can be issued in parallel.\n+(define_reservation \"sh4a_addrcalc\" \"sh4a_ex\")\n+\n+;; =======================================================\n+;; Reservations\n+\n+;; Branch (BF,BF/S,BT,BT/S,BRA,BSR)\n+;; Group: BR\n+;; Latency when taken: 2\n+(define_insn_reservation \"sh4a_branch\" 2\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"cbranch,jump\"))\n+  \"ID_or+sh4a_addrcalc\")\n+\n+;; Jump (JSR,JMP,RTS)\n+;; Group: BR\n+;; Latency: 3\n+(define_insn_reservation \"sh4a_jump\" 3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"return,jump_ind\"))\n+  \"ID_or+sh4a_addrcalc\")\n+\n+;; RTE\n+;; Group: CO\n+;; Latency: 3\n+(define_insn_reservation \"sh4a_rte\" 3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"rte\"))\n+  \"ID_and*4\")\n+\n+;; EX Group Single\n+;; Group: EX\n+;; Latency: 0\n+(define_insn_reservation \"sh4a_ex\" 0\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"insn_class\" \"ex_group\"))\n+  \"sh4a_ex\")\n+\n+;; MOVA\n+;; Group: LS\n+;; Latency: 1\n+(define_insn_reservation \"sh4a_mova\" 1\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"mova\"))\n+  \"sh4a_ls+sh4a_load_store\")\n+\n+;; MOV\n+;; Group: MT\n+;; Latency: 0\n+(define_insn_reservation \"sh4a_mov\" 0\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"move\"))\n+  \"ID_or\")\n+\n+;; Load\n+;; Group: LS\n+;; Latency: 3\n+(define_insn_reservation \"sh4a_load\" 3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"load,pcload\"))\n+  \"sh4a_ls+sh4a_memory\")\n+\n+(define_insn_reservation \"sh4a_load_si\" 3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"load_si,pcload_si\"))\n+  \"sh4a_ls+sh4a_memory\")\n+\n+;; Store\n+;; Group: LS\n+;; Latency: 0\n+(define_insn_reservation \"sh4a_store\" 0\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"store\"))\n+  \"sh4a_ls+sh4a_memory\")\n+\n+;; CWB TYPE\n+\n+;; MOVUA\n+;; Group: LS\n+;; Latency: 3\n+(define_insn_reservation \"sh4a_movua\" 3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"movua\"))\n+  \"sh4a_ls+sh4a_memory*2\")\n+\n+;; Fixed point multiplication (single)\n+;; Group: CO\n+;; Latency: 2\n+(define_insn_reservation \"sh4a_smult\" 2\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"smpy\"))\n+  \"ID_or+sh4a_mult\")\n+\n+;; Fixed point multiplication (double)\n+;; Group: CO\n+;; Latency: 3\n+(define_insn_reservation \"sh4a_dmult\" 3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"dmpy\"))\n+  \"ID_or+sh4a_mult\")\n+\n+(define_insn_reservation \"sh4a_mac_gp\" 3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"mac_gp\"))\n+  \"ID_and\")\n+\n+;; Other MT  group instructions(1 step operations)\n+;; Group:\tMT\n+;; Latency: \t1\n+(define_insn_reservation \"sh4a_mt\" 1\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"mt_group\"))\n+  \"ID_or\")\n+\n+;; Floating point reg move\n+;; Group: LS\n+;; Latency: 2\n+(define_insn_reservation \"sh4a_freg_mov\" 2\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"fmove\"))\n+  \"sh4a_ls,sh4a_fls\")\n+\n+;; Single precision floating point computation FCMP/EQ,\n+;; FCMP/GT, FADD, FLOAT, FMAC, FMUL, FSUB, FTRC, FRVHG, FSCHG\n+;; Group:\tFE\n+;; Latency: \t3\n+(define_insn_reservation \"sh4a_fp_arith\"  3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"fp\"))\n+  \"ID_or,sh4a_fex\")\n+\n+(define_insn_reservation \"sh4a_fp_arith_ftrc\"  3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"ftrc_s\"))\n+  \"ID_or,sh4a_fex\")\n+\n+;; Single-precision FDIV/FSQRT\n+;; Group: FE\n+;; Latency: 20\n+(define_insn_reservation \"sh4a_fdiv\" 20\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"fdiv\"))\n+  \"ID_or,sh4a_fex+sh4a_fdiv,sh4a_fex\")\n+\n+;; Double Precision floating point computation\n+;; (FCNVDS, FCNVSD, FLOAT, FTRC)\n+;; Group:\tFE\n+;; Latency: \t3\n+(define_insn_reservation \"sh4a_dp_float\" 3\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"dfp_conv\"))\n+  \"ID_or,sh4a_fex\")\n+\n+;; Double-precision floating-point (FADD,FMUL,FSUB)\n+;; Group:\tFE\n+;; Latency: \t5\n+(define_insn_reservation \"sh4a_fp_double_arith\" 5\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"dfp_arith\"))\n+  \"ID_or,sh4a_fex*3\")\n+\n+;; Double precision FDIV/SQRT\n+;; Group:\tFE\n+;; Latency: \t36\n+(define_insn_reservation \"sh4a_dp_div\" 36\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"dfdiv\"))\n+  \"ID_or,sh4a_fex+sh4a_fdiv,sh4a_fex*2\")\n+\n+;; FSRRA\n+;; Group: FE\n+;; Latency: 5\n+(define_insn_reservation \"sh4a_fsrra\" 5\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"fsrra\"))\n+  \"ID_or,sh4a_fex\")\n+\n+;; FSCA\n+;; Group: FE\n+;; Latency: 7\n+(define_insn_reservation \"sh4a_fsca\" 7\n+  (and (eq_attr \"cpu\" \"sh4a\")\n+       (eq_attr \"type\" \"fsca\"))\n+  \"ID_or,sh4a_fex*3\")"}, {"sha": "788b852962dabc9bba8ea152f5a0eeb32e0ccaa9", "filename": "gcc/config/sh/t-mlib-sh4a", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1 @@\n+ML_sh4a=m4a/"}, {"sha": "c9dc28bb8863e1bfadde842e1216192caaddd6db", "filename": "gcc/config/sh/t-mlib-sh4a-nofpu", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-nofpu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-nofpu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-nofpu?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1 @@\n+ML_sh4a_nofpu=m4a-nofpu/"}, {"sha": "036a4cc0a36182151ffe33586d492f2e5a4fdeef", "filename": "gcc/config/sh/t-mlib-sh4a-single", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-single", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-single", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-single?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1 @@\n+ML_sh4a_single=m4a-single/"}, {"sha": "5709e8ef7898d43c10c3fb4f7e364422fe56fa85", "filename": "gcc/config/sh/t-mlib-sh4a-single-only", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-single-only", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-single-only", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4a-single-only?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1 @@\n+ML_sh4a_single_only=m4a-single-only/"}, {"sha": "e8e36ba5b860966990e931657a8d4f37f953f050", "filename": "gcc/config/sh/t-mlib-sh4al", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4al", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4al", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-mlib-sh4al?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1 @@\n+ML_sh4al=m4al/"}, {"sha": "97dd99bf10131420a07a89f268f7b56441d3841b", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -22,15 +22,16 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n MULTILIB_ENDIAN = ml/mb\n-MULTILIB_CPUS= $(ML_sh1)$(ML_sh2e)$(ML_sh2)$(ML_sh3e)$(ML_sh3)$(ML_sh4_nofpu)$(ML_sh4_single_only)$(ML_sh4_single)$(ML_sh4)$(ML_m5_32media)$(ML_m5_32media_nofpu)$(ML_m5_compact)$(ML_m5_compact_nofpu)$(ML_m5_64media)$(ML_m5_64media_nofpu)\n+MULTILIB_CPUS= $(ML_sh1)$(ML_sh2e)$(ML_sh2)$(ML_sh3e)$(ML_sh3)$(ML_sh4_nofpu)$(ML_sh4_single_only)$(ML_sh4_single)$(ML_sh4)$(ML_sh4a_nofpu)$(ML_sh4a_single_only)$(ML_sh4a_single)$(ML_sh4a)$(ML_m5_32media)$(ML_m5_32media_nofpu)$(ML_m5_compact)$(ML_m5_compact_nofpu)$(ML_m5_64media)$(ML_m5_64media_nofpu)\n \n MULTILIB_OPTIONS= $(MULTILIB_ENDIAN) $(MULTILIB_CPUS:/=)\n MULTILIB_DIRNAMES= \n #MULTILIB_MATCHES = m2=m3 m2e=m3e m2=m4-nofpu\n MULTILIB_MATCHES = $(shell \\\n   multilibs=\"$(MULTILIB_OPTIONS)\" ; \\\n-  for abi in m1,m2,m3,m4-nofpu \\\n-             m2e,m3e,m4-single-only \\\n+  for abi in m1,m2,m3,m4-nofpu,m4al,m4a-nofpu \\\n+             m2e,m3e,m4-single-only,m4a-single-only \\\n+             m4-single,m4a-single m4,m4a \\\n              m5-32media,m5-compact,m5-32media \\\n              m5-32media-nofpu,m5-compact-nofpu,m5-32media-nofpu; do \\\n     subst= ; \\"}, {"sha": "204c27bca7b8db22538e52d4109ce10b3c852afa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -621,6 +621,7 @@ See RS/6000 and PowerPC Options.\n @emph{SH Options}\n @gccoptlist{-m1  -m2  -m2e  -m3  -m3e @gol\n -m4-nofpu  -m4-single-only  -m4-single  -m4 @gol\n+-m4a-nofpu -m4a-single-only -m4a-single -m4a -m4al @gol\n -m5-64media  -m5-64media-nofpu @gol\n -m5-32media  -m5-32media-nofpu @gol\n -m5-compact  -m5-compact-nofpu @gol\n@@ -10518,6 +10519,31 @@ single-precision mode by default.\n @opindex m4\n Generate code for the SH4.\n \n+@item -m4a-nofpu\n+@opindex m4a-nofpu\n+Generate code for the SH4al-dsp, or for a SH4a in such a way that the\n+floating-point unit is not used.\n+\n+@item -m4a-single-only\n+@opindex m4a-single-only\n+Generate code for the SH4a, in such a way that no double-precision\n+floating point operations are used.\n+\n+@item -m4a-single\n+@opindex m4a-single\n+Generate code for the SH4a assuming the floating-point unit is in\n+single-precision mode by default.\n+\n+@item -m4a\n+@opindex m4a\n+Generate code for the SH4a.\n+\n+@item -m4al\n+@opindex m4al\n+Same as @option{-m4a-nofpu}, except that it implicitly passes\n+@option{-dsp} to the assembler.  GCC doesn't generate any DSP\n+instructions at the moment.\n+\n @item -mb\n @opindex mb\n Compile code for the processor in big endian mode."}, {"sha": "78fa42055bf383ab3b90aa412137cdc34b97a4f8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -1,3 +1,19 @@\n+2004-07-28  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t2003-07-06  Alexandre Oliva  <aoliva@redhat.com>\n+\t* gcc.dg/sh4a-memmovua.c: Tweak regular expression.\n+\t2003-07-01  Alexandre Oliva  <aoliva@redhat.com>\n+\t* gcc.dg/sh4a-bitmovua.c: New.\n+\t* gcc.dg/sh4a-cos.c: New.\n+\t* gcc.dg/sh4a-cosf.c: New.\n+\t* gcc.dg/sh4a-fprun.c: New.\n+\t* gcc.dg/sh4a-fsrra.c: New.\n+\t* gcc.dg/sh4a-memmovua.c: New.\n+\t* gcc.dg/sh4a-sin.c: New.\n+\t* gcc.dg/sh4a-sincos.c: New.\n+\t* gcc.dg/sh4a-sincosf.c: New.\n+\t* gcc.dg/sh4a-sinf.c: New.\n+\n 2004-07-28  Diego Novillo  <dnovillo@redhat.com>\n \n \t* gcc.dg/tree-ssa/20030714-2.c: Adjust number of expected"}, {"sha": "b7081bf7186937629243b50c00b90398a31cf135", "filename": "gcc/testsuite/gcc.dg/sh4a-bitmovua.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-bitmovua.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-bitmovua.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-bitmovua.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,73 @@\n+/* Verify that we generate movua to load unaligned 32-bit values.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { scan-assembler-times \"\\tmovua\\\\.l\\t\" 6 } } */\n+\n+#ifdef __SH4A__\n+/* Aligned.  */\n+struct s0 { long long d : 32; } x0;\n+long long f0() {\n+  return x0.d;\n+}\n+\n+/* Unaligned load.  */\n+struct s1 { long long c : 8; long long d : 32; } x1;\n+long long f1() {\n+  return x1.d;\n+}\n+\n+/* Unaligned load.  */\n+struct s2 { long long c : 16; long long d : 32; } x2;\n+long long f2() {\n+  return x2.d;\n+}\n+\n+/* Unaligned load.  */\n+struct s3 { long long c : 24; long long d : 32; } x3;\n+long long f3() {\n+  return x3.d;\n+}\n+\n+/* Aligned.  */\n+struct s4 { long long c : 32; long long d : 32; } x4;\n+long long f4() {\n+  return x4.d;\n+}\n+\n+/* Aligned.  */\n+struct u0 { unsigned long long d : 32; } y0;\n+unsigned long long g0() {\n+  return y0.d;\n+}\n+\n+/* Unaligned load.  */\n+struct u1 { long long c : 8; unsigned long long d : 32; } y1;\n+unsigned long long g1() {\n+  return y1.d;\n+}\n+\n+/* Unaligned load.  */\n+struct u2 { long long c : 16; unsigned long long d : 32; } y2;\n+unsigned long long g2() {\n+  return y2.d;\n+}\n+\n+/* Unaligned load.  */\n+struct u3 { long long c : 24; unsigned long long d : 32; } y3;\n+unsigned long long g3() {\n+  return y3.d;\n+}\n+\n+/* Aligned.  */\n+struct u4 { long long c : 32; unsigned long long d : 32; } y4;\n+unsigned long long g4() {\n+  return y4.d;\n+}\n+#else\n+asm (\"movua.l\\t\");\n+asm (\"movua.l\\t\");\n+asm (\"movua.l\\t\");\n+asm (\"movua.l\\t\");\n+asm (\"movua.l\\t\");\n+asm (\"movua.l\\t\");\n+#endif"}, {"sha": "198d41f8675d65351f11f483bf14d4763a85fae6", "filename": "gcc/testsuite/gcc.dg/sh4a-cos.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-cos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-cos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-cos.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,13 @@\n+/* Verify that we generate single-precision sine and cosine approximate\n+   (fsca) in fast math mode.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O -ffast-math\" } */\n+/* { dg-final { scan-assembler \"\\tfsca\\t\" } } */\n+\n+#if defined __SH4A__ && ! defined __SH4_NOFPU__\n+#include <math.h>\n+\n+double test(double f) { return cos(f); }\n+#else\n+asm (\"fsca\\t\");\n+#endif"}, {"sha": "f78c140d5014dde3679934659cec2279b5e17401", "filename": "gcc/testsuite/gcc.dg/sh4a-cosf.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-cosf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-cosf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-cosf.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,13 @@\n+/* Verify that we generate single-precision sine and cosine approximate\n+   (fsca) in fast math mode.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O -ffast-math\" } */\n+/* { dg-final { scan-assembler \"\\tfsca\\t\" } } */\n+\n+#if defined __SH4A__ && ! defined __SH4_NOFPU__\n+#include <math.h>\n+\n+float test(float f) { return cosf(f); }\n+#else\n+asm (\"fsca\\t\");\n+#endif"}, {"sha": "8e26dc170a151cc973ec81acdbd41ecdaa9369c1", "filename": "gcc/testsuite/gcc.dg/sh4a-fprun.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-fprun.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-fprun.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-fprun.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,35 @@\n+/* Verify that fsca and fssra yield reasonable results.  */\n+/* { do-do run { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O -ffast-math\" } */\n+\n+#include <math.h>\n+#include <stdlib.h>\n+\n+float sqrt_arg = 4.0f, sqrt_res = 2.0f;\n+float dg2rad_f;\n+double dg2rad_d;\n+\n+void check_f (float res, float expected) {\n+  if (res >= expected - 0.001f && res <= expected + 0.001f)\n+    return;\n+\n+  abort ();\n+}\n+\n+void check_d (double res, double expected) {\n+  if (res >= expected - 0.001 && res <= expected + 0.001)\n+    return;\n+\n+  abort ();\n+}\n+\n+int main() {\n+  check_f (sqrtf(sqrt_arg), sqrt_res);\n+  dg2rad_f = dg2rad_d = atan(1) / 45;\n+  check_f (sinf(90*dg2rad_f), 1);\n+  check_f (cosf(90*dg2rad_f), 0);\n+  check_d (sin(-90*dg2rad_d), -1);\n+  check_d (cos(180*dg2rad_d), -1);\n+  check_d (sin(-45*dg2rad_d) * cosf(135*dg2rad_f), 0.5);\n+  exit (0);\n+}"}, {"sha": "c8f04e4d2e2726df0c6402fed9cc1374398ce424", "filename": "gcc/testsuite/gcc.dg/sh4a-fsrra.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-fsrra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-fsrra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-fsrra.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,13 @@\n+/* Verify that we generate single-precision square root reciprocal\n+   approximate (fsrra) in fast math mode.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O -ffast-math\" } */\n+/* { dg-final { scan-assembler \"\\tfsrra\\t\" } } */\n+\n+#if defined __SH4A__ && ! defined __SH4_NOFPU__\n+#include <math.h>\n+\n+float test(float f) { return 1 / sqrtf(f); }\n+#else\n+asm (\"fsrra\\t\");\n+#endif"}, {"sha": "689279298548bef7922a131566e15531abc484ef", "filename": "gcc/testsuite/gcc.dg/sh4a-memmovua.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-memmovua.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-memmovua.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-memmovua.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,17 @@\n+/* Verify that we generate movua to copy unaligned memory regions to\n+   32-bit-aligned addresses.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { scan-assembler-times \"\\tmovua\\\\.l\\t(.*)+\" 2 } } */\n+\n+#ifdef __SH4A__\n+#include <stdlib.h>\n+\n+struct s { int i; char a[10], b[10]; } x;\n+int f() {\n+  memcpy(x.a, x.b, 10);\n+}\n+#else\n+asm (\"movua.l\\t+\");\n+asm (\"movua.l\\t+\");\n+#endif"}, {"sha": "9f46f600763ad3473dce7a54be9bd836b3cb600a", "filename": "gcc/testsuite/gcc.dg/sh4a-sin.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sin.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,13 @@\n+/* Verify that we generate single-precision sine and cosine approximate\n+   (fsca) in fast math mode.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O -ffast-math\" } */\n+/* { dg-final { scan-assembler \"\\tfsca\\t\" } } */\n+\n+#if defined __SH4A__ && ! defined __SH4_NOFPU__\n+#include <math.h>\n+\n+double test(double f) { return sin(f); }\n+#else\n+asm (\"fsca\\t\");\n+#endif"}, {"sha": "f42937975346dad0e999826904504418aca2f7bb", "filename": "gcc/testsuite/gcc.dg/sh4a-sincos.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sincos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sincos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sincos.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,14 @@\n+/* Verify that we generate a single single-precision sine and cosine\n+   approximate (fsca) in fast math mode when a function computes both\n+   sine and cosine.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"\\tfsca\\t\" 1 } } */\n+\n+#if defined __SH4A__ && ! defined __SH4_NOFPU__\n+#include <math.h>\n+\n+double test(double f) { return sin(f) + cos(f); }\n+#else\n+asm (\"fsca\\t\");\n+#endif"}, {"sha": "42913dbd59eaebeda56387d269b373250238d76a", "filename": "gcc/testsuite/gcc.dg/sh4a-sincosf.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sincosf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sincosf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sincosf.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,14 @@\n+/* Verify that we generate a single single-precision sine and cosine\n+   approximate (fsca) in fast math mode when a function computes both\n+   sine and cosine.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O -ffast-math\" } */\n+/* { dg-final { scan-assembler-times \"\\tfsca\\t\" 1 } } */\n+\n+#if defined __SH4A__ && ! defined __SH4_NOFPU__\n+#include <math.h>\n+\n+float test(float f) { return sinf(f) + cosf(f); }\n+#else\n+asm (\"fsca\\t\");\n+#endif"}, {"sha": "2a2343fd73a4ca79030b263b0a37b91080b6e919", "filename": "gcc/testsuite/gcc.dg/sh4a-sinf.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sinf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sinf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsh4a-sinf.c?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,13 @@\n+/* Verify that we generate single-precision sine and cosine approximate\n+   (fsca) in fast math mode.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O -ffast-math\" } */\n+/* { dg-final { scan-assembler \"\\tfsca\\t\" } } */\n+\n+#if defined __SH4A__ && ! defined __SH4_NOFPU__\n+#include <math.h>\n+\n+float test(float f) { return sinf(f); }\n+#else\n+asm (\"fsca\\t\");\n+#endif"}, {"sha": "aed1079e74d0b3ffd6a64e67e15eeac733c8b734", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -1,3 +1,11 @@\n+2004-07-28  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t2003-10-01  Eric Christopher  <echristo@redhat.com>\n+\t* config/cpu/sh/atomicity.h (__exchange_and_add): Remove 'm'\n+\tconstraint.\n+\t2003-07-09  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/cpu/sh/atomicity.h: New.  Use movli and movco on SH4a.\n+\n 2004-07-23  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/16678"}, {"sha": "b7d6c605d72bc639c5c4a6df17ebd31797e8cf41", "filename": "libstdc++-v3/config/cpu/sh/atomicity.h", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/312209c6a5ff3828335e698a9d0c872a48411fdf/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsh%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/312209c6a5ff3828335e698a9d0c872a48411fdf/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsh%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsh%2Fatomicity.h?ref=312209c6a5ff3828335e698a9d0c872a48411fdf", "patch": "@@ -0,0 +1,123 @@\n+// Low-level functions for atomic operations: Generic version  -*- C++ -*-\n+\n+// Copyright (C) 1999, 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _BITS_ATOMICITY_H\n+#define _BITS_ATOMICITY_H\t1\n+\n+#ifdef __SH4A__\n+\n+typedef int _Atomic_word;\n+\n+static inline _Atomic_word\n+__attribute__ ((__unused__))\n+__exchange_and_add (volatile _Atomic_word* __mem, int __val)\n+{\n+  _Atomic_word __result;\n+\n+  __asm__ __volatile__\n+    (\"0:\\n\"\n+     \"\\tmovli.l\\t@%2,r0\\n\"\n+     \"\\tmov\\tr0,%1\\n\"\n+     \"\\tadd\\t%3,r0\\n\"\n+     \"\\tmovco.l\\tr0,@%2\\n\"\n+     \"\\tbf\\t0b\"\n+     : \"+m\" (*__mem), \"=r\" (__result)\n+     : \"r\" (__mem), \"rI08\" (__val)\n+     : \"r0\");\n+\n+  return __result;\n+}\n+\n+\n+static inline void\n+__attribute__ ((__unused__))\n+__atomic_add (volatile _Atomic_word* __mem, int __val)\n+{\n+  asm(\"0:\\n\"\n+      \"\\tmovli.l\\t@%1,r0\\n\"\n+      \"\\tadd\\t%2,r0\\n\"\n+      \"\\tmovco.l\\tr0,@%1\\n\"\n+      \"\\tbf\\t0b\"\n+      : \"+m\" (*__mem)\n+      : \"r\" (__mem), \"rI08\" (__val)\n+      : \"r0\");\n+}\n+\n+#else\n+\n+/* This is generic/atomicity.h */\n+\n+#include <bits/gthr.h>\n+\n+#define _GLIBCPP_NEED_GENERIC_MUTEX\n+\n+typedef int _Atomic_word;\n+\n+namespace __gnu_cxx\n+{\n+  extern __gthread_mutex_t _Atomic_add_mutex;\n+\n+#ifndef __GTHREAD_MUTEX_INIT\n+  extern __gthread_once_t _Atomic_add_mutex_once;\n+  extern void __gthread_atomic_add_mutex_once();\n+#endif\n+}\n+\n+static inline _Atomic_word\n+__attribute__ ((__unused__))\n+__exchange_and_add (volatile _Atomic_word* __mem, int __val)\n+{\n+#ifndef __GTHREAD_MUTEX_INIT\n+  __gthread_once (&__gnu_cxx::_Atomic_add_mutex_once,\n+                  __gnu_cxx::__gthread_atomic_add_mutex_once);\n+#endif\n+\n+  _Atomic_word __result;\n+\n+  __gthread_mutex_lock (&__gnu_cxx::_Atomic_add_mutex);\n+\n+  __result = *__mem;\n+  *__mem += __val;\n+\n+  __gthread_mutex_unlock (&__gnu_cxx::_Atomic_add_mutex);\n+  return __result;\n+}\n+\n+\n+static inline void\n+__attribute__ ((__unused__))\n+__atomic_add (volatile _Atomic_word* __mem, int __val)\n+{\n+  (void) __exchange_and_add (__mem, __val);\n+}\n+\n+\n+#endif\n+\n+#endif /* atomicity.h */"}]}