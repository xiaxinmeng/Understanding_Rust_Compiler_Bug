{"sha": "804b7cc438701d94db8f958c2211c59f0357b757", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA0YjdjYzQzODcwMWQ5NGRiOGY5NThjMjIxMWM1OWYwMzU3Yjc1Nw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-10-02T14:06:40Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-10-02T14:06:40Z"}, "message": "C++17 P0067R5 std::to_chars and std::from_chars (partial)\n\nThis adds the integral overloads of std::to_chars and std::from_chars,\nincluding the changes made by P0682R0. Support for floating point types\nis absent.\n\n\t* include/Makefile.am: Add new <charconv> header.\n\t* include/Makefile.in: Regenerate.\n\t* include/precompiled/stdc++.h: Include <charconv>.\n\t* include/std/charconv: New file.\n\t(to_chars_result, to_chars, from_chars_result, from_chars): Define.\n\t* testsuite/20_util/from_chars/1.cc: New test.\n\t* testsuite/20_util/from_chars/1_neg.cc: New test.\n\t* testsuite/20_util/from_chars/2.cc: New test.\n\t* testsuite/20_util/from_chars/requirements.cc: New test.\n\t* testsuite/20_util/to_chars/1.cc: New test.\n\t* testsuite/20_util/to_chars/1_neg.cc: New test.\n\t* testsuite/20_util/to_chars/2.cc: New test.\n\t* testsuite/20_util/to_chars/requirements.cc: New test.\n\nFrom-SVN: r253353", "tree": {"sha": "e1a03dca44da9aa855ecc10d42b70286a942ccbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1a03dca44da9aa855ecc10d42b70286a942ccbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/804b7cc438701d94db8f958c2211c59f0357b757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804b7cc438701d94db8f958c2211c59f0357b757", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804b7cc438701d94db8f958c2211c59f0357b757", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804b7cc438701d94db8f958c2211c59f0357b757/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1453bec27eea720664c72e23d81bae22dba94ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1453bec27eea720664c72e23d81bae22dba94ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1453bec27eea720664c72e23d81bae22dba94ef"}], "stats": {"total": 1883, "additions": 1883, "deletions": 0}, "files": [{"sha": "12ac61d6d616daab518c8204cb1c487efdf07034", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -1,3 +1,19 @@\n+2017-10-02  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/Makefile.am: Add new <charconv> header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/precompiled/stdc++.h: Include <charconv>.\n+\t* include/std/charconv: New file.\n+\t(to_chars_result, to_chars, from_chars_result, from_chars): Define.\n+\t* testsuite/20_util/from_chars/1.cc: New test.\n+\t* testsuite/20_util/from_chars/1_neg.cc: New test.\n+\t* testsuite/20_util/from_chars/2.cc: New test.\n+\t* testsuite/20_util/from_chars/requirements.cc: New test.\n+\t* testsuite/20_util/to_chars/1.cc: New test.\n+\t* testsuite/20_util/to_chars/1_neg.cc: New test.\n+\t* testsuite/20_util/to_chars/2.cc: New test.\n+\t* testsuite/20_util/to_chars/requirements.cc: New test.\n+\n 2017-09-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* testsuite/22_locale/money_get/get/char/22131.cc: Make test less"}, {"sha": "236c2d6059f7bac813d84b6cef0bae9a8169beef", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -31,6 +31,7 @@ std_headers = \\\n \t${std_srcdir}/array \\\n \t${std_srcdir}/atomic \\\n \t${std_srcdir}/bitset \\\n+\t${std_srcdir}/charconv \\\n \t${std_srcdir}/chrono \\\n \t${std_srcdir}/codecvt \\\n \t${std_srcdir}/complex \\"}, {"sha": "39dfede549b215223ad60785415ff580a5609cea", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -324,6 +324,7 @@ std_headers = \\\n \t${std_srcdir}/array \\\n \t${std_srcdir}/atomic \\\n \t${std_srcdir}/bitset \\\n+\t${std_srcdir}/charconv \\\n \t${std_srcdir}/chrono \\\n \t${std_srcdir}/codecvt \\\n \t${std_srcdir}/complex \\"}, {"sha": "b2993cd379ffa749b3ddf6550f30600b6ef1e869", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -121,3 +121,7 @@\n #if __cplusplus >= 201402L\n #include <shared_mutex>\n #endif\n+\n+#if __cplusplus > 201402L\n+#include <charconv>\n+#endif"}, {"sha": "b8221e4e434b06539a22a213ab27bddbad1ba35d", "filename": "libstdc++-v3/include/std/charconv", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,654 @@\n+// Primitive numeric conversions (to_chars and from_chars) -*- C++ -*-\n+\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/charconv\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_CHARCONV\n+#define _GLIBCXX_CHARCONV 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <type_traits>\n+#include <limits>\n+#include <cctype>\n+#include <bits/error_constants.h> // for std::errc\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /// Result type of std::to_chars\n+  struct to_chars_result\n+  {\n+    char* ptr;\n+    errc ec;\n+  };\n+\n+  /// Result type of std::from_chars\n+  struct from_chars_result\n+  {\n+    const char* ptr;\n+    errc ec;\n+  };\n+\n+namespace __detail\n+{\n+  template<typename _Tp, typename... _Types>\n+    using __is_one_of = __or_<is_same<_Tp, _Types>...>;\n+\n+  template<typename _Tp>\n+    using __is_int_to_chars_type = __and_<is_integral<_Tp>,\n+\t  __not_<__is_one_of<_Tp, bool, char16_t, char32_t\n+#if _GLIBCXX_USE_WCHAR_T\n+\t  , wchar_t\n+#endif\n+\t    >>>;\n+\n+  template<typename _Tp>\n+    using __integer_to_chars_result_type\n+      = enable_if_t<__is_int_to_chars_type<_Tp>::value, to_chars_result>;\n+\n+  template<typename _Tp>\n+    using __unsigned_least_t\n+      = conditional_t<(sizeof(_Tp) <= sizeof(int)), unsigned int,\n+\tconditional_t<(sizeof(_Tp) <= sizeof(long)), unsigned long,\n+\tconditional_t<(sizeof(_Tp) <= sizeof(long long)), unsigned long long,\n+#if _GLIBCXX_USE_INT128\n+\tconditional_t<(sizeof(_Tp) <= sizeof(__int128)), unsigned __int128,\n+#endif\n+\tvoid>>>>;\n+\n+  // Generic implementation for arbitrary bases.\n+  template<typename _Tp>\n+    constexpr unsigned\n+    __to_chars_len(_Tp __value, int __base = 10) noexcept\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      unsigned __n = 1;\n+      const int __b2 = __base  * __base;\n+      const int __b3 = __b2 * __base;\n+      const int __b4 = __b3 * __base;\n+      for (;;)\n+\t{\n+\t  if (__value < __base) return __n;\n+\t  if (__value < __b2) return __n + 1;\n+\t  if (__value < __b3) return __n + 2;\n+\t  if (__value < __b4) return __n + 3;\n+\t  __value /= (unsigned)__b4;\n+\t  __n += 4;\n+\t}\n+    }\n+\n+  template<typename _Tp>\n+    constexpr unsigned\n+    __to_chars_len_2(_Tp __value) noexcept\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      constexpr size_t __nbits = __CHAR_BIT__ * sizeof(_Tp);\n+\n+      // N.B. __builtin_clzll is undefined if __value == 0, but std::to_chars\n+      // handles zero values directly.\n+\n+      // For sizeof(_Tp) > 1 this is an order of magnitude faster than\n+      // the generic __to_chars_len.\n+      return __nbits\n+\t- (__builtin_clzll(__value)\n+\t    - ((__CHAR_BIT__ * sizeof(long long)) - __nbits));\n+    }\n+\n+  template<typename _Tp>\n+    constexpr unsigned\n+    __to_chars_len_8(_Tp __value) noexcept\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      constexpr size_t __nbits = __CHAR_BIT__ * sizeof(_Tp);\n+\n+      if _GLIBCXX17_CONSTEXPR (__nbits <= 16)\n+\t{\n+\t  return __value > 077777u ? 6u\n+\t    : __value > 07777u ? 5u\n+\t    : __value > 0777u ? 4u\n+\t    : __value > 077u ? 3u\n+\t    : __value > 07u ? 2u\n+\t    : 1u;\n+\t}\n+      else\n+\treturn __to_chars_len(__value, 8);\n+    }\n+\n+  // Generic implementation for arbitrary bases.\n+  template<typename _Tp>\n+    to_chars_result\n+    __to_chars(char* __first, char* __last, _Tp __val, int __base) noexcept\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      to_chars_result __res;\n+\n+      const unsigned __len = __to_chars_len(__val, __base);\n+\n+      if (__builtin_expect((__last - __first) < __len, 0))\n+\t{\n+\t  __res.ptr = __last;\n+\t  __res.ec = errc::value_too_large;\n+\t  return __res;\n+\t}\n+\n+      unsigned __pos = __len - 1;\n+\n+      static constexpr char __digits[]\n+\t= \"0123456789abcdefghijklmnopqrstuvwxyz\";\n+\n+      while (__val >= __base)\n+\t{\n+\t  auto const __quo = __val / __base;\n+\t  auto const __rem = __val % __base;\n+\t  __first[__pos--] = __digits[__rem];\n+\t  __val = __quo;\n+\t}\n+      *__first = __digits[__val];\n+\n+      __res.ptr = __first + __len;\n+      __res.ec = {};\n+      return __res;\n+    }\n+\n+  template<typename _Tp>\n+    __integer_to_chars_result_type<_Tp>\n+    __to_chars_16(char* __first, char* __last, _Tp __val) noexcept\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      to_chars_result __res;\n+\n+      const unsigned __len = __to_chars_len(__val, 0x10);\n+\n+      if (__builtin_expect((__last - __first) < __len, 0))\n+\t{\n+\t  __res.ptr = __last;\n+\t  __res.ec = errc::value_too_large;\n+\t  return __res;\n+\t}\n+\n+      static constexpr char __digits[513] =\n+\t\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\"\n+\t\"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"\n+\t\"404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f\"\n+\t\"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\"\n+\t\"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\"\n+\t\"a0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\"\n+\t\"c0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\"\n+\t\"e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n+      unsigned __pos = __len - 1;\n+      while (__val >= 0x100)\n+\t{\n+\t  auto const __num = (__val % 0x100) * 2;\n+\t  __val /= 0x100;\n+\t  __first[__pos] = __digits[__num + 1];\n+\t  __first[__pos - 1] = __digits[__num];\n+\t  __pos -= 2;\n+\t}\n+      if (__val >= 0x10)\n+\t{\n+\t  auto const __num = __val * 2;\n+\t  __first[__pos] = __digits[__num + 1];\n+\t  __first[__pos - 1] = __digits[__num];\n+\t}\n+      else\n+\t__first[__pos] = \"0123456789abcdef\"[__val];\n+      __res.ptr = __first + __len;\n+      __res.ec = {};\n+      return __res;\n+    }\n+\n+  template<typename _Tp>\n+    __integer_to_chars_result_type<_Tp>\n+    __to_chars_10(char* __first, char* __last, _Tp __val) noexcept\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      to_chars_result __res;\n+\n+      const unsigned __len = __to_chars_len(__val, 10);\n+\n+      if (__builtin_expect((__last - __first) < __len, 0))\n+\t{\n+\t  __res.ptr = __last;\n+\t  __res.ec = errc::value_too_large;\n+\t  return __res;\n+\t}\n+\n+      static constexpr char __digits[201] =\n+\t\"0001020304050607080910111213141516171819\"\n+\t\"2021222324252627282930313233343536373839\"\n+\t\"4041424344454647484950515253545556575859\"\n+\t\"6061626364656667686970717273747576777879\"\n+\t\"8081828384858687888990919293949596979899\";\n+      unsigned __pos = __len - 1;\n+      while (__val >= 100)\n+\t{\n+\t  auto const __num = (__val % 100) * 2;\n+\t  __val /= 100;\n+\t  __first[__pos] = __digits[__num + 1];\n+\t  __first[__pos - 1] = __digits[__num];\n+\t  __pos -= 2;\n+\t}\n+      if (__val >= 10)\n+\t{\n+\t  auto const __num = __val * 2;\n+\t  __first[__pos] = __digits[__num + 1];\n+\t  __first[__pos - 1] = __digits[__num];\n+\t}\n+      else\n+\t__first[__pos] = '0' + __val;\n+      __res.ptr = __first + __len;\n+      __res.ec = {};\n+      return __res;\n+    }\n+\n+  template<typename _Tp>\n+    __integer_to_chars_result_type<_Tp>\n+    __to_chars_8(char* __first, char* __last, _Tp __val) noexcept\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      to_chars_result __res;\n+\n+      const unsigned __len = __to_chars_len_8(__val);\n+\n+      if (__builtin_expect((__last - __first) < __len, 0))\n+\t{\n+\t  __res.ptr = __last;\n+\t  __res.ec = errc::value_too_large;\n+\t  return __res;\n+\t}\n+\n+      static constexpr char __digits[129] =\n+\t\"00010203040506071011121314151617\"\n+\t\"20212223242526273031323334353637\"\n+\t\"40414243444546475051525354555657\"\n+\t\"60616263646566677071727374757677\";\n+      unsigned __pos = __len - 1;\n+      while (__val >= 0100)\n+\t{\n+\t  auto const __num = (__val % 0100) * 2;\n+\t  __val /= 0100;\n+\t  __first[__pos] = __digits[__num + 1];\n+\t  __first[__pos - 1] = __digits[__num];\n+\t  __pos -= 2;\n+\t}\n+      if (__val >= 010)\n+\t{\n+\t  auto const __num = __val * 2;\n+\t  __first[__pos] = __digits[__num + 1];\n+\t  __first[__pos - 1] = __digits[__num];\n+\t}\n+      else\n+\t__first[__pos] = '0' + __val;\n+      __res.ptr = __first + __len;\n+      __res.ec = {};\n+      return __res;\n+    }\n+\n+  template<typename _Tp>\n+    __integer_to_chars_result_type<_Tp>\n+    __to_chars_2(char* __first, char* __last, _Tp __val) noexcept\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      to_chars_result __res;\n+\n+      const unsigned __len = __to_chars_len_2(__val);\n+\n+      if (__builtin_expect((__last - __first) < __len, 0))\n+\t{\n+\t  __res.ptr = __last;\n+\t  __res.ec = errc::value_too_large;\n+\t  return __res;\n+\t}\n+\n+      unsigned __pos = __len - 1;\n+\n+      while (__pos)\n+\t{\n+\t  __first[__pos--] = '0' + (__val & 1);\n+\t  __val >>= 1;\n+\t}\n+      *__first = '0' + (__val & 1);\n+\n+      __res.ptr = __first + __len;\n+      __res.ec = {};\n+      return __res;\n+    }\n+\n+} // namespace __detail\n+\n+  template<typename _Tp>\n+    __detail::__integer_to_chars_result_type<_Tp>\n+    to_chars(char* __first, char* __last, _Tp __value, int __base = 10)\n+    {\n+      __glibcxx_assert(2 <= __base && __base <= 36);\n+\n+      using _Up = __detail::__unsigned_least_t<_Tp>;\n+      _Up __unsigned_val = __value;\n+\n+      if (__value == 0 && __first != __last)\n+\t{\n+\t  *__first = '0';\n+\t  return { __first + 1, errc{} };\n+\t}\n+\n+      if _GLIBCXX17_CONSTEXPR (std::is_signed<_Tp>::value)\n+\tif (__value < 0)\n+\t  {\n+\t    if (__builtin_expect(__first != __last, 1))\n+\t      *__first++ = '-';\n+\t    __unsigned_val = _Up(~__value) + _Up(1);\n+\t  }\n+\n+      switch (__base)\n+      {\n+      case 16:\n+\treturn __detail::__to_chars_16(__first, __last, __unsigned_val);\n+      case 10:\n+\treturn __detail::__to_chars_10(__first, __last, __unsigned_val);\n+      case 8:\n+\treturn __detail::__to_chars_8(__first, __last, __unsigned_val);\n+      case 2:\n+\treturn __detail::__to_chars_2(__first, __last, __unsigned_val);\n+      default:\n+\treturn __detail::__to_chars(__first, __last, __unsigned_val, __base);\n+      }\n+    }\n+\n+namespace __detail\n+{\n+  template<typename _Tp>\n+    bool\n+    __raise_and_add(_Tp& __val, int __base, unsigned char __c)\n+    {\n+      if (__builtin_mul_overflow(__val, __base, &__val)\n+\t  || __builtin_add_overflow(__val, __c, &__val))\n+\treturn false;\n+      return true;\n+    }\n+\n+  /// std::from_chars implementation for integers in base 2.\n+  template<typename _Tp>\n+    bool\n+    __from_chars_binary(const char*& __first, const char* __last, _Tp& __val)\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      const ptrdiff_t __len = __last - __first;\n+      int __i = 0;\n+      while (__i < __len)\n+\t{\n+\t  const unsigned char __c = (unsigned)__first[__i] - '0';\n+\t  if (__c < 2)\n+\t    __val = (__val << 1) | __c;\n+\t  else\n+\t    break;\n+\t  __i++;\n+\t}\n+      __first += __i;\n+      return __i <= (sizeof(_Tp) * __CHAR_BIT__);\n+    }\n+\n+  /// std::from_chars implementation for integers in bases 3 to 10.\n+  template<typename _Tp>\n+    bool\n+    __from_chars_digit(const char*& __first, const char* __last, _Tp& __val,\n+\t\t       int __base)\n+    {\n+      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n+      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n+\n+      auto __matches = [__base](char __c) {\n+\t  return '0' <= __c && __c <= ('0' + (__base - 1));\n+      };\n+\n+      while (__first != __last)\n+\t{\n+\t  const char __c = *__first;\n+\t  if (__matches(__c))\n+\t  {\n+\t    if (!__raise_and_add(__val, __base, __c - '0'))\n+\t      {\n+\t\twhile (++__first != __last && __matches(*__first))\n+\t\t  ;\n+\t\treturn false;\n+\t      }\n+\t    __first++;\n+\t  }\n+\t  else\n+\t    return true;\n+\t}\n+      return true;\n+    }\n+\n+  constexpr unsigned char\n+  __from_chars_alpha_to_num(char __c)\n+  {\n+    switch (__c)\n+    {\n+    case 'a':\n+    case 'A':\n+      return 10;\n+    case 'b':\n+    case 'B':\n+      return 11;\n+    case 'c':\n+    case 'C':\n+      return 12;\n+    case 'd':\n+    case 'D':\n+      return 13;\n+    case 'e':\n+    case 'E':\n+      return 14;\n+    case 'f':\n+    case 'F':\n+      return 15;\n+    case 'g':\n+    case 'G':\n+      return 16;\n+    case 'h':\n+    case 'H':\n+      return 17;\n+    case 'i':\n+    case 'I':\n+      return 18;\n+    case 'j':\n+    case 'J':\n+      return 19;\n+    case 'k':\n+    case 'K':\n+      return 20;\n+    case 'l':\n+    case 'L':\n+      return 21;\n+    case 'm':\n+    case 'M':\n+      return 22;\n+    case 'n':\n+    case 'N':\n+      return 23;\n+    case 'o':\n+    case 'O':\n+      return 24;\n+    case 'p':\n+    case 'P':\n+      return 25;\n+    case 'q':\n+    case 'Q':\n+      return 26;\n+    case 'r':\n+    case 'R':\n+      return 27;\n+    case 's':\n+    case 'S':\n+      return 28;\n+    case 't':\n+    case 'T':\n+      return 29;\n+    case 'u':\n+    case 'U':\n+      return 30;\n+    case 'v':\n+    case 'V':\n+      return 31;\n+    case 'w':\n+    case 'W':\n+      return 32;\n+    case 'x':\n+    case 'X':\n+      return 33;\n+    case 'y':\n+    case 'Y':\n+      return 34;\n+    case 'z':\n+    case 'Z':\n+      return 35;\n+    }\n+    return std::numeric_limits<unsigned char>::max();\n+  }\n+\n+  /// std::from_chars implementation for integers in bases 11 to 26.\n+  template<typename _Tp>\n+    bool\n+    __from_chars_alnum(const char*& __first, const char* __last, _Tp& __val,\n+\t\t       int __base)\n+    {\n+      bool __valid = true;\n+      while (__first != __last)\n+\t{\n+\t  unsigned char __c = *__first;\n+\t  if (std::isdigit(__c))\n+\t    __c -= '0';\n+\t  else\n+\t    {\n+\t      __c = __from_chars_alpha_to_num(__c);\n+\t      if (__c >= __base)\n+\t\tbreak;\n+\t    }\n+\n+\t  if (__builtin_expect(__valid, 1))\n+\t    __valid = __raise_and_add(__val, __base, __c);\n+\t  __first++;\n+\t}\n+      return __valid;\n+    }\n+\n+  template<typename _Tp>\n+    using __integer_from_chars_result_type\n+      = enable_if_t<__is_int_to_chars_type<_Tp>::value, from_chars_result>;\n+\n+} // namespace __detail\n+\n+  /// std::from_chars for integral types.\n+  template<typename _Tp>\n+    __detail::__integer_from_chars_result_type<_Tp>\n+    from_chars(const char* __first, const char* __last, _Tp& __value,\n+\t       int __base = 10)\n+    {\n+      __glibcxx_assert(2 <= __base && __base <= 36);\n+\n+      from_chars_result __res{__first, {}};\n+\n+      int __sign = 1;\n+      if _GLIBCXX17_CONSTEXPR (std::is_signed<_Tp>::value)\n+\tif (__first != __last && *__first == '-')\n+\t  {\n+\t    __sign = -1;\n+\t    ++__first;\n+\t  }\n+\n+      using _Up = __detail::__unsigned_least_t<_Tp>;\n+      _Up __val = 0;\n+\n+      const auto __start = __first;\n+      bool __valid;\n+      if (__base == 2)\n+\t__valid = __detail::__from_chars_binary(__first, __last, __val);\n+      else if (__base <= 10)\n+\t__valid = __detail::__from_chars_digit(__first, __last, __val, __base);\n+      else\n+\t__valid = __detail::__from_chars_alnum(__first, __last, __val, __base);\n+\n+      if (__builtin_expect(__first == __start, 0))\n+\t__res.ec = errc::invalid_argument;\n+      else\n+\t{\n+\t  __res.ptr = __first;\n+\t  if (!__valid)\n+\t    __res.ec = errc::result_out_of_range;\n+\t  else\n+\t    {\n+\t      if _GLIBCXX17_CONSTEXPR (std::is_signed<_Tp>::value)\n+\t\t{\n+\t\t  _Tp __tmp;\n+\t\t  if (__builtin_mul_overflow(__val, __sign, &__tmp))\n+\t\t    __res.ec = errc::result_out_of_range;\n+\t\t  else\n+\t\t    __value = __tmp;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if _GLIBCXX17_CONSTEXPR\n+\t\t    (numeric_limits<_Up>::max() > numeric_limits<_Tp>::max())\n+\t\t    {\n+\t\t      if (__val > numeric_limits<_Tp>::max())\n+\t\t\t__res.ec = errc::result_out_of_range;\n+\t\t      else\n+\t\t\t__value = __val;\n+\t\t    }\n+\t\t  else\n+\t\t    __value = __val;\n+\t\t}\n+\t    }\n+\t}\n+      return __res;\n+    }\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // C++14\n+#endif // _GLIBCXX_CHARCONV"}, {"sha": "b552195ae961da5557a3affb8aaf5546e48da024", "filename": "libstdc++-v3/testsuite/20_util/from_chars/1.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1.cc?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <charconv>\n+#include <string_view>\n+\n+template<typename I>\n+bool\n+check_from_chars(I expected, std::string_view s, int base = 0, char term = '\\0')\n+{\n+  I val;\n+  std::from_chars_result r = base == 0\n+    ? std::from_chars(s.begin(), s.end(), val)\n+    : std::from_chars(s.begin(), s.end(), val, base);\n+  return r.ec == std::errc{} && (r.ptr == s.end() || *r.ptr == term) && val == expected;\n+}\n+\n+#include <climits>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  // Using base 10\n+  VERIFY( check_from_chars(123, \"123\") );\n+  VERIFY( check_from_chars(-123, \"-123\") );\n+  VERIFY( check_from_chars(123, \"123a\", 10, 'a') );\n+  VERIFY( check_from_chars(123, \"0000000000000000000000000000123\") );\n+  VERIFY( check_from_chars(123, \"0000000000000000000000000000123a\", 10, 'a') );\n+}\n+\n+void\n+test02()\n+{\n+  // \"0x\" parsed as \"0\" not as hex prefix:\n+  VERIFY( check_from_chars(0, \"0x1\", 10, 'x') );\n+  VERIFY( check_from_chars(0, \"0X1\", 10, 'X') );\n+  VERIFY( check_from_chars(0, \"0x1\", 16, 'x') );\n+  VERIFY( check_from_chars(0, \"0X1\", 16, 'X') );\n+\n+  VERIFY( check_from_chars(1155, \"xx\", 34) );\n+  VERIFY( check_from_chars(1155, \"XX\", 34) );\n+  VERIFY( check_from_chars(1155, \"Xx\", 34) );\n+  VERIFY( check_from_chars(1224, \"yy\", 35) );\n+  VERIFY( check_from_chars(1224, \"YY\", 35) );\n+  VERIFY( check_from_chars(1224, \"yY\", 35) );\n+  VERIFY( check_from_chars(1295, \"zz\", 36) );\n+  VERIFY( check_from_chars(1295, \"ZZ\", 36) );\n+  VERIFY( check_from_chars(1295, \"Zz\", 36) );\n+\n+  // Parsing stops at first invalid digit for the given base:\n+  VERIFY( check_from_chars(1, \"01234\", 2, '2') );\n+  VERIFY( check_from_chars(27, \"1234\", 4, '4') );\n+  VERIFY( check_from_chars(1155, \"xxy\", 34, 'y') );\n+  VERIFY( check_from_chars(1224, \"yyz\", 35, 'z') );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "d826ba9712bfd3174472f5bf0a674f9117e2bc79", "filename": "libstdc++-v3/testsuite/20_util/from_chars/1_neg.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F1_neg.cc?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <charconv>\n+\n+void\n+test01(const char* first, const char* last)\n+{\n+#if _GLIBCXX_USE_WCHAR_T\n+  wchar_t wc;\n+  std::from_chars(first, last, wc); // { dg-error \"no matching\" }\n+  std::from_chars(first, last, wc, 10); // { dg-error \"no matching\" }\n+#endif\n+\n+  char16_t c16;\n+  std::from_chars(first, last, c16); // { dg-error \"no matching\" }\n+  std::from_chars(first, last, c16, 10); // { dg-error \"no matching\" }\n+  char32_t c32;\n+  std::from_chars(first, last, c32); // { dg-error \"no matching\" }\n+  std::from_chars(first, last, c32, 10); // { dg-error \"no matching\" }\n+}"}, {"sha": "117cf74662ae81f1ce126382f9605c29f53c0f98", "filename": "libstdc++-v3/testsuite/20_util/from_chars/2.cc", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2F2.cc?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,205 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <charconv>\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+\n+// Test std::from_chars error handling.\n+\n+void\n+test01()\n+{\n+  std::from_chars_result r;\n+  int i = 999;\n+  std::string_view s;\n+\n+  s = \"\";\n+  r = std::from_chars(s.begin(), s.end(), i);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.begin() );\n+  VERIFY( i == 999 );\n+\n+  s = \"*\";\n+  r = std::from_chars(s.begin(), s.end(), i);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.begin() );\n+  VERIFY( i == 999 );\n+\n+  s = \"-\";\n+  r = std::from_chars(s.begin(), s.end(), i);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.begin() );\n+  VERIFY( i == 999 );\n+\n+  s = \"-*\";\n+  r = std::from_chars(s.begin(), s.end(), i);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.begin() );\n+  VERIFY( i == 999 );\n+\n+  unsigned u = 888;\n+  s = \"-1\";\n+  r = std::from_chars(s.begin(), s.end(), u);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.begin() );\n+  s = \"-a\";\n+  r = std::from_chars(s.begin(), s.end(), u);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.begin() );\n+  s = \"-\";\n+  r = std::from_chars(s.begin(), s.end(), u);\n+  VERIFY( r.ec == std::errc::invalid_argument );\n+  VERIFY( r.ptr == s.begin() );\n+  VERIFY( u == 888 );\n+\n+  for (int base = 2; base <= 36; ++base)\n+  {\n+    const char digits[] = \"0123456789abcdefghijklmnopqrstuvwxyz*\";\n+    const char buf[2] = { '-', digits[base] };\n+    r = std::from_chars(buf, buf + 1, i, base);\n+    VERIFY( r.ec == std::errc::invalid_argument );\n+    VERIFY( r.ptr == buf );\n+    VERIFY( i == 999 );\n+    r = std::from_chars(buf + 1, buf + 2, i, base);\n+    VERIFY( r.ec == std::errc::invalid_argument );\n+    VERIFY( r.ptr == buf + 1 );\n+    VERIFY( i == 999 );\n+    r = std::from_chars(buf, buf + 2, i, base);\n+    VERIFY( r.ec == std::errc::invalid_argument );\n+    VERIFY( r.ptr == buf );\n+    VERIFY( i == 999 );\n+  }\n+}\n+\n+void\n+test02()\n+{\n+  std::from_chars_result r;\n+  std::string_view s;\n+\n+  signed char c = -5;\n+  s = \"-10000001\";\n+  r = std::from_chars(s.begin(), s.end(), c, 2);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"-10000001*\";\n+  r = std::from_chars(s.begin(), s.end(), c, 2);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 9 );\n+  s = \"-10000001000*\";\n+  r = std::from_chars(s.begin(), s.end(), c, 2);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 12 );\n+  s = \"-129\";\n+  r = std::from_chars(s.begin(), s.end(), c, 10);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"-129*\";\n+  r = std::from_chars(s.begin(), s.end(), c, 10);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 4 );\n+  s = \"-100\";\n+  r = std::from_chars(s.begin(), s.end(), c, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"-100*\";\n+  r = std::from_chars(s.begin(), s.end(), c, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 4 );\n+  s = \"-81\";\n+  r = std::from_chars(s.begin(), s.end(), c, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"-81*\";\n+  r = std::from_chars(s.begin(), s.end(), c, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 3 );\n+  s = \"128\";\n+  r = std::from_chars(s.begin(), s.end(), c, 10);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"128*\";\n+  r = std::from_chars(s.begin(), s.end(), c, 10);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 3 );\n+  s = \"80\";\n+  r = std::from_chars(s.begin(), s.end(), c, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"80*\";\n+  r = std::from_chars(s.begin(), s.end(), c, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 2 );\n+  VERIFY( c == -5 );\n+\n+  unsigned char uc = 9;\n+  s = \"100000000\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 2);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"100000000*\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 2);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 9 );\n+  s = \"100000000000*\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 2);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 12 );\n+  s = \"256\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 10);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"256**\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 10);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 3 );\n+  s = \"256000**\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 10);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 6 );\n+  s = \"100\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.end() );\n+  s = \"100**\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 3 );\n+  s = \"100000**\";\n+  r = std::from_chars(s.begin(), s.end(), uc, 16);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 6 );\n+  VERIFY( uc == 9 );\n+\n+  unsigned long long ull = 123;\n+  s = \"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz****\";\n+  r = std::from_chars(s.begin(), s.end(), ull, 36);\n+  VERIFY( r.ec == std::errc::result_out_of_range );\n+  VERIFY( r.ptr == s.begin() + 42 );\n+  VERIFY( ull == 123 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "00b7d875664ea5b4625bd8481c6615710ef000bf", "filename": "libstdc++-v3/testsuite/20_util/from_chars/requirements.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ffrom_chars%2Frequirements.cc?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <charconv>\n+\n+namespace std\n+{\n+  struct from_chars_result;\n+\n+  const char* from_chars_result::*pm2 = &from_chars_result::ptr;\n+  errc from_chars_result::*pm1 = &from_chars_result::ec;\n+\n+  from_chars_result (*f1)(const char*, const char*, char&, int)\n+    = &from_chars;\n+  from_chars_result (*f2)(const char*, const char*, signed char&, int)\n+    = &from_chars;\n+  from_chars_result (*f3)(const char*, const char*, unsigned char&, int)\n+    = &from_chars;\n+  from_chars_result (*f4)(const char*, const char*, signed short&, int)\n+    = &from_chars;\n+  from_chars_result (*f5)(const char*, const char*, unsigned short&, int)\n+    = &from_chars;\n+  from_chars_result (*f6)(const char*, const char*, signed int&, int)\n+    = &from_chars;\n+  from_chars_result (*f7)(const char*, const char*, unsigned int&, int)\n+    = &from_chars;\n+  from_chars_result (*f8)(const char*, const char*, signed long&, int)\n+    = &from_chars;\n+  from_chars_result (*f9)(const char*, const char*, unsigned long&, int)\n+    = &from_chars;\n+  from_chars_result (*f10)(const char*, const char*, signed long long&, int)\n+    = &from_chars;\n+  from_chars_result (*f11)(const char*, const char*, unsigned long long&, int)\n+    = &from_chars;\n+}\n+\n+void bind()\n+{\n+  const char buf[1] = \"\";\n+  int i;\n+  auto [p, e] = std::from_chars(buf, buf + 1, i, 10);\n+  const char** pa = &p;\n+  std::errc* ea = &e;\n+}"}, {"sha": "bdd961104a215de7adc09c2f20a79e307097b558", "filename": "libstdc++-v3/testsuite/20_util/to_chars/1.cc", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F1.cc?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,661 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <charconv>\n+#include <string_view>\n+\n+template<typename I>\n+bool\n+check_to_chars(I val, std::string_view expected, int base = 0)\n+{\n+  // Space for minus sign, 64 binary digits, final '*', and null terminator:\n+  char buf[67] = \"******************************************************************\";\n+  std::to_chars_result r = base == 0\n+    ? std::to_chars(buf, buf+sizeof(buf), val)\n+    : std::to_chars(buf, buf+sizeof(buf), val, base);\n+  return r.ec == std::errc{} && *r.ptr == '*' && std::string_view(buf, r.ptr - buf) == expected;\n+}\n+\n+#include <string>\n+#include <climits>\n+#include <testsuite_hooks.h>\n+\n+// Using default base 10\n+void\n+test01()\n+{\n+  VERIFY( check_to_chars<char>(0, \"0\") );\n+  VERIFY( check_to_chars<signed char>(0, \"0\") );\n+  VERIFY( check_to_chars<unsigned char>(0, \"0\") );\n+  VERIFY( check_to_chars<signed short>(0, \"0\") );\n+  VERIFY( check_to_chars<unsigned short>(0, \"0\") );\n+  VERIFY( check_to_chars<signed int>(0, \"0\") );\n+  VERIFY( check_to_chars<unsigned int>(0, \"0\") );\n+  VERIFY( check_to_chars<signed long>(0, \"0\") );\n+  VERIFY( check_to_chars<unsigned long>(0, \"0\") );\n+  VERIFY( check_to_chars<signed long long>(0, \"0\") );\n+  VERIFY( check_to_chars<unsigned long long>(0, \"0\") );\n+\n+  VERIFY( check_to_chars<char>(1, \"1\") );\n+  VERIFY( check_to_chars<signed char>(1, \"1\") );\n+  VERIFY( check_to_chars<unsigned char>(1, \"1\") );\n+  VERIFY( check_to_chars<signed short>(1, \"1\") );\n+  VERIFY( check_to_chars<unsigned short>(1, \"1\") );\n+  VERIFY( check_to_chars<signed int>(1, \"1\") );\n+  VERIFY( check_to_chars<unsigned int>(1, \"1\") );\n+  VERIFY( check_to_chars<signed long>(1, \"1\") );\n+  VERIFY( check_to_chars<unsigned long>(1, \"1\") );\n+  VERIFY( check_to_chars<signed long long>(1, \"1\") );\n+  VERIFY( check_to_chars<unsigned long long>(1, \"1\") );\n+\n+  VERIFY( check_to_chars<char>(123, \"123\") );\n+  VERIFY( check_to_chars<signed char>(123, \"123\") );\n+  VERIFY( check_to_chars<unsigned char>(123, \"123\") );\n+  VERIFY( check_to_chars<signed short>(123, \"123\") );\n+  VERIFY( check_to_chars<unsigned short>(123, \"123\") );\n+  VERIFY( check_to_chars<signed int>(123, \"123\") );\n+  VERIFY( check_to_chars<unsigned int>(123, \"123\") );\n+  VERIFY( check_to_chars<signed long>(123, \"123\") );\n+  VERIFY( check_to_chars<unsigned long>(123, \"123\") );\n+  VERIFY( check_to_chars<signed long long>(123, \"123\") );\n+  VERIFY( check_to_chars<unsigned long long>(123, \"123\") );\n+\n+  if constexpr (std::is_signed_v<char>)\n+    VERIFY( check_to_chars<char>(-79, \"-79\") );\n+  VERIFY( check_to_chars<signed char>(-79, \"-79\") );\n+  VERIFY( check_to_chars<signed short>(-79, \"-79\") );\n+  VERIFY( check_to_chars<signed int>(-79, \"-79\") );\n+  VERIFY( check_to_chars<signed long>(-79, \"-79\") );\n+  VERIFY( check_to_chars<signed long long>(-79, \"-79\") );\n+\n+  using std::to_string;\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX, to_string(CHAR_MAX)) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX, to_string(SCHAR_MAX)) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX, to_string(UCHAR_MAX)) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX, to_string(SHRT_MAX)) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX, to_string(USHRT_MAX)) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX, to_string(INT_MAX)) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX, to_string(UINT_MAX)) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX, to_string(LONG_MAX)) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX, to_string(ULONG_MAX)) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX, to_string(LLONG_MAX)) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX, to_string(ULLONG_MAX)) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MIN, to_string(CHAR_MIN)) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MIN, to_string(SCHAR_MIN)) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MIN, to_string(SHRT_MIN)) );\n+  VERIFY( check_to_chars<signed int>(INT_MIN, to_string(INT_MIN)) );\n+  VERIFY( check_to_chars<signed long>(LONG_MIN, to_string(LONG_MIN)) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MIN, to_string(LLONG_MIN)) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX/2, to_string(CHAR_MAX/2)) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX/2, to_string(SCHAR_MAX/2)) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX/2, to_string(UCHAR_MAX/2)) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX/2, to_string(SHRT_MAX/2)) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX/2, to_string(USHRT_MAX/2)) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX/2, to_string(INT_MAX/2)) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX/2, to_string(UINT_MAX/2)) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX/2, to_string(LONG_MAX/2)) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX/2, to_string(ULONG_MAX/2)) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX/2, to_string(LLONG_MAX/2)) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX/2, to_string(ULLONG_MAX/2)) );\n+}\n+\n+// Using explicit base 10\n+void\n+test02()\n+{\n+  VERIFY( check_to_chars<char>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<signed char>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<unsigned char>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<signed short>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<unsigned short>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<signed int>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<unsigned int>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<signed long>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<unsigned long>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<signed long long>(0, \"0\", 10) );\n+  VERIFY( check_to_chars<unsigned long long>(0, \"0\", 10) );\n+\n+  VERIFY( check_to_chars<char>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<signed char>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<unsigned char>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<signed short>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<unsigned short>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<signed int>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<unsigned int>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<signed long>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<unsigned long>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<signed long long>(1, \"1\", 10) );\n+  VERIFY( check_to_chars<unsigned long long>(1, \"1\", 10) );\n+\n+  VERIFY( check_to_chars<char>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<signed char>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<unsigned char>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<signed short>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<unsigned short>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<signed int>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<unsigned int>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<signed long>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<unsigned long>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<signed long long>(123, \"123\", 10) );\n+  VERIFY( check_to_chars<unsigned long long>(123, \"123\", 10) );\n+\n+  if constexpr (std::is_signed_v<char>)\n+    VERIFY( check_to_chars<char>(-79, \"-79\", 10) );\n+  VERIFY( check_to_chars<signed char>(-79, \"-79\", 10) );\n+  VERIFY( check_to_chars<signed short>(-79, \"-79\", 10) );\n+  VERIFY( check_to_chars<signed int>(-79, \"-79\", 10) );\n+  VERIFY( check_to_chars<signed long>(-79, \"-79\", 10) );\n+  VERIFY( check_to_chars<signed long long>(-79, \"-79\", 10) );\n+\n+  using std::to_string;\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX, to_string(CHAR_MAX), 10) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX, to_string(SCHAR_MAX), 10) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX, to_string(UCHAR_MAX), 10) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX, to_string(SHRT_MAX), 10) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX, to_string(USHRT_MAX), 10) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX, to_string(INT_MAX), 10) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX, to_string(UINT_MAX), 10) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX, to_string(LONG_MAX), 10) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX, to_string(ULONG_MAX), 10) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX, to_string(LLONG_MAX), 10) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX, to_string(ULLONG_MAX), 10) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MIN, to_string(CHAR_MIN), 10) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MIN, to_string(SCHAR_MIN), 10) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MIN, to_string(SHRT_MIN), 10) );\n+  VERIFY( check_to_chars<signed int>(INT_MIN, to_string(INT_MIN), 10) );\n+  VERIFY( check_to_chars<signed long>(LONG_MIN, to_string(LONG_MIN), 10) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MIN, to_string(LLONG_MIN), 10) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX/2, to_string(CHAR_MAX/2), 10) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX/2, to_string(SCHAR_MAX/2), 10) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX/2, to_string(UCHAR_MAX/2), 10) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX/2, to_string(SHRT_MAX/2), 10) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX/2, to_string(USHRT_MAX/2), 10) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX/2, to_string(INT_MAX/2), 10) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX/2, to_string(UINT_MAX/2), 10) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX/2, to_string(LONG_MAX/2), 10) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX/2, to_string(ULONG_MAX/2), 10) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX/2, to_string(LLONG_MAX/2), 10) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX/2, to_string(ULLONG_MAX/2), 10) );\n+}\n+\n+// Using all bases\n+void\n+test03()\n+{\n+  // -2017 in all bases from [2,36]\n+  const char* str2017[37] = { nullptr, nullptr,\n+    \"-11111100001\",\n+    \"-2202201\",\n+    \"-133201\",\n+    \"-31032\",\n+    \"-13201\",\n+    \"-5611\",\n+    \"-3741\",\n+    \"-2681\",\n+    \"-2017\",\n+    \"-1574\",\n+    \"-1201\",\n+    \"-bc2\",\n+    \"-a41\",\n+    \"-8e7\",\n+    \"-7e1\",\n+    \"-6gb\",\n+    \"-641\",\n+    \"-5b3\",\n+    \"-50h\",\n+    \"-4c1\",\n+    \"-43f\",\n+    \"-3ig\",\n+    \"-3c1\",\n+    \"-35h\",\n+    \"-2pf\",\n+    \"-2kj\",\n+    \"-2g1\",\n+    \"-2bg\",\n+    \"-277\",\n+    \"-232\",\n+    \"-1v1\",\n+    \"-1s4\",\n+    \"-1pb\",\n+    \"-1mm\",\n+    \"-1k1\"\n+  };\n+  // -12345 in all bases from [2,36]\n+  const char* str12345[37] = { nullptr, nullptr,\n+    \"-11000000111001\",\n+    \"-121221020\",\n+    \"-3000321\",\n+    \"-343340\",\n+    \"-133053\",\n+    \"-50664\",\n+    \"-30071\",\n+    \"-17836\",\n+    \"-12345\",\n+    \"-9303\",\n+    \"-7189\",\n+    \"-5808\",\n+    \"-46db\",\n+    \"-39d0\",\n+    \"-3039\",\n+    \"-28c3\",\n+    \"-221f\",\n+    \"-1f3e\",\n+    \"-1ah5\",\n+    \"-16ki\",\n+    \"-13b3\",\n+    \"-107h\",\n+    \"-la9\",\n+    \"-jik\",\n+    \"-i6l\",\n+    \"-gp6\",\n+    \"-fkp\",\n+    \"-ejk\",\n+    \"-dlf\",\n+    \"-cq7\",\n+    \"-c1p\",\n+    \"-bb3\",\n+    \"-an3\",\n+    \"-a2p\",\n+    \"-9ix\"\n+  };\n+  // -23456 in all bases from [2,36]\n+  const char* str23456[37] = { nullptr, nullptr,\n+    \"-101101110100000\",\n+    \"-1012011202\",\n+    \"-11232200\",\n+    \"-1222311\",\n+    \"-300332\",\n+    \"-125246\",\n+    \"-55640\",\n+    \"-35152\",\n+    \"-23456\",\n+    \"-16694\",\n+    \"-116a8\",\n+    \"-a8a4\",\n+    \"-8796\",\n+    \"-6e3b\",\n+    \"-5ba0\",\n+    \"-4d2d\",\n+    \"-4072\",\n+    \"-37ia\",\n+    \"-2icg\",\n+    \"-2b3k\",\n+    \"-24a4\",\n+    \"-1l7j\",\n+    \"-1gh8\",\n+    \"-1cd6\",\n+    \"-18i4\",\n+    \"-154k\",\n+    \"-11pk\",\n+    \"-rpo\",\n+    \"-q1q\",\n+    \"-ock\",\n+    \"-mt0\",\n+    \"-lhq\",\n+    \"-k9u\",\n+    \"-j56\",\n+    \"-i3k\"\n+  };\n+  // INT_MIN in all bases from [2,36]\n+  const char* strINT_MIN[37] = { nullptr, nullptr,\n+    \"-10000000000000000000000000000000\",\n+    \"-12112122212110202102\",\n+    \"-2000000000000000\",\n+    \"-13344223434043\",\n+    \"-553032005532\",\n+    \"-104134211162\",\n+    \"-20000000000\",\n+    \"-5478773672\",\n+    \"-2147483648\",\n+    \"-a02220282\",\n+    \"-4bb2308a8\",\n+    \"-282ba4aab\",\n+    \"-1652ca932\",\n+    \"-c87e66b8\",\n+    \"-80000000\",\n+    \"-53g7f549\",\n+    \"-3928g3h2\",\n+    \"-27c57h33\",\n+    \"-1db1f928\",\n+    \"-140h2d92\",\n+    \"-ikf5bf2\",\n+    \"-ebelf96\",\n+    \"-b5gge58\",\n+    \"-8jmdnkn\",\n+    \"-6oj8ioo\",\n+    \"-5ehnckb\",\n+    \"-4clm98g\",\n+    \"-3hk7988\",\n+    \"-2sb6cs8\",\n+    \"-2d09uc2\",\n+    \"-2000000\",\n+    \"-1lsqtl2\",\n+    \"-1d8xqrq\",\n+    \"-15v22un\",\n+    \"-zik0zk\"\n+  };\n+\n+  for (int base = 2; base <= 36; ++base)\n+  {\n+    VERIFY( check_to_chars<char>(0, \"0\", base) );\n+    VERIFY( check_to_chars<signed char>(0, \"0\", base) );\n+    VERIFY( check_to_chars<unsigned char>(0, \"0\", base) );\n+    VERIFY( check_to_chars<signed short>(0, \"0\", base) );\n+    VERIFY( check_to_chars<unsigned short>(0, \"0\", base) );\n+    VERIFY( check_to_chars<signed int>(0, \"0\", base) );\n+    VERIFY( check_to_chars<unsigned int>(0, \"0\", base) );\n+    VERIFY( check_to_chars<signed long>(0, \"0\", base) );\n+    VERIFY( check_to_chars<unsigned long>(0, \"0\", base) );\n+    VERIFY( check_to_chars<signed long long>(0, \"0\", base) );\n+    VERIFY( check_to_chars<unsigned long long>(0, \"0\", base) );\n+\n+    VERIFY( check_to_chars<char>(1, \"1\", base) );\n+    VERIFY( check_to_chars<signed char>(1, \"1\", base) );\n+    VERIFY( check_to_chars<unsigned char>(1, \"1\", base) );\n+    VERIFY( check_to_chars<signed short>(1, \"1\", base) );\n+    VERIFY( check_to_chars<unsigned short>(1, \"1\", base) );\n+    VERIFY( check_to_chars<signed int>(1, \"1\", base) );\n+    VERIFY( check_to_chars<unsigned int>(1, \"1\", base) );\n+    VERIFY( check_to_chars<signed long>(1, \"1\", base) );\n+    VERIFY( check_to_chars<unsigned long>(1, \"1\", base) );\n+    VERIFY( check_to_chars<signed long long>(1, \"1\", base) );\n+    VERIFY( check_to_chars<unsigned long long>(1, \"1\", base) );\n+\n+    if constexpr (std::is_signed_v<char>)\n+      VERIFY( check_to_chars<char>(-1, \"-1\", base) );\n+    VERIFY( check_to_chars<signed char>(-1, \"-1\", base) );\n+    VERIFY( check_to_chars<signed short>(-1, \"-1\", base) );\n+    VERIFY( check_to_chars<signed int>(-1, \"-1\", base) );\n+    VERIFY( check_to_chars<signed long>(-1, \"-1\", base) );\n+    VERIFY( check_to_chars<signed long long>(-1, \"-1\", base) );\n+\n+    if (base > 2)\n+    {\n+      VERIFY( check_to_chars<char>(2, \"2\", base) );\n+      VERIFY( check_to_chars<signed char>(2, \"2\", base) );\n+      VERIFY( check_to_chars<unsigned char>(2, \"2\", base) );\n+      VERIFY( check_to_chars<signed short>(2, \"2\", base) );\n+      VERIFY( check_to_chars<unsigned short>(2, \"2\", base) );\n+      VERIFY( check_to_chars<signed int>(2, \"2\", base) );\n+      VERIFY( check_to_chars<unsigned int>(2, \"2\", base) );\n+      VERIFY( check_to_chars<signed long>(2, \"2\", base) );\n+      VERIFY( check_to_chars<unsigned long>(2, \"2\", base) );\n+      VERIFY( check_to_chars<signed long long>(2, \"2\", base) );\n+      VERIFY( check_to_chars<unsigned long long>(2, \"2\", base) );\n+\n+      if constexpr (std::is_signed_v<char>)\n+\tVERIFY( check_to_chars<char>(-2, \"-2\", base) );\n+      VERIFY( check_to_chars<signed char>(-2, \"-2\", base) );\n+      VERIFY( check_to_chars<signed short>(-2, \"-2\", base) );\n+      VERIFY( check_to_chars<signed int>(-2, \"-2\", base) );\n+      VERIFY( check_to_chars<signed long>(-2, \"-2\", base) );\n+      VERIFY( check_to_chars<signed long long>(-2, \"-2\", base) );\n+    }\n+\n+    VERIFY( check_to_chars(2017u, str2017[base]+1, base) );\n+    VERIFY( check_to_chars(2017, str2017[base]+1, base) );\n+    VERIFY( check_to_chars(-2017, str2017[base], base) );\n+    VERIFY( check_to_chars(12345u, str12345[base]+1, base) );\n+    VERIFY( check_to_chars(12345, str12345[base]+1, base) );\n+    VERIFY( check_to_chars(-12345, str12345[base], base) );\n+    VERIFY( check_to_chars(23456u, str23456[base]+1, base) );\n+    VERIFY( check_to_chars(23456, str23456[base]+1, base) );\n+    VERIFY( check_to_chars(-23456, str23456[base], base) );\n+    VERIFY( check_to_chars(INT_MAX + 1ull, strINT_MIN[base]+1, base) );\n+    VERIFY( check_to_chars(INT_MAX + 1ll, strINT_MIN[base]+1, base) );\n+    VERIFY( check_to_chars(INT_MIN, strINT_MIN[base], base) );\n+  }\n+\n+  VERIFY( check_to_chars(1155, \"xx\", 34) );\n+  VERIFY( check_to_chars(1224, \"yy\", 35) );\n+  VERIFY( check_to_chars(1295, \"zz\", 36) );\n+}\n+\n+#include <sstream>\n+#include <ios>\n+\n+// base 8\n+void\n+test04()\n+{\n+  auto to_string = [](auto val) {\n+    std::ostringstream ss;\n+    ss << std::oct;\n+    if (val < 0)\n+      ss << '-' << (~val + 1ull);\n+    else if (sizeof(val) == 1)\n+      ss << (int)val;\n+    else\n+      ss << val;\n+    return ss.str();\n+  };\n+\n+  VERIFY( check_to_chars<char>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<signed char>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<unsigned char>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<signed short>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<unsigned short>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<signed int>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<unsigned int>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<signed long>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<unsigned long>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<signed long long>(123, to_string(123), 8) );\n+  VERIFY( check_to_chars<unsigned long long>(123, to_string(123), 8) );\n+\n+  if constexpr (std::is_signed_v<char>)\n+    VERIFY( check_to_chars<char>(-79, to_string(-79), 8) );\n+  VERIFY( check_to_chars<signed char>(-79, to_string(-79), 8) );\n+  VERIFY( check_to_chars<signed short>(-79, to_string(-79), 8) );\n+  VERIFY( check_to_chars<signed int>(-79, to_string(-79), 8) );\n+  VERIFY( check_to_chars<signed long>(-79, to_string(-79), 8) );\n+  VERIFY( check_to_chars<signed long long>(-79, to_string(-79), 8) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX, to_string(CHAR_MAX), 8) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX, to_string(SCHAR_MAX), 8) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX, to_string(UCHAR_MAX), 8) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX, to_string(SHRT_MAX), 8) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX, to_string(USHRT_MAX), 8) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX, to_string(INT_MAX), 8) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX, to_string(UINT_MAX), 8) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX, to_string(LONG_MAX), 8) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX, to_string(ULONG_MAX), 8) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX, to_string(LLONG_MAX), 8) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX, to_string(ULLONG_MAX), 8) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MIN, to_string(CHAR_MIN), 8) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MIN, to_string(SCHAR_MIN), 8) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MIN, to_string(SHRT_MIN), 8) );\n+  VERIFY( check_to_chars<signed int>(INT_MIN, to_string(INT_MIN), 8) );\n+  VERIFY( check_to_chars<signed long>(LONG_MIN, to_string(LONG_MIN), 8) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MIN, to_string(LLONG_MIN), 8) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX/2, to_string(CHAR_MAX/2), 8) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX/2, to_string(SCHAR_MAX/2), 8) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX/2, to_string(UCHAR_MAX/2), 8) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX/2, to_string(SHRT_MAX/2), 8) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX/2, to_string(USHRT_MAX/2), 8) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX/2, to_string(INT_MAX/2), 8) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX/2, to_string(UINT_MAX/2), 8) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX/2, to_string(LONG_MAX/2), 8) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX/2, to_string(ULONG_MAX/2), 8) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX/2, to_string(LLONG_MAX/2), 8) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX/2, to_string(ULLONG_MAX/2), 8) );\n+}\n+\n+// base 16\n+void\n+test05()\n+{\n+  auto to_string = [](auto val) {\n+    std::ostringstream ss;\n+    ss << std::hex;\n+    if (val < 0)\n+      ss << '-' << (~val + 1ull);\n+    else if (sizeof(val) == 1)\n+      ss << (int)val;\n+    else\n+      ss << val;\n+    return ss.str();\n+  };\n+\n+  VERIFY( check_to_chars<char>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<signed char>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<unsigned char>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<signed short>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<unsigned short>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<signed int>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<unsigned int>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<signed long>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<unsigned long>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<signed long long>(123, to_string(123), 16) );\n+  VERIFY( check_to_chars<unsigned long long>(123, to_string(123), 16) );\n+\n+  if constexpr (std::is_signed_v<char>)\n+    VERIFY( check_to_chars<char>(-79, to_string(-79), 16) );\n+  VERIFY( check_to_chars<signed char>(-79, to_string(-79), 16) );\n+  VERIFY( check_to_chars<signed short>(-79, to_string(-79), 16) );\n+  VERIFY( check_to_chars<signed int>(-79, to_string(-79), 16) );\n+  VERIFY( check_to_chars<signed long>(-79, to_string(-79), 16) );\n+  VERIFY( check_to_chars<signed long long>(-79, to_string(-79), 16) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX, to_string(CHAR_MAX), 16) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX, to_string(SCHAR_MAX), 16) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX, to_string(UCHAR_MAX), 16) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX, to_string(SHRT_MAX), 16) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX, to_string(USHRT_MAX), 16) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX, to_string(INT_MAX), 16) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX, to_string(UINT_MAX), 16) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX, to_string(LONG_MAX), 16) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX, to_string(ULONG_MAX), 16) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX, to_string(LLONG_MAX), 16) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX, to_string(ULLONG_MAX), 16) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MIN, to_string(CHAR_MIN), 16) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MIN, to_string(SCHAR_MIN), 16) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MIN, to_string(SHRT_MIN), 16) );\n+  VERIFY( check_to_chars<signed int>(INT_MIN, to_string(INT_MIN), 16) );\n+  VERIFY( check_to_chars<signed long>(LONG_MIN, to_string(LONG_MIN), 16) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MIN, to_string(LLONG_MIN), 16) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX/2, to_string(CHAR_MAX/2), 16) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX/2, to_string(SCHAR_MAX/2), 16) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX/2, to_string(UCHAR_MAX/2), 16) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX/2, to_string(SHRT_MAX/2), 16) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX/2, to_string(USHRT_MAX/2), 16) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX/2, to_string(INT_MAX/2), 16) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX/2, to_string(UINT_MAX/2), 16) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX/2, to_string(LONG_MAX/2), 16) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX/2, to_string(ULONG_MAX/2), 16) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX/2, to_string(LLONG_MAX/2), 16) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX/2, to_string(ULLONG_MAX/2), 16) );\n+}\n+\n+#include <bitset>\n+\n+// base 2\n+void\n+test06()\n+{\n+  auto to_string = [](auto val) {\n+    std::string s, sign;\n+    if (val < 0)\n+    {\n+      auto absval = ~val + 1ull;\n+      s = std::bitset<sizeof(absval) * CHAR_BIT>(absval).to_string();\n+      sign = '-';\n+    }\n+    else\n+      s = std::bitset<sizeof(val) * CHAR_BIT>(val).to_string();\n+    auto pos = s.find_first_not_of(\"0\");\n+    if (pos == std::string::npos)\n+      s.resize(1);\n+    else\n+      s.erase(0, pos);\n+    return sign + s;\n+  };\n+\n+  VERIFY( check_to_chars<char>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<signed char>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<unsigned char>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<signed short>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<unsigned short>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<signed int>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<unsigned int>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<signed long>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<unsigned long>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<signed long long>(123, to_string(123), 2) );\n+  VERIFY( check_to_chars<unsigned long long>(123, to_string(123), 2) );\n+\n+  if constexpr (std::is_signed_v<char>)\n+    VERIFY( check_to_chars<char>(-79, to_string(-79), 2) );\n+  VERIFY( check_to_chars<signed char>(-79, to_string(-79), 2) );\n+  VERIFY( check_to_chars<signed short>(-79, to_string(-79), 2) );\n+  VERIFY( check_to_chars<signed int>(-79, to_string(-79), 2) );\n+  VERIFY( check_to_chars<signed long>(-79, to_string(-79), 2) );\n+  VERIFY( check_to_chars<signed long long>(-79, to_string(-79), 2) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX, to_string(CHAR_MAX), 2) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX, to_string(SCHAR_MAX), 2) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX, to_string(UCHAR_MAX), 2) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX, to_string(SHRT_MAX), 2) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX, to_string(USHRT_MAX), 2) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX, to_string(INT_MAX), 2) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX, to_string(UINT_MAX), 2) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX, to_string(LONG_MAX), 2) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX, to_string(ULONG_MAX), 2) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX, to_string(LLONG_MAX), 2) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX, to_string(ULLONG_MAX), 2) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MIN, to_string(CHAR_MIN), 2) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MIN, to_string(SCHAR_MIN), 2) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MIN, to_string(SHRT_MIN), 2) );\n+  VERIFY( check_to_chars<signed int>(INT_MIN, to_string(INT_MIN), 2) );\n+  VERIFY( check_to_chars<signed long>(LONG_MIN, to_string(LONG_MIN), 2) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MIN, to_string(LLONG_MIN), 2) );\n+\n+  VERIFY( check_to_chars<char>(CHAR_MAX/2, to_string(CHAR_MAX/2), 2) );\n+  VERIFY( check_to_chars<signed char>(SCHAR_MAX/2, to_string(SCHAR_MAX/2), 2) );\n+  VERIFY( check_to_chars<unsigned char>(UCHAR_MAX/2, to_string(UCHAR_MAX/2), 2) );\n+  VERIFY( check_to_chars<signed short>(SHRT_MAX/2, to_string(SHRT_MAX/2), 2) );\n+  VERIFY( check_to_chars<unsigned short>(USHRT_MAX/2, to_string(USHRT_MAX/2), 2) );\n+  VERIFY( check_to_chars<signed int>(INT_MAX/2, to_string(INT_MAX/2), 2) );\n+  VERIFY( check_to_chars<unsigned int>(UINT_MAX/2, to_string(UINT_MAX/2), 2) );\n+  VERIFY( check_to_chars<signed long>(LONG_MAX/2, to_string(LONG_MAX/2), 2) );\n+  VERIFY( check_to_chars<unsigned long>(ULONG_MAX/2, to_string(ULONG_MAX/2), 2) );\n+  VERIFY( check_to_chars<signed long long>(LLONG_MAX/2, to_string(LLONG_MAX/2), 2) );\n+  VERIFY( check_to_chars<unsigned long long>(ULLONG_MAX/2, to_string(ULLONG_MAX/2), 2) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+}"}, {"sha": "8302b250cd051b5c5152fb1ec51dcb3bca560a39", "filename": "libstdc++-v3/testsuite/20_util/to_chars/1_neg.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F1_neg.cc?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,35 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <charconv>\n+\n+void\n+test01(char* first, char* last)\n+{\n+#if _GLIBCXX_USE_WCHAR_T\n+  std::to_chars(first, last, L'\\x1'); // { dg-error \"no matching\" }\n+  std::to_chars(first, last, L'\\x1', 10); // { dg-error \"no matching\" }\n+#endif\n+\n+  std::to_chars(first, last, u'\\x1'); // { dg-error \"no matching\" }\n+  std::to_chars(first, last, u'\\x1', 10); // { dg-error \"no matching\" }\n+  std::to_chars(first, last, U'\\x1'); // { dg-error \"no matching\" }\n+  std::to_chars(first, last, U'\\x1', 10); // { dg-error \"no matching\" }\n+}"}, {"sha": "b28320cc7b8c7151e6c1b64d6c4a8232021cd849", "filename": "libstdc++-v3/testsuite/20_util/to_chars/2.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F2.cc?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,78 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <charconv>\n+#include <testsuite_hooks.h>\n+\n+// Test std::to_chars error handling.\n+\n+void\n+test01()\n+{\n+  char buf[9] = \"********\";\n+  std::to_chars_result r;\n+\n+  r = std::to_chars(buf, buf, 1);\n+  VERIFY( r.ec == std::errc::value_too_large );\n+  VERIFY( r.ptr == buf );\n+  VERIFY( *r.ptr == '*' );\n+\n+  r = std::to_chars(buf, buf + 3, 0b1000, 2);\n+  VERIFY( r.ec == std::errc::value_too_large );\n+  VERIFY( r.ptr == buf + 3 );\n+  VERIFY( *r.ptr == '*' );\n+  r = std::to_chars(buf, buf + 4, 0b1000, 2);\n+  VERIFY( r.ec == std::errc{} );\n+  VERIFY( r.ptr == buf + 4 );\n+  VERIFY( *r.ptr == '*' );\n+\n+  r = std::to_chars(buf, buf + 4, 010000, 8);\n+  VERIFY( r.ec == std::errc::value_too_large );\n+  VERIFY( r.ptr == buf + 4 );\n+  VERIFY( *r.ptr == '*' );\n+  r = std::to_chars(buf, buf + 5, 010000, 8);\n+  VERIFY( r.ec == std::errc{} );\n+  VERIFY( r.ptr == buf + 5 );\n+  VERIFY( *r.ptr == '*' );\n+\n+  r = std::to_chars(buf, buf + 5, 100000, 10);\n+  VERIFY( r.ec == std::errc::value_too_large );\n+  VERIFY( r.ptr == buf + 5 );\n+  VERIFY( *r.ptr == '*' );\n+  r = std::to_chars(buf, buf + 6, 100000, 10);\n+  VERIFY( r.ec == std::errc{} );\n+  VERIFY( r.ptr == buf + 6 );\n+  VERIFY( *r.ptr == '*' );\n+\n+  r = std::to_chars(buf, buf + 6, 0x1000000, 16);\n+  VERIFY( r.ec == std::errc::value_too_large );\n+  VERIFY( r.ptr == buf + 6 );\n+  VERIFY( *r.ptr == '*' );\n+  r = std::to_chars(buf, buf + 7, 0x1000000, 16);\n+  VERIFY( r.ec == std::errc{} );\n+  VERIFY( r.ptr == buf + 7 );\n+  VERIFY( *r.ptr == '*' );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "d50588bd90288bcc6466f8997f7423e1ceba63d2", "filename": "libstdc++-v3/testsuite/20_util/to_chars/requirements.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804b7cc438701d94db8f958c2211c59f0357b757/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Frequirements.cc?ref=804b7cc438701d94db8f958c2211c59f0357b757", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <charconv>\n+\n+namespace std\n+{\n+  struct to_chars_result;\n+\n+  char* to_chars_result::*pm2 = &to_chars_result::ptr;\n+  errc to_chars_result::*pm1 = &to_chars_result::ec;\n+\n+  to_chars_result (*f1)(char*, char*, char, int) = &to_chars;\n+  to_chars_result (*f2)(char*, char*, signed char, int) = &to_chars;\n+  to_chars_result (*f3)(char*, char*, unsigned char, int) = &to_chars;\n+  to_chars_result (*f4)(char*, char*, signed short, int) = &to_chars;\n+  to_chars_result (*f5)(char*, char*, unsigned short, int) = &to_chars;\n+  to_chars_result (*f6)(char*, char*, signed int, int) = &to_chars;\n+  to_chars_result (*f7)(char*, char*, unsigned int, int) = &to_chars;\n+  to_chars_result (*f8)(char*, char*, signed long, int) = &to_chars;\n+  to_chars_result (*f9)(char*, char*, unsigned long, int) = &to_chars;\n+  to_chars_result (*f10)(char*, char*, signed long long, int) = &to_chars;\n+  to_chars_result (*f11)(char*, char*, unsigned long long, int) = &to_chars;\n+}\n+\n+void bind()\n+{\n+  char buf[1];\n+  auto [p, e] = std::to_chars(buf, buf + 1, 1, 10);\n+  char** pa = &p;\n+  std::errc* ea = &e;\n+}"}]}