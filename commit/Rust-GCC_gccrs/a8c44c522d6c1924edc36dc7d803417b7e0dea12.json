{"sha": "a8c44c522d6c1924edc36dc7d803417b7e0dea12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThjNDRjNTIyZDZjMTkyNGVkYzM2ZGM3ZDgwMzQxN2I3ZTBkZWExMg==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-07-19T22:34:31Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-07-19T22:34:31Z"}, "message": "target.def (class_max_nregs): New hook.\n\n\t* target.def (class_max_nregs): New hook.\n\t* doc/tm.texi.in (TARGET_CLASS_MAX_NREGS): Document.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.c (default_class_max_nregs): New function.\n\t* targhooks.h (default_class_max_nregs): Declare.\n\t* ira.h (target_ira): Change type x_ira_reg_class_max_nregs and\n\tx_ira_reg_class_min_nregs arrays to unsigned char.\n\t* ira.c (setup_reg_class_nregs): Use TARGET_CLASS_MAX_NREGS target\n\thook instead of CLASS_MAX_NREGS macro.\n\t* reginfo.c (restore_register_info): Ditto.\n\t* ira-conflicts.c (process_regs_for_copy): Use\n\tira_reg_class_max_nregs array instead of CLASS_MAX_NREGS macro.\n\tChange type rclass and aclass vars to reg_class_t.\n\t* ira-costs.c (record_reg_classes): Use ira_reg_class_max_nregs\n\tarray instead of CLASS_MAX_NREGS macro. Change type rclass var to\n\treg_class_t.\n\t* reload.c (combine_reloads, find_reloads, find_reloads_address_1):\n\tUse ira_reg_class_max_nregs array instead of CLASS_MAX_NREGS macro.\n\n\t* config/i386/i386.h (CLASS_MAX_NREGS): Remove.\n\t* config/i386/i386.c (ix86_class_max_nregs): New function.\n\t(ix86_register_move_cost): Use TARGET_CLASS_MAX_NREGS target hook\n\tinstead of CLASS_MAX_NREGS macro.\n\t(TARGET_CLASS_MAX_NREGS): Define.\n\t* config/avr/avr.h (CLASS_MAX_NREGS): Remove.\n\t* config/avr/avr-protos.h (class_max_nregs): Remove declaration.\n\t* config/avr/avr.c (class_max_nregs): Remove function.\n\t* config/alpha/alpha.h (CLASS_MAX_NREGS): Remove.\n\t* config/spu/spu.h (CLASS_MAX_NREGS): Remove.\n\t* config/mep/mep.h (CLASS_MAX_NREGS): Remove.\n\t* config/m32r/m32r.h (CLASS_MAX_NREGS): Remove.\n\t* config/microblaze/microblaze.h (CLASS_MAX_NREGS): Remove.\n\t* config/xtensa/xtensa.h (CLASS_MAX_NREGS): Remove.\n\t* config/stormy16/stormy16.h (CLASS_MAX_NREGS): Remove.\n\t* config/lm32/lm32.h (CLASS_MAX_NREGS): Remove.\n\t* config/moxie/moxie.h (CLASS_MAX_NREGS): Remove.\n\t* config/iq2000/iq2000.h (CLASS_MAX_NREGS): Remove.\n\t* config/mn10300/mn10300.h (CLASS_MAX_NREGS): Remove.\n\t* config/score/score.h (CLASS_MAX_NREGS): Remove.\n\t* config/vax/vax.h (CLASS_MAX_NREGS): Remove.\n\t* config/h8300/h8300.h (CLASS_MAX_NREGS): Remove.\n\t* config/v850/v850.h (CLASS_MAX_NREGS): Remove.\n\nFrom-SVN: r176490", "tree": {"sha": "be0d4ac507c0199eef723492fa6d2ae947669e5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be0d4ac507c0199eef723492fa6d2ae947669e5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8c44c522d6c1924edc36dc7d803417b7e0dea12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c44c522d6c1924edc36dc7d803417b7e0dea12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8c44c522d6c1924edc36dc7d803417b7e0dea12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c44c522d6c1924edc36dc7d803417b7e0dea12/comments", "author": null, "committer": null, "parents": [{"sha": "fd811f03425ed77208a00c3fccefb2e960e052a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd811f03425ed77208a00c3fccefb2e960e052a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd811f03425ed77208a00c3fccefb2e960e052a9"}], "stats": {"total": 271, "additions": 147, "deletions": 124}, "files": [{"sha": "26eb56f7f9653b24040b37da35a81c077faf5960", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -1,3 +1,48 @@\n+2011-07-20  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* target.def (class_max_nregs): New hook.\n+\t* doc/tm.texi.in (TARGET_CLASS_MAX_NREGS): Document.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.c (default_class_max_nregs): New function.\n+\t* targhooks.h (default_class_max_nregs): Declare.\n+\t* ira.h (target_ira): Change type x_ira_reg_class_max_nregs and\n+\tx_ira_reg_class_min_nregs arrays to unsigned char.\n+\t* ira.c (setup_reg_class_nregs): Use TARGET_CLASS_MAX_NREGS target\n+\thook instead of CLASS_MAX_NREGS macro.\n+\t* reginfo.c (restore_register_info): Ditto.\n+\t* ira-conflicts.c (process_regs_for_copy): Use\n+\tira_reg_class_max_nregs array instead of CLASS_MAX_NREGS macro.\n+\tChange type rclass and aclass vars to reg_class_t.\n+\t* ira-costs.c (record_reg_classes): Use ira_reg_class_max_nregs\n+\tarray instead of CLASS_MAX_NREGS macro. Change type rclass var to\n+\treg_class_t.\n+\t* reload.c (combine_reloads, find_reloads, find_reloads_address_1):\n+\tUse ira_reg_class_max_nregs array instead of CLASS_MAX_NREGS macro.\n+\n+\t* config/i386/i386.h (CLASS_MAX_NREGS): Remove.\n+\t* config/i386/i386.c (ix86_class_max_nregs): New function.\n+\t(ix86_register_move_cost): Use TARGET_CLASS_MAX_NREGS target hook\n+\tinstead of CLASS_MAX_NREGS macro.\n+\t(TARGET_CLASS_MAX_NREGS): Define.\n+\t* config/avr/avr.h (CLASS_MAX_NREGS): Remove.\n+\t* config/avr/avr-protos.h (class_max_nregs): Remove declaration.\n+\t* config/avr/avr.c (class_max_nregs): Remove function.\n+\t* config/alpha/alpha.h (CLASS_MAX_NREGS): Remove.\n+\t* config/spu/spu.h (CLASS_MAX_NREGS): Remove.\n+\t* config/mep/mep.h (CLASS_MAX_NREGS): Remove.\n+\t* config/m32r/m32r.h (CLASS_MAX_NREGS): Remove.\n+\t* config/microblaze/microblaze.h (CLASS_MAX_NREGS): Remove.\n+\t* config/xtensa/xtensa.h (CLASS_MAX_NREGS): Remove.\n+\t* config/stormy16/stormy16.h (CLASS_MAX_NREGS): Remove.\n+\t* config/lm32/lm32.h (CLASS_MAX_NREGS): Remove.\n+\t* config/moxie/moxie.h (CLASS_MAX_NREGS): Remove.\n+\t* config/iq2000/iq2000.h (CLASS_MAX_NREGS): Remove.\n+\t* config/mn10300/mn10300.h (CLASS_MAX_NREGS): Remove.\n+\t* config/score/score.h (CLASS_MAX_NREGS): Remove.\n+\t* config/vax/vax.h (CLASS_MAX_NREGS): Remove.\n+\t* config/h8300/h8300.h (CLASS_MAX_NREGS): Remove.\n+\t* config/v850/v850.h (CLASS_MAX_NREGS): Remove.\n+\n 2011-07-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* cif-code.def (OVERWRITABLE): Fix typo and move around."}, {"sha": "07ffa9fe8b1e7c3f48128508b8eb0137ea91f760", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -549,12 +549,6 @@ enum reg_class {\n    : GET_MODE_SIZE (MODE) >= 4 ? (MODE)\t\t\t\\\n    : mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (MODE), 0))\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\\\n- ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Return the class of registers that cannot change mode from FROM to TO.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\"}, {"sha": "9b95caa0111d9377dc85d49d92166e7f8022ec61", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -110,10 +110,6 @@ extern void out_shift_with_cnt (const char *templ, rtx insn,\n extern rtx avr_incoming_return_addr_rtx (void);\n #endif /* RTX_CODE */\n \n-#ifdef HAVE_MACHINE_MODES\n-extern int class_max_nregs (enum reg_class rclass, enum machine_mode mode);\n-#endif /* HAVE_MACHINE_MODES */\n-\n #ifdef REAL_VALUE_TYPE\n extern void asm_output_float (FILE *file, REAL_VALUE_TYPE n);\n #endif"}, {"sha": "ebfec0da02459da86eeef674df7669c91567d8d0", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -1491,15 +1491,6 @@ notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx insn)\n     }\n }\n \n-/* Return maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.  */\n-\n-int\n-class_max_nregs (enum reg_class rclass ATTRIBUTE_UNUSED,enum machine_mode mode)\n-{\n-  return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n-}\n-\n /* Choose mode for jump insn:\n    1 - relative jump in range -63 <= x <= 62 ;\n    2 - relative jump in range -2046 <= x <= 2045 ;"}, {"sha": "ddd30d6ee3a57735e7ab78d8ad4310ece6de5de0", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -312,8 +312,6 @@ enum reg_class {\n \n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n-#define CLASS_MAX_NREGS(CLASS, MODE)   class_max_nregs (CLASS, MODE)\n-\n #define STACK_PUSH_CODE POST_DEC\n \n #define STACK_GROWS_DOWNWARD"}, {"sha": "82e55f6628b68be666607bd9cc7419471a483991", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -357,14 +357,6 @@ enum reg_class {\n #define INDEX_REG_CLASS (TARGET_H8300SX ? GENERAL_REGS : NO_REGS)\n #define BASE_REG_CLASS  GENERAL_REGS\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-\n-/* On the H8, this is the size of MODE in words.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Stack layout; function entry, exit and calling.  */\n \n /* Define this if pushing a word on the stack"}, {"sha": "814250fa24e8ccd7925a90e9906535f7289651c0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -28263,6 +28263,32 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n   return inline_secondary_memory_needed (class1, class2, mode, strict);\n }\n \n+/* Implement the TARGET_CLASS_MAX_NREGS hook.\n+\n+   On the 80386, this is the size of MODE in words,\n+   except in the FP regs, where a single reg is always enough.  */\n+\n+static unsigned char\n+ix86_class_max_nregs (reg_class_t rclass, enum machine_mode mode)\n+{\n+  if (MAYBE_INTEGER_CLASS_P (rclass))\n+    {\n+      if (mode == XFmode)\n+\treturn (TARGET_64BIT ? 2 : 3);\n+      else if (mode == XCmode)\n+\treturn (TARGET_64BIT ? 4 : 6);\n+      else\n+\treturn ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n+    }\n+  else\n+    {\n+      if (COMPLEX_MODE_P (mode))\n+\treturn 2;\n+      else\n+\treturn 1;\n+    }\n+}\n+\n /* Return true if the registers in CLASS cannot represent the change from\n    modes FROM to TO.  */\n \n@@ -28459,7 +28485,8 @@ ix86_register_move_cost (enum machine_mode mode, reg_class_t class1_i,\n       /* In case of copying from general_purpose_register we may emit multiple\n          stores followed by single load causing memory size mismatch stall.\n          Count this as arbitrarily high cost of 20.  */\n-      if (CLASS_MAX_NREGS (class1, mode) > CLASS_MAX_NREGS (class2, mode))\n+      if (targetm.class_max_nregs (class1, mode)\n+\t  > targetm.class_max_nregs (class2, mode))\n \tcost += 20;\n \n       /* In the case of FP/MMX moves, the registers actually overlap, and we\n@@ -34931,6 +34958,9 @@ ix86_autovectorize_vector_sizes (void)\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD ix86_secondary_reload\n \n+#undef TARGET_CLASS_MAX_NREGS\n+#define TARGET_CLASS_MAX_NREGS ix86_class_max_nregs\n+\n #undef TARGET_PREFERRED_RELOAD_CLASS\n #define TARGET_PREFERRED_RELOAD_CLASS ix86_preferred_reload_class\n #undef TARGET_PREFERRED_OUTPUT_RELOAD_CLASS"}, {"sha": "47c1388c9c087734c189eb6236f51c5a1740816c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -1357,19 +1357,6 @@ enum reg_class\n    ? mode_for_size (32, GET_MODE_CLASS (MODE), 0)\t\t\\\n    : MODE)\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On the 80386, this is the size of MODE in words,\n-   except in the FP regs, where a single reg is always enough.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  (MAYBE_INTEGER_CLASS_P (CLASS)\t\t\t\t\t\\\n-   ? ((MODE) == XFmode\t\t\t\t\t\t\t\\\n-      ? (TARGET_64BIT ? 2 : 3)\t\t\t\t\t\t\\\n-      : (MODE) == XCmode\t\t\t\t\t\t\\\n-      ? (TARGET_64BIT ? 4 : 6)\t\t\t\t\t\t\\\n-      : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\t\\\n-   : (COMPLEX_MODE_P (MODE) ? 2 : 1))\n-\n /* Return a class of registers that cannot change FROM mode to TO mode.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\"}, {"sha": "130acc9b38431a69e13450901a82062accbeedd8", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -228,9 +228,6 @@ enum reg_class\n \t ? (GR_REGS)\t\t\t\t\t\t\\\n \t : (CLASS))))\n \n-#define CLASS_MAX_NREGS(CLASS, MODE)    \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n \f\n /* Basic Stack Layout.  */\n "}, {"sha": "5c516860beddd7eeb2455b9230316bd5b9c0a195", "filename": "gcc/config/lm32/lm32.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Flm32%2Flm32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Flm32%2Flm32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -202,9 +202,6 @@ enum reg_class\n #define REGNO_REG_CLASS(REGNO) \\\n     (G_REG_P(REGNO) ? GENERAL_REGS : NO_REGS)\n \n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n #define INDEX_REG_CLASS NO_REGS\n \n #define BASE_REG_CLASS GENERAL_REGS"}, {"sha": "0072b2f0da3eb6140ecee3b42318ced90766a2fe", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -509,11 +509,6 @@ extern enum reg_class m32r_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n #define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Return true if a value is inside a range.  */\n #define IN_RANGE_P(VALUE, LOW, HIGH)\t\t\t\\\n   (((unsigned HOST_WIDE_INT)((VALUE) - (LOW)))\t\t\\"}, {"sha": "dbb481430343ad1af9ce468ed1b59b2cb1d91837", "filename": "gcc/config/mep/mep.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fmep%2Fmep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fmep%2Fmep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -428,9 +428,6 @@ enum reg_class\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n \tmep_secondary_memory_needed (CLASS1, CLASS2, MODE)\n \n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n #if 0\n #define CONST_OK_FOR_LETTER_P(VALUE, C) mep_const_ok_for_letter_p (VALUE, C)\n "}, {"sha": "92f0f60f1ff05e8c26091263b21c1b335f2b6846", "filename": "gcc/config/microblaze/microblaze.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -388,9 +388,6 @@ extern enum reg_class microblaze_regno_to_class[];\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)\t\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_INT)\n \n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((GET_MODE_SIZE (MODE) + (UNITS_PER_WORD) - 1) / (UNITS_PER_WORD))\n-\n /* Stack layout; function entry, exit and calling.  */\n \n #define STACK_GROWS_DOWNWARD"}, {"sha": "79b20f5a4d8b8358465c61abd61eb3b151b8feb7", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -388,12 +388,6 @@ enum reg_class\n #define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n   (!TARGET_AM33 && (MODE == QImode || MODE == HImode) ? DATA_REGS : CLASS)\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* A class that contains registers which the compiler must always\n    access in a mode that is the same size as the mode in which it\n    loaded the register.  */"}, {"sha": "d2a455b289c79611f902a5e8beb97943bb3a2b82", "filename": "gcc/config/moxie/moxie.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -189,11 +189,6 @@ enum reg_class\n    accessible in mode MODE2 without copying.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) 1\n \n-/* A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* The Overall Framework of an Assembler File */\n \n #undef  ASM_SPEC"}, {"sha": "3c8851a602fe31bd9cfb7bd3b2e4688f875a450d", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -418,11 +418,6 @@ extern enum reg_class score_char_to_class[256];\n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X) \\\n   score_secondary_reload_class (CLASS, MODE, X)\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)    \\\n   (GET_MODE_SIZE (FROM) != GET_MODE_SIZE (TO)        \\\n    ? reg_classes_intersect_p (HI_REG, (CLASS)) : 0)"}, {"sha": "c69cf7efc4e37fd50d59a8cf66cf8fa57bec4cb9", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -225,9 +225,6 @@ enum reg_class {\n #define INT_REG_OK_FOR_BASE_P(X,STRICT) \\\n \t((!(STRICT) || REGNO_OK_FOR_BASE_P (REGNO (X))))\n \n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-\t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* GCC assumes that modes are in the lowpart of a register, which is\n    only true for SPU. */\n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\"}, {"sha": "43833625608fae037f2286a61c4691dfc2d2e2a2", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -227,9 +227,6 @@ enum reg_class\n #define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n   xstormy16_secondary_reload_class (CLASS, MODE, X)\n \n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n \f\n /* Basic Stack Layout.  */\n "}, {"sha": "f5b64deab2bd7c2676dd901d505c040220c85877", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -341,12 +341,6 @@ enum reg_class\n \n #define REGNO_OK_FOR_INDEX_P(regno) 0\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Convenience wrappers around insn_const_int_ok_for_constraint.  */\n \n #define CONST_OK_FOR_I(VALUE) \\"}, {"sha": "0c835637ae11bea9720e1e66c06e8b452df4417b", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -219,11 +219,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define REG_CLASS_NAMES\t\\\n   { \"NO_REGS\", \"ALL_REGS\" }\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n@@ -242,12 +237,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define INDEX_REG_CLASS ALL_REGS\n #define BASE_REG_CLASS ALL_REGS\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On the VAX, this is always the size of MODE in words,\n-   since all registers are the same size.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "b1a24c6d86d6d2c952217a7e00fc055e807fc2cd", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -450,15 +450,6 @@ extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n    the RTL, as either incoming or outgoing arguments.  */\n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_UNITS(mode, size)\t\t\t\t\t\t\\\n-  ((GET_MODE_SIZE (mode) + (size) - 1) / (size))\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  (CLASS_UNITS (MODE, UNITS_PER_WORD))\n-\n-\n /* Stack layout; function entry, exit and calling.  */\n \n #define STACK_GROWS_DOWNWARD"}, {"sha": "097531f7f6ba034310be4ba39768afe265c5ab07", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -2846,6 +2846,23 @@ the only effect of such implementation would be to slow down register\n allocation.\n @end deftypefn\n \n+@deftypefn {Target Hook} {unsigned char} TARGET_CLASS_MAX_NREGS (reg_class_t @var{rclass}, enum machine_mode @var{mode})\n+A target hook returns the maximum number of consecutive registers\n+of class @var{rclass} needed to hold a value of mode @var{mode}.\n+\n+This is closely related to the macro @code{HARD_REGNO_NREGS}.  In fact,\n+the value returned by @code{TERGET_CLASS_MAX_NREGS (@var{rclass},\n+@var{mode})} target hook should be the maximum value of\n+@code{HARD_REGNO_NREGS (@var{regno}, @var{mode})} for all @var{regno}\n+values in the class @var{rclass}.\n+\n+This target hook helps control the handling of multiple-word values\n+in the reload pass.\n+\n+The default version of this target hook returns the size of @var{mode}\n+in words.\n+@end deftypefn\n+\n @defmac CLASS_MAX_NREGS (@var{class}, @var{mode})\n A C expression for the maximum number of consecutive registers\n of class @var{class} needed to hold a value of mode @var{mode}."}, {"sha": "01beeb47920e7d01d693c489041e6f9a82444906", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -2832,6 +2832,23 @@ the only effect of such implementation would be to slow down register\n allocation.\n @end deftypefn\n \n+@hook TARGET_CLASS_MAX_NREGS\n+A target hook returns the maximum number of consecutive registers\n+of class @var{rclass} needed to hold a value of mode @var{mode}.\n+\n+This is closely related to the macro @code{HARD_REGNO_NREGS}.  In fact,\n+the value returned by @code{TERGET_CLASS_MAX_NREGS (@var{rclass},\n+@var{mode})} target hook should be the maximum value of\n+@code{HARD_REGNO_NREGS (@var{regno}, @var{mode})} for all @var{regno}\n+values in the class @var{rclass}.\n+\n+This target hook helps control the handling of multiple-word values\n+in the reload pass.\n+\n+The default version of this target hook returns the size of @var{mode}\n+in words.\n+@end deftypefn\n+\n @defmac CLASS_MAX_NREGS (@var{class}, @var{mode})\n A C expression for the maximum number of consecutive registers\n of class @var{class} needed to hold a value of mode @var{mode}."}, {"sha": "3df65709f6fa2b66038b0508f8902b7443c1a75c", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -393,7 +393,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n   int allocno_preferenced_hard_regno, cost, index, offset1, offset2;\n   bool only_regs_p;\n   ira_allocno_t a;\n-  enum reg_class rclass, aclass;\n+  reg_class_t rclass, aclass;\n   enum machine_mode mode;\n   ira_copy_t cp;\n \n@@ -438,7 +438,7 @@ process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n   mode = ALLOCNO_MODE (a);\n   aclass = ALLOCNO_CLASS (a);\n   if (only_regs_p && insn != NULL_RTX\n-      && reg_class_size[rclass] <= (unsigned) CLASS_MAX_NREGS (rclass, mode))\n+      && reg_class_size[rclass] <= ira_reg_class_max_nregs [rclass][mode])\n     /* It is already taken into account in ira-costs.c.  */\n     return false;\n   index = ira_class_hard_reg_index[aclass][allocno_preferenced_hard_regno];"}, {"sha": "39ef33a541c17b13b1479e732c7201f0ac072966", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -930,15 +930,15 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  enum machine_mode mode = GET_MODE (ops[!i]);\n \t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n \t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n-\t  enum reg_class rclass;\n+\t  reg_class_t rclass;\n \t  int nr;\n \n \t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n \t    {\n \t      rclass = cost_classes[k];\n \t      if (TEST_HARD_REG_BIT (reg_class_contents[rclass], other_regno)\n-\t\t  && (reg_class_size[rclass]\n-\t\t      == (unsigned) CLASS_MAX_NREGS (rclass, mode)))\n+\t\t  && (reg_class_size[(int) rclass]\n+\t\t      == ira_reg_class_max_nregs [(int) rclass][(int) mode]))\n \t\t{\n \t\t  if (reg_class_size[rclass] == 1)\n \t\t    op_costs[i]->cost[k] = -frequency;"}, {"sha": "b54762e8962b025345369ce4b267c4221997072b", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -1403,7 +1403,7 @@ setup_reg_class_nregs (void)\n       for (cl = 0; cl < N_REG_CLASSES; cl++)\n \tira_reg_class_max_nregs[cl][m]\n \t  = ira_reg_class_min_nregs[cl][m]\n-\t  = CLASS_MAX_NREGS ((enum reg_class) cl, (enum machine_mode) m);\n+\t  = targetm.class_max_nregs ((reg_class_t) cl, (enum machine_mode) m);\n       for (cl = 0; cl < N_REG_CLASSES; cl++)\n \tfor (i = 0;\n \t     (cl2 = alloc_reg_class_subclasses[cl][i]) != LIM_REG_CLASSES;"}, {"sha": "60518ecb3138b14f5cb9d9821c302bd48eb701d8", "filename": "gcc/ira.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -68,8 +68,8 @@ struct target_ira {\n   /* Maps: register class x machine mode -> maximal/minimal number of\n      hard registers of given class needed to store value of given\n      mode.  */\n-  int x_ira_reg_class_max_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n-  int x_ira_reg_class_min_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n+  unsigned char x_ira_reg_class_max_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n+  unsigned char x_ira_reg_class_min_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n \n   /* Array analogous to target hook TARGET_MEMORY_MOVE_COST.  */\n   short x_ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];"}, {"sha": "537364192da2d687b317e3a12134039d920e838a", "filename": "gcc/reginfo.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -529,8 +529,7 @@ init_reg_sets_1 (void)\n \t  SET_HARD_REG_BIT (ok_regs, j);\n \n       for (i = 0; i < N_REG_CLASSES; i++)\n-\tif (((unsigned) CLASS_MAX_NREGS ((enum reg_class) i,\n-\t\t\t\t\t (enum machine_mode) m)\n+\tif ((targetm.class_max_nregs ((reg_class_t) i, (enum machine_mode) m)\n \t     <= reg_class_size[i])\n \t    && hard_reg_set_intersect_p (ok_regs, reg_class_contents[i]))\n \t  {"}, {"sha": "c671765ba93850ad0103fc4613d4cefe4a48d1a3", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -1767,9 +1767,9 @@ combine_reloads (void)\n \t&& rld[i].when_needed != RELOAD_FOR_OUTPUT_ADDRESS\n \t&& rld[i].when_needed != RELOAD_FOR_OUTADDR_ADDRESS\n \t&& rld[i].when_needed != RELOAD_OTHER\n-\t&& (CLASS_MAX_NREGS (rld[i].rclass, rld[i].inmode)\n-\t    == CLASS_MAX_NREGS (rld[output_reload].rclass,\n-\t\t\t\trld[output_reload].outmode))\n+\t&& (ira_reg_class_max_nregs [(int)rld[i].rclass][(int) rld[i].inmode]\n+\t    == ira_reg_class_max_nregs [(int) rld[output_reload].rclass]\n+\t\t\t\t       [(int) rld[output_reload].outmode])\n \t&& rld[i].inc == 0\n \t&& rld[i].reg_rtx == 0\n #ifdef SECONDARY_MEMORY_NEEDED\n@@ -4542,7 +4542,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t       > GET_MODE_SIZE (rld[i].inmode)))\n \t  ? rld[i].outmode : rld[i].inmode;\n \n-      rld[i].nregs = CLASS_MAX_NREGS (rld[i].rclass, rld[i].mode);\n+      rld[i].nregs = ira_reg_class_max_nregs [rld[i].rclass][rld[i].mode];\n     }\n \n   /* Special case a simple move with an input reload and a\n@@ -5992,8 +5992,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t  else\n \t    {\n \t      enum reg_class rclass = context_reg_class;\n-\t      if ((unsigned) CLASS_MAX_NREGS (rclass, GET_MODE (SUBREG_REG (x)))\n-\t\t  > reg_class_size[rclass])\n+\t      if (ira_reg_class_max_nregs [rclass][GET_MODE (SUBREG_REG (x))]\n+\t\t  > reg_class_size[(int) rclass])\n \t\t{\n \t\t  x = find_reloads_subreg_address (x, 0, opnum,\n \t\t\t\t\t\t   ADDR_TYPE (type),"}, {"sha": "9ff97e690e991e76ec8010438a089ab1fea48dbb", "filename": "gcc/target.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -2245,6 +2245,14 @@ DEFHOOK\n  bool, (reg_class_t rclass),\n  default_class_likely_spilled_p)\n \n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class RCLASS.  */\n+DEFHOOK\n+(class_max_nregs,\n+ \"\",\n+ unsigned char, (reg_class_t rclass, enum machine_mode mode),\n+ default_class_max_nregs)\n+\n DEFHOOK\n (preferred_rename_class,\n  \"A target hook that places additional preference on the register\\"}, {"sha": "16d0b189f658fce287049071d859843c3f04582d", "filename": "gcc/targhooks.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -1309,6 +1309,19 @@ default_class_likely_spilled_p (reg_class_t rclass)\n   return (reg_class_size[(int) rclass] == 1);\n }\n \n+/* The default implementation of TARGET_CLASS_MAX_NREGS.  */\n+\n+unsigned char\n+default_class_max_nregs (reg_class_t rclass ATTRIBUTE_UNUSED,\n+\t\t\t enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+#ifdef CLASS_MAX_NREGS\n+  return (unsigned char) CLASS_MAX_NREGS ((enum reg_class) rclass, mode);\n+#else\n+  return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n+#endif\n+}\n+\n /* Determine the debugging unwind mechanism for the target.  */\n \n enum unwind_info_type"}, {"sha": "552407b21db2085e1cc613b3ffcd47f81677333f", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8c44c522d6c1924edc36dc7d803417b7e0dea12/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=a8c44c522d6c1924edc36dc7d803417b7e0dea12", "patch": "@@ -163,6 +163,7 @@ extern reg_class_t default_preferred_reload_class (rtx, reg_class_t);\n extern reg_class_t default_preferred_output_reload_class (rtx, reg_class_t);\n extern reg_class_t default_preferred_rename_class (reg_class_t rclass);\n extern bool default_class_likely_spilled_p (reg_class_t);\n+extern unsigned char default_class_max_nregs (reg_class_t, enum machine_mode);\n \n extern enum unwind_info_type default_debug_unwind_info (void);\n "}]}