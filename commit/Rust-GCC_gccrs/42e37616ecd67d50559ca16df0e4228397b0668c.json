{"sha": "42e37616ecd67d50559ca16df0e4228397b0668c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJlMzc2MTZlY2Q2N2Q1MDU1OWNhMTZkZjBlNDIyODM5N2IwNjY4Yw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@davemloft.net", "date": "2013-04-10T19:41:57Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2013-04-10T19:41:57Z"}, "message": "Improve cstore code generation on 64-bit sparc.\n\nOne major suboptimal area of the sparc back end is cstore generation\non 64-bit.\n\nDue to the way arguments and return values of functions must be\npromoted, the ideal mode for cstore's result would be DImode.\n\nBut this hasn't been done because of a fundamental limitation\nof the cstore patterns.  They require a fixed mode be used for\nthe boolean result value.\n\nI've decided to work around this by building a target hook which\nspecifies the type to use for conditional store results, and then I\nuse a special predicate for operans 0 in the cstore expanders so\nthat they still match even when we use DImode.\n\nThe default version of the target hook just does what it does now,\nso no other target should be impacted by this at all.\n\nRegstrapped on 32-bit sparc-linux-gnu and I've run the testsuite\nwith \"-m64\" to validate the 64-bit side.\n\ngcc/\n\n\t* target.def (cstore_mode): New hook.\n\t* target.h: Include insn-codes.h\n\t* targhooks.c: Likewise.\n\t(default_cstore_mode): New function.\n\t* targhooks.h: Declare it.\n\t* doc/tm.texi.in: New hook slot for TARGET_CSTORE_MODE.\n\t* doc/tm.texi: Rebuild.\n\t* expmed.c (emit_cstore): Obtain cstore boolean result mode using\n\ttarget hook, rather than inspecting the insn_data.\n\t* config/sparc/sparc.c (sparc_cstore_mode): New function.\n\t(TARGET_CSTORE_MODE): Redefine.\n\t(emit_scc_insn): When TARGET_ARCH64, emit new 64-bit boolean\n\tresult patterns.\n\t* config/sparc/predicates.md (cstore_result_operand): New special\n\tpredicate.\n\t* config/sparc/sparc.md (cstoresi4, cstoredi4, cstore<F:mode>4):\n\tUse it for operand 0.\n\t(*seqsi_special): Rewrite using 'P' mode iterator on operand 0.\n\t(*snesi_special): Likewise.\n\t(*snesi_zero): Likewise.\n\t(*seqsi_zero): Likewise.\n\t(*sltu_insn): Likewise.\n\t(*sgeu_insn): Likewise.\n\t(*seqdi_special): Make operand 0 and comparison operation be of\n\tDImode.\n\t(*snedi_special): Likewise.\n\t(*snedi_special_vis3): Likewise.\n\t(*neg_snesi_zero): Rename to *neg_snesisi_zero.\n\t(*neg_snesi_sign_extend): Rename to *neg_snesidi_zero.\n\t(*snesi_zero_extend): Delete, covered by 'P' mode iterator.\n\t(*neg_seqsi_zero): Rename to *neg_seqsisi_zero.\n\t(*neg_seqsi_sign_extend): Rename to *neg_seqsidi_zero.\n\t(*seqsi_zero_extend): Delete, covered by 'P' mode iterator.\n\t(*sltu_extend_sp64): Likewise.\n\t(*neg_sltu_insn): Rename to *neg_sltusi_insn.\n\t(*neg_sltu_extend_sp64): Rename to *neg_sltudi_insn.\n\t(*sgeu_extend_sp64): Delete, covered by 'P' mode iterator.\n\t(*neg_sgeu_insn): Rename to *neg_sgeusi_insn.\n\t(*neg_sgeu_extend_sp64): Rename to *neg_sgeudi_insn.\n\ngcc/testsuite/\n\n\t* gcc.target/sparc/setcc-4.c: New test.\n\t* gcc.target/sparc/setcc-5.c: New test.\n\nFrom-SVN: r197679", "tree": {"sha": "03cbdc17b2b7d1af99a46a569ba37bb1f11fc28f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03cbdc17b2b7d1af99a46a569ba37bb1f11fc28f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42e37616ecd67d50559ca16df0e4228397b0668c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42e37616ecd67d50559ca16df0e4228397b0668c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42e37616ecd67d50559ca16df0e4228397b0668c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42e37616ecd67d50559ca16df0e4228397b0668c/comments", "author": {"login": "davem330", "id": 1053866, "node_id": "MDQ6VXNlcjEwNTM4NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1053866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davem330", "html_url": "https://github.com/davem330", "followers_url": "https://api.github.com/users/davem330/followers", "following_url": "https://api.github.com/users/davem330/following{/other_user}", "gists_url": "https://api.github.com/users/davem330/gists{/gist_id}", "starred_url": "https://api.github.com/users/davem330/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davem330/subscriptions", "organizations_url": "https://api.github.com/users/davem330/orgs", "repos_url": "https://api.github.com/users/davem330/repos", "events_url": "https://api.github.com/users/davem330/events{/privacy}", "received_events_url": "https://api.github.com/users/davem330/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "95ca411e0437d9954a40a2134bba237b1f2ef0fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ca411e0437d9954a40a2134bba237b1f2ef0fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ca411e0437d9954a40a2134bba237b1f2ef0fc"}], "stats": {"total": 327, "additions": 230, "deletions": 97}, "files": [{"sha": "1c36f919af51cbf4b0cbade4a4e46584f6f675c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -1,3 +1,45 @@\n+2013-04-10  David S. Miller  <davem@davemloft.net>\n+\n+\t* target.def (cstore_mode): New hook.\n+\t* target.h: Include insn-codes.h\n+\t* targhooks.c: Likewise.\n+\t(default_cstore_mode): New function.\n+\t* targhooks.h: Declare it.\n+\t* doc/tm.texi.in: New hook slot for TARGET_CSTORE_MODE.\n+\t* doc/tm.texi: Rebuild.\n+\t* expmed.c (emit_cstore): Obtain cstore boolean result mode using\n+\ttarget hook, rather than inspecting the insn_data.\n+\t* config/sparc/sparc.c (sparc_cstore_mode): New function.\n+\t(TARGET_CSTORE_MODE): Redefine.\n+\t(emit_scc_insn): When TARGET_ARCH64, emit new 64-bit boolean\n+\tresult patterns.\n+\t* config/sparc/predicates.md (cstore_result_operand): New special\n+\tpredicate.\n+\t* config/sparc/sparc.md (cstoresi4, cstoredi4, cstore<F:mode>4):\n+\tUse it for operand 0.\n+\t(*seqsi_special): Rewrite using 'P' mode iterator on operand 0.\n+\t(*snesi_special): Likewise.\n+\t(*snesi_zero): Likewise.\n+\t(*seqsi_zero): Likewise.\n+\t(*sltu_insn): Likewise.\n+\t(*sgeu_insn): Likewise.\n+\t(*seqdi_special): Make operand 0 and comparison operation be of\n+\tDImode.\n+\t(*snedi_special): Likewise.\n+\t(*snedi_special_vis3): Likewise.\n+\t(*neg_snesi_zero): Rename to *neg_snesisi_zero.\n+\t(*neg_snesi_sign_extend): Rename to *neg_snesidi_zero.\n+\t(*snesi_zero_extend): Delete, covered by 'P' mode iterator.\n+\t(*neg_seqsi_zero): Rename to *neg_seqsisi_zero.\n+\t(*neg_seqsi_sign_extend): Rename to *neg_seqsidi_zero.\n+\t(*seqsi_zero_extend): Delete, covered by 'P' mode iterator.\n+\t(*sltu_extend_sp64): Likewise.\n+\t(*neg_sltu_insn): Rename to *neg_sltusi_insn.\n+\t(*neg_sltu_extend_sp64): Rename to *neg_sltudi_insn.\n+\t(*sgeu_extend_sp64): Delete, covered by 'P' mode iterator.\n+\t(*neg_sgeu_insn): Rename to *neg_sgeusi_insn.\n+\t(*neg_sgeu_extend_sp64): Rename to *neg_sgeudi_insn.\n+\n 2013-04-10  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_print_extension): New function."}, {"sha": "073bce2adec3a29742a3a4b2695dd303677f373d", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -265,6 +265,11 @@\n   (ior (match_test \"register_operand (op, SImode)\")\n        (match_test \"TARGET_ARCH64 && register_operand (op, DImode)\")))\n \n+;; Return true if OP is an integer register of the appropriate mode\n+;; for a cstore result.\n+(define_special_predicate \"cstore_result_operand\"\n+  (match_test \"register_operand (op, TARGET_ARCH64 ? DImode : SImode)\"))\n+\n ;; Return true if OP is a floating point condition code register.\n (define_predicate \"fcc_register_operand\"\n   (match_code \"reg\")"}, {"sha": "4a73c73147521fa432e87ae9c7aadfc425cbb1ba", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -597,6 +597,7 @@ static void sparc_print_operand_address (FILE *, rtx);\n static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t   enum machine_mode,\n \t\t\t\t\t   secondary_reload_info *);\n+static enum machine_mode sparc_cstore_mode (enum insn_code icode);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -802,6 +803,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_ATOMIC_TEST_AND_SET_TRUEVAL\n #define TARGET_ATOMIC_TEST_AND_SET_TRUEVAL 0xff\n \n+#undef TARGET_CSTORE_MODE\n+#define TARGET_CSTORE_MODE sparc_cstore_mode\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n static void\n@@ -2572,7 +2576,11 @@ emit_scc_insn (rtx operands[])\n     {\n       if (GET_MODE (x) == SImode)\n         {\n-          rtx pat = gen_seqsi_special (operands[0], x, y);\n+\t  rtx pat;\n+\t  if (TARGET_ARCH64)\n+\t    pat = gen_seqsidi_special (operands[0], x, y);\n+\t  else\n+\t    pat = gen_seqsisi_special (operands[0], x, y);\n           emit_insn (pat);\n           return true;\n         }\n@@ -2588,7 +2596,11 @@ emit_scc_insn (rtx operands[])\n     {\n       if (GET_MODE (x) == SImode)\n         {\n-          rtx pat = gen_snesi_special (operands[0], x, y);\n+          rtx pat;\n+\t  if (TARGET_ARCH64)\n+\t    pat = gen_snesidi_special (operands[0], x, y);\n+\t  else\n+\t    pat = gen_snesisi_special (operands[0], x, y);\n           emit_insn (pat);\n           return true;\n         }\n@@ -2631,7 +2643,7 @@ emit_scc_insn (rtx operands[])\n       || (!TARGET_VIS3 && code == GEU))\n     {\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t      gen_rtx_fmt_ee (code, SImode,\n+\t\t\t      gen_rtx_fmt_ee (code, GET_MODE (operands[0]),\n \t\t\t\t\t      gen_compare_reg_1 (code, x, y),\n \t\t\t\t\t      const0_rtx)));\n       return true;\n@@ -12104,4 +12116,9 @@ sparc_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n   return true;\n }\n \n+static enum machine_mode sparc_cstore_mode (enum insn_code icode ATTRIBUTE_UNUSED)\n+{\n+  return (TARGET_ARCH64 ? DImode : SImode);\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "292cb2052717e6642e2d6136062e860d086108f8", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 44, "deletions": 93, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -615,11 +615,14 @@\n \f\n ;; Next come the scc insns.\n \n+;; Note that the boolean result (operand 0) takes on DImode\n+;; (not SImode) when TARGET_ARCH64.\n+\n (define_expand \"cstoresi4\"\n   [(use (match_operator 1 \"comparison_operator\"\n          [(match_operand:SI 2 \"compare_operand\" \"\")\n           (match_operand:SI 3 \"arith_operand\" \"\")]))\n-   (clobber (match_operand:SI 0 \"register_operand\"))]\n+   (clobber (match_operand:SI 0 \"cstore_result_operand\"))]\n   \"\"\n {\n   if (GET_CODE (operands[2]) == ZERO_EXTRACT && operands[3] != const0_rtx)\n@@ -631,7 +634,7 @@\n   [(use (match_operator 1 \"comparison_operator\"\n          [(match_operand:DI 2 \"compare_operand\" \"\")\n           (match_operand:DI 3 \"arith_operand\" \"\")]))\n-   (clobber (match_operand:SI 0 \"register_operand\"))]\n+   (clobber (match_operand:SI 0 \"cstore_result_operand\"))]\n   \"TARGET_ARCH64\"\n {\n   if (GET_CODE (operands[2]) == ZERO_EXTRACT && operands[3] != const0_rtx)\n@@ -643,7 +646,7 @@\n   [(use (match_operator 1 \"comparison_operator\"\n          [(match_operand:F 2 \"register_operand\" \"\")\n           (match_operand:F 3 \"register_operand\" \"\")]))\n-   (clobber (match_operand:SI 0 \"register_operand\"))]\n+   (clobber (match_operand:SI 0 \"cstore_result_operand\"))]\n   \"TARGET_FPU\"\n   { if (emit_scc_insn (operands)) DONE; else FAIL; })\n \n@@ -652,12 +655,12 @@\n ;; Seq_special[_xxx] and sne_special[_xxx] clobber the CC reg, because they\n ;; generate addcc/subcc instructions.\n \n-(define_expand \"seqsi_special\"\n+(define_expand \"seqsi<P:mode>_special\"\n   [(set (match_dup 3)\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t(match_operand:SI 2 \"register_operand\" \"\")))\n-   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (eq:SI (match_dup 3) (const_int 0)))\n+   (parallel [(set (match_operand:P 0 \"register_operand\" \"\")\n+\t\t   (eq:P (match_dup 3) (const_int 0)))\n \t      (clobber (reg:CC CC_REG))])]\n   \"\"\n   { operands[3] = gen_reg_rtx (SImode); })\n@@ -666,17 +669,17 @@\n   [(set (match_dup 3)\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(eq:SI (match_dup 3) (const_int 0)))]\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(eq:DI (match_dup 3) (const_int 0)))]\n   \"TARGET_ARCH64\"\n   { operands[3] = gen_reg_rtx (DImode); })\n \n-(define_expand \"snesi_special\"\n+(define_expand \"snesi<P:mode>_special\"\n   [(set (match_dup 3)\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t(match_operand:SI 2 \"register_operand\" \"\")))\n-   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (ne:SI (match_dup 3) (const_int 0)))\n+   (parallel [(set (match_operand:P 0 \"register_operand\" \"\")\n+\t\t   (ne:P (match_dup 3) (const_int 0)))\n \t      (clobber (reg:CC CC_REG))])]\n   \"\"\n   { operands[3] = gen_reg_rtx (SImode); })\n@@ -685,17 +688,17 @@\n   [(set (match_dup 3)\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ne:SI (match_dup 3) (const_int 0)))]\n+   (set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ne:DI (match_dup 3) (const_int 0)))]\n   \"TARGET_ARCH64 && ! TARGET_VIS3\"\n   { operands[3] = gen_reg_rtx (DImode); })\n \n (define_expand \"snedi_special_vis3\"\n   [(set (match_dup 3)\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t(match_operand:DI 2 \"register_operand\" \"\")))\n-   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t   (ne:SI (match_dup 3) (const_int 0)))\n+   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t\t   (ne:DI (match_dup 3) (const_int 0)))\n \t      (clobber (reg:CCX CC_REG))])]\n   \"TARGET_ARCH64 && TARGET_VIS3\"\n   { operands[3] = gen_reg_rtx (DImode); })\n@@ -708,21 +711,21 @@\n ;; them to always use the splits below so the results can be\n ;; scheduled.\n \n-(define_insn_and_split \"*snesi_zero\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+(define_insn_and_split \"*snesi<P:mode>_zero\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(ne:P (match_operand:SI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"#\"\n   \"\"\n   [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n \t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (ltu:SI (reg:CC CC_REG) (const_int 0)))]\n+   (set (match_dup 0) (ltu:P (reg:CC CC_REG) (const_int 0)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*neg_snesi_zero\"\n+(define_insn_and_split \"*neg_snesisi_zero\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (ne:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t       (const_int 0))))\n@@ -736,35 +739,16 @@\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*snesi_zero_extend\"\n+(define_insn_and_split \"*neg_snesidi_zero\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (ne:DI (match_operand:SI 1 \"register_operand\" \"r\")\n-               (const_int 0)))\n+\t(neg:DI (ne:DI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t       (const_int 0))))\n    (clobber (reg:CC CC_REG))]\n   \"TARGET_ARCH64\"\n   \"#\"\n-  \"&& 1\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (minus:SI (const_int 0)\n-                                                     (match_dup 1))\n-                                           (const_int 0)))\n-   (set (match_dup 0) (zero_extend:DI (plus:SI (plus:SI (const_int 0)\n-                                                        (const_int 0))\n-                                               (ltu:SI (reg:CC_NOOV CC_REG)\n-                                                       (const_int 0)))))]\n   \"\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn_and_split \"*neg_snesi_sign_extend\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (neg:DI (ne:DI (match_operand:SI 1 \"register_operand\" \"r\")\n-                      (const_int 0))))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_ARCH64\"\n-  \"#\"\n-  \"&& 1\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (minus:SI (const_int 0)\n-                                                     (match_dup 1))\n-                                           (const_int 0)))\n+  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n+\t\t\t\t\t   (const_int 0)))\n    (set (match_dup 0) (sign_extend:DI (neg:SI (ltu:SI (reg:CC CC_REG)\n                                                       (const_int 0)))))]\n   \"\"\n@@ -843,21 +827,21 @@\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*seqsi_zero\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+(define_insn_and_split \"*seqsi<P:mode>_zero\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(eq:P (match_operand:SI 1 \"register_operand\" \"r\")\n \t       (const_int 0)))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n   \"#\"\n   \"\"\n   [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (neg:SI (match_dup 1))\n \t\t\t\t\t   (const_int 0)))\n-   (set (match_dup 0) (geu:SI (reg:CC CC_REG) (const_int 0)))]\n+   (set (match_dup 0) (geu:P (reg:CC CC_REG) (const_int 0)))]\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*neg_seqsi_zero\"\n+(define_insn_and_split \"*neg_seqsisi_zero\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (eq:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t       (const_int 0))))\n@@ -871,25 +855,7 @@\n   \"\"\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn_and_split \"*seqsi_zero_extend\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-        (eq:DI (match_operand:SI 1 \"register_operand\" \"r\")\n-               (const_int 0)))\n-   (clobber (reg:CC CC_REG))]\n-  \"TARGET_ARCH64\"\n-  \"#\"\n-  \"&& 1\"\n-  [(set (reg:CC_NOOV CC_REG) (compare:CC_NOOV (minus:SI (const_int 0)\n-                                                     (match_dup 1))\n-                                           (const_int 0)))\n-   (set (match_dup 0) (zero_extend:DI (minus:SI (minus:SI (const_int 0)\n-                                                          (const_int -1))\n-                                                (ltu:SI (reg:CC_NOOV CC_REG)\n-                                                        (const_int 0)))))]\n-  \"\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn_and_split \"*neg_seqsi_sign_extend\"\n+(define_insn_and_split \"*neg_seqsidi_zero\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(neg:DI (eq:DI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t       (const_int 0))))\n@@ -1021,9 +987,9 @@\n ;; ??? The addx/subx insns use the 32 bit carry flag so there are no DImode\n ;; versions for v9.\n \n-(define_insn \"*sltu_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ltu:SI (reg:CC CC_REG) (const_int 0)))]\n+(define_insn \"*sltu<P:mode>_insn\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(ltu:P (reg:CC CC_REG) (const_int 0)))]\n   \"\"\n   \"addx\\t%%g0, 0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n@@ -1042,28 +1008,20 @@\n   \"addxc\\t%%g0, %%g0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sltu_extend_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ltu:DI (reg:CC CC_REG) (const_int 0)))]\n-  \"TARGET_ARCH64\"\n-  \"addx\\t%%g0, 0, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n-(define_insn \"*neg_sltu_insn\"\n+(define_insn \"*neg_sltusi_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (ltu:SI (reg:CC CC_REG) (const_int 0))))]\n   \"\"\n   \"subx\\t%%g0, 0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*neg_sltu_extend_sp64\"\n+(define_insn \"*neg_sltudi_insn\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(sign_extend:DI (neg:SI (ltu:SI (reg:CC CC_REG) (const_int 0)))))]\n   \"TARGET_ARCH64\"\n   \"subx\\t%%g0, 0, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-;; ??? Combine should canonicalize these next two to the same pattern.\n (define_insn \"*neg_sltu_minus_x\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(minus:SI (neg:SI (ltu:SI (reg:CC CC_REG) (const_int 0)))\n@@ -1080,28 +1038,21 @@\n   \"subx\\t%%g0, %1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sgeu_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(geu:SI (reg:CC CC_REG) (const_int 0)))]\n+(define_insn \"*sgeu<P:mode>_insn\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(geu:P (reg:CC CC_REG) (const_int 0)))]\n   \"\"\n   \"subx\\t%%g0, -1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*sgeu_extend_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(geu:DI (reg:CC CC_REG) (const_int 0)))]\n-  \"TARGET_ARCH64\"\n-  \"subx\\t%%g0, -1, %0\"\n-  [(set_attr \"type\" \"ialuX\")])\n-\n-(define_insn \"*neg_sgeu_insn\"\n+(define_insn \"*neg_sgeusi_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(neg:SI (geu:SI (reg:CC CC_REG) (const_int 0))))]\n   \"\"\n   \"addx\\t%%g0, -1, %0\"\n   [(set_attr \"type\" \"ialuX\")])\n \n-(define_insn \"*neg_sgeu_extend_sp64\"\n+(define_insn \"*neg_sgeudi_insn\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(sign_extend:DI (neg:SI (geu:SI (reg:CC CC_REG) (const_int 0)))))]\n   \"TARGET_ARCH64\""}, {"sha": "f6c59f9e3a01931f739ce75b12643dca037041a1", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -2905,6 +2905,10 @@ A target hook which returns true if an address with the same structure  can have\n This hook defines a class of registers which could be used for spilling  pseudos of the given mode and class, or @code{NO_REGS} if only memory  should be used.  Not defining this hook is equivalent to returning  @code{NO_REGS} for all inputs.\n @end deftypefn\n \n+@deftypefn {Target Hook} {enum machine_mode} TARGET_CSTORE_MODE (enum insn_code @var{icode})\n+This hook defines the machine mode to use for the boolean result of  conditional store patterns.  The ICODE argument is the instruction code  for the cstore being performed.  Not definiting this hook is the same  as accepting the mode encoded into operand 0 of the cstore expander  patterns.\n+@end deftypefn\n+\n @node Old Constraints\n @section Obsolete Macros for Defining Constraints\n @cindex defining constraints, obsolete method"}, {"sha": "2d4b98af0848f16f7229e1e689229ee5433a8810", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -2873,6 +2873,8 @@ as below:\n \n @hook TARGET_SPILL_CLASS\n \n+@hook TARGET_CSTORE_MODE\n+\n @node Old Constraints\n @section Obsolete Macros for Defining Constraints\n @cindex defining constraints, obsolete method"}, {"sha": "3c3a179701fbc2832d19ce994d3806be909d8823", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -5081,7 +5081,7 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n {\n   struct expand_operand ops[4];\n   rtx op0, last, comparison, subtarget;\n-  enum machine_mode result_mode = insn_data[(int) icode].operand[0].mode;\n+  enum machine_mode result_mode = targetm.cstore_mode (icode);\n \n   last = get_last_insn ();\n   x = prepare_operand (icode, x, 2, mode, compare_mode, unsignedp);"}, {"sha": "db742732e340799edfd1cfdca8b56148c35f3271", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -2457,6 +2457,16 @@ DEFHOOK\n  reg_class_t, (reg_class_t, enum machine_mode),\n  NULL)\n \n+DEFHOOK\n+(cstore_mode,\n+ \"This hook defines the machine mode to use for the boolean result of\\\n+  conditional store patterns.  The ICODE argument is the instruction code\\\n+  for the cstore being performed.  Not definiting this hook is the same\\\n+  as accepting the mode encoded into operand 0 of the cstore expander\\\n+  patterns.\",\n+  enum machine_mode, (enum insn_code icode),\n+  default_cstore_mode)\n+\n /* True if a structure, union or array with MODE containing FIELD should\n    be accessed using BLKmode.  */\n DEFHOOK"}, {"sha": "405e2928b7372d2d0951556a644c0567c7f31a73", "filename": "gcc/target.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -49,6 +49,7 @@\n #define GCC_TARGET_H\n \n #include \"insn-modes.h\"\n+#include \"insn-codes.h\"\n \n #ifdef ENABLE_CHECKING\n "}, {"sha": "80b4aa6bafd9ae1590c119f0ca777e432a6842f2", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"tree-flow.h\"\n #include \"tree-ssa-alias.h\"\n+#include \"insn-codes.h\"\n \n \n bool\n@@ -1537,6 +1538,14 @@ default_pch_valid_p (const void *data_p, size_t len)\n   return NULL;\n }\n \n+/* Default version of cstore_mode.  */\n+\n+enum machine_mode\n+default_cstore_mode (enum insn_code icode)\n+{\n+  return insn_data[(int) icode].operand[0].mode;\n+}\n+\n /* Default version of member_type_forces_blk.  */\n \n bool"}, {"sha": "ce10ebc947b73f5637970399158ffa92c23d8c5f", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -195,4 +195,5 @@ extern const char *default_pch_valid_p (const void *, size_t);\n \n extern void default_asm_output_ident_directive (const char*);\n \n+extern enum machine_mode default_cstore_mode (enum insn_code);\n extern bool default_member_type_forces_blk (const_tree, enum machine_mode);"}, {"sha": "ef84fe1a495c64322daea4fcf68957cc900dd5be", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -1,3 +1,8 @@\n+2013-04-10  David S. Miller  <davem@davemloft.net>\n+\n+\t* gcc.target/sparc/setcc-4.c: New test.\n+\t* gcc.target/sparc/setcc-5.c: New test.\n+\n 2013-04-10  Richard Biener  <rguenther@suse.de>\n \n \t* g++.dg/pr55604.C: Use -fdump-rtl-ira."}, {"sha": "ffa4ee046c821d073e91aa9eba20bef425b44ca5", "filename": "gcc/testsuite/gcc.target/sparc/setcc-4.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-4.c?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O1 -mno-vis3\" } */\n+\n+long neq (long a, long b)\n+{\n+  return a != b;\n+}\n+\n+long eq (long a, long b)\n+{\n+  return a == b;\n+}\n+\n+long lt (unsigned long a, unsigned long b)\n+{\n+  return a < b;\n+}\n+\n+long leq (unsigned long a, unsigned long b)\n+{\n+  return a <= b;\n+}\n+\n+long geq (unsigned long a, unsigned long b)\n+{\n+  return a >= b;\n+}\n+\n+long gt (unsigned long a, unsigned long b)\n+{\n+  return a > b;\n+}\n+\n+/* { dg-final { scan-assembler-times \"xor\\t%\" 2 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"movrne\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movre\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movlu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movleu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movgeu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movgu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-not \"sra\\t%\" } } */\n+/* { dg-final { scan-assembler-not \"and\\t%\" } } */"}, {"sha": "58f1ee39f74f99ebf3236a86cfbeb3d72c57da86", "filename": "gcc/testsuite/gcc.target/sparc/setcc-5.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42e37616ecd67d50559ca16df0e4228397b0668c/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsetcc-5.c?ref=42e37616ecd67d50559ca16df0e4228397b0668c", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O1 -mvis3\" } */\n+\n+long neq (long a, long b)\n+{\n+  return a != b;\n+}\n+\n+long eq (long a, long b)\n+{\n+  return a == b;\n+}\n+\n+long lt (unsigned long a, unsigned long b)\n+{\n+  return a < b;\n+}\n+\n+long leq (unsigned long a, unsigned long b)\n+{\n+  return a <= b;\n+}\n+\n+long geq (unsigned long a, unsigned long b)\n+{\n+  return a >= b;\n+}\n+\n+long gt (unsigned long a, unsigned long b)\n+{\n+  return a > b;\n+}\n+\n+/* { dg-final { scan-assembler-times \"xor\\t%\" 2 } } */\n+/* { dg-final { scan-assembler-times \"cmp\\t%\" 4 } } */\n+/* { dg-final { scan-assembler-times \"addxc\\t%\" 3 } } */\n+/* { dg-final { scan-assembler-times \"movre\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movleu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movgeu\\t%\" 1 } } */\n+/* { dg-final { scan-assembler-not \"sra\\t%\" } } */\n+/* { dg-final { scan-assembler-not \"and\\t%\" } } */"}]}