{"sha": "d428be77b67871c71638355985061dca1ff06acb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQyOGJlNzdiNjc4NzFjNzE2MzgzNTU5ODUwNjFkY2ExZmYwNmFjYg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-05-18T02:29:27Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-05-18T02:29:27Z"}, "message": "re PR libfortran/52539 (I/O: Wrong result for UTF-8/UCS-4 list-directed and namelist read and nml write)\n\n2014-05-17  Jerry DeLisle  <jvdelisle@gcc.gnu>\n\n\tPR libfortran/52539\n\t* io/io.h (gfc_unit): New function pointers *next_char_fn_ptr\n\tand *push_char_fn_ptr.\n\t*io/list_read.c (next_char): Create macro with this name to call\n\tthe new function pointer. Split the original next_char function\n\tinto three new functions. (next_char_default, next_char_internal,\n\tnext_char_utf8): New functions. (push_char): Create macro with\n\tthis name to call new function pointer. Split the original\n\tpush_char into three new functions. (push_char_default,\n\tpush_char_internal, push_char4): New functions. (set_workers):\n\tNew function to initilize the function pointers depending on the\n\ttype of IO to be performed. (list_formatted_read_scalar): Use\n\tset_workers function. (finish_list_read): Likewise.\n\t(namelist_read): Likewise.\n\t(nml_get_obj_data): Use push_char_default.\n\nFrom-SVN: r210574", "tree": {"sha": "0ba97cc9c85f611d67cbc29703a41e51264adaad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ba97cc9c85f611d67cbc29703a41e51264adaad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d428be77b67871c71638355985061dca1ff06acb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d428be77b67871c71638355985061dca1ff06acb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d428be77b67871c71638355985061dca1ff06acb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d428be77b67871c71638355985061dca1ff06acb/comments", "author": null, "committer": null, "parents": [{"sha": "ef61de094e058fbb13793e3bd64037bc8718ee1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef61de094e058fbb13793e3bd64037bc8718ee1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef61de094e058fbb13793e3bd64037bc8718ee1b"}], "stats": {"total": 337, "additions": 195, "deletions": 142}, "files": [{"sha": "94789e8f3a108bbc5d47a63e1ecabc610e7026e8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d428be77b67871c71638355985061dca1ff06acb/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d428be77b67871c71638355985061dca1ff06acb/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d428be77b67871c71638355985061dca1ff06acb", "patch": "@@ -1,3 +1,21 @@\n+2014-05-17  Jerry DeLisle  <jvdelisle@gcc.gnu>\n+\n+\tPR libfortran/52539\n+\t* io/io.h (gfc_unit): New function pointers *next_char_fn_ptr\n+\tand *push_char_fn_ptr.\n+\t*io/list_read.c (next_char): Create macro with this name to call\n+\tthe new function pointer. Split the original next_char function\n+\tinto three new functions. (next_char_default, next_char_internal,\n+\tnext_char_utf8): New functions. (push_char): Create macro with\n+\tthis name to call new function pointer. Split the original\n+\tpush_char into three new functions. (push_char_default,\n+\tpush_char_internal, push_char4): New functions. (set_workers):\n+\tNew function to initilize the function pointers depending on the\n+\ttype of IO to be performed. (list_formatted_read_scalar): Use\n+\tset_workers function. (finish_list_read): Likewise.\n+\t(namelist_read): Likewise.\n+\t(nml_get_obj_data): Use push_char_default.\n+\n 2014-05-16  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR libfortran/61187"}, {"sha": "4e71d4953b1aa98cb9ec8de1a041700a8dc4a5e6", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d428be77b67871c71638355985061dca1ff06acb/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d428be77b67871c71638355985061dca1ff06acb/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=d428be77b67871c71638355985061dca1ff06acb", "patch": "@@ -575,6 +575,10 @@ typedef struct gfc_unit\n   \n   /* Formatting buffer.  */\n   struct fbuf *fbuf;\n+  \n+  /* Function pointer, points to list_read worker functions.  */\n+  int (*next_char_fn_ptr) (st_parameter_dt *);\n+  void (*push_char_fn_ptr) (st_parameter_dt *, int);\n }\n gfc_unit;\n "}, {"sha": "885db4a399a8e49d0901b602499bd83b9fcce074", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 173, "deletions": 142, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d428be77b67871c71638355985061dca1ff06acb/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d428be77b67871c71638355985061dca1ff06acb/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=d428be77b67871c71638355985061dca1ff06acb", "patch": "@@ -67,10 +67,17 @@ typedef unsigned char uchar;\n \n #define MSGLEN 100\n \n-/* Save a character to a string buffer, enlarging it as necessary.  */\n \n+/* Wrappers for calling the current worker functions.  */\n+\n+#define next_char(dtp) ((dtp)->u.p.current_unit->next_char_fn_ptr (dtp))\n+#define push_char(dtp, c) ((dtp)->u.p.current_unit->push_char_fn_ptr (dtp, c))\n+\n+/* Worker function to save a default KIND=1 character to a string\n+   buffer, enlarging it as necessary.  */\n+   \n static void\n-push_char (st_parameter_dt *dtp, char c)\n+push_char_default (st_parameter_dt *dtp, int c)\n {\n   char *new;\n \n@@ -96,14 +103,15 @@ push_char (st_parameter_dt *dtp, char c)\n \n     }\n \n-  dtp->u.p.saved_string[dtp->u.p.saved_used++] = c;\n+  dtp->u.p.saved_string[dtp->u.p.saved_used++] = (char) c;\n }\n \n-/* Save a KIND=4 character to a string buffer, enlarging the buffer\n-   as necessary.  */\n \n+/* Worker function to save a KIND=4 character to a string buffer,\n+   enlarging the buffer as necessary.  */\n+   \n static void\n-push_char4 (st_parameter_dt *dtp, gfc_char4_t c)\n+push_char4 (st_parameter_dt *dtp, int c)\n {\n   gfc_char4_t *new, *p = (gfc_char4_t *) dtp->u.p.saved_string;\n \n@@ -118,12 +126,12 @@ push_char4 (st_parameter_dt *dtp, gfc_char4_t c)\n   if (dtp->u.p.saved_used >= dtp->u.p.saved_length)\n     {\n       dtp->u.p.saved_length = 2 * dtp->u.p.saved_length;\n-      new = realloc (p, dtp->u.p.saved_length);\n+      new = realloc (p, dtp->u.p.saved_length * sizeof (gfc_char4_t));\n       if (new == NULL)\n \tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n       p = new;\n       \n-      memset (new + dtp->u.p.saved_used, 0, \n+      memset4 (new + dtp->u.p.saved_used, 0, \n \t      dtp->u.p.saved_length - dtp->u.p.saved_used);\n     }\n \n@@ -162,13 +170,16 @@ free_line (st_parameter_dt *dtp)\n }\n \n \n+/* Unget saves the last character so when reading the next character,\n+   we need to check to see if there is a character waiting.  Similar,\n+   if the line buffer is being used to read_logical, check it too.  */\n+   \n static int\n-next_char (st_parameter_dt *dtp)\n+check_buffers (st_parameter_dt *dtp)\n {\n-  ssize_t length;\n-  gfc_offset record;\n   int c;\n \n+  c = '\\0';\n   if (dtp->u.p.last_char != EOF - 1)\n     {\n       dtp->u.p.at_eol = 0;\n@@ -194,6 +205,43 @@ next_char (st_parameter_dt *dtp)\n       dtp->u.p.line_buffer_pos = 0;\n       dtp->u.p.line_buffer_enabled = 0;\n     }\n+    \n+done:\n+  dtp->u.p.at_eol = (c == '\\n' || c == EOF);\n+  return c;\n+}\n+\n+\n+/* Worker function for default character encoded file.  */\n+static int\n+next_char_default (st_parameter_dt *dtp)\n+{\n+  int c;\n+\n+  /* Always check the unget and line buffer first.  */\n+  if ((c = check_buffers (dtp)))\n+    return c;\n+\n+  c = fbuf_getc (dtp->u.p.current_unit);\n+  if (c != EOF && is_stream_io (dtp))\n+    dtp->u.p.current_unit->strm_pos++;\n+\n+  dtp->u.p.at_eol = (c == '\\n' || c == EOF);\n+  return c;\n+}\n+\n+\n+/* Worker function for internal and array I/O units.  */\n+static int\n+next_char_internal (st_parameter_dt *dtp)\n+{\n+  ssize_t length;\n+  gfc_offset record;\n+  int c;\n+\n+  /* Always check the unget and line buffer first.  */\n+  if ((c = check_buffers (dtp)))\n+    return c;\n \n   /* Handle the end-of-record and end-of-file conditions for\n      internal array unit.  */\n@@ -229,68 +277,63 @@ next_char (st_parameter_dt *dtp)\n \n   /* Get the next character and handle end-of-record conditions.  */\n \n-  if (is_internal_unit (dtp))\n+  if (dtp->common.unit) /* Check for kind=4 internal unit.  */\n+   length = sread (dtp->u.p.current_unit->s, &c, sizeof (gfc_char4_t));\n+  else\n+   {\n+     char cc;\n+     length = sread (dtp->u.p.current_unit->s, &cc, 1);\n+     c = cc;\n+   }\n+\n+  if (unlikely (length < 0))\n     {\n-      /* Check for kind=4 internal unit.  */\n-      if (dtp->common.unit)\n-       length = sread (dtp->u.p.current_unit->s, &c, sizeof (gfc_char4_t));\n-      else\n-       {\n-         char cc;\n-         length = sread (dtp->u.p.current_unit->s, &cc, 1);\n-         c = cc;\n-       }\n+      generate_error (&dtp->common, LIBERROR_OS, NULL);\n+      return '\\0';\n+    }\n \n-      if (unlikely (length < 0))\n+  if (is_array_io (dtp))\n+    {\n+      /* Check whether we hit EOF.  */ \n+      if (unlikely (length == 0))\n \t{\n-\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t  return '\\0';\n-\t}\n-\n-      if (is_array_io (dtp))\n-\t{\n-\t  /* Check whether we hit EOF.  */ \n-\t  if (unlikely (length == 0))\n-\t    {\n-\t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n-\t      return '\\0';\n-\t    } \n-\t  dtp->u.p.current_unit->bytes_left--;\n-\t}\n-      else\n-\t{\n-\t  if (dtp->u.p.at_eof) \n-\t    return EOF;\n-\t  if (length == 0)\n-\t    {\n-\t      c = '\\n';\n-\t      dtp->u.p.at_eof = 1;\n-\t    }\n-\t}\n+\t} \n+      dtp->u.p.current_unit->bytes_left--;\n     }\n   else\n     {\n-      c = fbuf_getc (dtp->u.p.current_unit);\n-      if (c != EOF && is_stream_io (dtp))\n-\tdtp->u.p.current_unit->strm_pos++;\n+      if (dtp->u.p.at_eof) \n+\treturn EOF;\n+      if (length == 0)\n+\t{\n+\t  c = '\\n';\n+\t  dtp->u.p.at_eof = 1;\n+\t}\n     }\n+\n done:\n   dtp->u.p.at_eol = (c == '\\n' || c == EOF);\n   return c;\n }\n \n \n-static gfc_char4_t\n+/* Worker function for UTF encoded files.  */\n+static int\n next_char_utf8 (st_parameter_dt *dtp) \n {\n   static const uchar masks[6] = { 0x7F, 0x1F, 0x0F, 0x07, 0x02, 0x01 };\n   static const uchar patns[6] = { 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n   int i, nb;\n   gfc_char4_t c;\n \n-  c = next_char (dtp);\n+  /* Always check the unget and line buffer first.  */\n+  if (!(c = check_buffers (dtp)))\n+    c = fbuf_getc (dtp->u.p.current_unit);\n+\n   if (c < 0x80)\n-    return c;\n+    goto utf_done;\n \n   /* The number of leading 1-bits in the first byte indicates how many\n      bytes follow.  */\n@@ -305,11 +348,9 @@ next_char_utf8 (st_parameter_dt *dtp)\n   /* Decode the bytes read.  */\n   for (i = 1; i < nb; i++)\n     {\n-      gfc_char4_t n = next_char (dtp);\n-\n+      gfc_char4_t n = fbuf_getc (dtp->u.p.current_unit);\n       if ((n & 0xC0) != 0x80)\n \tgoto invalid;\n-\n       c = ((c << 6) + (n & 0x3F));\n     }\n \n@@ -324,7 +365,9 @@ next_char_utf8 (st_parameter_dt *dtp)\n   if (c > 0x7FFFFFFF || (c >= 0xD800 && c <= 0xDFFF))\n     goto invalid;\n \n-  return c;\n+utf_done:\n+  dtp->u.p.at_eol = (c == '\\n' || c == (gfc_char4_t) EOF);\n+  return (int) c;\n       \n  invalid:\n   generate_error (&dtp->common, LIBERROR_READ_VALUE, \"Invalid UTF-8 encoding\");\n@@ -1172,96 +1215,50 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n \n  get_string:\n \n-  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n-    for (;;)\n-      {\n-\tif ((c = next_char_utf8 (dtp)) == EOF)\n-\t  goto done_eof;\n-\tswitch (c)\n-\t  {\n-\t  case '\"':\n-\t  case '\\'':\n-\t    if (c != quote)\n-\t      {\n-\t\tpush_char4 (dtp, c);\n-\t\tbreak;\n-\t      }\n-  \n-\t    /* See if we have a doubled quote character or the end of\n-\t       the string.  */\n-  \n-\t    if ((c = next_char_utf8 (dtp)) == EOF)\n-\t      goto done_eof;\n-\t    if (c == quote)\n-\t      {\n-\t\tpush_char4 (dtp, quote);\n-\t\tbreak;\n-\t      }\n-  \n-\t    unget_char (dtp, c);\n-\t    goto done;\n-  \n-\t  CASE_SEPARATORS:\n-\t    if (quote == ' ')\n-\t      {\n-\t\tunget_char (dtp, c);\n-\t\tgoto done;\n-\t      }\n-  \n-\t    if (c != '\\n' && c != '\\r')\n-\t      push_char4 (dtp, c);\n-\t    break;\n-  \n-\t  default:\n-\t    push_char4 (dtp, c);\n-\t    break;\n-\t  }\n-      }\n-  else\n-    for (;;)\n-      {\n-\tif ((c = next_char (dtp)) == EOF)\n-\t  goto done_eof;\n-\tswitch (c)\n-\t  {\n-\t  case '\"':\n-\t  case '\\'':\n-\t    if (c != quote)\n-\t      {\n-\t\tpush_char (dtp, c);\n-\t\tbreak;\n-\t      }\n-  \n-\t    /* See if we have a doubled quote character or the end of\n-\t       the string.  */\n+  for (;;)\n+    {\n+      if ((c = next_char (dtp)) == EOF)\n+\tgoto done_eof;\n+      switch (c)\n+\t{\n+\tcase '\"':\n+\tcase '\\'':\n+\t  if (c != quote)\n+\t    {\n+\t      push_char (dtp, c);\n+\t      break;\n+\t    }\n   \n-\t    if ((c = next_char (dtp)) == EOF)\n-\t      goto done_eof;\n-\t    if (c == quote)\n-\t      {\n-\t\tpush_char (dtp, quote);\n-\t\tbreak;\n-\t      }\n+\t  /* See if we have a doubled quote character or the end of\n+\t     the string.  */\n   \n-\t    unget_char (dtp, c);\n-\t    goto done;\n+\t  if ((c = next_char (dtp)) == EOF)\n+\t    goto done_eof;\n+\t  if (c == quote)\n+\t    {\n+\t      push_char (dtp, quote);\n+\t      break;\n+\t    }\n   \n-\t  CASE_SEPARATORS:\n-\t    if (quote == ' ')\n-\t      {\n-\t\tunget_char (dtp, c);\n-\t\tgoto done;\n-\t      }\n+\t  unget_char (dtp, c);\n+\t  goto done;\n   \n-\t    if (c != '\\n' && c != '\\r')\n-\t      push_char (dtp, c);\n-\t    break;\n+\tCASE_SEPARATORS:\n+\t  if (quote == ' ')\n+\t    {\n+\t      unget_char (dtp, c);\n+\t      goto done;\n+\t    }\n   \n-\t  default:\n+\t  if (c != '\\n' && c != '\\r')\n \t    push_char (dtp, c);\n-\t    break;\n-\t  }\n-      }\n+\t  break;\n+  \n+\tdefault:\n+\t  push_char (dtp, c);\n+\t  break;\n+\t}\n+    }\n \n   /* At this point, we have to have a separator, or else the string is\n      invalid.  */\n@@ -2025,6 +2022,30 @@ check_type (st_parameter_dt *dtp, bt type, int kind)\n }\n \n \n+/* Initialize the function pointers to select the correct versions of\n+   next_char and push_char depending on what we are doing.  */\n+\n+static void\n+set_workers (st_parameter_dt *dtp)\n+{\n+  if (dtp->u.p.current_unit->flags.encoding == ENCODING_UTF8)\n+    {\n+      dtp->u.p.current_unit->next_char_fn_ptr = &next_char_utf8;\n+      dtp->u.p.current_unit->push_char_fn_ptr = &push_char4;\n+    }\n+  else if (is_internal_unit (dtp))\n+    {\n+      dtp->u.p.current_unit->next_char_fn_ptr = &next_char_internal;\n+      dtp->u.p.current_unit->push_char_fn_ptr = &push_char_default;\n+    }\n+  else\n+    {\n+      dtp->u.p.current_unit->next_char_fn_ptr = &next_char_default;\n+      dtp->u.p.current_unit->push_char_fn_ptr = &push_char_default;\n+    }\n+\n+}\n+\n /* Top level data transfer subroutine for list reads.  Because we have\n    to deal with repeat counts, the data item is always saved after\n    reading, usually in the dtp->u.p.value[] array.  If a repeat count is\n@@ -2040,6 +2061,9 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n \n   dtp->u.p.namelist_mode = 0;\n \n+  /* Set the next_char and push_char worker functions.  */\n+  set_workers (dtp);\n+\n   if (dtp->u.p.first_item)\n     {\n       dtp->u.p.first_item = 0;\n@@ -2162,7 +2186,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n \t\tmemcpy (p, dtp->u.p.saved_string, m);\n \t      else\n \t\tfor (i = 0; i < m; i++)\n-\t\t  *q++ = (unsigned char) dtp->u.p.saved_string[i];\n+\t\t  *q++ = *r++;\n \t    }\n \t}\n       else\n@@ -2244,6 +2268,10 @@ finish_list_read (st_parameter_dt *dtp)\n   if (!is_internal_unit (dtp))\n     {\n       int c;\n+\n+      /* Set the next_char and push_char worker functions.  */\n+      set_workers (dtp);\n+\n       c = next_char (dtp);\n       if (c == EOF)\n \t{\n@@ -3060,7 +3088,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n   do\n     {\n       if (!is_separator (c))\n-\tpush_char (dtp, tolower(c));\n+\tpush_char_default (dtp, tolower(c));\n       if ((c = next_char (dtp)) == EOF)\n \tgoto nml_err_ret;\n     }\n@@ -3075,7 +3103,7 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n      are present for an object.  (iii) gives the same error message\n      as (i)  */\n \n-  push_char (dtp, '\\0');\n+  push_char_default (dtp, '\\0');\n \n   if (component_flag)\n     {\n@@ -3314,6 +3342,9 @@ namelist_read (st_parameter_dt *dtp)\n   dtp->u.p.namelist_mode = 1;\n   dtp->u.p.input_complete = 0;\n   dtp->u.p.expanded_read = 0;\n+  \n+  /* Set the next_char and push_char worker functions.  */\n+  set_workers (dtp);\n \n   /* Look for &namelist_name .  Skip all characters, testing for $nmlname.\n      Exit on success or EOF. If '?' or '=?' encountered in stdin, print"}]}