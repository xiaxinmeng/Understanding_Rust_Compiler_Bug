{"sha": "9fb9293aca4ddbe4d11a334befaa7847b279ed39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiOTI5M2FjYTRkZGJlNGQxMWEzMzRiZWZhYTc4NDdiMjc5ZWQzOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:15:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:15:54Z"}, "message": "poly_int: vectorizable_induction\n\nThis patch makes vectorizable_induction cope with variable-length\nvectors.  For now we punt on SLP inductions, but patchees after\nthe main SVE submission add support for those too.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vect-loop.c (vectorizable_induction): Treat the number\n\tof units as polynomial.  Punt on SLP inductions.  Use an integer\n\tVEC_SERIES_EXPR for variable-length integer reductions.  Use a\n\tcast of such a series for variable-length floating-point\n\treductions.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256134", "tree": {"sha": "290a2b4c5b9cd2e00b2a1704ce9a24f65266a156", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/290a2b4c5b9cd2e00b2a1704ce9a24f65266a156"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb9293aca4ddbe4d11a334befaa7847b279ed39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb9293aca4ddbe4d11a334befaa7847b279ed39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb9293aca4ddbe4d11a334befaa7847b279ed39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb9293aca4ddbe4d11a334befaa7847b279ed39/comments", "author": null, "committer": null, "parents": [{"sha": "e54dd6d3a791536543d4769aa09508b89d882f37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e54dd6d3a791536543d4769aa09508b89d882f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e54dd6d3a791536543d4769aa09508b89d882f37"}], "stats": {"total": 85, "additions": 68, "deletions": 17}, "files": [{"sha": "25f476aa12187fc5bf79817a95bc39077ec37fa8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb9293aca4ddbe4d11a334befaa7847b279ed39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb9293aca4ddbe4d11a334befaa7847b279ed39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fb9293aca4ddbe4d11a334befaa7847b279ed39", "patch": "@@ -1,3 +1,13 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vect-loop.c (vectorizable_induction): Treat the number\n+\tof units as polynomial.  Punt on SLP inductions.  Use an integer\n+\tVEC_SERIES_EXPR for variable-length integer reductions.  Use a\n+\tcast of such a series for variable-length floating-point\n+\treductions.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "2b3bb07292c6d82ab948a26f4a4556e864c9b845", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb9293aca4ddbe4d11a334befaa7847b279ed39/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb9293aca4ddbe4d11a334befaa7847b279ed39/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9fb9293aca4ddbe4d11a334befaa7847b279ed39", "patch": "@@ -6693,7 +6693,7 @@ vectorizable_induction (gimple *phi,\n     return false;\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  unsigned nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   if (slp_node)\n     ncopies = 1;\n@@ -6758,6 +6758,16 @@ vectorizable_induction (gimple *phi,\n     iv_loop = loop;\n   gcc_assert (iv_loop == (gimple_bb (phi))->loop_father);\n \n+  if (slp_node && !nunits.is_constant ())\n+    {\n+      /* The current SLP code creates the initial value element-by-element.  */\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"SLP induction not supported for variable-length\"\n+\t\t\t \" vectors.\\n\");\n+      return false;\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n@@ -6806,6 +6816,9 @@ vectorizable_induction (gimple *phi,\n      [VF*S, VF*S, VF*S, VF*S] for all.  */\n   if (slp_node)\n     {\n+      /* Enforced above.  */\n+      unsigned int const_nunits = nunits.to_constant ();\n+\n       /* Convert the init to the desired type.  */\n       stmts = NULL;\n       init_expr = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n@@ -6834,19 +6847,20 @@ vectorizable_induction (gimple *phi,\n       /* Now generate the IVs.  */\n       unsigned group_size = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n       unsigned nvects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-      unsigned elts = nunits * nvects;\n-      unsigned nivs = least_common_multiple (group_size, nunits) / nunits;\n+      unsigned elts = const_nunits * nvects;\n+      unsigned nivs = least_common_multiple (group_size,\n+\t\t\t\t\t     const_nunits) / const_nunits;\n       gcc_assert (elts % group_size == 0);\n       tree elt = init_expr;\n       unsigned ivn;\n       for (ivn = 0; ivn < nivs; ++ivn)\n \t{\n-\t  tree_vector_builder elts (vectype, nunits, 1);\n+\t  tree_vector_builder elts (vectype, const_nunits, 1);\n \t  stmts = NULL;\n-\t  for (unsigned eltn = 0; eltn < nunits; ++eltn)\n+\t  for (unsigned eltn = 0; eltn < const_nunits; ++eltn)\n \t    {\n-\t      if (ivn*nunits + eltn >= group_size\n-\t\t  && (ivn*nunits + eltn) % group_size == 0)\n+\t      if (ivn*const_nunits + eltn >= group_size\n+\t\t  && (ivn * const_nunits + eltn) % group_size == 0)\n \t\telt = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (elt),\n \t\t\t\t    elt, step_expr);\n \t      elts.quick_push (elt);\n@@ -6883,7 +6897,7 @@ vectorizable_induction (gimple *phi,\n       if (ivn < nvects)\n \t{\n \t  unsigned vfp\n-\t    = least_common_multiple (group_size, nunits) / group_size;\n+\t    = least_common_multiple (group_size, const_nunits) / group_size;\n \t  /* Generate [VF'*S, VF'*S, ... ].  */\n \t  if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)))\n \t    {\n@@ -6958,18 +6972,45 @@ vectorizable_induction (gimple *phi,\n       stmts = NULL;\n       new_name = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n \n-      tree_vector_builder elts (vectype, nunits, 1);\n-      elts.quick_push (new_name);\n-      for (i = 1; i < nunits; i++)\n+      unsigned HOST_WIDE_INT const_nunits;\n+      if (nunits.is_constant (&const_nunits))\n \t{\n-\t  /* Create: new_name_i = new_name + step_expr  */\n-\t  new_name = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (new_name),\n-\t\t\t\t   new_name, step_expr);\n+\t  tree_vector_builder elts (vectype, const_nunits, 1);\n \t  elts.quick_push (new_name);\n+\t  for (i = 1; i < const_nunits; i++)\n+\t    {\n+\t      /* Create: new_name_i = new_name + step_expr  */\n+\t      new_name = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (new_name),\n+\t\t\t\t       new_name, step_expr);\n+\t      elts.quick_push (new_name);\n+\t    }\n+\t  /* Create a vector from [new_name_0, new_name_1, ...,\n+\t     new_name_nunits-1]  */\n+\t  vec_init = gimple_build_vector (&stmts, &elts);\n \t}\n-      /* Create a vector from [new_name_0, new_name_1, ...,\n-\t new_name_nunits-1]  */\n-      vec_init = gimple_build_vector (&stmts, &elts);\n+      else if (INTEGRAL_TYPE_P (TREE_TYPE (step_expr)))\n+\t/* Build the initial value directly from a VEC_SERIES_EXPR.  */\n+\tvec_init = gimple_build (&stmts, VEC_SERIES_EXPR, vectype,\n+\t\t\t\t new_name, step_expr);\n+      else\n+\t{\n+\t  /* Build:\n+\t        [base, base, base, ...]\n+\t\t+ (vectype) [0, 1, 2, ...] * [step, step, step, ...].  */\n+\t  gcc_assert (SCALAR_FLOAT_TYPE_P (TREE_TYPE (step_expr)));\n+\t  gcc_assert (flag_associative_math);\n+\t  tree index = build_index_vector (vectype, 0, 1);\n+\t  tree base_vec = gimple_build_vector_from_val (&stmts, vectype,\n+\t\t\t\t\t\t\tnew_name);\n+\t  tree step_vec = gimple_build_vector_from_val (&stmts, vectype,\n+\t\t\t\t\t\t\tstep_expr);\n+\t  vec_init = gimple_build (&stmts, FLOAT_EXPR, vectype, index);\n+\t  vec_init = gimple_build (&stmts, MULT_EXPR, vectype,\n+\t\t\t\t   vec_init, step_vec);\n+\t  vec_init = gimple_build (&stmts, PLUS_EXPR, vectype,\n+\t\t\t\t   vec_init, base_vec);\n+\t}\n+\n       if (stmts)\n \t{\n \t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);"}]}