{"sha": "b1a0b3b4ff189d34f58e2111121b35fb8c279602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFhMGIzYjRmZjE4OWQzNGY1OGUyMTExMTIxYjM1ZmI4YzI3OTYwMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-04-06T15:18:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-04-06T15:18:18Z"}, "message": "re PR tree-optimization/42906 (Empty loop not removed)\n\n\tPR tree-optimization/42906\n\n\t* tree-ssa-dce.c (mark_control_dependent_edges_necessary): Add IGNORE_SELF\n\targument; set visited_control_parents for fully processed BBs.\n\t(find_obviously_necessary_stmts): Update call of\n\tmark_control_dependent_edges_necessary.\n\t(propagate_necessity): Likewise; handle PHI edges more curefully.\n\n\t* gcc.dg/tree-ssa/dce-1.c: New testcase.\n\nFrom-SVN: r158004", "tree": {"sha": "73ad6f631ae8adc1be1e42fdd9d31ef2804d19d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73ad6f631ae8adc1be1e42fdd9d31ef2804d19d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1a0b3b4ff189d34f58e2111121b35fb8c279602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a0b3b4ff189d34f58e2111121b35fb8c279602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1a0b3b4ff189d34f58e2111121b35fb8c279602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a0b3b4ff189d34f58e2111121b35fb8c279602/comments", "author": null, "committer": null, "parents": [{"sha": "1b10fc20a2e823e7655e3d81961f7d47c0ff330a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b10fc20a2e823e7655e3d81961f7d47c0ff330a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b10fc20a2e823e7655e3d81961f7d47c0ff330a"}], "stats": {"total": 147, "additions": 135, "deletions": 12}, "files": [{"sha": "a05b59588d4fb26c69319fb035f096a1abf9e3f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a0b3b4ff189d34f58e2111121b35fb8c279602/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a0b3b4ff189d34f58e2111121b35fb8c279602/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1a0b3b4ff189d34f58e2111121b35fb8c279602", "patch": "@@ -1,3 +1,13 @@\n+2010-04-06  Jan Hubicka  <jh@suse.czpli\n+\n+\tPR tree-optimization/42906\n+\n+\t* tree-ssa-dce.c (mark_control_dependent_edges_necessary): Add IGNORE_SELF\n+\targument; set visited_control_parents for fully processed BBs.\n+\t(find_obviously_necessary_stmts): Update call of\n+\tmark_control_dependent_edges_necessary.\n+\t(propagate_necessity): Likewise; handle PHI edges more curefully.\n+\n 2010-04-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md: Remove comment about 'e' and 'E'"}, {"sha": "22f893424f6e3d0423ab11ce69a6e853335e9112", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a0b3b4ff189d34f58e2111121b35fb8c279602/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a0b3b4ff189d34f58e2111121b35fb8c279602/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1a0b3b4ff189d34f58e2111121b35fb8c279602", "patch": "@@ -1,3 +1,8 @@\n+2010-04-06  Jan Hubicka  <jh@suse.czpli\n+\n+\tPR tree-optimization/42906\n+\t* gcc.dg/tree-ssa/dce-1.c: New testcase.\n+\n 2010-04-06  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/43178"}, {"sha": "12612e54680d641315bcc193485199330289551d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/dce-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a0b3b4ff189d34f58e2111121b35fb8c279602/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdce-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a0b3b4ff189d34f58e2111121b35fb8c279602/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdce-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdce-1.c?ref=b1a0b3b4ff189d34f58e2111121b35fb8c279602", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cddce1\" } */\n+int foo (int b, int j)\n+{\n+  if (b)\n+    {\n+      int i;\n+      for (i = 0; i<1000; ++i)\n+        ;\n+      j = 0;\n+    }\n+  return j;\n+}\n+/* Check that empty loop is eliminated in this case.  We should no longer have\n+   the exit condition after the loop.  */\n+/* { dg-final { scan-tree-dump-not \"999\" \"cddce1\"} } */\n+/* { dg-final { scan-tree-dump-not \"1000\" \"cddce1\"} } */\n+/* { dg-final { cleanup-tree-dump \"cddce1\" } } */\n+"}, {"sha": "a1f1c710df70fde8cc13752e77d11d78f9d70719", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 101, "deletions": 12, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a0b3b4ff189d34f58e2111121b35fb8c279602/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a0b3b4ff189d34f58e2111121b35fb8c279602/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=b1a0b3b4ff189d34f58e2111121b35fb8c279602", "patch": "@@ -373,12 +373,15 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n \n /* Make corresponding control dependent edges necessary.  We only\n    have to do this once for each basic block, so we clear the bitmap\n-   after we're done.  */\n+   after we're done.\n+\n+   When IGNORE_SELF it true, ignore BB from the list of control dependences.  */\n static void\n-mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el)\n+mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el, bool ignore_self)\n {\n   bitmap_iterator bi;\n   unsigned edge_number;\n+  bool skipped = false;\n \n   gcc_assert (bb != EXIT_BLOCK_PTR);\n \n@@ -390,6 +393,12 @@ mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el)\n       gimple stmt;\n       basic_block cd_bb = INDEX_EDGE_PRED_BB (el, edge_number);\n \n+      if (ignore_self && cd_bb == bb)\n+\t{\n+\t  skipped = true;\n+\t  continue;\n+\t}\n+\n       if (TEST_BIT (last_stmt_necessary, cd_bb->index))\n \tcontinue;\n       SET_BIT (last_stmt_necessary, cd_bb->index);\n@@ -399,6 +408,8 @@ mark_control_dependent_edges_necessary (basic_block bb, struct edge_list *el)\n       if (stmt && is_ctrl_stmt (stmt))\n \tmark_stmt_necessary (stmt, true);\n     }\n+  if (!skipped)\n+    SET_BIT (visited_control_parents, bb->index);\n }\n \n \n@@ -459,7 +470,7 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t          if (dump_file)\n \t            fprintf (dump_file, \"Marking back edge of irreducible loop %i->%i\\n\",\n \t\t    \t     e->src->index, e->dest->index);\n-\t\t  mark_control_dependent_edges_necessary (e->dest, el);\n+\t\t  mark_control_dependent_edges_necessary (e->dest, el, false);\n \t\t}\n \t  }\n \n@@ -468,7 +479,7 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \"can not prove finiteness of loop %i\\n\", loop->num);\n-\t    mark_control_dependent_edges_necessary (loop->latch, el);\n+\t    mark_control_dependent_edges_necessary (loop->latch, el, false);\n \t  }\n       scev_finalize ();\n     }\n@@ -653,10 +664,7 @@ propagate_necessity (struct edge_list *el)\n \t  basic_block bb = gimple_bb (stmt);\n \t  if (bb != ENTRY_BLOCK_PTR\n \t      && ! TEST_BIT (visited_control_parents, bb->index))\n-\t    {\n-\t      SET_BIT (visited_control_parents, bb->index);\n-\t      mark_control_dependent_edges_necessary (bb, el);\n-\t    }\n+\t    mark_control_dependent_edges_necessary (bb, el, false);\n \t}\n \n       if (gimple_code (stmt) == GIMPLE_PHI\n@@ -679,17 +687,98 @@ propagate_necessity (struct edge_list *el)\n \t\tmark_operand_necessary (arg);\n \t    }\n \n+\t  /* For PHI operands it matters from where the control flow arrives\n+\t     to the BB.  Consider the following example:\n+\n+\t     a=exp1;\n+\t     b=exp2;\n+\t     if (test)\n+\t\t;\n+\t     else\n+\t\t;\n+\t     c=PHI(a,b)\n+\n+\t     We need to mark control dependence of the empty basic blocks, since they\n+\t     contains computation of PHI operands.\n+\n+\t     Doing so is too restrictive in the case the predecestor block is in\n+\t     the loop. Consider:\n+\n+\t      if (b)\n+\t\t{\n+\t\t  int i;\n+\t\t  for (i = 0; i<1000; ++i)\n+\t\t    ;\n+\t\t  j = 0;\n+\t\t}\n+\t      return j;\n+\n+\t     There is PHI for J in the BB containing return statement.\n+\t     In this case the control dependence of predecestor block (that is\n+\t     within the empty loop) also contains the block determining number\n+\t     of iterations of the block that would prevent removing of empty\n+\t     loop in this case.\n+\n+\t     This scenario can be avoided by splitting critical edges.\n+\t     To save the critical edge splitting pass we identify how the control\n+\t     dependence would look like if the edge was split.\n+\n+\t     Consider the modified CFG created from current CFG by splitting\n+\t     edge B->C.  In the postdominance tree of modified CFG, C' is\n+\t     always child of C.  There are two cases how chlids of C' can look\n+\t     like:\n+\n+\t\t1) C' is leaf\n+\n+\t\t   In this case the only basic block C' is control dependent on is B.\n+\n+\t\t2) C' has single child that is B\n+\n+\t\t   In this case control dependence of C' is same as control\n+\t\t   dependence of B in original CFG except for block B itself.\n+\t\t   (since C' postdominate B in modified CFG)\n+\n+\t     Now how to decide what case happens?  There are two basic options:\n+\n+\t\ta) C postdominate B.  Then C immediately postdominate B and\n+\t\t   case 2 happens iff there is no other way from B to C except\n+\t\t   the edge B->C.\n+\n+\t\t   There is other way from B to C iff there is succesor of B that\n+\t\t   is not postdominated by B.  Testing this condition is somewhat\n+\t\t   expensive, because we need to iterate all succesors of B.\n+\t\t   We are safe to assume that this does not happen: we will mark B\n+\t\t   as needed when processing the other path from B to C that is\n+\t\t   conrol dependent on B and marking control dependencies of B\n+\t\t   itself is harmless because they will be processed anyway after\n+\t\t   processing control statement in B.\n+\n+\t\tb) C does not postdominate B.  Always case 1 happens since there is\n+\t\t   path from C to exit that does not go through B and thus also C'.  */\n+\n \t  if (aggressive && !degenerate_phi_p (stmt))\n \t    {\n \t      for (k = 0; k < gimple_phi_num_args (stmt); k++)\n \t\t{\n \t\t  basic_block arg_bb = gimple_phi_arg_edge (stmt, k)->src;\n-\t\t  if (arg_bb != ENTRY_BLOCK_PTR\n-\t\t      && ! TEST_BIT (visited_control_parents, arg_bb->index))\n+\n+\t\t  if (gimple_bb (stmt)\n+\t\t      != get_immediate_dominator (CDI_POST_DOMINATORS, arg_bb))\n \t\t    {\n-\t\t      SET_BIT (visited_control_parents, arg_bb->index);\n-\t\t      mark_control_dependent_edges_necessary (arg_bb, el);\n+\t\t      if (!TEST_BIT (last_stmt_necessary, arg_bb->index))\n+\t\t\t{\n+\t\t\t  gimple stmt2;\n+\t\t\t  SET_BIT (last_stmt_necessary, arg_bb->index);\n+\t\t\t  SET_BIT (bb_contains_live_stmts, arg_bb->index);\n+\n+\t\t\t  stmt2 = last_stmt (arg_bb);\n+\t\t\t  if (stmt2 && is_ctrl_stmt (stmt2))\n+\t\t\t    mark_stmt_necessary (stmt2, true);\n+\t\t\t}\n \t\t    }\n+\t\t  else if (arg_bb != ENTRY_BLOCK_PTR\n+\t\t           && ! TEST_BIT (visited_control_parents, arg_bb->index))\n+\t\t    mark_control_dependent_edges_necessary (arg_bb, el, true);\n \t\t}\n \t    }\n \t}"}]}