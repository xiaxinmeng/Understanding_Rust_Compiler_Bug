{"sha": "302db8ba6180906dd9a8c4ce670aff804f921fab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAyZGI4YmE2MTgwOTA2ZGQ5YThjNGNlNjcwYWZmODA0ZjkyMWZhYg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-12-14T22:45:55Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-12-14T22:45:55Z"}, "message": "PR tree-optimization/88372 - alloc_size attribute is ignored on function pointers\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/88372\n\t* calls.c (maybe_warn_alloc_args_overflow): Handle function pointers.\n\t* tree-object-size.c (alloc_object_size): Same.  Simplify.\n\t* doc/extend.texi (Object Size Checking): Update.\n\t(Other Builtins): Add __builtin_object_size.\n\t(Common Type Attributes): Add alloc_size.\n\t(Common Variable Attributes): Ditto.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/88372\n\t* gcc.dg/Walloc-size-larger-than-18.c: New test.\n\t* gcc.dg/builtin-object-size-19.c: Same.\n\nFrom-SVN: r267158", "tree": {"sha": "257c476ecc81a6f345864f453f153057cf7f98de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/257c476ecc81a6f345864f453f153057cf7f98de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/302db8ba6180906dd9a8c4ce670aff804f921fab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/302db8ba6180906dd9a8c4ce670aff804f921fab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/302db8ba6180906dd9a8c4ce670aff804f921fab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/302db8ba6180906dd9a8c4ce670aff804f921fab/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e6837c2a56f47c6b3156bbc12a9e89611412f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e6837c2a56f47c6b3156bbc12a9e89611412f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e6837c2a56f47c6b3156bbc12a9e89611412f83"}], "stats": {"total": 348, "additions": 308, "deletions": 40}, "files": [{"sha": "492d9001e656dc86a97382714c20e5b5afe415f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=302db8ba6180906dd9a8c4ce670aff804f921fab", "patch": "@@ -1,3 +1,13 @@\n+2018-12-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/88372\n+\t* calls.c (maybe_warn_alloc_args_overflow): Handle function pointers.\n+\t* tree-object-size.c (alloc_object_size): Same.  Simplify.\n+\t* doc/extend.texi (Object Size Checking): Update.\n+\t(Other Builtins): Add __builtin_object_size.\n+\t(Common Type Attributes): Add alloc_size.\n+\t(Common Variable Attributes): Ditto.\n+\n 2018-12-14  Martin Sebor  <msebor@redhat.com>\n \n \tPR rtl-optimization/87096"}, {"sha": "e3b4ef80e51101b5bb70ebd3b3571c7b2b8e2046", "filename": "gcc/calls.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=302db8ba6180906dd9a8c4ce670aff804f921fab", "patch": "@@ -1342,9 +1342,10 @@ get_size_range (tree exp, tree range[2], bool allow_zero /* = false */)\n /* Diagnose a call EXP to function FN decorated with attribute alloc_size\n    whose argument numbers given by IDX with values given by ARGS exceed\n    the maximum object size or cause an unsigned oveflow (wrapping) when\n-   multiplied.  When ARGS[0] is null the function does nothing.  ARGS[1]\n-   may be null for functions like malloc, and non-null for those like\n-   calloc that are decorated with a two-argument attribute alloc_size.  */\n+   multiplied.  FN is null when EXP is a call via a function pointer.\n+   When ARGS[0] is null the function does nothing.  ARGS[1] may be null\n+   for functions like malloc, and non-null for those like calloc that\n+   are decorated with a two-argument attribute alloc_size.  */\n \n void\n maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n@@ -1357,6 +1358,8 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \n   location_t loc = EXPR_LOCATION (exp);\n \n+  tree fntype = fn ? TREE_TYPE (fn) : TREE_TYPE (TREE_TYPE (exp));\n+  built_in_function fncode = fn ? DECL_FUNCTION_CODE (fn) : BUILT_IN_NONE;\n   bool warned = false;\n \n   /* Validate each argument individually.  */\n@@ -1382,11 +1385,11 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t\t friends.\n \t\t Also avoid issuing the warning for calls to function named\n \t\t \"alloca\".  */\n-\t      if ((DECL_FUNCTION_CODE (fn) == BUILT_IN_ALLOCA\n+\t      if ((fncode == BUILT_IN_ALLOCA\n \t\t   && IDENTIFIER_LENGTH (DECL_NAME (fn)) != 6)\n-\t\t  || (DECL_FUNCTION_CODE (fn) != BUILT_IN_ALLOCA\n+\t\t  || (fncode != BUILT_IN_ALLOCA\n \t\t      && !lookup_attribute (\"returns_nonnull\",\n-\t\t\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (fn)))))\n+\t\t\t\t\t    TYPE_ATTRIBUTES (fntype))))\n \t\twarned = warning_at (loc, OPT_Walloc_zero,\n \t\t\t\t     \"%Kargument %i value is zero\",\n \t\t\t\t     exp, idx[i] + 1);\n@@ -1398,6 +1401,7 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t\t size overflow.  There's no good way to detect C++98 here\n \t\t so avoid diagnosing these calls for all C++ modes.  */\n \t      if (i == 0\n+\t\t  && fn\n \t\t  && !args[1]\n \t\t  && lang_GNU_CXX ()\n \t\t  && DECL_IS_OPERATOR_NEW (fn)\n@@ -1481,7 +1485,7 @@ maybe_warn_alloc_args_overflow (tree fn, tree exp, tree args[2], int idx[2])\n \t}\n     }\n \n-  if (warned)\n+  if (warned && fn)\n     {\n       location_t fnloc = DECL_SOURCE_LOCATION (fn);\n \n@@ -1933,14 +1937,13 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \n   bitmap_obstack_release (NULL);\n \n-  /* Extract attribute alloc_size and if set, store the indices of\n-     the corresponding arguments in ALLOC_IDX, and then the actual\n-     argument(s) at those indices in ALLOC_ARGS.  */\n+  /* Extract attribute alloc_size from the type of the called expression\n+     (which could be a function or a function pointer) and if set, store\n+     the indices of the corresponding arguments in ALLOC_IDX, and then\n+     the actual argument(s) at those indices in ALLOC_ARGS.  */\n   int alloc_idx[2] = { -1, -1 };\n-  if (tree alloc_size\n-      = (fndecl ? lookup_attribute (\"alloc_size\",\n-\t\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (fndecl)))\n-\t : NULL_TREE))\n+  if (tree alloc_size = lookup_attribute (\"alloc_size\",\n+\t\t\t\t\t  TYPE_ATTRIBUTES (fntype)))\n     {\n       tree args = TREE_VALUE (alloc_size);\n       alloc_idx[0] = TREE_INT_CST_LOW (TREE_VALUE (args)) - 1;"}, {"sha": "4bc90fa5d7592f3b475305779b2a00d3830fb3ed", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=302db8ba6180906dd9a8c4ce670aff804f921fab", "patch": "@@ -2522,7 +2522,7 @@ The function parameter(s) denoting the allocated size are specified by\n one or two integer arguments supplied to the attribute.  The allocated size\n is either the value of the single function argument specified or the product\n of the two function arguments specified.  Argument numbering starts at\n-one.\n+one for ordinary functions, and at two for C++ non-static member functions.\n \n For instance,\n \n@@ -6343,6 +6343,34 @@ This warning can be disabled by @option{-Wno-if-not-aligned}.\n The @code{warn_if_not_aligned} attribute can also be used for types\n (@pxref{Common Type Attributes}.)\n \n+@item alloc_size (@var{position})\n+@itemx alloc_size (@var{position-1}, @var{position-2})\n+@cindex @code{alloc_size} variable attribute\n+The @code{alloc_size} variable attribute may be applied to the declaration\n+of a pointer to a function that returns a pointer and takes at least one\n+argument of an integer type.  It indicates that the returned pointer points\n+to an object whose size is given by the function argument at @var{position-1},\n+or by the product of the arguments at @var{position-1} and @var{position-2}.\n+Meaningful sizes are positive values less than @code{PTRDIFF_MAX}.  Other\n+sizes are disagnosed when detected.  GCC uses this information to improve\n+the results of @code{__builtin_object_size}.\n+\n+For instance, the following declarations\n+\n+@smallexample\n+typedef __attribute__ ((alloc_size (1, 2))) void*\n+  (*calloc_ptr) (size_t, size_t);\n+typedef __attribute__ ((alloc_size (1))) void*\n+  (*malloc_ptr) (size_t);\n+@end smallexample\n+\n+@noindent\n+specify that @code{calloc_ptr} is a pointer of a function that, like\n+the standard C function @code{calloc}, returns an object whose size\n+is given by the product of arguments 1 and 2, and similarly, that\n+@code{malloc_ptr}, like the standard C function @code{malloc},\n+returns an object whose size is given by argument 1 to the function.\n+\n @item cleanup (@var{cleanup_function})\n @cindex @code{cleanup} variable attribute\n The @code{cleanup} attribute runs a function when the variable goes\n@@ -7328,6 +7356,34 @@ struct __attribute__ ((aligned (8))) foo\n \n This warning can be disabled by @option{-Wno-if-not-aligned}.\n \n+@item alloc_size (@var{position})\n+@itemx alloc_size (@var{position-1}, @var{position-2})\n+@cindex @code{alloc_size} type attribute\n+The @code{alloc_size} type attribute may be applied to the definition\n+of a type of a function that returns a pointer and takes at least one\n+argument of an integer type.  It indicates that the returned pointer\n+points to an object whose size is given by the function argument at\n+@var{position-1}, or by the product of the arguments at @var{position-1}\n+and @var{position-2}.  Meaningful sizes are positive values less than\n+@code{PTRDIFF_MAX}.  Other sizes are disagnosed when detected.  GCC uses\n+this information to improve the results of @code{__builtin_object_size}.\n+\n+For instance, the following declarations\n+\n+@smallexample\n+typedef __attribute__ ((alloc_size (1, 2))) void*\n+  calloc_type (size_t, size_t);\n+typedef __attribute__ ((alloc_size (1))) void*\n+  malloc_type (size_t);\n+@end smallexample\n+\n+@noindent\n+specify that @code{calloc_type} is a type of a function that, like\n+the standard C function @code{calloc}, returns an object whose size\n+is given by the product of arguments 1 and 2, and that\n+@code{malloc_type}, like the standard C function @code{malloc},\n+returns an object whose size is given by argument 1 to the function.\n+\n @item copy\n @itemx copy (@var{expression})\n @cindex @code{copy} type attribute\n@@ -11193,7 +11249,10 @@ a limited extent, they can be used without optimization as well.\n @deftypefn {Built-in Function} {size_t} __builtin_object_size (const void * @var{ptr}, int @var{type})\n is a built-in construct that returns a constant number of bytes from\n @var{ptr} to the end of the object @var{ptr} pointer points to\n-(if known at compile time).  @code{__builtin_object_size} never evaluates\n+(if known at compile time).  To determine the sizes of dynamically allocated\n+objects the function relies on the allocation functions called to obtain\n+the storage to be declared with the @code{alloc_size} attribute (@xref{Common\n+Function Attributes}).  @code{__builtin_object_size} never evaluates\n its arguments for side effects.  If there are any side effects in them, it\n returns @code{(size_t) -1} for @var{type} 0 or 1 and @code{(size_t) 0}\n for @var{type} 2 or 3.  If there are multiple objects @var{ptr} can\n@@ -11318,6 +11377,7 @@ is called and the @var{flag} argument passed to it.\n @findex __builtin_islessequal\n @findex __builtin_islessgreater\n @findex __builtin_isunordered\n+@findex __builtin_object_size\n @findex __builtin_powi\n @findex __builtin_powif\n @findex __builtin_powil\n@@ -12561,6 +12621,10 @@ is evaluated if it includes side effects but no other code is generated\n and GCC does not issue a warning.\n @end deftypefn\n \n+@deftypefn {Built-in Function}{size_t} __builtin_object_size (const void * @var{ptr}, int @var{type})\n+Returns the size of an object pointed to by @var{ptr}.  @xref{Object Size Checking} for a detailed description of the function.\n+@end deftypefn\n+\n @deftypefn {Built-in Function} double __builtin_huge_val (void)\n Returns a positive infinity, if supported by the floating-point format,\n else @code{DBL_MAX}.  This function is suitable for implementing the"}, {"sha": "24d9ee661e11ae1cd24b8d4b592f715f71237319", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=302db8ba6180906dd9a8c4ce670aff804f921fab", "patch": "@@ -1,3 +1,9 @@\n+2018-12-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/88372\n+\t* gcc.dg/Walloc-size-larger-than-18.c: New test.\n+\t* gcc.dg/builtin-object-size-19.c: Same.\n+\n 2018-12-14  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/87096"}, {"sha": "b4aa167f655e46ac2ed6f1acc9f6d08dd9d56fef", "filename": "gcc/testsuite/gcc.dg/Walloc-size-larger-than-18.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Ftestsuite%2Fgcc.dg%2FWalloc-size-larger-than-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Ftestsuite%2Fgcc.dg%2FWalloc-size-larger-than-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWalloc-size-larger-than-18.c?ref=302db8ba6180906dd9a8c4ce670aff804f921fab", "patch": "@@ -0,0 +1,93 @@\n+/* PR tree-optimization/88372 - alloc_size attribute is ignored\n+   on function pointers\n+   Verify that calls via function pointers declared alloc_size\n+   with zero or excessive size trigger either -Walloc-zero or\n+   -Walloc-size-larger-than warnings.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Walloc-zero -ftrack-macro-expansion=0\" } */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+\n+void sink (void*);\n+\n+#define T(call) sink (call)\n+\n+ATTR (alloc_size (1)) void* (*ai1)(int, int);\n+ATTR (alloc_size (2)) void* (*ai2)(int, int);\n+ATTR (alloc_size (1, 2)) void* (*ai1_2)(int, int);\n+\n+ATTR (alloc_size (1)) void* (*asz1)(size_t, size_t);\n+ATTR (alloc_size (2)) void* (*asz2)(size_t, size_t);\n+ATTR (alloc_size (1, 2)) void* (*asz1_2)(size_t, size_t);\n+\n+\n+void test_alloc_ptr_zero (void)\n+{\n+  T (asz1 (0, 0));      /* { dg-warning \"argument 1 value is zero\" } */\n+  T (asz1 (0, 1));      /* { dg-warning \"argument 1 value is zero\" } */\n+  T (asz1 (1, 0));\n+  T (asz1 (1, 1));\n+\n+  T (asz2 (0, 0));      /* { dg-warning \"argument 2 value is zero\" } */\n+  T (asz2 (0, 1));\n+  T (asz2 (1, 0));      /* { dg-warning \"argument 2 value is zero\" } */\n+  T (asz2 (1, 1));\n+\n+  T (asz1_2 (0, 0));    /* { dg-warning \"argument \\[12\\] value is zero\" } */\n+  T (asz1_2 (1, 0));    /* { dg-warning \"argument 2 value is zero\" } */\n+  T (asz1_2 (0, 1));    /* { dg-warning \"argument 1 value is zero\" } */\n+  T (asz1_2 (1, 1));\n+}\n+\n+\n+void test_alloc_ptr_negative (int n)\n+{\n+  T (ai1 (-1, -1));     /* { dg-warning \"argument 1 value .-1. is negative\" } */\n+  T (ai1 (-2,  1));     /* { dg-warning \"argument 1 value .-2. is negative\" } */\n+  T (ai1 ( 1, -1));\n+  T (ai1 ( 1,  1));\n+\n+  T (ai2 (-1, -3));     /* { dg-warning \"argument 2 value .-3. is negative\" } */\n+  T (ai2 (-1,  1));\n+  T (ai2 ( 1, -4));     /* { dg-warning \"argument 2 value .-4. is negative\" } */\n+  T (ai2 ( 1,  1));\n+\n+  T (ai1_2 (-5, -6));   /* { dg-warning \"argument \\[12\\] value .-\\[56\\]. is negative\" } */\n+  T (ai1_2 ( 1, -7));   /* { dg-warning \"argument 2 value .-7. is negative\" } */\n+  T (ai1_2 (-8,  1));   /* { dg-warning \"argument 1 value .-8. is negative\" } */\n+  T (ai1_2 ( 1,  1));\n+\n+  if (n > -1)\n+    n = -1;\n+\n+  /* Also verify a simple range.  */\n+  T (ai1_2 ( 1,  n));   /* { dg-warning \"argument 2 range \\\\\\[-\\[0-9\\]+, -1] is negative\" } */\n+  T (ai1_2 ( n,  1));   /* { dg-warning \"argument 1 range \\\\\\[-\\[0-9\\]+, -1] is negative\" } */\n+}\n+\n+void test_alloc_ptr_too_big (void)\n+{\n+  size_t x = (__SIZE_MAX__ >> 1) + 1;\n+  size_t y = __SIZE_MAX__ / 5;\n+\n+  T (asz1 (x, x));     /* { dg-warning \"argument 1 value .\\[0-9\\]+. exceeds\" } */\n+  T (asz1 (x, 1));     /* { dg-warning \"argument 1 value .\\[0-9\\]+. exceeds\" } */\n+  T (asz1 (1, x));\n+  T (asz1 (1, 1));\n+\n+  T (asz2 (x, x));     /* { dg-warning \"argument 2 value .\\[0-9\\]+. exceeds\" } */\n+  T (asz2 (x, 1));\n+  T (asz2 (1, x));     /* { dg-warning \"argument 2 value .\\[0-9\\]+. exceeds\" } */\n+  T (asz2 (1, 1));\n+\n+  T (asz1_2 (x, x));   /* { dg-warning \"argument \\[12\\] value .\\[0-9\\]+. exceeds\" } */\n+  T (asz1_2 (y, 3));   /* { dg-warning \"product .\\[0-9\\]+ \\\\\\* 3. of arguments 1 and 2 exceeds\" } */\n+  T (asz1_2 (y, y));   /* { dg-warning \"product .\\[0-9\\]+ \\\\\\* \\[0-9\\]+. of arguments 1 and 2 exceeds\" } */\n+  T (asz1_2 (1, x));   /* { dg-warning \"argument 2 value .\\[0-9\\]+. exceeds\" } */\n+  T (asz1_2 (x, 1));   /* { dg-warning \"argument 1 value .\\[0-9\\]+. exceeds\" } */\n+  T (asz1_2 (1, 1));\n+\n+}"}, {"sha": "1aab1efb77070ba8ddf8e2d287a12adaa31a6387", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-19.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-19.c?ref=302db8ba6180906dd9a8c4ce670aff804f921fab", "patch": "@@ -0,0 +1,101 @@\n+/* PR tree-optimization/88372 - alloc_size attribute is ignored\n+   on function pointers { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name) CAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to function named\n+   call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr)\t\t\t\t\t\t\t\\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+void sink (void*);\n+\n+#define T(alloc, n) do {\t\t\t\\\n+    void *p = alloc;\t\t\t\t\\\n+    sink (p);\t\t\t\t\t\\\n+    ELIM (n == __builtin_object_size (p, 0));\t\\\n+    ELIM (n == __builtin_object_size (p, 1));\t\\\n+    ELIM (n == __builtin_object_size (p, 2));\t\\\n+    ELIM (n == __builtin_object_size (p, 3));\t\\\n+  } while (0)\n+\n+\n+ATTR (alloc_size (1)) void* (*alloc_1_x)(size_t, size_t);\n+ATTR (alloc_size (2)) void* (*alloc_x_2)(size_t, size_t);\n+\n+/* Verify that things work when attribute alloc_size is applied\n+   to a typedef that is then used to declared a pointer.  */\n+typedef ATTR (alloc_size (1, 2)) void* (alloc_1_2_t)(size_t, size_t);\n+\n+void test_alloc_ptr (alloc_1_2_t *alloc_1_2)\n+{\n+  T (alloc_1_x (0, 0), 0);\n+  T (alloc_1_x (1, 0), 1);\n+  T (alloc_1_x (3, 0), 3);\n+  T (alloc_1_x (9, 5), 9);\n+\n+  T (alloc_x_2 (0, 0), 0);\n+  T (alloc_x_2 (1, 0), 0);\n+  T (alloc_x_2 (0, 1), 1);\n+  T (alloc_x_2 (9, 5), 5);\n+\n+  T (alloc_1_2 (0, 0), 0);\n+  T (alloc_1_2 (1, 0), 0);\n+  T (alloc_1_2 (0, 1), 0);\n+  T (alloc_1_2 (9, 5), 45);\n+}\n+\n+/* Verify that object size is detected even in indirect calls via\n+   function pointers to built-in allocation functions, even without\n+   explicit use of attribute alloc_size on the pointers.  */\n+\n+typedef void *(allocfn_1) (size_t);\n+typedef void *(allocfn_1_2) (size_t, size_t);\n+\n+static inline void *\n+call_alloc (allocfn_1 *fn1, allocfn_1_2 *fn2, size_t n1, size_t n2)\n+{\n+  return fn1 ? fn1 (n1) : fn2 (n1, n2);\n+}\n+\n+static inline void *\n+call_malloc (size_t n)\n+{\n+  return call_alloc (__builtin_malloc, 0, n, 0);\n+}\n+\n+static inline void *\n+call_calloc (size_t n1, size_t n2)\n+{\n+  return call_alloc (0, __builtin_calloc, n1, n2);\n+}\n+\n+void test_builtin_ptr (void)\n+{\n+  T (call_malloc (0), 0);\n+  T (call_malloc (1), 1);\n+  T (call_malloc (9), 9);\n+\n+  T (call_calloc (0, 0), 0);\n+  T (call_calloc (0, 1), 0);\n+  T (call_calloc (1, 0), 0);\n+  T (call_calloc (1, 1), 1);\n+  T (call_calloc (1, 3), 3);\n+  T (call_calloc (2, 3), 6);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"not_eliminated\" \"optimized\" } } */"}, {"sha": "d925a6caa1b6cb2ad61ff2d58032973c84504a76", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302db8ba6180906dd9a8c4ce670aff804f921fab/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=302db8ba6180906dd9a8c4ce670aff804f921fab", "patch": "@@ -401,25 +401,28 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \n \n /* Compute __builtin_object_size for CALL, which is a GIMPLE_CALL.\n-   Handles various allocation calls.  OBJECT_SIZE_TYPE is the second\n-   argument from __builtin_object_size.  If unknown, return\n-   unknown[object_size_type].  */\n+   Handles calls to functions declared with attribute alloc_size.\n+   OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.\n+   If unknown, return unknown[object_size_type].  */\n \n static unsigned HOST_WIDE_INT\n alloc_object_size (const gcall *call, int object_size_type)\n {\n-  tree callee, bytes = NULL_TREE;\n-  tree alloc_size;\n-  int arg1 = -1, arg2 = -1;\n-\n   gcc_assert (is_gimple_call (call));\n \n-  callee = gimple_call_fndecl (call);\n-  if (!callee)\n+  tree calltype;\n+  if (tree callfn = gimple_call_fndecl (call))\n+    calltype = TREE_TYPE (callfn);\n+  else\n+    calltype = gimple_call_fntype (call);\n+\n+  if (!calltype)\n     return unknown[object_size_type];\n \n-  alloc_size = lookup_attribute (\"alloc_size\",\n-\t\t\t\t TYPE_ATTRIBUTES (TREE_TYPE (callee)));\n+  /* Set to positions of alloc_size arguments.  */\n+  int arg1 = -1, arg2 = -1;\n+  tree alloc_size = lookup_attribute (\"alloc_size\",\n+\t\t\t\t      TYPE_ATTRIBUTES (calltype));\n   if (alloc_size && TREE_VALUE (alloc_size))\n     {\n       tree p = TREE_VALUE (alloc_size);\n@@ -429,26 +432,14 @@ alloc_object_size (const gcall *call, int object_size_type)\n         arg2 = TREE_INT_CST_LOW (TREE_VALUE (TREE_CHAIN (p)))-1;\n     }\n \n-  if (DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n-    switch (DECL_FUNCTION_CODE (callee))\n-      {\n-      case BUILT_IN_CALLOC:\n-\targ2 = 1;\n-\t/* fall through */\n-      case BUILT_IN_MALLOC:\n-      CASE_BUILT_IN_ALLOCA:\n-\targ1 = 0;\n-      default:\n-\tbreak;\n-      }\n-\n   if (arg1 < 0 || arg1 >= (int)gimple_call_num_args (call)\n       || TREE_CODE (gimple_call_arg (call, arg1)) != INTEGER_CST\n       || (arg2 >= 0\n \t  && (arg2 >= (int)gimple_call_num_args (call)\n \t      || TREE_CODE (gimple_call_arg (call, arg2)) != INTEGER_CST)))\n     return unknown[object_size_type];\n \n+  tree bytes = NULL_TREE;\n   if (arg2 >= 0)\n     bytes = size_binop (MULT_EXPR,\n \tfold_convert (sizetype, gimple_call_arg (call, arg1)),"}]}