{"sha": "e2f5cc96e5c4abde5879269220404fdd3e6efca2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJmNWNjOTZlNWM0YWJkZTU4NzkyNjkyMjA0MDRmZGQzZTZlZmNhMg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2015-11-05T21:42:10Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2015-11-05T21:42:10Z"}, "message": "PR c++/67942 - diagnose placement new buffer overflow\n\ngcc/\n        * invoke.texi (-Wplacement-new): Document new option.\n\t* gcc/testsuite/g++.dg/warn/Wplacement-new-size.C: New test.\n\ngcc/c-family/\n        * c.opt (-Wplacement-new): New option.\n\ngcc/cp/\n\t* cp/init.c (warn_placement_new_too_small): New function.\n\t(build_new_1): Call it.\n\ngcc/testsuite/\n        * g++.dg/warn/Wplacement-new-size.C: New test.\n\nFrom-SVN: r229827", "tree": {"sha": "ce31107d94774a8f934fd4e3164132222d38368f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce31107d94774a8f934fd4e3164132222d38368f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2f5cc96e5c4abde5879269220404fdd3e6efca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f5cc96e5c4abde5879269220404fdd3e6efca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2f5cc96e5c4abde5879269220404fdd3e6efca2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2f5cc96e5c4abde5879269220404fdd3e6efca2/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60f2d2f36d770c7d771ee5c1b3ae5a7b7169f894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f2d2f36d770c7d771ee5c1b3ae5a7b7169f894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f2d2f36d770c7d771ee5c1b3ae5a7b7169f894"}], "stats": {"total": 668, "additions": 660, "deletions": 8}, "files": [{"sha": "94e597e025a0c1592898e33921ffb61c4829f598", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2f5cc96e5c4abde5879269220404fdd3e6efca2", "patch": "@@ -1,3 +1,9 @@\n+2015-11-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/67942\n+\t* invoke.texi (-Wplacement-new): Document new option.\n+\t* gcc/testsuite/g++.dg/warn/Wplacement-new-size.C: New test.\n+\n 2015-11-05  Alan Lawrence  <alan.lawrence@arm.com>\n \n \tPR tree-optimization/65963"}, {"sha": "c21f50410faeb0a79b2382fed3ac3d56cb39c9e2", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e2f5cc96e5c4abde5879269220404fdd3e6efca2", "patch": "@@ -1,3 +1,8 @@\n+2015-11-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/67942\n+\t* c.opt (-Wplacement-new): New option.\n+\n 2015-11-05  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-common.h (c_finish_omp_atomic): Add TEST argument."}, {"sha": "5f38018d35e917b1664c7f6f6b531f0860be0332", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=e2f5cc96e5c4abde5879269220404fdd3e6efca2", "patch": "@@ -776,6 +776,10 @@ Wprotocol\n ObjC ObjC++ Var(warn_protocol) Init(1) Warning\n Warn if inherited methods are unimplemented.\n \n+Wplacement-new\n+C++ Var(warn_placement_new) Init(1) Warning\n+Warn for placement new expressions with undefined behavior\n+\n Wredundant-decls\n C ObjC C++ ObjC++ Var(warn_redundant_decls) Warning\n Warn about multiple declarations of the same object."}, {"sha": "b84778f32428edcd5d493e9c3e9f951c86d02d9d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e2f5cc96e5c4abde5879269220404fdd3e6efca2", "patch": "@@ -1,3 +1,9 @@\n+2015-11-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/67942\n+\t* cp/init.c (warn_placement_new_too_small): New function.\n+\t(build_new_1): Call it.\n+\n 2015-11-05  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/67846"}, {"sha": "7600363447d1f50acc60021425d61e89571272b1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 216, "deletions": 7, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e2f5cc96e5c4abde5879269220404fdd3e6efca2", "patch": "@@ -2276,6 +2276,201 @@ throw_bad_array_new_length (void)\n   return build_cxx_call (fn, 0, NULL, tf_warning_or_error);\n }\n \n+/* Attempt to verify that the argument, OPER, of a placement new expression\n+   refers to an object sufficiently large for an object of TYPE or an array\n+   of NELTS of such objects when NELTS is non-null, and issue a warning when\n+   it does not.  SIZE specifies the size needed to construct the object or\n+   array and captures the result of NELTS * sizeof (TYPE). (SIZE could be\n+   greater when the array under construction requires a cookie to store\n+   NELTS.  GCC's placement new expression stores the cookie when invoking\n+   a user-defined placement new operator function but not the default one.\n+   Placement new expressions with user-defined placement new operator are\n+   not diagnosed since we don't know how they use the buffer (this could\n+   be a future extension).  */\n+static void\n+warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n+{\n+  location_t loc = EXPR_LOC_OR_LOC (oper, input_location);\n+\n+  /* The number of bytes to add to or subtract from the size of the provided\n+     buffer based on an offset into an array or an array element reference.\n+     Although intermediate results may be negative (as in a[3] - 2) the final\n+     result cannot be.  */\n+  HOST_WIDE_INT adjust = 0;\n+  /* True when the size of the entire destination object should be used\n+     to compute the possibly optimistic estimate of the available space.  */\n+  bool use_obj_size = false;\n+  /* True when the reference to the destination buffer is an ADDR_EXPR.  */\n+  bool addr_expr = false;\n+\n+  STRIP_NOPS (oper);\n+\n+  /* Using a function argument or a (non-array) variable as an argument\n+     to placement new is not checked since it's unknown what it might\n+     point to.  */\n+  if (TREE_CODE (oper) == PARM_DECL\n+      || TREE_CODE (oper) == VAR_DECL\n+      || TREE_CODE (oper) == COMPONENT_REF)\n+    return;\n+\n+  /* Evaluate any constant expressions.  */\n+  size = fold_non_dependent_expr (size);\n+\n+  /* Handle the common case of array + offset expression when the offset\n+     is a constant.  */\n+  if (TREE_CODE (oper) == POINTER_PLUS_EXPR)\n+    {\n+      /* If the offset is comple-time constant, use it to compute a more\n+\t accurate estimate of the size of the buffer.  Otherwise, use\n+\t the size of the entire array as an optimistic estimate (this\n+\t may lead to false negatives).  */\n+      const_tree adj = TREE_OPERAND (oper, 1);\n+      if (CONSTANT_CLASS_P (adj))\n+\tadjust += tree_to_uhwi (adj);\n+      else\n+\tuse_obj_size = true;\n+\n+      oper = TREE_OPERAND (oper, 0);\n+\n+      STRIP_NOPS (oper);\n+    }\n+\n+  if (TREE_CODE (oper) == TARGET_EXPR)\n+    oper = TREE_OPERAND (oper, 1);\n+  else if (TREE_CODE (oper) == ADDR_EXPR)\n+    {\n+      addr_expr = true;\n+      oper = TREE_OPERAND (oper, 0);\n+    }\n+\n+  STRIP_NOPS (oper);\n+\n+  if (TREE_CODE (oper) == ARRAY_REF)\n+    {\n+      /* Similar to the offset computed above, see if the array index\n+\t is a compile-time constant.  If so, and unless the offset was\n+\t not a compile-time constant, use the index to determine the\n+\t size of the buffer.  Otherwise, use the entire array as\n+\t an optimistic estimate of the size.  */\n+      const_tree adj = TREE_OPERAND (oper, 1);\n+      if (!use_obj_size && CONSTANT_CLASS_P (adj))\n+\tadjust += tree_to_shwi (adj);\n+      else\n+\t{\n+\t  use_obj_size = true;\n+\t  adjust = 0;\n+\t}\n+\n+      oper = TREE_OPERAND (oper, 0);\n+    }\n+\n+  /* Descend into a struct or union to find the member whose address\n+     is being used as the agument.  */\n+  while (TREE_CODE (oper) == COMPONENT_REF)\n+    oper = TREE_OPERAND (oper, 1);\n+\n+  if ((addr_expr || !POINTER_TYPE_P (TREE_TYPE (oper)))\n+      && (TREE_CODE (oper) == VAR_DECL\n+\t  || TREE_CODE (oper) == FIELD_DECL\n+\t  || TREE_CODE (oper) == PARM_DECL))\n+    {\n+      /* A possibly optimistic estimate of the number of bytes available\n+\t in the destination buffer.  */\n+      unsigned HOST_WIDE_INT bytes_avail;\n+      /* True when the estimate above is in fact the exact size\n+\t of the destination buffer rather than an estimate.  */\n+      bool exact_size = true;\n+\n+      /* Treat members of unions and members of structs uniformly, even\n+\t though the size of a member of a union may be viewed as extending\n+\t to the end of the union itself (it is by __builtin_object_size).  */\n+      if (TREE_CODE (oper) == VAR_DECL || use_obj_size)\n+\t{\n+\t  /* Use the size of the entire array object when the expression\n+\t     refers to a variable or its size depends on an expression\n+\t     that's not a compile-time constant.  */\n+\t  bytes_avail = tree_to_shwi (DECL_SIZE_UNIT (oper));\n+\t  exact_size = !use_obj_size;\n+\t}\n+      else\n+\t{\n+\t  /* Use the size of the type of the destination buffer object\n+\t     as the optimistic estimate of the available space in it.  */\n+\t  bytes_avail = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (oper)));\n+\t}\n+\n+      /* Avoid diagnosing flexible array members (accepted as an extension\n+\t and diagnosed with -Wpedantic).\n+\t Constructing objects that appear to overflow the C99 equivalent of\n+\t flexible array members (i.e., array members of size zero or one)\n+\t are diagnosed in C++ since their declaration cannot be diagnosed.  */\n+      if (bytes_avail == 0 && TREE_CODE (TREE_TYPE (oper)) == ARRAY_TYPE)\n+\treturn;\n+\n+      /* The size of the buffer can only be adjusted down but not up.  */\n+      gcc_checking_assert (0 <= adjust);\n+\n+      /* Reduce the size of the buffer by the adjustment computed above\n+\t from the offset and/or the index into the array.  */\n+      if (bytes_avail < static_cast<unsigned HOST_WIDE_INT>(adjust))\n+\tbytes_avail = 0;\n+      else\n+\tbytes_avail -= adjust;\n+\n+      /* The minimum amount of space needed for the allocation.  This\n+\t is an optimistic estimate that makes it possible to detect\n+\t placement new invocation for some undersize buffers but not\n+\t others.  */\n+      unsigned HOST_WIDE_INT bytes_need;\n+\n+      if (CONSTANT_CLASS_P (size))\n+\tbytes_need = tree_to_uhwi (size);\n+      else if (nelts && CONSTANT_CLASS_P (nelts))\n+\t  bytes_need = tree_to_uhwi (nelts)\n+\t    * tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+      else\n+\tbytes_need = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+\n+      if (bytes_avail < bytes_need)\n+\t{\n+\t  if (nelts)\n+\t    if (CONSTANT_CLASS_P (nelts))\n+\t      warning_at (loc, OPT_Wplacement_new,\n+\t\t\t  exact_size ?\n+\t\t\t  \"placement new constructing an object of type \"\n+\t\t\t  \"%<%T [%wu]%> and size %qwu in a region of type %qT \"\n+\t\t\t  \"and size %qwi\"\n+\t\t\t  : \"placement new constructing an object of type \"\n+\t\t\t  \"%<%T [%lu]%> and size %qwu in a region of type %qT \"\n+\t\t\t  \"and size at most %qwu\",\n+\t\t\t  type, tree_to_uhwi (nelts), bytes_need,\n+\t\t\t  TREE_TYPE (oper),\n+\t\t\t  bytes_avail);\n+\t    else\n+\t      warning_at (loc, OPT_Wplacement_new,\n+\t\t\t  exact_size ?\n+\t\t\t  \"placement new constructing an array of objects \"\n+\t\t\t  \"of type %qT and size %qwu in a region of type %qT \"\n+\t\t\t  \"and size %qwi\"\n+\t\t\t  : \"placement new constructing an array of objects \"\n+\t\t\t  \"of type %qT and size %qwu in a region of type %qT \"\n+\t\t\t  \"and size at most %qwu\",\n+\t\t\t  type, bytes_need, TREE_TYPE (oper),\n+\t\t\t  bytes_avail);\n+\t  else\n+\t    warning_at (loc, OPT_Wplacement_new,\n+\t\t\texact_size ?\n+\t\t\t\"placement new constructing an object of type %qT \"\n+\t\t\t\"and size %qwu in a region of type %qT and size %qwi\"\n+\t\t\t: \"placement new constructing an object of type %qT\"\n+\t\t\t\"and size %qwu in a region of type %qT and size \"\n+\t\t\t\"at most %qwu\",\n+\t\t\ttype, bytes_need, TREE_TYPE (oper),\n+\t\t\tbytes_avail);\n+\t}\n+    }\n+}\n+\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n@@ -2525,6 +2720,8 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n       && (TYPE_PTR_P (TREE_TYPE ((**placement)[0]))))\n     placement_first = (**placement)[0];\n \n+  bool member_new_p = false;\n+\n   /* Allocate the object.  */\n   if (vec_safe_is_empty (*placement) && TYPE_FOR_JAVA (elt_type))\n     {\n@@ -2573,11 +2770,13 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n       fnname = ansi_opname (array_p ? VEC_NEW_EXPR : NEW_EXPR);\n \n-      if (!globally_qualified_p\n+      member_new_p = !globally_qualified_p\n \t  && CLASS_TYPE_P (elt_type)\n \t  && (array_p\n \t      ? TYPE_HAS_ARRAY_NEW_OPERATOR (elt_type)\n-\t      : TYPE_HAS_NEW_OPERATOR (elt_type)))\n+\t    : TYPE_HAS_NEW_OPERATOR (elt_type));\n+\n+      if (member_new_p)\n \t{\n \t  /* Use a class-specific operator new.  */\n \t  /* If a cookie is required, add some extra space.  */\n@@ -2652,20 +2851,30 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n   /* If we found a simple case of PLACEMENT_EXPR above, then copy it\n      into a temporary variable.  */\n   if (!processing_template_decl\n-      && placement_first != NULL_TREE\n       && TREE_CODE (alloc_call) == CALL_EXPR\n       && call_expr_nargs (alloc_call) == 2\n       && TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 0))) == INTEGER_TYPE\n       && TYPE_PTR_P (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 1))))\n     {\n-      tree placement_arg = CALL_EXPR_ARG (alloc_call, 1);\n+      tree placement = CALL_EXPR_ARG (alloc_call, 1);\n \n-      if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg)))\n-\t  || VOID_TYPE_P (TREE_TYPE (TREE_TYPE (placement_arg))))\n+      if (placement_first != NULL_TREE\n+\t  && (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (TREE_TYPE (placement)))\n+\t      || VOID_TYPE_P (TREE_TYPE (TREE_TYPE (placement)))))\n \t{\n \t  placement_expr = get_target_expr (placement_first);\n \t  CALL_EXPR_ARG (alloc_call, 1)\n-\t    = convert (TREE_TYPE (placement_arg), placement_expr);\n+\t    = convert (TREE_TYPE (placement), placement_expr);\n+\t}\n+\n+      if (!member_new_p\n+\t  && VOID_TYPE_P (TREE_TYPE (TREE_TYPE (CALL_EXPR_ARG (alloc_call, 1)))))\n+\t{\n+\t  /* Attempt to make the warning point at the operator new argument.  */\n+\t  if (placement_first)\n+\t    placement = placement_first;\n+\n+\t  warn_placement_new_too_small (orig_type, nelts, size, placement);\n \t}\n     }\n "}, {"sha": "587e30e613defa8cd7f982361cb027e1493bf5d2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e2f5cc96e5c4abde5879269220404fdd3e6efca2", "patch": "@@ -272,7 +272,7 @@ Objective-C and Objective-C++ Dialects}.\n -Woverride-init-side-effects @gol\n -Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol\n -Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol\n--Wpointer-arith  -Wno-pointer-to-int-cast @gol\n+-Wplacement-new -Wpointer-arith  -Wno-pointer-to-int-cast @gol\n -Wredundant-decls  -Wno-return-local-addr @gol\n -Wreturn-type  -Wsequence-point  -Wshadow  -Wno-shadow-ivar @gol\n -Wshift-overflow -Wshift-overflow=@var{n} @gol\n@@ -4870,6 +4870,13 @@ disables the warnings about non-ISO @code{printf} / @code{scanf} format\n width specifiers @code{I32}, @code{I64}, and @code{I} used on Windows targets,\n which depend on the MS runtime.\n \n+@item -Wplacement-new\n+@opindex Wplacement-new\n+@opindex Wno-placement-new\n+Warn about placement new expressions with undefined behavior, such as\n+constructing an object in a buffer that is smaller than the type of\n+the object.\n+\n @item -Wpointer-arith\n @opindex Wpointer-arith\n @opindex Wno-pointer-arith"}, {"sha": "c0a0d78ccc6c4a2d7f7de2fa30c96c9e1b3e56dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e2f5cc96e5c4abde5879269220404fdd3e6efca2", "patch": "@@ -1,3 +1,8 @@\n+2015-11-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/67942\n+\t* g++.dg/warn/Wplacement-new-size.C: New test.\n+\n 2015-11-05  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* gcc.dg/pr68112.c: New."}, {"sha": "a8a2a686e559b112a124ef1355a55a121cbfeb1a", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size.C", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2f5cc96e5c4abde5879269220404fdd3e6efca2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size.C?ref=e2f5cc96e5c4abde5879269220404fdd3e6efca2", "patch": "@@ -0,0 +1,410 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wplacement-new -fpermissive\" } */\n+\n+typedef __typeof__ (sizeof 0) size_t;\n+\n+void* operator new (size_t, void *p) { return p; }\n+void* operator new[] (size_t, void *p) { return p; }\n+\n+static __attribute__ ((used))char c;\n+static __attribute__ ((used))char ac1 [1];\n+static __attribute__ ((used))char ac2 [2];\n+static __attribute__ ((used))char ac3 [3];\n+static __attribute__ ((used))char ac4 [4];\n+static __attribute__ ((used))char ac5 [5];\n+static __attribute__ ((used))char ac6 [6];\n+static __attribute__ ((used))char ac7 [7];\n+static __attribute__ ((used))char ac8 [8];\n+\n+static __attribute__ ((used))char ac1_1 [1][1];\n+static __attribute__ ((used))char ac1_2 [1][2];\n+static __attribute__ ((used))char ac2_1 [2][1];\n+static __attribute__ ((used))char ac2_2 [2][2];\n+\n+static __attribute__ ((used))short s;\n+static __attribute__ ((used))short as1 [1];\n+static __attribute__ ((used))short as2 [2];\n+\n+static __attribute__ ((used))struct SC { char c; char *pc; void *pv; } sc;\n+static __attribute__ ((used))struct SAC1 { char ac [1]; } sac1;\n+static __attribute__ ((used))struct SAC2 { char ac [2]; } sac2;\n+static __attribute__ ((used))struct SAC3 { char ac [3]; } sac3;\n+static __attribute__ ((used))struct SAC4 { char ac [4]; } sac4;\n+\n+static __attribute__ ((used))struct SSC { SC sc; int x; } ssc;\n+static __attribute__ ((used))struct SSAC1 { SAC1 sac; } ssac1;\n+static __attribute__ ((used))struct SSAC2 { SAC2 sac; } ssac2;\n+static __attribute__ ((used))struct SSAC3 { SAC3 sac; } ssac3;\n+static __attribute__ ((used))struct SSAC4 { SAC4 sac; } ssac4;\n+\n+static __attribute__ ((used))struct SSAC4_2 { SSAC4 ssac4_2 [2]; } sssac4_2;\n+\n+static __attribute__ ((used))union UAC1 { char c; char ac [1]; } uac1;\n+static __attribute__ ((used))union UAC2 { char c; char ac [2]; } uac2;\n+static __attribute__ ((used))union UAC3 { char c; char ac [3]; } uac3;\n+static __attribute__ ((used))union UAC4 { char c; char ac [4]; } uac4;\n+\n+static __attribute__ ((used))SC fsc ()  { return SC (); }\n+static __attribute__ ((used))SAC1 fasc1 () { return SAC1 (); }\n+static __attribute__ ((used))SAC2 fasc2 () { return SAC2 (); }\n+static __attribute__ ((used))SAC3 fasc3 () { return SAC3 (); }\n+static __attribute__ ((used))SAC4 fasc4 () { return SAC4 (); }\n+\n+static __attribute__ ((used))void *r;\n+\n+static __attribute__ ((used))void* ptr () { return 0; }\n+\n+static __attribute__ ((used))\n+void test (void *p, int n)\n+{\n+    {\n+        void *q = p;\n+        struct { void *p; } s = { p };\n+\n+        // Verify that none of function arguments, local or global\n+        // variables, or function return values trigger the warning.\n+        new (p) char;\n+        new (q) char;\n+        new (r) char;\n+        new (s.p) char;\n+        new (ptr ()) char;\n+\n+        new (p) char [32];\n+        new (q) char [32];\n+        new (r) char [32];\n+        new (s.p) char [32];\n+        new (ptr ()) char [32];\n+\n+        new (&p) char;\n+        new (&q) char;\n+        new (&r) char;\n+\n+        // Using address of objects, however, must trigger the warning.\n+        new (&p) char [32];                 // { dg-warning \"placement\" }\n+        new (&q) char [32];                 // { dg-warning \"placement\" }\n+        new (&r) char [32];                 // { dg-warning \"placement\" }\n+    }\n+\n+    enum { N0, N1, N2, N3 };\n+\n+    new (&c) char;\n+\n+    // Warn for the common case when constructing at an offset from\n+    // the beginning of an array that doesn't leave enough space for\n+    // the object.\n+    new (&c + 0) char;                  // okay\n+    new (&c + n) char;                  // okay (n is unknown)\n+    new (&c + 1) char;                  // { dg-warning \"placement\" }\n+    new (&c + N0) char;\n+    new (&c + N1) char;                 // { dg-warning \"placement\" }\n+\n+    // No warning is issued when constructing an array in space exactly\n+    // its size even though strictly speaking a compiler is allowed to\n+    // add a cookie to the array (gcc does not).\n+    new (&c) char [1];\n+    new (&c) char [sizeof c];\n+    new (&c) char [n];\n+    new (&c) char [1][1];\n+    new (&c) char [1][1][1];\n+    new (&c + N1) char [1][1][1];       // { dg-warning \"placement\" }\n+\n+    new (&c) char [2];                  // { dg-warning \"placement\" }\n+    new (&c) char [sizeof c + 1];       // { dg-warning \"placement\" }\n+    new (&c) char [1][2];               // { dg-warning \"placement\" }\n+    new (&c) char [2][1];               // { dg-warning \"placement\" }\n+    new (&c) char [n][1];\n+    new (&c) char [n][2];               // { dg-warning \"placement\" }\n+    new (&c) char [3];                  // { dg-warning \"placement\" }\n+    new (&c) char [3][1];               // { dg-warning \"placement\" }\n+    new (&c) char [1][3];               // { dg-warning \"placement\" }\n+    new (&c) char [4][1];               // { dg-warning \"placement\" }\n+    new (&c) char [1][4];               // { dg-warning \"placement\" }\n+\n+    // Casts must not suppress it.\n+    new ((void*)&c) char [2];           // { dg-warning \"placement\" }\n+    new ((char*)&c) char [3];           // { dg-warning \"placement\" }\n+\n+    new (static_cast<void*>(&c)) char [4];        // { dg-warning \"placement\" }\n+    new (reinterpret_cast<char*>(&c)) char [5];   // { dg-warning \"placement\" }\n+\n+    new (&c + 0) char [2];              // { dg-warning \"placement\" }\n+    new (&c + 0) char [3];              // { dg-warning \"placement\" }\n+    new (&c + 0) char [4];              // { dg-warning \"placement\" }\n+\n+    new (&c + 1) char [2];              // { dg-warning \"placement\" }\n+    new (&c + 1) char [3];              // { dg-warning \"placement\" }\n+    new (&c + 1) char [4];              // { dg-warning \"placement\" }\n+\n+    new (&c + N0) char [1];\n+    new (&c + N1) char [2];             // { dg-warning \"placement\" }\n+\n+    // Warn even though n is unknown since c is too small for char[2]\n+    // regardless of the value of n.\n+    new (&c + n) char [2];              // { dg-warning \"placement\" }\n+\n+    new (ac2) char [1];\n+    new (ac2) char [1][1];\n+    new (ac2) char [1][2];\n+    new (ac2) char [2][1];\n+    new (ac2) char [1][3];              // { dg-warning \"placement\" }\n+    new (ac2) char [2][2];              // { dg-warning \"placement\" }\n+    new (ac2) char [3][1];              // { dg-warning \"placement\" }\n+\n+    new (ac2 + N0) char [1][1];\n+    new (ac2 + N0) char [1][2];\n+    new (ac2 + N1) char [1][2];         // { dg-warning \"placement\" }\n+    new (ac2 + N1) char [2][1];         // { dg-warning \"placement\" }\n+    new (ac2 + N2) char [1][1];         // { dg-warning \"placement\" }\n+    new (ac2 + N2) char [1][2];         // { dg-warning \"placement\" }\n+    new (ac2 + N2) char [2][1];         // { dg-warning \"placement\" }\n+    new (ac2 + N2) char [2][2];         // { dg-warning \"placement\" }\n+\n+    new (ac8) char [1];\n+    new (ac8) char [2][2];\n+    new (ac8) char [2][3];\n+    new (ac8) char [2][4];\n+    new (ac8) char [2][5];              // { dg-warning \"placement\" }\n+    new (ac8) char [2][2][2];\n+    new (ac8) char [2][2][3];           // { dg-warning \"placement\" }\n+\n+    new (&c) int;                       // { dg-warning \"placement\" }\n+\n+    new (&ac1) int;                     // { dg-warning \"placement\" }\n+    new (&ac2) int;                     // { dg-warning \"placement\" }\n+    new (&ac3) int;                     // { dg-warning \"placement\" }\n+    new (&ac4) int;\n+\n+    // Constructing at an address of an array element.\n+    new (&ac1 [0]) int;                 // { dg-warning \"placement\" }\n+    new (&ac2 [0]) int;                 // { dg-warning \"placement\" }\n+    new (&ac3 [0]) int;                 // { dg-warning \"placement\" }\n+    new (&ac4 [0]) int;\n+\n+    // ...plus or minus a constant offset.\n+    new (&ac1 [0] + 0) int;             // { dg-warning \"placement\" }\n+    new (&ac2 [0] + 0) int;             // { dg-warning \"placement\" }\n+    new (&ac3 [0] + 0) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [0] + 0) int;\n+    new (&ac4 [1] + 0) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [1] - 1) int;\n+    new (&ac4 [2] - 1) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [2] - 2) int;\n+    new (&ac4 [3] - 1) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [3] - 2) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [3] - 3) int;\n+    new (&ac4 [4] - 1) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [4] - 2) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [4] - 3) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [4] - 4) int;\n+\n+    new (&ac1 [0] + 1) int;             // { dg-warning \"placement\" }\n+    new (&ac2 [0] + 1) int;             // { dg-warning \"placement\" }\n+    new (&ac3 [0] + 1) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [0] + 1) int;             // { dg-warning \"placement\" }\n+\n+    new (&ac3 [0] + n) int;             // { dg-warning \"placement\" }\n+    new (&ac4 [0] + n) int;             // no warning (n could be zero)\n+    new (&ac4 [1] + n) int;             // no warning (n could be negative)\n+    new (&ac4 [2] + n) int;             // ditto\n+    new (&ac4 [3] + n) int;             // ditto\n+    new (&ac4 [4] + n) int;             // ditto\n+    new (&ac4 [4] - n) int;             // (or positive)\n+\n+    new (&c + 0) int;                   // { dg-warning \"placement\" }\n+    new (&c + 1) int;                   // { dg-warning \"placement\" }\n+\n+    // Constructing at an offset into the address of an array.\n+    new (&ac1 + 0) int;                 // { dg-warning \"placement\" }\n+    new (&ac1 + 1) int;                 // { dg-warning \"placement\" }\n+    new (&ac1 + n) int;                 // { dg-warning \"placement\" }\n+    new (&ac2 + 0) int;                 // { dg-warning \"placement\" }\n+    new (&ac2 + 1) int;                 // { dg-warning \"placement\" }\n+    new (&ac2 + n) int;                 // { dg-warning \"placement\" }\n+    new (&ac3 + 0) int;                 // { dg-warning \"placement\" }\n+    new (&ac3 + 1) int;                 // { dg-warning \"placement\" }\n+\n+    // Even though n below is uknown an array of 3 bytes isn't large\n+    // enugh for an int.\n+    new (&ac3 + n) int;                 // { dg-warning \"placement\" }\n+\n+    new (&ac4 + 0) int;\n+    new (&ac4 + 1) int;                 // { dg-warning \"placement\" }\n+    new (&ac4 + n) int;                 // no warning (n could be zero)\n+\n+    // Constructing in an array object.\n+    new (ac1) int;                      // { dg-warning \"placement\" }\n+    new (ac2) int;                      // { dg-warning \"placement\" }\n+    new (ac3) int;                      // { dg-warning \"placement\" }\n+    new (ac4) int;\n+    new (ac5) int;\n+    new (ac5 + 0) int;\n+    new (ac5 + 1) int;\n+    new (ac5 + n) int;                  // no warning (n could be zero)\n+    new (ac5 + 2) int;                  // { dg-warning \"placement\" }\n+    new (ac5 + 3) int;                  // { dg-warning \"placement\" }\n+    new (ac5 + 4) int;                  // { dg-warning \"placement\" }\n+    new (ac5 + 5) int;                  // { dg-warning \"placement\" }\n+\n+    new (ac1_1) char;\n+    new (ac1_1) char[1];\n+    new (ac1_1) char[n];                // no warning (n is unknown)\n+    new (ac1_1) char[2];                // { dg-warning \"placement\" }\n+    new (ac1_1) char[3];                // { dg-warning \"placement\" }\n+\n+    new (ac1_2) char;\n+    new (ac1_2) char[1];\n+    new (ac1_2) char[2];\n+    new (ac1_2) char[3];                // { dg-warning \"placement\" }\n+\n+    new (ac2_1) char;\n+    new (ac2_1) char[1];\n+    new (ac2_1) char[2];\n+    new (ac2_1) char[3];                // { dg-warning \"placement\" }\n+\n+    new (ac2_2) char;\n+    new (ac2_2) char[1];\n+    new (ac2_2) char[2];\n+    new (ac2_2) char[2][2];\n+\n+    // Even though n below is uknown it can't meaningfully be zero\n+    // (even if zero-size arrays are allowed as an extension, the size\n+    // they are allocated in by placement new is zero).\n+    new (ac1_1) char[n][2];             // { dg-warning \"placement\" }\n+    new (ac2_2) char[3];\n+    new (ac2_2) char[3][1];\n+    new (ac2_2) char[3][2];             // { dg-warning \"placement\" }\n+    new (ac2_2) char[4];\n+    new (ac2_2) char[4][1];\n+    new (ac2_2) char[4][2];             // { dg-warning \"placement\" }\n+    new (ac2_2) char[5];                // { dg-warning \"placement\" }\n+\n+    new (&s) int;                       // { dg-warning \"placement\" }\n+    new (&as1) int;                     // { dg-warning \"placement\" }\n+    new (&as2) int;\n+\n+    new (as1) int;                      // { dg-warning \"placement\" }\n+    new (as2) int;\n+\n+    new (&sc.c) int;                    // { dg-warning \"placement\" }\n+    new (&sac1.ac) int;                 // { dg-warning \"placement\" }\n+    new (&sac2.ac) int;                 // { dg-warning \"placement\" }\n+    new (&sac3.ac) int;                 // { dg-warning \"placement\" }\n+    new (&sac4.ac) int;\n+\n+    new (sc.pc) char;\n+    new (sc.pc) int;\n+    new (sc.pc) int[1024];\n+    new (sc.pc + 0) int;\n+    new (sc.pc + 0) int[2048];\n+    new (sc.pv) int;\n+    new (sc.pv) char[1024];\n+\n+    new (sac1.ac) int;                  // { dg-warning \"placement\" }\n+    new (sac2.ac) int;                  // { dg-warning \"placement\" }\n+    new (sac3.ac) int;                  // { dg-warning \"placement\" }\n+    new (sac4.ac) int;\n+\n+    new (&ssc.sc) SSC;                  // { dg-warning \"placement\" }\n+    new (&ssac1.sac) int;               // { dg-warning \"placement\" }\n+    new (&ssac2.sac) int;               // { dg-warning \"placement\" }\n+    new (&ssac3.sac) int;               // { dg-warning \"placement\" }\n+    new (&ssac4.sac) int;\n+\n+    new (&sssac4_2) char[sizeof sssac4_2];\n+    new (&sssac4_2) char[sizeof sssac4_2 + 1];   // { dg-warning \"placement\" }\n+\n+    // taking the address of a temporary is allowed with -fpermissive\n+    new (&fsc ().c) int;                // { dg-warning \"address|placement\" }\n+    new (&fasc1 ().ac) int;             // { dg-warning \"address|placement\" }\n+    new (&fasc2 ().ac) int;             // { dg-warning \"address|placement\" }\n+    new (&fasc3 ().ac) int;             // { dg-warning \"address|placement\" }\n+    new (&fasc4 ().ac) int;             // { dg-warning \"address|placement\" }\n+\n+    new (&uac1) int;                    // { dg-warning \"placement\" }\n+    new (&uac2) int;                    // { dg-warning \"placement\" }\n+    new (&uac3) int;                    // { dg-warning \"placement\" }\n+    new (&uac4) int;\n+    new (&uac4 + 1) int;                // { dg-warning \"placement\" }\n+\n+    new (&uac1.c) int;                  // { dg-warning \"placement\" }\n+    new (&uac2.c) int;                  // { dg-warning \"placement\" }\n+    new (&uac3.c) int;                  // { dg-warning \"placement\" }\n+\n+    // Diagnose the following even though the size of uac4.c could be\n+    // expected to extend to the end of the union (as it is by Built-in\n+    // Object Size and so isn't diagnosed in calls to functions like\n+    // memset(&uac4.c, 0, sizeof(int)) when _FORTIFY_SOURCE is non-zero.  */\n+    new (&uac4.c) int;                  // { dg-warning \"placement\" }\n+\n+    new (&uac4.c + 1) int;              // { dg-warning \"placement\" }\n+}\n+\n+\n+struct S { char c [2]; };\n+\n+// Verify the full text of the warning message.\n+static  __attribute__ ((used))\n+void test_message (int i)\n+{\n+    char a [2];\n+\n+    // The exact sizes of both the buffer and the type are known.\n+    new (a + 1) S;         // { dg-warning \"placement new constructing an object of type .S. and size .2. in a region of type .char \\\\\\[2\\\\\\]. and size .1.\" }\n+\n+    // The buffer size is known but only the size of the type whose\n+    // objects are being constructed is known, not their number.  While\n+    // in theory it could be zero, it practice likely never will be so\n+    // the potential false positive is acceptable.\n+    new (a + 1) S [i];  // { dg-warning \"placement new constructing an array of objects of type .S. and size .2. in a region of type .char \\\\\\[2\\\\\\]. and size .1.\" }\n+\n+    // The exact amount of space in the buffer isn't known, only its\n+    // maximum is.  The exact size of the array being created is known.\n+    new (a + i) S [2];  // { dg-warning \"placement new constructing an object of type .S \\\\\\[2\\\\\\]. and size .4. in a region of type .char \\\\\\[2\\\\\\]. and size at most .2.\" }\n+}\n+\n+\n+struct ClassWithMemberNew {\n+    struct Object { int i; } *pobj;\n+    unsigned nobj;\n+\n+    ClassWithMemberNew ();\n+    void foo ();\n+\n+    void* operator new (size_t, void*);\n+    void* operator new[] (size_t, void*);\n+};\n+\n+void ClassWithMemberNew::foo()\n+{\n+    for (unsigned i = 0; i != nobj; ++i)\n+        new (pobj + i) Object ();\n+}\n+\n+\n+struct ClassWithGlobalNew {\n+    int a [4];\n+    ClassWithGlobalNew ();\n+};\n+\n+void* operator new (size_t, ClassWithGlobalNew*);\n+void* operator new[] (size_t, ClassWithGlobalNew*);\n+\n+void test_user_defined_placement_new ()\n+{\n+    {\n+        ClassWithMemberNew x;\n+\n+        // Expect no diagnostics for placement new expressions with types\n+        // with their own placement operator new since the semantics of\n+        // the operator aren't known.\n+        new (&c) ClassWithMemberNew;\n+        new (&x) ClassWithMemberNew[2];\n+    }\n+\n+    {\n+        ClassWithGlobalNew x;\n+\n+        new (&c) ClassWithGlobalNew;    // { dg-warning \"placement\" }\n+        new (&x) ClassWithGlobalNew[2];\n+    }\n+}"}]}