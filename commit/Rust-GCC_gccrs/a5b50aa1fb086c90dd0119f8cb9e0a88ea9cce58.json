{"sha": "a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTViNTBhYTFmYjA4NmM5MGRkMDExOWY4Y2I5ZTBhODhlYTljY2U1OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-11-11T14:40:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-11-11T14:40:36Z"}, "message": "tree-vectorizer.h (vect_slp_analyze_and_verify_instance_alignment): Declare.\n\n2015-11-11  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_slp_analyze_and_verify_instance_alignment):\n\tDeclare.\n\t(vect_analyze_data_refs_alignment): Make loop vect specific.\n\t(vect_verify_datarefs_alignment): Likewise.\n\t* tree-vect-data-refs.c (vect_slp_analyze_data_ref_dependences):\n\tAdd missing continue.\n\t(vect_compute_data_ref_alignment): Export.\n\t(vect_compute_data_refs_alignment): Merge into...\n\t(vect_analyze_data_refs_alignment): ... this.\n\t(verify_data_ref_alignment): Split out from ...\n\t(vect_verify_datarefs_alignment): ... here.\n\t(vect_slp_analyze_and_verify_node_alignment): New function.\n\t(vect_slp_analyze_and_verify_instance_alignment): Likewise.\n\t* tree-vect-slp.c (vect_supported_load_permutation_p): Remove\n\tmisplaced checks on alignment.\n\t(vect_slp_analyze_bb_1): Add fatal output parameter.  Do\n\talignment analysis after SLP discovery and do it per instance.\n\t(vect_slp_bb): When vect_slp_analyze_bb_1 fatally failed do not\n\tbother to re-try using different vector sizes.\n\nFrom-SVN: r230173", "tree": {"sha": "2e35311f616d252ce5c52cd20fc09da4b3cb5d03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e35311f616d252ce5c52cd20fc09da4b3cb5d03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ac93c7cf665ea0dfb2313ccd8216afb9a4a5763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ac93c7cf665ea0dfb2313ccd8216afb9a4a5763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ac93c7cf665ea0dfb2313ccd8216afb9a4a5763"}], "stats": {"total": 378, "additions": 225, "deletions": 153}, "files": [{"sha": "ba87dcb4bd7174e1f1cb6cc88069ff11634ca9c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58", "patch": "@@ -1,3 +1,25 @@\n+2015-11-11  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_slp_analyze_and_verify_instance_alignment):\n+\tDeclare.\n+\t(vect_analyze_data_refs_alignment): Make loop vect specific.\n+\t(vect_verify_datarefs_alignment): Likewise.\n+\t* tree-vect-data-refs.c (vect_slp_analyze_data_ref_dependences):\n+\tAdd missing continue.\n+\t(vect_compute_data_ref_alignment): Export.\n+\t(vect_compute_data_refs_alignment): Merge into...\n+\t(vect_analyze_data_refs_alignment): ... this.\n+\t(verify_data_ref_alignment): Split out from ...\n+\t(vect_verify_datarefs_alignment): ... here.\n+\t(vect_slp_analyze_and_verify_node_alignment): New function.\n+\t(vect_slp_analyze_and_verify_instance_alignment): Likewise.\n+\t* tree-vect-slp.c (vect_supported_load_permutation_p): Remove\n+\tmisplaced checks on alignment.\n+\t(vect_slp_analyze_bb_1): Add fatal output parameter.  Do\n+\talignment analysis after SLP discovery and do it per instance.\n+\t(vect_slp_bb): When vect_slp_analyze_bb_1 fatally failed do not\n+\tbother to re-try using different vector sizes.\n+\n 2015-11-11  Nathan Sidwell  <nathan@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "f7471b8a75ed21f1e83a6c9e5d11dbaf5a4b638d", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 144, "deletions": 97, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58", "patch": "@@ -645,6 +645,7 @@ vect_slp_analyze_data_ref_dependences (bb_vec_info bb_vinfo)\n \t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n \t  vect_free_slp_instance (instance);\n \t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n+\t  continue;\n \t}\n       i++;\n     }\n@@ -668,7 +669,7 @@ vect_slp_analyze_data_ref_dependences (bb_vec_info bb_vinfo)\n    FOR NOW: No analysis is actually performed. Misalignment is calculated\n    only for trivial cases. TODO.  */\n \n-static bool\n+bool\n vect_compute_data_ref_alignment (struct data_reference *dr)\n {\n   gimple *stmt = DR_STMT (dr);\n@@ -838,45 +839,6 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n }\n \n \n-/* Function vect_compute_data_refs_alignment\n-\n-   Compute the misalignment of data references in the loop.\n-   Return FALSE if a data reference is found that cannot be vectorized.  */\n-\n-static bool\n-vect_compute_data_refs_alignment (vec_info *vinfo)\n-{\n-  vec<data_reference_p> datarefs = vinfo->datarefs;\n-  struct data_reference *dr;\n-  unsigned int i;\n-\n-  FOR_EACH_VEC_ELT (datarefs, i, dr)\n-    {\n-      stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n-      if (STMT_VINFO_VECTORIZABLE (stmt_info)\n-\t  && !vect_compute_data_ref_alignment (dr))\n-\t{\n-\t  /* Strided accesses perform only component accesses, misalignment\n-\t     information is irrelevant for them.  */\n-\t  if (STMT_VINFO_STRIDED_P (stmt_info)\n-\t      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-\t    continue;\n-\n-\t  if (is_a <bb_vec_info> (vinfo))\n-\t    {\n-\t      /* Mark unsupported statement as unvectorizable.  */\n-\t      STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) = false;\n-\t      continue;\n-\t    }\n-\t  else\n-\t    return false;\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n-\n /* Function vect_update_misalignment_for_peel\n \n    DR - the data reference whose misalignment is to be adjusted.\n@@ -936,63 +898,76 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n }\n \n \n+/* Function verify_data_ref_alignment\n+\n+   Return TRUE if DR can be handled with respect to alignment.  */\n+\n+static bool\n+verify_data_ref_alignment (data_reference_p dr)\n+{\n+  enum dr_alignment_support supportable_dr_alignment;\n+  gimple *stmt = DR_STMT (dr);\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return true;\n+\n+  /* For interleaving, only the alignment of the first access matters. \n+     Skip statements marked as not vectorizable.  */\n+  if ((STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+       && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n+      || !STMT_VINFO_VECTORIZABLE (stmt_info))\n+    return true;\n+\n+  /* Strided accesses perform only component accesses, alignment is\n+     irrelevant for them.  */\n+  if (STMT_VINFO_STRIDED_P (stmt_info)\n+      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    return true;\n+\n+  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n+  if (!supportable_dr_alignment)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  if (DR_IS_READ (dr))\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: unsupported unaligned load.\");\n+\t  else\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: unsupported unaligned \"\n+\t\t\t     \"store.\");\n+\n+\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t     DR_REF (dr));\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t}\n+      return false;\n+    }\n+\n+  if (supportable_dr_alignment != dr_aligned && dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"Vectorizing an unaligned access.\\n\");\n+\n+  return true;\n+}\n+\n /* Function vect_verify_datarefs_alignment\n \n    Return TRUE if all data references in the loop can be\n    handled with respect to alignment.  */\n \n bool\n-vect_verify_datarefs_alignment (vec_info *vinfo)\n+vect_verify_datarefs_alignment (loop_vec_info vinfo)\n {\n   vec<data_reference_p> datarefs = vinfo->datarefs;\n   struct data_reference *dr;\n-  enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n-    {\n-      gimple *stmt = DR_STMT (dr);\n-      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\n-      if (!STMT_VINFO_RELEVANT_P (stmt_info))\n-\tcontinue;\n-\n-      /* For interleaving, only the alignment of the first access matters. \n-         Skip statements marked as not vectorizable.  */\n-      if ((STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-           && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n-          || !STMT_VINFO_VECTORIZABLE (stmt_info))\n-        continue;\n-\n-      /* Strided accesses perform only component accesses, alignment is\n-\t irrelevant for them.  */\n-      if (STMT_VINFO_STRIDED_P (stmt_info)\n-\t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-\tcontinue;\n-\n-      supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n-      if (!supportable_dr_alignment)\n-        {\n-          if (dump_enabled_p ())\n-            {\n-              if (DR_IS_READ (dr))\n-                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                 \"not vectorized: unsupported unaligned load.\");\n-              else\n-                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                 \"not vectorized: unsupported unaligned \"\n-                                 \"store.\");\n+    if (! verify_data_ref_alignment (dr))\n+      return false;\n \n-              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-                                 DR_REF (dr));\n-              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-            }\n-          return false;\n-        }\n-      if (supportable_dr_alignment != dr_aligned && dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"Vectorizing an unaligned access.\\n\");\n-    }\n   return true;\n }\n \n@@ -2064,36 +2039,108 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n    Return FALSE if a data reference is found that cannot be vectorized.  */\n \n bool\n-vect_analyze_data_refs_alignment (vec_info *vinfo)\n+vect_analyze_data_refs_alignment (loop_vec_info vinfo)\n {\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_data_refs_alignment ===\\n\");\n \n   /* Mark groups of data references with same alignment using\n      data dependence information.  */\n-  if (is_a <loop_vec_info> (vinfo))\n+  vec<ddr_p> ddrs = vinfo->ddrs;\n+  struct data_dependence_relation *ddr;\n+  unsigned int i;\n+\n+  FOR_EACH_VEC_ELT (ddrs, i, ddr)\n+    vect_find_same_alignment_drs (ddr, vinfo);\n+\n+  vec<data_reference_p> datarefs = vinfo->datarefs;\n+  struct data_reference *dr;\n+\n+  FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n-      vec<ddr_p> ddrs = vinfo->ddrs;\n-      struct data_dependence_relation *ddr;\n-      unsigned int i;\n+      stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n+      if (STMT_VINFO_VECTORIZABLE (stmt_info)\n+\t  && !vect_compute_data_ref_alignment (dr))\n+\t{\n+\t  /* Strided accesses perform only component accesses, misalignment\n+\t     information is irrelevant for them.  */\n+\t  if (STMT_VINFO_STRIDED_P (stmt_info)\n+\t      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+\t    continue;\n+\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: can't calculate alignment \"\n+\t\t\t     \"for data ref.\\n\");\n \n-      FOR_EACH_VEC_ELT (ddrs, i, ddr)\n-\tvect_find_same_alignment_drs (ddr, as_a <loop_vec_info> (vinfo));\n+\t  return false;\n+\t}\n     }\n \n-  if (!vect_compute_data_refs_alignment (vinfo))\n+  return true;\n+}\n+\n+\n+/* Analyze alignment of DRs of stmts in NODE.  */\n+\n+static bool\n+vect_slp_analyze_and_verify_node_alignment (slp_tree node)\n+{\n+  unsigned i;\n+  gimple *stmt;\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t                 \"not vectorized: can't calculate alignment \"\n-\t                 \"for data ref.\\n\");\n-      return false;\n+      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+      /* Strided accesses perform only component accesses, misalignment\n+\t information is irrelevant for them.  */\n+      if (STMT_VINFO_STRIDED_P (stmt_info)\n+\t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+\tcontinue;\n+\n+      data_reference_p dr = STMT_VINFO_DATA_REF (stmt_info);\n+      if (! vect_compute_data_ref_alignment (dr)\n+\t  || ! verify_data_ref_alignment (dr))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: bad data alignment in basic \"\n+\t\t\t     \"block.\\n\");\n+\t  return false;\n+\t}\n     }\n \n   return true;\n }\n \n+/* Function vect_slp_analyze_instance_alignment\n+\n+   Analyze the alignment of the data-references in the SLP instance.\n+   Return FALSE if a data reference is found that cannot be vectorized.  */\n+\n+bool\n+vect_slp_analyze_and_verify_instance_alignment (slp_instance instance)\n+{\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+                     \"=== vect_slp_analyze_and_verify_instance_alignment ===\\n\");\n+\n+  slp_tree node;\n+  unsigned i;\n+  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), i, node)\n+    if (! vect_slp_analyze_and_verify_node_alignment (node))\n+      return false;\n+\n+  node = SLP_INSTANCE_TREE (instance);\n+  if (STMT_VINFO_DATA_REF (vinfo_for_stmt (SLP_TREE_SCALAR_STMTS (node)[0]))\n+      && ! vect_slp_analyze_and_verify_node_alignment\n+\t     (SLP_INSTANCE_TREE (instance)))\n+    return false;\n+\n+  return true;\n+}\n+\n \n /* Analyze groups of accesses: check that DR belongs to a group of\n    accesses of legal size, step, etc.  Detect gaps, single element"}, {"sha": "75875f333ada9b0d4d91a9f079cdc80ae9e30351", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58", "patch": "@@ -1282,8 +1282,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n   unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n   unsigned int i, j, k, next;\n   slp_tree node;\n-  gimple *stmt, *load, *next_load, *first_load;\n-  struct data_reference *dr;\n+  gimple *stmt, *load, *next_load;\n \n   if (dump_enabled_p ())\n     {\n@@ -1365,33 +1364,6 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \t\t}\n \t    }\n         }\n-\n-      /* Check that the alignment of the first load in every subchain, i.e.,\n-         the first statement in every load node, is supported.\n-\t ???  This belongs in alignment checking.  */\n-      FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n-\t{\n-\t  first_load = SLP_TREE_SCALAR_STMTS (node)[0];\n-\t  if (first_load != GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_load)))\n-\t    {\n-\t      dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_load));\n-\t      if (vect_supportable_dr_alignment (dr, false)\n-\t\t  == dr_unaligned_unsupported)\n-\t\t{\n-\t\t  if (dump_enabled_p ())\n-\t\t    {\n-\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t       vect_location,\n-\t\t\t\t       \"unsupported unaligned load \");\n-\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\tfirst_load, 0);\n-                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-\t\t    }\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\t}\n-\n       return true;\n     }\n \n@@ -2311,19 +2283,25 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   return true;\n }\n \n-/* Check if the basic block can be vectorized.  */\n+/* Check if the basic block can be vectorized.  Returns a bb_vec_info\n+   if so and sets fatal to true if failure is independent of\n+   current_vector_size.  */\n \n static bb_vec_info\n vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n \t\t       gimple_stmt_iterator region_end,\n-\t\t       vec<data_reference_p> datarefs, int n_stmts)\n+\t\t       vec<data_reference_p> datarefs, int n_stmts,\n+\t\t       bool &fatal)\n {\n   bb_vec_info bb_vinfo;\n   vec<slp_instance> slp_instances;\n   slp_instance instance;\n   int i;\n   int min_vf = 2;\n \n+  /* The first group of checks is independent of the vector size.  */\n+  fatal = true;\n+\n   if (n_stmts > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n     {\n       if (dump_enabled_p ())\n@@ -2375,19 +2353,25 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       return NULL;\n     }\n \n-  vect_pattern_recog (bb_vinfo);\n-\n-  if (!vect_analyze_data_refs_alignment (bb_vinfo))\n+  /* If there are no grouped stores in the region there is no need\n+     to continue with pattern recog as vect_analyze_slp will fail\n+     anyway.  */\n+  if (bb_vinfo->grouped_stores.is_empty ())\n     {\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: bad data alignment in basic \"\n-\t\t\t \"block.\\n\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: no grouped stores in \"\n+\t\t\t \"basic block.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n     }\n \n+  /* While the rest of the analysis below depends on it in some way.  */\n+  fatal = false;\n+\n+  vect_pattern_recog (bb_vinfo);\n+\n   /* Check the SLP opportunities in the basic block, analyze and build SLP\n      trees.  */\n   if (!vect_analyze_slp (bb_vinfo, n_stmts))\n@@ -2405,6 +2389,30 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n       return NULL;\n     }\n \n+  /* Analyze and verify the alignment of data references in the SLP\n+     instances.  */\n+  for (i = 0; BB_VINFO_SLP_INSTANCES (bb_vinfo).iterate (i, &instance); )\n+    {\n+      if (! vect_slp_analyze_and_verify_instance_alignment (instance))\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"removing SLP instance operations starting from: \");\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n+\t\t\t    SLP_TREE_SCALAR_STMTS\n+\t\t\t      (SLP_INSTANCE_TREE (instance))[0], 0);\n+\t  vect_free_slp_instance (instance);\n+\t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n+\t  continue;\n+\t}\n+      i++;\n+    }\n+\n+  if (! BB_VINFO_SLP_INSTANCES (bb_vinfo).length ())\n+    {\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n   slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n \n   /* Mark all the statements that we want to vectorize as pure SLP and\n@@ -2427,23 +2435,13 @@ vect_slp_analyze_bb_1 (gimple_stmt_iterator region_begin,\n   /* Analyze dependences.  At this point all stmts not participating in\n      vectorization have to be marked.  Dependence analysis assumes\n      that we either vectorize all SLP instances or none at all.  */\n-  if (!vect_slp_analyze_data_ref_dependences (bb_vinfo))\n-     {\n-       if (dump_enabled_p ())\n-\t dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t  \"not vectorized: unhandled data dependence \"\n-\t\t\t  \"in basic block.\\n\");\n-\n-       destroy_bb_vec_info (bb_vinfo);\n-       return NULL;\n-     }\n-\n-  if (!vect_verify_datarefs_alignment (bb_vinfo))\n+  if (! vect_slp_analyze_data_ref_dependences (bb_vinfo))\n     {\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not vectorized: unsupported alignment in basic \"\n-                         \"block.\\n\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: unhandled data dependence \"\n+\t\t\t \"in basic block.\\n\");\n+\n       destroy_bb_vec_info (bb_vinfo);\n       return NULL;\n     }\n@@ -2533,8 +2531,9 @@ vect_slp_bb (basic_block bb)\n       gimple_stmt_iterator region_end = gsi;\n \n       bool vectorized = false;\n+      bool fatal = false;\n       bb_vinfo = vect_slp_analyze_bb_1 (region_begin, region_end,\n-\t\t\t\t\tdatarefs, insns);\n+\t\t\t\t\tdatarefs, insns, fatal);\n       if (bb_vinfo\n \t  && dbg_cnt (vect_slp))\n \t{\n@@ -2559,7 +2558,10 @@ vect_slp_bb (basic_block bb)\n       vector_sizes &= ~current_vector_size;\n       if (vectorized\n \t  || vector_sizes == 0\n-\t  || current_vector_size == 0)\n+\t  || current_vector_size == 0\n+\t  /* If vect_slp_analyze_bb_1 signaled that analysis for all\n+\t     vector sizes will fail do not bother iterating.  */\n+\t  || fatal)\n \t{\n \t  if (gsi_end_p (region_end))\n \t    break;"}, {"sha": "eaeeb05f2a25d6c91c00c4305aa8c6e04084ab35", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a5b50aa1fb086c90dd0119f8cb9e0a88ea9cce58", "patch": "@@ -1011,8 +1011,9 @@ extern tree vect_get_smallest_scalar_type (gimple *, HOST_WIDE_INT *,\n extern bool vect_analyze_data_ref_dependences (loop_vec_info, int *);\n extern bool vect_slp_analyze_data_ref_dependences (bb_vec_info);\n extern bool vect_enhance_data_refs_alignment (loop_vec_info);\n-extern bool vect_analyze_data_refs_alignment (vec_info *);\n-extern bool vect_verify_datarefs_alignment (vec_info *);\n+extern bool vect_analyze_data_refs_alignment (loop_vec_info);\n+extern bool vect_verify_datarefs_alignment (loop_vec_info);\n+extern bool vect_slp_analyze_and_verify_instance_alignment (slp_instance);\n extern bool vect_analyze_data_ref_accesses (vec_info *);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern tree vect_check_gather_scatter (gimple *, loop_vec_info, tree *, tree *,"}]}