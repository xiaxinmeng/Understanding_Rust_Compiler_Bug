{"sha": "636dff67dd28fc952990b83580ffd96f6508a338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM2ZGZmNjdkZDI4ZmM5NTI5OTBiODM1ODBmZmQ5NmY2NTA4YTMzOA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-07T19:39:52Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-07T19:39:52Z"}, "message": "decl.c, [...]: Update Copyright dates.\n\n2007-01-07  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n    * decl.c, dump-parse-tree.c, error.c, data.c, expr.c, dependency.c,\n    convert.c:  Update Copyright dates.  Fix whitespace.\n\nFrom-SVN: r120552", "tree": {"sha": "e2633becc84e13a77c5ae809cc07bf460e685f59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2633becc84e13a77c5ae809cc07bf460e685f59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/636dff67dd28fc952990b83580ffd96f6508a338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636dff67dd28fc952990b83580ffd96f6508a338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636dff67dd28fc952990b83580ffd96f6508a338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636dff67dd28fc952990b83580ffd96f6508a338/comments", "author": null, "committer": null, "parents": [{"sha": "cd85e27a61d61fd365ad5a91f7613de78972c065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd85e27a61d61fd365ad5a91f7613de78972c065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd85e27a61d61fd365ad5a91f7613de78972c065"}], "stats": {"total": 1362, "additions": 645, "deletions": 717}, "files": [{"sha": "0eb50bc43f00b75ed01ae3f7b1feb6868d50da6e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=636dff67dd28fc952990b83580ffd96f6508a338", "patch": "@@ -1,3 +1,8 @@\n+2007-01-07  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* decl.c, dump-parse-tree.c, error.c, data.c, expr.c, dependency.c,\n+\tconvert.c:  Update Copyright dates.  Fix whitespace.\n+\n 2007-01-07  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \t* data.c (gfc_assign_data_value): Fix whitespace."}, {"sha": "b0c4d4550c8913cbc73fc35b935b5f4d885bbd13", "filename": "gcc/fortran/convert.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconvert.c?ref=636dff67dd28fc952990b83580ffd96f6508a338", "patch": "@@ -1,5 +1,6 @@\n /* Language-level data type conversion for GNU C.\n-   Copyright (C) 1987, 1988, 1991, 1998, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991, 1998, 2002, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -57,9 +58,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n      In expr.c: expand_expr, for operands of a MULT_EXPR.\n      In fold-const.c: fold.\n      In tree.c: get_narrower and get_unwidened.  */\n-\f\n+\n /* Subroutines of `convert'.  */\n-\f\n \n \n /* Create an expression whose value is that of EXPR,\n@@ -104,7 +104,7 @@ convert (tree type, tree expr)\n       e = gfc_truthvalue_conversion (e);\n \n       /* If we have a NOP_EXPR, we must fold it here to avoid\n-         infinite recursion between fold () and convert ().  */\n+\t infinite recursion between fold () and convert ().  */\n       if (TREE_CODE (e) == NOP_EXPR)\n \treturn fold_build1 (NOP_EXPR, type, TREE_OPERAND (e, 0));\n       else"}, {"sha": "70a715127df2e9f8d83bc3426e9cf2babaaba563", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 118, "deletions": 111, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=636dff67dd28fc952990b83580ffd96f6508a338", "patch": "@@ -1,6 +1,6 @@\n /* Supporting functions for resolving DATA statement.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Lifang Zeng <zlf605@hotmail.com>\n \n This file is part of GCC.\n@@ -22,14 +22,14 @@ Software Foundation, 51 Franklin Street, Fifth Floor,Boston, MA\n \n \n /* Notes for DATA statement implementation:\n-                                                                               \n+\t\t\t\t\t\t\t\t\t       \n    We first assign initial value to each symbol by gfc_assign_data_value\n    during resolveing DATA statement. Refer to check_data_variable and\n    traverse_data_list in resolve.c.\n-                                                                               \n+\t\t\t\t\t\t\t\t\t       \n    The complexity exists in the handling of array section, implied do\n    and array of struct appeared in DATA statement.\n-                                                                               \n+\t\t\t\t\t\t\t\t\t       \n    We call gfc_conv_structure, gfc_con_array_array_initializer,\n    etc., to convert the initial value. Refer to trans-expr.c and\n    trans-array.c.  */\n@@ -42,7 +42,7 @@ static void formalize_init_expr (gfc_expr *);\n /* Calculate the array element offset.  */\n \n static void\n-get_array_index (gfc_array_ref * ar, mpz_t * offset)\n+get_array_index (gfc_array_ref *ar, mpz_t *offset)\n {\n   gfc_expr *e;\n   int i;\n@@ -61,14 +61,15 @@ get_array_index (gfc_array_ref * ar, mpz_t * offset)\n       if ((gfc_is_constant_expr (ar->as->lower[i]) == 0)\n \t  || (gfc_is_constant_expr (ar->as->upper[i]) == 0)\n \t  || (gfc_is_constant_expr (e) == 0))\n-\tgfc_error (\"non-constant array in DATA statement %L\", &ar->where);        \n+\tgfc_error (\"non-constant array in DATA statement %L\", &ar->where);\n+\n       mpz_set (tmp, e->value.integer);\n       mpz_sub (tmp, tmp, ar->as->lower[i]->value.integer);\n       mpz_mul (tmp, tmp, delta);\n       mpz_add (*offset, tmp, *offset);\n \n       mpz_sub (tmp, ar->as->upper[i]->value.integer,\n-      ar->as->lower[i]->value.integer);\n+\t       ar->as->lower[i]->value.integer);\n       mpz_add_ui (tmp, tmp, 1);\n       mpz_mul (delta, tmp, delta);\n     }\n@@ -87,39 +88,40 @@ find_con_by_offset (splay_tree spt, mpz_t offset)\n   gfc_constructor *con;\n   splay_tree_node sptn;\n \n-/* The complexity is due to needing quick access to the linked list of\n-   constructors.  Both a linked list and a splay tree are used, and both are\n-   kept up to date if they are array elements (which is the only time that\n-   a specific constructor has to be found).  */  \n+  /* The complexity is due to needing quick access to the linked list of\n+     constructors.  Both a linked list and a splay tree are used, and both\n+     are kept up to date if they are array elements (which is the only time\n+     that a specific constructor has to be found).  */  \n \n   gcc_assert (spt != NULL);\n   mpz_init (tmp);\n \n-  sptn = splay_tree_lookup (spt, (splay_tree_key) mpz_get_si(offset));\n+  sptn = splay_tree_lookup (spt, (splay_tree_key) mpz_get_si (offset));\n \n   if (sptn)\n     ret = (gfc_constructor*) sptn->value;  \n   else\n     {\n        /* Need to check and see if we match a range, so we will pull\n-          the next lowest index and see if the range matches.  */\n-       sptn = splay_tree_predecessor (spt, (splay_tree_key) mpz_get_si(offset));\n+\t  the next lowest index and see if the range matches.  */\n+       sptn = splay_tree_predecessor (spt,\n+\t\t\t\t      (splay_tree_key) mpz_get_si (offset));\n        if (sptn)\n-         {\n-            con = (gfc_constructor*) sptn->value;\n-            if (mpz_cmp_ui (con->repeat, 1) > 0)\n-              {\n-                 mpz_init (tmp);\n-                 mpz_add (tmp, con->n.offset, con->repeat);\n-                 if (mpz_cmp (offset, tmp) < 0)\n-                   ret = con;\n-                 mpz_clear (tmp);\n-              }\n-            else \n-              ret = NULL; /* The range did not match.  */\n-         }\n+\t {\n+\t    con = (gfc_constructor*) sptn->value;\n+\t    if (mpz_cmp_ui (con->repeat, 1) > 0)\n+\t      {\n+\t\t mpz_init (tmp);\n+\t\t mpz_add (tmp, con->n.offset, con->repeat);\n+\t\t if (mpz_cmp (offset, tmp) < 0)\n+\t\t   ret = con;\n+\t\t mpz_clear (tmp);\n+\t      }\n+\t    else \n+\t      ret = NULL; /* The range did not match.  */\n+\t }\n       else\n-        ret = NULL; /* No pred, so no match.  */\n+\tret = NULL; /* No pred, so no match.  */\n     }\n \n   return ret;\n@@ -134,7 +136,7 @@ find_con_by_component (gfc_component *com, gfc_constructor *con)\n   for (; con; con = con->next)\n     {\n       if (com == con->n.component)\n-        return con;\n+\treturn con;\n     }\n   return NULL;\n }\n@@ -146,8 +148,8 @@ find_con_by_component (gfc_component *com, gfc_constructor *con)\n    according to normal assignment rules.  */\n \n static gfc_expr *\n-create_character_intializer (gfc_expr * init, gfc_typespec * ts,\n-\t\t\t     gfc_ref * ref, gfc_expr * rvalue)\n+create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n+\t\t\t     gfc_ref *ref, gfc_expr *rvalue)\n {\n   int len;\n   int start;\n@@ -181,14 +183,14 @@ create_character_intializer (gfc_expr * init, gfc_typespec * ts,\n       gcc_assert (ref->type == REF_SUBSTRING);\n \n       /* Only set a substring of the destination.  Fortran substring bounds\n-         are one-based [start, end], we want zero based [start, end).  */\n+\t are one-based [start, end], we want zero based [start, end).  */\n       start_expr = gfc_copy_expr (ref->u.ss.start);\n       end_expr = gfc_copy_expr (ref->u.ss.end);\n \n       if ((gfc_simplify_expr (start_expr, 1) == FAILURE)\n-\t     || (gfc_simplify_expr (end_expr, 1)) == FAILURE)\n+\t  || (gfc_simplify_expr (end_expr, 1)) == FAILURE)\n \t{\n-\t  gfc_error (\"failure to simplify substring reference in DATA\"\n+\t  gfc_error (\"failure to simplify substring reference in DATA \"\n \t\t     \"statement at %L\", &ref->u.ss.start->where);\n \t  return NULL;\n \t}\n@@ -225,12 +227,13 @@ create_character_intializer (gfc_expr * init, gfc_typespec * ts,\n   return init;\n }\n \n+\n /* Assign the initial value RVALUE to  LVALUE's symbol->value. If the\n    LVALUE already has an initialization, we extend this, otherwise we\n    create a new one.  */\n \n void\n-gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n+gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n {\n   gfc_ref *ref;\n   gfc_expr *init;\n@@ -262,7 +265,7 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t}\n \n       /* Use the existing initializer expression if it exists.  Otherwise\n-         create a new one.  */\n+\t create a new one.  */\n       if (init == NULL)\n \texpr = gfc_get_expr ();\n       else\n@@ -289,38 +292,40 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t  else\n \t    mpz_set (offset, index);\n \n-          /* Splay tree containing offset and gfc_constructor.  */\n-          spt = expr->con_by_offset;\n+\t  /* Splay tree containing offset and gfc_constructor.  */\n+\t  spt = expr->con_by_offset;\n \n-          if (spt == NULL)\n-            {\n-               spt = splay_tree_new (splay_tree_compare_ints,NULL,NULL);\n-               expr->con_by_offset = spt; \n-               con = NULL;\n-            }\n-         else\n+\t  if (spt == NULL)\n+\t    {\n+\t       spt = splay_tree_new (splay_tree_compare_ints, NULL, NULL);\n+\t       expr->con_by_offset = spt; \n+\t       con = NULL;\n+\t    }\n+\t else\n \t  con = find_con_by_offset (spt, offset);\n \n \t  if (con == NULL)\n \t    {\n+\t      splay_tree_key j;\n+\n \t      /* Create a new constructor.  */\n \t      con = gfc_get_constructor ();\n \t      mpz_set (con->n.offset, offset);\n-              sptn = splay_tree_insert (spt, (splay_tree_key) mpz_get_si(offset),\n-                                       (splay_tree_value) con);\n-              /* Fix up the linked list.  */\n-              sptn = splay_tree_predecessor (spt, (splay_tree_key) mpz_get_si(offset));\n-              if (sptn == NULL)\n-                {  /* Insert at the head.  */\n-                   con->next = expr->value.constructor;\n-                   expr->value.constructor = con;\n-                }\n-              else\n-                {  /* Insert in the chain.  */\n-                   pred = (gfc_constructor*) sptn->value;\n-                   con->next = pred->next;\n-                   pred->next = con;\n-                }\n+\t      j = (splay_tree_key) mpz_get_si (offset);\n+\t      sptn = splay_tree_insert (spt, j, (splay_tree_value) con);\n+\t      /* Fix up the linked list.  */\n+\t      sptn = splay_tree_predecessor (spt, j);\n+\t      if (sptn == NULL)\n+\t\t{  /* Insert at the head.  */\n+\t\t   con->next = expr->value.constructor;\n+\t\t   expr->value.constructor = con;\n+\t\t}\n+\t      else\n+\t\t{  /* Insert in the chain.  */\n+\t\t   pred = (gfc_constructor*) sptn->value;\n+\t\t   con->next = pred->next;\n+\t\t   pred->next = con;\n+\t\t}\n \t    }\n \t  break;\n \n@@ -374,16 +379,16 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n \t provokes a warning from other compilers.  */\n       if (init != NULL)\n \t{\n-\t  /* Order in which the expressions arrive here depends on whether they\n-\t     are from data statements or F95 style declarations. Therefore,\n-\t     check which is the most recent.  */\n+\t  /* Order in which the expressions arrive here depends on whether\n+\t     they are from data statements or F95 style declarations.\n+\t     Therefore, check which is the most recent.  */\n #ifdef USE_MAPPED_LOCATION\n \t  expr = (LOCATION_LINE (init->where.lb->location)\n \t\t  > LOCATION_LINE (rvalue->where.lb->location))\n-\t    ? init : rvalue;\n+\t       ? init : rvalue;\n #else\n-\t  expr = (init->where.lb->linenum > rvalue->where.lb->linenum) ?\n-\t\t    init : rvalue;\n+\t  expr = (init->where.lb->linenum > rvalue->where.lb->linenum)\n+\t       ? init : rvalue;\n #endif\n \t  gfc_notify_std (GFC_STD_GNU, \"Extension: re-initialization \"\n \t\t\t  \"of '%s' at %L\", symbol->name, &expr->where);\n@@ -400,12 +405,13 @@ gfc_assign_data_value (gfc_expr * lvalue, gfc_expr * rvalue, mpz_t index)\n     last_con->expr = expr;\n }\n \n+\n /* Similarly, but initialize REPEAT consecutive values in LVALUE the same\n    value in RVALUE.  For the nonce, LVALUE must refer to a full array, not\n    an array section.  */\n \n void\n-gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n+gfc_assign_data_value_range (gfc_expr *lvalue, gfc_expr *rvalue,\n \t\t\t     mpz_t index, mpz_t repeat)\n {\n   gfc_ref *ref;\n@@ -471,42 +477,44 @@ gfc_assign_data_value_range (gfc_expr * lvalue, gfc_expr * rvalue,\n \n \t  /* Find the same element in the existing constructor.  */\n \n-          /* Splay tree containing offset and gfc_constructor.  */\n-          spt = expr->con_by_offset;\n-\n-          if (spt == NULL)\n-            {\n-               spt = splay_tree_new (splay_tree_compare_ints,NULL,NULL);\n-               expr->con_by_offset = spt;\n-               con = NULL;\n-            }\n-          else \n-            con = find_con_by_offset (spt, offset);\n-\n-          if (con == NULL)\n-            {\n-              /* Create a new constructor.  */\n-              con = gfc_get_constructor ();\n-              mpz_set (con->n.offset, offset);\n-              if (ref->next == NULL)\n-                mpz_set (con->repeat, repeat);\n-              sptn = splay_tree_insert (spt, (splay_tree_key) mpz_get_si(offset),\n-                                       (splay_tree_value) con);\n-              /* Fix up the linked list.  */\n-              sptn = splay_tree_predecessor (spt, (splay_tree_key) mpz_get_si(offset));\n-              if (sptn == NULL)\n-                {  /* Insert at the head.  */\n-                   con->next = expr->value.constructor;\n-                   expr->value.constructor = con;\n-                }\n-              else\n-                {  /* Insert in the chain.  */\n-                   pred = (gfc_constructor*) sptn->value;\n-                   con->next = pred->next;\n-                   pred->next = con;\n-                }\n-            }\n-          else\n+\t  /* Splay tree containing offset and gfc_constructor.  */\n+\t  spt = expr->con_by_offset;\n+\n+\t  if (spt == NULL)\n+\t    {\n+\t       spt = splay_tree_new (splay_tree_compare_ints, NULL, NULL);\n+\t       expr->con_by_offset = spt;\n+\t       con = NULL;\n+\t    }\n+\t  else \n+\t    con = find_con_by_offset (spt, offset);\n+\n+\t  if (con == NULL)\n+\t    {\n+\t      splay_tree_key j;\n+\t      /* Create a new constructor.  */\n+\t      con = gfc_get_constructor ();\n+\t      mpz_set (con->n.offset, offset);\n+\t      j = (splay_tree_key) mpz_get_si (offset);\n+\t  \n+\t      if (ref->next == NULL)\n+\t\tmpz_set (con->repeat, repeat);\n+\t      sptn = splay_tree_insert (spt, j, (splay_tree_value) con);\n+\t      /* Fix up the linked list.  */\n+\t      sptn = splay_tree_predecessor (spt, j);\n+\t      if (sptn == NULL)\n+\t\t{  /* Insert at the head.  */\n+\t\t   con->next = expr->value.constructor;\n+\t\t   expr->value.constructor = con;\n+\t\t}\n+\t      else\n+\t\t{  /* Insert in the chain.  */\n+\t\t   pred = (gfc_constructor*) sptn->value;\n+\t\t   con->next = pred->next;\n+\t\t   pred->next = con;\n+\t\t}\n+\t    }\n+\t  else\n \t    gcc_assert (ref->next != NULL);\n \t  break;\n \n@@ -612,10 +620,9 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n       else\n \tcmp = mpz_cmp (section_index[i], ar->as->upper[i]->value.integer);\n \n-      if ((cmp > 0 && forwards)\n-\t  || (cmp < 0 && ! forwards))\n+      if ((cmp > 0 && forwards) || (cmp < 0 && !forwards))\n \t{\n-          /* Reset index to start, then loop to advance the next index.  */\n+\t  /* Reset index to start, then loop to advance the next index.  */\n \t  if (ar->start[i])\n \t    mpz_set (section_index[i], ar->start[i]->value.integer);\n \t  else\n@@ -635,7 +642,7 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n       mpz_add (*offset_ret, tmp, *offset_ret);\n \n       mpz_sub (tmp, ar->as->upper[i]->value.integer, \n-               ar->as->lower[i]->value.integer);\n+\t       ar->as->lower[i]->value.integer);\n       mpz_add_ui (tmp, tmp, 1);\n       mpz_mul (delta, tmp, delta);\n     }\n@@ -648,7 +655,7 @@ gfc_advance_section (mpz_t *section_index, gfc_array_ref *ar,\n    order.  Also insert NULL entries if necessary.  */\n \n static void\n-formalize_structure_cons (gfc_expr * expr)\n+formalize_structure_cons (gfc_expr *expr)\n {\n   gfc_constructor *head;\n   gfc_constructor *tail;\n@@ -710,7 +717,7 @@ formalize_structure_cons (gfc_expr * expr)\n    elements of the constructors are in the correct order.  */\n \n static void\n-formalize_init_expr (gfc_expr * expr)\n+formalize_init_expr (gfc_expr *expr)\n {\n   expr_t type;\n   gfc_constructor *c;\n@@ -789,7 +796,7 @@ gfc_get_section_index (gfc_array_ref *ar, mpz_t *section_index, mpz_t *offset)\n \t}\n \n       mpz_sub (tmp, ar->as->upper[i]->value.integer, \n-               ar->as->lower[i]->value.integer);\n+\t       ar->as->lower[i]->value.integer);\n       mpz_add_ui (tmp, tmp, 1);\n       mpz_mul (delta, tmp, delta);\n     }"}, {"sha": "2470722b8b24d7cf2536a0967bf118602bdc6f85", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 249, "deletions": 281, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=636dff67dd28fc952990b83580ffd96f6508a338", "patch": "@@ -1,5 +1,6 @@\n /* Declaration statement matcher\n-   Copyright (C) 2002, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -19,14 +20,12 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"gfortran.h\"\n #include \"match.h\"\n #include \"parse.h\"\n \n-\n /* This flag is set if an old-style length selector is matched\n    during a type-declaration statement.  */\n \n@@ -91,7 +90,7 @@ gfc_set_in_match_data (bool set_value)\n /* Free a gfc_data_variable structure and everything beneath it.  */\n \n static void\n-free_variable (gfc_data_variable * p)\n+free_variable (gfc_data_variable *p)\n {\n   gfc_data_variable *q;\n \n@@ -101,7 +100,6 @@ free_variable (gfc_data_variable * p)\n       gfc_free_expr (p->expr);\n       gfc_free_iterator (&p->iter, 0);\n       free_variable (p->list);\n-\n       gfc_free (p);\n     }\n }\n@@ -110,7 +108,7 @@ free_variable (gfc_data_variable * p)\n /* Free a gfc_data_value structure and everything beneath it.  */\n \n static void\n-free_value (gfc_data_value * p)\n+free_value (gfc_data_value *p)\n {\n   gfc_data_value *q;\n \n@@ -126,23 +124,22 @@ free_value (gfc_data_value * p)\n /* Free a list of gfc_data structures.  */\n \n void\n-gfc_free_data (gfc_data * p)\n+gfc_free_data (gfc_data *p)\n {\n   gfc_data *q;\n \n   for (; p; p = q)\n     {\n       q = p->next;\n-\n       free_variable (p->var);\n       free_value (p->value);\n-\n       gfc_free (p);\n     }\n }\n \n \n /* Free all data in a namespace.  */\n+\n static void\n gfc_free_data_all (gfc_namespace * ns)\n {\n@@ -163,7 +160,7 @@ static match var_element (gfc_data_variable *);\n    parenthesis.  */\n \n static match\n-var_list (gfc_data_variable * parent)\n+var_list (gfc_data_variable *parent)\n {\n   gfc_data_variable *tail, var;\n   match m;\n@@ -216,7 +213,7 @@ var_list (gfc_data_variable * parent)\n    variable-iterator list.  */\n \n static match\n-var_element (gfc_data_variable * new)\n+var_element (gfc_data_variable *new)\n {\n   match m;\n   gfc_symbol *sym;\n@@ -232,18 +229,19 @@ var_element (gfc_data_variable * new)\n \n   sym = new->expr->symtree->n.sym;\n \n-  if (!sym->attr.function && gfc_current_ns->parent && gfc_current_ns->parent == sym->ns)\n+  if (!sym->attr.function && gfc_current_ns->parent\n+      && gfc_current_ns->parent == sym->ns)\n     {\n       gfc_error (\"Host associated variable '%s' may not be in the DATA \"\n \t\t \"statement at %C\", sym->name);\n       return MATCH_ERROR;\n     }\n \n   if (gfc_current_state () != COMP_BLOCK_DATA\n-\t&& sym->attr.in_common\n-\t&& gfc_notify_std (GFC_STD_GNU, \"Extension: initialization of \"\n-\t\t\t   \"common block variable '%s' in DATA statement at %C\",\n-\t\t\t   sym->name) == FAILURE)\n+      && sym->attr.in_common\n+      && gfc_notify_std (GFC_STD_GNU, \"Extension: initialization of \"\n+\t\t\t \"common block variable '%s' in DATA statement at %C\",\n+\t\t\t sym->name) == FAILURE)\n     return MATCH_ERROR;\n \n   if (gfc_add_data (&sym->attr, sym->name, &new->expr->where) == FAILURE)\n@@ -256,7 +254,7 @@ var_element (gfc_data_variable * new)\n /* Match the top-level list of data variables.  */\n \n static match\n-top_var_list (gfc_data * d)\n+top_var_list (gfc_data *d)\n {\n   gfc_data_variable var, *tail, *new;\n   match m;\n@@ -297,7 +295,7 @@ top_var_list (gfc_data * d)\n \n \n static match\n-match_data_constant (gfc_expr ** result)\n+match_data_constant (gfc_expr **result)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n@@ -344,7 +342,7 @@ match_data_constant (gfc_expr ** result)\n    already been seen at this point.  */\n \n static match\n-top_val_list (gfc_data * data)\n+top_val_list (gfc_data *data)\n {\n   gfc_data_value *new, *tail;\n   gfc_expr *expr;\n@@ -458,6 +456,7 @@ match_old_style_init (const char *name)\n   return m;\n }\n \n+\n /* Match the stuff following a DATA statement. If ERROR_FLAG is set,\n    we are matching a DATA statement and are therefore issuing an error\n    if we encounter something unexpected, if not, we're trying to match \n@@ -535,9 +534,8 @@ match_intent_spec (void)\n    specification expression or a '*'.  */\n \n static match\n-char_len_param_value (gfc_expr ** expr)\n+char_len_param_value (gfc_expr **expr)\n {\n-\n   if (gfc_match_char ('*') == MATCH_YES)\n     {\n       *expr = NULL;\n@@ -552,7 +550,7 @@ char_len_param_value (gfc_expr ** expr)\n    char_len_param_value in parenthesis.  */\n \n static match\n-match_char_length (gfc_expr ** expr)\n+match_char_length (gfc_expr **expr)\n {\n   int length;\n   match m;\n@@ -602,13 +600,13 @@ match_char_length (gfc_expr ** expr)\n    (located in another namespace).  */\n \n static int\n-find_special (const char *name, gfc_symbol ** result)\n+find_special (const char *name, gfc_symbol **result)\n {\n   gfc_state_data *s;\n   int i;\n \n   i = gfc_get_symbol (name, NULL, result);\n-  if (i==0) \n+  if (i == 0) \n     goto end;\n   \n   if (gfc_current_state () != COMP_SUBROUTINE\n@@ -622,7 +620,7 @@ find_special (const char *name, gfc_symbol ** result)\n   if (s->state != COMP_INTERFACE)\n     goto end;\n   if (s->sym == NULL)\n-    goto end;                  /* Nameless interface */\n+    goto end;\t\t  /* Nameless interface */\n \n   if (strcmp (name, s->sym->name) == 0)\n     {\n@@ -642,8 +640,7 @@ find_special (const char *name, gfc_symbol ** result)\n    parent, then the symbol is just created in the current unit.  */\n \n static int\n-get_proc_name (const char *name, gfc_symbol ** result,\n-\t       bool module_fcn_entry)\n+get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n {\n   gfc_symtree *st;\n   gfc_symbol *sym;\n@@ -671,23 +668,23 @@ get_proc_name (const char *name, gfc_symbol ** result,\n \t this is handled using gsymbols to register unique,globally\n \t accessible names.  */\n       if (sym->attr.flavor != 0\n-\t    && sym->attr.proc != 0\n-\t    && (sym->attr.subroutine || sym->attr.function)\n-\t    && sym->attr.if_source != IFSRC_UNKNOWN)\n+\t  && sym->attr.proc != 0\n+\t  && (sym->attr.subroutine || sym->attr.function)\n+\t  && sym->attr.if_source != IFSRC_UNKNOWN)\n \tgfc_error_now (\"Procedure '%s' at %C is already defined at %L\",\n \t\t       name, &sym->declared_at);\n \n       /* Trap declarations of attributes in encompassing scope.  The\n \t signature for this is that ts.kind is set.  Legitimate\n \t references only set ts.type.  */\n       if (sym->ts.kind != 0\n-\t    && !sym->attr.implicit_type\n-\t    && sym->attr.proc == 0\n-\t    && gfc_current_ns->parent != NULL\n-\t    && sym->attr.access == 0\n-\t    && !module_fcn_entry)\n-\tgfc_error_now (\"Procedure '%s' at %C has an explicit interface\"\n-\t\t       \" and must not have attributes declared at %L\",\n+\t  && !sym->attr.implicit_type\n+\t  && sym->attr.proc == 0\n+\t  && gfc_current_ns->parent != NULL\n+\t  && sym->attr.access == 0\n+\t  && !module_fcn_entry)\n+\tgfc_error_now (\"Procedure '%s' at %C has an explicit interface \"\n+\t\t       \"and must not have attributes declared at %L\",\n \t\t       name, &sym->declared_at);\n     }\n \n@@ -707,10 +704,10 @@ get_proc_name (const char *name, gfc_symbol ** result,\n   /* See if the procedure should be a module procedure */\n \n   if (((sym->ns->proc_name != NULL\n-\t  && sym->ns->proc_name->attr.flavor == FL_MODULE\n-\t  && sym->attr.proc != PROC_MODULE) || module_fcn_entry)\n-\t&& gfc_add_procedure (&sym->attr, PROC_MODULE,\n-\t\t\t      sym->name, NULL) == FAILURE)\n+\t&& sym->ns->proc_name->attr.flavor == FL_MODULE\n+\t&& sym->attr.proc != PROC_MODULE) || module_fcn_entry)\n+       && gfc_add_procedure (&sym->attr, PROC_MODULE,\n+\t\t\t     sym->name, NULL) == FAILURE)\n     rc = 2;\n \n   return rc;\n@@ -721,21 +718,20 @@ get_proc_name (const char *name, gfc_symbol ** result,\n    table.  */\n \n static try\n-build_sym (const char *name, gfc_charlen * cl,\n-\t   gfc_array_spec ** as, locus * var_locus)\n+build_sym (const char *name, gfc_charlen *cl,\n+\t   gfc_array_spec **as, locus *var_locus)\n {\n   symbol_attribute attr;\n   gfc_symbol *sym;\n \n-  /* if (find_special (name, &sym)) */\n   if (gfc_get_symbol (name, NULL, &sym))\n     return FAILURE;\n \n   /* Start updating the symbol table.  Add basic type attribute\n      if present.  */\n   if (current_ts.type != BT_UNKNOWN\n-      &&(sym->attr.implicit_type == 0\n-\t || !gfc_compare_types (&sym->ts, &current_ts))\n+      && (sym->attr.implicit_type == 0\n+\t  || !gfc_compare_types (&sym->ts, &current_ts))\n       && gfc_add_type (sym, &current_ts, var_locus) == FAILURE)\n     return FAILURE;\n \n@@ -758,13 +754,14 @@ build_sym (const char *name, gfc_charlen * cl,\n   return SUCCESS;\n }\n \n+\n /* Set character constant to the given length. The constant will be padded or\n    truncated.  */\n \n void\n-gfc_set_constant_character_len (int len, gfc_expr * expr, bool array)\n+gfc_set_constant_character_len (int len, gfc_expr *expr, bool array)\n {\n-  char * s;\n+  char *s;\n   int slen;\n \n   gcc_assert (expr->expr_type == EXPR_CONSTANT);\n@@ -787,7 +784,7 @@ gfc_set_constant_character_len (int len, gfc_expr * expr, bool array)\n       if (array && slen < len && !(gfc_option.allow_std & GFC_STD_GNU))\n \tgfc_error_now (\"The CHARACTER elements of the array constructor \"\n \t\t       \"at %L must have the same length (%d/%d)\",\n-\t\t        &expr->where, slen, len);\n+\t\t\t&expr->where, slen, len);\n \n       s[len] = '\\0';\n       gfc_free (expr->value.character.string);\n@@ -806,7 +803,7 @@ gfc_set_constant_character_len (int len, gfc_expr * expr, bool array)\n    INIT points to its enumerator value.   */\n \n static void \n-create_enum_history(gfc_symbol *sym, gfc_expr *init)\n+create_enum_history (gfc_symbol *sym, gfc_expr *init)\n {\n   enumerator_history *new_enum_history;\n   gcc_assert (sym != NULL && init != NULL);\n@@ -829,15 +826,15 @@ create_enum_history(gfc_symbol *sym, gfc_expr *init)\n \n       if (mpz_cmp (max_enum->initializer->value.integer, \n \t\t   new_enum_history->initializer->value.integer) < 0)\n-        max_enum = new_enum_history;\n+\tmax_enum = new_enum_history;\n     }\n }\n \n \n /* Function to free enum kind history.  */ \n \n void \n-gfc_free_enum_history(void)\n+gfc_free_enum_history (void)\n {\n   enumerator_history *current = enum_history;  \n   enumerator_history *next;  \n@@ -857,8 +854,8 @@ gfc_free_enum_history(void)\n    expression to a symbol.  */\n \n static try\n-add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n-\t\t      locus * var_locus)\n+add_init_expr_to_sym (const char *name, gfc_expr **initp,\n+\t\t      locus *var_locus)\n {\n   symbol_attribute attr;\n   gfc_symbol *sym;\n@@ -905,9 +902,8 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n \t initializer.  */\n       if (sym->attr.data)\n \t{\n-\t  gfc_error\n-\t    (\"Variable '%s' at %C with an initializer already appears \"\n-\t     \"in a DATA statement\", sym->name);\n+\t  gfc_error (\"Variable '%s' at %C with an initializer already \"\n+\t\t     \"appears in a DATA statement\", sym->name);\n \t  return FAILURE;\n \t}\n \n@@ -924,13 +920,13 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n \t    {\n \t      /* If there are multiple CHARACTER variables declared on\n \t\t the same line, we don't want them to share the same\n-\t        length.  */\n+\t\tlength.  */\n \t      sym->ts.cl = gfc_get_charlen ();\n \t      sym->ts.cl->next = gfc_current_ns->cl_list;\n \t      gfc_current_ns->cl_list = sym->ts.cl;\n \n \t      if (sym->attr.flavor == FL_PARAMETER\n-\t\t    && init->expr_type == EXPR_ARRAY)\n+\t\t  && init->expr_type == EXPR_ARRAY)\n \t\tsym->ts.cl->length = gfc_copy_expr (init->ts.cl->length);\n \t    }\n \t  /* Update initializer character length according symbol.  */\n@@ -971,8 +967,8 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n    being built.  */\n \n static try\n-build_struct (const char *name, gfc_charlen * cl, gfc_expr ** init,\n-\t      gfc_array_spec ** as)\n+build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n+\t      gfc_array_spec **as)\n {\n   gfc_component *c;\n \n@@ -986,8 +982,7 @@ build_struct (const char *name, gfc_charlen * cl, gfc_expr ** init,\n       return FAILURE;\n     }\n \n-  if (gfc_current_block ()->attr.pointer\n-      && (*as)->rank != 0)\n+  if (gfc_current_block ()->attr.pointer && (*as)->rank != 0)\n     {\n       if ((*as)->type != AS_DEFERRED && (*as)->type != AS_EXPLICIT)\n \t{\n@@ -1046,9 +1041,8 @@ build_struct (const char *name, gfc_charlen * cl, gfc_expr ** init,\n     {\n       if (c->as->type != AS_EXPLICIT)\n \t{\n-\t  gfc_error\n-\t    (\"Array component of structure at %C must have an explicit \"\n-\t     \"shape\");\n+\t  gfc_error (\"Array component of structure at %C must have an \"\n+\t\t     \"explicit shape\");\n \t  return FAILURE;\n \t}\n     }\n@@ -1060,7 +1054,7 @@ build_struct (const char *name, gfc_charlen * cl, gfc_expr ** init,\n /* Match a 'NULL()', and possibly take care of some side effects.  */\n \n match\n-gfc_match_null (gfc_expr ** result)\n+gfc_match_null (gfc_expr **result)\n {\n   gfc_symbol *sym;\n   gfc_expr *e;\n@@ -1166,7 +1160,7 @@ variable_decl (int elem)\n \t   element.  */\n \tcase MATCH_NO:\n \t  if (elem > 1 && current_ts.cl->length\n-\t\t&& current_ts.cl->length->expr_type != EXPR_CONSTANT)\n+\t      && current_ts.cl->length->expr_type != EXPR_CONSTANT)\n \t    {\n \t      cl = gfc_get_charlen ();\n \t      cl->next = gfc_current_ns->cl_list;\n@@ -1249,10 +1243,10 @@ variable_decl (int elem)\n      that the interface may specify a procedure that is not pure if the procedure\n      is defined to be pure(12.3.2).  */\n   if (current_ts.type == BT_DERIVED\n-\t&& gfc_current_ns->proc_name\n-\t&& gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY\n-\t&& current_ts.derived->ns != gfc_current_ns\n-\t&& !gfc_current_ns->has_import_set)\n+      && gfc_current_ns->proc_name\n+      && gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY\n+      && current_ts.derived->ns != gfc_current_ns\n+      && !gfc_current_ns->has_import_set)\n     {\n       gfc_error (\"the type of '%s' at %C has not been declared within the \"\n \t\t \"interface\", name);\n@@ -1298,7 +1292,6 @@ variable_decl (int elem)\n     {\n       if (gfc_match (\" =>\") == MATCH_YES)\n \t{\n-\n \t  if (!current_attr.pointer)\n \t    {\n \t      gfc_error (\"Initialization at %C isn't for a pointer variable\");\n@@ -1315,9 +1308,8 @@ variable_decl (int elem)\n \n \t  if (gfc_pure (NULL))\n \t    {\n-\t      gfc_error\n-\t\t(\"Initialization of pointer at %C is not allowed in a \"\n-\t\t \"PURE procedure\");\n+\t      gfc_error (\"Initialization of pointer at %C is not allowed in \"\n+\t\t\t \"a PURE procedure\");\n \t      m = MATCH_ERROR;\n \t    }\n \n@@ -1329,8 +1321,8 @@ variable_decl (int elem)\n \t{\n \t  if (current_attr.pointer)\n \t    {\n-\t      gfc_error\n-\t\t(\"Pointer initialization at %C requires '=>', not '='\");\n+\t      gfc_error (\"Pointer initialization at %C requires '=>', \"\n+\t\t\t \"not '='\");\n \t      m = MATCH_ERROR;\n \t      goto cleanup;\n \t    }\n@@ -1344,9 +1336,8 @@ variable_decl (int elem)\n \n \t  if (current_attr.flavor != FL_PARAMETER && gfc_pure (NULL))\n \t    {\n-\t      gfc_error\n-\t\t(\"Initialization of variable at %C is not allowed in a \"\n-\t\t \"PURE procedure\");\n+\t      gfc_error (\"Initialization of variable at %C is not allowed in \"\n+\t\t\t \"a PURE procedure\");\n \t      m = MATCH_ERROR;\n \t    }\n \n@@ -1358,7 +1349,8 @@ variable_decl (int elem)\n   if (initializer != NULL && current_attr.allocatable\n \t&& gfc_current_state () == COMP_DERIVED)\n     {\n-      gfc_error (\"Initialization of allocatable component at %C is not allowed\");\n+      gfc_error (\"Initialization of allocatable component at %C is not \"\n+\t\t \"allowed\");\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n@@ -1371,16 +1363,16 @@ variable_decl (int elem)\n   if (gfc_current_state () == COMP_ENUM)\n     {\n       if (initializer == NULL)\n-        initializer = gfc_enum_initializer (last_initializer, old_locus);\n+\tinitializer = gfc_enum_initializer (last_initializer, old_locus);\n  \n       if (initializer == NULL || initializer->ts.type != BT_INTEGER)\n-        {\n-          gfc_error(\"ENUMERATOR %L not initialized with integer expression\",\n+\t{\n+\t  gfc_error(\"ENUMERATOR %L not initialized with integer expression\",\n \t\t    &var_locus);\n-          m = MATCH_ERROR; \n-          gfc_free_enum_history ();\n-          goto cleanup;\n-        }\n+\t  m = MATCH_ERROR; \n+\t  gfc_free_enum_history ();\n+\t  goto cleanup;\n+\t}\n \n       /* Store this current initializer, for the next enumerator\n \t variable to be parsed.  */\n@@ -1395,8 +1387,7 @@ variable_decl (int elem)\n   else\n     {\n       if (current_ts.type == BT_DERIVED\n-\t    && !current_attr.pointer\n-\t    && !initializer)\n+\t  && !current_attr.pointer && !initializer)\n \tinitializer = gfc_default_initializer (&current_ts);\n       t = build_struct (name, cl, &initializer, &as);\n     }\n@@ -1415,7 +1406,7 @@ variable_decl (int elem)\n /* Match an extended-f77 kind specification.  */\n \n match\n-gfc_match_old_kind_spec (gfc_typespec * ts)\n+gfc_match_old_kind_spec (gfc_typespec *ts)\n {\n   match m;\n   int original_kind;\n@@ -1433,18 +1424,18 @@ gfc_match_old_kind_spec (gfc_typespec * ts)\n   if (ts->type == BT_COMPLEX)\n     {\n       if (ts->kind % 2)\n-        {\n-          gfc_error (\"Old-style type declaration %s*%d not supported at %C\",\n-                     gfc_basic_typename (ts->type), original_kind);\n-          return MATCH_ERROR;\n-        }\n+\t{\n+\t  gfc_error (\"Old-style type declaration %s*%d not supported at %C\",\n+\t\t     gfc_basic_typename (ts->type), original_kind);\n+\t  return MATCH_ERROR;\n+\t}\n       ts->kind /= 2;\n     }\n \n   if (gfc_validate_kind (ts->type, ts->kind, true) < 0)\n     {\n       gfc_error (\"Old-style type declaration %s*%d not supported at %C\",\n-                 gfc_basic_typename (ts->type), original_kind);\n+\t\t gfc_basic_typename (ts->type), original_kind);\n       return MATCH_ERROR;\n     }\n \n@@ -1461,7 +1452,7 @@ gfc_match_old_kind_spec (gfc_typespec * ts)\n    string is found, then we know we have an error.  */\n \n match\n-gfc_match_kind_spec (gfc_typespec * ts)\n+gfc_match_kind_spec (gfc_typespec *ts)\n {\n   locus where;\n   gfc_expr *e;\n@@ -1532,7 +1523,7 @@ gfc_match_kind_spec (gfc_typespec * ts)\n    declaration.  We don't return MATCH_NO.  */\n \n static match\n-match_char_spec (gfc_typespec * ts)\n+match_char_spec (gfc_typespec *ts)\n {\n   int i, kind, seen_length;\n   gfc_charlen *cl;\n@@ -1584,7 +1575,7 @@ match_char_spec (gfc_typespec * ts)\n       goto rparen;\n     }\n \n-  /* Try to match ( LEN = <len-param> ) or ( LEN = <len-param>, KIND = <int> )  */\n+  /* Try to match \"LEN = <len-param>\" or \"LEN = <len-param>, KIND = <int>\"  */\n   if (gfc_match (\" len =\") == MATCH_YES)\n     {\n       m = char_len_param_value (&len);\n@@ -1691,7 +1682,7 @@ match_char_spec (gfc_typespec * ts)\n    statement correctly.  */\n \n static match\n-match_type_spec (gfc_typespec * ts, int implicit_flag)\n+match_type_spec (gfc_typespec *ts, int implicit_flag)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *sym;\n@@ -1804,7 +1795,7 @@ match_type_spec (gfc_typespec * ts, int implicit_flag)\n     {\n       c = gfc_peek_char();\n       if (!gfc_is_whitespace(c) && c != '*' && c != '('\n-         && c != ':' && c != ',')\n+\t  && c != ':' && c != ',')\n        return MATCH_NO;\n     }\n \n@@ -1827,7 +1818,6 @@ match_type_spec (gfc_typespec * ts, int implicit_flag)\n match\n gfc_match_implicit_none (void)\n {\n-\n   return (gfc_match_eos () == MATCH_YES) ? MATCH_YES : MATCH_NO;\n }\n \n@@ -1898,10 +1888,10 @@ match_implicit_range (void)\n \t}\n \n       /* See if we can add the newly matched range to the pending\n-         implicits from this IMPLICIT statement.  We do not check for\n-         conflicts with whatever earlier IMPLICIT statements may have\n-         set.  This is done when we've successfully finished matching\n-         the current one.  */\n+\t implicits from this IMPLICIT statement.  We do not check for\n+\t conflicts with whatever earlier IMPLICIT statements may have\n+\t set.  This is done when we've successfully finished matching\n+\t the current one.  */\n       if (gfc_add_new_implicit_range (c1, c2) != SUCCESS)\n \tgoto bad;\n     }\n@@ -2053,8 +2043,7 @@ gfc_match_import (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \n-\t\t      \"Fortran 2003: IMPORT statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: IMPORT statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -2068,10 +2057,10 @@ gfc_match_import (void)\n   if (gfc_match (\" ::\") == MATCH_YES)\n     {\n       if (gfc_match_eos () == MATCH_YES)\n-        {\n-           gfc_error (\"Expecting list of named entities at %C\");\n-           return MATCH_ERROR;\n-        }\n+\t{\n+\t   gfc_error (\"Expecting list of named entities at %C\");\n+\t   return MATCH_ERROR;\n+\t}\n     }\n \n   for(;;)\n@@ -2080,30 +2069,30 @@ gfc_match_import (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-          if (gfc_find_symbol (name, gfc_current_ns->parent, 1, &sym))\n-            {\n-               gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n-               return MATCH_ERROR;\n-            }\n-\n-          if (sym == NULL)\n-            {\n-              gfc_error (\"Cannot IMPORT '%s' from host scoping unit \"\n-                         \"at %C - does not exist.\", name);\n-              return MATCH_ERROR;\n-            }\n-\n-          if (gfc_find_symtree (gfc_current_ns->sym_root,name)) \n-            {\n-              gfc_warning (\"'%s' is already IMPORTed from host scoping unit \"\n-                           \"at %C.\", name);\n-              goto next_item;\n-            }\n-\n-          st = gfc_new_symtree (&gfc_current_ns->sym_root, name);\n-          st->n.sym = sym;\n-          sym->refs++;\n-          sym->ns = gfc_current_ns;\n+\t  if (gfc_find_symbol (name, gfc_current_ns->parent, 1, &sym))\n+\t    {\n+\t       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+\t       return MATCH_ERROR;\n+\t    }\n+\n+\t  if (sym == NULL)\n+\t    {\n+\t      gfc_error (\"Cannot IMPORT '%s' from host scoping unit \"\n+\t\t\t \"at %C - does not exist.\", name);\n+\t      return MATCH_ERROR;\n+\t    }\n+\n+\t  if (gfc_find_symtree (gfc_current_ns->sym_root,name)) \n+\t    {\n+\t      gfc_warning (\"'%s' is already IMPORTed from host scoping unit \"\n+\t\t\t   \"at %C.\", name);\n+\t      goto next_item;\n+\t    }\n+\n+\t  st = gfc_new_symtree (&gfc_current_ns->sym_root, name);\n+\t  st->n.sym = sym;\n+\t  sym->refs++;\n+\t  sym->ns = gfc_current_ns;\n \n \t  goto next_item;\n \n@@ -2141,7 +2130,6 @@ gfc_match_import (void)\n static match\n match_attr_spec (void)\n {\n-\n   /* Modifiers that can exist in a type statement.  */\n   typedef enum\n   { GFC_DECL_BEGIN = 0,\n@@ -2203,10 +2191,10 @@ match_attr_spec (void)\n \tbreak;\n        \n       if (gfc_current_state () == COMP_ENUM)\n-        {\n-          gfc_error (\"Enumerator cannot have attributes %C\");\n-          return MATCH_ERROR;\n-        }\n+\t{\n+\t  gfc_error (\"Enumerator cannot have attributes %C\");\n+\t  return MATCH_ERROR;\n+\t}\n \n       seen[d]++;\n       seen_at[d] = gfc_current_locus;\n@@ -2232,10 +2220,10 @@ match_attr_spec (void)\n     {\n       t = gfc_add_flavor (&current_attr, FL_PARAMETER, NULL, NULL);\n       if (t == FAILURE)\n-        {\n-          m = MATCH_ERROR;\n-          goto cleanup;\n-        }\n+\t{\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n     }\n \n   /* No double colon, so assume that we've been looking at something\n@@ -2326,16 +2314,15 @@ match_attr_spec (void)\n \t{\n \t  if (d == DECL_ALLOCATABLE)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \n-\t\t\t\t   \"Fortran 2003: ALLOCATABLE \"\n-\t\t\t\t   \"attribute at %C in a TYPE \"\n-\t\t\t\t   \"definition\") == FAILURE)         \n+\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ALLOCATABLE \"\n+\t\t\t\t  \"attribute at %C in a TYPE definition\")\n+\t\t  == FAILURE)\t \n \t\t{\n \t\t  m = MATCH_ERROR;\n \t\t  goto cleanup;\n \t\t}\n-            }\n-          else\n+\t    }\n+\t  else\n \t    {\n \t      gfc_error (\"Attribute at %L is not allowed in a TYPE definition\",\n \t\t\t  &seen_at[d]);\n@@ -2345,7 +2332,7 @@ match_attr_spec (void)\n \t}\n \n       if ((d == DECL_PRIVATE || d == DECL_PUBLIC)\n-\t     && gfc_current_state () != COMP_MODULE)\n+\t  && gfc_current_state () != COMP_MODULE)\n \t{\n \t  if (d == DECL_PRIVATE)\n \t    attr = \"PRIVATE\";\n@@ -2409,8 +2396,8 @@ match_attr_spec (void)\n \t       break;\n \t    }\n \n-\t  if (gfc_notify_std (GFC_STD_F2003,\n-                              \"Fortran 2003: PROTECTED attribute at %C\")\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PROTECTED \"\n+\t\t\t      \"attribute at %C\")\n \t      == FAILURE)\n \t    t = FAILURE;\n \t  else\n@@ -2436,8 +2423,8 @@ match_attr_spec (void)\n \t  break;\n \n \tcase DECL_VALUE:\n-\t  if (gfc_notify_std (GFC_STD_F2003,\n-                              \"Fortran 2003: VALUE attribute at %C\")\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: VALUE attribute \"\n+\t\t\t      \"at %C\")\n \t      == FAILURE)\n \t    t = FAILURE;\n \t  else\n@@ -2446,7 +2433,7 @@ match_attr_spec (void)\n \n \tcase DECL_VOLATILE:\n \t  if (gfc_notify_std (GFC_STD_F2003,\n-                              \"Fortran 2003: VOLATILE attribute at %C\")\n+\t\t\t      \"Fortran 2003: VOLATILE attribute at %C\")\n \t      == FAILURE)\n \t    t = FAILURE;\n \t  else\n@@ -2515,18 +2502,18 @@ gfc_match_data_decl (void)\n \tgoto ok;\n \n       gfc_find_symbol (current_ts.derived->name,\n-\t\t\t current_ts.derived->ns->parent, 1, &sym);\n+\t\t       current_ts.derived->ns->parent, 1, &sym);\n \n       /* Any symbol that we find had better be a type definition\n-         which has its components defined.  */\n+\t which has its components defined.  */\n       if (sym != NULL && sym->attr.flavor == FL_DERIVED\n-\t    && current_ts.derived->components != NULL)\n+\t  && current_ts.derived->components != NULL)\n \tgoto ok;\n \n       /* Now we have an error, which we signal, and then fix up\n \t because the knock-on is plain and simple confusing.  */\n       gfc_error_now (\"Derived type at %C has not been previously defined \"\n-\t\t \"and so cannot appear in a derived type definition\");\n+\t\t     \"and so cannot appear in a derived type definition\");\n       current_attr.pointer = 1;\n       goto ok;\n     }\n@@ -2574,7 +2561,7 @@ gfc_match_data_decl (void)\n    returned (the null string was matched).  */\n \n static match\n-match_prefix (gfc_typespec * ts)\n+match_prefix (gfc_typespec *ts)\n {\n   int seen_type;\n \n@@ -2623,9 +2610,8 @@ match_prefix (gfc_typespec * ts)\n /* Copy attributes matched by match_prefix() to attributes on a symbol.  */\n \n static try\n-copy_prefix (symbol_attribute * dest, locus * where)\n+copy_prefix (symbol_attribute *dest, locus *where)\n {\n-\n   if (current_attr.pure && gfc_add_pure (dest, where) == FAILURE)\n     return FAILURE;\n \n@@ -2642,7 +2628,7 @@ copy_prefix (symbol_attribute * dest, locus * where)\n /* Match a formal argument list.  */\n \n match\n-gfc_match_formal_arglist (gfc_symbol * progname, int st_flag, int null_flag)\n+gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n {\n   gfc_formal_arglist *head, *tail, *p, *q;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n@@ -2688,8 +2674,8 @@ gfc_match_formal_arglist (gfc_symbol * progname, int st_flag, int null_flag)\n       tail->sym = sym;\n \n       /* We don't add the VARIABLE flavor because the name could be a\n-         dummy procedure.  We don't apply these attributes to formal\n-         arguments of statement functions.  */\n+\t dummy procedure.  We don't apply these attributes to formal\n+\t arguments of statement functions.  */\n       if (sym != NULL && !st_flag\n \t  && (gfc_add_dummy (&sym->attr, sym->name, NULL) == FAILURE\n \t      || gfc_missing_attr (&sym->attr, NULL) == FAILURE))\n@@ -2699,8 +2685,8 @@ gfc_match_formal_arglist (gfc_symbol * progname, int st_flag, int null_flag)\n \t}\n \n       /* The name of a program unit can be in a different namespace,\n-         so check for it explicitly.  After the statement is accepted,\n-         the name is checked for especially in gfc_get_symbol().  */\n+\t so check for it explicitly.  After the statement is accepted,\n+\t the name is checked for especially in gfc_get_symbol().  */\n       if (gfc_new_block != NULL && sym != NULL\n \t  && strcmp (sym->name, gfc_new_block->name) == 0)\n \t{\n@@ -2733,9 +2719,8 @@ gfc_match_formal_arglist (gfc_symbol * progname, int st_flag, int null_flag)\n \t  for (q = p->next; q; q = q->next)\n \t    if (p->sym == q->sym)\n \t      {\n-\t\tgfc_error\n-\t\t  (\"Duplicate symbol '%s' in formal argument list at %C\",\n-\t\t   p->sym->name);\n+\t\tgfc_error (\"Duplicate symbol '%s' in formal argument list \"\n+\t\t\t   \"at %C\", p->sym->name);\n \n \t\tm = MATCH_ERROR;\n \t\tgoto cleanup;\n@@ -2762,7 +2747,7 @@ gfc_match_formal_arglist (gfc_symbol * progname, int st_flag, int null_flag)\n    ENTRY statement.  Also matches the end-of-statement.  */\n \n static match\n-match_result (gfc_symbol * function, gfc_symbol ** result)\n+match_result (gfc_symbol * function, gfc_symbol **result)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symbol *r;\n@@ -2783,8 +2768,7 @@ match_result (gfc_symbol * function, gfc_symbol ** result)\n \n   if (strcmp (function->name, name) == 0)\n     {\n-      gfc_error\n-\t(\"RESULT variable at %C must be different than function name\");\n+      gfc_error (\"RESULT variable at %C must be different than function name\");\n       return MATCH_ERROR;\n     }\n \n@@ -2841,7 +2825,7 @@ gfc_match_function_decl (void)\n   if (m == MATCH_NO)\n     {\n       gfc_error (\"Expected formal argument list in function \"\n-                \"definition at %C\");\n+\t\t \"definition at %C\");\n       m = MATCH_ERROR;\n       goto cleanup;\n     }\n@@ -2874,9 +2858,8 @@ gfc_match_function_decl (void)\n       || copy_prefix (&sym->attr, &sym->declared_at) == FAILURE)\n     goto cleanup;\n \n-  if (current_ts.type != BT_UNKNOWN\n-\t&& sym->ts.type != BT_UNKNOWN\n-\t&& !sym->attr.implicit_type)\n+  if (current_ts.type != BT_UNKNOWN && sym->ts.type != BT_UNKNOWN\n+      && !sym->attr.implicit_type)\n     {\n       gfc_error (\"Function '%s' at %C already has a type of %s\", name,\n \t\t gfc_basic_typename (sym->ts.type));\n@@ -2901,19 +2884,21 @@ gfc_match_function_decl (void)\n   return m;\n }\n \n-/* This is mostly a copy of parse.c(add_global_procedure) but modified to pass the\n-   name of the entry, rather than the gfc_current_block name, and to return false\n-   upon finding an existing global entry.  */\n+\n+/* This is mostly a copy of parse.c(add_global_procedure) but modified to\n+   pass the name of the entry, rather than the gfc_current_block name, and\n+   to return false upon finding an existing global entry.  */\n \n static bool\n-add_global_entry (const char * name, int sub)\n+add_global_entry (const char *name, int sub)\n {\n   gfc_gsymbol *s;\n \n   s = gfc_get_gsymbol(name);\n \n   if (s->defined\n-\t|| (s->type != GSYM_UNKNOWN && s->type != (sub ? GSYM_SUBROUTINE : GSYM_FUNCTION)))\n+      || (s->type != GSYM_UNKNOWN\n+\t  && s->type != (sub ? GSYM_SUBROUTINE : GSYM_FUNCTION)))\n     global_used(s, NULL);\n   else\n     {\n@@ -2925,6 +2910,7 @@ add_global_entry (const char * name, int sub)\n   return false;\n }\n \n+\n /* Match an ENTRY statement.  */\n \n match\n@@ -2956,42 +2942,40 @@ gfc_match_entry (void)\n \t    gfc_error (\"ENTRY statement at %C cannot appear within a MODULE\");\n \t    break;\n \t  case COMP_BLOCK_DATA:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear within a BLOCK DATA\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"a BLOCK DATA\");\n \t    break;\n \t  case COMP_INTERFACE:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear within an INTERFACE\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"an INTERFACE\");\n \t    break;\n \t  case COMP_DERIVED:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear \"\n-\t       \"within a DERIVED TYPE block\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"a DERIVED TYPE block\");\n \t    break;\n \t  case COMP_IF:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear within an IF-THEN block\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"an IF-THEN block\");\n \t    break;\n \t  case COMP_DO:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear within a DO block\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"a DO block\");\n \t    break;\n \t  case COMP_SELECT:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear within a SELECT block\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"a SELECT block\");\n \t    break;\n \t  case COMP_FORALL:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear within a FORALL block\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"a FORALL block\");\n \t    break;\n \t  case COMP_WHERE:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear within a WHERE block\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"a WHERE block\");\n \t    break;\n \t  case COMP_CONTAINS:\n-\t    gfc_error\n-\t      (\"ENTRY statement at %C cannot appear \"\n-\t       \"within a contained subprogram\");\n+\t    gfc_error (\"ENTRY statement at %C cannot appear within \"\n+\t\t       \"a contained subprogram\");\n \t    break;\n \t  default:\n \t    gfc_internal_error (\"gfc_match_entry(): Bad state\");\n@@ -3000,8 +2984,9 @@ gfc_match_entry (void)\n     }\n \n   module_procedure = gfc_current_ns->parent != NULL\n-      && gfc_current_ns->parent->proc_name\n-      && gfc_current_ns->parent->proc_name->attr.flavor == FL_MODULE;\n+\t\t   && gfc_current_ns->parent->proc_name\n+\t\t   && gfc_current_ns->parent->proc_name->attr.flavor\n+\t\t      == FL_MODULE;\n \n   if (gfc_current_ns->parent != NULL\n       && gfc_current_ns->parent->proc_name\n@@ -3040,14 +3025,14 @@ gfc_match_entry (void)\n   else\n     {\n       /* An entry in a function.\n-         We need to take special care because writing\n-            ENTRY f()\n-         as\n-            ENTRY f\n-         is allowed, whereas\n-            ENTRY f() RESULT (r)\n-         can't be written as\n-            ENTRY f RESULT (r).  */\n+\t We need to take special care because writing\n+\t    ENTRY f()\n+\t as\n+\t    ENTRY f\n+\t is allowed, whereas\n+\t    ENTRY f() RESULT (r)\n+\t can't be written as\n+\t    ENTRY f RESULT (r).  */\n       if (!add_global_entry (name, 0))\n \treturn MATCH_ERROR;\n \n@@ -3085,8 +3070,8 @@ gfc_match_entry (void)\n \n \t  if (gfc_add_result (&result->attr, result->name, NULL) == FAILURE\n \t      || gfc_add_entry (&entry->attr, result->name, NULL) == FAILURE\n-\t      || gfc_add_function (&entry->attr, result->name,\n-\t\t\t\t   NULL) == FAILURE)\n+\t      || gfc_add_function (&entry->attr, result->name, NULL)\n+\t\t == FAILURE)\n \t    return MATCH_ERROR;\n \n \t  entry->result = result;\n@@ -3179,8 +3164,7 @@ contained_procedure (void)\n \n   for (s=gfc_state_stack; s; s=s->previous)\n     if ((s->state == COMP_SUBROUTINE || s->state == COMP_FUNCTION)\n-       && s->previous != NULL\n-       && s->previous->state == COMP_CONTAINS)\n+\t&& s->previous != NULL && s->previous->state == COMP_CONTAINS)\n       return 1;\n \n   return 0;\n@@ -3220,12 +3204,13 @@ set_enum_kind(void)\n     }\n }\n \n+\n /* Match any of the various end-block statements.  Returns the type of\n    END to the caller.  The END INTERFACE, END IF, END DO and END\n    SELECT statements cannot be replaced by a single END statement.  */\n \n match\n-gfc_match_end (gfc_statement * st)\n+gfc_match_end (gfc_statement *st)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_compile_state state;\n@@ -3240,14 +3225,14 @@ gfc_match_end (gfc_statement * st)\n     return MATCH_NO;\n \n   state = gfc_current_state ();\n-  block_name =\n-    gfc_current_block () == NULL ? NULL : gfc_current_block ()->name;\n+  block_name = gfc_current_block () == NULL\n+\t     ? NULL : gfc_current_block ()->name;\n \n   if (state == COMP_CONTAINS)\n     {\n       state = gfc_state_stack->previous->state;\n-      block_name = gfc_state_stack->previous->sym == NULL ? NULL\n-\t: gfc_state_stack->previous->sym->name;\n+      block_name = gfc_state_stack->previous->sym == NULL\n+\t\t ? NULL : gfc_state_stack->previous->sym->name;\n     }\n \n   switch (state)\n@@ -3448,24 +3433,23 @@ attr_decl1 (void)\n \n       if (current_attr.dimension && m == MATCH_NO)\n \t{\n-\t  gfc_error\n-\t    (\"Missing array specification at %L in DIMENSION statement\",\n-\t     &var_locus);\n+\t  gfc_error (\"Missing array specification at %L in DIMENSION \"\n+\t\t     \"statement\", &var_locus);\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n \t}\n \n       if ((current_attr.allocatable || current_attr.pointer)\n \t  && (m == MATCH_YES) && (as->type != AS_DEFERRED))\n \t{\n-\t  gfc_error (\"Array specification must be deferred at %L\",\n-\t\t     &var_locus);\n+\t  gfc_error (\"Array specification must be deferred at %L\", &var_locus);\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n \t}\n     }\n \n-  /* Update symbol table.  DIMENSION attribute is set in gfc_set_array_spec().  */\n+  /* Update symbol table.  DIMENSION attribute is set\n+     in gfc_set_array_spec().  */\n   if (current_attr.dimension == 0\n       && gfc_copy_attr (&sym->attr, &current_attr, NULL) == FAILURE)\n     {\n@@ -3608,8 +3592,7 @@ cray_pointer_decl (void)\n       else if (cptr->ts.kind < gfc_index_integer_kind)\n \tgfc_warning (\"Cray pointer at %C has %d bytes of precision;\"\n \t\t     \" memory addresses require %d bytes\",\n-\t\t     cptr->ts.kind,\n-\t\t     gfc_index_integer_kind);\n+\t\t     cptr->ts.kind, gfc_index_integer_kind);\n \n       if (gfc_match_char (',') != MATCH_YES)\n \t{\n@@ -3706,7 +3689,6 @@ gfc_match_external (void)\n }\n \n \n-\n match\n gfc_match_intent (void)\n {\n@@ -3753,8 +3735,8 @@ gfc_match_pointer (void)\n     {\n       if (!gfc_option.flag_cray_pointer)\n \t{\n-\t  gfc_error (\"Cray pointer declaration at %C requires -fcray-pointer\"\n-\t\t     \" flag\");\n+\t  gfc_error (\"Cray pointer declaration at %C requires -fcray-pointer \"\n+\t\t     \"flag\");\n \t  return MATCH_ERROR;\n \t}\n       return cray_pointer_decl ();\n@@ -3772,7 +3754,6 @@ gfc_match_pointer (void)\n match\n gfc_match_allocatable (void)\n {\n-\n   gfc_clear_attr (&current_attr);\n   current_attr.allocatable = 1;\n \n@@ -3783,7 +3764,6 @@ gfc_match_allocatable (void)\n match\n gfc_match_dimension (void)\n {\n-\n   gfc_clear_attr (&current_attr);\n   current_attr.dimension = 1;\n \n@@ -3794,7 +3774,6 @@ gfc_match_dimension (void)\n match\n gfc_match_target (void)\n {\n-\n   gfc_clear_attr (&current_attr);\n   current_attr.target = 1;\n \n@@ -3835,9 +3814,8 @@ access_attr_decl (gfc_statement st)\n \t  if (gfc_get_symbol (name, NULL, &sym))\n \t    goto done;\n \n-\t  if (gfc_add_access (&sym->attr,\n-\t\t\t      (st ==\n-\t\t\t       ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE,\n+\t  if (gfc_add_access (&sym->attr, (st == ST_PUBLIC)\n+\t\t\t\t\t  ? ACCESS_PUBLIC : ACCESS_PRIVATE,\n \t\t\t      sym->name, NULL) == FAILURE)\n \t    return MATCH_ERROR;\n \n@@ -3863,14 +3841,13 @@ access_attr_decl (gfc_statement st)\n \n \t  if (uop->access == ACCESS_UNKNOWN)\n \t    {\n-\t      uop->access =\n-\t\t(st == ST_PUBLIC) ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n+\t      uop->access = (st == ST_PUBLIC)\n+\t\t\t  ? ACCESS_PUBLIC : ACCESS_PRIVATE;\n \t    }\n \t  else\n \t    {\n-\t      gfc_error\n-\t\t(\"Access specification of the .%s. operator at %C has \"\n-\t\t \"already been specified\", sym->name);\n+\t      gfc_error (\"Access specification of the .%s. operator at %C \"\n+\t\t\t \"has already been specified\", sym->name);\n \t      goto done;\n \t    }\n \n@@ -3907,8 +3884,7 @@ gfc_match_protected (void)\n \n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \n-\t\t      \"Fortran 2003: PROTECTED statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PROTECTED statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -3926,8 +3902,8 @@ gfc_match_protected (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_protected (&sym->attr, sym->name,\n-  \t\t\t         &gfc_current_locus) == FAILURE)\n+\t  if (gfc_add_protected (&sym->attr, sym->name, &gfc_current_locus)\n+\t      == FAILURE)\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -3953,13 +3929,12 @@ gfc_match_protected (void)\n }\n \n \n-\n /* The PRIVATE statement is a bit weird in that it can be a attribute\n    declaration, but also works as a standlone statement inside of a\n    type declaration or a module.  */\n \n match\n-gfc_match_private (gfc_statement * st)\n+gfc_match_private (gfc_statement *st)\n {\n \n   if (gfc_match (\"private\") != MATCH_YES)\n@@ -3989,7 +3964,7 @@ gfc_match_private (gfc_statement * st)\n \n \n match\n-gfc_match_public (gfc_statement * st)\n+gfc_match_public (gfc_statement *st)\n {\n \n   if (gfc_match (\"public\") != MATCH_YES)\n@@ -4112,9 +4087,8 @@ gfc_match_save (void)\n     {\n       if (gfc_current_ns->seen_save)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t      \"Blanket SAVE statement at %C follows previous \"\n-\t\t\t      \"SAVE statement\")\n+\t  if (gfc_notify_std (GFC_STD_LEGACY, \"Blanket SAVE statement at %C \"\n+\t\t\t      \"follows previous SAVE statement\")\n \t      == FAILURE)\n \t    return MATCH_ERROR;\n \t}\n@@ -4125,8 +4099,8 @@ gfc_match_save (void)\n \n   if (gfc_current_ns->save_all)\n     {\n-      if (gfc_notify_std (GFC_STD_LEGACY, \n-\t\t\t  \"SAVE statement at %C follows blanket SAVE statement\")\n+      if (gfc_notify_std (GFC_STD_LEGACY, \"SAVE statement at %C follows \"\n+\t\t\t  \"blanket SAVE statement\")\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n     }\n@@ -4139,8 +4113,8 @@ gfc_match_save (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_save (&sym->attr, sym->name,\n-\t\t\t    &gfc_current_locus) == FAILURE)\n+\t  if (gfc_add_save (&sym->attr, sym->name, &gfc_current_locus)\n+\t      == FAILURE)\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -4183,8 +4157,7 @@ gfc_match_value (void)\n   gfc_symbol *sym;\n   match m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \n-\t\t      \"Fortran 2003: VALUE statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: VALUE statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -4202,8 +4175,8 @@ gfc_match_value (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_value (&sym->attr, sym->name,\n-  \t\t\t        &gfc_current_locus) == FAILURE)\n+\t  if (gfc_add_value (&sym->attr, sym->name, &gfc_current_locus)\n+\t      == FAILURE)\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -4234,8 +4207,7 @@ gfc_match_volatile (void)\n   gfc_symbol *sym;\n   match m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \n-\t\t      \"Fortran 2003: VOLATILE statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: VOLATILE statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -4253,8 +4225,8 @@ gfc_match_volatile (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_add_volatile (&sym->attr, sym->name,\n-  \t\t\t        &gfc_current_locus) == FAILURE)\n+\t  if (gfc_add_volatile (&sym->attr, sym->name, &gfc_current_locus)\n+\t      == FAILURE)\n \t    return MATCH_ERROR;\n \t  goto next_item;\n \n@@ -4296,8 +4268,8 @@ gfc_match_modproc (void)\n       || gfc_state_stack->previous == NULL\n       || current_interface.type == INTERFACE_NAMELESS)\n     {\n-      gfc_error\n-\t(\"MODULE PROCEDURE at %C must be in a generic module interface\");\n+      gfc_error (\"MODULE PROCEDURE at %C must be in a generic module \"\n+\t\t \"interface\");\n       return MATCH_ERROR;\n     }\n \n@@ -4358,8 +4330,7 @@ gfc_match_derived_decl (void)\n     {\n       if (gfc_find_state (COMP_MODULE) == FAILURE)\n \t{\n-\t  gfc_error\n-\t    (\"Derived type at %C can only be PRIVATE within a MODULE\");\n+\t  gfc_error (\"Derived type at %C can only be PRIVATE within a MODULE\");\n \t  return MATCH_ERROR;\n \t}\n \n@@ -4399,9 +4370,8 @@ gfc_match_derived_decl (void)\n       || strcmp (name, \"logical\") == 0\n       || strcmp (name, \"complex\") == 0)\n     {\n-      gfc_error\n-\t(\"Type name '%s' at %C cannot be the same as an intrinsic type\",\n-\t name);\n+      gfc_error (\"Type name '%s' at %C cannot be the same as an intrinsic \"\n+\t\t \"type\", name);\n       return MATCH_ERROR;\n     }\n \n@@ -4426,9 +4396,8 @@ gfc_match_derived_decl (void)\n \n   if (sym->components != NULL)\n     {\n-      gfc_error\n-\t(\"Derived type definition of '%s' at %C has already been defined\",\n-\t sym->name);\n+      gfc_error (\"Derived type definition of '%s' at %C has already been \"\n+\t\t \"defined\", sym->name);\n       return MATCH_ERROR;\n     }\n \n@@ -4481,8 +4450,7 @@ gfc_match_enum (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \n-\t\t      \"Fortran 2003: ENUM AND ENUMERATOR at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ENUM AND ENUMERATOR at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n "}, {"sha": "e0e44c283fd29b8c46652af1504425db9e232fb0", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 43, "deletions": 59, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=636dff67dd28fc952990b83580ffd96f6508a338", "patch": "@@ -1,5 +1,6 @@\n /* Dependency analysis\n-   Copyright (C) 2000, 2001, 2002, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n \n This file is part of GCC.\n@@ -24,7 +25,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    have different dependency checking functions for different types\n    if dependencies.  Ideally these would probably be merged.  */\n    \n-\n #include \"config.h\"\n #include \"gfortran.h\"\n #include \"dependency.h\"\n@@ -52,7 +52,7 @@ gfc_dependency;\n    def if the value could not be determined.  */\n \n int\n-gfc_expr_is_one (gfc_expr * expr, int def)\n+gfc_expr_is_one (gfc_expr *expr, int def)\n {\n   gcc_assert (expr != NULL);\n \n@@ -70,23 +70,22 @@ gfc_expr_is_one (gfc_expr * expr, int def)\n    and -2 if the relationship could not be determined.  */\n \n int\n-gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n+gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n {\n   gfc_actual_arglist *args1;\n   gfc_actual_arglist *args2;\n   int i;\n \n   if (e1->expr_type == EXPR_OP\n       && (e1->value.op.operator == INTRINSIC_UPLUS\n-          || e1->value.op.operator == INTRINSIC_PARENTHESES))\n+\t  || e1->value.op.operator == INTRINSIC_PARENTHESES))\n     return gfc_dep_compare_expr (e1->value.op.op1, e2);\n   if (e2->expr_type == EXPR_OP\n       && (e2->value.op.operator == INTRINSIC_UPLUS\n-          || e2->value.op.operator == INTRINSIC_PARENTHESES))\n+\t  || e2->value.op.operator == INTRINSIC_PARENTHESES))\n     return gfc_dep_compare_expr (e1, e2->value.op.op1);\n \n-  if (e1->expr_type == EXPR_OP\n-      && e1->value.op.operator == INTRINSIC_PLUS)\n+  if (e1->expr_type == EXPR_OP && e1->value.op.operator == INTRINSIC_PLUS)\n     {\n       /* Compare X+C vs. X.  */\n       if (e1->value.op.op2->expr_type == EXPR_CONSTANT\n@@ -95,8 +94,7 @@ gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n \treturn mpz_sgn (e1->value.op.op2->value.integer);\n \n       /* Compare P+Q vs. R+S.  */\n-      if (e2->expr_type == EXPR_OP\n-\t  && e2->value.op.operator == INTRINSIC_PLUS)\n+      if (e2->expr_type == EXPR_OP && e2->value.op.operator == INTRINSIC_PLUS)\n \t{\n \t  int l, r;\n \n@@ -129,8 +127,7 @@ gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n     }\n \n   /* Compare X vs. X+C.  */\n-  if (e2->expr_type == EXPR_OP\n-      && e2->value.op.operator == INTRINSIC_PLUS)\n+  if (e2->expr_type == EXPR_OP && e2->value.op.operator == INTRINSIC_PLUS)\n     {\n       if (e2->value.op.op2->expr_type == EXPR_CONSTANT\n \t  && e2->value.op.op2->ts.type == BT_INTEGER\n@@ -139,17 +136,15 @@ gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n     }\n \n   /* Compare X-C vs. X.  */\n-  if (e1->expr_type == EXPR_OP\n-      && e1->value.op.operator == INTRINSIC_MINUS)\n+  if (e1->expr_type == EXPR_OP && e1->value.op.operator == INTRINSIC_MINUS)\n     {\n       if (e1->value.op.op2->expr_type == EXPR_CONSTANT\n \t  && e1->value.op.op2->ts.type == BT_INTEGER\n \t  && gfc_dep_compare_expr (e1->value.op.op1, e2) == 0)\n \treturn -mpz_sgn (e1->value.op.op2->value.integer);\n \n       /* Compare P-Q vs. R-S.  */\n-      if (e2->expr_type == EXPR_OP\n-\t  && e2->value.op.operator == INTRINSIC_MINUS)\n+      if (e2->expr_type == EXPR_OP && e2->value.op.operator == INTRINSIC_MINUS)\n \t{\n \t  int l, r;\n \n@@ -169,8 +164,7 @@ gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n     }\n \n   /* Compare X vs. X-C.  */\n-  if (e2->expr_type == EXPR_OP\n-      && e2->value.op.operator == INTRINSIC_MINUS)\n+  if (e2->expr_type == EXPR_OP && e2->value.op.operator == INTRINSIC_MINUS)\n     {\n       if (e2->value.op.op2->expr_type == EXPR_CONSTANT\n \t  && e2->value.op.op2->ts.type == BT_INTEGER\n@@ -218,8 +212,7 @@ gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n \n     case EXPR_FUNCTION:\n       /* We can only compare calls to the same intrinsic function.  */\n-      if (e1->value.function.isym == 0\n-\t  || e2->value.function.isym == 0\n+      if (e1->value.function.isym == 0 || e2->value.function.isym == 0\n \t  || e1->value.function.isym != e2->value.function.isym)\n \treturn -2;\n \n@@ -275,7 +268,7 @@ gfc_dep_compare_expr (gfc_expr * e1, gfc_expr * e2)\n    if the results are indeterminate.  N is the dimension to compare.  */\n \n int\n-gfc_is_same_range (gfc_array_ref * ar1, gfc_array_ref * ar2, int n, int def)\n+gfc_is_same_range (gfc_array_ref *ar1, gfc_array_ref *ar2, int n, int def)\n {\n   gfc_expr *e1;\n   gfc_expr *e2;\n@@ -375,7 +368,7 @@ gfc_is_same_range (gfc_array_ref * ar1, gfc_array_ref * ar2, int n, int def)\n    whose data can be reused, otherwise return NULL.  */\n \n gfc_expr *\n-gfc_get_noncopying_intrinsic_argument (gfc_expr * expr)\n+gfc_get_noncopying_intrinsic_argument (gfc_expr *expr)\n {\n   if (expr->expr_type != EXPR_FUNCTION || !expr->value.function.isym)\n     return NULL;\n@@ -439,8 +432,8 @@ gfc_ref_needs_temporary_p (gfc_ref *ref)\n    temporary.  */\n \n static int\n-gfc_check_argument_var_dependency (gfc_expr * var, sym_intent intent,\n-\t\t\t\t   gfc_expr * expr)\n+gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n+\t\t\t\t   gfc_expr *expr)\n {\n   gcc_assert (var->expr_type == EXPR_VARIABLE);\n   gcc_assert (var->rank > 0);\n@@ -472,8 +465,8 @@ gfc_check_argument_var_dependency (gfc_expr * var, sym_intent intent,\n    array expression OTHER, not just variables.  */\n \n static int\n-gfc_check_argument_dependency (gfc_expr * other, sym_intent intent,\n-\t\t\t       gfc_expr * expr)\n+gfc_check_argument_dependency (gfc_expr *other, sym_intent intent,\n+\t\t\t       gfc_expr *expr)\n {\n   switch (other->expr_type)\n     {\n@@ -498,8 +491,8 @@ gfc_check_argument_dependency (gfc_expr * other, sym_intent intent,\n    FNSYM is the function being called, or NULL if not known.  */\n \n int\n-gfc_check_fncall_dependency (gfc_expr * other, sym_intent intent,\n-\t\t\t     gfc_symbol * fnsym, gfc_actual_arglist * actual)\n+gfc_check_fncall_dependency (gfc_expr *other, sym_intent intent,\n+\t\t\t     gfc_symbol *fnsym, gfc_actual_arglist *actual)\n {\n   gfc_formal_arglist *formal;\n   gfc_expr *expr;\n@@ -518,8 +511,7 @@ gfc_check_fncall_dependency (gfc_expr * other, sym_intent intent,\n \tcontinue;\n \n       /* Skip intent(in) arguments if OTHER itself is intent(in).  */\n-      if (formal\n-\t  && intent == INTENT_IN\n+      if (formal && intent == INTENT_IN\n \t  && formal->sym->attr.intent == INTENT_IN)\n \tcontinue;\n \n@@ -550,12 +542,10 @@ gfc_are_equivalenced_arrays (gfc_expr *e1, gfc_expr *e2)\n   gfc_equiv_info *s, *fl1, *fl2;\n \n   gcc_assert (e1->expr_type == EXPR_VARIABLE\n-\t\t&& e2->expr_type == EXPR_VARIABLE);\n+\t      && e2->expr_type == EXPR_VARIABLE);\n \n   if (!e1->symtree->n.sym->attr.in_equivalence\n-\t|| !e2->symtree->n.sym->attr.in_equivalence\n-\t|| !e1->rank\n-\t|| !e2->rank)\n+      || !e2->symtree->n.sym->attr.in_equivalence|| !e1->rank || !e2->rank)\n     return 0;\n \n   /* Go through the equiv_lists and return 1 if the variables\n@@ -607,7 +597,7 @@ gfc_are_equivalenced_arrays (gfc_expr *e1, gfc_expr *e2)\n    temporary.  */\n \n int\n-gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, bool identical)\n+gfc_check_dependency (gfc_expr *expr1, gfc_expr *expr2, bool identical)\n {\n   gfc_ref *ref;\n   int n;\n@@ -637,13 +627,10 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, bool identical)\n \t    return 1;\n \n \t  /* Symbols can only alias if they have the same type.  */\n-\t  if (ts1->type != BT_UNKNOWN\n-\t      && ts2->type != BT_UNKNOWN\n-\t      && ts1->type != BT_DERIVED\n-\t      && ts2->type != BT_DERIVED)\n+\t  if (ts1->type != BT_UNKNOWN && ts2->type != BT_UNKNOWN\n+\t      && ts1->type != BT_DERIVED && ts2->type != BT_DERIVED)\n \t    {\n-\t      if (ts1->type != ts2->type\n-\t\t  || ts1->kind != ts2->kind)\n+\t      if (ts1->type != ts2->type || ts1->kind != ts2->kind)\n \t\treturn 0;\n \t    }\n \n@@ -710,7 +697,7 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, bool identical)\n /* Determines overlapping for two array sections.  */\n \n static gfc_dependency\n-gfc_check_section_vs_section (gfc_ref * lref, gfc_ref * rref, int n)\n+gfc_check_section_vs_section (gfc_ref *lref, gfc_ref *rref, int n)\n {\n   gfc_array_ref l_ar;\n   gfc_expr *l_start;\n@@ -761,7 +748,7 @@ gfc_check_section_vs_section (gfc_ref * lref, gfc_ref * rref, int n)\n   if (!l_stride)\n     l_dir = 1;\n   else if (l_stride->expr_type == EXPR_CONSTANT\n-           && l_stride->ts.type == BT_INTEGER)\n+\t   && l_stride->ts.type == BT_INTEGER)\n     l_dir = mpz_sgn (l_stride->value.integer);\n   else if (l_start && l_end)\n     l_dir = gfc_dep_compare_expr (l_end, l_start);\n@@ -772,7 +759,7 @@ gfc_check_section_vs_section (gfc_ref * lref, gfc_ref * rref, int n)\n   if (!r_stride)\n     r_dir = 1;\n   else if (r_stride->expr_type == EXPR_CONSTANT\n-           && r_stride->ts.type == BT_INTEGER)\n+\t   && r_stride->ts.type == BT_INTEGER)\n     r_dir = mpz_sgn (r_stride->value.integer);\n   else if (r_start && r_end)\n     r_dir = gfc_dep_compare_expr (r_end, r_start);\n@@ -827,18 +814,18 @@ gfc_check_section_vs_section (gfc_ref * lref, gfc_ref * rref, int n)\n   if (l_start && r_start && gfc_dep_compare_expr (l_start, r_start) == 0)\n     {\n       if (l_dir == 1 && r_dir == -1)\n-        return GFC_DEP_EQUAL;\n+\treturn GFC_DEP_EQUAL;\n       if (l_dir == -1 && r_dir == 1)\n-        return GFC_DEP_EQUAL;\n+\treturn GFC_DEP_EQUAL;\n     }\n \n   /* Handle cases like x:y:1 vs. z:y:-1 as GFC_DEP_EQUAL.  */\n   if (l_end && r_end && gfc_dep_compare_expr (l_end, r_end) == 0)\n     {\n       if (l_dir == 1 && r_dir == -1)\n-        return GFC_DEP_EQUAL;\n+\treturn GFC_DEP_EQUAL;\n       if (l_dir == -1 && r_dir == 1)\n-        return GFC_DEP_EQUAL;\n+\treturn GFC_DEP_EQUAL;\n     }\n \n   /* Check for forward dependencies x:y vs. x+1:z.  */\n@@ -874,7 +861,7 @@ gfc_check_section_vs_section (gfc_ref * lref, gfc_ref * rref, int n)\n /* Determines overlapping for a single element and a section.  */\n \n static gfc_dependency\n-gfc_check_element_vs_section( gfc_ref * lref, gfc_ref * rref, int n)\n+gfc_check_element_vs_section( gfc_ref *lref, gfc_ref *rref, int n)\n {\n   gfc_array_ref *ref;\n   gfc_expr *elem;\n@@ -999,7 +986,7 @@ gfc_check_element_vs_section( gfc_ref * lref, gfc_ref * rref, int n)\n    return true, and assume a dependency.  */\n \n static bool\n-contains_forall_index_p (gfc_expr * expr)\n+contains_forall_index_p (gfc_expr *expr)\n {\n   gfc_actual_arglist *arg;\n   gfc_constructor *c;\n@@ -1074,7 +1061,7 @@ contains_forall_index_p (gfc_expr * expr)\n /* Determines overlapping for two single element array references.  */\n \n static gfc_dependency\n-gfc_check_element_vs_element (gfc_ref * lref, gfc_ref * rref, int n)\n+gfc_check_element_vs_element (gfc_ref *lref, gfc_ref *rref, int n)\n {\n   gfc_array_ref l_ar;\n   gfc_array_ref r_ar;\n@@ -1099,8 +1086,7 @@ gfc_check_element_vs_element (gfc_ref * lref, gfc_ref * rref, int n)\n   /* However, we need to be careful when either scalar expression\n      contains a FORALL index, as these can potentially change value\n      during the scalarization/traversal of this array reference.  */\n-  if (contains_forall_index_p (r_start)\n-      || contains_forall_index_p (l_start))\n+  if (contains_forall_index_p (r_start) || contains_forall_index_p (l_start))\n     return GFC_DEP_OVERLAP;\n \n   if (i != -2)\n@@ -1141,8 +1127,7 @@ gfc_full_array_ref_p (gfc_ref *ref)\n \t\t\t\t       ref->u.ar.as->upper[i])))\n \treturn false;\n       /* Check the stride.  */\n-      if (ref->u.ar.stride[i]\n-\t  && !gfc_expr_is_one (ref->u.ar.stride[i], 0))\n+      if (ref->u.ar.stride[i] && !gfc_expr_is_one (ref->u.ar.stride[i], 0))\n \treturn false;\n     }\n   return true;\n@@ -1155,13 +1140,12 @@ gfc_full_array_ref_p (gfc_ref *ref)\n    \t0 : array references are identical or not overlapping.  */\n \n int\n-gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n+gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n {\n   int n;\n   gfc_dependency fin_dep;\n   gfc_dependency this_dep;\n \n-\n   fin_dep = GFC_DEP_ERROR;\n   /* Dependencies due to pointers should already have been identified.\n      We only need to check for overlapping array references.  */\n@@ -1186,7 +1170,7 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n \t  return 0;\n \t\n \tcase REF_ARRAY:\n-          if (lref->u.ar.dimen != rref->u.ar.dimen)\n+\t  if (lref->u.ar.dimen != rref->u.ar.dimen)\n \t    {\n \t      if (lref->u.ar.type == AR_FULL)\n \t\tfin_dep = gfc_full_array_ref_p (rref) ? GFC_DEP_EQUAL\n@@ -1195,7 +1179,7 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n \t\tfin_dep = gfc_full_array_ref_p (lref) ? GFC_DEP_EQUAL\n \t\t\t\t\t\t      : GFC_DEP_OVERLAP;\n \t      else\n-                return 1;\n+\t\treturn 1;\n \t      break;\n \t    }\n "}, {"sha": "6f2a6a74f8fee1e2e74078bae16f5f4afbff34b2", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 52, "deletions": 58, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=636dff67dd28fc952990b83580ffd96f6508a338", "patch": "@@ -1,5 +1,6 @@\n /* Parse tree dumper\n-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Steven Bosscher\n \n This file is part of GCC.\n@@ -40,7 +41,7 @@ static int show_level = 0;\n /* Do indentation for a specific level.  */\n \n static inline void\n-code_indent (int level, gfc_st_label * label)\n+code_indent (int level, gfc_st_label *label)\n {\n   int i;\n \n@@ -68,9 +69,8 @@ show_indent (void)\n /* Show type-specific information.  */\n \n void\n-gfc_show_typespec (gfc_typespec * ts)\n+gfc_show_typespec (gfc_typespec *ts)\n {\n-\n   gfc_status (\"(%s \", gfc_basic_typename (ts->type));\n \n   switch (ts->type)\n@@ -95,9 +95,8 @@ gfc_show_typespec (gfc_typespec * ts)\n /* Show an actual argument list.  */\n \n void\n-gfc_show_actual_arglist (gfc_actual_arglist * a)\n+gfc_show_actual_arglist (gfc_actual_arglist *a)\n {\n-\n   gfc_status (\"(\");\n \n   for (; a; a = a->next)\n@@ -122,7 +121,7 @@ gfc_show_actual_arglist (gfc_actual_arglist * a)\n /* Show a gfc_array_spec array specification structure.  */\n \n void\n-gfc_show_array_spec (gfc_array_spec * as)\n+gfc_show_array_spec (gfc_array_spec *as)\n {\n   const char *c;\n   int i;\n@@ -144,8 +143,8 @@ gfc_show_array_spec (gfc_array_spec * as)\n \tcase AS_ASSUMED_SIZE:  c = \"AS_ASSUMED_SIZE\";  break;\n \tcase AS_ASSUMED_SHAPE: c = \"AS_ASSUMED_SHAPE\"; break;\n \tdefault:\n-\t  gfc_internal_error\n-\t\t(\"gfc_show_array_spec(): Unhandled array shape type.\");\n+\t  gfc_internal_error (\"gfc_show_array_spec(): Unhandled array shape \"\n+\t\t\t      \"type.\");\n       }\n       gfc_status (\" %s \", c);\n \n@@ -233,9 +232,8 @@ gfc_show_array_ref (gfc_array_ref * ar)\n /* Show a list of gfc_ref structures.  */\n \n void\n-gfc_show_ref (gfc_ref * p)\n+gfc_show_ref (gfc_ref *p)\n {\n-\n   for (; p; p = p->next)\n     switch (p->type)\n       {\n@@ -264,9 +262,8 @@ gfc_show_ref (gfc_ref * p)\n /* Display a constructor.  Works recursively for array constructors.  */\n \n void\n-gfc_show_constructor (gfc_constructor * c)\n+gfc_show_constructor (gfc_constructor *c)\n {\n-\n   for (; c; c = c->next)\n     {\n       if (c->iterator == NULL)\n@@ -297,7 +294,7 @@ gfc_show_constructor (gfc_constructor * c)\n /* Show an expression.  */\n \n void\n-gfc_show_expr (gfc_expr * p)\n+gfc_show_expr (gfc_expr *p)\n {\n   const char *c;\n   int i;\n@@ -530,7 +527,7 @@ gfc_show_expr (gfc_expr * p)\n    whatever single bit attributes are present.  */\n \n void\n-gfc_show_attr (symbol_attribute * attr)\n+gfc_show_attr (symbol_attribute *attr)\n {\n \n   gfc_status (\"(%s %s %s %s\", gfc_code2string (flavors, attr->flavor),\n@@ -601,7 +598,7 @@ gfc_show_attr (symbol_attribute * attr)\n /* Show components of a derived type.  */\n \n void\n-gfc_show_components (gfc_symbol * sym)\n+gfc_show_components (gfc_symbol *sym)\n {\n   gfc_component *c;\n \n@@ -628,7 +625,7 @@ gfc_show_components (gfc_symbol * sym)\n    that symbol.  */\n \n void\n-gfc_show_symbol (gfc_symbol * sym)\n+gfc_show_symbol (gfc_symbol *sym)\n {\n   gfc_formal_arglist *formal;\n   gfc_interface *intr;\n@@ -683,12 +680,12 @@ gfc_show_symbol (gfc_symbol * sym)\n       gfc_status (\"Formal arglist:\");\n \n       for (formal = sym->formal; formal; formal = formal->next)\n-        {\n-          if (formal->sym != NULL)\n-            gfc_status (\" %s\", formal->sym->name);\n-          else\n-            gfc_status (\" [Alt Return]\");\n-        }\n+\t{\n+\t  if (formal->sym != NULL)\n+\t    gfc_status (\" %s\", formal->sym->name);\n+\t  else\n+\t    gfc_status (\" [Alt Return]\");\n+\t}\n     }\n \n   if (sym->formal_ns)\n@@ -706,7 +703,7 @@ gfc_show_symbol (gfc_symbol * sym)\n    and the name of the associated subroutine, really.  */\n \n static void\n-show_uop (gfc_user_op * uop)\n+show_uop (gfc_user_op *uop)\n {\n   gfc_interface *intr;\n \n@@ -721,9 +718,8 @@ show_uop (gfc_user_op * uop)\n /* Workhorse function for traversing the user operator symtree.  */\n \n static void\n-traverse_uop (gfc_symtree * st, void (*func) (gfc_user_op *))\n+traverse_uop (gfc_symtree *st, void (*func) (gfc_user_op *))\n {\n-\n   if (st == NULL)\n     return;\n \n@@ -737,17 +733,16 @@ traverse_uop (gfc_symtree * st, void (*func) (gfc_user_op *))\n /* Traverse the tree of user operator nodes.  */\n \n void\n-gfc_traverse_user_op (gfc_namespace * ns, void (*func) (gfc_user_op *))\n+gfc_traverse_user_op (gfc_namespace *ns, void (*func) (gfc_user_op *))\n {\n-\n   traverse_uop (ns->uop_root, func);\n }\n \n \n /* Function to display a common block.  */\n \n static void\n-show_common (gfc_symtree * st)\n+show_common (gfc_symtree *st)\n {\n   gfc_symbol *s;\n \n@@ -769,9 +764,8 @@ show_common (gfc_symtree * st)\n /* Worker function to display the symbol tree.  */\n \n static void\n-show_symtree (gfc_symtree * st)\n+show_symtree (gfc_symtree *st)\n {\n-\n   show_indent ();\n   gfc_status (\"symtree: %s  Ambig %d\", st->name, st->ambiguous);\n \n@@ -786,15 +780,14 @@ show_symtree (gfc_symtree * st)\n \n \n \n-static void gfc_show_code_node (int level, gfc_code * c);\n+static void gfc_show_code_node (int, gfc_code *);\n \n /* Show a list of code structures.  Mutually recursive with\n    gfc_show_code_node().  */\n \n void\n-gfc_show_code (int level, gfc_code * c)\n+gfc_show_code (int level, gfc_code *c)\n {\n-\n   for (; c; c = c->next)\n     gfc_show_code_node (level, c);\n }\n@@ -811,7 +804,7 @@ gfc_show_namelist (gfc_namelist *n)\n    if necessary.  */\n \n static void\n-gfc_show_omp_node (int level, gfc_code * c)\n+gfc_show_omp_node (int level, gfc_code *c)\n {\n   gfc_omp_clauses *omp_clauses = NULL;\n   const char *name = NULL;\n@@ -996,10 +989,11 @@ gfc_show_omp_node (int level, gfc_code * c)\n     gfc_status (\" (%s)\", c->ext.omp_name);\n }\n \n+\n /* Show a single code node and everything underneath it if necessary.  */\n \n static void\n-gfc_show_code_node (int level, gfc_code * c)\n+gfc_show_code_node (int level, gfc_code *c)\n {\n   gfc_forall_iterator *fa;\n   gfc_open *open;\n@@ -1051,24 +1045,24 @@ gfc_show_code_node (int level, gfc_code * c)\n     case EXEC_GOTO:\n       gfc_status (\"GOTO \");\n       if (c->label)\n-        gfc_status (\"%d\", c->label->value);\n+\tgfc_status (\"%d\", c->label->value);\n       else\n-        {\n-          gfc_show_expr (c->expr);\n-          d = c->block;\n-          if (d != NULL)\n-            {\n-              gfc_status (\", (\");\n-              for (; d; d = d ->block)\n-                {\n-                  code_indent (level, d->label);\n-                  if (d->block != NULL)\n-                    gfc_status_char (',');\n-                  else\n-                    gfc_status_char (')');\n-                }\n-            }\n-        }\n+\t{\n+\t  gfc_show_expr (c->expr);\n+\t  d = c->block;\n+\t  if (d != NULL)\n+\t    {\n+\t      gfc_status (\", (\");\n+\t      for (; d; d = d ->block)\n+\t\t{\n+\t\t  code_indent (level, d->label);\n+\t\t  if (d->block != NULL)\n+\t\t    gfc_status_char (',');\n+\t\t  else\n+\t\t    gfc_status_char (')');\n+\t\t}\n+\t    }\n+\t}\n       break;\n \n     case EXEC_CALL:\n@@ -1092,19 +1086,19 @@ gfc_show_code_node (int level, gfc_code * c)\n       gfc_status (\"PAUSE \");\n \n       if (c->expr != NULL)\n-        gfc_show_expr (c->expr);\n+\tgfc_show_expr (c->expr);\n       else\n-        gfc_status (\"%d\", c->ext.stop_code);\n+\tgfc_status (\"%d\", c->ext.stop_code);\n \n       break;\n \n     case EXEC_STOP:\n       gfc_status (\"STOP \");\n \n       if (c->expr != NULL)\n-        gfc_show_expr (c->expr);\n+\tgfc_show_expr (c->expr);\n       else\n-        gfc_status (\"%d\", c->ext.stop_code);\n+\tgfc_status (\"%d\", c->ext.stop_code);\n \n       break;\n \n@@ -1709,7 +1703,7 @@ gfc_show_equiv (gfc_equiv *eq)\n /* Show a freakin' whole namespace.  */\n \n void\n-gfc_show_namespace (gfc_namespace * ns)\n+gfc_show_namespace (gfc_namespace *ns)\n {\n   gfc_interface *intr;\n   gfc_namespace *save;"}, {"sha": "89cd4a9ac32636cb8bbf94ac16ceb57400f80a8e", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=636dff67dd28fc952990b83580ffd96f6508a338", "patch": "@@ -1,6 +1,6 @@\n /* Handle errors.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software\n-   Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught & Niels Kristian Bech Jensen\n \n This file is part of GCC.\n@@ -69,12 +69,10 @@ error_char (char c)\n     {\n       if (cur_error_buffer->index >= cur_error_buffer->allocated)\n \t{\n-\t  cur_error_buffer->allocated =\n-\t    cur_error_buffer->allocated\n-\t    ? cur_error_buffer->allocated * 2 : 1000;\n-\t  cur_error_buffer->message\n-\t    = xrealloc (cur_error_buffer->message,\n-\t\t\tcur_error_buffer->allocated);\n+\t  cur_error_buffer->allocated = cur_error_buffer->allocated\n+\t\t\t\t      ? cur_error_buffer->allocated * 2 : 1000;\n+\t  cur_error_buffer->message = xrealloc (cur_error_buffer->message,\n+\t\t\t\t\t\tcur_error_buffer->allocated);\n \t}\n       cur_error_buffer->message[cur_error_buffer->index++] = c;\n     }\n@@ -152,7 +150,7 @@ error_integer (int i)\n static void error_printf (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n \n static void\n-show_locus (locus * loc, int c1, int c2)\n+show_locus (locus *loc, int c1, int c2)\n {\n   gfc_linebuf *lb;\n   gfc_file *f;\n@@ -308,7 +306,7 @@ show_locus (locus * loc, int c1, int c2)\n    loci may or may not be on the same source line.  */\n \n static void\n-show_loci (locus * l1, locus * l2)\n+show_loci (locus *l1, locus *l2)\n {\n   int m, c1, c2;\n \n@@ -349,7 +347,6 @@ show_loci (locus * l1, locus * l2)\n   show_locus (l1, c1, c2);\n \n   return;\n-\n }\n \n \n@@ -545,10 +542,10 @@ error_print (const char *type, const char *format0, va_list argp)\n \t}\n \n       format++;\n-      if (ISDIGIT(*format))\n+      if (ISDIGIT (*format))\n \t{\n \t  /* This is a position specifier.  See comment above.  */\n-\t  while (ISDIGIT(*format))\n+\t  while (ISDIGIT (*format))\n \t    format++;\n \t    \n \t  /* Skip over the dollar sign.  */\n@@ -663,17 +660,15 @@ gfc_notify_std (int std, const char *nocmsgid, ...)\n   va_list argp;\n   bool warning;\n \n-  warning = ((gfc_option.warn_std & std) != 0)\n-\t    && !inhibit_warnings;\n-  if ((gfc_option.allow_std & std) != 0\n-      && !warning)\n+  warning = ((gfc_option.warn_std & std) != 0) && !inhibit_warnings;\n+  if ((gfc_option.allow_std & std) != 0 && !warning)\n     return SUCCESS;\n \n   if (gfc_suppress_error)\n     return warning ? SUCCESS : FAILURE;\n \n   cur_error_buffer = (warning && !warnings_are_errors)\n-    ? &warning_buffer : &error_buffer;\n+\t\t   ? &warning_buffer : &error_buffer;\n   cur_error_buffer->flag = 1;\n   cur_error_buffer->index = 0;\n \n@@ -889,7 +884,7 @@ gfc_error_check (void)\n /* Save the existing error state.  */\n \n void\n-gfc_push_error (gfc_error_buf * err)\n+gfc_push_error (gfc_error_buf *err)\n {\n   err->flag = error_buffer.flag;\n   if (error_buffer.flag)\n@@ -902,7 +897,7 @@ gfc_push_error (gfc_error_buf * err)\n /* Restore a previous pushed error state.  */\n \n void\n-gfc_pop_error (gfc_error_buf * err)\n+gfc_pop_error (gfc_error_buf *err)\n {\n   error_buffer.flag = err->flag;\n   if (error_buffer.flag)\n@@ -918,7 +913,7 @@ gfc_pop_error (gfc_error_buf * err)\n /* Free a pushed error state, but keep the current error state.  */\n \n void\n-gfc_free_error (gfc_error_buf * err)\n+gfc_free_error (gfc_error_buf *err)\n {\n   if (err->flag)\n     gfc_free (err->message);"}, {"sha": "dbe51888656bf1549aada81e4b58a4bfb3984d15", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 158, "deletions": 183, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/636dff67dd28fc952990b83580ffd96f6508a338/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=636dff67dd28fc952990b83580ffd96f6508a338", "patch": "@@ -1,6 +1,6 @@\n /* Routines for manipulation of expression nodes.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software \n-   Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -34,7 +34,6 @@ gfc_get_expr (void)\n   gfc_expr *e;\n \n   e = gfc_getmem (sizeof (gfc_expr));\n-\n   gfc_clear_ts (&e->ts);\n   e->shape = NULL;\n   e->ref = NULL;\n@@ -47,7 +46,7 @@ gfc_get_expr (void)\n /* Free an argument list and everything below it.  */\n \n void\n-gfc_free_actual_arglist (gfc_actual_arglist * a1)\n+gfc_free_actual_arglist (gfc_actual_arglist *a1)\n {\n   gfc_actual_arglist *a2;\n \n@@ -64,7 +63,7 @@ gfc_free_actual_arglist (gfc_actual_arglist * a1)\n /* Copy an arglist structure and all of the arguments.  */\n \n gfc_actual_arglist *\n-gfc_copy_actual_arglist (gfc_actual_arglist * p)\n+gfc_copy_actual_arglist (gfc_actual_arglist *p)\n {\n   gfc_actual_arglist *head, *tail, *new;\n \n@@ -93,7 +92,7 @@ gfc_copy_actual_arglist (gfc_actual_arglist * p)\n /* Free a list of reference structures.  */\n \n void\n-gfc_free_ref_list (gfc_ref * p)\n+gfc_free_ref_list (gfc_ref *p)\n {\n   gfc_ref *q;\n   int i;\n@@ -134,7 +133,7 @@ gfc_free_ref_list (gfc_ref * p)\n    something else or the expression node belongs to another structure.  */\n \n static void\n-free_expr0 (gfc_expr * e)\n+free_expr0 (gfc_expr *e)\n {\n   int n;\n \n@@ -221,9 +220,8 @@ free_expr0 (gfc_expr * e)\n /* Free an expression node and everything beneath it.  */\n \n void\n-gfc_free_expr (gfc_expr * e)\n+gfc_free_expr (gfc_expr *e)\n {\n-\n   if (e == NULL)\n     return;\n   if (e->con_by_offset)\n@@ -236,12 +234,10 @@ gfc_free_expr (gfc_expr * e)\n /* Graft the *src expression onto the *dest subexpression.  */\n \n void\n-gfc_replace_expr (gfc_expr * dest, gfc_expr * src)\n+gfc_replace_expr (gfc_expr *dest, gfc_expr *src)\n {\n-\n   free_expr0 (dest);\n   *dest = *src;\n-\n   gfc_free (src);\n }\n \n@@ -252,9 +248,8 @@ gfc_replace_expr (gfc_expr * dest, gfc_expr * src)\n    failure is OK for some callers.  */\n \n const char *\n-gfc_extract_int (gfc_expr * expr, int *result)\n+gfc_extract_int (gfc_expr *expr, int *result)\n {\n-\n   if (expr->expr_type != EXPR_CONSTANT)\n     return _(\"Constant expression required at %C\");\n \n@@ -276,7 +271,7 @@ gfc_extract_int (gfc_expr * expr, int *result)\n /* Recursively copy a list of reference structures.  */\n \n static gfc_ref *\n-copy_ref (gfc_ref * src)\n+copy_ref (gfc_ref *src)\n {\n   gfc_array_ref *ar;\n   gfc_ref *dest;\n@@ -312,13 +307,12 @@ copy_ref (gfc_ref * src)\n }\n \n \n-/* Detect whether an expression has any vector index array\n-   references.  */\n+/* Detect whether an expression has any vector index array references.  */\n \n int\n gfc_has_vector_index (gfc_expr *e)\n {\n-  gfc_ref * ref;\n+  gfc_ref *ref;\n   int i;\n   for (ref = e->ref; ref; ref = ref->next)\n     if (ref->type == REF_ARRAY)\n@@ -332,7 +326,7 @@ gfc_has_vector_index (gfc_expr *e)\n /* Copy a shape array.  */\n \n mpz_t *\n-gfc_copy_shape (mpz_t * shape, int rank)\n+gfc_copy_shape (mpz_t *shape, int rank)\n {\n   mpz_t *new_shape;\n   int n;\n@@ -363,7 +357,7 @@ gfc_copy_shape (mpz_t * shape, int rank)\n */\n \n mpz_t *\n-gfc_copy_shape_excluding (mpz_t * shape, int rank, gfc_expr * dim)\n+gfc_copy_shape_excluding (mpz_t *shape, int rank, gfc_expr *dim)\n {\n   mpz_t *new_shape, *s;\n   int i, n;\n@@ -380,24 +374,25 @@ gfc_copy_shape_excluding (mpz_t * shape, int rank, gfc_expr * dim)\n   if (n < 0 || n >= rank)\n     return NULL;\n \n-  s = new_shape = gfc_get_shape (rank-1);\n+  s = new_shape = gfc_get_shape (rank - 1);\n \n   for (i = 0; i < rank; i++)\n     {\n       if (i == n)\n-        continue;\n+\tcontinue;\n       mpz_init_set (*s, shape[i]);\n       s++;\n     }\n \n   return new_shape;\n }\n \n+\n /* Given an expression pointer, return a copy of the expression.  This\n    subroutine is recursive.  */\n \n gfc_expr *\n-gfc_copy_expr (gfc_expr * p)\n+gfc_copy_expr (gfc_expr *p)\n {\n   gfc_expr *q;\n   char *s;\n@@ -423,8 +418,7 @@ gfc_copy_expr (gfc_expr * p)\n \t  s = gfc_getmem (p->value.character.length + 1);\n \t  q->value.character.string = s;\n \n-\t  memcpy (s, p->value.character.string,\n-\t\t  p->value.character.length + 1);\n+\t  memcpy (s, p->value.character.string, p->value.character.length + 1);\n \t  break;\n \t}\n       switch (q->ts.type)\n@@ -434,15 +428,15 @@ gfc_copy_expr (gfc_expr * p)\n \t  break;\n \n \tcase BT_REAL:\n-          gfc_set_model_kind (q->ts.kind);\n-          mpfr_init (q->value.real);\n+\t  gfc_set_model_kind (q->ts.kind);\n+\t  mpfr_init (q->value.real);\n \t  mpfr_set (q->value.real, p->value.real, GFC_RND_MODE);\n \t  break;\n \n \tcase BT_COMPLEX:\n-          gfc_set_model_kind (q->ts.kind);\n-          mpfr_init (q->value.complex.r);\n-          mpfr_init (q->value.complex.i);\n+\t  gfc_set_model_kind (q->ts.kind);\n+\t  mpfr_init (q->value.complex.r);\n+\t  mpfr_init (q->value.complex.i);\n \t  mpfr_set (q->value.complex.r, p->value.complex.r, GFC_RND_MODE);\n \t  mpfr_set (q->value.complex.i, p->value.complex.i, GFC_RND_MODE);\n \t  break;\n@@ -452,8 +446,7 @@ gfc_copy_expr (gfc_expr * p)\n \t  s = gfc_getmem (p->value.character.length + 1);\n \t  q->value.character.string = s;\n \n-\t  memcpy (s, p->value.character.string,\n-\t\t  p->value.character.length + 1);\n+\t  memcpy (s, p->value.character.string, p->value.character.length + 1);\n \t  break;\n \n \tcase BT_LOGICAL:\n@@ -512,9 +505,8 @@ gfc_copy_expr (gfc_expr * p)\n    kind numbers mean more precision for numeric types.  */\n \n int\n-gfc_kind_max (gfc_expr * e1, gfc_expr * e2)\n+gfc_kind_max (gfc_expr *e1, gfc_expr *e2)\n {\n-\n   return (e1->ts.kind > e2->ts.kind) ? e1->ts.kind : e2->ts.kind;\n }\n \n@@ -524,17 +516,15 @@ gfc_kind_max (gfc_expr * e1, gfc_expr * e2)\n static int\n numeric_type (bt type)\n {\n-\n   return type == BT_COMPLEX || type == BT_REAL || type == BT_INTEGER;\n }\n \n \n /* Returns nonzero if the typespec is a numeric type, zero otherwise.  */\n \n int\n-gfc_numeric_ts (gfc_typespec * ts)\n+gfc_numeric_ts (gfc_typespec *ts)\n {\n-\n   return numeric_type (ts->type);\n }\n \n@@ -562,7 +552,7 @@ gfc_int_expr (int i)\n /* Returns an expression node that is a logical constant.  */\n \n gfc_expr *\n-gfc_logical_expr (int i, locus * where)\n+gfc_logical_expr (int i, locus *where)\n {\n   gfc_expr *p;\n \n@@ -586,7 +576,7 @@ gfc_logical_expr (int i, locus * where)\n    argument list with a NULL pointer terminating the list.  */\n \n gfc_expr *\n-gfc_build_conversion (gfc_expr * e)\n+gfc_build_conversion (gfc_expr *e)\n {\n   gfc_expr *p;\n \n@@ -612,7 +602,7 @@ gfc_build_conversion (gfc_expr * e)\n    1.0**2 stays as it is.  */\n \n void\n-gfc_type_convert_binary (gfc_expr * e)\n+gfc_type_convert_binary (gfc_expr *e)\n {\n   gfc_expr *op1, *op2;\n \n@@ -628,10 +618,9 @@ gfc_type_convert_binary (gfc_expr * e)\n   /* Kind conversions of same type.  */\n   if (op1->ts.type == op2->ts.type)\n     {\n-\n       if (op1->ts.kind == op2->ts.kind)\n \t{\n-          /* No type conversions.  */\n+\t  /* No type conversions.  */\n \t  e->ts = op1->ts;\n \t  goto done;\n \t}\n@@ -685,7 +674,7 @@ gfc_type_convert_binary (gfc_expr * e)\n    function expects that the expression has already been simplified.  */\n \n int\n-gfc_is_constant_expr (gfc_expr * e)\n+gfc_is_constant_expr (gfc_expr *e)\n {\n   gfc_constructor *c;\n   gfc_actual_arglist *arg;\n@@ -757,7 +746,7 @@ gfc_is_constant_expr (gfc_expr * e)\n /* Try to collapse intrinsic expressions.  */\n \n static try\n-simplify_intrinsic_op (gfc_expr * p, int type)\n+simplify_intrinsic_op (gfc_expr *p, int type)\n {\n   gfc_expr *op1, *op2, *result;\n \n@@ -882,9 +871,8 @@ simplify_intrinsic_op (gfc_expr * p, int type)\n    with gfc_simplify_expr().  */\n \n static try\n-simplify_constructor (gfc_constructor * c, int type)\n+simplify_constructor (gfc_constructor *c, int type)\n {\n-\n   for (; c; c = c->next)\n     {\n       if (c->iterator\n@@ -904,8 +892,8 @@ simplify_constructor (gfc_constructor * c, int type)\n /* Pull a single array element out of an array constructor.  */\n \n static try\n-find_array_element (gfc_constructor * cons, gfc_array_ref * ar,\n-\t\t    gfc_constructor ** rval)\n+find_array_element (gfc_constructor *cons, gfc_array_ref *ar,\n+\t\t    gfc_constructor **rval)\n {\n   unsigned long nelemen;\n   int i;\n@@ -930,10 +918,9 @@ find_array_element (gfc_constructor * cons, gfc_array_ref * ar,\n \n       /* Check the bounds.  */\n       if (ar->as->upper[i]\n-\t    && (mpz_cmp (e->value.integer,\n-\t\t\tar->as->upper[i]->value.integer) > 0\n-\t    || mpz_cmp (e->value.integer,\n-\t\t\tar->as->lower[i]->value.integer) < 0))\n+\t  && (mpz_cmp (e->value.integer, ar->as->upper[i]->value.integer) > 0\n+\t      || mpz_cmp (e->value.integer,\n+\t\t\t  ar->as->lower[i]->value.integer) < 0))\n \t{\n \t  gfc_error (\"index in dimension %d is out of bounds \"\n \t\t     \"at %L\", i + 1, &ar->c_where[i]);\n@@ -942,8 +929,7 @@ find_array_element (gfc_constructor * cons, gfc_array_ref * ar,\n \t  goto depart;\n \t}\n \n-      mpz_sub (delta, e->value.integer,\n-\t       ar->as->lower[i]->value.integer);\n+      mpz_sub (delta, e->value.integer, ar->as->lower[i]->value.integer);\n       mpz_add (offset, offset, delta);\n     }\n \n@@ -973,7 +959,7 @@ find_array_element (gfc_constructor * cons, gfc_array_ref * ar,\n /* Find a component of a structure constructor.  */\n \n static gfc_constructor *\n-find_component_ref (gfc_constructor * cons, gfc_ref * ref)\n+find_component_ref (gfc_constructor *cons, gfc_ref *ref)\n {\n   gfc_component *comp;\n   gfc_component *pick;\n@@ -994,7 +980,7 @@ find_component_ref (gfc_constructor * cons, gfc_ref * ref)\n    the subobject reference in the process.  */\n \n static void\n-remove_subobject_ref (gfc_expr * p, gfc_constructor * cons)\n+remove_subobject_ref (gfc_expr *p, gfc_constructor *cons)\n {\n   gfc_expr *e;\n \n@@ -1075,11 +1061,11 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       upper = ref->u.ar.as->upper[d];\n \n       if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR)  /* Vector subscript.  */\n-        {\n-          gcc_assert(begin);\n-\t  gcc_assert(begin->expr_type == EXPR_ARRAY); \n-\t  gcc_assert(begin->rank == 1);\n-\t  gcc_assert(begin->shape);\n+\t{\n+\t  gcc_assert (begin);\n+\t  gcc_assert (begin->expr_type == EXPR_ARRAY); \n+\t  gcc_assert (begin->rank == 1);\n+\t  gcc_assert (begin->shape);\n \n \t  vecsub[d] = begin->value.constructor;\n \t  mpz_set (ctr[d], vecsub[d]->expr->value.integer);\n@@ -1090,20 +1076,21 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t  for (c = vecsub[d]; c; c = c->next)\n \t    {\n \t      if (mpz_cmp (c->expr->value.integer, upper->value.integer) > 0\n-\t          || mpz_cmp (c->expr->value.integer, lower->value.integer) < 0)\n+\t\t  || mpz_cmp (c->expr->value.integer,\n+\t\t\t      lower->value.integer) < 0)\n \t\t{\n \t\t  gfc_error (\"index in dimension %d is out of bounds \"\n \t\t\t     \"at %L\", d + 1, &ref->u.ar.c_where[d]);\n \t\t  t = FAILURE;\n \t\t  goto cleanup;\n \t\t}\n \t    }\n-        }\n+\t}\n       else\n-        {\n+\t{\n \t  if ((begin && begin->expr_type != EXPR_CONSTANT)\n-\t\t|| (finish && finish->expr_type != EXPR_CONSTANT)\n-\t\t|| (step && step->expr_type != EXPR_CONSTANT))\n+\t      || (finish && finish->expr_type != EXPR_CONSTANT)\n+\t      || (step && step->expr_type != EXPR_CONSTANT))\n \t    {\n \t      t = FAILURE;\n \t      goto cleanup;\n@@ -1157,8 +1144,8 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t  mpz_div (tmp_mpz, tmp_mpz, stride[d]);\n \t  mpz_mul (nelts, nelts, tmp_mpz);\n \n-\t  /* An element reference reduces the rank of the expression; don't add\n-\t     anything to the shape array.  */\n+\t  /* An element reference reduces the rank of the expression; don't\n+\t     add anything to the shape array.  */\n \t  if (ref->u.ar.dimen_type[d] != DIMEN_ELEMENT) \n \t    mpz_set (expr->shape[shape_i++], tmp_mpz);\n \t}\n@@ -1178,7 +1165,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   /* Now clock through the array reference, calculating the index in\n      the source constructor and transferring the elements to the new\n      constructor.  */  \n-  for (idx = 0; idx < (int)mpz_get_si (nelts); idx++)\n+  for (idx = 0; idx < (int) mpz_get_si (nelts); idx++)\n     {\n       if (ref->u.ar.offset)\n \tmpz_set (ptr, ref->u.ar.offset->value.integer);\n@@ -1189,14 +1176,13 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n       for (d = 0; d < rank; d++)\n \t{\n \t  mpz_set (tmp_mpz, ctr[d]);\n-\t  mpz_sub (tmp_mpz, tmp_mpz,\n-\t\t   ref->u.ar.as->lower[d]->value.integer);\n+\t  mpz_sub (tmp_mpz, tmp_mpz, ref->u.ar.as->lower[d]->value.integer);\n \t  mpz_mul (tmp_mpz, tmp_mpz, delta[d]);\n \t  mpz_add (ptr, ptr, tmp_mpz);\n \n \t  if (!incr_ctr) continue;\n \n-\t  if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR)  /* Vector subscript.  */\n+\t  if (ref->u.ar.dimen_type[d] == DIMEN_VECTOR) /* Vector subscript.  */\n \t    {\n \t      gcc_assert(vecsub[d]);\n \n@@ -1213,9 +1199,9 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \t    {\n \t      mpz_add (ctr[d], ctr[d], stride[d]); \n \n-\t      if (mpz_cmp_ui (stride[d], 0) > 0 ?\n-\t\t    mpz_cmp (ctr[d], end[d]) > 0 :\n-\t\t    mpz_cmp (ctr[d], end[d]) < 0)\n+\t      if (mpz_cmp_ui (stride[d], 0) > 0\n+\t\t  ? mpz_cmp (ctr[d], end[d]) > 0\n+\t\t  : mpz_cmp (ctr[d], end[d]) < 0)\n \t\tmpz_set (ctr[d], start[d]);\n \t      else\n \t\tincr_ctr = false;\n@@ -1269,13 +1255,13 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n   char *chr;\n \n   if (p->ref->u.ss.start->expr_type != EXPR_CONSTANT\n-\t|| p->ref->u.ss.end->expr_type != EXPR_CONSTANT)\n+      || p->ref->u.ss.end->expr_type != EXPR_CONSTANT)\n     return FAILURE;\n \n   *newp = gfc_copy_expr (p);\n   chr = p->value.character.string;\n-  end = (int)mpz_get_ui (p->ref->u.ss.end->value.integer);\n-  start = (int)mpz_get_ui (p->ref->u.ss.start->value.integer);\n+  end = (int) mpz_get_ui (p->ref->u.ss.end->value.integer);\n+  start = (int) mpz_get_ui (p->ref->u.ss.start->value.integer);\n \n   (*newp)->value.character.length = end - start + 1;\n   strncpy ((*newp)->value.character.string, &chr[start - 1],\n@@ -1289,7 +1275,7 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n    parameter variable values are substituted.  */\n \n static try\n-simplify_const_ref (gfc_expr * p)\n+simplify_const_ref (gfc_expr *p)\n {\n   gfc_constructor *cons;\n   gfc_expr *newp;\n@@ -1302,8 +1288,7 @@ simplify_const_ref (gfc_expr * p)\n \t  switch (p->ref->u.ar.type)\n \t    {\n \t    case AR_ELEMENT:\n-\t      if (find_array_element (p->value.constructor,\n-\t\t\t\t      &p->ref->u.ar,\n+\t      if (find_array_element (p->value.constructor, &p->ref->u.ar,\n \t\t\t\t      &cons) == FAILURE)\n \t\treturn FAILURE;\n \n@@ -1322,7 +1307,7 @@ simplify_const_ref (gfc_expr * p)\n \n \t    case AR_FULL:\n \t      if (p->ref->next != NULL\n-\t\t    && (p->ts.type == BT_CHARACTER || p->ts.type == BT_DERIVED))\n+\t\t  && (p->ts.type == BT_CHARACTER || p->ts.type == BT_DERIVED))\n \t\t{\n \t\t  cons = p->value.constructor;\n \t\t  for (; cons; cons = cons->next)\n@@ -1364,7 +1349,7 @@ simplify_const_ref (gfc_expr * p)\n /* Simplify a chain of references.  */\n \n static try\n-simplify_ref_chain (gfc_ref * ref, int type)\n+simplify_ref_chain (gfc_ref *ref, int type)\n {\n   int n;\n \n@@ -1375,16 +1360,12 @@ simplify_ref_chain (gfc_ref * ref, int type)\n \tcase REF_ARRAY:\n \t  for (n = 0; n < ref->u.ar.dimen; n++)\n \t    {\n-\t      if (gfc_simplify_expr (ref->u.ar.start[n], type)\n-\t\t    == FAILURE)\n+\t      if (gfc_simplify_expr (ref->u.ar.start[n], type) == FAILURE)\n \t\treturn FAILURE;\n-\t      if (gfc_simplify_expr (ref->u.ar.end[n], type)\n-\t\t     == FAILURE)\n+\t      if (gfc_simplify_expr (ref->u.ar.end[n], type) == FAILURE)\n \t\treturn FAILURE;\n-\t      if (gfc_simplify_expr (ref->u.ar.stride[n], type)\n-\t\t     == FAILURE)\n+\t      if (gfc_simplify_expr (ref->u.ar.stride[n], type) == FAILURE)\n \t\treturn FAILURE;\n-\n \t    }\n \t  break;\n \n@@ -1405,7 +1386,7 @@ simplify_ref_chain (gfc_ref * ref, int type)\n \n /* Try to substitute the value of a parameter variable.  */\n static try\n-simplify_parameter_variable (gfc_expr * p, int type)\n+simplify_parameter_variable (gfc_expr *p, int type)\n {\n   gfc_expr *e;\n   try t;\n@@ -1423,7 +1404,7 @@ simplify_parameter_variable (gfc_expr * p, int type)\n \n   /* Only use the simplification if it eliminated all subobject\n      references.  */\n-  if (t == SUCCESS && ! e->ref)\n+  if (t == SUCCESS && !e->ref)\n     gfc_replace_expr (p, e);\n   else\n     gfc_free_expr (e);\n@@ -1446,12 +1427,12 @@ simplify_parameter_variable (gfc_expr * p, int type)\n    The expression type is defined for:\n      0   Basic expression parsing\n      1   Simplifying array constructors -- will substitute\n-         iterator values.\n+\t iterator values.\n    Returns FAILURE on error, SUCCESS otherwise.\n    NOTE: Will return SUCCESS even if the expression can not be simplified.  */\n \n try\n-gfc_simplify_expr (gfc_expr * p, int type)\n+gfc_simplify_expr (gfc_expr *p, int type)\n {\n   gfc_actual_arglist *ap;\n \n@@ -1489,7 +1470,7 @@ gfc_simplify_expr (gfc_expr * p, int type)\n \t  gfc_extract_int (p->ref->u.ss.end, &end);\n \t  s = gfc_getmem (end - start + 2);\n \t  memcpy (s, p->value.character.string + start, end - start);\n-\t  s[end-start+1] = '\\0';  /* TODO: C-style string for debugging.  */\n+\t  s[end - start + 1] = '\\0';  /* TODO: C-style string.  */\n \t  gfc_free (p->value.character.string);\n \t  p->value.character.string = s;\n \t  p->value.character.length = end - start;\n@@ -1510,7 +1491,7 @@ gfc_simplify_expr (gfc_expr * p, int type)\n \n     case EXPR_VARIABLE:\n       /* Only substitute array parameter variables if we are in an\n-         initialization expression, or we want a subsection.  */\n+\t initialization expression, or we want a subsection.  */\n       if (p->symtree->n.sym->attr.flavor == FL_PARAMETER\n \t  && (gfc_init_expr || p->ref\n \t      || p->symtree->n.sym->value->expr_type != EXPR_ARRAY))\n@@ -1539,9 +1520,8 @@ gfc_simplify_expr (gfc_expr * p, int type)\n       if (simplify_constructor (p->value.constructor, type) == FAILURE)\n \treturn FAILURE;\n \n-      if (p->expr_type == EXPR_ARRAY\n-\t    && p->ref && p->ref->type == REF_ARRAY\n-\t    && p->ref->u.ar.type == AR_FULL)\n+      if (p->expr_type == EXPR_ARRAY && p->ref && p->ref->type == REF_ARRAY\n+\t  && p->ref->u.ar.type == AR_FULL)\n \t  gfc_expand_constructor (p);\n \n       if (simplify_const_ref (p) == FAILURE)\n@@ -1559,9 +1539,8 @@ gfc_simplify_expr (gfc_expr * p, int type)\n    be declared as.  */\n \n static bt\n-et0 (gfc_expr * e)\n+et0 (gfc_expr *e)\n {\n-\n   if (e->expr_type == EXPR_VARIABLE && gfc_check_iter_variable (e) == SUCCESS)\n     return BT_INTEGER;\n \n@@ -1575,7 +1554,7 @@ et0 (gfc_expr * e)\n static try check_init_expr (gfc_expr *);\n \n static try\n-check_intrinsic_op (gfc_expr * e, try (*check_function) (gfc_expr *))\n+check_intrinsic_op (gfc_expr *e, try (*check_function) (gfc_expr *))\n {\n   gfc_expr *op1 = e->value.op.op1;\n   gfc_expr *op2 = e->value.op.op2;\n@@ -1605,7 +1584,7 @@ check_intrinsic_op (gfc_expr * e, try (*check_function) (gfc_expr *))\n \t{\n \t  gfc_error (\"Numeric or CHARACTER operands are required in \"\n \t\t     \"expression at %L\", &e->where);\n-         return FAILURE;\n+\t return FAILURE;\n \t}\n       break;\n \n@@ -1703,7 +1682,7 @@ check_intrinsic_op (gfc_expr * e, try (*check_function) (gfc_expr *))\n    this problem here.  */\n \n static try\n-check_inquiry (gfc_expr * e, int not_restricted)\n+check_inquiry (gfc_expr *e, int not_restricted)\n {\n   const char *name;\n \n@@ -1743,7 +1722,7 @@ check_inquiry (gfc_expr * e, int not_restricted)\n     {\n       if (e->symtree->n.sym->ts.type == BT_UNKNOWN\n \t  && gfc_set_default_type (e->symtree->n.sym, 0, gfc_current_ns)\n-            == FAILURE)\n+\t     == FAILURE)\n \treturn FAILURE;\n \n       e->ts = e->symtree->n.sym->ts;\n@@ -1752,8 +1731,8 @@ check_inquiry (gfc_expr * e, int not_restricted)\n   /* Assumed character length will not reduce to a constant expression\n      with LEN, as required by the standard.  */\n   if (i == 4 && not_restricted\n-\t&& e->symtree->n.sym->ts.type == BT_CHARACTER\n-\t&& e->symtree->n.sym->ts.cl->length == NULL)\n+      && e->symtree->n.sym->ts.type == BT_CHARACTER\n+      && e->symtree->n.sym->ts.cl->length == NULL)\n     gfc_notify_std (GFC_STD_GNU, \"assumed character length \"\n \t\t    \"variable '%s' in constant expression at %L\",\n \t\t    e->symtree->n.sym->name, &e->where);\n@@ -1770,7 +1749,7 @@ check_inquiry (gfc_expr * e, int not_restricted)\n    FAILURE is returned an error message has been generated.  */\n \n static try\n-check_init_expr (gfc_expr * e)\n+check_init_expr (gfc_expr *e)\n {\n   gfc_actual_arglist *ap;\n   match m;\n@@ -1809,7 +1788,7 @@ check_init_expr (gfc_expr * e)\n \t  if (m == MATCH_NO)\n \t    gfc_error (\"Function '%s' in initialization expression at %L \"\n \t\t       \"must be an intrinsic function\",\n-                       e->symtree->n.sym->name, &e->where);\n+\t\t       e->symtree->n.sym->name, &e->where);\n \n \t  if (m != MATCH_YES)\n \t    t = FAILURE;\n@@ -1882,7 +1861,7 @@ check_init_expr (gfc_expr * e)\n    expression, then reducing it to a constant.  */\n \n match\n-gfc_match_init_expr (gfc_expr ** result)\n+gfc_match_init_expr (gfc_expr **result)\n {\n   gfc_expr *expr;\n   match m;\n@@ -1914,9 +1893,8 @@ gfc_match_init_expr (gfc_expr ** result)\n \n   /* Not all inquiry functions are simplified to constant expressions\n      so it is necessary to call check_inquiry again.  */ \n-  if (!gfc_is_constant_expr (expr)\n-\t&& check_inquiry (expr, 1) == FAILURE\n-\t&& !gfc_in_match_data ())\n+  if (!gfc_is_constant_expr (expr) && check_inquiry (expr, 1) == FAILURE\n+      && !gfc_in_match_data ())\n     {\n       gfc_error (\"Initialization expression didn't reduce %C\");\n       return MATCH_ERROR;\n@@ -1928,15 +1906,14 @@ gfc_match_init_expr (gfc_expr ** result)\n }\n \n \n-\n static try check_restricted (gfc_expr *);\n \n /* Given an actual argument list, test to see that each argument is a\n    restricted expression and optionally if the expression type is\n    integer or character.  */\n \n static try\n-restricted_args (gfc_actual_arglist * a)\n+restricted_args (gfc_actual_arglist *a)\n {\n   for (; a; a = a->next)\n     {\n@@ -1954,7 +1931,7 @@ restricted_args (gfc_actual_arglist * a)\n /* Make sure a non-intrinsic function is a specification function.  */\n \n static try\n-external_spec_function (gfc_expr * e)\n+external_spec_function (gfc_expr *e)\n {\n   gfc_symbol *f;\n \n@@ -1996,7 +1973,7 @@ external_spec_function (gfc_expr * e)\n    restricted expression.  */\n \n static try\n-restricted_intrinsic (gfc_expr * e)\n+restricted_intrinsic (gfc_expr *e)\n {\n   /* TODO: Check constraints on inquiry functions.  7.1.6.2 (7).  */\n   if (check_inquiry (e, 0) == SUCCESS)\n@@ -2011,7 +1988,7 @@ restricted_intrinsic (gfc_expr * e)\n    return FAILURE.  */\n \n static try\n-check_restricted (gfc_expr * e)\n+check_restricted (gfc_expr *e)\n {\n   gfc_symbol *sym;\n   try t;\n@@ -2029,8 +2006,8 @@ check_restricted (gfc_expr * e)\n       break;\n \n     case EXPR_FUNCTION:\n-      t = e->value.function.esym ?\n-\texternal_spec_function (e) : restricted_intrinsic (e);\n+      t = e->value.function.esym ? external_spec_function (e)\n+\t\t\t\t : restricted_intrinsic (e);\n \n       break;\n \n@@ -2052,10 +2029,11 @@ check_restricted (gfc_expr * e)\n \t  break;\n \t}\n \n-      /* gfc_is_formal_arg broadcasts that a formal argument list is being processed\n-\t in resolve.c(resolve_formal_arglist).  This is done so that host associated\n-\t dummy array indices are accepted (PR23446). This mechanism also does the\n-\t same for the specification expressions of array-valued functions.  */\n+      /* gfc_is_formal_arg broadcasts that a formal argument list is being\n+\t processed in resolve.c(resolve_formal_arglist).  This is done so\n+\t that host associated dummy array indices are accepted (PR23446).\n+\t This mechanism also does the same for the specification expressions\n+\t of array-valued functions.  */\n       if (sym->attr.in_common\n \t  || sym->attr.use_assoc\n \t  || sym->attr.dummy\n@@ -2109,7 +2087,7 @@ check_restricted (gfc_expr * e)\n    we return FAILURE, an error has been generated.  */\n \n try\n-gfc_specification_expr (gfc_expr * e)\n+gfc_specification_expr (gfc_expr *e)\n {\n   if (e == NULL)\n     return SUCCESS;\n@@ -2138,8 +2116,7 @@ gfc_specification_expr (gfc_expr * e)\n /* Given two expressions, make sure that the arrays are conformable.  */\n \n try\n-gfc_check_conformance (const char *optype_msgid,\n-\t\t       gfc_expr * op1, gfc_expr * op2)\n+gfc_check_conformance (const char *optype_msgid, gfc_expr *op1, gfc_expr *op2)\n {\n   int op1_flag, op2_flag, d;\n   mpz_t op1_size, op2_size;\n@@ -2189,7 +2166,7 @@ gfc_check_conformance (const char *optype_msgid,\n    sure that the assignment can take place.  */\n \n try\n-gfc_check_assign (gfc_expr * lvalue, gfc_expr * rvalue, int conform)\n+gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n {\n   gfc_symbol *sym;\n   gfc_ref *ref;\n@@ -2219,10 +2196,9 @@ gfc_check_assign (gfc_expr * lvalue, gfc_expr * rvalue, int conform)\n    variable local to a function subprogram.  Its existence begins when\n    execution of the function is initiated and ends when execution of the\n    function is terminated.....\n-   Therefore, the left hand side is no longer a varaiable, when it is:*/\n-  if (sym->attr.flavor == FL_PROCEDURE\n-\t&& sym->attr.proc != PROC_ST_FUNCTION\n-\t&& !sym->attr.external)\n+   Therefore, the left hand side is no longer a varaiable, when it is:  */\n+  if (sym->attr.flavor == FL_PROCEDURE && sym->attr.proc != PROC_ST_FUNCTION\n+      && !sym->attr.external)\n     {\n       bool bad_proc;\n       bad_proc = false;\n@@ -2237,10 +2213,10 @@ gfc_check_assign (gfc_expr * lvalue, gfc_expr * rvalue, int conform)\n \n       /* (iii) A module or internal procedure....  */\n       if ((gfc_current_ns->proc_name->attr.proc == PROC_INTERNAL\n-\t     || gfc_current_ns->proc_name->attr.proc == PROC_MODULE)\n+\t   || gfc_current_ns->proc_name->attr.proc == PROC_MODULE)\n \t  && gfc_current_ns->parent\n \t  && (!(gfc_current_ns->parent->proc_name->attr.function\n-\t\t  || gfc_current_ns->parent->proc_name->attr.subroutine)\n+\t\t|| gfc_current_ns->parent->proc_name->attr.subroutine)\n \t      || gfc_current_ns->parent->proc_name->attr.is_main_program))\n \t{\n \t  /* .... that is not a function.... */ \n@@ -2285,8 +2261,8 @@ gfc_check_assign (gfc_expr * lvalue, gfc_expr * rvalue, int conform)\n        && lvalue->ref->u.ar.type == AR_FULL\n        && lvalue->ref->u.ar.as->cp_was_assumed)\n      {\n-       gfc_error (\"Vector assignment to assumed-size Cray Pointee at %L\"\n-\t\t  \" is illegal\", &lvalue->where);\n+       gfc_error (\"Vector assignment to assumed-size Cray Pointee at %L \"\n+\t\t  \"is illegal\", &lvalue->where);\n        return FAILURE;\n      }\n \n@@ -2332,7 +2308,7 @@ gfc_check_assign (gfc_expr * lvalue, gfc_expr * rvalue, int conform)\n    NULLIFY statement.  */\n \n try\n-gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n+gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n {\n   symbol_attribute attr;\n   gfc_ref *ref;\n@@ -2347,7 +2323,7 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n     }\n \n   if (lvalue->symtree->n.sym->attr.flavor == FL_PROCEDURE\n-\t&& lvalue->symtree->n.sym->attr.use_assoc)\n+      && lvalue->symtree->n.sym->attr.use_assoc)\n     {\n       gfc_error (\"'%s' in the pointer assignment at %L cannot be an \"\n \t\t \"l-value since it is a procedure\",\n@@ -2364,16 +2340,16 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n   for (ref = lvalue->ref; ref; ref = ref->next)\n     {\n       if (pointer)\n-        check_intent_in = 0;\n+\tcheck_intent_in = 0;\n \n       if (ref->type == REF_COMPONENT && ref->u.c.component->pointer)\n-        pointer = 1;\n+\tpointer = 1;\n     }\n \n   if (check_intent_in && lvalue->symtree->n.sym->attr.intent == INTENT_IN)\n     {\n       gfc_error (\"Cannot assign to INTENT(IN) variable '%s' at %L\",\n-                 lvalue->symtree->n.sym->name, &lvalue->where);\n+\t\t lvalue->symtree->n.sym->name, &lvalue->where);\n       return FAILURE;\n     }\n \n@@ -2387,8 +2363,7 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n \n   if (is_pure && gfc_impure_variable (lvalue->symtree->n.sym))\n     {\n-      gfc_error (\"Bad pointer object in PURE procedure at %L\",\n-\t\t &lvalue->where);\n+      gfc_error (\"Bad pointer object in PURE procedure at %L\", &lvalue->where);\n       return FAILURE;\n     }\n \n@@ -2415,7 +2390,7 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n   if (lvalue->rank != rvalue->rank)\n     {\n       gfc_error (\"Different ranks in pointer assignment at %L\",\n-\t\t  &lvalue->where);\n+\t\t &lvalue->where);\n       return FAILURE;\n     }\n \n@@ -2424,9 +2399,9 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n     return SUCCESS;\n \n   if (lvalue->ts.type == BT_CHARACTER\n-\t&& lvalue->ts.cl->length && rvalue->ts.cl->length\n-\t&& abs (gfc_dep_compare_expr (lvalue->ts.cl->length,\n-\t\t\t\t      rvalue->ts.cl->length)) == 1)\n+      && lvalue->ts.cl->length && rvalue->ts.cl->length\n+      && abs (gfc_dep_compare_expr (lvalue->ts.cl->length,\n+\t\t\t\t    rvalue->ts.cl->length)) == 1)\n     {\n       gfc_error (\"Different character lengths in pointer \"\n \t\t \"assignment at %L\", &lvalue->where);\n@@ -2457,7 +2432,7 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n   if (attr.protected && attr.use_assoc)\n     {\n       gfc_error (\"Pointer assigment target has PROTECTED \"\n-                 \"attribute at %L\", &rvalue->where);\n+\t\t \"attribute at %L\", &rvalue->where);\n       return FAILURE;\n     }\n \n@@ -2469,7 +2444,7 @@ gfc_check_pointer_assign (gfc_expr * lvalue, gfc_expr * rvalue)\n    symbol.  Used for initialization assignments.  */\n \n try\n-gfc_check_assign_symbol (gfc_symbol * sym, gfc_expr * rvalue)\n+gfc_check_assign_symbol (gfc_symbol *sym, gfc_expr *rvalue)\n {\n   gfc_expr lvalue;\n   try r;\n@@ -2480,7 +2455,7 @@ gfc_check_assign_symbol (gfc_symbol * sym, gfc_expr * rvalue)\n   lvalue.ts = sym->ts;\n   if (sym->as)\n     lvalue.rank = sym->as->rank;\n-  lvalue.symtree = (gfc_symtree *)gfc_getmem (sizeof (gfc_symtree));\n+  lvalue.symtree = (gfc_symtree *) gfc_getmem (sizeof (gfc_symtree));\n   lvalue.symtree->n.sym = sym;\n   lvalue.where = sym->declared_at;\n \n@@ -2510,7 +2485,7 @@ gfc_default_initializer (gfc_typespec *ts)\n   for (c = ts->derived->components; c; c = c->next)\n     {\n       if ((c->initializer || c->allocatable) && init == NULL)\n-        init = gfc_get_expr ();\n+\tinit = gfc_get_expr ();\n     }\n \n   if (init == NULL)\n@@ -2524,15 +2499,15 @@ gfc_default_initializer (gfc_typespec *ts)\n   for (c = ts->derived->components; c; c = c->next)\n     {\n       if (tail == NULL)\n-        init->value.constructor = tail = gfc_get_constructor ();\n+\tinit->value.constructor = tail = gfc_get_constructor ();\n       else\n-        {\n-          tail->next = gfc_get_constructor ();\n-          tail = tail->next;\n-        }\n+\t{\n+\t  tail->next = gfc_get_constructor ();\n+\t  tail = tail->next;\n+\t}\n \n       if (c->initializer)\n-        tail->expr = gfc_copy_expr (c->initializer);\n+\ttail->expr = gfc_copy_expr (c->initializer);\n \n       if (c->allocatable)\n \t{\n@@ -2550,7 +2525,7 @@ gfc_default_initializer (gfc_typespec *ts)\n    whole array.  */\n \n gfc_expr *\n-gfc_get_variable_expr (gfc_symtree * var)\n+gfc_get_variable_expr (gfc_symtree *var)\n {\n   gfc_expr *e;\n \n@@ -2574,7 +2549,7 @@ gfc_get_variable_expr (gfc_symtree * var)\n /* Traverse expr, marking all EXPR_VARIABLE symbols referenced.  */\n \n void\n-gfc_expr_set_symbols_referenced (gfc_expr * expr)\n+gfc_expr_set_symbols_referenced (gfc_expr *expr)\n {\n   gfc_actual_arglist *arg;\n   gfc_constructor *c;\n@@ -2592,7 +2567,7 @@ gfc_expr_set_symbols_referenced (gfc_expr * expr)\n \n     case EXPR_FUNCTION:\n       for (arg = expr->value.function.actual; arg; arg = arg->next)\n-        gfc_expr_set_symbols_referenced (arg->expr);\n+\tgfc_expr_set_symbols_referenced (arg->expr);\n       break;\n \n     case EXPR_VARIABLE:\n@@ -2607,7 +2582,7 @@ gfc_expr_set_symbols_referenced (gfc_expr * expr)\n     case EXPR_STRUCTURE:\n     case EXPR_ARRAY:\n       for (c = expr->value.constructor; c; c = c->next)\n-        gfc_expr_set_symbols_referenced (c->expr);\n+\tgfc_expr_set_symbols_referenced (c->expr);\n       break;\n \n     default:\n@@ -2617,26 +2592,26 @@ gfc_expr_set_symbols_referenced (gfc_expr * expr)\n \n     for (ref = expr->ref; ref; ref = ref->next)\n       switch (ref->type)\n-        {\n-        case REF_ARRAY:\n-          for (i = 0; i < ref->u.ar.dimen; i++)\n-            {\n-              gfc_expr_set_symbols_referenced (ref->u.ar.start[i]);\n-              gfc_expr_set_symbols_referenced (ref->u.ar.end[i]);\n-              gfc_expr_set_symbols_referenced (ref->u.ar.stride[i]);\n-            }\n-          break;\n-           \n-        case REF_COMPONENT:\n-          break;\n-           \n-        case REF_SUBSTRING:\n-          gfc_expr_set_symbols_referenced (ref->u.ss.start);\n-          gfc_expr_set_symbols_referenced (ref->u.ss.end);\n-          break;\n-           \n-        default:\n-          gcc_unreachable ();\n-          break;\n-        }\n+\t{\n+\tcase REF_ARRAY:\n+\t  for (i = 0; i < ref->u.ar.dimen; i++)\n+\t    {\n+\t      gfc_expr_set_symbols_referenced (ref->u.ar.start[i]);\n+\t      gfc_expr_set_symbols_referenced (ref->u.ar.end[i]);\n+\t      gfc_expr_set_symbols_referenced (ref->u.ar.stride[i]);\n+\t    }\n+\t  break;\n+\t   \n+\tcase REF_COMPONENT:\n+\t  break;\n+\t   \n+\tcase REF_SUBSTRING:\n+\t  gfc_expr_set_symbols_referenced (ref->u.ss.start);\n+\t  gfc_expr_set_symbols_referenced (ref->u.ss.end);\n+\t  break;\n+\t   \n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n }"}]}