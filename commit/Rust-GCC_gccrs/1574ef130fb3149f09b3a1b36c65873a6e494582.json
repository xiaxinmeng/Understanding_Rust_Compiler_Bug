{"sha": "1574ef130fb3149f09b3a1b36c65873a6e494582", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU3NGVmMTMwZmIzMTQ5ZjA5YjNhMWIzNmM2NTg3M2E2ZTQ5NDU4Mg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-01-02T02:31:58Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-01-02T02:31:58Z"}, "message": "c-common.h (genrtl_expr_stmt_value): Declare.\n\n* c-common.h (genrtl_expr_stmt_value): Declare.\n* c-semantics.c (genrtl_goto_stmt): Redirect to...\n(genrtl_goto_stmt_value): ... this new function.  Pass new\nargument down to expand_expr_stmt_value, taking\nTREE_ADDRESSABLE into account.\n* c-common.c (c_expand_expr): Mark the last EXPR_STMT of a\nSTMT_EXPR as addressable, i.e., one whose result we want.\n* expr.c (expand_expr): Don't save expression statement value\nof labeled_blocks or loop_exprs.\n* stmt.c (expand_expr_stmt): Redirect to...\n(expand_expr_stmt_value): ... this new function.  Use new\nargument to tell whether to save expression value.\n(expand_end_stmt_expr): Reset last_expr_type and\nlast_expr_value if we don't have either.\n* tree-inline.c (declare_return_variable): Mark its use\nstatement as addressable.\n* tree.h: Document new use of TREE_ADDRESSABLE.\n(expand_expr_stmt_value): Declare.\n\nFrom-SVN: r48456", "tree": {"sha": "88f850f8f5e7beb19776302640e41667d82628ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88f850f8f5e7beb19776302640e41667d82628ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1574ef130fb3149f09b3a1b36c65873a6e494582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1574ef130fb3149f09b3a1b36c65873a6e494582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1574ef130fb3149f09b3a1b36c65873a6e494582", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1574ef130fb3149f09b3a1b36c65873a6e494582/comments", "author": null, "committer": null, "parents": [{"sha": "6180abdb9dfdb541014932a732916a47a8bab8a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6180abdb9dfdb541014932a732916a47a8bab8a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6180abdb9dfdb541014932a732916a47a8bab8a5"}], "stats": {"total": 165, "additions": 124, "deletions": 41}, "files": [{"sha": "a9eaf973d7f56a5aa77d8392acbf906d387729d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1574ef130fb3149f09b3a1b36c65873a6e494582", "patch": "@@ -1,3 +1,24 @@\n+2002-01-02  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* c-common.h (genrtl_expr_stmt_value): Declare.\n+\t* c-semantics.c (genrtl_goto_stmt): Redirect to...\n+\t(genrtl_goto_stmt_value): ... this new function.  Pass new\n+\targument down to expand_expr_stmt_value, taking\n+\tTREE_ADDRESSABLE into account.\n+\t* c-common.c (c_expand_expr): Mark the last EXPR_STMT of a\n+\tSTMT_EXPR as addressable, i.e., one whose result we want.\n+\t* expr.c (expand_expr): Don't save expression statement value\n+\tof labeled_blocks or loop_exprs.\n+\t* stmt.c (expand_expr_stmt): Redirect to...\n+\t(expand_expr_stmt_value): ... this new function.  Use new\n+\targument to tell whether to save expression value.\n+\t(expand_end_stmt_expr): Reset last_expr_type and\n+\tlast_expr_value if we don't have either.\n+\t* tree-inline.c (declare_return_variable): Mark its use\n+\tstatement as addressable.\n+\t* tree.h: Document new use of TREE_ADDRESSABLE.\n+\t(expand_expr_stmt_value): Declare.\n+\n 2002-01-01  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* configure.in: Prepend ${srcdir}/config/${cpu_type}/ instead of"}, {"sha": "39ae17d9a8da474aa393a87341b6224b24ccfa19", "filename": "gcc/c-common.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=1574ef130fb3149f09b3a1b36c65873a6e494582", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines shared by all languages that are variants of C.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+   2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -3418,6 +3418,27 @@ c_expand_expr (exp, target, tmode, modifier)\n \t   STMT_EXPR.  */\n \tpush_temp_slots ();\n \trtl_expr = expand_start_stmt_expr ();\n+\n+\t/* If we want the result of this expression, find the last\n+           EXPR_STMT in the COMPOUND_STMT and mark it as addressable.  */\n+\tif (target != const0_rtx\n+\t    && TREE_CODE (STMT_EXPR_STMT (exp)) == COMPOUND_STMT\n+\t    && TREE_CODE (COMPOUND_BODY (STMT_EXPR_STMT (exp))) == SCOPE_STMT)\n+\t  {\n+\t    tree expr = COMPOUND_BODY (STMT_EXPR_STMT (exp));\n+\t    tree last = TREE_CHAIN (expr);\n+\n+\t    while (TREE_CHAIN (last))\n+\t      {\n+\t\texpr = last;\n+\t\tlast = TREE_CHAIN (last);\n+\t      }\n+\n+\t    if (TREE_CODE (last) == SCOPE_STMT\n+\t\t&& TREE_CODE (expr) == EXPR_STMT)\n+\t      TREE_ADDRESSABLE (expr) = 1;\n+\t  }\n+\n \texpand_stmt (STMT_EXPR_STMT (exp));\n \texpand_end_stmt_expr (rtl_expr);\n \tresult = expand_expr (rtl_expr, target, tmode, modifier);"}, {"sha": "4c49b9fcddfeb3d889b0e53b295c723f0847946c", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=1574ef130fb3149f09b3a1b36c65873a6e494582", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for c-common.c.\n    Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -717,6 +717,7 @@ extern void add_c_tree_codes\t\t        PARAMS ((void));\n extern void genrtl_do_pushlevel                 PARAMS ((void));\n extern void genrtl_goto_stmt                    PARAMS ((tree));\n extern void genrtl_expr_stmt                    PARAMS ((tree));\n+extern void genrtl_expr_stmt_value              PARAMS ((tree, int));\n extern void genrtl_decl_stmt                    PARAMS ((tree));\n extern void genrtl_if_stmt                      PARAMS ((tree));\n extern void genrtl_while_stmt                   PARAMS ((tree));"}, {"sha": "ef9ba333751a72160134cb14dc3008b4b73ac29e", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=1574ef130fb3149f09b3a1b36c65873a6e494582", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions and documentation for the common\n    tree codes used in the GNU C and C++ compilers (see c-common.def\n    for the standard codes).  \n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n    Written by Benjamin Chelf (chelf@codesourcery.com).\n \n This file is part of GCC.\n@@ -305,11 +305,26 @@ genrtl_goto_stmt (destination)\n     expand_computed_goto (destination);\n }\n \n-/* Generate the RTL for EXPR, which is an EXPR_STMT.  */\n+/* Generate the RTL for EXPR, which is an EXPR_STMT.  Provided just\n+   for backward compatibility.  genrtl_expr_stmt_value() should be\n+   used for new code.  */\n \n-void \n+void\n genrtl_expr_stmt (expr)\n      tree expr;\n+{\n+  genrtl_expr_stmt_value (expr, -1);\n+}\n+\n+/* Generate the RTL for EXPR, which is an EXPR_STMT.  WANT_VALUE tells\n+   whether to (1) save the value of the expression, (0) discard it or\n+   (-1) use expr_stmts_for_value to tell.  The use of -1 is\n+   deprecated, and retained only for backward compatibility.  */\n+\n+void \n+genrtl_expr_stmt_value (expr, want_value)\n+     tree expr;\n+     int want_value;\n {\n   if (expr != NULL_TREE)\n     {\n@@ -319,7 +334,7 @@ genrtl_expr_stmt (expr)\n \texpand_start_target_temps ();\n       \n       if (expr != error_mark_node)\n-\texpand_expr_stmt (expr);\n+\texpand_expr_stmt_value (expr, want_value);\n       \n       if (stmts_are_full_exprs_p ())\n \texpand_end_target_temps ();\n@@ -748,7 +763,7 @@ expand_stmt (t)\n \t  break;\n \n \tcase EXPR_STMT:\n-\t  genrtl_expr_stmt (EXPR_STMT_EXPR (t));\n+\t  genrtl_expr_stmt_value (EXPR_STMT_EXPR (t), TREE_ADDRESSABLE (t));\n \t  break;\n \n \tcase DECL_STMT:"}, {"sha": "1388b6ff8355a693e2af3cc31c424827eb38c8ff", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1574ef130fb3149f09b3a1b36c65873a6e494582", "patch": "@@ -1,6 +1,6 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001 Free Software Foundation, Inc.\n+   2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -6453,7 +6453,7 @@ expand_expr (exp, target, tmode, modifier)\n \n     case LABELED_BLOCK_EXPR:\n       if (LABELED_BLOCK_BODY (exp))\n-\texpand_expr_stmt (LABELED_BLOCK_BODY (exp));\n+\texpand_expr_stmt_value (LABELED_BLOCK_BODY (exp), 0);\n       /* Should perhaps use expand_label, but this is simpler and safer.  */\n       do_pending_stack_adjust ();\n       emit_label (label_rtx (LABELED_BLOCK_LABEL (exp)));\n@@ -6468,7 +6468,7 @@ expand_expr (exp, target, tmode, modifier)\n     case LOOP_EXPR:\n       push_temp_slots ();\n       expand_start_loop (1);\n-      expand_expr_stmt (TREE_OPERAND (exp, 0));\n+      expand_expr_stmt_value (TREE_OPERAND (exp, 0), 0);\n       expand_end_loop ();\n       pop_temp_slots ();\n "}, {"sha": "16a3882ffd0118e65fcbb51a169040eb4fddb1d7", "filename": "gcc/stmt.c", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=1574ef130fb3149f09b3a1b36c65873a6e494582", "patch": "@@ -1,6 +1,6 @@\n /* Expands front end tree to back end RTL for GNU C-Compiler\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2182,16 +2182,37 @@ resolve_operand_name_1 (p, outputs, inputs)\n }\n \f\n /* Generate RTL to evaluate the expression EXP\n-   and remember it in case this is the VALUE in a ({... VALUE; }) constr.  */\n+   and remember it in case this is the VALUE in a ({... VALUE; }) constr.\n+   Provided just for backward-compatibility.  expand_expr_stmt_value()\n+   should be used for new code.  */\n \n void\n expand_expr_stmt (exp)\n      tree exp;\n {\n+  expand_expr_stmt_value (exp, -1);\n+}\n+\n+/* Generate RTL to evaluate the expression EXP.  WANT_VALUE tells\n+   whether to (1) save the value of the expression, (0) discard it or\n+   (-1) use expr_stmts_for_value to tell.  The use of -1 is\n+   deprecated, and retained only for backward compatibility.  */\n+\n+void\n+expand_expr_stmt_value (exp, want_value)\n+     tree exp;\n+     int want_value;\n+{\n+  rtx value;\n+  tree type;\n+\n+  if (want_value == -1)\n+    want_value = expr_stmts_for_value != 0;\n+\n   /* If -W, warn about statements with no side effects,\n      except for an explicit cast to void (e.g. for assert()), and\n      except inside a ({...}) where they may be useful.  */\n-  if (expr_stmts_for_value == 0 && exp != error_mark_node)\n+  if (! want_value && exp != error_mark_node)\n     {\n       if (! TREE_SIDE_EFFECTS (exp))\n \t{\n@@ -2207,34 +2228,31 @@ expand_expr_stmt (exp)\n \n   /* If EXP is of function type and we are expanding statements for\n      value, convert it to pointer-to-function.  */\n-  if (expr_stmts_for_value && TREE_CODE (TREE_TYPE (exp)) == FUNCTION_TYPE)\n+  if (want_value && TREE_CODE (TREE_TYPE (exp)) == FUNCTION_TYPE)\n     exp = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (exp)), exp);\n \n   /* The call to `expand_expr' could cause last_expr_type and\n      last_expr_value to get reset.  Therefore, we set last_expr_value\n      and last_expr_type *after* calling expand_expr.  */\n-  last_expr_value = expand_expr (exp,\n-\t\t\t\t (expr_stmts_for_value\n-\t\t\t\t  ? NULL_RTX : const0_rtx),\n-\t\t\t\t VOIDmode, 0);\n-  last_expr_type = TREE_TYPE (exp);\n+  value = expand_expr (exp, want_value ? NULL_RTX : const0_rtx,\n+\t\t       VOIDmode, 0);\n+  type = TREE_TYPE (exp);\n \n   /* If all we do is reference a volatile value in memory,\n      copy it to a register to be sure it is actually touched.  */\n-  if (last_expr_value != 0 && GET_CODE (last_expr_value) == MEM\n-      && TREE_THIS_VOLATILE (exp))\n+  if (value && GET_CODE (value) == MEM && TREE_THIS_VOLATILE (exp))\n     {\n-      if (TYPE_MODE (TREE_TYPE (exp)) == VOIDmode)\n+      if (TYPE_MODE (type) == VOIDmode)\n \t;\n-      else if (TYPE_MODE (TREE_TYPE (exp)) != BLKmode)\n-\tcopy_to_reg (last_expr_value);\n+      else if (TYPE_MODE (type) != BLKmode)\n+\tvalue = copy_to_reg (value);\n       else\n \t{\n \t  rtx lab = gen_label_rtx ();\n \n \t  /* Compare the value with itself to reference it.  */\n-\t  emit_cmp_and_jump_insns (last_expr_value, last_expr_value, EQ,\n-\t\t\t\t   expand_expr (TYPE_SIZE (last_expr_type),\n+\t  emit_cmp_and_jump_insns (value, value, EQ,\n+\t\t\t\t   expand_expr (TYPE_SIZE (type),\n \t\t\t\t\t\tNULL_RTX, VOIDmode, 0),\n \t\t\t\t   BLKmode, 0, lab);\n \t  emit_label (lab);\n@@ -2243,13 +2261,19 @@ expand_expr_stmt (exp)\n \n   /* If this expression is part of a ({...}) and is in memory, we may have\n      to preserve temporaries.  */\n-  preserve_temp_slots (last_expr_value);\n+  preserve_temp_slots (value);\n \n   /* Free any temporaries used to evaluate this expression.  Any temporary\n      used as a result of this expression will already have been preserved\n      above.  */\n   free_temp_slots ();\n \n+  if (want_value)\n+    {\n+      last_expr_value = value;\n+      last_expr_type = type;\n+    }\n+\n   emit_queue ();\n }\n \n@@ -2386,6 +2410,7 @@ expand_start_stmt_expr ()\n   start_sequence_for_rtl_expr (t);\n   NO_DEFER_POP;\n   expr_stmts_for_value++;\n+  last_expr_value = NULL_RTX;\n   return t;\n }\n \n@@ -2407,15 +2432,11 @@ expand_end_stmt_expr (t)\n {\n   OK_DEFER_POP;\n \n-  if (last_expr_type == 0)\n+  if (! last_expr_value || ! last_expr_type)\n     {\n-      last_expr_type = void_type_node;\n       last_expr_value = const0_rtx;\n+      last_expr_type = void_type_node;\n     }\n-  else if (last_expr_value == 0)\n-    /* There are some cases where this can happen, such as when the\n-       statement is void type.  */\n-    last_expr_value = const0_rtx;\n   else if (GET_CODE (last_expr_value) != REG && ! CONSTANT_P (last_expr_value))\n     /* Remove any possible QUEUED.  */\n     last_expr_value = protect_from_queue (last_expr_value, 0);"}, {"sha": "02ba7161b46ce198144089bbe642d9afef177571", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1574ef130fb3149f09b3a1b36c65873a6e494582", "patch": "@@ -1,5 +1,5 @@\n /* Control and data flow functions for trees.\n-   Copyright 2001 Free Software Foundation, Inc.\n+   Copyright 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva <aoliva@redhat.com>\n \n This file is part of GNU CC.\n@@ -624,7 +624,9 @@ declare_return_variable (id, use_stmt)\n     *use_stmt = build_stmt (EXPR_STMT,\n \t\t\t    build1 (NOP_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n \t\t\t\t    var));\n-      \n+\n+  TREE_ADDRESSABLE (*use_stmt) = 1;\n+\n   /* Build the declaration statement if FN does not return an\n      aggregate.  */\n   if (need_return_decl)"}, {"sha": "051aa2c5bf357bf0aad76d4d48f7780f005a6e6f", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1574ef130fb3149f09b3a1b36c65873a6e494582/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1574ef130fb3149f09b3a1b36c65873a6e494582", "patch": "@@ -1,6 +1,6 @@\n /* Front-end tree definitions for GNU compiler.\n-   Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n+   2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -161,7 +161,9 @@ struct tree_common\n \n        TREE_ADDRESSABLE in\n    \t   VAR_DECL, FUNCTION_DECL, FIELD_DECL, CONSTRUCTOR, LABEL_DECL,\n-\t   ..._TYPE, IDENTIFIER_NODE\n+\t   ..._TYPE, IDENTIFIER_NODE.\n+\t   In a STMT_EXPR, it means we want the result of the enclosed\n+\t   expression.\n \n    static_flag:\n \n@@ -258,8 +260,7 @@ struct tree_common\n \t   expressions, VAR_DECL, PARM_DECL, FIELD_DECL, FUNCTION_DECL,\n \t   IDENTIFIER_NODE\n        TYPE_BOUNDED in\n-\t   ..._TYPE\n-*/\n+\t   ..._TYPE */\n \n /* Define accessors for the fields that all tree nodes have\n    (though some fields are not used for all kinds of nodes).  */\n@@ -2719,6 +2720,7 @@ extern void expand_fixups\t\t\tPARAMS ((rtx));\n extern tree expand_start_stmt_expr\t\tPARAMS ((void));\n extern tree expand_end_stmt_expr\t\tPARAMS ((tree));\n extern void expand_expr_stmt\t\t\tPARAMS ((tree));\n+extern void expand_expr_stmt_value\t\tPARAMS ((tree, int));\n extern int warn_if_unused_value\t\t\tPARAMS ((tree));\n extern void expand_decl_init\t\t\tPARAMS ((tree));\n extern void clear_last_expr\t\t\tPARAMS ((void));"}]}