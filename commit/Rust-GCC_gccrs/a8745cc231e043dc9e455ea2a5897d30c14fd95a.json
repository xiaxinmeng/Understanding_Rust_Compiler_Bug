{"sha": "a8745cc231e043dc9e455ea2a5897d30c14fd95a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg3NDVjYzIzMWUwNDNkYzllNDU1ZWEyYTU4OTdkMzBjMTRmZDk1YQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T12:08:28Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T12:08:28Z"}, "message": "tree-loop-distribution.c: Add general explanantion on the pass.\n\n\t* tree-loop-distribution.c: Add general explanantion on the pass.\n\t(generate_loops_for_partition): Mark distributed loop.\n\t(pg_add_dependence_edges): New parameter.  Handle alias data\n\tdependence specially and record it in the parameter if asked.\n\t(struct pg_vdata, pg_edata, pg_edge_callback_data): New structs.\n\t(init_partition_graph_vertices, add_partition_graph_edge): New.\n\t(pg_skip_alias_edge, free_partition_graph_edata_cb): New.\n\t(free_partition_graph_vdata, build_partition_graph): New.\n\t(sort_partitions_by_post_order, merge_dep_scc_partitions): New.\n\t(pg_collect_alias_ddrs, break_alias_scc_partitions): New.\n\t(data_ref_segment_size, latch_dominated_by_data_ref): New.\n\t(compute_alias_check_pairs, version_loop_by_alias_check): New.\n\t(version_for_distribution_p, finalize_partitions): New.\n\t(distribute_loop): Handle alias data dependence specially.  Factor\n\tout loop fusion code as functions and call these functions.\n\n\tgcc/testsuite\n\t* gcc.dg/tree-ssa/ldist-4.c: Adjust test string.\n\t* gcc.dg/tree-ssa/ldist-12.c: Ditto.\n\t* gcc.dg/tree-ssa/ldist-13.c: Ditto.\n\t* gcc.dg/tree-ssa/ldist-14.c: Ditto.\n\nFrom-SVN: r249994", "tree": {"sha": "8fe167022c6a719ea6fab5b5eef3cfebbc25ad49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fe167022c6a719ea6fab5b5eef3cfebbc25ad49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8745cc231e043dc9e455ea2a5897d30c14fd95a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8745cc231e043dc9e455ea2a5897d30c14fd95a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8745cc231e043dc9e455ea2a5897d30c14fd95a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8745cc231e043dc9e455ea2a5897d30c14fd95a/comments", "author": null, "committer": null, "parents": [{"sha": "4a52eb194ce8a5c9086dbc269210d17430ce706e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a52eb194ce8a5c9086dbc269210d17430ce706e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a52eb194ce8a5c9086dbc269210d17430ce706e"}], "stats": {"total": 859, "additions": 749, "deletions": 110}, "files": [{"sha": "2f11b143c962a781f39e05c626ea8d91a876abc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a8745cc231e043dc9e455ea2a5897d30c14fd95a", "patch": "@@ -1,3 +1,21 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c: Add general explanantion on the pass.\n+\t(generate_loops_for_partition): Mark distributed loop.\n+\t(pg_add_dependence_edges): New parameter.  Handle alias data\n+\tdependence specially and record it in the parameter if asked.\n+\t(struct pg_vdata, pg_edata, pg_edge_callback_data): New structs.\n+\t(init_partition_graph_vertices, add_partition_graph_edge): New.\n+\t(pg_skip_alias_edge, free_partition_graph_edata_cb): New.\n+\t(free_partition_graph_vdata, build_partition_graph): New.\n+\t(sort_partitions_by_post_order, merge_dep_scc_partitions): New.\n+\t(pg_collect_alias_ddrs, break_alias_scc_partitions): New.\n+\t(data_ref_segment_size, latch_dominated_by_data_ref): New.\n+\t(compute_alias_check_pairs, version_loop_by_alias_check): New.\n+\t(version_for_distribution_p, finalize_partitions): New.\n+\t(distribute_loop): Handle alias data dependence specially.  Factor\n+\tout loop fusion code as functions and call these functions.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (classify_partition): New parameter and"}, {"sha": "36b230927111ffc1dcff24bd55d6dcdd09c119ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a8745cc231e043dc9e455ea2a5897d30c14fd95a", "patch": "@@ -1,3 +1,10 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/ldist-4.c: Adjust test string.\n+\t* gcc.dg/tree-ssa/ldist-12.c: Ditto.\n+\t* gcc.dg/tree-ssa/ldist-13.c: Ditto.\n+\t* gcc.dg/tree-ssa/ldist-14.c: Ditto.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.dg/tree-ssa/ldist-26.c: New test."}, {"sha": "625dd92128e42d6e14aaa60fc3fdbd91ca05d001", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-12.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-12.c?ref=a8745cc231e043dc9e455ea2a5897d30c14fd95a", "patch": "@@ -18,4 +18,5 @@ int foo (int * __restrict__ ia,\n   return oya[22] + oyb[21];\n }\n \n-/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 1 \"ldist\" } } */\n+/* Distributing the loop doesn't expose more parallelism.  */\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */"}, {"sha": "8c9fd567e1e8914fe5cf0eddda8419d53caf7d1a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-13.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-13.c?ref=a8745cc231e043dc9e455ea2a5897d30c14fd95a", "patch": "@@ -16,6 +16,5 @@ float foo (int n)\n   return tmp;\n }\n \n-/* We should apply loop distribution.  */\n-\n-/* { dg-final { scan-tree-dump \"Loop 1 distributed: split to 2 loops\" \"ldist\" } } */\n+/* Distributing the loop doesn't expose more parallelism.  */\n+/* { dg-final { scan-tree-dump-not \"Loop 1 distributed: split to 2 loops\" \"ldist\" } } */"}, {"sha": "fa4d1a828798790d4935096ba6ce4d0b82f1847f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-14.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-14.c?ref=a8745cc231e043dc9e455ea2a5897d30c14fd95a", "patch": "@@ -21,6 +21,5 @@ float foo (int n)\n   return tmp;\n }\n \n-/* We should apply loop distribution.  */\n-\n-/* { dg-final { scan-tree-dump \"Loop 1 distributed: split to 2 loops\" \"ldist\" } } */\n+/* Distributing the loop doesn't expose more parallelism.  */\n+/* { dg-final { scan-tree-dump-not \"Loop 1 distributed: split to 2 loops\" \"ldist\" } } */"}, {"sha": "4def9b4719d8e9b0f9b51ef69fcc25525f6cd198", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-4.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c?ref=a8745cc231e043dc9e455ea2a5897d30c14fd95a", "patch": "@@ -20,7 +20,5 @@ int loop1 (int k)\n   return b[100-1][1];\n }\n \n-/* The current cost model fuses the two partitions because they have\n-   similar memory accesses.  */\n-/* { dg-final { scan-tree-dump \"similar memory accesses\" \"ldist\" } } */\n+/* Distributing inner loop doesn't expose more parallelism.  */\n /* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */"}, {"sha": "be0a6603ed228a2aec718c0187d38572676f3dc0", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 717, "deletions": 100, "changes": 817, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8745cc231e043dc9e455ea2a5897d30c14fd95a/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=a8745cc231e043dc9e455ea2a5897d30c14fd95a", "patch": "@@ -36,10 +36,58 @@ along with GCC; see the file COPYING3.  If not see\n    |   D(I) = A(I-1)*E\n    |ENDDO\n \n-   This pass uses an RDG, Reduced Dependence Graph built on top of the\n-   data dependence relations.  The RDG is then topologically sorted to\n-   obtain a map of information producers/consumers based on which it\n-   generates the new loops.  */\n+   Loop distribution is the dual of loop fusion.  It separates statements\n+   of a loop (or loop nest) into multiple loops (or loop nests) with the\n+   same loop header.  The major goal is to separate statements which may\n+   be vectorized from those that can't.  This pass implements distribution\n+   in the following steps:\n+\n+     1) Seed partitions with specific type statements.  For now we support\n+\ttwo types seed statements: statement defining variable used outside\n+\tof loop; statement storing to memory.\n+     2) Build reduced dependence graph (RDG) for loop to be distributed.\n+\tThe vertices (RDG:V) model all statements in the loop and the edges\n+\t(RDG:E) model flow and control dependencies between statements.\n+     3) Apart from RDG, compute data dependencies between memory references.\n+     4) Starting from seed statement, build up partition by adding depended\n+\tstatements according to RDG's dependence information.  Partition is\n+\tclassified as parallel type if it can be executed paralleled; or as\n+\tsequential type if it can't.  Parallel type partition is further\n+\tclassified as different builtin kinds if it can be implemented as\n+\tbuiltin function calls.\n+     5) Build partition dependence graph (PG) based on data dependencies.\n+\tThe vertices (PG:V) model all partitions and the edges (PG:E) model\n+\tall data dependencies between every partitions pair.  In general,\n+\tdata dependence is either compilation time known or unknown.  In C\n+\tfamily languages, there exists quite amount compilation time unknown\n+\tdependencies because of possible alias relation of data references.\n+\tWe categorize PG's edge to two types: \"true\" edge that represents\n+\tcompilation time known data dependencies; \"alias\" edge for all other\n+\tdata dependencies.\n+     6) Traverse subgraph of PG as if all \"alias\" edges don't exist.  Merge\n+\tpartitions in each strong connected component (SCC) correspondingly.\n+\tBuild new PG for merged partitions.\n+     7) Traverse PG again and this time with both \"true\" and \"alias\" edges\n+\tincluded.  We try to break SCCs by removing some edges.  Because\n+\tSCCs by \"true\" edges are all fused in step 6), we can break SCCs\n+\tby removing some \"alias\" edges.  It's NP-hard to choose optimal\n+\tedge set, fortunately simple approximation is good enough for us\n+\tgiven the small problem scale.\n+     8) Collect all data dependencies of the removed \"alias\" edges.  Create\n+\truntime alias checks for collected data dependencies.\n+     9) Version loop under the condition of runtime alias checks.  Given\n+\tloop distribution generally introduces additional overhead, it is\n+\tonly useful if vectorization is achieved in distributed loop.  We\n+\tversion loop with internal function call IFN_LOOP_DIST_ALIAS.  If\n+\tno distributed loop can be vectorized, we simply remove distributed\n+\tloops and recover to the original one.\n+\n+   TODO:\n+     1) We only distribute innermost loops now.  This pass should handle loop\n+\tnests in the future.\n+     2) We only fuse partitions in SCC now.  A better fusion algorithm is\n+\tdesired to minimize loop overhead, maximize parallelism and maximize\n+\tdata reuse.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -744,11 +792,18 @@ generate_loops_for_partition (struct loop *loop, partition *partition,\n \n   if (copy_p)\n     {\n+      int orig_loop_num = loop->orig_loop_num;\n       loop = copy_loop_before (loop);\n       gcc_assert (loop != NULL);\n+      loop->orig_loop_num = orig_loop_num;\n       create_preheader (loop, CP_SIMPLE_PREHEADERS);\n       create_bb_after_loop (loop);\n     }\n+  else\n+    {\n+      /* Origin number is set to the new versioned loop's num.  */\n+      gcc_assert (loop->orig_loop_num != loop->num);\n+    }\n \n   /* Remove stmts not in the PARTITION bitmap.  */\n   bbs = get_loop_body_in_dom_order (loop);\n@@ -1601,11 +1656,14 @@ partition_contains_all_rw (struct graph *rdg,\n }\n \n /* Compute partition dependence created by the data references in DRS1\n-   and DRS2 and modify and return DIR according to that.  */\n+   and DRS2, modify and return DIR according to that.  IF ALIAS_DDR is\n+   not NULL, we record dependence introduced by possible alias between\n+   two data references in ALIAS_DDRS; otherwise, we simply ignore such\n+   dependence as if it doesn't exist at all.  */\n \n static int\n pg_add_dependence_edges (struct graph *rdg, int dir,\n-\t\t\t bitmap drs1, bitmap drs2)\n+\t\t\t bitmap drs1, bitmap drs2, vec<ddr_p> *alias_ddrs)\n {\n   unsigned i, j;\n   bitmap_iterator bi, bj;\n@@ -1619,16 +1677,17 @@ pg_add_dependence_edges (struct graph *rdg, int dir,\n \n       EXECUTE_IF_SET_IN_BITMAP (drs2, 0, j, bj)\n \t{\n+\t  int res, this_dir = 1;\n+\t  ddr_p ddr;\n+\n \t  dr2 = datarefs_vec[j];\n \n \t  /* Skip all <read, read> data dependence.  */\n \t  if (DR_IS_READ (dr1) && DR_IS_READ (dr2))\n \t    continue;\n \n \t  saved_dr1 = dr1;\n-\t  int this_dir = 1;\n-\t  ddr_p ddr;\n-\t  /* Re-shuffle data-refs to be in dominator order.  */\n+\t  /* Re-shuffle data-refs to be in topological order.  */\n \t  if (rdg_vertex_for_stmt (rdg, DR_STMT (dr1))\n \t      > rdg_vertex_for_stmt (rdg, DR_STMT (dr2)))\n \t    {\n@@ -1637,27 +1696,44 @@ pg_add_dependence_edges (struct graph *rdg, int dir,\n \t    }\n \t  ddr = get_data_dependence (rdg, dr1, dr2);\n \t  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-\t    this_dir = 2;\n+\t    {\n+\t      this_dir = 0;\n+\t      res = data_ref_compare_tree (DR_BASE_ADDRESS (dr1),\n+\t\t\t\t\t   DR_BASE_ADDRESS (dr2));\n+\t      /* Be conservative.  If data references are not well analyzed,\n+\t\t or the two data references have the same base address and\n+\t\t offset, add dependence and consider it alias to each other.\n+\t\t In other words, the dependence can not be resolved by\n+\t\t runtime alias check.  */\n+\t      if (!DR_BASE_ADDRESS (dr1) || !DR_BASE_ADDRESS (dr2)\n+\t\t  || !DR_OFFSET (dr1) || !DR_OFFSET (dr2)\n+\t\t  || !DR_INIT (dr1) || !DR_INIT (dr2)\n+\t\t  || !DR_STEP (dr1) || !tree_fits_uhwi_p (DR_STEP (dr1))\n+\t\t  || !DR_STEP (dr2) || !tree_fits_uhwi_p (DR_STEP (dr2))\n+\t\t  || res == 0)\n+\t\tthis_dir = 2;\n+\t      /* Data dependence could be resolved by runtime alias check,\n+\t\t record it in ALIAS_DDRS.  */\n+\t      else if (alias_ddrs != NULL)\n+\t\talias_ddrs->safe_push (ddr);\n+\t      /* Or simply ignore it.  */\n+\t    }\n \t  else if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n \t    {\n \t      if (DDR_REVERSED_P (ddr))\n-\t\t{\n-\t\t  std::swap (dr1, dr2);\n-\t\t  this_dir = -this_dir;\n-\t\t}\n+\t\tthis_dir = -this_dir;\n+\n \t      /* Known dependences can still be unordered througout the\n \t\t iteration space, see gcc.dg/tree-ssa/ldist-16.c.  */\n \t      if (DDR_NUM_DIST_VECTS (ddr) != 1)\n \t\tthis_dir = 2;\n \t      /* If the overlap is exact preserve stmt order.  */\n \t      else if (lambda_vector_zerop (DDR_DIST_VECT (ddr, 0), 1))\n \t\t;\n+\t      /* Else as the distance vector is lexicographic positive swap\n+\t\t the dependence direction.  */\n \t      else\n-\t\t{\n-\t\t  /* Else as the distance vector is lexicographic positive\n-\t\t     swap the dependence direction.  */\n-\t\t  this_dir = -this_dir;\n-\t\t}\n+\t\tthis_dir = -this_dir;\n \t    }\n \t  else\n \t    this_dir = 0;\n@@ -1684,11 +1760,609 @@ pgcmp (const void *v1_, const void *v2_)\n   return v2->post - v1->post;\n }\n \n-/* Distributes the code from LOOP in such a way that producer\n-   statements are placed before consumer statements.  Tries to separate\n-   only the statements from STMTS into separate loops.\n-   Returns the number of distributed loops.  Set *DESTROY_P to whether\n-   LOOP needs to be destroyed.  */\n+/* Data attached to vertices of partition dependence graph.  */\n+struct pg_vdata\n+{\n+  /* ID of the corresponding partition.  */\n+  int id;\n+  /* The partition.  */\n+  struct partition *partition;\n+};\n+\n+/* Data attached to edges of partition dependence graph.  */\n+struct pg_edata\n+{\n+  /* If the dependence edge can be resolved by runtime alias check,\n+     this vector contains data dependence relations for runtime alias\n+     check.  On the other hand, if the dependence edge is introduced\n+     because of compilation time known data dependence, this vector\n+     contains nothing.  */\n+  vec<ddr_p> alias_ddrs;\n+};\n+\n+/* Callback data for traversing edges in graph.  */\n+struct pg_edge_callback_data\n+{\n+  /* Bitmap contains strong connected components should be merged.  */\n+  bitmap sccs_to_merge;\n+  /* Array constains component information for all vertices.  */\n+  int *vertices_component;\n+  /* Vector to record all data dependence relations which are needed\n+     to break strong connected components by runtime alias checks.  */\n+  vec<ddr_p> *alias_ddrs;\n+};\n+\n+/* Initialize vertice's data for partition dependence graph PG with\n+   PARTITIONS.  */\n+\n+static void\n+init_partition_graph_vertices (struct graph *pg,\n+\t\t\t       vec<struct partition *> *partitions)\n+{\n+  int i;\n+  partition *partition;\n+  struct pg_vdata *data;\n+\n+  for (i = 0; partitions->iterate (i, &partition); ++i)\n+    {\n+      data = new pg_vdata;\n+      pg->vertices[i].data = data;\n+      data->id = i;\n+      data->partition = partition;\n+    }\n+}\n+\n+/* Add edge <I, J> to partition dependence graph PG.  Attach vector of data\n+   dependence relations to the EDGE if DDRS isn't NULL.  */\n+\n+static void\n+add_partition_graph_edge (struct graph *pg, int i, int j, vec<ddr_p> *ddrs)\n+{\n+  struct graph_edge *e = add_edge (pg, i, j);\n+\n+  /* If the edge is attached with data dependence relations, it means this\n+     dependence edge can be resolved by runtime alias checks.  */\n+  if (ddrs != NULL)\n+    {\n+      struct pg_edata *data = new pg_edata;\n+\n+      gcc_assert (ddrs->length () > 0);\n+      e->data = data;\n+      data->alias_ddrs = vNULL;\n+      data->alias_ddrs.safe_splice (*ddrs);\n+    }\n+}\n+\n+/* Callback function for graph travesal algorithm.  It returns true\n+   if edge E should skipped when traversing the graph.  */\n+\n+static bool\n+pg_skip_alias_edge (struct graph_edge *e)\n+{\n+  struct pg_edata *data = (struct pg_edata *)e->data;\n+  return (data != NULL && data->alias_ddrs.length () > 0);\n+}\n+\n+/* Callback function freeing data attached to edge E of graph.  */\n+\n+static void\n+free_partition_graph_edata_cb (struct graph *, struct graph_edge *e, void *)\n+{\n+  if (e->data != NULL)\n+    {\n+      struct pg_edata *data = (struct pg_edata *)e->data;\n+      data->alias_ddrs.release ();\n+      delete data;\n+    }\n+}\n+\n+/* Free data attached to vertice of partition dependence graph PG.  */\n+\n+static void\n+free_partition_graph_vdata (struct graph *pg)\n+{\n+  int i;\n+  struct pg_vdata *data;\n+\n+  for (i = 0; i < pg->n_vertices; ++i)\n+    {\n+      data = (struct pg_vdata *)pg->vertices[i].data;\n+      delete data;\n+    }\n+}\n+\n+/* Build and return partition dependence graph for PARTITIONS.  RDG is\n+   reduced dependence graph for the loop to be distributed.  If IGNORE_ALIAS_P\n+   is true, data dependence caused by possible alias between references\n+   is ignored, as if it doesn't exist at all; otherwise all depdendences\n+   are considered.  */\n+\n+static struct graph *\n+build_partition_graph (struct graph *rdg,\n+\t\t       vec<struct partition *> *partitions,\n+\t\t       bool ignore_alias_p)\n+{\n+  int i, j;\n+  struct partition *partition1, *partition2;\n+  graph *pg = new_graph (partitions->length ());\n+  auto_vec<ddr_p> alias_ddrs, *alias_ddrs_p;\n+\n+  alias_ddrs_p = ignore_alias_p ? NULL : &alias_ddrs;\n+\n+  init_partition_graph_vertices (pg, partitions);\n+\n+  for (i = 0; partitions->iterate (i, &partition1); ++i)\n+    {\n+      for (j = i + 1; partitions->iterate (j, &partition2); ++j)\n+\t{\n+\t  /* dependence direction - 0 is no dependence, -1 is back,\n+\t     1 is forth, 2 is both (we can stop then, merging will occur).  */\n+\t  int dir = 0;\n+\n+\t  /* If the first partition has reduction, add back edge; if the\n+\t     second partition has reduction, add forth edge.  This makes\n+\t     sure that reduction partition will be sorted as the last one.  */\n+\t  if (partition_reduction_p (partition1))\n+\t    dir = -1;\n+\t  else if (partition_reduction_p (partition2))\n+\t    dir = 1;\n+\n+\t  /* Cleanup the temporary vector.  */\n+\t  alias_ddrs.truncate (0);\n+\n+\t  dir = pg_add_dependence_edges (rdg, dir, partition1->datarefs,\n+\t\t\t\t\t partition2->datarefs, alias_ddrs_p);\n+\n+\t  /* Add edge to partition graph if there exists dependence.  There\n+\t     are two types of edges.  One type edge is caused by compilation\n+\t     time known dependence, this type can not be resolved by runtime\n+\t     alias check.  The other type can be resolved by runtime alias\n+\t     check.  */\n+\t  if (dir == 1 || dir == 2\n+\t      || alias_ddrs.length () > 0)\n+\t    {\n+\t      /* Attach data dependence relations to edge that can be resolved\n+\t\t by runtime alias check.  */\n+\t      bool alias_edge_p = (dir != 1 && dir != 2);\n+\t      add_partition_graph_edge (pg, i, j,\n+\t\t\t\t\t(alias_edge_p) ? &alias_ddrs : NULL);\n+\t    }\n+\t  if (dir == -1 || dir == 2\n+\t      || alias_ddrs.length () > 0)\n+\t    {\n+\t      /* Attach data dependence relations to edge that can be resolved\n+\t\t by runtime alias check.  */\n+\t      bool alias_edge_p = (dir != -1 && dir != 2);\n+\t      add_partition_graph_edge (pg, j, i,\n+\t\t\t\t\t(alias_edge_p) ? &alias_ddrs : NULL);\n+\t    }\n+\t}\n+    }\n+  return pg;\n+}\n+\n+/* Sort partitions in PG by post order and store them in PARTITIONS.  */\n+\n+static void\n+sort_partitions_by_post_order (struct graph *pg,\n+\t\t\t       vec<struct partition *> *partitions)\n+{\n+  int i;\n+  struct pg_vdata *data;\n+\n+  /* Now order the remaining nodes in postorder.  */\n+  qsort (pg->vertices, pg->n_vertices, sizeof (vertex), pgcmp);\n+  partitions->truncate (0);\n+  for (i = 0; i < pg->n_vertices; ++i)\n+    {\n+      data = (struct pg_vdata *)pg->vertices[i].data;\n+      if (data->partition)\n+\tpartitions->safe_push (data->partition);\n+    }\n+}\n+\n+/* Given reduced dependence graph RDG merge strong connected components\n+   of PARTITIONS.  If IGNORE_ALIAS_P is true, data dependence caused by\n+   possible alias between references is ignored, as if it doesn't exist\n+   at all; otherwise all depdendences are considered.  */\n+\n+static void\n+merge_dep_scc_partitions (struct graph *rdg,\n+\t\t\t  vec<struct partition *> *partitions,\n+\t\t\t  bool ignore_alias_p)\n+{\n+  struct partition *partition1, *partition2;\n+  struct pg_vdata *data;\n+  graph *pg = build_partition_graph (rdg, partitions, ignore_alias_p);\n+  int i, j, num_sccs = graphds_scc (pg, NULL);\n+\n+  /* Strong connected compoenent means dependence cycle, we cannot distribute\n+     them.  So fuse them together.  */\n+  if ((unsigned) num_sccs < partitions->length ())\n+    {\n+      for (i = 0; i < num_sccs; ++i)\n+\t{\n+\t  for (j = 0; partitions->iterate (j, &partition1); ++j)\n+\t    if (pg->vertices[j].component == i)\n+\t      break;\n+\t  for (j = j + 1; partitions->iterate (j, &partition2); ++j)\n+\t    if (pg->vertices[j].component == i)\n+\t      {\n+\t\tpartition_merge_into (NULL, partition1,\n+\t\t\t\t      partition2, FUSE_SAME_SCC);\n+\t\tpartition1->type = PTYPE_SEQUENTIAL;\n+\t\t(*partitions)[j] = NULL;\n+\t\tpartition_free (partition2);\n+\t\tdata = (struct pg_vdata *)pg->vertices[j].data;\n+\t\tdata->partition = NULL;\n+\t      }\n+\t}\n+      sort_partitions_by_post_order (pg, partitions);\n+    }\n+  gcc_assert (partitions->length () == (unsigned)num_sccs);\n+  free_partition_graph_vdata (pg);\n+  free_graph (pg);\n+}\n+\n+/* Callback function for traversing edge E in graph G.  DATA is private\n+   callback data.  */\n+\n+static void\n+pg_collect_alias_ddrs (struct graph *g, struct graph_edge *e, void *data)\n+{\n+  int i, j, component;\n+  struct pg_edge_callback_data *cbdata;\n+  struct pg_edata *edata = (struct pg_edata *) e->data;\n+\n+  /* If the edge doesn't have attached data dependence, it represents\n+     compilation time known dependences.  This type dependence cannot\n+     be resolved by runtime alias check.  */\n+  if (edata == NULL || edata->alias_ddrs.length () == 0)\n+    return;\n+\n+  cbdata = (struct pg_edge_callback_data *) data;\n+  i = e->src;\n+  j = e->dest;\n+  component = cbdata->vertices_component[i];\n+  /* Vertices are topologically sorted according to compilation time\n+     known dependences, so we can break strong connected components\n+     by removing edges of the opposite direction, i.e, edges pointing\n+     from vertice with smaller post number to vertice with bigger post\n+     number.  */\n+  if (g->vertices[i].post < g->vertices[j].post\n+      /* We only need to remove edges connecting vertices in the same\n+\t strong connected component to break it.  */\n+      && component == cbdata->vertices_component[j]\n+      /* Check if we want to break the strong connected component or not.  */\n+      && !bitmap_bit_p (cbdata->sccs_to_merge, component))\n+    cbdata->alias_ddrs->safe_splice (edata->alias_ddrs);\n+}\n+\n+/* This is the main function breaking strong conected components in\n+   PARTITIONS giving reduced depdendence graph RDG.  Store data dependence\n+   relations for runtime alias check in ALIAS_DDRS.  */\n+\n+static void\n+break_alias_scc_partitions (struct graph *rdg,\n+\t\t\t    vec<struct partition *> *partitions,\n+\t\t\t    vec<ddr_p> *alias_ddrs)\n+{\n+  int i, j, num_sccs, num_sccs_no_alias;\n+  /* Build partition dependence graph.  */\n+  graph *pg = build_partition_graph (rdg, partitions, false);\n+\n+  alias_ddrs->truncate (0);\n+  /* Find strong connected components in the graph, with all dependence edges\n+     considered.  */\n+  num_sccs = graphds_scc (pg, NULL);\n+  /* All SCCs now can be broken by runtime alias checks because SCCs caused by\n+     compilation time known dependences are merged before this function.  */\n+  if ((unsigned) num_sccs < partitions->length ())\n+    {\n+      struct pg_edge_callback_data cbdata;\n+      auto_bitmap sccs_to_merge;\n+      auto_vec<enum partition_type> scc_types;\n+      struct partition *partition, *first;\n+\n+      /* If all paritions in a SCC has the same type, we can simply merge the\n+\t SCC.  This loop finds out such SCCS and record them in bitmap.  */\n+      bitmap_set_range (sccs_to_merge, 0, (unsigned) num_sccs);\n+      for (i = 0; i < num_sccs; ++i)\n+\t{\n+\t  for (j = 0; partitions->iterate (j, &first); ++j)\n+\t    if (pg->vertices[j].component == i)\n+\t      break;\n+\t  for (++j; partitions->iterate (j, &partition); ++j)\n+\t    {\n+\t      if (pg->vertices[j].component != i)\n+\t\tcontinue;\n+\n+\t      if (first->type != partition->type)\n+\t\t{\n+\t\t  bitmap_clear_bit (sccs_to_merge, i);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Initialize callback data for traversing.  */\n+      cbdata.sccs_to_merge = sccs_to_merge;\n+      cbdata.alias_ddrs = alias_ddrs;\n+      cbdata.vertices_component = XNEWVEC (int, pg->n_vertices);\n+      /* Record the component information which will be corrupted by next\n+\t graph scc finding call.  */\n+      for (i = 0; i < pg->n_vertices; ++i)\n+\tcbdata.vertices_component[i] = pg->vertices[i].component;\n+\n+      /* Collect data dependences for runtime alias checks to break SCCs.  */\n+      if (bitmap_count_bits (sccs_to_merge) != (unsigned) num_sccs)\n+\t{\n+\t  /* Run SCC finding algorithm again, with alias dependence edges\n+\t     skipped.  This is to topologically sort paritions according to\n+\t     compilation time known dependence.  Note the topological order\n+\t     is stored in the form of pg's post order number.  */\n+\t  num_sccs_no_alias = graphds_scc (pg, NULL, pg_skip_alias_edge);\n+\t  gcc_assert (partitions->length () == (unsigned) num_sccs_no_alias);\n+\t  /* With topological order, we can construct two subgraphs L and R.\n+\t     L contains edge <x, y> where x < y in terms of post order, while\n+\t     R contains edge <x, y> where x > y.  Edges for compilation time\n+\t     known dependence all fall in R, so we break SCCs by removing all\n+\t     (alias) edges of in subgraph L.  */\n+\t  for_each_edge (pg, pg_collect_alias_ddrs, &cbdata);\n+\t}\n+\n+      /* For SCC that doesn't need to be broken, merge it.  */\n+      for (i = 0; i < num_sccs; ++i)\n+\t{\n+\t  if (!bitmap_bit_p (sccs_to_merge, i))\n+\t    continue;\n+\n+\t  for (j = 0; partitions->iterate (j, &first); ++j)\n+\t    if (cbdata.vertices_component[j] == i)\n+\t      break;\n+\t  for (++j; partitions->iterate (j, &partition); ++j)\n+\t    {\n+\t      struct pg_vdata *data;\n+\n+\t      if (cbdata.vertices_component[j] != i)\n+\t\tcontinue;\n+\n+\t      partition_merge_into (NULL, first, partition, FUSE_SAME_SCC);\n+\t      (*partitions)[j] = NULL;\n+\t      partition_free (partition);\n+\t      data = (struct pg_vdata *)pg->vertices[j].data;\n+\t      gcc_assert (data->id == j);\n+\t      data->partition = NULL;\n+\t    }\n+\t}\n+    }\n+\n+  sort_partitions_by_post_order (pg, partitions);\n+  free_partition_graph_vdata (pg);\n+  for_each_edge (pg, free_partition_graph_edata_cb, NULL);\n+  free_graph (pg);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Possible alias data dependence to break:\\n\");\n+      dump_data_dependence_relations (dump_file, *alias_ddrs);\n+    }\n+}\n+\n+/* Compute and return an expression whose value is the segment length which\n+   will be accessed by DR in NITERS iterations.  */\n+\n+static tree\n+data_ref_segment_size (struct data_reference *dr, tree niters)\n+{\n+  tree segment_length;\n+\n+  if (integer_zerop (DR_STEP (dr)))\n+    segment_length = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n+  else\n+    segment_length = size_binop (MULT_EXPR,\n+\t\t\t\t fold_convert (sizetype, DR_STEP (dr)),\n+\t\t\t\t fold_convert (sizetype, niters));\n+\n+  return segment_length;\n+}\n+\n+/* Return true if LOOP's latch is dominated by statement for data reference\n+   DR.  */\n+\n+static inline bool\n+latch_dominated_by_data_ref (struct loop *loop, data_reference *dr)\n+{\n+  return dominated_by_p (CDI_DOMINATORS, single_exit (loop)->src,\n+\t\t\t gimple_bb (DR_STMT (dr)));\n+}\n+\n+/* Compute alias check pairs and store them in COMP_ALIAS_PAIRS for LOOP's\n+   data dependence relations ALIAS_DDRS.  */\n+\n+static void\n+compute_alias_check_pairs (struct loop *loop, vec<ddr_p> *alias_ddrs,\n+\t\t\t   vec<dr_with_seg_len_pair_t> *comp_alias_pairs)\n+{\n+  unsigned int i;\n+  unsigned HOST_WIDE_INT factor = 1;\n+  tree niters_plus_one, niters = number_of_latch_executions (loop);\n+\n+  gcc_assert (niters != NULL_TREE && niters != chrec_dont_know);\n+  niters = fold_convert (sizetype, niters);\n+  niters_plus_one = size_binop (PLUS_EXPR, niters, size_one_node);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Creating alias check pairs:\\n\");\n+\n+  /* Iterate all data dependence relations and compute alias check pairs.  */\n+  for (i = 0; i < alias_ddrs->length (); i++)\n+    {\n+      ddr_p ddr = (*alias_ddrs)[i];\n+      struct data_reference *dr_a = DDR_A (ddr);\n+      struct data_reference *dr_b = DDR_B (ddr);\n+      tree seg_length_a, seg_length_b;\n+      int comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (dr_a),\n+\t\t\t\t\t    DR_BASE_ADDRESS (dr_b));\n+\n+      if (comp_res == 0)\n+\tcomp_res = data_ref_compare_tree (DR_OFFSET (dr_a), DR_OFFSET (dr_b));\n+      gcc_assert (comp_res != 0);\n+\n+      if (latch_dominated_by_data_ref (loop, dr_a))\n+\tseg_length_a = data_ref_segment_size (dr_a, niters_plus_one);\n+      else\n+\tseg_length_a = data_ref_segment_size (dr_a, niters);\n+\n+      if (latch_dominated_by_data_ref (loop, dr_b))\n+\tseg_length_b = data_ref_segment_size (dr_b, niters_plus_one);\n+      else\n+\tseg_length_b = data_ref_segment_size (dr_b, niters);\n+\n+      dr_with_seg_len_pair_t dr_with_seg_len_pair\n+\t  (dr_with_seg_len (dr_a, seg_length_a),\n+\t   dr_with_seg_len (dr_b, seg_length_b));\n+\n+      /* Canonicalize pairs by sorting the two DR members.  */\n+      if (comp_res > 0)\n+\tstd::swap (dr_with_seg_len_pair.first, dr_with_seg_len_pair.second);\n+\n+      comp_alias_pairs->safe_push (dr_with_seg_len_pair);\n+    }\n+\n+  if (tree_fits_uhwi_p (niters))\n+    factor = tree_to_uhwi (niters);\n+\n+  /* Prune alias check pairs.  */\n+  prune_runtime_alias_test_list (comp_alias_pairs, factor);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file,\n+\t     \"Improved number of alias checks from %d to %d\\n\",\n+\t     alias_ddrs->length (), comp_alias_pairs->length ());\n+}\n+\n+/* Given data dependence relations in ALIAS_DDRS, generate runtime alias\n+   checks and version LOOP under condition of these runtime alias checks.  */\n+\n+static void\n+version_loop_by_alias_check (struct loop *loop, vec<ddr_p> *alias_ddrs)\n+{\n+  profile_probability prob;\n+  basic_block cond_bb;\n+  struct loop *nloop;\n+  tree lhs, arg0, cond_expr = NULL_TREE;\n+  gimple_seq cond_stmts = NULL;\n+  gimple *call_stmt = NULL;\n+  auto_vec<dr_with_seg_len_pair_t> comp_alias_pairs;\n+\n+  /* Generate code for runtime alias checks if necessary.  */\n+  gcc_assert (alias_ddrs->length () > 0);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file,\n+\t     \"Version loop <%d> with runtime alias check\\n\", loop->num);\n+\n+  compute_alias_check_pairs (loop, alias_ddrs, &comp_alias_pairs);\n+  create_runtime_alias_checks (loop, &comp_alias_pairs, &cond_expr);\n+  cond_expr = force_gimple_operand_1 (cond_expr, &cond_stmts,\n+\t\t\t\t      is_gimple_condexpr, NULL_TREE);\n+\n+  /* Depend on vectorizer to fold IFN_LOOP_DIST_ALIAS.  */\n+  if (flag_tree_loop_vectorize)\n+    {\n+      /* Generate internal function call for loop distribution alias check.  */\n+      call_stmt = gimple_build_call_internal (IFN_LOOP_DIST_ALIAS,\n+\t\t\t\t\t      2, NULL_TREE, cond_expr);\n+      lhs = make_ssa_name (boolean_type_node);\n+      gimple_call_set_lhs (call_stmt, lhs);\n+    }\n+  else\n+    lhs = cond_expr;\n+\n+  prob = profile_probability::guessed_always ().apply_scale (9, 10);\n+  initialize_original_copy_tables ();\n+  nloop = loop_version (loop, lhs, &cond_bb, prob, prob.invert (),\n+\t\t\tprob, prob.invert (), true);\n+  free_original_copy_tables ();\n+  /* Record the original loop number in newly generated loops.  In case of\n+     distribution, the original loop will be distributed and the new loop\n+     is kept.  */\n+  loop->orig_loop_num = nloop->num;\n+  nloop->orig_loop_num = nloop->num;\n+  nloop->dont_vectorize = true;\n+  nloop->force_vectorize = false;\n+\n+  if (call_stmt)\n+    {\n+      /* Record new loop's num in IFN_LOOP_DIST_ALIAS because the original\n+\t loop could be destroyed.  */\n+      arg0 = build_int_cst (integer_type_node, loop->orig_loop_num);\n+      gimple_call_set_arg (call_stmt, 0, arg0);\n+      gimple_seq_add_stmt_without_update (&cond_stmts, call_stmt);\n+    }\n+\n+  if (cond_stmts)\n+    {\n+      gimple_stmt_iterator cond_gsi = gsi_last_bb (cond_bb);\n+      gsi_insert_seq_before (&cond_gsi, cond_stmts, GSI_SAME_STMT);\n+    }\n+  update_ssa (TODO_update_ssa);\n+}\n+\n+/* Return true if loop versioning is needed to distrubute PARTITIONS.\n+   ALIAS_DDRS are data dependence relations for runtime alias check.  */\n+\n+static inline bool\n+version_for_distribution_p (vec<struct partition *> *partitions,\n+\t\t\t    vec<ddr_p> *alias_ddrs)\n+{\n+  /* No need to version loop if we have only one partition.  */\n+  if (partitions->length () == 1)\n+    return false;\n+\n+  /* Need to version loop if runtime alias check is necessary.  */\n+  return (alias_ddrs->length () > 0);\n+}\n+\n+/* Fuse all partitions if necessary before finalizing distribution.  */\n+\n+static void\n+finalize_partitions (vec<struct partition *> *partitions,\n+\t\t     vec<ddr_p> *alias_ddrs)\n+{\n+  unsigned i;\n+  struct partition *a, *partition;\n+\n+  if (partitions->length () == 1\n+      || alias_ddrs->length () > 0)\n+    return;\n+\n+  a = (*partitions)[0];\n+  if (a->kind != PKIND_NORMAL)\n+    return;\n+\n+  for (i = 1; partitions->iterate (i, &partition); ++i)\n+    {\n+      /* Don't fuse if partition has different type or it is a builtin.  */\n+      if (partition->type != a->type\n+\t  || partition->kind != PKIND_NORMAL)\n+\treturn;\n+    }\n+\n+  /* Fuse all partitions.  */\n+  for (i = 1; partitions->iterate (i, &partition); ++i)\n+    {\n+      partition_merge_into (NULL, a, partition, FUSE_FINALIZE);\n+      partition_free (partition);\n+    }\n+  partitions->truncate (1);\n+}\n+\n+/* Distributes the code from LOOP in such a way that producer statements\n+   are placed before consumer statements.  Tries to separate only the\n+   statements from STMTS into separate loops.  Returns the number of\n+   distributed loops.  Set NB_CALLS to number of generated builtin calls.\n+   Set *DESTROY_P to whether LOOP needs to be destroyed.  */\n \n static int\n distribute_loop (struct loop *loop, vec<gimple *> stmts,\n@@ -1698,8 +2372,6 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   partition *partition;\n   bool any_builtin;\n   int i, nbp;\n-  graph *pg = NULL;\n-  int num_sccs = 1;\n \n   *destroy_p = false;\n   *nb_calls = 0;\n@@ -1747,6 +2419,11 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   auto_vec<struct partition *, 3> partitions;\n   rdg_build_partitions (rdg, stmts, &partitions);\n \n+  /* Can't do runtime alias check if loop niter is unknown.  */\n+  tree niters = number_of_latch_executions (loop);\n+  bool rt_alias_check_p = (niters != NULL_TREE && niters != chrec_dont_know);\n+  auto_vec<ddr_p> alias_ddrs;\n+\n   auto_bitmap stmt_in_all_partitions;\n   bitmap_copy (stmt_in_all_partitions, partitions[0]->stmts);\n   for (i = 1; partitions.iterate (i, &partition); ++i)\n@@ -1833,81 +2510,14 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n   /* Build the partition dependency graph.  */\n   if (partitions.length () > 1)\n     {\n-      pg = new_graph (partitions.length ());\n-      struct pgdata {\n-\t  struct partition *partition;\n-      };\n-#define PGDATA(i) ((pgdata *)(pg->vertices[i].data))\n-      for (i = 0; partitions.iterate (i, &partition); ++i)\n-\t{\n-\t  vertex *v = &pg->vertices[i];\n-\t  pgdata *data = new pgdata;\n-\t  /* FIXME - leaks.  */\n-\t  v->data = data;\n-\t  data->partition = partition;\n-\t}\n-      struct partition *partition1, *partition2;\n-      for (i = 0; partitions.iterate (i, &partition1); ++i)\n-\tfor (int j = i + 1; partitions.iterate (j, &partition2); ++j)\n-\t  {\n-\t    /* dependence direction - 0 is no dependence, -1 is back,\n-\t       1 is forth, 2 is both (we can stop then, merging will occur).  */\n-\t    int dir = pg_add_dependence_edges (rdg, 0,\n-\t\t\t\t\t       partition1->datarefs,\n-\t\t\t\t\t       partition2->datarefs);\n-\t    if (dir == 1 || dir == 2)\n-\t      add_edge (pg, i, j);\n-\t    if (dir == -1 || dir == 2)\n-\t      add_edge (pg, j, i);\n-\t  }\n-\n-      /* Add edges to the reduction partition (if any) to force it last.  */\n-      unsigned j;\n-      for (j = 0; partitions.iterate (j, &partition); ++j)\n-\tif (partition_reduction_p (partition))\n-\t  break;\n-      if (j < partitions.length ())\n-\t{\n-\t  for (unsigned i = 0; partitions.iterate (i, &partition); ++i)\n-\t    if (i != j)\n-\t      add_edge (pg, i, j);\n-\t}\n-\n-      /* Compute partitions we cannot separate and fuse them.  */\n-      num_sccs = graphds_scc (pg, NULL);\n-      for (i = 0; i < num_sccs; ++i)\n-\t{\n-\t  struct partition *first;\n-\t  int j;\n-\t  for (j = 0; partitions.iterate (j, &first); ++j)\n-\t    if (pg->vertices[j].component == i)\n-\t      break;\n-\t  for (j = j + 1; partitions.iterate (j, &partition); ++j)\n-\t    if (pg->vertices[j].component == i)\n-\t      {\n-\t\tpartition_merge_into (NULL, first,\n-\t\t\t\t      partition, FUSE_SAME_SCC);\n-\t\tfirst->type = PTYPE_SEQUENTIAL;\n-\t\tpartitions[j] = NULL;\n-\t\tpartition_free (partition);\n-\t\tPGDATA (j)->partition = NULL;\n-\t      }\n-\t}\n-\n-      /* Now order the remaining nodes in postorder.  */\n-      qsort (pg->vertices, pg->n_vertices, sizeof (vertex), pgcmp);\n-      partitions.truncate (0);\n-      for (i = 0; i < pg->n_vertices; ++i)\n-\t{\n-\t  pgdata *data = PGDATA (i);\n-\t  if (data->partition)\n-\t    partitions.safe_push (data->partition);\n-\t  delete data;\n-\t}\n-      gcc_assert (partitions.length () == (unsigned)num_sccs);\n-      free_graph (pg);\n+      merge_dep_scc_partitions (rdg, &partitions, rt_alias_check_p);\n+      alias_ddrs.truncate (0);\n+      if (rt_alias_check_p && partitions.length () > 1)\n+\tbreak_alias_scc_partitions (rdg, &partitions, &alias_ddrs);\n     }\n \n+  finalize_partitions (&partitions, &alias_ddrs);\n+\n   nbp = partitions.length ();\n   if (nbp == 0\n       || (nbp == 1 && !partition_builtin_p (partitions[0]))\n@@ -1917,8 +2527,15 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n       goto ldist_done;\n     }\n \n+  if (version_for_distribution_p (&partitions, &alias_ddrs))\n+    version_loop_by_alias_check (loop, &alias_ddrs);\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_rdg_partitions (dump_file, partitions);\n+    {\n+      fprintf (dump_file,\n+\t       \"distribute loop <%d> into partitions:\\n\", loop->num);\n+      dump_rdg_partitions (dump_file, partitions);\n+    }\n \n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     {"}]}