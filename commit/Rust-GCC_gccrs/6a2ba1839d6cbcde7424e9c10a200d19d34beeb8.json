{"sha": "6a2ba1839d6cbcde7424e9c10a200d19d34beeb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEyYmExODM5ZDZjYmNkZTc0MjRlOWMxMGEyMDBkMTlkMzRiZWViOA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2010-07-26T15:26:17Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2010-07-26T15:26:17Z"}, "message": "libgomp.texi: Fix spelling and pasto problems throughout.\n\n        * libgomp.texi: Fix spelling and pasto problems throughout.\n        Adjust prototypes to match code.\n\nFrom-SVN: r162538", "tree": {"sha": "7b3eabe8d28a8f814c71fe84fd24e2bb23b1e21e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b3eabe8d28a8f814c71fe84fd24e2bb23b1e21e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a2ba1839d6cbcde7424e9c10a200d19d34beeb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2ba1839d6cbcde7424e9c10a200d19d34beeb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a2ba1839d6cbcde7424e9c10a200d19d34beeb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2ba1839d6cbcde7424e9c10a200d19d34beeb8/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "edc74207ded06c2421dd72ad6156a77fb0c0f07e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc74207ded06c2421dd72ad6156a77fb0c0f07e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edc74207ded06c2421dd72ad6156a77fb0c0f07e"}], "stats": {"total": 156, "additions": 81, "deletions": 75}, "files": [{"sha": "f98b9647ed8e1af13d9d86cd18d711fba164c299", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2ba1839d6cbcde7424e9c10a200d19d34beeb8/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2ba1839d6cbcde7424e9c10a200d19d34beeb8/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=6a2ba1839d6cbcde7424e9c10a200d19d34beeb8", "patch": "@@ -1,3 +1,8 @@\n+2010-07-26  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* libgomp.texi: Fix spelling and pasto problems throughout.\n+\tAdjust prototypes to match code.\n+\n 2010-07-24  Tobias Burnus  <burnus@net-b.de>\n \n \t* testsuite/libgomp.fortran/appendix-a/a.28.5.f90: Add -w to"}, {"sha": "3435819dbd67ed09f617bbaeeef188213cdb3547", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 76, "deletions": 75, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2ba1839d6cbcde7424e9c10a200d19d34beeb8/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2ba1839d6cbcde7424e9c10a200d19d34beeb8/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=6a2ba1839d6cbcde7424e9c10a200d19d34beeb8", "patch": "@@ -137,14 +137,14 @@ Control threads, processors and the parallel environment.\n * omp_get_ancestor_thread_num:: Ancestor thread ID\n * omp_get_dynamic::             Dynamic teams setting\n * omp_get_level::               Number of parallel regions\n-* omp_get_max_active_levels::   Maximal number of active regions\n-* omp_get_max_threads::         Maximal number of threads of parallel region\n+* omp_get_max_active_levels::   Maximum number of active regions\n+* omp_get_max_threads::         Maximum number of threads of parallel region\n * omp_get_nested::              Nested parallel regions\n * omp_get_num_procs::           Number of processors online\n * omp_get_num_threads::         Size of the active team\n * omp_get_schedule::            Obtain the runtime scheduling method\n * omp_get_team_size::           Number of threads in a team\n-* omp_get_thread_limit::        Maximal number of threads\n+* omp_get_thread_limit::        Maximum number of threads\n * omp_get_thread_num::          Current thread ID\n * omp_in_parallel::             Whether a parallel region is active\n * omp_set_dynamic::             Enable/disable dynamic teams\n@@ -187,7 +187,7 @@ which enclose the calling call.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_active_level();}\n+@item @emph{Prototype}: @tab @code{int omp_get_active_level(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -220,7 +220,7 @@ zero to @code{omp_get_level} -1 is returned; if @var{level} is\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{integer omp_ancestor_thread_num(level)}\n+@item @emph{Interface}: @tab @code{integer omp_get_ancestor_thread_num(level)}\n @item                   @tab @code{integer level}\n @end multitable\n \n@@ -248,7 +248,7 @@ disabled by default.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_dynamic();}\n+@item @emph{Prototype}: @tab @code{int omp_get_dynamic(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -274,7 +274,7 @@ which enclose the calling call.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get level();}\n+@item @emph{Prototype}: @tab @code{int omp_get_level(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -292,14 +292,14 @@ which enclose the calling call.\n \n \n @node omp_get_max_active_levels\n-@section @code{omp_set_max_active_levels} -- Maximal number of active regions\n+@section @code{omp_get_max_active_levels} -- Maximum number of active regions\n @table @asis\n @item @emph{Description}:\n-This function obtains the maximally allowed number of nested, active parallel regions.\n+This function obtains the maximum allowed number of nested, active parallel regions.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_max_active_levels();}\n+@item @emph{Prototype}: @tab @code{int omp_get_max_active_levels(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -317,15 +317,15 @@ This function obtains the maximally allowed number of nested, active parallel re\n \n \n @node omp_get_max_threads\n-@section @code{omp_get_max_threads} -- Maximal number of threads of parallel region\n+@section @code{omp_get_max_threads} -- Maximum number of threads of parallel region\n @table @asis\n @item @emph{Description}:\n-Return the maximal number of threads used for the current parallel region\n+Return the maximum number of threads used for the current parallel region\n that does not use the clause @code{num_threads}.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_max_threads();}\n+@item @emph{Prototype}: @tab @code{int omp_get_max_threads(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -357,7 +357,7 @@ disabled by default.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_nested();}\n+@item @emph{Prototype}: @tab @code{int omp_get_nested(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -382,7 +382,7 @@ Returns the number of processors online.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_num_procs();}\n+@item @emph{Prototype}: @tab @code{int omp_get_num_procs(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -400,7 +400,7 @@ Returns the number of processors online.\n @section @code{omp_get_num_threads} -- Size of the active team\n @table @asis\n @item @emph{Description}:\n-The number of threads in the current team. In a sequential section of \n+Returns the number of threads in the current team. In a sequential section of \n the program @code{omp_get_num_threads} returns 1.\n \n The default team size may be initialized at startup by the \n@@ -412,7 +412,7 @@ one thread per CPU online is used.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_num_threads();}\n+@item @emph{Prototype}: @tab @code{int omp_get_num_threads(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -433,14 +433,14 @@ one thread per CPU online is used.\n @section @code{omp_get_schedule} -- Obtain the runtime scheduling method\n @table @asis\n @item @emph{Description}:\n-Obtain runtime the scheduling method. The @var{kind} argument will be\n+Obtain the runtime scheduling method. The @var{kind} argument will be\n set to the value @code{omp_sched_static}, @code{omp_sched_dynamic},\n-@code{opm_sched_guided} or @code{auto}. The second argument, @var{modifier},\n-is set to the chunk size.\n+@code{omp_sched_guided} or @code{omp_sched_auto}. The second argument,\n+@var{modifier}, is set to the chunk size.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{omp_schedule(omp_sched_t * kind, int *modifier);}\n+@item @emph{Prototype}: @tab @code{omp_schedule(omp_sched_t *kind, int *modifier);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -465,13 +465,13 @@ is set to the chunk size.\n @item @emph{Description}:\n This function returns the number of threads in a thread team to which\n either the current thread or its ancestor belongs. For values of @var{level}\n-outside zero to @code{omp_get_level} -1 is returned; if @var{level} is zero\n-1 is returned and for @code{omp_get_level} the result is identical\n+outside zero to @code{omp_get_level}, -1 is returned; if @var{level} is zero,\n+1 is returned, and for @code{omp_get_level}, the result is identical\n to @code{omp_get_num_threads}.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_time_size(int level);}\n+@item @emph{Prototype}: @tab @code{int omp_get_team_size(int level);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -490,14 +490,14 @@ to @code{omp_get_num_threads}.\n \n \n @node omp_get_thread_limit\n-@section @code{omp_get_thread_limit} -- Maximal number of threads\n+@section @code{omp_get_thread_limit} -- Maximum number of threads\n @table @asis\n @item @emph{Description}:\n-Return the maximal number of threads of the program.\n+Return the maximum number of threads of the program.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_thread_limit();}\n+@item @emph{Prototype}: @tab @code{int omp_get_thread_limit(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -518,15 +518,15 @@ Return the maximal number of threads of the program.\n @section @code{omp_get_thread_num} -- Current thread ID\n @table @asis\n @item @emph{Description}:\n-Unique thread identification number within the current team.\n+Returns a unique thread identification number within the current team.\n In a sequential parts of the program, @code{omp_get_thread_num}\n always returns 0. In parallel regions the return value varies\n from 0 to @code{omp_get_num_threads}-1 inclusive. The return \n value of the master thread of a team is always 0.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_get_thread_num();}\n+@item @emph{Prototype}: @tab @code{int omp_get_thread_num(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -553,7 +553,7 @@ their language-specific counterparts.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_in_parallel();}\n+@item @emph{Prototype}: @tab @code{int omp_in_parallel(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -577,7 +577,7 @@ adjustment of team sizes and @code{false} disables it.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_set_dynamic(int);}\n+@item @emph{Prototype}: @tab @code{void omp_set_dynamic(int set);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -599,16 +599,17 @@ adjustment of team sizes and @code{false} disables it.\n @section @code{omp_set_max_active_levels} -- Limits the number of active parallel regions\n @table @asis\n @item @emph{Description}:\n-This function limits the maximally allowed number of nested, active parallel regions.\n+This function limits the maximum allowed number of nested, active\n+parallel regions.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{omp_set_max_active_levels(int max_levels);}\n+@item @emph{Prototype}: @tab @code{void omp_set_max_active_levels(int max_levels);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{omp_max_active_levels(max_levels)}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_max_active_levels(max_levels)}\n @item                   @tab @code{integer max_levels}\n @end multitable\n \n@@ -632,12 +633,12 @@ dynamic adjustment of team sizes and @code{false} disables it.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_set_dynamic(int);}\n+@item @emph{Prototype}: @tab @code{void omp_set_nested(int set);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_set_dynamic(set)}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_nested(set)}\n @item                   @tab @code{integer, intent(in) :: set}\n @end multitable\n \n@@ -660,13 +661,13 @@ argument of @code{omp_set_num_threads} shall be a positive integer.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_set_num_threads(int);}\n+@item @emph{Prototype}: @tab @code{void omp_set_num_threads(int n);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_set_num_threads(set)}\n-@item                   @tab @code{integer, intent(in) :: set}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_num_threads(n)}\n+@item                   @tab @code{integer, intent(in) :: n}\n @end multitable\n \n @item @emph{See also}:\n@@ -684,19 +685,19 @@ argument of @code{omp_set_num_threads} shall be a positive integer.\n @item @emph{Description}:\n Sets the runtime scheduling method. The @var{kind} argument can have the\n value @code{omp_sched_static}, @code{omp_sched_dynamic},\n-@code{opm_sched_guided} or @code{omp_sched_auto}. Except for\n+@code{omp_sched_guided} or @code{omp_sched_auto}. Except for\n @code{omp_sched_auto}, the chunk size is set to the value of\n-@var{modifier} if positive or to the default value if zero or negative.\n+@var{modifier} if positive, or to the default value if zero or negative.\n For @code{omp_sched_auto} the @var{modifier} argument is ignored.\n \n @item @emph{C/C++}\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{int omp_schedule(omp_sched_t * kind, int *modifier);}\n+@item @emph{Prototype}: @tab @code{int omp_set_schedule(omp_sched_t *kind, int *modifier);}\n @end multitable\n \n @item @emph{Fortran}:\n @multitable @columnfractions .20 .80\n-@item @emph{Interface}: @tab @code{subroutine omp_schedule(kind, modifier)}\n+@item @emph{Interface}: @tab @code{subroutine omp_set_schedule(kind, modifier)}\n @item                   @tab @code{integer(kind=omp_sched_kind) kind}\n @item                   @tab @code{integer modifier}\n @end multitable\n@@ -715,7 +716,7 @@ For @code{omp_sched_auto} the @var{modifier} argument is ignored.\n @section @code{omp_init_lock} -- Initialize simple lock\n @table @asis\n @item @emph{Description}:\n-Initialize a simple lock. After initialization, the lock is in \n+Initialize a simple lock.  After initialization, the lock is in \n an unlocked state.\n \n @item @emph{C/C++}:\n@@ -805,7 +806,7 @@ does not block if the lock is not available. This function returns\n A simple lock about to be unset must have been locked by @code{omp_set_lock}\n or @code{omp_test_lock} before. In addition, the lock must be held by the \n thread calling @code{omp_unset_lock}. Then, the lock becomes unlocked. If one \n-ore more threads attempted to set the lock before, one of them is chosen to, \n+or more threads attempted to set the lock before, one of them is chosen to, \n again, set the lock for itself.\n \n @item @emph{C/C++}:\n@@ -837,7 +838,7 @@ in the unlocked state.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{void omp_destroy_lock(omp_lock_t *);}\n+@item @emph{Prototype}: @tab @code{void omp_destroy_lock(omp_lock_t *lock);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -859,7 +860,7 @@ in the unlocked state.\n @section @code{omp_init_nest_lock} -- Initialize nested lock\n @table @asis\n @item @emph{Description}:\n-Initialize a nested lock. After initialization, the lock is in \n+Initialize a nested lock.  After initialization, the lock is in \n an unlocked state and the nesting count is set to zero.\n \n @item @emph{C/C++}:\n@@ -882,7 +883,7 @@ an unlocked state and the nesting count is set to zero.\n \n \n @node omp_set_nest_lock\n-@section @code{omp_set_nest_lock} -- Wait for and set simple lock\n+@section @code{omp_set_nest_lock} -- Wait for and set nested lock\n @table @asis\n @item @emph{Description}:\n Before setting a nested lock, the lock variable must be initialized by \n@@ -1008,7 +1009,7 @@ successive clock ticks.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{double omp_get_wtick();}\n+@item @emph{Prototype}: @tab @code{double omp_get_wtick(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -1030,13 +1031,13 @@ successive clock ticks.\n @table @asis\n @item @emph{Description}:\n Elapsed wall clock time in seconds. The time is measured per thread, no \n-guarantee can bee made that two distinct threads measure the same time.\n+guarantee can be made that two distinct threads measure the same time.\n Time is measured from some \"time in the past\". On POSIX compliant systems \n the seconds since the Epoch (00:00:00 UTC, January 1, 1970) are returned.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{double omp_get_wtime();}\n+@item @emph{Prototype}: @tab @code{double omp_get_wtime(void);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -1069,12 +1070,12 @@ extensions.\n \n @menu\n * OMP_DYNAMIC::           Dynamic adjustment of threads\n-* OMP_MAX_ACTIVE_LEVELS:: Set the maximal number of nested parallel regions\n+* OMP_MAX_ACTIVE_LEVELS:: Set the maximum number of nested parallel regions\n * OMP_NESTED::            Nested parallel regions\n * OMP_NUM_THREADS::       Specifies the number of threads to use\n * OMP_STACKSIZE::         Set default thread stack size\n * OMP_SCHEDULE::          How threads are scheduled\n-* OMP_THREAD_LIMIT::      Set the maximal number of threads\n+* OMP_THREAD_LIMIT::      Set the maximum number of threads\n * OMP_WAIT_POLICY::       How waiting threads are handled\n * GOMP_CPU_AFFINITY::     Bind threads to specific CPUs\n * GOMP_STACKSIZE::        Set default thread stack size\n@@ -1101,11 +1102,11 @@ disabled by default.\n \n \n @node OMP_MAX_ACTIVE_LEVELS\n-@section @env{OMP_MAX_ACTIVE_LEVELS} -- Set the maximal number of nested parallel regions\n+@section @env{OMP_MAX_ACTIVE_LEVELS} -- Set the maximum number of nested parallel regions\n @cindex Environment Variable\n @table @asis\n @item @emph{Description}:\n-Specifies the initial value for the maximal number of nested parallel\n+Specifies the initial value for the maximum number of nested parallel\n regions. The value of this variable shall be positive integer.\n If undefined, the number of active levels is unlimited.\n \n@@ -1145,8 +1146,8 @@ regions are disabled by default.\n @table @asis\n @item @emph{Description}:\n Specifies the default number of threads to use in parallel regions. The \n-value of this variable shall be positive integer. If undefined one thread \n-per CPU online is used.\n+value of this variable shall be a positive integer. If undefined one thread \n+per CPU is used.\n \n @item @emph{See also}:\n @ref{omp_set_num_threads}\n@@ -1187,7 +1188,7 @@ Set the default thread stack size in kilobytes, unless the number\n is suffixed by @code{B}, @code{K}, @code{M} or @code{G}, in which\n case the size is, respectively, in bytes, kilobytes, megabytes\n or gigabytes. This is different from @code{pthread_attr_setstacksize}\n-which gets the number of bytes as an argument. If the stacksize can not\n+which gets the number of bytes as an argument. If the stacksize cannot\n be set due to system constraints, an error is reported and the initial\n stacksize is left unchanged. If undefined, the stack size is system\n dependent.\n@@ -1199,12 +1200,12 @@ dependent.\n \n \n @node OMP_THREAD_LIMIT\n-@section @env{OMP_THREAD_LIMIT} -- Set the maximal number of threads\n+@section @env{OMP_THREAD_LIMIT} -- Set the maximum number of threads\n @cindex Environment Variable\n @table @asis\n @item @emph{Description}:\n Specifies the number of threads to use for the whole program. The\n-value of this variable shall be positive integer. If undefined,\n+value of this variable shall be a positive integer. If undefined,\n the number of threads is not limited.\n \n @item @emph{See also}:\n@@ -1238,15 +1239,15 @@ they should.\n @cindex Environment Variable\n @table @asis\n @item @emph{Description}:\n-Binds threads to specific CPUs. The variable should contain a space- or\n-comma-separated list of CPUs. This list may contain different kind of \n+Binds threads to specific CPUs. The variable should contain a space-separated\n+or comma-separated list of CPUs. This list may contain different kinds of \n entries: either single CPU numbers in any order, a range of CPUs (M-N) \n-or a range with some stride (M-N:S). CPU numbers are zero based. For example,\n+or a range with some stride (M-N:S).  CPU numbers are zero based. For example,\n @code{GOMP_CPU_AFFINITY=\"0 3 1-2 4-15:2\"} will bind the initial thread\n to CPU 0, the second to CPU 3, the third to CPU 1, the fourth to \n CPU 2, the fifth to CPU 4, the sixth through tenth to CPUs 6, 8, 10, 12,\n and 14 respectively and then start assigning back from the beginning of\n-the list. @code{GOMP_CPU_AFFINITY=0} binds all threads to CPU 0.\n+the list.  @code{GOMP_CPU_AFFINITY=0} binds all threads to CPU 0.\n \n There is no GNU OpenMP library routine to determine whether a CPU affinity \n specification is in effect. As a workaround, language-specific library \n@@ -1269,7 +1270,7 @@ assignment of threads to CPUs.\n @item @emph{Description}:\n Set the default thread stack size in kilobytes. This is different from\n @code{pthread_attr_setstacksize} which gets the number of bytes as an \n-argument. If the stacksize can not be set due to system constraints, an \n+argument. If the stacksize cannot be set due to system constraints, an \n error is reported and the initial stacksize is left unchanged. If undefined,\n the stack size is system dependent.\n \n@@ -1293,7 +1294,7 @@ GCC Patches Mailinglist}\n @chapter The libgomp ABI\n \n The following sections present notes on the external ABI as \n-presented by libgomp. Only maintainers should need them.\n+presented by libgomp.  Only maintainers should need them.\n \n @menu\n * Implementing MASTER construct::\n@@ -1323,7 +1324,7 @@ if (omp_get_thread_num () == 0)\n \n Alternately, we generate two copies of the parallel subfunction\n and only include this in the version run by the master thread.\n-Surely that's not worthwhile though...\n+Surely this is not worthwhile though...\n \n \n \n@@ -1348,7 +1349,7 @@ name being transformed into a variable declared like\n @end smallexample\n \n Ideally the ABI would specify that all zero is a valid unlocked\n-state, and so we wouldn't actually need to initialize this at\n+state, and so we wouldn't need to initialize this at\n startup.\n \n \n@@ -1415,14 +1416,14 @@ the semantic of new variable creation.\n @node Implementing FIRSTPRIVATE LASTPRIVATE COPYIN and COPYPRIVATE clauses\n @section Implementing FIRSTPRIVATE LASTPRIVATE COPYIN and COPYPRIVATE clauses\n \n-Seems simple enough for PARALLEL blocks.  Create a private \n-struct for communicating between parent and subfunction.\n+This seems simple enough for PARALLEL blocks.  Create a private \n+struct for communicating between the parent and subfunction.\n In the parent, copy in values for scalar and \"small\" structs;\n copy in addresses for others TREE_ADDRESSABLE types.  In the \n subfunction, copy the value into the local variable.\n \n-Not clear at all what to do with bare FOR or SECTION blocks.\n-The only thing I can figure is that we do something like\n+It is not clear what to do with bare FOR or SECTION blocks.\n+The only thing I can figure is that we do something like:\n \n @smallexample\n #pragma omp for firstprivate(x) lastprivate(y)\n@@ -1459,7 +1460,7 @@ broadcast would have to happen via SINGLE machinery instead.\n The private struct mentioned in the previous section should have \n a pointer to an array of the type of the variable, indexed by the \n thread's @var{team_id}.  The thread stores its final value into the \n-array, and after the barrier the master thread iterates over the\n+array, and after the barrier, the master thread iterates over the\n array to collect the values.\n \n \n@@ -1564,7 +1565,7 @@ becomes\n   @}\n @end smallexample\n \n-Note that while it looks like there is trickyness to propagating\n+Note that while it looks like there is trickiness to propagating\n a non-constant STEP, there isn't really.  We're explicitly allowed\n to evaluate it as many times as we want, and any variables involved\n should automatically be handled as PRIVATE or SHARED like any other\n@@ -1682,7 +1683,7 @@ becomes\n @chapter Reporting Bugs\n \n Bugs in the GNU OpenMP implementation should be reported via \n-@uref{http://gcc.gnu.org/bugzilla/, bugzilla}. In all cases, please add \n+@uref{http://gcc.gnu.org/bugzilla/, bugzilla}.  For all cases, please add \n \"openmp\" to the keywords field in the bug report.\n \n "}]}