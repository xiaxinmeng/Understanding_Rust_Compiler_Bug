{"sha": "39ba2f92e1b7970615fd87e16bff32b100c07252", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzliYTJmOTJlMWI3OTcwNjE1ZmQ4N2UxNmJmZjMyYjEwMGMwNzI1Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-10-08T13:34:56Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-10-08T13:34:56Z"}, "message": "re PR target/17245 (ICE compiling gsl-1.5 statistics/lag1.c)\n\n\tPR target/17245\n\t* config/sparc/sparc.c (input_operand): Remove redundant code\n\tfor handling LO_SUM.\n\t(legitimate_address_p) <REG+REG>: Do not recheck TARGET_V9.\n\t<LO_SUM>: If LO_SUM is offsettable, accept it for TFmode on V9.\n\tOtherwise only accept it for TFmode if quad move insns are available.\n\nFrom-SVN: r88753", "tree": {"sha": "b237fbaf12e296948730cf86c8b2c35e5e75c855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b237fbaf12e296948730cf86c8b2c35e5e75c855"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ba2f92e1b7970615fd87e16bff32b100c07252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ba2f92e1b7970615fd87e16bff32b100c07252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ba2f92e1b7970615fd87e16bff32b100c07252", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ba2f92e1b7970615fd87e16bff32b100c07252/comments", "author": null, "committer": null, "parents": [{"sha": "10a5233517ed126df715d041cdb64e41bb365cb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a5233517ed126df715d041cdb64e41bb365cb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a5233517ed126df715d041cdb64e41bb365cb2"}], "stats": {"total": 90, "additions": 63, "deletions": 27}, "files": [{"sha": "161ead26267c7b7fc7837529fc09d0e5e958c0f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba2f92e1b7970615fd87e16bff32b100c07252/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba2f92e1b7970615fd87e16bff32b100c07252/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39ba2f92e1b7970615fd87e16bff32b100c07252", "patch": "@@ -1,3 +1,12 @@\n+2004-10-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/17245\n+\t* config/sparc/sparc.c (input_operand): Remove redundant code\n+\tfor handling LO_SUM.\n+\t(legitimate_address_p) <REG+REG>: Do not recheck TARGET_V9.\n+\t<LO_SUM>: If LO_SUM is offsettable, accept it for TFmode on V9.\n+\tOtherwise only accept it for TFmode if quad move insns are available.\n+\n 2004-10-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-cfg.c (tree_forwarder_block_p): Reorder checks so that"}, {"sha": "3f75954e6cc6cb960afa0f5ddd828a0bf23eacd0", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba2f92e1b7970615fd87e16bff32b100c07252/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba2f92e1b7970615fd87e16bff32b100c07252/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=39ba2f92e1b7970615fd87e16bff32b100c07252", "patch": "@@ -1547,23 +1547,7 @@ input_operand (rtx op, enum machine_mode mode)\n \n   /* Check for valid MEM forms.  */\n   if (GET_CODE (op) == MEM)\n-    {\n-      rtx inside = XEXP (op, 0);\n-\n-      if (GET_CODE (inside) == LO_SUM)\n-\t{\n-\t  /* We can't allow these because all of the splits\n-\t     (eventually as they trickle down into DFmode\n-\t     splits) require offsettable memory references.  */\n-\t  if (! TARGET_V9\n-\t      && GET_MODE (op) == TFmode)\n-\t    return 0;\n-\n-\t  return (register_operand (XEXP (inside, 0), Pmode)\n-\t\t  && CONSTANT_P (XEXP (inside, 1)));\n-\t}\n-      return memory_address_p (mode, inside);\n-    }\n+    return memory_address_p (mode, XEXP (op, 0));\n \n   return 0;\n }\n@@ -3516,15 +3500,14 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n       else if ((REG_P (rs1) || GET_CODE (rs1) == SUBREG)\n \t       && (REG_P (rs2) || GET_CODE (rs2) == SUBREG))\n \t{\n-\t  /* We prohibit REG + REG for TFmode when there are no instructions\n-\t     which accept REG+REG instructions.  We do this because REG+REG\n-\t     is not an offsetable address.  If we get the situation in reload\n+\t  /* We prohibit REG + REG for TFmode when there are no quad move insns\n+\t     and we consequently need to split.  We do this because REG+REG\n+\t     is not an offsettable address.  If we get the situation in reload\n \t     where source and destination of a movtf pattern are both MEMs with\n \t     REG+REG address, then only one of them gets converted to an\n-\t     offsetable address.  */\n+\t     offsettable address.  */\n \t  if (mode == TFmode\n-\t      && !(TARGET_FPU && TARGET_ARCH64 && TARGET_V9\n-\t\t   && TARGET_HARD_QUAD))\n+\t      && ! (TARGET_FPU && TARGET_ARCH64 && TARGET_HARD_QUAD))\n \t    return 0;\n \n \t  /* We prohibit REG + REG on ARCH32 if not optimizing for\n@@ -3557,10 +3540,25 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n       if (! CONSTANT_P (imm1) || tls_symbolic_operand (rs1))\n \treturn 0;\n \n-      /* We can't allow TFmode, because an offset greater than or equal to the\n-         alignment (8) may cause the LO_SUM to overflow if !v9.  */\n-      if (mode == TFmode && !TARGET_V9)\n-\treturn 0;\n+      if (USE_AS_OFFSETABLE_LO10)\n+\t{\n+\t  /* We can't allow TFmode, because an offset greater than or equal to\n+\t     the alignment (8) may cause the LO_SUM to overflow if !v9.  */\n+\t  if (mode == TFmode && ! TARGET_V9)\n+\t    return 0;\n+\t}\n+      else\n+        {\n+\t  /* We prohibit LO_SUM for TFmode when there are no quad move insns\n+\t     and we consequently need to split.  We do this because LO_SUM\n+\t     is not an offsettable address.  If we get the situation in reload\n+\t     where source and destination of a movtf pattern are both MEMs with\n+\t     LO_SUM address, then only one of them gets converted to an\n+\t     offsettable address.  */\n+\t  if (mode == TFmode\n+\t      && ! (TARGET_FPU && TARGET_ARCH64 && TARGET_HARD_QUAD))\n+\t    return 0;\n+\t}\n     }\n   else if (GET_CODE (addr) == CONST_INT && SMALL_INT (addr))\n     return 1;"}, {"sha": "81dbc32754fad5b7b08f8ae4b242139cb79b2025", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba2f92e1b7970615fd87e16bff32b100c07252/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba2f92e1b7970615fd87e16bff32b100c07252/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=39ba2f92e1b7970615fd87e16bff32b100c07252", "patch": "@@ -1,3 +1,7 @@\n+2004-10-08  Christian Ehrhardt  <ehrhardt@mathematik.uni-ulm.de>\n+\n+\t* gcc.dg/ultrasp11.c: New test.\n+\n 2004-10-08  Michael Matz  <matz@suse.de>\n \n \t* gcc.dg/doloop-2.c: New test."}, {"sha": "8f279f721ae582d407f0eb882773af1855e4d956", "filename": "gcc/testsuite/gcc.dg/ultrasp11.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ba2f92e1b7970615fd87e16bff32b100c07252/gcc%2Ftestsuite%2Fgcc.dg%2Fultrasp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ba2f92e1b7970615fd87e16bff32b100c07252/gcc%2Ftestsuite%2Fgcc.dg%2Fultrasp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fultrasp11.c?ref=39ba2f92e1b7970615fd87e16bff32b100c07252", "patch": "@@ -0,0 +1,25 @@\n+/* PR target/17245 */\n+/* Origin: <aaronw@net.com> */\n+/* Testcase by Christian Ehrhardt <ehrhardt@mathematik.uni-ulm.de> */\n+/* { dg-do compile { target sparc*-*-* } } */\n+/* { dg-options \"-O -mcpu=v9\" } */\n+\n+/* This used to fail on 32-bit Ultrasparc because reload was emitting\n+   a move insn that doesn't satisfy its constraints.  */\n+\n+int n; \n+double range ;\n+double bin ;\n+double wmean;\n+\n+double f ()\n+{\n+  int i ;\n+  long double W = 0 ;\n+  for ( i = 0 ; i < n ; i ++) {\n+    double xi = range;\n+    double wi = bin;\n+    W += wi ;\n+    wmean += ( xi - wmean) * ( wi / W);\n+  }\n+}"}]}