{"sha": "c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdhZTY0ZjJjYzU3MzNlNDBiZmIzY2E2YTU4YTYzZWNlOTc2OTFlMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-11-10T20:03:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-11-10T20:03:49Z"}, "message": "stmt.c (expand_decl_cleanup_no_eh): New fn.\n\n\t* stmt.c (expand_decl_cleanup_no_eh): New fn.\n\n\t* except.c (expand_leftover_cleanups): do_pending_stack_adjust.\n\n\tComplete nested exception support.\n\t* except.c (do_pop_exception): Split out...\n\t(push_eh_cleanup): From here.  Handle the EH region by hand.\n\t(expand_start_catch_block): Add a new level for the catch parm.\n\tMove the rethrow region outside the two cleanup regions.\n\tProtect the initializer for the catch parm with terminate.\n\t(expand_end_catch_block): Likewise.  End the region for the eh_cleanup.\n\t* exception.cc (__cp_pop_exception): Now takes two parms.  Handle\n\tpopping off the middle of the stack.\n\t* tree.c (lvalue_p, real_lvalue_p): Handle TRY_CATCH_EXPR,\n\tWITH_CLEANUP_EXPR, and UNSAVE_EXPR.\n\t(build_cplus_new): Only wrap CALL_EXPRs.\n\t* init.c (expand_default_init): Handle a TRY_CATCH_EXPR around\n\tthe constructor call.\n\nFrom-SVN: r16419", "tree": {"sha": "bcf117ed27d06a44b18a74813ec3d1623001099e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcf117ed27d06a44b18a74813ec3d1623001099e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/comments", "author": null, "committer": null, "parents": [{"sha": "26f578a2286268f9ec2815978264f2647d6516ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26f578a2286268f9ec2815978264f2647d6516ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26f578a2286268f9ec2815978264f2647d6516ff"}], "stats": {"total": 222, "additions": 168, "deletions": 54}, "files": [{"sha": "33222307c4f9bc99b6ab4132c6884de491cd2528", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -1,3 +1,9 @@\n+Mon Nov 10 03:02:19 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* stmt.c (expand_decl_cleanup_no_eh): New fn.\n+\n+\t* except.c (expand_leftover_cleanups): do_pending_stack_adjust.\n+\n Mon Nov 10 00:05:56 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* alias.c (MAX_ALIAS_LOOP_PASSES): Define."}, {"sha": "b96f7b27434cbf511308c5a52b709549b10b6fa2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -4,6 +4,27 @@ Sun Nov  9 01:29:55 1997  Jim Wilson  (wilson@cygnus.com)\n \t* init.c (build_vec_delete_1): Delete build_block and\n \tadd_block_current_level calls.\n \n+Mon Nov 10 03:04:20 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tComplete nested exception support.\n+\t* except.c (do_pop_exception): Split out...\n+\t(push_eh_cleanup): From here.  Handle the EH region by hand.\n+\t(expand_start_catch_block): Add a new level for the catch parm.\n+\tMove the rethrow region outside the two cleanup regions.\n+\tProtect the initializer for the catch parm with terminate.\n+\t(expand_end_catch_block): Likewise.  End the region for the eh_cleanup.\n+\t* exception.cc (__cp_pop_exception): Now takes two parms.  Handle\n+\tpopping off the middle of the stack.\n+\t* tree.c (lvalue_p, real_lvalue_p): Handle TRY_CATCH_EXPR, \n+\tWITH_CLEANUP_EXPR, and UNSAVE_EXPR.\n+\t(build_cplus_new): Only wrap CALL_EXPRs.\n+\t* init.c (expand_default_init): Handle a TRY_CATCH_EXPR around \n+\tthe constructor call.\n+\n+Sun Nov  9 18:00:26 1997  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Make-lang.in (c++.distdir): Make inc subdirectory.\n+\n Fri Nov  7 11:57:28 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (finish_file): Put back some code."}, {"sha": "a1e5794492dd6887b263c0d6cd9ae685074ad8ae", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -1,5 +1,5 @@\n # Top level makefile fragment for GNU C++.\n-#   Copyright (C) 1994, 1995 Free Software Foundation, Inc.\n+#   Copyright (C) 1994, 1995, 1997 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -265,8 +265,14 @@ c++.stage4: stage4-start\n # distribution anyway.  It then copies the files to the distdir directory.\n c++.distdir:\n \tmkdir tmp/cp\n+\tmkdir tmp/cp/inc\n \tcd cp ; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) parse.c hash.h\n \tcd cp; \\\n \tfor file in *[0-9a-zA-Z+]; do \\\n \t  $(LN) $$file ../tmp/cp; \\\n \tdone\n+\tcd cp/inc; \\\n+\tfor file in *[0-9a-zA-Z+]; do \\\n+\t  ln $$file ../../tmp/cp/inc >/dev/null 2>&1 \\\n+\t   || cp $$file ../../tmp/cp/inc; \\\n+\tdone"}, {"sha": "e4cff1f823b936a968d5a1e7e926d790894cb192", "filename": "gcc/cp/except.c", "status": "modified", "additions": 85, "deletions": 47, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -461,26 +461,31 @@ build_eh_type (exp)\n   return build_eh_type_type (TREE_TYPE (exp));\n }\n \n-/* This routine creates the cleanup for the current exception.  */\n+/* Build up a call to __cp_pop_exception, to destroy the exception object\n+   for the current catch block.  HANDLER is either true or false, telling\n+   the library whether or not it is being called from an exception handler;\n+   if it is, it avoids destroying the object on rethrow.  */\n \n-static void\n-push_eh_cleanup ()\n+static tree\n+do_pop_exception (handler)\n+     tree handler;\n {\n-  /* All cleanups must last longer than normal.  */\n-  int yes = suspend_momentary ();\n   tree fn, cleanup;\n-\n   fn = get_identifier (\"__cp_pop_exception\");\n   if (IDENTIFIER_GLOBAL_VALUE (fn))\n     fn = IDENTIFIER_GLOBAL_VALUE (fn);\n   else\n     {\n-      /* Declare void __cp_pop_exception (void), as defined in exception.cc. */\n+      /* Declare void __cp_pop_exception (void *),\n+\t as defined in exception.cc. */\n       push_obstacks_nochange ();\n       end_temporary_allocation ();\n-      fn = build_lang_decl (FUNCTION_DECL, fn,\n-\t\t\t    build_function_type (void_type_node,\n-\t\t\t\t\t\t void_list_node));\n+      fn = build_lang_decl\n+\t(FUNCTION_DECL, fn,\n+\t build_function_type (void_type_node, tree_cons\n+\t\t\t      (NULL_TREE, ptr_type_node, tree_cons\n+\t\t\t       (NULL_TREE, boolean_type_node,\n+\t\t\t\tvoid_list_node))));\n       DECL_EXTERNAL (fn) = 1;\n       TREE_PUBLIC (fn) = 1;\n       DECL_ARTIFICIAL (fn) = 1;\n@@ -491,12 +496,26 @@ push_eh_cleanup ()\n     }\n \n   /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */\n-  cleanup = build_function_call (fn, NULL_TREE);\n-  expand_decl_cleanup (NULL_TREE, cleanup);\n+  cleanup = lookup_name (get_identifier (\"__exception_info\"), 0);\n+  cleanup = build_function_call (fn, expr_tree_cons\n+\t\t\t\t (NULL_TREE, cleanup, expr_tree_cons\n+\t\t\t\t  (NULL_TREE, handler, NULL_TREE)));\n+}\n+\n+/* This routine creates the cleanup for the current exception.  */\n \n+static void\n+push_eh_cleanup ()\n+{\n+  /* All cleanups must last longer than normal.  */\n+  int yes = suspend_momentary ();\n+  expand_decl_cleanup_no_eh (NULL_TREE, do_pop_exception (boolean_false_node));\n   resume_momentary (yes);\n-}\n \n+  /* We don't destroy the exception object on rethrow, so we can't use\n+     the normal cleanup mechanism for it.  */\n+  expand_eh_region_start ();\n+}\n \n /* call this to start a catch block. Typename is the typename, and identifier\n    is the variable to place the object in or NULL if the variable doesn't\n@@ -530,7 +549,18 @@ expand_start_catch_block (declspecs, declarator)\n   if (! doing_eh (1))\n     return;\n \n-  /* Create a binding level for the parm.  */\n+  /* If we are not doing setjmp/longjmp EH, because we are reordered\n+     out of line, we arrange to rethrow in the outer context so as to\n+     skip through the terminate region we are nested in, should we\n+     encounter an exception in the catch handler.  We also need to do\n+     this because we are not physically within the try block, if any,\n+     that contains this catch block.\n+\n+     Matches the end in expand_end_catch_block.  */\n+  expand_eh_region_start ();\n+\n+  /* Create a binding level for the eh_info and the exception object\n+     cleanup.  */\n   pushlevel (0);\n   expand_start_bindings (0);\n \n@@ -543,23 +573,17 @@ expand_start_catch_block (declspecs, declarator)\n \n   if (declspecs)\n     {\n-      tree exp;\n-      rtx call_rtx, return_value_rtx;\n-      tree init_type;\n-\n       decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n \n       if (decl == NULL_TREE)\n-\t{\n-\t  error (\"invalid catch parameter\");\n-\n-\t  /* This is cheap, but we want to maintain the data\n-             structures.  */\n-\n-\t  expand_eh_region_start ();\n+\terror (\"invalid catch parameter\");\n+    }\n \n-\t  return;\n-\t}\n+  if (decl)\n+    {\n+      tree exp;\n+      rtx call_rtx, return_value_rtx;\n+      tree init_type;\n \n       /* Make sure we mark the catch param as used, otherwise we'll get\n \t a warning about an unused ((anonymous)).  */\n@@ -592,37 +616,44 @@ expand_start_catch_block (declspecs, declarator)\n \n       push_eh_cleanup ();\n \n-      init = convert_from_reference (save_expr (make_tree (init_type, call_rtx)));\n+      /* Create a binding level for the parm.  */\n+      pushlevel (0);\n+      expand_start_bindings (0);\n+\n+      init = convert_from_reference (make_tree (init_type, call_rtx));\n+\n+      /* If the constructor for the catch parm exits via an exception, we\n+         must call terminate.  See eh23.C.  */\n+      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n+\t{\n+\t  /* Generate the copy constructor call directly so we can wrap it.\n+\t     See also expand_default_init.  */\n+\t  init = ocp_convert (TREE_TYPE (decl), init,\n+\t\t\t      CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n+\t  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,\n+\t\t\tTerminateFunctionCall);\n+\t}\n \n-      /* Do we need the below two lines? */\n       /* Let `cp_finish_decl' know that this initializer is ok.  */\n       DECL_INITIAL (decl) = init;\n       decl = pushdecl (decl);\n+\n       cp_finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n   else\n     {\n       push_eh_cleanup ();\n \n+      /* Create a binding level for the parm.  */\n+      pushlevel (0);\n+      expand_start_bindings (0);\n+\n       /* Fall into the catch all section.  */\n     }\n \n   init = build_modify_expr (get_eh_caught (), NOP_EXPR, integer_one_node);\n   expand_expr (init, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  /* If we are not doing setjmp/longjmp EH, because we are reordered\n-     out of line, we arrange to rethrow in the outer context so as to\n-     skip through the terminate region we are nested in, should we\n-     encounter an exception in the catch handler.\n-\n-     If we are doing setjmp/longjmp EH, we need to skip through the EH\n-     object cleanup region.  This isn't quite right, as we really need\n-     to clean the object up, but we cannot do that until we track\n-     multiple EH objects.\n-\n-     Matches the end in expand_end_catch_block.  */\n-  expand_eh_region_start ();\n-\n   emit_line_note (input_filename, lineno);\n }\n \n@@ -642,6 +673,17 @@ expand_end_catch_block ()\n   if (! doing_eh (1))\n     return;\n \n+  /* Cleanup the EH parameter.  */\n+  expand_end_bindings (getdecls (), kept_level_p (), 0);\n+  poplevel (kept_level_p (), 1, 0);\n+      \n+  /* Matches push_eh_cleanup.  */\n+  expand_eh_region_end (do_pop_exception (boolean_true_node));\n+\n+  /* Cleanup the EH object.  */\n+  expand_end_bindings (getdecls (), kept_level_p (), 0);\n+  poplevel (kept_level_p (), 1, 0);\n+      \n   t = make_node (RTL_EXPR);\n   TREE_TYPE (t) = void_type_node;\n   RTL_EXPR_RTL (t) = const0_rtx;\n@@ -672,7 +714,7 @@ expand_end_catch_block ()\n   RTL_EXPR_SEQUENCE (t) = get_insns ();\n   end_sequence ();\n \n-  /* Matches the start in expand_start_catch_block.  */\n+  /* For the rethrow region.  */\n   expand_eh_region_end (t);\n \n   /* Fall to outside the try statement when done executing handler and\n@@ -682,10 +724,6 @@ expand_end_catch_block ()\n \n   expand_leftover_cleanups ();\n \n-  /* Cleanup the EH parameter.  */\n-  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-  poplevel (kept_level_p (), 1, 0);\n-      \n   /* label we emit to jump to if this catch block didn't match.  */\n   /* This the closing } in the `if (eq) {' of the documentation.  */\n   emit_label (pop_label_entry (&false_label_stack));"}, {"sha": "2d1ae08124703757a482771064643e3bad199cee", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -118,12 +118,26 @@ __cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n }\n \n /* Compiler hook to pop an exception that has been finalized.  Used by\n-   push_eh_cleanup().  */\n+   push_eh_cleanup().  P is the info for the exception caught by the\n+   current catch block, and HANDLER determines if we've been called from\n+   an exception handler; if so, we avoid destroying the object on rethrow.  */\n \n extern \"C\" void\n-__cp_pop_exception (void)\n+__cp_pop_exception (cp_eh_info *p, bool handler)\n {\n-  cp_eh_info *p = __eh_info;\n+  cp_eh_info **q = &__eh_info;\n+\n+  if (handler && p == *q)\n+    return;\n+\n+  for (; *q; q = &((*q)->next))\n+    if (*q == p)\n+      break;\n+\n+  if (! *q)\n+    terminate ();\n+\n+  *q = p->next;\n \n   if (p->cleanup)\n     /* 3 is a magic value for destructors; see build_delete().  */\n@@ -133,7 +147,6 @@ __cp_pop_exception (void)\n   else\n     delete p->value;\n \n-  __eh_info = p->next;\n   delete p;\n }\n "}, {"sha": "09a3de18c14e4fae4bc984f784c5a5aec4b6d1df", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -1266,7 +1266,17 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n \t     && TREE_CODE (init) == TARGET_EXPR && TREE_TYPE (init) == type))\n \tinit = ocp_convert (type, init, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n-      expand_assignment (exp, init, 0, 0);\n+      if (TREE_CODE (init) == TRY_CATCH_EXPR)\n+\t/* We need to protect the initialization of a catch parm\n+\t   with a call to terminate(), which shows up as a TRY_CATCH_EXPR\n+\t   around the TARGET_EXPR for the copy constructor.  See\n+\t   expand_start_catch_block.  */\n+\tTREE_OPERAND (init, 0) = build (INIT_EXPR, TREE_TYPE (exp), exp,\n+\t\t\t\t\tTREE_OPERAND (init, 0));\n+      else\n+\tinit = build (INIT_EXPR, TREE_TYPE (exp), exp, init);\n+      TREE_SIDE_EFFECTS (init) = 1;\n+      expand_expr_stmt (init);\n       return;\n     }\n "}, {"sha": "9d2589fec6dce7fa4f08974264c32e807162f82d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -78,6 +78,9 @@ real_lvalue_p (ref)\n     case PREDECREMENT_EXPR:\n     case COMPONENT_REF:\n     case SAVE_EXPR:\n+    case UNSAVE_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case WITH_CLEANUP_EXPR:\n       return real_lvalue_p (TREE_OPERAND (ref, 0));\n \n     case STRING_CST:\n@@ -152,6 +155,9 @@ lvalue_p (ref)\n     case IMAGPART_EXPR:\n     case COMPONENT_REF:\n     case SAVE_EXPR:\n+    case UNSAVE_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case WITH_CLEANUP_EXPR:\n       return lvalue_p (TREE_OPERAND (ref, 0));\n \n     case STRING_CST:\n@@ -238,7 +244,7 @@ build_cplus_new (type, init)\n   tree slot;\n   tree rval;\n \n-  if (TREE_CODE (init) == TARGET_EXPR || init == error_mark_node)\n+  if (TREE_CODE (init) != CALL_EXPR && TREE_CODE (init) != NEW_EXPR)\n     return init;\n \n   slot = build (VAR_DECL, type);"}, {"sha": "29adf3b66c916999a6461d727286d7a1ef7807cf", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -1224,6 +1224,7 @@ expand_leftover_cleanups ()\n \t    }\n \t}\n \n+      do_pending_stack_adjust ();\n       free (entry);\n     }\n }"}, {"sha": "97a8d48a07948469354ac527c0903c6b6d9e6fc9", "filename": "gcc/stmt.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c7ae64f2cc5733e40bfb3ca6a58a63ece97691e3", "patch": "@@ -4012,6 +4012,19 @@ expand_decl_cleanup (decl, cleanup)\n   return 1;\n }\n \n+/* Like expand_decl_cleanup, but suppress generating an exception handler\n+   to perform the cleanup.  */\n+\n+int\n+expand_decl_cleanup_no_eh (decl, cleanup)\n+     tree decl, cleanup;\n+{\n+  int save_eh = using_eh_for_cleanups_p;\n+  using_eh_for_cleanups_p = 0;\n+  expand_decl_cleanup (decl, cleanup);\n+  using_eh_for_cleanups_p = save_eh;\n+}\n+\n /* Arrange for the top element of the dynamic cleanup chain to be\n    popped if we exit the current binding contour.  DECL is the\n    associated declaration, if any, otherwise NULL_TREE.  If the"}]}