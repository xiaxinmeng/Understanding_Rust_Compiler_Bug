{"sha": "d8064a5d0ab07d0e39867ee22f8545ec6c4bb904", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwNjRhNWQwYWIwN2QwZTM5ODY3ZWUyMmY4NTQ1ZWM2YzRiYjkwNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-27T20:52:20Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-27T20:52:20Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1101", "tree": {"sha": "338a61fcec20a04ccc68dd565ec42b9a2fca2eaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/338a61fcec20a04ccc68dd565ec42b9a2fca2eaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8064a5d0ab07d0e39867ee22f8545ec6c4bb904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8064a5d0ab07d0e39867ee22f8545ec6c4bb904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8064a5d0ab07d0e39867ee22f8545ec6c4bb904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8064a5d0ab07d0e39867ee22f8545ec6c4bb904/comments", "author": null, "committer": null, "parents": [{"sha": "55b2f10fbe1dff88a3d8c39ead368e1f06c8aaba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55b2f10fbe1dff88a3d8c39ead368e1f06c8aaba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55b2f10fbe1dff88a3d8c39ead368e1f06c8aaba"}], "stats": {"total": 5, "additions": 5, "deletions": 0}, "files": [{"sha": "9d0962e6bccd8107285a81df610c3b2ffd65075f", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8064a5d0ab07d0e39867ee22f8545ec6c4bb904/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8064a5d0ab07d0e39867ee22f8545ec6c4bb904/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=d8064a5d0ab07d0e39867ee22f8545ec6c4bb904", "patch": "@@ -2262,6 +2262,11 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   if (rem_flag && GET_CODE (op1) == MEM && MEM_VOLATILE_P (op1))\n     op1 = force_reg (compute_mode, op1);\n \n+  /* If we are computing the remainder, op0 will be needed later to calculate\n+     X - Y * (X / Y), therefore cannot be clobbered. */\n+  if (rem_flag)\n+    can_clobber_op0 = 0;\n+\n   if (target == 0 || GET_MODE (target) != compute_mode)\n     target = gen_reg_rtx (compute_mode);\n "}]}