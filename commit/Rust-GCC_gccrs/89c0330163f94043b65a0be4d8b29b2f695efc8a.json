{"sha": "89c0330163f94043b65a0be4d8b29b2f695efc8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODljMDMzMDE2M2Y5NDA0M2I2NWEwYmU0ZDhiMjliMmY2OTVlZmM4YQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T12:57:06Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-21T17:50:15Z"}, "message": "rs6000: Write output to the builtins header file\n\n2021-07-21  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c\n\t(write_autogenerated_header): New function.\n\t(write_decls): Likewise.\n\t(write_extern_fntype): New callback function.\n\t(write_header_file): Implement.", "tree": {"sha": "dd4f33a292e9d8075a33ca9d262e1405681129d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd4f33a292e9d8075a33ca9d262e1405681129d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89c0330163f94043b65a0be4d8b29b2f695efc8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c0330163f94043b65a0be4d8b29b2f695efc8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c0330163f94043b65a0be4d8b29b2f695efc8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c0330163f94043b65a0be4d8b29b2f695efc8a/comments", "author": null, "committer": null, "parents": [{"sha": "86e5e4c93716b84a49a2aba2b52649b366a77b95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86e5e4c93716b84a49a2aba2b52649b366a77b95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86e5e4c93716b84a49a2aba2b52649b366a77b95"}], "stats": {"total": 228, "additions": 228, "deletions": 0}, "files": [{"sha": "1b3a11455a24c371500f0388856e266f9df586ac", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c0330163f94043b65a0be4d8b29b2f695efc8a/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c0330163f94043b65a0be4d8b29b2f695efc8a/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=89c0330163f94043b65a0be4d8b29b2f695efc8a", "patch": "@@ -1998,11 +1998,239 @@ parse_ovld (void)\n   return result;\n }\n \n+/* Write a comment at the top of FILE about how the code was generated.  */\n+static void\n+write_autogenerated_header (FILE *file)\n+{\n+  fprintf (file, \"/* Automatically generated by the program '%s'\\n\",\n+\t   pgm_path);\n+  fprintf (file, \"   from the files '%s' and '%s'.  */\\n\\n\",\n+\t   bif_path, ovld_path);\n+}\n+\n+/* Write declarations into the header file.  */\n+static void\n+write_decls (void)\n+{\n+  fprintf (header_file, \"enum rs6000_gen_builtins\\n{\\n  RS6000_BIF_NONE,\\n\");\n+  for (int i = 0; i <= curr_bif; i++)\n+    fprintf (header_file, \"  RS6000_BIF_%s,\\n\", bifs[bif_order[i]].idname);\n+  fprintf (header_file, \"  RS6000_BIF_MAX,\\n\");\n+  fprintf (header_file, \"  RS6000_OVLD_NONE,\\n\");\n+  for (int i = 0; i < num_ovld_stanzas; i++)\n+    fprintf (header_file, \"  RS6000_OVLD_%s,\\n\", ovld_stanzas[i].stanza_id);\n+  fprintf (header_file, \"  RS6000_OVLD_MAX\\n};\\n\\n\");\n+\n+  fprintf (header_file,\n+\t   \"extern GTY(()) tree rs6000_builtin_decls_x[RS6000_OVLD_MAX];\\n\\n\");\n+\n+  fprintf (header_file,\n+\t   \"enum rs6000_ovld_instances\\n{\\n  RS6000_INST_NONE,\\n\");\n+  for (int i = 0; i <= curr_ovld; i++)\n+    fprintf (header_file, \"  RS6000_INST_%s,\\n\", ovlds[i].ovld_id_name);\n+  fprintf (header_file, \"  RS6000_INST_MAX\\n};\\n\\n\");\n+\n+  fprintf (header_file, \"#define MAX_OVLD_ARGS %d\\n\", max_ovld_args);\n+\n+  fprintf (header_file, \"enum restriction {\\n\");\n+  fprintf (header_file, \"  RES_NONE,\\n\");\n+  fprintf (header_file, \"  RES_BITS,\\n\");\n+  fprintf (header_file, \"  RES_RANGE,\\n\");\n+  fprintf (header_file, \"  RES_VAR_RANGE,\\n\");\n+  fprintf (header_file, \"  RES_VALUES\\n\");\n+  fprintf (header_file, \"};\\n\\n\");\n+\n+  fprintf (header_file, \"enum bif_enable {\\n\");\n+  fprintf (header_file, \"  ENB_ALWAYS,\\n\");\n+  fprintf (header_file, \"  ENB_P5,\\n\");\n+  fprintf (header_file, \"  ENB_P6,\\n\");\n+  fprintf (header_file, \"  ENB_ALTIVEC,\\n\");\n+  fprintf (header_file, \"  ENB_CELL,\\n\");\n+  fprintf (header_file, \"  ENB_VSX,\\n\");\n+  fprintf (header_file, \"  ENB_P7,\\n\");\n+  fprintf (header_file, \"  ENB_P7_64,\\n\");\n+  fprintf (header_file, \"  ENB_P8,\\n\");\n+  fprintf (header_file, \"  ENB_P8V,\\n\");\n+  fprintf (header_file, \"  ENB_P9,\\n\");\n+  fprintf (header_file, \"  ENB_P9_64,\\n\");\n+  fprintf (header_file, \"  ENB_P9V,\\n\");\n+  fprintf (header_file, \"  ENB_IEEE128_HW,\\n\");\n+  fprintf (header_file, \"  ENB_DFP,\\n\");\n+  fprintf (header_file, \"  ENB_CRYPTO,\\n\");\n+  fprintf (header_file, \"  ENB_HTM,\\n\");\n+  fprintf (header_file, \"  ENB_P10,\\n\");\n+  fprintf (header_file, \"  ENB_P10_64,\\n\");\n+  fprintf (header_file, \"  ENB_MMA\\n\");\n+  fprintf (header_file, \"};\\n\\n\");\n+\n+  fprintf (header_file, \"#define PPC_MAXRESTROPNDS 3\\n\");\n+  fprintf (header_file, \"struct GTY((user)) bifdata\\n\");\n+  fprintf (header_file, \"{\\n\");\n+  fprintf (header_file, \"  const char *bifname;\\n\");\n+  fprintf (header_file, \"  bif_enable enable;\\n\");\n+  fprintf (header_file, \"  tree fntype;\\n\");\n+  fprintf (header_file, \"  insn_code icode;\\n\");\n+  fprintf (header_file, \"  int  nargs;\\n\");\n+  fprintf (header_file, \"  int  bifattrs;\\n\");\n+  fprintf (header_file, \"  int  restr_opnd[PPC_MAXRESTROPNDS];\\n\");\n+  fprintf (header_file, \"  restriction restr[PPC_MAXRESTROPNDS];\\n\");\n+  fprintf (header_file, \"  int  restr_val1[PPC_MAXRESTROPNDS];\\n\");\n+  fprintf (header_file, \"  int  restr_val2[PPC_MAXRESTROPNDS];\\n\");\n+  fprintf (header_file, \"  const char *attr_string;\\n\");\n+  fprintf (header_file, \"  rs6000_gen_builtins assoc_bif;\\n\");\n+  fprintf (header_file, \"};\\n\\n\");\n+\n+  fprintf (header_file, \"#define bif_init_bit\\t\\t(0x00000001)\\n\");\n+  fprintf (header_file, \"#define bif_set_bit\\t\\t(0x00000002)\\n\");\n+  fprintf (header_file, \"#define bif_extract_bit\\t\\t(0x00000004)\\n\");\n+  fprintf (header_file, \"#define bif_nosoft_bit\\t\\t(0x00000008)\\n\");\n+  fprintf (header_file, \"#define bif_ldvec_bit\\t\\t(0x00000010)\\n\");\n+  fprintf (header_file, \"#define bif_stvec_bit\\t\\t(0x00000020)\\n\");\n+  fprintf (header_file, \"#define bif_reve_bit\\t\\t(0x00000040)\\n\");\n+  fprintf (header_file, \"#define bif_pred_bit\\t\\t(0x00000080)\\n\");\n+  fprintf (header_file, \"#define bif_htm_bit\\t\\t(0x00000100)\\n\");\n+  fprintf (header_file, \"#define bif_htmspr_bit\\t\\t(0x00000200)\\n\");\n+  fprintf (header_file, \"#define bif_htmcr_bit\\t\\t(0x00000400)\\n\");\n+  fprintf (header_file, \"#define bif_mma_bit\\t\\t(0x00000800)\\n\");\n+  fprintf (header_file, \"#define bif_quad_bit\\t\\t(0x00001000)\\n\");\n+  fprintf (header_file, \"#define bif_pair_bit\\t\\t(0x00002000)\\n\");\n+  fprintf (header_file, \"#define bif_no32bit_bit\\t\\t(0x00004000)\\n\");\n+  fprintf (header_file, \"#define bif_32bit_bit\\t\\t(0x00008000)\\n\");\n+  fprintf (header_file, \"#define bif_cpu_bit\\t\\t(0x00010000)\\n\");\n+  fprintf (header_file, \"#define bif_ldstmask_bit\\t(0x00020000)\\n\");\n+  fprintf (header_file, \"#define bif_lxvrse_bit\\t\\t(0x00040000)\\n\");\n+  fprintf (header_file, \"#define bif_lxvrze_bit\\t\\t(0x00080000)\\n\");\n+  fprintf (header_file, \"#define bif_endian_bit\\t\\t(0x00100000)\\n\");\n+  fprintf (header_file, \"\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_init(x)\\t\\t((x).bifattrs & bif_init_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_set(x)\\t\\t((x).bifattrs & bif_set_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_extract(x)\\t((x).bifattrs & bif_extract_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_nosoft(x)\\t((x).bifattrs & bif_nosoft_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_ldvec(x)\\t\\t((x).bifattrs & bif_ldvec_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_stvec(x)\\t\\t((x).bifattrs & bif_stvec_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_reve(x)\\t\\t((x).bifattrs & bif_reve_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_predicate(x)\\t((x).bifattrs & bif_pred_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_htm(x)\\t\\t((x).bifattrs & bif_htm_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_htmspr(x)\\t((x).bifattrs & bif_htmspr_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_htmcr(x)\\t\\t((x).bifattrs & bif_htmcr_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_mma(x)\\t\\t((x).bifattrs & bif_mma_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_quad(x)\\t\\t((x).bifattrs & bif_quad_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_pair(x)\\t\\t((x).bifattrs & bif_pair_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_no32bit(x)\\t((x).bifattrs & bif_no32bit_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_32bit(x)\\t((x).bifattrs & bif_32bit_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_cpu(x)\\t\\t((x).bifattrs & bif_cpu_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_ldstmask(x)\\t((x).bifattrs & bif_ldstmask_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_lxvrse(x)\\t((x).bifattrs & bif_lxvrse_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_lxvrze(x)\\t((x).bifattrs & bif_lxvrze_bit)\\n\");\n+  fprintf (header_file,\n+\t   \"#define bif_is_endian(x)\\t((x).bifattrs & bif_endian_bit)\\n\");\n+  fprintf (header_file, \"\\n\");\n+\n+  /* #### Note that the _x is added for now to avoid conflict with\n+     the existing rs6000_builtin_info[] file while testing.  It will\n+     be removed as we progress.  */\n+  /* #### Cannot mark this as a GC root because only pointer types can\n+     be marked as GTY((user)) and be GC roots.  All trees in here are\n+     kept alive by other globals, so not a big deal.  Alternatively,\n+     we could change the enum fields to ints and cast them in and out\n+     to avoid requiring a GTY((user)) designation, but that seems\n+     unnecessarily gross.  */\n+  fprintf (header_file,\n+\t   \"extern bifdata rs6000_builtin_info_x[RS6000_BIF_MAX];\\n\\n\");\n+\n+  fprintf (header_file, \"struct GTY((user)) ovlddata\\n\");\n+  fprintf (header_file, \"{\\n\");\n+  fprintf (header_file, \"  const char *bifname;\\n\");\n+  fprintf (header_file, \"  rs6000_gen_builtins bifid;\\n\");\n+  fprintf (header_file, \"  tree fntype;\\n\");\n+  fprintf (header_file, \"  ovlddata *next;\\n\");\n+  fprintf (header_file, \"};\\n\\n\");\n+\n+  fprintf (header_file, \"struct ovldrecord\\n\");\n+  fprintf (header_file, \"{\\n\");\n+  fprintf (header_file, \"  const char *ovld_name;\\n\");\n+  fprintf (header_file, \"  ovlddata *first_instance;\\n\");\n+  fprintf (header_file, \"};\\n\\n\");\n+\n+  fprintf (header_file,\n+\t   \"/* #### Cannot mark this as a GC root because only pointer\\n\"\n+\t   \"   types can be marked as GTY((user)) and be GC roots.  All\\n\"\n+\t   \"   trees in here are kept alive by other globals, so not a big\\n\"\n+\t   \"   deal.  Alternatively, we could change the enum fields to ints\\n\"\n+\t   \"   and cast them in and out to avoid requiring a GTY((user))\\n\"\n+\t   \"   designation, but that seems unnecessarily gross.  */\\n\");\n+  fprintf (header_file,\n+\t   \"extern ovlddata rs6000_instance_info[RS6000_INST_MAX];\\n\");\n+  fprintf (header_file, \"extern ovldrecord rs6000_overload_info[];\\n\\n\");\n+\n+  fprintf (header_file, \"extern void rs6000_autoinit_builtins ();\\n\\n\");\n+  fprintf (header_file,\n+\t   \"extern bool rs6000_new_builtin_is_supported_p \"\n+\t   \"(rs6000_gen_builtins);\\n\");\n+  fprintf (header_file,\n+\t   \"extern tree rs6000_builtin_decl (unsigned, \"\n+\t   \"bool ATTRIBUTE_UNUSED);\\n\\n\");\n+  fprintf (header_file,\n+\t   \"extern void gt_ggc_mx (bifdata *bd);\\n\");\n+  fprintf (header_file,\n+\t   \"extern void gt_pch_nx (bifdata *bd);\\n\");\n+  fprintf (header_file,\n+\t   \"extern void gt_pch_nx (bifdata *bd, gt_pointer_operator op, \"\n+\t   \"void *cookie);\\n\");\n+  fprintf (header_file,\n+\t   \"extern void gt_ggc_mx (ovlddata *od);\\n\");\n+  fprintf (header_file,\n+\t   \"extern void gt_pch_nx (ovlddata *od);\\n\");\n+  fprintf (header_file,\n+\t   \"extern void gt_pch_nx (ovlddata *od, gt_pointer_operator op, \"\n+\t   \"void *cookie);\\n\");\n+}\n+\n+/* Callback functions used for generating trees for function types.  */\n+void\n+write_extern_fntype (char *str)\n+{\n+  fprintf (header_file, \"extern GTY(()) tree %s;\\n\", str);\n+}\n+\n /* Write everything to the header file (rs6000-builtins.h).  Return\n    1 if successful, 0 otherwise.  */\n static int\n write_header_file (void)\n {\n+  write_autogenerated_header (header_file);\n+\n+  fprintf (header_file, \"#ifndef _RS6000_BUILTINS_H\\n\");\n+  fprintf (header_file, \"#define _RS6000_BUILTINS_H 1\\n\\n\");\n+  fprintf (header_file, \"extern int new_builtins_are_live;\\n\\n\");\n+\n+  write_decls ();\n+\n+  /* Write function type list declarators to the header file.  */\n+  rbt_inorder_callback (&fntype_rbt, fntype_rbt.rbt_root, write_extern_fntype);\n+  fprintf (header_file, \"\\n\");\n+  fprintf (header_file, \"\\n#endif\\n\");\n+\n   return 1;\n }\n "}]}