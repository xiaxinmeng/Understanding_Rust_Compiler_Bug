{"sha": "089d6ea74bea18d183968d655d7dd2c4e336ab03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg5ZDZlYTc0YmVhMThkMTgzOTY4ZDY1NWQ3ZGQyYzRlMzM2YWIwMw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-03-08T09:12:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-03-08T09:12:54Z"}, "message": "re PR c++/9809 (when are builtins brought into view)\n\n\tPR c++/9809\n\t* g++.dg/parse/builtin1.C: New test.\n\n\tPR c++/9982\n\t* g++.dg/abi/cookie1.C: New test.\n\t* g++.dg/abi/cookie2.C: Likewise.\n\n\tPR c++/9524\n\t* g++.dg/parse/field1.C: New test.\n\n\tPR c++/9912\n\t* g++.dg/parse/class1.C: New test.\n\t* g++.dg/parse/namespace7.C: Likewise.\n\t* g++.old-deja/g++.other/decl5.C: Remove XFAILs.\n\nFrom-SVN: r63977", "tree": {"sha": "6b4defb4aeefb856b583b42ac040705d6ebed502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b4defb4aeefb856b583b42ac040705d6ebed502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/089d6ea74bea18d183968d655d7dd2c4e336ab03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089d6ea74bea18d183968d655d7dd2c4e336ab03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/089d6ea74bea18d183968d655d7dd2c4e336ab03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089d6ea74bea18d183968d655d7dd2c4e336ab03/comments", "author": null, "committer": null, "parents": [{"sha": "6fef42173faf90a30b4fa0c565754173a74236b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fef42173faf90a30b4fa0c565754173a74236b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fef42173faf90a30b4fa0c565754173a74236b7"}], "stats": {"total": 395, "additions": 289, "deletions": 106}, "files": [{"sha": "4acff2124da6954c13095358006384eb43a84e12", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -1,3 +1,27 @@\n+2003-03-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9809\n+\t* call.c (add_function_candidate): Skip builtin fuctions that have\n+\tnot yet been declared.\n+\n+\tPR c++/9982\n+\t* init.c (build_new_1): Correct logic for determining whether or\n+\tnot to use an array cookie.\n+\n+\tPR c++/9524\n+\t* parser.c (cp_parser_postfix_expression): Call\n+\tfinish_non_static_data_member, even when processing_template_decl.\n+\n+\tPR c++/9912\n+\t* cp-tree.h (is_ancestor): New function.\n+\t(handle_class_head): Change prototype.\n+\t* decl2.c (is_namespace_ancestor): Rename to ...\n+\t(namespace_anecestor): ... this.\n+\t(set_decl_namespace): Adjust accordingly.\n+\t(handle_class_head): Remove unncessary parameters.\n+\t* parser.c (cp_parser_class_head): Check that\n+\tnested-name-specifiers are used appropriately.\n+\t\n 2003-03-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* call.c (reference_binding): Remove REF_IS_VAR parameter."}, {"sha": "64da5a43b993f0790795197532c48ce584b3d4fd", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -1382,6 +1382,11 @@ add_function_candidate (struct z_candidate **candidates,\n   tree orig_arglist;\n   int viable = 1;\n \n+  /* Built-in functions that haven't been declared don't really\n+     exist.  */\n+  if (DECL_ANTICIPATED (fn))\n+    return NULL;\n+\n   /* The `this', `in_chrg' and VTT arguments to constructors are not\n      considered in overload resolution.  */\n   if (DECL_CONSTRUCTOR_P (fn))"}, {"sha": "3ab95cc48156463ebfd56bb820b3694b163b7904", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -3724,6 +3724,7 @@ extern tree lookup_name_current_level\t\t(tree);\n extern tree lookup_type_current_level\t\t(tree);\n extern tree lookup_name_real                    (tree, int, int, int, int);\n extern tree namespace_ancestor\t\t\t(tree, tree);\n+extern bool is_ancestor                         (tree, tree);\n extern tree unqualified_namespace_lookup\t(tree, int, tree *);\n extern tree check_for_out_of_scope_variable     (tree);\n extern bool lookup_using_namespace (tree, tree, tree, tree, int, tree *);\n@@ -3850,7 +3851,7 @@ extern tree do_class_using_decl (tree);\n extern void do_using_directive (tree);\n extern void check_default_args (tree);\n extern void mark_used (tree);\n-extern tree handle_class_head (enum tag_types, tree, tree, tree, bool, bool *);\n+extern tree handle_class_head (enum tag_types, tree, tree, tree);\n extern tree lookup_arg_dependent (tree, tree, tree);\n extern void finish_static_data_member_decl (tree, tree, tree, int);\n extern tree cp_build_parm_decl (tree, tree);"}, {"sha": "f85fef2fa4e0ca49cfadd286620181ffcd6e6de0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -62,7 +62,6 @@ typedef struct priority_info_s {\n static void mark_vtable_entries (tree);\n static void grok_function_init (tree, tree);\n static bool maybe_emit_vtables (tree);\n-static bool is_namespace_ancestor (tree, tree);\n static void add_using_namespace (tree, tree, bool);\n static tree ambiguous_decl (tree, tree, tree,int);\n static tree build_anon_union_vars (tree);\n@@ -3352,18 +3351,36 @@ build_call_from_tree (tree fn, tree args, bool disallow_virtual)\n   return finish_call_expr (fn, args, disallow_virtual);\n }\n \n-/* Return 1 if root encloses child.  */\n+/* Returns true if ROOT (a namespace, class, or function) encloses\n+   CHILD.  CHILD may be either a class type or a namespace.  */\n \n-static bool\n-is_namespace_ancestor (tree root, tree child)\n+bool\n+is_ancestor (tree root, tree child)\n {\n-  if (root == child)\n-    return true;\n+  my_friendly_assert ((TREE_CODE (root) == NAMESPACE_DECL\n+\t\t       || TREE_CODE (root) == FUNCTION_DECL\n+\t\t       || CLASS_TYPE_P (root)), 20030307);\n+  my_friendly_assert ((TREE_CODE (child) == NAMESPACE_DECL\n+\t\t       || CLASS_TYPE_P (child)),\n+\t\t      20030307);\n+  \n+  /* The global namespace encloses everything.  */\n   if (root == global_namespace)\n     return true;\n-  if (child == global_namespace)\n-    return false;\n-  return is_namespace_ancestor (root, CP_DECL_CONTEXT (child));\n+\n+  while (true)\n+    {\n+      /* If we've run out of scopes, stop.  */\n+      if (!child)\n+\treturn false;\n+      /* If we've reached the ROOT, it encloses CHILD.  */\n+      if (root == child)\n+\treturn true;\n+      /* Go out one level.  */\n+      if (TYPE_P (child))\n+\tchild = TYPE_NAME (child);\n+      child = DECL_CONTEXT (child);\n+    }\n }\n   \n \n@@ -3374,7 +3391,7 @@ tree\n namespace_ancestor (tree ns1, tree ns2)\n {\n   timevar_push (TV_NAME_LOOKUP);\n-  if (is_namespace_ancestor (ns1, ns2))\n+  if (is_ancestor (ns1, ns2))\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ns1);\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n                           namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2));\n@@ -3636,7 +3653,7 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n   scope = ORIGINAL_NAMESPACE (scope);\n   \n   /* It is ok for friends to be qualified in parallel space.  */\n-  if (!friendp && !is_namespace_ancestor (current_namespace, scope))\n+  if (!friendp && !is_ancestor (current_namespace, scope))\n     error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n \t      decl, scope);\n   DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n@@ -4494,28 +4511,28 @@ mark_used (tree decl)\n     instantiate_decl (decl, /*defer_ok=*/1);\n }\n \n-/* Helper function for class_head_decl and class_head_defn\n-   nonterminals. AGGR is the class, union or struct tag. SCOPE is the\n-   explicit scope used (NULL for no scope resolution). ID is the\n-   name. DEFN_P is true, if this is a definition of the class and\n-   NEW_TYPE_P is set to nonzero, if we push into the scope containing\n-   the to be defined aggregate.\n-   \n-   Return a TYPE_DECL for the type declared by ID in SCOPE.  */\n+/* Called when a class-head is encountered.  TAG_KIND is the class-key\n+   for the class.  SCOPE, if non-NULL, is the type or namespace\n+   indicated in the nested-name-specifier for the declaration of the\n+   class.  ID is the name of the class, if any; it may be a TYPE_DECL,\n+   or an IDENTIFIER_NODE.  ATTRIBUTES are attributes that apply to the\n+   class.\n+\n+   Return a TYPE_DECL for the class being defined.  */\n \n tree\n handle_class_head (enum tag_types tag_kind, tree scope, tree id,\n-                   tree attributes, bool defn_p, bool *new_type_p)\n+                   tree attributes)\n {\n   tree decl = NULL_TREE;\n   tree current = current_scope ();\n   bool xrefd_p = false;\n-  \n+  bool new_type_p;\n+  tree context;\n+\n   if (current == NULL_TREE)\n     current = current_namespace;\n \n-  *new_type_p = false;\n-  \n   if (scope)\n     {\n       if (TREE_CODE (id) == TYPE_DECL)\n@@ -4552,7 +4569,7 @@ handle_class_head (enum tag_types tag_kind, tree scope, tree id,\n   \n   if (!decl)\n     {\n-      decl = TYPE_MAIN_DECL (xref_tag (tag_kind, id, attributes, !defn_p));\n+      decl = TYPE_MAIN_DECL (xref_tag (tag_kind, id, attributes, false));\n       xrefd_p = true;\n     }\n \n@@ -4562,24 +4579,21 @@ handle_class_head (enum tag_types tag_kind, tree scope, tree id,\n       return error_mark_node;\n     }\n   \n-  if (defn_p)\n-    {\n-      /* For a definition, we want to enter the containing scope\n-\t before looking up any base classes etc. Only do so, if this\n-\t is different to the current scope.  */\n-      tree context = CP_DECL_CONTEXT (decl);\n-\n-      *new_type_p = (current != context\n-\t\t     && TREE_CODE (context) != TEMPLATE_TYPE_PARM\n-\t\t     && TREE_CODE (context) != BOUND_TEMPLATE_TEMPLATE_PARM);\n-      if (*new_type_p)\n-\tpush_scope (context);\n-\n-      if (!xrefd_p \n-\t  && PROCESSING_REAL_TEMPLATE_DECL_P ()\n-\t  && !CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n-\tdecl = push_template_decl (decl);\n-    }\n+  /* For a definition, we want to enter the containing scope before\n+     looking up any base classes etc. Only do so, if this is different\n+     to the current scope.  */\n+  context = CP_DECL_CONTEXT (decl);\n+  \n+  new_type_p = (current != context\n+\t\t&& TREE_CODE (context) != TEMPLATE_TYPE_PARM\n+\t\t&& TREE_CODE (context) != BOUND_TEMPLATE_TEMPLATE_PARM);\n+  if (new_type_p)\n+    push_scope (context);\n+  \n+  if (!xrefd_p \n+      && PROCESSING_REAL_TEMPLATE_DECL_P ()\n+      && !CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n+    decl = push_template_decl (decl);\n \n   return decl;\n }"}, {"sha": "2e4ecc228cc5e2faeb90f56b8bcf4e940234e9b0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 88, "deletions": 55, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -2163,20 +2163,19 @@ build_new_1 (exp)\n   tree cookie_expr, init_expr;\n   int has_array = 0;\n   enum tree_code code;\n-  int use_cookie, nothrow, check_new;\n+  int nothrow, check_new;\n   /* Nonzero if the user wrote `::new' rather than just `new'.  */\n   int globally_qualified_p;\n-  /* Nonzero if we're going to call a global operator new, rather than\n-     a class-specific version.  */\n-  int use_global_new;\n   int use_java_new = 0;\n+  bool check_cookie = false;\n   /* If non-NULL, the number of extra bytes to allocate at the\n      beginning of the storage allocated for an array-new expression in\n      order to store the number of elements.  */\n   tree cookie_size = NULL_TREE;\n   /* True if the function we are calling is a placement allocation\n      function.  */\n   bool placement_allocation_fn_p;\n+  tree args;\n \n   placement = TREE_OPERAND (exp, 0);\n   type = TREE_OPERAND (exp, 1);\n@@ -2211,10 +2210,6 @@ build_new_1 (exp)\n   if (!complete_type_or_else (true_type, exp))\n     return error_mark_node;\n \n-  size = size_in_bytes (true_type);\n-  if (has_array)\n-    size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n-\n   if (TREE_CODE (true_type) == VOID_TYPE)\n     {\n       error (\"invalid type `void' for new\");\n@@ -2224,42 +2219,11 @@ build_new_1 (exp)\n   if (abstract_virtuals_error (NULL_TREE, true_type))\n     return error_mark_node;\n \n-  /* Figure out whether or not we're going to use the global operator\n-     new.  */\n-  if (!globally_qualified_p\n-      && IS_AGGR_TYPE (true_type)\n-      && (has_array\n-\t  ? TYPE_HAS_ARRAY_NEW_OPERATOR (true_type)\n-\t  : TYPE_HAS_NEW_OPERATOR (true_type)))\n-    use_global_new = 0;\n-  else\n-    use_global_new = 1;\n-\n-  /* We only need cookies for arrays containing types for which we\n-     need cookies.  */\n-  if (!has_array || !TYPE_VEC_NEW_USES_COOKIE (true_type))\n-    use_cookie = 0;\n-  /* When using placement new, users may not realize that they need\n-     the extra storage.  We require that the operator called be\n-     the global placement operator new[].  */\n-  else if (placement && !TREE_CHAIN (placement) \n-\t   && same_type_p (TREE_TYPE (TREE_VALUE (placement)),\n-\t\t\t   ptr_type_node))\n-    use_cookie = !use_global_new;\n-  /* Otherwise, we need the cookie.  */\n-  else\n-    use_cookie = 1;\n-\n-  /* Compute the number of extra bytes to allocate, now that we know\n-     whether or not we need the cookie.  */\n-  if (use_cookie)\n-    {\n-      cookie_size = get_cookie_size (true_type);\n-      size = size_binop (PLUS_EXPR, size, cookie_size);\n-    }\n+  size = size_in_bytes (true_type);\n+  if (has_array)\n+    size = size_binop (MULT_EXPR, size, convert (sizetype, nelts));\n \n   /* Allocate the object.  */\n-  \n   if (! placement && TYPE_FOR_JAVA (true_type))\n     {\n       tree class_addr, alloc_decl;\n@@ -2281,20 +2245,42 @@ build_new_1 (exp)\n   else\n     {\n       tree fnname;\n-      tree args;\n \n-      args = tree_cons (NULL_TREE, size, placement);\n       fnname = ansi_opname (code);\n \n-      if (use_global_new)\n-\talloc_call = (build_new_function_call \n-\t\t      (lookup_function_nonclass (fnname, args),\n-\t\t       args));\n+      if (!globally_qualified_p \n+\t  && CLASS_TYPE_P (true_type)\n+\t  && (has_array\n+\t      ? TYPE_HAS_ARRAY_NEW_OPERATOR (true_type)\n+\t      : TYPE_HAS_NEW_OPERATOR (true_type)))\n+\t{\n+\t  /* Use a class-specific operator new.  */\n+\t  /* If a cookie is required, add some extra space.  */\n+\t  if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n+\t    {\n+\t      cookie_size = get_cookie_size (true_type);\n+\t      size = size_binop (PLUS_EXPR, size, cookie_size);\n+\t    }\n+\t  /* Create the argument list.  */\n+\t  args = tree_cons (NULL_TREE, size, placement);\n+\t  /* Call the function.  */\n+\t  alloc_call = build_method_call (build_dummy_object (true_type),\n+\t\t\t\t\t  fnname, args, \n+\t\t\t\t\t  TYPE_BINFO (true_type),\n+\t\t\t\t\t  LOOKUP_NORMAL);\n+\t}\n       else\n-\talloc_call = build_method_call (build_dummy_object (true_type),\n-\t\t\t\t\tfnname, args, \n-\t\t\t\t\tTYPE_BINFO (true_type),\n-\t\t\t\t\tLOOKUP_NORMAL);\n+\t{\n+\t  /* Use a global operator new.  */\n+\t  /* Create the argument list.  */\n+\t  args = tree_cons (NULL_TREE, size, placement);\n+\t  /* Call the function.  */\n+\t  alloc_call \n+\t    = build_new_function_call (lookup_function_nonclass (fnname, args),\n+\t\t\t\t       args);\n+\t  /* We may need to add a cookie.  */\n+\t  check_cookie = true;\n+\t}\n     }\n \n   if (alloc_call == error_mark_node)\n@@ -2308,6 +2294,53 @@ build_new_1 (exp)\n     t = TREE_OPERAND (t, 1);\n   alloc_fn = get_callee_fndecl (t);\n   my_friendly_assert (alloc_fn != NULL_TREE, 20020325);\n+\n+  /* If we postponed deciding whether or not to use a cookie until\n+     after we knew what function was being called, that time is\n+     now.  */\n+  if (check_cookie)\n+    {\n+      /* If a cookie is required, add some extra space.  Whether\n+\t or not a cookie is required cannot be determined until\n+\t after we know which function was called.  */\n+      if (has_array && TYPE_VEC_NEW_USES_COOKIE (true_type))\n+\t{\n+\t  bool use_cookie = true;\n+\t  if (!abi_version_at_least (2))\n+\t    {\n+\t      /* In G++ 3.2, the check was implemented incorrectly; it\n+\t\t looked at the placement expression, rather than the\n+\t\t type of the function.  */\n+\t      if (placement && !TREE_CHAIN (placement)\n+\t\t  && same_type_p (TREE_TYPE (TREE_VALUE (placement)),\n+\t\t\t\t  ptr_type_node))\n+\t\tuse_cookie = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree arg_types;\n+\n+\t      arg_types = TYPE_ARG_TYPES (TREE_TYPE (alloc_fn));\n+\t      /* Skip the size_t parameter.  */\n+\t      arg_types = TREE_CHAIN (arg_types);\n+\t      /* Check the remaining parameters (if any).  */\n+\t      if (arg_types \n+\t\t  && !TREE_CHAIN (arg_types)\n+\t\t  && same_type_p (TREE_TYPE (TREE_VALUE (arg_types)),\n+\t\t\t\t  ptr_type_node))\n+\t\tuse_cookie = false;\n+\t    }\n+\t  /* If we need a cookie, adjust the number of bytes allocated.  */\n+\t  if (use_cookie)\n+\t    {\n+\t      cookie_size = get_cookie_size (true_type);\n+\t      size = size_binop (PLUS_EXPR, size, cookie_size);\n+\t      /* Update the argument list to reflect the adjusted size.  */\n+\t      TREE_VALUE (args) = cookie_size;\n+\t    }\n+\t}\n+    }\n+\n   /* Now, check to see if this function is actually a placement\n      allocation function.  This can happen even when PLACEMENT is NULL\n      because we might have something like:\n@@ -2337,7 +2370,7 @@ build_new_1 (exp)\n \n   alloc_expr = alloc_call;\n \n-  if (use_cookie)\n+  if (cookie_size)\n     /* Adjust so we're pointing to the start of the object.  */\n     alloc_expr = build (PLUS_EXPR, TREE_TYPE (alloc_expr),\n \t\t\talloc_expr, cookie_size);\n@@ -2351,7 +2384,7 @@ build_new_1 (exp)\n   alloc_node = TREE_OPERAND (alloc_expr, 0);\n \n   /* Now initialize the cookie.  */\n-  if (use_cookie)\n+  if (cookie_size)\n     {\n       tree cookie;\n \n@@ -2431,7 +2464,7 @@ build_new_1 (exp)\n \t\t       | (globally_qualified_p * LOOKUP_GLOBAL));\n \t  tree delete_node;\n \n-\t  if (use_cookie)\n+\t  if (cookie_size)\n \t    /* Subtract the padding back out to get to the pointer returned\n \t       from operator new.  */\n \t    delete_node = fold (build (MINUS_EXPR, TREE_TYPE (alloc_node),"}, {"sha": "468ba03b3dcf41185b2183f16bd1cd216293518a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -3809,13 +3809,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n   /* Otherwise, if we were avoiding committing until we knew\n      whether or not we had a pointer-to-member, we now know that\n      the expression is an ordinary reference to a qualified name.  */\n-  if (qualifying_class && !processing_template_decl)\n+  if (qualifying_class)\n     {\n       if (TREE_CODE (postfix_expression) == FIELD_DECL)\n \tpostfix_expression \n \t  = finish_non_static_data_member (postfix_expression,\n \t\t\t\t\t   qualifying_class);\n-      else if (BASELINK_P (postfix_expression))\n+      else if (BASELINK_P (postfix_expression) \n+\t       && !processing_template_decl)\n \t{\n \t  tree fn;\n \t  tree fns;\n@@ -11756,8 +11757,8 @@ cp_parser_class_head (cp_parser* parser,\n     }\n   else\n     {\n-      bool new_type_p;\n       tree class_type;\n+      tree scope;\n \n       /* Given:\n \n@@ -11780,14 +11781,25 @@ cp_parser_class_head (cp_parser* parser,\n \t    }\n \t}\n \n+      /* Figure out in what scope the declaration is being placed.  */\n+      scope = current_scope ();\n+      if (!scope)\n+\tscope = current_namespace;\n+      /* If that scope does not contain the scope in which the\n+\t class was originally declared, the program is invalid.  */\n+      if (scope && !is_ancestor (scope, CP_DECL_CONTEXT (type)))\n+\t{\n+\t  error (\"declaration of `%D' in  `%D' which does not \"\n+\t\t \"enclose `%D'\", type, scope, nested_name_specifier);\n+\t  return NULL_TREE;\n+\t}\n+\n       maybe_process_partial_specialization (TREE_TYPE (type));\n       class_type = current_class_type;\n       type = TREE_TYPE (handle_class_head (class_key, \n \t\t\t\t\t   nested_name_specifier,\n \t\t\t\t\t   type,\n-\t\t\t\t\t   attributes,\n-\t\t\t\t\t   /*defn_p=*/true,\n-\t\t\t\t\t   &new_type_p));\n+\t\t\t\t\t   attributes));\n       if (type != error_mark_node)\n \t{\n \t  if (!class_type && TYPE_CONTEXT (type))"}, {"sha": "b40952820c22a2c843d332442a372d388a050baa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -1,3 +1,20 @@\n+2003-03-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9809\n+\t* g++.dg/parse/builtin1.C: New test.\n+\n+\tPR c++/9982\n+\t* g++.dg/abi/cookie1.C: New test.\n+\t* g++.dg/abi/cookie2.C: Likewise.\n+\n+\tPR c++/9524\n+\t* g++.dg/parse/field1.C: New test.\n+\n+\tPR c++/9912\n+\t* g++.dg/parse/class1.C: New test.\n+\t* g++.dg/parse/namespace7.C: Likewise.\n+\t* g++.old-deja/g++.other/decl5.C: Remove XFAILs.\n+\t\n 2003-03-07  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/init/ref4.C: New test."}, {"sha": "defc4887b5372e55c6d68241ec0c972393be0d65", "filename": "gcc/testsuite/g++.dg/abi/cookie1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie1.C?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-fabi-version=0\" }\n+\n+void *operator new[](__SIZE_TYPE__, void *);\n+\n+struct A {\n+    ~A(){}\n+};\n+\n+int main()\n+{\n+  A * a = (A*) new char[20];\n+  A  * b = new(a) A[3];\n+  if (a != b)\n+    return 1;\n+}"}, {"sha": "dc180453b706a766d9c3170c9ce800a05d95cd1b", "filename": "gcc/testsuite/g++.dg/abi/cookie2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fcookie2.C?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -0,0 +1,16 @@\n+// { dg-options \"-fabi-version=1\" }\n+\n+void *operator new[](__SIZE_TYPE__, void *);\n+\n+struct A {\n+    ~A(){}\n+};\n+\n+int main()\n+{\n+  A * a = (A*) new char[20];\n+  A  * b = new(a) A[3];\n+  // In the 3.2 ABI, a cookie was allocated in this case.\n+  if (a == b)\n+    return 1;\n+}"}, {"sha": "3b826bd866a52382567ce7bab4e6fefcf68e04f2", "filename": "gcc/testsuite/g++.dg/parse/builtin1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fbuiltin1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fbuiltin1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fbuiltin1.C?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -0,0 +1,16 @@\n+namespace std {\n+class Base {};\n+}\n+\n+struct Derived : public std::Base {\n+  operator const char*() const;\n+  operator bool(void) const;\n+};\n+\n+void log(const char* str);\n+\n+void nothing()\n+{\n+  Derived temp;\n+  log(temp);\n+}"}, {"sha": "819c48d9c21d2887a022447e726f9bd79ebff3bb", "filename": "gcc/testsuite/g++.dg/parse/class1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fclass1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fclass1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fclass1.C?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -0,0 +1,10 @@\n+namespace N\n+{\n+  struct A;\n+  int f() {\n+    struct N::A { // { dg-error \"\" }\n+      A() {}\n+    };\n+    return 0;\n+  }\n+}"}, {"sha": "c8ac608823f13f2dde48c2134bf0104c7b9c1649", "filename": "gcc/testsuite/g++.dg/parse/namespace7.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnamespace7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnamespace7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fnamespace7.C?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -0,0 +1,8 @@\n+namespace O {\n+  struct SO;\n+  namespace I {\n+    struct SI;\n+    struct O::SO {}; // { dg-error \"\" }\n+  }\n+  struct I::SI {};\n+}"}, {"sha": "c61437b28d6dbbe4c70919e4a435278f845eba79", "filename": "gcc/testsuite/g++.dg/template/field1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffield1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffield1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffield1.C?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -0,0 +1,12 @@\n+struct A {\n+  void (*f)(void);\n+};\n+\n+template< typename R >\n+struct B : public A {\n+  void g()\n+  {\n+    A::f();\n+  }\n+};\n+template class B<bool>;"}, {"sha": "f384fe0316d5057993750b095ca2722d24756268", "filename": "gcc/testsuite/g++.old-deja/g++.other/decl5.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/089d6ea74bea18d183968d655d7dd2c4e336ab03/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl5.C?ref=089d6ea74bea18d183968d655d7dd2c4e336ab03", "patch": "@@ -26,7 +26,7 @@ struct B {\n   struct A::fink {    // ERROR - no such member\n   int m;\n   };\n-  struct A::Z {       // ERROR - A::Z not a member of B XFAIL \n+  struct A::Z {       // ERROR - A::Z not a member of B\n     int m;\n   };\n   int m;\n@@ -66,7 +66,7 @@ namespace NMS\n   int N::fn() {       // ERROR - N::fn not a member of NMS\n     return 0;\n   }\n-  struct N::F {       // ERROR - N::F not a member of NMS XFAIL \n+  struct N::F {       // ERROR - N::F not a member of NMS\n     int i;\n   };\n }"}]}