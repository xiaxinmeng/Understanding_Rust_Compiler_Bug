{"sha": "c80620fcfa577f25449c727758627f47224cfaf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwNjIwZmNmYTU3N2YyNTQ0OWM3Mjc3NTg2MjdmNDcyMjRjZmFmOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-11-17T21:42:13Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-11-17T21:42:13Z"}, "message": "re PR target/78101 (PowerPC 64-bit little endian fusion failure with -O3 -mcpu=power9)\n\n[gcc]\n2016-11-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/78101\n\t* config/rs6000/predicates.md (fusion_addis_mem_combo_load): Add\n\tthe appropriate checks for SFmode/DFmode load/stores in GPR\n\tregisters.\n\t(fusion_addis_mem_combo_store): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Rename\n\tfusion_fpr_* to fusion_vsx_* and add in support for ISA 3.0 scalar\n\td-form instructions for traditional Altivec registers.\n\t(emit_fusion_p9_load): Likewise.\n\t(emit_fusion_p9_store): Likewise.\n\t* config/rs6000/rs6000.md (p9 fusion store peephole2): Remove\n\tearly clobber from scratch register.  Do not match if the register\n\tbeing stored is the scratch register.\n\t(fusion_vsx_<P:mode>_<FPR_FUSION:mode>_load): Rename fusion_fpr_*\n\tto fusion_vsx_* and add in support for ISA 3.0 scalar d-form\n\tinstructions for traditional Altivec registers.\n\t(fusion_fpr_<P:mode>_<FPR_FUSION:mode>_load): Likewise.\n\t(fusion_vsx_<P:mode>_<FPR_FUSION:mode>_store): Likewise.\n\t(fusion_fpr_<P:mode>_<FPR_FUSION:mode>_store): Likewise.\n\n[gcc/testsuite]\n2016-11-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/78101\n\t* gcc.target/powerpc/fusion4.c: New test.\n\nFrom-SVN: r242564", "tree": {"sha": "036e8f9e6cf13af843d4f8cf0ec5b27bf17122af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/036e8f9e6cf13af843d4f8cf0ec5b27bf17122af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c80620fcfa577f25449c727758627f47224cfaf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80620fcfa577f25449c727758627f47224cfaf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c80620fcfa577f25449c727758627f47224cfaf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c80620fcfa577f25449c727758627f47224cfaf9/comments", "author": null, "committer": null, "parents": [{"sha": "f8691e98180da3205b8a19ff34f6656c46c4c92a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8691e98180da3205b8a19ff34f6656c46c4c92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8691e98180da3205b8a19ff34f6656c46c4c92a"}], "stats": {"total": 130, "additions": 104, "deletions": 26}, "files": [{"sha": "f997b96b671996b8902dbc3d83044f9e901e621e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c80620fcfa577f25449c727758627f47224cfaf9", "patch": "@@ -1,3 +1,25 @@\n+2016-11-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/78101\n+\t* config/rs6000/predicates.md (fusion_addis_mem_combo_load): Add\n+\tthe appropriate checks for SFmode/DFmode load/stores in GPR\n+\tregisters.\n+\t(fusion_addis_mem_combo_store): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): Rename\n+\tfusion_fpr_* to fusion_vsx_* and add in support for ISA 3.0 scalar\n+\td-form instructions for traditional Altivec registers.\n+\t(emit_fusion_p9_load): Likewise.\n+\t(emit_fusion_p9_store): Likewise.\n+\t* config/rs6000/rs6000.md (p9 fusion store peephole2): Remove\n+\tearly clobber from scratch register.  Do not match if the register\n+\tbeing stored is the scratch register.\n+\t(fusion_vsx_<P:mode>_<FPR_FUSION:mode>_load): Rename fusion_fpr_*\n+\tto fusion_vsx_* and add in support for ISA 3.0 scalar d-form\n+\tinstructions for traditional Altivec registers.\n+\t(fusion_fpr_<P:mode>_<FPR_FUSION:mode>_load): Likewise.\n+\t(fusion_vsx_<P:mode>_<FPR_FUSION:mode>_store): Likewise.\n+\t(fusion_fpr_<P:mode>_<FPR_FUSION:mode>_store): Likewise.\n+\n 2016-11-17  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \tPR target/77933"}, {"sha": "57a463b2007397604e993abcdb38c57eed6be47d", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=c80620fcfa577f25449c727758627f47224cfaf9", "patch": "@@ -1844,7 +1844,7 @@\n ;; Match a GPR load (lbz, lhz, lwz, ld) that uses a combined address in the\n ;; memory field with both the addis and the memory offset.  Sign extension\n ;; is not handled here, since lha and lwa are not fused.\n-;; With extended fusion, also match a FPR load (lfd, lfs) and float_extend\n+;; With P9 fusion, also match a fpr/vector load and float_extend\n (define_predicate \"fusion_addis_mem_combo_load\"\n   (match_code \"mem,zero_extend,float_extend\")\n {\n@@ -1867,17 +1867,27 @@\n     case SImode:\n       break;\n \n+    /* Do not fuse 64-bit DImode in 32-bit since it splits into two\n+       separate instructions.  */\n     case DImode:\n       if (!TARGET_POWERPC64)\n \treturn 0;\n       break;\n \n+    /* ISA 2.08/power8 only had fusion of GPR loads.  */\n     case SFmode:\n-    case DFmode:\n       if (!TARGET_P9_FUSION)\n \treturn 0;\n       break;\n \n+    /* ISA 2.08/power8 only had fusion of GPR loads.  Do not allow 64-bit\n+       DFmode in 32-bit if -msoft-float since it splits into two separate\n+       instructions.  */\n+    case DFmode:\n+      if ((!TARGET_POWERPC64 && !TARGET_DF_FPR) || !TARGET_P9_FUSION)\n+\treturn 0;\n+      break;\n+\n     default:\n       return 0;\n     }\n@@ -1920,20 +1930,21 @@\n     case QImode:\n     case HImode:\n     case SImode:\n+    case SFmode:\n       break;\n \n+    /* Do not fuse 64-bit DImode in 32-bit since it splits into two\n+       separate instructions.  */\n     case DImode:\n       if (!TARGET_POWERPC64)\n \treturn 0;\n       break;\n \n-    case SFmode:\n-      if (!TARGET_SF_FPR)\n-\treturn 0;\n-      break;\n-\n+    /* Do not allow 64-bit DFmode in 32-bit if -msoft-float since it splits\n+       into two separate instructions.  Do allow fusion if we have hardware\n+       floating point.  */\n     case DFmode:\n-      if (!TARGET_DF_FPR)\n+      if (!TARGET_POWERPC64 && !TARGET_DF_FPR)\n \treturn 0;\n       break;\n "}, {"sha": "e050da8875ebd87000df7bd880eca8d6441db593", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c80620fcfa577f25449c727758627f47224cfaf9", "patch": "@@ -3441,28 +3441,28 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \n       static const struct fuse_insns addis_insns[] = {\n \t{ SFmode, DImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_fpr_di_sf_load,\n-\t  CODE_FOR_fusion_fpr_di_sf_store },\n+\t  CODE_FOR_fusion_vsx_di_sf_load,\n+\t  CODE_FOR_fusion_vsx_di_sf_store },\n \n \t{ SFmode, SImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_fpr_si_sf_load,\n-\t  CODE_FOR_fusion_fpr_si_sf_store },\n+\t  CODE_FOR_fusion_vsx_si_sf_load,\n+\t  CODE_FOR_fusion_vsx_si_sf_store },\n \n \t{ DFmode, DImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_fpr_di_df_load,\n-\t  CODE_FOR_fusion_fpr_di_df_store },\n+\t  CODE_FOR_fusion_vsx_di_df_load,\n+\t  CODE_FOR_fusion_vsx_di_df_store },\n \n \t{ DFmode, SImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_fpr_si_df_load,\n-\t  CODE_FOR_fusion_fpr_si_df_store },\n+\t  CODE_FOR_fusion_vsx_si_df_load,\n+\t  CODE_FOR_fusion_vsx_si_df_store },\n \n \t{ DImode, DImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_fpr_di_di_load,\n-\t  CODE_FOR_fusion_fpr_di_di_store },\n+\t  CODE_FOR_fusion_vsx_di_di_load,\n+\t  CODE_FOR_fusion_vsx_di_di_store },\n \n \t{ DImode, SImode, RELOAD_REG_FPR,\n-\t  CODE_FOR_fusion_fpr_si_di_load,\n-\t  CODE_FOR_fusion_fpr_si_di_store },\n+\t  CODE_FOR_fusion_vsx_si_di_load,\n+\t  CODE_FOR_fusion_vsx_si_di_store },\n \n \t{ QImode, DImode, RELOAD_REG_GPR,\n \t  CODE_FOR_fusion_gpr_di_qi_load,\n@@ -3522,6 +3522,14 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \n \t  reg_addr[xmode].fusion_addis_ld[rtype] = addis_insns[i].load;\n \t  reg_addr[xmode].fusion_addis_st[rtype] = addis_insns[i].store;\n+\n+\t  if (rtype == RELOAD_REG_FPR && TARGET_P9_DFORM_SCALAR)\n+\t    {\n+\t      reg_addr[xmode].fusion_addis_ld[RELOAD_REG_VMX]\n+\t\t= addis_insns[i].load;\n+\t      reg_addr[xmode].fusion_addis_st[RELOAD_REG_VMX]\n+\t\t= addis_insns[i].store;\n+\t    }\n \t}\n     }\n \n@@ -39818,6 +39826,15 @@ emit_fusion_p9_load (rtx reg, rtx mem, rtx tmp_reg)\n       else\n \tgcc_unreachable ();\n     }\n+  else if (ALTIVEC_REGNO_P (r) && TARGET_P9_DFORM_SCALAR)\n+    {\n+      if (mode == SFmode)\n+\tload_string = \"lxssp\";\n+      else if (mode == DFmode || mode == DImode)\n+\tload_string = \"lxsd\";\n+      else\n+\tgcc_unreachable ();\n+    }\n   else if (INT_REGNO_P (r))\n     {\n       switch (mode)\n@@ -39896,6 +39913,15 @@ emit_fusion_p9_store (rtx mem, rtx reg, rtx tmp_reg)\n       else\n \tgcc_unreachable ();\n     }\n+  else if (ALTIVEC_REGNO_P (r) && TARGET_P9_DFORM_SCALAR)\n+    {\n+      if (mode == SFmode)\n+\tstore_string = \"stxssp\";\n+      else if (mode == DFmode || mode == DImode)\n+\tstore_string = \"stxsd\";\n+      else\n+\tgcc_unreachable ();\n+    }\n   else if (INT_REGNO_P (r))\n     {\n       switch (mode)"}, {"sha": "acd4a7e508b43dc721b4da7e9f2ec377a1845dbe", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c80620fcfa577f25449c727758627f47224cfaf9", "patch": "@@ -13438,7 +13438,8 @@\n    (set (match_operand:SFDF 2 \"offsettable_mem_operand\" \"\")\n \t(match_operand:SFDF 3 \"toc_fusion_or_p9_reg_operand\" \"\"))]\n   \"TARGET_P9_FUSION && peep2_reg_dead_p (2, operands[0])\n-   && fusion_p9_p (operands[0], operands[1], operands[2], operands[3])\"\n+   && fusion_p9_p (operands[0], operands[1], operands[2], operands[3])\n+   && !rtx_equal_p (operands[0], operands[3])\"\n   [(const_int 0)]\n {\n   expand_fusion_p9_store (operands);\n@@ -13496,16 +13497,16 @@\n \t(unspec:GPR_FUSION\n \t [(match_operand:GPR_FUSION 1 \"int_reg_operand\" \"r\")]\n \t UNSPEC_FUSION_P9))\n-   (clobber (match_operand:P 2 \"base_reg_operand\" \"=&b\"))]\n+   (clobber (match_operand:P 2 \"base_reg_operand\" \"=b\"))]\n   \"TARGET_P9_FUSION\"\n {\n   return emit_fusion_p9_store (operands[0], operands[1], operands[2]);\n }\n   [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"fusion_fpr_<P:mode>_<FPR_FUSION:mode>_load\"\n-  [(set (match_operand:FPR_FUSION 0 \"fpr_reg_operand\" \"=d\")\n+(define_insn \"fusion_vsx_<P:mode>_<FPR_FUSION:mode>_load\"\n+  [(set (match_operand:FPR_FUSION 0 \"vsx_register_operand\" \"=dwb\")\n \t(unspec:FPR_FUSION\n \t [(match_operand:FPR_FUSION 1 \"fusion_addis_mem_combo_load\" \"wF\")]\n \t UNSPEC_FUSION_P9))\n@@ -13517,10 +13518,10 @@\n   [(set_attr \"type\" \"fpload\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"fusion_fpr_<P:mode>_<FPR_FUSION:mode>_store\"\n+(define_insn \"fusion_vsx_<P:mode>_<FPR_FUSION:mode>_store\"\n   [(set (match_operand:FPR_FUSION 0 \"fusion_addis_mem_combo_store\" \"=wF\")\n \t(unspec:FPR_FUSION\n-\t [(match_operand:FPR_FUSION 1 \"fpr_reg_operand\" \"d\")]\n+\t [(match_operand:FPR_FUSION 1 \"vsx_register_operand\" \"dwb\")]\n \t UNSPEC_FUSION_P9))\n    (clobber (match_operand:P 2 \"base_reg_operand\" \"=b\"))]\n   \"TARGET_P9_FUSION\""}, {"sha": "8018587479a520779d112e5b7bda733480599148", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c80620fcfa577f25449c727758627f47224cfaf9", "patch": "@@ -1,3 +1,8 @@\n+2016-11-17  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/78101\n+\t* gcc.target/powerpc/fusion4.c: New test.\n+\n 2016-11-17  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \tPR target/77933"}, {"sha": "e0185ead1a3913df4d5b58e029b020b942063646", "filename": "gcc/testsuite/gcc.target/powerpc/fusion4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c80620fcfa577f25449c727758627f47224cfaf9/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffusion4.c?ref=c80620fcfa577f25449c727758627f47224cfaf9", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power7 -mtune=power9 -O3 -msoft-float -m32\" } */\n+\n+#define LARGE 0x12345\n+\n+float fusion_float_read (float *p){ return p[LARGE]; }\n+\n+void fusion_float_write (float *p, float f){ p[LARGE] = f; }\n+\n+/* { dg-final { scan-assembler \"store fusion, type SF\" } } */"}]}