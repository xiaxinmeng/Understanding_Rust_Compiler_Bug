{"sha": "8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ0NGNmNzI3NTUyN2FiYzg2ZjMzZTZkNmM1MWZjODRmYTljODc3YQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-26T14:10:43Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-26T14:10:43Z"}, "message": "tree-vect-data-refs.c (Operator==, [...]): Move from ...\n\n\t* tree-vect-data-refs.c (Operator==, comp_dr_with_seg_len_pair):\n\tMove from ...\n\t* tree-data-ref.c (Operator==, comp_dr_with_seg_len_pair): To here.\n\t* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list): Factor\n\tout code pruning runtime alias checks.\n\t* tree-data-ref.c (prune_runtime_alias_test_list): New function\n\tfactored out from above.\n\t* tree-vectorizer.h (struct dr_with_seg_len, dr_with_seg_len_pair_t):\n\tMove from ...\n\t* tree-data-ref.h (struct dr_with_seg_len, dr_with_seg_len_pair_t):\n\t... to here.\n\t(prune_runtime_alias_test_list): New decalaration.\n\nFrom-SVN: r248511", "tree": {"sha": "3273bf86a29a78426128ba067fc0e6b94ef45da3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3273bf86a29a78426128ba067fc0e6b94ef45da3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/comments", "author": null, "committer": null, "parents": [{"sha": "2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c8f03adb27b15e9e4665dfe24b04f5516ec2ea4"}], "stats": {"total": 544, "additions": 284, "deletions": 260}, "files": [{"sha": "882fc27cc8e430f3493b9621a43d3bf7aae525f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "patch": "@@ -1,3 +1,18 @@\n+2017-05-26  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-data-refs.c (Operator==, comp_dr_with_seg_len_pair):\n+\tMove from ...\n+\t* tree-data-ref.c (Operator==, comp_dr_with_seg_len_pair): To here.\n+\t* tree-vect-data-refs.c (vect_prune_runtime_alias_test_list): Factor\n+\tout code pruning runtime alias checks.\n+\t* tree-data-ref.c (prune_runtime_alias_test_list): New function\n+\tfactored out from above.\n+\t* tree-vectorizer.h (struct dr_with_seg_len, dr_with_seg_len_pair_t):\n+\tMove from ...\n+\t* tree-data-ref.h (struct dr_with_seg_len, dr_with_seg_len_pair_t):\n+\t... to here.\n+\t(prune_runtime_alias_test_list): New decalaration.\n+\n 2017-05-26  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-vect-data-refs.c (compare_tree): Rename and move ..."}, {"sha": "2796b135e27190c95d6b9698f5bf403981493b7f", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "patch": "@@ -1182,6 +1182,245 @@ data_ref_compare_tree (tree t1, tree t2)\n   return 0;\n }\n \n+/* Operator == between two dr_with_seg_len objects.\n+\n+   This equality operator is used to make sure two data refs\n+   are the same one so that we will consider to combine the\n+   aliasing checks of those two pairs of data dependent data\n+   refs.  */\n+\n+static bool\n+operator == (const dr_with_seg_len& d1,\n+\t     const dr_with_seg_len& d2)\n+{\n+  return operand_equal_p (DR_BASE_ADDRESS (d1.dr),\n+\t\t\t  DR_BASE_ADDRESS (d2.dr), 0)\n+\t   && data_ref_compare_tree (DR_OFFSET (d1.dr), DR_OFFSET (d2.dr)) == 0\n+\t   && data_ref_compare_tree (DR_INIT (d1.dr), DR_INIT (d2.dr)) == 0\n+\t   && data_ref_compare_tree (d1.seg_len, d2.seg_len) == 0;\n+}\n+\n+/* Comparison function for sorting objects of dr_with_seg_len_pair_t\n+   so that we can combine aliasing checks in one scan.  */\n+\n+static int\n+comp_dr_with_seg_len_pair (const void *pa_, const void *pb_)\n+{\n+  const dr_with_seg_len_pair_t* pa = (const dr_with_seg_len_pair_t *) pa_;\n+  const dr_with_seg_len_pair_t* pb = (const dr_with_seg_len_pair_t *) pb_;\n+  const dr_with_seg_len &a1 = pa->first, &a2 = pa->second;\n+  const dr_with_seg_len &b1 = pb->first, &b2 = pb->second;\n+\n+  /* For DR pairs (a, b) and (c, d), we only consider to merge the alias checks\n+     if a and c have the same basic address snd step, and b and d have the same\n+     address and step.  Therefore, if any a&c or b&d don't have the same address\n+     and step, we don't care the order of those two pairs after sorting.  */\n+  int comp_res;\n+\n+  if ((comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (a1.dr),\n+\t\t\t\t\t DR_BASE_ADDRESS (b1.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (a2.dr),\n+\t\t\t\t\t DR_BASE_ADDRESS (b2.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = data_ref_compare_tree (DR_STEP (a1.dr),\n+\t\t\t\t\t DR_STEP (b1.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = data_ref_compare_tree (DR_STEP (a2.dr),\n+\t\t\t\t\t DR_STEP (b2.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = data_ref_compare_tree (DR_OFFSET (a1.dr),\n+\t\t\t\t\t DR_OFFSET (b1.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = data_ref_compare_tree (DR_INIT (a1.dr),\n+\t\t\t\t\t DR_INIT (b1.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = data_ref_compare_tree (DR_OFFSET (a2.dr),\n+\t\t\t\t\t DR_OFFSET (b2.dr))) != 0)\n+    return comp_res;\n+  if ((comp_res = data_ref_compare_tree (DR_INIT (a2.dr),\n+\t\t\t\t\t DR_INIT (b2.dr))) != 0)\n+    return comp_res;\n+\n+  return 0;\n+}\n+\n+/* Merge alias checks recorded in ALIAS_PAIRS and remove redundant ones.\n+   FACTOR is number of iterations that each data reference is accessed.\n+\n+   Basically, for each pair of dependent data refs store_ptr_0 & load_ptr_0,\n+   we create an expression:\n+\n+   ((store_ptr_0 + store_segment_length_0) <= load_ptr_0)\n+   || (load_ptr_0 + load_segment_length_0) <= store_ptr_0))\n+\n+   for aliasing checks.  However, in some cases we can decrease the number\n+   of checks by combining two checks into one.  For example, suppose we have\n+   another pair of data refs store_ptr_0 & load_ptr_1, and if the following\n+   condition is satisfied:\n+\n+   load_ptr_0 < load_ptr_1  &&\n+   load_ptr_1 - load_ptr_0 - load_segment_length_0 < store_segment_length_0\n+\n+   (this condition means, in each iteration of vectorized loop, the accessed\n+   memory of store_ptr_0 cannot be between the memory of load_ptr_0 and\n+   load_ptr_1.)\n+\n+   we then can use only the following expression to finish the alising checks\n+   between store_ptr_0 & load_ptr_0 and store_ptr_0 & load_ptr_1:\n+\n+   ((store_ptr_0 + store_segment_length_0) <= load_ptr_0)\n+   || (load_ptr_1 + load_segment_length_1 <= store_ptr_0))\n+\n+   Note that we only consider that load_ptr_0 and load_ptr_1 have the same\n+   basic address.  */\n+\n+void\n+prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n+\t\t\t       unsigned HOST_WIDE_INT factor)\n+{\n+  /* Sort the collected data ref pairs so that we can scan them once to\n+     combine all possible aliasing checks.  */\n+  alias_pairs->qsort (comp_dr_with_seg_len_pair);\n+\n+  /* Scan the sorted dr pairs and check if we can combine alias checks\n+     of two neighboring dr pairs.  */\n+  for (size_t i = 1; i < alias_pairs->length (); ++i)\n+    {\n+      /* Deal with two ddrs (dr_a1, dr_b1) and (dr_a2, dr_b2).  */\n+      dr_with_seg_len *dr_a1 = &(*alias_pairs)[i-1].first,\n+\t\t      *dr_b1 = &(*alias_pairs)[i-1].second,\n+\t\t      *dr_a2 = &(*alias_pairs)[i].first,\n+\t\t      *dr_b2 = &(*alias_pairs)[i].second;\n+\n+      /* Remove duplicate data ref pairs.  */\n+      if (*dr_a1 == *dr_a2 && *dr_b1 == *dr_b2)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf (MSG_NOTE, \"found equal ranges \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a1->dr));\n+\t      dump_printf (MSG_NOTE,  \", \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b1->dr));\n+\t      dump_printf (MSG_NOTE,  \" and \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a2->dr));\n+\t      dump_printf (MSG_NOTE,  \", \");\n+\t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n+\t    }\n+\t  alias_pairs->ordered_remove (i--);\n+\t  continue;\n+\t}\n+\n+      if (*dr_a1 == *dr_a2 || *dr_b1 == *dr_b2)\n+\t{\n+\t  /* We consider the case that DR_B1 and DR_B2 are same memrefs,\n+\t     and DR_A1 and DR_A2 are two consecutive memrefs.  */\n+\t  if (*dr_a1 == *dr_a2)\n+\t    {\n+\t      std::swap (dr_a1, dr_b1);\n+\t      std::swap (dr_a2, dr_b2);\n+\t    }\n+\n+\t  if (!operand_equal_p (DR_BASE_ADDRESS (dr_a1->dr),\n+\t\t\t\tDR_BASE_ADDRESS (dr_a2->dr), 0)\n+\t      || !operand_equal_p (DR_OFFSET (dr_a1->dr),\n+\t\t\t\t   DR_OFFSET (dr_a2->dr), 0)\n+\t      || !tree_fits_shwi_p (DR_INIT (dr_a1->dr))\n+\t      || !tree_fits_shwi_p (DR_INIT (dr_a2->dr)))\n+\t    continue;\n+\n+\t  /* Only merge const step data references.  */\n+\t  if (TREE_CODE (DR_STEP (dr_a1->dr)) != INTEGER_CST\n+\t      || TREE_CODE (DR_STEP (dr_a2->dr)) != INTEGER_CST)\n+\t    continue;\n+\n+\t  /* DR_A1 and DR_A2 must goes in the same direction.  */\n+\t  if (tree_int_cst_compare (DR_STEP (dr_a1->dr), size_zero_node)\n+\t      != tree_int_cst_compare (DR_STEP (dr_a2->dr), size_zero_node))\n+\t    continue;\n+\n+\t  /* Make sure dr_a1 starts left of dr_a2.  */\n+\t  if (tree_int_cst_lt (DR_INIT (dr_a2->dr), DR_INIT (dr_a1->dr)))\n+\t    std::swap (*dr_a1, *dr_a2);\n+\n+\t  bool do_remove = false;\n+\t  unsigned HOST_WIDE_INT diff\n+\t    = (tree_to_shwi (DR_INIT (dr_a2->dr))\n+               - tree_to_shwi (DR_INIT (dr_a1->dr)));\n+\n+\t  /* If the left segment does not extend beyond the start of the\n+\t     right segment the new segment length is that of the right\n+\t     plus the segment distance.  */\n+\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n+\t      && compare_tree_int (dr_a1->seg_len, diff) <= 0)\n+\t    {\n+\t      dr_a1->seg_len = size_binop (PLUS_EXPR, dr_a2->seg_len,\n+\t\t\t\t\t   size_int (diff));\n+\t      do_remove = true;\n+\t    }\n+\t  /* Generally the new segment length is the maximum of the\n+\t     left segment size and the right segment size plus the distance.\n+\t     ???  We can also build tree MAX_EXPR here but it's not clear this\n+\t     is profitable.  */\n+\t  else if (tree_fits_uhwi_p (dr_a1->seg_len)\n+\t\t   && tree_fits_uhwi_p (dr_a2->seg_len))\n+\t    {\n+\t      unsigned HOST_WIDE_INT seg_len_a1 = tree_to_uhwi (dr_a1->seg_len);\n+\t      unsigned HOST_WIDE_INT seg_len_a2 = tree_to_uhwi (dr_a2->seg_len);\n+\t      dr_a1->seg_len = size_int (MAX (seg_len_a1, diff + seg_len_a2));\n+\t      do_remove = true;\n+\t    }\n+\t  /* Now we check if the following condition is satisfied:\n+\n+\t     DIFF - SEGMENT_LENGTH_A < SEGMENT_LENGTH_B\n+\n+\t     where DIFF = DR_A2_INIT - DR_A1_INIT.  However,\n+\t     SEGMENT_LENGTH_A or SEGMENT_LENGTH_B may not be constant so we\n+\t     have to make a best estimation.  We can get the minimum value\n+\t     of SEGMENT_LENGTH_B as a constant, represented by MIN_SEG_LEN_B,\n+\t     then either of the following two conditions can guarantee the\n+\t     one above:\n+\n+\t     1: DIFF <= MIN_SEG_LEN_B\n+\t     2: DIFF - SEGMENT_LENGTH_A < MIN_SEG_LEN_B  */\n+\t  else\n+\t    {\n+\t      unsigned HOST_WIDE_INT min_seg_len_b\n+\t\t= (tree_fits_uhwi_p (dr_b1->seg_len)\n+\t\t   ? tree_to_uhwi (dr_b1->seg_len)\n+\t\t   : factor);\n+\n+\t      if (diff <= min_seg_len_b\n+\t\t  || (tree_fits_uhwi_p (dr_a1->seg_len)\n+\t\t      && diff - tree_to_uhwi (dr_a1->seg_len) < min_seg_len_b))\n+\t\t{\n+\t\t  dr_a1->seg_len = size_binop (PLUS_EXPR,\n+\t\t\t\t\t       dr_a2->seg_len, size_int (diff));\n+\t\t  do_remove = true;\n+\t\t}\n+\t    }\n+\n+\t  if (do_remove)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf (MSG_NOTE, \"merging ranges for \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a1->dr));\n+\t\t  dump_printf (MSG_NOTE,  \", \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b1->dr));\n+\t\t  dump_printf (MSG_NOTE,  \" and \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a2->dr));\n+\t\t  dump_printf (MSG_NOTE,  \", \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));\n+\t\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t\t}\n+\t      alias_pairs->ordered_remove (i--);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Check if OFFSET1 and OFFSET2 (DR_OFFSETs of some data-refs) are identical\n    expressions.  */\n static bool"}, {"sha": "dbe8372c7f99409e327bf5a34b1cc7f7a3af7caf", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "patch": "@@ -148,6 +148,32 @@ struct data_reference\n \n typedef struct data_reference *data_reference_p;\n \n+/* This struct is used to store the information of a data reference,\n+   including the data ref itself and the segment length for aliasing\n+   checks.  This is used to merge alias checks.  */\n+\n+struct dr_with_seg_len\n+{\n+  dr_with_seg_len (data_reference_p d, tree len)\n+    : dr (d), seg_len (len) {}\n+\n+  data_reference_p dr;\n+  tree seg_len;\n+};\n+\n+/* This struct contains two dr_with_seg_len objects with aliasing data\n+   refs.  Two comparisons are generated from them.  */\n+\n+struct dr_with_seg_len_pair_t\n+{\n+  dr_with_seg_len_pair_t (const dr_with_seg_len& d1,\n+\t\t\t       const dr_with_seg_len& d2)\n+    : first (d1), second (d2) {}\n+\n+  dr_with_seg_len first;\n+  dr_with_seg_len second;\n+};\n+\n enum data_dependence_direction {\n   dir_positive,\n   dir_negative,\n@@ -343,6 +369,8 @@ extern bool dr_equal_offsets_p (struct data_reference *,\n                                 struct data_reference *);\n \n extern int data_ref_compare_tree (tree, tree);\n+extern void prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT);\n /* Return true when the base objects of data references A and B are\n    the same memory object.  */\n "}, {"sha": "a1ef24ed1d51e98f00e9f6842c4d4526d39e31c0", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 232, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "patch": "@@ -2814,72 +2814,6 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n   return true;\n }\n \n-\n-/* Operator == between two dr_with_seg_len objects.\n-\n-   This equality operator is used to make sure two data refs\n-   are the same one so that we will consider to combine the\n-   aliasing checks of those two pairs of data dependent data\n-   refs.  */\n-\n-static bool\n-operator == (const dr_with_seg_len& d1,\n-\t     const dr_with_seg_len& d2)\n-{\n-  return operand_equal_p (DR_BASE_ADDRESS (d1.dr),\n-\t\t\t  DR_BASE_ADDRESS (d2.dr), 0)\n-\t   && data_ref_compare_tree (DR_OFFSET (d1.dr), DR_OFFSET (d2.dr)) == 0\n-\t   && data_ref_compare_tree (DR_INIT (d1.dr), DR_INIT (d2.dr)) == 0\n-\t   && data_ref_compare_tree (d1.seg_len, d2.seg_len) == 0;\n-}\n-\n-/* Function comp_dr_with_seg_len_pair.\n-\n-   Comparison function for sorting objects of dr_with_seg_len_pair_t\n-   so that we can combine aliasing checks in one scan.  */\n-\n-static int\n-comp_dr_with_seg_len_pair (const void *pa_, const void *pb_)\n-{\n-  const dr_with_seg_len_pair_t* pa = (const dr_with_seg_len_pair_t *) pa_;\n-  const dr_with_seg_len_pair_t* pb = (const dr_with_seg_len_pair_t *) pb_;\n-  const dr_with_seg_len &a1 = pa->first, &a2 = pa->second;\n-  const dr_with_seg_len &b1 = pb->first, &b2 = pb->second;\n-\n-  /* For DR pairs (a, b) and (c, d), we only consider to merge the alias checks\n-     if a and c have the same basic address snd step, and b and d have the same\n-     address and step.  Therefore, if any a&c or b&d don't have the same address\n-     and step, we don't care the order of those two pairs after sorting.  */\n-  int comp_res;\n-\n-  if ((comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (a1.dr),\n-\t\t\t\t\t DR_BASE_ADDRESS (b1.dr))) != 0)\n-    return comp_res;\n-  if ((comp_res = data_ref_compare_tree (DR_BASE_ADDRESS (a2.dr),\n-\t\t\t\t\t DR_BASE_ADDRESS (b2.dr))) != 0)\n-    return comp_res;\n-  if ((comp_res = data_ref_compare_tree (DR_STEP (a1.dr),\n-\t\t\t\t\t DR_STEP (b1.dr))) != 0)\n-    return comp_res;\n-  if ((comp_res = data_ref_compare_tree (DR_STEP (a2.dr),\n-\t\t\t\t\t DR_STEP (b2.dr))) != 0)\n-    return comp_res;\n-  if ((comp_res = data_ref_compare_tree (DR_OFFSET (a1.dr),\n-\t\t\t\t\t DR_OFFSET (b1.dr))) != 0)\n-    return comp_res;\n-  if ((comp_res = data_ref_compare_tree (DR_INIT (a1.dr),\n-\t\t\t\t\t DR_INIT (b1.dr))) != 0)\n-    return comp_res;\n-  if ((comp_res = data_ref_compare_tree (DR_OFFSET (a2.dr),\n-\t\t\t\t\t DR_OFFSET (b2.dr))) != 0)\n-    return comp_res;\n-  if ((comp_res = data_ref_compare_tree (DR_INIT (a2.dr),\n-\t\t\t\t\t DR_INIT (b2.dr))) != 0)\n-    return comp_res;\n-\n-  return 0;\n-}\n-\n /* Function vect_vfa_segment_size.\n \n    Create an expression that computes the size of segment\n@@ -2994,34 +2928,6 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   if (may_alias_ddrs.is_empty ())\n     return true;\n \n-  /* Basically, for each pair of dependent data refs store_ptr_0\n-     and load_ptr_0, we create an expression:\n-\n-     ((store_ptr_0 + store_segment_length_0) <= load_ptr_0)\n-     || (load_ptr_0 + load_segment_length_0) <= store_ptr_0))\n-\n-     for aliasing checks.  However, in some cases we can decrease\n-     the number of checks by combining two checks into one.  For\n-     example, suppose we have another pair of data refs store_ptr_0\n-     and load_ptr_1, and if the following condition is satisfied:\n-\n-     load_ptr_0 < load_ptr_1  &&\n-     load_ptr_1 - load_ptr_0 - load_segment_length_0 < store_segment_length_0\n-\n-     (this condition means, in each iteration of vectorized loop,\n-     the accessed memory of store_ptr_0 cannot be between the memory\n-     of load_ptr_0 and load_ptr_1.)\n-\n-     we then can use only the following expression to finish the\n-     alising checks between store_ptr_0 & load_ptr_0 and\n-     store_ptr_0 & load_ptr_1:\n-\n-     ((store_ptr_0 + store_segment_length_0) <= load_ptr_0)\n-     || (load_ptr_1 + load_segment_length_1 <= store_ptr_0))\n-\n-     Note that we only consider that load_ptr_0 and load_ptr_1 have the\n-     same basic address.  */\n-\n   comp_alias_ddrs.create (may_alias_ddrs.length ());\n \n   /* First, we collect all data ref pairs for aliasing checks.  */\n@@ -3092,144 +2998,8 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       comp_alias_ddrs.safe_push (dr_with_seg_len_pair);\n     }\n \n-  /* Second, we sort the collected data ref pairs so that we can scan\n-     them once to combine all possible aliasing checks.  */\n-  comp_alias_ddrs.qsort (comp_dr_with_seg_len_pair);\n-\n-  /* Third, we scan the sorted dr pairs and check if we can combine\n-     alias checks of two neighboring dr pairs.  */\n-  for (size_t i = 1; i < comp_alias_ddrs.length (); ++i)\n-    {\n-      /* Deal with two ddrs (dr_a1, dr_b1) and (dr_a2, dr_b2).  */\n-      dr_with_seg_len *dr_a1 = &comp_alias_ddrs[i-1].first,\n-\t\t      *dr_b1 = &comp_alias_ddrs[i-1].second,\n-\t\t      *dr_a2 = &comp_alias_ddrs[i].first,\n-\t\t      *dr_b2 = &comp_alias_ddrs[i].second;\n-\n-      /* Remove duplicate data ref pairs.  */\n-      if (*dr_a1 == *dr_a2 && *dr_b1 == *dr_b2)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"found equal ranges \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t DR_REF (dr_a1->dr));\n-\t      dump_printf (MSG_NOTE,  \", \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t DR_REF (dr_b1->dr));\n-\t      dump_printf (MSG_NOTE,  \" and \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t DR_REF (dr_a2->dr));\n-\t      dump_printf (MSG_NOTE,  \", \");\n-\t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n-\t\t\t\t DR_REF (dr_b2->dr));\n-\t      dump_printf (MSG_NOTE, \"\\n\");\n-\t    }\n-\n-\t  comp_alias_ddrs.ordered_remove (i--);\n-\t  continue;\n-\t}\n-\n-      if (*dr_a1 == *dr_a2 || *dr_b1 == *dr_b2)\n-\t{\n-\t  /* We consider the case that DR_B1 and DR_B2 are same memrefs,\n-\t     and DR_A1 and DR_A2 are two consecutive memrefs.  */\n-\t  if (*dr_a1 == *dr_a2)\n-\t    {\n-\t      std::swap (dr_a1, dr_b1);\n-\t      std::swap (dr_a2, dr_b2);\n-\t    }\n-\n-\t  if (!operand_equal_p (DR_BASE_ADDRESS (dr_a1->dr),\n-\t\t\t\tDR_BASE_ADDRESS (dr_a2->dr), 0)\n-\t      || !operand_equal_p (DR_OFFSET (dr_a1->dr),\n-\t\t\t\t   DR_OFFSET (dr_a2->dr), 0)\n-\t      || !tree_fits_shwi_p (DR_INIT (dr_a1->dr))\n-\t      || !tree_fits_shwi_p (DR_INIT (dr_a2->dr)))\n-\t    continue;\n-\n-\t  /* Make sure dr_a1 starts left of dr_a2.  */\n-\t  if (tree_int_cst_lt (DR_INIT (dr_a2->dr), DR_INIT (dr_a1->dr)))\n-\t    std::swap (*dr_a1, *dr_a2);\n-\n-\t  bool do_remove = false;\n-\t  unsigned HOST_WIDE_INT diff\n-\t    = (tree_to_shwi (DR_INIT (dr_a2->dr))\n-               - tree_to_shwi (DR_INIT (dr_a1->dr)));\n-\n-\t  /* If the left segment does not extend beyond the start of the\n-\t     right segment the new segment length is that of the right\n-\t     plus the segment distance.  */\n-\t  if (tree_fits_uhwi_p (dr_a1->seg_len)\n-\t      && compare_tree_int (dr_a1->seg_len, diff) <= 0)\n-\t    {\n-\t      dr_a1->seg_len = size_binop (PLUS_EXPR, dr_a2->seg_len,\n-\t\t\t\t\t   size_int (diff));\n-\t      do_remove = true;\n-\t    }\n-\t  /* Generally the new segment length is the maximum of the\n-\t     left segment size and the right segment size plus the distance.\n-\t     ???  We can also build tree MAX_EXPR here but it's not clear this\n-\t     is profitable.  */\n-\t  else if (tree_fits_uhwi_p (dr_a1->seg_len)\n-\t\t   && tree_fits_uhwi_p (dr_a2->seg_len))\n-\t    {\n-\t      unsigned HOST_WIDE_INT seg_len_a1 = tree_to_uhwi (dr_a1->seg_len);\n-\t      unsigned HOST_WIDE_INT seg_len_a2 = tree_to_uhwi (dr_a2->seg_len);\n-\t      dr_a1->seg_len = size_int (MAX (seg_len_a1, diff + seg_len_a2));\n-\t      do_remove = true;\n-\t    }\n-\t  /* Now we check if the following condition is satisfied:\n-\n-\t     DIFF - SEGMENT_LENGTH_A < SEGMENT_LENGTH_B\n-\n-\t     where DIFF = DR_A2_INIT - DR_A1_INIT.  However,\n-\t     SEGMENT_LENGTH_A or SEGMENT_LENGTH_B may not be constant so we\n-\t     have to make a best estimation.  We can get the minimum value\n-\t     of SEGMENT_LENGTH_B as a constant, represented by MIN_SEG_LEN_B,\n-\t     then either of the following two conditions can guarantee the\n-\t     one above:\n-\n-\t     1: DIFF <= MIN_SEG_LEN_B\n-\t     2: DIFF - SEGMENT_LENGTH_A < MIN_SEG_LEN_B  */\n-\t  else\n-\t    {\n-\t      unsigned HOST_WIDE_INT min_seg_len_b\n-\t\t= (tree_fits_uhwi_p (dr_b1->seg_len)\n-\t\t   ? tree_to_uhwi (dr_b1->seg_len)\n-\t\t   : vect_factor);\n-\n-\t      if (diff <= min_seg_len_b\n-\t\t  || (tree_fits_uhwi_p (dr_a1->seg_len)\n-\t\t      && diff - tree_to_uhwi (dr_a1->seg_len) < min_seg_len_b))\n-\t\t{\n-\t\t  dr_a1->seg_len = size_binop (PLUS_EXPR,\n-\t\t\t\t\t       dr_a2->seg_len, size_int (diff));\n-\t\t  do_remove = true;\n-\t\t}\n-\t    }\n-\n-\t  if (do_remove)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t   \"merging ranges for \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a1->dr));\n-\t\t  dump_printf (MSG_NOTE,  \", \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b1->dr));\n-\t\t  dump_printf (MSG_NOTE,  \" and \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a2->dr));\n-\t\t  dump_printf (MSG_NOTE,  \", \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b2->dr));\n-\t\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n-\t      comp_alias_ddrs.ordered_remove (i--);\n-\t    }\n-\t}\n-    }\n-\n+  prune_runtime_alias_test_list (&comp_alias_ddrs,\n+\t\t\t\t (unsigned HOST_WIDE_INT) vect_factor);\n   dump_printf_loc (MSG_NOTE, vect_location,\n \t\t   \"improved number of alias checks from %d to %d\\n\",\n \t\t   may_alias_ddrs.length (), comp_alias_ddrs.length ());"}, {"sha": "eb47bd4f7ef6f0d692618779265fe4cb5f105ff7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d44cf7275527abc86f33e6d6c51fc84fa9c877a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=8d44cf7275527abc86f33e6d6c51fc84fa9c877a", "patch": "@@ -146,34 +146,6 @@ typedef struct _slp_instance {\n \n \n \n-/* This struct is used to store the information of a data reference,\n-   including the data ref itself and the segment length for aliasing\n-   checks.  This is used to merge alias checks.  */\n-\n-struct dr_with_seg_len\n-{\n-  dr_with_seg_len (data_reference_p d, tree len)\n-    : dr (d), seg_len (len) {}\n-\n-  data_reference_p dr;\n-  tree seg_len;\n-};\n-\n-/* This struct contains two dr_with_seg_len objects with aliasing data\n-   refs.  Two comparisons are generated from them.  */\n-\n-struct dr_with_seg_len_pair_t\n-{\n-  dr_with_seg_len_pair_t (const dr_with_seg_len& d1,\n-\t\t\t       const dr_with_seg_len& d2)\n-    : first (d1), second (d2) {}\n-\n-  dr_with_seg_len first;\n-  dr_with_seg_len second;\n-};\n-\n-\n-\n /* Vectorizer state common between loop and basic-block vectorization.  */\n struct vec_info {\n   enum { bb, loop } kind;"}]}