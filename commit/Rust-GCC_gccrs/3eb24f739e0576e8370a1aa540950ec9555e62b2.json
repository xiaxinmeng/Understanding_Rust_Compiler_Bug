{"sha": "3eb24f739e0576e8370a1aa540950ec9555e62b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ViMjRmNzM5ZTA1NzZlODM3MGExYWE1NDA5NTBlYzk1NTVlNjJiMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-09T19:13:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-09T19:13:33Z"}, "message": "decl.c (init_decl_processing): Reenable inlining on trees.\n\n\t* decl.c (init_decl_processing): Reenable inlining on trees.\n\t(finish_function): Likewise.\n\t* expr.c (cplus_expand_expr): Don't handle AGGR_INIT_EXPR here.\n\t* semantics.c (simplify_aggr_init_exprs): New function.\n\t(expand_body): Use it.\n\t* tree.c (walk_tree): Special-case TARGET_EXPRs since they\n\tsometimes present the same sub-tree twice.\n\nFrom-SVN: r30849", "tree": {"sha": "989046ebc48794210cbe94bbfea638ed07c2c931", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/989046ebc48794210cbe94bbfea638ed07c2c931"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3eb24f739e0576e8370a1aa540950ec9555e62b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb24f739e0576e8370a1aa540950ec9555e62b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb24f739e0576e8370a1aa540950ec9555e62b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb24f739e0576e8370a1aa540950ec9555e62b2/comments", "author": null, "committer": null, "parents": [{"sha": "1e54d32b0524638e375a871ef3cb6b8897ce203c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e54d32b0524638e375a871ef3cb6b8897ce203c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e54d32b0524638e375a871ef3cb6b8897ce203c"}], "stats": {"total": 220, "additions": 118, "deletions": 102}, "files": [{"sha": "b6505e55d75d1a1b44cabb84a18d7ff2c85155ff", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3eb24f739e0576e8370a1aa540950ec9555e62b2", "patch": "@@ -1,5 +1,13 @@\n 1999-12-09  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* decl.c (init_decl_processing): Reenable inlining on trees.\n+\t(finish_function): Likewise.\n+\t* expr.c (cplus_expand_expr): Don't handle AGGR_INIT_EXPR here.\n+\t* semantics.c (simplify_aggr_init_exprs): New function.\n+\t(expand_body): Use it.\n+\t* tree.c (walk_tree): Special-case TARGET_EXPRs since they\n+\tsometimes present the same sub-tree twice.\n+\t\n \t* dump.c (dequeue_and_dump): Abbreviate `class' as `cls', not\n \t`csl'.\n "}, {"sha": "b6a62ea48348bb396e93378bb3218f562fee502a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3eb24f739e0576e8370a1aa540950ec9555e62b2", "patch": "@@ -5973,10 +5973,8 @@ init_decl_processing ()\n     flag_strict_prototype = pedantic;\n   if (! flag_permissive && ! pedantic)\n     flag_pedantic_errors = 1;\n-#if 0\n   if (!flag_no_inline)\n     flag_inline_trees = 1;\n-#endif\n \n   strict_prototypes_lang_c = flag_strict_prototype;\n \n@@ -13669,7 +13667,6 @@ finish_function (lineno, flags)\n   if (!expanding_p && !processing_template_decl)\n     save_function_data (fndecl);\n \n-#if 0\n   /* If this function calls `setjmp' it cannot be inlined.  When\n      `longjmp' is called it is not guaranteed to restore the value of\n      local variables that have been modified since the call to\n@@ -13681,7 +13678,6 @@ finish_function (lineno, flags)\n      function.)  */\n   if (!expanding_p && !processing_template_decl && calls_setjmp_p (fndecl))\n     DECL_UNINLINABLE (fndecl) = 1;\n-#endif\n \n   if (expand_p)\n     {"}, {"sha": "2ac29f9f2c6379b054df46eee2337df5c528678e", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=3eb24f739e0576e8370a1aa540950ec9555e62b2", "patch": "@@ -120,102 +120,6 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \n   switch (code)\n     {\n-    case AGGR_INIT_EXPR:\n-      {\n-\t/* Something needs to be initialized, but we didn't know\n-\t   where that thing was when building the tree.  For example,\n-\t   it could be the return value of a function, or a parameter\n-\t   to a function which lays down in the stack, or a temporary\n-\t   variable which must be passed by reference.\n-\n-\t   Cleanups are handled in a language-specific way: they\n-\t   might be run by the called function (true in GNU C++\n-\t   for parameters with cleanups), or they might be\n-\t   run by the caller, after the call (true in GNU C++\n-\t   for other cleanup needs).  */\n-\n-\ttree func = TREE_OPERAND (exp, 0);\n-\ttree args = TREE_OPERAND (exp, 1);\n-\ttree type = TREE_TYPE (exp), slot;\n-\ttree call_exp;\n-\trtx call_target, return_target;\n-\tint pcc_struct_return = 0;\n-\n-\t/* The expression `init' wants to initialize what\n-\t   `target' represents.  SLOT holds the slot for TARGET.  */\n-\tslot = TREE_OPERAND (exp, 2);\n-\n-\t/* Should always be called with a target.  */\n-\tmy_friendly_assert (target != NULL_RTX, 205);\n-\n-\t/* The target the initializer will initialize (CALL_TARGET)\n-\t   must now be directed to initialize the target we are\n-\t   supposed to initialize (TARGET).  The semantics for\n-\t   choosing what CALL_TARGET is is language-specific,\n-\t   as is building the call which will perform the\n-\t   initialization.  It is left here to show the choices that\n-\t   exist for C++.  */\n-\t   \n-\tif (AGGR_INIT_VIA_CTOR_P (exp))\n-\t  {\n-\t    type = build_pointer_type (type);\n-\t    mark_addressable (slot);\n-\t    args = tree_cons (NULL_TREE, \n-\t\t\t      build1 (ADDR_EXPR, type, slot),\n-\t\t\t      TREE_CHAIN (args));\n-\t    call_target = 0;\n-\t  }\n-\telse\n-\t  {\n-\t    call_target = target;\n-#ifdef PCC_STATIC_STRUCT_RETURN\n-\t    if (aggregate_value_p (type))\n-\t      {\n-\t\tpcc_struct_return = 1;\n-\t\tcall_target = 0;\n-\t      }\n-#endif\n-\t  }\n-\n-\tcall_exp = build (CALL_EXPR, type, func, args, NULL_TREE);\n-\tTREE_SIDE_EFFECTS (call_exp) = 1;\n-\treturn_target = expand_call (call_exp, call_target, ignore);\n-\n-\tif (call_target)\n-\t  /* Trust that the right thing has been done; it's too hard to\n-\t     verify.  */\n-\t  return return_target;\n-\n-\t/* If we're suffering under the ancient PCC_STATIC_STRUCT_RETURN\n-\t   calling convention, we need to copy the return value out of\n-\t   the static return buffer into slot.  */\n-\tif (pcc_struct_return)\n-\t  {\n-\t    extern int flag_access_control;\n-\t    int old_ac = flag_access_control;\n-\n-\t    tree init = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t\t    build_reference_type (type));\n-\t    DECL_RTL (init) = XEXP (return_target, 0);\n-\t    init = convert_from_reference (init);\n-\n-\t    flag_access_control = 0;\n-\t    expand_expr (build_aggr_init (slot, init,\n-\t\t\t\t\t  LOOKUP_ONLYCONVERTING), \n-\t\t\t target, tmode, EXPAND_NORMAL);\n-\t    flag_access_control = old_ac;\n-\n-\t    if (TYPE_NEEDS_DESTRUCTOR (type))\n-\t      {\n-\t\tinit = maybe_build_cleanup (init);\n-\t\tif (init != NULL_TREE)\n-\t\t  expand_expr (init, const0_rtx, VOIDmode, 0);\n-\t      }\n-\t  }\n-\n-\treturn DECL_RTL (slot);\n-      }\n-\n     case PTRMEM_CST:\n       return expand_expr (cplus_expand_constant (exp),\n \t\t\t  target, tmode, modifier);"}, {"sha": "ca0201db58e2ce4e8ddbe7e8327de3459dd3f6e8", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3eb24f739e0576e8370a1aa540950ec9555e62b2", "patch": "@@ -2547,6 +2547,81 @@ expand_stmt (t)\n   return rval;\n }\n \n+/* Called from expand_body via walk_tree.  Replace all AGGR_INIT_EXPRs\n+   will equivalent CALL_EXPRs.  */\n+\n+static tree\n+simplify_aggr_init_exprs_r (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees ATTRIBUTE_UNUSED;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  tree aggr_init_expr;\n+  tree call_expr;\n+  tree fn;\n+  tree args;\n+  tree slot;\n+  tree type;\n+  tree call_type;\n+  int copy_from_buffer_p;\n+\n+  /* Only AGGR_INIT_EXPRs are interesting.  */\n+  aggr_init_expr = *tp;\n+  if (TREE_CODE (aggr_init_expr) != AGGR_INIT_EXPR)\n+    return NULL_TREE;\n+\n+  /* Form an appropriate CALL_EXPR.  */\n+  fn = TREE_OPERAND (aggr_init_expr, 0);\n+  args = TREE_OPERAND (aggr_init_expr, 1);\n+  slot = TREE_OPERAND (aggr_init_expr, 2);\n+  type = TREE_TYPE (aggr_init_expr);\n+  call_type = type;\n+  if (AGGR_INIT_VIA_CTOR_P (aggr_init_expr))\n+    {\n+      /* Replace the first argument with the address of the third\n+\t argument to the AGGR_INIT_EXPR.  */\n+      call_type = build_pointer_type (type);\n+      mark_addressable (slot);\n+      args = tree_cons (NULL_TREE, build1 (ADDR_EXPR, call_type, slot),\n+\t\t\tTREE_CHAIN (args));\n+    }\n+  call_expr = build (CALL_EXPR, call_type, fn, args, NULL_TREE);\n+  TREE_SIDE_EFFECTS (call_expr) = 1;\n+\n+  /* If we're using the non-reentrant PCC calling convention, then we\n+     need to copy the returned value out of the static buffer into the\n+     SLOT.  */\n+  copy_from_buffer_p = 0;\n+#ifdef PCC_STATIC_STRUCT_RETURN  \n+  if (!AGGR_INIT_VIA_CTOR_P (aggr_init_expr) && aggregate_value_p (type))\n+    {\n+      int old_ac;\n+\n+      flag_access_control = 0;\n+      call_expr = build_aggr_init (slot, call_expr, LOOKUP_ONLYCONVERTING);\n+      flag_access_control = old_ac;\n+      copy_from_buffer_p = 1;\n+    }\n+#endif\n+\n+  /* If this AGGR_INIT_EXPR indicates the value returned by a\n+     function, then we want to use the value of the initialized\n+     location as the result.  */\n+  if (AGGR_INIT_VIA_CTOR_P (aggr_init_expr) || copy_from_buffer_p)\n+    {\n+      call_expr = build (COMPOUND_EXPR, type,\n+\t\t\t call_expr, slot);\n+      TREE_SIDE_EFFECTS (call_expr) = 1;\n+    }\n+\n+  /* Replace the AGGR_INIT_EXPR with the CALL_EXPR.  */\n+  TREE_CHAIN (call_expr) = TREE_CHAIN (aggr_init_expr);\n+  *tp = call_expr;\n+\n+  /* Keep iterating.  */\n+  return NULL_TREE;\n+}\n+\n /* Generate RTL for FN.  */\n \n void\n@@ -2574,6 +2649,9 @@ expand_body (fn)\n       return;\n     }\n \n+  /* Replace AGGR_INIT_EXPRs with appropriate CALL_EXPRs.  */\n+  walk_tree (&DECL_SAVED_TREE (fn), simplify_aggr_init_exprs_r, NULL);\n+\n   /* There's no reason to do any of the work here if we're only doing\n      semantic analysis; this code just generates RTL.  */\n   if (flag_syntax_only)"}, {"sha": "31fbec0401c07b9fdbe4300cee287ba8ca2c9c98", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3eb24f739e0576e8370a1aa540950ec9555e62b2", "patch": "@@ -1626,8 +1626,18 @@ walk_tree (tp, func, data)\n       int i;\n \n       /* Walk over all the sub-trees of this operand.  */\n-      for (i = first_rtl_op (code) - 1; i >= 0; --i)\n-\tWALK_SUBTREE (TREE_OPERAND (*tp, i));\n+      i = first_rtl_op (code) - 1;\n+      /* TARGET_EXPRs are peculiar: operands 1 and 3 can be the same.\n+\t But, we only want to walk once.  */\n+      if (code == TARGET_EXPR\n+\t  && TREE_OPERAND (*tp, 3) == TREE_OPERAND (*tp, 1))\n+\t--i;\n+      /* Go through the subtrees.  */\n+      while (i >= 0)\n+\t{\n+\t  WALK_SUBTREE (TREE_OPERAND (*tp, i));\n+\t  --i;\n+\t}\n \n       /* For statements, we also walk the chain so that we cover the\n \t entire statement tree.  */"}, {"sha": "c4c71b797b4c06543fe13cb531a16e74e86215e2", "filename": "gcc/testsuite/g++.old-deja/g++.other/inline1.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finline1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eb24f739e0576e8370a1aa540950ec9555e62b2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finline1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Finline1.C?ref=3eb24f739e0576e8370a1aa540950ec9555e62b2", "patch": "@@ -0,0 +1,20 @@\n+// Build don't link:\n+// Origin: Martin Reinecke <martin@MPA-Garching.MPG.DE>\n+// Special g++ Options: -O2 -Winline\n+\n+class foo\n+{\n+  public:\n+    float x;\n+\n+    foo (float xval)\n+      : x (xval) {}\n+\n+    foo operator+ (const foo &foo2) const\n+      { return foo (x+foo2.x); }\n+};\n+\n+int main()\n+{\n+  foo f=foo(1)+foo(2);\n+}"}]}