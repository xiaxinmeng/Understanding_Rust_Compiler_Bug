{"sha": "db182590070bfa9157b03a4e7076aff270d3cda4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIxODI1OTAwNzBiZmE5MTU3YjAzYTRlNzA3NmFmZjI3MGQzY2RhNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-05T19:15:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-05T19:15:40Z"}, "message": "(struct format_char_info...\n\n(struct format_char_info, print_table, scan_table, struct\nfunction_info, function_info_entries, function_info_table,\nrecord_format_info, init_format_info_table, check_format): Moved to\nc-common.c.\n(build_function_call): Call check_function_format.\n\nFrom-SVN: r5608", "tree": {"sha": "9aee8964eb73c62b3ce42a944552807d042984f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aee8964eb73c62b3ce42a944552807d042984f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db182590070bfa9157b03a4e7076aff270d3cda4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db182590070bfa9157b03a4e7076aff270d3cda4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db182590070bfa9157b03a4e7076aff270d3cda4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db182590070bfa9157b03a4e7076aff270d3cda4/comments", "author": null, "committer": null, "parents": [{"sha": "1ccf251f9751554268b356b21bf452cf7f686f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccf251f9751554268b356b21bf452cf7f686f09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ccf251f9751554268b356b21bf452cf7f686f09"}], "stats": {"total": 555, "additions": 5, "deletions": 550}, "files": [{"sha": "82d4fa4889f8d294b90f876ed75ccffcc4ab09ee", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 5, "deletions": 550, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db182590070bfa9157b03a4e7076aff270d3cda4/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db182590070bfa9157b03a4e7076aff270d3cda4/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=db182590070bfa9157b03a4e7076aff270d3cda4", "patch": "@@ -1403,541 +1403,6 @@ build_array_ref (array, index)\n   }\n }\n \f\n-/* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against PARAMS.  */\n-\n-#define ISDIGIT(c)\t((c) >= '0' && (c) <= '9')\n-\n-#define T_I\t&integer_type_node\n-#define T_L\t&long_integer_type_node\n-#define T_S\t&short_integer_type_node\n-#define T_UI\t&unsigned_type_node\n-#define T_UL\t&long_unsigned_type_node\n-#define T_US\t&short_unsigned_type_node\n-#define T_F\t&float_type_node\n-#define T_D\t&double_type_node\n-#define T_LD\t&long_double_type_node\n-#define T_C\t&char_type_node\n-#define T_V\t&void_type_node\n-#define T_W\t&wchar_type_node\n-\n-typedef struct\n-{\n-  char *format_chars;\n-  int pointer_count;\n-  /* Type of argument if no length modifier is used.  */\n-  tree *nolen;\n-  /* Type of argument if length modifier for shortening is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *hlen;\n-  /* Type of argument if length modifier `l' is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *llen;\n-  /* Type of argument if length modifier `L' is used.\n-     If NULL, then this modifier is not allowed.  */\n-  tree *bigllen;\n-  /* List of other modifier characters allowed with these options.  */\n-  char *flag_chars;\n-} format_char_info;\n-\n-static format_char_info print_table[]\n-  = {\n-      { \"di\",\t\t0,\tT_I,\tT_I,\tT_L,\tNULL,\t\"-wp0 +\" },\n-      { \"oxX\",\t\t0,\tT_UI,\tT_UI,\tT_UL,\tNULL,\t\"-wp0#\" },\n-      { \"u\",\t\t0,\tT_UI,\tT_UI,\tT_UL,\tNULL,\t\"-wp0\" },\n-      { \"feEgG\",\t0,\tT_D,\tNULL,\tNULL,\tT_LD,\t\"-wp0 +#\" },\n-      { \"c\",\t\t0,\tT_I,\tNULL,\tT_W,\tNULL,\t\"-w\" },\n-      { \"C\",\t\t0,\tT_W,\tNULL,\tNULL,\tNULL,\t\"-w\" },\n-      { \"s\",\t\t1,\tT_C,\tNULL,\tT_W,\tNULL,\t\"-wp\" },\n-      { \"S\",\t\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"-wp\" },\n-      { \"p\",\t\t1,\tT_V,\tNULL,\tNULL,\tNULL,\t\"-w\" },\n-      { \"n\",\t\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"\" },\n-      { NULL }\n-    };\n-\n-static format_char_info scan_table[]\n-  = {\n-      { \"di\",\t\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"*\" },\n-      { \"ouxX\",\t\t1,\tT_UI,\tT_US,\tT_UL,\tNULL,\t\"*\" },\t\n-      { \"efgEG\",\t1,\tT_F,\tNULL,\tT_D,\tT_LD,\t\"*\" },\n-      { \"sc\",\t\t1,\tT_C,\tNULL,\tT_W,\tNULL,\t\"*\" },\n-      { \"[\",\t\t1,\tT_C,\tNULL,\tNULL,\tNULL,\t\"*\" },\n-      { \"C\",\t\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"*\" },\n-      { \"S\",\t\t1,\tT_W,\tNULL,\tNULL,\tNULL,\t\"*\" },\n-      { \"p\",\t\t2,\tT_V,\tNULL,\tNULL,\tNULL,\t\"*\" },\n-      { \"n\",\t\t1,\tT_I,\tT_S,\tT_L,\tNULL,\t\"\" },\n-      { NULL }\n-    };\n-\n-typedef struct\n-{\n-  tree function_ident;\t\t/* identifier such as \"printf\" */\n-  int is_scan;\t\t\t/* TRUE if *scanf */\n-  int format_num;\t\t/* number of format argument */\n-  int first_arg_num;\t\t/* number of first arg (zero for varargs) */\n-} function_info;\n-\n-static unsigned int function_info_entries = 0;\n-static function_info *function_info_table = NULL;\n-\n-/* Record information for argument format checking.  FUNCTION_IDENT is\n-   the identifier node for the name of the function to check (its decl\n-   need not exist yet).  IS_SCAN is true for scanf-type format checking;\n-   false indicates printf-style format checking.  FORMAT_NUM is the number\n-   of the argument which is the format control string (starting from 1).\n-   FIRST_ARG_NUM is the number of the first actual argument to check\n-   against teh format string, or zero if no checking is not be done\n-   (e.g. for varargs such as vfprintf).  */\n-\n-void\n-record_format_info (function_ident, is_scan, format_num, first_arg_num)\n-      tree function_ident;\n-      int is_scan;\n-      int format_num;\n-      int first_arg_num;\n-{\n-  function_info *info;\n-  \n-  function_info_entries++;\n-  if (function_info_table)\n-    function_info_table\n-      = (function_info *) xrealloc (function_info_table,\n-\t\t\t\t    function_info_entries * sizeof (function_info));\n-  else\n-    function_info_table = (function_info *) xmalloc (sizeof (function_info));\n-\n-  info = &function_info_table[function_info_entries - 1];\n-  \n-  info->function_ident = function_ident;\n-  info->is_scan = is_scan;\n-  info->format_num = format_num;\n-  info->first_arg_num = first_arg_num;\n-}\n-\n-/* Initialize the table of functions to perform format checking on.\n-   The ANSI functions are always checked (whether <stdio.h> is\n-   included or not), since it is common to call printf without\n-   including <stdio.h>.  There shouldn't be a problem with this,\n-   since ANSI reserves these function names whether you include the\n-   header file or not.  In any case, the checking is harmless.  */\n-\n-void\n-init_format_info_table ()\n-{\n-  record_format_info (get_identifier (\"printf\"), 0, 1, 2);\n-  record_format_info (get_identifier (\"fprintf\"), 0, 2, 3);\n-  record_format_info (get_identifier (\"sprintf\"), 0, 2, 3);\n-  record_format_info (get_identifier (\"scanf\"), 1, 1, 2);\n-  record_format_info (get_identifier (\"fscanf\"), 1, 2, 3);\n-  record_format_info (get_identifier (\"sscanf\"), 1, 2, 3);\n-  record_format_info (get_identifier (\"vprintf\"), 0, 1, 0);\n-  record_format_info (get_identifier (\"vfprintf\"), 0, 2, 0);\n-  record_format_info (get_identifier (\"vsprintf\"), 0, 2, 0);\n-}\n-\n-static char\ttfaff[] = \"too few arguments for format\";\n-\f\n-/* Check the argument list of a call to printf, scanf, etc.\n-   INFO points to the element of function_info_table.\n-   PARAMS is the list of argument values.  */\n-\n-static void\n-check_format (info, params)\n-     function_info *info;\n-     tree params;\n-{\n-  int i;\n-  int arg_num;\n-  int suppressed, wide, precise;\n-  int length_char;\n-  int format_char;\n-  int format_length;\n-  tree format_tree;\n-  tree cur_param;\n-  tree cur_type;\n-  tree wanted_type;\n-  char *format_chars;\n-  format_char_info *fci;\n-  static char message[132];\n-  char flag_chars[8];\n-\n-  /* Skip to format argument.  If the argument isn't available, there's\n-     no work for us to do; prototype checking will catch the problem.  */\n-  for (arg_num = 1; ; ++arg_num)\n-    {\n-      if (params == 0)\n-\treturn;\n-      if (arg_num == info->format_num)\n-\tbreak;\n-      params = TREE_CHAIN (params);\n-    }\n-  format_tree = TREE_VALUE (params);\n-  params = TREE_CHAIN (params);\n-  if (format_tree == 0)\n-    return;\n-  /* We can only check the format if it's a string constant.  */\n-  while (TREE_CODE (format_tree) == NOP_EXPR)\n-    format_tree = TREE_OPERAND (format_tree, 0); /* strip coercion */\n-  if (format_tree == null_pointer_node)\n-    {\n-      warning (\"null format string\");\n-      return;\n-    }\n-  if (TREE_CODE (format_tree) != ADDR_EXPR)\n-    return;\n-  format_tree = TREE_OPERAND (format_tree, 0);\n-  if (TREE_CODE (format_tree) != STRING_CST)\n-    return;\n-  format_chars = TREE_STRING_POINTER (format_tree);\n-  format_length = TREE_STRING_LENGTH (format_tree);\n-  if (format_length <= 1)\n-    warning (\"zero-length format string\");\n-  if (format_chars[--format_length] != 0)\n-    {\n-      warning (\"unterminated format string\");\n-      return;\n-    }\n-  /* Skip to first argument to check.  */\n-  while (arg_num + 1 < info->first_arg_num)\n-    {\n-      if (params == 0)\n-\treturn;\n-      params = TREE_CHAIN (params);\n-      ++arg_num;\n-    }\n-  while (1)\n-    {\n-      if (*format_chars == 0)\n-\t{\n-\t  if (format_chars - TREE_STRING_POINTER (format_tree) != format_length)\n-\t    warning (\"embedded `\\\\0' in format\");\n-\t  if (info->first_arg_num != 0 && params != 0)\n-\t    warning (\"too many arguments for format\");\n-\t  return;\n-\t}\n-      if (*format_chars++ != '%')\n-\tcontinue;\n-      if (*format_chars == 0)\n-\t{\n-\t  warning (\"spurious trailing `%%' in format\");\n-\t  continue;\n-\t}\n-      if (*format_chars == '%')\n-\t{\n-\t  ++format_chars;\n-\t  continue;\n-\t}\n-      flag_chars[0] = 0;\n-      suppressed = wide = precise = FALSE;\n-      if (info->is_scan)\n-\t{\n-\t  suppressed = *format_chars == '*';\n-\t  if (suppressed)\n-\t    ++format_chars;\n-\t  while (ISDIGIT (*format_chars))\n-\t    ++format_chars;\n-\t}\n-      else\n-\t{\n-\t  while (*format_chars != 0 && index (\" +#0-\", *format_chars) != 0)\n-\t    {\n-\t      if (index (flag_chars, *format_chars) != 0)\n-\t\t{\n-\t\t  sprintf (message, \"repeated `%c' flag in format\",\n-\t\t\t   *format_chars);\n-\t\t  warning (message);\n-\t\t}\n-\t      i = strlen (flag_chars);\n-\t      flag_chars[i++] = *format_chars++;\n-\t      flag_chars[i] = 0;\n-\t    }\n-\t  /* \"If the space and + flags both appear, \n-\t     the space flag will be ignored.\"  */\n-\t  if (index (flag_chars, ' ') != 0\n-\t      && index (flag_chars, '+') != 0)\n-\t    warning (\"use of both ` ' and `+' flags in format\");\n-\t  /* \"If the 0 and - flags both appear,\n-\t     the 0 flag will be ignored.\"  */\n-\t  if (index (flag_chars, '0') != 0\n-\t      && index (flag_chars, '-') != 0)\n-\t    warning (\"use of both `0' and `-' flags in format\");\n-\t  if (*format_chars == '*')\n-\t    {\n-\t      wide = TRUE;\n-\t      /* \"...a field width...may be indicated by an asterisk.\n-\t\t In this case, an int argument supplies the field width...\"  */\n-\t      ++format_chars;\n-\t      if (params == 0)\n-\t\t{\n-\t\t  warning (tfaff);\n-\t\t  return;\n-\t\t}\n-\t      if (info->first_arg_num != 0)\n-\t\t{\n-\t\t  cur_param = TREE_VALUE (params);\n-\t\t  params = TREE_CHAIN (params);\n-\t\t  ++arg_num;\n-\t\t  /* size_t is generally not valid here.\n-\t\t     It will work on most machines, because size_t and int\n-\t\t     have the same mode.  But might as well warn anyway,\n-\t\t     since it will fail on other machines.  */\n-\t\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n-\t\t      != integer_type_node)\n-\t\t    {\n-\t\t      sprintf (message,\n-\t\t\t       \"field width is not type int (arg %d)\",\n-\t\t\t       arg_num);\n-\t\t      warning (message);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      while (ISDIGIT (*format_chars))\n-\t\t{\n-\t\t  wide = TRUE;\n-\t\t  ++format_chars;\n-\t\t}\n-\t    }\n-\t  if (*format_chars == '.')\n-\t    {\n-\t      precise = TRUE;\n-\t      ++format_chars;\n-\t      if (*format_chars != '*' && !ISDIGIT (*format_chars))\n-\t\twarning (\"`.' not followed by `*' or digit in format\");\n-\t      /* \"...a...precision...may be indicated by an asterisk.\n-\t\t In this case, an int argument supplies the...precision.\"  */\n-\t      if (*format_chars == '*')\n-\t\t{\n-\t\t  if (info->first_arg_num != 0)\n-\t\t    {\n-\t\t      ++format_chars;\n-\t\t      if (params == 0)\n-\t\t        {\n-\t\t\t  warning (tfaff);\n-\t\t\t  return;\n-\t\t\t}\n-\t\t      cur_param = TREE_VALUE (params);\n-\t\t      params = TREE_CHAIN (params);\n-\t\t      ++arg_num;\n-\t\t      if (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))\n-\t\t\t  != integer_type_node)\n-\t\t        {\n-\t\t          sprintf (message,\n-\t\t\t\t   \"field width is not type int (arg %d)\",\n-\t\t\t\t   arg_num);\n-\t\t          warning (message);\n-\t\t        }\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  while (ISDIGIT (*format_chars))\n-\t\t    ++format_chars;\n-\t\t}\n-\t    }\n-\t}\n-      if (*format_chars == 'h' || *format_chars == 'l' || *format_chars == 'L')\n-\tlength_char = *format_chars++;\n-      else\n-\tlength_char = 0;\n-      if (suppressed && length_char != 0)\n-\t{\n-\t  sprintf (message,\n-\t\t   \"use of `*' and `%c' together in format\",\n-\t\t   length_char);\n-\t  warning (message);\n-\t}\n-      format_char = *format_chars;\n-      if (format_char == 0)\n-\t{\n-\t  warning (\"conversion lacks type at end of format\");\n-\t  continue;\n-\t}\n-      format_chars++;\n-      fci = info->is_scan ? scan_table : print_table;\n-      while (1)\n-\t{\n-\t  if (fci->format_chars == 0\n-\t      || index (fci->format_chars, format_char) != 0)\n-\t    break;\n-\t  ++fci;\n-\t}\n-      if (fci->format_chars == 0)\n-\t{\n-\t  if (format_char >= 040 && format_char < 0177)\n-\t    sprintf (message,\n-\t\t     \"unknown conversion type character `%c' in format\",\n-\t\t     format_char);\n-\t  else\n-\t    sprintf (message,\n-\t\t     \"unknown conversion type character 0x%x in format\",\n-\t\t     format_char);\n-\t  warning (message);\n-\t  continue;\n-\t}\n-      if (wide && index (fci->flag_chars, 'w') == 0)\n-\t{\n-\t  sprintf (message, \"width used with `%c' format\",\n-\t\t   format_char);\n-\t  warning (message);\n-\t}\n-      if (precise && index (fci->flag_chars, 'p') == 0)\n-\t{\n-\t  sprintf (message, \"precision used with `%c' format\",\n-\t\t   format_char);\n-\t  warning (message);\n-\t}\n-      if (info->is_scan && format_char == '[')\n-\t{\n-\t  /* Skip over scan set, in case it happens to have '%' in it.  */\n-\t  if (*format_chars == '^')\n-\t    ++format_chars;\n-\t  /* Find closing bracket; if one is hit immediately, then\n-\t     it's part of the scan set rather than a terminator.  */\n-\t  if (*format_chars == ']')\n-\t    ++format_chars;\n-\t  while (*format_chars && *format_chars != ']')\n-\t    ++format_chars;\n-\t  if (*format_chars != ']')\n-\t      /* The end of the format string was reached.  */\n-\t      warning (\"no closing `]' for `%%[' format\");\n-\t}\n-      if (suppressed)\n-\t{\n-\t  if (index (fci->flag_chars, '*') == 0)\n-\t    {\n-\t      sprintf (message,\n-\t\t       \"suppression of `%c' conversion in format\",\n-\t\t       format_char);\n-\t      warning (message);\n-\t    }\n-\t  continue;\n-\t}\n-      for (i = 0; flag_chars[i] != 0; ++i)\n-\t{\n-\t  if (index (fci->flag_chars, flag_chars[i]) == 0)\n-\t    {\n-\t      sprintf (message, \"flag `%c' used with type `%c'\",\n-\t\t       flag_chars[i], format_char);\n-\t      warning (message);\n-\t    }\n-\t}\n-      if (precise && index (flag_chars, '0') != 0\n-\t  && (format_char == 'd' || format_char == 'i'\n-\t      || format_char == 'o' || format_char == 'u'\n-\t      || format_char == 'x' || format_char == 'x'))\n-\t{\n-\t  sprintf (message,\n-\t\t   \"precision and `0' flag not both allowed with `%c' format\",\n-\t\t   format_char);\n-\t  warning (message);\n-\t}\n-      switch (length_char)\n-\t{\n-\tdefault: wanted_type = fci->nolen ? *(fci->nolen) : 0; break;\n-\tcase 'h': wanted_type = fci->hlen ? *(fci->hlen) : 0; break;\n-\tcase 'l': wanted_type = fci->llen ? *(fci->llen) : 0; break;\n-\tcase 'L': wanted_type = fci->bigllen ? *(fci->bigllen) : 0; break;\n-\t}\n-      if (wanted_type == 0)\n-\t{\n-\t  sprintf (message,\n-\t\t   \"use of `%c' length character with `%c' type character\",\n-\t\t   length_char, format_char);\n-\t  warning (message);\n-\t}\n-\n-      /*\n-       ** XXX -- should kvetch about stuff such as\n-       **\t{\n-       **\t\tconst int\ti;\n-       **\n-       **\t\tscanf (\"%d\", &i);\n-       **\t}\n-       */\n-\n-      /* Finally. . .check type of argument against desired type!  */\n-      if (info->first_arg_num == 0)\n-\tcontinue;\n-      if (params == 0)\n-\t{\n-\t  warning (tfaff);\n-\t  return;\n-\t}\n-      cur_param = TREE_VALUE (params);\n-      params = TREE_CHAIN (params);\n-      ++arg_num;\n-      cur_type = TREE_TYPE (cur_param);\n-\n-      /* Check the types of any additional pointer arguments\n-\t that precede the \"real\" argument.  */\n-      for (i = 0; i < fci->pointer_count; ++i)\n-\t{\n-\t  if (TREE_CODE (cur_type) == POINTER_TYPE)\n-\t    {\n-\t      cur_type = TREE_TYPE (cur_type);\n-\t      continue;\n-\t    }\n-\t  sprintf (message,\n-\t\t   \"format argument is not a %s (arg %d)\",\n-\t\t   ((fci->pointer_count == 1) ? \"pointer\" : \"pointer to a pointer\"),\n-\t\t   arg_num);\n-\t  warning (message);\n-\t  break;\n-\t}\n-\n-      /* Check the type of the \"real\" argument, if there's a type we want.  */\n-      if (i == fci->pointer_count && wanted_type != 0\n-\t  && wanted_type != TYPE_MAIN_VARIANT (cur_type)\n-\t  /* If we want `void *', allow any pointer type.\n-\t     (Anything else would already have got a warning.)  */\n-\t  && ! (wanted_type == void_type_node\n-\t\t&& fci->pointer_count > 0)\n-\t  /* Don't warn about differences merely in signedness.  */\n-\t  && !(TREE_CODE (wanted_type) == INTEGER_TYPE\n-\t       && TREE_CODE (cur_type) == INTEGER_TYPE\n-\t       && (wanted_type == (TREE_UNSIGNED (wanted_type)\n-\t\t\t\t   ? unsigned_type : signed_type) (cur_type))))\n-\t{\n-\t  register char *this;\n-\t  register char *that;\n-  \n-\t  this = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n-\t  that = 0;\n-\t  if (TREE_CODE (cur_type) != ERROR_MARK\n-\t      && TYPE_NAME (cur_type) != 0\n-\t      && TREE_CODE (cur_type) != INTEGER_TYPE\n-\t      && !(TREE_CODE (cur_type) == POINTER_TYPE\n-\t\t   && TREE_CODE (TREE_TYPE (cur_type)) == INTEGER_TYPE))\n-\t    {\n-\t      if (TREE_CODE (TYPE_NAME (cur_type)) == TYPE_DECL\n-\t\t  && DECL_NAME (TYPE_NAME (cur_type)) != 0)\n-\t\tthat = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (cur_type)));\n-\t      else\n-\t\tthat = IDENTIFIER_POINTER (TYPE_NAME (cur_type));\n-\t    }\n-\n-\t  /* A nameless type can't possibly match what the format wants.\n-\t     So there will be a warning for it.\n-\t     Make up a string to describe vaguely what it is.  */\n-\t  if (that == 0)\n-\t    {\n-\t      if (TREE_CODE (cur_type) == POINTER_TYPE)\n-\t\tthat = \"pointer\";\n-\t      else\n-\t\tthat = \"different type\";\n-\t    }\n-\n-\t  if (strcmp (this, that) != 0)\n-\t    {\n-\t      sprintf (message, \"%s format, %s arg (arg %d)\",\n-\t\t\tthis, that, arg_num);\n-\t      warning (message);\n-\t    }\n-\t}\n-    }\n-}\n-\f\n /* Build a function call to function FUNCTION with parameters PARAMS.\n    PARAMS is a list--a chain of TREE_LIST nodes--in which the\n    TREE_VALUE of each node is a parameter-expression.\n@@ -1949,7 +1414,7 @@ build_function_call (function, params)\n {\n   register tree fntype, fundecl;\n   register tree coerced_params;\n-  tree name = NULL_TREE;\n+  tree name = NULL_TREE, assembler_name = NULL_TREE;\n \n   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n   STRIP_TYPE_NOPS (function);\n@@ -1958,6 +1423,8 @@ build_function_call (function, params)\n   if (TREE_CODE (function) == FUNCTION_DECL)\n     {\n       name = DECL_NAME (function);\n+      assembler_name = DECL_ASSEMBLER_NAME (function);\n+\n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n \t (because calling an inline function does not mean the function\n \t needs to be separately compiled).  */\n@@ -1992,21 +1459,9 @@ build_function_call (function, params)\n     = convert_arguments (TYPE_ARG_TYPES (fntype), params, name, fundecl);\n \n   /* Check for errors in format strings.  */\n-  if (warn_format && name != 0)\n-    {\n-      unsigned int i;\n-\n-      /* See if this function is a format function.  */\n-      for (i = 0; i < function_info_entries; i++)\n-\tif (function_info_table[i].function_ident == name)\n-\t  {\n-\t    register char *message;\n \n-\t    /* If so, check it.  */\n-\t    check_format (&function_info_table[i], coerced_params);\n-\t    break;\n-\t  }\n-    }\n+  if (warn_format && (name || assembler_name))\n+    check_function_format (name, assembler_name, coerced_params);\n \n   /* Recognize certain built-in functions so we can make tree-codes\n      other than CALL_EXPR.  We do this when it enables fold-const.c"}]}