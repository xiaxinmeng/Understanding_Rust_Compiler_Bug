{"sha": "d8474337a0b2bf1b3c84863957cef1da92811ffe", "node_id": "C_kwDOANBUbNoAKGQ4NDc0MzM3YTBiMmJmMWIzYzg0ODYzOTU3Y2VmMWRhOTI4MTFmZmU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-05-22T18:17:39Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-01T09:09:32Z"}, "message": "Revamp irange_allocator to handle vranges.\n\nThis patch revamps the range allocator to handle generic vrange's.\nI've cleaned it up somehow to make it obvious the various things you\ncan allocate with it.  I've also moved away from overloads into\ndistinct names when appropriate.\n\nThe various entry points are now:\n\n  // Allocate a range of TYPE.\n  vrange *alloc_vrange (tree type);\n  // Allocate a memory block of BYTES.\n  void *alloc (unsigned bytes);\n  // Return a clone of SRC.\n  template <typename T> T *clone (const T &src);\n\nIt is now possible to allocate a clone of an irange, or any future\nrange types:\n\n      irange *i = allocator.clone <irange> (some_irange);\n      frange *f = allocator.clone <frange> (some_frange);\n\nYou can actually do so without the <>, but I find it clearer to\nspecify the vrange type.\n\nSo with it you can allocate a specific range type, or vrange, or a\nblock of memory.\n\nI have rewritten the C style casts to C++ casts, since casts tend to\nbe hints of problematic designs.  With the C++ casts you can at least\ngrep for them easier.  Speak of which, the next patch, which converts\nranger to vrange, will further clean this space by removing some\nunnecessary casts.\n\nTested on x86-64 Linux and ppc64le Linux.\n\n\t* gimple-range-cache.cc (sbr_vector::sbr_vector): Adjust for\n\tvrange allocator.\n\t(sbr_vector::grow): Same.\n\t(sbr_vector::set_bb_range): Same.\n\t(sbr_sparse_bitmap::sbr_sparse_bitmap): Same.\n\t(sbr_sparse_bitmap::set_bb_range): Same.\n\t(block_range_cache::~block_range_cache): Same.\n\t(block_range_cache::set_bb_range): Same.\n\t(ssa_global_cache::ssa_global_cache): Same.\n\t(ssa_global_cache::~ssa_global_cache): Same.\n\t(ssa_global_cache::set_global_range): Same.\n\t* gimple-range-cache.h (block_range_cache): Same.\n\t(ssa_global_cache): Same.\n\t* gimple-range-edge.cc\n\t(gimple_outgoing_range::calc_switch_ranges): Same.\n\t* gimple-range-edge.h (gimple_outgoing_range): Same.\n\t* gimple-range-infer.cc (infer_range_manager::get_nonzero):\n\tSame.\n\t(infer_range_manager::add_range): Same.\n\t* gimple-range-infer.h (class infer_range_manager): Same.\n\t* value-range.h (class irange_allocator): Rename to...\n\t(class vrange_allocator): ...this.\n\t(irange_allocator::irange_allocator): New.\n\t(vrange_allocator::vrange_allocator): New.\n\t(irange_allocator::~irange_allocator): New.\n\t(vrange_allocator::~vrange_allocator): New.\n\t(irange_allocator::get_memory): Rename to...\n\t(vrange_allocator::alloc): ...this.\n\t(vrange_allocator::alloc_vrange): Rename from...\n\t(irange_allocator::allocate): ...this.\n\t(vrange_allocator::alloc_irange): New.", "tree": {"sha": "9362ae8a8d6e626b9ae8b9519b2720a79e840b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9362ae8a8d6e626b9ae8b9519b2720a79e840b68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8474337a0b2bf1b3c84863957cef1da92811ffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8474337a0b2bf1b3c84863957cef1da92811ffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8474337a0b2bf1b3c84863957cef1da92811ffe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8474337a0b2bf1b3c84863957cef1da92811ffe/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5bea76f9d84f6218f0a5085db63a50aed9d95a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf5bea76f9d84f6218f0a5085db63a50aed9d95a"}], "stats": {"total": 162, "additions": 96, "deletions": 66}, "files": [{"sha": "25ade1300aff401cb2c548a9f70ab87cf3271bff", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=d8474337a0b2bf1b3c84863957cef1da92811ffe", "patch": "@@ -75,7 +75,7 @@ ssa_block_ranges::dump (FILE *f)\n class sbr_vector : public ssa_block_ranges\n {\n public:\n-  sbr_vector (tree t, irange_allocator *allocator);\n+  sbr_vector (tree t, vrange_allocator *allocator);\n \n   virtual bool set_bb_range (const_basic_block bb, const irange &r) override;\n   virtual bool get_bb_range (irange &r, const_basic_block bb) override;\n@@ -86,20 +86,21 @@ class sbr_vector : public ssa_block_ranges\n   int_range<2> m_varying;\n   int_range<2> m_undefined;\n   tree m_type;\n-  irange_allocator *m_irange_allocator;\n+  vrange_allocator *m_range_allocator;\n   void grow ();\n };\n \n \n // Initialize a block cache for an ssa_name of type T.\n \n-sbr_vector::sbr_vector (tree t, irange_allocator *allocator)\n+sbr_vector::sbr_vector (tree t, vrange_allocator *allocator)\n {\n   gcc_checking_assert (TYPE_P (t));\n   m_type = t;\n-  m_irange_allocator = allocator;\n+  m_range_allocator = allocator;\n   m_tab_size = last_basic_block_for_fn (cfun) + 1;\n-  m_tab = (irange **)allocator->get_memory (m_tab_size * sizeof (irange *));\n+  m_tab = static_cast <irange **>\n+    (allocator->alloc (m_tab_size * sizeof (irange *)));\n   memset (m_tab, 0, m_tab_size * sizeof (irange *));\n \n   // Create the cached type range.\n@@ -121,8 +122,8 @@ sbr_vector::grow ()\n   int new_size = inc + curr_bb_size;\n \n   // Allocate new memory, copy the old vector and clear the new space.\n-  irange **t = (irange **)m_irange_allocator->get_memory (new_size\n-\t\t\t\t\t\t\t  * sizeof (irange *));\n+  irange **t = static_cast <irange **>\n+    (m_range_allocator->alloc (new_size * sizeof (irange *)));\n   memcpy (t, m_tab, m_tab_size * sizeof (irange *));\n   memset (t + m_tab_size, 0, (new_size - m_tab_size) * sizeof (irange *));\n \n@@ -143,7 +144,7 @@ sbr_vector::set_bb_range (const_basic_block bb, const irange &r)\n   else if (r.undefined_p ())\n     m = &m_undefined;\n   else\n-    m = m_irange_allocator->allocate (r);\n+    m = m_range_allocator->clone (r);\n   m_tab[bb->index] = m;\n   return true;\n }\n@@ -191,38 +192,40 @@ sbr_vector::bb_range_p (const_basic_block bb)\n class sbr_sparse_bitmap : public ssa_block_ranges\n {\n public:\n-  sbr_sparse_bitmap (tree t, irange_allocator *allocator, bitmap_obstack *bm);\n+  sbr_sparse_bitmap (tree t, vrange_allocator *allocator, bitmap_obstack *bm);\n   virtual bool set_bb_range (const_basic_block bb, const irange &r) override;\n   virtual bool get_bb_range (irange &r, const_basic_block bb) override;\n   virtual bool bb_range_p (const_basic_block bb) override;\n private:\n   void bitmap_set_quad (bitmap head, int quad, int quad_value);\n   int bitmap_get_quad (const_bitmap head, int quad);\n-  irange_allocator *m_irange_allocator;\n+  vrange_allocator *m_range_allocator;\n   irange *m_range[SBR_NUM];\n   bitmap_head bitvec;\n   tree m_type;\n };\n \n // Initialize a block cache for an ssa_name of type T.\n \n-sbr_sparse_bitmap::sbr_sparse_bitmap (tree t, irange_allocator *allocator,\n-\t\t\t\tbitmap_obstack *bm)\n+sbr_sparse_bitmap::sbr_sparse_bitmap (tree t, vrange_allocator *allocator,\n+\t\t\t\t      bitmap_obstack *bm)\n {\n   gcc_checking_assert (TYPE_P (t));\n   m_type = t;\n   bitmap_initialize (&bitvec, bm);\n   bitmap_tree_view (&bitvec);\n-  m_irange_allocator = allocator;\n+  m_range_allocator = allocator;\n   // Pre-cache varying.\n-  m_range[0] = m_irange_allocator->allocate (2);\n+  m_range[0] = static_cast <irange *> (m_range_allocator->alloc_vrange (t));\n   m_range[0]->set_varying (t);\n   // Pre-cache zero and non-zero values for pointers.\n   if (POINTER_TYPE_P (t))\n     {\n-      m_range[1] = m_irange_allocator->allocate (2);\n+      m_range[1]\n+\t= static_cast <irange *> (m_range_allocator->alloc_vrange (t));\n       m_range[1]->set_nonzero (t);\n-      m_range[2] = m_irange_allocator->allocate (2);\n+      m_range[2]\n+\t= static_cast <irange *> (m_range_allocator->alloc_vrange (t));\n       m_range[2]->set_zero (t);\n     }\n   else\n@@ -267,7 +270,7 @@ sbr_sparse_bitmap::set_bb_range (const_basic_block bb, const irange &r)\n     if (!m_range[x] || r == *(m_range[x]))\n       {\n \tif (!m_range[x])\n-\t  m_range[x] = m_irange_allocator->allocate (r);\n+\t  m_range[x] = m_range_allocator->clone (r);\n \tbitmap_set_quad (&bitvec, bb->index, x + 1);\n \treturn true;\n       }\n@@ -312,14 +315,14 @@ block_range_cache::block_range_cache ()\n   bitmap_obstack_initialize (&m_bitmaps);\n   m_ssa_ranges.create (0);\n   m_ssa_ranges.safe_grow_cleared (num_ssa_names);\n-  m_irange_allocator = new irange_allocator;\n+  m_range_allocator = new vrange_allocator;\n }\n \n // Remove any m_block_caches which have been created.\n \n block_range_cache::~block_range_cache ()\n {\n-  delete m_irange_allocator;\n+  delete m_range_allocator;\n   // Release the vector itself.\n   m_ssa_ranges.release ();\n   bitmap_obstack_release (&m_bitmaps);\n@@ -341,17 +344,17 @@ block_range_cache::set_bb_range (tree name, const_basic_block bb,\n       // Use sparse representation if there are too many basic blocks.\n       if (last_basic_block_for_fn (cfun) > param_evrp_sparse_threshold)\n \t{\n-\t  void *r = m_irange_allocator->get_memory (sizeof (sbr_sparse_bitmap));\n+\t  void *r = m_range_allocator->alloc (sizeof (sbr_sparse_bitmap));\n \t  m_ssa_ranges[v] = new (r) sbr_sparse_bitmap (TREE_TYPE (name),\n-\t\t\t\t\t\t       m_irange_allocator,\n+\t\t\t\t\t\t       m_range_allocator,\n \t\t\t\t\t\t       &m_bitmaps);\n \t}\n       else\n \t{\n \t  // Otherwise use the default vector implemntation.\n-\t  void *r = m_irange_allocator->get_memory (sizeof (sbr_vector));\n+\t  void *r = m_range_allocator->alloc (sizeof (sbr_vector));\n \t  m_ssa_ranges[v] = new (r) sbr_vector (TREE_TYPE (name),\n-\t\t\t\t\t\tm_irange_allocator);\n+\t\t\t\t\t\tm_range_allocator);\n \t}\n     }\n   return m_ssa_ranges[v]->set_bb_range (bb, r);\n@@ -467,15 +470,15 @@ block_range_cache::dump (FILE *f, basic_block bb, bool print_varying)\n ssa_global_cache::ssa_global_cache ()\n {\n   m_tab.create (0);\n-  m_irange_allocator = new irange_allocator;\n+  m_range_allocator = new vrange_allocator;\n }\n \n // Deconstruct a global cache.\n \n ssa_global_cache::~ssa_global_cache ()\n {\n   m_tab.release ();\n-  delete m_irange_allocator;\n+  delete m_range_allocator;\n }\n \n // Retrieve the global range of NAME from cache memory if it exists. \n@@ -509,7 +512,7 @@ ssa_global_cache::set_global_range (tree name, const irange &r)\n   if (m && m->fits_p (r))\n     *m = r;\n   else\n-    m_tab[v] = m_irange_allocator->allocate (r);\n+    m_tab[v] = m_range_allocator->clone (r);\n   return m != NULL;\n }\n "}, {"sha": "73d12f35abe8200cfaed80144ef918edda9eb933", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=d8474337a0b2bf1b3c84863957cef1da92811ffe", "patch": "@@ -44,7 +44,7 @@ class block_range_cache\n   vec<class ssa_block_ranges *> m_ssa_ranges;\n   ssa_block_ranges &get_block_ranges (tree name);\n   ssa_block_ranges *query_block_ranges (tree name);\n-  irange_allocator *m_irange_allocator;\n+  vrange_allocator *m_range_allocator;\n   bitmap_obstack m_bitmaps;\n };\n \n@@ -64,7 +64,7 @@ class ssa_global_cache\n   void dump (FILE *f = stderr);\n private:\n   vec<irange *> m_tab;\n-  class irange_allocator *m_irange_allocator;\n+  vrange_allocator *m_range_allocator;\n };\n \n // This class provides all the caches a global ranger may need, and makes "}, {"sha": "5264e627c9a5993fb618d5fc4e5167b4ba3bc50d", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=d8474337a0b2bf1b3c84863957cef1da92811ffe", "patch": "@@ -166,13 +166,13 @@ gimple_outgoing_range::calc_switch_ranges (gswitch *sw)\n       // If there was an existing range and it doesn't fit, we lose the memory.\n       // It'll get reclaimed when the obstack is freed.  This seems less\n       // intrusive than allocating max ranges for each case.\n-      slot = m_range_allocator.allocate (case_range);\n+      slot = m_range_allocator.clone <irange> (case_range);\n     }\n \n   irange *&slot = m_edge_table->get_or_insert (default_edge, &existed);\n   // This should be the first call into this switch.\n   gcc_checking_assert (!existed);\n-  irange *dr = m_range_allocator.allocate (default_range);\n+  irange *dr = m_range_allocator.clone <irange> (default_range);\n   slot = dr;\n }\n "}, {"sha": "ce383b0aa6fd1e99841388bb0db9a38c89fd3712", "filename": "gcc/gimple-range-edge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-edge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-edge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.h?ref=d8474337a0b2bf1b3c84863957cef1da92811ffe", "patch": "@@ -47,7 +47,7 @@ class gimple_outgoing_range\n \n   int m_max_edges;\n   hash_map<edge, irange *> *m_edge_table;\n-  irange_allocator m_range_allocator;\n+  vrange_allocator m_range_allocator;\n };\n \n // If there is a range control statement at the end of block BB, return it."}, {"sha": "14ddfb803d81b427f5742b220d9b49e36524818d", "filename": "gcc/gimple-range-infer.cc", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-infer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-infer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.cc?ref=d8474337a0b2bf1b3c84863957cef1da92811ffe", "patch": "@@ -189,8 +189,10 @@ infer_range_manager::get_nonzero (tree name)\n     m_nonzero.safe_grow_cleared (num_ssa_names + 20);\n   if (!m_nonzero[v])\n     {\n-      m_nonzero[v] = m_range_allocator.allocate (2);\n-      m_nonzero[v]->set_nonzero (TREE_TYPE (name));\n+      tree type = TREE_TYPE (name);\n+      m_nonzero[v]\n+\t= static_cast <irange *> (m_range_allocator.alloc_vrange (type));\n+      m_nonzero[v]->set_nonzero (type);\n     }\n   return *(m_nonzero[v]);\n }\n@@ -259,14 +261,17 @@ infer_range_manager::add_range (tree name, basic_block bb, const irange &r)\n       if (ptr->range->fits_p (cur))\n \t*(ptr->range) = cur;\n       else\n-\tptr->range = m_range_allocator.allocate (cur);\n+\t{\n+\t  vrange &v = cur;\n+\t  ptr->range = static_cast <irange *> (m_range_allocator.clone (v));\n+\t}\n       return;\n     }\n \n   // Otherwise create a record.\n   bitmap_set_bit (m_on_exit[bb->index].m_names, SSA_NAME_VERSION (name));\n   ptr = (exit_range *)obstack_alloc (&m_list_obstack, sizeof (exit_range));\n-  ptr->range = m_range_allocator.allocate (r);\n+  ptr->range = m_range_allocator.clone (r);\n   ptr->name = name;\n   ptr->next = m_on_exit[bb->index].head;\n   m_on_exit[bb->index].head = ptr;"}, {"sha": "65f6e83809d03e11369c29b038fe434094445bc4", "filename": "gcc/gimple-range-infer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-infer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fgimple-range-infer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.h?ref=d8474337a0b2bf1b3c84863957cef1da92811ffe", "patch": "@@ -78,7 +78,7 @@ class infer_range_manager\n   bitmap m_seen;\n   bitmap_obstack m_bitmaps;\n   struct obstack m_list_obstack;\n-  irange_allocator m_range_allocator;\n+  vrange_allocator m_range_allocator;\n };\n \n #endif // GCC_GIMPLE_RANGE_SIDE_H"}, {"sha": "5cd0e0ef76a7b6faeb33c9a6b949f289f25aff3e", "filename": "gcc/value-range.h", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8474337a0b2bf1b3c84863957cef1da92811ffe/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=d8474337a0b2bf1b3c84863957cef1da92811ffe", "patch": "@@ -92,7 +92,7 @@ class vrange\n \n class GTY((user)) irange : public vrange\n {\n-  friend class irange_allocator;\n+  friend class vrange_allocator;\n public:\n   // In-place setters.\n   virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n@@ -897,56 +897,63 @@ vrp_val_min (const_tree type)\n   return NULL_TREE;\n }\n \n-// This is the irange storage class.  It is used to allocate the\n-// minimum amount of storage needed for a given irange.  Storage is\n-// automatically freed at destruction of the storage class.\n-//\n-// It is meant for long term storage, as opposed to int_range_max\n-// which is meant for intermediate temporary results on the stack.\n-//\n-// The newly allocated irange is initialized to the empty set\n-// (undefined_p() is true).\n+// This is the range storage class.  It is used to allocate the\n+// minimum amount of storage needed for a given range.  Storage is\n+// automatically freed at destruction of the class.\n \n-class irange_allocator\n+class vrange_allocator\n {\n public:\n-  irange_allocator ();\n-  ~irange_allocator ();\n-  // Return a new range with NUM_PAIRS.\n-  irange *allocate (unsigned num_pairs);\n-  // Return a copy of SRC with the minimum amount of sub-ranges needed\n-  // to represent it.\n-  irange *allocate (const irange &src);\n-  void *get_memory (unsigned num_bytes);\n+  vrange_allocator ();\n+  ~vrange_allocator ();\n+  // Allocate a range of TYPE.\n+  vrange *alloc_vrange (tree type);\n+  // Allocate a memory block of BYTES.\n+  void *alloc (unsigned bytes);\n+  // Return a clone of SRC.\n+  template <typename T> T *clone (const T &src);\n private:\n-  DISABLE_COPY_AND_ASSIGN (irange_allocator);\n+  irange *alloc_irange (unsigned pairs);\n+  DISABLE_COPY_AND_ASSIGN (vrange_allocator);\n   struct obstack m_obstack;\n };\n \n inline\n-irange_allocator::irange_allocator ()\n+vrange_allocator::vrange_allocator ()\n {\n   obstack_init (&m_obstack);\n }\n \n inline\n-irange_allocator::~irange_allocator ()\n+vrange_allocator::~vrange_allocator ()\n {\n   obstack_free (&m_obstack, NULL);\n }\n \n // Provide a hunk of memory from the obstack.\n+\n inline void *\n-irange_allocator::get_memory (unsigned num_bytes)\n+vrange_allocator::alloc (unsigned bytes)\n {\n-  void *r = obstack_alloc (&m_obstack, num_bytes);\n-  return r;\n+  return obstack_alloc (&m_obstack, bytes);\n+}\n+\n+// Return a new range to hold ranges of TYPE.  The newly allocated\n+// range is initialized to VR_UNDEFINED.\n+\n+inline vrange *\n+vrange_allocator::alloc_vrange (tree type)\n+{\n+  if (irange::supports_type_p (type))\n+    return alloc_irange (2);\n+\n+  gcc_unreachable ();\n }\n \n // Return a new range with NUM_PAIRS.\n \n inline irange *\n-irange_allocator::allocate (unsigned num_pairs)\n+vrange_allocator::alloc_irange (unsigned num_pairs)\n {\n   // Never allocate 0 pairs.\n   // Don't allocate 1 either, or we get legacy value_range's.\n@@ -956,17 +963,32 @@ irange_allocator::allocate (unsigned num_pairs)\n   size_t nbytes = sizeof (tree) * 2 * num_pairs;\n \n   // Allocate the irange and required memory for the vector.\n-  void *r = obstack_alloc (&m_obstack, sizeof (irange));\n-  tree *mem = (tree *) obstack_alloc (&m_obstack, nbytes);\n+  void *r = alloc (sizeof (irange));\n+  tree *mem = static_cast <tree *> (alloc (nbytes));\n   return new (r) irange (mem, num_pairs);\n }\n \n+// Return a clone of an irange.\n+\n+template <>\n inline irange *\n-irange_allocator::allocate (const irange &src)\n+vrange_allocator::clone <irange> (const irange &src)\n {\n-  irange *r = allocate (src.num_pairs ());\n+  irange *r = alloc_irange (src.num_pairs ());\n   *r = src;\n   return r;\n }\n \n+// Return a clone of a vrange.\n+\n+template <>\n+inline vrange *\n+vrange_allocator::clone <vrange> (const vrange &src)\n+{\n+  if (is_a <irange> (src))\n+    return clone <irange> (as_a <irange> (src));\n+\n+  gcc_unreachable ();\n+}\n+\n #endif // GCC_VALUE_RANGE_H"}]}