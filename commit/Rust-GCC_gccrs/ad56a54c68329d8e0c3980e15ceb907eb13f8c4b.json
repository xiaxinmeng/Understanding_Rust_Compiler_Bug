{"sha": "ad56a54c68329d8e0c3980e15ceb907eb13f8c4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ1NmE1NGM2ODMyOWQ4ZTBjMzk4MGUxNWNlYjkwN2ViMTNmOGM0Yg==", "commit": {"author": {"name": "Rainer Orth", "email": "ro@CeBiTec.Uni-Bielefeld.DE", "date": "2011-02-14T12:32:11Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2011-02-14T12:32:11Z"}, "message": "re PR ada/41929 (64-bit null_pointer_deref1 gnat.dg test consumes all available memory)\n\n\tgcc:\n\tPR ada/41929\n\t* config/sparc/sol2-unwind.h: Include <sys/frame.h>, <sys/stack.h>\n\t(IS_SIGHANDLER): Define.\n\t(sparc64_is_sighandler): New function, split off from\n\tsparc64_fallback_frame_state.\n\t(sparc_is_sighandler): New function, split off from\n\tsparc_fallback_frame_state.\n\t(sparc64_fallback_frame_state): Merge with ...\n\t(sparc_fallback_frame_state): ... this into ...\n\t(MD_FALLBACK_FRAME_STATE_FOR): ... this.\n\tChange new_cfa to long.\n\tRemove regs_off, fpu_save_off, fpu_save.\n\tDefine nframes, mctx.\n\tUse IS_SIGHANDLER, handler_args, mctx, walk stack instead of\n\thardcoded offsets.\n\n\tgcc/testsuite:\n\tPR ada/41929\n\t* gnat.dg/null_pointer_deref1.exp: Don't skip on\n\tsparc*-sun-solaris2.11.\n\nFrom-SVN: r170126", "tree": {"sha": "b71f453cc48f11afb05ba82b07f71ae7d74a6c58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b71f453cc48f11afb05ba82b07f71ae7d74a6c58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/comments", "author": {"login": "rorth", "id": 3930951, "node_id": "MDQ6VXNlcjM5MzA5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rorth", "html_url": "https://github.com/rorth", "followers_url": "https://api.github.com/users/rorth/followers", "following_url": "https://api.github.com/users/rorth/following{/other_user}", "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rorth/subscriptions", "organizations_url": "https://api.github.com/users/rorth/orgs", "repos_url": "https://api.github.com/users/rorth/repos", "events_url": "https://api.github.com/users/rorth/events{/privacy}", "received_events_url": "https://api.github.com/users/rorth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "93302a249147f4260a9f3ab1c7f9a30a268b42c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93302a249147f4260a9f3ab1c7f9a30a268b42c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93302a249147f4260a9f3ab1c7f9a30a268b42c1"}], "stats": {"total": 674, "additions": 314, "deletions": 360}, "files": [{"sha": "aa604ee4ab29fbd4e573c80d8ae3c70bd6fae2f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad56a54c68329d8e0c3980e15ceb907eb13f8c4b", "patch": "@@ -1,3 +1,21 @@\n+2011-02-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\tPR ada/41929\n+\t* config/sparc/sol2-unwind.h: Include <sys/frame.h>, <sys/stack.h>\n+\t(IS_SIGHANDLER): Define.\n+\t(sparc64_is_sighandler): New function, split off from\n+\tsparc64_fallback_frame_state.\n+\t(sparc_is_sighandler): New function, split off from\n+\tsparc_fallback_frame_state.\n+\t(sparc64_fallback_frame_state): Merge with ...\n+\t(sparc_fallback_frame_state): ... this into ...\n+\t(MD_FALLBACK_FRAME_STATE_FOR): ... this.\n+\tChange new_cfa to long.\n+\tRemove regs_off, fpu_save_off, fpu_save.\n+\tDefine nframes, mctx.\n+\tUse IS_SIGHANDLER, handler_args, mctx, walk stack instead of\n+\thardcoded offsets.\n+\n 2011-02-14  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* go/gccgo.texi (Top, Import and Export): Fix a typo and a"}, {"sha": "f8b99027247b89379c6105504f89908d989a381c", "filename": "gcc/config/sparc/sol2-unwind.h", "status": "modified", "additions": 289, "deletions": 359, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/gcc%2Fconfig%2Fsparc%2Fsol2-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/gcc%2Fconfig%2Fsparc%2Fsol2-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2-unwind.h?ref=ad56a54c68329d8e0c3980e15ceb907eb13f8c4b", "patch": "@@ -1,5 +1,5 @@\n /* DWARF2 EH unwinding support for SPARC Solaris.\n-   Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -26,224 +26,130 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    state data appropriately.  See unwind-dw2.c for the structs.  */\n \n #include <ucontext.h>\n+#include <sys/frame.h>\n+#include <sys/stack.h>\n \n #if defined(__arch64__)\n \n-#define MD_FALLBACK_FRAME_STATE_FOR sparc64_fallback_frame_state\n+#define IS_SIGHANDLER sparc64_is_sighandler\n \n-static _Unwind_Reason_Code\n-sparc64_fallback_frame_state (struct _Unwind_Context *context,\n-\t\t\t      _Unwind_FrameState *fs)\n+static int\n+sparc64_is_sighandler (unsigned int *pc, unsigned int *savpc, int *nframes)\n {\n-  void *pc = context->ra;\n-  void *this_cfa = context->cfa;\n-  void *new_cfa, *ra_location, *shifted_ra_location;\n-  int regs_off;\n-  int fpu_save_off;\n-  unsigned char fpu_save;\n-  int i;\n-\n-  /* This is the observed pattern for the sigacthandler in Solaris 8.  */\n-  unsigned int sigacthandler_sol8_pattern []\n-    = {0x9401400f, 0xca5aafa0, 0x913e2000, 0x892a3003,\n-       0xe0590005, 0x9fc40000, 0x9410001a, 0x80a6e008};\n-\n-  /* This is the observed pattern for the sigacthandler in Solaris 9.  */ \n-  unsigned int sigacthandler_sol9_pattern []\n-    = {0xa33e2000, 0x00000000, 0x892c7003, 0x90100011,\n-       0xe0590005, 0x9fc40000, 0x9410001a, 0x80a46008};\n-\n-  /* This is the observed pattern for the __sighndlr.  */\n-  unsigned int sighndlr_pattern []\n-    = {0x9de3bf50, 0x90100018, 0x92100019, 0x9fc6c000,\n-       0x9410001a, 0x81c7e008, 0x81e80000};\n-\n-  /* Deal with frame-less function from which a signal was raised.  */\n-  if (_Unwind_IsSignalFrame (context))\n+  if (/* Solaris 8 - single-threaded\n+\t----------------------------\n+\t<sigacthandler+24>:  add  %g5, %o7, %o2\n+\t<sigacthandler+28>:  ldx  [ %o2 + 0xfa0 ], %g5\n+\t<sigacthandler+32>:  sra  %i0, 0, %o0\n+\t<sigacthandler+36>:  sllx  %o0, 3, %g4\n+\t<sigacthandler+40>:  ldx  [ %g4 + %g5 ], %l0\n+\t<sigacthandler+44>:  call  %l0\n+\t<sigacthandler+48>:  mov  %i2, %o2\n+\t<sigacthandler+52>:  cmp  %i3, 8\t<--- PC  */\n+      (   pc[-7] == 0x9401400f\n+       && pc[-6] == 0xca5aafa0\n+       && pc[-5] == 0x913e2000\n+       && pc[-4] == 0x892a3003\n+       && pc[-3] == 0xe0590005\n+       && pc[-2] == 0x9fc40000\n+       && pc[-1] == 0x9410001a\n+       && pc[ 0] == 0x80a6e008)\n+\n+      || /* Solaris 9 - single-threaded\n+\t   ----------------------------\n+\t   The pattern changes slightly in different versions of the\n+\t   operating system, so we skip the comparison against pc[-6] for\n+\t   Solaris 9.\n+\n+\t   <sigacthandler+24>:  sra  %i0, 0, %l1\n+\n+\t   Solaris 9 5/02:\n+\t   <sigacthandler+28>:  ldx  [ %o2 + 0xf68 ], %g5\n+\t   Solaris 9 9/05:\n+\t   <sigacthandler+28>:  ldx  [ %o2 + 0xe50 ], %g5\n+\n+\t   <sigacthandler+32>:  sllx  %l1, 3, %g4\n+\t   <sigacthandler+36>:  mov  %l1, %o0\n+\t   <sigacthandler+40>:  ldx  [ %g4 + %g5 ], %l0\n+\t   <sigacthandler+44>:  call  %l0\n+\t   <sigacthandler+48>:  mov  %i2, %o2\n+\t   <sigacthandler+52>:  cmp  %l1, 8\t<--- PC  */\n+      (   pc[-7] == 0xa33e2000\n+       /* skip pc[-6] */\n+       && pc[-5] == 0x892c7003\n+       && pc[-4] == 0x90100011\n+       && pc[-3] == 0xe0590005\n+       && pc[-2] == 0x9fc40000\n+       && pc[-1] == 0x9410001a\n+       && pc[ 0] == 0x80a46008))\n     {\n-      /* The CFA is by definition unmodified in this case.  */\n-      fs->regs.cfa_how = CFA_REG_OFFSET;\n-      fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n-      fs->regs.cfa_offset = 0;\n-\n-      /* This is the canonical RA column.  */\n-      fs->retaddr_column = 15;\n-\n-      return _URC_NO_REASON;\n+      /* We need to move up one frame:\n+\n+\t\t<signal handler>\t<-- context->cfa\n+\t\tsigacthandler\n+\t\t<kernel>\n+      */\n+      *nframes = 1;\n+      return 1;\n     }\n \n-  /* Look for the sigacthandler pattern.  The pattern changes slightly\n-     in different versions of the operating system, so we skip the\n-     comparison against pc-(4*6) for Solaris 9.  */\n-  if ((    *(unsigned int *)(pc-(4*7)) == sigacthandler_sol8_pattern[0]\n-\t&& *(unsigned int *)(pc-(4*6)) == sigacthandler_sol8_pattern[1]\n-\t&& *(unsigned int *)(pc-(4*5)) == sigacthandler_sol8_pattern[2]\n-\t&& *(unsigned int *)(pc-(4*4)) == sigacthandler_sol8_pattern[3]\n-\t&& *(unsigned int *)(pc-(4*3)) == sigacthandler_sol8_pattern[4]\n-\t&& *(unsigned int *)(pc-(4*2)) == sigacthandler_sol8_pattern[5]\n-\t&& *(unsigned int *)(pc-(4*1)) == sigacthandler_sol8_pattern[6]\n-\t&& *(unsigned int *)(pc-(4*0)) == sigacthandler_sol8_pattern[7] ) ||\n-      (    *(unsigned int *)(pc-(4*7)) == sigacthandler_sol9_pattern[0]\n-\t/* skip pc-(4*6) */\n-\t&& *(unsigned int *)(pc-(4*5)) == sigacthandler_sol9_pattern[2]\n-\t&& *(unsigned int *)(pc-(4*4)) == sigacthandler_sol9_pattern[3]\n-\t&& *(unsigned int *)(pc-(4*3)) == sigacthandler_sol9_pattern[4]\n-\t&& *(unsigned int *)(pc-(4*2)) == sigacthandler_sol9_pattern[5]\n-\t&& *(unsigned int *)(pc-(4*1)) == sigacthandler_sol9_pattern[6]\n-\t&& *(unsigned int *)(pc-(4*0)) == sigacthandler_sol9_pattern[7] ) )\n-    /* We need to move up two frames (the kernel frame and the handler\n-       frame).  Minimum stack frame size is 176 bytes (128 + 48): 128\n-       bytes for spilling register window (16 extended words for in\n-       and local registers), and 6 extended words to store at least\n-       6 arguments to callees, The kernel frame and the sigacthandler\n-       both have this minimal stack.  The ucontext_t structure is after\n-       this offset.  */\n-    regs_off = 176 + 176;\n-\n-  /* Look for the __sighndlr pattern.  */\n-  else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]\n-\t    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]\n-\t    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]\n-\t    && *(unsigned int *)(pc-(4*2)) == sighndlr_pattern[3]\n-\t    && *(unsigned int *)(pc-(4*1)) == sighndlr_pattern[4]\n-\t    && *(unsigned int *)(pc-(4*0)) == sighndlr_pattern[5]\n-\t    && *(unsigned int *)(pc+(4*1)) == sighndlr_pattern[6] )\n+  if (/* Solaris 8+ - multi-threaded\n+\t----------------------------\n+\t<__sighndlr>:        save  %sp, -176, %sp\n+\t<__sighndlr+4>:      mov  %i0, %o0\n+\t<__sighndlr+8>:      mov  %i1, %o1\n+\t<__sighndlr+12>:     call  %i3\n+\t<__sighndlr+16>:     mov  %i2, %o2\n+\t<__sighndlr+20>:     ret \t\t<--- PC\n+\t<__sighndlr+24>:     restore  */\n+         pc[-5] == 0x9de3bf50\n+      && pc[-4] == 0x90100018\n+      && pc[-3] == 0x92100019\n+      && pc[-2] == 0x9fc6c000\n+      && pc[-1] == 0x9410001a\n+      && pc[ 0] == 0x81c7e008\n+      && pc[ 1] == 0x81e80000)\n     {\n-      /* We have observed different calling frames among different\n-\t versions of the operating system, so that we need to\n-\t discriminate using the upper frame.  We look for the return\n-\t address of the caller frame (there is an offset of 15 double\n-\t words between the frame address and the place where this return\n-\t address is stored) in order to do some more pattern matching.  */\n-      unsigned int cuh_pattern\n-\t= *(unsigned int *)(*(unsigned long *)(this_cfa + 15*8) - 4);\n-\n-      if (cuh_pattern == 0xd25fa7ef)\n+      if (/* Solaris 8 /usr/lib/sparcv9/libthread.so.1\n+\t    ------------------------------------------\n+\t    Before patch 108827-08:\n+\t    <sigacthandler+1760>:     st  %g4, [ %i1 + 0x1c ]\n+\n+\t    Since patch 108827-08:\n+\t    <sigacthandler+1816>:     st  %l0, [ %i4 + 0x10 ]  */\n+\t        savpc[-1] == 0xc826601c\n+\t     || savpc[-1] == 0xe0272010)\n \t{\n-\t  /* This matches the call_user_handler pattern for Solaris 10.\n-\t     There are 2 cases so we look for the return address of the\n-\t     caller's caller frame in order to do more pattern matching.  */\n-\t  unsigned int sah_pattern\n-\t    = *(unsigned int *)(*(unsigned long *)(this_cfa + 176 + 15*8) - 4);\n-\n-          if (sah_pattern == 0x92100019)\n-\t    /* This is the same setup as for Solaris 9, see below.  */\n-\t    regs_off = 176 + 176 + 176 + 304;\n-\t  else\n-\t    /* We need to move up three frames (the kernel frame, the\n-\t       call_user_handler frame, the __sighndlr frame).  Two of them\n-\t       have the minimum stack frame size (kernel and __sighndlr\n-\t       frames) of 176 bytes, and there is another with a stack frame\n-\t       of 304 bytes (the call_user_handler frame).  The ucontext_t\n-\t       structure is after this offset.  */\n-\t    regs_off = 176 + 176 + 304;\n+\t  /* We need to move up three frames:\n+\n+\t\t<signal handler>\t<-- context->cfa\n+\t\t__sighndlr\n+\t\tsigacthandler\n+\t\t<kernel>\n+\t  */\n+\t  *nframes = 2;\n \t}\n-      else if (cuh_pattern == 0x9410001a || cuh_pattern == 0x94100013)\n-\t/* This matches the call_user_handler pattern for Solaris 9 and\n-\t   for Solaris 8 running inside Solaris Containers respectively.\n-\t   We need to move up four frames (the kernel frame, the signal\n-\t   frame, the call_user_handler frame, the __sighndlr frame).\n-\t   Three of them have the minimum stack frame size (kernel,\n-\t   signal, and __sighndlr frames) of 176 bytes, and there is\n-\t   another with a stack frame of 304 bytes (the call_user_handler\n-\t   frame).  The ucontext_t structure is after this offset.  */\n-\tregs_off = 176 + 176 + 176 + 304;\n-      else\n-\t/* We need to move up three frames (the kernel frame, the\n-\t   sigacthandler frame, and the __sighndlr frame).  The kernel\n-\t   frame has a stack frame size of 176, the __sighndlr frames of\n-\t   304 bytes, and there is a stack frame of 176 bytes for the\n-\t   sigacthandler frame.  The ucontext_t structure is after this\n-\t   offset.  */\n-\tregs_off = 176 + 304 + 176;\n-    }\n-\n-  /* Exit if the pattern at the return address does not match the\n-     previous three patterns.  */\n-  else\n-    return _URC_END_OF_STACK;\n-\n-  /* FPU information can be extracted from the ucontext_t structure \n-     that is the third argument for the signal handler, that is saved\n-     in the stack.  There are 64 bytes between the beginning of the\n-     ucontext_t argument of the signal handler and the uc_mcontext\n-     field.  There are 176 bytes between the beginning of uc_mcontext\n-     and the beginning of the fpregs field.  */\n-  fpu_save_off = regs_off + (8*10) + 176;\n-\n-  /* The fpregs field contains 32 extended words at the beginning that\n-     contain the FPU state.  Then there are 2 extended words and two\n-     bytes.  */\n-  fpu_save = *(unsigned char *)(this_cfa + fpu_save_off + (8*32) + (2*8) + 2);\n-\n-  /* We need to get the frame pointer for the kernel frame that\n-     executes when the signal is raised.  This frame is just the\n-     following to the application code that generated the signal, so\n-     that the later's stack pointer is the former's frame pointer.\n-     The stack pointer for the interrupted application code can be\n-     calculated from the ucontext_t structure (third argument for the\n-     signal handler) that is saved in the stack.  There are 10 words\n-     between the beginning of the  ucontext_t argument  of the signal\n-     handler and the uc_mcontext.gregs field that contains the\n-     registers saved by the signal handler.  */\n-  new_cfa = *(void **)(this_cfa + regs_off + (8*10) + (REG_SP*8));\n-  /* The frame address is %sp + STACK_BIAS in 64-bit mode. */\n-  new_cfa += 2047;\n-  fs->regs.cfa_how = CFA_REG_OFFSET;\n-  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n-  fs->regs.cfa_offset = new_cfa - this_cfa;\n-\n-  /* Restore global and out registers (in this order) from the\n-     ucontext_t structure, uc_mcontext.gregs field.  */\n-  for (i = 1; i < 16; i++)\n-    {\n-      /* We never restore %sp as everything is purely CFA-based.  */\n-      if ((unsigned int) i == __builtin_dwarf_sp_column ())\n-\tcontinue;\n-\n-      /* First the global registers and then the out registers.  */\n-      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i].loc.offset\n-\t= this_cfa + regs_off + (8*10) + ((REG_Y+i)*8) - new_cfa;\n-    }\n-\n-  /* Just above the stack pointer there are 16 extended words in which\n-     the register window (in and local registers) was saved.  */\n-  for (i = 0; i < 16; i++)\n-    {\n-      fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i + 16].loc.offset = i*8;\n-    }\n-\n-  /* Check whether we need to restore FPU registers.  */\n-  if (fpu_save)\n-    {\n-      for (i = 0; i < 64; i++)\n+      else /* Solaris 8 /usr/lib/lwp/sparcv9/libthread.so.1, Solaris 9+\n+\t     ----------------------------------------------------------  */\n \t{\n-\t  if (i > 32 && (i & 1))\n-\t    continue;\n-\n-\t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n-\t  fs->regs.reg[i + 32].loc.offset\n-\t    = this_cfa + fpu_save_off + (i*4) - new_cfa;\n+\t  /* We need to move up three frames:\n+\n+\t\t<signal handler>\t<-- context->cfa\n+\t\t__sighndlr\n+\t\tcall_user_handler\n+\t\tsigacthandler\n+\t\t<kernel>\n+\t  */\n+\t  *nframes = 3;\n \t}\n+      return 1;\n     }\n \n-  /* State the rules to find the kernel's code \"return address\", which is\n-     the address of the active instruction when the signal was caught.\n-     On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we\n-     need to preventively subtract it from the purported return address.  */\n-  ra_location = this_cfa + regs_off + (8*10) + (REG_PC*8);\n-  shifted_ra_location = this_cfa + regs_off + (8*10) + (REG_Y*8);\n-  *(void **)shifted_ra_location = *(void **)ra_location - 8;\n-  fs->retaddr_column = 0;\n-  fs->regs.reg[0].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;\n-  fs->signal_frame = 1;\n-\n-  return _URC_NO_REASON;\n+  return 0;\n }\n \n+#define MD_FALLBACK_FRAME_STATE_FOR sparc64_fallback_frame_state\n+\n #define MD_FROB_UPDATE_CONTEXT sparc64_frob_update_context\n \n static void\n@@ -258,42 +164,150 @@ sparc64_frob_update_context (struct _Unwind_Context *context,\n       && fs->regs.cfa_how == CFA_REG_OFFSET\n       && fs->regs.cfa_offset != 0\n       && !fs->signal_frame)\n-    context->cfa -= 2047;\n+    context->cfa -= STACK_BIAS;\n }\n \n #else\n \n+#define IS_SIGHANDLER sparc_is_sighandler\n+\n+static int\n+sparc_is_sighandler (unsigned int *pc, unsigned int * savpc, int *nframes)\n+{\n+  if (/* Solaris 8, 9 - single-threaded\n+        -------------------------------\n+\tThe pattern changes slightly in different versions of the operating\n+\tsystem, so we skip the comparison against pc[-6].\n+\n+\t<sigacthandler+16>:  add  %o1, %o7, %o3\n+\t<sigacthandler+20>:  mov  %i1, %o1\n+\n+\t<sigacthandler+24>:  ld  [ %o3 + <offset> ], %o2\n+\n+\t<sigacthandler+28>:  sll  %i0, 2, %o0\n+\t<sigacthandler+32>:  ld  [ %o0 + %o2 ], %l0\n+\t<sigacthandler+36>:  mov  %i0, %o0\n+\t<sigacthandler+40>:  call  %l0\n+\t<sigacthandler+44>:  mov  %i2, %o2\n+\t<sigacthandler+48>:  cmp  %i0, 8\t<--- PC  */\n+         pc[-8] == 0x9602400f\n+      && pc[-7] == 0x92100019\n+      /* skip pc[-6] */\n+      && pc[-5] == 0x912e2002\n+      && pc[-4] == 0xe002000a\n+      && pc[-3] == 0x90100018\n+      && pc[-2] == 0x9fc40000\n+      && pc[-1] == 0x9410001a\n+      && pc[ 0] == 0x80a62008)\n+    {\n+      /* Need to move up one frame:\n+\n+\t\t<signal handler>\t<-- context->cfa\n+\t\tsigacthandler\n+\t\t<kernel>\n+      */\n+      *nframes = 1;\n+      return 1;\n+    }\n+\n+  if (/* Solaris 8 - multi-threaded\n+\t---------------------------\n+\t<__libthread_segvhdlr+212>:  clr  %o2\n+\t<__libthread_segvhdlr+216>:  ld  [ %fp + -28 ], %l0\n+\t<__libthread_segvhdlr+220>:  mov  %i4, %o0\n+\t<__libthread_segvhdlr+224>:  mov  %i1, %o1\n+\t<__libthread_segvhdlr+228>:  call  %l0\n+\t<__libthread_segvhdlr+232>:  mov  %i2, %o2\n+\t<__libthread_segvhdlr+236>:  ret\t\t<--- PC\n+\t<__libthread_segvhdlr+240>:  restore\n+\t<__libthread_segvhdlr+244>:  cmp  %o1, 0  */\n+         pc[-6] == 0x94102000\n+      && pc[-5] == 0xe007bfe4\n+      && pc[-4] == 0x9010001c\n+      && pc[-3] == 0x92100019\n+      && pc[-2] == 0x9fc40000\n+      && pc[-1] == 0x9410001a\n+      && pc[ 0] == 0x81c7e008\n+      && pc[ 1] == 0x81e80000\n+      && pc[ 2] == 0x80a26000)\n+    {\n+      /* Need to move up one frame:\n+\n+\t\t<signal handler>\t<-- context->cfa\n+\t\t__libthread_segvhdlr\n+\t\t<kernel>\n+      */\n+      *nframes = 1;\n+      return 1;\n+    }\n+\n+  if(/* Solaris 8+ - multi-threaded\n+       ----------------------------\n+       <__sighndlr>:\tsave  %sp, -96, %sp\n+       <__sighndlr+4>:\tmov  %i0, %o0\n+       <__sighndlr+8>:\tmov  %i1, %o1\n+       <__sighndlr+12>:\tcall  %i3\n+       <__sighndlr+16>:\tmov  %i2, %o2\n+       <__sighndlr+20>:\tret \t\t<--- PC\n+       <__sighndlr+24>:\trestore  */\n+        pc[-5] == 0x9de3bfa0\n+     && pc[-4] == 0x90100018\n+     && pc[-3] == 0x92100019\n+     && pc[-2] == 0x9fc6c000\n+     && pc[-1] == 0x9410001a\n+     && pc[ 0] == 0x81c7e008\n+     && pc[ 1] == 0x81e80000)\n+    {\n+      if (/* Solaris 8 /usr/lib/libthread.so.1\n+\t    ----------------------------------\n+\t    <sigacthandler+1796>:     mov  %i0, %o0  */\n+\t  savpc[-1] == 0x90100018)\n+\t{\n+\t  /* We need to move up two frames:\n+\n+\t\t<signal handler>\t<-- context->cfa\n+\t\t__sighndlr\n+\t\tsigacthandler\n+\t\t<kernel>\n+\t  */\n+\t  *nframes = 2;\n+\t}\n+      else /* Solaris 8 /usr/lib/lwp/libthread.so.1, Solaris 9+\n+\t     --------------------------------------------------  */\n+\t{\n+\t  /* We need to move up three frames:\n+\n+\t\t<signal handler>\t<-- context->cfa\n+\t\t__sighndlr\n+\t\tcall_user_handler\n+\t\tsigacthandler\n+\t\t<kernel>\n+\t  */\n+\t  *nframes = 3;\n+\t}\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n #define MD_FALLBACK_FRAME_STATE_FOR sparc_fallback_frame_state\n \n+#endif\n+\n static _Unwind_Reason_Code\n-sparc_fallback_frame_state (struct _Unwind_Context *context,\n-\t\t\t    _Unwind_FrameState *fs)\n+MD_FALLBACK_FRAME_STATE_FOR (struct _Unwind_Context *context,\n+\t\t\t     _Unwind_FrameState *fs)\n {\n   void *pc = context->ra;\n+  struct frame *fp = (struct frame *) context->cfa;\n+  int nframes;\n   void *this_cfa = context->cfa;\n-  void *new_cfa, *ra_location, *shifted_ra_location;\n-  int regs_off;\n-  int fpu_save_off;\n-  unsigned char fpu_save;\n+  long new_cfa;\n+  void *ra_location, *shifted_ra_location;\n+  mcontext_t *mctx;\n   int i;\n \n-  /* This is the observed pattern for the sigacthandler.  */\n-  unsigned int sigacthandler_pattern []\n-    = {0x9602400f, 0x92100019, 0x00000000, 0x912e2002,\n-       0xe002000a, 0x90100018, 0x9fc40000, 0x9410001a,\n-       0x80a62008};\n-\n-  /* This is the observed pattern for the __libthread_segvhdlr.  */\n-  unsigned int segvhdlr_pattern []\n-    = {0x94102000, 0xe007bfe4, 0x9010001c, 0x92100019,\n-       0x9fc40000, 0x9410001a, 0x81c7e008, 0x81e80000,\n-       0x80a26000};\n-\n-  /* This is the observed pattern for the __sighndlr.  */\n-  unsigned int sighndlr_pattern []\n-    = {0x9de3bfa0, 0x90100018, 0x92100019, 0x9fc6c000,\n-       0x9410001a, 0x81c7e008, 0x81e80000};\n-\n   /* Deal with frame-less function from which a signal was raised.  */\n   if (_Unwind_IsSignalFrame (context))\n     {\n@@ -308,135 +322,41 @@ sparc_fallback_frame_state (struct _Unwind_Context *context,\n       return _URC_NO_REASON;\n     }\n \n-  /* Look for the sigacthandler pattern.  The pattern changes slightly\n-     in different versions of the operating system, so we skip the\n-     comparison against pc-(4*6).  */\n-  if (    *(unsigned int *)(pc-(4*8)) == sigacthandler_pattern[0]\n-       && *(unsigned int *)(pc-(4*7)) == sigacthandler_pattern[1]\n-       /* skip pc-(4*6) */\n-       && *(unsigned int *)(pc-(4*5)) == sigacthandler_pattern[3]\n-       && *(unsigned int *)(pc-(4*4)) == sigacthandler_pattern[4]\n-       && *(unsigned int *)(pc-(4*3)) == sigacthandler_pattern[5]\n-       && *(unsigned int *)(pc-(4*2)) == sigacthandler_pattern[6]\n-       && *(unsigned int *)(pc-(4*1)) == sigacthandler_pattern[7]\n-       && *(unsigned int *)(pc-(4*0)) == sigacthandler_pattern[8] )\n-    /* We need to move up two frames (the kernel frame and the handler\n-       frame).  Minimum stack frame size is 96 bytes (64 + 4 + 24): 64\n-       bytes for spilling register window (16 words for in and local\n-       registers), 4 bytes for a pointer to space for callees\n-       returning structs, and 24 bytes to store at least six argument\n-       to callees.  The ucontext_t structure is after this offset.  */\n-    regs_off = 96 + 96;\n-\n-  /* Look for the __libthread_segvhdlr pattern.  */\n-  else if (    *(unsigned int *)(pc-(4*6)) == segvhdlr_pattern[0]\n-\t    && *(unsigned int *)(pc-(4*5)) == segvhdlr_pattern[1]\n-\t    && *(unsigned int *)(pc-(4*4)) == segvhdlr_pattern[2]\n-\t    && *(unsigned int *)(pc-(4*3)) == segvhdlr_pattern[3]\n-\t    && *(unsigned int *)(pc-(4*2)) == segvhdlr_pattern[4]\n-\t    && *(unsigned int *)(pc-(4*1)) == segvhdlr_pattern[5]\n-\t    && *(unsigned int *)(pc-(4*0)) == segvhdlr_pattern[6]\n-\t    && *(unsigned int *)(pc+(4*1)) == segvhdlr_pattern[7]\n-\t    && *(unsigned int *)(pc+(4*2)) == segvhdlr_pattern[8] )\n-    /* We need to move up four frames (the kernel frame, the\n-       sigacthandler frame, the __sighndlr frame, and the\n-       __libthread_segvhdlr).  Two of them have the minimum\n-       stack frame size (kernel and __sighndlr frames) of 96 bytes,\n-       other has a stack frame of 216 bytes (the sigacthandler frame),\n-       and there is another with a stack frame of 128 bytes (the\n-       __libthread_segvhdlr).  The ucontext_t structure is after this\n-       offset.  */\n-    regs_off = 96 + 96 + 128 + 216;\n-\n-  /* Look for the __sighndlr pattern.  */\n-  else if (    *(unsigned int *)(pc-(4*5)) == sighndlr_pattern[0]\n-\t    && *(unsigned int *)(pc-(4*4)) == sighndlr_pattern[1]\n-\t    && *(unsigned int *)(pc-(4*3)) == sighndlr_pattern[2]\n-\t    && *(unsigned int *)(pc-(4*2)) == sighndlr_pattern[3]\n-\t    && *(unsigned int *)(pc-(4*1)) == sighndlr_pattern[4]\n-\t    && *(unsigned int *)(pc-(4*0)) == sighndlr_pattern[5]\n-\t    && *(unsigned int *)(pc+(4*1)) == sighndlr_pattern[6] )\n+  if (IS_SIGHANDLER (pc, (unsigned int *)fp->fr_savpc, &nframes))\n     {\n-      /* We have observed different calling frames among different\n-\t versions of the operating system, so that we need to\n-\t discriminate using the upper frame.  We look for the return\n-\t address of the caller frame (there is an offset of 15 words\n-\t between the frame address and the place where this return\n-\t address is stored) in order to do some more pattern matching.  */\n-      unsigned int cuh_pattern\n-\t= *(unsigned int *)(*(unsigned int *)(this_cfa + 15*4) - 4);\n-\n-      if (cuh_pattern == 0xd407a04c)\n-\t{\n-\t  /* This matches the call_user_handler pattern for Solaris 10.\n-\t     There are 2 cases so we look for the return address of the\n-\t     caller's caller frame in order to do more pattern matching.  */\n-\t  unsigned int sah_pattern\n-\t    = *(unsigned int *)(*(unsigned int *)(this_cfa + 96 + 15*4) - 4);\n-\n-          if (sah_pattern == 0x92100019)\n-\t    /* This is the same setup as for Solaris 9, see below.  */\n-\t    regs_off = 96 + 96 + 96 + 160;\n-\t  else\n-\t    /* We need to move up three frames (the kernel frame, the\n-\t       call_user_handler frame, the __sighndlr frame).  Two of them\n-\t       have the minimum stack frame size (kernel and __sighndlr\n-\t       frames) of 96 bytes, and there is another with a stack frame\n-\t       of 160 bytes (the call_user_handler frame).  The ucontext_t\n-\t       structure is after this offset.  */\n-\t    regs_off = 96 + 96 + 160;\n-\t}\n-      else if (cuh_pattern == 0x9410001a || cuh_pattern == 0x9410001b)\n-\t/* This matches the call_user_handler pattern for Solaris 9 and\n-\t   for Solaris 8 running inside Solaris Containers respectively.\n-\t   We need to move up four frames (the kernel frame, the signal\n-\t   frame, the call_user_handler frame, the __sighndlr frame).\n-\t   Three of them have the minimum stack frame size (kernel,\n-\t   signal, and __sighndlr frames) of 96 bytes, and there is\n-\t   another with a stack frame of 160 bytes (the call_user_handler\n-\t   frame).  The ucontext_t structure is after this offset.  */\n-\tregs_off = 96 + 96 + 96 + 160;\n-      else\n-\t/* We need to move up three frames (the kernel frame, the\n-\t   sigacthandler frame, and the __sighndlr frame).  Two of them\n-\t   have the minimum stack frame size (kernel and __sighndlr\n-\t   frames) of 96 bytes, and there is another with a stack frame\n-\t   of 216 bytes (the sigacthandler frame).  The ucontext_t \n-\t   structure is after this offset.  */\n-\tregs_off = 96 + 96 + 216;\n+      struct handler_args {\n+\tstruct frame frwin;\n+\tucontext_t ucontext;\n+      } *handler_args;\n+      ucontext_t *ucp;\n+\n+      /* context->cfa points into the frame after the saved frame pointer and\n+         saved pc (struct frame).\n+\n+         The ucontext_t structure is in the kernel frame after a struct\n+         frame.  Since the frame sizes vary even within OS releases, we\n+         need to walk the stack to get there.  */\n+\n+      for (i = 0; i < nframes; i++)\n+\tfp = (struct frame *) ((char *)fp->fr_savfp + STACK_BIAS);\n+\n+      handler_args = (struct handler_args *) fp;\n+      ucp = &handler_args->ucontext;\n+      mctx = &ucp->uc_mcontext;\n     }\n \n   /* Exit if the pattern at the return address does not match the\n      previous three patterns.  */\n   else\n     return _URC_END_OF_STACK;\n \n-  /* FPU information can be extracted from the ucontext_t structure\n-     that is the third argument for the signal handler, that is saved\n-     in the stack.  There are 10 words between the beginning of the\n-     ucontext_t argument of the signal handler and the uc_mcontext\n-     field.  There are 80 bytes between the beginning of uc_mcontext\n-     and the beginning of the fpregs field.  */\n-  fpu_save_off = regs_off + (4*10) + (4*20);\n-\n-  /* The fpregs field contains 32 words at the beginning that contain\n-     the FPU state.  Then there are 2 words and two bytes.  */\n-  fpu_save = *(unsigned char *)(this_cfa + fpu_save_off + (4*32) + (2*4) + 2);\n-\n-  /* We need to get the frame pointer for the kernel frame that\n-     executes when the signal is raised.  This frame is just the\n-     following to the application code that generated the signal, so\n-     that the later's stack pointer is the former's frame pointer.\n-     The stack pointer for the interrupted application code can be\n-     calculated from the ucontext_t structure (third argument for the\n-     signal handler) that is saved in the stack.  There are 10 words\n-     between the beginning of the  ucontext_t argument  of the signal\n-     handler and the uc_mcontext.gregs field that contains the\n-     registers saved by the signal handler.  */\n-  new_cfa = *(void **)(this_cfa + regs_off + (4*10) + (REG_SP*4));\n+  new_cfa = mctx->gregs[REG_SP];\n+  /* The frame address is %sp + STACK_BIAS in 64-bit mode.  */\n+  new_cfa += STACK_BIAS;\n+\n   fs->regs.cfa_how = CFA_REG_OFFSET;\n   fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n-  fs->regs.cfa_offset = new_cfa - this_cfa;\n+  fs->regs.cfa_offset = new_cfa - (long) this_cfa;\n \n   /* Restore global and out registers (in this order) from the\n      ucontext_t structure, uc_mcontext.gregs field.  */\n@@ -446,44 +366,54 @@ sparc_fallback_frame_state (struct _Unwind_Context *context,\n       if ((unsigned int) i == __builtin_dwarf_sp_column ())\n \tcontinue;\n \n-      /* First the global registers and then the out registers */\n+      /* First the global registers and then the out registers.  */\n       fs->regs.reg[i].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i].loc.offset\n-\t= this_cfa + regs_off + (4*10) + ((REG_Y+i)*4) - new_cfa;\n+      fs->regs.reg[i].loc.offset = (long)&mctx->gregs[REG_Y + i] - new_cfa;\n     }\n \n-  /* Just above the stack pointer there are 16 words in which the\n-     register window (in and local registers) was saved.  */\n+  /* Just above the stack pointer there are 16 extended words in which\n+     the register window (in and local registers) was saved.  */\n   for (i = 0; i < 16; i++)\n     {\n       fs->regs.reg[i + 16].how = REG_SAVED_OFFSET;\n-      fs->regs.reg[i + 16].loc.offset = i*4;\n+      fs->regs.reg[i + 16].loc.offset = i*sizeof(long);\n     }\n \n   /* Check whether we need to restore FPU registers.  */\n-  if (fpu_save)\n+  if (mctx->fpregs.fpu_qcnt)\n     {\n       for (i = 0; i < 32; i++)\n \t{\n \t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n \t  fs->regs.reg[i + 32].loc.offset\n-\t    = this_cfa + fpu_save_off + (i*4) - new_cfa;\n+\t    = (long)&mctx->fpregs.fpu_fr.fpu_regs[i] - new_cfa;\n+\t}\n+\n+#ifdef __arch64__\n+      /* For 64-bit, fpu_fr.fpu_dregs contains 32 instead of 16 doubles.  */\n+      for (i = 32; i < 64; i++)\n+\t{\n+\t  if (i > 32 && (i & 1))\n+\t    continue;\n+\n+\t  fs->regs.reg[i + 32].how = REG_SAVED_OFFSET;\n+\t  fs->regs.reg[i + 32].loc.offset\n+\t    = (long)&mctx->fpregs.fpu_fr.fpu_dregs[i/2] - new_cfa;\n \t}\n+#endif\n     }\n \n   /* State the rules to find the kernel's code \"return address\", which is\n      the address of the active instruction when the signal was caught.\n      On the SPARC, since RETURN_ADDR_OFFSET (essentially 8) is defined, we\n      need to preventively subtract it from the purported return address.  */\n-  ra_location = this_cfa + regs_off + (4*10) + (REG_PC*4);\n-  shifted_ra_location = this_cfa + regs_off + (4*10) + (REG_Y*4);\n+  ra_location = &mctx->gregs[REG_PC];\n+  shifted_ra_location = &mctx->gregs[REG_Y];\n   *(void **)shifted_ra_location = *(void **)ra_location - 8;\n   fs->retaddr_column = 0;\n   fs->regs.reg[0].how = REG_SAVED_OFFSET;\n-  fs->regs.reg[0].loc.offset = shifted_ra_location - new_cfa;\n+  fs->regs.reg[0].loc.offset = (long)shifted_ra_location - new_cfa;\n   fs->signal_frame = 1;\n \n   return _URC_NO_REASON;\n-};\n-\n-#endif\n+}"}, {"sha": "63318f130715a988a6af8b5a36f81f6fc2ebce83", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad56a54c68329d8e0c3980e15ceb907eb13f8c4b", "patch": "@@ -1,3 +1,9 @@\n+2011-02-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\tPR ada/41929\n+\t* gnat.dg/null_pointer_deref1.exp: Don't skip on\n+\tsparc*-sun-solaris2.11.\n+\n 2011-02-14  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/47349"}, {"sha": "6e7bf14e5df5a028c685fea15e39ef6185f52852", "filename": "gcc/testsuite/gnat.dg/null_pointer_deref1.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/gcc%2Ftestsuite%2Fgnat.dg%2Fnull_pointer_deref1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad56a54c68329d8e0c3980e15ceb907eb13f8c4b/gcc%2Ftestsuite%2Fgnat.dg%2Fnull_pointer_deref1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fnull_pointer_deref1.adb?ref=ad56a54c68329d8e0c3980e15ceb907eb13f8c4b", "patch": "@@ -1,4 +1,4 @@\n--- { dg-do run { target { ! \"sparc*-sun-solaris2.11\" } } }\n+-- { dg-do run }\n -- { dg-options \"-gnatp\" }\n \n -- This test requires architecture- and OS-specific support code for unwinding"}]}