{"sha": "aa2a8516ce528253bf241f1730876c904823e469", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyYTg1MTZjZTUyODI1M2JmMjQxZjE3MzA4NzZjOTA0ODIzZTQ2OQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-10-17T18:14:58Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-10-17T18:14:58Z"}, "message": "howto.html: Remove 1999 links (and explain why).\n\n2001-10-17  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* docs/html/17_intro/howto.html:  Remove 1999 links (and explain\n\twhy).  Add link to recent message.\n\t* docs/html/faq/index.html (5.6):  Reformat text only; fixup <pre>\n\tmarkup.\n\t* docs/html/faq/index.txt:  Regenerate.\n\nFrom-SVN: r46321", "tree": {"sha": "9e8b2be2ba87bc6d511aa4e19a17c0f4dd6a9a00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e8b2be2ba87bc6d511aa4e19a17c0f4dd6a9a00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa2a8516ce528253bf241f1730876c904823e469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2a8516ce528253bf241f1730876c904823e469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa2a8516ce528253bf241f1730876c904823e469", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa2a8516ce528253bf241f1730876c904823e469/comments", "author": null, "committer": null, "parents": [{"sha": "a4f6c312688e3393618ade5af501364f76599f8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f6c312688e3393618ade5af501364f76599f8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f6c312688e3393618ade5af501364f76599f8f"}], "stats": {"total": 183, "additions": 97, "deletions": 86}, "files": [{"sha": "32f6c21208a512cbd6736136ee77be1452763861", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2a8516ce528253bf241f1730876c904823e469/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2a8516ce528253bf241f1730876c904823e469/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=aa2a8516ce528253bf241f1730876c904823e469", "patch": "@@ -1,3 +1,11 @@\n+2001-10-17  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* docs/html/17_intro/howto.html:  Remove 1999 links (and explain\n+\twhy).  Add link to recent message.\n+\t* docs/html/faq/index.html (5.6):  Reformat text only; fixup <pre>\n+\tmarkup.\n+\t* docs/html/faq/index.txt:  Regenerate.\n+\n 2001-10-12  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* docs/html/faq/index.html (Is libstdc++-v3 thread-safe?): Update"}, {"sha": "69d9886887fa4012c92190bc100a8afd25f66cbe", "filename": "libstdc++-v3/docs/html/17_intro/howto.html", "status": "modified", "additions": 14, "deletions": 38, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2a8516ce528253bf241f1730876c904823e469/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2a8516ce528253bf241f1730876c904823e469/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html?ref=aa2a8516ce528253bf241f1730876c904823e469", "patch": "@@ -67,7 +67,8 @@ <h2><a name=\"3\">Thread-safety</a></h2>\n       means for a library (not a general program).  We currently use the\n       <a href=\"http://www.sgi.com/tech/stl/thread_safety.html\">same\n       definition that SGI</a> uses for their STL subset.\n-      <em>Please see the many cautions given in HOWTOs on containers.</em>\n+      <em>Please see the many cautions given in\n+      <a href=\"../23_containers/howto.html\">HOWTOs on containers</a>.</em>\n    </p>\n    <p>Here is another attempt at explaining the dangers of using the\n       STL with threading support without understanding some important\n@@ -109,46 +110,21 @@ <h2><a name=\"3\">Thread-safety</a></h2>\n       &quot;Thread Next&quot; to move down the thread.  This farm is in\n       latest-to-oldest order.\n       <ul>\n+        <li>Our threading expert Loren gives a breakdown of\n+        <a href=\"http://gcc.gnu.org/ml/libstdc++/2001-10/msg00024.html\">the\n+        six situations involving threads</a> for the 3.0 release series.\n         <li><a href=\"http://gcc.gnu.org/ml/libstdc++/2001-05/msg00384.html\">\n-        inspired this most recent updating of issues with threading\n+        This message</a> inspired a recent updating of issues with threading\n         and the SGI STL library.  It also contains some example\n-        POSIX-multithreaded STL code.</a>\n-        <li> <a href=\"http://gcc.gnu.org/ml/libstdc++/2001-05/msg00136.html\">\n-        an early analysis of why __USE_MALLOC should be disabled for\n-        the 3.0 release of libstdc++.</a>\n-      </ul>\n-      <br>\n-      Here are discussions that took place before the current snapshot;\n-      they are still relevant and instructive.  (Some of them may not work;\n-      as the drive containing some of the 1999 archives crashed, and nobody\n-      has had time to recover the backups.)\n-      <br>\n-      <ul>\n-        <li>One way of preventing memory leaks by the old default memory\n-            allocator in multithreaded code is\n-            <a href=\"http://gcc.gnu.org/ml/gcc/1999-11n/msg00431.html\">discussed here</a>.\n-        <li><a href=\"http://gcc.gnu.org/ml/libstdc++/1999-q3/msg00167.html\">This thread\n-            concerns strings</a>.\n-        <li><a href=\"http://gcc.gnu.org/ml/libstdc++/1999-q2/msg00339.html\">So does this\n-            one</a>.  This initial message also refers to another\n-            thread in the GCC mailing list...\n-        <li><a href=\"http://gcc.gnu.org/ml/gcc/1999-06n/msg00680.html\">which is here</a>,\n-            and goes on for some time.  Ironically, the initial message\n-            in this thread also mentions another threading thread...\n-        <li><a href=\"http://gcc.gnu.org/ml/gcc-bugs/1999-04n/msg00777.html\">beginning here</a>,\n-            and talking about pthreads.  (Note that a much more recent\n-            message from the first thread in this list notes that\n-            <a href=\"http://gcc.gnu.org/ml/libstdc++/1999-q3/msg00176.html\">pthreads\n-            should not be used as a starting point</a> for making\n-            libstdc++ threadsafe.)\n-        <li><a href=\"http://gcc.gnu.org/ml/libstdc++/1999-q2/msg00168.html\">This\n-            message</a>,\n-            <a href=\"http://gcc.gnu.org/ml/libstdc++/1999-q2/msg00159.html\">this one</a>,\n-            and <a href=\"http://gcc.gnu.org/ml/libstdc++/1999-q2/msg00156.html\">this one</a>\n-            are the tops of related threads (all within the same time\n-            period) discussing threading and the IO library.  Much of it\n-            is dealing with the C library, but C++ is included as well.\n+        POSIX-multithreaded STL code.\n+        <li><a href=\"http://gcc.gnu.org/ml/libstdc++/2001-05/msg00136.html\">\n+        Here</a> is an early analysis of why __USE_MALLOC should be disabled\n+        for the 3.0 release of libstdc++.</a>\n       </ul>\n+      (A large selection of links to older messages has been removed; many\n+      of the messages from 1999 were lost in a disk crash, and the few\n+      people with access to the backup tapes have been too swamped with work\n+      to restore them.  Many of the points have been superceded anyhow.)\n    </p>\n    <p>This section will be updated as new and interesting issues come\n       to light."}, {"sha": "650a5ec700aee350df9741fa997deb8eb89c15c3", "filename": "libstdc++-v3/docs/html/faq/index.html", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2a8516ce528253bf241f1730876c904823e469/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2a8516ce528253bf241f1730876c904823e469/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.html?ref=aa2a8516ce528253bf241f1730876c904823e469", "patch": "@@ -687,49 +687,46 @@ <h2><a name=\"5_5\">5.5 [removed]</a></h2>\n <hr>\n    <h2><a name=\"5_6\">5.6 Is libstdc++-v3 thread-safe?</a></h2>\n       <p>When the system's libc is itself thread-safe, a non-generic\n-         implementation of atomicity.h exists for the architecture, and\n-\t gcc itself reports a thread model other than single; libstdc++-v3\n+         implementation of atomicity.h exists for the architecture, and gcc\n+         itself reports a thread model other than single; libstdc++-v3\n          strives to be thread-safe.  The user-code must guard against\n-         concurrent method calls which may access any particular\n-         library object's state.  Typically, the application\n-         programmer may infer what object locks must be held based on\n-         the objects referenced in a method call.  Without getting\n-         into great detail, here is an example which requires\n-         user-level locks:\n-      </p>\n+         concurrent method calls which may access any particular library\n+         object's state.  Typically, the application programmer may infer\n+         what object locks must be held based on the objects referenced in\n+         a method call.  Without getting into great detail, here is an\n+         example which requires user-level locks:\n          <pre>\n-       library_class_a shared_object_a;\n+     library_class_a shared_object_a;\n \n-       thread_main () {\n-         library_class_b *object_b = new library_class_b;\n-\t shared_object_a.add_b (object_b); // must hold lock for shared_object_a\n-\t shared_object_a.mutate (); // must hold lock for shared_object_a\n-       }\n+     thread_main () {\n+       library_class_b *object_b = new library_class_b;\n+       shared_object_a.add_b (object_b);   // must hold lock for shared_object_a\n+       shared_object_a.mutate ();          // must hold lock for shared_object_a\n+     }\n \n-       // Multiple copies of thread_main() are started in independent threads.\n-         </pre>\n-      <p>Under the assumption that object_a and object_b are never\n-         exposed to another thread, here is an example that should not\n-         require any user-level locks:\n+     // Multiple copies of thread_main() are started in independent threads.</pre>\n       </p>\n+      <p>Under the assumption that object_a and object_b are never exposed to\n+         another thread, here is an example that should not require any\n+         user-level locks:\n          <pre>\n-       thread_main () {\n-         library_class_a object_a;\n-         library_class_b *object_b = new library_class_b;\n-\t object_a.add_b (object_b);\n-\t object_a.mutate ();\n-       }\n-         </pre>\n-      <p>All library objects are safe to use in a multithreaded\n-         program as long as each thread carefully locks out access by\n-         any other thread while it uses any object visible to another\n-         thread.  This requirement includes both read and write access\n-         to objects; do not assume that two threads may read a shared\n-         standard container at the same time.\n-      </p>\n-      <p>See chapters <a href=\"../17_intro/howto.html#3\">17</a>,\n-         <a href=\"../23_containers/howto.html#3\">23</a> and\n-\t <a href=\"../27_io/howto.html#9\">27</a> for more information.\n+     thread_main () {\n+       library_class_a object_a;\n+       library_class_b *object_b = new library_class_b;\n+       object_a.add_b (object_b);\n+       object_a.mutate ();\n+     } </pre>\n+      </p>\n+      <p>All library objects are safe to use in a multithreaded program as\n+         long as each thread carefully locks out access by any other thread\n+         while it uses any object visible to another thread.  This requirement\n+         includes both read and write access to objects; do not assume that\n+         two threads may read a shared standard container at the same time.\n+      </p>\n+      <p>See chapters <a href=\"../17_intro/howto.html#3\">17</a> (library\n+         introduction), <a href=\"../23_containers/howto.html#3\">23</a>\n+         (containers), and <a href=\"../27_io/howto.html#9\">27</a> (I/O) for\n+         more information.\n       </p>\n \n <hr>"}, {"sha": "44c4748083c52210dd35eb96caec6ca16e50f3b9", "filename": "libstdc++-v3/docs/html/faq/index.txt", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa2a8516ce528253bf241f1730876c904823e469/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa2a8516ce528253bf241f1730876c904823e469/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ffaq%2Findex.txt?ref=aa2a8516ce528253bf241f1730876c904823e469", "patch": "@@ -548,15 +548,45 @@ http://clisp.cons.org/~haible/gccinclude-glibc-2.2-compat.diff\n \n 5.6 Is libstdc++-v3 thread-safe?\n \n-   Quick  answer:  no,  as  of  3.0,  most of the library is not safe for\n-   multithreaded access. The string class is MT-safe.\n-\n-   This  is  assuming  that  your  idea of \"multithreaded\" is the same as\n-   ours...  The  general  question  of multithreading and libstdc++-v3 is\n-   addressed in the chapter-specific advice for [80]Library Introduction.\n-   Threadsafe  containers  are covered in more detail in [81]the Received\n-   Wisdom  section  on  containers.  Threading  and  I/O are discussed in\n-   [82]the I/O chapter.\n+   When   the   system's   libc  is  itself  thread-safe,  a  non-generic\n+   implementation  of  atomicity.h  exists  for the architecture, and gcc\n+   itself  reports a thread model other than single; libstdc++-v3 strives\n+   to  be thread-safe. The user-code must guard against concurrent method\n+   calls   which  may  access  any  particular  library  object's  state.\n+   Typically, the application programmer may infer what object locks must\n+   be  held  based  on  the  objects referenced in a method call. Without\n+   getting   into  great  detail,  here  is  an  example  which  requires\n+   user-level locks:\n+     library_class_a shared_object_a;\n+\n+     thread_main () {\n+       library_class_b *object_b = new library_class_b;\n+       shared_object_a.add_b (object_b);   // must hold lock for shared_object_\n+a\n+       shared_object_a.mutate ();          // must hold lock for shared_object_\n+a\n+     }\n+\n+     // Multiple copies of thread_main() are started in independent threads.\n+\n+   Under  the  assumption that object_a and object_b are never exposed to\n+   another  thread,  here  is  an  example  that  should  not require any\n+   user-level locks:\n+     thread_main () {\n+       library_class_a object_a;\n+       library_class_b *object_b = new library_class_b;\n+       object_a.add_b (object_b);\n+       object_a.mutate ();\n+     }\n+\n+   All library objects are safe to use in a multithreaded program as long\n+   as each thread carefully locks out access by any other thread while it\n+   uses  any  object visible to another thread. This requirement includes\n+   both  read and write access to objects; do not assume that two threads\n+   may read a shared standard container at the same time.\n+\n+   See  chapters  [80]17 (library introduction), [81]23 (containers), and\n+   [82]27 (I/O) for more information.\n      _________________________________________________________________\n \n 5.7 How do I get a copy of the ISO C++ Standard?\n@@ -660,8 +690,8 @@ References\n   78. http://www.sgi.com/Technology/STL/\n   79. ../ext/howto.html\n   80. ../17_intro/howto.html#3\n-  81. ../23_containers/howto.html\n-  82. ../27_io/howto.html\n+  81. ../23_containers/howto.html#3\n+  82. ../27_io/howto.html#9\n   83. http://www.ansi.org/\n   84. http://webstore.ansi.org/ansidocstore/product.asp?sku=ISO%2FIEC+14882%2D1998\n   85. http://www.iso.ch/"}]}