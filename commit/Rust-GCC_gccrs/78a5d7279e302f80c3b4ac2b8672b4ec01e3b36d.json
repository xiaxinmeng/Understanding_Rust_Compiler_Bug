{"sha": "78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhhNWQ3Mjc5ZTMwMmY4MGMzYjRhYzJiODY3MmI0ZWMwMWUzYjM2ZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2005-09-30T21:36:44Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2005-09-30T21:36:44Z"}, "message": "arm.md (movqi): On thumb when optimizing...\n\n\t* arm.md (movqi): On thumb when optimizing, handle loading from\n\tmemory by describing this as taking a subreg of a zero-extended load\n\tinto an SImode register.\n\t(movhi): Likewise.\n\nFrom-SVN: r104836", "tree": {"sha": "66995d70c8e0a99c5b9701103d4e14a750360085", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66995d70c8e0a99c5b9701103d4e14a750360085"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d/comments", "author": null, "committer": null, "parents": [{"sha": "3c993f84de5f901dde406e4065f3f623e92fff3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c993f84de5f901dde406e4065f3f623e92fff3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c993f84de5f901dde406e4065f3f623e92fff3a"}], "stats": {"total": 104, "additions": 62, "deletions": 42}, "files": [{"sha": "9baa569fa21d129ac1155d0e9006055e0da8c43a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d", "patch": "@@ -1,3 +1,10 @@\n+2005-09-30  Richard Earnshaw  <richard.earnshaw@arm.com>\n+\n+\t* arm.md (movqi): On thumb when optimizing, handle loading from \n+\tmemory by describing this as taking a subreg of a zero-extended load\n+\tinto an SImode register.\n+\t(movhi): Likewise.\n+\n 2005-09-30  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* reload1.c (merge_assigned_reloads): Do not change any"}, {"sha": "783fab06e8bbbc3da3760ddee7239dd9c26aa2a8", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 55, "deletions": 42, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=78a5d7279e302f80c3b4ac2b8672b4ec01e3b36d", "patch": "@@ -4729,8 +4729,13 @@\n     {\n       if (!no_new_pseudos)\n         {\n-          if (GET_CODE (operands[0]) != REG)\n-\t    operands[1] = force_reg (HImode, operands[1]);\n+\t  if (GET_CODE (operands[1]) == CONST_INT)\n+\t    {\n+\t      rtx reg = gen_reg_rtx (SImode);\n+\n+\t      emit_insn (gen_movsi (reg, operands[1]));\n+\t      operands[1] = gen_lowpart (HImode, reg);\n+\t    }\n \n           /* ??? We shouldn't really get invalid addresses here, but this can\n \t     happen if we are passed a SP (never OK for HImode/QImode) or \n@@ -4753,11 +4758,23 @@\n \t    operands[1]\n \t      = replace_equiv_address (operands[1],\n \t\t\t\t       copy_to_reg (XEXP (operands[1], 0)));\n+\n+\t  if (GET_CODE (operands[1]) == MEM && optimize > 0)\n+\t    {\n+\t      rtx reg = gen_reg_rtx (SImode);\n+\n+\t      emit_insn (gen_zero_extendhisi2 (reg, operands[1]));\n+\t      operands[1] = gen_lowpart (HImode, reg);\n+\t    }\n+\n+          if (GET_CODE (operands[0]) == MEM)\n+\t    operands[1] = force_reg (HImode, operands[1]);\n         }\n-      /* Handle loading a large integer during reload.  */\n       else if (GET_CODE (operands[1]) == CONST_INT\n \t        && !CONST_OK_FOR_THUMB_LETTER (INTVAL (operands[1]), 'I'))\n         {\n+\t  /* Handle loading a large integer during reload.  */\n+\n           /* Writing a constant to memory needs a scratch, which should\n \t     be handled with SECONDARY_RELOADs.  */\n           gcc_assert (GET_CODE (operands[0]) == REG);\n@@ -4938,37 +4955,20 @@\n         (match_operand:QI 1 \"general_operand\" \"\"))]\n   \"TARGET_EITHER\"\n   \"\n-  if (TARGET_ARM)\n-    {\n-      /* Everything except mem = const or mem = mem can be done easily */\n-\n-      if (!no_new_pseudos)\n-        {\n-          if (GET_CODE (operands[1]) == CONST_INT)\n-\t    {\n-\t      rtx reg = gen_reg_rtx (SImode);\n-\n-\t      emit_insn (gen_movsi (reg, operands[1]));\n-\t      operands[1] = gen_lowpart (QImode, reg);\n-\t    }\n-\t  if (GET_CODE (operands[1]) == MEM && optimize > 0)\n-\t    {\n-\t      rtx reg = gen_reg_rtx (SImode);\n+  /* Everything except mem = const or mem = mem can be done easily */\n \n-\t      emit_insn (gen_zero_extendqisi2 (reg, operands[1]));\n-\t      operands[1] = gen_lowpart (QImode, reg);\n-\t    }\n-          if (GET_CODE (operands[0]) == MEM)\n-\t    operands[1] = force_reg (QImode, operands[1]);\n-        }\n-    }\n-  else /* TARGET_THUMB */\n+  if (!no_new_pseudos)\n     {\n-      if (!no_new_pseudos)\n-        {\n-          if (GET_CODE (operands[0]) != REG)\n-\t    operands[1] = force_reg (QImode, operands[1]);\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  rtx reg = gen_reg_rtx (SImode);\n \n+\t  emit_insn (gen_movsi (reg, operands[1]));\n+\t  operands[1] = gen_lowpart (QImode, reg);\n+\t}\n+\n+      if (TARGET_THUMB)\n+\t{\n           /* ??? We shouldn't really get invalid addresses here, but this can\n \t     happen if we are passed a SP (never OK for HImode/QImode) or\n \t     virtual register (rejected by GO_IF_LEGITIMATE_ADDRESS for\n@@ -4989,19 +4989,32 @@\n \t     operands[1]\n \t       = replace_equiv_address (operands[1],\n \t\t\t\t\tcopy_to_reg (XEXP (operands[1], 0)));\n-        }\n+\t}\n+\n+      if (GET_CODE (operands[1]) == MEM && optimize > 0)\n+\t{\n+\t  rtx reg = gen_reg_rtx (SImode);\n+\n+\t  emit_insn (gen_zero_extendqisi2 (reg, operands[1]));\n+\t  operands[1] = gen_lowpart (QImode, reg);\n+\t}\n+\n+      if (GET_CODE (operands[0]) == MEM)\n+\toperands[1] = force_reg (QImode, operands[1]);\n+    }\n+  else if (TARGET_THUMB\n+\t   && GET_CODE (operands[1]) == CONST_INT\n+\t   && !CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n+    {\n       /* Handle loading a large integer during reload.  */\n-      else if (GET_CODE (operands[1]) == CONST_INT\n-\t       && !CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'I'))\n-        {\n-          /* Writing a constant to memory needs a scratch, which should\n-\t     be handled with SECONDARY_RELOADs.  */\n-          gcc_assert (GET_CODE (operands[0]) == REG);\n \n-          operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n-          emit_insn (gen_movsi (operands[0], operands[1]));\n-          DONE;\n-       }\n+      /* Writing a constant to memory needs a scratch, which should\n+\t be handled with SECONDARY_RELOADs.  */\n+      gcc_assert (GET_CODE (operands[0]) == REG);\n+\n+      operands[0] = gen_rtx_SUBREG (SImode, operands[0], 0);\n+      emit_insn (gen_movsi (operands[0], operands[1]));\n+      DONE;\n     }\n   \"\n )"}]}