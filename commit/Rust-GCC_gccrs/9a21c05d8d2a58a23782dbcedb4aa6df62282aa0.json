{"sha": "9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEyMWMwNWQ4ZDJhNThhMjM3ODJkYmNlZGI0YWE2ZGY2MjI4MmFhMA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2015-09-10T20:22:37Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2015-09-10T20:22:37Z"}, "message": "rs6000.c (swap_web_entry): Update preceding commentary to simplify permute mask adjustment equation.\n\n[gcc]\n\n2015-09-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (swap_web_entry): Update preceding\n\tcommentary to simplify permute mask adjustment equation.\n\t(special_handling_values): Add SH_VPERM.\n\t(const_load_sequence_p): New function.\n\t(insn_is_swappable_p): Add logic to recognize an UNSPEC_VPERM with\n\tthe mask loaded from the constant pool.\n\t(adjust_vperm): New function.\n\t(handle_special_swappables): Call adjust_vperm.\n\t(dump_swap_insn_table): Handle SH_VPERM.\n\n[gcc/testsuite]\n\n2015-09-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/swaps-p8-20.c: New test.\n\t* gcc.target/powerpc/swaps-p8-21.c: New test.\n\nFrom-SVN: r227664", "tree": {"sha": "852f3146ea8487a44df261e0f0362cbc3695e8ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/852f3146ea8487a44df261e0f0362cbc3695e8ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7890973856c5d2e49392b6c4a1175ccb222a030", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7890973856c5d2e49392b6c4a1175ccb222a030", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7890973856c5d2e49392b6c4a1175ccb222a030"}], "stats": {"total": 277, "additions": 271, "deletions": 6}, "files": [{"sha": "7f15326d40af6c2d039dc62268617377d00ca115", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "patch": "@@ -1,3 +1,15 @@\n+2015-09-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (swap_web_entry): Update preceding\n+\tcommentary to simplify permute mask adjustment equation.\n+\t(special_handling_values): Add SH_VPERM.\n+\t(const_load_sequence_p): New function.\n+\t(insn_is_swappable_p): Add logic to recognize an UNSPEC_VPERM with\n+\tthe mask loaded from the constant pool.\n+\t(adjust_vperm): New function.\n+\t(handle_special_swappables): Call adjust_vperm.\n+\t(dump_swap_insn_table): Handle SH_VPERM.\n+\n 2015-09-10  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* shrink-wrap.c (requires_stack_frame_p): Remove static."}, {"sha": "7278792d0dc8f5bb4f1c991d0fb9bb88693d4d45", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 198, "deletions": 6, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "patch": "@@ -34943,10 +34943,8 @@ emit_fusion_gpr_load (rtx target, rtx mem)\n    throughout the computation, we can get correct behavior by replacing\n    M with M' as follows:\n \n-            { M[i+8]+8 : i < 8, M[i+8] in [0,7] U [16,23]\n-    M'[i] = { M[i+8]-8 : i < 8, M[i+8] in [8,15] U [24,31]\n-            { M[i-8]+8 : i >= 8, M[i-8] in [0,7] U [16,23]\n-            { M[i-8]-8 : i >= 8, M[i-8] in [8,15] U [24,31]\n+    M'[i] = { (M[i]+8)%16      : M[i] in [0,15]\n+            { ((M[i]+8)%16)+16 : M[i] in [16,31]\n \n    This seems promising at first, since we are just replacing one mask\n    with another.  But certain masks are preferable to others.  If M\n@@ -34964,7 +34962,11 @@ emit_fusion_gpr_load (rtx target, rtx mem)\n    mask to be produced by an UNSPEC_LVSL, in which case the mask \n    cannot be known at compile time.  In such a case we would have to\n    generate several instructions to compute M' as above at run time,\n-   and a cost model is needed again.  */\n+   and a cost model is needed again.\n+\n+   However, when the mask M for an UNSPEC_VPERM is loaded from the\n+   constant pool, we can replace M with M' as above at no cost\n+   beyond adding a constant pool entry.  */\n \n /* This is based on the union-find logic in web.c.  web_entry_base is\n    defined in df.h.  */\n@@ -35016,7 +35018,8 @@ enum special_handling_values {\n   SH_EXTRACT,\n   SH_SPLAT,\n   SH_XXPERMDI,\n-  SH_CONCAT\n+  SH_CONCAT,\n+  SH_VPERM\n };\n \n /* Union INSN with all insns containing definitions that reach USE.\n@@ -35151,6 +35154,64 @@ insn_is_swap_p (rtx insn)\n   return 1;\n }\n \n+/* Return TRUE if insn is a swap fed by a load from the constant pool.  */\n+static bool\n+const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n+{\n+  unsigned uid = INSN_UID (insn);\n+  if (!insn_entry[uid].is_swap || insn_entry[uid].is_load)\n+    return false;\n+\n+  /* Find the unique use in the swap and locate its def.  If the def\n+     isn't unique, punt.  */\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+  df_ref use;\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    {\n+      struct df_link *def_link = DF_REF_CHAIN (use);\n+      if (!def_link || def_link->next)\n+\treturn false;\n+\n+      rtx def_insn = DF_REF_INSN (def_link->ref);\n+      unsigned uid2 = INSN_UID (def_insn);\n+      if (!insn_entry[uid2].is_load || !insn_entry[uid2].is_swap)\n+\treturn false;\n+\n+      rtx body = PATTERN (def_insn);\n+      if (GET_CODE (body) != SET\n+\t  || GET_CODE (SET_SRC (body)) != VEC_SELECT\n+\t  || GET_CODE (XEXP (SET_SRC (body), 0)) != MEM)\n+\treturn false;\n+\n+      rtx mem = XEXP (SET_SRC (body), 0);\n+      rtx base_reg = XEXP (mem, 0);\n+\n+      df_ref base_use;\n+      insn_info = DF_INSN_INFO_GET (def_insn);\n+      FOR_EACH_INSN_INFO_USE (base_use, insn_info)\n+\t{\n+\t  if (!rtx_equal_p (DF_REF_REG (base_use), base_reg))\n+\t    continue;\n+\n+\t  struct df_link *base_def_link = DF_REF_CHAIN (base_use);\n+\t  if (!base_def_link || base_def_link->next)\n+\t    return false;\n+\n+\t  rtx tocrel_insn = DF_REF_INSN (base_def_link->ref);\n+\t  rtx tocrel_body = PATTERN (tocrel_insn);\n+\t  rtx base, offset;\n+\t  if (GET_CODE (tocrel_body) != SET)\n+\t    return false;\n+\t  if (!toc_relative_expr_p (SET_SRC (tocrel_body), false))\n+\t    return false;\n+\t  split_const (XVECEXP (tocrel_base, 0, 0), &base, &offset);\n+\t  if (GET_CODE (base) != SYMBOL_REF || !CONSTANT_POOL_ADDRESS_P (base))\n+\t    return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n /* Return 1 iff OP is an operand that will not be affected by having\n    vector doublewords swapped in memory.  */\n static unsigned int\n@@ -35410,6 +35471,32 @@ insn_is_swappable_p (swap_web_entry *insn_entry, rtx insn,\n       return 1;\n     }\n \n+  /* An UNSPEC_VPERM is ok if the mask operand is loaded from the\n+     constant pool.  */\n+  if (GET_CODE (body) == SET\n+      && GET_CODE (SET_SRC (body)) == UNSPEC\n+      && XINT (SET_SRC (body), 1) == UNSPEC_VPERM\n+      && XVECLEN (SET_SRC (body), 0) == 3\n+      && GET_CODE (XVECEXP (SET_SRC (body), 0, 2)) == REG)\n+    {\n+      rtx mask_reg = XVECEXP (SET_SRC (body), 0, 2);\n+      struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+      df_ref use;\n+      FOR_EACH_INSN_INFO_USE (use, insn_info)\n+\tif (rtx_equal_p (DF_REF_REG (use), mask_reg))\n+\t  {\n+\t    struct df_link *def_link = DF_REF_CHAIN (use);\n+\t    /* Punt if multiple definitions for this reg.  */\n+\t    if (def_link && !def_link->next &&\n+\t\tconst_load_sequence_p (insn_entry,\n+\t\t\t\t       DF_REF_INSN (def_link->ref)))\n+\t      {\n+\t\t*special = SH_VPERM;\n+\t\treturn 1;\n+\t      }\n+\t  }\n+    }\n+\n   /* Otherwise check the operands for vector lane violations.  */\n   return rtx_is_swappable_p (body, special);\n }\n@@ -35742,6 +35829,105 @@ adjust_concat (rtx_insn *insn)\n     fprintf (dump_file, \"Reversing inputs for concat %d\\n\", INSN_UID (insn));\n }\n \n+/* Given an UNSPEC_VPERM insn, modify the mask loaded from the\n+   constant pool to reflect swapped doublewords.  */\n+static void\n+adjust_vperm (rtx_insn *insn)\n+{\n+  /* We previously determined that the UNSPEC_VPERM was fed by a\n+     swap of a swapping load of a TOC-relative constant pool symbol.\n+     Find the MEM in the swapping load and replace it with a MEM for\n+     the adjusted mask constant.  */\n+  rtx set = PATTERN (insn);\n+  rtx mask_reg = XVECEXP (SET_SRC (set), 0, 2);\n+\n+  /* Find the swap.  */\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+  df_ref use;\n+  rtx_insn *swap_insn = 0;\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    if (rtx_equal_p (DF_REF_REG (use), mask_reg))\n+      {\n+\tstruct df_link *def_link = DF_REF_CHAIN (use);\n+\tgcc_assert (def_link && !def_link->next);\n+\tswap_insn = DF_REF_INSN (def_link->ref);\n+\tbreak;\n+      }\n+  gcc_assert (swap_insn);\n+  \n+  /* Find the load.  */\n+  insn_info = DF_INSN_INFO_GET (swap_insn);\n+  rtx_insn *load_insn = 0;\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    {\n+      struct df_link *def_link = DF_REF_CHAIN (use);\n+      gcc_assert (def_link && !def_link->next);\n+      load_insn = DF_REF_INSN (def_link->ref);\n+      break;\n+    }\n+  gcc_assert (load_insn);\n+\n+  /* Find the TOC-relative symbol access.  */\n+  insn_info = DF_INSN_INFO_GET (load_insn);\n+  rtx_insn *tocrel_insn = 0;\n+  FOR_EACH_INSN_INFO_USE (use, insn_info)\n+    {\n+      struct df_link *def_link = DF_REF_CHAIN (use);\n+      gcc_assert (def_link && !def_link->next);\n+      tocrel_insn = DF_REF_INSN (def_link->ref);\n+      break;\n+    }\n+  gcc_assert (tocrel_insn);\n+\n+  /* Find the embedded CONST_VECTOR.  We have to call toc_relative_expr_p\n+     to set tocrel_base; otherwise it would be unnecessary as we've\n+     already established it will return true.  */\n+  rtx base, offset;\n+  if (!toc_relative_expr_p (SET_SRC (PATTERN (tocrel_insn)), false))\n+    gcc_unreachable ();\n+  split_const (XVECEXP (tocrel_base, 0, 0), &base, &offset);\n+  rtx const_vector = get_pool_constant (base);\n+  gcc_assert (GET_CODE (const_vector) == CONST_VECTOR);\n+\n+  /* Create an adjusted mask from the initial mask.  */\n+  unsigned int new_mask[16], i, val;\n+  for (i = 0; i < 16; ++i) {\n+    val = INTVAL (XVECEXP (const_vector, 0, i));\n+    if (val < 16)\n+      new_mask[i] = (val + 8) % 16;\n+    else\n+      new_mask[i] = ((val + 8) % 16) + 16;\n+  }\n+\n+  /* Create a new CONST_VECTOR and a MEM that references it.  */\n+  rtx vals = gen_rtx_PARALLEL (V16QImode, rtvec_alloc (16));\n+  for (i = 0; i < 16; ++i)\n+    XVECEXP (vals, 0, i) = GEN_INT (new_mask[i]);\n+  rtx new_const_vector = gen_rtx_CONST_VECTOR (V16QImode, XVEC (vals, 0));\n+  rtx new_mem = force_const_mem (V16QImode, new_const_vector);\n+  /* This gives us a MEM whose base operand is a SYMBOL_REF, which we\n+     can't recognize.  Force the SYMBOL_REF into a register.  */\n+  if (!REG_P (XEXP (new_mem, 0))) {\n+    rtx base_reg = force_reg (Pmode, XEXP (new_mem, 0));\n+    XEXP (new_mem, 0) = base_reg;\n+    /* Move the newly created insn ahead of the load insn.  */\n+    rtx_insn *force_insn = get_last_insn ();\n+    remove_insn (force_insn);\n+    rtx_insn *before_load_insn = PREV_INSN (load_insn);\n+    add_insn_after (force_insn, before_load_insn, BLOCK_FOR_INSN (load_insn));\n+    df_insn_rescan (before_load_insn);\n+    df_insn_rescan (force_insn);\n+  }\n+\n+  /* Replace the MEM in the load instruction and rescan it.  */\n+  XEXP (SET_SRC (PATTERN (load_insn)), 0) = new_mem;\n+  INSN_CODE (load_insn) = -1; /* Force re-recognition.  */\n+  df_insn_rescan (load_insn);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Adjusting mask for vperm %d\\n\", INSN_UID (insn));\n+}\n+\n /* The insn described by INSN_ENTRY[I] can be swapped, but only\n    with special handling.  Take care of that here.  */\n static void\n@@ -35796,6 +35982,10 @@ handle_special_swappables (swap_web_entry *insn_entry, unsigned i)\n       /* Reverse the order of a concatenation operation.  */\n       adjust_concat (insn);\n       break;\n+    case SH_VPERM:\n+      /* Change the mask loaded from the constant pool for a VPERM.  */\n+      adjust_vperm (insn);\n+      break;\n     }\n }\n \n@@ -35872,6 +36062,8 @@ dump_swap_insn_table (swap_web_entry *insn_entry)\n \t      fputs (\"special:xxpermdi \", dump_file);\n \t    else if (insn_entry[i].special_handling == SH_CONCAT)\n \t      fputs (\"special:concat \", dump_file);\n+\t    else if (insn_entry[i].special_handling == SH_VPERM)\n+\t      fputs (\"special:vperm \", dump_file);\n \t  }\n \tif (insn_entry[i].web_not_optimizable)\n \t  fputs (\"unoptimizable \", dump_file);"}, {"sha": "4772dc0d4266bb4b80c309248802330368cf3bcf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "patch": "@@ -1,3 +1,8 @@\n+2015-09-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/swaps-p8-20.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-21.c: New test.\n+\n 2015-09-10  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/67526"}, {"sha": "7463781281ebdd00f1756f4f15ff4259f072f816", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-20.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-20.c?ref=9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } }\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-O2 -mcpu=power8 -maltivec\" } */\n+\n+/* The expansion for vector character multiply introduces a vperm operation.\n+   This tests that the swap optimization to remove swaps by changing the\n+   vperm mask results in correct code.  */\n+\n+#include <altivec.h>\n+\n+void abort ();\n+\n+vector unsigned char r;\n+vector unsigned char v =\n+  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+vector unsigned char i =\n+  { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n+vector unsigned char e =\n+  {0, 2, 6, 12, 20, 30, 42, 56, 72, 90, 110, 132, 156, 182, 210, 240};\n+\n+int main ()\n+{\n+  int j;\n+  r = v * i;\n+  if (!vec_all_eq (r, e))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "b981fcf2f36ce5759665383cd572c4672bb33113", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-21.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a21c05d8d2a58a23782dbcedb4aa6df62282aa0/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-21.c?ref=9a21c05d8d2a58a23782dbcedb4aa6df62282aa0", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } }\n+/* { dg-options \"-O2 -mcpu=power8 -maltivec\" } */\n+\n+/* The expansion for vector character multiply introduces a vperm operation.\n+   This tests that changing the vperm mask allows us to remove all swaps\n+   from the generated code.  */\n+\n+#include <altivec.h>\n+\n+void abort ();\n+\n+vector unsigned char r;\n+vector unsigned char v =\n+  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+vector unsigned char i =\n+  { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n+\n+int main ()\n+{\n+  int j;\n+  r = v * i;\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"vperm\" 1 } } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */"}]}