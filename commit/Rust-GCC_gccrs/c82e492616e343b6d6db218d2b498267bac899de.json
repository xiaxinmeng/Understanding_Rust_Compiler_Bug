{"sha": "c82e492616e343b6d6db218d2b498267bac899de", "node_id": "C_kwDOANBUbNoAKGM4MmU0OTI2MTZlMzQzYjZkNmRiMjE4ZDJiNDk4MjY3YmFjODk5ZGU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-10T16:01:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-10T16:03:58Z"}, "message": "libstdc++: Some time_get fixes [PR78714]\n\nThe following patch is an attempt to fix various time_get related issues.\nSorry, it is long...\n\nOne of them is PR78714.  It seems _M_extract_via_format has been written\nwith how strftime behaves in mind rather than how strptime behaves.\nThere is a significant difference between the two, for strftime %a and %A\nbehave differently etc., one emits an abbreviated name, the other full name.\nFor strptime both should behave the same and accept both the full or\nabbreviated names.  This needed large changes in _M_extract_name, which\nwas assuming the names are unique and names aren't prefixes of other names.\nThe _M_extract_name changes allow to deal with those cases.  As can be\nseen in the new testcase, e.g. for %b and english locales we need to\naccept both Apr and April.  If we see Apr in the input, the code looks\nat whether there is end right after those 3 chars or if the next\ncharacter doesn't match characters in the longer names; in that case\nit accepts the abbreviated name.  Otherwise, if the input has Apri, it\ncommits to a longer name and fails if it isn't April.  This behavior is\ndifferent from strptime, which for %bix and Aprix accepts it, but for\nan input iterator I'm afraid we can't do better, we can't go back (peek\nmore than the current character).\n\nAnother case is that %d and %e in strptime should work the same, while\npreviously the code was hardcoding that %d would be 01 to 31 and %e\n 1 to 31 (with leading 0 replaced by space).\nstrptime POSIX 2009 documentation seems to suggest for numbers it should\naccept up to the specified number of digits rather than exactly that number\nof digits:\nThe pattern \"[x,y]\" indicates that the value shall fall within the range\ngiven (both bounds being inclusive), and the maximum number of characters scanned\nshall be the maximum required to represent any value in the range without leading\nzeros.\nso by my reading \"1:\" is valid for \"%H:\".\nThe glibc strptime implementation actually skips any amount of whitespace\nin all the cases where a number is read, my current patch skips a single\nspace at the start of %d/%e but not the others, but doesn't subtract the\nspace length from the len characters.\nOne option would be to do the leading whitespace skipping in _M_extract_num\nbut take it into account how many digits can be read.\nThis matters for \" 12:\" and \"%H:\", but not for \" 12:\" and \" %H:\"\nas in the latter case the space in the format string results in all the\nwhitespace at the start to be consumed.\nNote, the allowing of a single digit rather than 2 changes a behavior in\nother ways, e.g. when seeing 40 in a number for range [1, 31] we reject\nit as before, but previously we'd keep *ret == '4' because it was assuming\nit has to be 2 digits and 40 isn't valid, so we know error already on the\n4, but now we accept the 4 as value and fail iff the next format string\ndoesn't match the 0.\nAlso, previously it wasn't really checking the number was in the right\nrange, it would accept 00 for [1, 31] numbers, or would accept 39.\n\nAnother thing is that %I was parsing 12 as tm_hour 12 rather than as tm_hour 0\nlike e.g. glibc does.\n\nAnother thing is that %t was matching a single tab and %n a single newline,\nwhile strptime docs say it skips over whitespace (again, zero or more).\n\nAnother thing is that %p wasn't handled at all, I think this was the main\ncause of\nFAIL: 22_locale/time_get/get_time/char/2.cc execution test\nFAIL: 22_locale/time_get/get_time/char/wrapped_env.cc execution test\nFAIL: 22_locale/time_get/get_time/char/wrapped_locale.cc execution test\nFAIL: 22_locale/time_get/get_time/wchar_t/2.cc execution test\nFAIL: 22_locale/time_get/get_time/wchar_t/wrapped_env.cc execution test\nFAIL: 22_locale/time_get/get_time/wchar_t/wrapped_locale.cc execution test\nbefore this patch, because en_HK* locales do use %I and %p in it.\nThe patch handles %p only if it follows %I (i.e. when the hour is parsed\nfirst), which is the more usual case (in glibc):\ngrep '%I' localedata/locales/* | grep '%I.*%p' | wc -l\n282\ngrep '%I' localedata/locales/* | grep -v '%I.*%p' | wc -l\n44\ngrep '%I' localedata/locales/* | grep -v '%p' | wc -l\n17\nThe last case use %P instead of %p in t_fmt_ampm, not sure if that one\nis never used by strptime because %P isn't handled by strptime.\nAnyway, the right thing to handle even %p%I would be to pass some state\naround through all the _M_extract_via_format calls like glibc passes\n  struct __strptime_state\n  {\n    unsigned int have_I : 1;\n    unsigned int have_wday : 1;\n    unsigned int have_yday : 1;\n    unsigned int have_mon : 1;\n    unsigned int have_mday : 1;\n    unsigned int have_uweek : 1;\n    unsigned int have_wweek : 1;\n    unsigned int is_pm : 1;\n    unsigned int want_century : 1;\n    unsigned int want_era : 1;\n    unsigned int want_xday : 1;\n    enum ptime_locale_status decided : 2;\n    signed char week_no;\n    signed char century;\n    int era_cnt;\n  } s;\naround.  That is for the %p case used like:\n  if (s.have_I && s.is_pm)\n    tm->tm_hour += 12;\nduring finalization, but handles tons of other cases which it is unclear\nif libstdc++ needs or doesn't need to handle, e.g. strptime if one\nspecifies year and yday computes wday/mon/day from it, etc. basically for\nthe redundant fields computes them from other fields if those have been\nparsed and are sufficient to determine it.\nTo do this we'd need to change ABI for the _M_extract_via_format,\nthough sure, we could add a wrapper around the new one with the old\narguments that would just use a dummy state.  And we'd need a new\n_M_whatever finalizer that would do those post parsing tweaks.\n\nAlso, %% wasn't handled.\n\nFor a whitespace in the strings there was inconsistent behavior,\n_M_extract_via_format would require exactly that whitespace char (say\nmatching space, or matching tab), while the caller follows what\nhttps://eel.is/c++draft/locale.time.get#members-8.5 says, that\nwhen encountering whitespace it skips whitespace in the format and\nthen whitespace in the input if any.  I've changed _M_extract_via_format\nto skip whitespace in the input (looping over format isn't IMHO necessary,\nbecause next iteration of the loop will handle that too).\n\nTested on x86_64-linux by make check-target-libstdc++-v3, ok for trunk\nif it passes full bootstrap/regtest?\n\nFor the new 3.cc testcases, I have included hopefully correctly\ncorresponding C testcase using strptime in an attachment, and to the\nextent where it can be compared (e.g. strptime on failure just\nreturns NULL, doesn't tell where it exactly stopped) I think the\nonly difference is that\n  str = \"Novembur\";\n  format = \"%bembur\";\n  ret = strptime (str, format, &time);\ncase where strptime accepts it but there is no way to do it with input\noperator.\n\nI admit I don't have libc++ or other STL libraries around to be able to\ncheck how much the new 3.cc matches or disagrees with other implementations.\n\nNow, the things not handled by this patch but which should be fixed (I\nprobably need to go back to compiler work) or at least looked at:\n\n1) seems %j, %r, %U, %w and %W aren't handled (not sure if all of them\n   are already in POSIX 2009 or some are later)\n2) I haven't touched the %y/%Y/%C and year handling stuff, that is\n   definitely not matching what POSIX 2009 says:\n       C       All  but the last two digits of the year {2}; leading zeros shall be permitted but shall not be required. A leading '+' or '\u2212' character shall be permitted before\n               any leading zeros but shall not be required.\n       y       The  last  two  digits of the year. When format contains neither a C conversion specifier nor a Y conversion specifier, values in the range [69,99] shall refer to\n               years 1969 to 1999 inclusive and values in the range [00,68] shall refer to years 2000 to 2068 inclusive; leading zeros shall be permitted but shall  not  be  re\u2010\n               quired. A leading '+' or '\u2212' character shall be permitted before any leading zeros but shall not be required.\n\n               Note:     It is expected that in a future version of this standard the default century inferred from a 2-digit year will change. (This would apply to all commands\n                         accepting a 2-digit year as input.)\n       Y       The full year {4}; leading zeros shall be permitted but shall not be required. A leading '+' or '\u2212' character shall be permitted  before  any  leading  zeros  but\n               shall not be required.\n   I've tried to avoid making changes to _M_extract_num for these as well\n   to keep current status quo (the __len == 4 cases).  One thing is what\n   to do for things with %C %y and/or %Y in the formats, another thing\n   is what to do in the methods that directly perform _M_extract_num\n   for year\n3) the above question what to do for leading whitespace of any numbers\n   being parsed\n4) the %p%I issue mentioned above and generally what to do if we\n   pass state and have finalizers at the end of parsing\n5) _M_extract_via_format is also inconsistent with its callers on handling\n   the non-whitespace characters in between format specifiers, the caller\n   follows https://eel.is/c++draft/locale.time.get#members-8.6 and does\n   case insensitive comparison:\n          // TODO real case-insensitive comparison\n          else if (__ctype.tolower(*__s) == __ctype.tolower(*__fmt) ||\n                   __ctype.toupper(*__s) == __ctype.toupper(*__fmt))\n   while _M_extract_via_format only compares exact characters:\n              // Verify format and input match, extract and discard.\n              if (__format[__i] == *__beg)\n                ++__beg;\n   (another question is if there is a better way how to do real\n   case-insensitive comparison of 2 characters and whether we e.g. need\n   to handle the Turkish i/\u0130 and \u0131/I which have different number of bytes\n   in UTF-8)\n6) _M_extract_name does something weird for case-sensitivity,\n      // NB: Some of the locale data is in the form of all lowercase\n      // names, and some is in the form of initially-capitalized\n      // names. Look for both.\n      if (__beg != __end)\n   and\n            if (__c == __names[__i1][0]\n                || __c == __ctype.toupper(__names[__i1][0]))\n   for the first letter while just\n        __name[__pos] == *__beg\n   on all the following letters.  strptime says:\n   In case a text string (such as the name of a day of the week or a month\n   name) is to be matched, the comparison is case insensitive.\n   so supposedly all the _M_extract_name comparisons should be case\n   insensitive.\n\n2021-12-10  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libstdc++/78714\n\t* include/bits/locale_facets_nonio.tcc (_M_extract_via_format):\n\tMention in function comment it interprets strptime format string\n\trather than strftime.  Handle %a and %A the same by accepting both\n\tfull and abbreviated names.  Similarly handle %h, %b and %B the same.\n\tHandle %d and %e the same by accepting possibly optional single space\n\tand 1 or 2 digits.  For %I store tm_hour 0 instead of tm_hour 12.  For\n\t%t and %n skip any whitespace.  Handle %p and %%.  For whitespace in\n\tthe string skip any whitespace.\n\t(_M_extract_num): For __len == 2 accept 1 or 2 digits rather than\n\talways 2.  Don't punt early if __value * __mult is larget than __max\n\tor smaller than __min - __mult, instead punt if __value > __max.\n\tAt the end verify __value is in between __min and __max and punt\n\totherwise.\n\t(_M_extract_name): Allow non-unique names or names which are prefixes\n\tof other names.  Don't recompute lengths of names for every character.\n\t* testsuite/22_locale/time_get/get/char/3.cc: New test.\n\t* testsuite/22_locale/time_get/get/wchar_t/3.cc: New test.\n\t* testsuite/22_locale/time_get/get_date/char/12791.cc (test01): Use\n\t62 instead 60 and expect 6 to be accepted and thus *ret01 == '2'.\n\t* testsuite/22_locale/time_get/get_date/wchar_t/12791.cc (test01):\n\tSimilarly.\n\t* testsuite/22_locale/time_get/get_time/char/2.cc (test02): Add \" PM\"\n\tto the string.\n\t* testsuite/22_locale/time_get/get_time/char/5.cc (test01): Expect\n\ttm_hour 1 rather than 0.\n\t* testsuite/22_locale/time_get/get_time/wchar_t/2.cc (test02): Add\n\t\" PM\" to the string.\n\t* testsuite/22_locale/time_get/get_time/wchar_t/5.cc (test01): Expect\n\ttm_hour 1 rather than 0.", "tree": {"sha": "3308009c19586490a8dcfd34208cdcf0be3ee1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3308009c19586490a8dcfd34208cdcf0be3ee1fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c82e492616e343b6d6db218d2b498267bac899de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c82e492616e343b6d6db218d2b498267bac899de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c82e492616e343b6d6db218d2b498267bac899de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c82e492616e343b6d6db218d2b498267bac899de/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57b291c27ee7b2b2e6c04c37ec1b8f5bf87b99c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57b291c27ee7b2b2e6c04c37ec1b8f5bf87b99c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57b291c27ee7b2b2e6c04c37ec1b8f5bf87b99c4"}], "stats": {"total": 944, "additions": 860, "deletions": 84}, "files": [{"sha": "3456ee1dd6a592efcaa93e30d4c049d114d6eabb", "filename": "libstdc++-v3/include/bits/locale_facets_nonio.tcc", "status": "modified", "additions": 140, "deletions": 76, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets_nonio.tcc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -684,7 +684,7 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n     time_get<_CharT, _InIter>::do_date_order() const\n     { return time_base::no_order; }\n \n-  // Expand a strftime format string and parse it.  E.g., do_get_date() may\n+  // Expand a strptime format string and parse it.  E.g., do_get_date() may\n   // pass %m/%d/%Y => extracted characters.\n   template<typename _CharT, typename _InIter>\n     _InIter\n@@ -714,41 +714,27 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n \t\t  const char* __cs;\n \t\t  _CharT __wcs[10];\n \t\tcase 'a':\n-\t\t  // Abbreviated weekday name [tm_wday]\n-\t\t  const char_type*  __days1[7];\n-\t\t  __tp._M_days_abbreviated(__days1);\n-\t\t  __beg = _M_extract_name(__beg, __end, __mem, __days1,\n-\t\t\t\t\t  7, __io, __tmperr);\n-\t\t  if (!__tmperr)\n-\t\t    __tm->tm_wday = __mem;\n-\t\t  break;\n \t\tcase 'A':\n-\t\t  // Weekday name [tm_wday].\n-\t\t  const char_type*  __days2[7];\n-\t\t  __tp._M_days(__days2);\n-\t\t  __beg = _M_extract_name(__beg, __end, __mem, __days2,\n-\t\t\t\t\t  7, __io, __tmperr);\n+\t\t  // Weekday name (possibly abbreviated) [tm_wday]\n+\t\t  const char_type*  __days[14];\n+\t\t  __tp._M_days(&__days[0]);\n+\t\t  __tp._M_days_abbreviated(&__days[7]);\n+\t\t  __beg = _M_extract_name(__beg, __end, __mem, __days,\n+\t\t\t\t\t  14, __io, __tmperr);\n \t\t  if (!__tmperr)\n-\t\t    __tm->tm_wday = __mem;\n+\t\t    __tm->tm_wday = __mem % 7;\n \t\t  break;\n \t\tcase 'h':\n \t\tcase 'b':\n-\t\t  // Abbreviated month name [tm_mon]\n-\t\t  const char_type*  __months1[12];\n-\t\t  __tp._M_months_abbreviated(__months1);\n-\t\t  __beg = _M_extract_name(__beg, __end, __mem,\n-\t\t\t\t\t  __months1, 12, __io, __tmperr);\n-\t\t  if (!__tmperr)\n-\t\t    __tm->tm_mon = __mem;\n-\t\t  break;\n \t\tcase 'B':\n-\t\t  // Month name [tm_mon].\n-\t\t  const char_type*  __months2[12];\n-\t\t  __tp._M_months(__months2);\n+\t\t  // Month name (possibly abbreviated) [tm_mon]\n+\t\t  const char_type*  __months[24];\n+\t\t  __tp._M_months(&__months[0]);\n+\t\t  __tp._M_months_abbreviated(&__months[12]);\n \t\t  __beg = _M_extract_name(__beg, __end, __mem,\n-\t\t\t\t\t  __months2, 12, __io, __tmperr);\n+\t\t\t\t\t  __months, 24, __io, __tmperr);\n \t\t  if (!__tmperr)\n-\t\t    __tm->tm_mon = __mem;\n+\t\t    __tm->tm_mon = __mem % 12;\n \t\t  break;\n \t\tcase 'c':\n \t\t  // Default time and date representation.\n@@ -758,21 +744,12 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n \t\t\t\t\t\t__tm, __dt[0]);\n \t\t  break;\n \t\tcase 'd':\n-\t\t  // Day [01, 31]. [tm_mday]\n-\t\t  __beg = _M_extract_num(__beg, __end, __mem, 1, 31, 2,\n-\t\t\t\t\t __io, __tmperr);\n-\t\t  if (!__tmperr)\n-\t\t    __tm->tm_mday = __mem;\n-\t\t  break;\n \t\tcase 'e':\n-\t\t  // Day [1, 31], with single digits preceded by\n-\t\t  // space. [tm_mday]\n+\t\t  // Day [1, 31]. [tm_mday]\n \t\t  if (__ctype.is(ctype_base::space, *__beg))\n-\t\t    __beg = _M_extract_num(++__beg, __end, __mem, 1, 9,\n-\t\t\t\t\t   1, __io, __tmperr);\n-\t\t  else\n-\t\t    __beg = _M_extract_num(__beg, __end, __mem, 10, 31,\n-\t\t\t\t\t   2, __io, __tmperr);\n+\t\t    ++__beg;\n+\t\t  __beg = _M_extract_num(__beg, __end, __mem, 1, 31, 2,\n+\t\t\t\t\t __io, __tmperr);\n \t\t  if (!__tmperr)\n \t\t    __tm->tm_mday = __mem;\n \t\t  break;\n@@ -795,7 +772,7 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n \t\t  __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,\n \t\t\t\t\t __io, __tmperr);\n \t\t  if (!__tmperr)\n-\t\t    __tm->tm_hour = __mem;\n+\t\t    __tm->tm_hour = __mem % 12;\n \t\t  break;\n \t\tcase 'm':\n \t\t  // Month [01, 12]. [tm_mon]\n@@ -812,10 +789,22 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n \t\t    __tm->tm_min = __mem;\n \t\t  break;\n \t\tcase 'n':\n-\t\t  if (__ctype.narrow(*__beg, 0) == '\\n')\n+\t\tcase 't':\n+\t\t  while (__beg != __end\n+\t\t\t && __ctype.is(ctype_base::space, *__beg))\n \t\t    ++__beg;\n-\t\t  else\n-\t\t    __tmperr |= ios_base::failbit;\n+\t\t  break;\n+\t\tcase 'p':\n+\t\t  // Locale's a.m. or p.m.\n+\t\t  const char_type*  __ampm[2];\n+\t\t  __tp._M_am_pm(&__ampm[0]);\n+\t\t  if (!__ampm[0][0] || !__ampm[1][0])\n+\t\t    break;\n+\t\t  __beg = _M_extract_name(__beg, __end, __mem, __ampm,\n+\t\t\t\t\t  2, __io, __tmperr);\n+\t\t  // FIXME: This only works if %I comes before %p.\n+\t\t  if (!__tmperr && __mem)\n+\t\t    __tm->tm_hour += 12;\n \t\t  break;\n \t\tcase 'R':\n \t\t  // Equivalent to (%H:%M).\n@@ -836,12 +825,6 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n \t\t  if (!__tmperr)\n \t\t  __tm->tm_sec = __mem;\n \t\t  break;\n-\t\tcase 't':\n-\t\t  if (__ctype.narrow(*__beg, 0) == '\\t')\n-\t\t    ++__beg;\n-\t\t  else\n-\t\t    __tmperr |= ios_base::failbit;\n-\t\t  break;\n \t\tcase 'T':\n \t\t  // Equivalent to (%H:%M:%S).\n \t\t  __cs = \"%H:%M:%S\";\n@@ -899,11 +882,24 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n \t\t  else\n \t\t    __tmperr |= ios_base::failbit;\n \t\t  break;\n+\t\tcase '%':\n+\t\t  if (*__beg == __ctype.widen('%'))\n+\t\t    ++__beg;\n+\t\t  else\n+\t\t    __tmperr |= ios_base::failbit;\n+\t\t  break;\n \t\tdefault:\n \t\t  // Not recognized.\n \t\t  __tmperr |= ios_base::failbit;\n \t\t}\n \t    }\n+\t  else if (__ctype.is(ctype_base::space, __format[__i]))\n+\t    {\n+\t      // Skip any whitespace.\n+\t      while (__beg != __end\n+\t\t     && __ctype.is(ctype_base::space, *__beg))\n+\t\t++__beg;\n+\t    }\n \t  else\n \t    {\n \t      // Verify format and input match, extract and discard.\n@@ -930,10 +926,6 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n       const locale& __loc = __io._M_getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \n-      // As-is works for __len = 1, 2, 4, the values actually used.\n-      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);\n-\n-      ++__min;\n       size_t __i = 0;\n       int __value = 0;\n       for (; __beg != __end && __i < __len; ++__beg, (void)++__i)\n@@ -942,27 +934,31 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n \t  if (__c >= '0' && __c <= '9')\n \t    {\n \t      __value = __value * 10 + (__c - '0');\n-\t      const int __valuec = __value * __mult;\n-\t      if (__valuec > __max || __valuec + __mult < __min)\n+\t      if (__value > __max)\n \t\tbreak;\n-\t      __mult /= 10;\n \t    }\n \t  else\n \t    break;\n \t}\n-      if (__i == __len)\n-\t__member = __value;\n       // Special encoding for do_get_year, 'y', and 'Y' above.\n-      else if (__len == 4 && __i == 2)\n+      if (__len == 4 && __i == 2)\n \t__member = __value - 100;\n+      else if (__len == 4 && __i == 4)\n+\t__member = __value;\n+      else if (__len == 2 && __i && __i <= 2\n+\t       && __value >= __min && __value <= __max)\n+\t__member = __value;\n       else\n \t__err |= ios_base::failbit;\n \n       return __beg;\n     }\n \n   // Assumptions:\n-  // All elements in __names are unique.\n+  // All elements in __names are unique, except if __indexlen is\n+  // even __names in the first half could be the same as corresponding\n+  // __names in the second half (May is abbreviated as May).  Some __names\n+  // elements could be prefixes of other __names elements.\n   template<typename _CharT, typename _InIter>\n     _InIter\n     time_get<_CharT, _InIter>::\n@@ -974,12 +970,15 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n       const locale& __loc = __io._M_getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n \n-      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)\n-\t\t\t\t\t\t\t  * __indexlen));\n+      size_t* __matches\n+\t= static_cast<size_t*>(__builtin_alloca(2 * sizeof(size_t)\n+\t\t\t\t\t\t* __indexlen));\n+      size_t* __lengths = __matches + __indexlen;\n       size_t __nmatches = 0;\n       size_t __pos = 0;\n       bool __testvalid = true;\n       const char_type* __name;\n+      bool __begupdated = false;\n \n       // Look for initial matches.\n       // NB: Some of the locale data is in the form of all lowercase\n@@ -991,26 +990,88 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n \t  for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)\n \t    if (__c == __names[__i1][0]\n \t\t|| __c == __ctype.toupper(__names[__i1][0]))\n-\t      __matches[__nmatches++] = __i1;\n+\t      {\n+\t\t__lengths[__nmatches]\n+\t\t  = __traits_type::length(__names[__i1]);\n+\t\t__matches[__nmatches++] = __i1;\n+\t      }\n \t}\n \n       while (__nmatches > 1)\n \t{\n \t  // Find smallest matching string.\n-\t  size_t __minlen = __traits_type::length(__names[__matches[0]]);\n+\t  size_t __minlen = __lengths[0];\n \t  for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)\n-\t    __minlen = std::min(__minlen,\n-\t\t\t      __traits_type::length(__names[__matches[__i2]]));\n-\t  ++__beg;\n+\t    __minlen = std::min(__minlen, __lengths[__i2]);\n \t  ++__pos;\n+\t  ++__beg;\n+\t  if (__pos == __minlen)\n+\t    {\n+\t      // If some match has remaining length of 0,\n+\t      // need to decide if any match with remaining\n+\t      // length non-zero matches the next character.\n+\t      // If so, remove all matches with remaining length\n+\t      // 0 from consideration, otherwise keep only matches\n+\t      // with remaining length 0.\n+\t      bool __match_longer = false;\n+\n+\t      if (__beg != __end)\n+\t\tfor (size_t __i3 = 0; __i3 < __nmatches; ++__i3)\n+\t\t  {\n+\t\t    __name = __names[__matches[__i3]];\n+\t\t    if (__lengths[__i3] > __pos && (__name[__pos] == *__beg))\n+\t\t      {\n+\t\t\t__match_longer = true;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      for (size_t __i4 = 0; __i4 < __nmatches;)\n+\t\tif (__match_longer == (__lengths[__i4] == __pos))\n+\t\t  {\n+\t\t    __matches[__i4] = __matches[--__nmatches];\n+\t\t    __lengths[__i4] = __lengths[__nmatches];\n+\t\t  }\n+\t\telse\n+\t\t  ++__i4;\n+\t      if (__match_longer)\n+\t\t{\n+\t\t  __minlen = __lengths[0];\n+\t\t  for (size_t __i5 = 1; __i5 < __nmatches; ++__i5)\n+\t\t    __minlen = std::min(__minlen, __lengths[__i5]);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // Deal with May being full as well as abbreviated month\n+\t\t  // name.  Pick the smaller index.\n+\t\t  if (__nmatches == 2 && (__indexlen & 1) == 0)\n+\t\t    {\n+\t\t      if (__matches[0] < __indexlen / 2)\n+\t\t\t{\n+\t\t\t  if (__matches[1] == __matches[0] + __indexlen / 2)\n+\t\t\t    __nmatches = 1;\n+\t\t\t}\n+\t\t      else if (__matches[1] == __matches[0] - __indexlen / 2)\n+\t\t\t{\n+\t\t\t  __matches[0] = __matches[1];\n+\t\t\t  __lengths[0] = __lengths[1];\n+\t\t\t  __nmatches = 1;\n+\t\t\t}\n+\t\t    }\n+\t\t  __begupdated = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n \t  if (__pos < __minlen && __beg != __end)\n-\t    for (size_t __i3 = 0; __i3 < __nmatches;)\n+\t    for (size_t __i6 = 0; __i6 < __nmatches;)\n \t      {\n-\t\t__name = __names[__matches[__i3]];\n+\t\t__name = __names[__matches[__i6]];\n \t\tif (!(__name[__pos] == *__beg))\n-\t\t  __matches[__i3] = __matches[--__nmatches];\n+\t\t  {\n+\t\t    __matches[__i6] = __matches[--__nmatches];\n+\t\t    __lengths[__i6] = __lengths[__nmatches];\n+\t\t  }\n \t\telse\n-\t\t  ++__i3;\n+\t\t  ++__i6;\n \t      }\n \t  else\n \t    break;\n@@ -1019,10 +1080,13 @@ _GLIBCXX_END_NAMESPACE_LDBL_OR_CXX11\n       if (__nmatches == 1)\n \t{\n \t  // Make sure found name is completely extracted.\n-\t  ++__beg;\n-\t  ++__pos;\n+\t  if (!__begupdated)\n+\t    {\n+\t      ++__beg;\n+\t      ++__pos;\n+\t    }\n \t  __name = __names[__matches[0]];\n-\t  const size_t __len = __traits_type::length(__name);\n+\t  const size_t __len = __lengths[0];\n \t  while (__pos < __len && __beg != __end && __name[__pos] == *__beg)\n \t    ++__beg, (void)++__pos;\n "}, {"sha": "524c1c5a97f6c4e54ccc83e1f60b6e1d35b57183", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get/char/3.cc", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget%2Fchar%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget%2Fchar%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget%2Fchar%2F3.cc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -0,0 +1,356 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <locale>\n+#include <sstream>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std;\n+\n+  locale loc_c = locale::classic();\n+\n+  istringstream iss;\n+  iss.imbue(loc_c);\n+  const time_get<char>& tget = use_facet<time_get<char>>(iss.getloc());\n+  typedef istreambuf_iterator<char> iter;\n+  const iter end;\n+\n+  tm time;\n+  ios_base::iostate err = ios_base::badbit;\n+\n+  // PR78714 tests\n+  iss.str(\"Mon\");\n+  string format = \"%a\";\n+  auto ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t      format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_wday == 1 );\n+\n+  iss.str(\"Tue \");\n+  format = \"%a\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == ' ' );\n+  VERIFY( time.tm_wday == 2 );\n+\n+  iss.str(\"Wednesday\");\n+  format = \"%a\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_wday == 3 );\n+\n+  iss.str(\"Thu\");\n+  format = \"%A\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_wday == 4 );\n+\n+  iss.str(\"Fri \");\n+  format = \"%A\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == ' ' );\n+  VERIFY( time.tm_wday == 5 );\n+\n+  iss.str(\"Saturday\");\n+  format = \"%A\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_wday == 6 );\n+\n+  iss.str(\"Feb\");\n+  format = \"%b\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 1 );\n+\n+  iss.str(\"Mar \");\n+  format = \"%b\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == ' ' );\n+  VERIFY( time.tm_mon == 2 );\n+\n+  iss.str(\"April\");\n+  format = \"%b\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 3 );\n+\n+  iss.str(\"May\");\n+  format = \"%B\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 4 );\n+\n+  iss.str(\"Jun \");\n+  format = \"%B\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == ' ' );\n+  VERIFY( time.tm_mon == 5 );\n+\n+  iss.str(\"July\");\n+  format = \"%B\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 6 );\n+\n+  iss.str(\"Aug\");\n+  format = \"%h\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 7 );\n+\n+  iss.str(\"May \");\n+  format = \"%h\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == ' ' );\n+  VERIFY( time.tm_mon == 4 );\n+\n+  iss.str(\"October\");\n+  format = \"%h\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 9 );\n+\n+  // Other tests.\n+  iss.str(\" 1.\");\n+  format = \"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 1 );\n+\n+  iss.str(\"2.\");\n+  format = \"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 2 );\n+\n+  iss.str(\"03.\");\n+  format = \"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 3 );\n+\n+  iss.str(\"0.\");\n+  format = \"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == '.' );\n+\n+  iss.str(\"32.\");\n+  format = \"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == '2' );\n+\n+  iss.str(\" 4.\");\n+  format = \"%e.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 4 );\n+\n+  iss.str(\"5.\");\n+  format = \"%e.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 5 );\n+\n+  iss.str(\"06.\");\n+  format = \"%e.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 6 );\n+\n+  iss.str(\"0\");\n+  format = \"%e\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit|ios_base::eofbit );\n+  VERIFY( ret == end );\n+\n+  iss.str(\"35\");\n+  format = \"%e\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == '5' );\n+\n+  iss.str(\" \\t\\t 02\");\n+  format = \"%t%m\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 1 );\n+\n+  iss.str(\" \\t \\t 03\");\n+  format = \"%n%m\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 2 );\n+\n+  iss.str(\" \\t \\t 4\");\n+  format = \" %m\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 3 );\n+\n+  iss.str(\" \\t \\t 5\");\n+  format = \"\\t%m\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 4 );\n+\n+  iss.str(\"12:00AM\");\n+  format = \"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 0 );\n+  VERIFY( time.tm_min == 0 );\n+\n+  iss.str(\"12:37AM\");\n+  format = \"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 0 );\n+  VERIFY( time.tm_min == 37 );\n+\n+  iss.str(\"01:25AM\");\n+  format = \"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 1 );\n+  VERIFY( time.tm_min == 25 );\n+\n+  iss.str(\"12:00PM\");\n+  format = \"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 12 );\n+  VERIFY( time.tm_min == 0 );\n+\n+  iss.str(\"12:42PM\");\n+  format = \"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 12 );\n+  VERIFY( time.tm_min == 42 );\n+\n+  iss.str(\"07:23PM\");\n+  format = \"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 19 );\n+  VERIFY( time.tm_min == 23 );\n+\n+  iss.str(\"17%20\");\n+  format = \"%H%%%M\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 17 );\n+  VERIFY( time.tm_min == 20 );\n+\n+  iss.str(\"24:30\");\n+  format = \"%H:%M\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == '4' );\n+\n+  // This one behaves differently from strptime, in a single\n+  // pass scaning we can't go back.\n+  iss.str(\"Novembur\");\n+  format = \"%bembur\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == 'u' );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "cbc31445677ce821fae25b96e1c738b395d73f32", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get/wchar_t/3.cc", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget%2Fwchar_t%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget%2Fwchar_t%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget%2Fwchar_t%2F3.cc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -0,0 +1,356 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <locale>\n+#include <sstream>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std;\n+\n+  locale loc_c = locale::classic();\n+\n+  wistringstream iss;\n+  iss.imbue(loc_c);\n+  const time_get<wchar_t>& tget = use_facet<time_get<wchar_t>>(iss.getloc());\n+  typedef istreambuf_iterator<wchar_t> iter;\n+  const iter end;\n+\n+  tm time;\n+  ios_base::iostate err = ios_base::badbit;\n+\n+  // PR78714 tests\n+  iss.str(L\"Mon\");\n+  wstring format = L\"%a\";\n+  auto ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t      format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_wday == 1 );\n+\n+  iss.str(L\"Tue L\");\n+  format = L\"%a\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == L' ' );\n+  VERIFY( time.tm_wday == 2 );\n+\n+  iss.str(L\"Wednesday\");\n+  format = L\"%a\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_wday == 3 );\n+\n+  iss.str(L\"Thu\");\n+  format = L\"%A\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_wday == 4 );\n+\n+  iss.str(L\"Fri L\");\n+  format = L\"%A\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == L' ' );\n+  VERIFY( time.tm_wday == 5 );\n+\n+  iss.str(L\"Saturday\");\n+  format = L\"%A\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_wday == 6 );\n+\n+  iss.str(L\"Feb\");\n+  format = L\"%b\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 1 );\n+\n+  iss.str(L\"Mar L\");\n+  format = L\"%b\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == L' ' );\n+  VERIFY( time.tm_mon == 2 );\n+\n+  iss.str(L\"April\");\n+  format = L\"%b\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 3 );\n+\n+  iss.str(L\"May\");\n+  format = L\"%B\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 4 );\n+\n+  iss.str(L\"Jun L\");\n+  format = L\"%B\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == L' ' );\n+  VERIFY( time.tm_mon == 5 );\n+\n+  iss.str(L\"July\");\n+  format = L\"%B\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 6 );\n+\n+  iss.str(L\"Aug\");\n+  format = L\"%h\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 7 );\n+\n+  iss.str(L\"May L\");\n+  format = L\"%h\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret != end && *ret == L' ' );\n+  VERIFY( time.tm_mon == 4 );\n+\n+  iss.str(L\"October\");\n+  format = L\"%h\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 9 );\n+\n+  // Other tests.\n+  iss.str(L\" 1.\");\n+  format = L\"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 1 );\n+\n+  iss.str(L\"2.\");\n+  format = L\"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 2 );\n+\n+  iss.str(L\"03.\");\n+  format = L\"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 3 );\n+\n+  iss.str(L\"0.\");\n+  format = L\"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == L'.' );\n+\n+  iss.str(L\"32.\");\n+  format = L\"%d.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == L'2' );\n+\n+  iss.str(L\" 4.\");\n+  format = L\"%e.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 4 );\n+\n+  iss.str(L\"5.\");\n+  format = L\"%e.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 5 );\n+\n+  iss.str(L\"06.\");\n+  format = L\"%e.\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::goodbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mday == 6 );\n+\n+  iss.str(L\"0\");\n+  format = L\"%e\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit|ios_base::eofbit );\n+  VERIFY( ret == end );\n+\n+  iss.str(L\"35\");\n+  format = L\"%e\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == L'5' );\n+\n+  iss.str(L\" \\t\\t 02\");\n+  format = L\"%t%m\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 1 );\n+\n+  iss.str(L\" \\t \\t 03\");\n+  format = L\"%n%m\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 2 );\n+\n+  iss.str(L\" \\t \\t 4\");\n+  format = L\" %m\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 3 );\n+\n+  iss.str(L\" \\t \\t 5\");\n+  format = L\"\\t%m\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_mon == 4 );\n+\n+  iss.str(L\"12:00AM\");\n+  format = L\"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 0 );\n+  VERIFY( time.tm_min == 0 );\n+\n+  iss.str(L\"12:37AM\");\n+  format = L\"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 0 );\n+  VERIFY( time.tm_min == 37 );\n+\n+  iss.str(L\"01:25AM\");\n+  format = L\"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 1 );\n+  VERIFY( time.tm_min == 25 );\n+\n+  iss.str(L\"12:00PM\");\n+  format = L\"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 12 );\n+  VERIFY( time.tm_min == 0 );\n+\n+  iss.str(L\"12:42PM\");\n+  format = L\"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 12 );\n+  VERIFY( time.tm_min == 42 );\n+\n+  iss.str(L\"07:23PM\");\n+  format = L\"%I:%M%p\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 19 );\n+  VERIFY( time.tm_min == 23 );\n+\n+  iss.str(L\"17%20\");\n+  format = L\"%H%%%M\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::eofbit );\n+  VERIFY( ret == end );\n+  VERIFY( time.tm_hour == 17 );\n+  VERIFY( time.tm_min == 20 );\n+\n+  iss.str(L\"24:30\");\n+  format = L\"%H:%M\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == L'4' );\n+\n+  // This one behaves differently from strptime, in a single\n+  // pass scaning we can't go back.\n+  iss.str(L\"Novembur\");\n+  format = L\"%bembur\";\n+  ret = tget.get(iter(iss), end, iss, err, &time,\n+\t\t format.data(), format.data()+format.size());\n+  VERIFY( err == ios_base::failbit );\n+  VERIFY( ret != end && *ret == L'u' );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "958a8f196bb5689c6a9d089e3ea1a465fe5b2eb9", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get_date/char/12791.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fchar%2F12791.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fchar%2F12791.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fchar%2F12791.cc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -39,14 +39,14 @@ void test01()\n   const ios_base::iostate good = ios_base::goodbit;\n   ios_base::iostate errorstate = good;\n \n-  iss.str(\"60/04/71\");\n+  iss.str(\"62/04/71\");\n   iterator_type is_it01(iss);\n   tm time01;\n   errorstate = good;\n   iterator_type ret01 = tim_get.get_date(is_it01, end, iss, errorstate,\n \t\t\t\t\t &time01);\n   VERIFY( errorstate == ios_base::failbit );\n-  VERIFY( *ret01 == '6' );\n+  VERIFY( *ret01 == '2' );\n \n   iss.str(\"04/38/71\");\n   iterator_type is_it02(iss);"}, {"sha": "0cf8f67ccd20b852b64ebff0d31d1aeceaeeaf61", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get_date/wchar_t/12791.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fwchar_t%2F12791.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fwchar_t%2F12791.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_date%2Fwchar_t%2F12791.cc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -40,14 +40,14 @@ void test01()\n   const ios_base::iostate good = ios_base::goodbit;\n   ios_base::iostate errorstate = good;\n \n-  iss.str(L\"60/04/71\");\n+  iss.str(L\"62/04/71\");\n   iterator_type is_it01(iss);\n   tm time01;\n   errorstate = good;\n   iterator_type ret01 = tim_get.get_date(is_it01, end, iss, errorstate,\n \t\t\t\t\t &time01);\n   VERIFY( errorstate == ios_base::failbit );\n-  VERIFY( *ret01 == L'6' );\n+  VERIFY( *ret01 == L'2' );\n \n   iss.str(L\"04/38/71\");\n   iterator_type is_it02(iss);"}, {"sha": "a847748dc2716c7073bf7e6a2c5be8d1fefbf21c", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get_time/char/2.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fchar%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fchar%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fchar%2F2.cc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -48,7 +48,7 @@ void test02()\n \n   // inspection of named locales, en_HK\n   iss.imbue(loc_hk);\n-  iss.str(\"12:00:00 PST\"); \n+  iss.str(\"12:00:00 PM PST\"); \n   // Hong Kong in California! Well, they have Paris in Vegas... this\n   // is all a little disney-esque anyway. Besides, you can get decent\n   // Dim Sum in San Francisco."}, {"sha": "a9bb79ce453506e43aa71ba290020c345010ae0c", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get_time/char/5.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fchar%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fchar%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fchar%2F5.cc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -52,7 +52,7 @@ void test01()\n   VERIFY( err == (failbit | eofbit) );\n   VERIFY( tm0.tm_sec == 0 );\n   VERIFY( tm0.tm_min == 0 );\n-  VERIFY( tm0.tm_hour == 0 );\n+  VERIFY( tm0.tm_hour == 1 );\n \n   const string str1 = \"12:00:00 \";\n   iter_type end1 = tg.get_time(str1.begin(), str1.end(), iss, err, &tm1);"}, {"sha": "b5d61e1afdbe1db19002d2bc4b290c3b46463730", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get_time/wchar_t/2.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fwchar_t%2F2.cc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -48,7 +48,7 @@ void test02()\n \n   // inspection of named locales, en_HK\n   iss.imbue(loc_hk);\n-  iss.str(L\"12:00:00 PST\"); \n+  iss.str(L\"12:00:00 PM PST\"); \n   // Hong Kong in California! Well, they have Paris in Vegas... this\n   // is all a little disney-esque anyway. Besides, you can get decent\n   // Dim Sum in San Francisco."}, {"sha": "db25046d33d5b23b84305d961b4b1881383257b2", "filename": "libstdc++-v3/testsuite/22_locale/time_get/get_time/wchar_t/5.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fwchar_t%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c82e492616e343b6d6db218d2b498267bac899de/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fwchar_t%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Ftime_get%2Fget_time%2Fwchar_t%2F5.cc?ref=c82e492616e343b6d6db218d2b498267bac899de", "patch": "@@ -52,7 +52,7 @@ void test01()\n   VERIFY( err == (failbit | eofbit) );\n   VERIFY( tm0.tm_sec == 0 );\n   VERIFY( tm0.tm_min == 0 );\n-  VERIFY( tm0.tm_hour == 0 );\n+  VERIFY( tm0.tm_hour == 1 );\n \n   const wstring str1 = L\"12:00:00 \";\n   iter_type end1 = tg.get_time(str1.begin(), str1.end(), iss, err, &tm1);"}]}