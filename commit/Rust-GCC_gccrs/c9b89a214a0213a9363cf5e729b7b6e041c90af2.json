{"sha": "c9b89a214a0213a9363cf5e729b7b6e041c90af2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzliODlhMjE0YTAyMTNhOTM2M2NmNWU3MjliN2I2ZTA0MWM5MGFmMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-10-03T07:26:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-10-03T07:26:42Z"}, "message": "rtlanal.c (single_set_1): Do not require USE and CLOBBERs to come last.\n\n\t* rtlanal.c (single_set_1): Do not require USE and CLOBBERs\n\tto come last.\n\nFrom-SVN: r36699", "tree": {"sha": "1a1fd2ed2c67e31f0881d9a70fd142817a5f3f44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a1fd2ed2c67e31f0881d9a70fd142817a5f3f44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9b89a214a0213a9363cf5e729b7b6e041c90af2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9b89a214a0213a9363cf5e729b7b6e041c90af2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9b89a214a0213a9363cf5e729b7b6e041c90af2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9b89a214a0213a9363cf5e729b7b6e041c90af2/comments", "author": null, "committer": null, "parents": [{"sha": "81bce466fe3e4220142dc0604248b6f4c723b4ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bce466fe3e4220142dc0604248b6f4c723b4ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81bce466fe3e4220142dc0604248b6f4c723b4ce"}], "stats": {"total": 127, "additions": 43, "deletions": 84}, "files": [{"sha": "405b6914af8aecbfe577742273dacf1b0d464634", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b89a214a0213a9363cf5e729b7b6e041c90af2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b89a214a0213a9363cf5e729b7b6e041c90af2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9b89a214a0213a9363cf5e729b7b6e041c90af2", "patch": "@@ -1,3 +1,8 @@\n+Mon Oct  2 14:50:14 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* rtlanal.c (single_set_1): Do not require USE and CLOBBERs\n+\tto come last.\n+\n 2000-10-03  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/float-c4x.h: New."}, {"sha": "8edcdbc184f15e07c3954ffbfb05072cefd77d23", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 38, "deletions": 84, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9b89a214a0213a9363cf5e729b7b6e041c90af2/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9b89a214a0213a9363cf5e729b7b6e041c90af2/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c9b89a214a0213a9363cf5e729b7b6e041c90af2", "patch": "@@ -846,98 +846,52 @@ rtx\n single_set_1 (insn)\n      rtx insn;\n {\n-  rtx set;\n+  rtx set = NULL;\n+  int set_verified = 1;\n   rtx pat = PATTERN (insn);\n   int i;\n-  \n+\n   if (GET_CODE (pat) == PARALLEL)\n     {\n-      rtx x, sub;\n-      /* This part is is performance critical for targets that use a lot of\n-\t parallels, such as i386.  We want to accept as single set\n-\t instructions even an instructions with multiple sets where only\n-\t one has live result, but we attempt to delay this tests only for\n-\t multiple set instructions to reduce amount of calls to\n-\t find_reg_note and side_effects_p.\n-       \n-\t We expect the \"common\" instruction to be parallel with first SET\n-\t followed by the clobbers.  So first we get the set, then look\n-\t if it is followed by USE or CLOBBER. If so, we just return expect\n-\t no SETs after these.  When SET is followed by another SET, we\n-\t continue by the clomplex loop trought all members of PARALLEL.\n-       */\n-#ifdef ENABLE_CHECKING\n-      if (XVECLEN (pat, 0) < 2)\n-\tabort ();\n-#endif\n-      set = XVECEXP (pat, 0, 0);\n-      switch (GET_CODE (set))\n-\t{\n-#ifdef ENABLE_CHECKING\n-\t  case USE:\n-\t  case CLOBBER:\n-\t    /* Instruction should not consist only from USEs and CLOBBERS,\n-\t       since then gcc is allowed to remove it entirely.  In case\n-\t       something else is present, it should be first in the pattern.  */\n-\t    fatal_insn (\"USE or CLOBBER before SET:\", insn);\n-#endif\n-\t  case SET:\n-\t    break;\n-\t  default:\n-\t    return NULL_RTX;\n-\t}\n-      x = XVECEXP (pat, 0, 1);\n-      switch (GET_CODE (x))\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n \t{\n-\tcase USE:\n-\tcase CLOBBER:\n-#ifdef ENABLE_CHECKING\n-\t  /* The USEs and CLOBBERs should always come last in the pattern.  */\n-\t  for (i = XVECLEN (pat, 0) - 1; i > 1; i--)\n-\t    if (GET_CODE (XVECEXP (pat, 0, i)) != USE\n-\t\t&& GET_CODE (XVECEXP (pat, 0, i)) != CLOBBER)\n-\t      fatal_insn (\"USE or CLOBBER before SET:\", insn);\n-#endif\n-\t    return set;\n-\tcase SET:\n-\t  {\n-\t    int seen_clobber = 0;\n+\t  rtx sub = XVECEXP (pat, 0, i);\n+\t  switch (GET_CODE (sub))\n+\t    {\n+\t    case USE:\n+\t    case CLOBBER:\n+\t      break;\n \n-\t    /* Multiple set insns - we are off the critical path now.  */\n-\t    for (i = 1; i < XVECLEN (pat, 0); i++)\n-\t      {\n-\t\tsub = XVECEXP (pat, 0, i);\n-\t\tswitch GET_CODE (sub)\n-\t\t  {\n-\t\t  case USE:\n-\t\t  case CLOBBER:\n-\t\t    seen_clobber = 1;\n-\t\t    break;\n-\t\t    \n-\t\t  case SET:\n-\t\t    if (seen_clobber)\n-\t\t      fatal_insn (\"USE or CLOBBER before SET:\", insn);\n-\t\t    if (!set\n-\t\t\t|| (find_reg_note (insn, REG_UNUSED, SET_DEST (set))\n-\t\t\t    && side_effects_p (set)))\n-\t\t      set = sub;\n-\t\t    else if (! find_reg_note (insn, REG_UNUSED, SET_DEST (sub))\n-\t\t\t     || side_effects_p (sub))\n-\t\t      return NULL_RTX;\n-\t\t    break;\n-\t\t    \n-\t\t  default:\n-\t\t    return NULL_RTX;\n-\t\t  }\n-\t      }\n-\t  }\n-\t  return set;\n-\tdefault:\n-\t  return NULL_RTX;\n+\t    case SET:\n+\t      /* We can consider insns having multiple sets, where all\n+\t\t but one are dead as single set insns.  In common case\n+\t\t only single set is present in the pattern so we want\n+\t\t to avoid checking for REG_UNUSED notes unless neccesary.\n+\n+\t\t When we reach set first time, we just expect this is\n+\t\t the single set we are looking for and only when more\n+\t\t sets are found in the insn, we check them.  */\n+\t      if (!set_verified)\n+\t\t{\n+\t\t  if (find_reg_note (insn, REG_UNUSED, SET_DEST (set))\n+\t\t      && !side_effects_p (set))\n+\t\t    set = NULL;\n+\t\t  else\n+\t\t    set_verified = 1;\n+\t\t}\n+\t      if (!set)\n+\t\tset = sub, set_verified = 0;\n+\t      else if (!find_reg_note (insn, REG_UNUSED, SET_DEST (sub))\n+\t\t       || side_effects_p (sub))\n+\t\treturn NULL_RTX;\n+\t      break;\n+\n+\t    default:\n+\t      return NULL_RTX;\n+\t    }\n \t}\n     }\n-  \n-  return 0;\n+  return set;\n }\n \n /* Given an INSN, return nonzero if it has more than one SET, else return"}]}