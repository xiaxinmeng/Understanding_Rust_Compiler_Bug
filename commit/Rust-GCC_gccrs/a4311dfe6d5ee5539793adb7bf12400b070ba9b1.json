{"sha": "a4311dfe6d5ee5539793adb7bf12400b070ba9b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQzMTFkZmU2ZDVlZTU1Mzk3OTNhZGI3YmYxMjQwMGIwNzBiYTliMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-09T22:52:09Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-09T22:52:09Z"}, "message": "alias.c (nonoverlapping_memrefs_p): New function.\n\n\t* alias.c (nonoverlapping_memrefs_p): New function.\n\t(true_dependence, canon_true_depenence, write_dependence_p): Call it.\n\nFrom-SVN: r46897", "tree": {"sha": "86174706216e85f35260246db13975108f5b73bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86174706216e85f35260246db13975108f5b73bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4311dfe6d5ee5539793adb7bf12400b070ba9b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4311dfe6d5ee5539793adb7bf12400b070ba9b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4311dfe6d5ee5539793adb7bf12400b070ba9b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4311dfe6d5ee5539793adb7bf12400b070ba9b1/comments", "author": null, "committer": null, "parents": [{"sha": "9ddfb1a75bece3f23c95c7d9ec0e8bbff3b1cb67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ddfb1a75bece3f23c95c7d9ec0e8bbff3b1cb67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ddfb1a75bece3f23c95c7d9ec0e8bbff3b1cb67"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "5c8c34d8af7f2504cfce144ee4562a5038f2c38e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4311dfe6d5ee5539793adb7bf12400b070ba9b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4311dfe6d5ee5539793adb7bf12400b070ba9b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4311dfe6d5ee5539793adb7bf12400b070ba9b1", "patch": "@@ -1,5 +1,8 @@\n Fri Nov  9 17:51:09 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* alias.c (nonoverlapping_memrefs_p): New function.\n+\t(true_dependence, canon_true_depenence, write_dependence_p): Call it.\n+\n \t* emit-rtl.c (set_mem_attributes): Get alignments for constants.\n \n 2001-11-09  Aldy Hernandez  <aldyh@redhat.com>"}, {"sha": "add9c94bb4815019441950a78d76f25b39aeab9d", "filename": "gcc/alias.c", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4311dfe6d5ee5539793adb7bf12400b070ba9b1/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4311dfe6d5ee5539793adb7bf12400b070ba9b1/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=a4311dfe6d5ee5539793adb7bf12400b070ba9b1", "patch": "@@ -104,6 +104,7 @@ static alias_set_entry get_alias_set_entry PARAMS ((HOST_WIDE_INT));\n static rtx fixed_scalar_and_varying_struct_p PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t\t\t      int (*) (rtx, int)));\n static int aliases_everything_p         PARAMS ((rtx));\n+static int nonoverlapping_memrefs_p\tPARAMS ((rtx, rtx));\n static int write_dependence_p           PARAMS ((rtx, rtx, int));\n static int nonlocal_mentioned_p         PARAMS ((rtx));\n \n@@ -1761,6 +1762,81 @@ aliases_everything_p (mem)\n   return 0;\n }\n \n+/* Return nonzero if we can deterimine the decls corresponding to memrefs\n+   X and Y and they do not overlap.  */\n+\n+static int\n+nonoverlapping_memrefs_p (x, y)\n+     rtx x, y;\n+{\n+  rtx rtlx, rtly;\n+  rtx basex, basey;\n+  HOST_WIDE_INT offsetx = 0, offsety = 0, sizex, sizey, tem;\n+\n+  /* Unless both have decls, we can't tell anything.  */\n+  if (MEM_DECL (x) == 0 || MEM_DECL (y) == 0)\n+    return 0;\n+\n+  rtlx = DECL_RTL (MEM_DECL (x));\n+  rtly = DECL_RTL (MEM_DECL (y));\n+\n+  /* If either RTL is a REG, they can't overlap unless they are the same\n+     because we never reuse that part of the stack frame used for locals for\n+     spilled pseudos.  */\n+  if ((REG_P (rtlx) || REG_P (rtly)) && ! rtx_equal_p (rtlx, rtly))\n+    return 1;\n+\n+  /* Get the base and offsets of both decls.  If either is a register, we\n+     know both are and are the same, so use that as the base.  The only\n+     we can avoid overlap is if we can deduce that they are nonoverlapping\n+     pieces of that decl, which is very rare.  */\n+  basex = REG_P (rtlx) ? rtlx : XEXP (rtlx, 0);\n+  if (GET_CODE (basex) == PLUS && GET_CODE (XEXP (basex, 1)) == CONST_INT)\n+    offsetx = INTVAL (XEXP (basex, 1)), basex = XEXP (basex, 0);\n+\n+  basey = REG_P (rtly) ? rtly : XEXP (rtly, 0);\n+  if (GET_CODE (basey) == PLUS && GET_CODE (XEXP (basey, 1)) == CONST_INT)\n+    offsety = INTVAL (XEXP (basey, 1)), basey = XEXP (basey, 0);\n+\n+  /* If the bases are both constant and they are different, we know these\n+     do not overlap.  If they are both registers, we can only deduce\n+     something if they are the same register.  */\n+  if (CONSTANT_P (basex) && CONSTANT_P (basey) && ! rtx_equal_p (basex, basey))\n+    return 1;\n+  else if (! rtx_equal_p (basex, basey))\n+    return 0;\n+\n+  sizex = (REG_P (rtlx) ? GET_MODE_SIZE (GET_MODE (rtlx))\n+\t   : MEM_SIZE (rtlx) ? INTVAL (MEM_SIZE (rtlx))\n+\t   : -1);\n+  sizey = (REG_P (rtly) ? GET_MODE_SIZE (GET_MODE (rtly))\n+\t   : MEM_SIZE (rtly) ? INTVAL (MEM_SIZE (rtly)) :\n+\t   -1);\n+\n+  /* If we have an offset or size for either memref, it can update the values\n+     computed above.  */\n+  if (MEM_OFFSET (x))\n+    offsetx += INTVAL (MEM_OFFSET (x));\n+  if (MEM_OFFSET (y))\n+    offsety += INTVAL (MEM_OFFSET (y));\n+\n+  if (MEM_SIZE (x))\n+    sizex = INTVAL (MEM_SIZE (x));\n+  if (MEM_SIZE (y))\n+    sizey = INTVAL (MEM_SIZE (y));\n+\n+  /* Put the values of the memref with the lower offset in X's values.  */\n+  if (offsetx > offsety)\n+    {\n+      tem = offsetx, offsetx = offsety, offsety = tem;\n+      tem = sizex, sizex = sizey, sizey = tem;\n+    }\n+\n+  /* If we don't know the size of the lower-offset value, we can't tell\n+     if they conflict.  Otherwise, we do the test.  */\n+  return sizex >= 0 && offsety > offsetx + sizex;\n+}\n+\n /* True dependence: X is read after store in MEM takes place.  */\n \n int\n@@ -1792,6 +1868,9 @@ true_dependence (mem, mem_mode, x, varies)\n   if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n     return 0;\n \n+  if (nonoverlapping_memrefs_p (mem, x))\n+    return 0;\n+\n   if (mem_mode == VOIDmode)\n     mem_mode = GET_MODE (mem);\n \n@@ -1861,6 +1940,9 @@ canon_true_dependence (mem, mem_mode, mem_addr, x, varies)\n   if (RTX_UNCHANGING_P (x) && ! RTX_UNCHANGING_P (mem))\n     return 0;\n \n+  if (nonoverlapping_memrefs_p (x, mem))\n+    return 0;\n+\n   x_addr = get_addr (XEXP (x, 0));\n \n   if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), mem_mode))\n@@ -1917,6 +1999,9 @@ write_dependence_p (mem, x, writep)\n   if (! writep && RTX_UNCHANGING_P (mem))\n     return 0;\n \n+  if (nonoverlapping_memrefs_p (x, mem))\n+    return 0;\n+\n   x_addr = get_addr (XEXP (x, 0));\n   mem_addr = get_addr (XEXP (mem, 0));\n "}]}