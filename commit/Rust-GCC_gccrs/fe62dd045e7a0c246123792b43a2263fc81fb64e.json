{"sha": "fe62dd045e7a0c246123792b43a2263fc81fb64e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU2MmRkMDQ1ZTdhMGMyNDYxMjM3OTJiNDNhMjI2M2ZjODFmYjY0ZQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2017-03-20T20:51:40Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2017-03-20T20:51:40Z"}, "message": "stl_deque.h (deque): Access allocator value_type only if concept checks are enabled.\n\n2017-03-20  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/stl_deque.h (deque): Access allocator value_type only if\n\tconcept checks are enabled.\n\t* include/bits/stl_stack.h (stack): Likewise.\n\t* include/bits/stl_vector.h (vector): Likewise.\n\t* include/bits/stl_list.h (list): Likewise and check\n\t_SGIAssignableConcept only in C++03.\n\t* include/bits/stl_map.h (map): Likewise.\n\t* include/bits/stl_set.h (set): Likewise.\n\t* include/bits/stl_multimap.h (multimap): Likewise.\n\t* include/bits/stl_multiset.h (multiset): Likewise.\n\t* include/bits/stl_queue.h (queue, priority_queue): Likewise.\n\nFrom-SVN: r246294", "tree": {"sha": "0070c577fc0c1a3b3d16574c081eb8f048b52172", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0070c577fc0c1a3b3d16574c081eb8f048b52172"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe62dd045e7a0c246123792b43a2263fc81fb64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe62dd045e7a0c246123792b43a2263fc81fb64e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe62dd045e7a0c246123792b43a2263fc81fb64e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe62dd045e7a0c246123792b43a2263fc81fb64e/comments", "author": null, "committer": null, "parents": [{"sha": "92279d5f85b9b1c2a4c1d9218732c6e9aaa4d973", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92279d5f85b9b1c2a4c1d9218732c6e9aaa4d973", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92279d5f85b9b1c2a4c1d9218732c6e9aaa4d973"}], "stats": {"total": 1100, "additions": 574, "deletions": 526}, "files": [{"sha": "6114393e6e44b6d0053c41a2705a82c16707ee6c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -1,3 +1,17 @@\n+2017-03-20  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/stl_deque.h (deque): Access allocator value_type only if\n+\tconcept checks are enabled.\n+\t* include/bits/stl_stack.h (stack): Likewise.\n+\t* include/bits/stl_vector.h (vector): Likewise.\n+\t* include/bits/stl_list.h (list): Likewise and check\n+\t_SGIAssignableConcept only in C++03.\n+\t* include/bits/stl_map.h (map): Likewise.\n+\t* include/bits/stl_set.h (set): Likewise.\n+\t* include/bits/stl_multimap.h (multimap): Likewise.\n+\t* include/bits/stl_multiset.h (multiset): Likewise.\n+\t* include/bits/stl_queue.h (queue, priority_queue): Likewise.\n+\n 2017-03-18  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/xml/manual/appendix_contributing.xml: Convert link to\n@@ -351,7 +365,7 @@\n \tTweak link description.\n \n 2017-02-18  Gerald Pfeifer  <gerald@pfeifer.com>\n-\t\n+\n \t* doc/xml/manual/profile_mode.xml: Fix link.\n \n 2017-02-16  Gerald Pfeifer  <gerald@pfeifer.com>\n@@ -418,9 +432,9 @@\n \n \t* include/bits/atomic_base.h: Re-indent.\n \n-2017-02-10  Gerald Pfeifer  <gerald@pfeifer.com> \n+2017-02-10  Gerald Pfeifer  <gerald@pfeifer.com>\n \n-\t* doc/xml/manual/profile_mode.xml: Update a paper reference. \n+\t* doc/xml/manual/profile_mode.xml: Update a paper reference.\n \n 2017-02-08  Gerald Pfeifer  <gerald@pfeifer.com>\n \n@@ -440,16 +454,16 @@\n \t* doc/html/*: Regenerate.\n \n 2017-02-08  Gerald Pfeifer  <gerald@pfeifer.com>\n-\t\n+\n \t* doc/xml/manual/profile_mode.xml: Unbreak link to\n \t\"Optimizing Sorting with Machine Learning Algorithms\".\n \n 2017-02-08  Gerald Pfeifer  <gerald@pfeifer.com>\n-\t\n+\n \t* src/c++11/snprintf_lite.cc (__err): Update bug reporting URL.\n \n 2017-02-08  Gerald Pfeifer  <gerald@pfeifer.com>\n-\t\n+\n \t* doc/xml/manual/abi.xml: Update link to \"Sun Studio 11: C++\n \tMigration Guide\".\n \n@@ -714,7 +728,7 @@\n \t* doc/xml/manual/debug.xml: code.google.com uses https now.\n \n 2017-01-22  Gerald Pfeifer  <gerald@pfeifer.com>\n-\t\n+\n \t* doc/xml/manual/test.xml: Fix link into gccint online manual.\n \n 2017-01-21  Ville Voutilainen  <ville.voutilainen@gmail.com>\n@@ -935,7 +949,7 @@\n 2017-01-17  Joshua Conner  <joshconner@google.com>\n \n \t* crossconfig.m4: Add fuchsia OS.\n-\t* configure: Regenerate. \n+\t* configure: Regenerate.\n \n 2017-01-17  Jonathan Wakely  <jwakely@redhat.com>\n \n@@ -1415,7 +1429,7 @@\n \n \t* doc/xml/faq.xml: Update address of C++ ABI link.\n \t* doc/xml/manual/abi.xml: Ditto.\n-\t\n+\n 2017-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "6090635b7d615a7146e6727acebaed79c6903c13", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 105, "deletions": 103, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -108,10 +108,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     struct _Deque_iterator\n     {\n #if __cplusplus < 201103L\n-      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n+      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>\t     iterator;\n       typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n-      typedef _Tp*                                         _Elt_pointer;\n-      typedef _Tp**                                        _Map_pointer;\n+      typedef _Tp*\t\t\t\t\t _Elt_pointer;\n+      typedef _Tp**\t\t\t\t\t_Map_pointer;\n #else\n     private:\n       template<typename _Up>\n@@ -128,13 +128,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT\n       { return __deque_buf_size(sizeof(_Tp)); }\n \n-      typedef std::random_access_iterator_tag iterator_category;\n-      typedef _Tp                             value_type;\n-      typedef _Ptr                            pointer;\n-      typedef _Ref                            reference;\n-      typedef size_t                          size_type;\n-      typedef ptrdiff_t                       difference_type;\n-      typedef _Deque_iterator                 _Self;\n+      typedef std::random_access_iterator_tag\titerator_category;\n+      typedef _Tp\t\t\t\tvalue_type;\n+      typedef _Ptr\t\t\t\tpointer;\n+      typedef _Ref\t\t\t\treference;\n+      typedef size_t\t\t\t\tsize_type;\n+      typedef ptrdiff_t\t\t\t\tdifference_type;\n+      typedef _Deque_iterator\t\t\t_Self;\n \n       _Elt_pointer _M_cur;\n       _Elt_pointer _M_first;\n@@ -143,14 +143,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT\n       : _M_cur(__x), _M_first(*__y),\n-        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }\n+\t_M_last(*__y + _S_buffer_size()), _M_node(__y) { }\n \n       _Deque_iterator() _GLIBCXX_NOEXCEPT\n       : _M_cur(), _M_first(), _M_last(), _M_node() { }\n \n       _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT\n       : _M_cur(__x._M_cur), _M_first(__x._M_first),\n-        _M_last(__x._M_last), _M_node(__x._M_node) { }\n+\t_M_last(__x._M_last), _M_node(__x._M_node) { }\n \n       iterator\n       _M_const_cast() const _GLIBCXX_NOEXCEPT\n@@ -214,7 +214,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  {\n \t    const difference_type __node_offset =\n \t      __offset > 0 ? __offset / difference_type(_S_buffer_size())\n-\t                   : -difference_type((-__offset - 1)\n+\t\t\t   : -difference_type((-__offset - 1)\n \t\t\t\t\t      / _S_buffer_size()) - 1;\n \t    _M_set_node(_M_node + __node_offset);\n \t    _M_cur = _M_first + (__offset - __node_offset\n@@ -245,7 +245,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       operator[](difference_type __n) const _GLIBCXX_NOEXCEPT\n       { return *(*this + __n); }\n \n-      /** \n+      /**\n        *  Prepares to traverse new_node.  Sets everything except\n        *  _M_cur, which should therefore be set by the caller\n        *  immediately afterwards, based on _M_first and _M_last.\n@@ -293,15 +293,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT\n     { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)\n-                                          : (__x._M_node < __y._M_node); }\n+\t\t\t\t\t  : (__x._M_node < __y._M_node); }\n \n   template<typename _Tp, typename _RefL, typename _PtrL,\n \t   typename _RefR, typename _PtrR>\n     inline bool\n     operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT\n     { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)\n-\t                                  : (__x._M_node < __y._M_node); }\n+\t\t\t\t\t  : (__x._M_node < __y._M_node); }\n \n   template<typename _Tp, typename _Ref, typename _Ptr>\n     inline bool\n@@ -477,14 +477,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;\n \n     public:\n-      typedef _Alloc                  allocator_type;\n+      typedef _Alloc\t\t  allocator_type;\n       typedef typename _Alloc_traits::size_type size_type;\n \n       allocator_type\n       get_allocator() const _GLIBCXX_NOEXCEPT\n       { return allocator_type(_M_get_Tp_allocator()); }\n \n-      typedef _Deque_iterator<_Tp, _Tp&, _Ptr>          iterator;\n+      typedef _Deque_iterator<_Tp, _Tp&, _Ptr>\t  iterator;\n       typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;\n \n       _Deque_base()\n@@ -597,7 +597,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       _Ptr\n       _M_allocate_node()\n-      { \n+      {\n \ttypedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;\n \treturn _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));\n       }\n@@ -830,31 +830,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n     class deque : protected _Deque_base<_Tp, _Alloc>\n     {\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n-      typedef typename _Alloc::value_type        _Alloc_value_type;\n-#if __cplusplus < 201103L\n+      typedef typename _Alloc::value_type\t_Alloc_value_type;\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-#endif\n+# endif\n       __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)\n+#endif\n \n       typedef _Deque_base<_Tp, _Alloc>\t\t\t_Base;\n       typedef typename _Base::_Tp_alloc_type\t\t_Tp_alloc_type;\n       typedef typename _Base::_Alloc_traits\t\t_Alloc_traits;\n       typedef typename _Base::_Map_pointer\t\t_Map_pointer;\n \n     public:\n-      typedef _Tp                                        value_type;\n-      typedef typename _Alloc_traits::pointer            pointer;\n-      typedef typename _Alloc_traits::const_pointer      const_pointer;\n-      typedef typename _Alloc_traits::reference          reference;\n-      typedef typename _Alloc_traits::const_reference    const_reference;\n-      typedef typename _Base::iterator                   iterator;\n-      typedef typename _Base::const_iterator             const_iterator;\n-      typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;\n-      typedef std::reverse_iterator<iterator>            reverse_iterator;\n-      typedef size_t                             size_type;\n-      typedef ptrdiff_t                          difference_type;\n-      typedef _Alloc                             allocator_type;\n+      typedef _Tp\t\t\t\t\tvalue_type;\n+      typedef typename _Alloc_traits::pointer\t\tpointer;\n+      typedef typename _Alloc_traits::const_pointer\tconst_pointer;\n+      typedef typename _Alloc_traits::reference\t\treference;\n+      typedef typename _Alloc_traits::const_reference\tconst_reference;\n+      typedef typename _Base::iterator\t\t\titerator;\n+      typedef typename _Base::const_iterator\t\tconst_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>\t\treverse_iterator;\n+      typedef size_t\t\t\t\t\tsize_type;\n+      typedef ptrdiff_t\t\t\t\t\tdifference_type;\n+      typedef _Alloc\t\t\t\t\tallocator_type;\n \n     protected:\n       static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT\n@@ -870,7 +872,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       using _Base::_M_deallocate_map;\n       using _Base::_M_get_Tp_allocator;\n \n-      /** \n+      /**\n        *  A total of four data members accumulated down the hierarchy.\n        *  May be accessed via _M_impl.*\n        */\n@@ -945,7 +947,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       deque(const deque& __x)\n       : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),\n \t      __x.size())\n-      { std::__uninitialized_copy_a(__x.begin(), __x.end(), \n+      { std::__uninitialized_copy_a(__x.begin(), __x.end(),\n \t\t\t\t    this->_M_impl._M_start,\n \t\t\t\t    _M_get_Tp_allocator()); }\n \n@@ -1018,16 +1020,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        deque(_InputIterator __first, _InputIterator __last,\n+\tdeque(_InputIterator __first, _InputIterator __last,\n \t      const allocator_type& __a = allocator_type())\n \t: _Base(__a)\n-        { _M_initialize_dispatch(__first, __last, __false_type()); }\n+\t{ _M_initialize_dispatch(__first, __last, __false_type()); }\n #else\n       template<typename _InputIterator>\n-        deque(_InputIterator __first, _InputIterator __last,\n+\tdeque(_InputIterator __first, _InputIterator __last,\n \t      const allocator_type& __a = allocator_type())\n \t: _Base(__a)\n-        {\n+\t{\n \t  // Check whether it's an integral type.  If so, it's not an iterator.\n \t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n \t  _M_initialize_dispatch(__first, __last, _Integral());\n@@ -1120,14 +1122,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        { _M_assign_dispatch(__first, __last, __false_type()); }\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{ _M_assign_dispatch(__first, __last, __false_type()); }\n #else\n       template<typename _InputIterator>\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n \t  _M_assign_dispatch(__first, __last, _Integral());\n \t}\n@@ -1505,8 +1507,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tif (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)\n \t  {\n \t    _Alloc_traits::construct(this->_M_impl,\n-\t                             this->_M_impl._M_start._M_cur - 1,\n-\t                             __x);\n+\t\t\t\t     this->_M_impl._M_start._M_cur - 1,\n+\t\t\t\t     __x);\n \t    --this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n@@ -1524,7 +1526,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #else\n \tvoid\n #endif\n-        emplace_front(_Args&&... __args);\n+\templace_front(_Args&&... __args);\n #endif\n \n       /**\n@@ -1543,7 +1545,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    != this->_M_impl._M_finish._M_last - 1)\n \t  {\n \t    _Alloc_traits::construct(this->_M_impl,\n-\t                             this->_M_impl._M_finish._M_cur, __x);\n+\t\t\t\t     this->_M_impl._M_finish._M_cur, __x);\n \t    ++this->_M_impl._M_finish._M_cur;\n \t  }\n \telse\n@@ -1561,7 +1563,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #else\n \tvoid\n #endif\n-        emplace_back(_Args&&... __args);\n+\templace_back(_Args&&... __args);\n #endif\n \n       /**\n@@ -1580,7 +1582,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    != this->_M_impl._M_start._M_last - 1)\n \t  {\n \t    _Alloc_traits::destroy(this->_M_impl,\n-\t                           this->_M_impl._M_start._M_cur);\n+\t\t\t\t   this->_M_impl._M_start._M_cur);\n \t    ++this->_M_impl._M_start._M_cur;\n \t  }\n \telse\n@@ -1604,7 +1606,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  {\n \t    --this->_M_impl._M_finish._M_cur;\n \t    _Alloc_traits::destroy(this->_M_impl,\n-\t                           this->_M_impl._M_finish._M_cur);\n+\t\t\t\t   this->_M_impl._M_finish._M_cur);\n \t  }\n \telse\n \t  _M_pop_back_aux();\n@@ -1621,8 +1623,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  with T(std::forward<Args>(args)...) before the specified location.\n        */\n       template<typename... _Args>\n-        iterator\n-        emplace(const_iterator __position, _Args&&... __args);\n+\titerator\n+\templace(const_iterator __position, _Args&&... __args);\n \n       /**\n        *  @brief  Inserts given value into %deque before specified iterator.\n@@ -1729,10 +1731,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        iterator\n-        insert(const_iterator __position, _InputIterator __first,\n+\titerator\n+\tinsert(const_iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n-        {\n+\t{\n \t  difference_type __offset = __position - cbegin();\n \t  _M_insert_dispatch(__position._M_const_cast(),\n \t\t\t     __first, __last, __false_type());\n@@ -1750,10 +1752,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  by @a __position.  This is known as <em>range insert</em>.\n        */\n       template<typename _InputIterator>\n-        void\n-        insert(iterator __position, _InputIterator __first,\n+\tvoid\n+\tinsert(iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n-        {\n+\t{\n \t  // Check whether it's an integral type.  If so, it's not an iterator.\n \t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n \t  _M_insert_dispatch(__position, __first, __last, _Integral());\n@@ -1846,19 +1848,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n-        void\n-        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n-        {\n+\tvoid\n+\t_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+\t{\n \t  _M_initialize_map(static_cast<size_type>(__n));\n \t  _M_fill_initialize(__x);\n \t}\n \n       // called by the range constructor to implement [23.1.1]/9\n       template<typename _InputIterator>\n-        void\n-        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+\tvoid\n+\t_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t       __false_type)\n-        {\n+\t{\n \t  _M_range_initialize(__first, __last,\n \t\t\t      std::__iterator_category(__first));\n \t}\n@@ -1876,14 +1878,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  push_back on each value from the iterator.\n        */\n       template<typename _InputIterator>\n-        void\n-        _M_range_initialize(_InputIterator __first, _InputIterator __last,\n+\tvoid\n+\t_M_range_initialize(_InputIterator __first, _InputIterator __last,\n \t\t\t    std::input_iterator_tag);\n \n       // called by the second initialize_dispatch above\n       template<typename _ForwardIterator>\n-        void\n-        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n+\tvoid\n+\t_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n \t\t\t    std::forward_iterator_tag);\n       //@}\n \n@@ -1914,29 +1916,29 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n-        void\n-        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-        { _M_fill_assign(__n, __val); }\n+\tvoid\n+\t_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+\t{ _M_fill_assign(__n, __val); }\n \n       // called by the range assign to implement [23.1.1]/9\n       template<typename _InputIterator>\n-        void\n-        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+\tvoid\n+\t_M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t   __false_type)\n \t{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }\n \n       // called by the second assign_dispatch above\n       template<typename _InputIterator>\n-        void\n-        _M_assign_aux(_InputIterator __first, _InputIterator __last,\n+\tvoid\n+\t_M_assign_aux(_InputIterator __first, _InputIterator __last,\n \t\t      std::input_iterator_tag);\n \n       // called by the second assign_dispatch above\n       template<typename _ForwardIterator>\n-        void\n-        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n+\tvoid\n+\t_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n \t\t      std::forward_iterator_tag)\n-        {\n+\t{\n \t  const size_type __len = std::distance(__first, __last);\n \t  if (__len > size())\n \t    {\n@@ -1975,10 +1977,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       void _M_push_front_aux(const value_type&);\n #else\n       template<typename... _Args>\n-        void _M_push_back_aux(_Args&&... __args);\n+\tvoid _M_push_back_aux(_Args&&... __args);\n \n       template<typename... _Args>\n-        void _M_push_front_aux(_Args&&... __args);\n+\tvoid _M_push_front_aux(_Args&&... __args);\n #endif\n \n       void _M_pop_back_aux();\n@@ -1994,32 +1996,32 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n-        void\n-        _M_insert_dispatch(iterator __pos,\n+\tvoid\n+\t_M_insert_dispatch(iterator __pos,\n \t\t\t   _Integer __n, _Integer __x, __true_type)\n-        { _M_fill_insert(__pos, __n, __x); }\n+\t{ _M_fill_insert(__pos, __n, __x); }\n \n       // called by the range insert to implement [23.1.1]/9\n       template<typename _InputIterator>\n-        void\n-        _M_insert_dispatch(iterator __pos,\n+\tvoid\n+\t_M_insert_dispatch(iterator __pos,\n \t\t\t   _InputIterator __first, _InputIterator __last,\n \t\t\t   __false_type)\n-        {\n-          _M_range_insert_aux(__pos, __first, __last,\n+\t{\n+\t  _M_range_insert_aux(__pos, __first, __last,\n \t\t\t      std::__iterator_category(__first));\n \t}\n \n       // called by the second insert_dispatch above\n       template<typename _InputIterator>\n-        void\n-        _M_range_insert_aux(iterator __pos, _InputIterator __first,\n+\tvoid\n+\t_M_range_insert_aux(iterator __pos, _InputIterator __first,\n \t\t\t    _InputIterator __last, std::input_iterator_tag);\n \n       // called by the second insert_dispatch above\n       template<typename _ForwardIterator>\n-        void\n-        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n+\tvoid\n+\t_M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n \t\t\t    _ForwardIterator __last, std::forward_iterator_tag);\n \n       // Called by insert(p,n,x), and the range insert when it turns out to be\n@@ -2034,8 +2036,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_insert_aux(iterator __pos, const value_type& __x);\n #else\n       template<typename... _Args>\n-        iterator\n-        _M_insert_aux(iterator __pos, _Args&&... __args);\n+\titerator\n+\t_M_insert_aux(iterator __pos, _Args&&... __args);\n #endif\n \n       // called by insert(p,n,x) via fill_insert\n@@ -2044,8 +2046,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // called by range_insert_aux for forward iterators\n       template<typename _ForwardIterator>\n-        void\n-        _M_insert_aux(iterator __pos,\n+\tvoid\n+\t_M_insert_aux(iterator __pos,\n \t\t      _ForwardIterator __first, _ForwardIterator __last,\n \t\t      size_type __n);\n \n@@ -2058,9 +2060,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // Called by ~deque().\n       // NB: Doesn't deallocate the nodes.\n       template<typename _Alloc1>\n-        void\n-        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)\n-        { _M_destroy_data_aux(__first, __last); }\n+\tvoid\n+\t_M_destroy_data(iterator __first, iterator __last, const _Alloc1&)\n+\t{ _M_destroy_data_aux(__first, __last); }\n \n       void\n       _M_destroy_data(iterator __first, iterator __last,\n@@ -2111,7 +2113,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_reserve_elements_at_front(size_type __n)\n       {\n \tconst size_type __vacancies = this->_M_impl._M_start._M_cur\n-\t                              - this->_M_impl._M_start._M_first;\n+\t\t\t\t      - this->_M_impl._M_start._M_first;\n \tif (__n > __vacancies)\n \t  _M_new_elements_at_front(__n - __vacancies);\n \treturn this->_M_impl._M_start - difference_type(__n);\n@@ -2256,7 +2258,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator==(const deque<_Tp, _Alloc>& __x,\n                          const deque<_Tp, _Alloc>& __y)\n     { return __x.size() == __y.size()\n-             && std::equal(__x.begin(), __x.end(), __y.begin()); }\n+\t     && std::equal(__x.begin(), __x.end(), __y.begin()); }\n \n   /**\n    *  @brief  Deque ordering relation."}, {"sha": "0420dbfbba744c4c7de73de967bdcd124d7dac9d", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 104, "deletions": 100, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -76,7 +76,7 @@ namespace std _GLIBCXX_VISIBILITY(default)\n     // \"needless\" static_cast'ing later on, but it's all safe\n     // downcasting.\n \n-    /// Common part of a node in the %list. \n+    /// Common part of a node in the %list.\n     struct _List_node_base\n     {\n       _List_node_base* _M_next;\n@@ -127,14 +127,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp>\n     struct _List_iterator\n     {\n-      typedef _List_iterator<_Tp>                _Self;\n-      typedef _List_node<_Tp>                    _Node;\n+      typedef _List_iterator<_Tp>\t\t_Self;\n+      typedef _List_node<_Tp>\t\t\t_Node;\n \n-      typedef ptrdiff_t                          difference_type;\n-      typedef std::bidirectional_iterator_tag    iterator_category;\n-      typedef _Tp                                value_type;\n-      typedef _Tp*                               pointer;\n-      typedef _Tp&                               reference;\n+      typedef ptrdiff_t\t\t\t\tdifference_type;\n+      typedef std::bidirectional_iterator_tag\titerator_category;\n+      typedef _Tp\t\t\t\tvalue_type;\n+      typedef _Tp*\t\t\t\tpointer;\n+      typedef _Tp&\t\t\t\treference;\n \n       _List_iterator() _GLIBCXX_NOEXCEPT\n       : _M_node() { }\n@@ -206,15 +206,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp>\n     struct _List_const_iterator\n     {\n-      typedef _List_const_iterator<_Tp>          _Self;\n-      typedef const _List_node<_Tp>              _Node;\n-      typedef _List_iterator<_Tp>                iterator;\n+      typedef _List_const_iterator<_Tp>\t\t_Self;\n+      typedef const _List_node<_Tp>\t\t_Node;\n+      typedef _List_iterator<_Tp>\t\titerator;\n \n-      typedef ptrdiff_t                          difference_type;\n-      typedef std::bidirectional_iterator_tag    iterator_category;\n-      typedef _Tp                                value_type;\n-      typedef const _Tp*                         pointer;\n-      typedef const _Tp&                         reference;\n+      typedef ptrdiff_t\t\t\t\tdifference_type;\n+      typedef std::bidirectional_iterator_tag\titerator_category;\n+      typedef _Tp\t\t\t\tvalue_type;\n+      typedef const _Tp*\t\t\tpointer;\n+      typedef const _Tp&\t\t\treference;\n \n       _List_const_iterator() _GLIBCXX_NOEXCEPT\n       : _M_node() { }\n@@ -291,7 +291,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Val>\n     inline bool\n     operator!=(const _List_iterator<_Val>& __x,\n-               const _List_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT\n+\t       const _List_const_iterator<_Val>& __y) _GLIBCXX_NOEXCEPT\n     { return __x._M_node != __y._M_node; }\n \n _GLIBCXX_BEGIN_NAMESPACE_CXX11\n@@ -447,8 +447,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       void\n       _M_init() _GLIBCXX_NOEXCEPT\n       {\n-        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;\n-        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;\n+\tthis->_M_impl._M_node._M_next = &this->_M_impl._M_node;\n+\tthis->_M_impl._M_node._M_prev = &this->_M_impl._M_node;\n \t_M_set_size(0);\n       }\n     };\n@@ -497,35 +497,39 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n    *  pointing to @e D, not to @e A!  To get to the head of the %list,\n    *  we start at the tail and move forward by one.  When this member\n    *  iterator's next/previous pointers refer to itself, the %list is\n-   *  %empty. \n+   *  %empty.\n   */\n   template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n     class list : protected _List_base<_Tp, _Alloc>\n     {\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n-      typedef typename _Alloc::value_type                _Alloc_value_type;\n+      typedef typename _Alloc::value_type\t\t_Alloc_value_type;\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+# endif\n       __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)\n+#endif\n \n-      typedef _List_base<_Tp, _Alloc>                    _Base;\n-      typedef typename _Base::_Tp_alloc_type\t\t _Tp_alloc_type;\n-      typedef typename _Base::_Tp_alloc_traits\t\t _Tp_alloc_traits;\n-      typedef typename _Base::_Node_alloc_type\t\t _Node_alloc_type;\n-      typedef typename _Base::_Node_alloc_traits\t _Node_alloc_traits;\n+      typedef _List_base<_Tp, _Alloc>\t\t\t_Base;\n+      typedef typename _Base::_Tp_alloc_type\t\t_Tp_alloc_type;\n+      typedef typename _Base::_Tp_alloc_traits\t\t_Tp_alloc_traits;\n+      typedef typename _Base::_Node_alloc_type\t\t_Node_alloc_type;\n+      typedef typename _Base::_Node_alloc_traits\t_Node_alloc_traits;\n \n     public:\n-      typedef _Tp                                        value_type;\n+      typedef _Tp\t\t\t\t\t value_type;\n       typedef typename _Tp_alloc_traits::pointer\t pointer;\n       typedef typename _Tp_alloc_traits::const_pointer\t const_pointer;\n       typedef typename _Tp_alloc_traits::reference\t reference;\n       typedef typename _Tp_alloc_traits::const_reference const_reference;\n       typedef _List_iterator<_Tp>\t\t\t iterator;\n       typedef _List_const_iterator<_Tp>\t\t\t const_iterator;\n-      typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;\n-      typedef std::reverse_iterator<iterator>            reverse_iterator;\n-      typedef size_t                                     size_type;\n-      typedef ptrdiff_t                                  difference_type;\n-      typedef _Alloc                                     allocator_type;\n+      typedef std::reverse_iterator<const_iterator>\t const_reverse_iterator;\n+      typedef std::reverse_iterator<iterator>\t\t reverse_iterator;\n+      typedef size_t\t\t\t\t\t size_type;\n+      typedef ptrdiff_t\t\t\t\t\t difference_type;\n+      typedef _Alloc\t\t\t\t\t allocator_type;\n \n     protected:\n       // Note that pointers-to-_Node's can be ctor-converted to\n@@ -562,8 +566,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       }\n #else\n       template<typename... _Args>\n-        _Node*\n-        _M_create_node(_Args&&... __args)\n+\t_Node*\n+\t_M_create_node(_Args&&... __args)\n \t{\n \t  auto __p = this->_M_get_node();\n \t  auto& __alloc = _M_get_Node_allocator();\n@@ -670,7 +674,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        *  initializer_list @a __l.  This is linear in __l.size().\n        */\n       list(initializer_list<value_type> __l,\n-           const allocator_type& __a = allocator_type())\n+\t   const allocator_type& __a = allocator_type())\n       : _Base(_Node_alloc_type(__a))\n       { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }\n \n@@ -702,16 +706,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        list(_InputIterator __first, _InputIterator __last,\n+\tlist(_InputIterator __first, _InputIterator __last,\n \t     const allocator_type& __a = allocator_type())\n \t: _Base(_Node_alloc_type(__a))\n-        { _M_initialize_dispatch(__first, __last, __false_type()); }\n+\t{ _M_initialize_dispatch(__first, __last, __false_type()); }\n #else\n       template<typename _InputIterator>\n-        list(_InputIterator __first, _InputIterator __last,\n+\tlist(_InputIterator __first, _InputIterator __last,\n \t     const allocator_type& __a = allocator_type())\n \t: _Base(_Node_alloc_type(__a))\n-        { \n+\t{\n \t  // Check whether it's an integral type.  If so, it's not an iterator.\n \t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n \t  _M_initialize_dispatch(__first, __last, _Integral());\n@@ -756,9 +760,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       noexcept(_Node_alloc_traits::_S_nothrow_move())\n       {\n \tconstexpr bool __move_storage =\n-          _Node_alloc_traits::_S_propagate_on_move_assign()\n-          || _Node_alloc_traits::_S_always_equal();\n-        _M_move_assign(std::move(__x), __bool_constant<__move_storage>());\n+\t  _Node_alloc_traits::_S_propagate_on_move_assign()\n+\t  || _Node_alloc_traits::_S_always_equal();\n+\t_M_move_assign(std::move(__x), __bool_constant<__move_storage>());\n \treturn *this;\n       }\n \n@@ -806,14 +810,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n #if __cplusplus >= 201103L\n       template<typename _InputIterator,\n \t       typename = std::_RequireInputIter<_InputIterator>>\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        { _M_assign_dispatch(__first, __last, __false_type()); }\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{ _M_assign_dispatch(__first, __last, __false_type()); }\n #else\n       template<typename _InputIterator>\n-        void\n-        assign(_InputIterator __first, _InputIterator __last)\n-        {\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n \t  // Check whether it's an integral type.  If so, it's not an iterator.\n \t  typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n \t  _M_assign_dispatch(__first, __last, _Integral());\n@@ -1030,7 +1034,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        */\n       reference\n       back() _GLIBCXX_NOEXCEPT\n-      { \n+      {\n \titerator __tmp = end();\n \t--__tmp;\n \treturn *__tmp;\n@@ -1042,7 +1046,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        */\n       const_reference\n       back() const _GLIBCXX_NOEXCEPT\n-      { \n+      {\n \tconst_iterator __tmp = end();\n \t--__tmp;\n \treturn *__tmp;\n@@ -1070,12 +1074,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n       template<typename... _Args>\n #if __cplusplus > 201402L\n-        reference\n+\treference\n #else\n \tvoid\n #endif\n-        emplace_front(_Args&&... __args)\n-        {\n+\templace_front(_Args&&... __args)\n+\t{\n \t  this->_M_insert(begin(), std::forward<_Args>(__args)...);\n #if __cplusplus > 201402L\n \t  return front();\n@@ -1120,15 +1124,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n       template<typename... _Args>\n #if __cplusplus > 201402L\n-        reference\n+\treference\n #else\n \tvoid\n #endif\n-        emplace_back(_Args&&... __args)\n-        {\n+\templace_back(_Args&&... __args)\n+\t{\n \t  this->_M_insert(end(), std::forward<_Args>(__args)...);\n #if __cplusplus > 201402L\n-        return back();\n+\treturn back();\n #endif\n \t}\n #endif\n@@ -1162,8 +1166,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        *  and references.\n        */\n       template<typename... _Args>\n-        iterator\n-        emplace(const_iterator __position, _Args&&... __args);\n+\titerator\n+\templace(const_iterator __position, _Args&&... __args);\n \n       /**\n        *  @brief  Inserts given value into %list before specified iterator.\n@@ -1205,7 +1209,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        *  the specified location.  Due to the nature of a %list this\n        *  operation can be done in constant time, and does not\n        *  invalidate iterators and references.\n-        */\n+\t*/\n       iterator\n       insert(const_iterator __position, value_type&& __x)\n       { return emplace(__position, std::move(__x)); }\n@@ -1304,10 +1308,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        *  does not invalidate iterators and references.\n        */\n       template<typename _InputIterator>\n-        void\n-        insert(iterator __position, _InputIterator __first,\n+\tvoid\n+\tinsert(iterator __position, _InputIterator __first,\n \t       _InputIterator __last)\n-        {\n+\t{\n \t  list __tmp(__first, __last, get_allocator());\n \t  splice(__position, __tmp);\n \t}\n@@ -1380,14 +1384,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       swap(list& __x) _GLIBCXX_NOEXCEPT\n       {\n \t__detail::_List_node_base::swap(this->_M_impl._M_node,\n-\t\t\t\t        __x._M_impl._M_node);\n+\t\t\t\t\t__x._M_impl._M_node);\n \n \tsize_t __xsize = __x._M_get_size();\n \t__x._M_set_size(this->_M_get_size());\n \tthis->_M_set_size(__xsize);\n \n \t_Node_alloc_traits::_S_on_swap(this->_M_get_Node_allocator(),\n-                                       __x._M_get_Node_allocator());\n+\t\t\t\t       __x._M_get_Node_allocator());\n       }\n \n       /**\n@@ -1399,8 +1403,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       void\n       clear() _GLIBCXX_NOEXCEPT\n       {\n-        _Base::_M_clear();\n-        _Base::_M_init();\n+\t_Base::_M_clear();\n+\t_Base::_M_init();\n       }\n \n       // [23.2.2.4] list operations\n@@ -1594,8 +1598,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        *  responsibility.\n        */\n       template<typename _Predicate>\n-        void\n-        remove_if(_Predicate);\n+\tvoid\n+\tremove_if(_Predicate);\n \n       /**\n        *  @brief  Remove consecutive duplicate elements.\n@@ -1623,8 +1627,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        *  Managing the pointer is the user's responsibility.\n        */\n       template<typename _BinaryPredicate>\n-        void\n-        unique(_BinaryPredicate);\n+\tvoid\n+\tunique(_BinaryPredicate);\n \n       /**\n        *  @brief  Merge sorted lists.\n@@ -1662,17 +1666,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        */\n #if __cplusplus >= 201103L\n       template<typename _StrictWeakOrdering>\n-        void\n-        merge(list&& __x, _StrictWeakOrdering __comp);\n+\tvoid\n+\tmerge(list&& __x, _StrictWeakOrdering __comp);\n \n       template<typename _StrictWeakOrdering>\n-        void\n-        merge(list& __x, _StrictWeakOrdering __comp)\n-        { merge(std::move(__x), __comp); }\n+\tvoid\n+\tmerge(list& __x, _StrictWeakOrdering __comp)\n+\t{ merge(std::move(__x), __comp); }\n #else\n       template<typename _StrictWeakOrdering>\n-        void\n-        merge(list& __x, _StrictWeakOrdering __comp);\n+\tvoid\n+\tmerge(list& __x, _StrictWeakOrdering __comp);\n #endif\n \n       /**\n@@ -1700,8 +1704,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        *  elements remain in list order.\n        */\n       template<typename _StrictWeakOrdering>\n-        void\n-        sort(_StrictWeakOrdering);\n+\tvoid\n+\tsort(_StrictWeakOrdering);\n \n     protected:\n       // Internal constructor functions follow.\n@@ -1711,16 +1715,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n-        void\n-        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n-        { _M_fill_initialize(static_cast<size_type>(__n), __x); }\n+\tvoid\n+\t_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+\t{ _M_fill_initialize(static_cast<size_type>(__n), __x); }\n \n       // Called by the range constructor to implement [23.1.1]/9\n       template<typename _InputIterator>\n-        void\n-        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+\tvoid\n+\t_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t       __false_type)\n-        {\n+\t{\n \t  for (; __first != __last; ++__first)\n #if __cplusplus >= 201103L\n \t    emplace_back(*__first);\n@@ -1759,14 +1763,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n-        void\n-        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-        { _M_fill_assign(__n, __val); }\n+\tvoid\n+\t_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+\t{ _M_fill_assign(__n, __val); }\n \n       // Called by the range assign to implement [23.1.1]/9\n       template<typename _InputIterator>\n-        void\n-        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+\tvoid\n+\t_M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t   __false_type);\n \n       // Called by assign(n,t), and the range assign when it turns out\n@@ -1785,8 +1789,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       void\n       _M_insert(iterator __position, const value_type& __x)\n       {\n-        _Node* __tmp = _M_create_node(__x);\n-        __tmp->_M_hook(__position._M_node);\n+\t_Node* __tmp = _M_create_node(__x);\n+\t__tmp->_M_hook(__position._M_node);\n \tthis->_M_inc_size(1);\n       }\n #else\n@@ -1805,15 +1809,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       _M_erase(iterator __position) _GLIBCXX_NOEXCEPT\n       {\n \tthis->_M_dec_size(1);\n-        __position._M_node->_M_unhook();\n-        _Node* __n = static_cast<_Node*>(__position._M_node);\n+\t__position._M_node->_M_unhook();\n+\t_Node* __n = static_cast<_Node*>(__position._M_node);\n #if __cplusplus >= 201103L\n \t_Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr());\n #else\n \t_Tp_alloc_type(_M_get_Node_allocator()).destroy(__n->_M_valptr());\n #endif\n \n-        _M_put_node(__n);\n+\t_M_put_node(__n);\n       }\n \n       // To implement the splice (and merge) bits of N1599.\n@@ -1845,16 +1849,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t    this->_M_set_size(__x._M_get_size());\n \t    __x._M_init();\n \t  }\n-        std::__alloc_on_move(this->_M_get_Node_allocator(),\n-                             __x._M_get_Node_allocator());\n+\tstd::__alloc_on_move(this->_M_get_Node_allocator(),\n+\t\t\t     __x._M_get_Node_allocator());\n       }\n \n       void\n       _M_move_assign(list&& __x, false_type)\n       {\n \tif (__x._M_get_Node_allocator() == this->_M_get_Node_allocator())\n-          _M_move_assign(std::move(__x), true_type{});\n-        else\n+\t  _M_move_assign(std::move(__x), true_type{});\n+\telse\n \t  // The rvalue's allocator cannot be moved, or is not equal,\n \t  // so we need to individually move each element.\n \t  _M_assign_dispatch(std::__make_move_if_noexcept_iterator(__x.begin()),"}, {"sha": "30339536f57b6b0f8ae0046090d12940c07f6762", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 182, "deletions": 178, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -79,7 +79,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  @tparam _Key  Type of key objects.\n    *  @tparam  _Tp  Type of mapped objects.\n    *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.\n-   *  @tparam _Alloc  Allocator type, defaults to \n+   *  @tparam _Alloc  Allocator type, defaults to\n    *                  allocator<pair<const _Key, _Tp>.\n    *\n    *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n@@ -95,23 +95,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  called (*_unique versus *_equal, same as the standard).\n   */\n   template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n-            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n+\t    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >\n     class map\n     {\n     public:\n-      typedef _Key                                          key_type;\n-      typedef _Tp                                           mapped_type;\n-      typedef std::pair<const _Key, _Tp>                    value_type;\n-      typedef _Compare                                      key_compare;\n-      typedef _Alloc                                        allocator_type;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Tp\t\t\t\t\tmapped_type;\n+      typedef std::pair<const _Key, _Tp>\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef _Alloc\t\t\t\t\tallocator_type;\n \n     private:\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n-      typedef typename _Alloc::value_type                   _Alloc_value_type;\n+      typedef typename _Alloc::value_type\t\t_Alloc_value_type;\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+# endif\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n       __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)\n+#endif\n \n     public:\n       class value_compare\n@@ -130,7 +134,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       };\n \n     private:\n-      /// This turns a red-black tree into a [multi]map. \n+      /// This turns a red-black tree into a [multi]map.\n       typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n \trebind<value_type>::other _Pair_alloc_type;\n \n@@ -145,15 +149,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     public:\n       // many of these are specified differently in ISO, but the following are\n       // \"functionally equivalent\"\n-      typedef typename _Alloc_traits::pointer            pointer;\n-      typedef typename _Alloc_traits::const_pointer      const_pointer;\n-      typedef typename _Alloc_traits::reference          reference;\n-      typedef typename _Alloc_traits::const_reference    const_reference;\n-      typedef typename _Rep_type::iterator               iterator;\n-      typedef typename _Rep_type::const_iterator         const_iterator;\n-      typedef typename _Rep_type::size_type              size_type;\n-      typedef typename _Rep_type::difference_type        difference_type;\n-      typedef typename _Rep_type::reverse_iterator       reverse_iterator;\n+      typedef typename _Alloc_traits::pointer\t\t pointer;\n+      typedef typename _Alloc_traits::const_pointer\t const_pointer;\n+      typedef typename _Alloc_traits::reference\t\t reference;\n+      typedef typename _Alloc_traits::const_reference\t const_reference;\n+      typedef typename _Rep_type::iterator\t\t iterator;\n+      typedef typename _Rep_type::const_iterator\t const_iterator;\n+      typedef typename _Rep_type::size_type\t\t size_type;\n+      typedef typename _Rep_type::difference_type\t difference_type;\n+      typedef typename _Rep_type::reverse_iterator\t reverse_iterator;\n       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n \n #if __cplusplus > 201402L\n@@ -241,10 +245,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /// Allocator-extended range constructor.\n       template<typename _InputIterator>\n-        map(_InputIterator __first, _InputIterator __last,\n+\tmap(_InputIterator __first, _InputIterator __last,\n \t    const allocator_type& __a)\n \t: _M_t(_Compare(), _Pair_alloc_type(__a))\n-        { _M_t._M_insert_unique(__first, __last); }\n+\t{ _M_t._M_insert_unique(__first, __last); }\n #endif\n \n       /**\n@@ -258,9 +262,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  distance(__first,__last)).\n        */\n       template<typename _InputIterator>\n-        map(_InputIterator __first, _InputIterator __last)\n+\tmap(_InputIterator __first, _InputIterator __last)\n \t: _M_t()\n-        { _M_t._M_insert_unique(__first, __last); }\n+\t{ _M_t._M_insert_unique(__first, __last); }\n \n       /**\n        *  @brief  Builds a %map from a range.\n@@ -275,11 +279,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  distance(__first,__last)).\n        */\n       template<typename _InputIterator>\n-        map(_InputIterator __first, _InputIterator __last,\n+\tmap(_InputIterator __first, _InputIterator __last,\n \t    const _Compare& __comp,\n \t    const allocator_type& __a = allocator_type())\n \t: _M_t(__comp, _Pair_alloc_type(__a))\n-        { _M_t._M_insert_unique(__first, __last); }\n+\t{ _M_t._M_insert_unique(__first, __last); }\n \n #if __cplusplus >= 201103L\n       /**\n@@ -490,7 +494,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t\t\t    std::tuple<const key_type&>(__k),\n \t\t\t\t\t    std::tuple<>());\n #else\n-          __i = insert(__i, value_type(__k, mapped_type()));\n+\t  __i = insert(__i, value_type(__k, mapped_type()));\n #endif\n \treturn (*__i).second;\n       }\n@@ -659,7 +663,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *\n        *  @param __k    Key to use for finding a possibly existing pair in\n        *                the map.\n-       *  @param __args  Arguments used to generate the .second for a new pair \n+       *  @param __args  Arguments used to generate the .second for a new pair\n        *                instance.\n        *\n        *  @return  A pair, of which the first element is an iterator that points\n@@ -675,37 +679,37 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Insertion requires logarithmic time.\n        */\n       template <typename... _Args>\n-        pair<iterator, bool>\n-        try_emplace(const key_type& __k, _Args&&... __args)\n-        {\n-          iterator __i = lower_bound(__k);\n-          if (__i == end() || key_comp()(__k, (*__i).first))\n-            {\n-              __i = emplace_hint(__i, std::piecewise_construct,\n-                                 std::forward_as_tuple(__k),\n-                                 std::forward_as_tuple(\n-                                   std::forward<_Args>(__args)...));\n-              return {__i, true};\n-            }\n-          return {__i, false};\n-        }\n+\tpair<iterator, bool>\n+\ttry_emplace(const key_type& __k, _Args&&... __args)\n+\t{\n+\t  iterator __i = lower_bound(__k);\n+\t  if (__i == end() || key_comp()(__k, (*__i).first))\n+\t    {\n+\t      __i = emplace_hint(__i, std::piecewise_construct,\n+\t\t\t\t std::forward_as_tuple(__k),\n+\t\t\t\t std::forward_as_tuple(\n+\t\t\t\t   std::forward<_Args>(__args)...));\n+\t      return {__i, true};\n+\t    }\n+\t  return {__i, false};\n+\t}\n \n       // move-capable overload\n       template <typename... _Args>\n-        pair<iterator, bool>\n-        try_emplace(key_type&& __k, _Args&&... __args)\n-        {\n-          iterator __i = lower_bound(__k);\n-          if (__i == end() || key_comp()(__k, (*__i).first))\n-            {\n-              __i = emplace_hint(__i, std::piecewise_construct,\n-                                 std::forward_as_tuple(std::move(__k)),\n-                                 std::forward_as_tuple(\n-                                   std::forward<_Args>(__args)...));\n-              return {__i, true};\n-            }\n-          return {__i, false};\n-        }\n+\tpair<iterator, bool>\n+\ttry_emplace(key_type&& __k, _Args&&... __args)\n+\t{\n+\t  iterator __i = lower_bound(__k);\n+\t  if (__i == end() || key_comp()(__k, (*__i).first))\n+\t    {\n+\t      __i = emplace_hint(__i, std::piecewise_construct,\n+\t\t\t\t std::forward_as_tuple(std::move(__k)),\n+\t\t\t\t std::forward_as_tuple(\n+\t\t\t\t   std::forward<_Args>(__args)...));\n+\t      return {__i, true};\n+\t    }\n+\t  return {__i, false};\n+\t}\n \n       /**\n        *  @brief Attempts to build and insert a std::pair into the %map.\n@@ -714,14 +718,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *                  pair should be inserted.\n        *  @param __k    Key to use for finding a possibly existing pair in\n        *                the map.\n-       *  @param __args  Arguments used to generate the .second for a new pair \n+       *  @param __args  Arguments used to generate the .second for a new pair\n        *                instance.\n        *  @return An iterator that points to the element with key of the\n        *          std::pair built from @a __args (may or may not be that\n        *          std::pair).\n        *\n        *  This function is not concerned about whether the insertion took place,\n-       *  and thus does not return a boolean like the single-argument \n+       *  and thus does not return a boolean like the single-argument\n        *  try_emplace() does. However, if insertion did not take place,\n        *  this function has no effect.\n        *  Note that the first parameter is only a hint and can potentially\n@@ -735,40 +739,40 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Insertion requires logarithmic time (if the hint is not taken).\n        */\n       template <typename... _Args>\n-        iterator\n-        try_emplace(const_iterator __hint, const key_type& __k,\n-                    _Args&&... __args)\n-        {\n-          iterator __i;\n-          auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n-          if (__true_hint.second)\n-            __i = emplace_hint(iterator(__true_hint.second),\n-                               std::piecewise_construct,\n-                               std::forward_as_tuple(__k),\n-                               std::forward_as_tuple(\n-                                 std::forward<_Args>(__args)...));\n-          else\n-            __i = iterator(__true_hint.first);\n-          return __i;\n-        }\n+\titerator\n+\ttry_emplace(const_iterator __hint, const key_type& __k,\n+\t\t    _Args&&... __args)\n+\t{\n+\t  iterator __i;\n+\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n+\t  if (__true_hint.second)\n+\t    __i = emplace_hint(iterator(__true_hint.second),\n+\t\t\t       std::piecewise_construct,\n+\t\t\t       std::forward_as_tuple(__k),\n+\t\t\t       std::forward_as_tuple(\n+\t\t\t\t std::forward<_Args>(__args)...));\n+\t  else\n+\t    __i = iterator(__true_hint.first);\n+\t  return __i;\n+\t}\n \n       // move-capable overload\n       template <typename... _Args>\n-        iterator\n-        try_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n-        {\n-          iterator __i;\n-          auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n-          if (__true_hint.second)\n-            __i = emplace_hint(iterator(__true_hint.second),\n-                               std::piecewise_construct,\n-                               std::forward_as_tuple(std::move(__k)),\n-                               std::forward_as_tuple(\n-                                 std::forward<_Args>(__args)...));\n-          else\n-            __i = iterator(__true_hint.first);\n-          return __i;\n-        }\n+\titerator\n+\ttry_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)\n+\t{\n+\t  iterator __i;\n+\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n+\t  if (__true_hint.second)\n+\t    __i = emplace_hint(iterator(__true_hint.second),\n+\t\t\t       std::piecewise_construct,\n+\t\t\t       std::forward_as_tuple(std::move(__k)),\n+\t\t\t       std::forward_as_tuple(\n+\t\t\t\t std::forward<_Args>(__args)...));\n+\t  else\n+\t    __i = iterator(__true_hint.first);\n+\t  return __i;\n+\t}\n #endif\n \n       /**\n@@ -777,8 +781,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @param __x Pair to be inserted (see std::make_pair for easy\n        *\t     creation of pairs).\n        *\n-       *  @return  A pair, of which the first element is an iterator that \n-       *           points to the possibly inserted pair, and the second is \n+       *  @return  A pair, of which the first element is an iterator that\n+       *           points to the possibly inserted pair, and the second is\n        *           a bool that is true if the pair was actually inserted.\n        *\n        *  This function attempts to insert a (key, value) %pair into the %map.\n@@ -795,9 +799,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        std::pair<iterator, bool>\n-        insert(_Pair&& __x)\n-        { return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }\n+\tstd::pair<iterator, bool>\n+\tinsert(_Pair&& __x)\n+\t{ return _M_t._M_insert_unique(std::forward<_Pair>(__x)); }\n #endif\n \n #if __cplusplus >= 201103L\n@@ -848,9 +852,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(const_iterator __position, _Pair&& __x)\n-        { return _M_t._M_insert_unique_(__position,\n+\titerator\n+\tinsert(const_iterator __position, _Pair&& __x)\n+\t{ return _M_t._M_insert_unique_(__position,\n \t\t\t\t\tstd::forward<_Pair>(__x)); }\n #endif\n \n@@ -863,21 +867,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Complexity similar to that of the range constructor.\n        */\n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        { _M_t._M_insert_unique(__first, __last); }\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{ _M_t._M_insert_unique(__first, __last); }\n \n #if __cplusplus > 201402L\n #define __cpp_lib_map_insertion 201411\n       /**\n        *  @brief Attempts to insert or assign a std::pair into the %map.\n        *  @param __k    Key to use for finding a possibly existing pair in\n        *                the map.\n-       *  @param __obj  Argument used to generate the .second for a pair \n+       *  @param __obj  Argument used to generate the .second for a pair\n        *                instance.\n        *\n-       *  @return  A pair, of which the first element is an iterator that \n-       *           points to the possibly inserted pair, and the second is \n+       *  @return  A pair, of which the first element is an iterator that\n+       *           points to the possibly inserted pair, and the second is\n        *           a bool that is true if the pair was actually inserted.\n        *\n        *  This function attempts to insert a (key, value) %pair into the %map.\n@@ -889,47 +893,47 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Insertion requires logarithmic time.\n        */\n       template <typename _Obj>\n-        pair<iterator, bool>\n-        insert_or_assign(const key_type& __k, _Obj&& __obj)\n-        {\n-          iterator __i = lower_bound(__k);\n-          if (__i == end() || key_comp()(__k, (*__i).first))\n-            {\n-              __i = emplace_hint(__i, std::piecewise_construct,\n-                                 std::forward_as_tuple(__k),\n-                                 std::forward_as_tuple(\n-                                   std::forward<_Obj>(__obj)));\n-              return {__i, true};\n-            }\n-          (*__i).second = std::forward<_Obj>(__obj);\n-          return {__i, false};\n-        }\n+\tpair<iterator, bool>\n+\tinsert_or_assign(const key_type& __k, _Obj&& __obj)\n+\t{\n+\t  iterator __i = lower_bound(__k);\n+\t  if (__i == end() || key_comp()(__k, (*__i).first))\n+\t    {\n+\t      __i = emplace_hint(__i, std::piecewise_construct,\n+\t\t\t\t std::forward_as_tuple(__k),\n+\t\t\t\t std::forward_as_tuple(\n+\t\t\t\t   std::forward<_Obj>(__obj)));\n+\t      return {__i, true};\n+\t    }\n+\t  (*__i).second = std::forward<_Obj>(__obj);\n+\t  return {__i, false};\n+\t}\n \n       // move-capable overload\n       template <typename _Obj>\n-        pair<iterator, bool>\n-        insert_or_assign(key_type&& __k, _Obj&& __obj)\n-        {\n-          iterator __i = lower_bound(__k);\n-          if (__i == end() || key_comp()(__k, (*__i).first))\n-            {\n-              __i = emplace_hint(__i, std::piecewise_construct,\n-                                 std::forward_as_tuple(std::move(__k)),\n-                                 std::forward_as_tuple(\n-                                   std::forward<_Obj>(__obj)));\n-              return {__i, true};\n-            }\n-          (*__i).second = std::forward<_Obj>(__obj);\n-          return {__i, false};\n-        }\n+\tpair<iterator, bool>\n+\tinsert_or_assign(key_type&& __k, _Obj&& __obj)\n+\t{\n+\t  iterator __i = lower_bound(__k);\n+\t  if (__i == end() || key_comp()(__k, (*__i).first))\n+\t    {\n+\t      __i = emplace_hint(__i, std::piecewise_construct,\n+\t\t\t\t std::forward_as_tuple(std::move(__k)),\n+\t\t\t\t std::forward_as_tuple(\n+\t\t\t\t   std::forward<_Obj>(__obj)));\n+\t      return {__i, true};\n+\t    }\n+\t  (*__i).second = std::forward<_Obj>(__obj);\n+\t  return {__i, false};\n+\t}\n \n       /**\n        *  @brief Attempts to insert or assign a std::pair into the %map.\n        *  @param  __hint  An iterator that serves as a hint as to where the\n        *                  pair should be inserted.\n        *  @param __k    Key to use for finding a possibly existing pair in\n        *                the map.\n-       *  @param __obj  Argument used to generate the .second for a pair \n+       *  @param __obj  Argument used to generate the .second for a pair\n        *                instance.\n        *\n        *  @return An iterator that points to the element with key of\n@@ -944,44 +948,44 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Insertion requires logarithmic time.\n        */\n       template <typename _Obj>\n-        iterator\n-        insert_or_assign(const_iterator __hint,\n-                         const key_type& __k, _Obj&& __obj)\n-        {\n-          iterator __i;\n-          auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n-          if (__true_hint.second)\n-            {\n-              return emplace_hint(iterator(__true_hint.second),\n-                                  std::piecewise_construct,\n-                                  std::forward_as_tuple(__k),\n-                                  std::forward_as_tuple(\n-                                    std::forward<_Obj>(__obj)));\n-            }\n-          __i = iterator(__true_hint.first);\n-          (*__i).second = std::forward<_Obj>(__obj);\n-          return __i;\n-        }\n+\titerator\n+\tinsert_or_assign(const_iterator __hint,\n+\t\t\t const key_type& __k, _Obj&& __obj)\n+\t{\n+\t  iterator __i;\n+\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n+\t  if (__true_hint.second)\n+\t    {\n+\t      return emplace_hint(iterator(__true_hint.second),\n+\t\t\t\t  std::piecewise_construct,\n+\t\t\t\t  std::forward_as_tuple(__k),\n+\t\t\t\t  std::forward_as_tuple(\n+\t\t\t\t    std::forward<_Obj>(__obj)));\n+\t    }\n+\t  __i = iterator(__true_hint.first);\n+\t  (*__i).second = std::forward<_Obj>(__obj);\n+\t  return __i;\n+\t}\n \n       // move-capable overload\n       template <typename _Obj>\n-        iterator\n-        insert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n-        {\n-          iterator __i;\n-          auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n-          if (__true_hint.second)\n-            {\n-              return emplace_hint(iterator(__true_hint.second),\n-                                  std::piecewise_construct,\n-                                  std::forward_as_tuple(std::move(__k)),\n-                                  std::forward_as_tuple(\n-                                    std::forward<_Obj>(__obj)));\n-            }\n-          __i = iterator(__true_hint.first);\n-          (*__i).second = std::forward<_Obj>(__obj);\n-          return __i;\n-        }\n+\titerator\n+\tinsert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)\n+\t{\n+\t  iterator __i;\n+\t  auto __true_hint = _M_t._M_get_insert_hint_unique_pos(__hint, __k);\n+\t  if (__true_hint.second)\n+\t    {\n+\t      return emplace_hint(iterator(__true_hint.second),\n+\t\t\t\t  std::piecewise_construct,\n+\t\t\t\t  std::forward_as_tuple(std::move(__k)),\n+\t\t\t\t  std::forward_as_tuple(\n+\t\t\t\t    std::forward<_Obj>(__obj)));\n+\t    }\n+\t  __i = iterator(__true_hint.first);\n+\t  (*__i).second = std::forward<_Obj>(__obj);\n+\t  return __i;\n+\t}\n #endif\n \n #if __cplusplus >= 201103L\n@@ -991,7 +995,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @brief Erases an element from a %map.\n        *  @param  __position  An iterator pointing to the element to be erased.\n        *  @return An iterator pointing to the element immediately following\n-       *          @a position prior to the element being erased. If no such \n+       *          @a position prior to the element being erased. If no such\n        *          element exists, end() is returned.\n        *\n        *  This function erases an element, pointed to by the given\n@@ -1351,13 +1355,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       //@}\n \n       template<typename _K1, typename _T1, typename _C1, typename _A1>\n-        friend bool\n-        operator==(const map<_K1, _T1, _C1, _A1>&,\n+\tfriend bool\n+\toperator==(const map<_K1, _T1, _C1, _A1>&,\n \t\t   const map<_K1, _T1, _C1, _A1>&);\n \n       template<typename _K1, typename _T1, typename _C1, typename _A1>\n-        friend bool\n-        operator<(const map<_K1, _T1, _C1, _A1>&,\n+\tfriend bool\n+\toperator<(const map<_K1, _T1, _C1, _A1>&,\n \t\t  const map<_K1, _T1, _C1, _A1>&);\n     };\n \n@@ -1374,7 +1378,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n-               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n   /**\n@@ -1391,35 +1395,35 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n-              const map<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t      const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   /// Based on operator==\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n-               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   /// Based on operator<\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n-              const map<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t      const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   /// Based on operator<\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n-               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   /// Based on operator<\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,\n-               const map<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t       const map<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::map::swap()."}, {"sha": "7dc22a96a595c046771e5780e7b236b4b70a55c1", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -77,7 +77,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  @tparam _Key  Type of key objects.\n    *  @tparam  _Tp  Type of mapped objects.\n    *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.\n-   *  @tparam _Alloc  Allocator type, defaults to \n+   *  @tparam _Alloc  Allocator type, defaults to\n    *                  allocator<pair<const _Key, _Tp>.\n    *\n    *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n@@ -98,19 +98,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     class multimap\n     {\n     public:\n-      typedef _Key                                          key_type;\n-      typedef _Tp                                           mapped_type;\n-      typedef std::pair<const _Key, _Tp>                    value_type;\n-      typedef _Compare                                      key_compare;\n-      typedef _Alloc                                        allocator_type;\n+      typedef _Key\t\t\t\t\tkey_type;\n+      typedef _Tp\t\t\t\t\tmapped_type;\n+      typedef std::pair<const _Key, _Tp>\t\tvalue_type;\n+      typedef _Compare\t\t\t\t\tkey_compare;\n+      typedef _Alloc\t\t\t\t\tallocator_type;\n \n     private:\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n-      typedef typename _Alloc::value_type                   _Alloc_value_type;\n+      typedef typename _Alloc::value_type\t\t_Alloc_value_type;\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+# endif\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n       __glibcxx_class_requires2(value_type, _Alloc_value_type, _SameTypeConcept)\n+#endif\n \n     public:\n       class value_compare\n@@ -143,15 +147,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     public:\n       // many of these are specified differently in ISO, but the following are\n       // \"functionally equivalent\"\n-      typedef typename _Alloc_traits::pointer            pointer;\n-      typedef typename _Alloc_traits::const_pointer      const_pointer;\n-      typedef typename _Alloc_traits::reference          reference;\n-      typedef typename _Alloc_traits::const_reference    const_reference;\n-      typedef typename _Rep_type::iterator               iterator;\n-      typedef typename _Rep_type::const_iterator         const_iterator;\n-      typedef typename _Rep_type::size_type              size_type;\n-      typedef typename _Rep_type::difference_type        difference_type;\n-      typedef typename _Rep_type::reverse_iterator       reverse_iterator;\n+      typedef typename _Alloc_traits::pointer\t\t pointer;\n+      typedef typename _Alloc_traits::const_pointer\t const_pointer;\n+      typedef typename _Alloc_traits::reference\t\t reference;\n+      typedef typename _Alloc_traits::const_reference\t const_reference;\n+      typedef typename _Rep_type::iterator\t\t iterator;\n+      typedef typename _Rep_type::const_iterator\t const_iterator;\n+      typedef typename _Rep_type::size_type\t\t size_type;\n+      typedef typename _Rep_type::difference_type\t difference_type;\n+      typedef typename _Rep_type::reverse_iterator\t reverse_iterator;\n       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n \n #if __cplusplus > 201402L\n@@ -238,10 +242,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /// Allocator-extended range constructor.\n       template<typename _InputIterator>\n-        multimap(_InputIterator __first, _InputIterator __last,\n+\tmultimap(_InputIterator __first, _InputIterator __last,\n \t\t const allocator_type& __a)\n \t: _M_t(_Compare(), _Pair_alloc_type(__a))\n-        { _M_t._M_insert_equal(__first, __last); }\n+\t{ _M_t._M_insert_equal(__first, __last); }\n #endif\n \n       /**\n@@ -254,9 +258,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  and NlogN otherwise (where N is distance(__first,__last)).\n        */\n       template<typename _InputIterator>\n-        multimap(_InputIterator __first, _InputIterator __last)\n+\tmultimap(_InputIterator __first, _InputIterator __last)\n \t: _M_t()\n-        { _M_t._M_insert_equal(__first, __last); }\n+\t{ _M_t._M_insert_equal(__first, __last); }\n \n       /**\n        *  @brief  Builds a %multimap from a range.\n@@ -270,11 +274,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  and NlogN otherwise (where N is distance(__first,__last)).\n        */\n       template<typename _InputIterator>\n-        multimap(_InputIterator __first, _InputIterator __last,\n+\tmultimap(_InputIterator __first, _InputIterator __last,\n \t\t const _Compare& __comp,\n \t\t const allocator_type& __a = allocator_type())\n \t: _M_t(__comp, _Pair_alloc_type(__a))\n-        { _M_t._M_insert_equal(__first, __last); }\n+\t{ _M_t._M_insert_equal(__first, __last); }\n \n #if __cplusplus >= 201103L\n       /**\n@@ -326,7 +330,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /// Get a copy of the memory allocation object.\n       allocator_type\n-      get_allocator() const _GLIBCXX_NOEXCEPT \n+      get_allocator() const _GLIBCXX_NOEXCEPT\n       { return allocator_type(_M_t.get_allocator()); }\n \n       // iterators\n@@ -530,9 +534,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(_Pair&& __x)\n-        { return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }\n+\titerator\n+\tinsert(_Pair&& __x)\n+\t{ return _M_t._M_insert_equal(std::forward<_Pair>(__x)); }\n #endif\n \n       /**\n@@ -567,9 +571,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _Pair, typename = typename\n \t       std::enable_if<std::is_constructible<value_type,\n \t\t\t\t\t\t    _Pair&&>::value>::type>\n-        iterator\n-        insert(const_iterator __position, _Pair&& __x)\n-        { return _M_t._M_insert_equal_(__position,\n+\titerator\n+\tinsert(const_iterator __position, _Pair&& __x)\n+\t{ return _M_t._M_insert_equal_(__position,\n \t\t\t\t       std::forward<_Pair>(__x)); }\n #endif\n \n@@ -583,9 +587,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Complexity similar to that of the range constructor.\n        */\n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        { _M_t._M_insert_equal(__first, __last); }\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{ _M_t._M_insert_equal(__first, __last); }\n \n #if __cplusplus >= 201103L\n       /**\n@@ -661,7 +665,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @brief Erases an element from a %multimap.\n        *  @param  __position  An iterator pointing to the element to be erased.\n        *  @return An iterator pointing to the element immediately following\n-       *          @a position prior to the element being erased. If no such \n+       *          @a position prior to the element being erased. If no such\n        *          element exists, end() is returned.\n        *\n        *  This function erases an element, pointed to by the given iterator,\n@@ -1016,13 +1020,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       //@}\n \n       template<typename _K1, typename _T1, typename _C1, typename _A1>\n-        friend bool\n-        operator==(const multimap<_K1, _T1, _C1, _A1>&,\n+\tfriend bool\n+\toperator==(const multimap<_K1, _T1, _C1, _A1>&,\n \t\t   const multimap<_K1, _T1, _C1, _A1>&);\n \n       template<typename _K1, typename _T1, typename _C1, typename _A1>\n-        friend bool\n-        operator<(const multimap<_K1, _T1, _C1, _A1>&,\n+\tfriend bool\n+\toperator<(const multimap<_K1, _T1, _C1, _A1>&,\n \t\t  const multimap<_K1, _T1, _C1, _A1>&);\n   };\n \n@@ -1039,7 +1043,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n-               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t == __y._M_t; }\n \n   /**\n@@ -1056,42 +1060,42 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n-              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t      const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __x._M_t < __y._M_t; }\n \n   /// Based on operator==\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n-               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   /// Based on operator<\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n-              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t      const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   /// Based on operator<\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n-               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   /// Based on operator<\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline bool\n     operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n-               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t       const multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::multimap::swap().\n   template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>\n     inline void\n     swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n-         multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n+\t multimap<_Key, _Tp, _Compare, _Alloc>& __y)\n     _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))\n     { __x.swap(__y); }\n "}, {"sha": "60a3db844cb36405dd518fc9571727b66da7b46d", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -94,12 +94,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    typename _Alloc = std::allocator<_Key> >\n     class multiset\n     {\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n-      typedef typename _Alloc::value_type                   _Alloc_value_type;\n+      typedef typename _Alloc::value_type\t\t_Alloc_value_type;\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n+# endif\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n-      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)\t\n+      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)\n+#endif\n \n     public:\n       // typedefs:\n@@ -122,19 +126,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;\n \n     public:\n-      typedef typename _Alloc_traits::pointer\t\t    pointer;\n-      typedef typename _Alloc_traits::const_pointer\t    const_pointer;\n-      typedef typename _Alloc_traits::reference\t\t    reference;\n-      typedef typename _Alloc_traits::const_reference\t    const_reference;\n+      typedef typename _Alloc_traits::pointer\t\t pointer;\n+      typedef typename _Alloc_traits::const_pointer\t const_pointer;\n+      typedef typename _Alloc_traits::reference\t\t reference;\n+      typedef typename _Alloc_traits::const_reference\t const_reference;\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 103. set::iterator is required to be modifiable,\n       // but this allows modification of keys.\n-      typedef typename _Rep_type::const_iterator            iterator;\n-      typedef typename _Rep_type::const_iterator            const_iterator;\n-      typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;\n+      typedef typename _Rep_type::const_iterator\t iterator;\n+      typedef typename _Rep_type::const_iterator\t const_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-      typedef typename _Rep_type::size_type                 size_type;\n-      typedef typename _Rep_type::difference_type           difference_type;\n+      typedef typename _Rep_type::size_type\t\t size_type;\n+      typedef typename _Rep_type::difference_type\t difference_type;\n \n #if __cplusplus > 201402L\n       using node_type = typename _Rep_type::node_type;\n@@ -170,9 +174,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  and NlogN otherwise (where N is distance(__first,__last)).\n        */\n       template<typename _InputIterator>\n-        multiset(_InputIterator __first, _InputIterator __last)\n+\tmultiset(_InputIterator __first, _InputIterator __last)\n \t: _M_t()\n-        { _M_t._M_insert_equal(__first, __last); }\n+\t{ _M_t._M_insert_equal(__first, __last); }\n \n       /**\n        *  @brief  Builds a %multiset from a range.\n@@ -186,11 +190,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  and NlogN otherwise (where N is distance(__first,__last)).\n        */\n       template<typename _InputIterator>\n-        multiset(_InputIterator __first, _InputIterator __last,\n+\tmultiset(_InputIterator __first, _InputIterator __last,\n \t\t const _Compare& __comp,\n \t\t const allocator_type& __a = allocator_type())\n \t: _M_t(__comp, _Key_alloc_type(__a))\n-        { _M_t._M_insert_equal(__first, __last); }\n+\t{ _M_t._M_insert_equal(__first, __last); }\n \n       /**\n        *  @brief  %Multiset copy constructor.\n@@ -250,10 +254,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /// Allocator-extended range constructor.\n       template<typename _InputIterator>\n-        multiset(_InputIterator __first, _InputIterator __last,\n+\tmultiset(_InputIterator __first, _InputIterator __last,\n \t\t const allocator_type& __a)\n \t: _M_t(_Compare(), _Key_alloc_type(__a))\n-        { _M_t._M_insert_equal(__first, __last); }\n+\t{ _M_t._M_insert_equal(__first, __last); }\n \n       /**\n        *  The dtor only erases the elements, and note that if the elements\n@@ -533,9 +537,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  Complexity similar to that of the range constructor.\n        */\n       template<typename _InputIterator>\n-        void\n-        insert(_InputIterator __first, _InputIterator __last)\n-        { _M_t._M_insert_equal(__first, __last); }\n+\tvoid\n+\tinsert(_InputIterator __first, _InputIterator __last)\n+\t{ _M_t._M_insert_equal(__first, __last); }\n \n #if __cplusplus >= 201103L\n       /**\n@@ -611,7 +615,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @brief Erases an element from a %multiset.\n        *  @param  __position  An iterator pointing to the element to be erased.\n        *  @return An iterator pointing to the element immediately following\n-       *          @a position prior to the element being erased. If no such \n+       *          @a position prior to the element being erased. If no such\n        *          element exists, end() is returned.\n        *\n        *  This function erases an element, pointed to by the given iterator,\n@@ -866,13 +870,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       //@}\n \n       template<typename _K1, typename _C1, typename _A1>\n-        friend bool\n-        operator==(const multiset<_K1, _C1, _A1>&,\n+\tfriend bool\n+\toperator==(const multiset<_K1, _C1, _A1>&,\n \t\t   const multiset<_K1, _C1, _A1>&);\n \n       template<typename _K1, typename _C1, typename _A1>\n-        friend bool\n-        operator< (const multiset<_K1, _C1, _A1>&,\n+\tfriend bool\n+\toperator< (const multiset<_K1, _C1, _A1>&,\n \t\t   const multiset<_K1, _C1, _A1>&);\n     };\n "}, {"sha": "c49f371fbc8d288e429000de951b45b8c5d5bc84", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -95,20 +95,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Sequence = deque<_Tp> >\n     class queue\n     {\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n       typedef typename _Sequence::value_type _Sequence_value_type;\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+# endif\n       __glibcxx_class_requires(_Sequence, _FrontInsertionSequenceConcept)\n       __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n       __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n+#endif\n \n       template<typename _Tp1, typename _Seq1>\n-        friend bool\n-        operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);\n+\tfriend bool\n+\toperator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);\n \n       template<typename _Tp1, typename _Seq1>\n-        friend bool\n-        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);\n+\tfriend bool\n+\toperator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);\n \n #if __cplusplus >= 201103L\n       template<typename _Alloc>\n@@ -117,11 +121,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n     public:\n-      typedef typename _Sequence::value_type                value_type;\n-      typedef typename _Sequence::reference                 reference;\n-      typedef typename _Sequence::const_reference           const_reference;\n-      typedef typename _Sequence::size_type                 size_type;\n-      typedef          _Sequence                            container_type;\n+      typedef typename\t_Sequence::value_type\t\tvalue_type;\n+      typedef typename\t_Sequence::reference\t\treference;\n+      typedef typename\t_Sequence::const_reference\tconst_reference;\n+      typedef typename\t_Sequence::size_type\t\tsize_type;\n+      typedef\t\t_Sequence\t\t\tcontainer_type;\n \n     protected:\n       /*  Maintainers wondering why this isn't uglified as per style\n@@ -259,8 +263,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ return c.emplace_back(std::forward<_Args>(__args)...); }\n #else\n       template<typename... _Args>\n-        void\n-        emplace(_Args&&... __args)\n+\tvoid\n+\templace(_Args&&... __args)\n \t{ c.emplace_back(std::forward<_Args>(__args)...); }\n #endif\n #endif\n@@ -381,12 +385,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *\n    *  @tparam _Tp  Type of element.\n    *  @tparam _Sequence  Type of underlying sequence, defaults to vector<_Tp>.\n-   *  @tparam _Compare  Comparison function object type, defaults to \n+   *  @tparam _Compare  Comparison function object type, defaults to\n    *                    less<_Sequence::value_type>.\n    *\n    *  This is not a true container, but an @e adaptor.  It holds\n    *  another container, and provides a wrapper interface to that\n-   *  container.  The wrapper is what enforces priority-based sorting \n+   *  container.  The wrapper is what enforces priority-based sorting\n    *  and %queue behavior.  Very few of the standard container/sequence\n    *  interface requirements are met (e.g., iterators).\n    *\n@@ -418,14 +422,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Compare  = less<typename _Sequence::value_type> >\n     class priority_queue\n     {\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n       typedef typename _Sequence::value_type _Sequence_value_type;\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+# endif\n       __glibcxx_class_requires(_Sequence, _SequenceConcept)\n       __glibcxx_class_requires(_Sequence, _RandomAccessContainerConcept)\n       __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n       __glibcxx_class_requires4(_Compare, bool, _Tp, _Tp,\n \t\t\t\t_BinaryFunctionConcept)\n+#endif\n \n #if __cplusplus >= 201103L\n       template<typename _Alloc>\n@@ -434,11 +442,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n     public:\n-      typedef typename _Sequence::value_type                value_type;\n-      typedef typename _Sequence::reference                 reference;\n-      typedef typename _Sequence::const_reference           const_reference;\n-      typedef typename _Sequence::size_type                 size_type;\n-      typedef          _Sequence                            container_type;\n+      typedef typename\t_Sequence::value_type\t\tvalue_type;\n+      typedef typename\t_Sequence::reference\t\t reference;\n+      typedef typename\t_Sequence::const_reference\t   const_reference;\n+      typedef typename\t_Sequence::size_type\t\t size_type;\n+      typedef\t\t_Sequence\t\t\t    container_type;\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 2684. priority_queue lacking comparator typedef\n       typedef\t       _Compare\t\t\t\t    value_compare;\n@@ -461,7 +469,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #else\n       template<typename _Seq = _Sequence, typename _Requires = typename\n \t       enable_if<__and_<is_default_constructible<_Compare>,\n-                                is_default_constructible<_Seq>>::value>::type>\n+\t\t\t\tis_default_constructible<_Seq>>::value>::type>\n \tpriority_queue()\n \t: c(), comp() { }\n \n@@ -519,33 +527,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n        */\n #if __cplusplus < 201103L\n       template<typename _InputIterator>\n-        priority_queue(_InputIterator __first, _InputIterator __last,\n+\tpriority_queue(_InputIterator __first, _InputIterator __last,\n \t\t       const _Compare& __x = _Compare(),\n \t\t       const _Sequence& __s = _Sequence())\n \t: c(__s), comp(__x)\n-        {\n+\t{\n \t  __glibcxx_requires_valid_range(__first, __last);\n \t  c.insert(c.end(), __first, __last);\n \t  std::make_heap(c.begin(), c.end(), comp);\n \t}\n #else\n       template<typename _InputIterator>\n-        priority_queue(_InputIterator __first, _InputIterator __last,\n+\tpriority_queue(_InputIterator __first, _InputIterator __last,\n \t\t       const _Compare& __x,\n \t\t       const _Sequence& __s)\n \t: c(__s), comp(__x)\n-        {\n+\t{\n \t  __glibcxx_requires_valid_range(__first, __last);\n \t  c.insert(c.end(), __first, __last);\n \t  std::make_heap(c.begin(), c.end(), comp);\n \t}\n \n       template<typename _InputIterator>\n-        priority_queue(_InputIterator __first, _InputIterator __last,\n+\tpriority_queue(_InputIterator __first, _InputIterator __last,\n \t\t       const _Compare& __x = _Compare(),\n \t\t       _Sequence&& __s = _Sequence())\n \t: c(std::move(__s)), comp(__x)\n-        {\n+\t{\n \t  __glibcxx_requires_valid_range(__first, __last);\n \t  c.insert(c.end(), __first, __last);\n \t  std::make_heap(c.begin(), c.end(), comp);\n@@ -599,8 +607,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       template<typename... _Args>\n-        void\n-        emplace(_Args&&... __args)\n+\tvoid\n+\templace(_Args&&... __args)\n \t{\n \t  c.emplace_back(std::forward<_Args>(__args)...);\n \t  std::push_heap(c.begin(), c.end(), comp);\n@@ -631,12 +639,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       swap(priority_queue& __pq)\n       noexcept(__and_<\n #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n-                 __is_nothrow_swappable<_Sequence>,\n+\t\t __is_nothrow_swappable<_Sequence>,\n #else\n-                 __is_nothrow_swappable<_Tp>,\n+\t\t __is_nothrow_swappable<_Tp>,\n #endif\n-                 __is_nothrow_swappable<_Compare>\n-               >::value)\n+\t\t __is_nothrow_swappable<_Compare>\n+\t       >::value)\n       {\n \tusing std::swap;\n \tswap(c, __pq.c);\n@@ -653,7 +661,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n     // Constrained free swap overload, see p0185r1\n     typename enable_if<__and_<__is_swappable<_Sequence>,\n-                              __is_swappable<_Compare>>::value>::type\n+\t\t\t      __is_swappable<_Compare>>::value>::type\n #else\n     void\n #endif"}, {"sha": "817bc2d870f3e8a89b2739f00839d0338ea72e54", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -92,12 +92,16 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t   typename _Alloc = std::allocator<_Key> >\n     class set\n     {\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n-      typedef typename _Alloc::value_type                   _Alloc_value_type;\n+      typedef typename _Alloc::value_type\t\t_Alloc_value_type;\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n+# endif\n       __glibcxx_class_requires4(_Compare, bool, _Key, _Key,\n \t\t\t\t_BinaryFunctionConcept)\n       __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)\n+#endif\n \n     public:\n       // typedefs:\n@@ -123,19 +127,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     public:\n       //@{\n       ///  Iterator-related typedefs.\n-      typedef typename _Alloc_traits::pointer\t\t    pointer;\n-      typedef typename _Alloc_traits::const_pointer\t    const_pointer;\n-      typedef typename _Alloc_traits::reference\t\t    reference;\n-      typedef typename _Alloc_traits::const_reference\t    const_reference;\n+      typedef typename _Alloc_traits::pointer\t\t pointer;\n+      typedef typename _Alloc_traits::const_pointer\t const_pointer;\n+      typedef typename _Alloc_traits::reference\t\t reference;\n+      typedef typename _Alloc_traits::const_reference\t const_reference;\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 103. set::iterator is required to be modifiable,\n       // but this allows modification of keys.\n-      typedef typename _Rep_type::const_iterator            iterator;\n-      typedef typename _Rep_type::const_iterator            const_iterator;\n-      typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;\n+      typedef typename _Rep_type::const_iterator\t iterator;\n+      typedef typename _Rep_type::const_iterator\t const_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n       typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n-      typedef typename _Rep_type::size_type                 size_type;\n-      typedef typename _Rep_type::difference_type           difference_type;\n+      typedef typename _Rep_type::size_type\t\t size_type;\n+      typedef typename _Rep_type::difference_type\t difference_type;\n       //@}\n \n #if __cplusplus > 201402L\n@@ -195,7 +199,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    const _Compare& __comp,\n \t    const allocator_type& __a = allocator_type())\n \t: _M_t(__comp, _Key_alloc_type(__a))\n-        { _M_t._M_insert_unique(__first, __last); }\n+\t{ _M_t._M_insert_unique(__first, __last); }\n \n       /**\n        *  @brief  %Set copy constructor.\n@@ -254,10 +258,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /// Allocator-extended range constructor.\n       template<typename _InputIterator>\n-        set(_InputIterator __first, _InputIterator __last,\n+\tset(_InputIterator __first, _InputIterator __last,\n \t    const allocator_type& __a)\n \t: _M_t(_Compare(), _Key_alloc_type(__a))\n-        { _M_t._M_insert_unique(__first, __last); }\n+\t{ _M_t._M_insert_unique(__first, __last); }\n \n       /**\n        *  The dtor only erases the elements, and note that if the elements"}, {"sha": "ac59ec715cf979c2d4a4b7f2fa7fb84208239857", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -98,21 +98,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, typename _Sequence = deque<_Tp> >\n     class stack\n     {\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // concept requirements\n       typedef typename _Sequence::value_type _Sequence_value_type;\n-#if __cplusplus < 201103L\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n       __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n-#endif\n+# endif\n       __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n+#endif\n \n       template<typename _Tp1, typename _Seq1>\n-        friend bool\n-        operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n+\tfriend bool\n+\toperator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n \n       template<typename _Tp1, typename _Seq1>\n-        friend bool\n-        operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n+\tfriend bool\n+\toperator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n \n #if __cplusplus >= 201103L\n       template<typename _Alloc>\n@@ -121,11 +123,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n     public:\n-      typedef typename _Sequence::value_type                value_type;\n-      typedef typename _Sequence::reference                 reference;\n-      typedef typename _Sequence::const_reference           const_reference;\n-      typedef typename _Sequence::size_type                 size_type;\n-      typedef          _Sequence                            container_type;\n+      typedef typename _Sequence::value_type\t\tvalue_type;\n+      typedef typename _Sequence::reference\t\treference;\n+      typedef typename _Sequence::const_reference\tconst_reference;\n+      typedef typename _Sequence::size_type\t\tsize_type;\n+      typedef\t       _Sequence\t\t\tcontainer_type;\n \n     protected:\n       //  See queue::c for notes on this name.\n@@ -235,8 +237,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ return c.emplace_back(std::forward<_Args>(__args)...); }\n #else\n       template<typename... _Args>\n-        void\n-        emplace(_Args&&... __args)\n+\tvoid\n+\templace(_Args&&... __args)\n \t{ c.emplace_back(std::forward<_Args>(__args)...); }\n #endif\n #endif"}, {"sha": "fb882126cf984f69b8b927a4a4bf0ff0dcc798fa", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe62dd045e7a0c246123792b43a2263fc81fb64e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=fe62dd045e7a0c246123792b43a2263fc81fb64e", "patch": "@@ -78,7 +78,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer\n        \tpointer;\n \n-      struct _Vector_impl \n+      struct _Vector_impl\n       : public _Tp_alloc_type\n       {\n \tpointer _M_start;\n@@ -107,7 +107,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  std::swap(_M_end_of_storage, __x._M_end_of_storage);\n \t}\n       };\n-      \n+\n     public:\n       typedef _Alloc allocator_type;\n \n@@ -215,13 +215,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n     class vector : protected _Vector_base<_Tp, _Alloc>\n     {\n+#ifdef _GLIBCXX_CONCEPT_CHECKS\n       // Concept requirements.\n       typedef typename _Alloc::value_type\t\t_Alloc_value_type;\n-#if __cplusplus < 201103L\n+# if __cplusplus < 201103L\n       __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-#endif\n+# endif\n       __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)\n-      \n+#endif\n+\n       typedef _Vector_base<_Tp, _Alloc>\t\t\t_Base;\n       typedef typename _Base::_Tp_alloc_type\t\t_Tp_alloc_type;\n       typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>\t_Alloc_traits;\n@@ -842,7 +844,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       at(size_type __n)\n       {\n \t_M_range_check(__n);\n-\treturn (*this)[__n]; \n+\treturn (*this)[__n];\n       }\n \n       /**\n@@ -895,7 +897,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t__glibcxx_requires_nonempty();\n \treturn *(end() - 1);\n       }\n-      \n+\n       /**\n        *  Returns a read-only (constant) reference to the data at the\n        *  last element of the %vector.\n@@ -953,7 +955,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       template<typename... _Args>\n #if __cplusplus > 201402L\n-        reference\n+\treference\n #else\n \tvoid\n #endif\n@@ -1045,7 +1047,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @param  __position  An iterator into the %vector.\n        *  @param  __l  An initializer_list.\n        *\n-       *  This function will insert copies of the data in the \n+       *  This function will insert copies of the data in the\n        *  initializer_list @a l into the %vector before the location\n        *  specified by @a position.\n        *"}]}