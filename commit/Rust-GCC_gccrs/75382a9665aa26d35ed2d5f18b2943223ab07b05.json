{"sha": "75382a9665aa26d35ed2d5f18b2943223ab07b05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUzODJhOTY2NWFhMjZkMzVlZDJkNWYxOGIyOTQzMjIzYWIwN2IwNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-06-21T17:34:31Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-06-21T17:34:31Z"}, "message": "re PR fortran/83118 (Bad intrinsic assignment of class(*) array component of derived type)\n\n2018-06-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/83118\n\t* resolve.c (resolve_ordinary_assign): Force the creation of a\n\tvtable for assignment of non-polymorphic expressions to an\n\tunlimited polymorphic object.\n\t* trans-array.c (gfc_alloc_allocatable_for_assignment): Use the\n\tsize of the rhs type for such assignments. Set the dtype, _len\n\tand vptrs appropriately.\n\t* trans-expr.c (gfc_trans_assignment): Force the use of the\n\t_copy function for these assignments.\n\n2018-06-21  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/83118\n\t* gfortran.dg/unlimited_polymorphic_30.f03: New test.\n\nFrom-SVN: r261857", "tree": {"sha": "b16d6362bc01c10d44f13604f3b352d4176cd089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b16d6362bc01c10d44f13604f3b352d4176cd089"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75382a9665aa26d35ed2d5f18b2943223ab07b05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75382a9665aa26d35ed2d5f18b2943223ab07b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75382a9665aa26d35ed2d5f18b2943223ab07b05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75382a9665aa26d35ed2d5f18b2943223ab07b05/comments", "author": null, "committer": null, "parents": [{"sha": "7792f13c845a8dc97e6b0a8023d81c67e8d650d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7792f13c845a8dc97e6b0a8023d81c67e8d650d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7792f13c845a8dc97e6b0a8023d81c67e8d650d2"}], "stats": {"total": 95, "additions": 92, "deletions": 3}, "files": [{"sha": "852f36e8f7cf66728ac92b06e270dd607982ebb8", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=75382a9665aa26d35ed2d5f18b2943223ab07b05", "patch": "@@ -1,3 +1,15 @@\n+2018-06-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/83118\n+\t* resolve.c (resolve_ordinary_assign): Force the creation of a\n+\tvtable for assignment of non-polymorphic expressions to an\n+\tunlimited polymorphic object.\n+\t* trans-array.c (gfc_alloc_allocatable_for_assignment): Use the\n+\tsize of the rhs type for such assignments. Set the dtype, _len\n+\tand vptrs appropriately.\n+\t* trans-expr.c (gfc_trans_assignment): Force the use of the\n+\t_copy function for these assignments.\n+\n 2018-06-20  Chung-Lin Tang <cltang@codesourcery.com>\n \t    Thomas Schwinge <thomas@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n@@ -38,7 +50,7 @@\n 2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/86110\n-\t* array.c (gfc_resolve_character_array_constructor): Avoid NULL \n+\t* array.c (gfc_resolve_character_array_constructor): Avoid NULL\n \tpointer dereference.\n \n 2018-06-13  Cesar Philippidis  <cesar@codesourcery.com>"}, {"sha": "1cc31652920eafda93edbf868826410f7df2df09", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=75382a9665aa26d35ed2d5f18b2943223ab07b05", "patch": "@@ -10385,6 +10385,11 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n       && rhs->expr_type != EXPR_ARRAY)\n     gfc_add_data_component (rhs);\n \n+  /* Make sure there is a vtable and, in particular, a _copy for the\n+     rhs type.  */\n+  if (UNLIMITED_POLY (lhs) && lhs->rank && rhs->ts.type != BT_CLASS)\n+    gfc_find_vtab (&rhs->ts);\n+\n   bool caf_convert_to_send = flag_coarray == GFC_FCOARRAY_LIB\n       && (lhs_coindexed\n \t  || (code->expr2->expr_type == EXPR_FUNCTION"}, {"sha": "f0f5c1b709ee2841174a2aadf49dac453bb45ad5", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=75382a9665aa26d35ed2d5f18b2943223ab07b05", "patch": "@@ -9951,6 +9951,8 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \t\t\t     gfc_array_index_type, tmp,\n \t\t\t     expr1->ts.u.cl->backend_decl);\n     }\n+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)\n+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));\n   else\n     tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));\n   tmp = fold_convert (gfc_array_index_type, tmp);\n@@ -9977,6 +9979,28 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n       gfc_add_modify (&fblock, tmp,\n \t\t      gfc_get_dtype_rank_type (expr1->rank,type));\n     }\n+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)\n+    {\n+      tree type;\n+      tmp = gfc_conv_descriptor_dtype (desc);\n+      type = gfc_typenode_for_spec (&expr2->ts);\n+      gfc_add_modify (&fblock, tmp,\n+\t\t      gfc_get_dtype_rank_type (expr2->rank,type));\n+      /* Set the _len field as well...  */\n+      tmp = gfc_class_len_get (TREE_OPERAND (desc, 0));\n+      if (expr2->ts.type == BT_CHARACTER)\n+\tgfc_add_modify (&fblock, tmp,\n+\t\t\tfold_convert (TREE_TYPE (tmp),\n+\t\t\t\t      TYPE_SIZE_UNIT (type)));\n+      else\n+\tgfc_add_modify (&fblock, tmp,\n+\t\t\tbuild_int_cst (TREE_TYPE (tmp), 0));\n+      /* ...and the vptr.  */\n+      tmp = gfc_class_vptr_get (TREE_OPERAND (desc, 0));\n+      tmp2 = gfc_get_symbol_decl (gfc_find_vtab (&expr2->ts));\n+      tmp2 = gfc_build_addr_expr (TREE_TYPE (tmp), tmp2);\n+      gfc_add_modify (&fblock, tmp, tmp2);\n+    }\n   else if (coarray && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n     {\n       gfc_add_modify (&fblock, gfc_conv_descriptor_dtype (desc),\n@@ -10082,10 +10106,11 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n \n \n   /* We already set the dtype in the case of deferred character\n-     length arrays.  */\n+     length arrays and unlimited polymorphic arrays.  */\n   if (!(GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n \t&& ((expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n-\t    || coarray)))\n+\t    || coarray))\n+      && !UNLIMITED_POLY (expr1))\n     {\n       tmp = gfc_conv_descriptor_dtype (desc);\n       gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));"}, {"sha": "f369b1b1be961a6285c2f82a855bdc21ab195c8f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=75382a9665aa26d35ed2d5f18b2943223ab07b05", "patch": "@@ -10437,6 +10437,10 @@ gfc_trans_assignment (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \treturn tmp;\n     }\n \n+  if (UNLIMITED_POLY (expr1) && expr1->rank\n+      && expr2->ts.type != BT_CLASS)\n+    use_vptr_copy = true;\n+\n   /* Fallback to the scalarizer to generate explicit loops.  */\n   return gfc_trans_assignment_1 (expr1, expr2, init_flag, dealloc,\n \t\t\t\t use_vptr_copy, may_alias);"}, {"sha": "60d02cb4b9d4466c32a86dd8ab068c348ed201aa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75382a9665aa26d35ed2d5f18b2943223ab07b05", "patch": "@@ -1,3 +1,8 @@\n+2018-06-21  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/83118\n+\t* gfortran.dg/unlimited_polymorphic_30.f03: New test.\n+\n 2018-06-21  Tom de Vries  <tdevries@suse.de>\n \n \t* gcc.dg/guality/pr45882.c (a): Add used attribute."}, {"sha": "4d0c2e7250bdc8aa751c568d8ae72e331230ed8d", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_30.f03", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_30.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75382a9665aa26d35ed2d5f18b2943223ab07b05/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_30.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_30.f03?ref=75382a9665aa26d35ed2d5f18b2943223ab07b05", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR83318.\n+!\n+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>\n+!\n+type :: any_vector\n+  class(*), allocatable :: v(:)\n+end type\n+type(any_vector) :: x, y\n+\n+! This did not work correctly\n+  x%v = ['foo','bar']\n+  call foo (x, 1)\n+\n+! This was reported as not working correctly but was OK before the above was fixed\n+  y = x\n+  call foo (y, 2)\n+\n+  x%v = [1_4,2_4]\n+  call foo (x, 3)\n+\n+  y = x\n+  call foo (y, 4)\n+\n+contains\n+\n+  subroutine foo (arg, n)\n+    type (any_vector) :: arg\n+    integer :: n\n+    select type (v => arg%v)\n+        type is (character(*))\n+           if (any (v .ne. [\"foo\",\"bar\"])) stop n\n+        type is (integer(4))\n+           if (any (v .ne. [1_4,2_4])) stop n\n+    end select\n+  end subroutine\n+end"}]}