{"sha": "78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhlYWY3YmYxODYzOTdmMWVhN2NhNTgxYzFlNzZlNTQzZWFhYzliNg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-04-27T10:07:47Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-04-27T10:07:47Z"}, "message": "re PR middle-end/43812 (compiling .cc file with -fwhole-program results in ICE, in ipcp_iterate_stage, at ipa-cp.c:760)\n\n2010-04-27  Martin Jambor  <mjambor@suse.cz>\n\n\tPR middle-end/43812\n\t* ipa.c (dissolve_same_comdat_group_list): New function.\n\t(function_and_variable_visibility): Call\n\tdissolve_same_comdat_group_list when comdat group contains external or\n\tnewly local nodes.\n\t* cgraphunit.c (verify_cgraph_node): Verify that same_comdat_group\n\tlists are circular and that they contain only DECL_ONE_ONLY nodes.\n\n\t* testsuite/g++.dg/ipa/pr43812.C: New test.\n\nFrom-SVN: r158777", "tree": {"sha": "815344fd064a1ca431cddb228100fe10fdc26f05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/815344fd064a1ca431cddb228100fe10fdc26f05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b56d3bbcab015c4dabf4c1ef82237ac0a37c792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b56d3bbcab015c4dabf4c1ef82237ac0a37c792", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b56d3bbcab015c4dabf4c1ef82237ac0a37c792"}], "stats": {"total": 116, "additions": 108, "deletions": 8}, "files": [{"sha": "f944bf5920a7e1eafbc97eef0962a8ec177d74e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "patch": "@@ -1,3 +1,13 @@\n+2010-04-27  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/43812\n+\t* ipa.c (dissolve_same_comdat_group_list): New function.\n+\t(function_and_variable_visibility): Call\n+\tdissolve_same_comdat_group_list when comdat group contains external or\n+\tnewly local nodes.\n+\t* cgraphunit.c (verify_cgraph_node): Verify that same_comdat_group\n+\tlists are circular and that they contain only DECL_ONE_ONLY nodes.\n+\n 2010-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* varasm.c (decode_addr_const): Handle special case of INDIRECT_REF."}, {"sha": "51b4732b45ad4135ccdbb580e85bfbf487d36f10", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "patch": "@@ -714,6 +714,32 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"double linked list of clones corrupted\");\n       error_found = true;\n     }\n+  if (node->same_comdat_group)\n+    {\n+      struct cgraph_node *n = node->same_comdat_group;\n+\n+      if (!DECL_ONE_ONLY (node->decl))\n+\t{\n+\t  error (\"non-DECL_ONE_ONLY node in a same_comdat_group list\");\n+\t  error_found = true;\n+\t}\n+      if (n == node)\n+\t{\n+\t  error (\"node is alone in a comdat group\");\n+\t  error_found = true;\n+\t}\n+      do\n+\t{\n+\t  if (!n->same_comdat_group)\n+\t    {\n+\t      error (\"same_comdat_group is not a circular list\");\n+\t      error_found = true;\n+\t      break;\n+\t    }\n+\t  n = n->same_comdat_group;\n+\t}\n+      while (n != node);\n+    }\n \n   if (node->analyzed && gimple_has_body_p (node->decl)\n       && !TREE_ASM_WRITTEN (node->decl)"}, {"sha": "8295357cc0e50c06d478f170ddcb12e622621427", "filename": "gcc/ipa.c", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "patch": "@@ -355,6 +355,21 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program)\n   return false;\n }\n \n+/* Dissolve the same_comdat_group list in which NODE resides.  */\n+\n+static void\n+dissolve_same_comdat_group_list (struct cgraph_node *node)\n+{\n+  struct cgraph_node *n = node, *next;\n+  do\n+    {\n+      next = n->same_comdat_group;\n+      n->same_comdat_group = NULL;\n+      n = next;\n+    }\n+  while (n != node);\n+}\n+\n /* Mark visibility of all functions.\n \n    A local function is one whose calls can occur only in the current\n@@ -385,17 +400,17 @@ function_and_variable_visibility (bool whole_program)\n \t and simplifies later passes.  */\n       if (node->same_comdat_group && DECL_EXTERNAL (node->decl))\n \t{\n-\t  struct cgraph_node *n = node, *next;\n-\t  do\n-\t    {\n+#ifdef ENABLE_CHECKING\n+\t  struct cgraph_node *n;\n+\n+\t  for (n = node->same_comdat_group;\n+\t       n != node;\n+\t       n = n->same_comdat_group)\n \t      /* If at least one of same comdat group functions is external,\n \t\t all of them have to be, otherwise it is a front-end bug.  */\n \t      gcc_assert (DECL_EXTERNAL (n->decl));\n-\t      next = n->same_comdat_group;\n-\t      n->same_comdat_group = NULL;\n-\t      n = next;\n-\t    }\n-\t  while (n != node);\n+#endif\n+\t  dissolve_same_comdat_group_list (node);\n \t}\n       gcc_assert ((!DECL_WEAK (node->decl) && !DECL_COMDAT (node->decl))\n       \t          || TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl));\n@@ -411,6 +426,12 @@ function_and_variable_visibility (bool whole_program)\n \t{\n \t  gcc_assert (whole_program || !TREE_PUBLIC (node->decl));\n \t  cgraph_make_decl_local (node->decl);\n+\t  if (node->same_comdat_group)\n+\t    /* cgraph_externally_visible_p has already checked all other nodes\n+\t       in the group and they will all be made local.  We need to\n+\t       dissolve the group at once so that the predicate does not\n+\t       segfault though. */\n+\t    dissolve_same_comdat_group_list (node);\n \t}\n       node->local.local = (cgraph_only_called_directly_p (node)\n \t\t\t   && node->analyzed"}, {"sha": "9c0afd60faac78cb26acb12ba30de4d6d907f7f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "patch": "@@ -1,3 +1,8 @@\n+2010-04-27  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/43812\n+\t* g++.dg/ipa/pr43812.C: New test.\n+\n 2010-04-27  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/ipa/iinline-1.c (main): Rename to..."}, {"sha": "cc46eed6501dc6f09f20680f62a01725fbe9d106", "filename": "gcc/testsuite/g++.dg/ipa/pr43812.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr43812.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78eaf7bf186397f1ea7ca581c1e76e543eaac9b6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr43812.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr43812.C?ref=78eaf7bf186397f1ea7ca581c1e76e543eaac9b6", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fwhole-program -fipa-cp\" } */\n+\n+typedef float scoord_t;\n+typedef scoord_t sdist_t;\n+typedef sdist_t dist_t;\n+template<typename T> class TRay { };\n+typedef TRay<dist_t> Ray;\n+class BBox { };\n+class RenderContext { };\n+class RefCounted {\n+public:\n+    void deref () const {\n+        if (--ref_count <= 0) {\n+            delete this;\n+        }\n+    }\n+    mutable int ref_count;\n+};\n+template<class T> class Ref {\n+public:\n+    ~Ref () {\n+        if (obj) obj->deref ();\n+    }\n+    T *obj;\n+};\n+class Material : public RefCounted { };\n+class Surface {\n+public:\n+    virtual ~Surface () { }\n+    class IsecInfo   { };\n+    virtual const IsecInfo *intersect (Ray &ray, RenderContext &context) const;\n+    Ref<const Material> material;\n+};\n+class LocalSurface : public Surface {\n+    virtual BBox bbox () const;\n+};\n+BBox LocalSurface::bbox () const { }"}]}