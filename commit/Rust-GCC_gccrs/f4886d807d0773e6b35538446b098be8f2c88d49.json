{"sha": "f4886d807d0773e6b35538446b098be8f2c88d49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ4ODZkODA3ZDA3NzNlNmIzNTUzODQ0NmIwOThiZThmMmM4OGQ0OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-12-02T16:41:02Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-12-02T16:41:02Z"}, "message": "re PR c++/68290 (g++.dg/concepts/auto1.C FAILs)\n\n\tPR c++/68290\n\t* constraint.cc (make_constrained_auto): Move to...\n\t* pt.c (make_auto_1): Add set_canonical parameter and set\n\tTYPE_CANONICAL on the type only if it is true.\n\t(make_decltype_auto): Adjust call to make_auto_1.\n\t(make_auto): Likewise.\n\t(splice_late_return_type): Likewise.\n\t(make_constrained_auto): ...here.  Call make_auto_1 instead of\n\tmake_auto and pass false.  Set TYPE_CANONICAL directly.\n\nFrom-SVN: r231189", "tree": {"sha": "f960efb13ba27b633b4230d78c80b8ab85993ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f960efb13ba27b633b4230d78c80b8ab85993ef6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4886d807d0773e6b35538446b098be8f2c88d49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4886d807d0773e6b35538446b098be8f2c88d49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4886d807d0773e6b35538446b098be8f2c88d49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4886d807d0773e6b35538446b098be8f2c88d49/comments", "author": null, "committer": null, "parents": [{"sha": "f74e65509f3355b9bb0992d2c784e56962b06001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f74e65509f3355b9bb0992d2c784e56962b06001", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f74e65509f3355b9bb0992d2c784e56962b06001"}], "stats": {"total": 81, "additions": 49, "deletions": 32}, "files": [{"sha": "f5f97070fac8bc47ee4cad229e8050e11efd4b3a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4886d807d0773e6b35538446b098be8f2c88d49/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4886d807d0773e6b35538446b098be8f2c88d49/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f4886d807d0773e6b35538446b098be8f2c88d49", "patch": "@@ -1,3 +1,15 @@\n+2015-12-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR c++/68290\n+\t* constraint.cc (make_constrained_auto): Move to...\n+\t* pt.c (make_auto_1): Add set_canonical parameter and set\n+\tTYPE_CANONICAL on the type only if it is true.\n+\t(make_decltype_auto): Adjust call to make_auto_1.\n+\t(make_auto): Likewise.\n+\t(splice_late_return_type): Likewise.\n+\t(make_constrained_auto): ...here.  Call make_auto_1 instead of\n+\tmake_auto and pass false.  Set TYPE_CANONICAL directly.\n+\n 2015-12-02  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* parser.c (cp_parser_omp_clause_name)"}, {"sha": "71e3e0d6f1c80cf5b93f6e36e4db862f8d8531b3", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4886d807d0773e6b35538446b098be8f2c88d49/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4886d807d0773e6b35538446b098be8f2c88d49/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=f4886d807d0773e6b35538446b098be8f2c88d49", "patch": "@@ -1353,32 +1353,6 @@ finish_template_introduction (tree tmpl_decl, tree intro_list)\n }\n \n \n-/* Make a \"constrained auto\" type-specifier. This is an\n-   auto type with constraints that must be associated after\n-   deduction.  The constraint is formed from the given\n-   CONC and its optional sequence of arguments, which are\n-   non-null if written as partial-concept-id.  */\n-tree\n-make_constrained_auto (tree con, tree args)\n-{\n-  tree type = make_auto();\n-\n-  /* Build the constraint. */\n-  tree tmpl = DECL_TI_TEMPLATE (con);\n-  tree expr;\n-  if (VAR_P (con))\n-    expr = build_concept_check (tmpl, type, args);\n-  else\n-    expr = build_concept_check (build_overload (tmpl, NULL_TREE), type, args);\n-\n-  tree constr = make_predicate_constraint (expr);\n-  PLACEHOLDER_TYPE_CONSTRAINTS (type) = constr;\n-\n-  /* Attach the constraint to the type declaration. */\n-  tree decl = TYPE_NAME (type);\n-  return decl;\n-}\n-\n /* Given the predicate constraint T from a constrained-type-specifier, extract\n    its TMPL and ARGS.  FIXME why do we need two different forms of\n    constrained-type-specifier?  */"}, {"sha": "8435ddc224ab1d301ab9d528b0103f0859bdb7c3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4886d807d0773e6b35538446b098be8f2c88d49/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4886d807d0773e6b35538446b098be8f2c88d49/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f4886d807d0773e6b35538446b098be8f2c88d49", "patch": "@@ -23469,10 +23469,10 @@ make_args_non_dependent (vec<tree, va_gc> *args)\n \n /* Returns a type which represents 'auto' or 'decltype(auto)'.  We use a\n    TEMPLATE_TYPE_PARM with a level one deeper than the actual template\n-   parms.  */\n+   parms.  If set_canonical is true, we set TYPE_CANONICAL on it.  */\n \n static tree\n-make_auto_1 (tree name)\n+make_auto_1 (tree name, bool set_canonical)\n {\n   tree au = cxx_make_type (TEMPLATE_TYPE_PARM);\n   TYPE_NAME (au) = build_decl (input_location,\n@@ -23481,7 +23481,8 @@ make_auto_1 (tree name)\n   TEMPLATE_TYPE_PARM_INDEX (au) = build_template_parm_index\n     (0, processing_template_decl + 1, processing_template_decl + 1,\n      TYPE_NAME (au), NULL_TREE);\n-  TYPE_CANONICAL (au) = canonical_type_parameter (au);\n+  if (set_canonical)\n+    TYPE_CANONICAL (au) = canonical_type_parameter (au);\n   DECL_ARTIFICIAL (TYPE_NAME (au)) = 1;\n   SET_DECL_TEMPLATE_PARM_P (TYPE_NAME (au));\n \n@@ -23491,13 +23492,43 @@ make_auto_1 (tree name)\n tree\n make_decltype_auto (void)\n {\n-  return make_auto_1 (get_identifier (\"decltype(auto)\"));\n+  return make_auto_1 (get_identifier (\"decltype(auto)\"), true);\n }\n \n tree\n make_auto (void)\n {\n-  return make_auto_1 (get_identifier (\"auto\"));\n+  return make_auto_1 (get_identifier (\"auto\"), true);\n+}\n+\n+/* Make a \"constrained auto\" type-specifier. This is an\n+   auto type with constraints that must be associated after\n+   deduction.  The constraint is formed from the given\n+   CONC and its optional sequence of arguments, which are\n+   non-null if written as partial-concept-id.  */\n+\n+tree\n+make_constrained_auto (tree con, tree args)\n+{\n+  tree type = make_auto_1 (get_identifier (\"auto\"), false);\n+\n+  /* Build the constraint. */\n+  tree tmpl = DECL_TI_TEMPLATE (con);\n+  tree expr;\n+  if (VAR_P (con))\n+    expr = build_concept_check (tmpl, type, args);\n+  else\n+    expr = build_concept_check (build_overload (tmpl, NULL_TREE), type, args);\n+\n+  tree constr = make_predicate_constraint (expr);\n+  PLACEHOLDER_TYPE_CONSTRAINTS (type) = constr;\n+\n+  /* Our canonical type depends on the constraint.  */\n+  TYPE_CANONICAL (type) = canonical_type_parameter (type);\n+\n+  /* Attach the constraint to the type declaration. */\n+  tree decl = TYPE_NAME (type);\n+  return decl;\n }\n \n /* Given type ARG, return std::initializer_list<ARG>.  */\n@@ -23813,7 +23844,7 @@ splice_late_return_type (tree type, tree late_return_type)\n \t/* In an abbreviated function template we didn't know we were dealing\n \t   with a function template when we saw the auto return type, so update\n \t   it to have the correct level.  */\n-\treturn make_auto_1 (TYPE_IDENTIFIER (type));\n+\treturn make_auto_1 (TYPE_IDENTIFIER (type), true);\n     }\n   return type;\n }"}]}