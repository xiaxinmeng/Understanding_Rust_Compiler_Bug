{"sha": "79f0451c67e8ed564b86a38581d5f3d57c5074d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlmMDQ1MWM2N2U4ZWQ1NjRiODZhMzg1ODFkNWYzZDU3YzUwNzRkOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-18T14:05:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-22T10:26:27Z"}, "message": "enfoce SLP_TREE_VECTYPE for invariants\n\nThis tries to enforce a set SLP_TREE_VECTYPE in vect_get_constant_vectors\nand provides some infrastructure for setting it in the vectorizable_*\nfunctions, amending those.\n\n2020-05-22  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_is_simple_use): New overload.\n\t(vect_maybe_update_slp_op_vectype): New.\n\t* tree-vect-stmts.c (vect_is_simple_use): New overload\n\taccessing operands of SLP vs. non-SLP operation transparently.\n\t(vect_maybe_update_slp_op_vectype): New function updating\n\tthe possibly shared SLP operands vector type.\n\t(vectorizable_operation): Be a bit more SLP vs non-SLP agnostic\n\tusing the new vect_is_simple_use overload;  update SLP invariant\n\toperand nodes vector type.\n\t(vectorizable_comparison): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t* tree-vect-loop.c (vectorizable_reduction): Likewise.\n\t* tree-vect-slp.c (vect_get_constant_vectors): Enforce\n\tpresent SLP_TREE_VECTYPE and check it matches previous\n\tbehavior.", "tree": {"sha": "6d021593ca3438568971032ee89debbba1a036c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d021593ca3438568971032ee89debbba1a036c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79f0451c67e8ed564b86a38581d5f3d57c5074d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f0451c67e8ed564b86a38581d5f3d57c5074d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f0451c67e8ed564b86a38581d5f3d57c5074d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f0451c67e8ed564b86a38581d5f3d57c5074d8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6ed2e2bca54d1d290f553549d28b0c60a0f240f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ed2e2bca54d1d290f553549d28b0c60a0f240f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6ed2e2bca54d1d290f553549d28b0c60a0f240f"}], "stats": {"total": 347, "additions": 279, "deletions": 68}, "files": [{"sha": "390a344e459a7642a1c64fb564b6e97d902f3743", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79f0451c67e8ed564b86a38581d5f3d57c5074d8", "patch": "@@ -1,3 +1,26 @@\n+2020-05-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_is_simple_use): New overload.\n+\t(vect_maybe_update_slp_op_vectype): New.\n+\t* tree-vect-stmts.c (vect_is_simple_use): New overload\n+\taccessing operands of SLP vs. non-SLP operation transparently.\n+\t(vect_maybe_update_slp_op_vectype): New function updating\n+\tthe possibly shared SLP operands vector type.\n+\t(vectorizable_operation): Be a bit more SLP vs non-SLP agnostic\n+\tusing the new vect_is_simple_use overload;  update SLP invariant\n+\toperand nodes vector type.\n+\t(vectorizable_comparison): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_shift): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_condition): Likewise.\n+\t(vectorizable_assignment): Likewise.\n+\t* tree-vect-loop.c (vectorizable_reduction): Likewise.\n+\t* tree-vect-slp.c (vect_get_constant_vectors): Enforce\n+\tpresent SLP_TREE_VECTYPE and check it matches previous\n+\tbehavior.\n+\n 2020-05-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/95248"}, {"sha": "4f94b4baad9f7c50eeecbe3a1deb0c6036a9e599", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=79f0451c67e8ed564b86a38581d5f3d57c5074d8", "patch": "@@ -6185,17 +6185,29 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n      The last use is the reduction variable.  In case of nested cycle this\n      assumption is not true: we use reduc_index to record the index of the\n      reduction variable.  */\n-  reduc_def = PHI_RESULT (reduc_def_phi);\n+  /* ???  To get at invariant/constant uses on the SLP node we have to\n+     get to it here, slp_node is still the reduction PHI.  */\n+  slp_tree slp_for_stmt_info = NULL;\n+  if (slp_node)\n+    {\n+      slp_for_stmt_info = slp_node_instance->root;\n+      /* And then there's reduction chain with a conversion ...  */\n+      if (SLP_TREE_SCALAR_STMTS (slp_for_stmt_info)[0] != stmt_info)\n+\tslp_for_stmt_info = SLP_TREE_CHILDREN (slp_for_stmt_info)[0];\n+      gcc_assert (SLP_TREE_SCALAR_STMTS (slp_for_stmt_info)[0] == stmt_info);\n+    }\n+  slp_tree *slp_op = XALLOCAVEC (slp_tree, op_type);\n   for (i = 0; i < op_type; i++)\n     {\n-      tree op = gimple_op (stmt, i + 1);\n       /* The condition of COND_EXPR is checked in vectorizable_condition().  */\n       if (i == 0 && code == COND_EXPR)\n         continue;\n \n       stmt_vec_info def_stmt_info;\n       enum vect_def_type dt;\n-      if (!vect_is_simple_use (op, loop_vinfo, &dt, &tem,\n+      tree op;\n+      if (!vect_is_simple_use (loop_vinfo, stmt_info, slp_for_stmt_info,\n+\t\t\t       i, &op, &slp_op[i], &dt, &tem,\n \t\t\t       &def_stmt_info))\n \t{\n \t  if (dump_enabled_p ())\n@@ -6729,6 +6741,21 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n       return false;\n     }\n \n+  if (slp_node\n+      && !(!single_defuse_cycle\n+\t   && code != DOT_PROD_EXPR\n+\t   && code != WIDEN_SUM_EXPR\n+\t   && code != SAD_EXPR\n+\t   && reduction_type != FOLD_LEFT_REDUCTION))\n+    for (i = 0; i < op_type; i++)\n+      if (!vect_maybe_update_slp_op_vectype (slp_op[i], vectype_in))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"incompatible vector types for invariants\\n\");\n+\t  return false;\n+\t}\n+\n   if (slp_node)\n     vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n   else"}, {"sha": "ec3675e7070b7f74ad09b709c7c98c905299ac04", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=79f0451c67e8ed564b86a38581d5f3d57c5074d8", "patch": "@@ -3621,16 +3621,22 @@ vect_get_constant_vectors (vec_info *vinfo,\n   gimple_seq ctor_seq = NULL;\n   auto_vec<tree, 16> permute_results;\n \n-  /* ???  SLP analysis should compute the vector type for the\n-     constant / invariant and store it in the SLP node.  */\n+  /* We always want SLP_TREE_VECTYPE (op_node) here correctly set.  */\n+  vector_type = SLP_TREE_VECTYPE (op_node);\n+    {\n   tree op = op_node->ops[0];\n-  /* Check if vector type is a boolean vector.  */\n   tree stmt_vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   if (VECT_SCALAR_BOOLEAN_TYPE_P (TREE_TYPE (op))\n       && vect_mask_constant_operand_p (vinfo, stmt_vinfo, op_num))\n-    vector_type = truth_type_for (stmt_vectype);\n+    gcc_assert (vector_type\n+\t\t&& types_compatible_p (vector_type,\n+\t\t\t\t       truth_type_for (stmt_vectype)));\n   else\n-    vector_type = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op), op_node);\n+    gcc_assert (vector_type\n+\t\t&& types_compatible_p (vector_type,\n+\t\t\t\t       get_vectype_for_scalar_type\n+\t\t\t\t\t (vinfo, TREE_TYPE (op), op_node)));\n+    }\n \n   poly_uint64 vf = 1;\n   if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))"}, {"sha": "e7822c4495151921775e8c4d21197a5fe89bf18f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 210, "deletions": 60, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=79f0451c67e8ed564b86a38581d5f3d57c5074d8", "patch": "@@ -3170,6 +3170,7 @@ vectorizable_call (vec_info *vinfo,\n     = { vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type,\n \tvect_unknown_def_type };\n   tree vectypes[ARRAY_SIZE (dt)] = {};\n+  slp_tree slp_op[ARRAY_SIZE (dt)] = {};\n   int ndts = ARRAY_SIZE (dt);\n   int ncopies, j;\n   auto_vec<tree, 8> vargs;\n@@ -3209,7 +3210,7 @@ vectorizable_call (vec_info *vinfo,\n   vectype_in = NULL_TREE;\n   nargs = gimple_call_num_args (stmt);\n \n-  /* Bail out if the function has more than three arguments, we do not have\n+  /* Bail out if the function has more than four arguments, we do not have\n      interesting builtin functions to vectorize with more than two arguments\n      except for fma.  No arguments is also not good.  */\n   if (nargs == 0 || nargs > 4)\n@@ -3229,17 +3230,17 @@ vectorizable_call (vec_info *vinfo,\n \n   for (i = 0; i < nargs; i++)\n     {\n-      op = gimple_call_arg (stmt, i);\n-\n       if ((int) i == mask_opno)\n \t{\n+\t  op = gimple_call_arg (stmt, i);\n \t  if (!vect_check_scalar_mask (vinfo,\n \t\t\t\t       stmt_info, op, &dt[i], &vectypes[i]))\n \t    return false;\n \t  continue;\n \t}\n \n-      if (!vect_is_simple_use (op, vinfo, &dt[i], &vectypes[i]))\n+      if (!vect_is_simple_use (vinfo, stmt_info, slp_node,\n+\t\t\t       i, &op, &slp_op[i], &dt[i], &vectypes[i]))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -3400,6 +3401,15 @@ vectorizable_call (vec_info *vinfo,\n   vec_loop_masks *masks = (loop_vinfo ? &LOOP_VINFO_MASKS (loop_vinfo) : NULL);\n   if (!vec_stmt) /* transformation not required.  */\n     {\n+      if (slp_node)\n+\tfor (i = 0; i < nargs; ++i)\n+\t  if (!vect_maybe_update_slp_op_vectype (slp_op[i], vectype_in))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"incompatible vector types for invariants\\n\");\n+\t      return false;\n+\t    }\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n       DUMP_VECT_SCOPE (\"vectorizable_call\");\n       vect_model_simple_cost (vinfo, stmt_info,\n@@ -4725,9 +4735,18 @@ vectorizable_conversion (vec_info *vinfo,\n   lhs_type = TREE_TYPE (scalar_dest);\n   vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n \n-  op0 = gimple_assign_rhs1 (stmt);\n-  rhs_type = TREE_TYPE (op0);\n+  /* Check the operands of the operation.  */\n+  slp_tree slp_op0, slp_op1 = NULL;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node,\n+\t\t\t   0, &op0, &slp_op0, &dt[0], &vectype_in))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"use not simple.\\n\");\n+      return false;\n+    }\n \n+  rhs_type = TREE_TYPE (op0);\n   if ((code != FIX_TRUNC_EXPR && code != FLOAT_EXPR)\n       && !((INTEGRAL_TYPE_P (lhs_type)\n \t    && INTEGRAL_TYPE_P (rhs_type))\n@@ -4748,34 +4767,24 @@ vectorizable_conversion (vec_info *vinfo,\n       return false;\n     }\n \n-  /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, vinfo, &dt[0], &vectype_in))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"use not simple.\\n\");\n-      return false;\n-    }\n   if (op_type == binary_op)\n     {\n-      bool ok;\n-\n-      op1 = gimple_assign_rhs2 (stmt);\n       gcc_assert (code == WIDEN_MULT_EXPR || code == WIDEN_LSHIFT_EXPR);\n-      /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n-\t OP1.  */\n-      if (CONSTANT_CLASS_P (op0))\n-\tok = vect_is_simple_use (op1, vinfo, &dt[1], &vectype_in);\n-      else\n-\tok = vect_is_simple_use (op1, vinfo, &dt[1]);\n \n-      if (!ok)\n+      op1 = gimple_assign_rhs2 (stmt);\n+      tree vectype1_in;\n+      if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 1,\n+\t\t\t       &op1, &slp_op1, &dt[1], &vectype1_in))\n \t{\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"use not simple.\\n\");\n \t  return false;\n \t}\n+      /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n+\t OP1.  */\n+      if (!vectype_in)\n+\tvectype_in = vectype1_in;\n     }\n \n   /* If op0 is an external or constant def, infer the vector type\n@@ -4949,6 +4958,15 @@ vectorizable_conversion (vec_info *vinfo,\n \n   if (!vec_stmt)\t\t/* transformation not required.  */\n     {\n+      if (slp_node\n+\t  && (!vect_maybe_update_slp_op_vectype (slp_op0, vectype_in)\n+\t      || !vect_maybe_update_slp_op_vectype (slp_op1, vectype_in)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"incompatible vector types for invariants\\n\");\n+\t  return false;\n+\t}\n       DUMP_VECT_SCOPE (\"vectorizable_conversion\");\n       if (modifier == NONE)\n         {\n@@ -5306,16 +5324,14 @@ vectorizable_assignment (vec_info *vinfo,\n   if (TREE_CODE (scalar_dest) != SSA_NAME)\n     return false;\n \n-  code = gimple_assign_rhs_code (stmt);\n-  if (gimple_assign_single_p (stmt)\n-      || code == PAREN_EXPR\n-      || CONVERT_EXPR_CODE_P (code))\n-    op = gimple_assign_rhs1 (stmt);\n-  else\n+  if (STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n-  if (code == VIEW_CONVERT_EXPR)\n-    op = TREE_OPERAND (op, 0);\n+  code = gimple_assign_rhs_code (stmt);\n+  if (!(gimple_assign_single_p (stmt)\n+\t|| code == PAREN_EXPR\n+\t|| CONVERT_EXPR_CODE_P (code)))\n+    return false;\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n@@ -5330,13 +5346,17 @@ vectorizable_assignment (vec_info *vinfo,\n \n   gcc_assert (ncopies >= 1);\n \n-  if (!vect_is_simple_use (op, vinfo, &dt[0], &vectype_in))\n+  slp_tree slp_op;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 0, &op, &slp_op,\n+\t\t\t   &dt[0], &vectype_in))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"use not simple.\\n\");\n       return false;\n     }\n+  if (!vectype_in)\n+    vectype_in = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op), slp_node);\n \n   /* We can handle NOP_EXPR conversions that do not change the number\n      of elements or the vector size.  */\n@@ -5373,6 +5393,14 @@ vectorizable_assignment (vec_info *vinfo,\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n+      if (slp_node\n+\t  && !vect_maybe_update_slp_op_vectype (slp_op, vectype_in))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"incompatible vector types for invariants\\n\");\n+\t  return false;\n+\t}\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n       DUMP_VECT_SCOPE (\"vectorizable_assignment\");\n       if (!vect_nop_conversion_p (stmt_info))\n@@ -5540,8 +5568,9 @@ vectorizable_shift (vec_info *vinfo,\n       return false;\n     }\n \n-  op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op0, vinfo, &dt[0], &vectype))\n+  slp_tree slp_op0;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node,\n+\t\t\t   0, &op0, &slp_op0, &dt[0], &vectype))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5567,10 +5596,10 @@ vectorizable_shift (vec_info *vinfo,\n   if (maybe_ne (nunits_out, nunits_in))\n     return false;\n \n-  op1 = gimple_assign_rhs2 (stmt);\n   stmt_vec_info op1_def_stmt_info;\n-  if (!vect_is_simple_use (op1, vinfo, &dt[1], &op1_vectype,\n-\t\t\t   &op1_def_stmt_info))\n+  slp_tree slp_op1;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 1, &op1, &slp_op1,\n+\t\t\t   &dt[1], &op1_vectype, &op1_def_stmt_info))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5743,6 +5772,15 @@ vectorizable_shift (vec_info *vinfo,\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n+      if (slp_node\n+\t  && (!vect_maybe_update_slp_op_vectype (slp_op0, vectype)\n+\t      || !vect_maybe_update_slp_op_vectype (slp_op1, op1_vectype)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"incompatible vector types for invariants\\n\");\n+\t  return false;\n+\t}\n       STMT_VINFO_TYPE (stmt_info) = shift_vec_info_type;\n       DUMP_VECT_SCOPE (\"vectorizable_shift\");\n       vect_model_simple_cost (vinfo, stmt_info, ncopies, dt,\n@@ -5931,7 +5969,8 @@ vectorizable_operation (vec_info *vinfo,\n   if (!stmt)\n     return false;\n \n-  if (TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n+  /* Loads and stores are handled in vectorizable_{load,store}.  */\n+  if (STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n   orig_code = code = gimple_assign_rhs_code (stmt);\n@@ -5988,8 +6027,9 @@ vectorizable_operation (vec_info *vinfo,\n       return false;\n     }\n \n-  op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op0, vinfo, &dt[0], &vectype))\n+  slp_tree slp_op0;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node,\n+\t\t\t   0, &op0, &slp_op0, &dt[0], &vectype))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6038,10 +6078,11 @@ vectorizable_operation (vec_info *vinfo,\n     return false;\n \n   tree vectype2 = NULL_TREE, vectype3 = NULL_TREE;\n+  slp_tree slp_op1 = NULL, slp_op2 = NULL;\n   if (op_type == binary_op || op_type == ternary_op)\n     {\n-      op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, vinfo, &dt[1], &vectype2))\n+      if (!vect_is_simple_use (vinfo, stmt_info, slp_node,\n+\t\t\t       1, &op1, &slp_op1, &dt[1], &vectype2))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6051,8 +6092,8 @@ vectorizable_operation (vec_info *vinfo,\n     }\n   if (op_type == ternary_op)\n     {\n-      op2 = gimple_assign_rhs3 (stmt);\n-      if (!vect_is_simple_use (op2, vinfo, &dt[2], &vectype3))\n+      if (!vect_is_simple_use (vinfo, stmt_info, slp_node,\n+\t\t\t       2, &op2, &slp_op2, &dt[2], &vectype3))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6164,6 +6205,18 @@ vectorizable_operation (vec_info *vinfo,\n \t\t\t\t   vectype, NULL);\n \t}\n \n+      /* Put types on constant and invariant SLP children.  */\n+      if (slp_node\n+\t  && (!vect_maybe_update_slp_op_vectype (slp_op0, vectype)\n+\t      || !vect_maybe_update_slp_op_vectype (slp_op1, vectype)\n+\t      || !vect_maybe_update_slp_op_vectype (slp_op2, vectype)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"incompatible vector types for invariants\\n\");\n+\t  return false;\n+\t}\n+\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n       DUMP_VECT_SCOPE (\"vectorizable_operation\");\n       vect_model_simple_cost (vinfo, stmt_info,\n@@ -7479,6 +7532,16 @@ vectorizable_store (vec_info *vinfo,\n \tcheck_load_store_masking (loop_vinfo, vectype, vls_type, group_size,\n \t\t\t\t  memory_access_type, &gs_info, mask);\n \n+      if (slp_node\n+\t  && !vect_maybe_update_slp_op_vectype (SLP_TREE_CHILDREN (slp_node)[0],\n+\t\t\t\t\t\tvectype))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"incompatible vector types for invariants\\n\");\n+\t  return false;\n+\t}\n+\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n       vect_model_store_cost (vinfo, stmt_info, ncopies,\n \t\t\t     memory_access_type, vls_type, slp_node, cost_vec);\n@@ -10060,17 +10123,23 @@ vectorizable_condition (vec_info *vinfo,\n     return false; /* FORNOW */\n \n   cond_expr = gimple_assign_rhs1 (stmt);\n-  then_clause = gimple_assign_rhs2 (stmt);\n-  else_clause = gimple_assign_rhs3 (stmt);\n \n   if (!vect_is_simple_cond (cond_expr, vinfo, slp_node,\n \t\t\t    &comp_vectype, &dts[0], vectype)\n       || !comp_vectype)\n     return false;\n \n-  if (!vect_is_simple_use (then_clause, vinfo, &dts[2], &vectype1))\n+  unsigned slp_adjust = 0;\n+  if (slp_node && SLP_TREE_CHILDREN (slp_node).length () == 4)\n+    /* ???  Hack.  Hope for COND_EXPR GIMPLE sanitizing or refactor\n+       things more...  */\n+    slp_adjust = 1;\n+  slp_tree then_slp_node, else_slp_node;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 1 + slp_adjust,\n+\t\t\t   &then_clause, &then_slp_node, &dts[2], &vectype1))\n     return false;\n-  if (!vect_is_simple_use (else_clause, vinfo, &dts[3], &vectype2))\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node, 2 + slp_adjust,\n+\t\t\t   &else_clause, &else_slp_node, &dts[3], &vectype2))\n     return false;\n \n   if (vectype1 && !useless_type_conversion_p (vectype, vectype1))\n@@ -10188,19 +10257,34 @@ vectorizable_condition (vec_info *vinfo,\n \t    }\n \t}\n \n-      if (loop_vinfo\n-\t  && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo)\n-\t  && reduction_type == EXTRACT_LAST_REDUCTION)\n-\tvect_record_loop_mask (loop_vinfo, &LOOP_VINFO_MASKS (loop_vinfo),\n-\t\t\t       ncopies * vec_num, vectype, NULL);\n-\n       vect_cost_for_stmt kind = vector_stmt;\n       if (reduction_type == EXTRACT_LAST_REDUCTION)\n \t/* Count one reduction-like operation per vector.  */\n \tkind = vec_to_scalar;\n       else if (!expand_vec_cond_expr_p (vectype, comp_vectype, cond_code))\n \treturn false;\n \n+      if (slp_node\n+\t  && (!vect_maybe_update_slp_op_vectype\n+\t\t (SLP_TREE_CHILDREN (slp_node)[0], comp_vectype)\n+\t      || (slp_adjust == 1\n+\t\t  && !vect_maybe_update_slp_op_vectype\n+\t\t\t(SLP_TREE_CHILDREN (slp_node)[1], comp_vectype))\n+\t      || !vect_maybe_update_slp_op_vectype (then_slp_node, vectype)\n+\t      || !vect_maybe_update_slp_op_vectype (else_slp_node, vectype)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"incompatible vector types for invariants\\n\");\n+\t  return false;\n+\t}\n+\n+      if (loop_vinfo\n+\t  && LOOP_VINFO_CAN_FULLY_MASK_P (loop_vinfo)\n+\t  && reduction_type == EXTRACT_LAST_REDUCTION)\n+\tvect_record_loop_mask (loop_vinfo, &LOOP_VINFO_MASKS (loop_vinfo),\n+\t\t\t       ncopies * vec_num, vectype, NULL);\n+\n       STMT_VINFO_TYPE (stmt_info) = condition_vec_info_type;\n       vect_model_simple_cost (vinfo, stmt_info, ncopies, dts, ndts, slp_node,\n \t\t\t      cost_vec, kind);\n@@ -10550,13 +10634,13 @@ vectorizable_comparison (vec_info *vinfo,\n   if (TREE_CODE_CLASS (code) != tcc_comparison)\n     return false;\n \n-  rhs1 = gimple_assign_rhs1 (stmt);\n-  rhs2 = gimple_assign_rhs2 (stmt);\n-\n-  if (!vect_is_simple_use (rhs1, vinfo, &dts[0], &vectype1))\n+  slp_tree slp_rhs1, slp_rhs2;\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node,\n+\t\t\t   0, &rhs1, &slp_rhs1, &dts[0], &vectype1))\n     return false;\n \n-  if (!vect_is_simple_use (rhs2, vinfo, &dts[1], &vectype2))\n+  if (!vect_is_simple_use (vinfo, stmt_info, slp_node,\n+\t\t\t   1, &rhs2, &slp_rhs2, &dts[1], &vectype2))\n     return false;\n \n   if (vectype1 && vectype2\n@@ -10649,6 +10733,17 @@ vectorizable_comparison (vec_info *vinfo,\n \t    }\n \t}\n \n+      /* Put types on constant and invariant SLP children.  */\n+      if (slp_node\n+\t  && (!vect_maybe_update_slp_op_vectype (slp_rhs1, vectype)\n+\t      || !vect_maybe_update_slp_op_vectype (slp_rhs2, vectype)))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"incompatible vector types for invariants\\n\");\n+\t  return false;\n+\t}\n+\n       STMT_VINFO_TYPE (stmt_info) = comparison_vec_info_type;\n       vect_model_simple_cost (vinfo, stmt_info,\n \t\t\t      ncopies * (1 + (bitop2 != NOP_EXPR)),\n@@ -11705,6 +11800,61 @@ vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n   return true;\n }\n \n+/* Function vect_is_simple_use.\n+\n+   Same as vect_is_simple_use but determines the operand by operand\n+   position OPERAND from either STMT or SLP_NODE, filling in *OP\n+   and *SLP_DEF (when SLP_NODE is not NULL).  */\n+\n+bool\n+vect_is_simple_use (vec_info *vinfo, stmt_vec_info stmt, slp_tree slp_node,\n+\t\t    unsigned operand, tree *op, slp_tree *slp_def,\n+\t\t    enum vect_def_type *dt,\n+\t\t    tree *vectype, stmt_vec_info *def_stmt_info_out)\n+{\n+  if (slp_node)\n+    {\n+      slp_tree child = SLP_TREE_CHILDREN (slp_node)[operand];\n+      *slp_def = child;\n+      if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+\t*op = gimple_get_lhs (SLP_TREE_SCALAR_STMTS (child)[0]->stmt);\n+      else\n+\t*op = SLP_TREE_SCALAR_OPS (child)[0];\n+    }\n+  else\n+    {\n+      if (gassign *ass = dyn_cast <gassign *> (stmt->stmt))\n+\t{\n+\t  *op = gimple_op (ass, operand + 1);\n+\t  /* ???  Ick.  But it will vanish with SLP only.  */\n+\t  if (TREE_CODE (*op) == VIEW_CONVERT_EXPR)\n+\t    *op = TREE_OPERAND (*op, 0);\n+\t}\n+      else if (gcall *call = dyn_cast <gcall *> (stmt->stmt))\n+\t*op = gimple_call_arg (call, operand);\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  /* ???  We might want to update *vectype from *slp_def here though\n+     when sharing nodes this would prevent unsharing in the caller.  */\n+  return vect_is_simple_use (*op, vinfo, dt, vectype, def_stmt_info_out);\n+}\n+\n+/* If OP is not NULL and is external or constant update its vector\n+   type with VECTYPE.  Returns true if successful or false if not,\n+   for example when conflicting vector types are present.  */\n+\n+bool\n+vect_maybe_update_slp_op_vectype (slp_tree op, tree vectype)\n+{\n+  if (!op || SLP_TREE_DEF_TYPE (op) == vect_internal_def)\n+    return true;\n+  if (SLP_TREE_VECTYPE (op))\n+    return types_compatible_p (SLP_TREE_VECTYPE (op), vectype);\n+  SLP_TREE_VECTYPE (op) = vectype;\n+  return true;\n+}\n \n /* Function supportable_widening_operation\n "}, {"sha": "2eb3ab5d280d9299e98fadd0d88d4f77a2be72b4", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f0451c67e8ed564b86a38581d5f3d57c5074d8/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=79f0451c67e8ed564b86a38581d5f3d57c5074d8", "patch": "@@ -1698,6 +1698,11 @@ extern bool vect_is_simple_use (tree, vec_info *, enum vect_def_type *,\n extern bool vect_is_simple_use (tree, vec_info *, enum vect_def_type *,\n \t\t\t\ttree *, stmt_vec_info * = NULL,\n \t\t\t\tgimple ** = NULL);\n+extern bool vect_is_simple_use (vec_info *, stmt_vec_info, slp_tree,\n+\t\t\t\tunsigned, tree *, slp_tree *,\n+\t\t\t\tenum vect_def_type *,\n+\t\t\t\ttree *, stmt_vec_info * = NULL);\n+extern bool vect_maybe_update_slp_op_vectype (slp_tree, tree);\n extern bool supportable_widening_operation (vec_info *,\n \t\t\t\t\t    enum tree_code, stmt_vec_info,\n \t\t\t\t\t    tree, tree, enum tree_code *,"}]}