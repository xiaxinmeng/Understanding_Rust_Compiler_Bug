{"sha": "0a7e721a6499a42f04361caf24772547afdeed57", "node_id": "C_kwDOANBUbNoAKDBhN2U3MjFhNjQ5OWE0MmYwNDM2MWNhZjI0NzcyNTQ3YWZkZWVkNTc", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-06-10T13:11:06Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-11T06:30:40Z"}, "message": "Implement global ranges for all vrange types (SSA_NAME_RANGE_INFO).\n\nCurrently SSA_NAME_RANGE_INFO only handles integer ranges, and loses\nhalf the precision in the process because its use of legacy\nvalue_range's.  This patch rewrites all the SSA_NAME_RANGE_INFO\n(nonzero bits included) to use the recently contributed\nvrange_storage.  With it, we'll be able to efficiently save any ranges\nsupported by ranger in GC memory.  Presently this will only be\nirange's, but shortly we'll add floating ranges and others to the mix.\n\nAs per the discussion with the trailing_wide_ints adjustments and\nvrange_storage, we'll be able to save integer ranges with a maximum of\n5 sub-ranges.  This could be adjusted later if more sub-ranges are\nneeded (unlikely).\n\nSince this is a behavior changing patch, I would like to take a few\ndays for discussion, and commit early next week if all goes well.\n\nA few notes.\n\nFirst, we get rid of the SSA_NAME_ANTI_RANGE_P bit in the SSA_NAME\nsince we store full resolution ranges.  Perhaps it could be re-used\nfor something else.\n\nThe range_info_def struct is gone in favor of an opaque type handled\nby vrange_storage.  It currently supports irange, but will support\nfrange, prange, etc, in due time.\n\nFrom the looks of it, set_range_info was an update operation despite\nits name, as we improved the nonzero bits with each call, even though\nwe clobbered the ranges.  Presumably this was because doing a proper\nintersect of ranges lost information with the anti-range hack.  We no\nlonger have this limitation so now we formalize both set_range_info\nand set_nonzero_bits to an update operation.  After all, we should\nnever be losing information, but enhancing it whenever possible.  This\nmeans, that if folks' finger-memory is not offended, as a follow-up,\nI'd like to rename set_nonzero_bits and set_range_info to update_*.\n\nI have kept the same global API we had in tree-ssanames.h, with the\ncaveat that all set operations are now update as discussed above.\n\nThere is a 2% performance penalty for evrp and a 3% penalty for VRP\nthat is coincidentally in line with a previous improvement of the same\namount in the vrange abstraction patchset.  Interestingly, this\npenalty is mostly due to the wide int to tree dance we keep doing with\nirange and legacy.  In a first draft of this patch where I was\nstreaming trees directly, there was actually a small improvement\ninstead.  I hope to get some of the gain back when we move irange's to\nwide-ints, though I'm not in a hurry ;-).\n\nTested and benchmarked on x86-64 Linux.  Tested on ppc64le Linux.\n\nComments welcome.\n\ngcc/ChangeLog:\n\n\t* gimple-range.cc (gimple_ranger::export_global_ranges): Remove\n\tverification against legacy value_range.\n\t(gimple_ranger::register_inferred_ranges): Same.\n\t(gimple_ranger::export_global_ranges): Rename update_global_range\n\tto set_range_info.\n\t* tree-core.h (struct range_info_def): Remove.\n\t(struct irange_storage_slot): New.\n\t(struct tree_base): Remove SSA_NAME_ANTI_RANGE_P documentation.\n\t(struct tree_ssa_name): Add vrange_storage support.\n\t* tree-ssanames.cc (range_info_p): New.\n\t(range_info_fits_p): New.\n\t(range_info_alloc): New.\n\t(range_info_free): New.\n\t(range_info_get_range): New.\n\t(range_info_set_range): New.\n\t(set_range_info_raw): Remove.\n\t(set_range_info): Adjust to use vrange_storage.\n\t(set_nonzero_bits): Same.\n\t(get_nonzero_bits): Same.\n\t(duplicate_ssa_name_range_info): Remove overload taking\n\tvalue_range_kind.\n\tRewrite tree overload to use vrange_storage.\n\t(duplicate_ssa_name_fn): Adjust to use vrange_storage.\n\t* tree-ssanames.h (struct range_info_def): Remove.\n\t(set_range_info): Adjust prototype to take vrange.\n\t* tree-vrp.cc (vrp_asserts::remove_range_assertions): Call\n\tduplicate_ssa_name_range_info.\n\t* tree.h (SSA_NAME_ANTI_RANGE_P): Remove.\n\t(SSA_NAME_RANGE_TYPE): Remove.\n\t* value-query.cc (get_ssa_name_range_info): Adjust to use\n\tvrange_storage.\n\t(update_global_range): Remove.\n\t(get_range_global): Remove as_a<irange>.\n\t* value-query.h (update_global_range): Remove.\n\t* tree-ssa-dom.cc (set_global_ranges_from_unreachable_edges):\n\tRename update_global_range to set_range_info.\n\t* value-range-storage.cc (vrange_storage::alloc_slot): Remove\n\tgcc_unreachable.", "tree": {"sha": "a6d9dd193377ac9d0c450b9af1d3965c10da587b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6d9dd193377ac9d0c450b9af1d3965c10da587b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a7e721a6499a42f04361caf24772547afdeed57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7e721a6499a42f04361caf24772547afdeed57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a7e721a6499a42f04361caf24772547afdeed57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7e721a6499a42f04361caf24772547afdeed57/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b53ebbc5417d522b820c269aee0d080bb2b27212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b53ebbc5417d522b820c269aee0d080bb2b27212", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b53ebbc5417d522b820c269aee0d080bb2b27212"}], "stats": {"total": 386, "additions": 149, "deletions": 237}, "files": [{"sha": "7ac48303e4e2ec6a09c68e87033a2ca77b64994c", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -468,22 +468,12 @@ gimple_ranger::register_inferred_ranges (gimple *s)\n     {\n       Value_Range tmp (TREE_TYPE (lhs));\n       if (range_of_stmt (tmp, s, lhs) && !tmp.varying_p ()\n-\t  && update_global_range (tmp, lhs) && dump_file)\n+\t  && set_range_info (lhs, tmp) && dump_file)\n \t{\n-\t  // ?? This section should be adjusted when non-iranges can\n-\t  // be exported.  For now, the only way update_global_range\n-\t  // above can succeed is with an irange so this is safe.\n-\t  value_range vr = as_a <irange> (tmp);\n \t  fprintf (dump_file, \"Global Exported: \");\n \t  print_generic_expr (dump_file, lhs, TDF_SLIM);\n \t  fprintf (dump_file, \" = \");\n-\t  vr.dump (dump_file);\n-\t  int_range_max same = vr;\n-\t  if (same != as_a <irange> (tmp))\n-\t    {\n-\t      fprintf (dump_file, \" ...  irange was : \");\n-\t      tmp.dump (dump_file);\n-\t    }\n+\t  tmp.dump (dump_file);\n \t  fputc ('\\n', dump_file);\n \t}\n     }\n@@ -509,7 +499,7 @@ gimple_ranger::export_global_ranges ()\n \t  && m_cache.get_global_range (r, name)\n \t  && !r.varying_p())\n \t{\n-\t  bool updated = update_global_range (r, name);\n+\t  bool updated = set_range_info (name, r);\n \t  if (!updated || !dump_file)\n \t    continue;\n \n@@ -522,22 +512,10 @@ gimple_ranger::export_global_ranges ()\n \t      print_header = false;\n \t    }\n \n-\t  if (!irange::supports_p (TREE_TYPE (name)))\n-\t    continue;\n-\n-\t  vrange &v = r;\n-\t  value_range vr = as_a <irange> (v);\n \t  print_generic_expr (dump_file, name , TDF_SLIM);\n \t  fprintf (dump_file, \"  : \");\n-\t  vr.dump (dump_file);\n+\t  r.dump (dump_file);\n \t  fprintf (dump_file, \"\\n\");\n-\t  int_range_max same = vr;\n-\t  if (same != as_a <irange> (v))\n-\t    {\n-\t      fprintf (dump_file, \"         irange : \");\n-\t      r.dump (dump_file);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n \t}\n     }\n }"}, {"sha": "ea9f281f1cc74d69f26e8caffd8ca86e0e1481a9", "filename": "gcc/tree-core.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -33,7 +33,7 @@ struct function;\n struct real_value;\n struct fixed_value;\n struct ptr_info_def;\n-struct range_info_def;\n+struct irange_storage_slot;\n struct die_struct;\n \n \n@@ -1194,9 +1194,6 @@ struct GTY(()) tree_base {\n        TRANSACTION_EXPR_OUTER in\n \t   TRANSACTION_EXPR\n \n-       SSA_NAME_ANTI_RANGE_P in\n-\t   SSA_NAME\n-\n        MUST_TAIL_CALL in\n \t   CALL_EXPR\n \n@@ -1594,8 +1591,12 @@ struct GTY(()) tree_ssa_name {\n   union ssa_name_info_type {\n     /* Pointer attributes used for alias analysis.  */\n     struct GTY ((tag (\"0\"))) ptr_info_def *ptr_info;\n-    /* Value range attributes used for zero/sign extension elimination.  */\n-    struct GTY ((tag (\"1\"))) range_info_def *range_info;\n+    /* This holds any range info supported by ranger (except ptr_info\n+       above) and is managed by vrange_storage.  */\n+    void * GTY ((skip)) range_info;\n+    /* GTY tag when the range in the range_info slot above satisfies\n+       irange::supports_type_p.  */\n+    struct GTY ((tag (\"1\"))) irange_storage_slot *irange_info;\n   } GTY ((desc (\"%1.typed.type ?\" \\\n \t\t\"!POINTER_TYPE_P (TREE_TYPE ((tree)&%1)) : 2\"))) info;\n "}, {"sha": "43acc756c96e7b1e19f29c3ac28e110931d3f0ae", "filename": "gcc/tree-ssa-dom.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-ssa-dom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-ssa-dom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.cc?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -1255,7 +1255,7 @@ dom_opt_dom_walker::set_global_ranges_from_unreachable_edges (basic_block bb)\n       && !r.varying_p ()\n       && !r.undefined_p ())\n     {\n-      update_global_range (r, name);\n+      set_range_info (name, r);\n       maybe_set_nonzero_bits (pred_e, name);\n     }\n }"}, {"sha": "9389454a5a715d641cb3cde5b36fe533045df79c", "filename": "gcc/tree-ssanames.cc", "status": "modified", "additions": 113, "deletions": 127, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-ssanames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-ssanames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.cc?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"value-query.h\"\n+#include \"value-range-storage.h\"\n \n /* Rewriting a function into SSA form can create a huge number of SSA_NAMEs,\n    many of which may be thrown away shortly after their creation if jumps\n@@ -71,6 +72,74 @@ unsigned int ssa_name_nodes_created;\n #define FREE_SSANAMES(fun) (fun)->gimple_df->free_ssanames\n #define FREE_SSANAMES_QUEUE(fun) (fun)->gimple_df->free_ssanames_queue\n \n+static ggc_vrange_allocator ggc_allocator;\n+static vrange_storage vstore (&ggc_allocator);\n+\n+/* Return TRUE if NAME has global range info.  */\n+\n+inline bool\n+range_info_p (const_tree name)\n+{\n+  return SSA_NAME_RANGE_INFO (name);\n+}\n+\n+/* Return TRUE if R fits in the global range of NAME.  */\n+\n+inline bool\n+range_info_fits_p (tree name, const vrange &r)\n+{\n+  gcc_checking_assert (range_info_p (name));\n+  void *mem = SSA_NAME_RANGE_INFO (name);\n+  return vrange_storage::fits_p (mem, r);\n+}\n+\n+/* Allocate a new global range for NAME and set it to R.  Return the\n+   allocation slot.  */\n+\n+inline void *\n+range_info_alloc (tree name, const vrange &r)\n+{\n+  void *mem = vstore.alloc_slot (r);\n+  SSA_NAME_RANGE_INFO (name) = mem;\n+  return mem;\n+}\n+\n+/* Free storage allocated for the global range for NAME.  */\n+\n+inline void\n+range_info_free (tree name)\n+{\n+  void *mem = SSA_NAME_RANGE_INFO (name);\n+  vstore.free (mem);\n+}\n+\n+/* Return the global range for NAME in R.  */\n+\n+inline void\n+range_info_get_range (tree name, vrange &r)\n+{\n+  vstore.get_vrange (SSA_NAME_RANGE_INFO (name), r, TREE_TYPE (name));\n+}\n+\n+/* Set the global range for NAME from R.  Return TRUE if successfull,\n+   or FALSE if we can't set a range of NAME's type.  */\n+\n+inline bool\n+range_info_set_range (tree name, const vrange &r)\n+{\n+  if (!range_info_p (name) || !range_info_fits_p (name, r))\n+    {\n+      if (range_info_p (name))\n+\trange_info_free (name);\n+\n+      return range_info_alloc (name, r);\n+    }\n+  else\n+    {\n+      vstore.set_vrange (SSA_NAME_RANGE_INFO (name), r);\n+      return true;\n+    }\n+}\n \n /* Initialize management of SSA_NAMEs to default SIZE.  If SIZE is\n    zero use default.  */\n@@ -343,94 +412,38 @@ make_ssa_name_fn (struct function *fn, tree var, gimple *stmt,\n   return t;\n }\n \n-/* Helper function for set_range_info.\n-\n-   Store range information RANGE_TYPE, MIN, and MAX to tree ssa_name\n-   NAME.  */\n-\n-void\n-set_range_info_raw (tree name, enum value_range_kind range_type,\n-\t\t    const wide_int_ref &min, const wide_int_ref &max)\n-{\n-  gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));\n-  gcc_assert (range_type == VR_RANGE || range_type == VR_ANTI_RANGE);\n-  range_info_def *ri = SSA_NAME_RANGE_INFO (name);\n-  unsigned int precision = TYPE_PRECISION (TREE_TYPE (name));\n-\n-  /* Allocate if not available.  */\n-  if (ri == NULL)\n-    {\n-      size_t size = (sizeof (range_info_def)\n-\t\t     + trailing_wide_ints <3>::extra_size (precision));\n-      ri = static_cast<range_info_def *> (ggc_internal_alloc (size));\n-      ri->ints.set_precision (precision);\n-      SSA_NAME_RANGE_INFO (name) = ri;\n-      ri->set_nonzero_bits (wi::shwi (-1, precision));\n-    }\n-\n-  /* Record the range type.  */\n-  if (SSA_NAME_RANGE_TYPE (name) != range_type)\n-    SSA_NAME_ANTI_RANGE_P (name) = (range_type == VR_ANTI_RANGE);\n+/* Update the range information for NAME, intersecting into an existing\n+   range if applicable.  Return TRUE if the range was updated.  */\n \n-  /* Set the values.  */\n-  ri->set_min (min);\n-  ri->set_max (max);\n-\n-  /* If it is a range, try to improve nonzero_bits from the min/max.  */\n-  if (range_type == VR_RANGE)\n-    {\n-      wide_int xorv = ri->get_min () ^ ri->get_max ();\n-      if (xorv != 0)\n-\txorv = wi::mask (precision - wi::clz (xorv), false, precision);\n-      ri->set_nonzero_bits (ri->get_nonzero_bits () & (ri->get_min () | xorv));\n-    }\n-}\n-\n-/* Store range information RANGE_TYPE, MIN, and MAX to tree ssa_name\n-   NAME while making sure we don't store useless range info.  */\n-\n-static void\n-set_range_info (tree name, enum value_range_kind range_type,\n-\t\tconst wide_int_ref &min, const wide_int_ref &max)\n+bool\n+set_range_info (tree name, const vrange &r)\n {\n-  gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));\n+  if (r.undefined_p () || r.varying_p ())\n+    return false;\n \n   tree type = TREE_TYPE (name);\n-  if (range_type == VR_VARYING)\n+  if (POINTER_TYPE_P (type))\n     {\n-      /* SSA_NAME_RANGE_TYPE can only hold a VR_RANGE or\n-\t VR_ANTI_RANGE.  Denormalize VR_VARYING to VR_RANGE.  */\n-      range_type = VR_RANGE;\n-      gcc_checking_assert (min == wi::min_value (type));\n-      gcc_checking_assert (max == wi::max_value (type));\n-    }\n-\n-  /* A range of the entire domain is really no range at all.  */\n-  if (min == wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type))\n-      && max == wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type)))\n-    {\n-      range_info_def *ri = SSA_NAME_RANGE_INFO (name);\n-      if (ri == NULL)\n-\treturn;\n-      if (ri->get_nonzero_bits () == -1)\n+      if (r.nonzero_p ())\n \t{\n-\t  ggc_free (ri);\n-\t  SSA_NAME_RANGE_INFO (name) = NULL;\n-\t  return;\n+\t  set_ptr_nonnull (name);\n+\t  return true;\n \t}\n+      return false;\n     }\n \n-  set_range_info_raw (name, range_type, min, max);\n-}\n-\n-/* Store range information for NAME from a value_range.  */\n+  /* If a global range already exists, incorporate it.  */\n+  if (range_info_p (name))\n+    {\n+      Value_Range tmp (type);\n+      range_info_get_range (name, tmp);\n+      tmp.intersect (r);\n+      if (tmp.undefined_p ())\n+\treturn false;\n \n-void\n-set_range_info (tree name, const value_range &vr)\n-{\n-  wide_int min = wi::to_wide (vr.min ());\n-  wide_int max = wi::to_wide (vr.max ());\n-  set_range_info (name, vr.kind (), min, max);\n+      return range_info_set_range (name, tmp);\n+    }\n+  return range_info_set_range (name, r);\n }\n \n /* Set nonnull attribute to pointer NAME.  */\n@@ -443,22 +456,16 @@ set_ptr_nonnull (tree name)\n   pi->pt.null = 0;\n }\n \n-/* Change non-zero bits bitmask of NAME.  */\n+/* Update the non-zero bits bitmask of NAME.  */\n \n void\n set_nonzero_bits (tree name, const wide_int_ref &mask)\n {\n   gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));\n-  if (SSA_NAME_RANGE_INFO (name) == NULL)\n-    {\n-      if (mask == -1)\n-\treturn;\n-      set_range_info_raw (name, VR_RANGE,\n-\t\t\t  wi::to_wide (TYPE_MIN_VALUE (TREE_TYPE (name))),\n-\t\t\t  wi::to_wide (TYPE_MAX_VALUE (TREE_TYPE (name))));\n-    }\n-  range_info_def *ri = SSA_NAME_RANGE_INFO (name);\n-  ri->set_nonzero_bits (mask);\n+\n+  int_range<2> r (TREE_TYPE (name));\n+  r.set_nonzero_bits (mask);\n+  set_range_info (name, r);\n }\n \n /* Return a widest_int with potentially non-zero bits in SSA_NAME\n@@ -482,10 +489,15 @@ get_nonzero_bits (const_tree name)\n       return wi::shwi (-1, precision);\n     }\n \n-  range_info_def *ri = SSA_NAME_RANGE_INFO (name);\n-  if (!ri)\n+  if (!range_info_p (name))\n     return wi::shwi (-1, precision);\n \n+  /* Optimization to get at the nonzero bits because we know the\n+     storage type.  This saves us measurable time compared to going\n+     through vrange_storage.  */\n+  gcc_checking_assert (irange::supports_p (TREE_TYPE (name)));\n+  irange_storage_slot *ri\n+    = static_cast <irange_storage_slot *> (SSA_NAME_RANGE_INFO (name));\n   return ri->get_nonzero_bits ();\n }\n \n@@ -727,38 +739,18 @@ duplicate_ssa_name_ptr_info (tree name, struct ptr_info_def *ptr_info)\n   SSA_NAME_PTR_INFO (name) = new_ptr_info;\n }\n \n-/* Creates a duplicate of the range_info_def at RANGE_INFO of type\n-   RANGE_TYPE for use by the SSA name NAME.  */\n-static void\n-duplicate_ssa_name_range_info (tree name, enum value_range_kind range_type,\n-\t\t\t       struct range_info_def *range_info)\n-{\n-  struct range_info_def *new_range_info;\n-\n-  gcc_assert (!POINTER_TYPE_P (TREE_TYPE (name)));\n-  gcc_assert (!SSA_NAME_RANGE_INFO (name));\n-\n-  if (!range_info)\n-    return;\n-\n-  unsigned int precision = TYPE_PRECISION (TREE_TYPE (name));\n-  size_t size = (sizeof (range_info_def)\n-\t\t + trailing_wide_ints <3>::extra_size (precision));\n-  new_range_info = static_cast<range_info_def *> (ggc_internal_alloc (size));\n-  memcpy (new_range_info, range_info, size);\n-\n-  gcc_assert (range_type == VR_RANGE || range_type == VR_ANTI_RANGE);\n-  SSA_NAME_ANTI_RANGE_P (name) = (range_type == VR_ANTI_RANGE);\n-  SSA_NAME_RANGE_INFO (name) = new_range_info;\n-}\n-\n void\n duplicate_ssa_name_range_info (tree name, tree src)\n {\n   gcc_checking_assert (!POINTER_TYPE_P (TREE_TYPE (src)));\n-  duplicate_ssa_name_range_info (name,\n-\t\t\t\t SSA_NAME_RANGE_TYPE (src),\n-\t\t\t\t SSA_NAME_RANGE_INFO (src));\n+  gcc_checking_assert (!range_info_p (name));\n+\n+  if (range_info_p (src))\n+    {\n+      Value_Range src_range (TREE_TYPE (src));\n+      range_info_get_range (src, src_range);\n+      range_info_set_range (name, src_range);\n+    }\n }\n \n \n@@ -776,14 +768,8 @@ duplicate_ssa_name_fn (struct function *fn, tree name, gimple *stmt)\n       if (old_ptr_info)\n \tduplicate_ssa_name_ptr_info (new_name, old_ptr_info);\n     }\n-  else\n-    {\n-      struct range_info_def *old_range_info = SSA_NAME_RANGE_INFO (name);\n-\n-      if (old_range_info)\n-\tduplicate_ssa_name_range_info (new_name, SSA_NAME_RANGE_TYPE (name),\n-\t\t\t\t       old_range_info);\n-    }\n+  else if (range_info_p (name))\n+    duplicate_ssa_name_range_info (new_name, name);\n \n   return new_name;\n }"}, {"sha": "ce10af9670a54bd18b308b0a976ade6b244b3dd1", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -45,16 +45,6 @@ struct GTY(()) ptr_info_def\n   unsigned int misalign;\n };\n \n-/* Value range information for SSA_NAMEs representing non-pointer variables.  */\n-\n-struct GTY ((variable_size)) range_info_def {\n-  /* Minimum, maximum and nonzero bits.  */\n-  TRAILING_WIDE_INT_ACCESSOR (min, ints, 0)\n-  TRAILING_WIDE_INT_ACCESSOR (max, ints, 1)\n-  TRAILING_WIDE_INT_ACCESSOR (nonzero_bits, ints, 2)\n-  trailing_wide_ints <3> ints;\n-};\n-\n \n #define SSANAMES(fun) (fun)->gimple_df->ssa_names\n #define DEFAULT_DEFS(fun) (fun)->gimple_df->default_defs\n@@ -67,7 +57,7 @@ struct GTY ((variable_size)) range_info_def {\n     if (VAR)\n \n /* Sets the value range to SSA.  */\n-extern void set_range_info (tree, const value_range &);\n+extern bool set_range_info (tree, const vrange &);\n extern void set_nonzero_bits (tree, const wide_int_ref &);\n extern wide_int get_nonzero_bits (const_tree);\n extern bool ssa_name_has_boolean_range (tree);"}, {"sha": "c3030a1b13054ce527f4102de633c642942bba4d", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -3739,16 +3739,18 @@ vrp_asserts::remove_range_assertions ()\n \t\t    && all_imm_uses_in_stmt_or_feed_cond (var, stmt,\n \t\t\t\t\t\t\t  single_pred (bb)))\n \t\t  {\n-\t\t    /* We could use duplicate_ssa_name_range_info here\n-\t\t       instead of peeking inside SSA_NAME_RANGE_INFO,\n-\t\t       but the aforementioned asserts that the\n-\t\t       destination has no global range.  This is\n-\t\t       slated for removal anyhow.  */\n-\t\t    value_range r (TREE_TYPE (lhs),\n-\t\t\t\t   SSA_NAME_RANGE_INFO (lhs)->get_min (),\n-\t\t\t\t   SSA_NAME_RANGE_INFO (lhs)->get_max (),\n-\t\t\t\t   SSA_NAME_RANGE_TYPE (lhs));\n-\t\t    set_range_info (var, r);\n+\t\t    if (SSA_NAME_RANGE_INFO (var))\n+\t\t      {\n+\t\t\t/* ?? This is a minor wart exposing the\n+\t\t\t   internals of SSA_NAME_RANGE_INFO in order\n+\t\t\t   to maintain existing behavior.  This is\n+\t\t\t   because duplicate_ssa_name_range_info below\n+\t\t\t   needs a NULL destination range.  This is\n+\t\t\t   all slated for removal...  */\n+\t\t\tggc_free (SSA_NAME_RANGE_INFO (var));\n+\t\t\tSSA_NAME_RANGE_INFO (var) = NULL;\n+\t\t      }\n+\t\t    duplicate_ssa_name_range_info (var, lhs);\n \t\t    maybe_set_nonzero_bits (single_pred_edge (bb), var);\n \t\t  }\n \t      }"}, {"sha": "e6564aaccb7b69cd938ff60b6121aec41b7e8a59", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -2030,14 +2030,6 @@ class auto_suppress_location_wrappers\n #define SSA_NAME_PTR_INFO(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.info.ptr_info\n \n-/* True if SSA_NAME_RANGE_INFO describes an anti-range.  */\n-#define SSA_NAME_ANTI_RANGE_P(N) \\\n-    SSA_NAME_CHECK (N)->base.static_flag\n-\n-/* The type of range described by SSA_NAME_RANGE_INFO.  */\n-#define SSA_NAME_RANGE_TYPE(N) \\\n-    (SSA_NAME_ANTI_RANGE_P (N) ? VR_ANTI_RANGE : VR_RANGE)\n-\n /* Value range info attributes for SSA_NAMEs of non pointer-type variables.  */\n #define SSA_NAME_RANGE_INFO(N) \\\n     SSA_NAME_CHECK (N)->ssa_name.info.range_info"}, {"sha": "51911bdd1d0f21ff7b27189930a9157dbeb18014", "filename": "gcc/value-query.cc", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-query.h\"\n #include \"alloc-pool.h\"\n #include \"gimple-range.h\"\n+#include \"value-range-storage.h\"\n \n // value_query default methods.\n \n@@ -271,23 +272,24 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n // Return the range for NAME from SSA_NAME_RANGE_INFO.\n \n static inline void\n-get_ssa_name_range_info (irange &r, const_tree name)\n+get_ssa_name_range_info (vrange &r, const_tree name)\n {\n   tree type = TREE_TYPE (name);\n   gcc_checking_assert (!POINTER_TYPE_P (type));\n   gcc_checking_assert (TREE_CODE (name) == SSA_NAME);\n \n-  range_info_def *ri = SSA_NAME_RANGE_INFO (name);\n+  void *ri = SSA_NAME_RANGE_INFO (name);\n \n   // Return VR_VARYING for SSA_NAMEs with NULL RANGE_INFO or SSA_NAMEs\n   // with integral types width > 2 * HOST_BITS_PER_WIDE_INT precision.\n   if (!ri || (GET_MODE_PRECISION (SCALAR_INT_TYPE_MODE (TREE_TYPE (name)))\n \t      > 2 * HOST_BITS_PER_WIDE_INT))\n     r.set_varying (type);\n   else\n-    r.set (wide_int_to_tree (type, ri->get_min ()),\n-\t   wide_int_to_tree (type, ri->get_max ()),\n-\t   SSA_NAME_RANGE_TYPE (name));\n+    {\n+      vrange_storage vstore (NULL);\n+      vstore.get_vrange (ri, r, TREE_TYPE (name));\n+    }\n }\n \n // Return nonnull attribute of pointer NAME from SSA_NAME_PTR_INFO.\n@@ -311,43 +313,6 @@ get_ssa_name_ptr_info_nonnull (const_tree name)\n }\n \n // Update the global range for NAME into the SSA_RANGE_NAME_INFO and\n-// SSA_NAME_PTR_INFO fields.  Return TRUE if the range for NAME was\n-// updated.\n-\n-bool\n-update_global_range (vrange &r, tree name)\n-{\n-  tree type = TREE_TYPE (name);\n-\n-  if (r.undefined_p () || r.varying_p ())\n-    return false;\n-\n-  if (INTEGRAL_TYPE_P (type))\n-    {\n-      // If a global range already exists, incorporate it.\n-      if (SSA_NAME_RANGE_INFO (name))\n-\t{\n-\t  value_range glob;\n-\t  get_ssa_name_range_info (glob, name);\n-\t  r.intersect (glob);\n-\t}\n-      if (r.undefined_p ())\n-\treturn false;\n-\n-      set_range_info (name, as_a <irange> (r));\n-      return true;\n-    }\n-  else if (POINTER_TYPE_P (type))\n-    {\n-      if (r.nonzero_p ())\n-\t{\n-\t  set_ptr_nonnull (name);\n-\t  return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n // Return the legacy global range for NAME if it has one, otherwise\n // return VARYING.\n \n@@ -372,7 +337,7 @@ get_range_global (vrange &r, tree name)\n \t    r.set_nonzero (type);\n \t  else if (INTEGRAL_TYPE_P (type))\n \t    {\n-\t      get_ssa_name_range_info (as_a <irange> (r), name);\n+\t      get_ssa_name_range_info (r, name);\n \t      if (r.undefined_p ())\n \t\tr.set_varying (type);\n \t    }\n@@ -387,8 +352,7 @@ get_range_global (vrange &r, tree name)\n    }\n   else if (!POINTER_TYPE_P (type) && SSA_NAME_RANGE_INFO (name))\n     {\n-      gcc_checking_assert (irange::supports_p (TREE_TYPE (name)));\n-      get_ssa_name_range_info (as_a <irange> (r), name);\n+      get_ssa_name_range_info (r, name);\n       if (r.undefined_p ())\n \tr.set_varying (type);\n     }"}, {"sha": "fc638eb76b1e6909db96acda9a5e3dfdbb51947a", "filename": "gcc/value-query.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -144,6 +144,5 @@ get_range_query (const struct function *fun)\n }\n \n extern void gimple_range_global (vrange &v, tree name);\n-extern bool update_global_range (vrange &v, tree name);\n \n #endif // GCC_QUERY_H"}, {"sha": "8b5ab544ce334d80e4a5c1c45ee4801718907bb3", "filename": "gcc/value-range-storage.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Fvalue-range-storage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a7e721a6499a42f04361caf24772547afdeed57/gcc%2Fvalue-range-storage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.cc?ref=0a7e721a6499a42f04361caf24772547afdeed57", "patch": "@@ -30,7 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-range.h\"\n #include \"value-range-storage.h\"\n \n-// Return a newly allocated slot holding R.\n+// Return a newly allocated slot holding R, or NULL if storing a range\n+// of R's type is not supported.\n \n void *\n vrange_storage::alloc_slot (const vrange &r)\n@@ -40,7 +41,6 @@ vrange_storage::alloc_slot (const vrange &r)\n   if (is_a <irange> (r))\n     return irange_storage_slot::alloc_slot (*m_alloc, as_a <irange> (r));\n \n-  gcc_unreachable ();\n   return NULL;\n }\n "}]}