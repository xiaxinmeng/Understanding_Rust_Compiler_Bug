{"sha": "ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEwNmIwZWQ3NTBhZmQ1Y2M0YzhhYTMzYTZlNjlkMDZkMzhlZGZkZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-06-26T23:14:21Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-06-26T23:14:21Z"}, "message": "pa.h (CMP_PSI): Delete.\n\n        * pa/pa.h (CMP_PSI): Delete.\n        (FUNCTION_POINTER_COMPARISON_MODE): Likewise.\n        * pa/pa.md (cmppsi); Delete expander.\n        (canonicalize_funcptr_for_compare): Renamed from plabel_dereference,\n        turned into an expander + anonymous pattern.\n\nFrom-SVN: r12334", "tree": {"sha": "9bb9f2f472b812d2cd3204b02d1bc4fb4185de39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bb9f2f472b812d2cd3204b02d1bc4fb4185de39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde/comments", "author": null, "committer": null, "parents": [{"sha": "cd8a6bdfe9a6be3bf206a3988d121cb95d4dea90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8a6bdfe9a6be3bf206a3988d121cb95d4dea90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8a6bdfe9a6be3bf206a3988d121cb95d4dea90"}], "stats": {"total": 99, "additions": 31, "deletions": 68}, "files": [{"sha": "f30da47ddb7835b9fcfa4eed5dfe96234f8d2d2a", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde", "patch": "@@ -23,8 +23,6 @@ Boston, MA 02111-1307, USA.  */\n \n enum cmp_type\t\t\t\t/* comparison type */\n {\n-  /* See FUNCTION_POINTER_COMPARISON_MODE for info on CMP_PSI.  */\n-  CMP_PSI,\t\t\t\t/* For function pointers.  */\n   CMP_SI,\t\t\t\t/* compare integers */\n   CMP_SF,\t\t\t\t/* compare single precision floats */\n   CMP_DF,\t\t\t\t/* compare double precision floats */\n@@ -1669,26 +1667,6 @@ while (0)\n    between pointers and any other objects of this machine mode.  */\n #define Pmode SImode\n \n-/* XXX FIXME.  The function pointer comparison code is only at the FSF\n-   for documentation and merging purposes, it is _NOT_ actually used.\n-\n-   I've been trying to get Kenner to deal with the machine independent\n-   problems for many months, and for whatever reason nothing ever seems\n-   to happen.\n-\n-   If you want function pointer comparisons to work, first scream at\n-   Kenner to deal with the MI problems, then email me for a hack that\n-   will get the job done (law@cygnus.com).\n-   \n-  The mode in which function pointer comparisons occur.  The PA backend\n-   uses this mode to identify function pointer comparisons so that special\n-   code needed to compare functions can be generated.\n-\n-   Note, special code is not needed for function pointer comparisons\n-   in the portable runtime model.  */\n-#define FUNCTION_POINTER_COMPARISON_MODE \\\n-  (TARGET_PORTABLE_RUNTIME ? Pmode : PSImode)\n-\n /* Add any extra modes needed to represent the condition code.\n \n    HPPA floating comparisons produce condition codes. */"}, {"sha": "79ebbcc08ca0cca033c4a9230768e09abc957296", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 31, "deletions": 46, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=ea06b0ed750afd5cc4c8aa33a6e69d06d38edfde", "patch": "@@ -340,44 +340,6 @@\n ;; emit RTL for both the compare and the branch.\n ;;\n \n-;; This expander is not used by the FSF compiler, refer to\n-;; FUNCTION_POINTER_COMPARISON_MODE in pa.h for a brief discussion why.\n-(define_expand \"cmppsi\"\n-  [(set (reg:CC 0)\n-\t(compare:CC (match_operand:SI 0 \"reg_or_0_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"reg_or_0_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  rtx res0, res1;\n-\n-  /* We need two new pseudos to hold the value of the dereferenced\n-     plabel.  */\n-  res0 = gen_reg_rtx (Pmode);\n-  res1 = gen_reg_rtx (Pmode);\n-\n-  /* Move the first function pointer into %r26 and call the\n-     magic millicode routine to get the function's actual\n-     address.   Copy the result from %r29 into the first\n-     psuedo.  */\n-  emit_move_insn (gen_rtx (REG, Pmode, 26), operands[0]);\n-  emit_insn (gen_plabel_dereference (gen_reg_rtx (SImode)));\n-  emit_move_insn (res0, gen_rtx (REG, Pmode, 29));\n-\n-  /* Likewise for the second function pointer. */\n-  emit_move_insn (gen_rtx (REG, Pmode, 26), operands[1]);\n-  emit_insn (gen_plabel_dereference (gen_reg_rtx (SImode)));\n-  emit_move_insn (res1, gen_rtx (REG, Pmode, 29));\n-\n-  /* Put the results in hppa_compare_op0 and hppa_compare_op1.  */\n-  hppa_compare_op0 = res0;\n-  hppa_compare_op1 = res1;\n-  /* The branch is really a SImode branch.  PSImode was used just\n-     so we could identify this as a function pointer comparison.  */\n- hppa_branch_type = CMP_SI;\n- DONE;\n-}\")\n-\n (define_expand \"cmpsi\"\n   [(set (reg:CC 0)\n \t(compare:CC (match_operand:SI 0 \"reg_or_0_operand\" \"\")\n@@ -5300,15 +5262,38 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n-/* Given a function pointer (aka plabel) in %r26, return (in %r29) the\n-   actual address of the function that would be called if the function\n-   pointer was used in an indirect call.\n \n-   We must show %r1 as clobbered since the linker might insert a stub\n-   in the call path that clobbers %r1 (yes, it really happens).  */\n-;; This expander is not used by the FSF compiler, refer to\n-;; FUNCTION_POINTER_COMPARISON_MODE in pa.h for a brief discussion why.\n-(define_insn \"plabel_dereference\"\n+;; XXX FIXME.  The function pointer comparison code is only at the FSF\n+;; for documentation and merging purposes, it is _NOT_ actually used.\n+;;\n+;; I've been trying to get Kenner to deal with the machine independent\n+;; problems for many months, and for whatever reason nothing ever seems\n+;; to happen.\n+;;\n+;; If you want function pointer comparisons to work, first scream at\n+;; Kenner to deal with the MI problems, then email me for a hack that\n+;; will get the job done (law@cygnus.com).\n+\n+;; Given a function pointer, canonicalize it so it can be \n+;; reliably compared to another function pointer.  */\n+(define_expand \"canonicalize_funcptr_for_compare\"\n+  [(set (reg:SI 26) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (parallel [(set (reg:SI 29) (unspec:SI [(reg:SI 26)] 0))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (reg:SI 26))\n+\t      (clobber (reg:SI 22))\n+\t      (clobber (reg:SI 31))])\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(reg:SI 29))]\n+  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (SImode);\n+  if (GET_CODE (operands[1]) != REG)\n+    force_reg (SImode, operands[1]);\n+}\")\n+\n+(define_insn \"\"\n   [(set (reg:SI 29) (unspec:SI [(reg:SI 26)] 0))\n    (clobber (match_operand:SI 0 \"register_operand\" \"=a\"))\n    (clobber (reg:SI 26))"}]}