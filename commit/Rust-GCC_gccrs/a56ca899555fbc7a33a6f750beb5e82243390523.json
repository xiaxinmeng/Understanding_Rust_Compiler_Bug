{"sha": "a56ca899555fbc7a33a6f750beb5e82243390523", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU2Y2E4OTk1NTVmYmM3YTMzYTZmNzUwYmViNWU4MjI0MzM5MDUyMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-12-24T20:52:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-12-24T20:52:36Z"}, "message": "re PR c++/160 (Reference variables not initialized correctly in constructor initializer list using , operator)\n\ncp:\n\tPR c++/160\n\t* typeck.c (build_modify_expr): Remove old unreachable code & tidy\n\tup. Don't stabilize_references when initializing a reference.\ntestsuite:\n\t* g++.dg/other/init2.C: New test.\n\nFrom-SVN: r48307", "tree": {"sha": "b6534364532f0b110ed850c1f6aa4570527c10c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6534364532f0b110ed850c1f6aa4570527c10c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a56ca899555fbc7a33a6f750beb5e82243390523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56ca899555fbc7a33a6f750beb5e82243390523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a56ca899555fbc7a33a6f750beb5e82243390523", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a56ca899555fbc7a33a6f750beb5e82243390523/comments", "author": null, "committer": null, "parents": [{"sha": "fdfc290b947e036ff15e9b221f64d2bcb8c9fabc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdfc290b947e036ff15e9b221f64d2bcb8c9fabc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdfc290b947e036ff15e9b221f64d2bcb8c9fabc"}], "stats": {"total": 261, "additions": 137, "deletions": 124}, "files": [{"sha": "529a36243d73f7f7cf775b6c21160906d928505c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ca899555fbc7a33a6f750beb5e82243390523/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ca899555fbc7a33a6f750beb5e82243390523/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a56ca899555fbc7a33a6f750beb5e82243390523", "patch": "@@ -1,3 +1,9 @@\n+2001-12-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/160\n+\t* typeck.c (build_modify_expr): Remove old unreachable code & tidy\n+\tup. Don't stabilize_references when initializing a reference.\n+\n 2001-12-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl2.c (lang_f_options): Const-ify."}, {"sha": "fefa72e1c419d2622d0da3f2587aa83605a4a5a3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 78, "deletions": 124, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ca899555fbc7a33a6f750beb5e82243390523/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ca899555fbc7a33a6f750beb5e82243390523/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a56ca899555fbc7a33a6f750beb5e82243390523", "patch": "@@ -5494,13 +5494,7 @@ build_modify_expr (lhs, modifycode, rhs)\n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n \n-  /* Types that aren't fully specified cannot be used in assignments.  */\n-  lhs = require_complete_type (lhs);\n-\n-  newrhs = rhs;\n-\n   /* Handle control structure constructs used as \"lvalues\".  */\n-\n   switch (TREE_CODE (lhs))\n     {\n       /* Handle --foo = 5; as these are valid constructs in C++ */\n@@ -5532,13 +5526,14 @@ build_modify_expr (lhs, modifycode, rhs)\n \n       /* Handle (a ? b : c) used as an \"lvalue\".  */\n     case COND_EXPR:\n-      rhs = save_expr (rhs);\n       {\n \t/* Produce (a ? (b = rhs) : (c = rhs))\n \t   except that the RHS goes through a save-expr\n \t   so the code to compute it is only emitted once.  */\n \ttree cond;\n \n+\trhs = save_expr (rhs);\n+\t\n \t/* Check this here to avoid odd errors when trying to convert\n \t   a throw to the type of the COND_EXPR.  */\n \tif (!lvalue_or_else (lhs, \"assignment\"))\n@@ -5558,54 +5553,27 @@ build_modify_expr (lhs, modifycode, rhs)\n \t/* Make sure the code to compute the rhs comes out\n \t   before the split.  */\n \treturn build (COMPOUND_EXPR, TREE_TYPE (lhs),\n-\t\t      /* Case to void to suppress warning\n+\t\t      /* Cast to void to suppress warning\n \t\t\t from warn_if_unused_value.  */\n \t\t      cp_convert (void_type_node, rhs), cond);\n       }\n-\n+      \n+    case OFFSET_REF:\n+      lhs = resolve_offset_ref (lhs);\n+      if (lhs == error_mark_node)\n+\treturn error_mark_node;\n+      olhstype = lhstype = TREE_TYPE (lhs);\n+    \n     default:\n       break;\n     }\n \n-  if (TREE_CODE (lhs) == OFFSET_REF)\n-    {\n-      if (TREE_OPERAND (lhs, 0) == NULL_TREE)\n-\t{\n-\t  /* Static class member?  */\n-\t  tree member = TREE_OPERAND (lhs, 1);\n-\t  if (TREE_CODE (member) == VAR_DECL)\n-\t    lhs = member;\n-\t  else\n-\t    {\n-\t      compiler_error (\"invalid static class member\");\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-      else\n-\tlhs = resolve_offset_ref (lhs);\n-\n-      olhstype = lhstype = TREE_TYPE (lhs);\n-    }\n-\n-  if (lhs == error_mark_node)\n-    return lhs;\n-\n-  if (TREE_CODE (lhstype) == REFERENCE_TYPE\n-      && modifycode != INIT_EXPR)\n-    {\n-      lhs = convert_from_reference (lhs);\n-      olhstype = lhstype = TREE_TYPE (lhs);\n-    }\n-\n-  /* If a binary op has been requested, combine the old LHS value with the RHS\n-     producing the value we should actually store into the LHS.  */\n-\n   if (modifycode == INIT_EXPR)\n     {\n       if (TREE_CODE (rhs) == CONSTRUCTOR)\n \t{\n-\t  if (! same_type_p (TREE_TYPE (rhs), lhstype))\n-\t    abort ();\n+\t  my_friendly_assert (same_type_p (TREE_TYPE (rhs), lhstype),\n+\t\t\t      20011220);\n \t  result = build (INIT_EXPR, lhstype, lhs, rhs);\n \t  TREE_SIDE_EFFECTS (result) = 1;\n \t  return result;\n@@ -5622,35 +5590,55 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  return result;\n \t}\n     }\n-  else if (modifycode == NOP_EXPR)\n+  else\n     {\n-      /* `operator=' is not an inheritable operator.  */\n-      if (! IS_AGGR_TYPE (lhstype))\n-\t/* Do the default thing */;\n-      else\n+      if (TREE_CODE (lhstype) == REFERENCE_TYPE)\n \t{\n-\t  result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t\t   lhs, rhs, make_node (NOP_EXPR));\n-\t  if (result == NULL_TREE)\n-\t    return error_mark_node;\n-\t  return result;\n+\t  lhs = convert_from_reference (lhs);\n+\t  olhstype = lhstype = TREE_TYPE (lhs);\n \t}\n-      lhstype = olhstype;\n-    }\n-  else if (PROMOTES_TO_AGGR_TYPE (lhstype, REFERENCE_TYPE))\n-    {\n-      my_friendly_abort (978652);\n-    }\n-  else\n-    {\n-      lhs = stabilize_reference (lhs);\n-      newrhs = cp_build_binary_op (modifycode, lhs, rhs);\n-      if (newrhs == error_mark_node)\n+      lhs = require_complete_type (lhs);\n+      if (lhs == error_mark_node)\n+\treturn error_mark_node;\n+\n+      if (modifycode == NOP_EXPR)\n \t{\n-\t  error (\"  in evaluation of `%Q(%#T, %#T)'\", modifycode,\n-\t\t    TREE_TYPE (lhs), TREE_TYPE (rhs));\n-\t  return error_mark_node;\n+\t  /* `operator=' is not an inheritable operator.  */\n+\t  if (! IS_AGGR_TYPE (lhstype))\n+\t    /* Do the default thing */;\n+\t  else\n+\t    {\n+\t      result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n+\t\t\t\t       lhs, rhs, make_node (NOP_EXPR));\n+\t      if (result == NULL_TREE)\n+\t\treturn error_mark_node;\n+\t      return result;\n+\t    }\n+\t  lhstype = olhstype;\n+\t}\n+      else\n+\t{\n+\t  /* A binary op has been requested.  Combine the old LHS\n+     \t     value with the RHS producing the value we should actually\n+     \t     store into the LHS.  */\n+\n+\t  my_friendly_assert (!PROMOTES_TO_AGGR_TYPE (lhstype, REFERENCE_TYPE),\n+\t\t\t      978652);\n+\t  lhs = stabilize_reference (lhs);\n+\t  newrhs = cp_build_binary_op (modifycode, lhs, rhs);\n+\t  if (newrhs == error_mark_node)\n+\t    {\n+\t      error (\"  in evaluation of `%Q(%#T, %#T)'\", modifycode,\n+\t\t     TREE_TYPE (lhs), TREE_TYPE (rhs));\n+\t      return error_mark_node;\n+\t    }\n+\t  \n+\t  /* Now it looks like a plain assignment.  */\n+\t  modifycode = NOP_EXPR;\n \t}\n+      my_friendly_assert (TREE_CODE (lhstype) != REFERENCE_TYPE, 20011220);\n+      my_friendly_assert (TREE_CODE (TREE_TYPE (newrhs)) != REFERENCE_TYPE,\n+\t\t\t  20011220);\n     }\n \n   /* Handle a cast used as an \"lvalue\".\n@@ -5669,15 +5657,16 @@ build_modify_expr (lhs, modifycode, rhs)\n     case FIX_FLOOR_EXPR:\n     case FIX_ROUND_EXPR:\n     case FIX_CEIL_EXPR:\n-      if (TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n-\t  || TREE_CODE (TREE_TYPE (newrhs)) == FUNCTION_TYPE\n-\t  || TREE_CODE (TREE_TYPE (newrhs)) == METHOD_TYPE\n-\t  || TREE_CODE (TREE_TYPE (newrhs)) == OFFSET_TYPE)\n-\tnewrhs = default_conversion (newrhs);\n       {\n \ttree inner_lhs = TREE_OPERAND (lhs, 0);\n \ttree result;\n \n+\tif (TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n+\t    || TREE_CODE (TREE_TYPE (newrhs)) == FUNCTION_TYPE\n+\t    || TREE_CODE (TREE_TYPE (newrhs)) == METHOD_TYPE\n+\t    || TREE_CODE (TREE_TYPE (newrhs)) == OFFSET_TYPE)\n+\t  newrhs = default_conversion (newrhs);\n+\t\n \t/* ISO C++ 5.4/1: The result is an lvalue if T is a reference\n \t   type, otherwise the result is an rvalue.  */\n \tif (! lvalue_p (lhs))\n@@ -5703,23 +5692,23 @@ build_modify_expr (lhs, modifycode, rhs)\n \n   GNU_xref_assign (lhs);\n \n-  /* Warn about storing in something that is `const'.  */\n-  /* For C++, don't warn if this is initialization.  */\n+  /* Warn about modifying something that is `const'.  Don't warn if\n+     this is initialization.  */\n   if (modifycode != INIT_EXPR\n       && (TREE_READONLY (lhs) || CP_TYPE_CONST_P (lhstype)\n \t  /* Functions are not modifiable, even though they are\n \t     lvalues.  */\n \t  || TREE_CODE (TREE_TYPE (lhs)) == FUNCTION_TYPE\n+\t  || TREE_CODE (TREE_TYPE (lhs)) == METHOD_TYPE\n+\t  /* If it's an aggregate and any field is const, then it is\n+\t     effectively const.  */\n \t  || (IS_AGGR_TYPE_CODE (TREE_CODE (lhstype))\n-\t      && C_TYPE_FIELDS_READONLY (lhstype))\n-\t  || (TREE_CODE (lhstype) == REFERENCE_TYPE\n-\t      && CP_TYPE_CONST_P (TREE_TYPE (lhstype)))))\n+\t      && C_TYPE_FIELDS_READONLY (lhstype))))\n     readonly_error (lhs, \"assignment\", 0);\n \n-  /* If storing into a structure or union member,\n-     it has probably been given type `int'.\n-     Compute the type that would go with\n-     the actual amount of storage the member occupies.  */\n+  /* If storing into a structure or union member, it has probably been\n+     given type `int'.  Compute the type that would go with the actual\n+     amount of storage the member occupies.  */\n \n   if (TREE_CODE (lhs) == COMPONENT_REF\n       && (TREE_CODE (lhstype) == INTEGER_TYPE\n@@ -5738,40 +5727,14 @@ build_modify_expr (lhs, modifycode, rhs)\n \t}\n     }\n \n-  if (modifycode != INIT_EXPR)\n+  if (TREE_CODE (lhstype) != REFERENCE_TYPE)\n     {\n-      /* Make modifycode now either a NOP_EXPR or an INIT_EXPR.  */\n-      modifycode = NOP_EXPR;\n-      /* Reference-bashing */\n-      if (TREE_CODE (lhstype) == REFERENCE_TYPE)\n-\t{\n-\t  tree tmp = convert_from_reference (lhs);\n-\t  lhstype = TREE_TYPE (tmp);\n-\t  if (!COMPLETE_TYPE_P (lhstype))\n-\t    {\n-\t      incomplete_type_error (lhs, lhstype);\n-\t      return error_mark_node;\n-\t    }\n-\t  lhs = tmp;\n-\t  olhstype = lhstype;\n-\t}\n-      if (TREE_CODE (TREE_TYPE (newrhs)) == REFERENCE_TYPE)\n-\t{\n-\t  tree tmp = convert_from_reference (newrhs);\n-\t  if (!COMPLETE_TYPE_P (TREE_TYPE (tmp)))\n-\t    {\n-\t      incomplete_type_error (newrhs, TREE_TYPE (tmp));\n-\t      return error_mark_node;\n-\t    }\n-\t  newrhs = tmp;\n-\t}\n+      if (TREE_SIDE_EFFECTS (lhs))\n+\tlhs = stabilize_reference (lhs);\n+      if (TREE_SIDE_EFFECTS (newrhs))\n+\tnewrhs = stabilize_reference (newrhs);\n     }\n \n-  if (TREE_SIDE_EFFECTS (lhs))\n-    lhs = stabilize_reference (lhs);\n-  if (TREE_SIDE_EFFECTS (newrhs))\n-    newrhs = stabilize_reference (newrhs);\n-\n   /* Convert new value to destination type.  */\n \n   if (TREE_CODE (lhstype) == ARRAY_TYPE)\n@@ -5795,17 +5758,8 @@ build_modify_expr (lhs, modifycode, rhs)\n     }\n \n   if (modifycode == INIT_EXPR)\n-    {\n-      newrhs = convert_for_initialization (lhs, lhstype, newrhs, LOOKUP_NORMAL,\n-\t\t\t\t\t   \"initialization\", NULL_TREE, 0);\n-      if (current_function_decl && \n-\t  lhs == DECL_RESULT (current_function_decl))\n-\t{\n-\t  if (DECL_INITIAL (lhs))\n-\t    warning (\"return value from function receives multiple initializations\");\n-\t  DECL_INITIAL (lhs) = newrhs;\n-\t}\n-    }\n+    newrhs = convert_for_initialization (lhs, lhstype, newrhs, LOOKUP_NORMAL,\n+\t\t\t\t\t \"initialization\", NULL_TREE, 0);\n   else\n     {\n       /* Avoid warnings on enum bit fields.  */"}, {"sha": "a022e893476209f15834752bb38b57e9cb7c67e5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ca899555fbc7a33a6f750beb5e82243390523/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ca899555fbc7a33a6f750beb5e82243390523/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a56ca899555fbc7a33a6f750beb5e82243390523", "patch": "@@ -1,3 +1,7 @@\n+2001-12-24  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/other/init2.C: New test.\n+\n 2001-12-24  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.dg/20011223-1.c: New."}, {"sha": "0b85aa67d0ac03396e7f2109c39f93efd79d0004", "filename": "gcc/testsuite/g++.dg/other/init2.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a56ca899555fbc7a33a6f750beb5e82243390523/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Finit2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a56ca899555fbc7a33a6f750beb5e82243390523/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Finit2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Finit2.C?ref=a56ca899555fbc7a33a6f750beb5e82243390523", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 20 Dec 2001 <nathan@nathan@codesourcery.com>\n+\n+// PR 160. Wrong code emitted for some reference initializers.\n+\n+void Foo ()\n+{\n+}\n+\n+int fail;\n+\n+class C\n+{\n+  public:\n+  int m;\n+  int &r;\n+  \n+  C () ;\n+};\n+\n+C::C ()\n+  : m (1), r ((Foo (), m))\n+{\n+  m = 10;\n+  \n+  if (r != m)\n+    fail = 1;\n+  else if (&m != &r)\n+    fail = 2;\n+}\n+int main ()\n+{\n+  int m (1);\n+  int &r ((Foo (),m));\n+\n+  m = 10;\n+  if (r != m)\n+    fail = 3;\n+  else if (&r != &m)\n+    fail = 4;\n+\n+  if (!fail)\n+    {\n+      C c;\n+    }\n+  return fail;\n+}"}]}