{"sha": "584d52b088f9fcf78704b504c3f1f07e17c1cded", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg0ZDUyYjA4OGY5ZmNmNzg3MDRiNTA0YzNmMWYwN2UxN2MxY2RlZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-05-23T08:00:32Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-05-23T08:40:16Z"}, "message": "libstdc++: Refactor filesystem::path string conversions\n\nThis simplifies the logic of converting Source arguments and pairs of\nInputIterator arguments into the native string format. For any input\nthat is a contiguous range of path::value_type (or char8_t for POSIX)\na string view can be created and the conversion can be done directly,\nwith no intermediate allocation. Previously some cases created a\nbasic_string unnecessarily, for example construction from a pair of\npath::string_type::iterators, or a pair of non-const value_type*\npointers.\n\n\t* include/bits/fs_path.h (__detail::_S_range_begin)\n\t(__detail::_S_range_end, path::_S_string_from_iter): Replace with\n\toverloaded function template __detail::__effective_range.\n\t(__detail::__effective_range): New overloaded function template to\n\tcreate a basic_string or basic_string_view for an effective range.\n\t(__detail::__value_type_is_char): Use __detail::__effective_range.\n\tDo not use remove_const on value type.\n\t(__detail::__value_type_is_char_or_char8_t): Likewise.\n\t(path::path(const Source&, format))\n\t(path::path(const Source&, const locale&))\n\t(path::operator/=(const Source&), path::append(const Source&))\n\t(path::concat(const Source&)): Use __detail::__effective_range.\n\t(path::_S_to_string(InputIterator, InputIterator)): New function\n\ttemplate to create a string view if possible, or string otherwise.\n\t(path::_S_convert): Add overloads that convert a string returned\n\tby __detail::__effective_range. Use if-constexpr to inline conversion\n\tlogic from all overloads of _Cvt::_S_convert.\n\t(path::_S_convert_loc): Add overload that converts a string. Use\n\t_S_to_string to avoid allocation when possible.\n\t(path::_Cvt): Remove.\n\t(path::operator+=(CharT)): Remove indirection through path::concat.\n\t* include/experimental/bits/fs_path.h (path::_S_convert_loc): Add\n\toverload for non-const pointers, to avoid constructing a std::string.\n\t* src/c++17/fs_path.cc (path::_S_convert_loc): Replace conditional\n\tcompilation with call to _S_convert.", "tree": {"sha": "307855a53014c608ad315f42aa64d0924f567322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/307855a53014c608ad315f42aa64d0924f567322"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/584d52b088f9fcf78704b504c3f1f07e17c1cded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/584d52b088f9fcf78704b504c3f1f07e17c1cded", "html_url": "https://github.com/Rust-GCC/gccrs/commit/584d52b088f9fcf78704b504c3f1f07e17c1cded", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/584d52b088f9fcf78704b504c3f1f07e17c1cded/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00c8f2a5e3a21d93a03182cacbae4badc02a37f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c8f2a5e3a21d93a03182cacbae4badc02a37f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c8f2a5e3a21d93a03182cacbae4badc02a37f1"}], "stats": {"total": 395, "additions": 198, "deletions": 197}, "files": [{"sha": "08a2ad3330cbb229b3e259ca4fbfcf7d314c028a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584d52b088f9fcf78704b504c3f1f07e17c1cded/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584d52b088f9fcf78704b504c3f1f07e17c1cded/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=584d52b088f9fcf78704b504c3f1f07e17c1cded", "patch": "@@ -1,5 +1,31 @@\n 2020-05-23  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/fs_path.h (__detail::_S_range_begin)\n+\t(__detail::_S_range_end, path::_S_string_from_iter): Replace with\n+\toverloaded function template __detail::__effective_range.\n+\t(__detail::__effective_range): New overloaded function template to\n+\tcreate a basic_string or basic_string_view for an effective range.\n+\t(__detail::__value_type_is_char): Use __detail::__effective_range.\n+\tDo not use remove_const on value type.\n+\t(__detail::__value_type_is_char_or_char8_t): Likewise.\n+\t(path::path(const Source&, format))\n+\t(path::path(const Source&, const locale&))\n+\t(path::operator/=(const Source&), path::append(const Source&))\n+\t(path::concat(const Source&)): Use __detail::__effective_range.\n+\t(path::_S_to_string(InputIterator, InputIterator)): New function\n+\ttemplate to create a string view if possible, or string otherwise.\n+\t(path::_S_convert): Add overloads that convert a string returned\n+\tby __detail::__effective_range. Use if-constexpr to inline conversion\n+\tlogic from all overloads of _Cvt::_S_convert.\n+\t(path::_S_convert_loc): Add overload that converts a string. Use\n+\t_S_to_string to avoid allocation when possible.\n+\t(path::_Cvt): Remove.\n+\t(path::operator+=(CharT)): Remove indirection through path::concat.\n+\t* include/experimental/bits/fs_path.h (path::_S_convert_loc): Add\n+\toverload for non-const pointers, to avoid constructing a std::string.\n+\t* src/c++17/fs_path.cc (path::_S_convert_loc): Replace conditional\n+\tcompilation with call to _S_convert.\n+\n \t* include/bits/fs_path.h (__detail::_S_range_begin)\n \t(__detail::_S_range_end): Remove unintentional static specifiers.\n \t* include/experimental/bits/fs_path.h (__detail::_S_range_begin)"}, {"sha": "2d2766ec62e5e10a5416b5135f79e5d95236bc81", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "modified", "additions": 164, "deletions": 192, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584d52b088f9fcf78704b504c3f1f07e17c1cded/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584d52b088f9fcf78704b504c3f1f07e17c1cded/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=584d52b088f9fcf78704b504c3f1f07e17c1cded", "patch": "@@ -155,56 +155,61 @@ namespace __detail\n   template<typename _Iter, typename _Tr = __safe_iterator_traits<_Iter>>\n     using _Path2 = enable_if_t<__is_path_iter_src<_Tr>::value, path>;\n \n-  template<typename _Source>\n-    _Source\n-    _S_range_begin(_Source __begin) { return __begin; }\n-\n-  struct __null_terminated { };\n-\n-  template<typename _Source>\n-    __null_terminated\n-    _S_range_end(_Source) { return {}; }\n-\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    inline const _CharT*\n-    _S_range_begin(const basic_string<_CharT, _Traits, _Alloc>& __str)\n-    { return __str.data(); }\n+  // The __effective_range overloads convert a Source parameter into\n+  // either a basic_string_view or basic_string containing the\n+  // effective range of the Source, as defined in [fs.path.req].\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n-    inline const _CharT*\n-    _S_range_end(const basic_string<_CharT, _Traits, _Alloc>& __str)\n-    { return __str.data() + __str.size(); }\n+    inline basic_string_view<_CharT, _Traits>\n+    __effective_range(const basic_string<_CharT, _Traits, _Alloc>& __source)\n+    { return __source; }\n \n   template<typename _CharT, typename _Traits>\n-    inline const _CharT*\n-    _S_range_begin(const basic_string_view<_CharT, _Traits>& __str)\n-    { return __str.data(); }\n+    inline const basic_string_view<_CharT, _Traits>&\n+    __effective_range(const basic_string_view<_CharT, _Traits>& __source)\n+    { return __source; }\n \n-  template<typename _CharT, typename _Traits>\n-    inline const _CharT*\n-    _S_range_end(const basic_string_view<_CharT, _Traits>& __str)\n-    { return __str.data() + __str.size(); }\n-\n-  template<typename _Tp,\n-\t   typename _Iter = decltype(_S_range_begin(std::declval<_Tp>())),\n-\t   typename _Val = typename std::iterator_traits<_Iter>::value_type,\n-\t   typename _UnqualVal = std::remove_const_t<_Val>>\n+  template<typename _Source>\n+    inline auto\n+    __effective_range(const _Source& __source)\n+    {\n+      if constexpr (is_pointer_v<decay_t<_Source>>)\n+\treturn basic_string_view{&*__source};\n+      else\n+\t{\n+\t  // _Source is an input iterator that iterates over an NTCTS.\n+\t  // Create a basic_string by reading until the null character.\n+\t  using value_type\n+\t    = typename iterator_traits<_Source>::value_type;\n+\t  basic_string<value_type> __str;\n+\t  _Source __it = __source;\n+\t  for (value_type __ch = *__it; __ch != value_type(); __ch = *++__it)\n+\t    __str.push_back(__ch);\n+\t  return __str;\n+\t}\n+    }\n+\n+  // The value type of a Source parameter's effective range.\n+  template<typename _Tp>\n+    using __value_t = typename remove_reference_t<\n+      decltype(__detail::__effective_range(std::declval<_Tp>()))>::value_type;\n+\n+  // SFINAE helper to check that an effective range has value_type char,\n+  // as required by path constructors taking a std::locale parameter.\n+  // The type _Tp must have already been checked by _Path<Tp> or _Path2<_Tp>.\n+  template<typename _Tp, typename _Val = __value_t<_Tp>>\n     using __value_type_is_char\n-      = std::enable_if_t<std::is_same_v<_UnqualVal, char>,\n-\t\t\t _UnqualVal>;\n+      = std::enable_if_t<std::is_same_v<_Val, char>, _Val>;\n \n-  template<typename _Tp,\n-\t   typename _Iter = decltype(_S_range_begin(std::declval<_Tp>())),\n-\t   typename _Val = typename std::iterator_traits<_Iter>::value_type,\n-\t   typename _UnqualVal = std::remove_const_t<_Val>>\n+  // As above, but also allows char8_t, as required by u8path\n+  // C++20 [depr.fs.path.factory]\n+  template<typename _Tp, typename _Val = __value_t<_Tp>>\n     using __value_type_is_char_or_char8_t\n-      = std::enable_if_t<__or_v<\n-\t\t\t   std::is_same<_UnqualVal, char>\n+      = std::enable_if_t<std::is_same_v<_Val, char>\n #ifdef _GLIBCXX_USE_CHAR8_T\n-\t\t\t   , std::is_same<_UnqualVal, char8_t>\n+\t\t\t || std::is_same_v<_Val, char8_t>\n #endif\n-\t\t\t   >,\n-\t\t\t _UnqualVal>;\n+\t\t\t , _Val>;\n \n } // namespace __detail\n   /// @endcond\n@@ -251,8 +256,7 @@ namespace __detail\n     template<typename _Source,\n \t     typename _Require = __detail::_Path<_Source>>\n       path(_Source const& __source, format = auto_format)\n-      : _M_pathname(_S_convert(__detail::_S_range_begin(__source),\n-\t\t\t       __detail::_S_range_end(__source)))\n+      : _M_pathname(_S_convert(__detail::__effective_range(__source)))\n       { _M_split_cmpts(); }\n \n     template<typename _InputIterator,\n@@ -264,9 +268,8 @@ namespace __detail\n     template<typename _Source,\n \t     typename _Require = __detail::_Path<_Source>,\n \t     typename _Require2 = __detail::__value_type_is_char<_Source>>\n-      path(_Source const& __source, const locale& __loc, format = auto_format)\n-      : _M_pathname(_S_convert_loc(__detail::_S_range_begin(__source),\n-\t\t\t\t   __detail::_S_range_end(__source), __loc))\n+      path(_Source const& __src, const locale& __loc, format = auto_format)\n+      : _M_pathname(_S_convert_loc(__detail::__effective_range(__src), __loc))\n       { _M_split_cmpts(); }\n \n     template<typename _InputIterator,\n@@ -309,17 +312,15 @@ namespace __detail\n       __detail::_Path<_Source>&\n       operator/=(_Source const& __source)\n       {\n-\t_M_append(_S_convert(__detail::_S_range_begin(__source),\n-\t\t\t     __detail::_S_range_end(__source)));\n+\t_M_append(_S_convert(__detail::__effective_range(__source)));\n \treturn *this;\n       }\n \n     template<typename _Source>\n       __detail::_Path<_Source>&\n       append(_Source const& __source)\n       {\n-\t_M_append(_S_convert(__detail::_S_range_begin(__source),\n-\t\t\t     __detail::_S_range_end(__source)));\n+\t_M_append(_S_convert(__detail::__effective_range(__source)));\n \treturn *this;\n       }\n \n@@ -351,8 +352,7 @@ namespace __detail\n       __detail::_Path<_Source>&\n       concat(_Source const& __x)\n       {\n-\t_M_concat(_S_convert(__detail::_S_range_begin(__x),\n-\t\t\t     __detail::_S_range_end(__x)));\n+\t_M_concat(_S_convert(__detail::__effective_range(__x)));\n \treturn *this;\n       }\n \n@@ -523,22 +523,6 @@ namespace __detail\n       return __result;\n     }\n \n-    /// @cond undocumented\n-    // Create a basic_string by reading until a null character.\n-    template<typename _InputIterator,\n-\t     typename _Traits = std::iterator_traits<_InputIterator>,\n-\t     typename _CharT\n-\t       = typename std::remove_cv_t<typename _Traits::value_type>>\n-      static std::basic_string<_CharT>\n-      _S_string_from_iter(_InputIterator __source)\n-      {\n-\tstd::basic_string<_CharT> __str;\n-\tfor (_CharT __ch = *__source; __ch != _CharT(); __ch = *++__source)\n-\t  __str.push_back(__ch);\n-\treturn __str;\n-      }\n-    /// @endcond\n-\n   private:\n     enum class _Type : unsigned char {\n       _Multi = 0, _Root_name, _Root_dir, _Filename\n@@ -558,43 +542,67 @@ namespace __detail\n \n     pair<const string_type*, size_t> _M_find_extension() const noexcept;\n \n-    template<typename _CharT>\n-      struct _Cvt;\n-\n-    static basic_string_view<value_type>\n-    _S_convert(value_type* __src, __detail::__null_terminated)\n-    { return __src; }\n+    // Create a string or string view from an iterator range.\n+    template<typename _InputIterator>\n+      static auto\n+      _S_to_string(_InputIterator __first, _InputIterator __last)\n+      {\n+\tusing _EcharT\n+\t  = typename std::iterator_traits<_InputIterator>::value_type;\n+\tstatic_assert(__detail::__is_encoded_char<_EcharT>);\n \n-    static basic_string_view<value_type>\n-    _S_convert(const value_type* __src, __detail::__null_terminated)\n-    { return __src; }\n+#if __cpp_lib_concepts\n+\tconstexpr bool __contiguous = std::contiguous_iterator<_InputIterator>;\n+#else\n+\tconstexpr bool __contiguous\n+\t  = is_pointer_v<decltype(std::__niter_base(__first))>;\n+#endif\n+\tif constexpr (__contiguous)\n+\t  {\n+\t    // For contiguous iterators we can just return a string view.\n+\t    const auto* __f = std::__to_address(std::__niter_base(__first));\n+\t    const auto* __l = std::__to_address(std::__niter_base(__last));\n+\t    return basic_string_view<_EcharT>(__f, __l - __f);\n+\t  }\n+\telse\n+\t  // Conversion requires contiguous characters, so create a string.\n+\t  return basic_string<_EcharT>(__first, __last);\n+      }\n \n-    static basic_string_view<value_type>\n-    _S_convert(value_type* __first, value_type* __last)\n-    { return {__first, __last - __first}; }\n+    // path::_S_convert creates a basic_string<value_type> or\n+    // basic_string_view<value_type> from a range (either the effective\n+    // range of a Source parameter, or a pair of InputIterator parameters),\n+    // performing the conversions required by [fs.path.type.cvt].\n+    // If the value_type of the range value type is path::value_type,\n+    // no encoding conversion is performed. If the range is contiguous\n+    // a string_view\n \n-    static basic_string_view<value_type>\n-    _S_convert(const value_type* __first, const value_type* __last)\n-    { return {__first, __last - __first}; }\n+    static string_type\n+    _S_convert(string_type __str)\n+    { return __str; }\n \n-    template<typename _Iter>\n-      static string_type\n-      _S_convert(_Iter __first, _Iter __last)\n+    template<typename _Tp>\n+      static auto\n+      _S_convert(const _Tp& __str)\n       {\n-\tusing __value_type = typename std::iterator_traits<_Iter>::value_type;\n-\treturn _Cvt<typename remove_cv<__value_type>::type>::\n-\t  _S_convert(__first, __last);\n+\tif constexpr (is_same_v<_Tp, string_type>)\n+\t  return __str;\n+\telse if constexpr (is_same_v<_Tp, basic_string_view<value_type>>)\n+\t  return __str;\n+\telse if constexpr (is_same_v<typename _Tp::value_type, value_type>)\n+\t  return basic_string_view<value_type>(__str.data(), __str.size());\n+\telse\n+\t  return _S_convert(__str.data(), __str.data() + __str.size());\n       }\n \n-    template<typename _InputIterator>\n-      static string_type\n-      _S_convert(_InputIterator __src, __detail::__null_terminated)\n-      {\n-\t// Read from iterator into basic_string until a null value is seen:\n-\tauto __s = _S_string_from_iter(__src);\n-\t// Convert (if needed) from iterator's value type to path::value_type:\n-\treturn string_type(_S_convert(__s.data(), __s.data() + __s.size()));\n-      }\n+    template<typename _EcharT>\n+      static auto\n+      _S_convert(const _EcharT* __first, const _EcharT* __last);\n+\n+    template<typename _Iter>\n+      static auto\n+      _S_convert(_Iter __first, _Iter __last)\n+      { return _S_convert(_S_to_string(__first, __last)); }\n \n     static string_type\n     _S_convert_loc(const char* __first, const char* __last,\n@@ -604,16 +612,14 @@ namespace __detail\n       static string_type\n       _S_convert_loc(_Iter __first, _Iter __last, const std::locale& __loc)\n       {\n-\tconst std::string __str(__first, __last);\n-\treturn _S_convert_loc(__str.data(), __str.data()+__str.size(), __loc);\n+\tconst auto __s = _S_to_string(__first, __last);\n+\treturn _S_convert_loc(__s.data(), __s.data() + __s.size(), __loc);\n       }\n \n-    template<typename _InputIterator>\n+    template<typename _Tp>\n       static string_type\n-      _S_convert_loc(_InputIterator __src, __detail::__null_terminated,\n-\t\t     const std::locale& __loc)\n+      _S_convert_loc(const _Tp& __s, const std::locale& __loc)\n       {\n-\tconst std::string __s = _S_string_from_iter(__src);\n \treturn _S_convert_loc(__s.data(), __s.data() + __s.size(), __loc);\n       }\n \n@@ -803,100 +809,66 @@ namespace __detail\n     size_t _M_pos;\n   };\n \n-  // specialize _Cvt for degenerate 'noconv' case\n-  template<>\n-    struct path::_Cvt<path::value_type>\n-    {\n-      template<typename _Iter>\n-\tstatic string_type\n-\t_S_convert(_Iter __first, _Iter __last)\n-\t{ return string_type{__first, __last}; }\n-    };\n-\n-#if !defined _GLIBCXX_FILESYSTEM_IS_WINDOWS  && defined _GLIBCXX_USE_CHAR8_T\n-  // For POSIX converting from char8_t to char is also 'noconv'\n-  template<>\n-    struct path::_Cvt<char8_t>\n+  template<typename _EcharT>\n+    auto\n+    path::_S_convert(const _EcharT* __f, const _EcharT* __l)\n     {\n-      template<typename _Iter>\n-\tstatic string_type\n-\t_S_convert(_Iter __first, _Iter __last)\n-\t{ return string_type(__first, __last); }\n-    };\n+      static_assert(__detail::__is_encoded_char<_EcharT>);\n+\n+      if constexpr (is_same_v<_EcharT, value_type>)\n+\treturn basic_string_view<value_type>(__f, __l - __f);\n+#if !defined _GLIBCXX_FILESYSTEM_IS_WINDOWS && defined _GLIBCXX_USE_CHAR8_T\n+      else if constexpr (is_same_v<_EcharT, char8_t>)\n+\t// For POSIX converting from char8_t to char is also 'noconv'\n+\treturn string_view(reinterpret_cast<const char*>(__f), __l - __f);\n #endif\n-\n-  template<typename _CharT>\n-    struct path::_Cvt\n-    {\n-      static string_type\n-      _S_convert(const _CharT* __f, const _CharT* __l)\n-      {\n+      else\n+\t{\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-\tstd::wstring __wstr;\n-\tif constexpr (is_same_v<_CharT, char>)\n-\t  {\n-\t    struct _UCvt : std::codecvt<wchar_t, char, std::mbstate_t>\n-\t    { } __cvt;\n-\t    if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))\n-\t      return __wstr;\n-\t  }\n+\t  std::wstring __wstr;\n+\t  if constexpr (is_same_v<_EcharT, char>)\n+\t    {\n+\t      struct _UCvt : std::codecvt<wchar_t, char, std::mbstate_t>\n+\t      { } __cvt;\n+\t      if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))\n+\t\treturn __wstr;\n+\t    }\n #ifdef _GLIBCXX_USE_CHAR8_T\n-\telse if constexpr (is_same_v<_CharT, char8_t>)\n-\t  {\n-\t    const char* __f2 = (const char*)__f;\n-\t    const char* __l2 = (const char*)__l;\n-\t    std::codecvt_utf8_utf16<wchar_t> __wcvt;\n-\t    if (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n-\t      return __wstr;\n-\t  }\n+\t  else if constexpr (is_same_v<_EcharT, char8_t>)\n+\t    {\n+\t      const char* __f2 = (const char*)__f;\n+\t      const char* __l2 = (const char*)__l;\n+\t      std::codecvt_utf8_utf16<wchar_t> __wcvt;\n+\t      if (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n+\t\treturn __wstr;\n+\t    }\n #endif\n-\telse // char16_t or char32_t\n-\t  {\n-\t    struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n-\t    { } __cvt;\n-\t    std::string __str;\n-\t    if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n-\t      {\n-\t\tconst char* __f2 = __str.data();\n-\t\tconst char* __l2 = __f2 + __str.size();\n-\t\tstd::codecvt_utf8_utf16<wchar_t> __wcvt;\n-\t\tif (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n-\t\t  return __wstr;\n-\t      }\n-\t  }\n+\t  else // char16_t or char32_t\n+\t    {\n+\t      struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>\n+\t      { } __cvt;\n+\t      std::string __str;\n+\t      if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n+\t\t{\n+\t\t  const char* __f2 = __str.data();\n+\t\t  const char* __l2 = __f2 + __str.size();\n+\t\t  std::codecvt_utf8_utf16<wchar_t> __wcvt;\n+\t\t  if (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n+\t\t    return __wstr;\n+\t\t}\n+\t    }\n #else // ! windows\n-\tstruct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n-\t{ } __cvt;\n-\tstd::string __str;\n-\tif (__str_codecvt_out_all(__f, __l, __str, __cvt))\n-\t  return __str;\n+\t  struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>\n+\t  { } __cvt;\n+\t  std::string __str;\n+\t  if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n+\t    return __str;\n #endif\n-\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n-\t      \"Cannot convert character sequence\",\n-\t      std::make_error_code(errc::illegal_byte_sequence)));\n-      }\n-\n-      static string_type\n-      _S_convert(_CharT* __f, _CharT* __l)\n-      {\n-\treturn _S_convert(const_cast<const _CharT*>(__f),\n-\t\t\t  const_cast<const _CharT*>(__l));\n-      }\n-\n-      template<typename _Iter>\n-\tstatic string_type\n-\t_S_convert(_Iter __first, _Iter __last)\n-\t{\n-\t  const std::basic_string<_CharT> __str(__first, __last);\n-\t  return _S_convert(__str.data(), __str.data() + __str.size());\n+\t  _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t\t\"Cannot convert character sequence\",\n+\t\tstd::make_error_code(errc::illegal_byte_sequence)));\n \t}\n-\n-      template<typename _Iter, typename _Cont>\n-\tstatic string_type\n-\t_S_convert(__gnu_cxx::__normal_iterator<_Iter, _Cont> __first,\n-\t\t  __gnu_cxx::__normal_iterator<_Iter, _Cont> __last)\n-\t{ return _S_convert(__first.base(), __last.base()); }\n-    };\n+    }\n \n   /// @endcond\n \n@@ -1030,10 +1002,10 @@ namespace __detail\n \n   template<typename _CharT>\n     inline __detail::_Path2<_CharT*>&\n-    path::operator+=(_CharT __x)\n+    path::operator+=(const _CharT __x)\n     {\n-      auto* __addr = std::__addressof(__x);\n-      return concat(__addr, __addr + 1);\n+      _M_concat(_S_convert(&__x, &__x + 1));\n+      return *this;\n     }\n \n   inline path&"}, {"sha": "c91937c66d863fd2617a2256987c7f0c25eb939e", "filename": "libstdc++-v3/include/experimental/bits/fs_path.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584d52b088f9fcf78704b504c3f1f07e17c1cded/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584d52b088f9fcf78704b504c3f1f07e17c1cded/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h?ref=584d52b088f9fcf78704b504c3f1f07e17c1cded", "patch": "@@ -495,6 +495,13 @@ namespace __detail\n     _S_convert_loc(const char* __first, const char* __last,\n \t\t   const std::locale& __loc);\n \n+    static string_type\n+    _S_convert_loc(char* __first, char* __last, const std::locale& __loc)\n+    {\n+      return _S_convert_loc(const_cast<const char*>(__first),\n+\t\t\t    const_cast<const char*>(__last), __loc);\n+    }\n+\n     template<typename _Iter>\n       static string_type\n       _S_convert_loc(_Iter __first, _Iter __last, const std::locale& __loc)"}, {"sha": "cea7aa08601f6daf58581e0b1b65ecdfc8f889d2", "filename": "libstdc++-v3/src/c++17/fs_path.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584d52b088f9fcf78704b504c3f1f07e17c1cded/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584d52b088f9fcf78704b504c3f1f07e17c1cded/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffs_path.cc?ref=584d52b088f9fcf78704b504c3f1f07e17c1cded", "patch": "@@ -1949,11 +1949,7 @@ path::_S_convert_loc(const char* __first, const char* __last,\n     _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n \t  \"Cannot convert character sequence\",\n \t  std::make_error_code(errc::illegal_byte_sequence)));\n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-  return __ws;\n-#else\n-  return _Cvt<wchar_t>::_S_convert(__ws.data(), __ws.data() + __ws.size());\n-#endif\n+  return _S_convert(std::move(__ws));\n #else\n   return {__first, __last};\n #endif"}]}