{"sha": "a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTljY2JiNjBkNGJmYTdiNzYzN2E5MTU3ZTEwZTU4ZjRjNjAxMDJhNQ==", "commit": {"author": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-12-04T00:50:35Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2001-12-04T00:50:35Z"}, "message": "builtin-types.def (BT_FN_VOID_PTR_INT_INT): New.\n\n\t* builtin-types.def (BT_FN_VOID_PTR_INT_INT): New.\n\t* builtins.def (BUILT_IN_PREFETCH): New.\n\t* builtins.c (expand_builtin_expect): New.\n\t  (expand_builtin): Call it.\n\t* doc/extend.texi: Document __builtin_expect.\n\nFrom-SVN: r47582", "tree": {"sha": "40c85f3d7a5f7892b65417f4aa96b825f4936046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40c85f3d7a5f7892b65417f4aa96b825f4936046"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/comments", "author": null, "committer": null, "parents": [{"sha": "21b8482ae8289fccb3ddaaa74532995aa3f27c56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b8482ae8289fccb3ddaaa74532995aa3f27c56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b8482ae8289fccb3ddaaa74532995aa3f27c56"}], "stats": {"total": 111, "additions": 111, "deletions": 0}, "files": [{"sha": "b4c866fdddaf9fc115affe7d578d21fcc2a12b47", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5", "patch": "@@ -156,6 +156,7 @@ DEF_FUNCTION_TYPE_3 (BT_FN_TRAD_PTR_PTR_INT_SIZE,\n \t             BT_TRAD_PTR, BT_PTR, BT_INT, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_TRAD_CONST_PTR_TRAD_CONST_PTR_LEN,\n \t\t     BT_INT, BT_TRAD_CONST_PTR, BT_TRAD_CONST_PTR, BT_LEN)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_INT_INT, BT_VOID, BT_PTR, BT_INT, BT_INT)\n \n DEF_FUNCTION_TYPE_4 (BT_FN_SIZE_CONST_PTR_SIZE_SIZE_PTR,\n \t\t     BT_SIZE, BT_CONST_PTR, BT_SIZE, BT_SIZE, BT_PTR)"}, {"sha": "6785ce546581fc43eb5ccde6a4724eb35df254e2", "filename": "gcc/builtins.c", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5", "patch": "@@ -87,6 +87,7 @@ static int apply_result_size\t\tPARAMS ((void));\n static rtx result_vector\t\tPARAMS ((int, rtx));\n #endif\n static rtx expand_builtin_setjmp\tPARAMS ((tree, rtx));\n+static void expand_builtin_prefetch\tPARAMS ((tree));\n static rtx expand_builtin_apply_args\tPARAMS ((void));\n static rtx expand_builtin_apply_args_1\tPARAMS ((void));\n static rtx expand_builtin_apply\t\tPARAMS ((rtx, rtx, rtx));\n@@ -715,6 +716,69 @@ expand_builtin_longjmp (buf_addr, value)\n     }\n }\n \n+/* Expand a call to __builtin_prefetch.  For a target that does not support\n+   data prefetch, evaluate the memory address argument in case it has side\n+   effects.  */\n+\n+static void\n+expand_builtin_prefetch (arglist)\n+     tree arglist;\n+{\n+  tree arg0, arg1, arg2;\n+  rtx op0, op1, op2;\n+\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* Argument 0 is an address.  */\n+  op0 = expand_expr (arg0, NULL_RTX, Pmode, EXPAND_NORMAL);\n+\n+  /* Argument 1 (read/write flag) must be a compile-time constant int.  */\n+  if (TREE_CODE (arg1) != INTEGER_CST)\n+    {\n+       error (\"second arg to `__builtin_prefetch' must be a constant\");\n+       arg1 = integer_zero_node;\n+    }\n+  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0); \n+  /* Argument 1 must be either zero or one.  */\n+  if (INTVAL (op1) != 0 && INTVAL (op1) != 1)\n+    {\n+      warning (\"invalid second arg to __builtin_prefetch; using zero\");\n+      op1 = const0_rtx;\n+    }\n+\n+  /* Argument 2 (locality) must be a compile-time constant int.  */\n+  if (TREE_CODE (arg2) != INTEGER_CST)\n+    {\n+      error (\"third arg to `__builtin_prefetch' must be a constant\");\n+      arg2 = integer_zero_node;\n+    }\n+  op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0); \n+  /* Argument 2 must be 0, 1, 2, or 3.  */\n+  if (INTVAL (op2) < 0 || INTVAL (op2) > 3)\n+    {\n+      warning (\"invalid third arg to __builtin_prefetch; using zero\");\n+      op2 = const0_rtx;\n+    }\n+\n+#ifdef HAVE_prefetch\n+  if (HAVE_prefetch)\n+    {\n+      if (! (*insn_data[(int)CODE_FOR_prefetch].operand[0].predicate)\n+\t    (op0, Pmode))\n+        op0 = force_reg (Pmode, op0);\n+      emit_insn (gen_prefetch (op0, op1, op2));\n+    }\n+  else\n+#endif\n+    op0 = protect_from_queue (op0, 0);\n+    /* Don't do anything with direct references to volatile memory, but\n+       generate code to handle other side effects.  */\n+    if (GET_CODE (op0) != MEM && side_effects_p (op0))\n+      emit_insn (op0);\n+}\n+\n /* Get a MEM rtx for expression EXP which is the address of an operand\n    to be used to be used in a string instruction (cmpstrsi, movstrsi, ..).  */\n \n@@ -3809,6 +3873,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       return expand_builtin_va_copy (arglist);\n     case BUILT_IN_EXPECT:\n       return expand_builtin_expect (arglist, target);\n+    case BUILT_IN_PREFETCH:\n+      expand_builtin_prefetch (arglist);\n+      return const0_rtx;\n+\n \n     default:\t\t\t/* just do library call, if unknown builtin */\n       error (\"built-in function `%s' not currently supported\","}, {"sha": "ebb323f235de18ef70d4942c18dd248ceea02904", "filename": "gcc/builtins.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5", "patch": "@@ -336,6 +336,9 @@ DEF_GCC_BUILTIN(BUILT_IN_LONGJMP,\n DEF_GCC_BUILTIN(BUILT_IN_TRAP,\n \t\t\"__builtin_trap\",\n \t\tBT_FN_VOID)\n+DEF_GCC_BUILTIN(BUILT_IN_PREFETCH,\n+\t\t\"__builtin_prefetch\",\n+\t\tBT_FN_VOID_PTR_INT_INT)\n \n /* Stdio builtins.  */\n DEF_FALLBACK_BUILTIN(BUILT_IN_PUTCHAR,"}, {"sha": "781fa997addc1a2dfa5af8186af783edf549eb80", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a9ccbb60d4bfa7b7637a9157e10e58f4c60102a5", "patch": "@@ -4474,6 +4474,45 @@ if (__builtin_expect (ptr != NULL, 1))\n when testing pointer or floating-point values.\n @end deftypefn\n \n+@deftypefn {Built-in Function} void __builtin_prefetch (void *@var{addr}, int @var{rw}, int @var{locality})\n+This function is used to minimize cache-miss latency by moving data into\n+a cache before it is accessed.\n+You can insert calls to @code{__builtin_prefetch} into code for which\n+you know addresses of data in memory that is likely to be accessed soon.\n+If the target supports them, data prefetch instructions will be generated.\n+If the prefetch is done early enough before the access then the data will\n+be in the cache by the time it is accessed.\n+\n+The value of @var{addr} is the address of the memory to prefetch.\n+The value of @var{rw} is a compile-time constant one or zero; one\n+means that the prefetch is preparing for a write to the memory address.\n+The value @var{locality} must be a compile-time constant integer between\n+zero and three.  A value of zero means that the data has no temporal\n+locality, so it need not be left in the cache after the access.  A value\n+of three means that the data has a high degree of temporal locality and\n+should be left in all levels of cache possible.  Values of one and two\n+mean, respectively, a low or moderate degree of temporal locality.\n+\n+@smallexample\n+for (i = 0; i < n; i++)\n+  @{\n+    a[i] = a[i] + b[i];\n+    __builtin_prefetch (&a[i+j], 1, 1);\n+    __builtin_prefetch (&b[i+j], 0, 1);\n+    /* ... */\n+  @}\n+@end smallexample\n+\n+Data prefetch does not generate faults if @var{addr} is invalid, but \n+the address expression itself must be valid.  For example, a prefetch\n+of @code{p->next} will not fault if @code{p->next} is not a valid\n+address, but evaluation will fault if @code{p} is not a valid address.\n+\n+If the target does not support data prefetch, the address expression\n+is evaluated if it includes side effects but no other code is generated\n+and GCC does not issue a warning.\n+@end deftypefn\n+\n @node Pragmas\n @section Pragmas Accepted by GCC\n @cindex pragmas"}]}