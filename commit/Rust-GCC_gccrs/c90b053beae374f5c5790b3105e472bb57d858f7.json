{"sha": "c90b053beae374f5c5790b3105e472bb57d858f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkwYjA1M2JlYWUzNzRmNWM1NzkwYjMxMDVlNDcyYmI1N2Q4NThmNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-06-12T13:52:51Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-06-12T13:52:51Z"}, "message": "tree-flow.h: Remove the prototype for compute_phi_arg_on_exit.\n\n\t* tree-flow.h: Remove the prototype for\n\tcompute_phi_arg_on_exit.\n\t* tree-ssa-loop-ivopts.c (protect_loop_closed_ssa_form_use,\n\tprotect_loop_closed_ssa_form, compute_phi_arg_on_exit):\n\tRemove.\n\nFrom-SVN: r114569", "tree": {"sha": "bf6d74d8283d3afb82dff31f5c413c957bdd2361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf6d74d8283d3afb82dff31f5c413c957bdd2361"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c90b053beae374f5c5790b3105e472bb57d858f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c90b053beae374f5c5790b3105e472bb57d858f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c90b053beae374f5c5790b3105e472bb57d858f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c90b053beae374f5c5790b3105e472bb57d858f7/comments", "author": null, "committer": null, "parents": [{"sha": "af7acf2ed6de83624492365a6012aeb3e07e2ea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af7acf2ed6de83624492365a6012aeb3e07e2ea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af7acf2ed6de83624492365a6012aeb3e07e2ea5"}], "stats": {"total": 115, "additions": 8, "deletions": 107}, "files": [{"sha": "c4b463e16515b28f0a11790b130e6dc69730e444", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90b053beae374f5c5790b3105e472bb57d858f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90b053beae374f5c5790b3105e472bb57d858f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c90b053beae374f5c5790b3105e472bb57d858f7", "patch": "@@ -1,3 +1,11 @@\n+2006-06-12  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* tree-flow.h: Remove the prototype for\n+\tcompute_phi_arg_on_exit.\n+\t* tree-ssa-loop-ivopts.c (protect_loop_closed_ssa_form_use,\n+\tprotect_loop_closed_ssa_form, compute_phi_arg_on_exit):\n+\tRemove.\n+\n 2006-06-12  Mark Shinwell  <shinwell@codesourcery.com>\n \n \t* builtins.c (expand_builtin_return_addr): Only use"}, {"sha": "4e693684bc2e1c9278d528b1c63ceb9aec989c04", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90b053beae374f5c5790b3105e472bb57d858f7/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90b053beae374f5c5790b3105e472bb57d858f7/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c90b053beae374f5c5790b3105e472bb57d858f7", "patch": "@@ -827,7 +827,6 @@ bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n void create_iv (tree, tree, tree, struct loop *, block_stmt_iterator *, bool,\n \t\ttree *, tree *);\n void split_loop_exit_edge (edge);\n-void compute_phi_arg_on_exit (edge, tree, tree);\n unsigned force_expr_to_var_cost (tree);\n basic_block bsi_insert_on_edge_immediate_loop (edge, tree);\n void standard_iv_increment_position (struct loop *, block_stmt_iterator *,"}, {"sha": "0f98604a2125ee34bc4adf829b0c2d99bd440768", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c90b053beae374f5c5790b3105e472bb57d858f7/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c90b053beae374f5c5790b3105e472bb57d858f7/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=c90b053beae374f5c5790b3105e472bb57d858f7", "patch": "@@ -5463,112 +5463,6 @@ rewrite_use_compare (struct ivopts_data *data,\n   *op_p = op;\n }\n \n-/* Ensure that operand *OP_P may be used at the end of EXIT without\n-   violating loop closed ssa form.  */\n-\n-static void\n-protect_loop_closed_ssa_form_use (edge exit, use_operand_p op_p)\n-{\n-  basic_block def_bb;\n-  struct loop *def_loop;\n-  tree phi, use;\n-\n-  use = USE_FROM_PTR (op_p);\n-  if (TREE_CODE (use) != SSA_NAME)\n-    return;\n-\n-  def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (use));\n-  if (!def_bb)\n-    return;\n-\n-  def_loop = def_bb->loop_father;\n-  if (flow_bb_inside_loop_p (def_loop, exit->dest))\n-    return;\n-\n-  /* Try finding a phi node that copies the value out of the loop.  */\n-  for (phi = phi_nodes (exit->dest); phi; phi = PHI_CHAIN (phi))\n-    if (PHI_ARG_DEF_FROM_EDGE (phi, exit) == use)\n-      break;\n-\n-  if (!phi)\n-    {\n-      /* Create such a phi node.  */\n-      tree new_name = duplicate_ssa_name (use, NULL);\n-\n-      phi = create_phi_node (new_name, exit->dest);\n-      SSA_NAME_DEF_STMT (new_name) = phi;\n-      add_phi_arg (phi, use, exit);\n-    }\n-\n-  SET_USE (op_p, PHI_RESULT (phi));\n-}\n-\n-/* Ensure that operands of STMT may be used at the end of EXIT without\n-   violating loop closed ssa form.  */\n-\n-static void\n-protect_loop_closed_ssa_form (edge exit, tree stmt)\n-{\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-\n-  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n-    protect_loop_closed_ssa_form_use (exit, use_p);\n-}\n-\n-/* STMTS compute a value of a phi argument OP on EXIT of a loop.  Arrange things\n-   so that they are emitted on the correct place, and so that the loop closed\n-   ssa form is preserved.  */\n-\n-void\n-compute_phi_arg_on_exit (edge exit, tree stmts, tree op)\n-{\n-  tree_stmt_iterator tsi;\n-  block_stmt_iterator bsi;\n-  tree phi, stmt, def, next;\n-\n-  if (!single_pred_p (exit->dest))\n-    split_loop_exit_edge (exit);\n-\n-  /* Ensure there is label in exit->dest, so that we can\n-     insert after it.  */\n-  tree_block_label (exit->dest);\n-  bsi = bsi_after_labels (exit->dest);\n-\n-  if (TREE_CODE (stmts) == STATEMENT_LIST)\n-    {\n-      for (tsi = tsi_start (stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n-        {\n-\t  tree stmt = tsi_stmt (tsi);\n-\t  bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n-\t  protect_loop_closed_ssa_form (exit, stmt);\n-\t}\n-    }\n-  else\n-    {\n-      bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n-      protect_loop_closed_ssa_form (exit, stmts);\n-    }\n-\n-  if (!op)\n-    return;\n-\n-  for (phi = phi_nodes (exit->dest); phi; phi = next)\n-    {\n-      next = PHI_CHAIN (phi);\n-\n-      if (PHI_ARG_DEF_FROM_EDGE (phi, exit) == op)\n-\t{\n-\t  def = PHI_RESULT (phi);\n-\t  remove_statement (phi, false);\n-\t  stmt = build2 (MODIFY_EXPR, TREE_TYPE (op),\n-\t\t\tdef, op);\n-\t  SSA_NAME_DEF_STMT (def) = stmt;\n-\t  bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n-\t}\n-    }\n-}\n-\n /* Rewrites USE using candidate CAND.  */\n \n static void"}]}