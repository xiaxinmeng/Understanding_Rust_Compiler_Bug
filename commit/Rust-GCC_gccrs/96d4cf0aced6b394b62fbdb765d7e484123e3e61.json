{"sha": "96d4cf0aced6b394b62fbdb765d7e484123e3e61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZkNGNmMGFjZWQ2YjM5NGI2MmZiZGI3NjVkN2U0ODQxMjNlM2U2MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T15:05:12Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T15:05:12Z"}, "message": "(fold_truthop): Treat a BIT_AND_EXPR with a constant of one as if it were surrounded with an NE_EXPR.\n\n(fold_truthop): Treat a BIT_AND_EXPR with a constant of one as if it were\nsurrounded with an NE_EXPR.\n(fold): Don't move operation into conditional if it is BIT_{AND,OR}_EXPR with\nthe constant 1; change it to TRUTH_*_EXPR instead.\nWhen moving things inside conditions, move comparisons as well as binary\noperations.\nDon't make a SAVE_EXPR when moving things inside conditionals unless the value\nwould really have been used twice.\n\nFrom-SVN: r4746", "tree": {"sha": "bd82616890a26fef6a8d9b57b2f29c86a7362f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd82616890a26fef6a8d9b57b2f29c86a7362f68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96d4cf0aced6b394b62fbdb765d7e484123e3e61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d4cf0aced6b394b62fbdb765d7e484123e3e61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96d4cf0aced6b394b62fbdb765d7e484123e3e61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96d4cf0aced6b394b62fbdb765d7e484123e3e61/comments", "author": null, "committer": null, "parents": [{"sha": "e9b3df3116138d36fdee587fe9c236e6f7d6d823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b3df3116138d36fdee587fe9c236e6f7d6d823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b3df3116138d36fdee587fe9c236e6f7d6d823"}], "stats": {"total": 74, "additions": 66, "deletions": 8}, "files": [{"sha": "4db203cdb221bcb610c3665352f69e2e0bf917f6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96d4cf0aced6b394b62fbdb765d7e484123e3e61/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96d4cf0aced6b394b62fbdb765d7e484123e3e61/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=96d4cf0aced6b394b62fbdb765d7e484123e3e61", "patch": "@@ -2696,7 +2696,9 @@ fold_truthop (code, truth_type, lhs, rhs)\n   int volatilep;\n \n   /* Start by getting the comparison codes and seeing if this looks like\n-     a range test.  Fail if anything is volatile.  */\n+     a range test.  Fail if anything is volatile.  If one operand is a\n+     BIT_AND_EXPR with the constant one, treat it as if it were surrounded\n+     with a NE_EXPR.  */\n \n   if (TREE_SIDE_EFFECTS (lhs)\n       || TREE_SIDE_EFFECTS (rhs))\n@@ -2705,6 +2707,12 @@ fold_truthop (code, truth_type, lhs, rhs)\n   lcode = TREE_CODE (lhs);\n   rcode = TREE_CODE (rhs);\n \n+  if (lcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (lhs, 1)))\n+    lcode = NE_EXPR, lhs = build (NE_EXPR, truth_type, lhs, integer_zero_node);\n+\n+  if (rcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (rhs, 1)))\n+    rcode = NE_EXPR, rhs = build (NE_EXPR, truth_type, rhs, integer_zero_node);\n+\n   if (TREE_CODE_CLASS (lcode) != '<'\n       || TREE_CODE_CLASS (rcode) != '<')\n     return 0;\n@@ -3102,7 +3110,26 @@ fold (expr)\n      operation inside the compound or conditional to see if any folding\n      can then be done.  Convert comparison to conditional for this purpose.\n      The also optimizes non-constant cases that used to be done in\n-     expand_expr.  */\n+     expand_expr.\n+\n+     Before we do that, see if this is a BIT_AND_EXPR or a BIT_OR_EXPR,\n+     one of the operands is a comparison and the other is either a comparison\n+     or a BIT_AND_EXPR with the constant 1.  In that case, the code below\n+     would make the expression more complex.  Change it to a\n+     TRUTH_{AND,OR}_EXPR.  */\n+\n+  if ((code == BIT_AND_EXPR || code == BIT_IOR_EXPR)\n+      && ((TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n+\t   && (TREE_CODE_CLASS (TREE_CODE (arg1)) == '<'\n+\t       || (TREE_CODE (arg1) == BIT_AND_EXPR\n+\t\t   && integer_onep (TREE_OPERAND (arg1, 1)))))\n+\t  || (TREE_CODE_CLASS (TREE_CODE (arg1)) == '<'\n+\t      && (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n+\t\t  || (TREE_CODE (arg0) == BIT_AND_EXPR\n+\t\t      && integer_onep (TREE_OPERAND (arg0, 1)))))))\n+    return fold (build (code == BIT_AND_EXPR ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n+\t\t\ttype, arg0, arg1));\n+\n   if (TREE_CODE_CLASS (code) == '1')\n     {\n       if (TREE_CODE (arg0) == COMPOUND_EXPR)\n@@ -3139,11 +3166,13 @@ fold (expr)\n \t\t\t    fold (build1 (code, type, integer_one_node)),\n \t\t\t    fold (build1 (code, type, integer_zero_node))));\n    }\n-  else if (TREE_CODE_CLASS (code) == '2')\n+  else if (TREE_CODE_CLASS (code) == '2'\n+\t   || TREE_CODE_CLASS (code) == '<')\n     {\n       if (TREE_CODE (arg1) == COMPOUND_EXPR)\n \treturn build (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n-\t\t      fold (build (code, type, arg0, TREE_OPERAND (arg1, 1))));\n+\t\t      fold (build (code, type,\n+\t\t\t\t   arg0, TREE_OPERAND (arg1, 1))));\n       else if (TREE_CODE (arg1) == COND_EXPR\n \t       || TREE_CODE_CLASS (TREE_CODE (arg1)) == '<')\n \t{\n@@ -3162,8 +3191,27 @@ fold (expr)\n \t      false_value = integer_zero_node;\n \t    }\n \n-\t  if (TREE_CODE (arg0) != VAR_DECL && TREE_CODE (arg0) != PARM_DECL)\n-\t    arg0 = save_expr (arg0);\n+\t  /* If ARG0 is complex we want to make sure we only evaluate\n+\t     it once.  Though this is only required if it is volatile, it\n+\t     might be more efficient even if it is not.  However, if we\n+\t     succeed in folding one part to a constant, we do not need\n+\t     to make this SAVE_EXPR.  Since we do this optimization\n+\t     primarily to see if we do end up with constant and this\n+\t     SAVE_EXPR interfers with later optimizations, suppressing\n+\t     it when we can is important.  */\n+\n+\t  if ((TREE_CODE (arg0) != VAR_DECL && TREE_CODE (arg0) != PARM_DECL)\n+\t      || TREE_SIDE_EFFECTS (arg0))\n+\t    {\n+\t      tree lhs = fold (build (code, type, arg0, true_value));\n+\t      tree rhs = fold (build (code, type, arg0, false_value));\n+\n+\t      if (TREE_CONSTANT (lhs) || TREE_CONSTANT (rhs))\n+\t\treturn fold (build (COND_EXPR, type, test, lhs, rhs));\n+\n+\t      arg0 = save_expr (arg0);\n+\t    }\n+\n \t  test = fold (build (COND_EXPR, type, test,\n \t\t\t      fold (build (code, type, arg0, true_value)),\n \t\t\t      fold (build (code, type, arg0, false_value))));\n@@ -3195,8 +3243,18 @@ fold (expr)\n \t      false_value = integer_zero_node;\n \t    }\n \n-\t  if (TREE_CODE (arg1) != VAR_DECL && TREE_CODE (arg1) != PARM_DECL)\n-\t    arg1 = save_expr (arg1);\n+\t  if ((TREE_CODE (arg1) != VAR_DECL && TREE_CODE (arg1) != PARM_DECL)\n+\t      || TREE_SIDE_EFFECTS (arg1))\n+\t    {\n+\t      tree lhs = fold (build (code, type, true_value, arg1));\n+\t      tree rhs = fold (build (code, type, false_value, arg1));\n+\n+\t      if (TREE_CONSTANT (lhs) || TREE_CONSTANT (rhs))\n+\t\treturn fold (build (COND_EXPR, type, test, lhs, rhs));\n+\n+\t      arg1 = save_expr (arg1);\n+\t    }\n+\n \t  test = fold (build (COND_EXPR, type, test,\n \t\t\t      fold (build (code, type, true_value, arg1)),\n \t\t\t      fold (build (code, type, false_value, arg1))));"}]}