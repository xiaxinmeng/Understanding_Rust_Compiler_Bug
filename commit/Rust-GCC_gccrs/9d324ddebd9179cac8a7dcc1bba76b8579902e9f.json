{"sha": "9d324ddebd9179cac8a7dcc1bba76b8579902e9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQzMjRkZGViZDkxNzljYWM4YTdkY2MxYmJhNzZiODU3OTkwMmU5Zg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-11-12T18:12:09Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-11-12T18:12:09Z"}, "message": "re PR rtl-optimization/38582 (excessive time in rename registers)\n\n\tPR rtl-opt/38582\n\t* regrename.c (struct du_head): New structure; some elements moved\n\tfrom...\n\t(struct du_chain): ... this one.\n\t(open_chains, closed_chains): Now of type struct du_head *.\n\t(do_replace): Accept du_head argument, not du_chain.  All callers\n\tchanged.  Modified code to match new data structures.\n\t(build_def_use): Return a list of du_head structures.  Modified code\n\tto match new data structures.\n\t(dump_def_use_chain): Accept du_head argument, not du_chain.  All\n\tcallers changed.  Modified code to match new data structures.\n\t(merge_overlapping_regs): Accept du_head argument, not du_chain.  All\n\tcallers changed.  Modified code to match new data structures.\n\t(scan_rtx_reg): Change type of this_regno and this_nregs to unsigned.\n\tAllocate a du_head structure as well as a du_chain when creating a\n\tnew chain.  Modified other code to match new data structures.\n\nFrom-SVN: r154123", "tree": {"sha": "9a56879015014a7d35d79fa3fcbbfbd94f9704c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a56879015014a7d35d79fa3fcbbfbd94f9704c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d324ddebd9179cac8a7dcc1bba76b8579902e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d324ddebd9179cac8a7dcc1bba76b8579902e9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d324ddebd9179cac8a7dcc1bba76b8579902e9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d324ddebd9179cac8a7dcc1bba76b8579902e9f/comments", "author": null, "committer": null, "parents": [{"sha": "a82892595bc3b2a84b13455711a609138dbcb052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a82892595bc3b2a84b13455711a609138dbcb052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a82892595bc3b2a84b13455711a609138dbcb052"}], "stats": {"total": 177, "additions": 111, "deletions": 66}, "files": [{"sha": "daf8ce8514bbe9622ca450a57c114b3a51ad8355", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d324ddebd9179cac8a7dcc1bba76b8579902e9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d324ddebd9179cac8a7dcc1bba76b8579902e9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d324ddebd9179cac8a7dcc1bba76b8579902e9f", "patch": "@@ -1,3 +1,22 @@\n+2009-11-12  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\tPR rtl-opt/38582\n+\t* regrename.c (struct du_head): New structure; some elements moved\n+\tfrom...\n+\t(struct du_chain): ... this one.\n+\t(open_chains, closed_chains): Now of type struct du_head *.\n+\t(do_replace): Accept du_head argument, not du_chain.  All callers\n+\tchanged.  Modified code to match new data structures.\n+\t(build_def_use): Return a list of du_head structures.  Modified code\n+\tto match new data structures.\n+\t(dump_def_use_chain): Accept du_head argument, not du_chain.  All\n+\tcallers changed.  Modified code to match new data structures.\n+\t(merge_overlapping_regs): Accept du_head argument, not du_chain.  All\n+\tcallers changed.  Modified code to match new data structures.\n+\t(scan_rtx_reg): Change type of this_regno and this_nregs to unsigned.\n+\tAllocate a du_head structure as well as a du_chain when creating a\n+\tnew chain.  Modified other code to match new data structures.\n+\n 2009-11-12 Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.h (varpool_node_name): Declare."}, {"sha": "b9d68e7bbee9a7fa100974b61c96c80bd31ef470", "filename": "gcc/regrename.c", "status": "modified", "additions": 92, "deletions": 66, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d324ddebd9179cac8a7dcc1bba76b8579902e9f/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d324ddebd9179cac8a7dcc1bba76b8579902e9f/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=9d324ddebd9179cac8a7dcc1bba76b8579902e9f", "patch": "@@ -40,15 +40,35 @@\n #include \"tree-pass.h\"\n #include \"df.h\"\n \n+/* We keep linked lists of DU_HEAD structures, each of which describes\n+   a chain of occurrences of a reg.  */\n+struct du_head\n+{\n+  /* The next chain.  */\n+  struct du_head *next_chain;\n+  /* The first and last elements of this chain.  */\n+  struct du_chain *first, *last;\n+  /* Describes the register being tracked.  */\n+  unsigned regno, nregs;\n+  /* Nonzero if the chain crosses a call.  */\n+  unsigned int need_caller_save_reg:1;\n+  /* Nonzero if the chain is finished.  */\n+  unsigned int terminated:1;\n+};\n+\n+/* This struct describes a single occurrence of a register.  */\n struct du_chain\n {\n-  struct du_chain *next_chain;\n+  /* Links to the next occurrence of the register.  */\n   struct du_chain *next_use;\n \n+  /* The insn where the register appears.  */\n   rtx insn;\n+  /* The location inside the insn.  */\n   rtx *loc;\n+  /* The register class required by the insn at this location.  */\n   ENUM_BITFIELD(reg_class) cl : 16;\n-  unsigned int need_caller_save_reg:1;\n+  /* Nonzero if the register is subject to earlyclobber.  */\n   unsigned int earlyclobber:1;\n };\n \n@@ -79,19 +99,19 @@ static const char * const scan_actions_name[] =\n \n static struct obstack rename_obstack;\n \n-static void do_replace (struct du_chain *, int);\n+static void do_replace (struct du_head *, int);\n static void scan_rtx_reg (rtx, rtx *, enum reg_class,\n \t\t\t  enum scan_actions, enum op_type, int);\n static void scan_rtx_address (rtx, rtx *, enum reg_class,\n \t\t\t      enum scan_actions, enum machine_mode);\n static void scan_rtx (rtx, rtx *, enum reg_class, enum scan_actions,\n \t\t      enum op_type, int);\n-static struct du_chain *build_def_use (basic_block);\n-static void dump_def_use_chain (struct du_chain *);\n+static struct du_head *build_def_use (basic_block);\n+static void dump_def_use_chain (struct du_head *);\n static void note_sets (rtx, const_rtx, void *);\n static void clear_dead_regs (HARD_REG_SET *, enum reg_note, rtx);\n static void merge_overlapping_regs (basic_block, HARD_REG_SET *,\n-\t\t\t\t    struct du_chain *);\n+\t\t\t\t    struct du_head *);\n \n /* Called through note_stores.  Find sets of registers, and\n    record them in *DATA (which is actually a HARD_REG_SET *).  */\n@@ -127,14 +147,14 @@ clear_dead_regs (HARD_REG_SET *pset, enum reg_note kind, rtx notes)\n       }\n }\n \n-/* For a def-use chain CHAIN in basic block B, find which registers overlap\n+/* For a def-use chain HEAD in basic block B, find which registers overlap\n    its lifetime and set the corresponding bits in *PSET.  */\n \n static void\n merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n-\t\t\tstruct du_chain *chain)\n+\t\t\tstruct du_head *head)\n {\n-  struct du_chain *t = chain;\n+  struct du_chain *t;\n   rtx insn;\n   HARD_REG_SET live;\n   df_ref *def_rec;\n@@ -146,6 +166,8 @@ merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n       if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)\n \tSET_HARD_REG_BIT (live, DF_REF_REGNO (def));\n     }\n+\n+  t = head->first;\n   insn = BB_HEAD (b);\n   while (t)\n     {\n@@ -159,7 +181,7 @@ merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n \t      note_stores (PATTERN (insn), note_sets, (void *) &live);\n \t      /* Only record currently live regs if we are inside the\n \t\t reg's live range.  */\n-\t      if (t != chain)\n+\t      if (t != head->first)\n \t\tIOR_HARD_REG_SET (*pset, live);\n \t      clear_dead_regs (&live, REG_UNUSED, REG_NOTES (insn));\n \t    }\n@@ -200,7 +222,7 @@ regrename_optimize (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      struct du_chain *all_chains = 0;\n+      struct du_head *all_chains = 0;\n       HARD_REG_SET unavailable;\n       HARD_REG_SET regs_seen;\n \n@@ -229,13 +251,13 @@ regrename_optimize (void)\n \t{\n \t  int new_reg, best_new_reg;\n \t  int n_uses;\n-\t  struct du_chain *this_du = all_chains;\n+\t  struct du_head *this_head = all_chains;\n \t  struct du_chain *tmp;\n \t  HARD_REG_SET this_unavailable;\n-\t  int reg = REGNO (*this_du->loc);\n+\t  int reg = this_head->regno;\n \t  int i;\n \n-\t  all_chains = this_du->next_chain;\n+\t  all_chains = this_head->next_chain;\n \n \t  best_new_reg = reg;\n \n@@ -262,7 +284,7 @@ regrename_optimize (void)\n \t  /* Count number of uses, and narrow the set of registers we can\n \t     use for renaming.  */\n \t  n_uses = 0;\n-\t  for (tmp = this_du; tmp; tmp = tmp->next_use)\n+\t  for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n \t    {\n \t      if (DEBUG_INSN_P (tmp->insn))\n \t\tcontinue;\n@@ -274,16 +296,17 @@ regrename_optimize (void)\n \t  if (n_uses < 2)\n \t    continue;\n \n-\t  if (this_du->need_caller_save_reg)\n+\t  if (this_head->need_caller_save_reg)\n \t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n \n-\t  merge_overlapping_regs (bb, &this_unavailable, this_du);\n+\t  merge_overlapping_regs (bb, &this_unavailable, this_head);\n \n \t  /* Now potential_regs is a reasonable approximation, let's\n \t     have a closer look at each register still in there.  */\n \t  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n \t    {\n-\t      int nregs = hard_regno_nregs[new_reg][GET_MODE (*this_du->loc)];\n+\t      enum machine_mode mode = GET_MODE (*this_head->first->loc);\n+\t      int nregs = hard_regno_nregs[new_reg][mode];\n \n \t      for (i = nregs - 1; i >= 0; --i)\n \t        if (TEST_HARD_REG_BIT (this_unavailable, new_reg + i)\n@@ -308,10 +331,10 @@ regrename_optimize (void)\n \n \t      /* See whether it accepts all modes that occur in\n \t\t definition and uses.  */\n-\t      for (tmp = this_du; tmp; tmp = tmp->next_use)\n+\t      for (tmp = this_head->first; tmp; tmp = tmp->next_use)\n \t\tif ((! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc))\n \t\t     && ! DEBUG_INSN_P (tmp->insn))\n-\t\t    || (tmp->need_caller_save_reg\n+\t\t    || (this_head->need_caller_save_reg\n \t\t\t&& ! (HARD_REGNO_CALL_PART_CLOBBERED\n \t\t\t      (reg, GET_MODE (*tmp->loc)))\n \t\t\t&& (HARD_REGNO_CALL_PART_CLOBBERED\n@@ -327,8 +350,8 @@ regrename_optimize (void)\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"Register %s in insn %d\",\n-\t\t       reg_names[reg], INSN_UID (this_du->insn));\n-\t      if (this_du->need_caller_save_reg)\n+\t\t       reg_names[reg], INSN_UID (this_head->first->insn));\n+\t      if (this_head->need_caller_save_reg)\n \t\tfprintf (dump_file, \" crosses a call\");\n \t    }\n \n@@ -343,7 +366,7 @@ regrename_optimize (void)\n \t  if (dump_file)\n \t    fprintf (dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n \n-\t  do_replace (this_du, best_new_reg);\n+\t  do_replace (this_head, best_new_reg);\n \t  tick[best_new_reg] = ++this_tick;\n \t  df_set_regs_ever_live (best_new_reg, true);\n \t}\n@@ -360,16 +383,17 @@ regrename_optimize (void)\n }\n \n static void\n-do_replace (struct du_chain *chain, int reg)\n+do_replace (struct du_head *head, int reg)\n {\n-  unsigned int base_regno = REGNO (*chain->loc);\n+  struct du_chain *chain;\n+  unsigned int base_regno = head->regno;\n \n-  gcc_assert (! DEBUG_INSN_P (chain->insn));\n+  gcc_assert (! DEBUG_INSN_P (head->first->insn));\n \n-  while (chain)\n+  for (chain = head->first; chain; chain = chain->next_use)\n     {\n       unsigned int regno = ORIGINAL_REGNO (*chain->loc);\n-      struct reg_attrs * attr = REG_ATTRS (*chain->loc);\n+      struct reg_attrs *attr = REG_ATTRS (*chain->loc);\n       int reg_ptr = REG_POINTER (*chain->loc);\n \n       if (DEBUG_INSN_P (chain->insn) && REGNO (*chain->loc) != base_regno)\n@@ -399,37 +423,42 @@ do_replace (struct du_chain *chain, int reg)\n \t}\n \n       df_insn_rescan (chain->insn);\n-      chain = chain->next_use;\n     }\n }\n \n \n-static struct du_chain *open_chains;\n-static struct du_chain *closed_chains;\n+static struct du_head *open_chains;\n+static struct du_head *closed_chains;\n \n static void\n scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t      enum scan_actions action, enum op_type type, int earlyclobber)\n {\n-  struct du_chain **p;\n+  struct du_head **p;\n   rtx x = *loc;\n   enum machine_mode mode = GET_MODE (x);\n-  int this_regno = REGNO (x);\n-  int this_nregs = hard_regno_nregs[this_regno][mode];\n+  unsigned this_regno = REGNO (x);\n+  unsigned this_nregs = hard_regno_nregs[this_regno][mode];\n \n   if (action == mark_write)\n     {\n       if (type == OP_OUT)\n \t{\n+\t  struct du_head *head = XOBNEW (&rename_obstack, struct du_head);\n \t  struct du_chain *this_du = XOBNEW (&rename_obstack, struct du_chain);\n+\t  head->next_chain = open_chains;\n+\t  open_chains = head;\n+\t  head->first = head->last = this_du;\n+\t  head->regno = this_regno;\n+\t  head->nregs = this_nregs;\n+\t  head->need_caller_save_reg = 0;\n+\t  head->terminated = 0;\n+\n \t  this_du->next_use = 0;\n-\t  this_du->next_chain = open_chains;\n \t  this_du->loc = loc;\n \t  this_du->insn = insn;\n \t  this_du->cl = cl;\n-\t  this_du->need_caller_save_reg = 0;\n \t  this_du->earlyclobber = earlyclobber;\n-\t  open_chains = this_du;\n \t}\n       return;\n     }\n@@ -439,7 +468,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \n   for (p = &open_chains; *p;)\n     {\n-      struct du_chain *this_du = *p;\n+      struct du_head *head = *p;\n \n       /* Check if the chain has been terminated if it has then skip to\n \t the next chain.\n@@ -448,18 +477,17 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t the chain in Step 3, but are trying to hide in-out operands\n \t from terminate_write in Step 5.  */\n \n-      if (*this_du->loc == cc0_rtx)\n-\tp = &this_du->next_chain;\n+      if (head->terminated)\n+\tp = &head->next_chain;\n       else\n \t{\n-\t  int regno = REGNO (*this_du->loc);\n-\t  int nregs = hard_regno_nregs[regno][GET_MODE (*this_du->loc)];\n-\t  int exact_match = (regno == this_regno && nregs == this_nregs);\n+\t  int exact_match = (head->regno == this_regno\n+\t\t\t     && head->nregs == this_nregs);\n \n-\t  if (regno + nregs <= this_regno\n-\t      || this_regno + this_nregs <= regno)\n+\t  if (head->regno + head->nregs <= this_regno\n+\t      || this_regno + this_nregs <= head->regno)\n \t    {\n-\t      p = &this_du->next_chain;\n+\t      p = &head->next_chain;\n \t      continue;\n \t    }\n \n@@ -473,51 +501,50 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t\t be replaced with, terminate the chain.  */\n \t      if (cl != NO_REGS)\n \t\t{\n+\t\t  struct du_chain *this_du;\n \t\t  this_du = XOBNEW (&rename_obstack, struct du_chain);\n \t\t  this_du->next_use = 0;\n-\t\t  this_du->next_chain = (*p)->next_chain;\n \t\t  this_du->loc = loc;\n \t\t  this_du->insn = insn;\n \t\t  this_du->cl = cl;\n-\t\t  this_du->need_caller_save_reg = 0;\n-\t\t  while (*p)\n-\t\t    p = &(*p)->next_use;\n-\t\t  *p = this_du;\n+\t\t  head->last->next_use = this_du;\n+\t\t  head->last = this_du;\n \t\t  return;\n \t\t}\n \t    }\n \n \t  if (action != terminate_overlapping_read || ! exact_match)\n \t    {\n-\t      struct du_chain *next = this_du->next_chain;\n+\t      struct du_head *next = head->next_chain;\n \n \t      /* Whether the terminated chain can be used for renaming\n \t         depends on the action and this being an exact match.\n \t         In either case, we remove this element from open_chains.  */\n \n+\t      head->terminated = 1;\n \t      if ((action == terminate_dead || action == terminate_write)\n \t\t  && exact_match)\n \t\t{\n-\t\t  this_du->next_chain = closed_chains;\n-\t\t  closed_chains = this_du;\n+\t\t  head->next_chain = closed_chains;\n+\t\t  closed_chains = head;\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Closing chain %s at insn %d (%s)\\n\",\n-\t\t\t     reg_names[REGNO (*this_du->loc)], INSN_UID (insn),\n+\t\t\t     reg_names[head->regno], INSN_UID (insn),\n \t\t\t     scan_actions_name[(int) action]);\n \t\t}\n \t      else\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Discarding chain %s at insn %d (%s)\\n\",\n-\t\t\t     reg_names[REGNO (*this_du->loc)], INSN_UID (insn),\n+\t\t\t     reg_names[head->regno], INSN_UID (insn),\n \t\t\t     scan_actions_name[(int) action]);\n \t\t}\n \t      *p = next;\n \t    }\n \t  else\n-\t    p = &this_du->next_chain;\n+\t    p = &head->next_chain;\n \t}\n     }\n }\n@@ -760,7 +787,7 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl,\n \n /* Build def/use chain.  */\n \n-static struct du_chain *\n+static struct du_head *\n build_def_use (basic_block bb)\n {\n   rtx insn;\n@@ -914,7 +941,7 @@ build_def_use (basic_block bb)\n \t     requires a caller-saved reg.  */\n \t  if (CALL_P (insn))\n \t    {\n-\t      struct du_chain *p;\n+\t      struct du_head *p;\n \t      for (p = open_chains; p; p = p->next_chain)\n \t\tp->need_caller_save_reg = 1;\n \t    }\n@@ -1014,22 +1041,21 @@ build_def_use (basic_block bb)\n    printed in reverse order as that's how we build them.  */\n \n static void\n-dump_def_use_chain (struct du_chain *chains)\n+dump_def_use_chain (struct du_head *head)\n {\n-  while (chains)\n+  while (head)\n     {\n-      struct du_chain *this_du = chains;\n-      int r = REGNO (*this_du->loc);\n-      int nregs = hard_regno_nregs[r][GET_MODE (*this_du->loc)];\n-      fprintf (dump_file, \"Register %s (%d):\", reg_names[r], nregs);\n+      struct du_chain *this_du = head->first;\n+      fprintf (dump_file, \"Register %s (%d):\",\n+\t       reg_names[head->regno], head->nregs);\n       while (this_du)\n \t{\n \t  fprintf (dump_file, \" %d [%s]\", INSN_UID (this_du->insn),\n \t\t   reg_class_names[this_du->cl]);\n \t  this_du = this_du->next_use;\n \t}\n       fprintf (dump_file, \"\\n\");\n-      chains = chains->next_chain;\n+      head = head->next_chain;\n     }\n }\n "}]}