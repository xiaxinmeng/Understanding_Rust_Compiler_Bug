{"sha": "20b5d666e7c8f05951fa54942a24174e600f8884", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBiNWQ2NjZlN2M4ZjA1OTUxZmE1NDk0MmEyNDE3NGU2MDBmODg4NA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-10-31T17:54:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:54:34Z"}, "message": "exp_ch4.adb (Expand_N_Type_Conversion): Handle missing interface type conversion.\n\n2006-10-31  Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n        \n        * exp_ch4.adb (Expand_N_Type_Conversion): Handle missing interface type\n\tconversion.\n        (Expand_N_In): Do validity checks on range\n\t(Expand_Selected_Component): Use updated for of Denotes_Discriminant.\n\t(Expand_N_Allocator): For \"new T\", if the object is constrained by\n\tdiscriminant defaults, allocate the right amount of memory, rather than\n\tthe maximum for type T.\n\t(Expand_Allocator_Expression): Suppress the call to Remove_Side_Effects\n\twhen the allocator is initialized by a build-in-place call, since the\n\tallocator is already rewritten as a reference to the function result,\n\tand this prevents an unwanted duplication of the function call.\n\tAdd with and use of Exp_Ch6.\n\t(Expand_Allocator_Expresssion): Check for an allocator whose expression\n\tis a call to build-in-place function and apply\n\tMake_Build_In_Place_Call_In_Allocator to the call (for both tagged and\n\tuntagged designated types).\n\t(Expand_N_Unchecked_Type_Conversion): Do not do integer literal\n\toptimization if source or target is biased.\n\t(Expand_N_Allocator): Add comments for case of an allocator within a\n\tfunction that returns an anonymous access type designating tasks.\n\t(Expand_N_Allocator): apply discriminant checks for access\n\tdiscriminants of anonymous access types (AI-402, AI-416)\n\nFrom-SVN: r118257", "tree": {"sha": "c91c1f18bd617f5763be3533122803393e01ad82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c91c1f18bd617f5763be3533122803393e01ad82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20b5d666e7c8f05951fa54942a24174e600f8884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b5d666e7c8f05951fa54942a24174e600f8884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20b5d666e7c8f05951fa54942a24174e600f8884", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b5d666e7c8f05951fa54942a24174e600f8884/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3476f949088b2f18c0cee16a36ea4ea330248138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3476f949088b2f18c0cee16a36ea4ea330248138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3476f949088b2f18c0cee16a36ea4ea330248138"}], "stats": {"total": 274, "additions": 182, "deletions": 92}, "files": [{"sha": "a65809fb63801a58e08e6749120e035c8bd24af6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 182, "deletions": 92, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20b5d666e7c8f05951fa54942a24174e600f8884/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20b5d666e7c8f05951fa54942a24174e600f8884/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=20b5d666e7c8f05951fa54942a24174e600f8884", "patch": "@@ -31,8 +31,10 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch3;  use Exp_Ch3;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n+with Exp_Disp; use Exp_Disp;\n with Exp_Fixd; use Exp_Fixd;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Tss;  use Exp_Tss;\n@@ -192,7 +194,7 @@ package body Exp_Ch4 is\n    --  this by using Convert_To_Actual_Subtype if necessary).\n \n    procedure Rewrite_Comparison (N : Node_Id);\n-   --  if N is the node for a comparison whose outcome can be determined at\n+   --  If N is the node for a comparison whose outcome can be determined at\n    --  compile time, then the node N can be rewritten with True or False. If\n    --  the outcome cannot be determined at compile time, the call has no\n    --  effect. If N is a type conversion, then this processing is applied to\n@@ -382,12 +384,28 @@ package body Exp_Ch4 is\n \n       Aggr_In_Place : constant Boolean := Is_Delayed_Aggregate (Exp);\n \n+      Call_In_Place : Boolean := False;\n+\n       Tag_Assign : Node_Id;\n       Tmp_Node   : Node_Id;\n \n    begin\n       if Is_Tagged_Type (T) or else Controlled_Type (T) then\n \n+         --  Ada 2005 (AI-318-02): If the initialization expression is a\n+         --  call to a build-in-place function, then access to the allocated\n+         --  object must be passed to the function. Currently we limit such\n+         --  functions to those with constrained limited result subtypes,\n+         --  but eventually we plan to expand the allowed forms of funtions\n+         --  that are treated as build-in-place.\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Build_In_Place_Function_Call (Exp)\n+         then\n+            Make_Build_In_Place_Call_In_Allocator (N, Exp);\n+            Call_In_Place := True;\n+         end if;\n+\n          --    Actions inserted before:\n          --              Temp : constant ptr_T := new T'(Expression);\n          --   <no CW>    Temp._tag := T'tag;\n@@ -397,7 +415,12 @@ package body Exp_Ch4 is\n          --  We analyze by hand the new internal allocator to avoid\n          --  any recursion and inappropriate call to Initialize\n \n-         if not Aggr_In_Place then\n+         --  We don't want to remove side effects when the expression must be\n+         --  built in place. In the case of a build-in-place function call,\n+         --  that could lead to a duplication of the call, which was already\n+         --  substituted for the allocator.\n+\n+         if not Aggr_In_Place and then not Call_In_Place then\n             Remove_Side_Effects (Exp);\n          end if;\n \n@@ -700,6 +723,18 @@ package body Exp_Ch4 is\n             end;\n          end if;\n \n+         --  Ada 2005 (AI-318-02): If the initialization expression is a\n+         --  call to a build-in-place function, then access to the allocated\n+         --  object must be passed to the function. Currently we limit such\n+         --  functions to those with constrained limited result subtypes,\n+         --  but eventually we plan to expand the allowed forms of funtions\n+         --  that are treated as build-in-place.\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Build_In_Place_Function_Call (Exp)\n+         then\n+            Make_Build_In_Place_Call_In_Allocator (N, Exp);\n+         end if;\n       end if;\n \n    exception\n@@ -2630,21 +2665,21 @@ package body Exp_Ch4 is\n                   Set_Assignment_OK (Arg1);\n                   Temp_Type := PtrT;\n \n-                  --  The initialization procedure expects a specific type.\n-                  --  if the context is access to class wide, indicate that\n-                  --  the object being allocated has the right specific type.\n+                  --  The initialization procedure expects a specific type. if\n+                  --  the context is access to class wide, indicate that the\n+                  --  object being allocated has the right specific type.\n \n                   if Is_Class_Wide_Type (Dtyp) then\n                      Arg1 := Unchecked_Convert_To (T, Arg1);\n                   end if;\n                end if;\n \n-               --  If designated type is a concurrent type or if it is a\n-               --  private type whose definition is a concurrent type,\n-               --  the first argument in the Init routine has to be\n-               --  unchecked conversion to the corresponding record type.\n-               --  If the designated type is a derived type, we also\n-               --  convert the argument to its root type.\n+               --  If designated type is a concurrent type or if it is private\n+               --  type whose definition is a concurrent type, the first\n+               --  argument in the Init routine has to be unchecked conversion\n+               --  to the corresponding record type. If the designated type is\n+               --  a derived type, we also convert the argument to its root\n+               --  type.\n \n                if Is_Concurrent_Type (T) then\n                   Arg1 :=\n@@ -2671,29 +2706,31 @@ package body Exp_Ch4 is\n \n                Args := New_List (Arg1);\n \n-               --  For the task case, pass the Master_Id of the access type\n-               --  as the value of the _Master parameter, and _Chain as the\n-               --  value of the _Chain parameter (_Chain will be defined as\n-               --  part of the generated code for the allocator).\n+               --  For the task case, pass the Master_Id of the access type as\n+               --  the value of the _Master parameter, and _Chain as the value\n+               --  of the _Chain parameter (_Chain will be defined as part of\n+               --  the generated code for the allocator).\n+\n+               --  In Ada 2005, the context may be a function that returns an\n+               --  anonymous access type. In that case the Master_Id has been\n+               --  created when expanding the function declaration.\n \n                if Has_Task (T) then\n                   if No (Master_Id (Base_Type (PtrT))) then\n \n-                     --  The designated type was an incomplete type, and\n-                     --  the access type did not get expanded. Salvage\n-                     --  it now.\n+                     --  The designated type was an incomplete type, and the\n+                     --  access type did not get expanded. Salvage it now.\n \n                      Expand_N_Full_Type_Declaration\n                        (Parent (Base_Type (PtrT)));\n                   end if;\n \n-                  --  If the context of the allocator is a declaration or\n-                  --  an assignment, we can generate a meaningful image for\n-                  --  it, even though subsequent assignments might remove\n-                  --  the connection between task and entity. We build this\n-                  --  image when the left-hand side is a simple variable,\n-                  --  a simple indexed assignment or a simple selected\n-                  --  component.\n+                  --  If the context of the allocator is a declaration or an\n+                  --  assignment, we can generate a meaningful image for it,\n+                  --  even though subsequent assignments might remove the\n+                  --  connection between task and entity. We build this image\n+                  --  when the left-hand side is a simple variable, a simple\n+                  --  indexed assignment or a simple selected component.\n \n                   if Nkind (Parent (N)) = N_Assignment_Statement then\n                      declare\n@@ -2745,26 +2782,60 @@ package body Exp_Ch4 is\n \n                --  Add discriminants if discriminated type\n \n-               if Has_Discriminants (T) then\n-                  Discr := First_Elmt (Discriminant_Constraint (T));\n+               declare\n+                  Dis : Boolean := False;\n+                  Typ : Entity_Id;\n \n-                  while Present (Discr) loop\n-                     Append (New_Copy_Tree (Elists.Node (Discr)), Args);\n-                     Next_Elmt (Discr);\n-                  end loop;\n+               begin\n+                  if Has_Discriminants (T) then\n+                     Dis := True;\n+                     Typ := T;\n \n-               elsif Is_Private_Type (T)\n-                 and then Present (Full_View (T))\n-                 and then Has_Discriminants (Full_View (T))\n-               then\n-                  Discr :=\n-                    First_Elmt (Discriminant_Constraint (Full_View (T)));\n+                  elsif Is_Private_Type (T)\n+                    and then Present (Full_View (T))\n+                    and then Has_Discriminants (Full_View (T))\n+                  then\n+                     Dis := True;\n+                     Typ := Full_View (T);\n+                  end if;\n \n-                  while Present (Discr) loop\n-                     Append (New_Copy_Tree (Elists.Node (Discr)), Args);\n-                     Next_Elmt (Discr);\n-                  end loop;\n-               end if;\n+                  if Dis then\n+                     --  If the allocated object will be constrained by the\n+                     --  default values for discriminants, then build a\n+                     --  subtype with those defaults, and change the allocated\n+                     --  subtype to that. Note that this happens in fewer\n+                     --  cases in Ada 2005 (AI-363).\n+\n+                     if not Is_Constrained (Typ)\n+                       and then Present (Discriminant_Default_Value\n+                                         (First_Discriminant (Typ)))\n+                       and then (Ada_Version < Ada_05\n+                                or else not Has_Constrained_Partial_View (Typ))\n+                     then\n+                        Typ := Build_Default_Subtype (Typ, N);\n+                        Set_Expression (N, New_Reference_To (Typ, Loc));\n+                     end if;\n+\n+                     Discr := First_Elmt (Discriminant_Constraint (Typ));\n+                     while Present (Discr) loop\n+                        Node := Elists.Node (Discr);\n+                        Append (New_Copy_Tree (Elists.Node (Discr)), Args);\n+\n+                        --  AI-416: when the discriminant constraint is an\n+                        --  anonymous access type make sure an accessibility\n+                        --  check is inserted if necessary (3.10.2(22.q/2))\n+\n+                        if Ada_Version >= Ada_05\n+                          and then\n+                            Ekind (Etype (Node)) = E_Anonymous_Access_Type\n+                        then\n+                           Apply_Accessibility_Check (Node, Typ);\n+                        end if;\n+\n+                        Next_Elmt (Discr);\n+                     end loop;\n+                  end if;\n+               end;\n \n                --  We set the allocator as analyzed so that when we analyze the\n                --  expression actions node, we do not get an unwanted recursive\n@@ -2780,8 +2851,8 @@ package body Exp_Ch4 is\n                --    <CTRL>  Attach_To_Final_List (Finalizable (Temp.all));\n                --    <CTRL>  Initialize (Finalizable (Temp.all));\n \n-               --  Here ptr_T is the pointer type for the allocator, and T\n-               --  is the subtype of the allocator.\n+               --  Here ptr_T is the pointer type for the allocator, and is the\n+               --  subtype of the allocator.\n \n                Temp_Decl :=\n                  Make_Object_Declaration (Loc,\n@@ -2798,8 +2869,8 @@ package body Exp_Ch4 is\n \n                Insert_Action (N, Temp_Decl, Suppress => All_Checks);\n \n-               --  If the designated type is task type or contains tasks,\n-               --  Create block to activate created tasks, and insert\n+               --  If the designated type is a task type or contains tasks,\n+               --  create block to activate created tasks, and insert\n                --  declaration for Task_Image variable ahead of call.\n \n                if Has_Task (T) then\n@@ -2899,8 +2970,8 @@ package body Exp_Ch4 is\n    -- Expand_N_And_Then --\n    -----------------------\n \n-   --  Expand into conditional expression if Actions present, and also\n-   --  deal with optimizing case of arguments being True or False.\n+   --  Expand into conditional expression if Actions present, and also deal\n+   --  with optimizing case of arguments being True or False.\n \n    procedure Expand_N_And_Then (N : Node_Id) is\n       Loc     : constant Source_Ptr := Sloc (N);\n@@ -2935,9 +3006,9 @@ package body Exp_Ch4 is\n             Adjust_Result_Type (N, Typ);\n             return;\n \n-         --  If left argument is False, change (False and then Right) to\n-         --  False. In this case we can forget the actions associated with\n-         --  Right, since they will never be executed.\n+         --  If left argument is False, change (False and then Right) to False.\n+         --  In this case we can forget the actions associated with Right,\n+         --  since they will never be executed.\n \n          elsif Entity (Left) = Standard_False then\n             Kill_Dead_Code (Right);\n@@ -3134,6 +3205,13 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Do validity check on operands\n+\n+      if Validity_Checks_On and Validity_Check_Operands then\n+         Ensure_Valid (Left_Opnd (N));\n+         Validity_Check_Range (Right_Opnd (N));\n+      end if;\n+\n       --  Case of explicit range\n \n       if Nkind (Rop) = N_Range then\n@@ -3235,11 +3313,10 @@ package body Exp_Ch4 is\n \n             if Is_Tagged_Type (Typ) then\n \n-               --  No expansion will be performed when Java_VM, as the\n-               --  JVM back end will handle the membership tests directly\n-               --  (tags are not explicitly represented in Java objects,\n-               --  so the normal tagged membership expansion is not what\n-               --  we want).\n+               --  No expansion will be performed when Java_VM, as the JVM back\n+               --  end will handle the membership tests directly (tags are not\n+               --  explicitly represented in Java objects, so the normal tagged\n+               --  membership expansion is not what we want).\n \n                if not Java_VM then\n                   Rewrite (N, Tagged_Membership (N));\n@@ -3248,7 +3325,7 @@ package body Exp_Ch4 is\n \n                return;\n \n-            --  If type is scalar type, rewrite as x in t'first .. t'last\n+            --  If type is scalar type, rewrite as x in t'first .. t'last.\n             --  This reason we do this is that the bounds may have the wrong\n             --  type if they come from the original type definition.\n \n@@ -6149,7 +6226,7 @@ package body Exp_Ch4 is\n \n                      if\n                        Denotes_Discriminant\n-                        (Node (Dcon), Check_Protected => True)\n+                        (Node (Dcon), Check_Concurrent => True)\n                      then\n                         exit Discr_Loop;\n \n@@ -6847,6 +6924,13 @@ package body Exp_Ch4 is\n                Actual_Target_Type  := Target_Type;\n             end if;\n \n+            --  Ada 2005 (AI-251): Handle interface type conversion\n+\n+            if Is_Interface (Actual_Operand_Type) then\n+               Expand_Interface_Conversion (N, Is_Static => False);\n+               return;\n+            end if;\n+\n             if Is_Class_Wide_Type (Actual_Operand_Type)\n               and then Root_Type (Actual_Operand_Type) /=  Actual_Target_Type\n               and then Is_Ancestor\n@@ -7242,8 +7326,14 @@ package body Exp_Ch4 is\n       --  flag is set, since then the value may be outside the expected range.\n       --  This happens in the Normalize_Scalars case.\n \n+      --  We also skip this if either the target or operand type is biased\n+      --  because in this case, the unchecked conversion is supposed to\n+      --  preserve the bit pattern, not the integer value.\n+\n       if Is_Integer_Type (Target_Type)\n+        and then not Has_Biased_Representation (Target_Type)\n         and then Is_Integer_Type (Operand_Type)\n+        and then not Has_Biased_Representation (Operand_Type)\n         and then Compile_Time_Known_Value (Operand)\n         and then not Kill_Range_Check (N)\n       then\n@@ -7692,17 +7782,17 @@ package body Exp_Ch4 is\n    --    type elem is  (<>);\n    --    type index is (<>);\n    --    type a is array (index range <>) of elem;\n-   --\n+\n    --  function Gnnn (X : a; Y: a) return boolean is\n    --    J : index := Y'first;\n-   --\n+\n    --  begin\n    --    if X'length = 0 then\n    --       return false;\n-   --\n+\n    --    elsif Y'length = 0 then\n    --       return true;\n-   --\n+\n    --    else\n    --      for I in X'range loop\n    --        if X (I) = Y (J) then\n@@ -7711,12 +7801,12 @@ package body Exp_Ch4 is\n    --          else\n    --            J := index'succ (J);\n    --          end if;\n-   --\n+\n    --        else\n    --           return X (I) > Y (J);\n    --        end if;\n    --      end loop;\n-   --\n+\n    --      return X'length > Y'length;\n    --    end if;\n    --  end Gnnn;\n@@ -8077,24 +8167,25 @@ package body Exp_Ch4 is\n    begin\n       if Nkind (N) = N_Type_Conversion then\n          Rewrite_Comparison (Expression (N));\n+         return;\n \n       elsif Nkind (N) not in N_Op_Compare then\n-         null;\n+         return;\n+      end if;\n \n-      else\n-         declare\n-            Typ : constant Entity_Id := Etype (N);\n-            Op1 : constant Node_Id   := Left_Opnd (N);\n-            Op2 : constant Node_Id   := Right_Opnd (N);\n+      declare\n+         Typ : constant Entity_Id := Etype (N);\n+         Op1 : constant Node_Id   := Left_Opnd (N);\n+         Op2 : constant Node_Id   := Right_Opnd (N);\n \n-            Res : constant Compare_Result := Compile_Time_Compare (Op1, Op2);\n-            --  Res indicates if compare outcome can be compile time determined\n+         Res : constant Compare_Result := Compile_Time_Compare (Op1, Op2);\n+         --  Res indicates if compare outcome can be compile time determined\n \n-            True_Result  : Boolean;\n-            False_Result : Boolean;\n+         True_Result  : Boolean;\n+         False_Result : Boolean;\n \n-         begin\n-            case N_Op_Compare (Nkind (N)) is\n+      begin\n+         case N_Op_Compare (Nkind (N)) is\n             when N_Op_Eq =>\n                True_Result  := Res = EQ;\n                False_Result := Res = LT or else Res = GT or else Res = NE;\n@@ -8142,24 +8233,23 @@ package body Exp_Ch4 is\n             when N_Op_Ne =>\n                True_Result  := Res = NE or else Res = GT or else Res = LT;\n                False_Result := Res = EQ;\n-            end case;\n+         end case;\n \n-            if True_Result then\n-               Rewrite (N,\n-                 Convert_To (Typ,\n-                   New_Occurrence_Of (Standard_True, Sloc (N))));\n-               Analyze_And_Resolve (N, Typ);\n-               Warn_On_Known_Condition (N);\n+         if True_Result then\n+            Rewrite (N,\n+              Convert_To (Typ,\n+                New_Occurrence_Of (Standard_True, Sloc (N))));\n+            Analyze_And_Resolve (N, Typ);\n+            Warn_On_Known_Condition (N);\n \n-            elsif False_Result then\n-               Rewrite (N,\n-                 Convert_To (Typ,\n-                   New_Occurrence_Of (Standard_False, Sloc (N))));\n-               Analyze_And_Resolve (N, Typ);\n-               Warn_On_Known_Condition (N);\n-            end if;\n-         end;\n-      end if;\n+         elsif False_Result then\n+            Rewrite (N,\n+              Convert_To (Typ,\n+                New_Occurrence_Of (Standard_False, Sloc (N))));\n+            Analyze_And_Resolve (N, Typ);\n+            Warn_On_Known_Condition (N);\n+         end if;\n+      end;\n    end Rewrite_Comparison;\n \n    ----------------------------"}]}