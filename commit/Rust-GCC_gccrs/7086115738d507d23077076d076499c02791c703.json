{"sha": "7086115738d507d23077076d076499c02791c703", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4NjExNTczOGQ1MDdkMjMwNzcwNzZkMDc2NDk5YzAyNzkxYzcwMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:41:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:41:04Z"}, "message": "[multiple changes]\n\n2013-04-24  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb, sem_ch7.adb: Minor reformatting.\n\t* gnat_rm.texi: Document pragma Loop_Invariant.\n\t* sem_attr.adb (Analyze_Attribute, case Loop_Entry): This is\n\tno longer an S14_Attribute.\n\t* sem_prag.adb (Analyze_Pragma, case Loop_Invariant): Combine\n\tprocessing with Assert, allow message parameter, remove call\n\tto S14_Pragma.\n\n2013-04-24  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb: Minor reformatting.\n\nFrom-SVN: r198241", "tree": {"sha": "7141db9e00c10e8daf06deb7a71f61e2b545f5b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7141db9e00c10e8daf06deb7a71f61e2b545f5b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7086115738d507d23077076d076499c02791c703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7086115738d507d23077076d076499c02791c703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7086115738d507d23077076d076499c02791c703", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7086115738d507d23077076d076499c02791c703/comments", "author": null, "committer": null, "parents": [{"sha": "24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24778dbb9a732e8c626807b1a5f4bfe8cec09a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24778dbb9a732e8c626807b1a5f4bfe8cec09a58"}], "stats": {"total": 170, "additions": 105, "deletions": 65}, "files": [{"sha": "5cbe4b17bf87a7eb7a0e1425c61b2fd13ecc1c3e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7086115738d507d23077076d076499c02791c703", "patch": "@@ -1,3 +1,17 @@\n+2013-04-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb, sem_ch7.adb: Minor reformatting.\n+\t* gnat_rm.texi: Document pragma Loop_Invariant.\n+\t* sem_attr.adb (Analyze_Attribute, case Loop_Entry): This is\n+\tno longer an S14_Attribute.\n+\t* sem_prag.adb (Analyze_Pragma, case Loop_Invariant): Combine\n+\tprocessing with Assert, allow message parameter, remove call\n+\tto S14_Pragma.\n+\n+2013-04-24  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb: Minor reformatting.\n+\n 2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch7.adb (Swap_Private_Dependents): New internal routine"}, {"sha": "e1b6cf0e5cc93a247351d7ca1ca753e1c279a557", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=7086115738d507d23077076d076499c02791c703", "patch": "@@ -4191,7 +4191,7 @@ package body Exp_Ch4 is\n \n       --  Local variables\n \n-      Dtyp    : constant Entity_Id  := Available_View (Designated_Type (PtrT));\n+      Dtyp    : constant Entity_Id := Available_View (Designated_Type (PtrT));\n       Desig   : Entity_Id;\n       Nod     : Node_Id;\n       Pool    : Entity_Id;"}, {"sha": "023cd12346fc9df294507764ce071b8bb559e869", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=7086115738d507d23077076d076499c02791c703", "patch": "@@ -179,6 +179,7 @@ Implementation Defined Pragmas\n * Pragma Linker_Destructor::\n * Pragma Linker_Section::\n * Pragma Long_Float::\n+* Pragma Loop_Invariant::\n * Pragma Loop_Optimize::\n * Pragma Loop_Variant::\n * Pragma Machine_Attribute::\n@@ -937,6 +938,7 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Linker_Destructor::\n * Pragma Linker_Section::\n * Pragma Long_Float::\n+* Pragma Loop_Invariant::\n * Pragma Loop_Optimize::\n * Pragma Loop_Variant::\n * Pragma Machine_Attribute::\n@@ -3993,6 +3995,33 @@ For further details on this pragma, see the\n @cite{DEC Ada Language Reference Manual}, section 3.5.7b.  Note that to use\n this pragma, the standard runtime libraries must be recompiled.\n \n+@node Pragma Loop_Invariant\n+@unnumberedsec Pragma Loop_Invariant\n+@findex Loop_Invariant\n+@noindent\n+Syntax:\n+@smallexample @c ada\n+pragma Loop_Invariant ( boolean_EXPRESSION );\n+\n+@end smallexample\n+\n+@noindent\n+The effect of this pragma is similar to that of pragma @code{Assert},\n+except that in an @code{Assertion_Policy} pragma, the identifier\n+@code{Loop_Invariant} is used to control whether it is ignored or checked\n+(or disabled).\n+\n+@code{Loop_Invariant} can only appear as one of the items in the sequence\n+of statements of a loop body. The intention is that it be used to\n+represent a \"loop invariant\" assertion, i.e. something that is true each\n+time through the loop, and which can be used to show that the loop is\n+achieving its purpose.\n+\n+To aid in writing such invariants, the special attribute @code{Loop_Entry}\n+may be used to refer to the value of an expression on entry to the loop. This\n+attribute can only be used within the expression of a @code{Loop_Invariant}\n+pragma. For full details, see documentation of attribute @code{Loop_Entry}.\n+\n @node Pragma Loop_Optimize\n @unnumberedsec Pragma Loop_Optimize\n @findex Loop_Optimize"}, {"sha": "f3845f60c74be5f3bc1abcdac0a6133700c3468e", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=7086115738d507d23077076d076499c02791c703", "patch": "@@ -379,6 +379,8 @@ package body Sem_Attr is\n       procedure S14_Attribute;\n       --  Called for all attributes defined for formal verification to check\n       --  that the S14_Extensions flag is set.\n+      --  Bad name ???\n+      --  No such thing as S14_Extensions flag ???\n \n       procedure Standard_Attribute (Val : Int);\n       --  Used to process attributes whose prefix is package Standard which\n@@ -3729,8 +3731,6 @@ package body Sem_Attr is\n          --  expression list. Instead, all available expressions are stored as\n          --  indexed components.\n \n-         S14_Attribute;\n-\n          --  When the attribute is part of an indexed component, find the first\n          --  expression as it will determine the semantics of 'Loop_Entry.\n "}, {"sha": "89f11dc6c83e6e00e578830e342c1bf25c0db9d5", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7086115738d507d23077076d076499c02791c703", "patch": "@@ -8659,7 +8659,7 @@ package body Sem_Ch3 is\n          Set_Known_To_Have_Preelab_Init\n            (Def_Id, Known_To_Have_Preelab_Init (T));\n \n-         --  private subtypes may have private dependents.\n+         --  Private subtypes may have private dependents\n \n          Set_Private_Dependents (Def_Id, New_Elmt_List);\n "}, {"sha": "b98bf9c1e4717676fc9b9d216c48a5bb66818c88", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=7086115738d507d23077076d076499c02791c703", "patch": "@@ -1820,6 +1820,10 @@ package body Sem_Ch7 is\n       --  same for its private dependents under proper visibility conditions.\n       --  When compiling a grand-chid unit this needs to be done recursively.\n \n+      -----------------------------\n+      -- Swap_Private_Dependents --\n+      -----------------------------\n+\n       procedure Swap_Private_Dependents (Priv_Deps : Elist_Id) is\n          Deps      : Elist_Id;\n          Priv      : Entity_Id;\n@@ -1828,13 +1832,12 @@ package body Sem_Ch7 is\n \n       begin\n          Priv_Elmt := First_Elmt (Priv_Deps);\n-\n          while Present (Priv_Elmt) loop\n             Priv := Node (Priv_Elmt);\n \n-            --  Before the exchange, verify that the presence of the\n-            --  Full_View field. It will be empty if the entity has already\n-            --  been installed due to a previous call.\n+            --  Before the exchange, verify that the presence of the Full_View\n+            --  field. This field will be empty if the entity has already been\n+            --  installed due to a previous call.\n \n             if Present (Full_View (Priv))\n               and then Is_Visible_Dependent (Priv)\n@@ -1846,9 +1849,9 @@ package body Sem_Ch7 is\n                   Is_Priv := False;\n                end if;\n \n-               --  For each subtype that is swapped, we also swap the\n-               --  reference to it in Private_Dependents, to allow access\n-               --  to it when we swap them out in End_Package_Scope.\n+               --  For each subtype that is swapped, we also swap the reference\n+               --  to it in Private_Dependents, to allow access to it when we\n+               --  swap them out in End_Package_Scope.\n \n                Replace_Elmt (Priv_Elmt, Full_View (Priv));\n                Exchange_Declarations (Priv);\n@@ -1857,7 +1860,7 @@ package body Sem_Ch7 is\n                Set_Is_Potentially_Use_Visible\n                  (Priv, Is_Potentially_Use_Visible (Node (Priv_Elmt)));\n \n-               --  Within a child unit, recurse.\n+               --  Within a child unit, recurse\n \n                if Is_Priv\n                  and then Is_Child_Unit (Cunit_Entity (Current_Sem_Unit))\n@@ -1870,14 +1873,16 @@ package body Sem_Ch7 is\n          end loop;\n       end Swap_Private_Dependents;\n \n+   --  Start processing for Install_Private_Declarations\n+\n    begin\n       --  First exchange declarations for private types, so that the full\n       --  declaration is visible. For each private type, we check its\n       --  Private_Dependents list and also exchange any subtypes of or derived\n       --  types from it. Finally, if this is a Taft amendment type, the\n       --  incomplete declaration is irrelevant, and we want to link the\n-      --  eventual full declaration with the original private one so we also\n-      --  skip the exchange.\n+      --  eventual full declaration with the original private one so we\n+      --  also skip the exchange.\n \n       Id := First_Entity (P);\n       while Present (Id) and then Id /= First_Private_Entity (P) loop\n@@ -1887,8 +1892,8 @@ package body Sem_Ch7 is\n            and then Scope (Full_View (Id)) = Scope (Id)\n            and then Ekind (Full_View (Id)) /= E_Incomplete_Type\n          then\n-            --  If there is a use-type clause on the private type, set the\n-            --  full view accordingly.\n+            --  If there is a use-type clause on the private type, set the full\n+            --  view accordingly.\n \n             Set_In_Use (Full_View (Id), In_Use (Id));\n             Full := Full_View (Id);\n@@ -1904,9 +1909,9 @@ package body Sem_Ch7 is\n                --  from another private type which is not private anymore. This\n                --  can only happen in a package nested within a child package,\n                --  when the parent type is defined in the parent unit. At this\n-               --  point the current type is not private either, and we have to\n-               --  install the underlying full view, which is now visible. Save\n-               --  the current full view as well, so that all views can be\n+               --  point the current type is not private either, and we have\n+               --  to install the underlying full view, which is now visible.\n+               --  Save the current full view as well, so that all views can be\n                --  restored on exit. It may seem that after compiling the child\n                --  body there are not environments to restore, but the back-end\n                --  expects those links to be valid, and freeze nodes depend on\n@@ -2069,7 +2074,6 @@ package body Sem_Ch7 is\n       else\n          declare\n             Prev : Entity_Id;\n-\n          begin\n             Prev := Find_Type_Name (N);\n             pragma Assert (Prev = Id"}, {"sha": "0b232153a8c444a40e63c11acd49955b43707f05", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 38, "deletions": 45, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7086115738d507d23077076d076499c02791c703/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=7086115738d507d23077076d076499c02791c703", "patch": "@@ -8828,9 +8828,9 @@ package body Sem_Prag is\n             end if;\n          end Annotate;\n \n-         ----------------------------------\n-         -- Assert/Assert_And_Cut/Assume --\n-         ----------------------------------\n+         -------------------------------------------------\n+         -- Assert/Assert_And_Cut/Assume/Loop_Invariant --\n+         -------------------------------------------------\n \n          --  pragma Assert\n          --    (   [Check => ]  Boolean_EXPRESSION\n@@ -8844,17 +8844,27 @@ package body Sem_Prag is\n          --    (   [Check => ]  Boolean_EXPRESSION\n          --     [, [Message =>] Static_String_EXPRESSION]);\n \n+         --  pragma Loop_Invariant\n+         --    (   [Check => ]  Boolean_EXPRESSION\n+         --     [, [Message =>] Static_String_EXPRESSION]);\n+\n          when Pragma_Assert         |\n               Pragma_Assert_And_Cut |\n-              Pragma_Assume         =>\n+              Pragma_Assume         |\n+              Pragma_Loop_Invariant =>\n          Assert : declare\n             Expr : Node_Id;\n             Newa : List_Id;\n \n          begin\n+            --  Assert is an Ada 2005 RM-defined pragma\n+\n             if Prag_Id = Pragma_Assert then\n                Ada_2005_Pragma;\n-            else -- Pragma_Assert_And_Cut\n+\n+            --  The remaining ones are GNAT pragmas\n+\n+            else\n                GNAT_Pragma;\n             end if;\n \n@@ -8863,19 +8873,32 @@ package body Sem_Prag is\n             Check_Arg_Order ((Name_Check, Name_Message));\n             Check_Optional_Identifier (Arg1, Name_Check);\n \n-            --  We treat pragma Assert[_And_Cut] as equivalent to:\n+            --  Special processing for Loop_Invariant\n \n-            --    pragma Check (Assert[_And_Cut], condition [, msg]);\n+            if Prag_Id = Pragma_Loop_Invariant then\n \n-            --  So rewrite pragma in this manner, transfer the message\n-            --  argument if present, and analyze the result\n+               --  Check restricted placement, must be within a loop\n \n-            --  Pragma Assert_And_Cut is treated exactly like pragma Assert by\n-            --  the frontend. Formal verification tools may use it to \"cut\" the\n-            --  paths through the code, to make verification tractable. When\n-            --  dealing with a semantically analyzed tree, the information that\n-            --  a Check node N corresponds to a source Assert_And_Cut pragma\n-            --  can be retrieved from the pragma kind of Original_Node(N).\n+               Check_Loop_Pragma_Placement;\n+\n+               --  Do preanalyze to deal with embedded Loop_Entry attribute\n+\n+               Preanalyze_Assert_Expression (Expression (Arg1), Any_Boolean);\n+            end if;\n+\n+            --  Implement Assert[_And_Cut]/Assume/Loop_Invariant by generating\n+            --  a corresponding Check pragma:\n+\n+            --    pragma Check (name, condition [, msg]);\n+\n+            --  Where name is the identifier matching the pragma name. So\n+            --  rewrite pragma in this manner, transfer the message argument\n+            --  if present, and analyze the result\n+\n+            --  Note: When dealing with a semantically analyzed tree, the\n+            --  information that a Check node N corresponds to a source Assert,\n+            --  Assume, or Assert_And_Cut pragma can be retrieved from the\n+            --  pragma kind of Original_Node(N).\n \n             Expr := Get_Pragma_Arg (Arg1);\n             Newa := New_List (\n@@ -13890,36 +13913,6 @@ package body Sem_Prag is\n             Set_Standard_Fpt_Formats;\n          end Long_Float;\n \n-         --------------------\n-         -- Loop_Invariant --\n-         --------------------\n-\n-         --  pragma Loop_Invariant ( boolean_EXPRESSION );\n-\n-         when Pragma_Loop_Invariant => Loop_Invariant : declare\n-         begin\n-            GNAT_Pragma;\n-            S14_Pragma;\n-            Check_Arg_Count (1);\n-            Check_Loop_Pragma_Placement;\n-\n-            Preanalyze_Assert_Expression (Expression (Arg1), Any_Boolean);\n-\n-            --  Transform pragma Loop_Invariant into equivalent pragma Check\n-            --  Generate:\n-            --    pragma Check (Loop_Invaraint, Arg1);\n-\n-            Rewrite (N,\n-              Make_Pragma (Loc,\n-                Chars                        => Name_Check,\n-                Pragma_Argument_Associations => New_List (\n-                  Make_Pragma_Argument_Association (Loc,\n-                    Expression => Make_Identifier (Loc, Name_Loop_Invariant)),\n-                  Relocate_Node (Arg1))));\n-\n-            Analyze (N);\n-         end Loop_Invariant;\n-\n          -------------------\n          -- Loop_Optimize --\n          -------------------"}]}