{"sha": "7097b0410ed48d3b7a5099e12fcec14b80f86910", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA5N2IwNDEwZWQ0OGQzYjdhNTA5OWUxMmZjZWMxNGI4MGY4NjkxMA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-04-29T20:26:56Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2011-04-29T20:26:56Z"}, "message": "re PR fortran/48462 (realloc on assignment: matmul Segmentation Fault with Allocatable Array)\n\n2011-04-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/48462\n\t* trans-expr.c (arrayfunc_assign_needs_temporary): Deal with\n\tautomatic reallocation when the lhs is a target.\n\n\tPR fortran/48746\n\t* trans-expr.c (fcncall_realloc_result): Make sure that the\n\tresult dtype field is set before the function call.\n\n2011-04-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/48462\n\t* gfortran.dg/realloc_on_assign_7.f03: Modify to test for lhs\n\tbeing a target.\n\n\tPR fortran/48746\n\t* gfortran.dg/realloc_on_assign_7.f03: Add subroutine pr48746.\n\nFrom-SVN: r173185", "tree": {"sha": "60ed47ddac407041385577f71d503609d3a92443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60ed47ddac407041385577f71d503609d3a92443"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7097b0410ed48d3b7a5099e12fcec14b80f86910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7097b0410ed48d3b7a5099e12fcec14b80f86910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7097b0410ed48d3b7a5099e12fcec14b80f86910", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7097b0410ed48d3b7a5099e12fcec14b80f86910/comments", "author": null, "committer": null, "parents": [{"sha": "fdf390e6c61f928da9e2b6a7af63c277e2d3b0eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdf390e6c61f928da9e2b6a7af63c277e2d3b0eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdf390e6c61f928da9e2b6a7af63c277e2d3b0eb"}], "stats": {"total": 71, "additions": 61, "deletions": 10}, "files": [{"sha": "0f7db3a441441fada1903a76246d27e7cb491300", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7097b0410ed48d3b7a5099e12fcec14b80f86910/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7097b0410ed48d3b7a5099e12fcec14b80f86910/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7097b0410ed48d3b7a5099e12fcec14b80f86910", "patch": "@@ -1,3 +1,13 @@\n+2011-04-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/48462\n+\t* trans-expr.c (arrayfunc_assign_needs_temporary): Deal with\n+\tautomatic reallocation when the lhs is a target.\n+\n+\tPR fortran/48746\n+\t* trans-expr.c (fcncall_realloc_result): Make sure that the\n+\tresult dtype field is set before the function call.\n+\n 2011-04-29  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/48810"}, {"sha": "1582833a0541d636cf887a589fa6f5d5ef470fc3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7097b0410ed48d3b7a5099e12fcec14b80f86910/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7097b0410ed48d3b7a5099e12fcec14b80f86910/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7097b0410ed48d3b7a5099e12fcec14b80f86910", "patch": "@@ -5444,9 +5444,12 @@ arrayfunc_assign_needs_temporary (gfc_expr * expr1, gfc_expr * expr2)\n     return true;\n \n   /* If we have reached here with an intrinsic function, we do not\n-     need a temporary.  */\n+     need a temporary except in the particular case that reallocation\n+     on assignment is active and the lhs is allocatable and a target.  */\n   if (expr2->value.function.isym)\n-    return false;\n+    return (gfc_option.flag_realloc_lhs\n+\t      && sym->attr.allocatable\n+\t      && sym->attr.target);\n \n   /* If the LHS is a dummy, we need a temporary if it is not\n      INTENT(OUT).  */\n@@ -5545,6 +5548,9 @@ fcncall_realloc_result (gfc_se *se)\n   /* Use the allocation done by the library.  Substitute the lhs\n      descriptor with a copy, whose data field is nulled.*/\n   desc = build_fold_indirect_ref_loc (input_location, se->expr);\n+  /* Unallocated, the descriptor does not have a dtype.  */\n+  tmp = gfc_conv_descriptor_dtype (desc);\n+  gfc_add_modify (&se->pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n   res_desc = gfc_evaluate_now (desc, &se->pre);\n   gfc_conv_descriptor_data_set (&se->pre, res_desc, null_pointer_node);\n   se->expr = gfc_build_addr_expr (TREE_TYPE (se->expr), res_desc);\n@@ -5556,10 +5562,6 @@ fcncall_realloc_result (gfc_se *se)\n   gfc_add_expr_to_block (&se->post, tmp);\n   tmp = gfc_conv_descriptor_data_get (res_desc);\n   gfc_conv_descriptor_data_set (&se->post, desc, tmp);\n-\n-  /* Unallocated, the descriptor does not have a dtype.  */\n-  tmp = gfc_conv_descriptor_dtype (desc);\n-  gfc_add_modify (&se->post, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n }\n \n "}, {"sha": "42ea961e1762f54ea4326c06e96033e65c9484c7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7097b0410ed48d3b7a5099e12fcec14b80f86910/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7097b0410ed48d3b7a5099e12fcec14b80f86910/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7097b0410ed48d3b7a5099e12fcec14b80f86910", "patch": "@@ -1,3 +1,12 @@\n+2011-04-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/48462\n+\t* gfortran.dg/realloc_on_assign_7.f03: Modify to test for lhs\n+\tbeing a target.\n+\n+\tPR fortran/48746\n+\t* gfortran.dg/realloc_on_assign_7.f03: Add subroutine pr48746.\n+\n 2011-04-29  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/48810"}, {"sha": "ca9a2d943e91201c481db0c4ea225aa37e74a5c7", "filename": "gcc/testsuite/gfortran.dg/realloc_on_assign_7.f03", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7097b0410ed48d3b7a5099e12fcec14b80f86910/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7097b0410ed48d3b7a5099e12fcec14b80f86910/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frealloc_on_assign_7.f03?ref=7097b0410ed48d3b7a5099e12fcec14b80f86910", "patch": "@@ -1,30 +1,41 @@\n ! { dg-do run }\n ! Check the fix for PR48462 in which the assignments involving matmul\n ! seg faulted because a was automatically freed before the assignment.\n+! Since it is related, the test for the fix of PR48746 has been added\n+! as a subroutine by that name.\n !\n ! Contributed by John Nedney  <ortp21@gmail.com>\n !\n program main\n   implicit none\n   integer, parameter :: dp = kind(0.0d0)\n   real(kind=dp), allocatable :: delta(:,:)\n+  real(kind=dp), allocatable, target :: a(:,:)\n+  real(kind=dp), pointer :: aptr(:,:)\n+\n+  allocate(a(3,3))\n+  aptr => a\n   \n   call foo\n+  if (.not. associated (aptr, a)) call abort () ! reallocated to same size - remains associated\n   call bar\n+  if (.not. associated (aptr, a)) call abort () ! reallocated to smaller size - remains associated\n+  call foobar\n+  if (associated (aptr, a)) call abort () ! reallocated to larger size - disassociates\n+\n+  call pr48746\n contains\n !\n ! Original reduced version from comment #2\n   subroutine foo\n     implicit none\n-    real(kind=dp), allocatable :: a(:,:)\n     real(kind=dp), allocatable :: b(:,:)\n \n-    allocate(a(3,3))\n     allocate(b(3,3))\n     allocate(delta(3,3))\n \n-    b = reshape ([1d0, 0d0, 0d0, 0d0, 1d0, 0d0, 0d0, 0d0, 1d0], [3,3])\n     a = reshape ([1d0, 2d0, 3d0, 4d0, 5d0, 6d0, 7d0, 8d0, 9d0], [3,3])\n+    b = reshape ([1d0, 0d0, 0d0, 0d0, 1d0, 0d0, 0d0, 0d0, 1d0], [3,3])\n \n     a = matmul( matmul( a, b ), b )\n     delta = (a - reshape ([1d0, 2d0, 3d0, 4d0, 5d0, 6d0, 7d0, 8d0, 9d0], [3,3]))**2\n@@ -47,5 +58,24 @@ subroutine bar\n     if (any (delta > 1d-12)) call abort\n     if (any (lbound (a) .ne. [1, 1])) call abort\n   end subroutine\n+  subroutine foobar\n+    integer :: i\n+    a = reshape ([(real(i, dp), i = 1, 100)],[10,10])\n+  end subroutine\n+  subroutine pr48746\n+! This is a further wrinkle on the original problem and came about\n+! because the dtype field of the result argument, passed to matmul,\n+! was not being set. This is needed by matmul for the rank.\n+!\n+! Contributed by Thomas Koenig  <tkoenig@gcc.gnu.org>\n+!\n+    implicit none\n+    integer, parameter :: m=10, n=12, count=4\n+    real :: optmatmul(m, n)\n+    real :: a(m, count), b(count, n), c(m, n)\n+    real, dimension(:,:), allocatable :: tmp\n+    call random_number(a)\n+    call random_number(b)\n+    tmp = matmul(a,b)\n+  end subroutine\n end program main\n-"}]}