{"sha": "a7e68e7fa76aa33eab48a30186abcb4d3b291322", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdlNjhlN2ZhNzZhYTMzZWFiNDhhMzAxODZhYmNiNGQzYjI5MTMyMg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2013-04-12T13:17:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T13:17:28Z"}, "message": "aspects.adb: Alphabetize subprogram bodies in this unit.\n\n2013-04-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb: Alphabetize subprogram bodies in this unit. Add\n\tan entry for Aspect_Ghost in the table of canonical aspects.\n\t(Has_Aspect): New routine.\n\t* aspects.ads: Add Aspect_Ghost to all relevant\n\ttables. Alphabetize subprograms in this unit.\n\t(Has_Aspect): New routine.\n\t* einfo.adb: Add with and use clauses for Aspects.\n\t(Is_Ghost_Function): New routine.\n\t* einfo.ads: Add new synthesized attribute Is_Ghost_Function and\n\tupdate the structure of the related nodes.\n\t(Is_Ghost_Function): New routine.\n\t* exp_ch4.adb (Find_Enclosing_Context): Use routine\n\tIs_Body_Or_Package_Declaration to terminate a search.\n\t(Is_Body_Or_Unit): Removed.\n\t* exp_util.adb (Within_Case_Or_If_Expression): Use routine\n\tIs_Body_Or_Package_Declaration to terminate a search.\n\t* par-prag.adb: Add pragma Ghost to the list of pragmas that do\n\tnot need special processing by the parser.\n\t* sem_attr.adb (Analyze_Access_Attribute): Detect an\n\tillegal use of 'Access where the prefix is a ghost function.\n\t(Analyze_Attribute): Use routine Is_Body_Or_Package_Declaration\n\tto terminate a search.\t(Check_References_In_Prefix): Use routine\n\tIs_Body_Or_Package_Declaration to terminate a search.\n\t* sem_ch4.adb (Analyze_Call): Mark a function when it appears\n\tinside an assertion expression.  Verify the legality of a call\n\tto a ghost function.\n\t(Check_Ghost_Function_Call): New routine.\n\t* sem_ch6.adb (Analyze_Function_Call): Code reformatting. Move\n\tthe setting of attribute In_Assertion_Expression to Analyze_Call.\n\t(Check_Overriding_Indicator): Detect an illegal attempt to\n\toverride a function with a ghost function.\n\t* sem_ch12.adb (Preanalyze_Actuals): Detect an illegal use of\n\ta ghost function as a generic actual.\n\t* sem_elab.adb (Check_Internal_Call_Continue): Update the call\n\tto In_Assertion.\n\t* sem_prag.adb: Add an entry for pragma Ghost in the table\n\tof significant arguments.\n\t(Analyze_Pragma): Do not analyze\n\tan \"others\" case guard. Add processing for pragma Ghost. Use\n\tPreanalyze_Assert_Expression when analyzing the expression of\n\tpragmas Loop_Invariant and Loop_Variant.\n\t* sem_util.adb (Get_Subprogram_Entity): Reimplemented.\n\t(Is_Body_Or_Package_Declaration): New routine.\n\t* sem_util.ads: Alphabetize subprotrams in this unit.\n\t(Is_Body_Or_Package_Declaration): New routine.\n\t* sinfo.adb (In_Assertion): Rename to In_Assertion_Expression.\n\t(Set_In_Assertion): Rename to Set_In_Assertion_Expression.\n\t* sinfo.ads: Rename flag In_Assertion to In_Assertion_Expression\n\tto better reflect its use.  Update all places that mention the flag.\n\t(In_Assertion): Rename to In_Assertion_Expression. Update\n\trelated pragma Inline.\t(Set_In_Assertion): Rename to\n\tSet_In_Assertion_Expression. Update related pragma Inline.\n\t* snames.ads-tmpl: Add new predefined name Ghost. Add new pragma\n\tid Pragma_Ghost.\n\nFrom-SVN: r197909", "tree": {"sha": "c7c678d7b9c33b74d5c089d938c6fa6b9abda2eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7c678d7b9c33b74d5c089d938c6fa6b9abda2eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7e68e7fa76aa33eab48a30186abcb4d3b291322", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e68e7fa76aa33eab48a30186abcb4d3b291322", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e68e7fa76aa33eab48a30186abcb4d3b291322", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e68e7fa76aa33eab48a30186abcb4d3b291322/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d515aef32662568e230d2cc772c4a7da61ca64c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d515aef32662568e230d2cc772c4a7da61ca64c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d515aef32662568e230d2cc772c4a7da61ca64c0"}], "stats": {"total": 557, "additions": 383, "deletions": 174}, "files": [{"sha": "80705e9414677a3c752b5b07c470cb4703936cb3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -1,3 +1,60 @@\n+2013-04-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb: Alphabetize subprogram bodies in this unit. Add\n+\tan entry for Aspect_Ghost in the table of canonical aspects.\n+\t(Has_Aspect): New routine.\n+\t* aspects.ads: Add Aspect_Ghost to all relevant\n+\ttables. Alphabetize subprograms in this unit.\n+\t(Has_Aspect): New routine.\n+\t* einfo.adb: Add with and use clauses for Aspects.\n+\t(Is_Ghost_Function): New routine.\n+\t* einfo.ads: Add new synthesized attribute Is_Ghost_Function and\n+\tupdate the structure of the related nodes.\n+\t(Is_Ghost_Function): New routine.\n+\t* exp_ch4.adb (Find_Enclosing_Context): Use routine\n+\tIs_Body_Or_Package_Declaration to terminate a search.\n+\t(Is_Body_Or_Unit): Removed.\n+\t* exp_util.adb (Within_Case_Or_If_Expression): Use routine\n+\tIs_Body_Or_Package_Declaration to terminate a search.\n+\t* par-prag.adb: Add pragma Ghost to the list of pragmas that do\n+\tnot need special processing by the parser.\n+\t* sem_attr.adb (Analyze_Access_Attribute): Detect an\n+\tillegal use of 'Access where the prefix is a ghost function.\n+\t(Analyze_Attribute): Use routine Is_Body_Or_Package_Declaration\n+\tto terminate a search.\t(Check_References_In_Prefix): Use routine\n+\tIs_Body_Or_Package_Declaration to terminate a search.\n+\t* sem_ch4.adb (Analyze_Call): Mark a function when it appears\n+\tinside an assertion expression.  Verify the legality of a call\n+\tto a ghost function.\n+\t(Check_Ghost_Function_Call): New routine.\n+\t* sem_ch6.adb (Analyze_Function_Call): Code reformatting. Move\n+\tthe setting of attribute In_Assertion_Expression to Analyze_Call.\n+\t(Check_Overriding_Indicator): Detect an illegal attempt to\n+\toverride a function with a ghost function.\n+\t* sem_ch12.adb (Preanalyze_Actuals): Detect an illegal use of\n+\ta ghost function as a generic actual.\n+\t* sem_elab.adb (Check_Internal_Call_Continue): Update the call\n+\tto In_Assertion.\n+\t* sem_prag.adb: Add an entry for pragma Ghost in the table\n+\tof significant arguments.\n+\t(Analyze_Pragma): Do not analyze\n+\tan \"others\" case guard. Add processing for pragma Ghost. Use\n+\tPreanalyze_Assert_Expression when analyzing the expression of\n+\tpragmas Loop_Invariant and Loop_Variant.\n+\t* sem_util.adb (Get_Subprogram_Entity): Reimplemented.\n+\t(Is_Body_Or_Package_Declaration): New routine.\n+\t* sem_util.ads: Alphabetize subprotrams in this unit.\n+\t(Is_Body_Or_Package_Declaration): New routine.\n+\t* sinfo.adb (In_Assertion): Rename to In_Assertion_Expression.\n+\t(Set_In_Assertion): Rename to Set_In_Assertion_Expression.\n+\t* sinfo.ads: Rename flag In_Assertion to In_Assertion_Expression\n+\tto better reflect its use.  Update all places that mention the flag.\n+\t(In_Assertion): Rename to In_Assertion_Expression. Update\n+\trelated pragma Inline.\t(Set_In_Assertion): Rename to\n+\tSet_In_Assertion_Expression. Update related pragma Inline.\n+\t* snames.ads-tmpl: Add new predefined name Ghost. Add new pragma\n+\tid Pragma_Ghost.\n+\n 2013-04-12  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_prag.adb (Set_Imported): Do not generate error for multiple"}, {"sha": "7799fa83a7025f1ecbbfd46b565f4b8013dd4d63", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -110,15 +110,6 @@ package body Aspects is\n       end if;\n    end Aspect_Specifications;\n \n-   -------------------\n-   -- Get_Aspect_Id --\n-   -------------------\n-\n-   function Get_Aspect_Id (Name : Name_Id) return Aspect_Id is\n-   begin\n-      return Aspect_Id_Hash_Table.Get (Name);\n-   end Get_Aspect_Id;\n-\n    -----------------\n    -- Find_Aspect --\n    -----------------\n@@ -169,6 +160,38 @@ package body Aspects is\n       return Empty;\n    end Find_Aspect;\n \n+   -------------------\n+   -- Get_Aspect_Id --\n+   -------------------\n+\n+   function Get_Aspect_Id (Name : Name_Id) return Aspect_Id is\n+   begin\n+      return Aspect_Id_Hash_Table.Get (Name);\n+   end Get_Aspect_Id;\n+\n+   ----------------\n+   -- Has_Aspect --\n+   ----------------\n+\n+   function Has_Aspect (Id : Entity_Id; A : Aspect_Id) return Boolean is\n+      Decl   : constant Node_Id := Parent (Parent (Id));\n+      Aspect : Node_Id;\n+\n+   begin\n+      if Has_Aspects (Decl) then\n+         Aspect := First (Aspect_Specifications (Decl));\n+         while Present (Aspect) loop\n+            if Get_Aspect_Id (Chars (Identifier (Aspect))) = A then\n+               return True;\n+            end if;\n+\n+            Next (Aspect);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Has_Aspect;\n+\n    ------------------\n    -- Move_Aspects --\n    ------------------\n@@ -271,6 +294,7 @@ package body Aspects is\n     Aspect_External_Name                => Aspect_External_Name,\n     Aspect_External_Tag                 => Aspect_External_Tag,\n     Aspect_Favor_Top_Level              => Aspect_Favor_Top_Level,\n+    Aspect_Ghost                        => Aspect_Ghost,\n     Aspect_Global                       => Aspect_Global,\n     Aspect_Implicit_Dereference         => Aspect_Implicit_Dereference,\n     Aspect_Import                       => Aspect_Import,"}, {"sha": "e282f1a6afcecf695278e4ae92d2682c00dd9b97", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -161,6 +161,7 @@ package Aspects is\n       Aspect_Discard_Names,\n       Aspect_Export,\n       Aspect_Favor_Top_Level,               -- GNAT\n+      Aspect_Ghost,                         -- GNAT\n       Aspect_Independent,\n       Aspect_Independent_Components,\n       Aspect_Import,\n@@ -234,6 +235,7 @@ package Aspects is\n                              Aspect_Dimension                => True,\n                              Aspect_Dimension_System         => True,\n                              Aspect_Favor_Top_Level          => True,\n+                             Aspect_Ghost                    => True,\n                              Aspect_Global                   => True,\n                              Aspect_Inline_Always            => True,\n                              Aspect_Invariant                => True,\n@@ -413,6 +415,7 @@ package Aspects is\n      Aspect_External_Tag                 => Name_External_Tag,\n      Aspect_Export                       => Name_Export,\n      Aspect_Favor_Top_Level              => Name_Favor_Top_Level,\n+     Aspect_Ghost                        => Name_Ghost,\n      Aspect_Global                       => Name_Global,\n      Aspect_Implicit_Dereference         => Name_Implicit_Dereference,\n      Aspect_Import                       => Name_Import,\n@@ -500,11 +503,6 @@ package Aspects is\n    --  implemented internally with a hash table in the body, that provides\n    --  access to aspect specifications.\n \n-   function Permits_Aspect_Specifications (N : Node_Id) return Boolean;\n-   --  Returns True if the node N is a declaration node that permits aspect\n-   --  specifications in the grammar. It is possible for other nodes to have\n-   --  aspect specifications as a result of Rewrite or Replace calls.\n-\n    function Aspect_Specifications (N : Node_Id) return List_Id;\n    --  Given a node N, returns the list of N_Aspect_Specification nodes that\n    --  are attached to this declaration node. If the node is in the class of\n@@ -519,34 +517,42 @@ package Aspects is\n    --  Replace calls, and this function may be used to retrieve the aspect\n    --  specifications for the original rewritten node in such cases.\n \n-   procedure Set_Aspect_Specifications (N : Node_Id; L : List_Id);\n-   --  The node N must be in the class of declaration nodes that permit aspect\n-   --  specifications and the Has_Aspects flag must be False on entry. L must\n-   --  be a non-empty list of N_Aspect_Specification nodes. This procedure sets\n-   --  the Has_Aspects flag to True, and makes an entry that can be retrieved\n-   --  by a subsequent Aspect_Specifications call. It is an error to call this\n-   --  procedure with a node that does not permit aspect specifications, or a\n-   --  node that has its Has_Aspects flag set True on entry, or with L being an\n-   --  empty list or No_List.\n-\n    function Find_Aspect (Ent : Entity_Id; A : Aspect_Id) return Node_Id;\n    --  Find value of a given aspect from aspect list of entity\n \n+   function Has_Aspect (Id : Entity_Id; A : Aspect_Id) return Boolean;\n+   --  Determine whether entity Id has aspect A\n+\n    procedure Move_Aspects (From : Node_Id; To : Node_Id);\n    --  Moves aspects from 'From' node to 'To' node. Has_Aspects (To) must be\n    --  False on entry. If Has_Aspects (From) is False, the call has no effect.\n    --  Otherwise the aspects are moved and on return Has_Aspects (To) is True,\n    --  and Has_Aspects (From) is False.\n \n+   function Permits_Aspect_Specifications (N : Node_Id) return Boolean;\n+   --  Returns True if the node N is a declaration node that permits aspect\n+   --  specifications in the grammar. It is possible for other nodes to have\n+   --  aspect specifications as a result of Rewrite or Replace calls.\n+\n    function Same_Aspect (A1 : Aspect_Id; A2 : Aspect_Id) return Boolean;\n    --  Returns True if A1 and A2 are (essentially) the same aspect. This is not\n    --  a simple equality test because e.g. Post and Postcondition are the same.\n    --  This is used for detecting duplicate aspects.\n \n-   procedure Tree_Write;\n-   --  Writes contents of Aspect_Specifications hash table to the tree file\n+   procedure Set_Aspect_Specifications (N : Node_Id; L : List_Id);\n+   --  The node N must be in the class of declaration nodes that permit aspect\n+   --  specifications and the Has_Aspects flag must be False on entry. L must\n+   --  be a non-empty list of N_Aspect_Specification nodes. This procedure sets\n+   --  the Has_Aspects flag to True, and makes an entry that can be retrieved\n+   --  by a subsequent Aspect_Specifications call. It is an error to call this\n+   --  procedure with a node that does not permit aspect specifications, or a\n+   --  node that has its Has_Aspects flag set True on entry, or with L being an\n+   --  empty list or No_List.\n \n    procedure Tree_Read;\n    --  Reads contents of Aspect_Specifications hash table from the tree file\n \n+   procedure Tree_Write;\n+   --  Writes contents of Aspect_Specifications hash table to the tree file\n+\n end Aspects;"}, {"sha": "234c67246b75d59910c5cb4bcd7ac8d235e82005", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -32,12 +32,13 @@\n pragma Style_Checks (All_Checks);\n --  Turn off subprogram ordering, not used for this unit\n \n-with Atree;  use Atree;\n-with Namet;  use Namet;\n-with Nlists; use Nlists;\n-with Output; use Output;\n-with Sinfo;  use Sinfo;\n-with Stand;  use Stand;\n+with Aspects; use Aspects;\n+with Atree;   use Atree;\n+with Namet;   use Namet;\n+with Nlists;  use Nlists;\n+with Output;  use Output;\n+with Sinfo;   use Sinfo;\n+with Stand;   use Stand;\n \n package body Einfo is\n \n@@ -6549,10 +6550,31 @@ package body Einfo is\n \n    function Is_Finalizer (Id : E) return B is\n    begin\n-      return Ekind (Id) = E_Procedure\n-        and then Chars (Id) = Name_uFinalizer;\n+      return Ekind (Id) = E_Procedure and then Chars (Id) = Name_uFinalizer;\n    end Is_Finalizer;\n \n+   -----------------------\n+   -- Is_Ghost_Function --\n+   -----------------------\n+\n+   function Is_Ghost_Function (Id : E) return B is\n+      Subp_Id : Entity_Id := Id;\n+\n+   begin\n+      if Present (Subp_Id) and then Ekind (Subp_Id) = E_Function then\n+\n+         --  Handle renamings of functions\n+\n+         if Present (Alias (Subp_Id)) then\n+            Subp_Id := Alias (Subp_Id);\n+         end if;\n+\n+         return Has_Aspect (Subp_Id, Aspect_Ghost);\n+      end if;\n+\n+      return False;\n+   end Is_Ghost_Function;\n+\n    --------------------\n    -- Is_Input_State --\n    --------------------\n@@ -6570,8 +6592,7 @@ package body Einfo is\n    function Is_Null_State (Id : E) return B is\n    begin\n       return\n-        Ekind (Id) = E_Abstract_State\n-          and then Nkind (Parent (Id)) = N_Null;\n+        Ekind (Id) = E_Abstract_State and then Nkind (Parent (Id)) = N_Null;\n    end Is_Null_State;\n \n    ---------------------\n@@ -6590,10 +6611,7 @@ package body Einfo is\n \n    function Is_Package_Or_Generic_Package (Id : E) return B is\n    begin\n-      return\n-        Ekind (Id) = E_Package\n-          or else\n-        Ekind (Id) = E_Generic_Package;\n+      return Ekind_In (Id, E_Generic_Package, E_Package);\n    end Is_Package_Or_Generic_Package;\n \n    ---------------\n@@ -6612,8 +6630,7 @@ package body Einfo is\n \n    function Is_Protected_Component (Id : E) return B is\n    begin\n-      return Ekind (Id) = E_Component\n-        and then Is_Protected_Type (Scope (Id));\n+      return Ekind (Id) = E_Component and then Is_Protected_Type (Scope (Id));\n    end Is_Protected_Component;\n \n    ----------------------------"}, {"sha": "5b7c95dd3397e1fd86108d14f4752c8683a530b0", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -1230,7 +1230,7 @@ package Einfo is\n --       the same structure for constrained and unconstrained arrays, subtype\n --       marks and discrete ranges are both represented by a subtype. This\n --       function returns the tree node corresponding to an occurrence of the\n---       first index (NOT the entity for the type). Subsequent indexes are\n+--       first index (NOT the entity for the type). Subsequent indices are\n --       obtained using Next_Index. Note that this field is defined for the\n --       case of string literal subtypes, but is always Empty.\n \n@@ -2292,6 +2292,10 @@ package Einfo is\n --       package, generic function, generic procedure), and False for all\n --       other entities.\n \n+--    Is_Ghost_Function (synthesized)\n+--       Applies to all entities. Yields True for a function marked by aspect\n+--       Ghost.\n+\n --    Is_Hidden (Flag57)\n --       Defined in all entities. Set true for all entities declared in the\n --       private part or body of a package. Also marks generic formals of a\n@@ -5404,6 +5408,7 @@ package Einfo is\n    --    Address_Clause                      (synth)\n    --    First_Formal                        (synth)\n    --    First_Formal_With_Extras            (synth)\n+   --    Is_Ghost_Function                   (synth)    (non-generic case only)\n    --    Last_Formal                         (synth)\n    --    Number_Formals                      (synth)\n    --    Scope_Depth                         (synth)\n@@ -6611,6 +6616,7 @@ package Einfo is\n    function Is_Discriminal                      (Id : E) return B;\n    function Is_Dynamic_Scope                    (Id : E) return B;\n    function Is_Finalizer                        (Id : E) return B;\n+   function Is_Ghost_Function                   (Id : E) return B;\n    function Is_Input_State                      (Id : E) return B;\n    function Is_Null_State                       (Id : E) return B;\n    function Is_Output_State                     (Id : E) return B;"}, {"sha": "e9458cf6bed954fbccd9f896544bd3ea8a595153", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -5033,30 +5033,9 @@ package body Exp_Ch4 is\n             ----------------------------\n \n             function Find_Enclosing_Context return Node_Id is\n-               function Is_Body_Or_Unit (N : Node_Id) return Boolean;\n-               --  Determine whether N denotes a body or unit declaration\n-\n-               ---------------------\n-               -- Is_Body_Or_Unit --\n-               ---------------------\n-\n-               function Is_Body_Or_Unit (N : Node_Id) return Boolean is\n-               begin\n-                  return Nkind_In (N, N_Entry_Body,\n-                                      N_Package_Body,\n-                                      N_Package_Declaration,\n-                                      N_Protected_Body,\n-                                      N_Subprogram_Body,\n-                                      N_Task_Body);\n-               end Is_Body_Or_Unit;\n-\n-               --  Local variables\n-\n                Par : Node_Id;\n                Top : Node_Id;\n \n-            --  Start of processing for Find_Enclosing_Context\n-\n             begin\n                --  The expression_with_actions is in a case/if expression and\n                --  the lifetime of any temporary controlled object is therefore\n@@ -5074,7 +5053,7 @@ package body Exp_Ch4 is\n \n                      --  Prevent the search from going too far\n \n-                     elsif Is_Body_Or_Unit (Par) then\n+                     elsif Is_Body_Or_Package_Declaration (Par) then\n                         exit;\n                      end if;\n \n@@ -5099,7 +5078,7 @@ package body Exp_Ch4 is\n \n                      --  Prevent the search from going too far\n \n-                     elsif Is_Body_Or_Unit (Par) then\n+                     elsif Is_Body_Or_Package_Declaration (Par) then\n                         exit;\n                      end if;\n \n@@ -5171,7 +5150,9 @@ package body Exp_Ch4 is\n                      then\n                         return Par;\n \n-                     elsif Is_Body_Or_Unit (Par) then\n+                     --  Prevent the search from going too far\n+\n+                     elsif Is_Body_Or_Package_Declaration (Par) then\n                         exit;\n                      end if;\n "}, {"sha": "69e16c996897cdd9fe578fb81b453fb41c63c7b5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -8013,13 +8013,7 @@ package body Exp_Util is\n \n          --  Prevent the search from going too far\n \n-         elsif Nkind_In (Par, N_Entry_Body,\n-                              N_Package_Body,\n-                              N_Package_Declaration,\n-                              N_Protected_Body,\n-                              N_Subprogram_Body,\n-                              N_Task_Body)\n-         then\n+         elsif Is_Body_Or_Package_Declaration (Par) then\n             return False;\n          end if;\n "}, {"sha": "be463778a7d48ae9fd6d8232efa68543edbdee40", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -1166,6 +1166,7 @@ begin\n            Pragma_Fast_Math                      |\n            Pragma_Finalize_Storage_Only          |\n            Pragma_Float_Representation           |\n+           Pragma_Ghost                          |\n            Pragma_Global                         |\n            Pragma_Ident                          |\n            Pragma_Implementation_Defined         |"}, {"sha": "4b3c46c4f1d5c42e6d295896ea7d8060a54db859", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -602,10 +602,13 @@ package body Sem_Attr is\n             if Has_Pragma_Inline_Always (Entity (P)) then\n                Error_Attr_P\n                  (\"prefix of % attribute cannot be Inline_Always subprogram\");\n-            end if;\n \n-            if Aname = Name_Unchecked_Access then\n+            elsif Aname = Name_Unchecked_Access then\n                Error_Attr (\"attribute% cannot be applied to a subprogram\", P);\n+\n+            elsif Is_Ghost_Function (Entity (P)) then\n+               Error_Attr_P\n+                 (\"prefix of % attribute cannot be a ghost function\");\n             end if;\n \n             --  Issue an error if the prefix denotes an eliminated subprogram\n@@ -3694,13 +3697,7 @@ package body Sem_Attr is\n \n                   --  Prevent the search from going too far\n \n-                  elsif Nkind_In (Stmt, N_Entry_Body,\n-                                        N_Package_Body,\n-                                        N_Package_Declaration,\n-                                        N_Protected_Body,\n-                                        N_Subprogram_Body,\n-                                        N_Task_Body)\n-                  then\n+                  elsif Is_Body_Or_Package_Declaration (Stmt) then\n                      exit;\n                   end if;\n \n@@ -3845,13 +3842,7 @@ package body Sem_Attr is\n \n             --  Prevent the search from going too far\n \n-            elsif Nkind_In (Stmt, N_Entry_Body,\n-                                  N_Package_Body,\n-                                  N_Package_Declaration,\n-                                  N_Protected_Body,\n-                                  N_Subprogram_Body,\n-                                  N_Task_Body)\n-            then\n+            elsif Is_Body_Or_Package_Declaration (Stmt) then\n                exit;\n             end if;\n \n@@ -9193,7 +9184,6 @@ package body Sem_Attr is\n                     and then\n                       (Ekind (Btyp) = E_Access_Subprogram_Type\n                         or else Is_Local_Anonymous_Access (Btyp))\n-\n                     and then Subprogram_Access_Level (Entity (P)) >\n                                Type_Access_Level (Btyp)\n                   then\n@@ -9595,9 +9585,9 @@ package body Sem_Attr is\n                --  in such a context.\n \n                if Attr_Id /= Attribute_Unchecked_Access\n+                 and then Ekind (Btyp) = E_General_Access_Type\n                  and then\n                    Object_Access_Level (P) > Deepest_Type_Access_Level (Btyp)\n-                 and then Ekind (Btyp) = E_General_Access_Type\n                then\n                   Accessibility_Message;\n                   return;"}, {"sha": "1fe5277cfd82311f4b6b1a704dfab6954f053d9a", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -12402,7 +12402,16 @@ package body Sem_Ch12 is\n                Analyze (Act);\n             end if;\n \n-            if Errs /= Serious_Errors_Detected then\n+            --  Ensure that a ghost function does not act as generic actual\n+\n+            if Is_Entity_Name (Act)\n+              and then Is_Ghost_Function (Entity (Act))\n+            then\n+               Error_Msg_N\n+                 (\"ghost function & cannot act as generic actual\", Act);\n+               Abandon_Instantiation (Act);\n+\n+            elsif Errs /= Serious_Errors_Detected then\n \n                --  Do a minimal analysis of the generic, to prevent spurious\n                --  warnings complaining about the generic being unreferenced,"}, {"sha": "b8ecf3989cf47501023ee54abd757908c107cdf2", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -868,6 +868,11 @@ package body Sem_Ch4 is\n       --  Flag indicates whether an interpretation of the prefix is a\n       --  parameterless call that returns an access_to_subprogram.\n \n+      procedure Check_Ghost_Function_Call;\n+      --  Verify the legality of a call to a ghost function. Such calls can\n+      --  appear only in assertion expressions except subtype predicates or\n+      --  from within another ghost function.\n+\n       procedure Check_Mixed_Parameter_And_Named_Associations;\n       --  Check that parameter and named associations are not mixed. This is\n       --  a restriction in SPARK mode.\n@@ -882,6 +887,38 @@ package body Sem_Ch4 is\n       procedure No_Interpretation;\n       --  Output error message when no valid interpretation exists\n \n+      -------------------------------\n+      -- Check_Ghost_Function_Call --\n+      -------------------------------\n+\n+      procedure Check_Ghost_Function_Call is\n+         S : Entity_Id;\n+\n+      begin\n+         --  The ghost function appears inside an assertion expression\n+\n+         if In_Assertion_Expression (N) then\n+            return;\n+\n+         else\n+            S := Current_Scope;\n+            while Present (S) and then S /= Standard_Standard loop\n+\n+               --  The call appears inside another ghost function\n+\n+               if Is_Ghost_Function (S) then\n+                  return;\n+               end if;\n+\n+               S := Scope (S);\n+            end loop;\n+         end if;\n+\n+         Error_Msg_N\n+           (\"call to ghost function must appear in assertion expression or \"\n+            & \"another ghost function\", N);\n+      end Check_Ghost_Function_Call;\n+\n       --------------------------------------------------\n       -- Check_Mixed_Parameter_And_Named_Associations --\n       --------------------------------------------------\n@@ -972,6 +1009,12 @@ package body Sem_Ch4 is\n          Check_Mixed_Parameter_And_Named_Associations;\n       end if;\n \n+      --  Mark a function that appears inside an assertion expression\n+\n+      if Nkind (N) = N_Function_Call and then In_Assertion_Expr > 0 then\n+         Set_In_Assertion_Expression (N);\n+      end if;\n+\n       --  Initialize the type of the result of the call to the error type,\n       --  which will be reset if the type is successfully resolved.\n \n@@ -1078,6 +1121,8 @@ package body Sem_Ch4 is\n             Set_Etype (Nam_Ent, Etype (N));\n          end if;\n \n+      --  Overloaded call\n+\n       else\n          --  An overloaded selected component must denote overloaded operations\n          --  of a concurrent type. The interpretations are attached to the\n@@ -1162,9 +1207,9 @@ package body Sem_Ch4 is\n             Get_Next_Interp (X, It);\n          end loop;\n \n-         --  If the name is the result of a function call, it can only\n-         --  be a call to a function returning an access to subprogram.\n-         --  Insert explicit dereference.\n+         --  If the name is the result of a function call, it can only be a\n+         --  call to a function returning an access to subprogram. Insert\n+         --  explicit dereference.\n \n          if Nkind (Nam) = N_Function_Call then\n             Insert_Explicit_Dereference (Nam);\n@@ -1243,6 +1288,13 @@ package body Sem_Ch4 is\n \n          End_Interp_List;\n       end if;\n+\n+      --  A call to a ghost function is allowed only in assertion expressions,\n+      --  excluding subtype predicates, or from within another ghost function.\n+\n+      if Is_Ghost_Function (Get_Subprogram_Entity (N)) then\n+         Check_Ghost_Function_Call;\n+      end if;\n    end Analyze_Call;\n \n    -----------------------------"}, {"sha": "c524f89e8b4ac442b0487e06da652737817a6599", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -486,19 +486,21 @@ package body Sem_Ch6 is\n    ----------------------------\n \n    procedure Analyze_Function_Call (N : Node_Id) is\n-      P       : constant Node_Id := Name (N);\n-      Actuals : constant List_Id := Parameter_Associations (N);\n-      Actual  : Node_Id;\n+      Actuals  : constant List_Id := Parameter_Associations (N);\n+      Func_Nam : constant Node_Id := Name (N);\n+      Actual   : Node_Id;\n+\n+   --  Start of processing for Analyze_Function_Call\n \n    begin\n-      Analyze (P);\n+      Analyze (Func_Nam);\n \n       --  A call of the form A.B (X) may be an Ada 2005 call, which is\n       --  rewritten as B (A, X). If the rewriting is successful, the call\n       --  has been analyzed and we just return.\n \n-      if Nkind (P) = N_Selected_Component\n-        and then Name (N) /= P\n+      if Nkind (Func_Nam) = N_Selected_Component\n+        and then Name (N) /= Func_Nam\n         and then Is_Rewrite_Substitution (N)\n         and then Present (Etype (N))\n       then\n@@ -507,7 +509,7 @@ package body Sem_Ch6 is\n \n       --  If error analyzing name, then set Any_Type as result type and return\n \n-      if Etype (P) = Any_Type then\n+      if Etype (Func_Nam) = Any_Type then\n          Set_Etype (N, Any_Type);\n          return;\n       end if;\n@@ -524,22 +526,16 @@ package body Sem_Ch6 is\n       end if;\n \n       Analyze_Call (N);\n-\n-      --  Mark function call if within assertion\n-\n-      if In_Assertion_Expr /= 0 then\n-         Set_In_Assertion (N);\n-      end if;\n    end Analyze_Function_Call;\n \n    -----------------------------\n    -- Analyze_Function_Return --\n    -----------------------------\n \n    procedure Analyze_Function_Return (N : Node_Id) is\n-      Loc        : constant Source_Ptr  := Sloc (N);\n-      Stm_Entity : constant Entity_Id   := Return_Statement_Entity (N);\n-      Scope_Id   : constant Entity_Id   := Return_Applies_To (Stm_Entity);\n+      Loc        : constant Source_Ptr := Sloc (N);\n+      Stm_Entity : constant Entity_Id  := Return_Statement_Entity (N);\n+      Scope_Id   : constant Entity_Id  := Return_Applies_To (Stm_Entity);\n \n       R_Type : constant Entity_Id := Etype (Scope_Id);\n       --  Function result subtype\n@@ -6562,6 +6558,11 @@ package body Sem_Ch6 is\n                else\n                   Set_Overridden_Operation (Subp, Overridden_Subp);\n                end if;\n+\n+            --  Ensure that a ghost function is not overriding another routine\n+\n+            elsif Is_Ghost_Function (Subp) then\n+               Error_Msg_N (\"ghost function & cannot be overriding\", Subp);\n             end if;\n          end if;\n "}, {"sha": "710983ffa5387a968acd12025358e19642f6bb45", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -2258,7 +2258,7 @@ package body Sem_Elab is\n            --  in this case, due to the out of order handling in this case.\n \n            and then (Nkind (Original_Node (N)) /= N_Function_Call\n-                      or else not In_Assertion (Original_Node (N)))\n+                      or else not In_Assertion_Expression (Original_Node (N)))\n          then\n             if Inst_Case then\n                Error_Msg_NE"}, {"sha": "240eb0c76842e3962fed9b287752c4f537de1c7f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -253,10 +253,15 @@ package body Sem_Prag is\n       --  Pre-analyze the guard and consequence expressions of a Contract_Cases\n       --  pragma/aspect aggregate expression.\n \n+      ----------------------------\n+      -- Analyze_Contract_Cases --\n+      ----------------------------\n+\n       procedure Analyze_Contract_Cases (Aggr : Node_Id) is\n          Case_Guard : Node_Id;\n          Conseq     : Node_Id;\n          Post_Case  : Node_Id;\n+\n       begin\n          Post_Case := First (Component_Associations (Aggr));\n          while Present (Post_Case) loop\n@@ -266,19 +271,24 @@ package body Sem_Prag is\n             --  Preanalyze the boolean expression, we treat this as a spec\n             --  expression (i.e. similar to a default expression).\n \n-            Preanalyze_Assert_Expression (Case_Guard, Standard_Boolean);\n+            if Nkind (Case_Guard) /= N_Others_Choice then\n+               Preanalyze_Assert_Expression (Case_Guard, Standard_Boolean);\n+            end if;\n+\n             Preanalyze_Assert_Expression (Conseq, Standard_Boolean);\n \n             Next (Post_Case);\n          end loop;\n       end Analyze_Contract_Cases;\n \n+   --  Start of processing for Analyze_CTC_In_Decl_Part\n+\n    begin\n       --  Install formals and push subprogram spec onto scope stack so that we\n       --  can see the formals from the pragma.\n \n-      Install_Formals (S);\n       Push_Scope (S);\n+      Install_Formals (S);\n \n       --  Preanalyze the boolean expressions, we treat these as spec\n       --  expressions (i.e. similar to a default expression).\n@@ -11194,6 +11204,39 @@ package body Sem_Prag is\n             end if;\n          end Float_Representation;\n \n+         -----------\n+         -- Ghost --\n+         -----------\n+\n+         --  pragma GHOST (function_LOCAL_NAME);\n+\n+         when Pragma_Ghost => Ghost : declare\n+            Subp    : Node_Id;\n+            Subp_Id : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+            Check_Arg_Count (1);\n+            Check_Arg_Is_Local_Name (Arg1);\n+\n+            --  Ensure the proper placement of the pragma. Ghost must be\n+            --  associated with a subprogram declaration.\n+\n+            Subp := Parent (Corresponding_Aspect (N));\n+\n+            if Nkind (Subp) /= N_Subprogram_Declaration then\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Subp_Id := Defining_Unit_Name (Specification (Subp));\n+\n+            if Ekind (Subp_Id) /= E_Function then\n+               Error_Pragma (\"pragma % must be applied to a function\");\n+            end if;\n+         end Ghost;\n+\n          ------------\n          -- Global --\n          ------------\n@@ -13542,14 +13585,12 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Preanalyze_And_Resolve (Expression (Arg1), Any_Boolean);\n+            Preanalyze_Assert_Expression (Expression (Arg1), Any_Boolean);\n \n             --  Transform pragma Loop_Invariant into equivalent pragma Check\n             --  Generate:\n             --    pragma Check (Loop_Invaraint, Arg1);\n \n-            --  Seems completely wrong to hijack pragma Check this way ???\n-\n             Rewrite (N,\n               Make_Pragma (Loc,\n                 Chars                        => Name_Check,\n@@ -13625,7 +13666,8 @@ package body Sem_Prag is\n                   Error_Pragma_Arg (\"wrong change modifier\", Variant);\n                end if;\n \n-               Preanalyze_And_Resolve (Expression (Variant), Any_Discrete);\n+               Preanalyze_Assert_Expression\n+                 (Expression (Variant), Any_Discrete);\n \n                Next (Variant);\n             end loop;\n@@ -17762,6 +17804,7 @@ package body Sem_Prag is\n       Pragma_Fast_Math                      => -1,\n       Pragma_Finalize_Storage_Only          =>  0,\n       Pragma_Float_Representation           =>  0,\n+      Pragma_Ghost                          =>  0,\n       Pragma_Global                         => -1,\n       Pragma_Ident                          => -1,\n       Pragma_Implementation_Defined         => -1,"}, {"sha": "533834e72728b4ef63cd129786312ebb2e1170f2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -5612,49 +5612,58 @@ package body Sem_Util is\n    ---------------------------\n \n    function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id is\n-      Nam  : Node_Id;\n-      Proc : Entity_Id;\n+      Subp    : Node_Id;\n+      Subp_Id : Entity_Id;\n \n    begin\n       if Nkind (Nod) = N_Accept_Statement then\n-         Nam := Entry_Direct_Name (Nod);\n+         Subp := Entry_Direct_Name (Nod);\n+\n+      elsif Nkind (Nod) = N_Slice then\n+         Subp := Prefix (Nod);\n+\n+      else\n+         Subp := Name (Nod);\n+      end if;\n+\n+      --  Strip the subprogram call\n+\n+      loop\n+         if Nkind_In (Subp, N_Explicit_Dereference,\n+                            N_Indexed_Component,\n+                            N_Selected_Component)\n+         then\n+            Subp := Prefix (Subp);\n \n-      --  For an entry call, the prefix of the call is a selected component.\n-      --  Need additional code for internal calls ???\n+         elsif Nkind_In (Subp, N_Type_Conversion,\n+                               N_Unchecked_Type_Conversion)\n+         then\n+            Subp := Expression (Subp);\n \n-      elsif Nkind (Nod) = N_Entry_Call_Statement then\n-         if Nkind (Name (Nod)) = N_Selected_Component then\n-            Nam := Entity (Selector_Name (Name (Nod)));\n          else\n-            Nam := Empty;\n+            exit;\n          end if;\n+      end loop;\n \n-      else\n-         Nam := Name (Nod);\n-      end if;\n+      --  Extract the entity of the subprogram call\n \n-      if Nkind (Nam) = N_Explicit_Dereference then\n-         Proc := Etype (Prefix (Nam));\n-      elsif Is_Entity_Name (Nam) then\n-         Proc := Entity (Nam);\n-      else\n-         return Empty;\n-      end if;\n+      if Is_Entity_Name (Subp) then\n+         Subp_Id := Entity (Subp);\n \n-      if Is_Object (Proc) then\n-         Proc := Etype (Proc);\n-      end if;\n+         if Ekind (Subp_Id) = E_Access_Subprogram_Type then\n+            Subp_Id := Directly_Designated_Type (Subp_Id);\n+         end if;\n \n-      if Ekind (Proc) = E_Access_Subprogram_Type then\n-         Proc := Directly_Designated_Type (Proc);\n-      end if;\n+         if Is_Subprogram (Subp_Id) then\n+            return Subp_Id;\n+         else\n+            return Empty;\n+         end if;\n+\n+      --  The search did not find a construct that denotes a subprogram\n \n-      if not Is_Subprogram (Proc)\n-        and then Ekind (Proc) /= E_Subprogram_Type\n-      then\n-         return Empty;\n       else\n-         return Proc;\n+         return Empty;\n       end if;\n    end Get_Subprogram_Entity;\n \n@@ -7714,6 +7723,20 @@ package body Sem_Util is\n       end if;\n    end Is_Atomic_Object;\n \n+   ------------------------------------\n+   -- Is_Body_Or_Package_Declaration --\n+   ------------------------------------\n+\n+   function Is_Body_Or_Package_Declaration (N : Node_Id) return Boolean is\n+   begin\n+      return Nkind_In (N, N_Entry_Body,\n+                          N_Package_Body,\n+                          N_Package_Declaration,\n+                          N_Protected_Body,\n+                          N_Subprogram_Body,\n+                          N_Task_Body);\n+   end Is_Body_Or_Package_Declaration;\n+\n    -----------------------\n    -- Is_Bounded_String --\n    -----------------------"}, {"sha": "3d252a2c6348bdaa8b24ccaf32164e2e6be9171f", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -178,6 +178,17 @@ package Sem_Util is\n    --  not necessarily mean that CE could be raised, but a response of True\n    --  means that for sure CE cannot be raised.\n \n+   procedure Check_Dynamically_Tagged_Expression\n+     (Expr        : Node_Id;\n+      Typ         : Entity_Id;\n+      Related_Nod : Node_Id);\n+   --  Check wrong use of dynamically tagged expression\n+\n+   procedure Check_Fully_Declared (T : Entity_Id; N : Node_Id);\n+   --  Verify that the full declaration of type T has been seen. If not, place\n+   --  error message on node N. Used in object declarations, type conversions\n+   --  and qualified expressions.\n+\n    procedure Check_Function_Writable_Actuals (N : Node_Id);\n    --  (Ada 2012): If the construct N has two or more direct constituents that\n    --  are names or expressions whose evaluation may occur in an arbitrary\n@@ -210,17 +221,6 @@ package Sem_Util is\n    --  remains in the Examiner (JB01-005). Note that the Examiner does not\n    --  count package declarations in later declarative items.\n \n-   procedure Check_Dynamically_Tagged_Expression\n-     (Expr        : Node_Id;\n-      Typ         : Entity_Id;\n-      Related_Nod : Node_Id);\n-   --  Check wrong use of dynamically tagged expression\n-\n-   procedure Check_Fully_Declared (T : Entity_Id; N : Node_Id);\n-   --  Verify that the full declaration of type T has been seen. If not, place\n-   --  error message on node N. Used in object declarations, type conversions\n-   --  and qualified expressions.\n-\n    procedure Check_Nested_Access (Ent : Entity_Id);\n    --  Check whether Ent denotes an entity declared in an uplevel scope, which\n    --  is accessed inside a nested procedure, and set Has_Up_Level_Access flag\n@@ -470,7 +470,7 @@ package Sem_Util is\n    --  discriminant at the same position in this new type.\n \n    procedure Find_Overlaid_Entity\n-     (N : Node_Id;\n+     (N   : Node_Id;\n       Ent : out Entity_Id;\n       Off : out Boolean);\n    --  The node N should be an address representation clause. Determines if\n@@ -849,6 +849,9 @@ package Sem_Util is\n    --  Determines if the given node denotes an atomic object in the sense of\n    --  the legality checks described in RM C.6(12).\n \n+   function Is_Body_Or_Package_Declaration (N : Node_Id) return Boolean;\n+   --  Determine whether node N denotes a body or a package declaration\n+\n    function Is_Bounded_String (T : Entity_Id) return Boolean;\n    --  True if T is a bounded string type. Used to make sure \"=\" composes\n    --  properly for bounded string types.\n@@ -1304,9 +1307,9 @@ package Sem_Util is\n    --  S2. Otherwise, it is S itself.\n \n    function Object_Access_Level (Obj : Node_Id) return Uint;\n-   --  Return the accessibility level of the view of the object Obj.\n-   --  For convenience, qualified expressions applied to object names\n-   --  are also allowed as actuals for this function.\n+   --  Return the accessibility level of the view of the object Obj. For\n+   --  convenience, qualified expressions applied to object names are also\n+   --  allowed as actuals for this function.\n \n    function Primitive_Names_Match (E1, E2 : Entity_Id) return Boolean;\n    --  Returns True if the names of both entities correspond with matching"}, {"sha": "3c9096fb94479f8aca50b70ad26154032d2f772e", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -1640,13 +1640,13 @@ package body Sinfo is\n       return Flag16 (N);\n    end Import_Interface_Present;\n \n-   function In_Assertion\n+   function In_Assertion_Expression\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Function_Call);\n       return Flag4 (N);\n-   end In_Assertion;\n+   end In_Assertion_Expression;\n \n    function In_Present\n       (N : Node_Id) return Boolean is\n@@ -4722,13 +4722,13 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Import_Interface_Present;\n \n-   procedure Set_In_Assertion\n+   procedure Set_In_Assertion_Expression\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_Function_Call);\n       Set_Flag4 (N, Val);\n-   end Set_In_Assertion;\n+   end Set_In_Assertion_Expression;\n \n    procedure Set_In_Present\n       (N : Node_Id; Val : Boolean := True) is"}, {"sha": "1711252ed31a5cefb6e3ed857f4f47395be2fddf", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -1227,7 +1227,7 @@ package Sinfo is\n    --     pragma of the other kind is also present. This is used to avoid\n    --     generating some unwanted error messages.\n \n-   --  In_Assertion (Flag4-Sem)\n+   --  In_Assertion_Expression (Flag4-Sem)\n    --     This flag is present in N_Function_Call nodes. It is set if the\n    --     function is called from within an assertion expression. This is\n    --     used to avoid some bogus warnings about early elaboration.\n@@ -4772,7 +4772,7 @@ package Sinfo is\n       --   actual parameter part)\n       --  First_Named_Actual (Node4-Sem)\n       --  Controlling_Argument (Node1-Sem) (set to Empty if not dispatching)\n-      --  In_Assertion (Flag4-Sem)\n+      --  In_Assertion_Expression (Flag4-Sem)\n       --  Is_Expanded_Build_In_Place_Call (Flag11-Sem)\n       --  Do_Tag_Check (Flag13-Sem)\n       --  No_Elaboration_Check (Flag14-Sem)\n@@ -8628,7 +8628,7 @@ package Sinfo is\n    function Import_Interface_Present\n      (N : Node_Id) return Boolean;    -- Flag16\n \n-   function In_Assertion\n+   function In_Assertion_Expression\n      (N : Node_Id) return Boolean;    -- Flag4\n \n    function In_Present\n@@ -9609,7 +9609,7 @@ package Sinfo is\n    procedure Set_Import_Interface_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n-   procedure Set_In_Assertion\n+   procedure Set_In_Assertion_Expression\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n    procedure Set_In_Present\n@@ -12007,7 +12007,7 @@ package Sinfo is\n    pragma Inline (Interface_Present);\n    pragma Inline (Includes_Infinities);\n    pragma Inline (Import_Interface_Present);\n-   pragma Inline (In_Assertion);\n+   pragma Inline (In_Assertion_Expression);\n    pragma Inline (In_Present);\n    pragma Inline (Inherited_Discriminant);\n    pragma Inline (Instance_Spec);\n@@ -12329,7 +12329,7 @@ package Sinfo is\n    pragma Inline (Set_Interface_List);\n    pragma Inline (Set_Interface_Present);\n    pragma Inline (Set_Import_Interface_Present);\n-   pragma Inline (Set_In_Assertion);\n+   pragma Inline (Set_In_Assertion_Expression);\n    pragma Inline (Set_In_Present);\n    pragma Inline (Set_Inherited_Discriminant);\n    pragma Inline (Set_Instance_Spec);"}, {"sha": "0510c5dfd6c304f4fd94716b3b81089e15430fe2", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e68e7fa76aa33eab48a30186abcb4d3b291322/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=a7e68e7fa76aa33eab48a30186abcb4d3b291322", "patch": "@@ -498,6 +498,7 @@ package Snames is\n    Name_Export_Valued_Procedure        : constant Name_Id := N + $; -- GNAT\n    Name_External                       : constant Name_Id := N + $; -- GNAT\n    Name_Finalize_Storage_Only          : constant Name_Id := N + $; -- GNAT\n+   Name_Ghost                          : constant Name_Id := N + $; -- GNAT\n    Name_Global                         : constant Name_Id := N + $; -- GNAT\n    Name_Ident                          : constant Name_Id := N + $; -- VMS\n    Name_Implementation_Defined         : constant Name_Id := N + $; -- GNAT\n@@ -1792,6 +1793,7 @@ package Snames is\n       Pragma_Export_Valued_Procedure,\n       Pragma_External,\n       Pragma_Finalize_Storage_Only,\n+      Pragma_Ghost,\n       Pragma_Global,\n       Pragma_Ident,\n       Pragma_Implementation_Defined,"}]}