{"sha": "997b8b4d4ca106e1aa07558d1ed050ded496a928", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3YjhiNGQ0Y2ExMDZlMWFhMDc1NThkMWVkMDUwZGVkNDk2YTkyOA==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2004-02-10T01:35:53Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2004-02-10T01:35:53Z"}, "message": "xtensa-protos.h (xtensa_copy_incoming_a7): Update.\n\n\t* config/xtensa/xtensa-protos.h (xtensa_copy_incoming_a7): Update.\n\t(init_cumulative_args): Likewise.\n\t(a7_overlap_mentioned_p): Delete prototype.\n\t* config/xtensa/xtensa.c (struct machine_function): Replace\n\tincoming_a7_copied field with need_a7_copy and vararg_a7 flags.\n\tAdd set_frame_ptr_insn field.\n\t(xtensa_emit_move_sequence): Update call to xtensa_copy_incoming_a7.\n\t(xtensa_copy_incoming_a7): Rewrite to check need_a7_copy flag and check\n\tif the operand is an argument in a7.  If so, copy a7 to a new pseudo\n\tat the function entry and replace the operand with the pseudo.\n\t(init_cumulative_args): Remove unused arguments.  Add new \"incoming\"\n\targument and record this flag in CUMULATIVE_ARGS.\n\t(function_arg): Remove result_mode and special-case code to handle\n\targuments in a7.  Instead, set need_a7_copy flag when there is an\n\tincoming argument in a7.\n\t(xtensa_expand_prologue): Remove code to search for set_frame_ptr insn\n\tand use the value recorded in cfun->machine->set_frame_ptr_insn.\n\t(xtensa_builtin_saveregs): Check for negative gp_left value.  Set\n\tneed_a7_copy and vararg_a7 flags.  Use move_block_from_reg instead of\n\tspecial-case code.\n\t(a7_overlap_mentioned_p): Delete.\n\t* config/xtensa/xtensa.h (CUMULATIVE_ARGS): Add \"incoming\" flag.\n\t(INIT_CUMULATIVE_ARGS, INIT_CUMULATIVE_INCOMING_ARGS): Remove useless\n\targuments to init_cumulative_args and pass \"incoming\" flag instead.\n\t(BLOCK_REG_PADDING): Delete.\n\t* config/xtensa/xtensa.md (movdi, movsf, movdf): Remove unnecessary\n\tchecks for reload_in_progress and reload_completed.  Update calls to\n\txtensa_copy_incoming_a7.\n\t(ashlsi3): Rename existing insn to ashlsi3_internal.  Add expander\n\tto call xtensa_copy_incoming_a7.\n\nFrom-SVN: r77583", "tree": {"sha": "5eba637467e7f664213b6a8716e2fea8bfccb32e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5eba637467e7f664213b6a8716e2fea8bfccb32e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/997b8b4d4ca106e1aa07558d1ed050ded496a928", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997b8b4d4ca106e1aa07558d1ed050ded496a928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/997b8b4d4ca106e1aa07558d1ed050ded496a928", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997b8b4d4ca106e1aa07558d1ed050ded496a928/comments", "author": null, "committer": null, "parents": [{"sha": "99bee03ac222a9cbddfa33edcde3cb6f9b24d01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99bee03ac222a9cbddfa33edcde3cb6f9b24d01c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99bee03ac222a9cbddfa33edcde3cb6f9b24d01c"}], "stats": {"total": 451, "additions": 192, "deletions": 259}, "files": [{"sha": "3b19517e936c77be082a4599e642e5cc664c6087", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=997b8b4d4ca106e1aa07558d1ed050ded496a928", "patch": "@@ -1,3 +1,36 @@\n+2004-02-09  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/xtensa-protos.h (xtensa_copy_incoming_a7): Update.\n+\t(init_cumulative_args): Likewise.\n+\t(a7_overlap_mentioned_p): Delete prototype.\n+\t* config/xtensa/xtensa.c (struct machine_function): Replace\n+\tincoming_a7_copied field with need_a7_copy and vararg_a7 flags.\n+\tAdd set_frame_ptr_insn field.\n+\t(xtensa_emit_move_sequence): Update call to xtensa_copy_incoming_a7.\n+\t(xtensa_copy_incoming_a7): Rewrite to check need_a7_copy flag and check\n+\tif the operand is an argument in a7.  If so, copy a7 to a new pseudo\n+\tat the function entry and replace the operand with the pseudo.\n+\t(init_cumulative_args): Remove unused arguments.  Add new \"incoming\"\n+\targument and record this flag in CUMULATIVE_ARGS.\n+\t(function_arg): Remove result_mode and special-case code to handle\n+\targuments in a7.  Instead, set need_a7_copy flag when there is an\n+\tincoming argument in a7.\n+\t(xtensa_expand_prologue): Remove code to search for set_frame_ptr insn\n+\tand use the value recorded in cfun->machine->set_frame_ptr_insn.\n+\t(xtensa_builtin_saveregs): Check for negative gp_left value.  Set\n+\tneed_a7_copy and vararg_a7 flags.  Use move_block_from_reg instead of\n+\tspecial-case code.\n+\t(a7_overlap_mentioned_p): Delete.\n+\t* config/xtensa/xtensa.h (CUMULATIVE_ARGS): Add \"incoming\" flag.\n+\t(INIT_CUMULATIVE_ARGS, INIT_CUMULATIVE_INCOMING_ARGS): Remove useless\n+\targuments to init_cumulative_args and pass \"incoming\" flag instead.\n+\t(BLOCK_REG_PADDING): Delete.\n+\t* config/xtensa/xtensa.md (movdi, movsf, movdf): Remove unnecessary\n+\tchecks for reload_in_progress and reload_completed.  Update calls to\n+\txtensa_copy_incoming_a7.\n+\t(ashlsi3): Rename existing insn to ashlsi3_internal.  Add expander\n+\tto call xtensa_copy_incoming_a7.\n+\n 2004-02-09  DJ Delorie  <dj@redhat.com>\n \n \t* config/i386/xm-djgpp.h (GCC_DRIVER_HOST_INITIALIZATION): No"}, {"sha": "38a5dce985e91684ce830be93708acfff57e214f", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=997b8b4d4ca106e1aa07558d1ed050ded496a928", "patch": "@@ -68,14 +68,14 @@ extern int xtensa_expand_scc (rtx *);\n extern int xtensa_expand_block_move (rtx *);\n extern void xtensa_split_operand_pair (rtx *, enum machine_mode);\n extern int xtensa_emit_move_sequence (rtx *, enum machine_mode);\n-extern bool xtensa_copy_incoming_a7 (rtx *, enum machine_mode);\n+extern rtx xtensa_copy_incoming_a7 (rtx);\n extern void xtensa_emit_block_move (rtx *, rtx *, int);\n extern void xtensa_expand_nonlocal_goto (rtx *);\n extern void xtensa_emit_loop_end (rtx, rtx *);\n extern char *xtensa_emit_call (int, rtx *);\n \n #ifdef TREE_CODE\n-extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n+extern void init_cumulative_args (CUMULATIVE_ARGS *, int);\n extern void xtensa_va_start (tree, rtx);\n extern rtx xtensa_va_arg (tree, tree);\n #endif /* TREE_CODE */\n@@ -88,7 +88,6 @@ extern enum reg_class xtensa_preferred_reload_class (rtx, enum reg_class, int);\n extern enum reg_class xtensa_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t     enum machine_mode, rtx,\n \t\t\t\t\t\t     int);\n-extern int a7_overlap_mentioned_p (rtx);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE"}, {"sha": "09a2f34941fb05f295ffcf15e186c8d8af7506f7", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 120, "deletions": 204, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=997b8b4d4ca106e1aa07558d1ed050ded496a928", "patch": "@@ -91,7 +91,9 @@ const char *xtensa_st_opcodes[(int) MAX_MACHINE_MODE];\n struct machine_function GTY(())\n {\n   int accesses_prev_frame;\n-  bool incoming_a7_copied;\n+  bool need_a7_copy;\n+  bool vararg_a7;\n+  rtx set_frame_ptr_insn;\n };\n \n /* Vector, indexed by hard register number, which contains 1 for a\n@@ -1271,14 +1273,11 @@ xtensa_emit_move_sequence (rtx *operands, enum machine_mode mode)\n \t}\n     }\n \n-  if (!(reload_in_progress | reload_completed))\n-    {\n-      if (!xtensa_valid_move (mode, operands))\n-\toperands[1] = force_reg (mode, operands[1]);\n+  if (!(reload_in_progress | reload_completed)\n+      && !xtensa_valid_move (mode, operands))\n+    operands[1] = force_reg (mode, operands[1]);\n \n-      if (xtensa_copy_incoming_a7 (operands, mode))\n-\treturn 1;\n-    }\n+  operands[1] = xtensa_copy_incoming_a7 (operands[1]);\n \n   /* During reload we don't want to emit (subreg:X (mem:Y)) since that\n      instruction won't be recognized after reload, so we remove the\n@@ -1309,89 +1308,114 @@ fixup_subreg_mem (rtx x)\n }\n \n \n-/* Check if this move is copying an incoming argument in a7.  If so,\n-   emit the move, followed by the special \"set_frame_ptr\"\n-   unspec_volatile insn, at the very beginning of the function.  This\n-   is necessary because the register allocator will ignore conflicts\n-   with a7 and may assign some other pseudo to a7.  If that pseudo was\n-   assigned prior to this move, it would clobber the incoming argument\n-   in a7.  By copying the argument out of a7 as the very first thing,\n-   and then immediately following that with an unspec_volatile to keep\n-   the scheduler away, we should avoid any problems.  */\n+/* Check if an incoming argument in a7 is expected to be used soon and\n+   if OPND is a register or register pair that includes a7.  If so,\n+   create a new pseudo and copy a7 into that pseudo at the very\n+   beginning of the function, followed by the special \"set_frame_ptr\"\n+   unspec_volatile insn.  The return value is either the original\n+   operand, if it is not a7, or the new pseudo containing a copy of\n+   the incoming argument.  This is necessary because the register\n+   allocator will ignore conflicts with a7 and may either assign some\n+   other pseudo to a7 or use a7 as the hard_frame_pointer, clobbering\n+   the incoming argument in a7.  By copying the argument out of a7 as\n+   the very first thing, and then immediately following that with an\n+   unspec_volatile to keep the scheduler away, we should avoid any\n+   problems.  Putting the set_frame_ptr insn at the beginning, with\n+   only the a7 copy before it, also makes it easier for the prologue\n+   expander to initialize the frame pointer after the a7 copy and to\n+   fix up the a7 copy to use the stack pointer instead of the frame\n+   pointer.  */\n \n-bool\n-xtensa_copy_incoming_a7 (rtx *operands, enum machine_mode mode)\n+rtx\n+xtensa_copy_incoming_a7 (rtx opnd)\n {\n-  if (a7_overlap_mentioned_p (operands[1])\n-      && !cfun->machine->incoming_a7_copied)\n+  rtx entry_insns = 0;\n+  rtx reg, tmp;\n+  enum machine_mode mode;\n+\n+  if (!cfun->machine->need_a7_copy)\n+    return opnd;\n+\n+  /* This function should never be called again once a7 has been copied.  */\n+  if (cfun->machine->set_frame_ptr_insn)\n+    abort ();\n+\n+  mode = GET_MODE (opnd);\n+\n+  /* The operand using a7 may come in a later instruction, so just return\n+     the original operand if it doesn't use a7.  */\n+  reg = opnd;\n+  if (GET_CODE (reg) == SUBREG)\n     {\n-      rtx mov, src;\n-\n-      /* Despite defining SPLIT_COMPLEX_ARGS, complex function\n-\t arguments may still appear if they are wrapped in a struct.\n-\t For CQImode and CHImode arguments, this results in a move\n-\t with a source operand of the form: \"(subreg:SI (reg:CHI a7)\n-\t 0)\".  The subreg is later removed by the reload pass,\n-\t resulting in the RTL for a7 being regenerated using\n-\t hard_frame_pointer_rtx, and making it impossible for us to\n-\t distinguish the function argument.  Detect this here when\n-\t generating the RTL and remove the subreg immediately so that\n-\t reload won't mess it up.  */\n-      src = operands[1];\n-      if (GET_CODE (src) == SUBREG\n-\t  && GET_CODE (SUBREG_REG (src)) == REG\n-\t  && REGNO (SUBREG_REG (src)) == A7_REG\n-\t  && SUBREG_BYTE (src) == 0\n-\t  && (GET_MODE (SUBREG_REG (src)) == CHImode\n-\t      || GET_MODE (SUBREG_REG (src)) == CQImode))\n-\toperands[1] = gen_raw_REG (mode, A7_REG);\n+      if (SUBREG_BYTE (reg) != 0)\n+\tabort ();\n+      reg = SUBREG_REG (reg);\n+    }\n+  if (GET_CODE (reg) != REG\n+      || REGNO (reg) > A7_REG\n+      || REGNO (reg) + HARD_REGNO_NREGS (A7_REG, mode) <= A7_REG)\n+    return opnd;\n \n-      switch (mode)\n-\t{\n-\tcase DFmode:\n-\t  mov = gen_movdf_internal (operands[0], operands[1]);\n-\t  break;\n-\tcase SFmode:\n-\t  mov = gen_movsf_internal (operands[0], operands[1]);\n-\t  break;\n-\tcase DImode:\n-\t  mov = gen_movdi_internal (operands[0], operands[1]);\n-\t  break;\n-\tcase SImode:\n-\t  mov = gen_movsi_internal (operands[0], operands[1]);\n-\t  break;\n-\tcase HImode:\n-\t  mov = gen_movhi_internal (operands[0], operands[1]);\n-\t  break;\n-\tcase QImode:\n-\t  mov = gen_movqi_internal (operands[0], operands[1]);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n+  /* 1-word args will always be in a7; 2-word args in a6/a7.  */\n+  if (REGNO (reg) + HARD_REGNO_NREGS (A7_REG, mode) - 1 != A7_REG)\n+    abort ();\n \n-      /* Insert the instructions before any other argument copies.\n-\t (The set_frame_ptr insn comes _after_ the move, so push it\n-\t out first.)  */\n-      push_topmost_sequence ();\n-      emit_insn_after (gen_set_frame_ptr (), get_insns ());\n-      emit_insn_after (mov, get_insns ());\n-      pop_topmost_sequence ();\n+  cfun->machine->need_a7_copy = false;\n \n-      /* Ideally the incoming argument in a7 would only be copied\n-\t once, since propagating a7 into the body of a function\n-\t will almost certainly lead to errors.  However, there is\n-\t at least one harmless case (in GCSE) where the original\n-\t copy from a7 is changed to copy into a new pseudo.  Thus,\n-\t we use a flag to only do this special treatment for the\n-\t first copy of a7.  */\n+  /* Copy a7 to a new pseudo at the function entry.  Use gen_raw_REG to\n+     create the REG for a7 so that hard_frame_pointer_rtx is not used.  */\n \n-      cfun->machine->incoming_a7_copied = true;\n+  push_to_sequence (entry_insns);\n+  tmp = gen_reg_rtx (mode);\n \n-      return 1;\n+  switch (mode)\n+    {\n+    case DFmode:\n+    case DImode:\n+      emit_insn (gen_movsi_internal (gen_rtx_SUBREG (SImode, tmp, 0),\n+\t\t\t\t     gen_rtx_REG (SImode, A7_REG - 1)));\n+      emit_insn (gen_movsi_internal (gen_rtx_SUBREG (SImode, tmp, 4),\n+\t\t\t\t     gen_raw_REG (SImode, A7_REG)));\n+      break;\n+    case SFmode:\n+      emit_insn (gen_movsf_internal (tmp, gen_raw_REG (mode, A7_REG)));\n+      break;\n+    case SImode:\n+      emit_insn (gen_movsi_internal (tmp, gen_raw_REG (mode, A7_REG)));\n+      break;\n+    case HImode:\n+      emit_insn (gen_movhi_internal (tmp, gen_raw_REG (mode, A7_REG)));\n+      break;\n+    case QImode:\n+      emit_insn (gen_movqi_internal (tmp, gen_raw_REG (mode, A7_REG)));\n+      break;\n+    default:\n+      abort ();\n     }\n \n-  return 0;\n+  cfun->machine->set_frame_ptr_insn = emit_insn (gen_set_frame_ptr ());\n+  entry_insns = get_insns ();\n+  end_sequence ();\n+\n+  if (cfun->machine->vararg_a7)\n+    {\n+      /* This is called from within builtin_savereg, so we're already\n+\t inside a start_sequence that will be placed at the start of\n+\t the function.  */\n+      emit_insn (entry_insns);\n+    }\n+  else\n+    {\n+      /* Put entry_insns after the NOTE that starts the function.  If\n+\t this is inside a start_sequence, make the outer-level insn\n+\t chain current, so the code is placed at the start of the\n+\t function.  */\n+      push_topmost_sequence ();\n+      emit_insn_after (entry_insns, get_insns ());\n+      pop_topmost_sequence ();\n+    }\n+\n+  return tmp;\n }\n \n \n@@ -1727,11 +1751,10 @@ xtensa_dbx_register_number (int regno)\n /* Initialize CUMULATIVE_ARGS for a function.  */\n \n void\n-init_cumulative_args (CUMULATIVE_ARGS *cum,\n-\t\t      tree fntype ATTRIBUTE_UNUSED,\n-\t\t      rtx libname ATTRIBUTE_UNUSED)\n+init_cumulative_args (CUMULATIVE_ARGS *cum, int incoming)\n {\n   cum->arg_words = 0;\n+  cum->incoming = incoming;\n }\n \n \n@@ -1768,7 +1791,6 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n   int regbase, words, max;\n   int *arg_words;\n   int regno;\n-  enum machine_mode result_mode;\n \n   arg_words = &cum->arg_words;\n   regbase = (incoming_p ? GP_ARG_FIRST : GP_OUTGOING_ARG_FIRST);\n@@ -1785,37 +1807,11 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n     return (rtx)0;\n \n   regno = regbase + *arg_words;\n-  result_mode = (mode == BLKmode ? TYPE_MODE (type) : mode);\n-\n-  /* We need to make sure that references to a7 are represented with\n-     rtx that is not equal to hard_frame_pointer_rtx.  For multi-word\n-     modes for which we don't define move patterns, we can't control\n-     the expansion unless we explicitly list the individual registers\n-     in a PARALLEL.  Likewise, a single-word BLKmode argument passed\n-     in a7 must be wrapped in a PARALLEL to avoid code that takes the\n-     register number and builds a new REG.  This is extremely fragile\n-     but seems to be the best solution for now.  */\n-\n-  if ((mode != DImode && mode != DFmode\n-       && regno < A7_REG\n-       && regno + words > A7_REG)\n-      || (mode == BLKmode && regno == A7_REG))\n-    {\n-      rtx result;\n-      int n;\n \n-      result = gen_rtx_PARALLEL (result_mode, rtvec_alloc (words));\n-      for (n = 0; n < words; n++)\n-\t{\n-\t  XVECEXP (result, 0, n) =\n-\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t       gen_raw_REG (SImode, regno + n),\n-\t\t\t       GEN_INT (n * UNITS_PER_WORD));\n-\t}\n-      return result;\n-    }\n+  if (cum->incoming && regno <= A7_REG && regno + words > A7_REG)\n+    cfun->machine->need_a7_copy = true;\n \n-  return gen_raw_REG (result_mode, regno);\n+  return gen_rtx_REG (mode, regno);\n }\n \n \n@@ -2264,41 +2260,18 @@ xtensa_expand_prologue (void)\n \n   if (frame_pointer_needed)\n     {\n-      rtx first, insn, set_frame_ptr_insn = 0;\n-\n-      push_topmost_sequence ();\n-      first = get_insns ();\n-      pop_topmost_sequence ();\n-\n-      /* Search all instructions, looking for the insn that sets up the\n-\t frame pointer.  This search will fail if the function does not\n-\t have an incoming argument in $a7, but in that case, we can just\n-\t set up the frame pointer at the very beginning of the\n-\t function.  */\n-\n-      for (insn = first; insn; insn = NEXT_INSN (insn))\n+      if (cfun->machine->set_frame_ptr_insn)\n \t{\n-\t  rtx pat;\n-\n-\t  if (!INSN_P (insn))\n-\t    continue;\n+\t  rtx first, insn;\n \n-\t  pat = PATTERN (insn);\n-\t  if (GET_CODE (pat) == SET\n-\t      && GET_CODE (SET_SRC (pat)) == UNSPEC_VOLATILE\n-\t      && (XINT (SET_SRC (pat), 1) == UNSPECV_SET_FP))\n-\t    {\n-\t      set_frame_ptr_insn = insn;\n-\t      break;\n-\t    }\n-\t}\n+\t  push_topmost_sequence ();\n+\t  first = get_insns ();\n+\t  pop_topmost_sequence ();\n \n-      if (set_frame_ptr_insn)\n-\t{\n \t  /* For all instructions prior to set_frame_ptr_insn, replace\n \t     hard_frame_pointer references with stack_pointer.  */\n \t  for (insn = first;\n-\t       insn != set_frame_ptr_insn;\n+\t       insn != cfun->machine->set_frame_ptr_insn;\n \t       insn = NEXT_INSN (insn))\n \t    {\n \t      if (INSN_P (insn))\n@@ -2400,9 +2373,8 @@ xtensa_builtin_saveregs (void)\n   rtx gp_regs, dest;\n   int arg_words = current_function_arg_words;\n   int gp_left = MAX_ARGS_IN_REGISTERS - arg_words;\n-  int i;\n \n-  if (gp_left == 0)\n+  if (gp_left <= 0)\n     return const0_rtx;\n \n   /* Allocate the general-purpose register space.  */\n@@ -2414,16 +2386,9 @@ xtensa_builtin_saveregs (void)\n   dest = change_address (gp_regs, SImode,\n \t\t\t plus_constant (XEXP (gp_regs, 0),\n \t\t\t\t\targ_words * UNITS_PER_WORD));\n-\n-  /* Note: Don't use move_block_from_reg() here because the incoming\n-     argument in a7 cannot be represented by hard_frame_pointer_rtx.\n-     Instead, call gen_raw_REG() directly so that we get a distinct\n-     instance of (REG:SI 7).  */\n-  for (i = 0; i < gp_left; i++)\n-    {\n-      emit_move_insn (operand_subword (dest, i, 1, BLKmode),\n-\t\t      gen_raw_REG (SImode, GP_ARG_FIRST + arg_words + i));\n-    }\n+  cfun->machine->need_a7_copy = true;\n+  cfun->machine->vararg_a7 = true;\n+  move_block_from_reg (GP_ARG_FIRST + arg_words, dest, gp_left);\n \n   return XEXP (gp_regs, 0);\n }\n@@ -2749,55 +2714,6 @@ order_regs_for_local_alloc (void)\n }\n \n \n-/* A customized version of reg_overlap_mentioned_p that only looks for\n-   references to a7 (as opposed to hard_frame_pointer_rtx).  */\n-\n-int\n-a7_overlap_mentioned_p (rtx x)\n-{\n-  int i, j;\n-  unsigned int x_regno;\n-  const char *fmt;\n-\n-  if (GET_CODE (x) == REG)\n-    {\n-      x_regno = REGNO (x);\n-      return (x != hard_frame_pointer_rtx\n-\t      && x_regno < A7_REG + 1\n-\t      && x_regno + HARD_REGNO_NREGS (A7_REG, GET_MODE (x)) > A7_REG);\n-    }\n-\n-  if (GET_CODE (x) == SUBREG\n-      && GET_CODE (SUBREG_REG (x)) == REG\n-      && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n-    {\n-      x_regno = subreg_regno (x);\n-      return (SUBREG_REG (x) != hard_frame_pointer_rtx\n-\t      && x_regno < A7_REG + 1\n-\t      && x_regno + HARD_REGNO_NREGS (A7_REG, GET_MODE (x)) > A7_REG);\n-    }\n-\n-  /* X does not match, so try its subexpressions.  */\n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (a7_overlap_mentioned_p (XEXP (x, i)))\n-\t    return 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  for (j = XVECLEN (x, i) - 1; j >=0; j--)\n-\t    if (a7_overlap_mentioned_p (XVECEXP (x, i, j)))\n-\t      return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-\n /* Some Xtensa targets support multiple bss sections.  If the section\n    name ends with \".bss\", add SECTION_BSS to the flags.  */\n "}, {"sha": "a956f1b6bb41615b2b4e553775fa950be4f66ca1", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=997b8b4d4ca106e1aa07558d1ed050ded496a928", "patch": "@@ -736,23 +736,21 @@ extern enum reg_class xtensa_char_to_class[256];\n #define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\t\\\n   ((N) >= GP_OUTGOING_ARG_FIRST && (N) <= GP_OUTGOING_ARG_LAST)\n \n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.  */\n-typedef struct xtensa_args {\n-    int arg_words;\t\t/* # total words the arguments take */\n+/* Record the number of argument words seen so far, along with a flag to\n+   indicate whether these are incoming arguments.  (FUNCTION_INCOMING_ARG\n+   is used for both incoming and outgoing args, so a separate flag is\n+   needed.  */\n+typedef struct xtensa_args\n+{\n+  int arg_words;\n+  int incoming;\n } CUMULATIVE_ARGS;\n \n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-  init_cumulative_args (&CUM, FNTYPE, LIBNAME)\n+  init_cumulative_args (&CUM, 0)\n \n #define INIT_CUMULATIVE_INCOMING_ARGS(CUM, FNTYPE, LIBNAME)\t\t\\\n-  init_cumulative_args (&CUM, FNTYPE, LIBNAME)\n+  init_cumulative_args (&CUM, 1)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n@@ -798,12 +796,6 @@ typedef struct xtensa_args {\n /* Pass complex arguments independently.  */\n #define SPLIT_COMPLEX_ARGS 1\n \n-/* Because Xtensa's function_arg() wraps BLKmode arguments passed in\n-   a7 inside a PARALLEL, BLOCK_REG_PADDING needs to be defined\n-   to get emit_group_store to do the right thing.  */\n-#define BLOCK_REG_PADDING(MODE, TYPE, FIRST) \\\n-  FUNCTION_ARG_PADDING (MODE, TYPE)\n-\n /* Profiling Xtensa code is typically done with the built-in profiling\n    feature of Tensilica's instruction set simulator, which does not\n    require any compiler support.  Profiling code on a real (i.e.,\n@@ -1142,11 +1134,6 @@ typedef struct xtensa_args {\n /* Prefer word-sized loads.  */\n #define SLOW_BYTE_ACCESS 1\n \n-/* ??? Xtensa doesn't have any instructions that set integer values\n-   based on the results of comparisons, but the simplification code in\n-   the combiner also uses STORE_FLAG_VALUE.  The default value (1) is\n-   fine for us, but (-1) might be better.  */\n-\n /* Shift instructions ignore all but the low-order few bits.  */\n #define SHIFT_COUNT_TRUNCATED 1\n "}, {"sha": "6e13568a651ac7c451d9a61ec84a2acbfab44a08", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997b8b4d4ca106e1aa07558d1ed050ded496a928/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=997b8b4d4ca106e1aa07558d1ed050ded496a928", "patch": "@@ -803,15 +803,11 @@\n   if (CONSTANT_P (operands[1]) && !TARGET_CONST16)\n     operands[1] = force_const_mem (DImode, operands[1]);\n \n-  if (!(reload_in_progress | reload_completed))\n-    {\n-      if (!register_operand (operands[0], DImode)\n-\t  && !register_operand (operands[1], DImode))\n-\toperands[1] = force_reg (DImode, operands[1]);\n+  if (!register_operand (operands[0], DImode)\n+      && !register_operand (operands[1], DImode))\n+    operands[1] = force_reg (DImode, operands[1]);\n \n-      if (xtensa_copy_incoming_a7 (operands, DImode))\n-\tDONE;\n-    }\n+  operands[1] = xtensa_copy_incoming_a7 (operands[1]);\n })\n \n (define_insn_and_split \"movdi_internal\"\n@@ -934,18 +930,15 @@\n   if (!TARGET_CONST16 && CONSTANT_P (operands[1]))\n     operands[1] = force_const_mem (SFmode, operands[1]);\n \n-  if (!(reload_in_progress | reload_completed))\n-    {\n-      if ((!register_operand (operands[0], SFmode)\n-\t   && !register_operand (operands[1], SFmode))\n-\t  || (FP_REG_P (xt_true_regnum (operands[0]))\n-\t      && (constantpool_mem_p (operands[1])\n-\t          || CONSTANT_P (operands[1]))))\n-\toperands[1] = force_reg (SFmode, operands[1]);\n-\n-      if (xtensa_copy_incoming_a7 (operands, SFmode))\n-\tDONE;\n-    }\n+  if ((!register_operand (operands[0], SFmode)\n+       && !register_operand (operands[1], SFmode))\n+      || (FP_REG_P (xt_true_regnum (operands[0]))\n+\t  && !(reload_in_progress | reload_completed)\n+\t  && (constantpool_mem_p (operands[1])\n+\t      || CONSTANT_P (operands[1]))))\n+    operands[1] = force_reg (SFmode, operands[1]);\n+\n+  operands[1] = xtensa_copy_incoming_a7 (operands[1]);\n })\n \n (define_insn \"movsf_internal\"\n@@ -1015,15 +1008,11 @@\n   if (CONSTANT_P (operands[1]) && !TARGET_CONST16)\n     operands[1] = force_const_mem (DFmode, operands[1]);\n \n-  if (!(reload_in_progress | reload_completed))\n-    {\n-      if (!register_operand (operands[0], DFmode)\n-\t  && !register_operand (operands[1], DFmode))\n-\toperands[1] = force_reg (DFmode, operands[1]);\n+  if (!register_operand (operands[0], DFmode)\n+      && !register_operand (operands[1], DFmode))\n+    operands[1] = force_reg (DFmode, operands[1]);\n \n-      if (xtensa_copy_incoming_a7 (operands, DFmode))\n-\tDONE;\n-    }\n+  operands[1] = xtensa_copy_incoming_a7 (operands[1]);\n })\n \n (define_insn_and_split \"movdf_internal\"\n@@ -1081,7 +1070,16 @@\n \f\n ;; Shift instructions.\n \n-(define_insn \"ashlsi3\"\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"\")))]\n+  \"\"\n+{\n+  operands[1] = xtensa_copy_incoming_a7 (operands[1]);\n+})\n+\n+(define_insn \"ashlsi3_internal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n \t\t   (match_operand:SI 2 \"arith_operand\" \"J,r\")))]"}]}