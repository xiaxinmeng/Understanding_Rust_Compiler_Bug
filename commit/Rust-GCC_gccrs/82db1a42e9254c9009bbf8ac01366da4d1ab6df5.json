{"sha": "82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJkYjFhNDJlOTI1NGM5MDA5YmJmOGFjMDEzNjZkYTRkMWFiNmRmNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-08-28T21:45:24Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-08-28T22:03:28Z"}, "message": "libstdc++: Fix std::gcd and std::lcm for unsigned integers [PR 92978]\n\nThis fixes a bug with mixed signed and unsigned types, where converting\na negative value to the unsigned result type alters the value. The\nsolution is to obtain the absolute values of the arguments immediately\nand to perform the actual GCD or LCM algorithm on two arguments of the\nsame type.\n\nIn order to operate on the most negative number without overflow when\ntaking its absolute, use an unsigned type for the result of the abs\noperation. For example, -INT_MIN will overflow, but -(unsigned)INT_MIN\nis (unsigned)INT_MAX+1U which is the correct value.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/92978\n\t* include/std/numeric (__abs_integral): Replace with ...\n\t(__detail::__absu): New function template that returns an\n\tunsigned type, guaranteeing it can represent the most\n\tnegative signed value.\n\t(__detail::__gcd, __detail::__lcm): Require arguments to\n\tbe unsigned and therefore already non-negative.\n\t(gcd, lcm): Convert arguments to absolute value as unsigned\n\ttype before calling __detail::__gcd or __detail::__lcm.\n\t* include/experimental/numeric (gcd, lcm): Likewise.\n\t* testsuite/26_numerics/gcd/gcd_neg.cc: Adjust expected\n\terrors.\n\t* testsuite/26_numerics/lcm/lcm_neg.cc: Likewise.\n\t* testsuite/26_numerics/gcd/92978.cc: New test.\n\t* testsuite/26_numerics/lcm/92978.cc: New test.\n\t* testsuite/experimental/numeric/92978.cc: New test.", "tree": {"sha": "8888e703096458531a7c9060fe8285f5a89db2a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8888e703096458531a7c9060fe8285f5a89db2a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d14c547abd484d3540b692bb8048c4a6efe92c8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14c547abd484d3540b692bb8048c4a6efe92c8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d14c547abd484d3540b692bb8048c4a6efe92c8b"}], "stats": {"total": 258, "additions": 190, "deletions": 68}, "files": [{"sha": "4154e535a9409387db359343410aa27cdd617c4b", "filename": "libstdc++-v3/include/experimental/numeric", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnumeric?ref=82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "patch": "@@ -54,29 +54,37 @@ inline namespace fundamentals_v2\n   /// Greatest common divisor\n   template<typename _Mn, typename _Nn>\n     constexpr common_type_t<_Mn, _Nn>\n-    gcd(_Mn __m, _Nn __n)\n+    gcd(_Mn __m, _Nn __n) noexcept\n     {\n-      static_assert(is_integral_v<_Mn>, \"gcd arguments are integers\");\n-      static_assert(is_integral_v<_Nn>, \"gcd arguments are integers\");\n-      static_assert(!is_same_v<remove_cv_t<_Mn>, bool>,\n-\t\t    \"gcd arguments are not bools\");\n-      static_assert(!is_same_v<remove_cv_t<_Nn>, bool>,\n-\t\t    \"gcd arguments are not bools\");\n-      return std::__detail::__gcd(__m, __n);\n+      static_assert(is_integral_v<_Mn>,\n+\t  \"std::experimental::gcd arguments must be integers\");\n+      static_assert(is_integral_v<_Nn>,\n+\t  \"std::experimental::gcd arguments must be integers\");\n+      static_assert(_Mn(2) != _Mn(1),\n+\t  \"std::experimental::gcd arguments must not be bool\");\n+      static_assert(_Nn(2) != _Nn(1),\n+\t  \"std::experimental::gcd arguments must not be bool\");\n+      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;\n+      return std::__detail::__gcd(std::__detail::__absu<_Up>(__m),\n+\t\t\t\t  std::__detail::__absu<_Up>(__n));\n     }\n \n   /// Least common multiple\n   template<typename _Mn, typename _Nn>\n     constexpr common_type_t<_Mn, _Nn>\n     lcm(_Mn __m, _Nn __n)\n     {\n-      static_assert(is_integral_v<_Mn>, \"lcm arguments are integers\");\n-      static_assert(is_integral_v<_Nn>, \"lcm arguments are integers\");\n-      static_assert(!is_same_v<remove_cv_t<_Mn>, bool>,\n-\t\t    \"lcm arguments are not bools\");\n-      static_assert(!is_same_v<remove_cv_t<_Nn>, bool>,\n-\t\t    \"lcm arguments are not bools\");\n-      return std::__detail::__lcm(__m, __n);\n+      static_assert(is_integral_v<_Mn>,\n+\t  \"std::experimental::lcm arguments must be integers\");\n+      static_assert(is_integral_v<_Nn>,\n+\t  \"std::experimental::lcm arguments must be integers\");\n+      static_assert(_Mn(2) != _Mn(1),\n+\t  \"std::experimental::lcm arguments must not be bool\");\n+      static_assert(_Nn(2) != _Nn(1),\n+\t  \"std::experimental::lcm arguments must not be bool\");\n+      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;\n+      return std::__detail::__lcm(std::__detail::__absu<_Up>(__m),\n+\t\t\t\t  std::__detail::__absu<_Up>(__n));\n     }\n } // namespace fundamentals_v2\n } // namespace experimental"}, {"sha": "8f2ed5c6a5e879083ee7cbcf47d49a7f703bfb91", "filename": "libstdc++-v3/include/std/numeric", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric?ref=82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "patch": "@@ -60,6 +60,7 @@\n #include <bits/c++config.h>\n #include <bits/stl_iterator_base_types.h>\n #include <bits/stl_numeric.h>\n+#include <ext/numeric_traits.h>\n \n #ifdef _GLIBCXX_PARALLEL\n # include <parallel/numeric>\n@@ -82,38 +83,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n namespace __detail\n {\n-  // std::abs is not constexpr and doesn't support unsigned integers.\n-  template<typename _Tp>\n-    constexpr\n-    enable_if_t<__and_<is_integral<_Tp>, is_signed<_Tp>>::value, _Tp>\n-    __abs_integral(_Tp __val)\n-    { return __val < 0 ? -__val : __val; }\n-\n-  template<typename _Tp>\n-    constexpr\n-    enable_if_t<__and_<is_integral<_Tp>, is_unsigned<_Tp>>::value, _Tp>\n-    __abs_integral(_Tp __val)\n-    { return __val; }\n+  // std::abs is not constexpr, doesn't support unsigned integers,\n+  // and std::abs(std::numeric_limits<T>::min()) is undefined.\n+  template<typename _Up, typename _Tp>\n+    constexpr _Up\n+    __absu(_Tp __val)\n+    {\n+      static_assert(is_unsigned<_Up>::value, \"result type must be unsigned\");\n+      static_assert(sizeof(_Up) >= sizeof(_Tp),\n+\t  \"result type must be at least as wide as the input type\");\n+      return __val < 0 ? -(_Up)__val : (_Up)__val;\n+    }\n \n-  void __abs_integral(bool) = delete;\n+  void __absu(bool) = delete;\n \n-  template<typename _Mn, typename _Nn>\n-    constexpr common_type_t<_Mn, _Nn>\n-    __gcd(_Mn __m, _Nn __n)\n+  // GCD implementation\n+  template<typename _Tp>\n+    constexpr _Tp\n+    __gcd(_Tp __m, _Tp __n)\n     {\n-      return __m == 0 ? __detail::__abs_integral(__n)\n-\t: __n == 0 ? __detail::__abs_integral(__m)\n-\t: __detail::__gcd(__n, __m % __n);\n+      static_assert(is_unsigned<_Tp>::value, \"type must be unsigned\");\n+      return __m == 0 ? __n\n+\t: __n == 0 ? __m\n+\t: __detail::__gcd(__n, _Tp(__m % __n));\n     }\n \n-  /// Least common multiple\n-  template<typename _Mn, typename _Nn>\n-    constexpr common_type_t<_Mn, _Nn>\n-    __lcm(_Mn __m, _Nn __n)\n+  // LCM implementation\n+  template<typename _Tp>\n+    constexpr _Tp\n+    __lcm(_Tp __m, _Tp __n)\n     {\n       return (__m != 0 && __n != 0)\n-\t? (__detail::__abs_integral(__m) / __detail::__gcd(__m, __n))\n-\t  * __detail::__abs_integral(__n)\n+\t? (__m / __detail::__gcd(__m, __n)) * __n\n \t: 0;\n     }\n } // namespace __detail\n@@ -128,29 +129,29 @@ namespace __detail\n   /// Greatest common divisor\n   template<typename _Mn, typename _Nn>\n     constexpr common_type_t<_Mn, _Nn>\n-    gcd(_Mn __m, _Nn __n)\n+    gcd(_Mn __m, _Nn __n) noexcept\n     {\n-      static_assert(is_integral_v<_Mn>, \"gcd arguments are integers\");\n-      static_assert(is_integral_v<_Nn>, \"gcd arguments are integers\");\n-      static_assert(!is_same_v<remove_cv_t<_Mn>, bool>,\n-\t\t    \"gcd arguments are not bools\");\n-      static_assert(!is_same_v<remove_cv_t<_Nn>, bool>,\n-\t\t    \"gcd arguments are not bools\");\n-      return __detail::__gcd(__m, __n);\n+      static_assert(is_integral_v<_Mn>, \"std::gcd arguments must be integers\");\n+      static_assert(is_integral_v<_Nn>, \"std::gcd arguments must be integers\");\n+      static_assert(_Mn(2) != _Mn(1), \"std::gcd arguments must not be bool\");\n+      static_assert(_Nn(2) != _Nn(1), \"std::gcd arguments must not be bool\");\n+      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;\n+      return __detail::__gcd(__detail::__absu<_Up>(__m),\n+\t\t\t     __detail::__absu<_Up>(__n));\n     }\n \n   /// Least common multiple\n   template<typename _Mn, typename _Nn>\n     constexpr common_type_t<_Mn, _Nn>\n-    lcm(_Mn __m, _Nn __n)\n+    lcm(_Mn __m, _Nn __n) noexcept\n     {\n-      static_assert(is_integral_v<_Mn>, \"lcm arguments are integers\");\n-      static_assert(is_integral_v<_Nn>, \"lcm arguments are integers\");\n-      static_assert(!is_same_v<remove_cv_t<_Mn>, bool>,\n-\t\t    \"lcm arguments are not bools\");\n-      static_assert(!is_same_v<remove_cv_t<_Nn>, bool>,\n-\t\t    \"lcm arguments are not bools\");\n-      return __detail::__lcm(__m, __n);\n+      static_assert(is_integral_v<_Mn>, \"std::lcm arguments must be integers\");\n+      static_assert(is_integral_v<_Nn>, \"std::lcm arguments must be integers\");\n+      static_assert(_Mn(2) == 2, \"std::lcm arguments must not be bool\");\n+      static_assert(_Nn(2) == 2, \"std::lcm arguments must not be bool\");\n+      using _Up = make_unsigned_t<common_type_t<_Mn, _Nn>>;\n+      return __detail::__lcm(__detail::__absu<_Up>(__m),\n+\t\t\t     __detail::__absu<_Up>(__n));\n     }\n \n #endif // C++17"}, {"sha": "0ae1d3bb6c41b282278a0a84a1456a36f78e7d1e", "filename": "libstdc++-v3/testsuite/26_numerics/gcd/92978.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F92978.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F92978.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2F92978.cc?ref=82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "patch": "@@ -0,0 +1,40 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++17 } }\n+\n+#include <numeric>\n+#include <limits.h>\n+\n+void\n+test01()\n+{\n+  // PR libstdc++/92978\n+  static_assert( std::gcd(-120, 10U) == 10 );\n+  static_assert( std::gcd(120U, -10) == 10 );\n+}\n+\n+void\n+test02()\n+{\n+  // |INT_MIN| should not be undefined, as long as it fits in the result type.\n+  static_assert( std::gcd(INT_MIN, 0LL) == 1LL+INT_MAX );\n+  static_assert( std::gcd(0LL, INT_MIN) == 1LL+INT_MAX );\n+  static_assert( std::gcd(INT_MIN, 0LL + INT_MIN) == 1LL + INT_MAX );\n+  static_assert( std::gcd(INT_MIN, 1LL + INT_MAX) == 1LL + INT_MAX );\n+  static_assert( std::gcd(SHRT_MIN, 1U + SHRT_MAX) == 1U + SHRT_MAX );\n+}"}, {"sha": "707148a267043c4a71adf620e24566e22457d6c0", "filename": "libstdc++-v3/testsuite/26_numerics/gcd/gcd_neg.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fgcd%2Fgcd_neg.cc?ref=82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "patch": "@@ -46,9 +46,8 @@ test01()\n   std::gcd<const int&, const int&>(0.1, 0.1);   // { dg-error \"from here\" }\n }\n \n-// { dg-error \"integers\" \"\" { target *-*-* } 133 }\n-// { dg-error \"integers\" \"\" { target *-*-* } 134 }\n-// { dg-error \"not bools\" \"\" { target *-*-* } 135 }\n-// { dg-error \"not bools\" \"\" { target *-*-* } 137 }\n-// { dg-prune-output \"deleted function\" }\n-// { dg-prune-output \"invalid operands\" }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 134 }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 135 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 136 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 137 }\n+// { dg-prune-output \"incomplete type .*make_unsigned\" }"}, {"sha": "0a016c34d43c1e25f349b6d4ddabb5408f798cfd", "filename": "libstdc++-v3/testsuite/26_numerics/lcm/92978.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2F92978.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2F92978.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2F92978.cc?ref=82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++17 } }\n+\n+#include <numeric>\n+\n+void\n+test01()\n+{\n+  // PR libstdc++/92978\n+  static_assert( std::lcm(-42, 21U) == 42U );\n+}"}, {"sha": "d4aa6b59da8ed6e92b0c8e07f8d6b2612fff51b0", "filename": "libstdc++-v3/testsuite/26_numerics/lcm/lcm_neg.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Flcm%2Flcm_neg.cc?ref=82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "patch": "@@ -46,9 +46,8 @@ test01()\n   std::lcm<const int&, const int&>(0.1, 0.1);   // { dg-error \"from here\" }\n }\n \n-// { dg-error \"integers\" \"\" { target *-*-* } 147 }\n-// { dg-error \"integers\" \"\" { target *-*-* } 148 }\n-// { dg-error \"not bools\" \"\" { target *-*-* } 149 }\n-// { dg-error \"not bools\" \"\" { target *-*-* } 151 }\n-// { dg-prune-output \"deleted function\" }\n-// { dg-prune-output \"invalid operands\" }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 148 }\n+// { dg-error \"must be integers\" \"\" { target *-*-* } 149 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 150 }\n+// { dg-error \"must not be bool\" \"\" { target *-*-* } 151 }\n+// { dg-prune-output \"incomplete type .*make_unsigned\" }"}, {"sha": "8408fd4d9ce3dc1df43e15f5f96d027d181ed7b7", "filename": "libstdc++-v3/testsuite/experimental/numeric/92978.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnumeric%2F92978.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82db1a42e9254c9009bbf8ac01366da4d1ab6df5/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnumeric%2F92978.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnumeric%2F92978.cc?ref=82db1a42e9254c9009bbf8ac01366da4d1ab6df5", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++14 } }\n+\n+#include <experimental/numeric>\n+#include <limits.h>\n+\n+void\n+test01()\n+{\n+  // PR libstdc++/92978\n+  static_assert( std::experimental::gcd(-120, 10U) == 10,\n+      \"mixed signed/unsigned\" );\n+  static_assert( std::experimental::gcd(120U, -10) == 10,\n+      \"mixed signed/unsigned\" );\n+\n+  static_assert( std::lcm(-42, 21U) == 42U );\n+}\n+\n+void\n+test02()\n+{\n+  static_assert( std::experimental::gcd(INT_MIN, 0LL) == 1LL+INT_MAX,\n+      \"|INT_MIN| should not be undefined as long as it fits in the result\" );\n+  static_assert( std::experimental::gcd(0LL, INT_MIN) == 1LL+INT_MAX,\n+      \"|INT_MIN| should not be undefined\" );\n+  static_assert( std::experimental::gcd(INT_MIN, 0LL + INT_MIN) == 1LL + INT_MAX,\n+      \"|INT_MIN| should not be undefined\" );\n+  static_assert( std::experimental::gcd(INT_MIN, 1LL + INT_MAX) == 1LL + INT_MAX,\n+      \"|INT_MIN| should not be undefined\" );\n+  static_assert( std::experimental::gcd(SHRT_MIN, 1U + SHRT_MAX) == 1U + SHRT_MAX,\n+      \"|SHRT_MIN| should not be undefined\" );\n+}"}]}