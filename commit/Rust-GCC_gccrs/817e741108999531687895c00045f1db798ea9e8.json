{"sha": "817e741108999531687895c00045f1db798ea9e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE3ZTc0MTEwODk5OTUzMTY4Nzg5NWMwMDA0NWYxZGI3OThlYTllOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-05-12T06:16:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-05-12T06:16:21Z"}, "message": "eh_personality.cc: Include unwind-pe.h.\n\n        * libsupc++/eh_personality.cc: Include unwind-pe.h.  Remove\n        all pointer encoding logic.\n        (struct lsda_header_info): Add ttype_base.\n        (get_ttype_entry): Use it instead of a context.\n        (check_exception_spec): Likewise.\n        (PERSONALITY_FUNCTION): Initialize ttype_base.  Store it in\n        the c++ exception header for __cxa_call_unexpected.\n        (__cxa_call_unexpected): Use it.\n\nFrom-SVN: r41982", "tree": {"sha": "cbada5b806739d2fe2fe015d836399811a9f2088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbada5b806739d2fe2fe015d836399811a9f2088"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/817e741108999531687895c00045f1db798ea9e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/817e741108999531687895c00045f1db798ea9e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/817e741108999531687895c00045f1db798ea9e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/817e741108999531687895c00045f1db798ea9e8/comments", "author": null, "committer": null, "parents": [{"sha": "2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1ee410cefc93b247bbcc9b8a153ba5af72be73"}], "stats": {"total": 213, "additions": 34, "deletions": 179}, "files": [{"sha": "a88f124dd0d14c8d13d884100ec52382748a2fb2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/817e741108999531687895c00045f1db798ea9e8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/817e741108999531687895c00045f1db798ea9e8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=817e741108999531687895c00045f1db798ea9e8", "patch": "@@ -1,3 +1,14 @@\n+2001-05-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* libsupc++/eh_personality.cc: Include unwind-pe.h.  Remove\n+\tall pointer encoding logic.\n+\t(struct lsda_header_info): Add ttype_base.\n+\t(get_ttype_entry): Use it instead of a context.\n+\t(check_exception_spec): Likewise.\n+\t(PERSONALITY_FUNCTION): Initialize ttype_base.  Store it in\n+\tthe c++ exception header for __cxa_call_unexpected.\n+\t(__cxa_call_unexpected): Use it.\n+\n 2001-05-09  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/lib/libstdc++.exp: Use libgloss.exp. Call"}, {"sha": "044212832a6d0612fbffc882a916bc00b6fd6b00", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 23, "deletions": 179, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/817e741108999531687895c00045f1db798ea9e8/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/817e741108999531687895c00045f1db798ea9e8/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=817e741108999531687895c00045f1db798ea9e8", "patch": "@@ -34,181 +34,14 @@\n \n using namespace __cxxabiv1;\n \n-\n-\f\n-// ??? These ought to go somewhere else dwarf2 or dwarf2eh related.\n-\n-// Pointer encodings.\n-#define DW_EH_PE_absptr         0x00\n-#define DW_EH_PE_omit           0xff\n-\n-#define DW_EH_PE_uleb128        0x01\n-#define DW_EH_PE_udata2         0x02\n-#define DW_EH_PE_udata4         0x03\n-#define DW_EH_PE_udata8         0x04\n-#define DW_EH_PE_sleb128        0x09\n-#define DW_EH_PE_sdata2         0x0A\n-#define DW_EH_PE_sdata4         0x0B\n-#define DW_EH_PE_sdata8         0x0C\n-#define DW_EH_PE_signed         0x08\n-\n-#define DW_EH_PE_pcrel          0x10\n-#define DW_EH_PE_textrel        0x20\n-#define DW_EH_PE_datarel        0x30\n-#define DW_EH_PE_funcrel        0x40\n-\n-static unsigned int\n-size_of_encoded_value (unsigned char encoding)\n-{\n-  switch (encoding & 0x07)\n-    {\n-    case DW_EH_PE_absptr:\n-      return sizeof (void *);\n-    case DW_EH_PE_udata2:\n-      return 2;\n-    case DW_EH_PE_udata4:\n-      return 4;\n-    case DW_EH_PE_udata8:\n-      return 8;\n-    }\n-  abort ();\n-}\n-\n-static const unsigned char *\n-read_encoded_value (_Unwind_Context *context, unsigned char encoding,\n-\t\t    const unsigned char *p, _Unwind_Ptr *val)\n-{\n-  union unaligned\n-    {\n-      void *ptr;\n-      unsigned u2 __attribute__ ((mode (HI)));\n-      unsigned u4 __attribute__ ((mode (SI)));\n-      unsigned u8 __attribute__ ((mode (DI)));\n-      signed s2 __attribute__ ((mode (HI)));\n-      signed s4 __attribute__ ((mode (SI)));\n-      signed s8 __attribute__ ((mode (DI)));\n-    } __attribute__((__packed__));\n-\n-  union unaligned *u = (union unaligned *) p;\n-  _Unwind_Ptr result;\n-\n-  switch (encoding & 0x0f)\n-    {\n-    case DW_EH_PE_absptr:\n-      result = (_Unwind_Ptr) u->ptr;\n-      p += sizeof (void *);\n-      break;\n-\n-    case DW_EH_PE_uleb128:\n-      {\n-\tunsigned int shift = 0;\n-\tunsigned char byte;\n-\n-\tresult = 0;\n-\tdo\n-\t  {\n-\t    byte = *p++;\n-\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n-\t    shift += 7;\n-\t  }\n-\twhile (byte & 0x80);\n-      }\n-      break;\n-\n-    case DW_EH_PE_sleb128:\n-      {\n-\tunsigned int shift = 0;\n-\tunsigned char byte;\n-\n-\tresult = 0;\n-\tdo\n-\t  {\n-\t    byte = *p++;\n-\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n-\t    shift += 7;\n-\t  }\n-\twhile (byte & 0x80);\n-\n-\tif (shift < 8 * sizeof(result) && (byte & 0x40) != 0)\n-\t  result |= -(1L << shift);\n-      }\n-      break;\n-\n-    case DW_EH_PE_udata2:\n-      result = u->u2;\n-      p += 2;\n-      break;\n-    case DW_EH_PE_udata4:\n-      result = u->u4;\n-      p += 4;\n-      break;\n-    case DW_EH_PE_udata8:\n-      result = u->u8;\n-      p += 8;\n-      break;\n-\n-    case DW_EH_PE_sdata2:\n-      result = u->s2;\n-      p += 2;\n-      break;\n-    case DW_EH_PE_sdata4:\n-      result = u->s4;\n-      p += 4;\n-      break;\n-    case DW_EH_PE_sdata8:\n-      result = u->s8;\n-      p += 8;\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  if (result != 0)\n-    switch (encoding & 0xf0)\n-      {\n-      case DW_EH_PE_absptr:\n-\tbreak;\n-\n-      case DW_EH_PE_pcrel:\n-\t// Define as relative to the beginning of the pointer.\n-\tresult += (_Unwind_Ptr) u;\n-\tbreak;\n-\n-      case DW_EH_PE_textrel:\n-      case DW_EH_PE_datarel:\n-\t// FIXME.\n-\tabort ();\n-\n-      case DW_EH_PE_funcrel:\n-\tresult += _Unwind_GetRegionStart (context);\n-\tbreak;\n-\n-      default:\n-\tabort ();\n-      }\n-\n-  *val = result;\n-  return p;\n-}\n-\n-static inline const unsigned char *\n-read_uleb128 (const unsigned char *p, _Unwind_Ptr *val)\n-{\n-  return read_encoded_value (0, DW_EH_PE_uleb128, p, val);\n-}\n-\n-static inline const unsigned char *\n-read_sleb128 (const unsigned char *p, _Unwind_Ptr *val)\n-{\n-  return read_encoded_value (0, DW_EH_PE_sleb128, p, val);\n-}\n+#include \"unwind-pe.h\"\n \n \f\n struct lsda_header_info\n {\n   _Unwind_Ptr Start;\n   _Unwind_Ptr LPStart;\n+  _Unwind_Ptr ttype_base;\n   const unsigned char *TType;\n   const unsigned char *action_table;\n   unsigned char ttype_encoding;\n@@ -251,19 +84,20 @@ parse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n }\n \n static const std::type_info *\n-get_ttype_entry (_Unwind_Context *context, lsda_header_info *info, long i)\n+get_ttype_entry (lsda_header_info *info, long i)\n {\n   _Unwind_Ptr ptr;\n \n   i *= size_of_encoded_value (info->ttype_encoding);\n-  read_encoded_value (context, info->ttype_encoding, info->TType - i, &ptr);\n+  read_encoded_value_with_base (info->ttype_encoding, info->ttype_base,\n+\t\t\t\tinfo->TType - i, &ptr);\n \n   return reinterpret_cast<const std::type_info *>(ptr);\n }\n \n static bool\n-check_exception_spec (_Unwind_Context *context, lsda_header_info *info,\n-\t\t      const std::type_info *throw_type, long filter_value)\n+check_exception_spec (lsda_header_info *info, const std::type_info *throw_type,\n+\t\t      long filter_value)\n {\n   const unsigned char *e = info->TType - filter_value - 1;\n \n@@ -281,7 +115,7 @@ check_exception_spec (_Unwind_Context *context, lsda_header_info *info,\n         return false;\n \n       // Match a ttype entry.\n-      catch_type = get_ttype_entry (context, info, tmp);\n+      catch_type = get_ttype_entry (info, tmp);\n       if (catch_type->__do_catch (throw_type, &dummy, 1))\n \treturn true;\n     }\n@@ -344,6 +178,7 @@ PERSONALITY_FUNCTION (int version,\n \n   // Parse the LSDA header.\n   p = parse_lsda_header (context, language_specific_data, &info);\n+  info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);\n   ip = _Unwind_GetIP (context) - 1;\n   landing_pad = 0;\n   action_record = 0;\n@@ -458,7 +293,7 @@ PERSONALITY_FUNCTION (int version,\n \t  else if (ar_filter > 0)\n \t    {\n \t      // Positive filter values are handlers.\n-\t      catch_type = get_ttype_entry (context, &info, ar_filter);\n+\t      catch_type = get_ttype_entry (&info, ar_filter);\n \t      adjusted_ptr = xh + 1;\n \n \t      // Null catch type is a catch-all handler.  We can catch\n@@ -494,8 +329,7 @@ PERSONALITY_FUNCTION (int version,\n \t      // see we can't match because there's no __cxa_exception\n \t      // object to stuff bits in for __cxa_call_unexpected to use.\n \t      if (throw_type\n-\t\t  && ! check_exception_spec (context, &info, throw_type,\n-\t\t\t\t\t     ar_filter))\n+\t\t  && ! check_exception_spec (&info, throw_type, ar_filter))\n \t\t{\n \t\t  saw_handler = true;\n \t\t  break;\n@@ -547,6 +381,15 @@ PERSONALITY_FUNCTION (int version,\n       __terminate (xh->terminateHandler);\n     }\n \n+  // Cache the TType base value for __cxa_call_unexpected, as we won't\n+  // have an _Unwind_Context then.\n+  if (handler_switch_value < 0)\n+    {\n+      parse_lsda_header (context, xh->languageSpecificData, &info);\n+      xh->catchTemp = (void *) base_of_encoded_value (info.ttype_encoding,\n+\t\t\t\t\t\t      context);\n+    }\n+\n   _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),\n \t\t (_Unwind_Ptr) &xh->unwindHeader);\n   _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),\n@@ -582,15 +425,16 @@ __cxa_call_unexpected (_Unwind_Exception *exc_obj)\n     // We don't quite have enough stuff cached; re-parse the LSDA.\n     lsda_header_info info;\n     parse_lsda_header (0, xh->languageSpecificData, &info);\n+    info.ttype_base = (_Unwind_Ptr) xh->catchTemp;\n \n     // If this new exception meets the exception spec, allow it.\n-    if (check_exception_spec (0, &info, new_xh->exceptionType,\n+    if (check_exception_spec (&info, new_xh->exceptionType,\n \t\t\t      xh->handlerSwitchValue))\n       throw;\n \n     // If the exception spec allows std::bad_exception, throw that.\n     const std::type_info &bad_exc = typeid (std::bad_exception);\n-    if (check_exception_spec (0, &info, &bad_exc, xh->handlerSwitchValue))\n+    if (check_exception_spec (&info, &bad_exc, xh->handlerSwitchValue))\n       throw std::bad_exception ();\n \n     // Otherwise, die."}]}