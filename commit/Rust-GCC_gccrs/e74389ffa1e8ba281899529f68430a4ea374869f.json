{"sha": "e74389ffa1e8ba281899529f68430a4ea374869f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc0Mzg5ZmZhMWU4YmEyODE4OTk1MjlmNjg0MzBhNGVhMzc0ODY5Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-05-17T02:31:35Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-05-17T02:31:35Z"}, "message": "reg-stack.c: Do not emit pop insns after cc0 setter.\n\n        * reg-stack.c: Do not emit pop insns after cc0 setter.\n        (emit_pop_insn): Do not emit insn in case WHEN is NULL.\n        (compare_for_stack_reg): Update REG_DEAD note and\n        do not emit push insn.\n        * i386.c: (output_float_compare): Handle new REG_DEAD notes.\n\nFrom-SVN: r26965", "tree": {"sha": "352e06d5ae889d3da960338aa9f5471299bbb3f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/352e06d5ae889d3da960338aa9f5471299bbb3f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e74389ffa1e8ba281899529f68430a4ea374869f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74389ffa1e8ba281899529f68430a4ea374869f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e74389ffa1e8ba281899529f68430a4ea374869f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74389ffa1e8ba281899529f68430a4ea374869f/comments", "author": null, "committer": null, "parents": [{"sha": "64c0b414201b1a9800d515ae895c19658f53d91f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64c0b414201b1a9800d515ae895c19658f53d91f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64c0b414201b1a9800d515ae895c19658f53d91f"}], "stats": {"total": 101, "additions": 75, "deletions": 26}, "files": [{"sha": "a70aa9c4bc7cef4f2efdb33860aed677bd184312", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74389ffa1e8ba281899529f68430a4ea374869f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74389ffa1e8ba281899529f68430a4ea374869f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e74389ffa1e8ba281899529f68430a4ea374869f", "patch": "@@ -1,3 +1,12 @@\n+Sat Oct 31 05:08:34 CET 1998 Jan Hubicka  (hubicka@freesoft.cz)\n+\n+\t* reg-stack.c: Do not emit pop insns after cc0 setter.\n+\t(emit_pop_insn): Do not emit insn in case WHEN is NULL.\n+\t(compare_for_stack_reg): Update REG_DEAD note and \n+\tdo not emit push insn.\n+\n+\t* i386.c: (output_float_compare): Handle new REG_DEAD notes.\n+\n Mon May 17 01:57:37 1999  David Daney <daney@ibw.com.ni>\n \n \t* i386/sol2.h (LINK_SPEC): Do not pass \"-z text\" to the linker"}, {"sha": "2e8236dcbbc084d67a0af5379ddda5e0d0c4e165", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74389ffa1e8ba281899529f68430a4ea374869f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74389ffa1e8ba281899529f68430a4ea374869f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e74389ffa1e8ba281899529f68430a4ea374869f", "patch": "@@ -4115,6 +4115,8 @@ output_float_compare (insn, operands)\n   rtx body = XVECEXP (PATTERN (insn), 0, 0);\n   int unordered_compare = GET_MODE (SET_SRC (body)) == CCFPEQmode;\n   rtx tmp;\n+  int cc0_set = 1;\n+  int i;\n \n   if (0 && TARGET_CMOVE && STACK_REG_P (operands[1]))\n     {\n@@ -4138,7 +4140,7 @@ output_float_compare (insn, operands)\n   if (STACK_REG_P (operands[1])\n       && stack_top_dies\n       && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))\n-      && REGNO (operands[1]) != FIRST_STACK_REG)\n+      && REGNO (operands[1]) == FIRST_STACK_REG + 1)\n     {\n       /* If both the top of the 387 stack dies, and the other operand\n \t is also a stack register that dies, then this must be a\n@@ -4150,7 +4152,7 @@ output_float_compare (insn, operands)\n \t    {\n \t      output_asm_insn (AS2 (fucomip,%y1,%0), operands);\n \t      output_asm_insn (AS1 (fstp, %y0), operands);\n-\t      return \"\";\n+\t      cc0_set = 0; \n \t    }\n \t  else\n \t    output_asm_insn (\"fucompp\", operands);\n@@ -4161,7 +4163,7 @@ output_float_compare (insn, operands)\n \t    {\n \t      output_asm_insn (AS2 (fcomip, %y1,%0), operands);\n \t      output_asm_insn (AS1 (fstp, %y0), operands);\n-\t      return \"\";\n+\t      cc0_set = 0; \n \t    }\n \t  else\n \t    output_asm_insn (\"fcompp\", operands);\n@@ -4186,15 +4188,39 @@ output_float_compare (insn, operands)\n       if (cc_status.flags & CC_FCOMI)\n \t{\n \t  output_asm_insn (strcat (buf, AS2 (%z1,%y1,%0)), operands);\n-\t  return \"\";\n+\t  cc0_set = 0; \n \t}\n       else\n         output_asm_insn (strcat (buf, AS1 (%z1,%y1)), operands);\n     }\n \n   /* Now retrieve the condition code. */\n+  if (cc0_set) \n+    {\n+      char *r = output_fp_cc0_set (insn); \n+      if (r[0]) output_asm_insn (r, operands);\n+    }\n+\n+\n+  /* We emit fstp instruction after integer comparsions to improve\n+     scheduling. */\n+  for (i = 0; i < 2 ; i++)\n+    {\n+      if (STACK_REG_P (operands[i])\n+          && find_regno_note (insn, REG_DEAD, REGNO (operands[i]))\n+          && REGNO (operands[i]) != FIRST_STACK_REG \n+          && (!stack_top_dies || REGNO (operands[i]) != FIRST_STACK_REG + 1))\n+        {\n+          rtx xexp[i];\n+          xexp[0] = gen_rtx_REG (DFmode,\n+\t\t\t\t REGNO (operands[i]) - (stack_top_dies != 0));\n+          output_asm_insn (AS1 (fstp, %y0), xexp);\n+        }\n+    }\n+\n+  return \"\";\n+\n \n-  return output_fp_cc0_set (insn);\n }\n \f\n /* Output opcodes to transfer the results of FP compare or test INSN"}, {"sha": "787b5a180322f7997636cf37b96ce46294b9ea6f", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74389ffa1e8ba281899529f68430a4ea374869f/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74389ffa1e8ba281899529f68430a4ea374869f/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=e74389ffa1e8ba281899529f68430a4ea374869f", "patch": "@@ -1470,9 +1470,12 @@ delete_insn_for_stacker (insn)\n \f\n /* Emit an insn to pop virtual register REG before or after INSN.\n    REGSTACK is the stack state after INSN and is updated to reflect this\n-   pop.  WHEN is either emit_insn_before or emit_insn_after.  A pop insn\n-   is represented as a SET whose destination is the register to be popped\n-   and source is the top of stack.  A death note for the top of stack\n+   pop.  WHEN is either emit_insn_before, emit_insn_after or NULL. \n+   in case WHEN is NULL we don't really emit the insn, just modify stack \n+   information.  Caller is expected to emit insn himself.\n+\n+   A pop insn is represented as a SET whose destination is the register to\n+   be popped and source is the top of stack.  A death note for the top of stack\n    cases the movdf pattern to pop.  */\n \n static rtx\n@@ -1490,14 +1493,18 @@ emit_pop_insn (insn, regstack, reg, when)\n   if (hard_regno < FIRST_STACK_REG)\n     abort ();\n \n-  pop_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n-\t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n+  if (when)\n+   {\n+     pop_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n+\t\t\t    FP_MODE_REG (FIRST_STACK_REG, DFmode));\n \n-  pop_insn = (*when) (pop_rtx, insn);\n+     pop_insn = (*when) (pop_rtx, insn);\n \n-  REG_NOTES (pop_insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t    FP_MODE_REG (FIRST_STACK_REG, DFmode),\n-\t\t\t\t\t    REG_NOTES (pop_insn));\n+     REG_NOTES (pop_insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t       FP_MODE_REG (FIRST_STACK_REG,\n+\t\t\t\t\t\t\t    DFmode),\n+\t\t\t\t\t       REG_NOTES (pop_insn));\n+   }\n \n   regstack->reg[regstack->top - (hard_regno - FIRST_STACK_REG)]\n     = regstack->reg[regstack->top];\n@@ -1757,10 +1764,18 @@ swap_rtx_condition (pat)\n /* Handle a comparison.  Special care needs to be taken to avoid\n    causing comparisons that a 387 cannot do correctly, such as EQ.\n \n-   Also, a pop insn may need to be emitted.  The 387 does have an\n+   Also, a fstp instruction may need to be emitted.  The 387 does have an\n    `fcompp' insn that can pop two regs, but it is sometimes too expensive\n    to do this - a `fcomp' followed by a `fstpl %st(0)' may be easier to\n-   set up.  */\n+   set up. \n+ \n+   We can not handle this by emiting fpop instruction after compare, because\n+   it appears between cc0 setter and user.  So we emit only\n+   REG_DEAD note and handle it as a special case in machine description.\n+ \n+   This code used trick with delay_slot filling to emit pop insn after\n+   comparsion but it didn't worked because it caused confusion with cc_status\n+   in final pass. */\n \n static void\n compare_for_stack_reg (insn, regstack, pat)\n@@ -1772,6 +1787,7 @@ compare_for_stack_reg (insn, regstack, pat)\n   rtx src1_note, src2_note;\n   rtx cc0_user;\n   int have_cmove; \n+  int hard_regno;\n \n   src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n   src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n@@ -1838,7 +1854,10 @@ compare_for_stack_reg (insn, regstack, pat)\n   replace_reg (src1, FIRST_STACK_REG);\n \n   if (STACK_REG_P (*src2))\n-    replace_reg (src2, get_hard_regnum (regstack, *src2));\n+    {\n+      hard_regno = get_hard_regnum (regstack, *src2);\n+      replace_reg (src2, hard_regno);\n+    }\n \n   if (src1_note)\n     {\n@@ -1867,16 +1886,11 @@ compare_for_stack_reg (insn, regstack, pat)\n \t}\n       else\n \t{\n-\t  /* The 386 can only represent death of the first operand in\n-\t     the case handled above.  In all other cases, emit a separate\n-\t     pop and remove the death note from here.  */\n-\n-\t  link_cc0_insns (insn);\n-\n-\t  remove_regno_note (insn, REG_DEAD, REGNO (XEXP (src2_note, 0)));\n+\t  /* Pop of second operand is handled using special REG_DEAD note\n+\t     because we can't emit pop insn after cc0 setter.  */\n \n-\t  emit_pop_insn (insn, regstack, XEXP (src2_note, 0),\n-\t\t\t emit_insn_after);\n+\t  emit_pop_insn (insn, regstack, XEXP (src2_note, 0), NULL);\n+\t  replace_reg (&XEXP (src2_note, 0), hard_regno);\n \t}\n     }\n }"}]}