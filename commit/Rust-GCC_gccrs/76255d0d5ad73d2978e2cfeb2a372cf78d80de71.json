{"sha": "76255d0d5ad73d2978e2cfeb2a372cf78d80de71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYyNTVkMGQ1YWQ3M2QyOTc4ZTJjZmViMmEzNzJjZjc4ZDgwZGU3MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-02-04T21:05:14Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-02-04T21:05:14Z"}, "message": "re PR target/69667 (ppc64le -mlra: ICE: Max. number of generated reload insns per insn is achieved (90))\n\n[gcc]\n2016-02-04  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/69667\n\t* config/rs6000/rs6000.md (mov<mode>_64bit_dm): Use 'd' constraint\n\tinstead of 'ws', and 'wh' instead of 'wm' since TFmode/IFmode are\n\tnot allowed into the traditional Altivec registers.\n\t(movtd_64bit_nodm): Likewise.\n\t(mov<mode>_32bit, FMOVE128_FPR iterator): Likewise.\n\n[gcc/testsuite]\n2016-02-04  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/69667\n\t* g++.dg/pr69667.C: New file.\n\nFrom-SVN: r233147", "tree": {"sha": "07d80db7ab8d2b3c01591736baf1fd685c94957d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07d80db7ab8d2b3c01591736baf1fd685c94957d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76255d0d5ad73d2978e2cfeb2a372cf78d80de71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76255d0d5ad73d2978e2cfeb2a372cf78d80de71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76255d0d5ad73d2978e2cfeb2a372cf78d80de71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/comments", "author": null, "committer": null, "parents": [{"sha": "0168b518a0b472973d35f10fa7d8c6636795503a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0168b518a0b472973d35f10fa7d8c6636795503a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0168b518a0b472973d35f10fa7d8c6636795503a"}], "stats": {"total": 127, "additions": 123, "deletions": 4}, "files": [{"sha": "f6f727fb7f7ce735e7b74e45f9691afd57ab9410", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76255d0d5ad73d2978e2cfeb2a372cf78d80de71", "patch": "@@ -1,3 +1,12 @@\n+2016-02-04  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/69667\n+\t* config/rs6000/rs6000.md (mov<mode>_64bit_dm): Use 'd' constraint\n+\tinstead of 'ws', and 'wh' instead of 'wm' since TFmode/IFmode are\n+\tnot allowed into the traditional Altivec registers.\n+\t(movtd_64bit_nodm): Likewise.\n+\t(mov<mode>_32bit, FMOVE128_FPR iterator): Likewise.\n+\n 2016-02-04  David Malcolm  <dmalcolm@redhat.com>\n \n \t* config/aarch64/cortex-a57-fma-steering.c"}, {"sha": "5614695c853de0029e29e046ff6f7ff06d8043ca", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=76255d0d5ad73d2978e2cfeb2a372cf78d80de71", "patch": "@@ -6738,8 +6738,8 @@\n ;; problematical.  Don't allow direct move for this case.\n \n (define_insn_and_split \"*mov<mode>_64bit_dm\"\n-  [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r,r,wm\")\n-\t(match_operand:FMOVE128_FPR 1 \"input_operand\" \"d,m,d,j,r,jY,r,wm,r\"))]\n+  [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,d,Y,r,r,r,wh\")\n+\t(match_operand:FMOVE128_FPR 1 \"input_operand\" \"d,m,d,j,r,jY,r,wh,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64\n    && FLOAT128_2REG_P (<MODE>mode)\n    && (<MODE>mode != TDmode || WORDS_BIG_ENDIAN)\n@@ -6752,7 +6752,7 @@\n   [(set_attr \"length\" \"8,8,8,8,12,12,8,8,8\")])\n \n (define_insn_and_split \"*movtd_64bit_nodm\"\n-  [(set (match_operand:TD 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r\")\n+  [(set (match_operand:TD 0 \"nonimmediate_operand\" \"=m,d,d,d,Y,r,r\")\n \t(match_operand:TD 1 \"input_operand\" \"d,m,d,j,r,jY,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_POWERPC64 && !WORDS_BIG_ENDIAN\n    && (gpc_reg_operand (operands[0], TDmode)\n@@ -6764,7 +6764,7 @@\n   [(set_attr \"length\" \"8,8,8,8,12,12,8\")])\n \n (define_insn_and_split \"*mov<mode>_32bit\"\n-  [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,ws,Y,r,r\")\n+  [(set (match_operand:FMOVE128_FPR 0 \"nonimmediate_operand\" \"=m,d,d,d,Y,r,r\")\n \t(match_operand:FMOVE128_FPR 1 \"input_operand\" \"d,m,d,j,r,jY,r\"))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && !TARGET_POWERPC64\n    && (FLOAT128_2REG_P (<MODE>mode)"}, {"sha": "5d6bec01d651da77c1ed0076a264b47290eded76", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76255d0d5ad73d2978e2cfeb2a372cf78d80de71", "patch": "@@ -1,3 +1,8 @@\n+2016-02-04  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/69667\n+\t* g++.dg/pr69667.C: New file.\n+\n 2016-02-04  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \tPR target/69619"}, {"sha": "df445629bf10c049d7792839627fb649aade85cc", "filename": "gcc/testsuite/g++.dg/pr69667.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69667.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76255d0d5ad73d2978e2cfeb2a372cf78d80de71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69667.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr69667.C?ref=76255d0d5ad73d2978e2cfeb2a372cf78d80de71", "patch": "@@ -0,0 +1,105 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n+/* { dg-options \"-mcpu=power8 -w -std=c++14 -mlra\" } */\n+\n+/* target/69667, compiler got\n+   internal compiler error: Max. number of generated reload insns per insn is achieved (90)  */\n+\n+struct A {\n+  typedef int evaluation_error_type;\n+};\n+template <class T, class> T get_epsilon();\n+template <class E> __attribute__((__noreturn__)) void throw_exception(E);\n+template <class Formatter, class Group> char do_format(Formatter, Group &);\n+int raise_error_e, non_central_beta_p_k;\n+template <class, class T> void raise_error(T &p1) {\n+  char msg = do_format(msg, p1);\n+  throw_exception(raise_error_e);\n+}\n+char raise_evaluation_error_function;\n+template <class T1, class T2, class Policy>\n+T1 gamma_p_derivative(T1, T2, Policy);\n+template <class T, class Policy> T ibeta_imp(Policy, bool, T *);\n+template <class> struct B {};\n+template <class Dist, class RealType> B<Dist> complement(Dist, RealType);\n+template <class, class> class C;\n+template <class T, class Policy> struct D {\n+  D(C<T, Policy> p1, T, bool) : dist(p1) {}\n+  void operator()(T p1) { comp ? cdf(complement(dist, p1)) : T(); }\n+  C<T, Policy> dist;\n+  bool comp;\n+};\n+template <class, class = A> class C {\n+public:\n+  C(int, int, int);\n+};\n+template <class RealType, class Policy> void quantile(Policy p1, RealType) {\n+  nc_beta_quantile(p1, false);\n+}\n+double quantile_sanity_check___trans_tmp_1, quantile_sanity_check___trans_tmp_3,\n+    quantile_sanity_check___trans_tmp_5, quantile_sanity_check___trans_tmp_7;\n+void Trans_NS_detail_raise_evaluation_error(char *, char *, long double &p3,\n+                                            int) {\n+  raise_error<int>(p3);\n+}\n+template <class T, class Policy>\n+void raise_evaluation_error(char *, T &p2, Policy) {\n+  Trans_NS_detail_raise_evaluation_error(\n+      &raise_evaluation_error_function, \"\", p2,\n+      typename Policy::evaluation_error_type());\n+}\n+template <class T, class Policy>\n+T non_central_beta_p(T p1, T p2, T p3, Policy p4, T p5 = 0) {\n+  T y, errtol = get_epsilon<T, Policy>(), l2,\n+       pois = gamma_p_derivative(T(), l2, p4), xterm, last_term = 0;\n+  if (pois)\n+    return p5;\n+  T beta = y ? ibeta_imp(p4, false, &xterm) : ibeta_imp(p4, true, &xterm);\n+  xterm = y - 1;\n+  T sum = p5;\n+  if (beta && xterm)\n+    return p5;\n+  for (; non_central_beta_p_k;) {\n+    sum += beta;\n+    if (errtol && last_term || beta)\n+      break;\n+    xterm *=\n+        p1 + non_central_beta_p_k - 1 / p3 * p1 + p2 + non_central_beta_p_k - 2;\n+    last_term = beta;\n+  }\n+  raise_evaluation_error(\"\", sum, p4);\n+}\n+template <class RealType, class Policy>\n+RealType non_central_beta_cdf(RealType, bool, Policy) {\n+  RealType b, a, x;\n+  non_central_beta_p(a, b, x, A());\n+}\n+template <class F, class T, class Tol, class Policy>\n+int bracket_and_solve_root_01(F p1, T, bool, Tol, unsigned, Policy) {\n+  T guess;\n+  p1(guess);\n+}\n+template <class RealType, class Policy>\n+void nc_beta_quantile(C<RealType, Policy>, bool p2) {\n+  RealType p;\n+  typedef RealType value_type;\n+  D<value_type, Policy> f(C<value_type, Policy>(0, 0, 0), p, p2);\n+  void tol();\n+  long max_iter =\n+      bracket_and_solve_root_01(f, value_type(), true, tol, max_iter, Policy());\n+}\n+template <class RealType, class Policy> RealType cdf(B<C<RealType, Policy>>) {\n+  RealType l = non_central_beta_cdf(l, true, Policy());\n+}\n+template <typename T> void quantile_sanity_check(T) {\n+  quantile(C<long double>(quantile_sanity_check___trans_tmp_1,\n+                          quantile_sanity_check___trans_tmp_3,\n+                          quantile_sanity_check___trans_tmp_5),\n+           quantile_sanity_check___trans_tmp_7);\n+}\n+void test_accuracy() {\n+  int ncbeta;\n+  quantile_sanity_check(ncbeta);\n+}"}]}