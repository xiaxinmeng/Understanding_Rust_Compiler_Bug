{"sha": "a2ea9f7e7027a9945744f5f7c126a0618a30c334", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJlYTlmN2U3MDI3YTk5NDU3NDRmNWY3YzEyNmEwNjE4YTMwYzMzNA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-27T14:51:23Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-27T14:51:23Z"}, "message": "Original rust code from 2014/2015", "tree": {"sha": "74fa49a9a53e564258471c1b76b3967b32647cb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74fa49a9a53e564258471c1b76b3967b32647cb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2ea9f7e7027a9945744f5f7c126a0618a30c334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ea9f7e7027a9945744f5f7c126a0618a30c334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2ea9f7e7027a9945744f5f7c126a0618a30c334", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2ea9f7e7027a9945744f5f7c126a0618a30c334/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8ae0812ee567fa380f0a8c7f30c7a660a5069c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ae0812ee567fa380f0a8c7f30c7a660a5069c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ae0812ee567fa380f0a8c7f30c7a660a5069c3"}], "stats": {"total": 278342, "additions": 278342, "deletions": 0}, "files": [{"sha": "5abdb40b57278b04fda02f82df0483455e8d330e", "filename": "gcc/rust/Make-lang.in", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,227 @@\n+# Make-lang.in -- Top level -*- makefile -*- fragment for gcc Go frontend.\n+\n+# Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# This file provides the language dependent support in the main Makefile.\n+\n+# Installation name.\n+\n+GCCRUST_INSTALL_NAME := $(shell echo gccrust|sed '$(program_transform_name)')\n+GCCRUST_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gccrust|sed '$(program_transform_name)')\n+\n+# The name for selecting rust in LANGUAGES.\n+rust: rust1$(exeext)\n+\n+.PHONY: rust\n+\n+CFLAGS-rust/rustspec.o += $(DRIVER_DEFINES)\n+\n+GCCRUST_OBJS = $(GCC_OBJS) rust/rustspec.o\n+gccrust$(exeext): $(GCCRUST_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a $(LIBDEPS)\n+\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t  $(GCCRUST_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \\\n+\t  $(EXTRA_GCC_LIBS) $(LIBS)\n+\n+# The cross-compiler version.  This is built mainly as a signal to the\n+# rust.install-common target.  If this executable exists, it means that\n+# rust.all.cross was run.\n+gccrust-cross$(exeext): gccrust$(exeext)\n+\t-rm -f gccrust-cross$(exeext)\n+\tcp gccrust$(exeext) gccrust-cross$(exeext)\n+\n+# Use strict warnings.\n+rust-warn = $(STRICT_WARN)\n+\n+RUST_OBJS = \\\n+\trust/rust-lang.o \\\n+\trust/rust-backend.o \\\n+\trust/rust-linemap.o \\\n+\trust/rust-gcc-diagnostics.o \\\n+\trust/main.o\n+\n+rust_OBJS = $(RUST_OBJS) rust/rustspec.o\n+\n+rust1$(exeext): $(RUST_OBJS) attribs.o $(BACKEND) $(LIBDEPS)\n+\t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t      $(RUST_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n+\n+# Documentation.\n+\n+RUST_TEXI_FILES = \\\n+\trust/gccrust.texi \\\n+\t$(gcc_docdir)/include/fdl.texi \\\n+\t$(gcc_docdir)/include/gpl_v3.texi \\\n+\t$(gcc_docdir)/include/gcc-common.texi \\\n+\tgcc-vers.texi\n+\n+doc/gccrust.info: $(RUST_TEXI_FILES)\n+\tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n+\t  rm -f doc/gccrust.info*; \\\n+\t  $(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \\\n+\t\t-I $(gcc_docdir)/include -o $@ $<; \\\n+\telse true; fi\n+\n+doc/gccrust.dvi: $(RUST_TEXI_FILES)\n+\t$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+\n+doc/gccrust.pdf: $(RUST_TEXI_FILES)\n+\t$(TEXI2PDF) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+\n+$(build_htmldir)/rust/index.html: $(RUST_TEXI_FILES)\n+\t$(mkinstalldirs) $(@D)\n+\trm -f $(@D)/*\n+\t$(TEXI2HTML) -I $(gcc_docdir) -I $(gcc_docdir)/include \\\n+\t\t-I $(srcdir)/rust -o $(@D) $<\n+\n+.INTERMEDIATE: gccrust.pod\n+\n+gccrust.pod: rust/gccrust.texi\n+\t-$(TEXI2POD) -D gccrust < $< > $@\n+\n+# Build hooks.\n+\n+rust.all.cross: gccrust-cross$(exeext)\n+rust.start.encap: gccrust$(exeext)\n+rust.rest.encap:\n+rust.info: doc/gccrust.info\n+rust.dvi: doc/gccrust.dvi\n+rust.pdf: doc/gccrust.pdf\n+rust.html: $(build_htmldir)/rust/index.html\n+rust.srcinfo: doc/gccrust.info\n+\t-cp -p $^ $(srcdir)/doc\n+rust.srcextra:\n+rust.tags: force\n+\tcd $(srcdir)/rust; \\\n+\tetags -o TAGS.sub *.c *.h rustfrontend/*.h rustfrontend/*.cc; \\\n+\tetags --include TAGS.sub --include ../TAGS.sub\n+rust.man: doc/gccrust.1\n+rust.srcman: doc/gccrust.1\n+\t-cp -p $^ $(srcdir)/doc\n+\n+lang_checks += check-rust\n+lang_checks_parallelized += check-rust\n+check_rust_parallelize = 10\n+\n+# No rust-specific selftests\n+selftest-rust:\n+\n+# Install hooks.\n+\n+# Install hooks.\n+\n+# Install everything that is part of the front end, apart from the compiler executables listed in \n+# compilers in config-lang.in. \n+rust.install-common: installdirs\n+\t-rm -f $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n+\t$(INSTALL_PROGRAM) gccrust$(exeext) $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n+\t-if test -f rust1$(exeext); then \\\n+\t  if test -f gccrust-cross$(exeext); then \\\n+\t    :; \\\n+\t  else \\\n+\t    rm -f $(DESTDIR)$(bindir)/$(GCCRUST_TARGET_INSTALL_NAME)$(exeext); \\\n+\t    ( cd $(DESTDIR)$(bindir) && \\\n+\t      $(LN) $(GCCRUST_INSTALL_NAME)$(exeext) $(GCCRUST_TARGET_INSTALL_NAME)$(exeext) ); \\\n+\t  fi; \\\n+\tfi\n+\n+# Install headers needed for plugins. \n+rust.install-plugin:\n+\n+rust.install-info: $(DESTDIR)$(infodir)/gccrust.info\n+\n+rust.install-pdf: doc/gccrust.pdf\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n+\t@for p in doc/gccrust.pdf; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(pdf__strip_dir) \\\n+\t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n+\t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n+\tdone\n+\n+rust.install-html: $(build_htmldir)/rust\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n+\t@for p in $(build_htmldir)/rust; do \\\n+\t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; fi; \\\n+\t  f=$(html__strip_dir) \\\n+\t  if test -d \"$$d$$p\"; then \\\n+\t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\t  else \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\t  fi; \\\n+\tdone\n+\n+rust.install-man: $(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext)\n+\n+$(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext): doc/gccrust.1 installdirs\n+\t-rm -f $@\n+\t-$(INSTALL_DATA) $< $@\n+\t-chmod a-x $@\n+\n+rust.uninstall:\n+\trm -rf $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n+\trm -rf $(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext)\n+\trm -rf $(DESTDIR)$(bindir)/$(GCCRUST_TARGET_INSTALL_NAME)$(exeext)\n+\trm -rf $(DESTDIR)$(infodir)/gccrust.info*\n+\n+# Clean hooks.\n+\n+rust.mostlyclean:\n+\t-rm -f rust/*$(objext)\n+\t-rm -f rust/*$(coverageexts)\n+\t-rm -f gccrust$(exeext) gccrust-cross$(exeext) rust1$(exeext)\n+rust.clean:\n+rust.distclean:\n+rust.maintainer-clean:\n+\t-rm -f $(docobjdir)/gccrust.1\n+\n+# Stage hooks.\n+\n+rust.stage1: stage1-start\n+\t-mv rust/*$(objext) stage1/rust\n+rust.stage2: stage2-start\n+\t-mv rust/*$(objext) stage2/rust\n+rust.stage3: stage3-start\n+\t-mv rust/*$(objext) stage3/rust\n+rust.stage4: stage4-start\n+\t-mv rust/*$(objext) stage4/rust\n+rust.stageprofile: stageprofile-start\n+\t-mv rust/*$(objext) stageprofile/rust\n+rust.stagefeedback: stagefeedback-start\n+\t-mv rust/*$(objext) stagefeedback/rust\n+\n+CFLAGS-rust/rust-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n+\t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n+\n+RUSTINCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/rustfrontend\n+\n+CFLAGS-rust/rust-gcc.o += $(RUSTINCLUDES)\n+CFLAGS-rust/rust-linemap.o += $(RUSTINCLUDES)\n+CFLAGS-rust/rust-sha1.o += $(RUSTINCLUDES)\n+CFLAGS-rust/rust-gcc-diagnostics.o += $(RUSTINCLUDES)\n+CFLAGS-rust/rust-encode-id.o += $(RUSTINCLUDES)\n+\n+rust/%.o: rust/rustfrontend/%.cc\n+\t$(COMPILE) $(RUSTINCLUDES) $<\n+\t$(POSTCOMPILE)"}, {"sha": "2e290285e96a88a2950f4da3cc41e479676ca47f", "filename": "gcc/rust/TO_notes.txt", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2FTO_notes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2FTO_notes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FTO_notes.txt?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,48 @@\n+TO notes:\n+\n+This is the actual compiler frontend.\n+\n+What needs to occur in a frontend according to GCC docs:\n+\n+Parsing pass:\n+-Language frontend is only invoked once via lang_hooks.parse_file (which parses any input)\n+-Frontend may use any intermediate language representation deemed appropriate (i.e. could use MIR like in actual Rust, but GENERIC trees would probably be used)\n+-At some point, the frontend must translate the intermediate language representation used inside it to a representation understood by the rest of the compiler (GIMPLE or maybe GENERIC). There are two current ways of doing this:\n+\t-C frontend manually invokes gimplifier on each function, and uses gimplifier callbacks to convert language-specific tree nodes directly to GIMPLE before passing function off to be compiled. \n+\t-Fortran frontend converts from private representation to GENERIC, which is later lowered to GIMPLE when the function is compiled.\n+\t-Also, a front end could generate GIMPLE directly, which is a \"moderately complex process\" but would maybe mean that more of the Rust LLVM frontend could be used without modification.\n+\t-Which route to choose depends on how well GENERIC (plus extensions) can be made to match up with the source language and necessary parsing data structures. The easiest seems to be the Fortran method, i.e. just make GENERIC. \n+-Note that each function (and top level declaration) must be passed separately to the middle end or something. Function and data definitions must be passed to the middle-end, and for debug info, data and type declarations should also be passed.\n+-Front end needs complete top-level function or data declaration, and each data definition should be passed to rest_of_decl_compilation . Each complete type definition should be passed to rest_of_type_compilation . Each function definition should be passed to cgraph_finalize_function .\n+-Middle-end will either emit the function and data definitions immediately or queue them for later processing.\n+\n+Gimplification pass:\n+-Consists of conversion of frontend's intermediate representation to GIMPLE\n+-Main entry point is gimplify_function_tree in gimplify.c . From here, the entire function is processed, gimplifying each statement in turn. Main workhorse for this pass is gimplify_expr . Approximately everything passes through here at least once, and it is from here that we invoke lang_hooks.gimplify_expr callback.\n+-Callback should examine the expression and return GS_UNHANDLED if the expression is not a language-specific construct that requires attention. Otherwise it should alter the expression in some way to progress towards it being valid GIMPLE. If callback is certain that transformation is complete and expression is valid GIMPLE, should return GS_ALL_DONE . Otherwise, return GS_OK , which causes expression to be processed again. If callback encounters error during transformation (because frontend relies on gimplification to finish semantic checks), return GS_ERROR .\n+\n+Pass manager:\n+-Pass manager is located in passes.c, tree-optimize.c, and tree-pass.h . It processes passes as defined in passes.def . It runs all passes in correct order. etc. more stuff\n+\n+After this, the AST should be built in GIMPLE or whatever, so the middle-end and back-end of GCC take care of the rest of compilation, I hope. \n+\n+\n+\n+Notes on GENERIC:\n+-A language-independent way of representing an entire _function_ in trees. If you can express it with gcc/tree.def, it's GENERIC.\n+-A statement is defined as an expression whose value, if any, is ignored. A statement will always have TREE_SIDE_EFFECTS set, but a non-statement expression may also have side effects, e.g. CALL_EXPR (probably a function call).\n+-Implication that frontends lower GENERIC to GIMPLE.\n+\n+Trees:\n+-The central data structure, tree, is a node of C type tree. It is a pointer type, but the object it points to may be a variety of types.\n+-Can tell what kind of a node a tree is by using TREE_CODE macro. Many macros take trees as input and return trees as output. Most require a certain kind of tree node as input, i.e. there is a particular type system for trees not reflected in C's type system.\n+-For safety, useful to configure GCC with --enable-checking . All tree types are checked at runtime as a result, destroying performance but aiding debugging.\n+-Many macros behave as predicates (a function used to test something about a supplied argument - e.g. lambda expression LINQ), and many, though not all, of these end in _P . Don't rely on result type of macros being of any particular type, but may rely on fact that type can be compared to 0, so statements like \"int i = (TEST_P(t) != 0);\" are legal. Macros that return int values now may be changed to return tree values, or other pointers in the future. Thus, should not write code like \"if (TEST_P(t) == 1)\".\n+-\n+\n+\n+\n+Notes on basic outline:\n+-rustc and mrustc appear to use a hand-written recursive-descent parser, not a bison-generated LALR parser.\n+-I don't know if redbrain's original parser was bison LALR or handwritten recursive-descent - it seemed to have aspects of both. However, he mentioned using a bison-generated parser initially and then moving to a handwritten one later.\n+-As such, own parser should probably be hand-written recursive-descent.\n\\ No newline at end of file"}, {"sha": "c023de0b4e746784120451b0630ff3e8b70e8b83", "filename": "gcc/rust/config-lang.in", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fconfig-lang.in?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,48 @@\n+# config-lang.in -- Top level configure fragment for gcc Go frontend.\n+\n+# Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Configure looks for the existence of this file to auto-config each language.\n+# We define several parameters used by configure:\n+#\n+# language\t- name of language as it would appear in $(LANGUAGES)\n+# compilers\t- value to add to $(COMPILERS)\n+# diff_excludes\t- files to ignore when building diffs between two versions.\n+\n+language=\"rust\"\n+\n+# Space-separated list of compiler executables that will be run by the driver. The names here will \n+# each end with \u2018\\$(exeext)\u2019. \n+compilers=\"rust1\\$(exeext)\"\n+\n+# Do not build by default.\n+build_by_default=\"no\"\n+\n+# Lists (space-separated) language front ends other than C that this front end requires to be\n+# enabled (with the names given being their language settings). \n+#lang_requires_boot_languages=c++\n+\n+# Lists (space-separated) targets in the top level Makefile to build the runtime libraries \n+# for this language, such as target-libobjc. \n+target_libs=\"target-libffi target-libbacktrace\"\n+\n+# Space-separated list of files that should be scanned by gengtype.c to generate the garbage \n+# collection tables and routines for this language. This excludes the files that are common to all \n+# front ends. \n+gtfiles=\"\\$(srcdir)/rust/rust-lang.c \\$(srcdir)/rust/rust-c.h\""}, {"sha": "9b4a3ec0f326529e43cbd076b813d3286d14e380", "filename": "gcc/rust/lang-specs.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang-specs.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,31 @@\n+/* lang-specs.h -- gcc driver specs for Rust frontend.\n+   Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+// describes Rust front-end to GCC driver\n+\n+/* tells GCC to invoke Rust frontend on .rs files, gives instructions on \n+   other programs to be run, such as assembler, etc. \n+   In this, it has grs1 as the actual compiler and whatever */\n+/* This is the contribution to the `default_compilers' array in gcc.c\n+   for the Rust language.  */\n+{\".rs\",  \"@rs\", 0, 1, 0},\n+{\"@rs\",  \"rust1 %i %(cc1_options) %{I*} %{L*} %D %{!fsyntax-only:%(invoke_as)}\",\n+    0, 1, 0},\n+\n+// \"May take a while\" to write this file - refer to other language lang-specs.h\n\\ No newline at end of file"}, {"sha": "7e67bdaaa53914cb5b24f5cc704da3191fc281fc", "filename": "gcc/rust/lang.opt", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang.opt?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,42 @@\n+; Options for the Rust front end.\n+; Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013\n+; Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+; \n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+; \n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+; See the GCC internals manual for a description of this file's format.\n+\n+; Please try to keep this file in ASCII collating order.\n+\n+; Describes command-line options used by this frontend\n+\n+Language\n+Rust\n+\n+I\n+Rust Joined Separate\n+; Documented in c.opt\n+\n+L\n+Rust Joined Separate\n+; Not documented\n+\n+o\n+Rust Joined Separate\n+; Documented in common.opt\n+\n+; This comment is to ensure we retain the blank line above."}, {"sha": "e4fe49daea2c8a8dd1d2d8537864c6a1d2d6f2cf", "filename": "gcc/rust/mrustc_parser/ast/ast.cpp", "status": "added", "additions": 440, "deletions": 0, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,440 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/ast.cpp\n+ * - Implementation of the various AST classes\n+ */\n+#include \"ast.hpp\"\n+#include \"crate.hpp\"\n+#include \"types.hpp\"\n+#include \"expr.hpp\"\n+#include \"../common.hpp\"\n+#include <iostream>\n+#include \"../parse/parseerror.hpp\"\n+#include <algorithm>\n+\n+namespace AST {\n+\n+\n+namespace {\n+    ::std::vector<Attribute> clone_mivec(const ::std::vector<Attribute>& v) {\n+        ::std::vector<Attribute>    ri;\n+        ri.reserve(v.size());\n+        for(const auto& i : v)\n+            ri.push_back( i.clone() );\n+        return ri;\n+    }\n+}\n+\n+AttributeList AttributeList::clone() const\n+{\n+    return AttributeList( clone_mivec(m_items) );\n+}\n+\n+void AttributeList::push_back(Attribute i)\n+{\n+    m_items.push_back( ::std::move(i) );\n+}\n+const Attribute* AttributeList::get(const char *name) const\n+{\n+    for( auto& i : m_items ) {\n+        if(i.name() == name) {\n+            //i.mark_used();\n+            return &i;\n+        }\n+    }\n+    return 0;\n+}\n+\n+Attribute Attribute::clone() const\n+{\n+    TU_MATCHA( (m_data), (e),\n+    (None,\n+        return Attribute(m_span, m_name);\n+        ),\n+    (String,\n+        return Attribute(m_span, m_name, e.val);\n+        ),\n+    (List,\n+        return Attribute(m_span, m_name, clone_mivec(e.sub_items));\n+        )\n+    )\n+    throw ::std::runtime_error(\"Attribute::clone - Fell off end\");\n+}\n+\n+StructItem StructItem::clone() const\n+{\n+    return StructItem(m_attrs.clone(), m_is_public, m_name, m_type.clone());\n+}\n+TupleItem TupleItem::clone() const\n+{\n+    return TupleItem(m_attrs.clone(), m_is_public, m_type.clone());\n+}\n+\n+\n+TypeAlias TypeAlias::clone() const\n+{\n+    return TypeAlias( m_params.clone(), m_type.clone() );\n+}\n+Static Static::clone() const\n+{\n+    return Static( m_class, m_type.clone(), m_value.is_valid() ? AST::Expr( m_value.node().clone() ) : AST::Expr() );\n+}\n+\n+Function::Function(Span sp, GenericParams params, ::std::string abi, bool is_unsafe, bool is_const, bool is_variadic, TypeRef ret_type, Arglist args):\n+    m_span(sp),\n+    m_params( move(params) ),\n+    m_rettype( move(ret_type) ),\n+    m_args( move(args) ),\n+    m_abi( mv$(abi) ),\n+    m_is_const(is_const),\n+    m_is_unsafe(is_unsafe),\n+    m_is_variadic(is_variadic)\n+{\n+}\n+Function Function::clone() const\n+{\n+    decltype(m_args)    new_args;\n+    for(const auto& arg : m_args)\n+        new_args.push_back( ::std::make_pair( arg.first.clone(), arg.second.clone() ) );\n+\n+    auto rv = Function( m_span, m_params.clone(), m_abi, m_is_unsafe, m_is_const, m_is_variadic, m_rettype.clone(), mv$(new_args) );\n+    if( m_code.is_valid() )\n+    {\n+        rv.m_code = AST::Expr( m_code.node().clone() );\n+    }\n+    return rv;\n+}\n+\n+void Trait::add_type(::std::string name, AttributeList attrs, TypeRef type) {\n+    m_items.push_back( Named<Item>(mv$(name), Item::make_Type({TypeAlias(GenericParams(), mv$(type))}), true) );\n+    m_items.back().data.attrs = mv$(attrs);\n+}\n+void Trait::add_function(::std::string name, AttributeList attrs, Function fcn) {\n+    DEBUG(\"trait fn \" << name);\n+    m_items.push_back( Named<Item>(mv$(name), Item::make_Function({mv$(fcn)}), true) );\n+    m_items.back().data.attrs = mv$(attrs);\n+}\n+void Trait::add_static(::std::string name, AttributeList attrs, Static v) {\n+    m_items.push_back( Named<Item>(mv$(name), Item::make_Static({mv$(v)}), true) );\n+    m_items.back().data.attrs = mv$(attrs);\n+}\n+void Trait::set_is_marker() {\n+    m_is_marker = true;\n+}\n+bool Trait::is_marker() const {\n+    return m_is_marker;\n+}\n+bool Trait::has_named_item(const ::std::string& name, bool& out_is_fcn) const\n+{\n+    for( const auto& i : m_items )\n+    {\n+        if( i.name == name ) {\n+            out_is_fcn = i.data.is_Function();\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+Trait Trait::clone() const\n+{\n+    auto rv = Trait(m_params.clone(), m_supertraits);\n+    for(const auto& item : m_items)\n+    {\n+        rv.m_items.push_back( Named<Item> { item.name, item.data.clone(), item.is_pub } );\n+    }\n+    return rv;\n+}\n+\n+Enum Enum::clone() const\n+{\n+    decltype(m_variants)    new_variants;\n+    for(const auto& var : m_variants)\n+    {\n+        TU_MATCHA( (var.m_data), (e),\n+        (Value,\n+            new_variants.push_back( EnumVariant(var.m_attrs.clone(), var.m_name, e.m_value.clone()) );\n+            ),\n+        (Tuple,\n+            decltype(e.m_sub_types) new_st;\n+            for(const auto& f : e.m_sub_types)\n+                new_st.push_back( f.clone() );\n+            new_variants.push_back( EnumVariant(var.m_attrs.clone(), var.m_name, mv$(new_st)) );\n+            ),\n+        (Struct,\n+            decltype(e.m_fields)    new_fields;\n+            for(const auto& f : e.m_fields)\n+                new_fields.push_back( f.clone() );\n+            new_variants.push_back( EnumVariant(var.m_attrs.clone(), var.m_name, mv$(new_fields)) );\n+            )\n+        )\n+    }\n+    return Enum(m_params.clone(), mv$(new_variants));\n+}\n+Struct Struct::clone() const\n+{\n+    TU_MATCHA( (m_data), (e),\n+    (Unit,\n+        return Struct(m_params.clone());\n+        ),\n+    (Tuple,\n+        decltype(e.ents)    new_fields;\n+        for(const auto& f : e.ents)\n+            new_fields.push_back( f.clone() );\n+        return Struct(m_params.clone(), mv$(new_fields));\n+        ),\n+    (Struct,\n+        decltype(e.ents)    new_fields;\n+        for(const auto& f : e.ents)\n+            new_fields.push_back( f.clone() );\n+        return Struct(m_params.clone(), mv$(new_fields));\n+        )\n+    )\n+    throw \"\";\n+}\n+\n+Union Union::clone() const\n+{\n+    decltype(m_variants)    new_vars;\n+    for(const auto& f : m_variants)\n+        new_vars.push_back( f.clone() );\n+    return Union(m_params.clone(), mv$(new_vars));\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const ImplDef& impl)\n+{\n+    return os << \"impl<\" << impl.m_params << \"> \" << impl.m_trait.ent << \" for \" << impl.m_type << \"\";\n+}\n+\n+void Impl::add_function(bool is_public, bool is_specialisable, ::std::string name, Function fcn)\n+{\n+    DEBUG(\"impl fn \" << name);\n+    m_items.push_back( ImplItem { is_public, is_specialisable, mv$(name), box$( Item::make_Function(mv$(fcn)) ) } );\n+}\n+void Impl::add_type(bool is_public, bool is_specialisable, ::std::string name, TypeRef type)\n+{\n+    m_items.push_back( ImplItem { is_public, is_specialisable, mv$(name), box$( Item::make_Type(TypeAlias(GenericParams(), mv$(type))) ) } );\n+}\n+void Impl::add_static(bool is_public, bool is_specialisable, ::std::string name, Static v)\n+{\n+    m_items.push_back( ImplItem { is_public, is_specialisable, mv$(name), box$( Item::make_Static(mv$(v)) ) } );\n+}\n+void Impl::add_macro_invocation(MacroInvocation item) {\n+    m_items.push_back( ImplItem { false, false, \"\", box$( Item::make_MacroInv(mv$(item)) ) } );\n+}\n+\n+bool Impl::has_named_item(const ::std::string& name) const\n+{\n+    for( const auto& it : this->items() )\n+    {\n+        if( it.name == name ) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const Impl& impl)\n+{\n+    return os << impl.m_def;\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const UseStmt& x)\n+{\n+    os << \"Use(\" << x.path << \")\";\n+    return os;\n+}\n+\n+\n+\n+MacroInvocation MacroInvocation::clone() const\n+{\n+    return MacroInvocation(m_span, m_macro_name, m_ident, m_input.clone());\n+}\n+\n+\n+UseStmt UseStmt::clone() const\n+{\n+    return UseStmt(sp, path);\n+}\n+\n+void ExternBlock::add_item(Named<Item> named_item)\n+{\n+    ASSERT_BUG(named_item.data.span, named_item.data.is_Function() || named_item.data.is_Static(), \"Incorrect item type for ExternBlock\");\n+    m_items.push_back( mv$(named_item) );\n+}\n+ExternBlock ExternBlock::clone() const\n+{\n+    TODO(Span(), \"Clone an extern block\");\n+}\n+\n+::std::shared_ptr<AST::Module> Module::add_anon() {\n+    auto rv = ::std::shared_ptr<AST::Module>( new Module(m_my_path + FMT(\"#\" << m_anon_modules.size())) );\n+    DEBUG(\"New anon \" << rv->m_my_path);\n+    rv->m_file_info = m_file_info;\n+\n+    m_anon_modules.push_back( rv );\n+\n+    return rv;\n+}\n+\n+void Module::add_item( Named<Item> named_item ) {\n+    m_items.push_back( mv$(named_item) );\n+    const auto& i = m_items.back();\n+    if( i.name == \"\" ) {\n+    }\n+    else {\n+        DEBUG(m_my_path << \"::\" << i.name << \" = \" << i.data.tag_str() << \", attrs = \" << i.data.attrs);\n+    }\n+}\n+void Module::add_item(bool is_pub, ::std::string name, Item it, AttributeList attrs) {\n+    it.attrs = mv$(attrs);\n+    add_item( Named<Item>( mv$(name), mv$(it), is_pub ) );\n+}\n+void Module::add_ext_crate(bool is_public, ::std::string ext_name, ::std::string imp_name, AttributeList attrs) {\n+    this->add_item( is_public, imp_name, Item::make_Crate({mv$(ext_name)}), mv$(attrs) );\n+}\n+void Module::add_alias(bool is_public, UseStmt us, ::std::string name, AttributeList attrs) {\n+    this->add_item( is_public, mv$(name), Item(mv$(us)), mv$(attrs) );\n+}\n+void Module::add_macro_invocation(MacroInvocation item) {\n+    this->add_item( false, \"\", Item( mv$(item) ), ::AST::AttributeList {} );\n+}\n+void Module::add_macro(bool is_exported, ::std::string name, MacroRulesPtr macro) {\n+    m_macros.push_back( Named<MacroRulesPtr>( mv$(name), mv$(macro), is_exported ) );\n+}\n+void Module::add_macro_import(::std::string name, const MacroRules& mr) {\n+    m_macro_import_res.push_back( Named<const MacroRules*>( mv$(name), &mr, false ) );\n+}\n+\n+Item Item::clone() const\n+{\n+    TU_MATCHA( (*this), (e),\n+    (None,\n+        return AST::Item(e);\n+        ),\n+    (MacroInv,\n+        TODO(this->span, \"Clone on Item::MacroInv\");\n+        ),\n+    (Use,\n+        return AST::Item(e.clone());\n+        ),\n+    (ExternBlock,\n+        TODO(this->span, \"Clone on Item::\" << this->tag_str());\n+        ),\n+    (Impl,\n+        TODO(this->span, \"Clone on Item::Impl\");\n+        ),\n+    (NegImpl,\n+        TODO(this->span, \"Clone on Item::NegImpl\");\n+        ),\n+    (Module,\n+        TODO(this->span, \"Clone on Item::Module\");\n+        ),\n+    (Crate,\n+        return AST::Item(e);\n+        ),\n+    (Type,\n+        return AST::Item(e.clone());\n+        ),\n+    (Struct,\n+        return AST::Item(e.clone());\n+        ),\n+    (Enum,\n+        return AST::Item(e.clone());\n+        ),\n+    (Union,\n+        return AST::Item(e.clone());\n+        ),\n+    (Trait,\n+        return AST::Item(e.clone());\n+        ),\n+\n+    (Function,\n+        return AST::Item(e.clone());\n+        ),\n+    (Static,\n+        return AST::Item(e.clone());\n+        )\n+    )\n+    throw \"\";\n+}\n+\n+\n+\n+::std::ostream& operator<<(::std::ostream& os, const TypeParam& tp)\n+{\n+    //os << \"TypeParam(\";\n+    os << tp.m_name;\n+    os << \" = \";\n+    os << tp.m_default;\n+    //os << \")\";\n+    return os;\n+}\n+::std::ostream& operator<<(::std::ostream& os, const LifetimeParam& p)\n+{\n+    os << \"'\" << p.m_name;\n+    return os;\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const HigherRankedBounds& x)\n+{\n+    if( x.m_lifetimes.empty() ) {\n+        return os;\n+    }\n+    os << \"for<\";\n+    for(const auto& l : x.m_lifetimes)\n+        os << \"'\" << l << \",\";\n+    os << \"> \";\n+    return os;\n+}\n+\n+\n+::std::ostream& operator<<(::std::ostream& os, const GenericBound& x)\n+{\n+    TU_MATCH(GenericBound, (x), (ent),\n+    (None,\n+        os << \"/*-*/\";\n+        ),\n+    (Lifetime,\n+        os << \"'\" << ent.test << \": '\" << ent.bound;\n+        ),\n+    (TypeLifetime,\n+        os << ent.type << \": '\" << ent.bound;\n+        ),\n+    (IsTrait,\n+        os << ent.outer_hrbs << ent.type << \": \" << ent.inner_hrbs << ent.trait;\n+        ),\n+    (MaybeTrait,\n+        os << ent.type << \": ?\" << ent.trait;\n+        ),\n+    (NotTrait,\n+        os << ent.type << \": !\" << ent.trait;\n+        ),\n+    (Equality,\n+        os << ent.type << \" = \" << ent.replacement;\n+        )\n+    )\n+    return os;\n+}\n+\n+\n+int GenericParams::find_name(const char* name) const\n+{\n+    for( unsigned int i = 0; i < m_type_params.size(); i ++ )\n+    {\n+        if( m_type_params[i].name() == name )\n+            return i;\n+    }\n+    DEBUG(\"Type param '\" << name << \"' not in list\");\n+    return -1;\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const GenericParams& tps)\n+{\n+    return os << \"<\" << tps.m_lifetime_params << \",\" << tps.m_type_params << \"> where {\" << tps.m_bounds << \"}\";\n+}\n+\n+}    // namespace AST"}, {"sha": "0a43cc713bf83f734810dd40bc190225da05d257", "filename": "gcc/rust/mrustc_parser/ast/ast.hpp", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,638 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/ast.hpp\n+ * - Core AST header\n+ */\n+#ifndef AST_HPP_INCLUDED\n+#define AST_HPP_INCLUDED\n+\n+#include <string>\n+#include <vector>\n+#include <stdexcept>\n+#include \"../coretypes.hpp\"\n+#include <memory>\n+#include <map>\n+#include <unordered_map>\n+#include <algorithm>\n+\n+#include \"../parse/tokentree.hpp\"\n+#include \"types.hpp\"\n+\n+#include <ast/pattern.hpp>\n+#include <ast/attrs.hpp>\n+#include <ast/expr_ptr.hpp>\n+#include <ast/item.hpp>\n+#include <ast/macro.hpp>    // MacroInvocation\n+\n+#include \"generics.hpp\"\n+\n+#include <macro_rules/macro_rules_ptr.hpp>\n+\n+namespace AST {\n+\n+class Crate;\n+\n+class Module;\n+class Item;\n+\n+using ::std::unique_ptr;\n+using ::std::move;\n+\n+enum eItemType\n+{\n+    ITEM_TRAIT,\n+    ITEM_STRUCT,\n+    ITEM_FN,\n+    ITEM_STATIC,\n+};\n+\n+struct StructItem\n+{\n+    ::AST::AttributeList   m_attrs;\n+    bool    m_is_public;\n+    ::std::string   m_name;\n+    TypeRef m_type;\n+\n+    //StructItem() {}\n+\n+    StructItem(::AST::AttributeList attrs, bool is_pub, ::std::string name, TypeRef ty):\n+        m_attrs( mv$(attrs) ),\n+        m_is_public(is_pub),\n+        m_name( mv$(name) ),\n+        m_type( mv$(ty) )\n+    {\n+    }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const StructItem& x) {\n+        return os << (x.m_is_public ? \"pub \" : \"\") << x.m_name << \": \" << x.m_type;\n+    }\n+\n+    StructItem clone() const;\n+};\n+\n+struct TupleItem\n+{\n+    ::AST::AttributeList    m_attrs;\n+    bool    m_is_public;\n+    TypeRef m_type;\n+\n+    //TupleItem() {}\n+\n+    TupleItem(::AST::AttributeList attrs, bool is_pub, TypeRef ty):\n+        m_attrs( mv$(attrs) ),\n+        m_is_public(is_pub),\n+        m_type( mv$(ty) )\n+    {\n+    }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const TupleItem& x) {\n+        return os << (x.m_is_public ? \"pub \" : \"\") << x.m_type;\n+    }\n+\n+    TupleItem clone() const;\n+};\n+\n+class TypeAlias\n+{\n+    GenericParams  m_params;\n+    TypeRef m_type;\n+public:\n+    //TypeAlias() {}\n+    TypeAlias(GenericParams params, TypeRef type):\n+        m_params( move(params) ),\n+        m_type( move(type) )\n+    {}\n+\n+    const GenericParams& params() const { return m_params; }\n+    const TypeRef& type() const { return m_type; }\n+\n+    GenericParams& params() { return m_params; }\n+    TypeRef& type() { return m_type; }\n+\n+    TypeAlias clone() const;\n+};\n+\n+class Static\n+{\n+public:\n+    enum Class\n+    {\n+        CONST,\n+        STATIC,\n+        MUT,\n+    };\n+private:\n+    Class   m_class;\n+    TypeRef m_type;\n+    Expr    m_value;\n+public:\n+    Static(Class s_class, TypeRef type, Expr value):\n+        m_class(s_class),\n+        m_type( move(type) ),\n+        m_value( move(value) )\n+    {}\n+\n+    const Class& s_class() const { return m_class; }\n+    const TypeRef& type() const { return m_type; }\n+    const Expr& value() const { return m_value; }\n+\n+    TypeRef& type() { return m_type; }\n+    Expr& value() { return m_value; }\n+\n+    Static clone() const;\n+};\n+\n+class Function\n+{\n+public:\n+    typedef ::std::vector< ::std::pair<AST::Pattern,TypeRef> >   Arglist;\n+\n+private:\n+    Span    m_span;\n+    GenericParams  m_params;\n+    Expr    m_code;\n+    TypeRef m_rettype;\n+    Arglist m_args;\n+\n+    ::std::string   m_abi;\n+    bool    m_is_const;\n+    bool    m_is_unsafe;\n+    bool    m_is_variadic;  // extern only\n+public:\n+    Function(const Function&) = delete;\n+    Function& operator=(const Function&) = delete;\n+    Function(Function&&) = default;\n+    Function& operator=(Function&&) = default;\n+\n+    Function(Span sp, GenericParams params, ::std::string abi, bool is_unsafe, bool is_const, bool is_variadic, TypeRef ret_type, Arglist args);\n+\n+    void set_code(Expr code) { m_code = ::std::move(code); }\n+\n+    const ::std::string& abi() const { return m_abi; };\n+    bool is_const() const { return m_is_const; }\n+    bool is_unsafe() const { return m_is_unsafe; }\n+    bool is_variadic() const { return m_is_variadic; }\n+\n+    const GenericParams& params() const { return m_params; }\n+          GenericParams& params()       { return m_params; }\n+    const Expr& code() const { return m_code; }\n+          Expr& code()       { return m_code; }\n+    const TypeRef& rettype() const { return m_rettype; }\n+          TypeRef& rettype()       { return m_rettype; }\n+    const Arglist& args() const { return m_args; }\n+          Arglist& args()       { return m_args; }\n+\n+    Function clone() const;\n+};\n+\n+class Trait\n+{\n+    GenericParams  m_params;\n+    ::std::vector< Spanned<Type_TraitPath> > m_supertraits;\n+\n+    bool m_is_marker;\n+    bool m_is_unsafe;\n+    NamedList<Item> m_items;\n+public:\n+    Trait():\n+        m_is_marker(false),\n+        m_is_unsafe(false)\n+    {}\n+    Trait(GenericParams params, ::std::vector< Spanned<Type_TraitPath> > supertraits):\n+        m_params( mv$(params) ),\n+        m_supertraits( mv$(supertraits) ),\n+        m_is_marker(false),\n+        m_is_unsafe(false)\n+    {\n+    }\n+\n+    const GenericParams& params() const { return m_params; }\n+          GenericParams& params()       { return m_params; }\n+    const ::std::vector<Spanned<Type_TraitPath> >& supertraits() const { return m_supertraits; }\n+          ::std::vector<Spanned<Type_TraitPath> >& supertraits()       { return m_supertraits; }\n+\n+    const NamedList<Item>& items() const { return m_items; }\n+          NamedList<Item>& items()       { return m_items; }\n+\n+    void add_type(::std::string name, AttributeList attrs, TypeRef type);\n+    void add_function(::std::string name, AttributeList attrs, Function fcn);\n+    void add_static(::std::string name, AttributeList attrs, Static v);\n+\n+    void set_is_marker();\n+    bool is_marker() const;\n+    void set_is_unsafe() { m_is_unsafe = true; }\n+    bool is_unsafe() const { return m_is_unsafe; }\n+\n+    bool has_named_item(const ::std::string& name, bool& out_is_fcn) const;\n+\n+    Trait clone() const;\n+};\n+\n+TAGGED_UNION_EX(EnumVariantData, (), Value,\n+    (\n+    (Value, struct {\n+        ::AST::Expr m_value;\n+        }),\n+    (Tuple, struct {\n+        ::std::vector<TypeRef>  m_sub_types;\n+        }),\n+    (Struct, struct {\n+        ::std::vector<StructItem>   m_fields;\n+        })\n+    ),\n+    (), (),\n+    (\n+    public:\n+    )\n+    );\n+\n+struct EnumVariant\n+{\n+    AttributeList   m_attrs;\n+    ::std::string   m_name;\n+    EnumVariantData m_data;\n+\n+    EnumVariant()\n+    {\n+    }\n+\n+    EnumVariant(AttributeList attrs, ::std::string name, Expr&& value):\n+        m_attrs( mv$(attrs) ),\n+        m_name( mv$(name) ),\n+        m_data( EnumVariantData::make_Value({mv$(value)}) )\n+    {\n+    }\n+\n+    EnumVariant(AttributeList attrs, ::std::string name, ::std::vector<TypeRef> sub_types):\n+        m_attrs( mv$(attrs) ),\n+        m_name( ::std::move(name) ),\n+        m_data( EnumVariantData::make_Tuple( {mv$(sub_types)} ) )\n+    {\n+    }\n+\n+    EnumVariant(AttributeList attrs, ::std::string name, ::std::vector<StructItem> fields):\n+        m_attrs( mv$(attrs) ),\n+        m_name( ::std::move(name) ),\n+        m_data( EnumVariantData::make_Struct( {mv$(fields)} ) )\n+    {\n+    }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const EnumVariant& x)\n+    {\n+        os << \"EnumVariant(\" << x.m_name;\n+        TU_MATCH(EnumVariantData, (x.m_data), (e),\n+        (Value,\n+            os << \" = \" << e.m_value;\n+            ),\n+        (Tuple,\n+            os << \"(\" << e.m_sub_types << \")\";\n+            ),\n+        (Struct,\n+            os << \" { \" << e.m_fields << \" }\";\n+            )\n+        )\n+        return os << \")\";\n+    }\n+};\n+\n+class Enum\n+{\n+    GenericParams    m_params;\n+    ::std::vector<EnumVariant>   m_variants;\n+public:\n+    Enum() {}\n+    Enum( GenericParams params, ::std::vector<EnumVariant> variants ):\n+        m_params( move(params) ),\n+        m_variants( move(variants) )\n+    {}\n+\n+    const GenericParams& params() const { return m_params; }\n+          GenericParams& params()       { return m_params; }\n+    const ::std::vector<EnumVariant>& variants() const { return m_variants; }\n+          ::std::vector<EnumVariant>& variants()       { return m_variants; }\n+\n+    Enum clone() const;\n+};\n+\n+TAGGED_UNION_EX(StructData, (), Struct,\n+    (\n+    (Unit, struct {}),\n+    (Tuple, struct {\n+        ::std::vector<TupleItem>    ents;\n+        }),\n+    (Struct, struct {\n+        ::std::vector<StructItem>   ents;\n+        })\n+    ),\n+    (),(),\n+    (\n+    public:\n+        )\n+    );\n+\n+class Struct\n+{\n+    GenericParams    m_params;\n+public:\n+    StructData  m_data;\n+\n+    Struct() {}\n+    Struct(GenericParams params):\n+        m_params( mv$(params) ),\n+        m_data( StructData::make_Unit({}) )\n+    {\n+    }\n+    Struct( GenericParams params, ::std::vector<StructItem> fields ):\n+        m_params( move(params) ),\n+        m_data( StructData::make_Struct({mv$(fields)}) )\n+    {}\n+    Struct( GenericParams params, ::std::vector<TupleItem> fields ):\n+        m_params( move(params) ),\n+        m_data( StructData::make_Tuple({mv$(fields)}) )\n+    {}\n+\n+    const GenericParams& params() const { return m_params; }\n+          GenericParams& params()       { return m_params; }\n+\n+    Struct clone() const;\n+};\n+\n+class Union\n+{\n+public:\n+    GenericParams   m_params;\n+    ::std::vector<StructItem>   m_variants;\n+\n+    Union( GenericParams params, ::std::vector<StructItem> fields ):\n+        m_params( move(params) ),\n+        m_variants( mv$(fields) )\n+    {}\n+\n+    const GenericParams& params() const { return m_params; }\n+          GenericParams& params()       { return m_params; }\n+\n+    Union clone() const;\n+};\n+\n+class ImplDef\n+{\n+    AttributeList   m_attrs;\n+    bool    m_is_unsafe;\n+    GenericParams  m_params;\n+    Spanned<Path>   m_trait;\n+    TypeRef m_type;\n+public:\n+    ImplDef(AttributeList attrs, GenericParams params, Spanned<Path> trait_type, TypeRef impl_type):\n+        m_attrs( mv$(attrs) ),\n+        m_is_unsafe( false ),\n+        m_params( mv$(params) ),\n+        m_trait( mv$(trait_type) ),\n+        m_type( mv$(impl_type) )\n+    {}\n+\n+    ImplDef(ImplDef&&) /*noexcept*/ = default;\n+    ImplDef& operator=(ImplDef&&) = default;\n+\n+    void set_is_unsafe() { m_is_unsafe = true; }\n+    bool is_unsafe() const { return m_is_unsafe; }\n+\n+    // Accessors\n+    const AttributeList& attrs() const { return m_attrs; }\n+          AttributeList& attrs()       { return m_attrs; }\n+\n+    const GenericParams& params() const { return m_params; }\n+          GenericParams& params()       { return m_params; }\n+    const Spanned<Path>& trait() const { return m_trait; }\n+          Spanned<Path>& trait()       { return m_trait; }\n+    const TypeRef& type() const { return m_type; }\n+          TypeRef& type()       { return m_type; }\n+\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const ImplDef& impl);\n+};\n+\n+class Impl\n+{\n+public:\n+    struct ImplItem {\n+        bool    is_pub; // Ignored for trait impls\n+        bool    is_specialisable;\n+        ::std::string   name;\n+\n+        ::std::unique_ptr<Item> data;\n+    };\n+\n+private:\n+    ImplDef m_def;\n+\n+    ::std::vector< ImplItem >   m_items;\n+    //NamedList<TypeRef>   m_types;\n+    //NamedList<Function>  m_functions;\n+    //NamedList<Static>    m_statics;\n+\n+public:\n+    Impl(Impl&&) /*noexcept*/ = default;\n+    Impl(ImplDef def):\n+        m_def( mv$(def) )\n+    {}\n+    Impl& operator=(Impl&&) = default;\n+\n+    void add_function(bool is_public, bool is_specialisable, ::std::string name, Function fcn);\n+    void add_type(bool is_public, bool is_specialisable, ::std::string name, TypeRef type);\n+    void add_static(bool is_public, bool is_specialisable, ::std::string name, Static v);\n+    void add_macro_invocation( MacroInvocation inv );\n+\n+    const ImplDef& def() const { return m_def; }\n+          ImplDef& def()       { return m_def; }\n+    const ::std::vector<ImplItem>& items() const { return m_items; }\n+          ::std::vector<ImplItem>& items()       { return m_items; }\n+\n+    bool has_named_item(const ::std::string& name) const;\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const Impl& impl);\n+\n+private:\n+};\n+\n+struct UseStmt\n+{\n+    Span    sp;\n+    ::AST::Path path;\n+    ::AST::PathBinding  alt_binding;\n+\n+    UseStmt(Span sp, Path p):\n+        sp(sp),\n+        path(p)\n+    {\n+    }\n+\n+    UseStmt clone() const;\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const UseStmt& x);\n+};\n+\n+class ExternBlock\n+{\n+    ::std::string   m_abi;\n+    ::std::vector< Named<Item>> m_items;\n+public:\n+    ExternBlock(::std::string abi):\n+        m_abi( mv$(abi) )\n+    {}\n+\n+    const ::std::string& abi() const { return m_abi; }\n+\n+    void add_item(Named<Item> named_item);\n+\n+    // NOTE: Only Function and Static are valid.\n+          ::std::vector<Named<Item>>& items()       { return m_items; }\n+    const ::std::vector<Named<Item>>& items() const { return m_items; }\n+\n+    ExternBlock clone() const;\n+};\n+\n+/// Representation of a parsed (and being converted) function\n+class Module\n+{\n+    ::AST::Path m_my_path;\n+\n+    // Module-level items\n+    /// General items\n+    ::std::vector<Named<Item>>  m_items;\n+\n+    // --- Runtime caches and state ---\n+    ::std::vector< ::std::shared_ptr<Module> >  m_anon_modules;\n+\n+    ::std::vector< Named<const MacroRules*> >   m_macro_import_res;\n+    ::std::vector< Named<MacroRulesPtr> >  m_macros;\n+\n+public:\n+    struct FileInfo\n+    {\n+        bool    controls_dir = false;\n+        ::std::string   path = \"!\";\n+    };\n+\n+    FileInfo    m_file_info;\n+\n+    bool    m_insert_prelude = true;    // Set to false by `#[no_prelude]` handler\n+    char    m_index_populated = 0;  // 0 = no, 1 = partial, 2 = complete\n+    struct IndexEnt {\n+        bool is_pub;    // Used as part of glob import checking\n+        bool is_import; // Set if this item has a path that isn't `mod->path() + name`\n+        ::AST::Path path;\n+    };\n+\n+    // TODO: Document difference between namespace and Type\n+    ::std::unordered_map< ::std::string, IndexEnt >    m_namespace_items;\n+    ::std::unordered_map< ::std::string, IndexEnt >    m_type_items;\n+    ::std::unordered_map< ::std::string, IndexEnt >    m_value_items;\n+\n+    // List of macros imported from other modules (via #[macro_use], includes proc macros)\n+    // - First value is an absolute path to the macro (including crate name)\n+    ::std::vector<::std::pair< ::std::vector<::std::string>, const MacroRules* >>  m_macro_imports;\n+\n+public:\n+    Module() {}\n+    Module(::AST::Path path):\n+        m_my_path( mv$(path) )\n+    {\n+    }\n+\n+    bool is_anon() const {\n+        return m_my_path.nodes().size() > 0 && m_my_path.nodes().back().name()[0] == '#';\n+    }\n+\n+    /// Create an anon module (for use inside expressions)\n+    ::std::shared_ptr<AST::Module> add_anon();\n+\n+    void add_item(Named<Item> item);\n+    void add_item(bool is_pub, ::std::string name, Item it, AttributeList attrs);\n+    void add_ext_crate(bool is_public, ::std::string ext_name, ::std::string imp_name, AttributeList attrs);\n+    void add_alias(bool is_public, UseStmt path, ::std::string name, AttributeList attrs);\n+    void add_macro_invocation(MacroInvocation item);\n+\n+    void add_macro(bool is_exported, ::std::string name, MacroRulesPtr macro);\n+    void add_macro_import(::std::string name, const MacroRules& mr);\n+\n+\n+\n+    const ::AST::Path& path() const { return m_my_path; }\n+\n+          ::std::vector<Named<Item>>& items()       { return m_items; }\n+    const ::std::vector<Named<Item>>& items() const { return m_items; }\n+\n+          ::std::vector< ::std::shared_ptr<Module> >&   anon_mods()       { return m_anon_modules; }\n+    const ::std::vector< ::std::shared_ptr<Module> >&   anon_mods() const { return m_anon_modules; }\n+\n+\n+          NamedList<MacroRulesPtr>&    macros()        { return m_macros; }\n+    const NamedList<MacroRulesPtr>&    macros()  const { return m_macros; }\n+    const ::std::vector<Named<const MacroRules*> >  macro_imports_res() const { return m_macro_import_res; }\n+\n+private:\n+    void resolve_macro_import(const Crate& crate, const ::std::string& modname, const ::std::string& macro_name);\n+};\n+\n+TAGGED_UNION_EX(Item, (), None,\n+    (\n+    (None, struct {} ),\n+    (MacroInv, MacroInvocation),\n+    (Use, UseStmt),\n+\n+    // Nameless items\n+    (ExternBlock, ExternBlock),\n+    (Impl, Impl),\n+    (NegImpl, ImplDef),\n+\n+    (Module, Module),\n+    (Crate, struct {\n+        ::std::string   name;\n+        }),\n+\n+    (Type, TypeAlias),\n+    (Struct, Struct),\n+    (Enum, Enum),\n+    (Union, Union),\n+    (Trait, Trait),\n+\n+    (Function, Function),\n+    (Static, Static)\n+    ),\n+\n+    (, attrs(mv$(x.attrs))), (attrs = mv$(x.attrs);),\n+    (\n+    public:\n+        AttributeList  attrs;\n+        Span    span;\n+\n+        Item clone() const;\n+    )\n+    );\n+\n+} // namespace AST\n+\n+class GenericResolveClosure\n+{\n+    const ::AST::GenericParams&  m_params;\n+    const ::std::vector<TypeRef>&   m_args;\n+public:\n+    GenericResolveClosure(const AST::GenericParams& params, const ::std::vector<TypeRef>& args):\n+        m_params(params),\n+        m_args(args)\n+    {}\n+    const TypeRef& operator()(const char *argname) {\n+        for(unsigned int i = 0; i < m_params.ty_params().size(); i ++)\n+        {\n+            if( m_params.ty_params()[i].name() == argname ) {\n+                return m_args.at(i);\n+            }\n+        }\n+        throw ::std::runtime_error(\"BUGCHECK - Unknown arg in field type\");\n+    }\n+};\n+\n+\n+#endif // AST_HPP_INCLUDED"}, {"sha": "0e1c8149dc35b81bfa5b90fd1f8ebbed8ce76b37", "filename": "gcc/rust/mrustc_parser/ast/attrs.hpp", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fattrs.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fattrs.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fattrs.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,157 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/attrs.hpp\n+ * - AST Attributes (#[foo] and #![foo])\n+ */\n+#ifndef _AST_ATTRS_HPP_\n+#define _AST_ATTRS_HPP_\n+\n+\n+namespace AST {\n+\n+//\n+class Attribute;\n+::std::ostream& operator<<(::std::ostream& os, const Attribute& x);\n+\n+/// A list of attributes on an item (searchable by the attribute name)\n+class AttributeList\n+{\n+public:\n+    ::std::vector<Attribute> m_items;\n+\n+    AttributeList() {}\n+    AttributeList(::std::vector<Attribute> items):\n+        m_items( mv$(items) )\n+    {\n+    }\n+\n+    // Move present\n+    AttributeList(AttributeList&&) = default;\n+    AttributeList& operator=(AttributeList&&) = default;\n+    // No copy assign, but explicit copy\n+    explicit AttributeList(const AttributeList&) = default;\n+    AttributeList& operator=(const AttributeList&) = delete;\n+    // Explicit clone\n+    AttributeList clone() const;\n+\n+    void push_back(Attribute i);\n+\n+    const Attribute* get(const char *name) const;\n+    Attribute* get(const char *name) {\n+        return const_cast<Attribute*>( const_cast<const AttributeList*>(this)->get(name));\n+    }\n+    bool has(const char *name) const {\n+        return get(name) != 0;\n+    }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const AttributeList& x) {\n+        for(const auto& i : x.m_items) {\n+            os << \"#[\" << i << \"]\";\n+        }\n+        return os;\n+    }\n+};\n+\n+\n+TAGGED_UNION(AttributeData, None,\n+    (None, struct {}),\n+    (String, struct {\n+        ::std::string   val;\n+        }),\n+    (List, struct {\n+        ::std::vector<Attribute> sub_items;\n+        })\n+    );\n+\n+// An attribute can has a name, and optional data:\n+// Data can be:\n+// - A parenthesised token tree\n+//   > In 1.19 this was actually just sub-attributes\n+// - an associated (string) literal\n+\n+class Attribute\n+{\n+    Span    m_span;\n+    ::std::string   m_name;\n+    AttributeData   m_data;\n+    mutable bool    m_is_used;\n+public:\n+    Attribute(Span sp, ::std::string name):\n+        m_span(::std::move(sp)),\n+        m_name(name),\n+        m_data( AttributeData::make_None({}) )\n+    {\n+    }\n+    Attribute(Span sp, ::std::string name, ::std::string str_val):\n+        m_span(::std::move(sp)),\n+        m_name(name),\n+        m_data( AttributeData::make_String({mv$(str_val)}) )\n+    {\n+    }\n+    Attribute(Span sp, ::std::string name, ::std::vector<Attribute> items):\n+        m_span(::std::move(sp)),\n+        m_name(name),\n+        m_data( AttributeData::make_List({mv$(items)}) )\n+    {\n+    }\n+\n+    explicit Attribute(const Attribute& x):\n+        m_span(x.m_span),\n+        m_name(x.m_name),\n+        m_is_used(x.m_is_used)\n+    {\n+        TU_MATCHA( (x.m_data), (e),\n+        (None,\n+            ),\n+        (String,\n+            m_data = AttributeData::make_String({ e.val });\n+            ),\n+        (List,\n+            m_data = AttributeData::make_List({ ::std::vector<Attribute>(e.sub_items) });\n+            )\n+        )\n+    }\n+    Attribute& operator=(const Attribute& ) = delete;\n+    Attribute(Attribute&& ) = default;\n+    Attribute& operator=(Attribute&& ) = default;\n+    Attribute clone() const;\n+\n+    void mark_used() const { m_is_used = true; }\n+    bool is_used() const { return m_is_used; }\n+\n+    const Span& span() const { return m_span; }\n+    const ::std::string& name() const { return m_name; }\n+    const AttributeData& data() const { return m_data; }\n+\n+    // Legacy accessors/checkers\n+    bool has_noarg() const { return m_data.is_None(); }\n+\n+    bool has_string() const { return m_data.is_String(); }\n+    const ::std::string& string() const { return m_data.as_String().val; }\n+\n+    bool has_sub_items() const { return m_data.is_List(); }\n+    const ::std::vector<Attribute>& items() const { return m_data.as_List().sub_items; }\n+          ::std::vector<Attribute>& items()       { return m_data.as_List().sub_items; }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const Attribute& x) {\n+        os << x.m_name;\n+        TU_MATCHA( (x.m_data), (e),\n+        (None,\n+            ),\n+        (String,\n+            os << \"=\\\"\" << e.val << \"\\\"\";\n+            ),\n+        (List,\n+            os << \"(\" << e.sub_items << \")\";\n+            )\n+        )\n+        return os;\n+    }\n+};\n+\n+}   // namespace AST\n+\n+#endif\n+"}, {"sha": "3db09f1b9e21cd98c7fe7fad8ace9e2a3b58991a", "filename": "gcc/rust/mrustc_parser/ast/crate.cpp", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,209 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/crate.cpp\n+ * - Helper functions for the AST::Crate type (includes loading `extern crate`s)\n+ */\n+#include \"crate.hpp\"\n+#include \"ast.hpp\"\n+#include \"../parse/parseerror.hpp\"\n+#include \"../expand/cfg.hpp\"\n+#include <hir/hir.hpp>  // HIR::Crate\n+#include <hir/main_bindings.hpp>    // HIR_Deserialise\n+#include <fstream>\n+\n+::std::vector<::std::string>    AST::g_crate_load_dirs = { };\n+::std::map<::std::string, ::std::string>    AST::g_crate_overrides;\n+\n+namespace {\n+    bool check_item_cfg(const ::AST::AttributeList& attrs)\n+    {\n+        for(const auto& at : attrs.m_items) {\n+            if( at.name() == \"cfg\" && !check_cfg(at.span(), at) ) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    void iterate_module(::AST::Module& mod, ::std::function<void(::AST::Module& mod)> fcn)\n+    {\n+        fcn(mod);\n+        for( auto& sm : mod.items() )\n+        {\n+            TU_IFLET(::AST::Item, sm.data, Module, e,\n+                if( check_item_cfg(sm.data.attrs) )\n+                {\n+                    iterate_module(e, fcn);\n+                }\n+            )\n+        }\n+        // TODO: What about if an anon mod has been #[cfg]-d out?\n+        // - For now, disable\n+        //for(const auto& anon : mod.anon_mods() ) {\n+        //    iterate_module(*anon, fcn);\n+        //}\n+    }\n+}\n+\n+\n+namespace AST {\n+\n+Crate::Crate():\n+    m_root_module(::AST::Path(\"\",{})),\n+    m_load_std(LOAD_STD)\n+{\n+}\n+\n+void Crate::load_externs()\n+{\n+    auto cb = [this](Module& mod) {\n+        for( /*const*/ auto& it : mod.items() )\n+        {\n+            TU_IFLET(AST::Item, it.data, Crate, c,\n+                if( check_item_cfg(it.data.attrs) )\n+                {\n+                    c.name = load_extern_crate( it.data.span, c.name );\n+                }\n+            )\n+        }\n+        };\n+    iterate_module(m_root_module, cb);\n+\n+    // Check for no_std or no_core, and load libstd/libcore\n+    // - Duplicates some of the logic in \"Expand\", but also helps keep crate loading separate to most of expand\n+    // NOTE: Not all crates are loaded here, any crates loaded by macro invocations will be done during expand.\n+    bool no_std  = false;\n+    bool no_core = false;\n+\n+    for( const auto& a : this->m_attrs.m_items )\n+    {\n+        if( a.name() == \"no_std\" )\n+            no_std = true;\n+        if( a.name() == \"no_core\" )\n+            no_core = true;\n+        if( a.name() == \"cfg_attr\" && a.items().size() == 2 ) {\n+            if( check_cfg(a.span(), a.items().at(0)) )\n+            {\n+                const auto& a2 = a.items().at(1);\n+                if( a2.name() == \"no_std\" )\n+                    no_std = true;\n+                if( a2.name() == \"no_core\" )\n+                    no_core = true;\n+            }\n+        }\n+    }\n+\n+    if( no_core ) {\n+        // Don't load anything\n+    }\n+    else if( no_std ) {\n+        auto n = this->load_extern_crate(Span(), \"core\");\n+        ASSERT_BUG(Span(), n == \"core\", \"libcore wasn't loaded as `core`, instead `\" << n << \"`\");\n+    }\n+    else {\n+        auto n = this->load_extern_crate(Span(), \"std\");\n+        ASSERT_BUG(Span(), n == \"std\", \"libstd wasn't loaded as `std`, instead `\" << n << \"`\");\n+    }\n+}\n+// TODO: Handle disambiguating crates with the same name (e.g. libc in std and crates.io libc)\n+// - Crates recorded in rlibs should specify a hash/tag that's passed in to this function.\n+::std::string Crate::load_extern_crate(Span sp, const ::std::string& name, const ::std::string& basename/*=\"\"*/)\n+{\n+    DEBUG(\"Loading crate '\" << name << \"'\");\n+\n+    ::std::string   path;\n+    auto it = g_crate_overrides.find(name);\n+    if(basename == \"\" && it != g_crate_overrides.end())\n+    {\n+        path = it->second;\n+        if( !::std::ifstream(path).good() ) {\n+            ERROR(sp, E0000, \"Unable to open crate '\" << name << \"' at path \" << path);\n+        }\n+    }\n+    else\n+    {\n+        // Search a list of load paths for the crate\n+        for(const auto& p : g_crate_load_dirs)\n+        {\n+            if( basename == \"\" )\n+            {\n+                path = p + \"/lib\" + name + \".hir\";\n+                // TODO: Search for `p+\"/lib\"+name+\"-*.hir\" (which would match e.g. libnum-0.11.hir)\n+            }\n+            else\n+            {\n+                path = p + \"/\" + basename;\n+            }\n+\n+            if( ::std::ifstream(path).good() ) {\n+                break ;\n+            }\n+        }\n+        if( !::std::ifstream(path).good() ) {\n+            if( basename.empty() )\n+                ERROR(sp, E0000, \"Unable to locate crate '\" << name << \"' in search directories\");\n+            else\n+                ERROR(sp, E0000, \"Unable to locate crate '\" << name << \"' with filename \" << basename << \" in search directories\");\n+        }\n+    }\n+\n+    // NOTE: Creating `ExternCrate` loads the crate from the specified path\n+    auto ec = ExternCrate { name, path };\n+    auto real_name = ec.m_hir->m_crate_name;\n+    assert(!real_name.empty());\n+    auto res = m_extern_crates.insert(::std::make_pair( real_name, mv$(ec) ));\n+    if( !res.second ) {\n+        // Crate already loaded?\n+    }\n+    auto& ext_crate = res.first->second;\n+    // Move the external list out (doesn't need to be kept in the nested crate)\n+    auto crate_ext_list = mv$( ext_crate.m_hir->m_ext_crates );\n+\n+    // Load referenced crates\n+    for( const auto& ext : crate_ext_list )\n+    {\n+        if( m_extern_crates.count(ext.first) == 0 )\n+        {\n+            const auto load_name = this->load_extern_crate(sp, ext.first, ext.second.m_basename);\n+            if( load_name != ext.first )\n+            {\n+                // ERROR - The crate loaded wasn't the one that was used when compiling this crate.\n+                ERROR(sp, E0000, \"The crate file `\" << ext.second.m_basename << \"` didn't load the expected crate - have \" << load_name << \" != exp \" << ext.first);\n+            }\n+        }\n+    }\n+\n+    DEBUG(\"Loaded '\" << name << \"' from '\" << basename << \"' (actual name is '\" << real_name << \"')\");\n+    return real_name;\n+}\n+\n+ExternCrate::ExternCrate(const ::std::string& name, const ::std::string& path):\n+    m_name(name),\n+    m_filename(path)\n+{\n+    TRACE_FUNCTION_F(\"name=\" << name << \", path='\" << path << \"'\");\n+    m_hir = HIR_Deserialise(path, name);\n+\n+    m_hir->post_load_update(name);\n+    m_name = m_hir->m_crate_name;\n+}\n+\n+void ExternCrate::with_all_macros(::std::function<void(const ::std::string& , const MacroRules&)> cb) const\n+{\n+    for(const auto& m : m_hir->m_exported_macros)\n+    {\n+        cb(m.first, *m.second);\n+    }\n+}\n+const MacroRules* ExternCrate::find_macro_rules(const ::std::string& name) const\n+{\n+    auto i = m_hir->m_exported_macros.find(name);\n+    if(i != m_hir->m_exported_macros.end())\n+        return &*i->second;\n+    return nullptr;\n+}\n+\n+\n+}   // namespace AST\n+"}, {"sha": "87a9f867b9ece1512518fe63a5c9811ce6b70a93", "filename": "gcc/rust/mrustc_parser/ast/crate.hpp", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,118 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/crate.hpp\n+ * - AST::Crate type, and other top-level AST definitions\n+ */\n+#pragma once\n+\n+#include \"ast.hpp\"\n+#include \"types.hpp\"\n+#include <hir/crate_ptr.hpp>\n+\n+namespace AST {\n+\n+\n+class ExternCrate;\n+\n+class TestDesc\n+{\n+public:\n+    ::AST::Path path;\n+    ::std::string   name;\n+    bool    ignore = false;\n+    bool    is_benchmark = false;\n+\n+    enum class ShouldPanic {\n+        No,\n+        Yes,\n+        YesWithMessage,\n+    } panic_type = ShouldPanic::No;\n+\n+    ::std::string   expected_panic_message;\n+};\n+\n+class ProcMacroDef\n+{\n+public:\n+    ::std::string   name;\n+    ::AST::Path path;\n+    ::std::vector<::std::string>    attributes;\n+};\n+\n+class Crate\n+{\n+public:\n+    ::AST::AttributeList    m_attrs;\n+\n+    ::std::map< ::std::string, ::AST::Path> m_lang_items;\n+public:\n+    Module  m_root_module;\n+    ::std::map< ::std::string, ExternCrate> m_extern_crates;\n+    // Mapping filled by searching for (?visible) macros with is_pub=true\n+    ::std::map< ::std::string, const MacroRules*> m_exported_macros;\n+\n+    // List of tests (populated in expand if --test is passed)\n+    bool    m_test_harness = false;\n+    ::std::vector<TestDesc>   m_tests;\n+\n+    //::std::vector<::std::string>    m_extra_files;\n+\n+    // Procedural macros!\n+    ::std::vector<ProcMacroDef> m_proc_macros;\n+\n+    enum class Type {\n+        Unknown,\n+        RustLib,\n+        RustDylib,\n+        CDylib,\n+        Executable,\n+        ProcMacro,   // Procedural macro\n+    } m_crate_type = Type::Unknown;\n+    enum LoadStd {\n+        LOAD_STD,\n+        LOAD_CORE,\n+        LOAD_NONE,\n+    } m_load_std = LOAD_STD;\n+    ::std::string   m_crate_name_suffix;\n+    ::std::string   m_crate_name;\n+    AST::Path   m_prelude_path;\n+\n+\n+    Crate();\n+\n+    const Module& root_module() const { return m_root_module; }\n+          Module& root_module()       { return m_root_module; }\n+\n+    /// Load referenced crates\n+    void load_externs();\n+\n+    /// Load the named crate and returns the crate's unique name\n+    /// If the parameter `file` is non-empty, only that particular filename will be loaded (from any of the search paths)\n+    ::std::string load_extern_crate(Span sp, const ::std::string& name, const ::std::string& file=\"\");\n+};\n+\n+/// Representation of an imported crate\n+class ExternCrate\n+{\n+public:\n+    ::std::string   m_name;\n+    ::std::string   m_filename;\n+    ::HIR::CratePtr m_hir;\n+\n+    ExternCrate(const ::std::string& name, const ::std::string& path);\n+\n+    ExternCrate(ExternCrate&&) = default;\n+    ExternCrate& operator=(ExternCrate&&) = default;\n+    ExternCrate(const ExternCrate&) = delete;\n+    ExternCrate& operator=(const ExternCrate& ) = delete;\n+\n+    void with_all_macros(::std::function<void(const ::std::string& , const MacroRules&)> cb) const;\n+    const MacroRules* find_macro_rules(const ::std::string& name) const;\n+};\n+\n+extern ::std::vector<::std::string>    g_crate_load_dirs;\n+extern ::std::map<::std::string, ::std::string>    g_crate_overrides;\n+\n+}   // namespace AST"}, {"sha": "f1481abff816733eeb6f1ce29f63b797ba607873", "filename": "gcc/rust/mrustc_parser/ast/dump.cpp", "status": "added", "additions": 1179, "deletions": 0, "changes": 1179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fdump.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fdump.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fdump.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,1179 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/dump.cpp\n+ * - Dumps the AST of a crate as rust code (annotated)\n+ */\n+#include <ast/crate.hpp>\n+#include <ast/ast.hpp>\n+#include <ast/expr.hpp>\n+#include <main_bindings.hpp>\n+#include <hir/hir.hpp>  // ABI_RUST - TODO: Move elsewhere?\n+#include <fstream>\n+\n+#include <cpp_unpack.h>\n+\n+#define IS(v, c)    (dynamic_cast<c*>(&v) != 0)\n+#define WRAPIF_CMD(v, t)  || IS(v, t)\n+#define WRAPIF(uniq_ptr, class1, ...) do { auto& _v = *(uniq_ptr); if( IS(_v, class1) CC_ITERATE(WRAPIF_CMD, (_v), __VA_ARGS__) ) { paren_wrap(uniq_ptr); } else { AST::NodeVisitor::visit(uniq_ptr); } } while(0)\n+\n+class RustPrinter:\n+    public AST::NodeVisitor\n+{\n+    ::std::ostream& m_os;\n+    int m_indent_level;\n+    bool m_expr_root;   //!< used to allow 'if' and 'match' to behave differently as standalone exprs\n+public:\n+    RustPrinter(::std::ostream& os):\n+        m_os(os),\n+        m_indent_level(0),\n+        m_expr_root(false)\n+    {}\n+\n+    void handle_module(const AST::Module& mod);\n+    void handle_struct(const AST::Struct& s);\n+    void handle_enum(const AST::Enum& s);\n+    void handle_trait(const AST::Trait& s);\n+\n+    void handle_function(bool is_pub, const ::std::string& name, const AST::Function& f);\n+\n+    virtual bool is_const() const override { return true; }\n+    virtual void visit(AST::ExprNode_Block& n) override {\n+        if( n.m_is_unsafe ) {\n+            m_os << \"unsafe \";\n+        }\n+        m_os << \"{\";\n+        inc_indent();\n+        if( n.m_local_mod )\n+        {\n+            handle_module(*n.m_local_mod);\n+        }\n+        bool is_first = true;\n+        for( auto& child : n.m_nodes )\n+        {\n+            if(is_first) {\n+                is_first = false;\n+            } else {\n+                m_os << \";\";\n+            }\n+            m_os << \"\\n\";\n+            m_os << indent();\n+            m_expr_root = true;\n+            if( !child.get() )\n+                m_os << \"/* nil */\";\n+            else\n+                AST::NodeVisitor::visit(child);\n+        }\n+        if( !n.m_yields_final_value )\n+            m_os << \";\";\n+        m_os << \"\\n\";\n+        dec_indent();\n+        m_os << indent() << \"}\";\n+    }\n+    virtual void visit(AST::ExprNode_Macro& n) override {\n+        m_expr_root = false;\n+        m_os << n.m_name << \"!( /* TODO: Macro TT */ )\";\n+    }\n+    virtual void visit(AST::ExprNode_Asm& n) override {\n+        m_os << \"asm!( \\\"\" << n.m_text << \"\\\"\";\n+        m_os << \" :\";\n+        for(const auto& v : n.m_output)\n+        {\n+            m_os << \" \\\"\" << v.name << \"\\\" (\";\n+            AST::NodeVisitor::visit(v.value);\n+            m_os << \"),\";\n+        }\n+        m_os << \" :\";\n+        for(const auto& v : n.m_input)\n+        {\n+            m_os << \" \\\"\" << v.name << \"\\\" (\";\n+            AST::NodeVisitor::visit(v.value);\n+            m_os << \"),\";\n+        }\n+        m_os << \" :\";\n+        for(const auto& v : n.m_clobbers)\n+            m_os << \" \\\"\" << v << \"\\\",\";\n+        m_os << \" :\";\n+        for(const auto& v : n.m_flags)\n+            m_os << \" \\\"\" << v << \"\\\",\";\n+        m_os << \" )\";\n+    }\n+    virtual void visit(AST::ExprNode_Flow& n) override {\n+        m_expr_root = false;\n+        switch(n.m_type)\n+        {\n+        case AST::ExprNode_Flow::RETURN:    m_os << \"return \";  break;\n+        case AST::ExprNode_Flow::BREAK:     m_os << \"break \";  break;\n+        case AST::ExprNode_Flow::CONTINUE:  m_os << \"continue \";  break;\n+        }\n+        AST::NodeVisitor::visit(n.m_value);\n+    }\n+    virtual void visit(AST::ExprNode_LetBinding& n) override {\n+        m_expr_root = false;\n+        m_os << \"let \";\n+        print_pattern(n.m_pat, false);\n+        m_os << \": \";\n+        print_type(n.m_type);\n+        m_os << \" = \";\n+        AST::NodeVisitor::visit(n.m_value);\n+    }\n+    virtual void visit(AST::ExprNode_Assign& n) override {\n+        m_expr_root = false;\n+        AST::NodeVisitor::visit(n.m_slot);\n+        switch(n.m_op)\n+        {\n+        case AST::ExprNode_Assign::NONE:    m_os << \"  = \";  break;\n+        case AST::ExprNode_Assign::ADD:     m_os << \" += \";  break;\n+        case AST::ExprNode_Assign::SUB:     m_os << \" -= \";  break;\n+        case AST::ExprNode_Assign::MUL:     m_os << \" *= \";  break;\n+        case AST::ExprNode_Assign::DIV:     m_os << \" /= \";  break;\n+        case AST::ExprNode_Assign::MOD:     m_os << \" %= \";  break;\n+        case AST::ExprNode_Assign::AND:     m_os << \" &= \";  break;\n+        case AST::ExprNode_Assign::OR:      m_os << \" |= \";  break;\n+        case AST::ExprNode_Assign::XOR:     m_os << \" ^= \";  break;\n+        case AST::ExprNode_Assign::SHR:     m_os << \" >>= \";  break;\n+        case AST::ExprNode_Assign::SHL:     m_os << \" <<= \";  break;\n+        }\n+        AST::NodeVisitor::visit(n.m_value);\n+    }\n+    virtual void visit(AST::ExprNode_CallPath& n) override {\n+        m_expr_root = false;\n+        m_os << n.m_path;\n+        m_os << \"(\";\n+        bool is_first = true;\n+        for( auto& arg : n.m_args )\n+        {\n+            if(is_first) {\n+                is_first = false;\n+            } else {\n+                m_os << \", \";\n+            }\n+            AST::NodeVisitor::visit(arg);\n+        }\n+        m_os << \")\";\n+    }\n+    virtual void visit(AST::ExprNode_CallMethod& n) override {\n+        m_expr_root = false;\n+        WRAPIF( n.m_val\n+            , AST::ExprNode_Deref, AST::ExprNode_UniOp\n+            , AST::ExprNode_Cast, AST::ExprNode_BinOp, AST::ExprNode_Assign\n+            , AST::ExprNode_Match, AST::ExprNode_If, AST::ExprNode_IfLet, AST::ExprNode_Match\n+            );\n+        m_os << \".\" << n.m_method;\n+        m_os << \"(\";\n+        bool is_first = true;\n+        for( auto& arg : n.m_args )\n+        {\n+            if(is_first) {\n+                is_first = false;\n+            } else {\n+                m_os << \", \";\n+            }\n+            AST::NodeVisitor::visit(arg);\n+        }\n+        m_os << \")\";\n+    }\n+    virtual void visit(AST::ExprNode_CallObject& n) override {\n+        m_expr_root = false;\n+        m_os << \"(\";\n+        AST::NodeVisitor::visit(n.m_val);\n+        m_os << \")(\";\n+        bool is_first = true;\n+        for( auto& arg : n.m_args )\n+        {\n+            if(is_first) {\n+                is_first = false;\n+            } else {\n+                m_os << \", \";\n+            }\n+            AST::NodeVisitor::visit(arg);\n+        }\n+        m_os << \")\";\n+    }\n+    virtual void visit(AST::ExprNode_Loop& n) override {\n+        bool expr_root = m_expr_root;\n+        m_expr_root = false;\n+\n+        switch(n.m_type)\n+        {\n+        case AST::ExprNode_Loop::LOOP:\n+            m_os << \"loop\";\n+            break;\n+        case AST::ExprNode_Loop::WHILE:\n+            m_os << \"while \";\n+            AST::NodeVisitor::visit(n.m_cond);\n+            break;\n+        case AST::ExprNode_Loop::WHILELET:\n+            m_os << \"while let \";\n+            print_pattern(n.m_pattern, true);\n+            m_os << \" = \";\n+            AST::NodeVisitor::visit(n.m_cond);\n+            break;\n+        case AST::ExprNode_Loop::FOR:\n+            m_os << \"while for \";\n+            print_pattern(n.m_pattern, true);\n+            m_os << \" in \";\n+            AST::NodeVisitor::visit(n.m_cond);\n+            break;\n+        }\n+\n+        if( expr_root )\n+        {\n+            m_os << \"\\n\";\n+            m_os << indent();\n+        }\n+        else\n+        {\n+            m_os << \" \";\n+        }\n+\n+        AST::NodeVisitor::visit(n.m_code);\n+    }\n+    virtual void visit(AST::ExprNode_Match& n) override {\n+        bool expr_root = m_expr_root;\n+        m_expr_root = false;\n+        m_os << \"match \";\n+        AST::NodeVisitor::visit(n.m_val);\n+\n+        if(expr_root)\n+        {\n+            m_os << \"\\n\";\n+            m_os << indent() << \"{\\n\";\n+        }\n+        else\n+        {\n+            m_os << \" {\\n\";\n+            inc_indent();\n+        }\n+\n+        for( auto& arm : n.m_arms )\n+        {\n+            m_os << indent();\n+            bool is_first = true;\n+            for( const auto& pat : arm.m_patterns ) {\n+                if(!is_first)\n+                    m_os << \"|\";\n+                is_first = false;\n+                print_pattern(pat, true);\n+            }\n+            if( arm.m_cond )\n+            {\n+                m_os << \" if \";\n+                AST::NodeVisitor::visit(arm.m_cond);\n+            }\n+            m_os << \" => \";\n+            // Increase indent, but don't print. Causes nested blocks to be indented above the match\n+            inc_indent();\n+            AST::NodeVisitor::visit(arm.m_code);\n+            dec_indent();\n+            m_os << \",\\n\";\n+        }\n+\n+        if(expr_root)\n+        {\n+            m_os << indent() << \"}\";\n+        }\n+        else\n+        {\n+            m_os << indent() << \"}\";\n+            dec_indent();\n+        }\n+    }\n+    virtual void visit(AST::ExprNode_If& n) override {\n+        bool expr_root = m_expr_root;\n+        m_expr_root = false;\n+        m_os << \"if \";\n+        AST::NodeVisitor::visit(n.m_cond);\n+\n+        visit_if_common(expr_root, n.m_true, n.m_false);\n+    }\n+    virtual void visit(AST::ExprNode_IfLet& n) override {\n+        bool expr_root = m_expr_root;\n+        m_expr_root = false;\n+        m_os << \"if let \";\n+        print_pattern(n.m_pattern, true);\n+        m_os << \" = \";\n+        AST::NodeVisitor::visit(n.m_value);\n+\n+        visit_if_common(expr_root, n.m_true, n.m_false);\n+    }\n+    void visit_if_common(bool expr_root, const ::std::unique_ptr<AST::ExprNode>& tv, const ::std::unique_ptr<AST::ExprNode>& fv)\n+    {\n+        if( expr_root )\n+        {\n+            m_os << \"\\n\";\n+            m_os << indent();\n+        }\n+        else\n+        {\n+            m_os << \" \";\n+        }\n+\n+        bool is_block = (dynamic_cast<const AST::ExprNode_Block*>(&*tv) != nullptr);\n+        if( !is_block ) m_os << \"{ \";\n+        AST::NodeVisitor::visit(tv);\n+        if( !is_block ) m_os << \" }\";\n+        if(fv.get())\n+        {\n+            if( expr_root )\n+            {\n+                m_os << \"\\n\";\n+                m_os << indent() << \"else\";\n+                // handle chained if statements nicely\n+                if( IS(*fv, AST::ExprNode_If) || IS(*fv, AST::ExprNode_IfLet) ) {\n+                    m_expr_root = true;\n+                    m_os << \" \";\n+                }\n+                else\n+                    m_os << \"\\n\" << indent();\n+            }\n+            else\n+            {\n+                m_os << \" else \";\n+            }\n+            AST::NodeVisitor::visit(fv);\n+        }\n+    }\n+    virtual void visit(AST::ExprNode_Closure& n) override {\n+        m_expr_root = false;\n+        m_os << \"|\";\n+        bool is_first = true;\n+        for( const auto& arg : n.m_args )\n+        {\n+            if(!is_first)   m_os << \", \";\n+            is_first = false;\n+            print_pattern(arg.first, false);\n+            m_os << \": \";\n+            print_type(arg.second);\n+        }\n+        m_os << \"| ->\";\n+        print_type(n.m_return);\n+        m_os << \" \";\n+        AST::NodeVisitor::visit(n.m_code);\n+    }\n+    virtual void visit(AST::ExprNode_Integer& n) override {\n+        m_expr_root = false;\n+        switch(n.m_datatype)\n+        {\n+        case CORETYPE_INVAL:\n+            m_os << \"0x\" << ::std::hex << n.m_value << ::std::dec << \"_/*INVAL*/\";\n+            break;\n+        case CORETYPE_BOOL:\n+        case CORETYPE_STR:\n+            m_os << \"0x\" << ::std::hex << n.m_value << ::std::dec << \"_/*bool/str*/\";\n+            break;\n+        case CORETYPE_CHAR:\n+            m_os << \"'\\\\u{\" << ::std::hex << n.m_value << ::std::dec << \"}'\";\n+            break;\n+        case CORETYPE_F32:\n+        case CORETYPE_F64:\n+            break;\n+        case CORETYPE_U8:\n+        case CORETYPE_U16:\n+        case CORETYPE_U32:\n+        case CORETYPE_U64:\n+        case CORETYPE_U128:\n+        case CORETYPE_UINT:\n+        case CORETYPE_ANY:\n+            m_os << \"0x\" << ::std::hex << n.m_value << ::std::dec;\n+            break;\n+        case CORETYPE_I8:\n+        case CORETYPE_I16:\n+        case CORETYPE_I32:\n+        case CORETYPE_I64:\n+        case CORETYPE_I128:\n+        case CORETYPE_INT:\n+            m_os << (int64_t)n.m_value;\n+            break;\n+        }\n+    }\n+    virtual void visit(AST::ExprNode_Float& n) override {\n+        m_expr_root = false;\n+        switch(n.m_datatype)\n+        {\n+        case CORETYPE_ANY:\n+        case CORETYPE_F32:\n+        case CORETYPE_F64:\n+            m_os.precision(10);\n+            m_os << n.m_value;\n+            break;\n+        default:\n+            break;\n+        }\n+    }\n+    virtual void visit(AST::ExprNode_Bool& n) override {\n+        m_expr_root = false;\n+        if( n.m_value )\n+            m_os << \"true\";\n+        else\n+            m_os << \"false\";\n+    }\n+    virtual void visit(AST::ExprNode_String& n) override {\n+        m_expr_root = false;\n+        m_os << \"\\\"\" << n.m_value << \"\\\"\";\n+    }\n+    virtual void visit(AST::ExprNode_ByteString& n) override {\n+        m_expr_root = false;\n+        m_os << \"b\\\"\" << n.m_value << \"\\\"\";\n+    }\n+\n+    virtual void visit(AST::ExprNode_StructLiteral& n) override {\n+        m_expr_root = false;\n+        m_os << n.m_path << \" {\\n\";\n+        inc_indent();\n+        for( const auto& i : n.m_values )\n+        {\n+            // TODO: Attributes\n+            m_os << indent() << i.name << \": \";\n+            AST::NodeVisitor::visit(i.value);\n+            m_os << \",\\n\";\n+        }\n+        if( n.m_base_value.get() )\n+        {\n+            m_os << indent() << \".. \";\n+            AST::NodeVisitor::visit(n.m_base_value);\n+            m_os << \"\\n\";\n+        }\n+        m_os << indent() << \"}\";\n+        dec_indent();\n+    }\n+    virtual void visit(AST::ExprNode_Array& n) override {\n+        m_expr_root = false;\n+        m_os << \"[\";\n+        if( n.m_size.get() )\n+        {\n+            AST::NodeVisitor::visit(n.m_values[0]);\n+            m_os << \"; \";\n+            AST::NodeVisitor::visit(n.m_size);\n+        }\n+        else {\n+            for( auto& item : n.m_values )\n+            {\n+                AST::NodeVisitor::visit(item);\n+                m_os << \", \";\n+            }\n+        }\n+        m_os << \"]\";\n+    }\n+    virtual void visit(AST::ExprNode_Tuple& n) override {\n+        m_expr_root = false;\n+        m_os << \"(\";\n+        for( auto& item : n.m_values )\n+        {\n+            AST::NodeVisitor::visit(item);\n+            m_os << \", \";\n+        }\n+        m_os << \")\";\n+    }\n+    virtual void visit(AST::ExprNode_NamedValue& n) override {\n+        m_expr_root = false;\n+        m_os << n.m_path;\n+    }\n+    virtual void visit(AST::ExprNode_Field& n) override {\n+        m_expr_root = false;\n+        WRAPIF( n.m_obj\n+            , AST::ExprNode_Deref, AST::ExprNode_UniOp\n+            , AST::ExprNode_Cast, AST::ExprNode_BinOp, AST::ExprNode_Assign\n+            , AST::ExprNode_Match, AST::ExprNode_If, AST::ExprNode_IfLet, AST::ExprNode_Match\n+            );\n+        m_os << \".\" << n.m_name;\n+    }\n+    virtual void visit(AST::ExprNode_Index& n) override {\n+        m_expr_root = false;\n+        WRAPIF( n.m_obj\n+            , AST::ExprNode_Deref, AST::ExprNode_UniOp\n+            , AST::ExprNode_Cast, AST::ExprNode_BinOp, AST::ExprNode_Assign\n+            , AST::ExprNode_Match, AST::ExprNode_If, AST::ExprNode_IfLet, AST::ExprNode_Match\n+            );\n+        m_os << \"[\";\n+        AST::NodeVisitor::visit(n.m_idx);\n+        m_os << \"]\";\n+    }\n+    virtual void visit(AST::ExprNode_Deref& n) override {\n+        m_expr_root = false;\n+        m_os << \"*(\";\n+        AST::NodeVisitor::visit(n.m_value);\n+        m_os << \")\";\n+    }\n+    virtual void visit(AST::ExprNode_Cast& n) override {\n+        m_expr_root = false;\n+        AST::NodeVisitor::visit(n.m_value);\n+        m_os << \" as \" << n.m_type;\n+    }\n+    virtual void visit(AST::ExprNode_TypeAnnotation& n) override {\n+        m_expr_root = false;\n+        AST::NodeVisitor::visit(n.m_value);\n+        m_os << \": \" << n.m_type;\n+    }\n+    virtual void visit(AST::ExprNode_BinOp& n) override {\n+        m_expr_root = false;\n+        if( IS(*n.m_left, AST::ExprNode_BinOp) && dynamic_cast<AST::ExprNode_BinOp&>(*n.m_left).m_type == n.m_type ) {\n+            AST::NodeVisitor::visit(n.m_left);\n+        }\n+        else {\n+            WRAPIF(n.m_left\n+                , AST::ExprNode_Cast, AST::ExprNode_BinOp\n+                );\n+        }\n+        m_os << \" \";\n+        switch(n.m_type)\n+        {\n+        case AST::ExprNode_BinOp::CMPEQU: m_os << \"==\"; break;\n+        case AST::ExprNode_BinOp::CMPNEQU:m_os << \"!=\"; break;\n+        case AST::ExprNode_BinOp::CMPLT:  m_os << \"<\";  break;\n+        case AST::ExprNode_BinOp::CMPLTE: m_os << \"<=\"; break;\n+        case AST::ExprNode_BinOp::CMPGT:  m_os << \">\";  break;\n+        case AST::ExprNode_BinOp::CMPGTE: m_os << \">=\"; break;\n+        case AST::ExprNode_BinOp::BOOLAND:m_os << \"&&\"; break;\n+        case AST::ExprNode_BinOp::BOOLOR: m_os << \"||\"; break;\n+        case AST::ExprNode_BinOp::BITAND: m_os << \"&\";  break;\n+        case AST::ExprNode_BinOp::BITOR:  m_os << \"|\";  break;\n+        case AST::ExprNode_BinOp::BITXOR: m_os << \"^\";  break;\n+        case AST::ExprNode_BinOp::SHL:    m_os << \"<<\"; break;\n+        case AST::ExprNode_BinOp::SHR:    m_os << \">>\"; break;\n+        case AST::ExprNode_BinOp::MULTIPLY: m_os << \"*\"; break;\n+        case AST::ExprNode_BinOp::DIVIDE:   m_os << \"/\"; break;\n+        case AST::ExprNode_BinOp::MODULO:   m_os << \"%\"; break;\n+        case AST::ExprNode_BinOp::ADD:   m_os << \"+\"; break;\n+        case AST::ExprNode_BinOp::SUB:   m_os << \"-\"; break;\n+        case AST::ExprNode_BinOp::RANGE: m_os << \"..\"; break;\n+        case AST::ExprNode_BinOp::RANGE_INC: m_os << \"...\"; break;\n+        case AST::ExprNode_BinOp::PLACE_IN: m_os << \"<-\"; break;\n+        }\n+        m_os << \" \";\n+        if( IS(*n.m_right, AST::ExprNode_BinOp) && dynamic_cast<AST::ExprNode_BinOp&>(*n.m_right).m_type != n.m_type ) {\n+            paren_wrap(n.m_right);\n+        }\n+        else\n+            AST::NodeVisitor::visit(n.m_right);\n+    }\n+    virtual void visit(AST::ExprNode_UniOp& n) override {\n+        m_expr_root = false;\n+        switch(n.m_type)\n+        {\n+        case AST::ExprNode_UniOp::NEGATE:   m_os << \"-\";    break;\n+        case AST::ExprNode_UniOp::INVERT:   m_os << \"!\";    break;\n+        case AST::ExprNode_UniOp::BOX:      m_os << \"box \";    break;\n+        case AST::ExprNode_UniOp::REF:    m_os << \"&\";    break;\n+        case AST::ExprNode_UniOp::REFMUT: m_os << \"&mut \";    break;\n+        case AST::ExprNode_UniOp::QMARK: break;\n+        }\n+\n+        if( IS(*n.m_value, AST::ExprNode_BinOp) )\n+            m_os << \"(\";\n+        AST::NodeVisitor::visit(n.m_value);\n+        if( IS(*n.m_value, AST::ExprNode_BinOp) )\n+            m_os << \")\";\n+        switch(n.m_type)\n+        {\n+        case AST::ExprNode_UniOp::QMARK: m_os << \"?\"; break;\n+        default:    break;\n+        }\n+    }\n+\n+\n+private:\n+    void paren_wrap(::std::unique_ptr<AST::ExprNode>& node) {\n+        m_os << \"(\";\n+        AST::NodeVisitor::visit(node);\n+        m_os << \")\";\n+    }\n+\n+    void print_attrs(const AST::AttributeList& attrs);\n+    void print_params(const AST::GenericParams& params);\n+    void print_bounds(const AST::GenericParams& params);\n+    void print_pattern_tuple(const AST::Pattern::TuplePat& v, bool is_refutable);\n+    void print_pattern(const AST::Pattern& p, bool is_refutable);\n+    void print_type(const TypeRef& t);\n+\n+    void inc_indent();\n+    RepeatLitStr indent();\n+    void dec_indent();\n+};\n+\n+void Dump_Rust(const char *filename, const AST::Crate& crate)\n+{\n+    ::std::ofstream os(filename);\n+    RustPrinter printer(os);\n+    printer.handle_module(crate.root_module());\n+}\n+\n+void RustPrinter::print_attrs(const AST::AttributeList& attrs)\n+{\n+    for(const auto& a : attrs.m_items)\n+    {\n+        m_os << indent() << \"#[\" << a << \"]\\n\";\n+    }\n+}\n+\n+void RustPrinter::handle_module(const AST::Module& mod)\n+{\n+    bool need_nl = true;\n+\n+    for( const auto& i : mod.items() )\n+    {\n+        if( !i.data.is_Use() )  continue ;\n+        const auto& i_data = i.data.as_Use();\n+        //if(need_nl) {\n+        //    m_os << \"\\n\";\n+        //    need_nl = false;\n+        //}\n+        if( i_data.path == AST::Path() ) {\n+            continue ;\n+        }\n+        m_os << indent() << (i.is_pub ? \"pub \" : \"\") << \"use \" << i_data;\n+        if( i.name == \"\" )\n+        {\n+            m_os << \"::*\";\n+        }\n+        else if( i_data.path.nodes().back().name() != i.name )\n+        {\n+            m_os << \" as \" << i.name;\n+        }\n+        m_os << \";\\n\";\n+    }\n+    need_nl = true;\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Crate() )    continue ;\n+        const auto& e = item.data.as_Crate();\n+\n+        print_attrs(item.data.attrs);\n+        m_os << indent() << \"extern crate \\\"\" << e.name << \"\\\" as \" << item.name << \";\\n\";\n+    }\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_ExternBlock() )    continue ;\n+        const auto& e = item.data.as_ExternBlock();\n+\n+        print_attrs(item.data.attrs);\n+        m_os << indent() << \"extern \\\"\" << e.abi() << \"\\\" {}\\n\";\n+    }\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Module() )    continue ;\n+        const auto& e = item.data.as_Module();\n+\n+        m_os << \"\\n\";\n+        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"mod \" << item.name << \"\\n\";\n+        m_os << indent() << \"{\\n\";\n+        inc_indent();\n+        handle_module(e);\n+        dec_indent();\n+        m_os << indent() << \"}\\n\";\n+        m_os << \"\\n\";\n+    }\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Type() )    continue ;\n+        const auto& e = item.data.as_Type();\n+\n+        if(need_nl) {\n+            m_os << \"\\n\";\n+            need_nl = false;\n+        }\n+        print_attrs(item.data.attrs);\n+        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"type \" << item.name;\n+        print_params(e.params());\n+        m_os << \" = \" << e.type();\n+        print_bounds(e.params());\n+        m_os << \";\\n\";\n+    }\n+    need_nl = true;\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Struct() )    continue ;\n+        const auto& e = item.data.as_Struct();\n+\n+        m_os << \"\\n\";\n+        print_attrs(item.data.attrs);\n+        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"struct \" << item.name;\n+        handle_struct(e);\n+    }\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Enum() )    continue ;\n+        const auto& e = item.data.as_Enum();\n+\n+        m_os << \"\\n\";\n+        print_attrs(item.data.attrs);\n+        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"enum \" << item.name;\n+        handle_enum(e);\n+    }\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Trait() )    continue ;\n+        const auto& e = item.data.as_Trait();\n+\n+        m_os << \"\\n\";\n+        print_attrs(item.data.attrs);\n+        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"trait \" << item.name;\n+        handle_trait(e);\n+    }\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Static() )    continue ;\n+        const auto& e = item.data.as_Static();\n+\n+        if(need_nl) {\n+            m_os << \"\\n\";\n+            need_nl = false;\n+        }\n+        print_attrs(item.data.attrs);\n+        m_os << indent() << (item.is_pub ? \"pub \" : \"\");\n+        switch( e.s_class() )\n+        {\n+        case AST::Static::CONST:  m_os << \"const \";   break;\n+        case AST::Static::STATIC: m_os << \"static \";   break;\n+        case AST::Static::MUT:    m_os << \"static mut \";   break;\n+        }\n+        m_os << item.name << \": \" << e.type() << \" = \";\n+        e.value().visit_nodes(*this);\n+        m_os << \";\\n\";\n+    }\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Function() )    continue ;\n+        const auto& e = item.data.as_Function();\n+\n+        m_os << \"\\n\";\n+        print_attrs(item.data.attrs);\n+        handle_function(item.is_pub, item.name, e);\n+    }\n+\n+    for( const auto& item : mod.items() )\n+    {\n+        if( !item.data.is_Impl() )    continue ;\n+        const auto& i = item.data.as_Impl();\n+\n+        m_os << \"\\n\";\n+        m_os << indent() << \"impl\";\n+        print_params(i.def().params());\n+        if( i.def().trait().ent != AST::Path() )\n+        {\n+                m_os << \" \" << i.def().trait().ent << \" for\";\n+        }\n+        m_os << \" \" << i.def().type() << \"\\n\";\n+\n+        print_bounds(i.def().params());\n+        m_os << indent() << \"{\\n\";\n+        inc_indent();\n+        for( const auto& it : i.items() )\n+        {\n+            TU_MATCH_DEF(AST::Item, (*it.data), (e),\n+            (\n+                throw ::std::runtime_error(FMT(\"Unexpected item type in impl block - \" << it.data->tag_str()));\n+                ),\n+            (None,\n+                // Ignore, it's been deleted by #[cfg]\n+                ),\n+            (MacroInv,\n+                // TODO: Dump macro invocations\n+                ),\n+            (Static,\n+                m_os << indent();\n+                switch(e.s_class())\n+                {\n+                case ::AST::Static::CONST:  m_os << \"const \";   break;\n+                case ::AST::Static::STATIC: m_os << \"static \";  break;\n+                case ::AST::Static::MUT:    m_os << \"static mut \";  break;\n+                }\n+                m_os << it.name << \": \" << e.type() << \" = \";\n+                e.value().visit_nodes(*this);\n+                m_os << \";\\n\";\n+                ),\n+            (Type,\n+                m_os << indent() << \"type \" << it.name << \" = \" << e.type() << \";\\n\";\n+                ),\n+            (Function,\n+                handle_function(it.is_pub, it.name, e);\n+                )\n+            )\n+        }\n+        dec_indent();\n+        m_os << indent() << \"}\\n\";\n+    }\n+}\n+\n+void RustPrinter::print_params(const AST::GenericParams& params)\n+{\n+    if( params.ty_params().size() > 0 || params.lft_params().size() > 0 )\n+    {\n+        bool is_first = true;\n+        m_os << \"<\";\n+        // Lifetimes\n+        for( const auto& p : params.lft_params() )\n+        {\n+            if( !is_first )\n+                m_os << \", \";\n+            m_os << \"'\" << p;\n+            is_first = false;\n+        }\n+        // Types\n+        for( const auto& p : params.ty_params() )\n+        {\n+            if( !is_first )\n+                m_os << \", \";\n+            m_os << p.name();\n+            if( !p.get_default().is_wildcard() )\n+                m_os << \" = \" << p.get_default();\n+            is_first = false;\n+        }\n+        m_os << \">\";\n+    }\n+}\n+\n+void RustPrinter::print_bounds(const AST::GenericParams& params)\n+{\n+    if( params.bounds().size() )\n+    {\n+        m_os << indent() << \"where\\n\";\n+        inc_indent();\n+        bool is_first = true;\n+\n+        for( const auto& b : params.bounds() )\n+        {\n+            if( !is_first )\n+                m_os << \",\\n\";\n+            is_first = false;\n+\n+            m_os << indent();\n+            TU_MATCH(AST::GenericBound, (b), (ent),\n+            (None,\n+                m_os << \"/*-*/\";\n+                ),\n+            (Lifetime,\n+                m_os << \"'\" << ent.test << \": '\" << ent.bound;\n+                ),\n+            (TypeLifetime,\n+                m_os << ent.type << \": '\" << ent.bound;\n+                ),\n+            (IsTrait,\n+                m_os << ent.outer_hrbs << ent.type << \": \" << ent.inner_hrbs << ent.trait;\n+                ),\n+            (MaybeTrait,\n+                m_os << ent.type << \": ?\" << ent.trait;\n+                ),\n+            (NotTrait,\n+                m_os << ent.type << \": !\" << ent.trait;\n+                ),\n+            (Equality,\n+                m_os << ent.type << \": =\" << ent.replacement;\n+                )\n+            )\n+        }\n+        m_os << \"\\n\";\n+\n+        dec_indent();\n+    }\n+}\n+\n+void RustPrinter::print_pattern_tuple(const AST::Pattern::TuplePat& v, bool is_refutable)\n+{\n+    for(const auto& sp : v.start) {\n+        print_pattern(sp, is_refutable);\n+        m_os << \", \";\n+    }\n+    if( v.has_wildcard )\n+    {\n+        m_os << \".., \";\n+        for(const auto& sp : v.end) {\n+            print_pattern(sp, is_refutable);\n+            m_os << \", \";\n+        }\n+    }\n+}\n+void RustPrinter::print_pattern(const AST::Pattern& p, bool is_refutable)\n+{\n+    if( p.binding().is_valid() ) {\n+        if( p.binding().m_mutable )\n+            m_os << \"mut \";\n+        switch(p.binding().m_type)\n+        {\n+        case ::AST::PatternBinding::Type::MOVE:\n+            break;\n+        case ::AST::PatternBinding::Type::REF:\n+            m_os << \"ref \";\n+            break;\n+        case ::AST::PatternBinding::Type::MUTREF:\n+            m_os << \"ref mut \";\n+            break;\n+        }\n+        m_os << p.binding().m_name << \"/*\"<<p.binding().m_slot<<\"*/\";\n+        // If binding is irrefutable, and would be binding against a wildcard, just emit the name\n+        if( !is_refutable && p.data().is_Any() )\n+        {\n+            return ;\n+        }\n+        m_os << \" @ \";\n+    }\n+    TU_MATCH(AST::Pattern::Data, (p.data()), (v),\n+    (Any,\n+        m_os << \"_\";\n+        ),\n+    (MaybeBind,\n+        m_os << \"_ /*?*/\";\n+        ),\n+    (Macro,\n+        m_os << *v.inv;\n+        ),\n+    (Box, {\n+        const auto& v = p.data().as_Box();\n+        m_os << \"& \";\n+        print_pattern(*v.sub, is_refutable);\n+        }),\n+    (Ref, {\n+        const auto& v = p.data().as_Ref();\n+        if(v.mut)\n+            m_os << \"&mut \";\n+        else\n+            m_os << \"& \";\n+        print_pattern(*v.sub, is_refutable);\n+        }),\n+    (Value,\n+        m_os << v.start;\n+        if( ! v.end.is_Invalid() ) {\n+            m_os << \" ... \" << v.end;\n+        }\n+        ),\n+    (StructTuple,\n+        m_os << v.path << \"(\";\n+        this->print_pattern_tuple(v.tup_pat, is_refutable);\n+        m_os << \")\";\n+        ),\n+    (Struct, {\n+        const auto& v = p.data().as_Struct();\n+        m_os << v.path << \"(\";\n+        for(const auto& sp : v.sub_patterns) {\n+            m_os << sp.first << \": \";\n+            print_pattern(sp.second, is_refutable);\n+            m_os << \",\";\n+        }\n+        m_os << \")\";\n+        }),\n+    (Tuple,\n+        m_os << \"(\";\n+        this->print_pattern_tuple(v, is_refutable);\n+        m_os << \")\";\n+        ),\n+    (Slice,\n+        m_os << \"[\";\n+        m_os << v.sub_pats;\n+        m_os << \"]\";\n+        ),\n+    (SplitSlice,\n+        m_os << \"[\";\n+        bool needs_comma = false;\n+        if(v.leading.size()) {\n+            m_os << v.leading;\n+            m_os << \", \";\n+        }\n+\n+        if(v.extra_bind.is_valid())\n+        {\n+            const auto& b = v.extra_bind;\n+            if( b.m_mutable )\n+                m_os << \"mut \";\n+            switch(b.m_type)\n+            {\n+            case ::AST::PatternBinding::Type::MOVE:\n+                break;\n+            case ::AST::PatternBinding::Type::REF:\n+                m_os << \"ref \";\n+                break;\n+            case ::AST::PatternBinding::Type::MUTREF:\n+                m_os << \"ref mut \";\n+                break;\n+            }\n+            m_os << b.m_name << \"/*\"<<b.m_slot<<\"*/\";\n+        }\n+        m_os << \"..\";\n+        needs_comma = true;\n+\n+        if(v.trailing.size()) {\n+            if( needs_comma ) {\n+                m_os << \", \";\n+            }\n+            m_os << v.trailing;\n+        }\n+        m_os << \"]\";\n+        )\n+    )\n+}\n+\n+void RustPrinter::print_type(const TypeRef& t)\n+{\n+    m_os << t;\n+}\n+\n+void RustPrinter::handle_struct(const AST::Struct& s)\n+{\n+    print_params(s.params());\n+\n+    TU_MATCH(AST::StructData, (s.m_data), (e),\n+    (Unit,\n+        m_os << \" /* unit-like */\\n\";\n+        print_bounds(s.params());\n+        m_os << indent() << \";\\n\";\n+        ),\n+    (Tuple,\n+        m_os << \"(\";\n+        for( const auto& i : e.ents )\n+            m_os << i.m_type << \", \";\n+        m_os << \")\\n\";\n+        print_bounds(s.params());\n+        m_os << indent() << \";\\n\";\n+        ),\n+    (Struct,\n+        m_os << \"\\n\";\n+        print_bounds(s.params());\n+\n+        m_os << indent() << \"{\\n\";\n+        inc_indent();\n+        for( const auto& i : e.ents )\n+        {\n+            m_os << indent() << (i.m_is_public ? \"pub \" : \"\") << i.m_name << \": \" << i.m_type.print_pretty() << \"\\n\";\n+        }\n+        dec_indent();\n+        m_os << indent() << \"}\\n\";\n+        )\n+    )\n+    m_os << \"\\n\";\n+}\n+\n+void RustPrinter::handle_enum(const AST::Enum& s)\n+{\n+    print_params(s.params());\n+    m_os << \"\\n\";\n+    print_bounds(s.params());\n+\n+    m_os << indent() << \"{\\n\";\n+    inc_indent();\n+    unsigned int idx = 0;\n+    for( const auto& i : s.variants() )\n+    {\n+        m_os << indent() << \"/*\"<<idx<<\"*/\" << i.m_name;\n+        TU_MATCH(AST::EnumVariantData, (i.m_data), (e),\n+        (Value,\n+            m_os << \" = \" << e.m_value;\n+            ),\n+        (Tuple,\n+            m_os << \"(\";\n+            for( const auto& t : e.m_sub_types )\n+                m_os << t.print_pretty() << \", \";\n+            m_os << \")\";\n+            ),\n+        (Struct,\n+            m_os << \"{\\n\";\n+            inc_indent();\n+            for( const auto& i : e.m_fields )\n+            {\n+                m_os << indent() << i.m_name << \": \" << i.m_type.print_pretty() << \"\\n\";\n+            }\n+            dec_indent();\n+            m_os << indent() << \"}\";\n+            )\n+        )\n+        m_os << \",\\n\";\n+        idx ++;\n+    }\n+    dec_indent();\n+    m_os << indent() << \"}\\n\";\n+    m_os << \"\\n\";\n+}\n+\n+void RustPrinter::handle_trait(const AST::Trait& s)\n+{\n+    print_params(s.params());\n+    m_os << \"\\n\";\n+    print_bounds(s.params());\n+\n+    m_os << indent() << \"{\\n\";\n+    inc_indent();\n+\n+    for( const auto& i : s.items() )\n+    {\n+        TU_MATCH_DEF(AST::Item, (i.data), (e),\n+        (\n+            ),\n+        (Type,\n+            m_os << indent() << \"type \" << i.name << \";\\n\";\n+            ),\n+        (Function,\n+            handle_function(false, i.name, e);\n+            )\n+        )\n+    }\n+\n+    dec_indent();\n+    m_os << indent() << \"}\\n\";\n+    m_os << \"\\n\";\n+}\n+\n+void RustPrinter::handle_function(bool is_pub, const ::std::string& name, const AST::Function& f)\n+{\n+    m_os << indent();\n+    m_os << (is_pub ? \"pub \" : \"\");\n+    if( f.is_const() )\n+        m_os << \"const \";\n+    if( f.is_unsafe() )\n+        m_os << \"unsafe \";\n+    if( f.abi() != ABI_RUST )\n+        m_os << \"extern \\\"\" << f.abi() << \"\\\" \";\n+    m_os << \"fn \" << name;\n+    print_params(f.params());\n+    m_os << \"(\";\n+    bool is_first = true;\n+    for( const auto& a : f.args() )\n+    {\n+        if( !is_first )\n+            m_os << \", \";\n+        print_pattern( a.first, false );\n+        m_os << \": \" << a.second.print_pretty();\n+        is_first = false;\n+    }\n+    m_os << \")\";\n+    if( !f.rettype().is_unit() )\n+    {\n+        m_os << \" -> \" << f.rettype().print_pretty();\n+    }\n+\n+    if( f.code().is_valid() )\n+    {\n+        m_os << \"\\n\";\n+        print_bounds(f.params());\n+\n+        m_os << indent();\n+        f.code().visit_nodes(*this);\n+        m_os << \"\\n\";\n+        //m_os << indent() << f.data.code() << \"\\n\";\n+    }\n+    else\n+    {\n+        print_bounds(f.params());\n+        m_os << \";\\n\";\n+    }\n+}\n+\n+void RustPrinter::inc_indent()\n+{\n+    m_indent_level ++;\n+}\n+RepeatLitStr RustPrinter::indent()\n+{\n+    return RepeatLitStr { \"    \", m_indent_level };\n+}\n+void RustPrinter::dec_indent()\n+{\n+    m_indent_level --;\n+}"}, {"sha": "1525ed1263a68622f6c1a2e90ff99de9e8eeff22", "filename": "gcc/rust/mrustc_parser/ast/expr.cpp", "status": "added", "additions": 625, "deletions": 0, "changes": 625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,625 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/expr.cpp\n+ * - AST Expression nodes\n+ */\n+#include \"expr.hpp\"\n+#include \"ast.hpp\"\n+\n+namespace AST {\n+\n+\n+Expr::Expr(unique_ptr<ExprNode> node):\n+    m_node(node.release())\n+{\n+}\n+Expr::Expr(ExprNode* node):\n+    m_node(node)\n+{\n+}\n+Expr::Expr():\n+    m_node(nullptr)\n+{\n+}\n+void Expr::visit_nodes(NodeVisitor& v)\n+{\n+    if( m_node )\n+    {\n+        m_node->visit(v);\n+    }\n+}\n+void Expr::visit_nodes(NodeVisitor& v) const\n+{\n+    if( m_node )\n+    {\n+        assert(v.is_const());\n+        //const_cast<const ExprNode*>(m_node.get())->visit(v);\n+        m_node->visit(v);\n+    }\n+}\n+\n+Expr Expr::clone() const\n+{\n+    if( m_node ) {\n+        return Expr( m_node->clone() );\n+    }\n+    else {\n+        return Expr();\n+    }\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const Expr& pat)\n+{\n+    if( pat.m_node.get() )\n+        return os << *pat.m_node;\n+    else\n+        return os << \"/* null */\";\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const ExprNode& node)\n+{\n+    assert( static_cast<const void*>(&node) != nullptr );\n+    node.print(os);\n+    return os;\n+}\n+ExprNode::~ExprNode() {\n+}\n+\n+#define NODE(class, _print, _clone)\\\n+    void class::visit(NodeVisitor& nv) { nv.visit(*this); } \\\n+    void class::print(::std::ostream& os) const _print \\\n+    ::std::unique_ptr<ExprNode> class::clone() const _clone\n+#define OPT_CLONE(node) (node.get() ? node->clone() : ::AST::ExprNodeP())\n+\n+namespace {\n+    static inline ExprNodeP mk_exprnodep(const Span& pos, AST::ExprNode* en) {\n+        en->set_span(pos);\n+        return ExprNodeP(en);\n+    }\n+    #define NEWNODE(type, ...)  mk_exprnodep(span(), new type(__VA_ARGS__))\n+}\n+\n+NODE(ExprNode_Block, {\n+    os << \"{\";\n+    for(const auto& n : m_nodes)\n+        os << *n << \";\";\n+    os << \"}\";\n+},{\n+    ::std::vector<ExprNodeP>    nodes;\n+    for(const auto& n : m_nodes)\n+        nodes.push_back( n->clone() );\n+    return NEWNODE(ExprNode_Block, m_is_unsafe, m_yields_final_value, mv$(nodes), m_local_mod);\n+})\n+\n+NODE(ExprNode_Macro, {\n+    os << m_name << \"!\";\n+    if( m_ident.size() > 0 )\n+    {\n+        os << \" \" << m_ident << \" \";\n+    }\n+    os << \"(\" << \" /*TODO*/ \" << \")\";\n+},{\n+    return NEWNODE(ExprNode_Macro, m_name, m_ident, m_tokens.clone());\n+})\n+\n+NODE(ExprNode_Asm, {\n+    os << \"asm!( \\\"\" << m_text << \"\\\"\";\n+    os << \" :\";\n+    for(const auto& v : m_output)\n+        os << \" \\\"\" << v.name << \"\\\" (\" << *v.value << \"),\";\n+    os << \" :\";\n+    for(const auto& v : m_input)\n+        os << \" \\\"\" << v.name << \"\\\" (\" << *v.value << \"),\";\n+    os << \" :\";\n+    for(const auto& v : m_clobbers)\n+        os << \" \\\"\" << v << \"\\\",\";\n+    os << \" :\";\n+    for(const auto& v : m_flags)\n+        os << \" \\\"\" << v << \"\\\",\";\n+    os << \" )\";\n+},{\n+    ::std::vector<ExprNode_Asm::ValRef> outputs;\n+    for(const auto& v : m_output)\n+        outputs.push_back( ExprNode_Asm::ValRef { v.name, v.value->clone() });\n+    ::std::vector<ExprNode_Asm::ValRef> inputs;\n+    for(const auto& v : m_input)\n+        inputs.push_back( ExprNode_Asm::ValRef { v.name, v.value->clone() });\n+    return NEWNODE(ExprNode_Asm, m_text, mv$(outputs), mv$(inputs), m_clobbers, m_flags);\n+})\n+\n+NODE(ExprNode_Flow, {\n+    switch(m_type)\n+    {\n+    case RETURN:    os << \"return\"; break;\n+    case BREAK:     os << \"break\"; break;\n+    case CONTINUE:  os << \"continue\"; break;\n+    }\n+    if(m_value)\n+        os << \" \" << *m_value;\n+},{\n+    return NEWNODE(ExprNode_Flow, m_type, m_target, m_value ? m_value->clone() : nullptr);\n+})\n+\n+\n+NODE(ExprNode_LetBinding, {\n+    os << \"let \" << m_pat << \": \" << m_type;\n+    if(m_value)\n+        os << \" = \" << *m_value;\n+},{\n+    return NEWNODE(ExprNode_LetBinding, m_pat.clone(), m_type.clone(), OPT_CLONE(m_value));\n+})\n+\n+NODE(ExprNode_Assign, {\n+    os << *m_slot << \" = \" << *m_value;\n+},{\n+    return NEWNODE(ExprNode_Assign, m_op, m_slot->clone(), m_value->clone());\n+})\n+\n+NODE(ExprNode_CallPath, {\n+    os << m_path << \"(\";\n+    for(const auto& a : m_args) {\n+        os << *a << \",\";\n+    }\n+    os << \")\";\n+},{\n+    ::std::vector<ExprNodeP>    args;\n+    for(const auto& a : m_args) {\n+        args.push_back( a->clone() );\n+    }\n+    return NEWNODE(ExprNode_CallPath, AST::Path(m_path), mv$(args));\n+})\n+\n+NODE(ExprNode_CallMethod, {\n+    os << \"(\" << *m_val << \").\" << m_method << \"(\";\n+    for(const auto& a : m_args) {\n+        os << *a << \",\";\n+    }\n+    os << \")\";\n+},{\n+    ::std::vector<ExprNodeP>    args;\n+    for(const auto& a : m_args) {\n+        args.push_back( a->clone() );\n+    }\n+    return NEWNODE(ExprNode_CallMethod, m_val->clone(), m_method, mv$(args));\n+})\n+\n+NODE(ExprNode_CallObject, {\n+    os << \"(\" << *m_val << \")(\";\n+    for(const auto& a : m_args) {\n+        os << *a << \",\";\n+    }\n+    os << \")\";\n+},{\n+    ::std::vector<ExprNodeP>    args;\n+    for(const auto& a : m_args) {\n+        args.push_back( a->clone() );\n+    }\n+    return NEWNODE(ExprNode_CallObject, m_val->clone(), mv$(args));\n+})\n+\n+NODE(ExprNode_Loop, {\n+    os << \"LOOP [\" << m_label << \"] \" << m_pattern;\n+    if(m_cond)\n+        os << \" in/= \" << *m_cond;\n+    os << \" \" << *m_code;\n+},{\n+    return NEWNODE(ExprNode_Loop, m_label, m_type, m_pattern.clone(), OPT_CLONE(m_cond), m_code->clone());\n+})\n+\n+NODE(ExprNode_Match, {\n+    os << \"match (\"<<*m_val<<\") {\";\n+    for(const auto& arm : m_arms)\n+    {\n+        for( const auto& pat : arm.m_patterns )\n+            os << \" \" << pat;\n+        if( arm.m_cond )\n+            os << \" if \" << *arm.m_cond;\n+\n+        os << \" => \" << *arm.m_code << \",\";\n+    }\n+    os << \"}\";\n+},{\n+    ::std::vector< ExprNode_Match_Arm>  arms;\n+    for(const auto& arm : m_arms) {\n+        ::std::vector< AST::Pattern>    patterns;\n+        for( const auto& pat : arm.m_patterns ) {\n+            patterns.push_back( pat.clone() );\n+        }\n+        arms.push_back( ExprNode_Match_Arm( mv$(patterns), OPT_CLONE(arm.m_cond), arm.m_code->clone() ) );\n+        arms.back().m_attrs = arm.m_attrs.clone();\n+    }\n+    return NEWNODE(ExprNode_Match, m_val->clone(), mv$(arms));\n+})\n+\n+NODE(ExprNode_If, {\n+    os << \"if \" << *m_cond << \" { \" << *m_true << \" }\";\n+    if(m_false)\n+        os << \" else { \" << *m_false << \" }\";\n+},{\n+    return NEWNODE(ExprNode_If, m_cond->clone(), m_true->clone(), OPT_CLONE(m_false));\n+})\n+NODE(ExprNode_IfLet, {\n+    os << \"if let \" << m_pattern << \" = (\" << *m_value << \") { \" << *m_true << \" }\";\n+    if(m_false) os << \" else { \" << *m_false << \" }\";\n+},{\n+    return NEWNODE(ExprNode_IfLet, m_pattern.clone(), m_value->clone(), m_true->clone(), OPT_CLONE(m_false));\n+})\n+\n+NODE(ExprNode_Integer, {\n+    if( m_datatype == CORETYPE_CHAR )\n+        os << \"'\\\\u{\" << ::std::hex << m_value << ::std::dec << \"}'\";\n+    else\n+    {\n+        os << m_value;\n+        if( m_datatype == CORETYPE_ANY )\n+            ;\n+        else\n+            os << \"_\" << coretype_name(m_datatype);\n+    }\n+},{\n+    return NEWNODE(ExprNode_Integer, m_value, m_datatype);\n+})\n+NODE(ExprNode_Float, {\n+    os << m_value << \"_\" << m_datatype;\n+},{\n+    return NEWNODE(ExprNode_Float, m_value, m_datatype);\n+})\n+NODE(ExprNode_Bool, {\n+    os << m_value;\n+},{\n+    return NEWNODE(ExprNode_Bool, m_value);\n+})\n+NODE(ExprNode_String, {\n+    os << \"\\\"\" << m_value << \"\\\"\";\n+},{\n+    return NEWNODE(ExprNode_String, m_value);\n+})\n+NODE(ExprNode_ByteString, {\n+    os << \"b\\\"\" << m_value << \"\\\"\";\n+},{\n+    return NEWNODE(ExprNode_ByteString, m_value);\n+})\n+\n+NODE(ExprNode_Closure, {\n+    if( m_is_move )\n+        os << \"move \";\n+    os << \"|\";\n+    for(const auto& a : m_args)\n+    {\n+        os << a.first << \": \" << a.second << \",\";\n+    }\n+    os << \"|\";\n+    os << \"->\" << m_return;\n+    os << \" \" << *m_code;\n+},{\n+    ExprNode_Closure::args_t    args;\n+    for(const auto& a : m_args) {\n+        args.push_back( ::std::make_pair(a.first.clone(), a.second.clone()) );\n+    }\n+    return NEWNODE(ExprNode_Closure, mv$(args), m_return.clone(), m_code->clone(), m_is_move);\n+});\n+\n+NODE(ExprNode_StructLiteral, {\n+    os << m_path << \" { \";\n+    for(const auto& v : m_values)\n+    {\n+        os << v.name << \": \" << *v.value << \", \";\n+    }\n+    if(m_base_value)\n+    {\n+        os << \"..\" << *m_base_value;\n+    }\n+    os << \"}\";\n+},{\n+    ExprNode_StructLiteral::t_values    vals;\n+\n+    for(const auto& v : m_values) {\n+        vals.push_back({ v.attrs.clone(), v.name, v.value->clone() });\n+    }\n+\n+    return NEWNODE(ExprNode_StructLiteral, AST::Path(m_path), OPT_CLONE(m_base_value), mv$(vals) );\n+})\n+\n+NODE(ExprNode_Array, {\n+    os << \"[\";\n+    if( m_size.get() )\n+        os << *m_values[0] << \"; \" << *m_size;\n+    else\n+        for(const auto& a : m_values)\n+            os << *a << \",\";\n+    os << \"]\";\n+},{\n+    if( m_size.get() )\n+    {\n+        return NEWNODE(ExprNode_Array, m_values[0]->clone(), m_size->clone());\n+    }\n+    else\n+    {\n+        ::std::vector<ExprNodeP>    nodes;\n+        for(const auto& n : m_values)\n+            nodes.push_back( n->clone() );\n+        return NEWNODE(ExprNode_Array, mv$(nodes));\n+    }\n+})\n+\n+NODE(ExprNode_Tuple, {\n+    os << \"(\";\n+    for(const auto& a : m_values) {\n+        os << *a << \",\";\n+    }\n+    os << \")\";\n+},{\n+    ::std::vector<ExprNodeP>    nodes;\n+    for(const auto& n : m_values)\n+        nodes.push_back( n->clone() );\n+    return NEWNODE(ExprNode_Tuple, mv$(nodes));\n+})\n+\n+NODE(ExprNode_NamedValue, {\n+    os << m_path;\n+},{\n+    return NEWNODE(ExprNode_NamedValue, AST::Path(m_path));\n+})\n+\n+NODE(ExprNode_Field, {\n+    os << \"(\" << *m_obj << \").\" << m_name;\n+},{\n+    return NEWNODE(ExprNode_Field, m_obj->clone(), m_name);\n+})\n+\n+NODE(ExprNode_Index, {\n+    os << \"(\" << *m_obj << \")[\" << *m_idx << \"]\";\n+},{\n+    return NEWNODE(ExprNode_Index, m_obj->clone(), m_idx->clone());\n+})\n+\n+NODE(ExprNode_Deref, {\n+    os << \"*(\" << *m_value << \")\";\n+},{\n+    return NEWNODE(ExprNode_Deref, m_value->clone());\n+});\n+\n+NODE(ExprNode_Cast, {\n+    os << \"(\" << *m_value << \" as \" << m_type << \")\";\n+},{\n+    return NEWNODE(ExprNode_Cast, m_value->clone(), m_type.clone());\n+})\n+NODE(ExprNode_TypeAnnotation, {\n+    os << \"(\" << *m_value << \": \" << m_type << \")\";\n+},{\n+    return NEWNODE(ExprNode_TypeAnnotation, m_value->clone(), m_type.clone());\n+})\n+\n+NODE(ExprNode_BinOp, {\n+    if( m_type == RANGE_INC ) {\n+        os << \"(\";\n+        if( m_left ) {\n+            os << *m_left << \" \";\n+        }\n+        os << \"... \" << *m_right;\n+        os << \")\";\n+        return ;\n+    }\n+    if( m_type == RANGE ) {\n+        os << \"(\";\n+        if( m_left ) {\n+            os << *m_left;\n+        }\n+        os << \"..\";\n+        if( m_right ) {\n+            os << \" \" << *m_right;\n+        }\n+        os << \")\";\n+        return ;\n+    }\n+    os << \"(\" << *m_left << \" \";\n+    switch(m_type)\n+    {\n+    case CMPEQU:    os << \"==\"; break;\n+    case CMPNEQU:   os << \"!=\"; break;\n+    case CMPLT:     os << \"<\";  break;\n+    case CMPLTE:    os << \"<=\"; break;\n+    case CMPGT:     os << \">\";  break;\n+    case CMPGTE:    os << \">=\"; break;\n+    case BOOLAND:   os << \"&&\"; break;\n+    case BOOLOR:    os << \"||\"; break;\n+    case BITAND:    os << \"&\"; break;\n+    case BITOR:     os << \"|\"; break;\n+    case BITXOR:    os << \"^\"; break;\n+    case SHR:    os << \">>\"; break;\n+    case SHL:    os << \"<<\"; break;\n+    case MULTIPLY: os << \"*\"; break;\n+    case DIVIDE:   os << \"/\"; break;\n+    case MODULO:   os << \"%\"; break;\n+    case ADD:   os << \"+\"; break;\n+    case SUB:   os << \"-\"; break;\n+    case RANGE:   os << \"..\"; break;\n+    case RANGE_INC:   os << \"...\"; break;\n+    case PLACE_IN:  os << \"<-\"; break;\n+    }\n+    os << \" \" << *m_right << \")\";\n+},{\n+    return NEWNODE(ExprNode_BinOp, m_type, OPT_CLONE(m_left), OPT_CLONE(m_right));\n+})\n+\n+NODE(ExprNode_UniOp, {\n+    switch(m_type)\n+    {\n+    case NEGATE: os << \"(-\"; break;\n+    case INVERT: os << \"(!\"; break;\n+    case BOX: os << \"(box \"; break;\n+    case REF: os << \"(&\"; break;\n+    case REFMUT: os << \"(&mut \"; break;\n+    case QMARK: os << \"(\" << *m_value << \"?)\"; return;\n+    }\n+    os << *m_value << \")\";\n+},{\n+    return NEWNODE(ExprNode_UniOp, m_type, m_value->clone());\n+})\n+\n+\n+#define NV(type, actions)\\\n+    void NodeVisitorDef::visit(type& node) { /*DEBUG(\"DEF - \"#type);*/ actions }\n+//  void NodeVisitorDef::visit(const type& node) { DEBUG(\"DEF - \"#type\" (const)\"); actions }\n+\n+NV(ExprNode_Block, {\n+    //INDENT();\n+    for( auto& child : node.m_nodes )\n+        visit(child);\n+    //UNINDENT();\n+})\n+NV(ExprNode_Macro,\n+{\n+    BUG(node.span(), \"Hit unexpanded macro in expression - \" << node);\n+})\n+NV(ExprNode_Asm,\n+{\n+    for(auto& v : node.m_output)\n+        visit(v.value);\n+    for(auto& v : node.m_input)\n+        visit(v.value);\n+})\n+NV(ExprNode_Flow,\n+{\n+    visit(node.m_value);\n+})\n+NV(ExprNode_LetBinding,\n+{\n+    // TODO: Handle recurse into Let pattern?\n+    visit(node.m_value);\n+})\n+NV(ExprNode_Assign,\n+{\n+    INDENT();\n+    visit(node.m_slot);\n+    visit(node.m_value);\n+    UNINDENT();\n+})\n+NV(ExprNode_CallPath,\n+{\n+    INDENT();\n+    for( auto& arg : node.m_args )\n+        visit(arg);\n+    UNINDENT();\n+})\n+NV(ExprNode_CallMethod,\n+{\n+    INDENT();\n+    visit(node.m_val);\n+    for( auto& arg : node.m_args )\n+        visit(arg);\n+    UNINDENT();\n+})\n+NV(ExprNode_CallObject,\n+{\n+    INDENT();\n+    visit(node.m_val);\n+    for( auto& arg : node.m_args )\n+        visit(arg);\n+    UNINDENT();\n+})\n+NV(ExprNode_Loop,\n+{\n+    INDENT();\n+    visit(node.m_cond);\n+    visit(node.m_code);\n+    UNINDENT();\n+})\n+NV(ExprNode_Match,\n+{\n+    INDENT();\n+    visit(node.m_val);\n+    for( auto& arm : node.m_arms )\n+    {\n+        visit(arm.m_cond);\n+        visit(arm.m_code);\n+    }\n+    UNINDENT();\n+})\n+NV(ExprNode_If,\n+{\n+    INDENT();\n+    visit(node.m_cond);\n+    visit(node.m_true);\n+    visit(node.m_false);\n+    UNINDENT();\n+})\n+NV(ExprNode_IfLet,\n+{\n+    INDENT();\n+    visit(node.m_value);\n+    visit(node.m_true);\n+    visit(node.m_false);\n+    UNINDENT();\n+})\n+\n+NV(ExprNode_Integer, {(void)node;})\n+NV(ExprNode_Float, {(void)node;})\n+NV(ExprNode_Bool, {(void)node;})\n+NV(ExprNode_String, {(void)node;})\n+NV(ExprNode_ByteString, {(void)node;})\n+\n+NV(ExprNode_Closure,\n+{\n+    visit(node.m_code);\n+});\n+NV(ExprNode_StructLiteral,\n+{\n+    visit(node.m_base_value);\n+    for( auto& val : node.m_values )\n+        visit(val.value);\n+})\n+NV(ExprNode_Array,\n+{\n+    visit(node.m_size);\n+    for( auto& val : node.m_values )\n+        visit(val);\n+})\n+NV(ExprNode_Tuple,\n+{\n+    for( auto& val : node.m_values )\n+        visit(val);\n+})\n+NV(ExprNode_NamedValue,\n+{\n+    (void)node;\n+    // LEAF\n+})\n+\n+NV(ExprNode_Field,\n+{\n+    visit(node.m_obj);\n+})\n+NV(ExprNode_Index,\n+{\n+    visit(node.m_obj);\n+    visit(node.m_idx);\n+})\n+NV(ExprNode_Deref,\n+{\n+    visit(node.m_value);\n+})\n+NV(ExprNode_Cast,\n+{\n+    visit(node.m_value);\n+})\n+NV(ExprNode_TypeAnnotation,\n+{\n+    visit(node.m_value);\n+})\n+NV(ExprNode_BinOp,\n+{\n+    visit(node.m_left);\n+    visit(node.m_right);\n+})\n+NV(ExprNode_UniOp,\n+{\n+    visit(node.m_value);\n+})\n+#undef NV\n+\n+\n+};\n+"}, {"sha": "264b37e92a0a48f6901881123472689da8c21b34", "filename": "gcc/rust/mrustc_parser/ast/expr.hpp", "status": "added", "additions": 719, "deletions": 0, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,719 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/expr.hpp\n+ * - AST Expression Nodes\n+ */\n+#ifndef AST_EXPR_INCLUDED\n+#define AST_EXPR_INCLUDED\n+\n+#include <ostream>\n+#include <memory>   // unique_ptr\n+#include <vector>\n+\n+#include \"../parse/tokentree.hpp\"\n+#include \"types.hpp\"\n+#include \"pattern.hpp\"\n+#include \"attrs.hpp\"\n+\n+namespace AST {\n+\n+using ::std::unique_ptr;\n+\n+class NodeVisitor;\n+\n+class ExprNode\n+{\n+    AttributeList   m_attrs;\n+    Span    m_span;\n+public:\n+    virtual ~ExprNode() = 0;\n+\n+    virtual void visit(NodeVisitor& nv) = 0;\n+    virtual void print(::std::ostream& os) const = 0;\n+    virtual ::std::unique_ptr<ExprNode> clone() const = 0;\n+\n+    void set_span(Span s) { m_span = ::std::move(s); }\n+    const Span& span() const { return m_span; }\n+\n+    void set_attrs(AttributeList&& mi) {\n+        m_attrs = mv$(mi);\n+    }\n+    AttributeList& attrs() { return m_attrs; }\n+};\n+typedef ::std::unique_ptr<ExprNode> ExprNodeP;\n+\n+#define NODE_METHODS()  \\\n+    void visit(NodeVisitor& nv) override;\\\n+    void print(::std::ostream& os) const override; \\\n+    ::std::unique_ptr<ExprNode> clone() const override;\n+\n+struct ExprNode_Block:\n+    public ExprNode\n+{\n+    bool m_is_unsafe;\n+    bool m_yields_final_value;\n+    ::std::shared_ptr<AST::Module> m_local_mod;\n+    ::std::vector<ExprNodeP>    m_nodes;\n+\n+    ExprNode_Block(::std::vector<ExprNodeP> nodes={}):\n+        m_is_unsafe(false),\n+        m_yields_final_value(true),\n+        m_local_mod(),\n+        m_nodes( mv$(nodes) )\n+    {}\n+    ExprNode_Block(bool is_unsafe, bool yields_final_value, ::std::vector<ExprNodeP> nodes, ::std::shared_ptr<AST::Module> local_mod):\n+        m_is_unsafe(is_unsafe),\n+        m_yields_final_value(yields_final_value),\n+        m_local_mod( move(local_mod) ),\n+        m_nodes( move(nodes) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+\n+struct ExprNode_Macro:\n+    public ExprNode\n+{\n+    ::std::string   m_name;\n+    ::std::string   m_ident;\n+    ::TokenTree m_tokens;\n+\n+    ExprNode_Macro(::std::string name, ::std::string ident, ::TokenTree&& tokens):\n+        m_name(name),\n+        m_ident(ident),\n+        m_tokens( move(tokens) )\n+    {}\n+\n+    NODE_METHODS();\n+};\n+\n+// asm! macro\n+struct ExprNode_Asm:\n+    public ExprNode\n+{\n+    struct ValRef\n+    {\n+        ::std::string   name;\n+        unique_ptr<ExprNode>    value;\n+    };\n+\n+    ::std::string   m_text;\n+    ::std::vector<ValRef>   m_output;\n+    ::std::vector<ValRef>   m_input;\n+    ::std::vector<::std::string>    m_clobbers;\n+    ::std::vector<::std::string>    m_flags;\n+\n+    ExprNode_Asm(::std::string text, ::std::vector<ValRef> output, ::std::vector<ValRef> input, ::std::vector<::std::string> clobbers, ::std::vector<::std::string> flags):\n+        m_text( move(text) ),\n+        m_output( move(output) ),\n+        m_input( move(input) ),\n+        m_clobbers( move(clobbers) ),\n+        m_flags( move(flags) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+\n+// Break/Continue/Return\n+struct ExprNode_Flow:\n+    public ExprNode\n+{\n+    enum Type {\n+        RETURN,\n+        CONTINUE,\n+        BREAK,\n+    } m_type;\n+    ::std::string   m_target;\n+    unique_ptr<ExprNode>    m_value;\n+\n+    ExprNode_Flow(Type type, ::std::string target, unique_ptr<ExprNode>&& value):\n+        m_type(type),\n+        m_target( move(target) ),\n+        m_value( move(value) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+struct ExprNode_LetBinding:\n+    public ExprNode\n+{\n+    Pattern m_pat;\n+    TypeRef m_type;\n+    unique_ptr<ExprNode>    m_value;\n+\n+    ExprNode_LetBinding(Pattern pat, TypeRef type, unique_ptr<ExprNode>&& value):\n+        m_pat( move(pat) ),\n+        m_type( move(type) ),\n+        m_value( move(value) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+struct ExprNode_Assign:\n+    public ExprNode\n+{\n+    enum Operation {\n+        NONE,\n+        ADD, SUB,\n+        MUL, DIV, MOD,\n+        AND, OR , XOR,\n+        SHR, SHL,\n+    } m_op;\n+    unique_ptr<ExprNode>    m_slot;\n+    unique_ptr<ExprNode>    m_value;\n+\n+    ExprNode_Assign(): m_op(NONE) {}\n+    ExprNode_Assign(Operation op, unique_ptr<ExprNode>&& slot, unique_ptr<ExprNode>&& value):\n+        m_op(op),\n+        m_slot( move(slot) ),\n+        m_value( move(value) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+struct ExprNode_CallPath:\n+    public ExprNode\n+{\n+    Path    m_path;\n+    ::std::vector<unique_ptr<ExprNode>> m_args;\n+\n+    ExprNode_CallPath(Path&& path, ::std::vector<unique_ptr<ExprNode>>&& args):\n+        m_path( move(path) ),\n+        m_args( move(args) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+struct ExprNode_CallMethod:\n+    public ExprNode\n+{\n+    unique_ptr<ExprNode>    m_val;\n+    PathNode    m_method;\n+    ::std::vector<unique_ptr<ExprNode>> m_args;\n+\n+    ExprNode_CallMethod(unique_ptr<ExprNode> obj, PathNode method, ::std::vector<unique_ptr<ExprNode>> args):\n+        m_val( move(obj) ),\n+        m_method( move(method) ),\n+        m_args( move(args) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+// Call an object (Fn/FnMut/FnOnce)\n+struct ExprNode_CallObject:\n+    public ExprNode\n+{\n+    unique_ptr<ExprNode>    m_val;\n+    ::std::vector<unique_ptr<ExprNode>> m_args;\n+\n+    ExprNode_CallObject(unique_ptr<ExprNode>&& val, ::std::vector< unique_ptr<ExprNode> >&& args):\n+        m_val( move(val) ),\n+        m_args( move(args) )\n+    {\n+    }\n+    NODE_METHODS();\n+};\n+\n+struct ExprNode_Loop:\n+    public ExprNode\n+{\n+    enum Type {\n+        LOOP,\n+        WHILE,\n+        WHILELET,\n+        FOR,\n+    } m_type;\n+    ::std::string   m_label;\n+    AST::Pattern    m_pattern;\n+    unique_ptr<ExprNode>    m_cond; // if NULL, loop is a 'loop'\n+    unique_ptr<ExprNode>    m_code;\n+\n+    ExprNode_Loop(): m_type(LOOP) {}\n+    ExprNode_Loop(::std::string label, unique_ptr<ExprNode> code):\n+        m_type(LOOP),\n+        m_label( ::std::move(label) ),\n+        m_code( ::std::move(code) )\n+    {}\n+    ExprNode_Loop(::std::string label, unique_ptr<ExprNode> cond, unique_ptr<ExprNode> code):\n+        m_type(WHILE),\n+        m_label( ::std::move(label) ),\n+        m_cond( ::std::move(cond) ),\n+        m_code( ::std::move(code) )\n+    {}\n+    ExprNode_Loop(::std::string label, Type type, AST::Pattern pattern, unique_ptr<ExprNode> val, unique_ptr<ExprNode> code):\n+        m_type(type),\n+        m_label( ::std::move(label) ),\n+        m_pattern( ::std::move(pattern) ),\n+        m_cond( ::std::move(val) ),\n+        m_code( ::std::move(code) )\n+    {}\n+    NODE_METHODS();\n+};\n+\n+struct ExprNode_Match_Arm\n+{\n+    AttributeList   m_attrs;\n+    ::std::vector<Pattern>  m_patterns;\n+    unique_ptr<ExprNode>    m_cond;\n+\n+    unique_ptr<ExprNode>    m_code;\n+\n+\n+    ExprNode_Match_Arm()\n+    {}\n+    ExprNode_Match_Arm(::std::vector<Pattern> patterns, unique_ptr<ExprNode> cond, unique_ptr<ExprNode> code):\n+        m_patterns( mv$(patterns) ),\n+        m_cond( mv$(cond) ),\n+        m_code( mv$(code) )\n+    {}\n+};\n+\n+struct ExprNode_Match:\n+    public ExprNode\n+{\n+    unique_ptr<ExprNode>    m_val;\n+    ::std::vector<ExprNode_Match_Arm>  m_arms;\n+\n+    ExprNode_Match(unique_ptr<ExprNode> val, ::std::vector<ExprNode_Match_Arm> arms):\n+        m_val( ::std::move(val) ),\n+        m_arms( ::std::move(arms) )\n+    {\n+    }\n+    NODE_METHODS();\n+};\n+\n+struct ExprNode_If:\n+    public ExprNode\n+{\n+    unique_ptr<ExprNode>    m_cond;\n+    unique_ptr<ExprNode>    m_true;\n+    unique_ptr<ExprNode>    m_false;\n+\n+    ExprNode_If(unique_ptr<ExprNode>&& cond, unique_ptr<ExprNode>&& true_code, unique_ptr<ExprNode>&& false_code):\n+        m_cond( ::std::move(cond) ),\n+        m_true( ::std::move(true_code) ),\n+        m_false( ::std::move(false_code) )\n+    {\n+    }\n+    NODE_METHODS();\n+};\n+struct ExprNode_IfLet:\n+    public ExprNode\n+{\n+    AST::Pattern    m_pattern;\n+    unique_ptr<ExprNode>    m_value;\n+    unique_ptr<ExprNode>    m_true;\n+    unique_ptr<ExprNode>    m_false;\n+\n+    ExprNode_IfLet(AST::Pattern pattern, unique_ptr<ExprNode>&& cond, unique_ptr<ExprNode>&& true_code, unique_ptr<ExprNode>&& false_code):\n+        m_pattern( ::std::move(pattern) ),\n+        m_value( ::std::move(cond) ),\n+        m_true( ::std::move(true_code) ),\n+        m_false( ::std::move(false_code) )\n+    {\n+    }\n+    NODE_METHODS();\n+};\n+// Literal integer\n+struct ExprNode_Integer:\n+    public ExprNode\n+{\n+    enum eCoreType  m_datatype;\n+    uint64_t    m_value;\n+\n+    ExprNode_Integer(uint64_t value, enum eCoreType datatype):\n+        m_datatype(datatype),\n+        m_value(value)\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+// Literal float\n+struct ExprNode_Float:\n+    public ExprNode\n+{\n+    enum eCoreType  m_datatype;\n+    double  m_value;\n+\n+    ExprNode_Float(double value, enum eCoreType datatype):\n+        m_datatype(datatype),\n+        m_value(value)\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+// Literal boolean\n+struct ExprNode_Bool:\n+    public ExprNode\n+{\n+    bool    m_value;\n+\n+    ExprNode_Bool(bool value):\n+        m_value(value)\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+// Literal string\n+struct ExprNode_String:\n+    public ExprNode\n+{\n+    ::std::string   m_value;\n+\n+    ExprNode_String(::std::string value):\n+        m_value( ::std::move(value) )\n+    {}\n+\n+    NODE_METHODS();\n+};\n+// Literal byte string\n+struct ExprNode_ByteString:\n+    public ExprNode\n+{\n+    ::std::string   m_value;\n+\n+    ExprNode_ByteString(::std::string value):\n+        m_value( ::std::move(value) )\n+    {}\n+\n+    NODE_METHODS();\n+};\n+\n+// Closure / Lambda\n+struct ExprNode_Closure:\n+    public ExprNode\n+{\n+    typedef ::std::vector< ::std::pair<AST::Pattern, TypeRef> > args_t;\n+\n+    args_t  m_args;\n+    TypeRef m_return;\n+    unique_ptr<ExprNode>    m_code;\n+    bool m_is_move;\n+\n+    ExprNode_Closure(args_t args, TypeRef rv, unique_ptr<ExprNode> code, bool is_move):\n+        m_args( ::std::move(args) ),\n+        m_return( ::std::move(rv) ),\n+        m_code( ::std::move(code) ),\n+        m_is_move( is_move )\n+    {}\n+\n+    NODE_METHODS();\n+};\n+// Literal structure\n+struct ExprNode_StructLiteral:\n+    public ExprNode\n+{\n+    struct Ent {\n+        AttributeList   attrs;\n+        ::std::string   name;\n+        unique_ptr<ExprNode>    value;\n+    };\n+    typedef ::std::vector<Ent> t_values;\n+    Path    m_path;\n+    unique_ptr<ExprNode>    m_base_value;\n+    t_values    m_values;\n+\n+    ExprNode_StructLiteral(Path path, unique_ptr<ExprNode>&& base_value, t_values&& values ):\n+        m_path( move(path) ),\n+        m_base_value( move(base_value) ),\n+        m_values( move(values) )\n+    {}\n+\n+    NODE_METHODS();\n+};\n+// Array\n+struct ExprNode_Array:\n+    public ExprNode\n+{\n+    unique_ptr<ExprNode>    m_size; // if non-NULL, it's a sized array\n+    ::std::vector< unique_ptr<ExprNode> >   m_values;\n+\n+    ExprNode_Array(::std::vector< unique_ptr<ExprNode> > vals):\n+        m_values( ::std::move(vals) )\n+    {}\n+    ExprNode_Array(unique_ptr<ExprNode> val, unique_ptr<ExprNode> size):\n+        m_size( ::std::move(size) )\n+    {\n+        m_values.push_back( ::std::move(val) );\n+    }\n+\n+    NODE_METHODS();\n+};\n+// Tuple\n+struct ExprNode_Tuple:\n+    public ExprNode\n+{\n+    ::std::vector< unique_ptr<ExprNode> >   m_values;\n+\n+    ExprNode_Tuple(::std::vector< unique_ptr<ExprNode> > vals):\n+        m_values( ::std::move(vals) )\n+    {}\n+\n+    NODE_METHODS();\n+};\n+// Variable / Constant\n+struct ExprNode_NamedValue:\n+    public ExprNode\n+{\n+    Path    m_path;\n+\n+    ExprNode_NamedValue(Path&& path):\n+        m_path( ::std::move(path) )\n+    {\n+    }\n+    NODE_METHODS();\n+};\n+// Field dereference\n+struct ExprNode_Field:\n+    public ExprNode\n+{\n+    ::std::unique_ptr<ExprNode> m_obj;\n+    ::std::string   m_name;\n+\n+    ExprNode_Field(::std::unique_ptr<ExprNode>&& obj, ::std::string name):\n+        m_obj( ::std::move(obj) ),\n+        m_name( ::std::move(name) )\n+    {\n+    }\n+    NODE_METHODS();\n+};\n+struct ExprNode_Index:\n+    public ExprNode\n+{\n+    ::std::unique_ptr<ExprNode> m_obj;\n+    ::std::unique_ptr<ExprNode> m_idx;\n+\n+    ExprNode_Index(::std::unique_ptr<ExprNode> obj, ::std::unique_ptr<ExprNode> idx):\n+        m_obj( ::std::move(obj) ),\n+        m_idx( ::std::move(idx) )\n+    {}\n+\n+    NODE_METHODS();\n+};\n+\n+// Pointer dereference\n+struct ExprNode_Deref:\n+    public ExprNode\n+{\n+    ::std::unique_ptr<ExprNode>    m_value;\n+\n+    ExprNode_Deref(::std::unique_ptr<ExprNode> value):\n+        m_value( ::std::move(value) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+\n+// Type cast ('as')\n+struct ExprNode_Cast:\n+    public ExprNode\n+{\n+    unique_ptr<ExprNode>    m_value;\n+    TypeRef m_type;\n+\n+    ExprNode_Cast(unique_ptr<ExprNode>&& value, TypeRef&& dst_type):\n+        m_value( move(value) ),\n+        m_type( move(dst_type) )\n+    {\n+    }\n+    NODE_METHODS();\n+};\n+\n+// Type annotation (': _')\n+struct ExprNode_TypeAnnotation:\n+    public ExprNode\n+{\n+    unique_ptr<ExprNode>    m_value;\n+    TypeRef m_type;\n+\n+    ExprNode_TypeAnnotation(unique_ptr<ExprNode>&& value, TypeRef&& dst_type):\n+        m_value( move(value) ),\n+        m_type( move(dst_type) )\n+    {\n+    }\n+    NODE_METHODS();\n+};\n+\n+// Binary operation\n+struct ExprNode_BinOp:\n+    public ExprNode\n+{\n+    enum Type {\n+        CMPEQU,\n+        CMPNEQU,\n+        CMPLT,\n+        CMPLTE,\n+        CMPGT,\n+        CMPGTE,\n+\n+        RANGE,\n+        RANGE_INC,\n+        BOOLAND,\n+        BOOLOR,\n+\n+        BITAND,\n+        BITOR,\n+        BITXOR,\n+\n+        SHL,\n+        SHR,\n+\n+        MULTIPLY,\n+        DIVIDE,\n+        MODULO,\n+        ADD,\n+        SUB,\n+\n+        PLACE_IN,   // `in PLACE { expr }` or `PLACE <- expr`\n+    };\n+\n+    Type    m_type;\n+    ::std::unique_ptr<ExprNode> m_left;\n+    ::std::unique_ptr<ExprNode> m_right;\n+\n+    ExprNode_BinOp(Type type, ::std::unique_ptr<ExprNode> left, ::std::unique_ptr<ExprNode> right):\n+        m_type(type),\n+        m_left( ::std::move(left) ),\n+        m_right( ::std::move(right) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+\n+struct ExprNode_UniOp:\n+    public ExprNode\n+{\n+    enum Type {\n+        REF,    // '& <expr>'\n+        REFMUT, // '&mut <expr>'\n+        BOX,    // 'box <expr>'\n+        INVERT, // '!<expr>'\n+        NEGATE, // '-<expr>'\n+        QMARK, // '<expr>?'\n+    };\n+\n+    enum Type   m_type;\n+    ::std::unique_ptr<ExprNode> m_value;\n+\n+    ExprNode_UniOp(Type type, ::std::unique_ptr<ExprNode> value):\n+        m_type(type),\n+        m_value( ::std::move(value) )\n+    {\n+    }\n+\n+    NODE_METHODS();\n+};\n+\n+#undef NODE_METHODS\n+\n+class NodeVisitor\n+{\n+public:\n+    virtual ~NodeVisitor() = default;\n+    inline void visit(const unique_ptr<ExprNode>& cnode) {\n+        if(cnode.get())\n+            cnode->visit(*this);\n+    }\n+    virtual bool is_const() const { return false; }\n+\n+    #define NT(nt) \\\n+        virtual void visit(nt& node) = 0/*; \\\n+        virtual void visit(const nt& node) = 0*/\n+    NT(ExprNode_Block);\n+    NT(ExprNode_Macro);\n+    NT(ExprNode_Asm);\n+    NT(ExprNode_Flow);\n+    NT(ExprNode_LetBinding);\n+    NT(ExprNode_Assign);\n+    NT(ExprNode_CallPath);\n+    NT(ExprNode_CallMethod);\n+    NT(ExprNode_CallObject);\n+    NT(ExprNode_Loop);\n+    NT(ExprNode_Match);\n+    NT(ExprNode_If);\n+    NT(ExprNode_IfLet);\n+\n+    NT(ExprNode_Integer);\n+    NT(ExprNode_Float);\n+    NT(ExprNode_Bool);\n+    NT(ExprNode_String);\n+    NT(ExprNode_ByteString);\n+    NT(ExprNode_Closure);\n+    NT(ExprNode_StructLiteral);\n+    NT(ExprNode_Array);\n+    NT(ExprNode_Tuple);\n+    NT(ExprNode_NamedValue);\n+\n+    NT(ExprNode_Field);\n+    NT(ExprNode_Index);\n+    NT(ExprNode_Deref);\n+    NT(ExprNode_Cast);\n+    NT(ExprNode_TypeAnnotation);\n+    NT(ExprNode_BinOp);\n+    NT(ExprNode_UniOp);\n+    #undef NT\n+};\n+class NodeVisitorDef:\n+    public NodeVisitor\n+{\n+public:\n+    inline void visit(const unique_ptr<ExprNode>& cnode) {\n+        if(cnode.get())\n+            cnode->visit(*this);\n+    }\n+    #define NT(nt) \\\n+        virtual void visit(nt& node) override;/* \\\n+        virtual void visit(const nt& node) override*/\n+    NT(ExprNode_Block);\n+    NT(ExprNode_Macro);\n+    NT(ExprNode_Asm);\n+    NT(ExprNode_Flow);\n+    NT(ExprNode_LetBinding);\n+    NT(ExprNode_Assign);\n+    NT(ExprNode_CallPath);\n+    NT(ExprNode_CallMethod);\n+    NT(ExprNode_CallObject);\n+    NT(ExprNode_Loop);\n+    NT(ExprNode_Match);\n+    NT(ExprNode_If);\n+    NT(ExprNode_IfLet);\n+\n+    NT(ExprNode_Integer);\n+    NT(ExprNode_Float);\n+    NT(ExprNode_Bool);\n+    NT(ExprNode_String);\n+    NT(ExprNode_ByteString);\n+    NT(ExprNode_Closure);\n+    NT(ExprNode_StructLiteral);\n+    NT(ExprNode_Array);\n+    NT(ExprNode_Tuple);\n+    NT(ExprNode_NamedValue);\n+\n+    NT(ExprNode_Field);\n+    NT(ExprNode_Index);\n+    NT(ExprNode_Deref);\n+    NT(ExprNode_Cast);\n+    NT(ExprNode_TypeAnnotation);\n+    NT(ExprNode_BinOp);\n+    NT(ExprNode_UniOp);\n+    #undef NT\n+};\n+\n+}\n+\n+#endif\n+"}, {"sha": "cae519ccc3a381bbb89e9f17cd27268d298035c1", "filename": "gcc/rust/mrustc_parser/ast/expr_ptr.hpp", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr_ptr.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr_ptr.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr_ptr.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,38 @@\n+/*\n+  * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/expr_ptr.hpp\n+ * - Pointer type wrapping AST::ExprNode (prevents need to know the full definition)\n+ */\n+#include <memory>\n+\n+namespace AST {\n+\n+class ExprNode;\n+class NodeVisitor;\n+\n+typedef ::std::unique_ptr<AST::ExprNode>    ExprNodeP;\n+extern ::std::ostream& operator<<(::std::ostream& os, const ExprNode& node);\n+\n+class Expr\n+{\n+    ::std::shared_ptr<ExprNode> m_node;\n+public:\n+    Expr(unique_ptr<ExprNode> node);\n+    Expr(ExprNode* node);\n+    Expr();\n+\n+    bool is_valid() const { return m_node.get() != nullptr; }\n+    const ExprNode& node() const { assert(m_node.get()); return *m_node; }\n+          ExprNode& node()       { assert(m_node.get()); return *m_node; }\n+    ::std::shared_ptr<ExprNode> take_node() { assert(m_node.get()); return ::std::move(m_node); }\n+    void visit_nodes(NodeVisitor& v);\n+    void visit_nodes(NodeVisitor& v) const;\n+\n+    Expr clone() const;\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const Expr& pat);\n+};\n+\n+}"}, {"sha": "c222044cabe188b7d5117de76ca0d6a53aa85a7c", "filename": "gcc/rust/mrustc_parser/ast/generics.hpp", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fgenerics.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fgenerics.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fgenerics.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,181 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/generics.hpp\n+ * - AST Generics (type parameters, bounds, ...)\n+ */\n+#pragma once\n+\n+#include <string>\n+#include \"types.hpp\"\n+\n+namespace AST {\n+\n+class TypeParam\n+{\n+    ::AST::AttributeList    m_attrs;\n+    Span    m_span;\n+    // TODO: use an Ident?\n+    ::std::string   m_name;\n+    ::TypeRef m_default;\n+public:\n+    TypeParam(TypeParam&& x) = default;\n+    TypeParam& operator=(TypeParam&& x) = default;\n+    explicit TypeParam(const TypeParam& x):\n+        m_attrs( x.m_attrs ),\n+        m_span( x.m_span ),\n+        m_name( x.m_name ),\n+        m_default( x.m_default.clone() )\n+    {\n+    }\n+\n+    TypeParam(Span sp, ::AST::AttributeList attrs, ::std::string name):\n+        m_attrs( ::std::move(attrs) ),\n+        m_span( ::std::move(sp) ),\n+        m_name( ::std::move(name) ),\n+        m_default(m_span)\n+    {}\n+\n+    void setDefault(TypeRef type) {\n+        assert(m_default.is_wildcard());\n+        m_default = ::std::move(type);\n+    }\n+\n+    const ::AST::AttributeList& attrs() const { return m_attrs; }\n+    const Span& span() const { return m_span; }\n+    const ::std::string& name() const { return m_name; }\n+\n+    const TypeRef& get_default() const { return m_default; }\n+          TypeRef& get_default()       { return m_default; }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const TypeParam& tp);\n+};\n+class LifetimeParam\n+{\n+    ::AST::AttributeList    m_attrs;\n+    Span    m_span;\n+    Ident   m_name;\n+public:\n+    LifetimeParam(Span sp, ::AST::AttributeList attrs, Ident name):\n+        m_attrs( ::std::move(attrs) ),\n+        m_span( ::std::move(sp) ),\n+        m_name( ::std::move(name) )\n+    {\n+    }\n+    LifetimeParam(LifetimeParam&&) = default;\n+    LifetimeParam& operator=(LifetimeParam&&) = default;\n+    explicit LifetimeParam(const LifetimeParam&) = default;\n+\n+    const ::AST::AttributeList& attrs() const { return m_attrs; }\n+    const Span& span() const { return m_span; }\n+    const Ident& name() const { return m_name; }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const LifetimeParam& p);\n+};\n+\n+// HigherRankedBounds is defined in `types.hpp`\n+\n+TAGGED_UNION_EX( GenericBound, (), None,\n+    (\n+    (None, struct{}),\n+    // Lifetime bound: 'test must be valid for 'bound\n+    (Lifetime, struct {\n+        LifetimeRef test;\n+        LifetimeRef bound;\n+        }),\n+    // Type lifetime bound\n+    (TypeLifetime, struct {\n+        TypeRef type;\n+        LifetimeRef bound;\n+        }),\n+    // Standard trait bound: \"Type: [for<'a>] Trait\"\n+    (IsTrait, struct {\n+        HigherRankedBounds  outer_hrbs;\n+        TypeRef type;\n+        HigherRankedBounds  inner_hrbs;\n+        AST::Path   trait;\n+        }),\n+    // Removed trait bound: \"Type: ?Trait\"\n+    (MaybeTrait, struct {\n+        TypeRef type;\n+        AST::Path   trait;\n+        }),\n+    // Negative trait bound: \"Type: !Trait\"\n+    (NotTrait, struct {\n+        TypeRef type;\n+        AST::Path   trait;\n+        }),\n+    // Type equality: \"Type = Replacement\"\n+    (Equality, struct {\n+        TypeRef type;\n+        TypeRef replacement;\n+        })\n+    ),\n+\n+    (, span(x.span) ), ( span = x.span; ),\n+    (\n+    public:\n+\n+        Span    span;\n+\n+        GenericBound clone() const {\n+            TU_MATCH(GenericBound, ( (*this) ), (ent),\n+            (None, return make_None({}); ),\n+            (Lifetime,     return make_Lifetime({ent.test, ent.bound});     ),\n+            (TypeLifetime, return make_TypeLifetime({ent.type.clone(), ent.bound}); ),\n+            (IsTrait,    return make_IsTrait({ent.outer_hrbs, ent.type.clone(), ent.inner_hrbs, ent.trait}); ),\n+            (MaybeTrait, return make_MaybeTrait({ent.type.clone(), ent.trait}); ),\n+            (NotTrait,   return make_NotTrait({ent.type.clone(), ent.trait}); ),\n+            (Equality,   return make_Equality({ent.type.clone(), ent.replacement.clone()}); )\n+            )\n+            return GenericBound();\n+        }\n+        )\n+    );\n+\n+::std::ostream& operator<<(::std::ostream& os, const GenericBound& x);\n+\n+class GenericParams\n+{\n+    ::std::vector<TypeParam>    m_type_params;\n+    ::std::vector<LifetimeParam>    m_lifetime_params;\n+    ::std::vector<GenericBound>    m_bounds;\n+public:\n+    GenericParams() {}\n+    GenericParams(GenericParams&& x) = default;\n+    GenericParams& operator=(GenericParams&& x) = default;\n+    GenericParams(const GenericParams& x) = delete;\n+\n+    GenericParams clone() const {\n+        GenericParams   rv;\n+        rv.m_type_params = ::std::vector<TypeParam>( m_type_params );   // Copy-constructable\n+        rv.m_lifetime_params = ::std::vector<LifetimeParam>(m_lifetime_params);\n+        rv.m_bounds.reserve( m_bounds.size() );\n+        for(auto& e: m_bounds)\n+            rv.m_bounds.push_back( e.clone() );\n+        return rv;\n+    }\n+\n+    const ::std::vector<TypeParam>& ty_params() const { return m_type_params; }\n+          ::std::vector<TypeParam>& ty_params()       { return m_type_params; }\n+    const ::std::vector<LifetimeParam>& lft_params() const { return m_lifetime_params; }\n+    const ::std::vector<GenericBound>& bounds() const { return m_bounds; }\n+          ::std::vector<GenericBound>& bounds()       { return m_bounds; }\n+\n+    void add_ty_param(TypeParam param) { m_type_params.push_back( ::std::move(param) ); }\n+    void add_lft_param(LifetimeParam lft) { m_lifetime_params.push_back( ::std::move(lft) ); }\n+    void add_bound(GenericBound bound) {\n+        m_bounds.push_back( ::std::move(bound) );\n+    }\n+\n+    int find_name(const char* name) const;\n+    bool check_params(Crate& crate, const ::std::vector<TypeRef>& types) const;\n+    bool check_params(Crate& crate, ::std::vector<TypeRef>& types, bool allow_infer) const;\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const GenericParams& tp);\n+};\n+\n+\n+}\n+"}, {"sha": "0074ce9adeff463dbc24f4b6d9e308558def1b9a", "filename": "gcc/rust/mrustc_parser/ast/item.hpp", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fitem.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fitem.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fitem.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/item.hpp\n+ * - AST named item wrapper\n+ */\n+#pragma once\n+\n+#include <string>\n+#include <vector>\n+\n+namespace AST {\n+\n+template <typename T>\n+struct Named\n+{\n+    ::std::string   name;\n+    T   data;\n+    bool    is_pub;\n+\n+    Named():\n+        is_pub(false)\n+    {}\n+    Named(Named&&) = default;\n+    Named(const Named&) = default;\n+    Named& operator=(Named&&) = default;\n+    Named(::std::string name, T data, bool is_pub):\n+        name( ::std::move(name) ),\n+        data( ::std::move(data) ),\n+        is_pub( is_pub )\n+    {\n+    }\n+};\n+\n+template <typename T>\n+using NamedList = ::std::vector<Named<T> >;\n+\n+}   // namespace AST\n+"}, {"sha": "5b2223ce9c1c9e292c3530694237dae9f28a2655", "filename": "gcc/rust/mrustc_parser/ast/macro.hpp", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fmacro.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fmacro.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fmacro.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,67 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/macro.hpp\n+ * - AST representation of a macro invocation\n+ */\n+#ifndef _AST_MACRO_HPP_\n+#define _AST_MACRO_HPP_\n+\n+#include \"../parse/tokentree.hpp\"\n+#include <span.hpp>\n+#include \"attrs.hpp\"\n+\n+namespace AST {\n+\n+class MacroInvocation\n+{\n+    Span    m_span;\n+\n+    ::std::string   m_macro_name;\n+    ::std::string   m_ident;\n+    TokenTree   m_input;\n+public:\n+    MacroInvocation(MacroInvocation&&) = default;\n+    MacroInvocation& operator=(MacroInvocation&&) = default;\n+    MacroInvocation(const MacroInvocation&) = delete;\n+    MacroInvocation& operator=(const MacroInvocation&) = delete;\n+\n+    MacroInvocation()\n+    {\n+    }\n+\n+    MacroInvocation(Span span, ::std::string macro, ::std::string ident, TokenTree input):\n+        m_span( mv$(span) ),\n+        m_macro_name( mv$(macro) ),\n+        m_ident( mv$(ident) ),\n+        m_input( mv$(input) )\n+    {\n+    }\n+\n+    MacroInvocation clone() const;\n+\n+    void clear() {\n+        m_macro_name = \"\";\n+        m_ident = \"\";\n+        m_input = TokenTree();\n+    }\n+\n+    const Span& span() const { return m_span; }\n+    const ::std::string& name() const { return m_macro_name; }\n+\n+    const ::std::string& input_ident() const { return m_ident; }\n+    const TokenTree& input_tt() const { return m_input; }\n+          TokenTree& input_tt()       { return m_input; }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const MacroInvocation& x) {\n+        os << x.m_macro_name << \"! \" << x.m_ident << x.m_input;\n+        return os;\n+    }\n+};\n+\n+\n+}\n+\n+#endif\n+"}, {"sha": "6fdf1e40d177c57ac6c96ead1c93fb6df955ec4e", "filename": "gcc/rust/mrustc_parser/ast/path.cpp", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,347 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/path.cpp\n+ * - AST::Path and friends\n+ */\n+#include \"path.hpp\"\n+#include \"ast.hpp\"\n+#include \"types.hpp\"\n+#include <iostream>\n+#include \"../parse/parseerror.hpp\"\n+#include <algorithm>\n+\n+#define PRETTY_PATH_PRINT   1\n+\n+namespace AST {\n+\n+// --- AST::PathBinding\n+::std::ostream& operator<<(::std::ostream& os, const PathBinding& x) {\n+    TU_MATCH(PathBinding, (x), (i),\n+    (Unbound, os << \"_\";   ),\n+    (Crate ,  os << \"Crate\";    ),\n+    (Module,  os << \"Module\";    ),\n+    (Trait,     os << \"Trait\";   ),\n+    (Struct,    os << \"Struct\";  ),\n+    (Enum,      os << \"Enum\";    ),\n+    (Union,     os << \"Union\";   ),\n+    (Static,    os << \"Static\";  ),\n+    (Function,  os << \"Function\";),\n+    (EnumVar,  os << \"EnumVar(\" << i.idx << \")\"; ),\n+    (TypeAlias, os << \"TypeAlias\";),\n+    (StructMethod, os << \"StructMethod\"; ),\n+    (TraitMethod,  os << \"TraitMethod\";  ),\n+\n+    (TypeParameter, os << \"TyParam(\" << i.level << \" # \" << i.idx << \")\"; ),\n+    (Variable, os << \"Var(\" << i.slot << \")\"; )\n+    )\n+    return os;\n+}\n+PathBinding PathBinding::clone() const\n+{\n+    TU_MATCH(::AST::PathBinding, (*this), (e),\n+    (Unbound , return PathBinding::make_Unbound({}); ),\n+    (Module  , return PathBinding::make_Module(e);   ),\n+    (Crate   , return PathBinding(e); ),\n+    (Trait   , return PathBinding(e); ),\n+    (Struct  , return PathBinding(e); ),\n+    (Enum    , return PathBinding(e); ),\n+    (Union   , return PathBinding(e); ),\n+    (Static  , return PathBinding(e); ),\n+    (Function, return PathBinding(e); ),\n+    (TypeAlias, return PathBinding::make_TypeAlias(e); ),\n+    (EnumVar , return PathBinding::make_EnumVar(e);  ),\n+    (StructMethod, return PathBinding::make_StructMethod(e); ),\n+    (TraitMethod, return PathBinding::make_TraitMethod(e); ),\n+\n+    (TypeParameter, return PathBinding::make_TypeParameter(e); ),\n+    (Variable, return PathBinding::make_Variable(e); )\n+    )\n+    throw \"BUG: Fell off the end of PathBinding::clone\";\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const PathParams& x)\n+{\n+    bool needs_comma = false;\n+    os << \"<\";\n+    for(const auto& v : x.m_lifetimes) {\n+        if(needs_comma) os << \", \";\n+        needs_comma = true;\n+        os << \"'\" << v;\n+    }\n+    for(const auto& v : x.m_types) {\n+        if(needs_comma) os << \", \";\n+        needs_comma = true;\n+        os << v;\n+    }\n+    for(const auto& v : x.m_assoc) {\n+        if(needs_comma) os << \", \";\n+        needs_comma = true;\n+        os << v.first << \"=\" << v.second;\n+    }\n+    os << \">\";\n+    return os;\n+}\n+PathParams::PathParams(const PathParams& x):\n+    m_lifetimes( x.m_lifetimes )\n+{\n+    m_types.reserve( x.m_types.size() );\n+    for(const auto& t : x.m_types)\n+        m_types.push_back(t.clone());\n+\n+    m_assoc.reserve( x.m_assoc.size() );\n+    for(const auto& t : x.m_assoc)\n+        m_assoc.push_back( ::std::make_pair(t.first, t.second.clone()) );\n+}\n+Ordering PathParams::ord(const PathParams& x) const\n+{\n+    Ordering rv;\n+    rv = ::ord(m_lifetimes, x.m_lifetimes);\n+    if(rv != OrdEqual)  return rv;\n+    rv = ::ord(m_types, x.m_types);\n+    if(rv != OrdEqual)  return rv;\n+    rv = ::ord(m_assoc, x.m_assoc);\n+    if(rv != OrdEqual)  return rv;\n+    return rv;\n+}\n+\n+// --- AST::PathNode\n+PathNode::PathNode(::std::string name, PathParams args):\n+    m_name( mv$(name) ),\n+    m_params( mv$(args) )\n+{\n+}\n+Ordering PathNode::ord(const PathNode& x) const\n+{\n+    Ordering    rv;\n+    rv = ::ord(m_name, x.m_name);\n+    if(rv != OrdEqual)  return rv;\n+    rv = m_params.ord(x.m_params);\n+    if(rv != OrdEqual)  return rv;\n+    return OrdEqual;\n+}\n+void PathNode::print_pretty(::std::ostream& os, bool is_type_context) const\n+{\n+    os << m_name;\n+    if( ! m_params.is_empty() )\n+    {\n+        if( ! is_type_context )\n+            os << \"::\";\n+        os << m_params;\n+    }\n+}\n+::std::ostream& operator<<(::std::ostream& os, const PathNode& pn) {\n+    pn.print_pretty(os, false);\n+    return os;\n+}\n+\n+/// Return an iterator to the named item\n+template<typename T>\n+typename ::std::vector<Named<T> >::const_iterator find_named(const ::std::vector<Named<T> >& vec, const ::std::string& name)\n+{\n+    return ::std::find_if(vec.begin(), vec.end(), [&name](const Named<T>& x) {\n+        return x.name == name;\n+    });\n+}\n+\n+// --- AST::Path\n+AST::Path::~Path()\n+{\n+}\n+AST::Path::Path(TagUfcs, TypeRef type, ::std::vector<AST::PathNode> nodes):\n+    m_class( AST::Path::Class::make_UFCS({box$(type), nullptr, nodes}) )\n+{\n+}\n+AST::Path::Path(TagUfcs, TypeRef type, Path trait, ::std::vector<AST::PathNode> nodes):\n+    m_class( AST::Path::Class::make_UFCS({box$(type), box$(trait), nodes}) )\n+{\n+}\n+AST::Path::Path(const Path& x):\n+    m_class()\n+    //m_binding(x.m_binding)\n+{\n+    TU_MATCH(Class, (x.m_class), (ent),\n+    (Invalid, m_class = Class::make_Invalid({});),\n+    (Local,\n+        m_class = Class::make_Local({ent.name});\n+        ),\n+    (Relative,\n+        m_class = Class::make_Relative({ent.hygiene, ent.nodes});\n+        ),\n+    (Self,\n+        m_class = Class::make_Self({ent.nodes});\n+        ),\n+    (Super,\n+        m_class = Class::make_Super({ent.count, ent.nodes});\n+        ),\n+    (Absolute,\n+        m_class = Class::make_Absolute({ent.crate, ent.nodes});\n+        ),\n+    (UFCS,\n+        if( ent.trait )\n+            m_class = Class::make_UFCS({ box$(ent.type->clone()), ::std::unique_ptr<Path>(new Path(*ent.trait)), ent.nodes });\n+        else\n+            m_class = Class::make_UFCS({ box$(ent.type->clone()), nullptr, ent.nodes });\n+        )\n+    )\n+\n+    memcpy(&m_binding, &x.m_binding, sizeof(PathBinding));\n+}\n+\n+void Path::bind_variable(unsigned int slot)\n+{\n+    m_binding = PathBinding::make_Variable({slot});\n+}\n+void Path::bind_enum_var(const Enum& ent, const ::std::string& name, const ::std::vector<TypeRef>& /*args*/)\n+{\n+    auto it = ::std::find_if(ent.variants().begin(), ent.variants().end(), [&](const auto& x) { return x.m_name == name; });\n+    if( it == ent.variants().end() )\n+    {\n+        throw ParseError::Generic(\"Enum variant not found\");\n+    }\n+    unsigned int idx = it - ent.variants().begin();\n+\n+    DEBUG(\"Bound to enum variant '\" << name << \"' (#\" << idx << \")\");\n+    ::AST::PathBinding::Data_EnumVar tmp = {};\n+    tmp.enum_ = &ent;\n+    tmp.idx = idx;\n+    m_binding = PathBinding::make_EnumVar( mv$(tmp) );\n+}\n+\n+Path& Path::operator+=(const Path& other)\n+{\n+    for(auto& node : other.nodes())\n+        append(node);\n+    // If the path is modified, clear the binding\n+    m_binding = PathBinding();\n+    return *this;\n+}\n+\n+Ordering Path::ord(const Path& x) const\n+{\n+    Ordering rv;\n+\n+    rv = ::ord( (unsigned)m_class.tag(), (unsigned)x.m_class.tag() );\n+    if( rv != OrdEqual )    return rv;\n+\n+    TU_MATCH(Path::Class, (m_class, x.m_class), (ent, x_ent),\n+    (Invalid,\n+        return OrdEqual;\n+        ),\n+    (Local,\n+        return ::ord(ent.name, x_ent.name);\n+        ),\n+    (Relative,\n+        return ::ord(ent.nodes, x_ent.nodes);\n+        ),\n+    (Self,\n+        return ::ord(ent.nodes, x_ent.nodes);\n+        ),\n+    (Super,\n+        return ::ord(ent.nodes, x_ent.nodes);\n+        ),\n+    (Absolute,\n+        rv = ::ord( ent.crate, x_ent.crate );\n+        if( rv != OrdEqual )    return rv;\n+        return ::ord(ent.nodes, x_ent.nodes);\n+        ),\n+    (UFCS,\n+        rv = ent.type->ord( *x_ent.type );\n+        if( rv != OrdEqual )    return rv;\n+        rv = ent.trait->ord( *x_ent.trait );\n+        if( rv != OrdEqual )    return rv;\n+        return ::ord(ent.nodes, x_ent.nodes);\n+        )\n+    )\n+\n+    return OrdEqual;\n+}\n+\n+void Path::print_pretty(::std::ostream& os, bool is_type_context, bool is_debug) const\n+{\n+    TU_MATCH(Path::Class, (m_class), (ent),\n+    (Invalid,\n+        os << \"/*inv*/\";\n+        // NOTE: Don't print the binding for invalid paths\n+        return ;\n+        ),\n+    (Local,\n+        // Only print comment if there's no binding\n+        if( m_binding.is_Unbound() )\n+        {\n+            if( is_debug )\n+                os << \"/*var*/\";\n+        }\n+        else\n+            assert( m_binding.is_Variable() );\n+        os << ent.name;\n+        ),\n+    (Relative,\n+        if( is_debug )\n+            os << ent.hygiene;\n+        for(const auto& n : ent.nodes)\n+        {\n+            if( &n != &ent.nodes[0] ) {\n+                os << \"::\";\n+            }\n+            n.print_pretty(os, is_type_context);\n+        }\n+        ),\n+    (Self,\n+        os << \"self\";\n+        for(const auto& n : ent.nodes)\n+        {\n+            os << \"::\";\n+            n.print_pretty(os, is_type_context);\n+        }\n+        ),\n+    (Super,\n+        os << \"super\";\n+        for(const auto& n : ent.nodes)\n+        {\n+            os << \"::\";\n+            n.print_pretty(os, is_type_context);\n+        }\n+        ),\n+    (Absolute,\n+        if( ent.crate != \"\" )\n+            os << \"::\\\"\" << ent.crate << \"\\\"\";\n+        for(const auto& n : ent.nodes)\n+        {\n+            os << \"::\";\n+            n.print_pretty(os, is_type_context);\n+        }\n+        ),\n+    (UFCS,\n+        //os << \"/*ufcs*/\";\n+        if( ent.trait ) {\n+            os << \"<\" << *ent.type << \" as \";\n+            if( ent.trait->m_class.is_Invalid() ) {\n+                os << \"_\";\n+            }\n+            else {\n+                os << *ent.trait;\n+            }\n+            os << \">\";\n+        }\n+        else {\n+            os << \"<\" << *ent.type << \">\";\n+        }\n+        for(const auto& n : ent.nodes) {\n+            os << \"::\";\n+            n.print_pretty(os, is_type_context);\n+        }\n+        )\n+    )\n+    if( is_debug )\n+        os << \"/*\" << m_binding << \"*/\";\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const Path& path)\n+{\n+    path.print_pretty(os, false, true);\n+    return os;\n+}\n+\n+}"}, {"sha": "c2d13d73e1b10bf267d01ab6ce68a6a071d2c473", "filename": "gcc/rust/mrustc_parser/ast/path.hpp", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,365 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/path.hpp\n+ * - AST::Path and helper types\n+ */\n+#ifndef AST_PATH_HPP_INCLUDED\n+#define AST_PATH_HPP_INCLUDED\n+\n+#include \"../common.hpp\"\n+#include <string>\n+#include <stdexcept>\n+#include <vector>\n+#include <initializer_list>\n+#include <cassert>\n+#include <tagged_union.hpp>\n+#include <string>\n+#include \"../include/span.hpp\"\n+#include \"../include/ident.hpp\"\n+\n+class TypeRef;\n+\n+namespace HIR {\n+class Module;\n+class Trait;\n+class Enum;\n+class Struct;\n+class Union;\n+class Static;\n+}   // namespace HIR\n+\n+namespace AST {\n+\n+class LifetimeRef;\n+class GenericParams;\n+class Crate;\n+class Module;\n+class TypeAlias;\n+class Enum;\n+class Struct;\n+class Union;\n+class Trait;\n+class Static;\n+class Function;\n+class ExternCrate;\n+\n+TAGGED_UNION_EX(PathBinding, (), Unbound, (\n+    (Unbound, struct {\n+        }),\n+    (Crate, struct {\n+        const ExternCrate* crate_;\n+        }),\n+    (Module, struct {\n+        const Module* module_;\n+        const ::HIR::Module* hir;\n+        }),\n+    (Struct, struct {\n+        const Struct* struct_;\n+        const ::HIR::Struct* hir;\n+        }),\n+    (Enum,   struct {\n+        const Enum* enum_;\n+        const ::HIR::Enum*  hir;\n+        }),\n+    (Union,   struct {\n+        const Union* union_;\n+        const ::HIR::Union*  hir;\n+        }),\n+    (Trait,  struct {\n+        const Trait* trait_;\n+        const ::HIR::Trait* hir;\n+        }),\n+    (Static, struct {\n+        const Static* static_;\n+        const ::HIR::Static* hir; // if nullptr and static_ == nullptr, points to a `const`\n+        }),\n+    (Function, struct {\n+        const Function* func_;\n+        }),\n+    (EnumVar, struct {\n+        const Enum* enum_;\n+        unsigned int idx;\n+        const ::HIR::Enum*  hir;\n+        }),\n+    (TypeAlias, struct {\n+        const TypeAlias* alias_;\n+        }),\n+    (StructMethod, struct {\n+        const Struct* struct_;\n+        ::std::string name;\n+        }),\n+    (TraitMethod, struct {\n+        const Trait* trait_;\n+        ::std::string name;\n+        }),\n+\n+    (TypeParameter, struct {\n+        unsigned int level;\n+        unsigned int idx;\n+        }),\n+    (Variable, struct {\n+        unsigned int slot;\n+        })\n+    ),\n+    (), (),\n+    (\n+    public:\n+        PathBinding clone() const;\n+        )\n+    );\n+\n+extern ::std::ostream& operator<<(::std::ostream& os, const PathBinding& x);\n+\n+struct PathParams\n+{\n+    ::std::vector< LifetimeRef >  m_lifetimes;\n+    ::std::vector< TypeRef >    m_types;\n+    ::std::vector< ::std::pair< ::std::string, TypeRef> >   m_assoc;\n+\n+    PathParams(PathParams&& x) = default;\n+    PathParams(const PathParams& x);\n+    PathParams() {}\n+    PathParams(::std::vector<LifetimeRef> lfts, ::std::vector<TypeRef> tys, ::std::vector<::std::pair<::std::string,TypeRef>> a):\n+        m_lifetimes(mv$(lfts)),\n+        m_types(mv$(tys)),\n+        m_assoc(mv$(a))\n+    {}\n+\n+    PathParams& operator=(PathParams&& x) = default;\n+    PathParams& operator=(const PathParams& x) = delete;\n+\n+    bool is_empty() const {\n+        return m_lifetimes.empty() && m_types.empty() && m_assoc.empty();\n+    }\n+\n+    Ordering ord(const PathParams& x) const;\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const PathParams& x);\n+};\n+\n+class PathNode\n+{\n+    ::std::string   m_name;\n+    PathParams  m_params;\n+public:\n+    PathNode() {}\n+    PathNode(::std::string name, PathParams args = {});\n+    const ::std::string& name() const { return m_name; }\n+\n+    const ::AST::PathParams& args() const { return m_params; }\n+          ::AST::PathParams& args()       { return m_params; }\n+\n+    Ordering ord(const PathNode& x) const;\n+    void print_pretty(::std::ostream& os, bool is_type_context) const;\n+\n+    bool operator==(const PathNode& x) const { return ord(x) == OrdEqual; }\n+    friend ::std::ostream& operator<<(::std::ostream& os, const PathNode& pn);\n+};\n+\n+class Path\n+{\n+public:\n+    TAGGED_UNION(Class, Invalid,\n+        (Invalid, struct {}),\n+        (Local, struct {   // Variable / Type param (resolved)\n+            ::std::string name;\n+            } ),\n+        (Relative, struct {    // General relative\n+            Ident::Hygiene hygiene;\n+            ::std::vector<PathNode> nodes;\n+            } ),\n+        (Self, struct {    // Module-relative\n+            ::std::vector<PathNode> nodes;\n+            } ),\n+        (Super, struct {   // Parent-relative\n+            unsigned int count; // Number of `super` keywords, must be >= 1\n+            ::std::vector<PathNode> nodes;\n+            } ),\n+        (Absolute, struct {    // Absolute\n+            ::std::string   crate;\n+            ::std::vector<PathNode> nodes;\n+            } ),\n+        (UFCS, struct {    // Type-relative\n+            ::std::unique_ptr<TypeRef> type;    // always non-null\n+            ::std::unique_ptr<Path> trait;   // nullptr = inherent, Invalid = unknown trait\n+            ::std::vector<PathNode> nodes;\n+            } )\n+        );\n+\n+public:\n+    Class   m_class;\n+\n+private:\n+    PathBinding m_binding;\n+public:\n+    virtual ~Path();\n+    // INVALID\n+    Path():\n+        m_class()\n+    {}\n+    Path(Path&&) = default;\n+    Path& operator=(AST::Path&& x) {\n+        m_class = mv$(x.m_class);\n+        m_binding = mv$(x.m_binding);\n+        //DEBUG(\"Path, \" << x);\n+        return *this;\n+    }\n+\n+    Path(const Path& x);\n+    Path& operator=(const AST::Path&) = delete;\n+\n+    // ABSOLUTE\n+    Path(::std::string crate, ::std::vector<PathNode> nodes):\n+        m_class( Class::make_Absolute({ mv$(crate), mv$(nodes)}) )\n+    {}\n+\n+    // UFCS\n+    struct TagUfcs {};\n+    Path(TagUfcs, TypeRef type, ::std::vector<PathNode> nodes={});\n+    Path(TagUfcs, TypeRef type, Path trait, ::std::vector<PathNode> nodes={});\n+\n+    // VARIABLE\n+    struct TagLocal {};\n+    Path(TagLocal, ::std::string name):\n+        m_class( Class::make_Local({ mv$(name) }) )\n+    {}\n+    Path(::std::string name):\n+        m_class( Class::make_Local({ mv$(name) }) )\n+    {}\n+\n+    // RELATIVE\n+    struct TagRelative {};\n+    Path(TagRelative, Ident::Hygiene hygiene, ::std::vector<PathNode> nodes):\n+        m_class( Class::make_Relative({ mv$(hygiene), mv$(nodes) }) )\n+    {}\n+    // SELF\n+    struct TagSelf {};\n+    Path(TagSelf, ::std::vector<PathNode> nodes):\n+        m_class( Class::make_Self({ mv$(nodes) }) )\n+    {}\n+    // SUPER\n+    struct TagSuper {};\n+    Path(TagSuper, unsigned int count, ::std::vector<PathNode> nodes):\n+        m_class( Class::make_Super({ count, mv$(nodes) }) )\n+    {}\n+\n+    //void set_crate(::std::string crate) {\n+    //    if( m_crate == \"\" ) {\n+    //        m_crate = crate;\n+    //        DEBUG(\"crate set to \" << m_crate);\n+    //    }\n+    //}\n+\n+\n+    Class::Tag class_tag() const {\n+        return m_class.tag();\n+    }\n+\n+    Path operator+(PathNode pn) const {\n+        Path tmp = Path(*this);\n+        tmp.nodes().push_back( mv$(pn) );\n+        return tmp;\n+    }\n+    Path operator+(const ::std::string& s) const {\n+        Path tmp = Path(*this);\n+        tmp.append(PathNode(s, {}));\n+        return tmp;\n+    }\n+    Path operator+(const Path& x) const {\n+        return Path(*this) += x;\n+    }\n+    Path& operator+=(const Path& x);\n+\n+    void append(PathNode node) {\n+        assert( !m_class.is_Invalid() );\n+        //if( m_class.is_Invalid() )\n+        //    m_class = Class::make_Relative({});\n+        nodes().push_back( mv$(node) );\n+        m_binding = PathBinding();\n+    }\n+\n+    bool is_trivial() const {\n+        TU_MATCH_DEF(Class, (m_class), (e),\n+        (\n+            return false;\n+            ),\n+        (Local,\n+            return true;\n+            ),\n+        (Relative,\n+            return e.nodes.size() == 1 && e.nodes[0].args().is_empty();\n+            )\n+        )\n+    }\n+\n+    bool is_valid() const { return !m_class.is_Invalid(); }\n+    bool is_absolute() const { return m_class.is_Absolute(); }\n+    bool is_relative() const { return m_class.is_Relative() || m_class.is_Super() || m_class.is_Self(); }\n+\n+    size_t size() const {\n+        TU_MATCH(Class, (m_class), (ent),\n+        (Invalid,  assert(!m_class.is_Invalid()); throw ::std::runtime_error(\"Path::nodes() on Invalid\"); ),\n+        (Local,    return 1;),\n+        (Relative, return ent.nodes.size();),\n+        (Self,     return ent.nodes.size();),\n+        (Super,    return ent.nodes.size();),\n+        (Absolute, return ent.nodes.size();),\n+        (UFCS,     return ent.nodes.size();)\n+        )\n+        throw ::std::runtime_error(\"Path::nodes() fell off\");\n+    }\n+    //const ::std::string& crate() const { return m_crate; }\n+\n+    bool is_concrete() const;\n+\n+    bool is_bound() const { return !m_binding.is_Unbound(); }\n+    const PathBinding& binding() const { return m_binding; }\n+    void bind_variable(unsigned int slot);\n+\n+    ::std::vector<PathNode>& nodes() {\n+        TU_MATCH(Class, (m_class), (ent),\n+        (Invalid,  assert(!m_class.is_Invalid()); throw ::std::runtime_error(\"Path::nodes() on Invalid\"); ),\n+        (Local,    assert(!m_class.is_Local()); throw ::std::runtime_error(\"Path::nodes() on Local\"); ),\n+        (Relative, return ent.nodes;),\n+        (Self,     return ent.nodes;),\n+        (Super,    return ent.nodes;),\n+        (Absolute, return ent.nodes;),\n+        (UFCS,     return ent.nodes;)\n+        )\n+        throw ::std::runtime_error(\"Path::nodes() fell off\");\n+    }\n+    const ::std::vector<PathNode>& nodes() const {\n+        return ((Path*)this)->nodes();\n+    }\n+\n+    PathNode& operator[](int idx) { if(idx>=0) return nodes()[idx]; else return nodes()[size()+idx]; }\n+    const PathNode& operator[](int idx) const { return (*(Path*)this)[idx]; }\n+\n+    Ordering ord(const Path& x) const;\n+    bool operator==(const Path& x) const { return ord(x) == OrdEqual; }\n+    bool operator!=(const Path& x) const { return ord(x) != OrdEqual; }\n+    bool operator<(const Path& x) const { return ord(x) != OrdLess; }\n+\n+    void print_pretty(::std::ostream& os, bool is_type_context, bool is_debug=false) const;\n+    friend ::std::ostream& operator<<(::std::ostream& os, const Path& path);\n+private:\n+    static void resolve_args_nl(::std::vector<PathNode>& nodes, ::std::function<TypeRef(const char*)> fcn);\n+\n+    void check_param_counts(const GenericParams& params, bool expect_params, PathNode& node);\n+public:\n+    void bind_enum_var(const Enum& ent, const ::std::string& name, const ::std::vector<TypeRef>& args={});\n+    void bind_function(const Function& ent, const ::std::vector<TypeRef>& args={}) {\n+        (void)args;\n+        m_binding = PathBinding::make_Function({&ent});\n+    }\n+\n+    void bind(::AST::PathBinding pb) {\n+        m_binding = mv$(pb);\n+    }\n+};\n+\n+}   // namespace AST\n+\n+#endif"}, {"sha": "72087d95f3c7f86201603f0959d399a90b7b163d", "filename": "gcc/rust/mrustc_parser/ast/pattern.cpp", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,243 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/pattern.cpp\n+ * - AST::Pattern support/implementation code\n+ */\n+#include \"../common.hpp\"\n+#include \"ast.hpp\"\n+#include \"pattern.hpp\"\n+\n+namespace AST {\n+\n+::std::ostream& operator<<(::std::ostream& os, const Pattern::Value& val)\n+{\n+    TU_MATCH(Pattern::Value, (val), (e),\n+    (Invalid,\n+        os << \"/*BAD PAT VAL*/\";\n+        ),\n+    (Integer,\n+        switch(e.type)\n+        {\n+        case CORETYPE_BOOL:\n+            os << (e.value ? \"true\" : \"false\");\n+            break;\n+        case CORETYPE_F32:\n+        case CORETYPE_F64:\n+            BUG(Span(), \"Hit F32/f64 in printing pattern literal\");\n+            break;\n+        default:\n+            os << e.value;\n+            break;\n+        }\n+        ),\n+    (Float,\n+        switch(e.type)\n+        {\n+        case CORETYPE_BOOL:\n+            os << (e.value ? \"true\" : \"false\");\n+            break;\n+        case CORETYPE_ANY:\n+        case CORETYPE_F32:\n+        case CORETYPE_F64:\n+            os << e.value;\n+            break;\n+        default:\n+            BUG(Span(), \"Hit integer in printing pattern literal\");\n+            break;\n+        }\n+        ),\n+    (String,\n+        os << \"\\\"\" << e << \"\\\"\";\n+        ),\n+    (ByteString,\n+        os << \"b\\\"\" << e.v << \"\\\"\";\n+        ),\n+    (Named,\n+        os << e;\n+        )\n+    )\n+    return os;\n+}\n+::std::ostream& operator<<(::std::ostream& os, const Pattern::TuplePat& val)\n+{\n+    if( val.has_wildcard )\n+    {\n+        os << val.start;\n+        os << \".., \";\n+        os << val.end;\n+    }\n+    else\n+    {\n+        os << val.start;\n+        assert(val.end.size() == 0);\n+    }\n+    return os;\n+}\n+::std::ostream& operator<<(::std::ostream& os, const PatternBinding& pb)\n+{\n+    if( pb.m_mutable )\n+        os << \"mut \";\n+    switch(pb.m_type)\n+    {\n+    case PatternBinding::Type::MOVE:    break;\n+    case PatternBinding::Type::REF:     os << \"ref \";   break;\n+    case PatternBinding::Type::MUTREF:  os << \"ref mut \";   break;\n+    }\n+    os << pb.m_name;\n+    return os;\n+}\n+::std::ostream& operator<<(::std::ostream& os, const Pattern& pat)\n+{\n+    if( pat.m_binding.is_valid() ) {\n+        os << pat.m_binding << \" @ \";\n+    }\n+    TU_MATCH(Pattern::Data, (pat.m_data), (ent),\n+    (MaybeBind,\n+        os << ent.name << \"?\";\n+        ),\n+    (Macro,\n+        os << *ent.inv;\n+        ),\n+    (Any,\n+        os << \"_\";\n+        ),\n+    (Box,\n+        os << \"box \" << *ent.sub;\n+        ),\n+    (Ref,\n+        os << \"&\" << (ent.mut ? \"mut \" : \"\") << *ent.sub;\n+        ),\n+    (Value,\n+        os << ent.start;\n+        if( ! ent.end.is_Invalid() )\n+            os << \" ... \" << ent.end;\n+        ),\n+    (Tuple,\n+        os << \"(\" << ent << \")\";\n+        ),\n+    (StructTuple,\n+        os << ent.path << \" (\" << ent.tup_pat << \")\";\n+        ),\n+    (Struct,\n+        os << ent.path << \" {\" << ent.sub_patterns << \"}\";\n+        ),\n+    (Slice,\n+        os << \"[\";\n+        os << ent.sub_pats;\n+        os << \"]\";\n+        ),\n+    (SplitSlice,\n+        os << \"[\";\n+        bool needs_comma = false;\n+        if(ent.leading.size()) {\n+            os << ent.leading;\n+            needs_comma = true;\n+        }\n+\n+        if( needs_comma ) {\n+            os << \", \";\n+        }\n+        if( ent.extra_bind.is_valid() )\n+            os << ent.extra_bind;\n+        os << \"..\";\n+        needs_comma = true;\n+\n+        if(ent.trailing.size()) {\n+            if( needs_comma ) {\n+                os << \", \";\n+            }\n+            os << ent.trailing;\n+        }\n+        os << \"]\";\n+        )\n+    )\n+    return os;\n+}\n+\n+Pattern::~Pattern()\n+{\n+}\n+\n+AST::Pattern AST::Pattern::clone() const\n+{\n+    AST::Pattern    rv;\n+    rv.m_span = m_span;\n+    rv.m_binding = PatternBinding(m_binding);\n+\n+    struct H {\n+        static ::std::unique_ptr<Pattern> clone_sp(const ::std::unique_ptr<Pattern>& p) {\n+            return ::std::make_unique<Pattern>( p->clone() );\n+        }\n+        static ::std::vector<Pattern> clone_list(const ::std::vector<Pattern>& list) {\n+            ::std::vector<Pattern>  rv;\n+            rv.reserve(list.size());\n+            for(const auto& p : list)\n+                rv.push_back( p.clone() );\n+            return rv;\n+        }\n+        static TuplePat clone_tup(const TuplePat& p) {\n+            return TuplePat {\n+                H::clone_list(p.start),\n+                p.has_wildcard,\n+                H::clone_list(p.end)\n+                };\n+        }\n+        static AST::Pattern::Value clone_val(const AST::Pattern::Value& v) {\n+            TU_MATCH(::AST::Pattern::Value, (v), (e),\n+            (Invalid, return Value(e);),\n+            (Integer, return Value(e);),\n+            (Float, return Value(e);),\n+            (String, return Value(e);),\n+            (ByteString, return Value(e);),\n+            (Named, return Value::make_Named( AST::Path(e) );)\n+            )\n+            throw \"\";\n+        }\n+    };\n+\n+    TU_MATCH(Pattern::Data, (m_data), (e),\n+    (Any,\n+        rv.m_data = Data::make_Any(e);\n+        ),\n+    (MaybeBind,\n+        rv.m_data = Data::make_MaybeBind(e);\n+        ),\n+    (Macro,\n+        rv.m_data = Data::make_Macro({ ::std::make_unique<AST::MacroInvocation>( e.inv->clone() ) });\n+        ),\n+    (Box,\n+        rv.m_data = Data::make_Box({ H::clone_sp(e.sub) });\n+        ),\n+    (Ref,\n+        rv.m_data = Data::make_Ref({ e.mut, H::clone_sp(e.sub) });\n+        ),\n+    (Value,\n+        rv.m_data = Data::make_Value({ H::clone_val(e.start), H::clone_val(e.end) });\n+        ),\n+    (Tuple,\n+        rv.m_data = Data::make_Tuple( H::clone_tup(e) );\n+        ),\n+    (StructTuple,\n+        rv.m_data = Data::make_StructTuple({ ::AST::Path(e.path), H::clone_tup(e.tup_pat) });\n+        ),\n+    (Struct,\n+        ::std::vector< ::std::pair< ::std::string, Pattern> >   sps;\n+        for(const auto& sp : e.sub_patterns)\n+            sps.push_back( ::std::make_pair(sp.first, sp.second.clone()) );\n+        rv.m_data = Data::make_Struct({ ::AST::Path(e.path), mv$(sps) });\n+        ),\n+    (Slice,\n+        rv.m_data = Data::make_Slice({ H::clone_list(e.sub_pats) });\n+        ),\n+    (SplitSlice,\n+        rv.m_data = Data::make_SplitSlice({ H::clone_list(e.leading), e.extra_bind, H::clone_list(e.trailing) });\n+        )\n+    )\n+\n+    return rv;\n+}\n+\n+}   // namespace AST\n+"}, {"sha": "40cfa927b1f88b7df63f049a53ac61bd23e1a347", "filename": "gcc/rust/mrustc_parser/ast/pattern.hpp", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,205 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/pattern.hpp\n+ * - AST Pattern representation\n+ */\n+\n+#ifndef _AST__PATTERN_HPP_INCLUDED_\n+#define _AST__PATTERN_HPP_INCLUDED_\n+\n+#include <vector>\n+#include <memory>\n+#include <string>\n+#include <tagged_union.hpp>\n+#include <ident.hpp>\n+#include \"path.hpp\"\n+\n+namespace AST {\n+\n+using ::std::unique_ptr;\n+using ::std::move;\n+class MacroInvocation;\n+\n+class PatternBinding\n+{\n+public:\n+    enum class Type {\n+        MOVE,\n+        REF,\n+        MUTREF,\n+    };\n+    Ident   m_name;\n+    Type    m_type;\n+    bool    m_mutable;\n+    unsigned int    m_slot;\n+\n+    PatternBinding():\n+        m_name({}, \"\"),\n+        m_type(Type::MOVE),\n+        m_mutable(false),\n+        m_slot( ~0u )\n+    {}\n+    PatternBinding(Ident name, Type ty, bool ismut):\n+        m_name(::std::move(name)),\n+        m_type(ty),\n+        m_mutable(ismut),\n+        m_slot( ~0u )\n+    {}\n+\n+    PatternBinding(PatternBinding&& x) = default;\n+    PatternBinding(const PatternBinding& x) = default;\n+    PatternBinding& operator=(PatternBinding&& x) = default;\n+\n+    bool is_valid() const { return m_name.name != \"\"; }\n+};\n+\n+class Pattern\n+{\n+public:\n+    TAGGED_UNION(Value, Invalid,\n+        (Invalid, struct {}),\n+        (Integer, struct {\n+            enum eCoreType type;\n+            uint64_t value; // Signed numbers are encoded as 2's complement\n+            }),\n+        (Float, struct {\n+            enum eCoreType type;\n+            double value;\n+            }),\n+        (String, ::std::string),\n+        (ByteString, struct { ::std::string v; }),\n+        (Named, Path)\n+        );\n+\n+    struct TuplePat {\n+        ::std::vector<Pattern>  start;\n+        bool has_wildcard;\n+        ::std::vector<Pattern>  end;\n+    };\n+\n+    TAGGED_UNION(Data, Any,\n+        (MaybeBind, struct { Ident name; } ),\n+        (Macro,     struct { unique_ptr<::AST::MacroInvocation> inv; } ),\n+        (Any,       struct { } ),\n+        (Box,       struct { unique_ptr<Pattern> sub; } ),\n+        (Ref,       struct { bool mut; unique_ptr<Pattern> sub; } ),\n+        (Value,     struct { Value start; Value end; } ),\n+        (Tuple,     TuplePat ),\n+        (StructTuple, struct { Path path; TuplePat tup_pat; } ),\n+        (Struct,    struct { Path path; ::std::vector< ::std::pair< ::std::string, Pattern> > sub_patterns; bool is_exhaustive; } ),\n+        (Slice,     struct { ::std::vector<Pattern> sub_pats; }),\n+        (SplitSlice, struct { ::std::vector<Pattern> leading; PatternBinding extra_bind; ::std::vector<Pattern> trailing; } )\n+        );\n+private:\n+    Span    m_span;\n+    PatternBinding  m_binding;\n+    Data m_data;\n+\n+public:\n+    virtual ~Pattern();\n+\n+    Pattern()\n+    {}\n+    Pattern(Pattern&&) = default;\n+    Pattern& operator=(Pattern&&) = default;\n+\n+    Pattern(Span sp, Data dat):\n+        m_span( mv$(sp) ),\n+        m_data( mv$(dat) )\n+    {};\n+\n+    struct TagMaybeBind {};\n+    Pattern(TagMaybeBind, Span sp, Ident name):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_MaybeBind({ mv$(name) }) )\n+    {}\n+\n+    struct TagMacro {};\n+    Pattern(TagMacro, Span sp, unique_ptr<::AST::MacroInvocation> inv):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_Macro({ mv$(inv) }) )\n+    {}\n+\n+    struct TagBind {};\n+    Pattern(TagBind, Span sp, Ident name, PatternBinding::Type ty = PatternBinding::Type::MOVE, bool is_mut=false):\n+        m_span( mv$(sp) ),\n+        m_binding( PatternBinding(mv$(name), ty, is_mut) )\n+    {}\n+\n+    struct TagBox {};\n+    Pattern(TagBox, Span sp, Pattern sub):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_Box({ unique_ptr<Pattern>(new Pattern(mv$(sub))) }) )\n+    {}\n+\n+    struct TagValue {};\n+    Pattern(TagValue, Span sp, Value val, Value end = Value()):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_Value({ ::std::move(val), ::std::move(end) }) )\n+    {}\n+\n+\n+    struct TagReference {};\n+    Pattern(TagReference, Span sp, bool is_mutable, Pattern sub_pattern):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_Ref( /*Data::Data_Ref */ {\n+            is_mutable, unique_ptr<Pattern>(new Pattern(::std::move(sub_pattern)))\n+            }) )\n+    {\n+    }\n+\n+    struct TagTuple {};\n+    Pattern(TagTuple, Span sp, ::std::vector<Pattern> pats):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_Tuple( TuplePat { mv$(pats), false, {} } ) )\n+    {}\n+    Pattern(TagTuple, Span sp, TuplePat pat):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_Tuple( mv$(pat) ) )\n+    {}\n+\n+    struct TagNamedTuple {};\n+    Pattern(TagNamedTuple, Span sp, Path path, ::std::vector<Pattern> pats):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_StructTuple( { mv$(path), TuplePat { mv$(pats), false, {} } } ) )\n+    {}\n+    Pattern(TagNamedTuple, Span sp, Path path, TuplePat pat = TuplePat { {}, false, {} }):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_StructTuple( { ::std::move(path), ::std::move(pat) } ) )\n+    {}\n+\n+    struct TagStruct {};\n+    Pattern(TagStruct, Span sp, Path path, ::std::vector< ::std::pair< ::std::string,Pattern> > sub_patterns, bool is_exhaustive):\n+        m_span( mv$(sp) ),\n+        m_data( Data::make_Struct( { ::std::move(path), ::std::move(sub_patterns), is_exhaustive } ) )\n+    {}\n+\n+    // Mutators\n+    void set_bind(Ident name, PatternBinding::Type type, bool is_mut) {\n+        m_binding = PatternBinding(mv$(name), type, is_mut);\n+    }\n+\n+\n+    const Span& span() const { return m_span; }\n+\n+    Pattern clone() const;\n+\n+    // Accessors\n+          PatternBinding& binding()       { return m_binding; }\n+    const PatternBinding& binding() const { return m_binding; }\n+          Data& data()       { return m_data; }\n+    const Data& data() const { return m_data; }\n+          Path& path()       { return m_data.as_StructTuple().path; }\n+    const Path& path() const { return m_data.as_StructTuple().path; }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const Pattern& pat);\n+};\n+\n+extern ::std::ostream& operator<<(::std::ostream& os, const Pattern::Value& val);\n+extern ::std::ostream& operator<<(::std::ostream& os, const Pattern::TuplePat& val);\n+\n+};\n+\n+#endif"}, {"sha": "98bc6ee13bfdf9cdf699a85633e80504668c8c46", "filename": "gcc/rust/mrustc_parser/ast/types.cpp", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,334 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * types.cpp\n+ * - Backing code for the TypeRef class\n+ *\n+ * Handles a chunk of type resolution (merging) and matching/comparing types\n+ */\n+#include \"types.hpp\"\n+#include \"ast/ast.hpp\"\n+#include <ast/crate.hpp>\n+#include <ast/expr.hpp>\n+\n+/// Mappings from internal type names to the core type enum\n+static const struct {\n+    const char* name;\n+    enum eCoreType  type;\n+} CORETYPES[] = {\n+    // NOTE: Sorted\n+    {\"_\", CORETYPE_ANY},\n+    {\"bool\", CORETYPE_BOOL},\n+    {\"char\", CORETYPE_CHAR},\n+    {\"f32\", CORETYPE_F32},\n+    {\"f64\", CORETYPE_F64},\n+    {\"i128\", CORETYPE_I128},\n+    {\"i16\", CORETYPE_I16},\n+    {\"i32\", CORETYPE_I32},\n+    {\"i64\", CORETYPE_I64},\n+    {\"i8\", CORETYPE_I8},\n+    {\"int\", CORETYPE_INT},\n+    {\"isize\", CORETYPE_INT},\n+    {\"str\", CORETYPE_STR},\n+    {\"u128\", CORETYPE_U128},\n+    {\"u16\", CORETYPE_U16},\n+    {\"u32\", CORETYPE_U32},\n+    {\"u64\", CORETYPE_U64},\n+    {\"u8\",  CORETYPE_U8},\n+    {\"uint\", CORETYPE_UINT},\n+    {\"usize\", CORETYPE_UINT},\n+};\n+\n+enum eCoreType coretype_fromstring(const ::std::string& name)\n+{\n+    for(unsigned int i = 0; i < sizeof(CORETYPES)/sizeof(CORETYPES[0]); i ++)\n+    {\n+        if( name < CORETYPES[i].name )\n+            break;\n+        if( name == CORETYPES[i].name )\n+            return CORETYPES[i].type;\n+    }\n+    return CORETYPE_INVAL;\n+}\n+\n+const char* coretype_name(const eCoreType ct ) {\n+    switch(ct)\n+    {\n+    case CORETYPE_INVAL:return \"INVAL\";\n+    case CORETYPE_ANY:  return \"_\";\n+    case CORETYPE_CHAR: return \"char\";\n+    case CORETYPE_STR:  return \"str\";\n+    case CORETYPE_BOOL: return \"bool\";\n+    case CORETYPE_UINT: return \"usize\";\n+    case CORETYPE_INT:  return \"isize\";\n+    case CORETYPE_U8:   return \"u8\";\n+    case CORETYPE_I8:   return \"i8\";\n+    case CORETYPE_U16:  return \"u16\";\n+    case CORETYPE_I16:  return \"i16\";\n+    case CORETYPE_U32:  return \"u32\";\n+    case CORETYPE_I32:  return \"i32\";\n+    case CORETYPE_U64:  return \"u64\";\n+    case CORETYPE_I64:  return \"i64\";\n+    case CORETYPE_U128: return \"u128\";\n+    case CORETYPE_I128: return \"i128\";\n+    case CORETYPE_F32:  return \"f32\";\n+    case CORETYPE_F64:  return \"f64\";\n+    }\n+    DEBUG(\"Unknown core type?! \" << ct);\n+    return \"NFI\";\n+}\n+\n+Type_Function::Type_Function(const Type_Function& other):\n+    is_unsafe(other.is_unsafe),\n+    m_abi(other.m_abi),\n+    m_rettype( box$( other.m_rettype->clone() ) )\n+{\n+    for( const auto& at : other.m_arg_types )\n+        m_arg_types.push_back( at.clone() );\n+}\n+\n+Ordering Type_Function::ord(const Type_Function& x) const\n+{\n+    Ordering rv;\n+\n+    rv = ::ord(m_abi, x.m_abi);\n+    if(rv != OrdEqual)  return rv;\n+    rv = ::ord(m_arg_types, x.m_arg_types);\n+    if(rv != OrdEqual)  return rv;\n+    return (*m_rettype).ord( *x.m_rettype );\n+}\n+\n+TypeRef::~TypeRef()\n+{\n+}\n+\n+TypeRef TypeRef::clone() const\n+{\n+    struct H {\n+        static ::std::vector< ::TypeRef> clone_ty_vec(const ::std::vector<TypeRef>& x) {\n+            ::std::vector<TypeRef>  rv;\n+            rv.reserve(x.size());\n+            for(const auto& t : x)\n+                rv.push_back( t.clone() );\n+            return rv;\n+        }\n+    };\n+    switch( m_data.tag() )\n+    {\n+    case TypeData::TAGDEAD: assert(!\"Copying a destructed type\");\n+    #define _COPY(VAR)  case TypeData::TAG_##VAR: return TypeRef(m_span, TypeData::make_##VAR(m_data.as_##VAR()) ); break;\n+    #define _CLONE(VAR, ...)    case TypeData::TAG_##VAR: { auto& old = m_data.as_##VAR(); return TypeRef(m_span, TypeData::make_##VAR(__VA_ARGS__) ); } break;\n+    _COPY(None)\n+    _COPY(Any)\n+    _COPY(Bang)\n+    _CLONE(Macro, { old.inv.clone() })\n+    //case TypeData::TAG_Macro:   assert( !\"Copying an unexpanded type macro\" );\n+    _COPY(Unit)\n+    _COPY(Primitive)\n+    _COPY(Function)\n+    _CLONE(Tuple, { H::clone_ty_vec(old.inner_types) })\n+    _CLONE(Borrow,  { AST::LifetimeRef(old.lifetime), old.is_mut, box$(old.inner->clone()) })\n+    _CLONE(Pointer, { old.is_mut, box$(old.inner->clone()) })\n+    _CLONE(Array, { box$(old.inner->clone()), old.size })\n+    _COPY(Generic)\n+    _COPY(Path)\n+    _COPY(TraitObject)\n+    _COPY(ErasedType)\n+    #undef _COPY\n+    #undef _CLONE\n+    }\n+    throw \"\";\n+}\n+\n+Ordering Type_TraitPath::ord(const Type_TraitPath& x) const\n+{\n+    Ordering    rv;\n+\n+    rv = ::ord( this->path, x.path );\n+    if(rv != OrdEqual)  return rv;\n+\n+    return rv;\n+}\n+Ordering TypeRef::ord(const TypeRef& x) const\n+{\n+    Ordering    rv;\n+\n+    rv = ::ord( (unsigned)m_data.tag(), (unsigned)x.m_data.tag() );\n+    if(rv != OrdEqual)  return rv;\n+\n+    TU_MATCH(TypeData, (m_data, x.m_data), (ent, x_ent),\n+    (None, return OrdEqual;),\n+    (Macro, throw CompileError::BugCheck(\"TypeRef::ord - unexpanded macro\");),\n+    (Any,  return OrdEqual;),\n+    (Unit, return OrdEqual;),\n+    (Bang, return OrdEqual;),\n+    (Primitive,\n+        return ::ord( (unsigned)ent.core_type, (unsigned)x_ent.core_type );\n+        ),\n+    (Function,\n+        return ent.info.ord( x_ent.info );\n+        ),\n+    (Tuple,\n+        return ::ord(ent.inner_types, x_ent.inner_types);\n+        ),\n+    (Borrow,\n+        rv = ::ord(ent.is_mut, x_ent.is_mut);\n+        if(rv != OrdEqual)  return rv;\n+        return (*ent.inner).ord(*x_ent.inner);\n+        ),\n+    (Pointer,\n+        rv = ::ord(ent.is_mut, x_ent.is_mut);\n+        if(rv != OrdEqual)  return rv;\n+        return (*ent.inner).ord(*x_ent.inner);\n+        ),\n+    (Array,\n+        rv = (*ent.inner).ord( *x_ent.inner );\n+        if(rv != OrdEqual)  return rv;\n+        if(ent.size.get())\n+        {\n+            throw ::std::runtime_error(\"TODO: Sized array comparisons\");\n+        }\n+        return OrdEqual;\n+        ),\n+    (Generic,\n+        return ::ord(ent.name, x_ent.name);\n+        ),\n+    (Path,\n+        return ent.path.ord( x_ent.path );\n+        ),\n+    (TraitObject,\n+        return ::ord(ent.traits, x_ent.traits);\n+        ),\n+    (ErasedType,\n+        return ::ord(ent.traits, x_ent.traits);\n+        )\n+    )\n+    throw ::std::runtime_error(FMT(\"BUGCHECK - Unhandled TypeRef class '\" << m_data.tag() << \"'\"));\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const eCoreType ct) {\n+    return os << coretype_name(ct);\n+}\n+\n+void TypeRef::print(::std::ostream& os, bool is_debug/*=false*/) const\n+{\n+    //os << \"TypeRef(\";\n+    #define _(VAR, ...) case TypeData::TAG_##VAR: { const auto &ent = this->m_data.as_##VAR(); (void)&ent; __VA_ARGS__ } break;\n+    switch(this->m_data.tag())\n+    {\n+    case TypeData::TAGDEAD: throw \"\";\n+    _(None,\n+        os << \"!!\";\n+        )\n+    _(Any,\n+        os << \"_\";\n+        )\n+    _(Bang,\n+        os << \"!\";\n+        )\n+    _(Macro,\n+        os << ent.inv;\n+        )\n+    _(Unit,\n+        os << \"()\";\n+        )\n+    _(Primitive,\n+        os << ent.core_type;\n+        )\n+    _(Function,\n+        if( ent.info.m_abi != \"\" )\n+            os << \"extern \\\"\" << ent.info.m_abi << \"\\\" \";\n+        os << \"fn (\";\n+        for( const auto& arg : ent.info.m_arg_types )\n+        {\n+            arg.print(os, is_debug);\n+            os << \", \";\n+        }\n+        os << \") -> \" << *ent.info.m_rettype;\n+        )\n+    _(Tuple,\n+        os << \"( \";\n+        for( const auto& it : ent.inner_types )\n+        {\n+            it.print(os, is_debug);\n+            os << \", \";\n+        }\n+        os << \")\";\n+        )\n+    _(Borrow,\n+        os << \"&\" << (ent.is_mut ? \"mut \" : \"\");\n+        ent.inner->print(os, is_debug);\n+        )\n+    _(Pointer,\n+        os << \"*\" << (ent.is_mut ? \"mut\" : \"const\");\n+        ent.inner->print(os, is_debug);\n+        )\n+    _(Array,\n+        os << \"[\";\n+        ent.inner->print(os, is_debug);\n+        if( ent.size.get() )\n+            os << \"; \" << *ent.size;\n+        os << \"]\";\n+        )\n+    _(Generic,\n+        if(is_debug)\n+            os << \"/* arg */ \";\n+        os << ent.name;\n+        if(is_debug)\n+            os << \"/*\"<<ent.index<<\"*/\";\n+        )\n+    _(Path,\n+        ent.path.print_pretty(os, true, is_debug);\n+        )\n+    _(TraitObject,\n+        os << \"(\";\n+        for( const auto& it : ent.traits ) {\n+            if( &it != &ent.traits.front() )\n+                os << \"+\";\n+            os << it.hrbs;\n+            it.path.print_pretty(os, true, is_debug);\n+        }\n+        os << \")\";\n+        )\n+    _(ErasedType,\n+        os << \"impl \";\n+        for( const auto& it : ent.traits ) {\n+            if( &it != &ent.traits.front() )\n+                os << \"+\";\n+            os << it.hrbs;\n+            it.path.print_pretty(os, true, is_debug);\n+        }\n+        os << \"\";\n+        )\n+    }\n+    #undef _\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const TypeRef& tr) {\n+    tr.print(os, true);\n+    return os;\n+}\n+::std::ostream& operator<<(::std::ostream& os, const PrettyPrintType& x) {\n+    x.m_type.print(os, false);\n+    return os;\n+}\n+\n+namespace AST {\n+    ::std::ostream& operator<<(::std::ostream& os, const LifetimeRef& x) {\n+        if( x.m_binding == LifetimeRef::BINDING_STATIC ) {\n+            os << \"'static\";\n+        }\n+        else if( x.m_binding == LifetimeRef::BINDING_INFER ) {\n+            os << \"'_\";\n+        }\n+        else {\n+            os << \"'\" << x.m_name;\n+            if( x.m_binding != LifetimeRef::BINDING_UNBOUND ) {\n+                os << \"/*\" << x.m_binding << \"*/\";\n+            }\n+        }\n+        return os;\n+    }\n+}\n+"}, {"sha": "af07ba2dc6f777c8b81715830516f09b2060aa5e", "filename": "gcc/rust/mrustc_parser/ast/types.hpp", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,354 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * ast/types.hpp\n+ * - AST Type reference (and helpers)\n+ */\n+#ifndef TYPES_HPP_INCLUDED\n+#define TYPES_HPP_INCLUDED\n+\n+#include <memory>\n+\n+#include \"../common.hpp\"\n+#include \"coretypes.hpp\"\n+#include \"ast/path.hpp\"\n+#include \"ast/macro.hpp\"\n+#include <tagged_union.hpp>\n+\n+namespace AST {\n+class ExprNode;\n+class Expr;\n+class LifetimeParam;\n+}\n+\n+namespace AST {\n+\n+    // Defined here for dependency reasons\n+    class HigherRankedBounds\n+    {\n+    public:\n+        ::std::vector<LifetimeParam>    m_lifetimes;\n+        //::std::vector<TypeParam>    m_types;\n+        //::std::vector<GenericBound>    m_bounds;\n+\n+        bool empty() const {\n+            return m_lifetimes.empty();\n+        }\n+\n+        friend ::std::ostream& operator<<(::std::ostream& os, const HigherRankedBounds& x);\n+    };\n+\n+    class LifetimeRef\n+    {\n+        static const uint16_t BINDING_STATIC = 0xFFFF;\n+        static const uint16_t BINDING_UNBOUND = 0xFFFE;\n+        static const uint16_t BINDING_INFER = 0xFFFD;\n+\n+        Ident   m_name;\n+        uint16_t  m_binding;\n+\n+        LifetimeRef(Ident name, uint32_t binding):\n+            m_name( ::std::move(name) ),\n+            m_binding( binding )\n+        {\n+        }\n+    public:\n+        LifetimeRef():\n+            LifetimeRef(\"\", BINDING_INFER)\n+        {\n+        }\n+        LifetimeRef(Ident name):\n+            LifetimeRef(::std::move(name), BINDING_UNBOUND)\n+        {\n+        }\n+        static LifetimeRef new_static() {\n+            return LifetimeRef(\"static\", BINDING_STATIC);\n+        }\n+\n+        void set_binding(uint16_t b) { assert(m_binding == BINDING_UNBOUND); m_binding = b; }\n+        bool is_unbound() const { return m_binding == BINDING_UNBOUND; }\n+        bool is_infer() const { return m_binding == BINDING_INFER; }\n+\n+        const Ident& name() const { return m_name; }\n+        Ordering ord(const LifetimeRef& x) const { return ::ord(m_name.name, x.m_name.name); }\n+        bool operator==(const LifetimeRef& x) const { return ord(x) == OrdEqual; }\n+        bool operator!=(const LifetimeRef& x) const { return ord(x) != OrdEqual; }\n+        bool operator<(const LifetimeRef& x) const { return ord(x) == OrdLess; };\n+\n+        friend ::std::ostream& operator<<(::std::ostream& os, const LifetimeRef& x);\n+    };\n+}\n+\n+class PrettyPrintType\n+{\n+    const TypeRef&  m_type;\n+public:\n+    PrettyPrintType(const TypeRef& ty):\n+        m_type(ty)\n+    {}\n+\n+    void print(::std::ostream& os) const;\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const PrettyPrintType& v);\n+};\n+\n+struct TypeArgRef\n+{\n+    ::std::string   name;\n+    unsigned int    level;\n+    const AST::GenericParams*  params;\n+};\n+\n+struct Type_Function\n+{\n+    AST::HigherRankedBounds hrbs;\n+    bool    is_unsafe;\n+    ::std::string   m_abi;\n+    ::std::unique_ptr<TypeRef>  m_rettype;\n+    ::std::vector<TypeRef>  m_arg_types;\n+    bool is_variadic;\n+\n+    Type_Function() {}\n+    Type_Function(AST::HigherRankedBounds hrbs, bool is_unsafe, ::std::string abi, ::std::unique_ptr<TypeRef> ret, ::std::vector<TypeRef> args, bool is_variadic):\n+        hrbs(mv$(hrbs)),\n+        is_unsafe(is_unsafe),\n+        m_abi(mv$(abi)),\n+        m_rettype(mv$(ret)),\n+        m_arg_types(mv$(args)),\n+        is_variadic(is_variadic)\n+    {}\n+    Type_Function(Type_Function&& other) = default;\n+    Type_Function(const Type_Function& other);\n+\n+    Ordering ord(const Type_Function& x) const;\n+};\n+\n+struct Type_TraitPath\n+{\n+    AST::HigherRankedBounds hrbs;\n+    AST::Path   path;\n+\n+    Ordering ord(const Type_TraitPath& x) const;\n+};\n+\n+TAGGED_UNION(TypeData, None,\n+    (None, struct { }),\n+    (Any,  struct { }),\n+    (Bang, struct { }),\n+    (Unit, struct { }),\n+    (Macro, struct {\n+        ::AST::MacroInvocation inv;\n+        }),\n+    (Primitive, struct {\n+        enum eCoreType core_type;\n+        }),\n+    (Function, struct {\n+        Type_Function   info;\n+        }),\n+    (Tuple, struct {\n+        ::std::vector<TypeRef> inner_types;\n+        }),\n+    (Borrow, struct {\n+        AST::LifetimeRef lifetime;\n+        bool is_mut;\n+        ::std::unique_ptr<TypeRef> inner;\n+        }),\n+    (Pointer, struct {\n+        bool is_mut;\n+        ::std::unique_ptr<TypeRef> inner;\n+        }),\n+    (Array, struct {\n+        ::std::unique_ptr<TypeRef> inner;\n+        ::std::shared_ptr<AST::ExprNode> size;\n+        }),\n+    (Generic, struct {\n+        ::std::string name;\n+        unsigned int index;\n+        }),\n+    (Path, struct {\n+        AST::Path path;\n+        }),\n+    (TraitObject, struct {\n+        ::std::vector<Type_TraitPath>   traits;\n+        ::std::vector<AST::LifetimeRef> lifetimes;\n+        }),\n+    (ErasedType, struct {\n+        ::std::vector<Type_TraitPath>   traits;\n+        ::std::vector<AST::LifetimeRef> lifetimes;\n+        })\n+    );\n+\n+/// A type\n+class TypeRef\n+{\n+    Span    m_span;\n+public:\n+    TypeData    m_data;\n+\n+    ~TypeRef();\n+\n+    TypeRef(TypeRef&& other) = default;\n+    TypeRef& operator=(TypeRef&& other) = default;\n+\n+    #if 1\n+    TypeRef(const TypeRef& other) = delete;\n+    TypeRef& operator=(const TypeRef& other) = delete;\n+    #else\n+    TypeRef(const TypeRef& other): m_span(other.m_span) {\n+        *this = other.clone();\n+    }\n+    TypeRef& operator=(const TypeRef& other) {\n+        m_data = mv$(other.clone().m_data);\n+        return *this;\n+    }\n+    #endif\n+\n+    TypeRef(Span sp):\n+        m_span( mv$(sp) ),\n+        m_data( TypeData::make_Any({}) )\n+    {}\n+    TypeRef(Span sp, TypeData data):\n+        m_span( mv$(sp) ),\n+        m_data( mv$(data) )\n+    {}\n+\n+    struct TagInvalid {};\n+    TypeRef(TagInvalid, Span sp):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_None({}))\n+    {}\n+\n+    struct TagMacro {};\n+    TypeRef(TagMacro, ::AST::MacroInvocation inv):\n+        m_span(inv.span()),\n+        m_data(TypeData::make_Macro({mv$(inv)}))\n+    {}\n+\n+    struct TagUnit {};  // unit maps to a zero-length tuple, just easier to type\n+    TypeRef(TagUnit, Span sp):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Unit({}))\n+    {}\n+\n+    struct TagPrimitive {};\n+    TypeRef(TagPrimitive, Span sp, enum eCoreType type):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Primitive({type}))\n+    {}\n+    TypeRef(Span sp, enum eCoreType type):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Primitive({type}))\n+    {}\n+\n+    struct TagTuple {};\n+    TypeRef(TagTuple , Span sp, ::std::vector<TypeRef> inner_types):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Tuple({::std::move(inner_types)}))\n+    {}\n+    struct TagFunction {};\n+    TypeRef(TagFunction, Span sp, AST::HigherRankedBounds hrbs, bool is_unsafe, ::std::string abi, ::std::vector<TypeRef> args, bool is_variadic, TypeRef ret):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Function({ Type_Function( mv$(hrbs), is_unsafe, abi, box$(ret), mv$(args), is_variadic ) }))\n+    {}\n+\n+    struct TagReference {};\n+    TypeRef(TagReference , Span sp, AST::LifetimeRef lft, bool is_mut, TypeRef inner_type):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Borrow({ ::std::move(lft), is_mut, ::make_unique_ptr(mv$(inner_type)) }))\n+    {}\n+    struct TagPointer {};\n+    TypeRef(TagPointer , Span sp, bool is_mut, TypeRef inner_type):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Pointer({ is_mut, ::make_unique_ptr(mv$(inner_type)) }))\n+    {}\n+    struct TagSizedArray {};\n+    TypeRef(TagSizedArray , Span sp, TypeRef inner_type, ::std::shared_ptr<AST::ExprNode> size):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Array({ ::make_unique_ptr(mv$(inner_type)), mv$(size) }))\n+    {}\n+    struct TagUnsizedArray {};\n+    TypeRef(TagUnsizedArray , Span sp, TypeRef inner_type):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Array({ ::make_unique_ptr(mv$(inner_type)), ::std::shared_ptr<AST::ExprNode>() }))\n+    {}\n+\n+    struct TagArg {};\n+    TypeRef(TagArg, Span sp, ::std::string name, unsigned int binding = ~0u):\n+        m_span( mv$(sp) ),\n+        m_data(TypeData::make_Generic({ name, binding }))\n+    {}\n+    TypeRef(Span sp, ::std::string name, unsigned int binding = ~0u):\n+        TypeRef(TagArg(), mv$(sp), mv$(name), binding)\n+    {}\n+\n+    struct TagPath {};\n+    TypeRef(TagPath, Span sp, AST::Path path):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_Path({ ::std::move(path) }))\n+    {}\n+    TypeRef(Span sp, AST::Path path):\n+        TypeRef(TagPath(), mv$(sp), mv$(path))\n+    {}\n+\n+    TypeRef( Span sp, ::std::vector<Type_TraitPath> traits, ::std::vector<AST::LifetimeRef> lifetimes ):\n+        m_span(mv$(sp)),\n+        m_data(TypeData::make_TraitObject({ ::std::move(traits), mv$(lifetimes) }))\n+    {}\n+\n+\n+    const Span& span() const { return m_span; }\n+\n+    bool is_valid() const { return ! m_data.is_None(); }\n+\n+    bool is_unbounded() const { return m_data.is_Any(); }\n+    bool is_wildcard() const { return m_data.is_Any(); }\n+\n+    bool is_unit() const { return m_data.is_Unit(); }\n+    bool is_primitive() const { return m_data.is_Primitive(); }\n+\n+    bool is_path() const { return m_data.is_Path(); }\n+    const AST::Path& path() const { return m_data.as_Path().path; }\n+    AST::Path& path() { return m_data.as_Path().path; }\n+\n+    bool is_type_param() const { return m_data.is_Generic(); }\n+    const ::std::string& type_param() const { return m_data.as_Generic().name; }\n+\n+    bool is_reference() const { return m_data.is_Borrow(); }\n+    bool is_pointer() const { return m_data.is_Pointer(); }\n+    bool is_tuple() const { return m_data.is_Tuple(); }\n+\n+    TypeRef clone() const;\n+\n+    const TypeRef& inner_type() const {\n+        TU_MATCH_DEF(TypeData, (m_data), (e),\n+        ( throw ::std::runtime_error(\"Called inner_type on non-wrapper\"); ),\n+        (Borrow,  return *e.inner; ),\n+        (Pointer, return *e.inner; ),\n+        (Array,   return *e.inner; )\n+        )\n+    }\n+    TypeRef& inner_type() {\n+        TU_MATCH_DEF(TypeData, (m_data), (e),\n+        ( throw ::std::runtime_error(\"Called inner_type on non-wrapper\"); ),\n+        (Borrow,  return *e.inner; ),\n+        (Pointer, return *e.inner; ),\n+        (Array,   return *e.inner; )\n+        )\n+    }\n+\n+    Ordering ord(const TypeRef& x) const;\n+    bool operator==(const TypeRef& x) const { return ord(x) == OrdEqual; }\n+    bool operator!=(const TypeRef& x) const { return ord(x) != OrdEqual; }\n+    bool operator<(const TypeRef& x) const { return ord(x) == OrdLess; };\n+\n+    void print(::std::ostream& os, bool is_debug=false) const;\n+\n+    PrettyPrintType print_pretty() const { return PrettyPrintType(*this); }\n+\n+    friend class PrettyPrintType;\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const TypeRef& tr);\n+};\n+\n+#endif // TYPES_HPP_INCLUDED"}, {"sha": "31a212ad3c31c5e2de2dac1d0a97be0e025b85e2", "filename": "gcc/rust/mrustc_parser/gcc-interface-test/gcc-interface.cc", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Fgcc-interface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Fgcc-interface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Fgcc-interface.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,434 @@\n+// gcc interface main - do stuff here\n+\n+#include \"common/common-target.h\"\n+#include \"config.h\"\n+#include \"convert.h\"\n+#include \"coretypes.h\"\n+#include \"debug.h\"\n+#include \"diagnostic.h\"\n+#include \"fold-const.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimplify.h\"\n+#include \"langhooks-def.h\"\n+#include \"langhooks.h\"\n+#include \"opts.h\"\n+#include \"stor-layout.h\"\n+#include \"system.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+\n+#include <mpfr.h>\n+\n+#include \"rust-c-interface.h\"\n+\n+/* Language-dependent contents of a type.  */\n+// seems to be a \"gengtype\" of some kind\n+struct GTY(()) lang_type {\n+    char dummy;\n+};\n+\n+/* Language-dependent contents of a decl.  */\n+\n+struct GTY(()) lang_decl {\n+    char dummy;\n+};\n+\n+/* Language-dependent contents of an identifier.  This must include a\n+   tree_identifier.  */\n+\n+struct GTY(()) lang_identifier {\n+    struct tree_identifier common;\n+};\n+\n+/* The resulting tree type.  */\n+union GTY((desc(\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+           chain_next(\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), TS_COMMON) ? \n+           ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n+  lang_tree_node {\n+    union tree_node GTY((tag(\"0\"),\n+                         desc(\"tree_node_structure (&%h)\"))) generic;\n+    struct lang_identifier GTY((tag(\"1\"))) identifier;\n+};\n+\n+/* We don't use language_function.  */\n+struct GTY(()) language_function {\n+    int dummy;\n+};\n+\n+/* Option information we need to pass to rust_create_grs.  */\n+\n+static const char* rust_pkgpath = NULL;\n+static const char* rust_prefix = NULL;\n+static const char* rust_relative_import_path = NULL;\n+static const char* rust_c_header = NULL;\n+\n+/* Language hooks.  */\n+\n+static bool grs_langhook_init(void) {\n+    build_common_tree_nodes(false);\n+\n+    /* I don't know why this has to be done explicitly.  */\n+    void_list_node = build_tree_list(NULL_TREE, void_type_node);\n+\n+    // not currently relevant\n+    /* We must create the grs IR after calling build_common_tree_nodes\n+     (because Gorust::define_builtin_function_trees refers indirectly\n+     to, e.g., unsigned_char_type_node) but before calling\n+     build_common_builtin_nodes (because it calls, indirectly,\n+     rust_type_for_size).  */\n+    /* struct rust_create_grs_args args;\n+    args.int_type_size = INT_TYPE_SIZE;\n+    args.pointer_size = POINTER_SIZE;\n+    args.pkgpath = rust_pkgpath;\n+    args.prefix = rust_prefix;\n+    args.relative_import_path = rust_relative_import_path;\n+    args.c_header = rust_c_header;\n+    args.check_divide_by_zero = rust_check_divide_zero;\n+    args.check_divide_overflow = rust_check_divide_overflow;\n+    args.compiling_runtime = rust_compiling_runtime;\n+    args.debug_escape_level = rust_debug_escape_level;\n+    args.debug_escape_hash = rust_debug_escape_hash;\n+    args.nil_check_size_threshold = TARGET_AIX ? -1 : 4096;\n+    args.debug_optimization = rust_debug_optimization;\n+    args.linemap = rust_get_linemap();\n+    args.backend = rust_get_backend();\n+    rust_create_grs(&args);*/\n+\n+    build_common_builtin_nodes();\n+\n+    /* The default precision for floating point numbers.  This is used\n+     for floating point constants with abstract type.  This may\n+     eventually be controllable by a command line option.  */\n+    mpfr_set_default_prec(128);\n+\n+    /* Rust uses exceptions.  */\n+    using_eh_for_cleanups();\n+\n+    // maybe get rid of this?\n+    rdot_init();\n+\n+    return true;\n+}\n+\n+/* Initialize the options structure before parsing options.  */\n+static void grs_langhook_init_options_struct(struct gcc_options* opts) {\n+    /* Go says that signed overflow is precisely defined.  */\n+    opts->x_flag_wrapv = 1;\n+\n+    /* We default to using strict aliasing, since Go pointers are safe.\n+     This is turned off for code that imports the \"unsafe\" package,\n+     because using unsafe.pointer violates C style aliasing\n+     requirements.  */\n+    opts->x_flag_strict_aliasing = 1;\n+\n+    /* Default to avoiding range issues for complex multiply and\n+     divide.  */\n+    opts->x_flag_complex_method = 2;\n+\n+    /* The builtin math functions should not set errno.  */\n+    opts->x_flag_errno_math = 0;\n+    opts->frontend_set_flag_errno_math = true;\n+\n+    /* Turn on stack splitting if possible? */\n+    // no definition for that anymore, apparently\n+    /* if (targetm_common.supports_split_stack(false, opts))\n+        opts->x_flag_split_stack = 1; */\n+\n+    /* Exceptions are used to handle recovering from panics.  */\n+    opts->x_flag_exceptions = 1;\n+    opts->x_flag_non_call_exceptions = 1;\n+\n+    // nope, don't need this because no gc\n+    /* We need to keep pointers live for the garbage collector.  */\n+    //opts->x_flag_keep_gc_roots_live = 1;\n+\n+    /* Go programs expect runtime.Callers to work, and that uses\n+     libbacktrace that uses debug info.  Set the debug info level to 1\n+     by default.  In post_options we will set the debug type if the\n+     debug info level was not set back to 0 on the command line.  */\n+    opts->x_debug_info_level = DINFO_LEVEL_TERSE;\n+}\n+\n+// doesn't seem to be needed, currently\n+/*  Infrastructure for a vector of char * pointers.  */\n+/* typedef const char* rust_char_p;*/\n+\n+/* The list of directories to search after all the Go specific\n+   directories have been searched.  */\n+/* static vec<rust_char_p> rust_search_dirs;*/\n+\n+/* Handle grs specific options.  Return 0 if we didn't do anything.  */\n+static bool grs_langhook_handle_option(size_t scode, const char* arg ATTRIBUTE_UNUSED, \n+    int value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED, \n+    const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n+    enum opt_code code = (enum opt_code)scode;\n+    bool ret = true;\n+\n+    // ignore options...\n+    switch (code) {\n+\n+        default:\n+            /* Just return 1 to indicate that the option is valid.  */\n+            break;\n+    }\n+\n+    return ret;\n+}\n+\n+/* Run after parsing options.  */\n+static bool grs_langhook_post_options(const char** pfilename ATTRIBUTE_UNUSED) {\n+\n+    if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT)\n+        flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n+\n+    /* We turn on stack splitting if we can.  */\n+    if (!global_options_set.x_flag_split_stack && targetm_common.supports_split_stack(false, \n+        &global_options))\n+        global_options.x_flag_split_stack = 1;\n+\n+    /* If stack splitting is turned on, and the user did not explicitly\n+     request function partitioning, turn off partitioning, as it\n+     confuses the linker when trying to handle partitioned split-stack\n+     code that calls a non-split-stack function.  */\n+    if (global_options.x_flag_split_stack && global_options.x_flag_reorder_blocks_and_partition \n+        && !global_options_set.x_flag_reorder_blocks_and_partition)\n+        global_options.x_flag_reorder_blocks_and_partition = 0;\n+\n+    /* Returning false means that the backend should be used.  */\n+    return false;\n+}\n+\n+static void grs_langhook_parse_file(void) {\n+    //grs_parse_input_files(in_fnames, num_in_fnames, flag_syntax_only, rust_require_return_statement);\n+\n+    /* Final processing of globals and early debug info generation.  */\n+    //rust_write_globals();\n+\n+    // loop through all input file names\n+    for (size_t idx = 0; idx < num_in_fnames; idx++) {\n+        // get input file string for index\n+        const char* in = in_fnames[idx];\n+        GRS_current_infname = xstrdup(in);\n+        GRS_current_infile = basename(GRS_current_infname);\n+        grs_do_compile(in); // calls lexer?\n+    }\n+}\n+\n+static tree grs_langhook_type_for_size(unsigned int bits ATTRIBUTE_UNUSED,\n+                                       int unsignedp ATTRIBUTE_UNUSED) {\n+    /* tree type;\n+    if (unsignedp) {\n+        if (bits == INT_TYPE_SIZE)\n+            type = unsigned_type_node;\n+        else if (bits == CHAR_TYPE_SIZE)\n+            type = unsigned_char_type_node;\n+        else if (bits == SHORT_TYPE_SIZE)\n+            type = short_unsigned_type_node;\n+        else if (bits == LONG_TYPE_SIZE)\n+            type = long_unsigned_type_node;\n+        else if (bits == LONG_LONG_TYPE_SIZE)\n+            type = long_long_unsigned_type_node;\n+        else\n+            type = make_unsigned_type(bits);\n+    } else {\n+        if (bits == INT_TYPE_SIZE)\n+            type = integer_type_node;\n+        else if (bits == CHAR_TYPE_SIZE)\n+            type = signed_char_type_node;\n+        else if (bits == SHORT_TYPE_SIZE)\n+            type = short_integer_type_node;\n+        else if (bits == LONG_TYPE_SIZE)\n+            type = long_integer_type_node;\n+        else if (bits == LONG_LONG_TYPE_SIZE)\n+            type = long_long_integer_type_node;\n+        else\n+            type = make_signed_type(bits);\n+    }\n+    return type;*/\n+\n+    gcc_unreachable();\n+\n+    return NULL_TREE;\n+}\n+\n+static tree grs_langhook_type_for_mode(enum machine_mode mode, int unsignedp) {\n+    if (mode == TYPE_MODE(float_type_node))\n+        return float_type_node;\n+\n+    if (mode == TYPE_MODE(double_type_node))\n+        return double_type_node;\n+\n+    if (mode == TYPE_MODE(integer_type_node))\n+        return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+    if (mode == TYPE_MODE(long_integer_type_node))\n+        return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+    if (COMPLEX_MODE_P(mode)) {\n+        if (mode == TYPE_MODE(complex_float_type_node))\n+            return complex_float_type_node;\n+\n+        if (mode == TYPE_MODE(complex_double_type_node))\n+            return complex_double_type_node;\n+\n+        if (mode == TYPE_MODE(complex_long_double_type_node))\n+            return complex_long_double_type_node;\n+\n+        if (mode == TYPE_MODE(complex_integer_type_node) && !unsignedp)\n+            return complex_integer_type_node;\n+    }\n+\n+    /* gcc unreachable */\n+    return NULL;\n+}\n+\n+/* Record a builtin function.  We just ignore builtin functions.  */\n+static tree grs_langhook_builtin_function(tree decl) {\n+    return decl;\n+}\n+\n+/* Return true if we are in the global binding level.  */\n+static bool grs_langhook_global_bindings_p(void) {\n+    return current_function_decl == NULL_TREE;\n+}\n+\n+/* Push a declaration into the current binding level.  We can't\n+   usefully implement this since we don't want to convert from tree\n+   back to one of our internal data structures.  I think the only way\n+   this is used is to record a decl which is to be returned by\n+   getdecls, and we could implement it for that purpose if\n+   necessary.  */\n+static tree grs_langhook_pushdecl(tree decl ATTRIBUTE_UNUSED) {\n+    gcc_unreachable();\n+    return NULL;\n+}\n+\n+/* This hook is used to get the current list of declarations as trees.\n+   We don't support that; instead we use the write_globals hook.  This\n+   can't simply crash because it is called by -gstabs.  */\n+static tree grs_langhook_getdecls(void) {\n+    gcc_unreachable();\n+    return NULL;\n+}\n+\n+/* Write out globals. */\n+static void grs_langhook_write_globals(void) {\n+    // pass off to middle-end function, basically\n+    dot_pass_WriteGlobals();\n+}\n+\n+static unsigned int grs_langhook_option_lang_mask(void) {\n+    return CL_Rust;\n+}\n+\n+/* Return a decl for the exception personality function.  The function\n+   itself is implemented in librust/runtime/rust-unwind.c.  */\n+static tree grs_langhook_eh_personality(void) {\n+    static tree personality_decl;\n+\n+    if (personality_decl == NULL_TREE) {\n+        personality_decl = build_personality_function(\"gccrs\");\n+        grs_preserve_from_gc(personality_decl);\n+    }\n+\n+    return personality_decl;\n+}\n+\n+/* Rust-specific gimplification.  We need to gimplify\n+   CALL_EXPR_STATIC_CHAIN, because the gimplifier doesn't handle\n+   it.  */\n+static int grs_langhook_gimplify_expr(tree* expr_p ATTRIBUTE_UNUSED, \n+    gimple_seq* pre_p ATTRIBUTE_UNUSED, gimple_seq* post_p ATTRIBUTE_UNUSED) {\n+    if (TREE_CODE(*expr_p) == CALL_EXPR && CALL_EXPR_STATIC_CHAIN(*expr_p) != NULL_TREE)\n+        gimplify_expr(&CALL_EXPR_STATIC_CHAIN(*expr_p), pre_p, post_p, is_gimple_val, fb_rvalue);\n+\n+    /* Often useful to use debug_tree here to see what's going on because every gimplification calls\n+       this. */\n+    //debug_tree(*expr_p)\n+    return GS_UNHANDLED;\n+}\n+\n+/* Functions called directly by the generic backend.  */\n+tree convert(tree type, tree expr) {\n+    if (type == error_mark_node || expr == error_mark_node || TREE_TYPE(expr) == error_mark_node)\n+        return error_mark_node;\n+\n+    if (type == TREE_TYPE(expr))\n+        return expr;\n+\n+    if (TYPE_MAIN_VARIANT(type) == TYPE_MAIN_VARIANT(TREE_TYPE(expr)))\n+        return fold_convert(type, expr);\n+\n+    switch (TREE_CODE(type)) {\n+        case VOID_TYPE:\n+        case BOOLEAN_TYPE:\n+            return fold_convert(type, expr);\n+        case INTEGER_TYPE:\n+            return fold(convert_to_integer(type, expr));\n+        case POINTER_TYPE:\n+            return fold(convert_to_pointer(type, expr));\n+        case REAL_TYPE:\n+            return fold(convert_to_real(type, expr));\n+        case COMPLEX_TYPE:\n+            return fold(convert_to_complex(type, expr));\n+        default:\n+            break;\n+    }\n+\n+    gcc_unreachable();\n+}\n+\n+static GTY(()) tree grs_gc_root;\n+void grs_preserve_from_gc(tree t) {\n+    grs_gc_root = tree_cons(NULL_TREE, t, grs_gc_root);\n+}\n+\n+// seems to be unused\n+/* Convert an identifier for use in an error message.  */\n+/* const char* rust_localize_identifier(const char* ident) {\n+    return identifier_to_locale(ident);\n+}*/\n+\n+/* The language hooks data structure. This is the main interface between the GCC front-end\n+ * and the GCC middle-end/back-end. A list of language hooks could be found in\n+ * <gcc>/langhooks.h\n+ */\n+#undef LANG_HOOKS_NAME\n+#undef LANG_HOOKS_INIT\n+#undef LANG_HOOKS_OPTION_LANG_MASK\n+#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n+#undef LANG_HOOKS_HANDLE_OPTION\n+#undef LANG_HOOKS_POST_OPTIONS\n+#undef LANG_HOOKS_PARSE_FILE\n+#undef LANG_HOOKS_TYPE_FOR_MODE\n+#undef LANG_HOOKS_TYPE_FOR_SIZE\n+#undef LANG_HOOKS_BUILTIN_FUNCTION\n+#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n+#undef LANG_HOOKS_PUSHDECL\n+#undef LANG_HOOKS_GETDECLS\n+#undef LANG_HOOKS_WRITE_GLOBALS\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#undef LANG_HOOKS_EH_PERSONALITY\n+\n+#define LANG_HOOKS_NAME                 \"GNU Rust\"\n+#define LANG_HOOKS_INIT                 grs_langhook_init\n+#define LANG_HOOKS_OPTION_LANG_MASK     grs_langhook_option_lang_mask\n+#define LANG_HOOKS_INIT_OPTIONS_STRUCT  grs_langhook_init_options_struct\n+#define LANG_HOOKS_HANDLE_OPTION        grs_langhook_handle_option\n+#define LANG_HOOKS_POST_OPTIONS         grs_langhook_post_options\n+#define LANG_HOOKS_PARSE_FILE           grs_langhook_parse_file\n+#define LANG_HOOKS_TYPE_FOR_MODE        grs_langhook_type_for_mode\n+#define LANG_HOOKS_TYPE_FOR_SIZE        grs_langhook_type_for_size\n+#define LANG_HOOKS_BUILTIN_FUNCTION     grs_langhook_builtin_function\n+#define LANG_HOOKS_GLOBAL_BINDINGS_P    grs_langhook_global_bindings_p\n+#define LANG_HOOKS_PUSHDECL             grs_langhook_pushdecl\n+#define LANG_HOOKS_GETDECLS             grs_langhook_getdecls\n+#define LANG_HOOKS_WRITE_GLOBALS        grs_langhook_write_globals\n+#define LANG_HOOKS_GIMPLIFY_EXPR        grs_langhook_gimplify_expr\n+#define LANG_HOOKS_EH_PERSONALITY       grs_langhook_eh_personality\n+\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+#include \"gt-rust-rs-lang.h\"\n+#include \"gtype-rust.h\"\n+// TODO: something to do with this, maybe"}, {"sha": "2a8eecf1ec60cfa511b73eb9a270124bdcb71462", "filename": "gcc/rust/mrustc_parser/gcc-interface-test/rust-c-interface.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Frust-c-interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Frust-c-interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Frust-c-interface.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,58 @@\n+// mrustc-GCC interface header\n+\n+#ifndef RUST_C_INT_H\n+#define RUST_C_INT_H\n+\n+/* Functions defined in the Rust frontend proper called by the GCC\n+   interface. TODO move around */\n+\n+extern int rust_enable_dump(const char*);\n+extern int rust_enable_optimize(const char*, int);\n+\n+extern void grs_add_search_path(const char*);\n+\n+struct rust_create_grs_args {\n+    int int_type_size;\n+    int pointer_size;\n+    const char* pkgpath;\n+    const char* prefix;\n+    const char* relative_import_path;\n+    const char* c_header;\n+    //Backend* backend;\n+    //Linemap* linemap;\n+    bool check_divide_by_zero;\n+    bool check_divide_overflow;\n+    bool compiling_runtime;\n+    int debug_escape_level;\n+    const char* debug_escape_hash;\n+    int64_t nil_check_size_threshold;\n+    bool debug_optimization;\n+};\n+\n+extern void rust_create_gsr(const struct rust_create_grs_args*);\n+\n+extern void grs_parse_input_files(const char**, unsigned int, bool only_check_syntax, \n+    bool require_return_statement);\n+extern void grs_write_globals(void);\n+\n+/* Functions defined in the GCC interface called by the Rust frontend\n+   proper. TODO: move around */\n+\n+extern void grs_preserve_from_gc(tree);\n+\n+extern bool saw_errors(void);\n+\n+extern const char* rust_localize_identifier(const char*);\n+\n+extern unsigned int rust_field_alignment(tree);\n+\n+extern void rust_imported_unsafe(void);\n+\n+extern void rust_write_export_data(const char*, unsigned int);\n+\n+extern const char* rust_read_export_data(int, off_t, char**, size_t*, int*);\n+\n+extern GTY(()) tree rust_non_zero_struct;\n+\n+\n+#endif\n\\ No newline at end of file"}, {"sha": "49499c861b2d35a353cc976422e8c61b7882d216", "filename": "gcc/rust/mrustc_parser/parse/common.hpp", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fcommon.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fcommon.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fcommon.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,72 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/common.hpp\n+ * - Common definitions used by the parser\n+ */\n+#ifndef PARSE_COMMON_HPP_INCLUDED\n+#define PARSE_COMMON_HPP_INCLUDED\n+#include <iostream>\n+#include \"tokenstream.hpp\"\n+#include \"../ast/ast.hpp\"\n+\n+#define GET_TOK(tok, lex) ((tok = lex.getToken()).type())\n+#define PUTBACK(tok, lex) lex.putback( ::std::move(tok) )\n+#define LOOK_AHEAD(lex) (lex.lookahead(0))\n+#define GET_CHECK_TOK(tok, lex, exp) do {\\\n+    if((tok = lex.getToken()).type() != exp) { \\\n+        DEBUG(\"GET_CHECK_TOK \" << __FILE__ << \":\" << __LINE__); \\\n+        throw ParseError::Unexpected(lex, tok, Token(exp));\\\n+    }\\\n+} while(0)\n+#define CHECK_TOK(tok, exp) do {\\\n+    if(tok.type() != exp) { \\\n+        DEBUG(\"CHECK_TOK \" << __FILE__ << \":\" << __LINE__); \\\n+        throw ParseError::Unexpected(lex, tok, Token(exp));\\\n+    } \\\n+} while(0)\n+\n+// --- path.cpp\n+enum eParsePathGenericMode\n+{\n+    PATH_GENERIC_NONE,\n+    PATH_GENERIC_EXPR,\n+    PATH_GENERIC_TYPE\n+};\n+extern AST::Path   Parse_Path(TokenStream& lex, eParsePathGenericMode generic_mode);    // Auto-determines\n+extern AST::Path   Parse_Path(TokenStream& lex, bool is_abs, eParsePathGenericMode generic_mode);\n+extern ::std::vector<AST::PathNode> Parse_PathNodes(TokenStream& lex, eParsePathGenericMode generic_mode);\n+extern AST::PathParams Parse_Path_GenericList(TokenStream& lex);\n+\n+\n+extern AST::HigherRankedBounds Parse_HRB(TokenStream& lex);\n+extern AST::AttributeList  Parse_ItemAttrs(TokenStream& lex);\n+extern void Parse_ParentAttrs(TokenStream& lex, AST::AttributeList& out);\n+extern AST::Attribute   Parse_MetaItem(TokenStream& lex);\n+extern ::AST::MacroInvocation Parse_MacroInvocation(ProtoSpan ps, ::std::string name, TokenStream& lex);\n+extern TypeRef     Parse_Type(TokenStream& lex, bool allow_trait_list = true);\n+extern AST::Pattern Parse_Pattern(TokenStream& lex, bool is_refutable);\n+\n+extern void Parse_Impl_Item(TokenStream& lex, AST::Impl& impl);\n+extern void Parse_Mod_Item(TokenStream& lex, AST::Module& mod, AST::AttributeList meta_items);\n+extern ::AST::Named<::AST::Item> Parse_Mod_Item_S(TokenStream& lex, const AST::Module::FileInfo& mod_fileinfo, const ::AST::Path& mod_path, AST::AttributeList meta_items);\n+extern void Parse_ModRoot_Items(TokenStream& lex, AST::Module& mod);\n+\n+\n+extern AST::Expr   Parse_Expr(TokenStream& lex);\n+extern AST::Expr   Parse_ExprBlock(TokenStream& lex);\n+extern AST::ExprNodeP   Parse_Expr0(TokenStream& lex);\n+extern AST::ExprNodeP   Parse_ExprVal(TokenStream& lex);\n+extern AST::ExprNodeP Parse_ExprBlockNode(TokenStream& lex, bool is_unsafe=false);\n+extern AST::ExprNodeP Parse_ExprBlockLine(TokenStream& lex, bool *add_silence);\n+extern AST::ExprNodeP Parse_ExprBlockLine_WithItems(TokenStream& lex, ::std::shared_ptr<AST::Module>& local_mod, bool& add_silence_if_end);\n+extern AST::ExprNodeP Parse_Stmt(TokenStream& lex);\n+\n+// unwrapped = Exclude the enclosing brackets (used by macro parse code)\n+extern TokenTree Parse_TT(TokenStream& lex, bool unwrapped);\n+\n+\n+extern bool Parse_IsTokValue(eTokenType tok_type);\n+\n+#endif // PARSE_COMMON_HPP_INCLUDED"}, {"sha": "5104142b33fafd09cdacd9d11afd1f4e365e82ed", "filename": "gcc/rust/mrustc_parser/parse/eTokenType.enum.h", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2FeTokenType.enum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2FeTokenType.enum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2FeTokenType.enum.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,154 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/eTokenType.enum.h\n+ * - Multi-include file for defining the eTokenType enum\n+ */\n+_(TOK_NULL)\n+_(TOK_EOF)\n+\n+_(TOK_NEWLINE)\n+_(TOK_WHITESPACE)\n+_(TOK_COMMENT)\n+\n+_(TOK_INTERPOLATED_IDENT)\n+_(TOK_INTERPOLATED_PATH)\n+_(TOK_INTERPOLATED_TYPE)\n+_(TOK_INTERPOLATED_PATTERN)\n+_(TOK_INTERPOLATED_EXPR)\n+_(TOK_INTERPOLATED_STMT)\n+_(TOK_INTERPOLATED_BLOCK)\n+_(TOK_INTERPOLATED_META)\n+_(TOK_INTERPOLATED_ITEM)\n+\n+// Value tokens\n+_(TOK_IDENT)\n+_(TOK_LIFETIME)\n+_(TOK_INTEGER)\n+_(TOK_CHAR)\n+_(TOK_FLOAT)\n+_(TOK_STRING)\n+_(TOK_BYTESTRING)\n+\n+_(TOK_HASH)\n+\n+_(TOK_UNDERSCORE)\n+\n+// Symbols\n+_(TOK_PAREN_OPEN)   _(TOK_PAREN_CLOSE)\n+_(TOK_BRACE_OPEN)   _(TOK_BRACE_CLOSE)\n+_(TOK_LT)           _(TOK_GT)\n+_(TOK_SQUARE_OPEN)  _(TOK_SQUARE_CLOSE)\n+_(TOK_COMMA)\n+_(TOK_SEMICOLON)\n+_(TOK_COLON)\n+_(TOK_DOUBLE_COLON)\n+_(TOK_STAR)     _(TOK_AMP)\n+_(TOK_PIPE)\n+\n+_(TOK_FATARROW)   // =>\n+_(TOK_THINARROW)  // ->\n+_(TOK_THINARROW_LEFT)   // <-\n+\n+_(TOK_PLUS) _(TOK_DASH)\n+_(TOK_EXCLAM)\n+_(TOK_PERCENT)\n+_(TOK_SLASH)\n+\n+_(TOK_DOT)\n+_(TOK_DOUBLE_DOT)\n+_(TOK_TRIPLE_DOT)\n+\n+_(TOK_EQUAL)\n+_(TOK_PLUS_EQUAL)\n+_(TOK_DASH_EQUAL)\n+_(TOK_PERCENT_EQUAL)\n+_(TOK_SLASH_EQUAL)\n+_(TOK_STAR_EQUAL)\n+_(TOK_AMP_EQUAL)\n+_(TOK_PIPE_EQUAL)\n+\n+_(TOK_DOUBLE_EQUAL)\n+_(TOK_EXCLAM_EQUAL)\n+_(TOK_GTE)\n+_(TOK_LTE)\n+\n+_(TOK_DOUBLE_AMP)\n+_(TOK_DOUBLE_PIPE)\n+_(TOK_DOUBLE_LT)\n+_(TOK_DOUBLE_GT)\n+_(TOK_DOUBLE_LT_EQUAL)\n+_(TOK_DOUBLE_GT_EQUAL)\n+\n+_(TOK_DOLLAR)\n+\n+_(TOK_QMARK)\n+_(TOK_AT)\n+_(TOK_TILDE)\n+_(TOK_BACKSLASH)\n+_(TOK_CARET)\n+_(TOK_CARET_EQUAL)\n+_(TOK_BACKTICK)\n+\n+// Reserved Words\n+// NOTE: ORDERING MATTERS! _PUB must be the first, and no non-rword tokens should follow\n+_(TOK_RWORD_PUB)\n+_(TOK_RWORD_PRIV)\n+_(TOK_RWORD_MUT)\n+_(TOK_RWORD_CONST)\n+_(TOK_RWORD_STATIC)\n+_(TOK_RWORD_UNSAFE)\n+_(TOK_RWORD_EXTERN)\n+\n+_(TOK_RWORD_CRATE)\n+_(TOK_RWORD_MOD)\n+_(TOK_RWORD_STRUCT)\n+_(TOK_RWORD_ENUM)\n+_(TOK_RWORD_TRAIT)\n+_(TOK_RWORD_FN)\n+_(TOK_RWORD_USE)\n+_(TOK_RWORD_IMPL)\n+_(TOK_RWORD_TYPE)\n+\n+_(TOK_RWORD_WHERE)\n+_(TOK_RWORD_AS)\n+\n+_(TOK_RWORD_LET)\n+_(TOK_RWORD_MATCH)\n+_(TOK_RWORD_IF)\n+_(TOK_RWORD_ELSE)\n+_(TOK_RWORD_LOOP)\n+_(TOK_RWORD_WHILE)\n+_(TOK_RWORD_FOR)\n+_(TOK_RWORD_IN)\n+_(TOK_RWORD_DO)\n+\n+_(TOK_RWORD_CONTINUE)\n+_(TOK_RWORD_BREAK)\n+_(TOK_RWORD_RETURN)\n+_(TOK_RWORD_YIELD)\n+_(TOK_RWORD_BOX)\n+_(TOK_RWORD_REF)\n+\n+_(TOK_RWORD_FALSE)\n+_(TOK_RWORD_TRUE)\n+_(TOK_RWORD_SELF)\n+_(TOK_RWORD_SUPER)\n+\n+_(TOK_RWORD_PROC)\n+_(TOK_RWORD_MOVE)\n+\n+_(TOK_RWORD_ABSTRACT)\n+_(TOK_RWORD_FINAL)\n+_(TOK_RWORD_PURE)\n+_(TOK_RWORD_OVERRIDE)\n+_(TOK_RWORD_VIRTUAL)\n+\n+_(TOK_RWORD_ALIGNOF)\n+_(TOK_RWORD_OFFSETOF)\n+_(TOK_RWORD_SIZEOF)\n+_(TOK_RWORD_TYPEOF)\n+\n+_(TOK_RWORD_BE)\n+_(TOK_RWORD_UNSIZED)"}, {"sha": "5194e1d87e390505541b5fcace7c0828ca5ab1d1", "filename": "gcc/rust/mrustc_parser/parse/expr.cpp", "status": "added", "additions": 1338, "deletions": 0, "changes": 1338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fexpr.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fexpr.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fexpr.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,1338 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/expr.cpp\n+ * - Expression (i.e. code) parsing\n+ *\n+ * Start points:\n+ * - Parse_ExprBlockNode : Parses a block\n+ * - Parse_Stmt : Parse a single statement\n+ * - Parse_Expr0 : Parse a single expression\n+ */\n+#include \"parseerror.hpp\"\n+#include <ast/ast.hpp>\n+#include <ast/expr.hpp>\n+#include \"common.hpp\"\n+#include <iostream>\n+#include \"tokentree.hpp\"\n+#include \"interpolated_fragment.hpp\"\n+\n+using AST::ExprNode;\n+using AST::ExprNodeP;\n+// TODO: Use a ProtoSpan instead of a point span?\n+static inline ExprNodeP mk_exprnodep(const TokenStream& lex, AST::ExprNode* en){en->set_span(lex.point_span()); return ExprNodeP(en); }\n+#define NEWNODE(type, ...)  mk_exprnodep(lex, new type(__VA_ARGS__))\n+\n+//ExprNodeP Parse_ExprBlockNode(TokenStream& lex, bool is_unsafe=false);    // common.hpp\n+//ExprNodeP Parse_ExprBlockLine_WithItems(TokenStream& lex, ::std::shared_ptr<AST::Module>& local_mod, bool& add_silence_if_end);\n+//ExprNodeP Parse_ExprBlockLine(TokenStream& lex, bool *add_silence);\n+ExprNodeP Parse_ExprBlockLine_Stmt(TokenStream& lex, bool& has_semicolon);\n+//ExprNodeP Parse_Stmt(TokenStream& lex);   // common.hpp\n+ExprNodeP Parse_Stmt_Let(TokenStream& lex);\n+ExprNodeP Parse_Expr0(TokenStream& lex);\n+ExprNodeP Parse_IfStmt(TokenStream& lex);\n+ExprNodeP Parse_WhileStmt(TokenStream& lex, ::std::string lifetime);\n+ExprNodeP Parse_ForStmt(TokenStream& lex, ::std::string lifetime);\n+ExprNodeP Parse_Expr_Match(TokenStream& lex);\n+ExprNodeP Parse_Expr1(TokenStream& lex);\n+ExprNodeP Parse_ExprMacro(TokenStream& lex, AST::Path tok);\n+\n+AST::Expr Parse_Expr(TokenStream& lex)\n+{\n+    return ::AST::Expr( Parse_Expr0(lex) );\n+}\n+\n+AST::Expr Parse_ExprBlock(TokenStream& lex)\n+{\n+    return ::AST::Expr( Parse_ExprBlockNode(lex) );\n+}\n+\n+ExprNodeP Parse_ExprBlockNode(TokenStream& lex, bool is_unsafe/*=false*/)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    ::std::vector<ExprNodeP> nodes;\n+\n+    ::std::shared_ptr<AST::Module> local_mod;\n+\n+    GET_CHECK_TOK(tok, lex, TOK_BRACE_OPEN);\n+\n+    bool last_value_yielded = false;\n+    while( LOOK_AHEAD(lex) != TOK_BRACE_CLOSE )\n+    {\n+        last_value_yielded = false;\n+        DEBUG(\"tok = \" << tok);\n+\n+        // NOTE: Doc comments can appear within a function and apply to the function\n+        if( lex.parse_state().parent_attrs )\n+        {\n+            Parse_ParentAttrs(lex, *lex.parse_state().parent_attrs);\n+        }\n+        if( LOOK_AHEAD(lex) == TOK_BRACE_CLOSE )\n+            break;\n+\n+        bool    add_silence_if_end = false;\n+        // `add_silence_if_end` indicates that the statement had a semicolon.\n+        auto rv = Parse_ExprBlockLine_WithItems(lex, local_mod, add_silence_if_end);\n+        if( rv )\n+        {\n+            // Set to TRUE if there was no semicolon after a statement\n+            last_value_yielded = !add_silence_if_end;\n+            nodes.push_back( mv$(rv) );\n+        }\n+        else {\n+            assert( !add_silence_if_end );\n+            last_value_yielded = false;\n+        }\n+    }\n+    GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n+\n+    return NEWNODE( AST::ExprNode_Block, is_unsafe, last_value_yielded, mv$(nodes), mv$(local_mod) );\n+}\n+\n+/// Parse a single line in a block, handling items added to the local module\n+///\n+/// - If an item was parsed, this returns an empty ExprNodeP\n+ExprNodeP Parse_ExprBlockLine_WithItems(TokenStream& lex, ::std::shared_ptr<AST::Module>& local_mod, bool& add_silence_if_end)\n+{\n+    Token   tok;\n+\n+    auto item_attrs = Parse_ItemAttrs(lex);\n+    GET_TOK(tok, lex);\n+\n+    // `union Ident` - contextual keyword\n+    if( tok.type() == TOK_IDENT && tok.str() == \"union\" && lex.lookahead(0) == TOK_IDENT ) {\n+        PUTBACK(tok, lex);\n+        if( !local_mod ) {\n+            local_mod = lex.parse_state().get_current_mod().add_anon();\n+        }\n+        Parse_Mod_Item(lex, *local_mod, mv$(item_attrs));\n+        return ExprNodeP();\n+    }\n+\n+    if( tok.type() == TOK_IDENT && tok.str() == \"macro_rules\" && lex.lookahead(0) == TOK_EXCLAM )\n+    {\n+        // Special case - create a local module if macro_rules! is seen\n+        // - Allows correct scoping of defined macros\n+        if( !local_mod ) {\n+            local_mod = lex.parse_state().get_current_mod().add_anon();\n+        }\n+    }\n+\n+    switch(tok.type())\n+    {\n+    // Items:\n+    case TOK_RWORD_PUB:\n+        // NOTE: Allowed, but doesn't do much\n+    case TOK_RWORD_TYPE:\n+    case TOK_RWORD_USE:\n+    case TOK_RWORD_EXTERN:\n+    case TOK_RWORD_CONST:\n+    case TOK_RWORD_STATIC:\n+    case TOK_RWORD_STRUCT:\n+    case TOK_RWORD_ENUM:\n+    case TOK_RWORD_TRAIT:\n+    case TOK_RWORD_IMPL:\n+    case TOK_RWORD_FN:\n+    case TOK_RWORD_MOD:\n+        PUTBACK(tok, lex);\n+        if( !local_mod ) {\n+            local_mod = lex.parse_state().get_current_mod().add_anon();\n+        }\n+        Parse_Mod_Item(lex, *local_mod, mv$(item_attrs));\n+        return ExprNodeP();\n+    // 'unsafe' - Check if the next token isn't a `{`, if so it's an item. Otherwise, fall through\n+    case TOK_RWORD_UNSAFE:\n+        if( LOOK_AHEAD(lex) != TOK_BRACE_OPEN )\n+        {\n+            PUTBACK(tok, lex);\n+            if( !local_mod ) {\n+                local_mod = lex.parse_state().get_current_mod().add_anon();\n+            }\n+            Parse_Mod_Item(lex, *local_mod, mv$(item_attrs));\n+            return ExprNodeP();\n+        }\n+        // fall\n+    default: {\n+        PUTBACK(tok, lex);\n+        auto rv = Parse_ExprBlockLine(lex, &add_silence_if_end);\n+        if( rv ) {\n+            rv->set_attrs( mv$(item_attrs) );\n+        }\n+        else if( item_attrs.m_items.size() > 0 ) {\n+            // TODO: Is this an error? - Attributes on a expression that didn't yeild a node.\n+            // - They should have applied to the item that was parsed?\n+        }\n+        else {\n+        }\n+        return rv;\n+        } break;\n+    }\n+}\n+\n+/// Parse a single line from a block\n+///\n+/// Handles:\n+/// - Block-level constructs (with lifetime annotations)\n+/// - use/extern/const/let\n+ExprNodeP Parse_ExprBlockLine(TokenStream& lex, bool *add_silence)\n+{\n+    Token tok;\n+    ExprNodeP   ret;\n+\n+    if( GET_TOK(tok, lex) == TOK_LIFETIME )\n+    {\n+        // Lifetimes can only precede loops... and blocks?\n+        ::std::string lifetime = tok.str();\n+        GET_CHECK_TOK(tok, lex, TOK_COLON);\n+\n+        switch( GET_TOK(tok, lex) )\n+        {\n+        case TOK_RWORD_LOOP:\n+            return NEWNODE( AST::ExprNode_Loop, lifetime, Parse_ExprBlockNode(lex) );\n+        case TOK_RWORD_WHILE:\n+            return Parse_WhileStmt(lex, lifetime);\n+        case TOK_RWORD_FOR:\n+            return Parse_ForStmt(lex, lifetime);\n+        //case TOK_RWORD_IF:\n+        //    return Parse_IfStmt(lex);\n+        //case TOK_RWORD_MATCH:\n+        //    return Parse_Expr_Match(lex);\n+        //case TOK_BRACE_OPEN:\n+        //    PUTBACK(tok, lex);\n+        //    return Parse_ExprBlockNode(lex);\n+\n+        default:\n+            throw ParseError::Unexpected(lex, tok);\n+        }\n+    }\n+    else\n+    {\n+        switch( tok.type() )\n+        {\n+        case TOK_INTERPOLATED_BLOCK:\n+            return tok.take_frag_node();\n+        case TOK_SEMICOLON:\n+            // Return a NULL expression, nothing here.\n+            return nullptr;\n+\n+        // let binding\n+        case TOK_RWORD_LET:\n+            ret = Parse_Stmt_Let(lex);\n+            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+            return ret;\n+\n+        // Blocks that don't need semicolons\n+        // NOTE: If these are followed by a small set of tokens (`.` and `?`) then they are actually the start of an expression\n+        // HACK: Parse here, but if the next token is one of the set store in a TOK_INTERPOLATED_EXPR and invoke the statement parser\n+        case TOK_RWORD_LOOP:\n+            ret = NEWNODE( AST::ExprNode_Loop, \"\", Parse_ExprBlockNode(lex) );\n+            if(0)\n+        case TOK_RWORD_WHILE:\n+            ret = Parse_WhileStmt(lex, \"\");\n+            if(0)\n+        case TOK_RWORD_FOR:\n+            ret = Parse_ForStmt(lex, \"\");\n+            if(0)\n+        case TOK_RWORD_IF:\n+            ret = Parse_IfStmt(lex);\n+            if(0)\n+        case TOK_RWORD_MATCH:\n+            ret = Parse_Expr_Match(lex);\n+            if(0)\n+        case TOK_RWORD_UNSAFE:\n+            ret = Parse_ExprBlockNode(lex, true);\n+            if(0)\n+        case TOK_BRACE_OPEN:\n+            { PUTBACK(tok, lex); ret = Parse_ExprBlockNode(lex); }\n+\n+            if( lex.lookahead(0) == TOK_DOT || lex.lookahead(0) == TOK_QMARK ) {\n+                lex.putback( Token(Token::TagTakeIP(), InterpolatedFragment(InterpolatedFragment::EXPR, ret.release())) );\n+                return Parse_ExprBlockLine_Stmt(lex, *add_silence);\n+            }\n+\n+            if( LOOK_AHEAD(lex) == TOK_SEMICOLON ) {\n+                GET_TOK(tok, lex);\n+                *add_silence = true;\n+            }\n+\n+            return ret;\n+\n+        // Flow control\n+        case TOK_RWORD_RETURN:\n+        case TOK_RWORD_CONTINUE:\n+        case TOK_RWORD_BREAK: {\n+            PUTBACK(tok, lex);\n+            auto ret = Parse_Stmt(lex);\n+            if( LOOK_AHEAD(lex) == TOK_EOF ) {\n+            }\n+            else if( GET_TOK(tok, lex) != TOK_SEMICOLON ) {\n+                CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+                PUTBACK(tok, lex);\n+            }\n+            else {\n+                // return/continue/break don't need silencing\n+            }\n+            return ret;\n+            }\n+\n+        case TOK_IDENT:\n+            if( lex.lookahead(0) == TOK_EXCLAM )\n+            {\n+                // If a braced macro invocation is the first part of a statement, don't expect a semicolon\n+                if( lex.lookahead(1) == TOK_BRACE_OPEN || (lex.lookahead(1) == TOK_IDENT && lex.lookahead(2) == TOK_BRACE_OPEN) ) {\n+                    lex.getToken();\n+                    return Parse_ExprMacro(lex, tok.str());\n+                }\n+            }\n+        // Fall through to the statement code\n+        default:\n+            PUTBACK(tok, lex);\n+            return Parse_ExprBlockLine_Stmt(lex, *add_silence);\n+        }\n+    }\n+}\n+\n+ExprNodeP Parse_ExprBlockLine_Stmt(TokenStream& lex, bool& has_semicolon)\n+{\n+    Token tok;\n+    auto ret = Parse_Stmt(lex);\n+    // If this expression statement wasn't followed by a semicolon, then it's yielding its value out of the block.\n+    // - I.e. The block should be ending\n+    if( GET_TOK(tok, lex) != TOK_SEMICOLON ) {\n+        // - Allow TOK_EOF for macro expansion.\n+        if( tok.type() == TOK_EOF )\n+            ;\n+        else\n+            CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+        PUTBACK(tok, lex);\n+    }\n+    else {\n+        has_semicolon = true;\n+    }\n+    return ret;\n+}\n+\n+/// While loop (either as a statement, or as part of an expression)\n+ExprNodeP Parse_WhileStmt(TokenStream& lex, ::std::string lifetime)\n+{\n+    Token   tok;\n+\n+    if( GET_TOK(tok, lex) == TOK_RWORD_LET ) {\n+        auto pat = Parse_Pattern(lex, true);    // Refutable pattern\n+        GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n+        ExprNodeP val;\n+        {\n+            SET_PARSE_FLAG(lex, disallow_struct_literal);\n+            val = Parse_Expr0(lex);\n+        }\n+        return NEWNODE( AST::ExprNode_Loop, lifetime, AST::ExprNode_Loop::WHILELET,\n+            ::std::move(pat), ::std::move(val), Parse_ExprBlockNode(lex) );\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+        ExprNodeP cnd;\n+        {\n+            SET_PARSE_FLAG(lex, disallow_struct_literal);\n+            cnd = Parse_Expr1(lex);\n+        }\n+        return NEWNODE( AST::ExprNode_Loop, lifetime, ::std::move(cnd), Parse_ExprBlockNode(lex) );\n+    }\n+}\n+/// For loop (either as a statement, or as part of an expression)\n+ExprNodeP Parse_ForStmt(TokenStream& lex, ::std::string lifetime)\n+{\n+    Token   tok;\n+\n+    // Irrefutable pattern\n+    AST::Pattern    pat = Parse_Pattern(lex, false);\n+    GET_CHECK_TOK(tok, lex, TOK_RWORD_IN);\n+    ExprNodeP val;\n+    {\n+        SET_PARSE_FLAG(lex, disallow_struct_literal);\n+        val = Parse_Expr0(lex);\n+    }\n+    return NEWNODE( AST::ExprNode_Loop, lifetime, AST::ExprNode_Loop::FOR,\n+            ::std::move(pat), ::std::move(val), Parse_ExprBlockNode(lex) );\n+}\n+/// Parse an 'if' statement\n+// Note: TOK_RWORD_IF has already been eaten\n+ExprNodeP Parse_IfStmt(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+\n+    Token   tok;\n+    ExprNodeP cond;\n+    AST::Pattern    pat;\n+    bool if_let = false;\n+\n+    {\n+        SET_PARSE_FLAG(lex, disallow_struct_literal);\n+        if( GET_TOK(tok, lex) == TOK_RWORD_LET ) {\n+            if_let = true;\n+            // Refutable pattern\n+            pat = Parse_Pattern(lex, true);\n+            GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n+            cond = Parse_Expr0(lex);\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+            cond = Parse_Expr0(lex);\n+        }\n+    }\n+\n+    // Contents\n+    ExprNodeP code = Parse_ExprBlockNode(lex);\n+\n+    // Handle else:\n+    ExprNodeP altcode;\n+    if( GET_TOK(tok, lex) == TOK_RWORD_ELSE )\n+    {\n+        // Recurse for 'else if'\n+        if( GET_TOK(tok, lex) == TOK_RWORD_IF ) {\n+            altcode = Parse_IfStmt(lex);\n+        }\n+        // - or get block\n+        else {\n+            PUTBACK(tok, lex);\n+            altcode = Parse_ExprBlockNode(lex);\n+        }\n+    }\n+    // - or nothing\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+\n+    if( if_let )\n+        return NEWNODE( AST::ExprNode_IfLet, ::std::move(pat), ::std::move(cond), ::std::move(code), ::std::move(altcode) );\n+    else\n+        return NEWNODE( AST::ExprNode_If, ::std::move(cond), ::std::move(code), ::std::move(altcode) );\n+}\n+/// \"match\" block\n+ExprNodeP Parse_Expr_Match(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+    Token tok;\n+\n+    CLEAR_PARSE_FLAG(lex, disallow_struct_literal);\n+    // 1. Get expression\n+    ExprNodeP   switch_val;\n+    {\n+        SET_PARSE_FLAG(lex, disallow_struct_literal);\n+        switch_val = Parse_Expr1(lex);\n+    }\n+    //ASSERT(lex, !CHECK_PARSE_FLAG(lex, disallow_struct_literal) );\n+    GET_CHECK_TOK(tok, lex, TOK_BRACE_OPEN);\n+\n+    ::std::vector< AST::ExprNode_Match_Arm >    arms;\n+    do {\n+        if( GET_TOK(tok, lex) == TOK_BRACE_CLOSE )\n+            break;\n+        PUTBACK(tok, lex);\n+        AST::ExprNode_Match_Arm    arm;\n+\n+        arm.m_attrs = Parse_ItemAttrs(lex);\n+\n+        do {\n+            // Refutable pattern\n+            arm.m_patterns.push_back( Parse_Pattern(lex, true) );\n+        } while( GET_TOK(tok, lex) == TOK_PIPE );\n+\n+        if( tok.type() == TOK_RWORD_IF )\n+        {\n+            arm.m_cond = Parse_Expr1(lex);\n+            GET_TOK(tok, lex);\n+        }\n+        CHECK_TOK(tok, TOK_FATARROW);\n+\n+        arm.m_code = Parse_Stmt(lex);\n+\n+        arms.push_back( ::std::move(arm) );\n+\n+        if( GET_TOK(tok, lex) == TOK_COMMA )\n+            continue;\n+        PUTBACK(tok, lex);\n+\n+    } while( 1 );\n+    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+\n+    return NEWNODE( AST::ExprNode_Match, ::std::move(switch_val), ::std::move(arms) );\n+}\n+\n+/// Parses the 'stmt' fragment specifier\n+/// - Flow control\n+/// - Expressions\n+ExprNodeP Parse_Stmt(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    switch(GET_TOK(tok, lex))\n+    {\n+    case TOK_INTERPOLATED_STMT:\n+        return tok.take_frag_node();\n+    // Duplicated here for the :stmt pattern fragment.\n+    case TOK_RWORD_LET:\n+        return Parse_Stmt_Let(lex);\n+    case TOK_RWORD_RETURN: {\n+        ExprNodeP   val;\n+        switch(LOOK_AHEAD(lex))\n+        {\n+        case TOK_EOF:\n+        case TOK_SEMICOLON:\n+        case TOK_COMMA:\n+        case TOK_BRACE_CLOSE:\n+        case TOK_PAREN_CLOSE:\n+        case TOK_SQUARE_CLOSE:\n+            break;\n+        default:\n+            val = Parse_Expr0(lex);\n+            break;\n+        }\n+        return NEWNODE( AST::ExprNode_Flow, AST::ExprNode_Flow::RETURN, \"\", ::std::move(val) );\n+        }\n+    case TOK_RWORD_CONTINUE:\n+    case TOK_RWORD_BREAK:\n+        {\n+        AST::ExprNode_Flow::Type    type;\n+        switch(tok.type())\n+        {\n+        case TOK_RWORD_CONTINUE: type = AST::ExprNode_Flow::CONTINUE; break;\n+        case TOK_RWORD_BREAK:    type = AST::ExprNode_Flow::BREAK;    break;\n+        default:    throw ParseError::BugCheck(/*lex,*/ \"continue/break\");\n+        }\n+        ::std::string   lifetime;\n+        if( GET_TOK(tok, lex) == TOK_LIFETIME )\n+        {\n+            lifetime = tok.str();\n+            GET_TOK(tok, lex);\n+        }\n+        ExprNodeP   val;\n+        switch(tok.type())\n+        {\n+        case TOK_EOF:\n+        case TOK_SEMICOLON:\n+        case TOK_COMMA:\n+        case TOK_BRACE_OPEN:\n+        case TOK_BRACE_CLOSE:\n+        case TOK_PAREN_CLOSE:\n+        case TOK_SQUARE_CLOSE:\n+            PUTBACK(tok, lex);\n+            break;\n+        default:\n+            PUTBACK(tok, lex);\n+            val = Parse_Expr1(lex);\n+            break;\n+        }\n+        return NEWNODE( AST::ExprNode_Flow, type, lifetime, ::std::move(val) );\n+        }\n+    case TOK_BRACE_OPEN:\n+        PUTBACK(tok, lex);\n+        return Parse_ExprBlockNode(lex);\n+    default:\n+        PUTBACK(tok, lex);\n+        return Parse_Expr0(lex);\n+    }\n+}\n+\n+ExprNodeP Parse_Stmt_Let(TokenStream& lex)\n+{\n+    Token   tok;\n+    AST::Pattern pat = Parse_Pattern(lex, false);   // irrefutable\n+    TypeRef type { lex.point_span() };\n+    if( GET_TOK(tok, lex) == TOK_COLON ) {\n+        type = Parse_Type(lex);\n+        GET_TOK(tok, lex);\n+    }\n+    ExprNodeP val;\n+    if( tok.type() == TOK_EQUAL ) {\n+        val = Parse_Expr0(lex);\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+    return NEWNODE( AST::ExprNode_LetBinding, ::std::move(pat), mv$(type), ::std::move(val) );\n+}\n+\n+::std::vector<ExprNodeP> Parse_ParenList(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    CLEAR_PARSE_FLAG(lex, disallow_struct_literal);\n+\n+    ::std::vector<ExprNodeP> rv;\n+    GET_CHECK_TOK(tok, lex, TOK_PAREN_OPEN);\n+    if( GET_TOK(tok, lex) != TOK_PAREN_CLOSE )\n+    {\n+        PUTBACK(tok, lex);\n+        do {\n+            if( LOOK_AHEAD(lex) == TOK_PAREN_CLOSE ) {\n+                GET_TOK(tok, lex);\n+                break;\n+            }\n+            rv.push_back( Parse_Expr0(lex) );\n+        } while( GET_TOK(tok, lex) == TOK_COMMA );\n+        CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+    }\n+    return rv;\n+}\n+\n+// 0: Assign\n+ExprNodeP Parse_Expr0(TokenStream& lex)\n+{\n+    //TRACE_FUNCTION;\n+    Token tok;\n+\n+    auto expr_attrs = Parse_ItemAttrs(lex);\n+\n+    ExprNodeP rv = Parse_Expr1(lex);\n+    auto op = AST::ExprNode_Assign::NONE;\n+    switch( GET_TOK(tok, lex) )\n+    {\n+    case TOK_PLUS_EQUAL:\n+        op = AST::ExprNode_Assign::ADD; if(0)\n+    case TOK_DASH_EQUAL:\n+        op = AST::ExprNode_Assign::SUB; if(0)\n+    case TOK_STAR_EQUAL:\n+        op = AST::ExprNode_Assign::MUL; if(0)\n+    case TOK_SLASH_EQUAL:\n+        op = AST::ExprNode_Assign::DIV; if(0)\n+    case TOK_PERCENT_EQUAL:\n+        op = AST::ExprNode_Assign::MOD; if(0)\n+\n+    case TOK_AMP_EQUAL:\n+        op = AST::ExprNode_Assign::AND; if(0)\n+    case TOK_PIPE_EQUAL:\n+        op = AST::ExprNode_Assign::OR ; if(0)\n+    case TOK_CARET_EQUAL:\n+        op = AST::ExprNode_Assign::XOR; if(0)\n+\n+    case TOK_DOUBLE_GT_EQUAL:\n+        op = AST::ExprNode_Assign::SHR; if(0)\n+    case TOK_DOUBLE_LT_EQUAL:\n+        op = AST::ExprNode_Assign::SHL; if(0)\n+\n+    case TOK_EQUAL:\n+        op = AST::ExprNode_Assign::NONE;\n+        rv = NEWNODE( AST::ExprNode_Assign, op, ::std::move(rv), Parse_Expr0(lex) );\n+        rv->set_attrs(mv$(expr_attrs));\n+        return rv;\n+\n+    default:\n+        PUTBACK(tok, lex);\n+        rv->set_attrs(mv$(expr_attrs));\n+        return rv;\n+    }\n+}\n+\n+\n+#define LEFTASSOC(cur, _next, cases) \\\n+ExprNodeP _next(TokenStream& lex); \\\n+ExprNodeP cur(TokenStream& lex) \\\n+{ \\\n+    ExprNodeP (*next)(TokenStream&) = _next;\\\n+    ExprNodeP rv = next(lex); \\\n+    while(true) \\\n+    { \\\n+        Token   tok; \\\n+        switch((tok = lex.getToken()).type()) \\\n+        { \\\n+        cases \\\n+        default: \\\n+            /*::std::cout << \"<<\" << #cur << ::std::endl; */\\\n+            PUTBACK(tok, lex); \\\n+            return rv; \\\n+        } \\\n+    } \\\n+}\n+bool Parse_IsTokValue(eTokenType tok_type)\n+{\n+    switch( tok_type )\n+    {\n+    case TOK_DOUBLE_COLON:\n+    case TOK_IDENT:\n+    case TOK_INTEGER:\n+    case TOK_FLOAT:\n+    case TOK_STRING:\n+    case TOK_RWORD_TRUE:\n+    case TOK_RWORD_FALSE:\n+    case TOK_RWORD_SELF:\n+    case TOK_RWORD_SUPER:\n+    case TOK_RWORD_BOX:\n+    case TOK_RWORD_IN:\n+    case TOK_PAREN_OPEN:\n+    case TOK_SQUARE_OPEN:\n+\n+    case TOK_INTERPOLATED_PATH:\n+    case TOK_INTERPOLATED_EXPR:\n+\n+    case TOK_PIPE:\n+    case TOK_EXCLAM:\n+    case TOK_DASH:\n+    case TOK_STAR:\n+    case TOK_AMP:\n+        return true;\n+    default:\n+        return false;\n+    }\n+}\n+ExprNodeP Parse_Expr1_1(TokenStream& lex);\n+ExprNodeP Parse_Expr1(TokenStream& lex)\n+{\n+    Token   tok;\n+    ExprNodeP (*next)(TokenStream&) = Parse_Expr1_1;\n+\n+    auto dest = next(lex);\n+    if( lex.lookahead(0) == TOK_THINARROW_LEFT )\n+    {\n+        GET_TOK(tok, lex);\n+        auto val = Parse_Expr1(lex);\n+        return NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::PLACE_IN, mv$(dest), mv$(val));\n+    }\n+    else\n+    {\n+        return dest;\n+    }\n+}\n+ExprNodeP Parse_Expr1_2(TokenStream& lex);\n+// Very evil handling for '..'\n+ExprNodeP Parse_Expr1_1(TokenStream& lex)\n+{\n+    Token   tok;\n+    ExprNodeP (*next)(TokenStream&) = Parse_Expr1_2;\n+    ExprNodeP   left, right;\n+\n+    // Inclusive range to a value\n+    if( GET_TOK(tok, lex) == TOK_TRIPLE_DOT ) {\n+        right = next(lex);\n+        return NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::RANGE_INC, nullptr, mv$(right) );\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+\n+    // Exclusive ranges\n+    // - If NOT `.. <VAL>`, parse a leading value\n+    if( GET_TOK(tok, lex) != TOK_DOUBLE_DOT )\n+    {\n+        PUTBACK(tok, lex);\n+\n+        left = next(lex);\n+\n+        // - If NOT `<VAL> ..`, return the value\n+        if( GET_TOK(tok, lex) != TOK_DOUBLE_DOT )\n+        {\n+            PUTBACK(tok, lex);\n+            return ::std::move(left);\n+        }\n+    }\n+    assert( tok.type() == TOK_DOUBLE_DOT );\n+    // If the next token is part of a value, parse that value\n+    if( Parse_IsTokValue( LOOK_AHEAD(lex) ) )\n+    {\n+        right = next(lex);\n+    }\n+    else\n+    {\n+        // Otherwise, leave `right` as nullptr\n+    }\n+\n+    return NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::RANGE, ::std::move(left), ::std::move(right) );\n+}\n+LEFTASSOC(Parse_Expr1_2, Parse_Expr1_5,\n+    case TOK_TRIPLE_DOT:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::RANGE_INC, mv$(rv), next(lex) );\n+        break;\n+)\n+// 1: Bool OR\n+LEFTASSOC(Parse_Expr1_5, Parse_Expr2,\n+    case TOK_DOUBLE_PIPE:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BOOLOR, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 2: Bool AND\n+LEFTASSOC(Parse_Expr2, Parse_Expr3,\n+    case TOK_DOUBLE_AMP:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BOOLAND, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 3: (In)Equality\n+LEFTASSOC(Parse_Expr3, Parse_Expr4,\n+    case TOK_DOUBLE_EQUAL:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPEQU, ::std::move(rv), next(lex));\n+        break;\n+    case TOK_EXCLAM_EQUAL:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPNEQU, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 4: Comparisons\n+LEFTASSOC(Parse_Expr4, Parse_Expr5,\n+    case TOK_LT:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPLT, ::std::move(rv), next(lex));\n+        break;\n+    case TOK_GT:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPGT, ::std::move(rv), next(lex));\n+        break;\n+    case TOK_LTE:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPLTE, ::std::move(rv), next(lex));\n+        break;\n+    case TOK_GTE:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPGTE, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 5: Bit OR\n+LEFTASSOC(Parse_Expr5, Parse_Expr6,\n+    case TOK_PIPE:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BITOR, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 6: Bit XOR\n+LEFTASSOC(Parse_Expr6, Parse_Expr7,\n+    case TOK_CARET:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BITXOR, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 7: Bit AND\n+LEFTASSOC(Parse_Expr7, Parse_Expr8,\n+    case TOK_AMP:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BITAND, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 8: Bit Shifts\n+LEFTASSOC(Parse_Expr8, Parse_Expr9,\n+    case TOK_DOUBLE_LT:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::SHL, ::std::move(rv), next(lex));\n+        break;\n+    case TOK_DOUBLE_GT:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::SHR, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 9: Add / Subtract\n+LEFTASSOC(Parse_Expr9, Parse_Expr10,\n+    case TOK_PLUS:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::ADD, ::std::move(rv), next(lex));\n+        break;\n+    case TOK_DASH:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::SUB, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 10: Times / Divide / Modulo\n+LEFTASSOC(Parse_Expr10, Parse_Expr11,\n+    case TOK_STAR:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::MULTIPLY, ::std::move(rv), next(lex));\n+        break;\n+    case TOK_SLASH:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::DIVIDE, ::std::move(rv), next(lex));\n+        break;\n+    case TOK_PERCENT:\n+        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::MODULO, ::std::move(rv), next(lex));\n+        break;\n+)\n+// 11: Cast\n+LEFTASSOC(Parse_Expr11, Parse_Expr12,\n+    case TOK_RWORD_AS:\n+        rv = NEWNODE( AST::ExprNode_Cast, ::std::move(rv), Parse_Type(lex, false) );\n+        break;\n+)\n+// 12: Type Ascription\n+ExprNodeP Parse_Expr13(TokenStream& lex);\n+ExprNodeP Parse_Expr12(TokenStream& lex)\n+{\n+    Token   tok;\n+    auto rv = Parse_Expr13(lex);\n+    if(GET_TOK(tok, lex) == TOK_COLON)\n+    {\n+        rv = NEWNODE( AST::ExprNode_TypeAnnotation, mv$(rv), Parse_Type(lex) );\n+    }\n+    else\n+    {\n+        PUTBACK(tok, lex);\n+    }\n+    return rv;\n+}\n+// 13: Unaries\n+ExprNodeP Parse_ExprFC(TokenStream& lex);\n+ExprNodeP Parse_Expr13(TokenStream& lex)\n+{\n+    Token   tok;\n+    switch(GET_TOK(tok, lex))\n+    {\n+    case TOK_DASH:\n+        return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::NEGATE, Parse_Expr12(lex) );\n+    case TOK_EXCLAM:\n+        return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::INVERT, Parse_Expr12(lex) );\n+    case TOK_STAR:\n+        return NEWNODE( AST::ExprNode_Deref, Parse_Expr12(lex) );\n+    case TOK_RWORD_BOX:\n+        return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::BOX, Parse_Expr12(lex) );\n+    case TOK_RWORD_IN: {\n+        ExprNodeP   dest;\n+        {\n+            SET_PARSE_FLAG(lex, disallow_struct_literal);\n+            dest = Parse_Expr1(lex);\n+        }\n+        auto val = Parse_ExprBlockNode(lex);\n+        return NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::PLACE_IN, mv$(dest), mv$(val));\n+        }\n+    case TOK_DOUBLE_AMP:\n+        // HACK: Split && into & &\n+        lex.putback( Token(TOK_AMP) );\n+    case TOK_AMP:\n+        if( GET_TOK(tok, lex) == TOK_RWORD_MUT )\n+            return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::REFMUT, Parse_Expr12(lex) );\n+        else {\n+            PUTBACK(tok, lex);\n+            return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::REF, Parse_Expr12(lex) );\n+        }\n+    default:\n+        PUTBACK(tok, lex);\n+        return Parse_ExprFC(lex);\n+    }\n+}\n+\n+ExprNodeP Parse_ExprVal(TokenStream& lex);\n+ExprNodeP Parse_ExprFC(TokenStream& lex)\n+{\n+    ExprNodeP   val = Parse_ExprVal(lex);\n+    while(true)\n+    {\n+        Token   tok;\n+        switch(GET_TOK(tok, lex))\n+        {\n+        case TOK_QMARK:\n+            val = NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::QMARK, mv$(val) );\n+            break;\n+\n+        case TOK_PAREN_OPEN:\n+            // Expression method call\n+            PUTBACK(tok, lex);\n+            val = NEWNODE( AST::ExprNode_CallObject, ::std::move(val), Parse_ParenList(lex) );\n+            break;\n+        case TOK_SQUARE_OPEN:\n+            val = NEWNODE( AST::ExprNode_Index, ::std::move(val), Parse_Expr0(lex) );\n+            GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n+            break;\n+        case TOK_DOT:\n+            // Field access / method call / tuple index\n+            switch(GET_TOK(tok, lex))\n+            {\n+            case TOK_IDENT: {\n+                AST::PathNode   path( mv$(tok.str()) , {});\n+                switch( GET_TOK(tok, lex) )\n+                {\n+                case TOK_PAREN_OPEN:\n+                    PUTBACK(tok, lex);\n+                    val = NEWNODE( AST::ExprNode_CallMethod, ::std::move(val), ::std::move(path), Parse_ParenList(lex) );\n+                    break;\n+                case TOK_DOUBLE_COLON:\n+                    GET_CHECK_TOK(tok, lex, TOK_LT);\n+                    path.args() = Parse_Path_GenericList(lex);\n+                    val = NEWNODE( AST::ExprNode_CallMethod, ::std::move(val), ::std::move(path), Parse_ParenList(lex) );\n+                    break;\n+                default:\n+                    val = NEWNODE( AST::ExprNode_Field, ::std::move(val), ::std::string(path.name()) );\n+                    PUTBACK(tok, lex);\n+                    break;\n+                }\n+                break; }\n+            case TOK_INTEGER:\n+                val = NEWNODE( AST::ExprNode_Field, ::std::move(val), FMT(tok.intval()) );\n+                break;\n+            default:\n+                throw ParseError::Unexpected(lex, mv$(tok));\n+            }\n+            break;\n+        default:\n+            PUTBACK(tok, lex);\n+            return val;\n+        }\n+    }\n+}\n+\n+ExprNodeP Parse_ExprVal_StructLiteral(TokenStream& lex, AST::Path path)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    // #![feature(relaxed_adts)]\n+    if( LOOK_AHEAD(lex) == TOK_INTEGER )\n+    {\n+        ::std::map<unsigned int, ExprNodeP> nodes;\n+        while( GET_TOK(tok, lex) == TOK_INTEGER )\n+        {\n+            unsigned int ofs = static_cast<unsigned int>(tok.intval());\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            ExprNodeP   val = Parse_Stmt(lex);\n+            if( ! nodes.insert( ::std::make_pair(ofs, mv$(val)) ).second ) {\n+                ERROR(lex.point_span(), E0000, \"Duplicate index\");\n+            }\n+\n+            if( GET_TOK(tok,lex) == TOK_BRACE_CLOSE )\n+                break;\n+            CHECK_TOK(tok, TOK_COMMA);\n+        }\n+        CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+\n+        ::std::vector<ExprNodeP>    items;\n+        unsigned int i = 0;\n+        for(auto& p : nodes)\n+        {\n+            if( p.first != i ) {\n+                ERROR(lex.point_span(), E0000, \"Missing index \" << i);\n+            }\n+            items.push_back( mv$(p.second) );\n+            i ++;\n+        }\n+\n+        return NEWNODE( AST::ExprNode_CallPath, mv$(path), mv$(items) );\n+    }\n+\n+    // Braced structure literal\n+    // - A series of 0 or more pairs of <ident>: <expr>,\n+    // - '..' <expr>\n+    ::AST::ExprNode_StructLiteral::t_values items;\n+    while( GET_TOK(tok, lex) == TOK_IDENT || tok.type() == TOK_HASH )\n+    {\n+        ::AST::AttributeList attrs;    // Note: Parse_ItemAttrs uses lookahead, so can't use it here.\n+        if( tok.type() == TOK_HASH )\n+        {\n+            PUTBACK(tok, lex);\n+            attrs = Parse_ItemAttrs(lex);\n+            GET_TOK(tok, lex);\n+        }\n+        CHECK_TOK(tok, TOK_IDENT);\n+        auto h = lex.getHygiene();\n+        auto name = mv$(tok.str());\n+\n+        ExprNodeP   val;\n+        if( lex.lookahead(0) != TOK_COLON )\n+        {\n+            val = NEWNODE( AST::ExprNode_NamedValue, ::AST::Path(::AST::Path::TagRelative{}, h, { ::AST::PathNode(name) }) );\n+        }\n+        else\n+        {\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            val = Parse_Stmt(lex);\n+        }\n+        items.push_back(::AST::ExprNode_StructLiteral::Ent { mv$(attrs), mv$(name), mv$(val) });\n+\n+        if( GET_TOK(tok,lex) == TOK_BRACE_CLOSE )\n+            break;\n+        CHECK_TOK(tok, TOK_COMMA);\n+    }\n+    ExprNodeP    base_val;\n+    if( tok.type() == TOK_DOUBLE_DOT )\n+    {\n+        // default\n+        base_val = Parse_Expr0(lex);\n+        GET_TOK(tok, lex);\n+    }\n+    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+\n+    return NEWNODE( AST::ExprNode_StructLiteral, path, ::std::move(base_val), ::std::move(items) );\n+}\n+\n+ExprNodeP Parse_ExprVal_Closure(TokenStream& lex, bool is_move)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    ::std::vector< ::std::pair<AST::Pattern, TypeRef> > args;\n+\n+    while( GET_TOK(tok, lex) != TOK_PIPE )\n+    {\n+        PUTBACK(tok, lex);\n+        // Irrefutable pattern\n+        AST::Pattern    pat = Parse_Pattern(lex, false);\n+\n+        TypeRef type { lex.point_span() };\n+        if( GET_TOK(tok, lex) == TOK_COLON )\n+            type = Parse_Type(lex);\n+        else\n+            PUTBACK(tok, lex);\n+\n+        args.push_back( ::std::make_pair( ::std::move(pat), ::std::move(type) ) );\n+\n+        if( GET_TOK(tok, lex) != TOK_COMMA )\n+            break;\n+    }\n+    CHECK_TOK(tok, TOK_PIPE);\n+\n+    auto rt = TypeRef(lex.point_span());\n+    if( GET_TOK(tok, lex) == TOK_THINARROW ) {\n+\n+        if( GET_TOK(tok, lex) == TOK_EXCLAM ) {\n+            rt = TypeRef(TypeRef::TagInvalid(), Span(tok.get_pos()));\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+            rt = Parse_Type(lex);\n+        }\n+    }\n+    else\n+        PUTBACK(tok, lex);\n+\n+    auto code = Parse_Expr0(lex);\n+\n+    return NEWNODE( AST::ExprNode_Closure, ::std::move(args), ::std::move(rt), ::std::move(code), is_move );\n+}\n+\n+ExprNodeP Parse_ExprVal(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+\n+    Token   tok;\n+    AST::Path   path;\n+    switch( GET_TOK(tok, lex) )\n+    {\n+    case TOK_BRACE_OPEN:\n+        PUTBACK(tok, lex);\n+        return Parse_ExprBlockNode(lex);\n+\n+    case TOK_INTERPOLATED_EXPR:\n+    case TOK_INTERPOLATED_BLOCK:\n+        return tok.take_frag_node();\n+\n+\n+    // Return/break/continue/... also parsed here (but recurses back up to actually handle them)\n+    case TOK_RWORD_RETURN:\n+    case TOK_RWORD_CONTINUE:\n+    case TOK_RWORD_BREAK:\n+        PUTBACK(tok, lex);\n+        return Parse_Stmt(lex);\n+\n+    case TOK_RWORD_LOOP:\n+        return NEWNODE( AST::ExprNode_Loop, \"\", Parse_ExprBlockNode(lex) );\n+    case TOK_RWORD_WHILE:\n+        return Parse_WhileStmt(lex, \"\");\n+    case TOK_RWORD_FOR:\n+        return Parse_ForStmt(lex, \"\");\n+    case TOK_RWORD_MATCH:\n+        return Parse_Expr_Match(lex);\n+    case TOK_RWORD_IF:\n+        return Parse_IfStmt(lex);\n+    case TOK_RWORD_UNSAFE:\n+        return Parse_ExprBlockNode(lex, true);\n+\n+    // UFCS\n+    case TOK_DOUBLE_LT:\n+    case TOK_LT:\n+        PUTBACK(tok, lex);\n+        path = Parse_Path(lex, PATH_GENERIC_EXPR);\n+        // Skip down to method\n+        if(0)\n+    case TOK_RWORD_SELF:\n+        {\n+            if( LOOK_AHEAD(lex) != TOK_DOUBLE_COLON ) {\n+                return NEWNODE( AST::ExprNode_NamedValue, AST::Path(AST::Path::TagLocal(), \"self\") );\n+            }\n+            else\n+            {\n+                PUTBACK(tok, lex);\n+                path = Parse_Path(lex, PATH_GENERIC_EXPR);\n+            }\n+        }\n+        if(0)\n+    case TOK_RWORD_SUPER:\n+        {\n+            PUTBACK(tok, lex);\n+            path = Parse_Path(lex, PATH_GENERIC_EXPR);\n+        }\n+        if(0)\n+    case TOK_IDENT:\n+        // Get path\n+        {\n+            PUTBACK(tok, lex);\n+            path = Parse_Path(lex, false, PATH_GENERIC_EXPR);\n+        }\n+        if(0)\n+    case TOK_INTERPOLATED_PATH:\n+        {\n+            path = mv$(tok.frag_path());\n+        }\n+        if(0)\n+    case TOK_DOUBLE_COLON:\n+        path = Parse_Path(lex, true, PATH_GENERIC_EXPR);\n+        DEBUG(\"path = \" << path << \", lookahead=\" << Token::typestr(lex.lookahead(0)));\n+        // SKIP TARGET\n+        switch( GET_TOK(tok, lex) )\n+        {\n+        case TOK_EXCLAM:\n+            return Parse_ExprMacro(lex, mv$(path));\n+        case TOK_PAREN_OPEN:\n+            // Function call\n+            PUTBACK(tok, lex);\n+            return NEWNODE( AST::ExprNode_CallPath, ::std::move(path), Parse_ParenList(lex) );\n+        case TOK_BRACE_OPEN:\n+            if( !CHECK_PARSE_FLAG(lex, disallow_struct_literal) )\n+                return Parse_ExprVal_StructLiteral(lex, ::std::move(path));\n+            else\n+                DEBUG(\"Not parsing struct literal\");\n+        default:\n+            // Value\n+            PUTBACK(tok, lex);\n+            return NEWNODE( AST::ExprNode_NamedValue, ::std::move(path) );\n+        }\n+    case TOK_RWORD_MOVE:\n+        GET_TOK(tok, lex);\n+        if(tok.type() == TOK_PIPE)\n+            return Parse_ExprVal_Closure(lex, true);\n+        else if(tok.type() == TOK_DOUBLE_PIPE) {\n+            lex.putback(Token(TOK_PIPE));\n+            return Parse_ExprVal_Closure(lex, true);\n+        }\n+        else {\n+            CHECK_TOK(tok, TOK_PIPE);\n+        }\n+    case TOK_DOUBLE_PIPE:\n+        lex.putback(Token(TOK_PIPE));\n+    case TOK_PIPE:\n+        return Parse_ExprVal_Closure(lex, false);\n+    case TOK_INTEGER:\n+        return NEWNODE( AST::ExprNode_Integer, tok.intval(), tok.datatype() );\n+    case TOK_FLOAT:\n+        return NEWNODE( AST::ExprNode_Float, tok.floatval(), tok.datatype() );\n+    case TOK_STRING:\n+        return NEWNODE( AST::ExprNode_String, tok.str() );\n+    case TOK_BYTESTRING:\n+        return NEWNODE( AST::ExprNode_ByteString, tok.str() );\n+    case TOK_RWORD_TRUE:\n+        return NEWNODE( AST::ExprNode_Bool, true );\n+    case TOK_RWORD_FALSE:\n+        return NEWNODE( AST::ExprNode_Bool, false );\n+    case TOK_PAREN_OPEN:\n+        if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n+        {\n+            DEBUG(\"Unit\");\n+            return NEWNODE( AST::ExprNode_Tuple, ::std::vector<ExprNodeP>() );\n+        }\n+        else\n+        {\n+            CLEAR_PARSE_FLAG(lex, disallow_struct_literal);\n+            PUTBACK(tok, lex);\n+\n+            ExprNodeP rv = Parse_Expr0(lex);\n+            if( GET_TOK(tok, lex) == TOK_COMMA ) {\n+                ::std::vector<ExprNodeP> ents;\n+                ents.push_back( ::std::move(rv) );\n+                do {\n+                    if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n+                        break;\n+                    PUTBACK(tok, lex);\n+                    ents.push_back( Parse_Expr0(lex) );\n+                } while( GET_TOK(tok, lex) == TOK_COMMA );\n+                rv = NEWNODE( AST::ExprNode_Tuple, ::std::move(ents) );\n+            }\n+            CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+            return rv;\n+        }\n+    case TOK_SQUARE_OPEN:\n+        if( GET_TOK(tok, lex) == TOK_SQUARE_CLOSE )\n+        {\n+            // Empty literal\n+            return NEWNODE( AST::ExprNode_Array, ::std::vector<ExprNodeP>() );\n+        }\n+        else\n+        {\n+            PUTBACK(tok, lex);\n+            auto first = Parse_Expr0(lex);\n+            if( GET_TOK(tok, lex) == TOK_SEMICOLON )\n+            {\n+                // Repetiion\n+                auto count = Parse_Expr0(lex);\n+                GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n+                return NEWNODE( AST::ExprNode_Array, ::std::move(first), ::std::move(count) );\n+            }\n+            else\n+            {\n+                ::std::vector<ExprNodeP>    items;\n+                items.push_back( ::std::move(first) );\n+                while( tok.type() == TOK_COMMA )\n+                {\n+                    if( GET_TOK(tok, lex) == TOK_SQUARE_CLOSE )\n+                        break;\n+                    else\n+                        PUTBACK(tok, lex);\n+                    items.push_back( Parse_Expr0(lex) );\n+                    GET_TOK(tok, lex);\n+                }\n+                CHECK_TOK(tok, TOK_SQUARE_CLOSE);\n+                return NEWNODE( AST::ExprNode_Array, ::std::move(items) );\n+            }\n+        }\n+        throw ParseError::BugCheck(lex, \"Array literal fell\");\n+    default:\n+        throw ParseError::Unexpected(lex, tok);\n+    }\n+}\n+ExprNodeP Parse_ExprMacro(TokenStream& lex, AST::Path path)\n+{\n+    if( !path.is_trivial() ) {\n+        TODO(lex.point_span(), \"Support path macros - \" << path);\n+    }\n+\n+    Token   tok;\n+    ::std::string name = path.m_class.is_Local() ? path.m_class.as_Local().name : path.nodes()[0].name();\n+    ::std::string ident;\n+    if( GET_TOK(tok, lex) == TOK_IDENT ) {\n+        ident = mv$(tok.str());\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+    TokenTree tt = Parse_TT(lex, true);\n+    if( tt.is_token() ) {\n+        throw ParseError::Unexpected(lex, tt.tok());\n+    }\n+    return NEWNODE(AST::ExprNode_Macro, mv$(name), mv$(ident), mv$(tt));\n+}\n+\n+// Token Tree Parsing\n+TokenTree Parse_TT(TokenStream& lex, bool unwrapped)\n+{\n+    TokenTree   rv;\n+    TRACE_FUNCTION_FR(\"\", rv);\n+\n+    Token tok = lex.getToken();\n+    eTokenType  closer = TOK_PAREN_CLOSE;\n+    switch(tok.type())\n+    {\n+    case TOK_PAREN_OPEN:\n+        closer = TOK_PAREN_CLOSE;\n+        break;\n+    case TOK_SQUARE_OPEN:\n+        closer = TOK_SQUARE_CLOSE;\n+        break;\n+    case TOK_BRACE_OPEN:\n+        closer = TOK_BRACE_CLOSE;\n+        break;\n+\n+    case TOK_EOF:\n+    case TOK_NULL:\n+    case TOK_PAREN_CLOSE:\n+    case TOK_SQUARE_CLOSE:\n+    case TOK_BRACE_CLOSE:\n+        throw ParseError::Unexpected(lex, tok);\n+    default:\n+        rv = TokenTree(lex.getHygiene(), mv$(tok) );\n+        return rv;\n+    }\n+\n+    ::std::vector<TokenTree>   items;\n+    if( !unwrapped )\n+        items.push_back( TokenTree(lex.getHygiene(), mv$(tok)) );\n+    while(GET_TOK(tok, lex) != closer && tok.type() != TOK_EOF)\n+    {\n+        if( tok.type() == TOK_NULL )\n+            throw ParseError::Unexpected(lex, tok);\n+        PUTBACK(tok, lex);\n+        items.push_back(Parse_TT(lex, false));\n+    }\n+    if( !unwrapped )\n+        items.push_back( TokenTree(lex.getHygiene(), mv$(tok)) );\n+    rv = TokenTree(lex.getHygiene(), mv$(items));\n+    return rv;\n+}"}, {"sha": "d8a8bc43330ecac22677b939b9b11aea33272692", "filename": "gcc/rust/mrustc_parser/parse/interpolated_fragment.cpp", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,123 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/interpolated_fragment.cpp\n+ * - An \"interpolated fragment\", result of parsing e.g. :expr in a macro invocation\n+ */\n+#include <iostream>\n+#include \"interpolated_fragment.hpp\"\n+#include <ast/ast.hpp>\n+#include <ast/expr.hpp> // For definition of ExprNode\n+\n+InterpolatedFragment::~InterpolatedFragment()\n+{\n+    if( m_ptr )\n+    {\n+        switch(m_type)\n+        {\n+        case InterpolatedFragment::TT:  delete reinterpret_cast<TokenTree*>(m_ptr);  break;\n+        case InterpolatedFragment::PAT: delete reinterpret_cast<AST::Pattern*>(m_ptr); break;\n+        case InterpolatedFragment::PATH:delete reinterpret_cast<AST::Path*>(m_ptr);    break;\n+        case InterpolatedFragment::TYPE:delete reinterpret_cast<TypeRef*>(m_ptr);    break;\n+        case InterpolatedFragment::EXPR:\n+        case InterpolatedFragment::STMT:\n+        case InterpolatedFragment::BLOCK:\n+            delete reinterpret_cast<AST::ExprNode*>(m_ptr);\n+            break;\n+        case InterpolatedFragment::META:\n+            delete reinterpret_cast<AST::Attribute*>(m_ptr);\n+            break;\n+        case InterpolatedFragment::ITEM:\n+            delete reinterpret_cast<AST::Named<AST::Item>*>(m_ptr);\n+            break;\n+        }\n+    }\n+}\n+\n+InterpolatedFragment::InterpolatedFragment(InterpolatedFragment&& x):\n+    m_type( x.m_type )\n+{\n+    m_ptr = x.m_ptr, x.m_ptr = nullptr;\n+}\n+InterpolatedFragment& InterpolatedFragment::operator=(InterpolatedFragment&& x)\n+{\n+    m_type = x.m_type;\n+    m_ptr = x.m_ptr, x.m_ptr = nullptr;\n+    return *this;\n+}\n+\n+InterpolatedFragment::InterpolatedFragment(InterpolatedFragment::Type type, AST::ExprNode* ptr):\n+    m_type( type ),\n+    m_ptr( ptr )\n+{\n+}\n+InterpolatedFragment::InterpolatedFragment(AST::Attribute v):\n+    m_type( InterpolatedFragment::META ),\n+    m_ptr( new AST::Attribute(mv$(v)) )\n+{\n+}\n+InterpolatedFragment::InterpolatedFragment(::AST::Named<::AST::Item> v):\n+    m_type( InterpolatedFragment::ITEM ),\n+    m_ptr( new ::AST::Named<::AST::Item>( mv$(v) ) )\n+{\n+}\n+InterpolatedFragment::InterpolatedFragment(TokenTree v):\n+    m_type( InterpolatedFragment::TT ),\n+    m_ptr( new TokenTree(mv$(v)) )\n+{\n+}\n+InterpolatedFragment::InterpolatedFragment(AST::Path v):\n+    m_type( InterpolatedFragment::PATH ),\n+    m_ptr( new AST::Path(mv$(v)) )\n+{\n+}\n+InterpolatedFragment::InterpolatedFragment(AST::Pattern v):\n+    m_type( InterpolatedFragment::PAT ),\n+    m_ptr( new AST::Pattern(mv$(v)) )\n+{\n+}\n+InterpolatedFragment::InterpolatedFragment(TypeRef v):\n+    m_type( InterpolatedFragment::TYPE ),\n+    m_ptr( new TypeRef(mv$(v)) )\n+{\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, InterpolatedFragment const& x)\n+{\n+    switch(x.m_type)\n+    {\n+    case InterpolatedFragment::TT:\n+        os << \"tt[\" << x.as_tt() << \"]\";\n+        break;\n+    case InterpolatedFragment::PAT:\n+        os << \"pat[\" << *reinterpret_cast<AST::Pattern*>(x.m_ptr) << \"]\";\n+        break;\n+    case InterpolatedFragment::PATH:\n+        os << \"path[\" << *reinterpret_cast<AST::Path*>(x.m_ptr) << \"]\";\n+        break;\n+    case InterpolatedFragment::TYPE:\n+        os << \"type[\" << *reinterpret_cast<TypeRef*>(x.m_ptr) << \"]\";\n+        break;\n+\n+    case InterpolatedFragment::EXPR:\n+        os << \"expr[\" << *reinterpret_cast<const AST::ExprNode*>(x.m_ptr) << \"]\";\n+        break;\n+    case InterpolatedFragment::STMT:\n+        os << \"stmt[\" << *reinterpret_cast<const AST::ExprNode*>(x.m_ptr) << \"]\";\n+        break;\n+    case InterpolatedFragment::BLOCK:\n+        os << \"block[\" << *reinterpret_cast<const AST::ExprNode*>(x.m_ptr) << \"]\";\n+        break;\n+\n+    case InterpolatedFragment::META:\n+        os << \"meta[\" << *reinterpret_cast<const AST::Attribute*>(x.m_ptr) << \"]\";\n+        break;\n+    case InterpolatedFragment::ITEM: {\n+        const auto& named_item = *reinterpret_cast<const AST::Named<AST::Item>*>(x.m_ptr);\n+        os << \"item[\" << named_item.data.tag_str() << \"(\" << named_item.name << \")]\";\n+        } break;\n+    }\n+    return os;\n+}\n+"}, {"sha": "36539fb0e0ac3b14dfaf0249f0baab4a1c7c3a55", "filename": "gcc/rust/mrustc_parser/parse/interpolated_fragment.hpp", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,61 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/interpolated_fragment.hpp\n+ * - An \"interpolated fragment\", result of parsing e.g. :expr in a macro invocation\n+ */\n+#pragma once\n+\n+#include <cassert>\n+\n+class TypeRef;\n+class TokenTree;\n+namespace AST {\n+    class Pattern;\n+    class Path;\n+    class ExprNode;\n+    class Attribute;\n+    template<typename T> struct Named;\n+    class Item;\n+};\n+\n+\n+class InterpolatedFragment\n+{\n+public:\n+    enum Type\n+    {\n+        TT,\n+        PAT,\n+        PATH,\n+        TYPE,\n+\n+        EXPR,\n+        STMT,\n+        BLOCK,\n+\n+        META,\n+        ITEM,\n+    } m_type;\n+\n+    // Owned type-pruned pointer\n+    void*   m_ptr;\n+\n+    InterpolatedFragment(InterpolatedFragment&& );\n+    InterpolatedFragment& operator=(InterpolatedFragment&& );\n+    //InterpolatedFragment(const InterpolatedFragment& );\n+    InterpolatedFragment(TokenTree );\n+    InterpolatedFragment(::AST::Pattern);\n+    InterpolatedFragment(::AST::Path);\n+    InterpolatedFragment(::TypeRef);\n+    InterpolatedFragment(::AST::Attribute );\n+    InterpolatedFragment(::AST::Named<AST::Item> );\n+    ~InterpolatedFragment();\n+    InterpolatedFragment(Type , ::AST::ExprNode*);\n+\n+    TokenTree& as_tt() { assert(m_type == TT); return *reinterpret_cast<TokenTree*>(m_ptr); }\n+    const TokenTree& as_tt() const { assert(m_type == TT); return *reinterpret_cast<TokenTree*>(m_ptr); }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const InterpolatedFragment& x);\n+};"}, {"sha": "a71289ee21582147c6bebac9557a006e1d23d6db", "filename": "gcc/rust/mrustc_parser/parse/lex.cpp", "status": "added", "additions": 1071, "deletions": 0, "changes": 1071, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,1071 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/lex.cpp\n+ * - Lexer (converts input file to token stream)\n+ */\n+#include \"lex.hpp\"\n+#include \"../common.hpp\"\n+#include \"parseerror.hpp\"\n+#include \"tokentree.hpp\"\n+#include <algorithm> // std::count\n+#include <cassert>\n+#include <cctype>\n+#include <cstdlib> // strtol\n+#include <iostream>\n+#include <typeinfo>\n+//#define TRACE_CHARS\n+//#define TRACE_RAW_TOKENS\n+\n+Lexer::Lexer(const ::std::string& filename)\n+  : m_path(filename.c_str())\n+  , m_line(1)\n+  , m_line_ofs(0)\n+  , m_istream(filename.c_str())\n+  , m_last_char_valid(false)\n+  , m_hygiene(Ident::Hygiene::new_scope()) {\n+    if (!m_istream.is_open()) {\n+        throw ::std::runtime_error(\"Unable to open file '\" + filename + \"'\");\n+    }\n+    // Consume the BOM\n+    if (this->getc_byte() == '\\xef') {\n+        if (this->getc_byte() != '\\xbb') {\n+            throw ::std::runtime_error(\"Incomplete BOM - missing \\\\xBB in second position\");\n+        }\n+        if (this->getc_byte() != '\\xbf') {\n+            throw ::std::runtime_error(\"Incomplete BOM - missing \\\\xBF in second position\");\n+        }\n+        m_line_ofs = 0;\n+    } else {\n+        m_istream.unget();\n+    }\n+}\n+\n+#define LINECOMMENT -1\n+#define BLOCKCOMMENT -2\n+#define SINGLEQUOTE -3\n+#define DOUBLEQUOTE -4\n+#define SHEBANG -5\n+\n+// NOTE: This array must be kept sorted, or symbols are will be skipped\n+#define TOKENT(str, sym) \\\n+    { sizeof(str) - 1, str, sym }\n+static const struct {\n+    unsigned char len;\n+    const char* chars;\n+    signed int type;\n+} TOKENMAP[] = {\n+    TOKENT(\"!\", TOK_EXCLAM),\n+    TOKENT(\"!=\", TOK_EXCLAM_EQUAL),\n+    TOKENT(\"\\\"\", DOUBLEQUOTE),\n+    TOKENT(\"#\", TOK_HASH),\n+    TOKENT(\"$\", TOK_DOLLAR),\n+    TOKENT(\"%\", TOK_PERCENT),\n+    TOKENT(\"%=\", TOK_PERCENT_EQUAL),\n+    TOKENT(\"&\", TOK_AMP),\n+    TOKENT(\"&&\", TOK_DOUBLE_AMP),\n+    TOKENT(\"&=\", TOK_AMP_EQUAL),\n+    TOKENT(\"'\", SINGLEQUOTE),\n+    TOKENT(\"(\", TOK_PAREN_OPEN),\n+    TOKENT(\")\", TOK_PAREN_CLOSE),\n+    TOKENT(\"*\", TOK_STAR),\n+    TOKENT(\"*=\", TOK_STAR_EQUAL),\n+    TOKENT(\"+\", TOK_PLUS),\n+    TOKENT(\"+=\", TOK_PLUS_EQUAL),\n+    TOKENT(\",\", TOK_COMMA),\n+    TOKENT(\"-\", TOK_DASH),\n+    TOKENT(\"-=\", TOK_DASH_EQUAL),\n+    TOKENT(\"->\", TOK_THINARROW),\n+    TOKENT(\".\", TOK_DOT),\n+    TOKENT(\"..\", TOK_DOUBLE_DOT),\n+    TOKENT(\"...\", TOK_TRIPLE_DOT),\n+    TOKENT(\"/\", TOK_SLASH),\n+    TOKENT(\"/*\", BLOCKCOMMENT),\n+    TOKENT(\"//\", LINECOMMENT),\n+    TOKENT(\"/=\", TOK_SLASH_EQUAL),\n+    // 0-9 :: Elsewhere\n+    TOKENT(\":\", TOK_COLON),\n+    TOKENT(\"::\", TOK_DOUBLE_COLON),\n+    TOKENT(\";\", TOK_SEMICOLON),\n+    TOKENT(\"<\", TOK_LT),\n+    TOKENT(\"<-\", TOK_THINARROW_LEFT),\n+    TOKENT(\"<<\", TOK_DOUBLE_LT),\n+    TOKENT(\"<<=\", TOK_DOUBLE_LT_EQUAL),\n+    TOKENT(\"<=\", TOK_LTE),\n+    TOKENT(\"=\", TOK_EQUAL),\n+    TOKENT(\"==\", TOK_DOUBLE_EQUAL),\n+    TOKENT(\"=>\", TOK_FATARROW),\n+    TOKENT(\">\", TOK_GT),\n+    TOKENT(\">=\", TOK_GTE),\n+    TOKENT(\">>\", TOK_DOUBLE_GT),\n+    TOKENT(\">>=\", TOK_DOUBLE_GT_EQUAL),\n+    TOKENT(\"?\", TOK_QMARK),\n+    TOKENT(\"@\", TOK_AT),\n+    // A-Z :: Elsewhere\n+    TOKENT(\"[\", TOK_SQUARE_OPEN),\n+    TOKENT(\"\\\\\", TOK_BACKSLASH),\n+    TOKENT(\"]\", TOK_SQUARE_CLOSE),\n+    TOKENT(\"^\", TOK_CARET),\n+    TOKENT(\"^=\", TOK_CARET_EQUAL),\n+    TOKENT(\"`\", TOK_BACKTICK),\n+    // a-z :: Elsewhere\n+    //TOKENT(\"b\\\"\", DOUBLEQUOTE),\n+\n+    TOKENT(\"{\", TOK_BRACE_OPEN),\n+    TOKENT(\"|\", TOK_PIPE),\n+    TOKENT(\"|=\", TOK_PIPE_EQUAL),\n+    TOKENT(\"||\", TOK_DOUBLE_PIPE),\n+    TOKENT(\"}\", TOK_BRACE_CLOSE),\n+    TOKENT(\"~\", TOK_TILDE),\n+};\n+#define LEN(arr) (sizeof(arr) / sizeof(arr[0]))\n+static const struct {\n+    unsigned char len;\n+    const char* chars;\n+    signed int type;\n+} RWORDS[] = {\n+    TOKENT(\"_\", TOK_UNDERSCORE),\n+    TOKENT(\"abstract\", TOK_RWORD_ABSTRACT),\n+    TOKENT(\"alignof\", TOK_RWORD_ALIGNOF),\n+    TOKENT(\"as\", TOK_RWORD_AS),\n+    TOKENT(\"be\", TOK_RWORD_BE),\n+    TOKENT(\"box\", TOK_RWORD_BOX),\n+    TOKENT(\"break\", TOK_RWORD_BREAK),\n+    TOKENT(\"const\", TOK_RWORD_CONST),\n+    TOKENT(\"continue\", TOK_RWORD_CONTINUE),\n+    TOKENT(\"crate\", TOK_RWORD_CRATE),\n+    TOKENT(\"do\", TOK_RWORD_DO),\n+    TOKENT(\"else\", TOK_RWORD_ELSE),\n+    TOKENT(\"enum\", TOK_RWORD_ENUM),\n+    TOKENT(\"extern\", TOK_RWORD_EXTERN),\n+    TOKENT(\"false\", TOK_RWORD_FALSE),\n+    TOKENT(\"final\", TOK_RWORD_FINAL),\n+    TOKENT(\"fn\", TOK_RWORD_FN),\n+    TOKENT(\"for\", TOK_RWORD_FOR),\n+    TOKENT(\"if\", TOK_RWORD_IF),\n+    TOKENT(\"impl\", TOK_RWORD_IMPL),\n+    TOKENT(\"in\", TOK_RWORD_IN),\n+    TOKENT(\"let\", TOK_RWORD_LET),\n+    TOKENT(\"loop\", TOK_RWORD_LOOP),\n+    TOKENT(\"match\", TOK_RWORD_MATCH),\n+    TOKENT(\"mod\", TOK_RWORD_MOD),\n+    TOKENT(\"move\", TOK_RWORD_MOVE),\n+    TOKENT(\"mut\", TOK_RWORD_MUT),\n+    TOKENT(\"offsetof\", TOK_RWORD_OFFSETOF),\n+    TOKENT(\"override\", TOK_RWORD_OVERRIDE),\n+    TOKENT(\"priv\", TOK_RWORD_PRIV),\n+    TOKENT(\"proc\", TOK_RWORD_PROC),\n+    TOKENT(\"pub\", TOK_RWORD_PUB),\n+    TOKENT(\"pure\", TOK_RWORD_PURE),\n+    TOKENT(\"ref\", TOK_RWORD_REF),\n+    TOKENT(\"return\", TOK_RWORD_RETURN),\n+    TOKENT(\"self\", TOK_RWORD_SELF),\n+    TOKENT(\"sizeof\", TOK_RWORD_SIZEOF),\n+    TOKENT(\"static\", TOK_RWORD_STATIC),\n+    TOKENT(\"struct\", TOK_RWORD_STRUCT),\n+    TOKENT(\"super\", TOK_RWORD_SUPER),\n+    TOKENT(\"trait\", TOK_RWORD_TRAIT),\n+    TOKENT(\"true\", TOK_RWORD_TRUE),\n+    TOKENT(\"type\", TOK_RWORD_TYPE),\n+    TOKENT(\"typeof\", TOK_RWORD_TYPEOF),\n+    TOKENT(\"unsafe\", TOK_RWORD_UNSAFE),\n+    TOKENT(\"unsized\", TOK_RWORD_UNSIZED),\n+    TOKENT(\"use\", TOK_RWORD_USE),\n+    TOKENT(\"virtual\", TOK_RWORD_VIRTUAL),\n+    TOKENT(\"where\", TOK_RWORD_WHERE),\n+    TOKENT(\"while\", TOK_RWORD_WHILE),\n+    TOKENT(\"yield\", TOK_RWORD_YIELD),\n+};\n+\n+signed int Lexer::getSymbol() {\n+    Codepoint ch = this->getc();\n+    // 1. lsearch for character\n+    // 2. Consume as many characters as currently match\n+    // 3. IF: a smaller character or, EOS is hit - Return current best\n+    unsigned ofs = 0;\n+    signed int best = 0;\n+    bool hit_eof = false;\n+    for (unsigned i = 0; i < LEN(TOKENMAP); i++) {\n+        const char* const chars = TOKENMAP[i].chars;\n+        const size_t len = TOKENMAP[i].len;\n+\n+        if (ofs >= len || static_cast<uint32_t>(chars[ofs]) > ch.v) {\n+            break;\n+        }\n+\n+        while (chars[ofs] && ch == chars[ofs]) {\n+            try {\n+                ch = this->getc();\n+            } catch (Lexer::EndOfFile) {\n+                ch = 0;\n+                // Prevent `ungetc` if EOF was hit\n+                hit_eof = true;\n+            }\n+            ofs++;\n+        }\n+        if (chars[ofs] == 0) {\n+            best = TOKENMAP[i].type;\n+        }\n+    }\n+\n+    if (!hit_eof) {\n+        this->ungetc();\n+    }\n+    \n+    return best;\n+}\n+\n+bool issym(Codepoint ch) {\n+    if ('0' <= ch.v && ch.v <= '9')\n+        return true;\n+    if (::std::isalpha(ch.v))\n+        return true;\n+    if (ch == '_')\n+        return true;\n+    if (ch.v >= 128)\n+        return !ch.isspace();\n+    return false;\n+}\n+\n+Position Lexer::getPosition() const {\n+    return Position(m_path, m_line, m_line_ofs);\n+}\n+\n+Ident::Hygiene Lexer::realGetHygiene() const {\n+    return m_hygiene;\n+}\n+\n+Token Lexer::realGetToken() {\n+    while (true) {\n+        Token tok = getTokenInt();\n+#ifdef TRACE_RAW_TOKENS\n+        ::std::cout << \"getTokenInt: tok = \" << tok << ::std::endl;\n+#endif\n+        switch (tok.type()) {\n+            case TOK_NEWLINE:\n+                continue;\n+            case TOK_WHITESPACE:\n+                continue;\n+            case TOK_COMMENT: {\n+                continue;\n+            }\n+            default:\n+                return tok;\n+        }\n+    }\n+}\n+\n+Token Lexer::getTokenInt() {\n+    if (!this->m_next_tokens.empty()) {\n+        auto rv = ::std::move(this->m_next_tokens.back());\n+        m_next_tokens.pop_back();\n+        return rv;\n+    }\n+    try {\n+        Codepoint ch = this->getc();\n+\n+        if (m_line == 1 && m_line_ofs == 1 && ch == '#') {\n+            switch ((ch = this->getc()).v) {\n+                case '!':\n+                    switch ((ch = this->getc()).v) {\n+                        case '/':\n+                            // SHEBANG!\n+                            while (ch != '\\n')\n+                                ch = this->getc();\n+                            return Token(TOK_NEWLINE);\n+                        case '[':\n+                            this->ungetc();\n+                            this->m_next_tokens.push_back(TOK_EXCLAM);\n+                            return Token(TOK_HASH);\n+                        default:\n+                            throw ParseError::BadChar(*this, ch.v);\n+                    }\n+                case '[':\n+                    this->ungetc();\n+                    return Token(TOK_HASH);\n+                default:\n+                    this->ungetc();\n+                    //return Token(TOK_HASH);\n+                    throw ParseError::BadChar(*this, ch.v);\n+            }\n+        }\n+\n+        if (ch == '\\n')\n+            return Token(TOK_NEWLINE);\n+        if (ch.isspace()) {\n+            while ((ch = this->getc()).isspace() && ch != '\\n')\n+                ;\n+            this->ungetc();\n+            return Token(TOK_WHITESPACE);\n+        }\n+        this->ungetc();\n+\n+        const signed int sym = this->getSymbol();\n+        if (sym == 0) {\n+            // No match at all, check for symbol\n+            auto ch = this->getc();\n+            if (ch.isdigit()) {\n+                enum eCoreType num_type = CORETYPE_ANY;\n+                enum {\n+                    BIN,\n+                    OCT,\n+                    DEC,\n+                    HEX,\n+                } num_mode = DEC;\n+\n+                // Handle integers/floats\n+                uint64_t val = 0;\n+                if (ch == '0') {\n+                    // Octal/hex handling\n+                    ch = this->getc_num();\n+                    if (ch == 'x') {\n+                        num_mode = HEX;\n+                        while ((ch = this->getc_num()).isxdigit()) {\n+                            val *= 16;\n+                            if (ch.v <= '9')\n+                                val += ch.v - '0';\n+                            else if (ch.v <= 'F')\n+                                val += ch.v - 'A' + 10;\n+                            else if (ch.v <= 'f')\n+                                val += ch.v - 'a' + 10;\n+                        }\n+                    } else if (ch == 'b') {\n+                        num_mode = BIN;\n+                        while ((ch = this->getc_num()).isdigit()) {\n+                            val *= 2;\n+                            if (ch.v == '0')\n+                                val += 0;\n+                            else if (ch.v == '1')\n+                                val += 1;\n+                            else\n+                                throw ParseError::Generic(\"Invalid digit in binary literal\");\n+                        }\n+                    } else if (ch == 'o') {\n+                        num_mode = OCT;\n+                        while ((ch = this->getc_num()).isdigit()) {\n+                            val *= 8;\n+                            if ('0' <= ch.v && ch.v <= '7')\n+                                val += ch.v - '0';\n+                            else\n+                                throw ParseError::Generic(\"Invalid digit in octal literal\");\n+                        }\n+                    } else {\n+                        num_mode = DEC;\n+                        while (ch.isdigit()) {\n+                            val *= 10;\n+                            val += ch.v - '0';\n+                            ch = this->getc_num();\n+                        }\n+                    }\n+                } else {\n+                    while (ch.isdigit()) {\n+                        val *= 10;\n+                        val += ch.v - '0';\n+                        ch = this->getc_num();\n+                    }\n+                }\n+\n+                if (ch == 'e' || ch == 'E' || ch == '.') {\n+                    if (ch == '.') {\n+                        ch = this->getc();\n+\n+                        // Double/Triple Dot\n+                        if (ch == '.') {\n+                            if (this->getc() == '.') {\n+                                this->m_next_tokens.push_back(TOK_TRIPLE_DOT);\n+                            } else {\n+                                this->ungetc();\n+                                this->m_next_tokens.push_back(TOK_DOUBLE_DOT);\n+                            }\n+                            return Token(val, CORETYPE_ANY);\n+                        }\n+\n+                        // Single dot followed by a non-digit, could be a float or an integer with a method/field access\n+                        if (!ch.isdigit()) {\n+                            this->ungetc();\n+                            if (issym(ch)) {\n+                                this->m_next_tokens.push_back(TOK_DOT);\n+                                return Token(val, CORETYPE_ANY);\n+                            } else {\n+                                double fval = static_cast<double>(val);\n+                                return Token(fval, CORETYPE_ANY);\n+                            }\n+                        } else {\n+                            // Digit, continue\n+                            // NOTE: parseFloat assumes that the '.' has been consumed, and reads digits until it hits a non-digit and then parses exponents\n+                            // - Thus, continuing here and letting the below 'ungetc' push a digit back is correct.\n+                        }\n+                    }\n+                    if (num_mode != DEC)\n+                        TODO(this->getPosition(), \"Non-decimal floats\");\n+\n+                    this->ungetc();\n+                    double fval = this->parseFloat(val);\n+                    if (issym(ch = this->getc())) {\n+                        ::std::string suffix;\n+                        while (issym(ch)) {\n+                            suffix += ch;\n+                            ch = this->getc();\n+                        }\n+                        this->ungetc();\n+\n+                        if (0)\n+                            ;\n+                        else if (suffix == \"f32\")\n+                            num_type = CORETYPE_F32;\n+                        else if (suffix == \"f64\")\n+                            num_type = CORETYPE_F64;\n+                        else\n+                            throw ParseError::Generic(FMT(\"Unknown number suffix \" << suffix));\n+                    } else {\n+                        this->ungetc();\n+                    }\n+                    return Token(fval, num_type);\n+\n+                } else if (issym(ch)) {\n+                    // Unsigned\n+                    ::std::string suffix;\n+                    while (issym(ch)) {\n+                        suffix += ch;\n+                        ch = this->getc();\n+                    }\n+                    this->ungetc();\n+\n+                    if (0)\n+                        ;\n+                    else if (suffix == \"i8\")\n+                        num_type = CORETYPE_I8;\n+                    else if (suffix == \"i16\")\n+                        num_type = CORETYPE_I16;\n+                    else if (suffix == \"i32\")\n+                        num_type = CORETYPE_I32;\n+                    else if (suffix == \"i64\")\n+                        num_type = CORETYPE_I64;\n+                    else if (suffix == \"i128\")\n+                        num_type = CORETYPE_I128;\n+                    else if (suffix == \"isize\")\n+                        num_type = CORETYPE_INT;\n+                    else if (suffix == \"u8\")\n+                        num_type = CORETYPE_U8;\n+                    else if (suffix == \"u16\")\n+                        num_type = CORETYPE_U16;\n+                    else if (suffix == \"u32\")\n+                        num_type = CORETYPE_U32;\n+                    else if (suffix == \"u64\")\n+                        num_type = CORETYPE_U64;\n+                    else if (suffix == \"u128\")\n+                        num_type = CORETYPE_U128;\n+                    else if (suffix == \"usize\")\n+                        num_type = CORETYPE_UINT;\n+                    else if (suffix == \"f32\")\n+                        num_type = CORETYPE_F32;\n+                    else if (suffix == \"f64\")\n+                        num_type = CORETYPE_F64;\n+                    else\n+                        throw ParseError::Generic(*this, FMT(\"Unknown integer suffix '\" << suffix << \"'\"));\n+                    return Token(val, num_type);\n+                } else {\n+                    this->ungetc();\n+                    return Token(val, num_type);\n+                }\n+            }\n+            // Byte/Raw strings\n+            else if (ch == 'b' || ch == 'r') {\n+                bool is_byte = false;\n+                if (ch == 'b') {\n+                    is_byte = true;\n+                    ch = this->getc();\n+                }\n+\n+                if (ch == 'r') {\n+                    return this->getTokenInt_RawString(is_byte);\n+                } else {\n+                    assert(is_byte);\n+\n+                    // Byte string\n+                    if (ch == '\"') {\n+                        ::std::string str;\n+                        while ((ch = this->getc()) != '\"') {\n+                            if (ch == '\\\\') {\n+                                auto v = this->parseEscape('\"');\n+                                if (v != ~0u) {\n+                                    if (v > 256)\n+                                        throw ParseError::Generic(*this, \"Value out of range for byte literal\");\n+                                    str += (char)v;\n+                                }\n+                            } else {\n+                                str += ch;\n+                            }\n+                        }\n+                        return Token(TOK_BYTESTRING, str);\n+                    }\n+                    // Byte constant\n+                    else if (ch == '\\'') {\n+                        // Byte constant\n+                        ch = this->getc();\n+                        if (ch == '\\\\') {\n+                            uint32_t val = this->parseEscape('\\'');\n+                            if (this->getc() != '\\'')\n+                                throw ParseError::Generic(*this, \"Multi-byte character literal\");\n+                            return Token((uint64_t)val, CORETYPE_U8);\n+                        } else {\n+                            if (this->getc() != '\\'')\n+                                throw ParseError::Generic(*this, \"Multi-byte character literal\");\n+                            return Token((uint64_t)ch.v, CORETYPE_U8);\n+                        }\n+                    } else {\n+                        assert(is_byte);\n+                        this->ungetc();\n+                        return this->getTokenInt_Identifier('b');\n+                    }\n+                }\n+            }\n+            // Symbols\n+            else if (issym(ch)) {\n+                return this->getTokenInt_Identifier(ch);\n+            } else {\n+                throw ParseError::BadChar(*this, ch.v);\n+            }\n+        } else if (sym > 0) {\n+            return Token((enum eTokenType)sym);\n+        } else {\n+            switch (sym) {\n+                case LINECOMMENT: {\n+                    // Line comment\n+                    ::std::string str;\n+                    auto ch = this->getc();\n+                    bool is_doc = false;\n+                    bool is_pdoc = false;\n+                    if (ch == '/') {\n+                        ch = this->getc();\n+                        if (ch == '/')\n+                            str += \"/\";\n+                        else\n+                            is_doc = true;\n+                    } else if (ch == '!') {\n+                        is_pdoc = true;\n+                        ch = this->getc();\n+                    }\n+                    while (ch != '\\n' && ch != '\\r') {\n+                        str += ch;\n+                        ch = this->getc();\n+                    }\n+                    this->ungetc();\n+                    if (is_doc || is_pdoc) {\n+                        //# [ doc = \"commment data\" ]\n+                        m_next_tokens.push_back(TOK_SQUARE_CLOSE);\n+                        m_next_tokens.push_back(Token(TOK_STRING, mv$(str)));\n+                        m_next_tokens.push_back(TOK_EQUAL);\n+                        m_next_tokens.push_back(Token(TOK_IDENT, \"doc\"));\n+                        m_next_tokens.push_back(TOK_SQUARE_OPEN);\n+                        if (is_pdoc)\n+                            m_next_tokens.push_back(TOK_EXCLAM);\n+                        return TOK_HASH;\n+                    }\n+                    return Token(TOK_COMMENT, str);\n+                }\n+                case BLOCKCOMMENT: {\n+                    ::std::string str;\n+                    bool is_doc = false;\n+                    bool is_pdoc = false;\n+                    ch = this->getc();\n+                    if (ch == '*') {\n+                        ch = this->getc();\n+                        if (ch == '*') {\n+                            str += \"*\";\n+                        } else\n+                            is_doc = true;\n+                    } else if (ch == '!') {\n+                        is_pdoc = true;\n+                        ch = this->getc();\n+                    }\n+                    unsigned int level = 0;\n+                    while (true) {\n+                        if (ch == '/') {\n+                            str += ch;\n+                            ch = this->getc();\n+                            if (ch == '*') {\n+                                level++;\n+                            }\n+                            str += ch;\n+                        } else {\n+                            if (ch == '*') {\n+                                ch = this->getc();\n+                                if (ch == '/') {\n+                                    if (level == 0)\n+                                        break;\n+                                    level--;\n+                                    str.push_back('*');\n+                                    str.push_back('/');\n+                                } else {\n+                                    str.push_back('*');\n+                                    str += ch;\n+                                }\n+                            } else {\n+                                str += ch;\n+                            }\n+                        }\n+                        ch = this->getc();\n+                    }\n+                    if (is_doc || is_pdoc) {\n+                        //# [ doc = \"commment data\" ]\n+                        m_next_tokens.push_back(TOK_SQUARE_CLOSE);\n+                        m_next_tokens.push_back(Token(TOK_STRING, mv$(str)));\n+                        m_next_tokens.push_back(TOK_EQUAL);\n+                        m_next_tokens.push_back(Token(TOK_IDENT, \"doc\"));\n+                        m_next_tokens.push_back(TOK_SQUARE_OPEN);\n+                        if (is_pdoc)\n+                            m_next_tokens.push_back(TOK_EXCLAM);\n+                        return TOK_HASH;\n+                    }\n+                    return Token(TOK_COMMENT, str);\n+                }\n+                case SINGLEQUOTE: {\n+                    auto firstchar = this->getc();\n+                    if (firstchar.v == '\\\\') {\n+                        // Character constant with an escape code\n+                        uint32_t val = this->parseEscape('\\'');\n+                        if (this->getc() != '\\'') {\n+                            throw ParseError::Todo(\"Proper error for lex failures\");\n+                        }\n+                        return Token((uint64_t)val, CORETYPE_CHAR);\n+                    } else {\n+                        ch = this->getc();\n+                        if (ch == '\\'') {\n+                            // Character constant\n+                            return Token((uint64_t)firstchar.v, CORETYPE_CHAR);\n+                        } else if (issym(firstchar.v)) {\n+                            // Lifetime name\n+                            ::std::string str;\n+                            str += firstchar;\n+                            while (issym(ch)) {\n+                                str += ch;\n+                                ch = this->getc();\n+                            }\n+                            this->ungetc();\n+                            return Token(TOK_LIFETIME, str);\n+                        } else {\n+                            throw ParseError::Todo(\"Lex Fail - Expected ' after character constant\");\n+                        }\n+                    }\n+                    break;\n+                }\n+                case DOUBLEQUOTE: {\n+                    ::std::string str;\n+                    while ((ch = this->getc()) != '\"') {\n+                        if (ch == '\\\\') {\n+                            auto v = this->parseEscape('\"');\n+                            if (v != ~0u) {\n+                                str += Codepoint(v);\n+                            }\n+                        } else {\n+                            str += ch;\n+                        }\n+                    }\n+                    return Token(TOK_STRING, str);\n+                }\n+                default:\n+                    assert(!\"bugcheck\");\n+            }\n+        }\n+    } catch (const Lexer::EndOfFile& /*e*/) {\n+        return Token(TOK_EOF);\n+    }\n+\n+    throw \"Fell off the end of getTokenInt\";\n+}\n+\n+Token Lexer::getTokenInt_RawString(bool is_byte) {\n+    // Raw string (possibly byte)\n+    Codepoint ch = this->getc();\n+    unsigned int hashes = 0;\n+    while (ch == '#') {\n+        hashes++;\n+        ch = this->getc();\n+    }\n+\n+    if (hashes == 0 && ch != '\"') {\n+        this->ungetc(); // Unget the not '\"'\n+        if (is_byte)\n+            return this->getTokenInt_Identifier('b', 'r');\n+        else\n+            return this->getTokenInt_Identifier('r');\n+    }\n+    auto terminator = ch;\n+    ::std::string val;\n+    DEBUG(\"terminator = '\" << terminator << \"', hashes = \" << hashes);\n+\n+    unsigned terminating_hashes = 0;\n+\n+    for (;;) {\n+        try {\n+            ch = this->getc();\n+        } catch (const Lexer::EndOfFile& /*e*/) {\n+            throw ParseError::Generic(*this, \"EOF reached in raw string\");\n+        }\n+\n+        if (terminating_hashes > 0) {\n+            assert(terminating_hashes > 0);\n+            if (ch != '#') {\n+                val += terminator;\n+                while (terminating_hashes < hashes) {\n+                    val += '#';\n+                    terminating_hashes += 1;\n+                }\n+                terminating_hashes = 0;\n+\n+                this->ungetc();\n+            } else {\n+                terminating_hashes -= 1;\n+                if (terminating_hashes == 0) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            if (ch == terminator) {\n+                if (hashes == 0) {\n+                    break;\n+                }\n+                terminating_hashes = hashes;\n+            } else {\n+                val += ch;\n+            }\n+        }\n+    }\n+\n+    return Token(is_byte ? TOK_BYTESTRING : TOK_STRING, val);\n+}\n+Token Lexer::getTokenInt_Identifier(Codepoint leader, Codepoint leader2) {\n+    ::std::string str;\n+    \n+    if (leader2 != '\\0')\n+        str += leader;\n+\n+    auto ch = leader2 == '\\0' ? leader : leader2;\n+\n+    while (issym(ch)) {\n+        str += ch;\n+        ch = this->getc();\n+    }\n+\n+    this->ungetc();\n+    for (unsigned int i = 0; i < LEN(RWORDS); i++) {\n+        if (str < RWORDS[i].chars)\n+            break;\n+        if (str == RWORDS[i].chars)\n+            return Token((enum eTokenType)RWORDS[i].type);\n+    }\n+    return Token(TOK_IDENT, mv$(str));\n+}\n+\n+// Takes the VERY lazy way of reading the float into a string then passing to strtod\n+double Lexer::parseFloat(uint64_t whole) {\n+    const int MAX_LEN = 63;\n+    const int MAX_SIG = MAX_LEN - 1 - 4;\n+    char buf[MAX_LEN + 1];\n+    int ofs = snprintf(buf, MAX_LEN + 1, \"%llu.\", (unsigned long long)whole);\n+\n+    auto ch = this->getc_num();\n+#define PUTC(ch)                                          \\\n+    do {                                                  \\\n+        if (ofs < MAX_SIG) {                              \\\n+            assert(ch.v < 127);                           \\\n+            buf[ofs] = ch.v;                              \\\n+            ofs++;                                        \\\n+        } else {                                          \\\n+            throw ParseError::Generic(\"Oversized float\"); \\\n+        }                                                 \\\n+    } while (0)\n+    while (ch.isdigit()) {\n+        PUTC(ch);\n+        ch = this->getc_num();\n+    }\n+\n+    if (ch == 'e' || ch == 'E') {\n+        PUTC(ch);\n+        ch = this->getc_num();\n+        if (ch == '-' || ch == '+') {\n+            PUTC(ch);\n+            ch = this->getc_num();\n+        }\n+        if (!ch.isdigit())\n+            throw ParseError::Generic(FMT(\"Non-numeric '\" << ch << \"' in float exponent\"));\n+        do {\n+            PUTC(ch);\n+            ch = this->getc_num();\n+        } while (ch.isdigit());\n+    }\n+\n+    this->ungetc();\n+    buf[ofs] = 0;\n+\n+    DEBUG(\"buf = \" << buf << \", ch = '\" << ch << \"'\");\n+\n+    return ::std::strtod(buf, NULL);\n+}\n+\n+uint32_t Lexer::parseEscape(char enclosing) {\n+    auto ch = this->getc();\n+\n+    switch (ch.v) {\n+        case 'x': {\n+            ch = this->getc();\n+            if (!ch.isxdigit())\n+                throw ParseError::Generic(*this, FMT(\"Found invalid character '\\\\x\" << ::std::hex << ch.v << \"' in \\\\u sequence\"));\n+            char tmp[3] = { static_cast<char>(ch.v), 0, 0 };\n+            ch = this->getc();\n+            if (!ch.isxdigit())\n+                throw ParseError::Generic(*this, FMT(\"Found invalid character '\\\\x\" << ::std::hex << ch.v << \"' in \\\\u sequence\"));\n+            tmp[1] = static_cast<char>(ch.v);\n+            return ::std::strtol(tmp, NULL, 16);\n+        } break;\n+        case 'u': {\n+            // Unicode (up to six hex digits)\n+            uint32_t val = 0;\n+            ch = this->getc();\n+            bool req_close_brace = false;\n+            if (ch == '{') {\n+                req_close_brace = true;\n+                ch = this->getc();\n+            }\n+            if (!ch.isxdigit())\n+                throw ParseError::Generic(*this, FMT(\"Found invalid character '\\\\x\" << ::std::hex << ch.v << \"' in \\\\u sequence\"));\n+            while (ch.isxdigit()) {\n+                char tmp[2] = { static_cast<char>(ch.v), 0 };\n+                val *= 16;\n+                val += ::std::strtol(tmp, NULL, 16);\n+                ch = this->getc();\n+            }\n+            if (!req_close_brace)\n+                this->ungetc();\n+            else if (ch != '}')\n+                throw ParseError::Generic(*this, \"Expected terminating } in \\\\u sequence\");\n+            else {\n+            }\n+            return val;\n+        }\n+\n+        case '0':\n+            return '\\0';\n+        case '\\\\':\n+            return '\\\\';\n+        case '\\'':\n+            return '\\'';\n+        case '\"':\n+            return '\"';\n+        case 'r':\n+            return '\\r';\n+        case 'n':\n+            return '\\n';\n+        case 't':\n+            return '\\t';\n+        case '\\r':\n+        case '\\n':\n+            while (ch.isspace())\n+                ch = this->getc();\n+            if (ch == '\\\\')\n+                return parseEscape(enclosing);\n+            else if (ch == enclosing) {\n+                this->ungetc();\n+                return ~0;\n+            } else\n+                return ch.v;\n+        default:\n+            throw ParseError::Todo(FMT(\"Unknown escape sequence \\\\\" << ch));\n+    }\n+}\n+\n+char Lexer::getc_byte() {\n+    int rv = m_istream.get();\n+    if (rv == EOF || m_istream.eof())\n+        throw Lexer::EndOfFile();\n+\n+    if (rv == '\\n') {\n+        m_line++;\n+        m_line_ofs = 0;\n+    }\n+\n+    return rv;\n+}\n+\n+Codepoint Lexer::getc() {\n+    if (m_last_char_valid) {\n+        m_last_char_valid = false;\n+#ifdef TRACE_CHARS\n+        ::std::cout << \"getc(): U+\" << ::std::hex << m_last_char.v << \" (cached)\" << ::std::endl;\n+#endif\n+    } else {\n+        m_last_char = this->getc_cp();\n+        m_line_ofs += 1;\n+#ifdef TRACE_CHARS\n+        ::std::cout << \"getc(): U+\" << ::std::hex << m_last_char.v << ::std::endl;\n+#endif\n+    }\n+\n+    return m_last_char;\n+}\n+\n+Codepoint Lexer::getc_num() {\n+    Codepoint ch;\n+\n+    do {\n+        ch = this->getc();\n+    } while (ch == '_');\n+\n+    return ch;\n+}\n+Codepoint Lexer::getc_cp() {\n+    uint8_t v1 = this->getc_byte();\n+\n+    if (v1 < 128) {\n+        return { v1 };\n+    } else if ((v1 & 0xC0) == 0x80) {\n+        // Invalid (continuation)\n+        return { 0xFFFE };\n+    } else if ((v1 & 0xE0) == 0xC0) {\n+        // Two bytes\n+        uint8_t e1 = this->getc_byte();\n+        if ((e1 & 0xC0) != 0x80)\n+            return { 0xFFFE };\n+\n+        uint32_t outval = ((v1 & 0x1F) << 6) | ((e1 & 0x3F) << 0);\n+        return { outval };\n+    } else if ((v1 & 0xF0) == 0xE0) {\n+        // Three bytes\n+        uint8_t e1 = this->getc_byte();\n+        if ((e1 & 0xC0) != 0x80)\n+            return { 0xFFFE };\n+        uint8_t e2 = this->getc_byte();\n+        if ((e2 & 0xC0) != 0x80)\n+            return { 0xFFFE };\n+\n+        uint32_t outval = ((v1 & 0x0F) << 12) | ((e1 & 0x3F) << 6) | ((e2 & 0x3F) << 0);\n+        return { outval };\n+    } else if ((v1 & 0xF8) == 0xF0) {\n+        // Four bytes\n+        uint8_t e1 = this->getc_byte();\n+        if ((e1 & 0xC0) != 0x80)\n+            return { 0xFFFE };\n+        uint8_t e2 = this->getc_byte();\n+        if ((e2 & 0xC0) != 0x80)\n+            return { 0xFFFE };\n+        uint8_t e3 = this->getc_byte();\n+        if ((e3 & 0xC0) != 0x80)\n+            return { 0xFFFE };\n+\n+        uint32_t outval = ((v1 & 0x07) << 18) | ((e1 & 0x3F) << 12) | ((e2 & 0x3F) << 6) | ((e3 & 0x3F) << 0);\n+        return { outval };\n+    } else {\n+        throw ParseError::Generic(\"Invalid UTF-8 (too long)\");\n+    }\n+}\n+\n+void Lexer::ungetc() {\n+#ifdef TRACE_CHARS\n+    ::std::cout << \"ungetc(): cache U+\" << ::std::hex << m_last_char.v << ::std::endl;\n+#endif\n+    assert(!m_last_char_valid);\n+    m_last_char_valid = true;\n+}\n+\n+// --------------------------------------------------------------------\n+// Codepoint - Unicode codepoint.\n+// --------------------------------------------------------------------\n+\n+bool Codepoint::isspace() const {\n+    switch (this->v) {\n+        case '\\t':\n+        case '\\r':\n+        case '\\n':\n+        case ' ':\n+        case 0xC: // ^L\n+        case 0x85:\n+        case 0x200E:\n+        case 0x200F: // LTR / RTL markers\n+        case 0x2028: // Line Separator\n+        case 0x2029: // Paragrah Separator\n+            return true;\n+        default:\n+            return false;\n+    }\n+}\n+\n+bool Codepoint::isdigit() const {\n+    return this->v < 128 && std::isdigit(static_cast<int>(this->v));\n+}\n+\n+bool Codepoint::isxdigit() const {\n+    return this->v < 128 && std::isxdigit(static_cast<int>(this->v));\n+}\n+\n+::std::string& operator+=(::std::string& s, const Codepoint& cp) {\n+    if (cp.v < 0x80) {\n+        s += (char)cp.v;\n+    } else if (cp.v < (0x1F + 1) << (1 * 6)) {\n+\n+        s += (char)(0xC0 | ((cp.v >> 6) & 0x1F));\n+        s += (char)(0x80 | ((cp.v >> 0) & 0x3F));\n+    } else if (cp.v < (0x0F + 1) << (2 * 6)) {\n+        s += (char)(0xE0 | ((cp.v >> 12) & 0x0F));\n+        s += (char)(0x80 | ((cp.v >> 6) & 0x3F));\n+        s += (char)(0x80 | ((cp.v >> 0) & 0x3F));\n+    } else if (cp.v < (0x07 + 1) << (3 * 6)) {\n+        s += (char)(0xF0 | ((cp.v >> 18) & 0x07));\n+        s += (char)(0x80 | ((cp.v >> 12) & 0x3F));\n+        s += (char)(0x80 | ((cp.v >> 6) & 0x3F));\n+        s += (char)(0x80 | ((cp.v >> 0) & 0x3F));\n+    } else {\n+        throw ::std::runtime_error(FMT(\"BUGCHECK: Bad unicode codepoint encountered - \" << ::std::hex << cp.v));\n+    }\n+    return s;\n+}\n+::std::ostream& operator<<(::std::ostream& os, const Codepoint& cp) {\n+    if (cp.v < 0x80) {\n+        os << (char)cp.v;\n+    } else if (cp.v < (0x1F + 1) << (1 * 6)) {\n+        os << (char)(0xC0 | ((cp.v >> 6) & 0x1F));\n+        os << (char)(0x80 | ((cp.v >> 0) & 0x3F));\n+    } else if (cp.v < (0x0F + 1) << (2 * 6)) {\n+        os << (char)(0xE0 | ((cp.v >> 12) & 0x0F));\n+        os << (char)(0x80 | ((cp.v >> 6) & 0x3F));\n+        os << (char)(0x80 | ((cp.v >> 0) & 0x3F));\n+    } else if (cp.v < (0x07 + 1) << (2 * 6)) {\n+        os << (char)(0xF0 | ((cp.v >> 18) & 0x07));\n+        os << (char)(0x80 | ((cp.v >> 12) & 0x3F));\n+        os << (char)(0x80 | ((cp.v >> 6) & 0x3F));\n+        os << (char)(0x80 | ((cp.v >> 0) & 0x3F));\n+    } else {\n+        throw ::std::runtime_error(\"BUGCHECK: Bad unicode codepoint encountered\");\n+    }\n+    return os;\n+}\n+\n+Token Lex_FindOperator(const ::std::string& s) {\n+    if (s == \"_\")\n+        return TOK_UNDERSCORE;\n+    for (size_t i = 0; i < LEN(TOKENMAP); i++) {\n+        const auto& e = TOKENMAP[i];\n+        if (s < e.chars)\n+            break;\n+        if (s == e.chars) {\n+            if (e.type < 0)\n+                break;\n+            return static_cast<eTokenType>(e.type);\n+        }\n+    }\n+    return TOK_NULL;\n+}\n+\n+Token Lex_FindReservedWord(const ::std::string& s) {\n+    for (size_t i = 0; i < LEN(RWORDS); i++) {\n+        const auto& e = RWORDS[i];\n+        if (s < e.chars)\n+            break;\n+        if (s == e.chars) {\n+            assert(e.type > 0);\n+            return static_cast<eTokenType>(e.type);\n+        }\n+    }\n+    return TOK_NULL;\n+}"}, {"sha": "7ff0003e1f570cc36a2d040c299163fb080a5b2a", "filename": "gcc/rust/mrustc_parser/parse/lex.hpp", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,80 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/lex.hpp\n+ * - Lexer header\n+ */\n+#ifndef LEX_HPP_INCLUDED\n+#define LEX_HPP_INCLUDED\n+\n+#include <string>\n+#include <fstream>\n+#include \"tokenstream.hpp\"\n+\n+struct Codepoint {\n+    uint32_t    v;\n+    Codepoint(): v(0) { }\n+    Codepoint(uint32_t v): v(v) { }\n+    bool isspace() const;\n+    bool isdigit() const;\n+    bool isxdigit() const;\n+    bool operator==(char x) { return v == static_cast<uint32_t>(x); }\n+    bool operator!=(char x) { return v != static_cast<uint32_t>(x); }\n+    bool operator==(Codepoint x) { return v == x.v; }\n+    bool operator!=(Codepoint x) { return v != x.v; }\n+};\n+extern ::std::string& operator+=(::std::string& s, const Codepoint& cp);\n+extern ::std::ostream& operator<<(::std::ostream& s, const Codepoint& cp);\n+\n+extern Token Lex_FindOperator(const ::std::string& s);\n+extern Token Lex_FindReservedWord(const ::std::string& s);\n+\n+typedef Codepoint   uchar;\n+\n+class Lexer:\n+    public TokenStream\n+{\n+    RcString    m_path;\n+    unsigned int m_line;\n+    unsigned int m_line_ofs;\n+\n+    ::std::ifstream m_istream;\n+    bool    m_last_char_valid;\n+    Codepoint   m_last_char;\n+    ::std::vector<Token>    m_next_tokens;\n+\n+    Ident::Hygiene m_hygiene;\n+public:\n+    Lexer(const ::std::string& filename);\n+\n+    Position getPosition() const override;\n+    Ident::Hygiene realGetHygiene() const override;\n+    Token realGetToken() override;\n+\n+private:\n+    Token getTokenInt();\n+\n+    signed int getSymbol();\n+    Token getTokenInt_RawString(bool is_byte);\n+    Token getTokenInt_Identifier(Codepoint ch, Codepoint ch2='\\0');\n+    double parseFloat(uint64_t whole);\n+    uint32_t parseEscape(char enclosing);\n+\n+    void push_hygine() override {\n+        m_hygiene = Ident::Hygiene::new_scope_chained(m_hygiene);\n+    }\n+    void pop_hygine() override {\n+        m_hygiene = m_hygiene.get_parent();\n+    }\n+\n+    void ungetc();\n+    Codepoint getc_num();\n+    Codepoint getc();\n+    Codepoint getc_cp();\n+    char getc_byte();\n+\n+    class EndOfFile {};\n+};\n+\n+#endif // LEX_HPP_INCLUDED"}, {"sha": "1bb309857b5b5e6293d567fdf285471c9b620263", "filename": "gcc/rust/mrustc_parser/parse/parseerror.cpp", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,91 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/parseerror.cpp\n+ * - Exceptions thrown for different types of parsing errors\n+ */\n+#include \"parseerror.hpp\"\n+#include <iostream>\n+\n+CompileError::Base::~Base() throw()\n+{\n+}\n+\n+CompileError::Generic::Generic(::std::string message):\n+    m_message(message)\n+{\n+    ::std::cout << \"Generic(\" << message << \")\" << ::std::endl;\n+}\n+CompileError::Generic::Generic(const TokenStream& lex, ::std::string message)\n+{\n+    ::std::cout << lex.point_span() << \": Generic(\" << message << \")\" << ::std::endl;\n+}\n+\n+CompileError::BugCheck::BugCheck(const TokenStream& lex, ::std::string message):\n+    m_message(message)\n+{\n+    ::std::cout << lex.point_span() << \"BugCheck(\" << message << \")\" << ::std::endl;\n+}\n+CompileError::BugCheck::BugCheck(::std::string message):\n+    m_message(message)\n+{\n+    ::std::cout << \"BugCheck(\" << message << \")\" << ::std::endl;\n+}\n+\n+CompileError::Todo::Todo(::std::string message):\n+    m_message(message)\n+{\n+    ::std::cout << \"Todo(\" << message << \")\" << ::std::endl;\n+}\n+CompileError::Todo::Todo(const TokenStream& lex, ::std::string message):\n+    m_message(message)\n+{\n+    ::std::cout << lex.point_span() << \": Todo(\" << message << \")\" << ::std::endl;\n+}\n+CompileError::Todo::~Todo() throw()\n+{\n+}\n+\n+ParseError::BadChar::BadChar(const TokenStream& lex, char character)\n+{\n+    ::std::cout << lex.point_span() << \": BadChar(\" << character << \")\" << ::std::endl;\n+}\n+ParseError::BadChar::~BadChar() throw()\n+{\n+}\n+\n+ParseError::Unexpected::Unexpected(const TokenStream& lex, const Token& tok)//:\n+//    m_tok( mv$(tok) )\n+{\n+    Span pos = tok.get_pos();\n+    if(pos.filename == \"\")\n+        pos = lex.point_span();\n+    ::std::cout << pos << \": Unexpected(\" << tok << \")\" << ::std::endl;\n+}\n+ParseError::Unexpected::Unexpected(const TokenStream& lex, const Token& tok, Token exp)//:\n+//    m_tok( mv$(tok) )\n+{\n+    Span pos = tok.get_pos();\n+    if(pos.filename == \"\")\n+        pos = lex.point_span();\n+    ::std::cout << pos << \": Unexpected(\" << tok << \", \" << exp << \")\" << ::std::endl;\n+}\n+ParseError::Unexpected::Unexpected(const TokenStream& lex, const Token& tok, ::std::vector<eTokenType> exp)\n+{\n+    Span pos = tok.get_pos();\n+    if(pos.filename == \"\")\n+        pos = lex.point_span();\n+    ::std::cout << pos << \": Unexpected \" << tok << \", expected \";\n+    bool f = true;\n+    for(auto v: exp) {\n+        if(!f)\n+            ::std::cout << \" or \";\n+        f = false;\n+        ::std::cout << Token::typestr(v);\n+    }\n+    ::std::cout << ::std::endl;\n+}\n+ParseError::Unexpected::~Unexpected() throw()\n+{\n+}"}, {"sha": "d6e2b03e3b6f6e2db7dbbfdbcd923e1a081ed1a9", "filename": "gcc/rust/mrustc_parser/parse/parseerror.hpp", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,47 @@\n+/*\n+ * MRustC - Mutabah's Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/parseerror.hpp\n+ * - Exception classes for parsing/lexing errors\n+ */\n+#ifndef PARSEERROR_HPP_INCLUDED\n+#define PARSEERROR_HPP_INCLUDED\n+\n+#include <stdexcept>\n+#include \"tokenstream.hpp\"\n+#include <compile_error.hpp>\n+\n+namespace ParseError {\n+\n+using CompileError::Generic;\n+using CompileError::BugCheck;\n+using CompileError::Todo;\n+\n+class BadChar:\n+    public CompileError::Base\n+{\n+    //char    m_char;\n+public:\n+    BadChar(const TokenStream& lex, char character);\n+    virtual ~BadChar() throw ();\n+\n+};\n+\n+class Unexpected:\n+    public CompileError::Base\n+{\n+    Token   m_tok;\n+public:\n+    Unexpected(const TokenStream& lex, const Token& tok);\n+    Unexpected(const TokenStream& lex, const Token& tok, Token exp);\n+    Unexpected(const TokenStream& lex, const Token& tok, ::std::vector<eTokenType> exp);\n+    virtual ~Unexpected() throw ();\n+\n+};\n+\n+#define ASSERT(lex, cnd)    do { if( !(cnd) ) throw CompileError::BugCheck(lex, \"Assertion failed: \" __FILE__ \" - \" #cnd); } while(0)\n+\n+}\n+\n+#endif // PARSEERROR_HPP_INCLUDED"}, {"sha": "d103840e9e9ff832557bca02eb64496f3d68cc11", "filename": "gcc/rust/mrustc_parser/parse/paths.cpp", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpaths.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpaths.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpaths.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,254 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/paths.cpp\n+ * - Parsing for module paths\n+ */\n+#include \"parseerror.hpp\"\n+#include \"common.hpp\"\n+#include \"../ast/ast.hpp\"\n+\n+AST::Path   Parse_Path(TokenStream& lex, eParsePathGenericMode generic_mode);\n+AST::Path   Parse_Path(TokenStream& lex, bool is_abs, eParsePathGenericMode generic_mode);\n+::std::vector<AST::PathNode> Parse_PathNodes(TokenStream& lex, eParsePathGenericMode generic_mode);\n+AST::PathParams Parse_Path_GenericList(TokenStream& lex);\n+\n+AST::Path Parse_Path(TokenStream& lex, eParsePathGenericMode generic_mode)\n+{\n+    TRACE_FUNCTION_F(\"generic_mode=\"<<generic_mode);\n+\n+    Token   tok;\n+    switch( GET_TOK(tok, lex) )\n+    {\n+    case TOK_INTERPOLATED_PATH:\n+        return mv$(tok.frag_path());\n+\n+    case TOK_RWORD_SELF:\n+        GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n+        return AST::Path(AST::Path::TagSelf(), Parse_PathNodes(lex, generic_mode));\n+\n+    case TOK_RWORD_SUPER: {\n+        GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n+        unsigned int count = 1;\n+        while( LOOK_AHEAD(lex) == TOK_RWORD_SUPER ) {\n+            count += 1;\n+            GET_TOK(tok, lex);\n+            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n+        }\n+        return AST::Path(AST::Path::TagSuper(), count, Parse_PathNodes(lex, generic_mode));\n+        }\n+\n+    case TOK_DOUBLE_COLON:\n+        return Parse_Path(lex, true, generic_mode);\n+\n+    case TOK_DOUBLE_LT:\n+        lex.putback( Token(TOK_LT) );\n+    case TOK_LT: {\n+        TypeRef ty = Parse_Type(lex, true);  // Allow trait objects without parens\n+        if( GET_TOK(tok, lex) == TOK_RWORD_AS ) {\n+            ::AST::Path trait;\n+            if( GET_TOK(tok, lex) == TOK_DOUBLE_COLON ) {\n+                trait = Parse_Path(lex, true, PATH_GENERIC_TYPE);\n+            }\n+            else {\n+                PUTBACK(tok, lex);\n+                trait = Parse_Path(lex, false, PATH_GENERIC_TYPE);\n+            }\n+            GET_CHECK_TOK(tok, lex, TOK_GT);\n+            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n+            return AST::Path(AST::Path::TagUfcs(), mv$(ty), mv$(trait), Parse_PathNodes(lex, generic_mode));\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+            GET_CHECK_TOK(tok, lex, TOK_GT);\n+            // TODO: Terminating the \"path\" here is sometimes valid?\n+            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n+            // NOTE: <Foo>::BAR is actually `<Foo as _>::BAR` (in mrustc parleance)\n+            //return AST::Path(AST::Path::TagUfcs(), mv$(ty), Parse_PathNodes(lex, generic_mode));\n+            return AST::Path(AST::Path::TagUfcs(), mv$(ty), AST::Path(), Parse_PathNodes(lex, generic_mode));\n+        }\n+        throw \"\"; }\n+\n+    default:\n+        PUTBACK(tok, lex);\n+        return Parse_Path(lex, false, generic_mode);\n+    }\n+}\n+AST::Path Parse_Path(TokenStream& lex, bool is_abs, eParsePathGenericMode generic_mode)\n+{\n+    Token   tok;\n+    if( is_abs )\n+    {\n+        if( GET_TOK(tok, lex) == TOK_STRING ) {\n+            ::std::string   cratename = tok.str();\n+            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n+            return AST::Path(cratename, Parse_PathNodes(lex, generic_mode));\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+            return AST::Path(\"\", Parse_PathNodes(lex, generic_mode));\n+        }\n+    }\n+    else {\n+        // TODO: TOK_INTERPOLATED_IDENT?\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        auto hygine = lex.getHygiene();\n+        PUTBACK(tok, lex);\n+        return AST::Path(AST::Path::TagRelative(), mv$(hygine), Parse_PathNodes(lex, generic_mode));\n+    }\n+}\n+\n+::std::vector<AST::PathNode> Parse_PathNodes(TokenStream& lex, eParsePathGenericMode generic_mode)\n+{\n+    TRACE_FUNCTION_F(\"generic_mode=\"<<generic_mode);\n+\n+    Token tok;\n+    ::std::vector<AST::PathNode>    ret;\n+\n+    tok = lex.getToken();\n+    while(true)\n+    {\n+        ::AST::PathParams   params;\n+\n+        CHECK_TOK(tok, TOK_IDENT);\n+        auto component = mv$( tok.str() );\n+\n+        GET_TOK(tok, lex);\n+        if( generic_mode == PATH_GENERIC_TYPE )\n+        {\n+            if( tok.type() == TOK_LT || tok.type() == TOK_DOUBLE_LT )\n+            {\n+                // HACK! Handle breaking << into < <\n+                if( tok.type() == TOK_DOUBLE_LT )\n+                    lex.putback( Token(TOK_LT) );\n+\n+                // Type-mode generics \"::path::to::Type<A,B>\"\n+                params = Parse_Path_GenericList(lex);\n+                GET_TOK(tok, lex);\n+            }\n+            // HACK - 'Fn*(...) -> ...' notation\n+            else if( tok.type() == TOK_PAREN_OPEN )\n+            {\n+                auto ps = lex.start_span();\n+                DEBUG(\"Fn() hack\");\n+                ::std::vector<TypeRef>  args;\n+                if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n+                {\n+                    // Empty list\n+                }\n+                else\n+                {\n+                    PUTBACK(tok, lex);\n+                    do {\n+                        // TODO: Trailing commas\n+                        args.push_back( Parse_Type(lex) );\n+                    } while( GET_TOK(tok, lex) == TOK_COMMA );\n+                }\n+                CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+\n+                TypeRef ret_type = TypeRef( TypeRef::TagUnit(), Span(tok.get_pos()) );\n+                if( GET_TOK(tok, lex) == TOK_THINARROW ) {\n+                    ret_type = Parse_Type(lex, false);\n+                }\n+                else {\n+                    PUTBACK(tok, lex);\n+                }\n+                DEBUG(\"- Fn(\"<<args<<\")->\"<<ret_type<<\"\");\n+\n+                // Encode into path, by converting Fn(A,B)->C into Fn<(A,B),Ret=C>\n+                params = ::AST::PathParams {\n+                    {},\n+                    ::make_vec1( TypeRef(TypeRef::TagTuple(), lex.end_span(ps), mv$(args)) ),\n+                    ::make_vec1( ::std::make_pair( ::std::string(\"Output\"), mv$(ret_type) ) )\n+                    };\n+\n+                GET_TOK(tok, lex);\n+            }\n+            else\n+            {\n+            }\n+        }\n+        if( tok.type() != TOK_DOUBLE_COLON ) {\n+            ret.push_back( AST::PathNode(component, mv$(params)) );\n+            break;\n+        }\n+        tok = lex.getToken();\n+        if( generic_mode == PATH_GENERIC_EXPR && (tok.type() == TOK_LT || tok.type() == TOK_DOUBLE_LT) )\n+        {\n+            // HACK! Handle breaking << into < <\n+            if( tok.type() == TOK_DOUBLE_LT )\n+                lex.putback( Token(TOK_LT) );\n+\n+            // Expr-mode generics \"::path::to::function::<Type1,Type2>(arg1, arg2)\"\n+            params = Parse_Path_GenericList(lex);\n+            if( GET_TOK(tok, lex) != TOK_DOUBLE_COLON ) {\n+                ret.push_back( AST::PathNode(component, mv$(params)) );\n+                // Break out of loop down to return\n+                break;\n+            }\n+            // Match with CHECK_TOK at start of loop\n+            GET_TOK(tok, lex);\n+        }\n+        ret.push_back( AST::PathNode(component, mv$(params)) );\n+    }\n+    PUTBACK(tok, lex);\n+    DEBUG(\"ret = \" << ret);\n+    return ret;\n+}\n+/// Parse a list of parameters within a path\n+::AST::PathParams Parse_Path_GenericList(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    ::std::vector<TypeRef>  types;\n+    ::std::vector<AST::LifetimeRef>   lifetimes;\n+    ::std::vector< ::std::pair< ::std::string, TypeRef > > assoc_bounds;\n+\n+    do {\n+        if( LOOK_AHEAD(lex) == TOK_GT || LOOK_AHEAD(lex) == TOK_DOUBLE_GT || LOOK_AHEAD(lex) == TOK_GTE || LOOK_AHEAD(lex) == TOK_DOUBLE_GT_EQUAL ) {\n+            GET_TOK(tok, lex);\n+            break;\n+        }\n+        switch(GET_TOK(tok, lex))\n+        {\n+        case TOK_LIFETIME:\n+            lifetimes.push_back(AST::LifetimeRef(/*lex.point_span(),*/ lex.get_ident(mv$(tok)) ));\n+            break;\n+        case TOK_IDENT:\n+            if( LOOK_AHEAD(lex) == TOK_EQUAL )\n+            {\n+                ::std::string name = mv$(tok.str());\n+                GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n+                assoc_bounds.push_back( ::std::make_pair( mv$(name), Parse_Type(lex,false) ) );\n+                break;\n+            }\n+        default:\n+            PUTBACK(tok, lex);\n+            types.push_back( Parse_Type(lex) );\n+            break;\n+        }\n+    } while( GET_TOK(tok, lex) == TOK_COMMA );\n+\n+    // HACK: Split >> into >\n+    if(tok.type() == TOK_DOUBLE_GT_EQUAL) {\n+        lex.putback(Token(TOK_GTE));\n+    }\n+    else if(tok.type() == TOK_GTE) {\n+        lex.putback(Token(TOK_EQUAL));\n+    }\n+    else if(tok.type() == TOK_DOUBLE_GT) {\n+        lex.putback(Token(TOK_GT));\n+    }\n+    else {\n+        CHECK_TOK(tok, TOK_GT);\n+    }\n+\n+    return ::AST::PathParams {\n+        mv$( lifetimes ),\n+        mv$( types ),\n+        mv$( assoc_bounds )\n+        };\n+}\n+"}, {"sha": "e2949a632ea80327447b5cfd0f19aad6436a59d0", "filename": "gcc/rust/mrustc_parser/parse/pattern.cpp", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpattern.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpattern.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpattern.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,526 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/pattern.cpp\n+ * - Parsing for patterns\n+ */\n+#include \"common.hpp\"\n+#include \"parseerror.hpp\"\n+#include <ast/expr.hpp> // To convert :expr\n+\n+// NEWNODE is needed for the Value pattern type\n+typedef ::std::unique_ptr<AST::ExprNode>    ExprNodeP;\n+#define NEWNODE(type, ...)  ExprNodeP(new type(__VA_ARGS__))\n+using AST::ExprNode;\n+\n+\n+\n+::AST::Pattern::TuplePat Parse_PatternTuple(TokenStream& lex, bool is_refutable);\n+AST::Pattern Parse_PatternReal_Slice(TokenStream& lex, bool is_refutable);\n+AST::Pattern Parse_PatternReal_Path(TokenStream& lex, ProtoSpan ps, AST::Path path, bool is_refutable);\n+AST::Pattern Parse_PatternReal(TokenStream& lex, bool is_refutable);\n+AST::Pattern Parse_PatternStruct(TokenStream& lex, ProtoSpan ps, AST::Path path, bool is_refutable);\n+\n+AST::Pattern Parse_PatternReal(TokenStream& lex, bool is_refutable);\n+AST::Pattern Parse_PatternReal1(TokenStream& lex, bool is_refutable);\n+\n+\n+/// Parse a pattern\n+///\n+/// Examples:\n+/// - `Enum::Variant(a)`\n+/// - `(1, a)`\n+/// - `1 ... 2`\n+/// - `\"string\"`\n+/// - `mut x`\n+/// - `mut x @ 1 ... 2`\n+AST::Pattern Parse_Pattern(TokenStream& lex, bool is_refutable)\n+{\n+    TRACE_FUNCTION;\n+    auto ps = lex.start_span();\n+\n+    Token   tok;\n+    tok = lex.getToken();\n+\n+    if( tok.type() == TOK_IDENT && lex.lookahead(0) == TOK_EXCLAM )\n+    {\n+        lex.getToken();\n+        return AST::Pattern( AST::Pattern::TagMacro(), lex.end_span(ps), box$(Parse_MacroInvocation(ps, tok.str(), lex)));\n+    }\n+    if( tok.type() == TOK_INTERPOLATED_PATTERN )\n+    {\n+        return mv$(tok.frag_pattern());\n+    }\n+\n+    bool expect_bind = false;\n+    auto bind_type = AST::PatternBinding::Type::MOVE;\n+    bool is_mut = false;\n+    // 1. Mutablity + Reference\n+    if( tok.type() == TOK_RWORD_REF )\n+    {\n+        expect_bind = true;\n+        tok = lex.getToken();\n+        if( tok.type() == TOK_RWORD_MUT )\n+        {\n+            bind_type = AST::PatternBinding::Type::MUTREF;\n+            GET_TOK(tok, lex);\n+        }\n+        else\n+        {\n+            bind_type = AST::PatternBinding::Type::REF;\n+        }\n+    }\n+    else if( tok.type() == TOK_RWORD_MUT )\n+    {\n+        is_mut = true;\n+        expect_bind = true;\n+        GET_TOK(tok, lex);\n+    }\n+    else\n+    {\n+        // Fall through\n+    }\n+\n+    AST::PatternBinding binding;\n+    // If a 'ref' or 'mut' annotation was seen, the next name must be a binding name\n+    if( expect_bind )\n+    {\n+        CHECK_TOK(tok, TOK_IDENT);\n+        auto bind_name = Ident(lex.getHygiene(), mv$(tok.str()));\n+        // If there's no '@' after it, it's a name binding only (_ pattern)\n+        if( GET_TOK(tok, lex) != TOK_AT )\n+        {\n+            PUTBACK(tok, lex);\n+            return AST::Pattern(AST::Pattern::TagBind(), lex.end_span(mv$(ps)), mv$(bind_name), bind_type, is_mut);\n+        }\n+        binding = AST::PatternBinding( mv$(bind_name), bind_type, is_mut );\n+\n+        // '@' consumed, move on to next token\n+        GET_TOK(tok, lex);\n+    }\n+    // Otherwise, handle MaybeBind\n+    else if( tok.type() == TOK_IDENT )\n+    {\n+        switch( LOOK_AHEAD(lex) )\n+        {\n+        // Known path `ident::`\n+        case TOK_DOUBLE_COLON:\n+            break;\n+        // Known struct `Ident {` or `Ident (`\n+        case TOK_BRACE_OPEN:\n+        case TOK_PAREN_OPEN:\n+            break;\n+        // Known value `IDENT ...`\n+        case TOK_TRIPLE_DOT:\n+            break;\n+        // Known binding `ident @`\n+        case TOK_AT:\n+            binding = AST::PatternBinding( Ident(lex.getHygiene(), mv$(tok.str())), bind_type/*MOVE*/, is_mut/*false*/ );\n+            GET_TOK(tok, lex);  // '@'\n+            GET_TOK(tok, lex);  // Match lex.putback() below\n+            break;\n+        default: {  // Maybe bind\n+            Ident   name = Ident(lex.getHygiene(), mv$(tok.str()));\n+            // if the pattern can be refuted (i.e this could be an enum variant), return MaybeBind\n+            if( is_refutable ) {\n+                assert(bind_type == ::AST::PatternBinding::Type::MOVE);\n+                assert(is_mut == false);\n+                return AST::Pattern(AST::Pattern::TagMaybeBind(), lex.end_span(mv$(ps)), mv$(name));\n+            }\n+            // Otherwise, it IS a binding\n+            else {\n+                return AST::Pattern(AST::Pattern::TagBind(), lex.end_span(mv$(ps)), mv$(name), bind_type, is_mut);\n+            }\n+            break;}\n+        }\n+    }\n+    else\n+    {\n+        // Otherwise, fall through\n+    }\n+\n+    PUTBACK(tok, lex);\n+    auto pat = Parse_PatternReal(lex, is_refutable);\n+    pat.binding() = mv$(binding);\n+    return pat;\n+}\n+\n+AST::Pattern Parse_PatternReal(TokenStream& lex, bool is_refutable)\n+{\n+    Token   tok;\n+    if( LOOK_AHEAD(lex) == TOK_INTERPOLATED_PATTERN )\n+    {\n+        GET_TOK(tok, lex);\n+        return mv$(tok.frag_pattern());\n+    }\n+    auto ps = lex.start_span();\n+    AST::Pattern    ret = Parse_PatternReal1(lex, is_refutable);\n+    if( GET_TOK(tok, lex) == TOK_TRIPLE_DOT )\n+    {\n+        if( !ret.data().is_Value() )\n+            throw ParseError::Generic(lex, \"Using '...' with a non-value on left\");\n+        auto& ret_v = ret.data().as_Value();\n+\n+        auto    right_pat = Parse_PatternReal1(lex, is_refutable);\n+        if( !right_pat.data().is_Value() )\n+            throw ParseError::Generic(lex, \"Using '...' with a non-value on right\");\n+        auto    rightval = mv$( right_pat.data().as_Value().start );\n+        ret_v.end = mv$(rightval);\n+        // TODO: use `ps` here?\n+\n+        return ret;\n+    }\n+    else\n+    {\n+        PUTBACK(tok, lex);\n+        return ret;\n+    }\n+}\n+AST::Pattern Parse_PatternReal1(TokenStream& lex, bool is_refutable)\n+{\n+    TRACE_FUNCTION;\n+    auto ps = lex.start_span();\n+\n+    Token   tok;\n+    AST::Path   path;\n+\n+    switch( GET_TOK(tok, lex) )\n+    {\n+    case TOK_UNDERSCORE:\n+        return AST::Pattern( lex.end_span(mv$(ps)), AST::Pattern::Data() );\n+    //case TOK_DOUBLE_DOT:\n+    //    return AST::Pattern( AST::Pattern::TagWildcard() );\n+    case TOK_RWORD_BOX:\n+        return AST::Pattern( AST::Pattern::TagBox(), lex.end_span(mv$(ps)), Parse_Pattern(lex, is_refutable) );\n+    case TOK_DOUBLE_AMP:\n+        lex.putback(TOK_AMP);\n+    case TOK_AMP: {\n+        DEBUG(\"Ref\");\n+        // NOTE: Falls back into \"Pattern\" not \"PatternReal\" to handle MaybeBind again\n+        bool is_mut = false;\n+        if( GET_TOK(tok, lex) == TOK_RWORD_MUT )\n+            is_mut = true;\n+        else\n+            PUTBACK(tok, lex);\n+        return AST::Pattern( AST::Pattern::TagReference(), lex.end_span(mv$(ps)), is_mut, Parse_Pattern(lex, is_refutable) );\n+        }\n+    case TOK_RWORD_SELF:\n+    case TOK_RWORD_SUPER:\n+    case TOK_IDENT:\n+    case TOK_LT:\n+    case TOK_DOUBLE_LT:\n+    case TOK_INTERPOLATED_PATH:\n+        PUTBACK(tok, lex);\n+        return Parse_PatternReal_Path( lex, ps, Parse_Path(lex, PATH_GENERIC_EXPR), is_refutable );\n+    case TOK_DOUBLE_COLON:\n+        // 2. Paths are enum/struct names\n+        return Parse_PatternReal_Path( lex, ps, Parse_Path(lex, true, PATH_GENERIC_EXPR), is_refutable );\n+    case TOK_DASH:\n+        if(GET_TOK(tok, lex) == TOK_INTEGER)\n+        {\n+            auto dt = tok.datatype();\n+            // TODO: Ensure that the type is ANY or a signed integer\n+            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({dt, -tok.intval()}) );\n+        }\n+        else if( tok.type() == TOK_FLOAT )\n+        {\n+            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Float({tok.datatype(), -tok.floatval()}) );\n+        }\n+        else\n+        {\n+            throw ParseError::Unexpected(lex, tok, {TOK_INTEGER, TOK_FLOAT});\n+        }\n+    case TOK_FLOAT:\n+        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Float({tok.datatype(), tok.floatval()}) );\n+    case TOK_INTEGER:\n+        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({tok.datatype(), tok.intval()}) );\n+    case TOK_RWORD_TRUE:\n+        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({CORETYPE_BOOL, 1}) );\n+    case TOK_RWORD_FALSE:\n+        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({CORETYPE_BOOL, 0}) );\n+    case TOK_STRING:\n+        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_String( mv$(tok.str()) ) );\n+    case TOK_BYTESTRING:\n+        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_ByteString({ mv$(tok.str()) }) );\n+    case TOK_INTERPOLATED_EXPR: {\n+        auto e = tok.take_frag_node();\n+        if( auto* n = dynamic_cast<AST::ExprNode_String*>(e.get()) ) {\n+            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_String( mv$(n->m_value) ) );\n+        }\n+        //else if( auto* n = dynamic_cast<AST::ExprNode_ByteString*>(e.get()) ) {\n+        //    return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_ByteString( mv$(n->m_value) ) );\n+        //}\n+        else if( auto* n = dynamic_cast<AST::ExprNode_Bool*>(e.get()) ) {\n+            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({CORETYPE_BOOL, n->m_value}) );\n+        }\n+        else if( auto* n = dynamic_cast<AST::ExprNode_Integer*>(e.get()) ) {\n+            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({n->m_datatype, n->m_value}) );\n+        }\n+        else if( auto* n = dynamic_cast<AST::ExprNode_Float*>(e.get()) ) {\n+            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Float({n->m_datatype, n->m_value}) );\n+        }\n+        else {\n+            TODO(lex.point_span(), \"Convert :expr into a pattern value - \" << *e);\n+        }\n+        } break;\n+\n+    case TOK_PAREN_OPEN:\n+        return AST::Pattern( AST::Pattern::TagTuple(), lex.end_span(mv$(ps)), Parse_PatternTuple(lex, is_refutable) );\n+    case TOK_SQUARE_OPEN:\n+        return Parse_PatternReal_Slice(lex, is_refutable);\n+    default:\n+        throw ParseError::Unexpected(lex, tok);\n+    }\n+}\n+AST::Pattern Parse_PatternReal_Path(TokenStream& lex, ProtoSpan ps, AST::Path path, bool is_refutable)\n+{\n+    Token   tok;\n+\n+    switch( GET_TOK(tok, lex) )\n+    {\n+    case TOK_PAREN_OPEN:\n+        return AST::Pattern( AST::Pattern::TagNamedTuple(), lex.end_span(mv$(ps)), mv$(path), Parse_PatternTuple(lex, is_refutable) );\n+    case TOK_BRACE_OPEN:\n+        return Parse_PatternStruct(lex, ps, mv$(path), is_refutable);\n+    default:\n+        PUTBACK(tok, lex);\n+        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Named(mv$(path)) );\n+    }\n+}\n+\n+AST::Pattern Parse_PatternReal_Slice(TokenStream& lex, bool is_refutable)\n+{\n+    auto ps = lex.start_span();\n+    Token   tok;\n+\n+    ::std::vector< ::AST::Pattern>  leading;\n+    ::std::vector< ::AST::Pattern>  trailing;\n+    ::AST::PatternBinding   inner_binding;\n+    bool is_split = false;\n+\n+    while(GET_TOK(tok, lex) != TOK_SQUARE_CLOSE)\n+    {\n+        bool has_binding = true;\n+        ::AST::PatternBinding  binding;\n+        if( tok.type() == TOK_RWORD_REF && lex.lookahead(0) == TOK_IDENT && lex.lookahead(1) == TOK_DOUBLE_DOT ) {\n+            GET_TOK(tok, lex);\n+            binding = ::AST::PatternBinding( lex.get_ident(mv$(tok)), ::AST::PatternBinding::Type::REF, false );\n+        }\n+        else if( tok.type() == TOK_IDENT && lex.lookahead(0) == TOK_DOUBLE_DOT) {\n+            binding = ::AST::PatternBinding( lex.get_ident(mv$(tok)), ::AST::PatternBinding::Type::MOVE, false );\n+        }\n+        else if( tok.type() == TOK_UNDERSCORE && lex.lookahead(0) == TOK_DOUBLE_DOT) {\n+            // No binding, but switching to trailing\n+        }\n+        else if( tok.type() == TOK_DOUBLE_DOT ) {\n+            // No binding, but switching to trailing\n+            PUTBACK(tok, lex);\n+        }\n+        else {\n+            has_binding = false;\n+        }\n+\n+        if( has_binding ) {\n+            if(is_split)\n+                ERROR(lex.end_span(mv$(ps)), E0000, \"Multiple instances of .. in a slice pattern\");\n+\n+            inner_binding = mv$(binding);\n+            is_split = true;\n+            GET_TOK(tok, lex);  // TOK_DOUBLE_DOT\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+            if(!is_split) {\n+                leading.push_back( Parse_Pattern(lex, is_refutable) );\n+            }\n+            else {\n+                trailing.push_back( Parse_Pattern(lex, is_refutable) );\n+            }\n+        }\n+\n+        if( GET_TOK(tok, lex) != TOK_COMMA )\n+            break;\n+    }\n+    CHECK_TOK(tok, TOK_SQUARE_CLOSE);\n+\n+    if( is_split )\n+    {\n+        return ::AST::Pattern( lex.end_span(mv$(ps)), ::AST::Pattern::Data::make_SplitSlice({ mv$(leading), mv$(inner_binding), mv$(trailing) }) );\n+    }\n+    else\n+    {\n+        assert( !inner_binding.is_valid() );\n+        assert( trailing.empty() );\n+        return ::AST::Pattern( lex.end_span(mv$(ps)), ::AST::Pattern::Data::make_Slice({ mv$(leading) }) );\n+    }\n+}\n+\n+::AST::Pattern::TuplePat Parse_PatternTuple(TokenStream& lex, bool is_refutable)\n+{\n+    TRACE_FUNCTION;\n+    auto sp = lex.start_span();\n+    Token tok;\n+\n+    ::std::vector<AST::Pattern> leading;\n+    while( LOOK_AHEAD(lex) != TOK_PAREN_CLOSE && LOOK_AHEAD(lex) != TOK_DOUBLE_DOT )\n+    {\n+        leading.push_back( Parse_Pattern(lex, is_refutable) );\n+\n+        if( GET_TOK(tok, lex) != TOK_COMMA ) {\n+            CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+            return AST::Pattern::TuplePat { mv$(leading), false, {} };\n+        }\n+    }\n+\n+    if( LOOK_AHEAD(lex) != TOK_DOUBLE_DOT )\n+    {\n+        GET_TOK(tok, lex);\n+\n+        CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+        return AST::Pattern::TuplePat { mv$(leading), false, {} };\n+    }\n+    GET_CHECK_TOK(tok, lex, TOK_DOUBLE_DOT);\n+\n+    ::std::vector<AST::Pattern> trailing;\n+    if( GET_TOK(tok, lex) == TOK_COMMA )\n+    {\n+        while( LOOK_AHEAD(lex) != TOK_PAREN_CLOSE )\n+        {\n+            trailing.push_back( Parse_Pattern(lex, is_refutable) );\n+\n+            if( GET_TOK(tok, lex) != TOK_COMMA ) {\n+                PUTBACK(tok, lex);\n+                break;\n+            }\n+        }\n+        GET_TOK(tok, lex);\n+    }\n+\n+    CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+    return ::AST::Pattern::TuplePat { mv$(leading), true, mv$(trailing) };\n+}\n+\n+AST::Pattern Parse_PatternStruct(TokenStream& lex, ProtoSpan ps, AST::Path path, bool is_refutable)\n+{\n+    TRACE_FUNCTION;\n+    Token tok;\n+\n+    // #![feature(relaxed_adts)]\n+    if( LOOK_AHEAD(lex) == TOK_INTEGER )\n+    {\n+        bool split_allowed = false;\n+        ::std::map<unsigned int, AST::Pattern> pats;\n+        while( GET_TOK(tok, lex) == TOK_INTEGER )\n+        {\n+            unsigned int ofs = static_cast<unsigned int>(tok.intval());\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            auto val = Parse_Pattern(lex, is_refutable);\n+            if( ! pats.insert( ::std::make_pair(ofs, mv$(val)) ).second ) {\n+                ERROR(lex.point_span(), E0000, \"Duplicate index\");\n+            }\n+\n+            if( GET_TOK(tok,lex) == TOK_BRACE_CLOSE )\n+                break;\n+            CHECK_TOK(tok, TOK_COMMA);\n+        }\n+        if( tok.type() == TOK_DOUBLE_DOT ) {\n+            split_allowed = true;\n+            GET_TOK(tok, lex);\n+        }\n+        CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+\n+        bool has_split = false;\n+        ::std::vector<AST::Pattern> leading;\n+        ::std::vector<AST::Pattern> trailing;\n+        unsigned int i = 0;\n+        for(auto& p : pats)\n+        {\n+            if( p.first != i ) {\n+                if( has_split || !split_allowed ) {\n+                    ERROR(lex.point_span(), E0000, \"Missing index \" << i);\n+                }\n+                has_split = true;\n+                i = p.first;\n+            }\n+            if( ! has_split ) {\n+                leading.push_back( mv$(p.second) );\n+            }\n+            else {\n+                trailing.push_back( mv$(p.second) );\n+            }\n+            i ++;\n+        }\n+\n+        return AST::Pattern(AST::Pattern::TagNamedTuple(), lex.end_span(mv$(ps)), mv$(path),  AST::Pattern::TuplePat { mv$(leading), has_split, mv$(trailing) });\n+    }\n+\n+    bool is_exhaustive = true;\n+    ::std::vector< ::std::pair< ::std::string, AST::Pattern> >  subpats;\n+    do {\n+        GET_TOK(tok, lex);\n+        DEBUG(\"tok = \" << tok);\n+        if( tok.type() == TOK_BRACE_CLOSE )\n+            break;\n+        if( tok.type() == TOK_DOUBLE_DOT ) {\n+            is_exhaustive = false;\n+            GET_TOK(tok, lex);\n+            break;\n+        }\n+\n+        auto inner_ps = lex.start_span();\n+        bool is_short_bind = false;\n+        bool is_box = false;\n+        auto bind_type = AST::PatternBinding::Type::MOVE;\n+        bool is_mut = false;\n+        if( tok.type() == TOK_RWORD_BOX ) {\n+            is_box = true;\n+            is_short_bind = true;\n+            GET_TOK(tok, lex);\n+        }\n+        if( tok.type() == TOK_RWORD_REF ) {\n+            is_short_bind = true;\n+            GET_TOK(tok, lex);\n+            if( tok.type() == TOK_RWORD_MUT ) {\n+                bind_type = AST::PatternBinding::Type::MUTREF;\n+                GET_TOK(tok, lex);\n+            }\n+            else {\n+                bind_type = AST::PatternBinding::Type::REF;\n+            }\n+        }\n+        else if( tok.type() == TOK_RWORD_MUT ) {\n+            is_mut = true;\n+            is_short_bind = true;\n+            GET_TOK(tok, lex);\n+        }\n+\n+        CHECK_TOK(tok, TOK_IDENT);\n+        auto field_ident = lex.get_ident(mv$(tok));\n+        ::std::string field_name;\n+        GET_TOK(tok, lex);\n+\n+        AST::Pattern    pat;\n+        if( is_short_bind || tok.type() != TOK_COLON ) {\n+            PUTBACK(tok, lex);\n+            pat = AST::Pattern(lex.end_span(inner_ps), {});\n+            field_name = field_ident.name;\n+            pat.set_bind(mv$(field_ident), bind_type, is_mut);\n+            if( is_box )\n+            {\n+                pat = AST::Pattern(AST::Pattern::TagBox(), lex.end_span(inner_ps), mv$(pat));\n+            }\n+        }\n+        else {\n+            CHECK_TOK(tok, TOK_COLON);\n+            field_name = mv$(field_ident.name);\n+            pat = Parse_Pattern(lex, is_refutable);\n+        }\n+\n+        subpats.push_back( ::std::make_pair(mv$(field_name), mv$(pat)) );\n+    } while( GET_TOK(tok, lex) == TOK_COMMA );\n+    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+\n+    return AST::Pattern(AST::Pattern::TagStruct(), lex.end_span(mv$(ps)), ::std::move(path), ::std::move(subpats), is_exhaustive);\n+}\n+"}, {"sha": "d799f09dfad283d7231f530e2f56806fcb7b2a94", "filename": "gcc/rust/mrustc_parser/parse/root.cpp", "status": "added", "additions": 1999, "deletions": 0, "changes": 1999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Froot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Froot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Froot.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,1999 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/root.cpp\n+ * - Parsing at the module level (highest-level parsing)\n+ *\n+ * Entrypoint:\n+ * - Parse_Crate : Handles crate attrbutes, and passes on to Parse_ModRoot\n+ * - Parse_ModRoot\n+ */\n+#include <ast/ast.hpp>\n+#include <ast/crate.hpp>\n+#include \"parseerror.hpp\"\n+#include \"common.hpp\"\n+#include <cassert>\n+#include <hir/hir.hpp>  // ABI_RUST - TODO: Move elsewhere?\n+#include <expand/cfg.hpp>   // check_cfg - for `mod nonexistant;`\n+#include <fstream>  // Used by directory path\n+#include \"lex.hpp\"  // New file lexer\n+#include <ast/expr.hpp>\n+\n+template<typename T>\n+Spanned<T> get_spanned(TokenStream& lex, ::std::function<T()> f) {\n+    auto ps = lex.start_span();\n+    auto v = f();\n+    return Spanned<T> {\n+        lex.end_span( mv$(ps) ),\n+        mv$(v)\n+        };\n+}\n+#define GET_SPANNED(type, lex, val) get_spanned< type >(lex, [&](){ return val; })\n+\n+// Check the next two tokens\n+#define LOOKAHEAD2(lex, tok1, tok2) ((lex).lookahead(0) == (tok1) && (lex).lookahead(1) == (tok2))\n+\n+::std::string dirname(::std::string input) {\n+    while( input.size() > 0 && input.back() != '/' && input.back() != '\\\\' ) {\n+        input.pop_back();\n+    }\n+    return input;\n+}\n+\n+AST::AttributeList Parse_ItemAttrs(TokenStream& lex);\n+void Parse_ParentAttrs(TokenStream& lex, AST::AttributeList& out);\n+AST::Attribute  Parse_MetaItem(TokenStream& lex);\n+void Parse_ModRoot(TokenStream& lex, AST::Module& mod, AST::AttributeList& mod_attrs);\n+bool Parse_MacroInvocation_Opt(TokenStream& lex,  AST::MacroInvocation& out_inv);\n+\n+//::AST::Path Parse_Publicity(TokenStream& lex)\n+bool Parse_Publicity(TokenStream& lex, bool allow_restricted=true)\n+{\n+    Token   tok;\n+    if( LOOK_AHEAD(lex) == TOK_RWORD_PUB )\n+    {\n+        GET_TOK(tok, lex);\n+        if( LOOK_AHEAD(lex) == TOK_PAREN_OPEN )\n+        {\n+            // HACK: tuple structs have a parsing ambiguity around `pub (self::Type,)`\n+            if( !allow_restricted )\n+            {\n+                if( lex.lookahead(1) == TOK_RWORD_IN )\n+                    ;\n+                else if( lex.lookahead(1) == TOK_RWORD_CRATE && lex.lookahead(2) == TOK_PAREN_CLOSE )\n+                    ;\n+                else if( lex.lookahead(1) == TOK_RWORD_SUPER && lex.lookahead(2) == TOK_PAREN_CLOSE )\n+                    ;\n+                else if( lex.lookahead(1) == TOK_RWORD_SELF && lex.lookahead(2) == TOK_PAREN_CLOSE )\n+                    ;\n+                else\n+                    return true;\n+            }\n+            auto    path = AST::Path(\"\", {});\n+            // Restricted publicity.\n+            GET_TOK(tok, lex);  // '('\n+\n+            switch(GET_TOK(tok, lex))\n+            {\n+            case TOK_RWORD_CRATE:\n+                // Crate visibility\n+                break;\n+            case TOK_RWORD_SELF:\n+                // Private!\n+                path = AST::Path( lex.parse_state().get_current_mod().path() );\n+                break;\n+            case TOK_RWORD_SUPER:\n+                path = AST::Path( lex.parse_state().get_current_mod().path() );\n+                path.nodes().pop_back();\n+                while( lex.lookahead(0) == TOK_DOUBLE_COLON && lex.lookahead(1) == TOK_RWORD_SUPER )\n+                {\n+                    GET_TOK(tok, lex);\n+                    GET_TOK(tok, lex);\n+                    path.nodes().pop_back();\n+                }\n+                if( lex.lookahead(0) != TOK_DOUBLE_COLON )\n+                    break;\n+                GET_TOK(tok, lex);\n+                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            case TOK_RWORD_IN:\n+                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+                path.nodes().push_back( AST::PathNode(tok.str()) );\n+                while( LOOK_AHEAD(lex) == TOK_DOUBLE_COLON )\n+                {\n+                    GET_TOK(tok, lex);\n+                    GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+                    path.nodes().push_back( AST::PathNode(tok.str()) );\n+                }\n+                break;\n+            default:\n+                throw ParseError::Unexpected(lex, tok);\n+            }\n+            GET_CHECK_TOK(tok, lex, TOK_PAREN_CLOSE);\n+        }\n+        return true;\n+    }\n+    else\n+    {\n+        return false;\n+    }\n+}\n+\n+::AST::HigherRankedBounds Parse_HRB(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    ::AST::HigherRankedBounds   rv;\n+    GET_CHECK_TOK(tok, lex, TOK_LT);\n+    do {\n+        // Support empty lists and comma-terminated lists\n+        if( lex.lookahead(0) == TOK_GT ) {\n+            GET_TOK(tok, lex);\n+            break;\n+        }\n+        auto attrs = Parse_ItemAttrs(lex);\n+\n+        switch(GET_TOK(tok, lex))\n+        {\n+        case TOK_LIFETIME:\n+            rv.m_lifetimes.push_back(::AST::LifetimeParam(lex.point_span(), ::std::move(attrs), Ident(lex.getHygiene(), tok.str())));\n+            break;\n+        default:\n+            throw ParseError::Unexpected(lex, tok, Token(TOK_LIFETIME));\n+        }\n+    } while( GET_TOK(tok, lex) == TOK_COMMA );\n+    CHECK_TOK(tok, TOK_GT);\n+    return rv;\n+}\n+::AST::HigherRankedBounds Parse_HRB_Opt(TokenStream& lex)\n+{\n+    if( lex.lookahead(0) == TOK_RWORD_FOR )\n+    {\n+        lex.getToken(); // Consume\n+        return Parse_HRB(lex);\n+    }\n+    else\n+    {\n+        return ::AST::HigherRankedBounds();\n+    }\n+}\n+\n+namespace {\n+    AST::LifetimeRef get_LifetimeRef(TokenStream& lex, Token tok)\n+    {\n+        CHECK_TOK(tok, TOK_LIFETIME);\n+        return AST::LifetimeRef(/*lex.point_span(), */Ident(lex.getHygiene(), mv$(tok.str())));\n+    }\n+}\n+/// Parse type parameters in a definition\n+void Parse_TypeBound(TokenStream& lex, AST::GenericParams& ret, TypeRef checked_type, \n+    AST::HigherRankedBounds outer_hrbs = {})\n+{\n+    TRACE_FUNCTION;\n+    Token tok;\n+\n+    do\n+    {\n+        // If an item terminator is seen (end of item, start of body, list separator), return early.\n+        //if( LOOK_AHEAD(lex) == TOK_SEMICOLON || LOOK_AHEAD(lex) == TOK_COMMA )\n+        //{\n+        //    return;\n+        //}\n+\n+        if(GET_TOK(tok, lex) == TOK_LIFETIME) {\n+            ret.add_bound(AST::GenericBound::make_TypeLifetime( {\n+                checked_type.clone(), get_LifetimeRef(lex, mv$(tok))\n+                } ));\n+        }\n+        else if( tok.type() == TOK_QMARK ) {\n+            auto hrbs = Parse_HRB_Opt(lex);\n+            (void)hrbs; // The only valid ?Trait is Sized, which doesn't have any generics\n+            ret.add_bound(AST::GenericBound::make_MaybeTrait( {\n+                checked_type.clone(), Parse_Path(lex, PATH_GENERIC_TYPE)\n+                } ));\n+        }\n+        else {\n+            ::AST::HigherRankedBounds inner_hrls;\n+            if( tok.type() == TOK_RWORD_FOR )\n+            {\n+                inner_hrls = Parse_HRB(lex);\n+            }\n+            else {\n+                PUTBACK(tok, lex);\n+            }\n+            auto trait_path = Parse_Path(lex, PATH_GENERIC_TYPE);\n+\n+            auto this_outer_hrbs = (lex.lookahead(0) == TOK_PLUS ? \n+                AST::HigherRankedBounds(outer_hrbs) : mv$(outer_hrbs));\n+            ret.add_bound( AST::GenericBound::make_IsTrait({\n+                mv$(this_outer_hrbs), checked_type.clone(), mv$(inner_hrls), mv$(trait_path)\n+                }) );\n+        }\n+    } while( GET_TOK(tok, lex) == TOK_PLUS );\n+    PUTBACK(tok, lex);\n+}\n+\n+/// Parse type parameters within '<' and '>' (definition)\n+AST::GenericParams Parse_GenericParams(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+\n+    AST::GenericParams ret;\n+    Token tok;\n+    do {\n+        if( GET_TOK(tok, lex) == TOK_GT ) {\n+            break ;\n+        }\n+\n+        PUTBACK(tok, lex);\n+        auto attrs = Parse_ItemAttrs(lex);\n+\n+        GET_TOK(tok, lex);\n+        if( tok.type() == TOK_IDENT )\n+        {\n+            ::std::string param_name = mv$(tok.str());\n+            ret.add_ty_param( AST::TypeParam( lex.point_span(), ::std::move(attrs), param_name ) );\n+\n+            auto param_ty = TypeRef(lex.point_span(), param_name);\n+            if( GET_TOK(tok, lex) == TOK_COLON )\n+            {\n+                Parse_TypeBound(lex, ret, mv$(param_ty));\n+                GET_TOK(tok, lex);\n+            }\n+\n+            if( tok.type() == TOK_EQUAL )\n+            {\n+                ret.ty_params().back().setDefault( Parse_Type(lex) );\n+                GET_TOK(tok, lex);\n+            }\n+        }\n+        else if( tok.type() == TOK_LIFETIME )\n+        {\n+            auto param_name = tok.str();\n+            auto ref = get_LifetimeRef(lex, mv$(tok));\n+            ret.add_lft_param(::AST::LifetimeParam(lex.point_span(), ::std::move(attrs), \n+                Ident(lex.getHygiene(), param_name) ));\n+            if( GET_TOK(tok, lex) == TOK_COLON )\n+            {\n+                do {\n+                    GET_CHECK_TOK(tok, lex, TOK_LIFETIME);\n+                    ret.add_bound(AST::GenericBound::make_Lifetime({ AST::LifetimeRef(ref), \n+                        get_LifetimeRef(lex, mv$(tok)) }));\n+                } while( GET_TOK(tok, lex) == TOK_PLUS );\n+            }\n+        }\n+        else\n+        {\n+            throw ParseError::Unexpected(lex, tok, {TOK_IDENT, TOK_LIFETIME});\n+        }\n+    } while( tok.type() == TOK_COMMA );\n+    PUTBACK(tok, lex);\n+    return ret;\n+}\n+\n+\n+/// Parse the contents of a 'where' clause\n+void Parse_WhereClause(TokenStream& lex, AST::GenericParams& params)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    do {\n+        GET_TOK(tok, lex);\n+        if( tok.type() == TOK_BRACE_OPEN ) {\n+            break;\n+        }\n+\n+        if( tok.type() == TOK_LIFETIME )\n+        {\n+            auto lhs = get_LifetimeRef(lex, mv$(tok));\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            do {\n+                GET_CHECK_TOK(tok, lex, TOK_LIFETIME);\n+                auto rhs = get_LifetimeRef(lex, mv$(tok));\n+                params.add_bound( AST::GenericBound::make_Lifetime({lhs, rhs}) );\n+            } while( GET_TOK(tok, lex) == TOK_PLUS );\n+            PUTBACK(tok, lex);\n+        }\n+        // Higher-ranked types/lifetimes\n+        else if( tok.type() == TOK_RWORD_FOR )\n+        {\n+            auto hrbs = Parse_HRB(lex);\n+\n+            TypeRef type = Parse_Type(lex);\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            Parse_TypeBound(lex,params, mv$(type), mv$(hrbs));\n+        }\n+        else\n+        {\n+            PUTBACK(tok, lex);\n+            TypeRef type = Parse_Type(lex);\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            Parse_TypeBound(lex, params, mv$(type));\n+        }\n+    } while( GET_TOK(tok, lex) == TOK_COMMA );\n+    PUTBACK(tok, lex);\n+}\n+\n+// Parse a single function argument\n+::std::pair< AST::Pattern, TypeRef> Parse_Function_Arg(TokenStream& lex, bool expect_named)\n+{\n+    TRACE_FUNCTION_F(\"expect_named = \" << expect_named);\n+    Token   tok;\n+\n+    AST::Pattern pat;\n+\n+    // If any of the following\n+    // - Expecting a named parameter (i.e. defining a function in root or impl)\n+    // - Next token is an underscore (only valid as a pattern here)\n+    // - Next token is 'mut' (a mutable parameter slot)\n+    // - Next two are <ident> ':' (a trivial named parameter)\n+    // NOTE: When not expecting a named param, destructuring patterns are not allowed\n+    if( expect_named\n+      || LOOK_AHEAD(lex) == TOK_UNDERSCORE\n+      || LOOK_AHEAD(lex) == TOK_RWORD_MUT\n+      || (LOOK_AHEAD(lex) == TOK_IDENT && lex.lookahead(1) == TOK_COLON)\n+      )\n+    {\n+        // Function args can't be refuted\n+        pat = Parse_Pattern(lex, false);\n+        GET_CHECK_TOK(tok, lex, TOK_COLON);\n+    }\n+\n+    TypeRef type = Parse_Type(lex);\n+\n+\n+    return ::std::make_pair( ::std::move(pat), ::std::move(type) );\n+}\n+\n+/// Parse a function definition (after the 'fn <name>')\n+AST::Function Parse_FunctionDef(TokenStream& lex, ::std::string abi, bool allow_self, \n+    bool can_be_prototype,  bool is_unsafe, bool is_const)\n+{\n+    TRACE_FUNCTION;\n+    ProtoSpan   ps = lex.start_span();\n+\n+    Token   tok;\n+\n+    // Parameters\n+    AST::GenericParams params;\n+    if( GET_TOK(tok, lex) == TOK_LT )\n+    {\n+        params = Parse_GenericParams(lex);\n+        GET_CHECK_TOK(tok, lex, TOK_GT);\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+\n+    AST::Function::Arglist  args;\n+\n+    GET_CHECK_TOK(tok, lex, TOK_PAREN_OPEN);\n+    GET_TOK(tok, lex);\n+\n+    // Handle self\n+    if( tok.type() == TOK_AMP )\n+    {\n+        // By-reference method?\n+\n+        unsigned int ofs = 0;\n+        // Handle a lifetime parameter name\n+        if( lex.lookahead(0) == TOK_LIFETIME )\n+            ofs ++;\n+\n+        if( lex.lookahead(ofs) == TOK_RWORD_SELF || (lex.lookahead(ofs) == TOK_RWORD_MUT \n+            && lex.lookahead(ofs+1) == TOK_RWORD_SELF) )\n+        {\n+            auto ps = lex.start_span();\n+            AST::LifetimeRef lifetime;\n+            if( GET_TOK(tok, lex) == TOK_LIFETIME ) {\n+                lifetime = get_LifetimeRef(lex, mv$(tok));\n+                GET_TOK(tok, lex);\n+            }\n+\n+            bool is_mut = false;\n+            if( tok.type() == TOK_RWORD_MUT )\n+            {\n+                is_mut = true;\n+                GET_TOK(tok, lex);\n+            }\n+            CHECK_TOK(tok, TOK_RWORD_SELF);\n+            auto sp = lex.end_span(ps);\n+            args.push_back( ::std::make_pair( AST::Pattern(AST::Pattern::TagBind(), sp, \"self\"), \n+                TypeRef(TypeRef::TagReference(), sp, ::std::move(lifetime), is_mut, \n+                TypeRef(sp, \"Self\", 0xFFFF))) );\n+            if( allow_self == false )\n+                throw ParseError::Generic(lex, \"Self binding not expected\");\n+\n+            // Prime tok for next step\n+            GET_TOK(tok, lex);\n+        }\n+        else\n+        {\n+            // Unbound method\n+        }\n+    }\n+    else if( tok.type() == TOK_RWORD_MUT )\n+    {\n+        if( LOOK_AHEAD(lex) == TOK_RWORD_SELF )\n+        {\n+            GET_TOK(tok, lex);\n+            if( allow_self == false )\n+                throw ParseError::Generic(lex, \"Self binding not expected\");\n+            auto binding_sp = lex.end_span(ps);\n+            TypeRef ty = TypeRef( lex.point_span(), \"Self\", 0xFFFF );\n+            if( GET_TOK(tok, lex) == TOK_COLON ) {\n+                // Typed mut self\n+                ty = Parse_Type(lex);\n+            }\n+            else {\n+                PUTBACK(tok, lex);\n+            }\n+            args.push_back( ::std::make_pair( AST::Pattern(AST::Pattern::TagBind(), binding_sp, \n+                \"self\"), mv$(ty)) );\n+            GET_TOK(tok, lex);\n+        }\n+    }\n+    else if( tok.type() == TOK_RWORD_SELF )\n+    {\n+        // By-value method\n+        if( allow_self == false )\n+            throw ParseError::Generic(lex, \"Self binding not expected\");\n+        auto binding_sp = lex.end_span(ps);\n+        TypeRef ty = TypeRef( lex.point_span(), \"Self\", 0xFFFF );\n+        if( GET_TOK(tok, lex) == TOK_COLON ) {\n+            // Typed mut self\n+            ty = Parse_Type(lex);\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+        }\n+        args.push_back( ::std::make_pair( AST::Pattern(AST::Pattern::TagBind(), binding_sp, \"self\"), \n+            mv$(ty)) );\n+        GET_TOK(tok, lex);\n+    }\n+    else\n+    {\n+        // Unbound method\n+    }\n+\n+    bool    is_variadic = false;\n+    if( tok.type() != TOK_PAREN_CLOSE )\n+    {\n+        // Comma after self\n+        if( args.size() )\n+        {\n+            CHECK_TOK(tok, TOK_COMMA);\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+        }\n+\n+        // Argument list\n+        do {\n+            if( LOOK_AHEAD(lex) == TOK_PAREN_CLOSE ) {\n+                GET_TOK(tok, lex);\n+                break;\n+            }\n+            if( LOOK_AHEAD(lex) == TOK_TRIPLE_DOT ) {\n+                GET_TOK(tok, lex);\n+                is_variadic = true;\n+                GET_TOK(tok, lex);\n+                break;\n+            }\n+            args.push_back( Parse_Function_Arg(lex, !can_be_prototype) );\n+        } while( GET_TOK(tok, lex) == TOK_COMMA );\n+        CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+    }\n+    else {\n+        // Eat 'tok', negative comparison\n+    }\n+\n+    TypeRef ret_type = TypeRef(TypeRef::TagUnit(), Span(tok.get_pos()));\n+    if( GET_TOK(tok, lex) == TOK_THINARROW )\n+    {\n+        // Return type\n+        ret_type = Parse_Type(lex);\n+    }\n+    else\n+    {\n+        PUTBACK(tok, lex);\n+    }\n+\n+    if( GET_TOK(tok, lex) == TOK_RWORD_WHERE )\n+    {\n+        Parse_WhereClause(lex, params);\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+\n+    return AST::Function(lex.end_span( mv$(ps) ), mv$(params), mv$(abi), is_unsafe, is_const, \n+        is_variadic, mv$(ret_type), mv$(args));\n+}\n+\n+AST::Function Parse_FunctionDefWithCode(TokenStream& lex, ::std::string abi, bool allow_self, \n+    bool is_unsafe, bool is_const)\n+{\n+    Token   tok;\n+    auto ret = Parse_FunctionDef(lex, abi, allow_self, false,  is_unsafe, is_const);\n+    GET_CHECK_TOK(tok, lex, TOK_BRACE_OPEN);\n+    // Enter a new hygine scope for the function (TODO: Should this be in Parse_ExprBlock?)\n+    lex.push_hygine();\n+    PUTBACK(tok, lex);\n+    ret.set_code( Parse_ExprBlock(lex) );\n+    lex.pop_hygine();\n+    return ret;\n+}\n+\n+AST::TypeAlias Parse_TypeAlias(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+\n+    Token   tok;\n+\n+    // Params\n+    AST::GenericParams params;\n+    if( GET_TOK(tok, lex) == TOK_LT )\n+    {\n+        params = Parse_GenericParams(lex);\n+        GET_CHECK_TOK(tok, lex, TOK_GT);\n+        GET_TOK(tok, lex);\n+    }\n+\n+    if( tok.type() == TOK_RWORD_WHERE )\n+    {\n+        Parse_WhereClause(lex, params);\n+        GET_TOK(tok, lex);\n+    }\n+    CHECK_TOK(tok, TOK_EQUAL);\n+\n+    // Type\n+    TypeRef type = Parse_Type(lex);\n+    GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+\n+    return AST::TypeAlias( ::std::move(params), ::std::move(type) );\n+}\n+\n+AST::Struct Parse_Struct(TokenStream& lex, const AST::AttributeList& meta_items)\n+{\n+    TRACE_FUNCTION;\n+\n+    Token   tok;\n+\n+    tok = lex.getToken();\n+    AST::GenericParams params;\n+    if( tok.type() == TOK_LT )\n+    {\n+        params = Parse_GenericParams(lex);\n+        GET_CHECK_TOK(tok, lex, TOK_GT);\n+        if(GET_TOK(tok, lex) == TOK_RWORD_WHERE)\n+        {\n+            Parse_WhereClause(lex, params);\n+            tok = lex.getToken();\n+        }\n+    }\n+    if(tok.type() == TOK_PAREN_OPEN)\n+    {\n+        // Tuple structs\n+        ::std::vector<AST::TupleItem>  refs;\n+        while(lex.lookahead(0) != TOK_PAREN_CLOSE)\n+        {\n+            auto item_attrs = Parse_ItemAttrs(lex);\n+            SET_ATTRS(lex, item_attrs);\n+\n+            bool    is_pub = Parse_Publicity(lex, /*allow_restricted=*/false);  // HACK: Disable `pub(restricted)` syntax in tuple structs, due to ambiguity\n+\n+            refs.push_back( AST::TupleItem( mv$(item_attrs), is_pub, Parse_Type(lex) ) );\n+            if( GET_TOK(tok, lex) != TOK_COMMA ) {\n+                PUTBACK(tok, lex);\n+                break;\n+            }\n+        }\n+        GET_CHECK_TOK(tok, lex, TOK_PAREN_CLOSE);\n+\n+        if(LOOK_AHEAD(lex) == TOK_RWORD_WHERE)\n+        {\n+            GET_TOK(tok, lex);\n+            Parse_WhereClause(lex, params);\n+        }\n+        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+        //if( refs.size() == 0 )\n+        //    WARNING( , W000, \"Use 'struct Name;' instead of 'struct Name();' ... ning-nong\");\n+        return AST::Struct(mv$(params), mv$(refs));\n+    }\n+    else if(tok.type() == TOK_SEMICOLON)\n+    {\n+        // Unit-like struct\n+        return AST::Struct(mv$(params));\n+    }\n+    else if(tok.type() == TOK_BRACE_OPEN)\n+    {\n+        ::std::vector<AST::StructItem>  items;\n+        while( GET_TOK(tok, lex) != TOK_BRACE_CLOSE )\n+        {\n+            PUTBACK(tok, lex);\n+\n+            auto item_attrs = Parse_ItemAttrs(lex);\n+            SET_ATTRS(lex, item_attrs);\n+\n+            bool is_pub = Parse_Publicity(lex);\n+\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            auto name = mv$(tok.str());\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            TypeRef type = Parse_Type(lex);\n+\n+            items.push_back( AST::StructItem( mv$(item_attrs), is_pub, mv$(name), mv$(type) ) );\n+            if(GET_TOK(tok, lex) == TOK_BRACE_CLOSE)\n+                break;\n+            CHECK_TOK(tok, TOK_COMMA);\n+        }\n+        //if( items.size() == 0 )\n+        //    WARNING( , W000, \"Use 'struct Name;' instead of 'struct Nam { };' ... ning-nong\");\n+        return AST::Struct(mv$(params), mv$(items));\n+    }\n+    else\n+    {\n+        throw ParseError::Unexpected(lex, tok);\n+    }\n+}\n+\n+AST::Trait Parse_TraitDef(TokenStream& lex, const AST::AttributeList& meta_items)\n+{\n+    TRACE_FUNCTION;\n+\n+    Token   tok;\n+\n+    AST::GenericParams params;\n+    if( GET_TOK(tok, lex) == TOK_LT )\n+    {\n+        params = Parse_GenericParams(lex);\n+        GET_CHECK_TOK(tok, lex, TOK_GT);\n+        tok = lex.getToken();\n+    }\n+\n+    // Trait bounds \"trait Trait : 'lifetime + OtherTrait + OtherTrait2\"\n+    ::std::vector<Spanned<Type_TraitPath> >    supertraits;\n+    if(tok.type() == TOK_COLON)\n+    {\n+        // TODO: Just add these as `where Self: <foo>` (would that break typecheck?)\n+        do {\n+            if( GET_TOK(tok, lex) == TOK_LIFETIME ) {\n+                // TODO: Need a better way of indiciating 'static than just an invalid path\n+                ASSERT_BUG(lex.point_span(), tok.str() == \"static\", \n+                    \"TODO: Support lifetimes other than 'static in trait bounds\");\n+                supertraits.push_back( make_spanned( Span(tok.get_pos()), Type_TraitPath{ {}, \n+                    AST::Path() } ) );\n+            }\n+            else if( tok.type() == TOK_BRACE_OPEN ) {\n+                break;\n+            }\n+            else {\n+                PUTBACK(tok, lex);\n+                auto hrbs = Parse_HRB_Opt(lex);\n+                supertraits.push_back( GET_SPANNED(Type_TraitPath, lex, (Type_TraitPath{ mv$(hrbs), \n+                    Parse_Path(lex, PATH_GENERIC_TYPE) })) );\n+            }\n+        } while( GET_TOK(tok, lex) == TOK_PLUS );\n+    }\n+\n+    if(tok.type() == TOK_RWORD_WHERE)\n+    {\n+        //if( params.ty_params().size() == 0 )\n+        //    throw ParseError::Generic(\"Where clause with no generic params\");\n+        Parse_WhereClause(lex, params);\n+        tok = lex.getToken();\n+    }\n+\n+\n+    AST::Trait trait( mv$(params), mv$(supertraits) );\n+\n+    CHECK_TOK(tok, TOK_BRACE_OPEN);\n+    while( GET_TOK(tok, lex) != TOK_BRACE_CLOSE )\n+    {\n+        PUTBACK(tok, lex);\n+\n+        auto item_attrs = Parse_ItemAttrs(lex);\n+        SET_ATTRS(lex, item_attrs);\n+\n+        auto ps = lex.start_span();\n+        {\n+            ::AST::MacroInvocation  inv;\n+            if( Parse_MacroInvocation_Opt(lex, inv) )\n+            {\n+                trait.items().push_back( AST::Named<AST::Item>(\"\", AST::Item(mv$(inv)), false) );\n+                continue ;\n+            }\n+            GET_TOK(tok, lex);\n+        }\n+\n+        bool is_specialisable = false;\n+        if( tok.type() == TOK_IDENT && tok.str() == \"default\" ) {\n+            is_specialisable = true;\n+            GET_TOK(tok, lex);\n+        }\n+        // TODO: Mark specialisation\n+        (void)is_specialisable;\n+\n+        bool fn_is_const = false;\n+        bool fn_is_unsafe = false;\n+        ::std::string   abi = ABI_RUST;\n+        switch(tok.type())\n+        {\n+        case TOK_RWORD_STATIC: {\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            auto name = mv$(tok.str());\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            auto ty = Parse_Type(lex);\n+            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+\n+            ::AST::Expr val;\n+            if(GET_TOK(tok, lex) == TOK_EQUAL) {\n+                val = Parse_Expr(lex);\n+                GET_TOK(tok, lex);\n+            }\n+            CHECK_TOK(tok, TOK_SEMICOLON);\n+\n+            trait.add_static( mv$(name), mv$(item_attrs), ::AST::Static(AST::Static::STATIC, mv$(ty), \n+                val) );\n+            break; }\n+        case TOK_RWORD_CONST: {\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            auto name = mv$(tok.str());\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            auto ty = Parse_Type(lex);\n+\n+            ::AST::Expr val;\n+            if(GET_TOK(tok, lex) == TOK_EQUAL) {\n+                val = Parse_Expr(lex);\n+                GET_TOK(tok, lex);\n+            }\n+            CHECK_TOK(tok, TOK_SEMICOLON);\n+\n+            trait.add_static( mv$(name), mv$(item_attrs), ::AST::Static(AST::Static::CONST, mv$(ty), \n+                val) );\n+            break; }\n+        // Associated type\n+        case TOK_RWORD_TYPE: {\n+            auto atype_params = ::AST::GenericParams { };\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            auto name = mv$(tok.str());\n+            if( GET_TOK(tok, lex) == TOK_COLON )\n+            {\n+                // Bounded associated type\n+                Parse_TypeBound(lex, atype_params, TypeRef(lex.point_span(), \"Self\", 0xFFFF));\n+                GET_TOK(tok, lex);\n+            }\n+            if( tok.type() == TOK_RWORD_WHERE ) {\n+                throw ParseError::Todo(lex, \"Where clause on associated type\");\n+            }\n+\n+            TypeRef default_type = TypeRef( lex.point_span() );\n+            if( tok.type() == TOK_EQUAL ) {\n+                default_type = Parse_Type(lex);\n+                GET_TOK(tok, lex);\n+            }\n+\n+            CHECK_TOK(tok, TOK_SEMICOLON);\n+            trait.add_type( ::std::move(name), mv$(item_attrs), ::std::move(default_type) );\n+            trait.items().back().data.as_Type().params() = mv$(atype_params);\n+            break; }\n+\n+        // Functions (possibly unsafe)\n+        case TOK_RWORD_UNSAFE:\n+            fn_is_unsafe = true;\n+            if( GET_TOK(tok, lex) == TOK_RWORD_EXTERN )\n+        case TOK_RWORD_EXTERN:\n+            {\n+                abi = \"C\";\n+                if( GET_TOK(tok, lex) == TOK_STRING )\n+                    abi = tok.str();\n+                else\n+                    PUTBACK(tok, lex);\n+\n+                GET_TOK(tok, lex);\n+            }\n+            CHECK_TOK(tok, TOK_RWORD_FN);\n+        case TOK_RWORD_FN: {\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            ::std::string name = mv$(tok.str());\n+            // Self allowed, prototype-form allowed (optional names and no code)\n+            auto fcn = Parse_FunctionDef(lex, abi, true, true,  fn_is_unsafe, fn_is_const);\n+            if( GET_TOK(tok, lex) == TOK_BRACE_OPEN )\n+            {\n+                PUTBACK(tok, lex);\n+                // Enter a new hygine scope for the function body. (TODO: Should this be in Parse_ExprBlock?)\n+                lex.push_hygine();\n+                fcn.set_code( Parse_ExprBlock(lex) );\n+                lex.pop_hygine();\n+            }\n+            else if( tok.type() == TOK_SEMICOLON )\n+            {\n+                // Accept it\n+            }\n+            else\n+            {\n+                throw ParseError::Unexpected(lex, tok);\n+            }\n+            trait.add_function( ::std::move(name), mv$(item_attrs), ::std::move(fcn) );\n+            break; }\n+        default:\n+            throw ParseError::Unexpected(lex, tok);\n+        }\n+    }\n+\n+    return trait;\n+}\n+\n+AST::Enum Parse_EnumDef(TokenStream& lex, const AST::AttributeList& meta_items)\n+{\n+    TRACE_FUNCTION;\n+\n+    Token   tok;\n+\n+    tok = lex.getToken();\n+    // Type params supporting \"where\"\n+    AST::GenericParams params;\n+    if( tok.type() == TOK_LT )\n+    {\n+        params = Parse_GenericParams(lex);\n+        GET_CHECK_TOK(tok, lex, TOK_GT);\n+        if(GET_TOK(tok, lex) == TOK_RWORD_WHERE)\n+        {\n+            Parse_WhereClause(lex, params);\n+            tok = lex.getToken();\n+        }\n+    }\n+\n+    // Body\n+    CHECK_TOK(tok, TOK_BRACE_OPEN);\n+    ::std::vector<AST::EnumVariant>   variants;\n+    while( GET_TOK(tok, lex) != TOK_BRACE_CLOSE )\n+    {\n+        auto sp = lex.start_span();\n+        PUTBACK(tok, lex);\n+\n+        auto item_attrs = Parse_ItemAttrs(lex);\n+        SET_ATTRS(lex, item_attrs);\n+\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        ::std::string   name = mv$(tok.str());\n+        // Tuple-like variants\n+        if( GET_TOK(tok, lex) == TOK_PAREN_OPEN )\n+        {\n+            ::std::vector<TypeRef>  types;\n+            // Get type list\n+            do\n+            {\n+                if(LOOK_AHEAD(lex) == TOK_PAREN_CLOSE)\n+                {\n+                    GET_TOK(tok, lex);\n+                    break;\n+                }\n+\n+                auto field_attrs = Parse_ItemAttrs(lex);\n+                (void)field_attrs;  // TODO: Store field_attrs\n+\n+                types.push_back( Parse_Type(lex) );\n+            } while( GET_TOK(tok, lex) == TOK_COMMA );\n+            CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+            GET_TOK(tok, lex);\n+            variants.push_back( AST::EnumVariant(mv$(item_attrs), mv$(name), mv$(types)) );\n+        }\n+        // Struct-like variants\n+        else if( tok.type() == TOK_BRACE_OPEN )\n+        {\n+            ::std::vector<::AST::StructItem>   fields;\n+            do\n+            {\n+                if(LOOK_AHEAD(lex) == TOK_BRACE_CLOSE)\n+                {\n+                    GET_TOK(tok, lex);\n+                    break;\n+                }\n+\n+                auto field_attrs = Parse_ItemAttrs(lex);\n+\n+                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+                auto name = mv$(tok.str());\n+                GET_CHECK_TOK(tok, lex, TOK_COLON);\n+                auto ty = Parse_Type(lex);\n+                fields.push_back( ::AST::StructItem(mv$(field_attrs), true, mv$(name), mv$(ty)) );\n+            } while( GET_TOK(tok, lex) == TOK_COMMA );\n+            CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+            GET_TOK(tok, lex);\n+\n+            variants.push_back( AST::EnumVariant(mv$(item_attrs), mv$(name), mv$(fields)) );\n+        }\n+        // Value variants\n+        else if( tok.type() == TOK_EQUAL )\n+        {\n+            auto node = Parse_Expr(lex);\n+            variants.push_back( AST::EnumVariant(mv$(item_attrs), mv$(name), mv$(node)) );\n+            GET_TOK(tok, lex);\n+        }\n+        // Unit variants\n+        else\n+        {\n+            variants.push_back( AST::EnumVariant(mv$(item_attrs), mv$(name), ::AST::Expr()) );\n+        }\n+\n+        if( tok.type() != TOK_COMMA )\n+            break;\n+    }\n+    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+\n+\n+    return AST::Enum( mv$(params), mv$(variants) );\n+}\n+\n+::AST::Union Parse_Union(TokenStream& lex, AST::AttributeList& meta_items)\n+{\n+    Token   tok;\n+\n+    TRACE_FUNCTION;\n+\n+    AST::GenericParams params;\n+    if( GET_TOK(tok, lex) == TOK_LT )\n+    {\n+        params = Parse_GenericParams(lex);\n+        GET_CHECK_TOK(tok, lex, TOK_GT);\n+        if(GET_TOK(tok, lex) == TOK_RWORD_WHERE)\n+        {\n+            Parse_WhereClause(lex, params);\n+            tok = lex.getToken();\n+        }\n+    }\n+\n+    ::std::vector< ::AST::StructItem>   variants;\n+\n+    CHECK_TOK(tok, TOK_BRACE_OPEN);\n+    do {\n+        if( LOOK_AHEAD(lex) == TOK_BRACE_CLOSE ) {\n+            GET_TOK(tok, lex);\n+            break ;\n+        }\n+\n+        auto item_attrs = Parse_ItemAttrs(lex);\n+        SET_ATTRS(lex, item_attrs);\n+\n+        bool is_pub = Parse_Publicity(lex);\n+\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        auto name = mv$(tok.str());\n+        GET_CHECK_TOK(tok, lex, TOK_COLON);\n+\n+        auto ty = Parse_Type(lex);\n+\n+        variants.push_back( ::AST::StructItem( mv$(item_attrs), is_pub, mv$(name), mv$(ty) ) );\n+\n+    } while( GET_TOK(tok, lex) == TOK_COMMA );\n+    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n+\n+    return ::AST::Union( mv$(params), mv$(variants) );\n+}\n+\n+AST::AttributeList Parse_ItemAttrs(TokenStream& lex)\n+{\n+    AST::AttributeList  rv;\n+    Token   tok;\n+    while( lex.lookahead(0) == TOK_HASH )\n+    {\n+        GET_CHECK_TOK(tok, lex, TOK_HASH);\n+        GET_CHECK_TOK(tok, lex, TOK_SQUARE_OPEN);\n+        rv.push_back( Parse_MetaItem(lex) );\n+        GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n+    }\n+    return rv;\n+}\n+void Parse_ParentAttrs(TokenStream& lex, AST::AttributeList& out)\n+{\n+    Token   tok;\n+    while( lex.lookahead(0) == TOK_HASH && lex.lookahead(1) == TOK_EXCLAM )\n+    {\n+        GET_CHECK_TOK(tok, lex, TOK_HASH);\n+        GET_CHECK_TOK(tok, lex, TOK_EXCLAM);\n+        GET_CHECK_TOK(tok, lex, TOK_SQUARE_OPEN);\n+        out.push_back( Parse_MetaItem(lex) );\n+        GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n+    }\n+}\n+/// Parse a meta-item declaration (either #![ or #[)\n+AST::Attribute Parse_MetaItem(TokenStream& lex)\n+{\n+    TRACE_FUNCTION;\n+    Token tok;\n+    GET_TOK(tok, lex);\n+\n+    if( tok.type() == TOK_INTERPOLATED_META ) {\n+        return mv$(tok.frag_meta());\n+    }\n+\n+    auto ps = lex.start_span();\n+    CHECK_TOK(tok, TOK_IDENT);\n+    ::std::string   name = mv$(tok.str());\n+    switch(GET_TOK(tok, lex))\n+    {\n+    case TOK_EQUAL:\n+        switch(GET_TOK(tok, lex))\n+        {\n+        case TOK_STRING:\n+            return AST::Attribute(lex.end_span(mv$(ps)), name, tok.str());\n+        case TOK_INTERPOLATED_EXPR: {\n+            auto n = tok.take_frag_node();\n+            if( auto* v = dynamic_cast<::AST::ExprNode_String*>(&*n) )\n+            {\n+                return AST::Attribute(lex.end_span(mv$(ps)), name, mv$(v->m_value));\n+            }\n+            else\n+            {\n+                // - Force an error.\n+                CHECK_TOK(tok, TOK_STRING);\n+            }\n+            break; }\n+        default:\n+            // - Force an error.\n+            CHECK_TOK(tok, TOK_STRING);\n+        }\n+        throw \"\";\n+    case TOK_PAREN_OPEN: {\n+        ::std::vector<AST::Attribute>    items;\n+        do {\n+            if(LOOK_AHEAD(lex) == TOK_PAREN_CLOSE) {\n+                GET_TOK(tok, lex);\n+                break;\n+            }\n+            items.push_back(Parse_MetaItem(lex));\n+        } while(GET_TOK(tok, lex) == TOK_COMMA);\n+        CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+        return AST::Attribute(lex.end_span(mv$(ps)), name, mv$(items)); }\n+    default:\n+        PUTBACK(tok, lex);\n+        return AST::Attribute(lex.end_span(mv$(ps)), name);\n+    }\n+}\n+\n+::AST::Item Parse_Impl(TokenStream& lex, AST::AttributeList attrs, bool is_unsafe=false)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+    auto ps = lex.start_span();\n+\n+    AST::GenericParams params;\n+    // 1. (optional) type parameters\n+    if( GET_TOK(tok, lex) == TOK_LT )\n+    {\n+        params = Parse_GenericParams(lex);\n+        GET_CHECK_TOK(tok, lex, TOK_GT);\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+    // 2. Either a trait name (with type params), or the type to impl\n+\n+    Spanned<AST::Path>   trait_path;\n+\n+    // - Handle negative impls specially, which must be a trait\n+    // \"impl !Trait for Type {}\"\n+    if( GET_TOK(tok, lex) == TOK_EXCLAM )\n+    {\n+        trait_path = GET_SPANNED(::AST::Path, lex, Parse_Path(lex, PATH_GENERIC_TYPE));\n+        GET_CHECK_TOK(tok, lex, TOK_RWORD_FOR);\n+        auto impl_type = Parse_Type(lex, true);\n+\n+        if( GET_TOK(tok, lex) == TOK_RWORD_WHERE )\n+        {\n+            Parse_WhereClause(lex, params);\n+            GET_TOK(tok, lex);\n+        }\n+        CHECK_TOK(tok, TOK_BRACE_OPEN);\n+        // negative impls can't have any content\n+        GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n+\n+        return ::AST::Item::make_NegImpl(AST::ImplDef( mv$(attrs), mv$(params), mv$(trait_path), \n+            mv$(impl_type) ));\n+    }\n+\n+    // - Don't care which at this stage\n+    PUTBACK(tok, lex);\n+\n+    auto impl_type = Parse_Type(lex, true);\n+\n+    if( GET_TOK(tok, lex) == TOK_RWORD_FOR )\n+    {\n+        // Trickery! All traits parse as valid types, so this works.\n+        if( !impl_type.is_path() )\n+            throw ParseError::Generic(lex, \"Trait was not a path\");\n+        trait_path = Spanned< AST::Path> {\n+            impl_type.span(),\n+            mv$(impl_type.path())\n+            };\n+        // Implementing a trait for another type, get the target type\n+        if( GET_TOK(tok, lex) == TOK_DOUBLE_DOT )\n+        {\n+            // Default impl\n+            impl_type = TypeRef(TypeRef::TagInvalid(), lex.point_span());\n+        }\n+        else\n+        {\n+            PUTBACK(tok, lex);\n+            impl_type = Parse_Type(lex, true);\n+        }\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+\n+    // Where clause\n+    if( GET_TOK(tok, lex) == TOK_RWORD_WHERE )\n+    {\n+        Parse_WhereClause(lex, params);\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+    GET_CHECK_TOK(tok, lex, TOK_BRACE_OPEN);\n+\n+    Parse_ParentAttrs(lex,  attrs);\n+\n+    auto impl = AST::Impl(AST::ImplDef( mv$(attrs), mv$(params), mv$(trait_path), mv$(impl_type) ));\n+\n+    // A sequence of method implementations\n+    while( lex.lookahead(0) != TOK_BRACE_CLOSE )\n+    {\n+        Parse_Impl_Item(lex, impl);\n+    }\n+    GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n+\n+    return ::AST::Item::make_Impl( mv$(impl) );\n+}\n+\n+void Parse_Impl_Item(TokenStream& lex, AST::Impl& impl)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    auto item_attrs = Parse_ItemAttrs(lex);\n+    SET_ATTRS(lex, item_attrs);\n+\n+    {\n+        ::AST::MacroInvocation  inv;\n+        if( Parse_MacroInvocation_Opt(lex,  inv) )\n+        {\n+            impl.add_macro_invocation( mv$(inv) );\n+            impl.items().back().data->attrs = mv$(item_attrs);\n+            return ;\n+        }\n+    }\n+\n+    auto ps = lex.start_span();\n+\n+    bool is_public = Parse_Publicity(lex);\n+    GET_TOK(tok, lex);\n+\n+    bool is_specialisable = false;\n+    if( tok.type() == TOK_IDENT && tok.str() == \"default\" ) {\n+        is_specialisable = true;\n+        GET_TOK(tok, lex);\n+    }\n+\n+    ::std::string   abi = ABI_RUST;\n+    bool fn_is_unsafe = false;\n+    bool fn_is_const = false;\n+    switch(tok.type())\n+    {\n+    case TOK_RWORD_TYPE: {\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        auto name = mv$(tok.str());\n+        GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n+        impl.add_type(is_public, is_specialisable, name, Parse_Type(lex));\n+        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+        break; }\n+    case TOK_RWORD_UNSAFE:\n+        fn_is_unsafe = true;\n+        GET_TOK(tok, lex);\n+        if( tok.type() == TOK_RWORD_CONST )\n+    case TOK_RWORD_CONST:\n+        {\n+            GET_TOK(tok, lex);\n+            if( tok.type() != TOK_RWORD_FN && tok.type() != TOK_RWORD_UNSAFE && !fn_is_unsafe )\n+            {\n+                CHECK_TOK(tok, TOK_IDENT);\n+                auto name = mv$(tok.str());\n+                GET_CHECK_TOK(tok, lex, TOK_COLON);\n+                auto ty = Parse_Type(lex);\n+                GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n+                auto val = Parse_Expr(lex);\n+                GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+\n+                auto i = ::AST::Static(AST::Static::CONST, mv$(ty), mv$(val));\n+                impl.add_static( is_public, is_specialisable, mv$(name),  mv$(i) );\n+                break ;\n+            }\n+            else if( tok.type() == TOK_RWORD_UNSAFE )\n+            {\n+                fn_is_unsafe = true;\n+                GET_CHECK_TOK(tok, lex, TOK_RWORD_FN);\n+            }\n+            fn_is_const = true;\n+        }\n+        if( tok.type() == TOK_RWORD_EXTERN )\n+        // FALL\n+    case TOK_RWORD_EXTERN:\n+        {\n+            abi = \"C\";\n+            if( GET_TOK(tok, lex) == TOK_STRING )\n+                abi = tok.str();\n+            else\n+                PUTBACK(tok, lex);\n+\n+            GET_TOK(tok, lex);\n+        }\n+        CHECK_TOK(tok, TOK_RWORD_FN);\n+        // FALL\n+    case TOK_RWORD_FN: {\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        // TODO: Hygine on function names? - Not in impl blocks?\n+        ::std::string name = mv$(tok.str());\n+        DEBUG(\"Function \" << name);\n+        // - Self allowed, can't be prototype-form\n+        auto fcn = Parse_FunctionDefWithCode(lex, abi, true,  fn_is_unsafe, fn_is_const);\n+        impl.add_function(is_public, is_specialisable, mv$(name), mv$(fcn));\n+        break; }\n+\n+    default:\n+        throw ParseError::Unexpected(lex, tok);\n+    }\n+\n+    impl.items().back().data->span = lex.end_span(mv$(ps));\n+    impl.items().back().data->attrs = mv$(item_attrs);    // Empty for functions\n+}\n+\n+AST::ExternBlock Parse_ExternBlock(TokenStream& lex, ::std::string abi, \n+    ::AST::AttributeList& block_attrs)\n+{\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    Parse_ParentAttrs(lex,  block_attrs);\n+\n+    AST::ExternBlock    rv { abi };\n+\n+    while( GET_TOK(tok, lex) != TOK_BRACE_CLOSE )\n+    {\n+        PUTBACK(tok, lex);\n+        auto meta_items = Parse_ItemAttrs(lex);\n+        SET_ATTRS(lex, meta_items);\n+\n+        auto ps = lex.start_span();\n+\n+        bool is_public = Parse_Publicity(lex);\n+        switch( GET_TOK(tok, lex) )\n+        {\n+        case TOK_RWORD_FN: {\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            auto name = mv$(tok.str());\n+            // parse function as prototype\n+            // - no self, is prototype, is unsafe and not const\n+            auto i = ::AST::Item( Parse_FunctionDef(lex, abi, false, true,  true,false) );\n+            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+\n+            i.attrs = mv$(meta_items);\n+            i.span = lex.end_span(mv$(ps));\n+\n+            rv.add_item( AST::Named<AST::Item> { mv$(name), mv$(i), is_public } );\n+            break; }\n+        case TOK_RWORD_STATIC: {\n+            bool is_mut = false;\n+            if( GET_TOK(tok, lex) == TOK_RWORD_MUT )\n+                is_mut = true;\n+            else\n+                PUTBACK(tok, lex);\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            auto name = mv$(tok.str());\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            auto type = Parse_Type(lex);\n+            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+\n+            auto i = ::AST::Item(::AST::Static( (is_mut ? ::AST::Static::MUT : ::AST::Static::STATIC),  \n+                mv$(type), ::AST::Expr() ));\n+            i.attrs = mv$(meta_items);\n+            i.span = lex.end_span(mv$(ps));\n+            rv.add_item( AST::Named<AST::Item> { mv$(name), mv$(i), is_public } );\n+            break; }\n+        default:\n+            throw ParseError::Unexpected(lex, tok, {TOK_RWORD_FN, TOK_RWORD_STATIC});\n+        }\n+    }\n+\n+    return rv;\n+}\n+\n+void Parse_Use_Wildcard(Span sp, AST::Path base_path, ::std::function<void(AST::UseStmt, \n+    ::std::string)> fcn)\n+{\n+    fcn( AST::UseStmt(mv$(sp), mv$(base_path)), \"\" ); // HACK! Empty path indicates wilcard import\n+}\n+void Parse_Use_Set(TokenStream& lex, const ProtoSpan& ps, const AST::Path& base_path, \n+    ::std::function<void(AST::UseStmt, ::std::string)> fcn)\n+{\n+    TRACE_FUNCTION;\n+\n+    Token   tok;\n+    do {\n+        AST::Path   path;\n+        ::std::string   name;\n+        if( GET_TOK(tok, lex) == TOK_RWORD_SELF ) {\n+            path = ::AST::Path(base_path);\n+            name = base_path[base_path.size()-1].name();\n+        }\n+        else if( tok.type() == TOK_BRACE_CLOSE ) {\n+            break ;\n+        }\n+        else {\n+            CHECK_TOK(tok, TOK_IDENT);\n+            path = base_path + AST::PathNode(tok.str(), {});\n+            name = mv$(tok.str());\n+        }\n+\n+        if( GET_TOK(tok, lex) == TOK_RWORD_AS ) {\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            name = mv$(tok.str());\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+        }\n+        fcn(AST::UseStmt(lex.end_span(ps), mv$(path)), mv$(name));\n+    } while( GET_TOK(tok, lex) == TOK_COMMA );\n+    PUTBACK(tok, lex);\n+}\n+\n+void Parse_Use(TokenStream& lex, ::std::function<void(AST::UseStmt, ::std::string)> fcn)\n+{\n+    TRACE_FUNCTION;\n+\n+    Token   tok;\n+    AST::Path   path = AST::Path(\"\", {});\n+    ::std::vector<AST::PathNode>    nodes;\n+    ProtoSpan   span_start = lex.start_span();\n+\n+    switch( GET_TOK(tok, lex) )\n+    {\n+    case TOK_RWORD_SELF:\n+        path = AST::Path( AST::Path::TagSelf(), {} );    // relative path\n+        break;\n+    case TOK_RWORD_SUPER: {\n+        unsigned int count = 1;\n+        while( LOOK_AHEAD(lex) == TOK_DOUBLE_COLON && lex.lookahead(1) == TOK_RWORD_SUPER ) {\n+            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n+            GET_CHECK_TOK(tok, lex, TOK_RWORD_SUPER);\n+            count += 1;\n+        }\n+        path = AST::Path( AST::Path::TagSuper(), count, {} );\n+        break; }\n+    case TOK_IDENT:\n+        path.append( AST::PathNode(mv$(tok.str()), {}) );\n+        break;\n+    // Leading :: is allowed and ignored for the $crate feature\n+    case TOK_DOUBLE_COLON:\n+        // Absolute path\n+        // HACK! mrustc emits $crate as `::\"crate-name\"`\n+        if( LOOK_AHEAD(lex) == TOK_STRING )\n+        {\n+            GET_CHECK_TOK(tok, lex, TOK_STRING);\n+            path = ::AST::Path(tok.str(), {});\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+        }\n+        break;\n+    case TOK_BRACE_OPEN:\n+        Parse_Use_Set(lex, span_start, path, fcn);\n+        GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n+        return;\n+    case TOK_STAR:\n+        Parse_Use_Wildcard( lex.end_span(span_start), mv$(path), fcn );\n+        return;\n+    case TOK_INTERPOLATED_PATH:\n+        path = mv$(tok.frag_path());\n+        break;\n+    default:\n+        throw ParseError::Unexpected(lex, tok);\n+    }\n+    while( GET_TOK(tok, lex) == TOK_DOUBLE_COLON )\n+    {\n+        if( GET_TOK(tok, lex) == TOK_IDENT )\n+        {\n+            path.append( AST::PathNode( mv$(tok.str()), {}) );\n+        }\n+        else\n+        {\n+            //path.set_span( lex.end_span(span_start) );\n+            switch( tok.type() )\n+            {\n+            case TOK_BRACE_OPEN:\n+                Parse_Use_Set(lex, span_start, mv$(path), fcn);\n+                GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n+                break ;\n+            case TOK_STAR:\n+                Parse_Use_Wildcard( lex.end_span(span_start), mv$(path), fcn );\n+                break ;\n+            default:\n+                throw ParseError::Unexpected(lex, tok);\n+            }\n+            // early return - This branch is either the end of the use statement, or a syntax error\n+            return ;\n+        }\n+    }\n+    //path.set_span( lex.end_span(span_start) );\n+\n+    ::std::string name;\n+    // This should only be allowed if the last token was an ident\n+    // - Above checks ensure this\n+    if( tok.type() == TOK_RWORD_AS )\n+    {\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        name = mv$(tok.str());\n+    }\n+    else\n+    {\n+        PUTBACK(tok, lex);\n+        ASSERT_BUG(lex.point_span(), path.nodes().size() > 0, \"`use` with no path\");\n+        name = path.nodes().back().name();\n+    }\n+\n+    fcn( AST::UseStmt(lex.end_span(span_start), mv$(path)), name);\n+}\n+\n+\n+::AST::MacroInvocation Parse_MacroInvocation(ProtoSpan span_start, ::std::string name, \n+    TokenStream& lex)\n+{\n+    Token   tok;\n+    ::std::string   ident;\n+    if( GET_TOK(tok, lex) == TOK_IDENT ) {\n+        ident = mv$(tok.str());\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+    DEBUG(\"name=\" << name << \", ident=\" << ident);\n+    TokenTree tt = Parse_TT(lex, true);\n+    return ::AST::MacroInvocation( lex.end_span(span_start), mv$(name), mv$(ident), mv$(tt));\n+}\n+\n+bool Parse_MacroInvocation_Opt(TokenStream& lex,  AST::MacroInvocation& out_inv)\n+{\n+    Token   tok;\n+    if( lex.lookahead(0) == TOK_IDENT && lex.lookahead(1) == TOK_EXCLAM )\n+    {\n+        // Good\n+    }\n+    else\n+    {\n+        return false;\n+    }\n+\n+    auto ps = lex.start_span();\n+    GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+    auto name = tok.str();\n+    GET_CHECK_TOK(tok, lex, TOK_EXCLAM);\n+\n+    bool is_braced = (lex.lookahead(0) == TOK_BRACE_OPEN || (lex.lookahead(0) == TOK_IDENT \n+        && lex.lookahead(1) == TOK_BRACE_OPEN));\n+\n+    out_inv = Parse_MacroInvocation(ps, name, lex);\n+\n+    if(!is_braced )\n+    {\n+        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+    }\n+    return true;\n+}\n+\n+::AST::Named<::AST::Item> Parse_Mod_Item_S(TokenStream& lex, const AST::Module::FileInfo& mod_fileinfo, \n+    const ::AST::Path& mod_path, AST::AttributeList meta_items)\n+{\n+    TRACE_FUNCTION_F(\"mod_path=\"<<mod_path<<\", meta_items=\"<<meta_items);\n+    Token   tok;\n+\n+    // NOTE: This assigns into a parameter, so can't use Parse_ItemAttrs\n+    while( LOOKAHEAD2(lex, TOK_HASH, TOK_SQUARE_OPEN) )\n+    {\n+        // Attributes!\n+        GET_CHECK_TOK(tok, lex, TOK_HASH);\n+        GET_CHECK_TOK(tok, lex, TOK_SQUARE_OPEN);\n+        meta_items.push_back( Parse_MetaItem(lex) );\n+        GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n+    }\n+\n+    if( LOOK_AHEAD(lex) == TOK_INTERPOLATED_ITEM ) {\n+        GET_TOK(tok, lex);\n+        auto rv = tok.take_frag_item();\n+        // Transfer new attributes onto the item\n+        for(auto& mi : meta_items.m_items)\n+            rv.data.attrs.m_items.push_back( mv$(mi) );\n+        return rv;\n+    }\n+\n+    auto ps = lex.start_span();\n+\n+    ::std::string   item_name;\n+    ::AST::Item item_data;\n+\n+    {\n+        ::AST::MacroInvocation  inv;\n+        if( Parse_MacroInvocation_Opt(lex, inv) )\n+        {\n+            item_data = ::AST::Item( mv$(inv) );\n+            item_data.attrs = mv$(meta_items);\n+            item_data.span = lex.end_span(mv$(ps));\n+\n+            return ::AST::Named< ::AST::Item> { \"\", mv$(item_data), false };\n+        }\n+    }\n+\n+    bool    is_public = Parse_Publicity(lex);\n+\n+    switch( GET_TOK(tok, lex) )\n+    {\n+    case TOK_RWORD_USE:\n+        // NOTE: The only problem here is with things like `use foo::{a, b, c}` - all others are a single statement.\n+        // - These are caught by the condition in the closure\n+        Parse_Use(lex, [&](AST::UseStmt p, std::string s) {\n+                DEBUG(mod_path << \" - use \" << p << \" as '\" << s << \"'\");\n+                if( !item_data.is_None() )\n+                    TODO(lex.point_span(), \"Encode multi-item use statements as a single Item\");\n+                item_data = ::AST::Item(mv$(p));\n+                item_name = mv$(s);\n+            });\n+        assert( !item_data.is_None() );\n+        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+        break;\n+\n+    case TOK_RWORD_EXTERN:\n+        switch( GET_TOK(tok, lex) )\n+        {\n+        // `extern \"<ABI>\" fn ...`\n+        // `extern \"<ABI>\" { ...`\n+        case TOK_STRING: {\n+            ::std::string abi = tok.str();\n+            switch(GET_TOK(tok, lex))\n+            {\n+            // `extern \"<ABI>\" fn ...`\n+            case TOK_RWORD_FN: {\n+                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+                item_name = mv$(tok.str());\n+                item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, abi, false,  false,false) );\n+                break; }\n+            // `extern \"ABI\" {`\n+            case TOK_BRACE_OPEN:\n+                item_name = \"\";\n+                item_data = ::AST::Item( Parse_ExternBlock(lex, mv$(abi), meta_items) );\n+                break;\n+            default:\n+                throw ParseError::Unexpected(lex, tok, {TOK_RWORD_FN, TOK_BRACE_OPEN});\n+            }\n+            break; }\n+        // `extern fn ...`\n+        case TOK_RWORD_FN:\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            item_name = mv$(tok.str());\n+            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, \"C\", false,  false,false) );\n+            break;\n+\n+        // NOTE: `extern { ...` is handled in caller\n+        case TOK_BRACE_OPEN:\n+            item_name = \"\";\n+            item_data = ::AST::Item( Parse_ExternBlock(lex, \"C\", meta_items) );\n+            break;\n+\n+        // `extern crate \"crate-name\" as crate_name;`\n+        // `extern crate crate_name;`\n+        // `extern crate crate_name as other_name;`\n+        case TOK_RWORD_CRATE:\n+            switch( GET_TOK(tok, lex) )\n+            {\n+            // `extern crate \"crate-name\" as crate_name;`\n+            // NOTE: rustc doesn't allow this, keep in mrustc for for reparse support\n+            case TOK_STRING:\n+                item_data = ::AST::Item::make_Crate({ tok.str() });\n+                GET_CHECK_TOK(tok, lex, TOK_RWORD_AS);\n+                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+                item_name = mv$(tok.str());\n+                break;\n+            // `extern crate crate_name;`\n+            // `extern crate crate_name as other_name;`\n+            case TOK_IDENT:\n+                item_name = mv$(tok.str());\n+                if(GET_TOK(tok, lex) == TOK_RWORD_AS) {\n+                    item_data = ::AST::Item::make_Crate({ mv$(item_name) });\n+\n+                    GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+                    item_name = mv$(tok.str());\n+                }\n+                else {\n+                    PUTBACK(tok, lex);\n+                    item_data = ::AST::Item::make_Crate({ item_name });\n+                }\n+                break;\n+            default:\n+                throw ParseError::Unexpected(lex, tok, {TOK_STRING, TOK_IDENT});\n+            }\n+            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+            break;\n+        default:\n+            throw ParseError::Unexpected(lex, tok, {TOK_STRING, TOK_RWORD_FN, TOK_BRACE_OPEN, \n+                TOK_RWORD_CRATE});\n+        }\n+        break;\n+\n+    // `const NAME`\n+    // `const [unsafe] fn`\n+    case TOK_RWORD_CONST:\n+        switch( GET_TOK(tok, lex) )\n+        {\n+        case TOK_IDENT: {\n+            item_name = mv$(tok.str());\n+\n+            GET_CHECK_TOK(tok, lex, TOK_COLON);\n+            TypeRef type = Parse_Type(lex);\n+            GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n+            AST::Expr val = Parse_Expr(lex);\n+            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+            item_data = ::AST::Item( ::AST::Static(AST::Static::CONST, mv$(type), mv$(val)) );\n+            break; }\n+        case TOK_RWORD_UNSAFE:\n+            GET_CHECK_TOK(tok, lex, TOK_RWORD_FN);\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            item_name = mv$(tok.str());\n+            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, ABI_RUST, false,  \n+                true,true/*unsafe,const*/) );\n+            break;\n+        case TOK_RWORD_FN:\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            item_name = mv$(tok.str());\n+            // - self not allowed, not prototype\n+            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, ABI_RUST, false,  \n+                false,true/*unsafe,const*/) );\n+            break;\n+        default:\n+            throw ParseError::Unexpected(lex, tok, {TOK_IDENT, TOK_RWORD_FN});\n+        }\n+        break;\n+    // `static NAME`\n+    // `static mut NAME`\n+    case TOK_RWORD_STATIC: {\n+        bool is_mut = false;\n+        if(GET_TOK(tok, lex) == TOK_RWORD_MUT) {\n+            is_mut = true;\n+            GET_TOK(tok, lex);\n+        }\n+        CHECK_TOK(tok, TOK_IDENT);\n+        item_name = mv$(tok.str());\n+\n+        GET_CHECK_TOK(tok, lex, TOK_COLON);\n+        TypeRef type = Parse_Type(lex);\n+\n+        GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n+\n+        AST::Expr val = Parse_Expr(lex);\n+\n+        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+        item_data = ::AST::Item( ::AST::Static( (is_mut ? AST::Static::MUT : AST::Static::STATIC), \n+            mv$(type), mv$(val)) );\n+        break; }\n+\n+    // `unsafe fn`\n+    // `unsafe trait`\n+    // `unsafe impl`\n+    case TOK_RWORD_UNSAFE:\n+        switch(GET_TOK(tok, lex))\n+        {\n+        // `unsafe extern fn`\n+        case TOK_RWORD_EXTERN: {\n+            ::std::string   abi = \"C\";\n+            if(GET_TOK(tok, lex) == TOK_STRING) {\n+                abi = mv$(tok.str());\n+            }\n+            else {\n+                PUTBACK(tok, lex);\n+            }\n+            GET_CHECK_TOK(tok, lex, TOK_RWORD_FN);\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            item_name = mv$(tok.str());\n+            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, abi, false,  \n+                true,false/*unsafe,const*/) );\n+            break; }\n+        // `unsafe fn`\n+        case TOK_RWORD_FN:\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            item_name = mv$(tok.str());\n+            // - self not allowed, not prototype\n+            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, ABI_RUST, false,  \n+                true,false/*unsafe,const*/) );\n+            break;\n+        // `unsafe trait`\n+        case TOK_RWORD_TRAIT: {\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            item_name = mv$(tok.str());\n+            auto tr = Parse_TraitDef(lex, meta_items);\n+            tr.set_is_unsafe();\n+            item_data = ::AST::Item( ::std::move(tr) );\n+            break; }\n+        // `unsafe impl`\n+        case TOK_RWORD_IMPL: {\n+            auto impl = Parse_Impl(lex, mv$(meta_items), true);\n+            if( impl.is_Impl() ) {\n+                impl.as_Impl().def().set_is_unsafe();\n+            }\n+            else if( impl.is_NegImpl() ) {\n+                impl.as_NegImpl().set_is_unsafe();\n+            }\n+            else {\n+                BUG(lex.point_span(), \"Parse_Impl returned a variant other than Impl or NegImpl\");\n+            }\n+            return ::AST::Named< ::AST::Item> { \"\", mv$(impl), false };\n+            }\n+        default:\n+            throw ParseError::Unexpected(lex, tok, {TOK_RWORD_FN, TOK_RWORD_TRAIT, TOK_RWORD_IMPL});\n+        }\n+        break;\n+    // `fn`\n+    case TOK_RWORD_FN:\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        item_name = mv$(tok.str());\n+        // - self not allowed, not prototype\n+        item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, ABI_RUST, false,  \n+            false,false/*unsafe,const*/) );\n+        break;\n+    // `type`\n+    case TOK_RWORD_TYPE:\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        item_name = mv$(tok.str());\n+        item_data = ::AST::Item( Parse_TypeAlias(lex) );\n+        break;\n+    // `struct`\n+    case TOK_RWORD_STRUCT:\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        item_name = mv$(tok.str());\n+        item_data = ::AST::Item( Parse_Struct(lex, meta_items) );\n+        break;\n+    // `enum`\n+    case TOK_RWORD_ENUM:\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        item_name = mv$(tok.str());\n+        item_data = ::AST::Item( Parse_EnumDef(lex, meta_items) );\n+        break;\n+    // Contextual keywords\n+    case TOK_IDENT:\n+        if( tok.str() == \"union\" ) {\n+            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+            item_name = mv$(tok.str());\n+            item_data = ::AST::Item( Parse_Union(lex, meta_items) );\n+        }\n+        else {\n+            throw ParseError::Unexpected(lex, tok);\n+        }\n+        break;\n+    // `impl`\n+    case TOK_RWORD_IMPL:\n+        return ::AST::Named< ::AST::Item> { \"\", Parse_Impl(lex, mv$(meta_items)), false };\n+    // `trait`\n+    case TOK_RWORD_TRAIT:\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        item_name = mv$(tok.str());\n+        item_data = ::AST::Item( Parse_TraitDef(lex, meta_items) );\n+        break;\n+\n+    case TOK_RWORD_MOD: {\n+        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n+        auto name = mv$(tok.str());\n+        DEBUG(\"Sub module '\" << name << \"'\");\n+        AST::Module submod( mod_path + name );\n+\n+        // Rules for external files (/ path handling):\n+        // - IF using stdin (path='-') - Disallow and propagate '-' as path\n+        // - IF a #[path] attribute was passed, allow\n+        // - IF in crate root or mod.rs, allow (input flag)\n+        // - else, disallow and set flag\n+        ::std::string path_attr = (meta_items.has(\"path\") ? meta_items.get(\"path\")->string() : \"\");\n+\n+        //submod.m_file_info = get_submod_file(lex.end_span(ps), mod_fileinfo,  name, path_attr, LOOK_AHEAD(lex) == TOK_SEMICOLON);\n+\n+        ::std::string   sub_path;\n+        bool    sub_file_controls_dir = true;\n+        if( mod_fileinfo.path == \"-\" ) {\n+            if( path_attr.size() ) {\n+                ERROR(lex.point_span(), E0000, \"Cannot load module from file when reading stdin\");\n+            }\n+            sub_path = \"-\";\n+        }\n+        else if( path_attr.size() > 0 )\n+        {\n+            sub_path = dirname(mod_fileinfo.path) + path_attr;\n+        }\n+        else if( mod_fileinfo.controls_dir )\n+        {\n+            sub_path = dirname(mod_fileinfo.path) + name;\n+        }\n+        else\n+        {\n+            sub_path = mod_fileinfo.path;\n+            sub_file_controls_dir = false;\n+        }\n+        DEBUG(\"Mod '\" << name << \"', sub_path = \" << sub_path);\n+\n+        submod.m_file_info.path = sub_path;\n+        submod.m_file_info.controls_dir = sub_file_controls_dir;\n+\n+        // Check #[cfg] and don't load if it fails\n+        struct H {\n+            static bool check_item_cfg(const ::AST::AttributeList& attrs)\n+            {\n+                for(const auto& at : attrs.m_items) {\n+                    if( at.name() == \"cfg\" && !check_cfg(at.span(), at) ) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n+\n+        switch( GET_TOK(tok, lex) )\n+        {\n+        case TOK_BRACE_OPEN:\n+            submod.m_file_info.path = sub_path + \"/\";\n+            Parse_ModRoot(lex, submod, meta_items);\n+            GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n+            break;\n+        case TOK_SEMICOLON:\n+            if( sub_path == \"-\" ) {\n+                ERROR(lex.point_span(), E0000, \"Cannot load module from file when reading stdin\");\n+            }\n+            else if( path_attr.size() == 0 && ! mod_fileinfo.controls_dir )\n+            {\n+                ERROR(lex.point_span(), E0000, \"Can't load from files outside of mod.rs or crate root\");\n+            }\n+            else if( !H::check_item_cfg(meta_items) ) {\n+                // Ignore - emit Item::None\n+                item_name = mv$(name);\n+                item_data = ::AST::Item( );\n+                break ;\n+            }\n+            else\n+            {\n+                ::std::string newpath_dir  = sub_path + \"/\";\n+                ::std::string newpath_file = path_attr.size() > 0 ? sub_path : sub_path + \".rs\";\n+                DEBUG(\"newpath_dir = '\" << newpath_dir << \"', newpath_file = '\" << newpath_file << \"'\");\n+                ::std::ifstream ifs_dir (newpath_dir + \"mod.rs\");\n+                ::std::ifstream ifs_file(newpath_file);\n+                if( ifs_dir.is_open() && ifs_file.is_open() )\n+                {\n+                    // Collision\n+                    ERROR(lex.point_span(), E0000, \"Both modname.rs and modname/mod.rs exist\");\n+                }\n+                else if( ifs_dir.is_open() )\n+                {\n+                    // Load from dir\n+                    submod.m_file_info.path = newpath_dir + \"mod.rs\";\n+                }\n+                else if( ifs_file.is_open() )\n+                {\n+                    submod.m_file_info.path = newpath_file;\n+                }\n+                else\n+                {\n+                    // Can't find file\n+                    ERROR(lex.point_span(), E0000, \"Can't find file for '\" << name << \"' in '\" << mod_fileinfo.path << \"'\");\n+                }\n+                DEBUG(\"- path = \" << submod.m_file_info.path);\n+                Lexer sub_lex(submod.m_file_info.path);\n+                Parse_ModRoot(sub_lex, submod, meta_items);\n+                GET_CHECK_TOK(tok, sub_lex, TOK_EOF);\n+            }\n+            break;\n+        default:\n+            throw ParseError::Generic(\"Expected { or ; after module name\");\n+        }\n+        item_name = mv$(name);\n+        item_data = ::AST::Item( mv$(submod) );\n+        break; }\n+\n+    default:\n+        throw ParseError::Unexpected(lex, tok);\n+    }\n+\n+    item_data.attrs = mv$(meta_items);\n+    item_data.span = lex.end_span(mv$(ps));\n+\n+    return ::AST::Named< ::AST::Item> { mv$(item_name), mv$(item_data), is_public };\n+}\n+\n+void Parse_Mod_Item(TokenStream& lex, AST::Module& mod, AST::AttributeList meta_items)\n+{\n+    SET_MODULE(lex, mod);\n+    lex.parse_state().parent_attrs = &meta_items;\n+\n+    //TRACE_FUNCTION;\n+    Token   tok;\n+\n+    // `use ...`\n+    // TODO: This doesn't spot `pub(path) use`.\n+    if( LOOK_AHEAD(lex) == TOK_RWORD_USE || (lex.lookahead(0) == TOK_RWORD_PUB \n+        && lex.lookahead(1) == TOK_RWORD_USE) )\n+    {\n+        bool    is_public = Parse_Publicity(lex);\n+        GET_CHECK_TOK(tok, lex, TOK_RWORD_USE);\n+\n+        Parse_Use(lex, [&mod,is_public,&meta_items](AST::UseStmt p, std::string s) {\n+                DEBUG(mod.path() << \" - use \" << p << \" as '\" << s << \"'\");\n+                mod.add_alias(is_public, mv$(p), s, meta_items.clone());\n+            });\n+        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n+    }\n+    else\n+    {\n+        mod.add_item( Parse_Mod_Item_S(lex, mod.m_file_info, mod.path(), mv$(meta_items)) );\n+    }\n+}\n+\n+void Parse_ModRoot_Items(TokenStream& lex, AST::Module& mod)\n+{\n+    Token   tok;\n+\n+    for(;;)\n+    {\n+        // Check 1 - End of module (either via a closing brace, or EOF)\n+        switch(GET_TOK(tok, lex))\n+        {\n+        case TOK_BRACE_CLOSE:\n+        case TOK_EOF:\n+            PUTBACK(tok, lex);\n+            return;\n+        default:\n+            PUTBACK(tok, lex);\n+            break;\n+        }\n+\n+        // Attributes on the following item\n+        auto meta_items = Parse_ItemAttrs(lex);\n+        DEBUG(\"meta_items = \" << meta_items);\n+\n+        Parse_Mod_Item(lex, mod, mv$(meta_items));\n+    }\n+}\n+\n+void Parse_ModRoot(TokenStream& lex, AST::Module& mod, AST::AttributeList& mod_attrs)\n+{\n+    TRACE_FUNCTION;\n+\n+    // Attributes on module/crate (will continue loop)\n+    Parse_ParentAttrs(lex,  mod_attrs);\n+\n+    Parse_ModRoot_Items(lex, mod);\n+}\n+\n+AST::Crate Parse_Crate(::std::string mainfile)\n+{\n+    Token   tok;\n+\n+    Lexer lex(mainfile);\n+\n+    size_t p = mainfile.find_last_of('/');\n+    p = (p == ::std::string::npos ? mainfile.find_last_of('\\\\') : p);\n+    ::std::string mainpath = (p != ::std::string::npos ? ::std::string(mainfile.begin(), \n+        mainfile.begin()+p+1) : \"./\");\n+\n+    AST::Crate  crate;\n+\n+    //crate.root_module().m_file_info.file_path = mainfile;\n+    crate.root_module().m_file_info.path = mainpath;\n+    crate.root_module().m_file_info.controls_dir = true;\n+\n+    Parse_ModRoot(lex, crate.root_module(), crate.m_attrs);\n+\n+    return crate;\n+}"}, {"sha": "2e5a61d4d9e16978cdc9c26b06d48da50283e070", "filename": "gcc/rust/mrustc_parser/parse/token.cpp", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,512 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ */\n+#include \"token.hpp\"\n+#include <common.hpp>\n+#include <parse/parseerror.hpp>\n+#include \"interpolated_fragment.hpp\"\n+#include <ast/types.hpp>\n+#include <ast/ast.hpp>\n+#include <ast/expr.hpp> // for reasons\n+\n+Token::~Token()\n+{\n+    switch(m_type)\n+    {\n+    case TOK_INTERPOLATED_TYPE:\n+        delete reinterpret_cast<TypeRef*>(m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_PATTERN:\n+        delete reinterpret_cast<AST::Pattern*>(m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_PATH:\n+        delete reinterpret_cast<AST::Path*>(m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_EXPR:\n+        delete reinterpret_cast<AST::ExprNode*>(m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_STMT:\n+        delete reinterpret_cast<AST::ExprNode*>(m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_BLOCK:\n+        delete reinterpret_cast<AST::ExprNode*>(m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_META:\n+        delete reinterpret_cast<AST::Attribute*>(m_data.as_Fragment());\n+        break;\n+    default:\n+        break;\n+    }\n+\n+}\n+\n+Token::Token():\n+    m_type(TOK_NULL)\n+{\n+}\n+Token::Token(enum eTokenType type):\n+    m_type(type)\n+{\n+}\n+Token::Token(enum eTokenType type, ::std::string str):\n+    m_type(type),\n+    m_data(Data::make_String(mv$(str)))\n+{\n+}\n+Token::Token(uint64_t val, enum eCoreType datatype):\n+    m_type(TOK_INTEGER),\n+    m_data( Data::make_Integer({datatype, val}) )\n+{\n+}\n+Token::Token(double val, enum eCoreType datatype):\n+    m_type(TOK_FLOAT),\n+    m_data( Data::make_Float({datatype, val}) )\n+{\n+}\n+Token::Token(const InterpolatedFragment& frag)\n+{\n+    switch(frag.m_type)\n+    {\n+    case InterpolatedFragment::TT:  throw \"\";\n+    case InterpolatedFragment::TYPE:\n+        m_type = TOK_INTERPOLATED_TYPE;\n+        m_data = new TypeRef( reinterpret_cast<const TypeRef*>(frag.m_ptr)->clone() );\n+        break;\n+    case InterpolatedFragment::PAT:\n+        m_type = TOK_INTERPOLATED_PATTERN;\n+        m_data = new AST::Pattern( reinterpret_cast<const AST::Pattern*>(frag.m_ptr)->clone() );\n+        break;\n+    case InterpolatedFragment::PATH:\n+        m_type = TOK_INTERPOLATED_PATH;\n+        m_data = new AST::Path( *reinterpret_cast<const AST::Path*>(frag.m_ptr) );\n+        break;\n+    case InterpolatedFragment::EXPR:\n+        m_type = TOK_INTERPOLATED_EXPR; if(0)\n+    case InterpolatedFragment::STMT:\n+        m_type = TOK_INTERPOLATED_STMT; if(0)\n+    case InterpolatedFragment::BLOCK:\n+        m_type = TOK_INTERPOLATED_BLOCK;\n+\n+        m_data = reinterpret_cast<const AST::ExprNode*>(frag.m_ptr)->clone().release();\n+        break;\n+    case InterpolatedFragment::META:\n+        m_type = TOK_INTERPOLATED_META;\n+        m_data = new AST::Attribute( reinterpret_cast<const AST::Attribute*>(frag.m_ptr)->clone() );\n+        break;\n+    case InterpolatedFragment::ITEM: {\n+        m_type = TOK_INTERPOLATED_ITEM;\n+        const auto& named = *reinterpret_cast<const AST::Named<AST::Item>*>(frag.m_ptr);\n+        ::AST::Item item = named.data.clone();\n+        m_data = new AST::Named<AST::Item>( named.name, mv$(item), named.is_pub );\n+        break; }\n+    }\n+}\n+Token::Token(TagTakeIP, InterpolatedFragment frag)\n+{\n+    switch(frag.m_type)\n+    {\n+    case InterpolatedFragment::TT:  throw \"\";\n+    case InterpolatedFragment::TYPE:\n+        m_type = TOK_INTERPOLATED_TYPE;\n+        m_data = new TypeRef( mv$(*reinterpret_cast<TypeRef*>(frag.m_ptr)) );\n+        break;\n+    case InterpolatedFragment::PAT:\n+        m_type = TOK_INTERPOLATED_PATTERN;\n+        m_data = new AST::Pattern( mv$(*reinterpret_cast<AST::Pattern*>(frag.m_ptr)) );\n+        break;\n+    case InterpolatedFragment::PATH:\n+        m_type = TOK_INTERPOLATED_PATH;\n+        m_data = new AST::Path( mv$(*reinterpret_cast<AST::Path*>(frag.m_ptr)) );\n+        break;\n+    case InterpolatedFragment::EXPR:\n+        m_type = TOK_INTERPOLATED_EXPR; if(0)\n+    case InterpolatedFragment::STMT:\n+        m_type = TOK_INTERPOLATED_STMT; if(0)\n+    case InterpolatedFragment::BLOCK:\n+        m_type = TOK_INTERPOLATED_BLOCK;\n+\n+        m_data = reinterpret_cast<AST::ExprNode*>(frag.m_ptr);\n+        frag.m_ptr = nullptr;\n+        break;\n+    case InterpolatedFragment::ITEM:\n+        m_type = TOK_INTERPOLATED_ITEM;\n+        m_data = frag.m_ptr;\n+        frag.m_ptr = nullptr;\n+        break;\n+    case InterpolatedFragment::META:\n+        m_type = TOK_INTERPOLATED_META;\n+        m_data = frag.m_ptr;\n+        frag.m_ptr = nullptr;\n+        break;\n+    }\n+}\n+\n+Token::Token(const Token& t):\n+    m_type(t.m_type),\n+    m_data( Data::make_None({}) ),\n+    m_pos( t.m_pos )\n+{\n+    assert( t.m_data.tag() != Data::TAGDEAD );\n+    TU_MATCH(Data, (t.m_data), (e),\n+    (None,  ),\n+    (String,    m_data = Data::make_String(e); ),\n+    (Integer,   m_data = Data::make_Integer(e);),\n+    (Float, m_data = Data::make_Float(e);),\n+    (Fragment, BUG(t.m_pos, \"Attempted to copy a fragment - \" << t);)\n+    )\n+}\n+Token Token::clone() const\n+{\n+    Token   rv(m_type);\n+    rv.m_pos = m_pos;\n+\n+    assert( m_data.tag() != Data::TAGDEAD );\n+    TU_MATCH(Data, (m_data), (e),\n+    (None,\n+        ),\n+    (String,\n+        rv.m_data = Data::make_String(e);\n+        ),\n+    (Integer,\n+        rv.m_data = Data::make_Integer(e);\n+        ),\n+    (Float,\n+        rv.m_data = Data::make_Float(e);\n+        ),\n+    (Fragment,\n+        assert(e);\n+        switch(m_type)\n+        {\n+        case TOK_INTERPOLATED_TYPE:\n+            rv.m_data = new TypeRef( reinterpret_cast<TypeRef*>(e)->clone() );\n+            break;\n+        case TOK_INTERPOLATED_PATTERN:\n+            rv.m_data = new AST::Pattern( reinterpret_cast<AST::Pattern*>(e)->clone() );\n+            break;\n+        case TOK_INTERPOLATED_PATH:\n+            rv.m_data = new AST::Path( *reinterpret_cast<AST::Path*>(e) );\n+            break;\n+        case TOK_INTERPOLATED_EXPR:\n+            rv.m_data = reinterpret_cast<AST::ExprNode*>(e)->clone().release();\n+            break;\n+        case TOK_INTERPOLATED_STMT:\n+            rv.m_data = reinterpret_cast<AST::ExprNode*>(e)->clone().release();\n+            break;\n+        case TOK_INTERPOLATED_BLOCK:\n+            rv.m_data = reinterpret_cast<AST::ExprNode*>(e)->clone().release();\n+            break;\n+        case TOK_INTERPOLATED_META:\n+            rv.m_data = new AST::Attribute( reinterpret_cast<AST::Attribute*>(e)->clone() );\n+            break;\n+        case TOK_INTERPOLATED_ITEM:\n+            TODO(m_pos, \"clone interpolated item\");\n+            //rv.m_data = new AST::Named( AST::Item( reinterpret_cast<AST::Attribute*>(e)->clone() ) );\n+            break;\n+        default:\n+            BUG(m_pos, \"Fragment with invalid token type (\" << *this << \")\");\n+            break;\n+        }\n+        assert(rv.m_data.is_Fragment());\n+        )\n+    )\n+    return rv;\n+}\n+\n+::std::unique_ptr<AST::ExprNode> Token::take_frag_node()\n+{\n+    assert( m_type == TOK_INTERPOLATED_EXPR || m_type == TOK_INTERPOLATED_STMT || m_type == TOK_INTERPOLATED_BLOCK );\n+    auto ptr = m_data.as_Fragment();\n+    m_data.as_Fragment() = nullptr;\n+    return ::std::unique_ptr<AST::ExprNode>( reinterpret_cast<AST::ExprNode*>( ptr ) );\n+}\n+::AST::Named<AST::Item> Token::take_frag_item()\n+{\n+    assert( m_type == TOK_INTERPOLATED_ITEM );\n+    auto ptr = reinterpret_cast<AST::Named<AST::Item>*>(m_data.as_Fragment());\n+    m_data.as_Fragment() = nullptr;\n+    auto rv = mv$( *ptr );\n+    delete ptr;\n+    return mv$(rv);\n+}\n+\n+const char* Token::typestr(enum eTokenType type)\n+{\n+    switch(type)\n+    {\n+    #define _(t)    case t: return #t;\n+    #include \"eTokenType.enum.h\"\n+    #undef _\n+    }\n+    return \">>BUGCHECK: BADTOK<<\";\n+}\n+\n+enum eTokenType Token::typefromstr(const ::std::string& s)\n+{\n+    if(s == \"\")\n+        return TOK_NULL;\n+    #define _(t)    if( s == #t ) return t;\n+    #include \"eTokenType.enum.h\"\n+    #undef _\n+    return TOK_NULL;\n+}\n+\n+struct EscapedString {\n+    const ::std::string& s;\n+    EscapedString(const ::std::string& s): s(s) {}\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const EscapedString& x) {\n+        for(auto b : x.s) {\n+            switch(b)\n+            {\n+            case '\"':\n+                os << \"\\\\\\\"\";\n+                break;\n+            case '\\\\':\n+                os << \"\\\\\\\\\";\n+                break;\n+            case '\\n':\n+                os << \"\\\\n\";\n+                break;\n+            default:\n+                if( ' ' <= b && b < 0x7F )\n+                    os << b;\n+                else\n+                    os << \"\\\\u{\" << ::std::hex << (unsigned int)b << \"}\";\n+                break;\n+            }\n+        }\n+        return os;\n+    }\n+};\n+\n+::std::string Token::to_str() const\n+{\n+    ::std::stringstream ss;\n+    switch(m_type)\n+    {\n+    case TOK_NULL:  return \"/*null*/\";\n+    case TOK_EOF:   return \"/*eof*/\";\n+\n+    case TOK_NEWLINE:    return \"\\n\";\n+    case TOK_WHITESPACE: return \" \";\n+    case TOK_COMMENT:    return \"/*\" + m_data.as_String() + \"*/\";\n+    case TOK_INTERPOLATED_TYPE:\n+        reinterpret_cast<const ::TypeRef*>(m_data.as_Fragment())->print(ss, false);\n+        return ss.str();\n+    case TOK_INTERPOLATED_PATH:\n+        reinterpret_cast<const ::AST::Path*>(m_data.as_Fragment())->print_pretty(ss, true);\n+        return ss.str();\n+    case TOK_INTERPOLATED_PATTERN:\n+        // TODO: Use a pretty printer too?\n+        return FMT( *reinterpret_cast<const ::AST::Pattern*>(m_data.as_Fragment()) );\n+    case TOK_INTERPOLATED_STMT:\n+    case TOK_INTERPOLATED_BLOCK:\n+    case TOK_INTERPOLATED_EXPR: {\n+        ::std::stringstream ss;\n+        reinterpret_cast<const ::AST::ExprNode*>(m_data.as_Fragment())->print(ss);\n+        return ss.str();\n+        }\n+    case TOK_INTERPOLATED_META: return \"/*:meta*/\";\n+    case TOK_INTERPOLATED_ITEM: return \"/*:item*/\";\n+    case TOK_INTERPOLATED_IDENT: return \"/*:ident*/\";\n+    // Value tokens\n+    case TOK_IDENT:     return m_data.as_String();\n+    case TOK_LIFETIME:  return \"'\" + m_data.as_String();\n+    case TOK_INTEGER:\n+        if( m_data.as_Integer().m_datatype == CORETYPE_ANY ) {\n+            return FMT(m_data.as_Integer().m_intval);\n+        }\n+        else {\n+            return FMT(m_data.as_Integer().m_intval << \"_\" << m_data.as_Integer().m_datatype);\n+        }\n+    case TOK_CHAR:      return FMT(\"'\\\\u{\"<< ::std::hex << m_data.as_Integer().m_intval << \"}\");\n+    case TOK_FLOAT:\n+        if( m_data.as_Float().m_datatype == CORETYPE_ANY ) {\n+            return FMT(m_data.as_Float().m_floatval);\n+        }\n+        else {\n+            return FMT(m_data.as_Float().m_floatval << \"_\" << m_data.as_Float().m_datatype);\n+        }\n+    case TOK_STRING:    return FMT(\"\\\"\" << EscapedString(m_data.as_String()) << \"\\\"\");\n+    case TOK_BYTESTRING:return FMT(\"b\\\"\" << m_data.as_String() << \"\\\"\");\n+    case TOK_HASH:  return \"#\";\n+    case TOK_UNDERSCORE:return \"_\";\n+    // Symbols\n+    case TOK_PAREN_OPEN:    return \"(\";\n+    case TOK_PAREN_CLOSE:   return \")\";\n+    case TOK_BRACE_OPEN:    return \"{\";\n+    case TOK_BRACE_CLOSE:   return \"}\";\n+    case TOK_LT:    return \"<\";\n+    case TOK_GT:    return \">\";\n+    case TOK_SQUARE_OPEN:   return \"[\";\n+    case TOK_SQUARE_CLOSE:  return \"]\";\n+    case TOK_COMMA:     return \",\";\n+    case TOK_SEMICOLON: return \";\";\n+    case TOK_COLON:     return \":\";\n+    case TOK_DOUBLE_COLON:  return \"::\";\n+    case TOK_STAR:  return \"*\";\n+    case TOK_AMP:   return \"&\";\n+    case TOK_PIPE:  return \"|\";\n+\n+    case TOK_FATARROW:  return \"=>\";\n+    case TOK_THINARROW: return \"->\";\n+    case TOK_THINARROW_LEFT: return \"<-\";\n+\n+    case TOK_PLUS:  return \"+\";\n+    case TOK_DASH:  return \"-\";\n+    case TOK_EXCLAM:    return \"!\";\n+    case TOK_PERCENT:   return \"%\";\n+    case TOK_SLASH:     return \"/\";\n+\n+    case TOK_DOT:   return \".\";\n+    case TOK_DOUBLE_DOT:    return \"...\";\n+    case TOK_TRIPLE_DOT:    return \"..\";\n+\n+    case TOK_EQUAL: return \"=\";\n+    case TOK_PLUS_EQUAL:    return \"+=\";\n+    case TOK_DASH_EQUAL:    return \"-\";\n+    case TOK_PERCENT_EQUAL: return \"%=\";\n+    case TOK_SLASH_EQUAL:   return \"/=\";\n+    case TOK_STAR_EQUAL:    return \"*=\";\n+    case TOK_AMP_EQUAL:     return \"&=\";\n+    case TOK_PIPE_EQUAL:    return \"|=\";\n+\n+    case TOK_DOUBLE_EQUAL:  return \"==\";\n+    case TOK_EXCLAM_EQUAL:  return \"!=\";\n+    case TOK_GTE:    return \">=\";\n+    case TOK_LTE:    return \"<=\";\n+\n+    case TOK_DOUBLE_AMP:    return \"&&\";\n+    case TOK_DOUBLE_PIPE:   return \"||\";\n+    case TOK_DOUBLE_LT:     return \"<<\";\n+    case TOK_DOUBLE_GT:     return \">>\";\n+    case TOK_DOUBLE_LT_EQUAL:   return \"<=\";\n+    case TOK_DOUBLE_GT_EQUAL:   return \">=\";\n+\n+    case TOK_DOLLAR:    return \"$\";\n+\n+    case TOK_QMARK: return \"?\";\n+    case TOK_AT:    return \"@\";\n+    case TOK_TILDE:     return \"~\";\n+    case TOK_BACKSLASH: return \"\\\\\";\n+    case TOK_CARET:     return \"^\";\n+    case TOK_CARET_EQUAL:   return \"^=\";\n+    case TOK_BACKTICK:  return \"`\";\n+\n+    // Reserved Words\n+    case TOK_RWORD_PUB:     return \"pub\";\n+    case TOK_RWORD_PRIV:    return \"priv\";\n+    case TOK_RWORD_MUT:     return \"mut\";\n+    case TOK_RWORD_CONST:   return \"const\";\n+    case TOK_RWORD_STATIC:  return \"static\";\n+    case TOK_RWORD_UNSAFE:  return \"unsafe\";\n+    case TOK_RWORD_EXTERN:  return \"extern\";\n+\n+    case TOK_RWORD_CRATE:   return \"crate\";\n+    case TOK_RWORD_MOD:     return \"mod\";\n+    case TOK_RWORD_STRUCT:  return \"struct\";\n+    case TOK_RWORD_ENUM:    return \"enum\";\n+    case TOK_RWORD_TRAIT:   return \"trait\";\n+    case TOK_RWORD_FN:      return \"fn\";\n+    case TOK_RWORD_USE:     return \"use\";\n+    case TOK_RWORD_IMPL:    return \"impl\";\n+    case TOK_RWORD_TYPE:    return \"type\";\n+\n+    case TOK_RWORD_WHERE:   return \"where\";\n+    case TOK_RWORD_AS:      return \"as\";\n+\n+    case TOK_RWORD_LET:     return \"let\";\n+    case TOK_RWORD_MATCH:   return \"match\";\n+    case TOK_RWORD_IF:      return \"if\";\n+    case TOK_RWORD_ELSE:    return \"else\";\n+    case TOK_RWORD_LOOP:    return \"loop\";\n+    case TOK_RWORD_WHILE:   return \"while\";\n+    case TOK_RWORD_FOR:     return \"for\";\n+    case TOK_RWORD_IN:      return \"in\";\n+    case TOK_RWORD_DO:      return \"do\";\n+\n+    case TOK_RWORD_CONTINUE:return \"continue\";\n+    case TOK_RWORD_BREAK:   return \"break\";\n+    case TOK_RWORD_RETURN:  return \"return\";\n+    case TOK_RWORD_YIELD:   return \"yeild\";\n+    case TOK_RWORD_BOX:     return \"box\";\n+    case TOK_RWORD_REF:     return \"ref\";\n+\n+    case TOK_RWORD_FALSE:   return \"false\";\n+    case TOK_RWORD_TRUE:    return \"true\";\n+    case TOK_RWORD_SELF:    return \"self\";\n+    case TOK_RWORD_SUPER:   return \"super\";\n+\n+    case TOK_RWORD_PROC:    return \"proc\";\n+    case TOK_RWORD_MOVE:    return \"move\";\n+\n+    case TOK_RWORD_ABSTRACT:return \"abstract\";\n+    case TOK_RWORD_FINAL:   return \"final\";\n+    case TOK_RWORD_PURE:    return \"pure\";\n+    case TOK_RWORD_OVERRIDE:return \"override\";\n+    case TOK_RWORD_VIRTUAL: return \"virtual\";\n+\n+    case TOK_RWORD_ALIGNOF: return \"alignof\";\n+    case TOK_RWORD_OFFSETOF:return \"offsetof\";\n+    case TOK_RWORD_SIZEOF:  return \"sizeof\";\n+    case TOK_RWORD_TYPEOF:  return \"typeof\";\n+\n+    case TOK_RWORD_BE:      return \"be\";\n+    case TOK_RWORD_UNSIZED: return \"unsized\";\n+    }\n+    throw ParseError::BugCheck(\"Reached end of Token::to_str\");\n+}\n+\n+\n+::std::ostream&  operator<<(::std::ostream& os, const Token& tok)\n+{\n+    os << Token::typestr(tok.type());\n+    switch(tok.type())\n+    {\n+    case TOK_STRING:\n+    case TOK_BYTESTRING:\n+    case TOK_IDENT:\n+    case TOK_LIFETIME:\n+        if( tok.m_data.is_String() )\n+            os << \"\\\"\" << EscapedString(tok.str()) << \"\\\"\";\n+        break;\n+    case TOK_INTEGER:\n+        if( tok.m_data.is_Integer() )\n+            os << \":\" << tok.intval();\n+        break;\n+    case TOK_INTERPOLATED_TYPE:\n+        os << \":\" << *reinterpret_cast<TypeRef*>(tok.m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_PATTERN:\n+        os << \":\" << *reinterpret_cast<AST::Pattern*>(tok.m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_PATH:\n+        os << \":\" << *reinterpret_cast<AST::Path*>(tok.m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_EXPR:\n+        os << \":\" << *reinterpret_cast<AST::ExprNode*>(tok.m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_STMT:\n+        os << \":\" << *reinterpret_cast<AST::ExprNode*>(tok.m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_BLOCK:\n+        os << \":\" << *reinterpret_cast<AST::ExprNode*>(tok.m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_META:\n+        os << \":\" << *reinterpret_cast<AST::Attribute*>(tok.m_data.as_Fragment());\n+        break;\n+    case TOK_INTERPOLATED_ITEM: {\n+        const auto& named_item = *reinterpret_cast<const AST::Named<AST::Item>*>(tok.m_data.as_Fragment());\n+        os << \":\" << named_item.data.tag_str() << \"(\" << named_item.name << \")\";\n+        } break;\n+    default:\n+        break;\n+    }\n+    return os;\n+}\n+::std::ostream& operator<<(::std::ostream& os, const Position& p)\n+{\n+    return os << ::std::dec << p.filename << \":\" << p.line;\n+}\n+"}, {"sha": "af27804f1b89d446785bda5e1af0f66faec6600f", "filename": "gcc/rust/mrustc_parser/parse/token.hpp", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,158 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/token.hpp\n+ * - Lexer Tokens\n+ */\n+#pragma once\n+\n+#include \"../coretypes.hpp\"\n+#include <ident.hpp>\n+#include <memory>\n+#include <rc_string.hpp>\n+#include <tagged_union.hpp>\n+\n+enum eTokenType {\n+#define _(t) t,\n+#include \"eTokenType.enum.h\"\n+#undef _\n+};\n+\n+class Position {\n+  public:\n+    RcString filename;\n+    unsigned int line;\n+    unsigned int ofs;\n+\n+    Position()\n+      : filename(\"\")\n+      , line(0)\n+      , ofs(0) {}\n+    Position(RcString filename, unsigned int line, unsigned int ofs)\n+      : filename(filename)\n+      , line(line)\n+      , ofs(ofs) {\n+    }\n+};\n+extern ::std::ostream& operator<<(::std::ostream& os, const Position& p);\n+\n+class TypeRef;\n+class TokenTree;\n+namespace AST {\n+    class Pattern;\n+    class Path;\n+    class ExprNode;\n+    class Attribute;\n+    class Item;\n+\n+    template<typename T>\n+    struct Named;\n+};\n+\n+class InterpolatedFragment;\n+\n+class Token {\n+    friend class HirSerialiser;\n+    friend class HirDeserialiser;\n+\n+    TAGGED_UNION(Data, None, (None, struct {}), (String, ::std::string), (Integer, struct {\n+                     enum eCoreType m_datatype;\n+                     uint64_t m_intval;\n+                 }),\n+                 (Float, struct {\n+                     enum eCoreType m_datatype;\n+                     double m_floatval;\n+                 }),\n+                 (Fragment, void*));\n+\n+    enum eTokenType m_type;\n+    Data m_data;\n+    Position m_pos;\n+\n+    Token(enum eTokenType t, Data d, Position p)\n+      : m_type(t)\n+      , m_data(::std::move(d))\n+      , m_pos(::std::move(p)) {\n+    }\n+\n+  public:\n+    virtual ~Token();\n+    Token();\n+    Token& operator=(Token&& t) {\n+        m_type = t.m_type;\n+        t.m_type = TOK_NULL;\n+        m_data = ::std::move(t.m_data);\n+        m_pos = ::std::move(t.m_pos);\n+        return *this;\n+    }\n+    Token(Token&& t)\n+      : m_type(t.m_type)\n+      , m_data(::std::move(t.m_data))\n+      , m_pos(::std::move(t.m_pos)) {\n+        t.m_type = TOK_NULL;\n+    }\n+    Token(const Token& t);\n+    Token clone() const;\n+\n+    Token(enum eTokenType type);\n+    Token(enum eTokenType type, ::std::string str);\n+    Token(uint64_t val, enum eCoreType datatype);\n+    Token(double val, enum eCoreType datatype);\n+    Token(const InterpolatedFragment&);\n+    struct TagTakeIP {};\n+    Token(TagTakeIP, InterpolatedFragment);\n+\n+    enum eTokenType type() const { return m_type; }\n+    ::std::string& str() { return m_data.as_String(); }\n+    const ::std::string& str() const { return m_data.as_String(); }\n+    enum eCoreType datatype() const { \n+        TU_MATCH_DEF(Data, (m_data), (e), (assert(!\"Getting datatype of invalid token type\");), \n+        (Integer, return e.m_datatype;), (Float, return e.m_datatype;)) throw \"\"; }\n+    uint64_t intval() const { return m_data.as_Integer().m_intval; }\n+    double floatval() const { return m_data.as_Float().m_floatval; }\n+\n+    TypeRef& frag_type() {\n+        assert(m_type == TOK_INTERPOLATED_TYPE);\n+        return *reinterpret_cast<TypeRef*>(m_data.as_Fragment());\n+    }\n+    \n+    AST::Path& frag_path() {\n+        assert(m_type == TOK_INTERPOLATED_PATH);\n+        return *reinterpret_cast<AST::Path*>(m_data.as_Fragment());\n+    }\n+    \n+    AST::Pattern& frag_pattern() {\n+        assert(m_type == TOK_INTERPOLATED_PATTERN);\n+        return *reinterpret_cast<AST::Pattern*>(m_data.as_Fragment());\n+    }\n+    \n+    AST::Attribute& frag_meta() {\n+        assert(m_type == TOK_INTERPOLATED_META);\n+        return *reinterpret_cast<AST::Attribute*>(m_data.as_Fragment());\n+    }\n+    \n+    ::std::unique_ptr<AST::ExprNode> take_frag_node();\n+    ::AST::Named<AST::Item> take_frag_item();\n+\n+    bool operator==(const Token& r) const {\n+        if (type() != r.type())\n+            return false;\n+        TU_MATCH(Data, (m_data, r.m_data), (e, re), (None, return true;), (String, return e == re;), (Integer, return e.m_datatype == re.m_datatype && e.m_intval == re.m_intval;), (Float, return e.m_datatype == re.m_datatype && e.m_floatval == re.m_floatval;), (Fragment, assert(!\"Token equality on Fragment\");))\n+        throw \"\";\n+    }\n+    \n+    bool operator!=(const Token& r) const { return !(*this == r); }\n+\n+    ::std::string to_str() const;\n+\n+    void set_pos(Position pos) { m_pos = pos; }\n+    const Position& get_pos() const { return m_pos; }\n+\n+    static const char* typestr(enum eTokenType type);\n+    static eTokenType typefromstr(const ::std::string& s);\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const Token& tok);\n+};\n+\n+extern ::std::ostream& operator<<(::std::ostream& os, const Token& tok);"}, {"sha": "889c626c6477a05104f1a81dd1ba91ff86102a16", "filename": "gcc/rust/mrustc_parser/parse/tokenstream.cpp", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,153 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/tokenstream.cpp\n+ * - TokenStream - Parser token source interface\n+ */\n+#include \"tokenstream.hpp\"\n+#include <common.hpp>\n+#include \"parseerror.hpp\"\n+\n+const bool DEBUG_PRINT_TOKENS = false;\n+//const bool DEBUG_PRINT_TOKENS = true;\n+//#define DEBUG_PRINT_TOKENS  debug_enabled(\"Lexer Tokens\")\n+//#define FULL_TRACE\n+\n+TokenStream::TokenStream():\n+    m_cache_valid(false)\n+{\n+}\n+TokenStream::~TokenStream()\n+{\n+}\n+\n+Token TokenStream::innerGetToken()\n+{\n+    Token ret = this->realGetToken();\n+    if( ret != TOK_EOF && ret.get_pos().filename == \"\" )\n+        ret.set_pos( this->getPosition() );\n+    //DEBUG(\"ret.get_pos() = \" << ret.get_pos());\n+    return ret;\n+}\n+Token TokenStream::getToken()\n+{\n+    if( m_cache_valid )\n+    {\n+#ifdef FULL_TRACE\n+        DEBUG(\"<<< \" << m_cache << \" (cache)\");\n+#endif\n+        m_cache_valid = false;\n+        return mv$(m_cache);\n+    }\n+    else if( m_lookahead.size() )\n+    {\n+        Token ret = mv$( m_lookahead.front().first );\n+        m_hygiene = m_lookahead.front().second;\n+        m_lookahead.erase(m_lookahead.begin());\n+#ifdef FULL_TRACE\n+        DEBUG(\"<<< \" << ret << \" (lookahead)\");\n+#endif\n+        if( DEBUG_PRINT_TOKENS ) {\n+            ::std::cout << \"getToken[\" << typeid(*this).name() << \"] - \" << ret.get_pos() << \"-\" << ret << ::std::endl;\n+        }\n+        return ret;\n+    }\n+    else\n+    {\n+        Token ret = this->innerGetToken();\n+        m_hygiene = this->realGetHygiene();\n+#ifdef FULL_TRACE\n+        DEBUG(\"<<< \" << ret << \" (new)\");\n+#endif\n+        if( DEBUG_PRINT_TOKENS ) {\n+            ::std::cout << \"getToken[\" << typeid(*this).name() << \"] - \" << ret.get_pos() << \"-\" << ret << ::std::endl;\n+        }\n+        return ret;\n+    }\n+}\n+void TokenStream::putback(Token tok)\n+{\n+    if( m_cache_valid )\n+    {\n+        DEBUG(\"\" << getPosition() << \" - Double putback: \" << tok << \" but \" << m_cache);\n+        throw ParseError::BugCheck(\"Double putback\");\n+    }\n+    else\n+    {\n+#ifdef FULL_TRACE\n+        DEBUG(\">>> \" << tok);\n+#endif\n+        m_cache_valid = true;\n+        m_cache = mv$(tok);\n+    }\n+}\n+\n+eTokenType TokenStream::lookahead(unsigned int i)\n+{\n+    const unsigned int MAX_LOOKAHEAD = 3;\n+\n+    if( m_cache_valid )\n+    {\n+        if( i == 0 )\n+            return m_cache.type();\n+        i --;\n+    }\n+\n+    if( i >= MAX_LOOKAHEAD )\n+        throw ParseError::BugCheck(\"Excessive lookahead\");\n+\n+    while( i >= m_lookahead.size() )\n+    {\n+        DEBUG(\"lookahead - read #\" << m_lookahead.size());\n+        auto tok = this->innerGetToken();\n+        auto hygiene = this->realGetHygiene();\n+        m_lookahead.push_back( ::std::make_pair(mv$(tok), mv$(hygiene)) );\n+    }\n+\n+    DEBUG(\"lookahead(\" << i << \") = \" << m_lookahead[i]);\n+    return m_lookahead[i].first.type();\n+}\n+\n+Ident::Hygiene TokenStream::getHygiene() const\n+{\n+    return m_hygiene;\n+}\n+\n+ProtoSpan TokenStream::start_span() const\n+{\n+    auto p = this->getPosition();\n+    return ProtoSpan {\n+        p.filename,\n+        p.line, p.ofs\n+        };\n+}\n+Span TokenStream::end_span(ProtoSpan ps) const\n+{\n+    auto p = this->getPosition();\n+    auto rv = Span( ::std::move(ps.filename),  ps.start_line, ps.start_ofs,  p.line, p.ofs );\n+    rv.outer_span = this->outerSpan();\n+    return rv;\n+}\n+Span TokenStream::point_span() const\n+{\n+    Span rv = this->getPosition();\n+    rv.outer_span = this->outerSpan();\n+    return rv;\n+}\n+Ident TokenStream::get_ident(Token tok) const\n+{\n+    if(tok.type() == TOK_IDENT) {\n+        return Ident(getHygiene(), tok.str());\n+    }\n+    else if(tok.type() == TOK_LIFETIME) {\n+        // TODO: Maybe only when it's explicitly asked for?\n+        return Ident(getHygiene(), tok.str());\n+    }\n+    else if( tok.type() == TOK_INTERPOLATED_IDENT ) {\n+        TODO(getPosition(), \"get_ident from TOK_INTERPOLATED_IDENT\");\n+    }\n+    else {\n+        throw ParseError::Unexpected(*this, tok);\n+    }\n+}"}, {"sha": "a9d325c23c3015c538d71f828a9a007187e9894c", "filename": "gcc/rust/mrustc_parser/parse/tokenstream.hpp", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,105 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/tokenstream.hpp\n+ * - Parser stream (TokenStream) header\n+ */\n+#pragma once\n+\n+#include <iostream>\n+#include <vector>\n+#include <span.hpp>\n+#include <debug.hpp>\n+#include <ident.hpp>\n+#include \"token.hpp\"\n+\n+namespace AST {\n+    class Module;\n+    class AttributeList;\n+}\n+\n+/// State the parser needs to pass down via a second channel.\n+struct ParseState\n+{\n+    // Used for \"for/if/while\" to handle ambiguity\n+    bool disallow_struct_literal = false;\n+    // A debugging hook that disables expansion of macros\n+    bool no_expand_macros = false;\n+\n+    ::AST::Module*  module = nullptr;\n+    ::AST::AttributeList*   parent_attrs = nullptr;\n+\n+    ::AST::Module& get_current_mod() {\n+        assert(this->module);\n+        return *this->module;\n+    }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const ParseState& ps) {\n+        os << \"ParseState {\";\n+        if(ps.disallow_struct_literal)  os << \" disallow_struct_literal\";\n+        if(ps.no_expand_macros)  os << \" no_expand_macros\";\n+        os << \" }\";\n+        return os;\n+    }\n+};\n+\n+class TokenStream\n+{\n+    friend class TTLexer;   // needs access to internals to know what was consumed\n+\n+    bool    m_cache_valid;\n+    Token   m_cache;\n+    Ident::Hygiene  m_hygiene;\n+    ::std::vector< ::std::pair<Token, Ident::Hygiene> > m_lookahead;\n+    ParseState  m_parse_state;\n+public:\n+    TokenStream();\n+    virtual ~TokenStream();\n+    Token   getToken();\n+    void    putback(Token tok);\n+    eTokenType  lookahead(unsigned int count);\n+\n+    Ident::Hygiene getHygiene() const;\n+    virtual void push_hygine() {}\n+    virtual void pop_hygine() {}\n+\n+    ParseState& parse_state() { return m_parse_state; }\n+\n+    ProtoSpan   start_span() const;\n+    Span    end_span(ProtoSpan ps) const;\n+    Span    point_span() const;\n+\n+    Ident get_ident(Token tok) const;\n+\n+protected:\n+    virtual Position getPosition() const = 0;\n+    virtual ::std::shared_ptr<Span> outerSpan() const { return ::std::shared_ptr<Span>(0); }\n+    virtual Token   realGetToken() = 0;\n+    virtual Ident::Hygiene realGetHygiene() const = 0;\n+private:\n+    Token innerGetToken();\n+};\n+\n+class SavedParseState\n+{\n+    TokenStream&    m_lex;\n+    ParseState  m_state;\n+public:\n+    SavedParseState(TokenStream& lex, ParseState state):\n+        m_lex(lex),\n+        m_state(state)\n+    {\n+    }\n+    ~SavedParseState()\n+    {\n+        DEBUG(\"Restoring \" << m_state);\n+        m_lex.parse_state() = m_state;\n+    }\n+};\n+\n+#define SET_MODULE(lex, mod)    SavedParseState _sps(lex, lex.parse_state()); lex.parse_state().module = &(mod)\n+#define SET_ATTRS(lex, attrs)    SavedParseState _sps(lex, lex.parse_state()); lex.parse_state().parent_attrs = &(attrs)\n+#define SET_PARSE_FLAG(lex, flag)    SavedParseState _sps(lex, lex.parse_state()); lex.parse_state().flag = true\n+#define CLEAR_PARSE_FLAG(lex, flag)    SavedParseState _sps(lex, lex.parse_state()); lex.parse_state().flag = false\n+#define CHECK_PARSE_FLAG(lex, flag) (lex.parse_state().flag == true)"}, {"sha": "2d807f7d8f8cd62be5dd18bce6484e679ee2e80f", "filename": "gcc/rust/mrustc_parser/parse/tokentree.cpp", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,55 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/tokentree.cpp\n+ * - Token Tree (collection of tokens)\n+ */\n+#include \"tokentree.hpp\"\n+#include <common.hpp>\n+\n+TokenTree TokenTree::clone() const\n+{\n+    if( m_subtrees.size() == 0 ) {\n+        return TokenTree(m_hygiene, m_tok.clone());\n+    }\n+    else {\n+        ::std::vector< TokenTree>   ents;\n+        ents.reserve( m_subtrees.size() );\n+        for(const auto& sub : m_subtrees)\n+            ents.push_back( sub.clone() );\n+        return TokenTree( m_hygiene, mv$(ents) );\n+    }\n+}\n+\n+::std::ostream& operator<<(::std::ostream& os, const TokenTree& tt)\n+{\n+    if( tt.m_subtrees.size() == 0 )\n+    {\n+        switch(tt.m_tok.type())\n+        {\n+        case TOK_IDENT:\n+        case TOK_LIFETIME:\n+            os << \"/*\" << tt.m_hygiene << \"*/\";\n+            break;\n+        default:\n+            if( TOK_INTERPOLATED_IDENT <= tt.m_tok.type() && tt.m_tok.type() <= TOK_INTERPOLATED_ITEM ) {\n+                os << \"/*int*/\";\n+            }\n+            break;\n+        }\n+        return os << tt.m_tok.to_str();\n+    }\n+    else {\n+        os << \"/*\" << tt.m_hygiene << \" TT*/\";\n+        // NOTE: All TTs (except the outer tt on a macro invocation) include the grouping\n+        bool first = true;\n+        for(const auto& i : tt.m_subtrees) {\n+            if(!first)\n+                os << \" \";\n+            os << i;\n+            first = false;\n+        }\n+        return os;\n+    }\n+}"}, {"sha": "3d6e63deef3c952da772243f072ed29a594a7a6e", "filename": "gcc/rust/mrustc_parser/parse/tokentree.hpp", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,61 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/tokentree.hpp\n+ * - Token Trees (groups of tokens\n+ */\n+#ifndef TOKENTREE_HPP_INCLUDED\n+#define TOKENTREE_HPP_INCLUDED\n+\n+#include \"token.hpp\"\n+#include <ident.hpp>\n+#include <vector>\n+\n+class TokenTree\n+{\n+    Ident::Hygiene m_hygiene;\n+    Token   m_tok;\n+    ::std::vector<TokenTree>    m_subtrees;\n+public:\n+    virtual ~TokenTree() {}\n+    TokenTree() {}\n+    TokenTree(TokenTree&&) = default;\n+    TokenTree& operator=(TokenTree&&) = default;\n+    TokenTree(enum eTokenType ty):\n+        m_tok( Token(ty) )\n+    {\n+    }\n+    TokenTree(Token tok):\n+        m_tok( ::std::move(tok) )\n+    {\n+    }\n+    TokenTree(Ident::Hygiene hygiene, Token tok):\n+        m_hygiene( ::std::move(hygiene) ),\n+        m_tok( ::std::move(tok) )\n+    {\n+    }\n+    TokenTree(Ident::Hygiene hygiene, ::std::vector<TokenTree> subtrees):\n+        m_hygiene( ::std::move(hygiene) ),\n+        m_subtrees( ::std::move(subtrees) )\n+    {\n+    }\n+\n+    TokenTree clone() const;\n+\n+    bool is_token() const {\n+        return m_tok.type() != TOK_NULL;\n+    }\n+    unsigned int size() const {\n+        return m_subtrees.size();\n+    }\n+    const TokenTree& operator[](unsigned int idx) const { assert(idx < m_subtrees.size()); return m_subtrees[idx]; }\n+          TokenTree& operator[](unsigned int idx)       { assert(idx < m_subtrees.size()); return m_subtrees[idx]; }\n+    const Token& tok() const { return m_tok; }\n+          Token& tok()       { return m_tok; }\n+    const Ident::Hygiene& hygiene() const { return m_hygiene; }\n+\n+    friend ::std::ostream& operator<<(::std::ostream& os, const TokenTree& tt);\n+};\n+\n+#endif // TOKENTREE_HPP_INCLUDED"}, {"sha": "32c9a90ac19546b7dc8e3b62b6f434f24c7ddfef", "filename": "gcc/rust/mrustc_parser/parse/ttstream.cpp", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,121 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/ttstream.cpp\n+ * - Token-Tree backed token streams\n+ */\n+#include \"ttstream.hpp\"\n+#include <common.hpp>\n+\n+TTStream::TTStream(Span parent, const TokenTree& input_tt):\n+    m_parent_span( new Span(mv$(parent)) )\n+{\n+    DEBUG(\"input_tt = [\" << input_tt << \"]\");\n+    m_stack.push_back( ::std::make_pair(0, &input_tt) );\n+}\n+TTStream::~TTStream()\n+{\n+}\n+Token TTStream::realGetToken()\n+{\n+    while(m_stack.size() > 0)\n+    {\n+        // If current index is above TT size, go up\n+        unsigned int& idx = m_stack.back().first;\n+        assert( m_stack.back().second );\n+        const TokenTree& tree = *m_stack.back().second;\n+\n+        if(idx == 0 && tree.is_token()) {\n+            idx ++;\n+            m_hygiene_ptr = &tree.hygiene();\n+            return tree.tok();\n+        }\n+\n+        if(idx < tree.size())\n+        {\n+            const TokenTree&    subtree = tree[idx];\n+            idx ++;\n+            if( subtree.size() == 0 ) {\n+                m_hygiene_ptr = &subtree.hygiene();\n+                return subtree.tok().clone();\n+            }\n+            else {\n+                m_stack.push_back( ::std::make_pair(0, &subtree) );\n+            }\n+        }\n+        else {\n+            m_stack.pop_back();\n+        }\n+    }\n+    //m_hygiene = nullptr;\n+    return Token(TOK_EOF);\n+}\n+Position TTStream::getPosition() const\n+{\n+    // TODO: Position associated with the previous/next token?\n+    return Position(\"TTStream\", 0,0);\n+}\n+Ident::Hygiene TTStream::realGetHygiene() const\n+{\n+    // Empty.\n+    if(!m_hygiene_ptr)\n+        return Ident::Hygiene();\n+    return *m_hygiene_ptr;\n+}\n+\n+\n+TTStreamO::TTStreamO(Span parent, TokenTree input_tt):\n+    m_input_tt( mv$(input_tt) ),\n+    m_parent_span( new Span(mv$(parent)) )\n+{\n+    m_stack.push_back( ::std::make_pair(0, nullptr) );\n+}\n+TTStreamO::~TTStreamO()\n+{\n+}\n+Token TTStreamO::realGetToken()\n+{\n+    while(m_stack.size() > 0)\n+    {\n+        // If current index is above TT size, go up\n+        unsigned int& idx = m_stack.back().first;\n+        TokenTree& tree = (m_stack.back().second ? *m_stack.back().second : m_input_tt);\n+\n+        if(idx == 0 && tree.is_token()) {\n+            idx ++;\n+            m_last_pos = tree.tok().get_pos();\n+            m_hygiene_ptr = &tree.hygiene();\n+            return mv$(tree.tok());\n+        }\n+\n+        if(idx < tree.size())\n+        {\n+            TokenTree& subtree = tree[idx];\n+            idx ++;\n+            if( subtree.size() == 0 ) {\n+                m_last_pos = subtree.tok().get_pos();\n+                m_hygiene_ptr = &subtree.hygiene();\n+                return mv$( subtree.tok() );\n+            }\n+            else {\n+                m_stack.push_back( ::std::make_pair(0, &subtree) );\n+            }\n+        }\n+        else {\n+            m_stack.pop_back();\n+        }\n+    }\n+    return Token(TOK_EOF);\n+}\n+Position TTStreamO::getPosition() const\n+{\n+    return m_last_pos;\n+}\n+Ident::Hygiene TTStreamO::realGetHygiene() const\n+{\n+    // Empty.\n+    if(!m_hygiene_ptr)\n+        return Ident::Hygiene();\n+    return *m_hygiene_ptr;\n+}"}, {"sha": "530a177bef395b09c177a6783a5feefbfb512cb0", "filename": "gcc/rust/mrustc_parser/parse/ttstream.hpp", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.hpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,57 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/ttstrea.hpp\n+ * - Token tree streams (for post-lex parsing)\n+ */\n+#pragma once\n+\n+#include \"tokentree.hpp\"\n+#include \"tokenstream.hpp\"\n+\n+/// Borrowed TTStream\n+class TTStream:\n+    public TokenStream\n+{\n+    ::std::vector< ::std::pair<unsigned int, const TokenTree*> > m_stack;\n+    ::std::shared_ptr<Span> m_parent_span;\n+    const Ident::Hygiene*   m_hygiene_ptr = nullptr;\n+public:\n+    TTStream(Span parent, const TokenTree& input_tt);\n+    ~TTStream();\n+\n+    TTStream& operator=(const TTStream& x) { m_stack = x.m_stack; return *this; }\n+\n+    Position getPosition() const override;\n+    ::std::shared_ptr<Span> outerSpan() const override { return m_parent_span; }\n+\n+protected:\n+    Ident::Hygiene realGetHygiene() const override;\n+    Token realGetToken() override;\n+};\n+\n+/// Owned TTStream\n+class TTStreamO:\n+    public TokenStream\n+{\n+    Position    m_last_pos;\n+    TokenTree   m_input_tt;\n+    ::std::vector< ::std::pair<unsigned int, TokenTree*> > m_stack;\n+    const Ident::Hygiene*   m_hygiene_ptr = nullptr;\n+public:\n+    ::std::shared_ptr<Span> m_parent_span;\n+    TTStreamO(Span parent, TokenTree input_tt);\n+    TTStreamO(TTStreamO&& x) = default;\n+    ~TTStreamO();\n+\n+    TTStreamO& operator=(const TTStreamO& x) { m_stack = x.m_stack; return *this; }\n+    TTStreamO& operator=(TTStreamO&& x) = default;\n+\n+    Position getPosition() const override;\n+    ::std::shared_ptr<Span> outerSpan() const override { return m_parent_span; }\n+\n+protected:\n+    Ident::Hygiene realGetHygiene() const override;\n+    Token realGetToken() override;\n+};"}, {"sha": "ca5b78923c44b307f967071ef4a8cb62c1858835", "filename": "gcc/rust/mrustc_parser/parse/types.cpp", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftypes.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftypes.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftypes.cpp?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,340 @@\n+/*\n+ * MRustC - Rust Compiler\n+ * - By John Hodge (Mutabah/thePowersGang)\n+ *\n+ * parse/types.cpp\n+ * - Parsing for type usages\n+ */\n+#include \"common.hpp\"\n+#include \"parseerror.hpp\"\n+#include <ast/types.hpp>\n+#include <ast/ast.hpp>\n+\n+// === PROTOTYPES ===\n+//TypeRef Parse_Type(TokenStream& lex, bool allow_trait_list);\n+TypeRef Parse_Type_Int(TokenStream& lex, bool allow_trait_list);\n+TypeRef Parse_Type_Fn(TokenStream& lex, AST::HigherRankedBounds hrbs = {});\n+TypeRef Parse_Type_Path(TokenStream& lex, AST::HigherRankedBounds hrbs, bool allow_trait_list);\n+TypeRef Parse_Type_ErasedType(TokenStream& lex, bool allow_trait_list);\n+\n+// === CODE ===\n+TypeRef Parse_Type(TokenStream& lex, bool allow_trait_list)\n+{\n+    ProtoSpan ps = lex.start_span();\n+    TypeRef rv = Parse_Type_Int(lex, allow_trait_list);\n+    //rv.set_span(lex.end_span(ps));\n+    return rv;\n+}\n+\n+TypeRef Parse_Type_Int(TokenStream& lex, bool allow_trait_list)\n+{\n+    //TRACE_FUNCTION;\n+    auto ps = lex.start_span();\n+\n+    Token tok;\n+\n+    switch( GET_TOK(tok, lex) )\n+    {\n+    case TOK_INTERPOLATED_TYPE:\n+        return mv$(tok.frag_type());\n+    // '!' - Only ever used as part of function prototypes, but is kinda a type... not allowed here though\n+    case TOK_EXCLAM:\n+        return TypeRef( Span(tok.get_pos()), TypeData::make_Bang({}) );\n+    // '_' = Wildcard (type inferrence variable)\n+    case TOK_UNDERSCORE:\n+        return TypeRef(Span(tok.get_pos()));\n+\n+    // 'unsafe' - An unsafe function type\n+    case TOK_RWORD_UNSAFE:\n+    // 'extern' - A function type with an ABI\n+    case TOK_RWORD_EXTERN:\n+    // 'fn' - Rust function\n+    case TOK_RWORD_FN:\n+        PUTBACK(tok, lex);\n+        return Parse_Type_Fn(lex);\n+\n+    case TOK_RWORD_IMPL:\n+        return Parse_Type_ErasedType(lex, allow_trait_list);\n+\n+    // '<' - An associated type cast\n+    case TOK_LT:\n+    case TOK_DOUBLE_LT: {\n+        PUTBACK(tok, lex);\n+        auto path = Parse_Path(lex, PATH_GENERIC_TYPE);\n+        return TypeRef(TypeRef::TagPath(), lex.end_span(mv$(ps)), mv$(path));\n+        }\n+    //\n+    case TOK_RWORD_FOR: {\n+        auto hrls = Parse_HRB(lex);\n+        switch(LOOK_AHEAD(lex))\n+        {\n+        case TOK_RWORD_UNSAFE:\n+        case TOK_RWORD_EXTERN:\n+        case TOK_RWORD_FN:\n+            return Parse_Type_Fn(lex, hrls);\n+        default:\n+            return Parse_Type_Path(lex, hrls, true);\n+        }\n+        }\n+    // <ident> - Either a primitive, or a path\n+    case TOK_IDENT:\n+        if( lex.lookahead(0) == TOK_EXCLAM )\n+        {\n+            lex.getToken();\n+            // TODO: path macros\n+            return TypeRef(TypeRef::TagMacro(), Parse_MacroInvocation(ps, mv$(tok.str()), lex));\n+        }\n+        // or a primitive\n+        //if( auto ct = coretype_fromstring(tok.str()) )\n+        //{\n+        //    return TypeRef(TypeRef::TagPrimitive(), Span(tok.get_pos()), ct);\n+        //}\n+        PUTBACK(tok, lex);\n+        return Parse_Type_Path(lex, {}, allow_trait_list);\n+        // - Fall through to path handling\n+    // '::' - Absolute path\n+    case TOK_DOUBLE_COLON:\n+    // 'self' - This relative path\n+    case TOK_RWORD_SELF:\n+    // 'super' - Parent relative path\n+    case TOK_RWORD_SUPER:\n+    // ':path' fragment\n+    case TOK_INTERPOLATED_PATH:\n+        PUTBACK(tok, lex);\n+        return Parse_Type_Path(lex, {}, allow_trait_list);\n+\n+    // HACK! Convert && into & &\n+    case TOK_DOUBLE_AMP:\n+        lex.putback(Token(TOK_AMP));\n+    // '&' - Reference type\n+    case TOK_AMP: {\n+        AST::LifetimeRef lifetime;\n+        // Reference\n+        tok = lex.getToken();\n+        if( tok.type() == TOK_LIFETIME ) {\n+            lifetime = AST::LifetimeRef(/*lex.point_span(), */lex.get_ident(::std::move(tok)));\n+            tok = lex.getToken();\n+        }\n+        bool is_mut = false;\n+        if( tok.type() == TOK_RWORD_MUT ) {\n+            is_mut = true;\n+        }\n+        else {\n+            PUTBACK(tok, lex);\n+        }\n+        return TypeRef(TypeRef::TagReference(), lex.end_span(mv$(ps)), ::std::move(lifetime), is_mut, Parse_Type(lex, false));\n+        }\n+    // '*' - Raw pointer\n+    case TOK_STAR:\n+        // Pointer\n+        switch( GET_TOK(tok, lex) )\n+        {\n+        case TOK_RWORD_MUT:\n+            // Mutable pointer\n+            return TypeRef(TypeRef::TagPointer(), lex.end_span(mv$(ps)), true, Parse_Type(lex, false));\n+        case TOK_RWORD_CONST:\n+            // Immutable pointer\n+            return TypeRef(TypeRef::TagPointer(), lex.end_span(mv$(ps)), false, Parse_Type(lex, false));\n+        default:\n+            throw ParseError::Unexpected(lex, tok, {TOK_RWORD_CONST, TOK_RWORD_MUT});\n+        }\n+        throw ParseError::BugCheck(\"Reached end of Parse_Type:STAR\");\n+    // '[' - Array type\n+    case TOK_SQUARE_OPEN: {\n+        // Array\n+        TypeRef inner = Parse_Type(lex);\n+        if( GET_TOK(tok, lex)  == TOK_SEMICOLON ) {\n+            // Sized array\n+            AST::Expr array_size = Parse_Expr(lex);\n+            GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n+            return TypeRef(TypeRef::TagSizedArray(), lex.end_span(mv$(ps)), mv$(inner), array_size.take_node());\n+        }\n+        else if( tok.type() == TOK_SQUARE_CLOSE )\n+        {\n+            return TypeRef(TypeRef::TagUnsizedArray(), lex.end_span(mv$(ps)), mv$(inner));\n+        }\n+        else {\n+            throw ParseError::Unexpected(lex, tok/*, \"; or ]\"*/);\n+        }\n+        }\n+\n+    // '(' - Tuple (or lifetime bounded trait)\n+    case TOK_PAREN_OPEN: {\n+        DEBUG(\"Tuple\");\n+        if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n+            return TypeRef(TypeRef::TagTuple(), lex.end_span(mv$(ps)), {});\n+        PUTBACK(tok, lex);\n+\n+        TypeRef inner = Parse_Type(lex, true);\n+        if( LOOK_AHEAD(lex) == TOK_PAREN_CLOSE )\n+        {\n+            // Type in parens, NOT a tuple\n+            GET_CHECK_TOK(tok, lex, TOK_PAREN_CLOSE);\n+            return inner;\n+        }\n+        else\n+        {\n+            ::std::vector<TypeRef>  types;\n+            types.push_back( mv$(inner) );\n+            while( GET_TOK(tok, lex) == TOK_COMMA )\n+            {\n+                if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n+                    break;\n+                else\n+                    PUTBACK(tok, lex);\n+                types.push_back( Parse_Type(lex) );\n+            }\n+            CHECK_TOK(tok, TOK_PAREN_CLOSE);\n+            return TypeRef(TypeRef::TagTuple(), lex.end_span(mv$(ps)), mv$(types)); }\n+        }\n+    default:\n+        throw ParseError::Unexpected(lex, tok);\n+    }\n+    throw ParseError::BugCheck(\"Reached end of Parse_Type\");\n+}\n+\n+TypeRef Parse_Type_Fn(TokenStream& lex, ::AST::HigherRankedBounds hrbs)\n+{\n+    auto ps = lex.start_span();\n+    TRACE_FUNCTION;\n+    Token   tok;\n+\n+    ::std::string   abi = \"\";\n+    bool    is_unsafe = false;\n+\n+    GET_TOK(tok, lex);\n+\n+    // `unsafe`\n+    if( tok.type() == TOK_RWORD_UNSAFE )\n+    {\n+        is_unsafe = true;\n+        GET_TOK(tok, lex);\n+    }\n+    // `exern`\n+    if( tok.type() == TOK_RWORD_EXTERN )\n+    {\n+        if( GET_TOK(tok, lex) == TOK_STRING ) {\n+            abi = tok.str();\n+            if( abi == \"\" )\n+                ERROR(lex.point_span(), E0000, \"Empty ABI\");\n+            GET_TOK(tok, lex);\n+        }\n+        else {\n+            abi = \"C\";\n+        }\n+    }\n+    // `fn`\n+    CHECK_TOK(tok, TOK_RWORD_FN);\n+\n+    ::std::vector<TypeRef>  args;\n+    bool is_variadic = false;\n+    GET_CHECK_TOK(tok, lex, TOK_PAREN_OPEN);\n+    while( LOOK_AHEAD(lex) != TOK_PAREN_CLOSE )\n+    {\n+        if( LOOK_AHEAD(lex) == TOK_TRIPLE_DOT ) {\n+            GET_TOK(tok, lex);\n+            is_variadic = true;\n+            break;\n+        }\n+        // Handle `ident: `\n+        if( (lex.lookahead(0) == TOK_IDENT || lex.lookahead(0) == TOK_UNDERSCORE) && lex.lookahead(1) == TOK_COLON ) {\n+            GET_TOK(tok, lex);\n+            GET_TOK(tok, lex);\n+        }\n+        args.push_back( Parse_Type(lex) );\n+        if( GET_TOK(tok, lex) != TOK_COMMA ) {\n+            PUTBACK(tok, lex);\n+            break;\n+        }\n+    }\n+    GET_CHECK_TOK(tok, lex, TOK_PAREN_CLOSE);\n+\n+    // `-> RetType`\n+    TypeRef ret_type = TypeRef(TypeRef::TagUnit(), Span(tok.get_pos()));\n+    if( GET_TOK(tok, lex) == TOK_THINARROW )\n+    {\n+        ret_type = Parse_Type(lex, false);\n+    }\n+    else {\n+        PUTBACK(tok, lex);\n+    }\n+\n+    return TypeRef(TypeRef::TagFunction(), lex.end_span(mv$(ps)), mv$(hrbs), is_unsafe, mv$(abi), mv$(args), is_variadic, mv$(ret_type));\n+}\n+\n+TypeRef Parse_Type_Path(TokenStream& lex, ::AST::HigherRankedBounds hrbs, bool allow_trait_list)\n+{\n+    Token   tok;\n+\n+    auto ps = lex.start_span();\n+\n+    if( hrbs.empty() && !allow_trait_list )\n+    {\n+        return TypeRef(TypeRef::TagPath(), lex.end_span(mv$(ps)), Parse_Path(lex, PATH_GENERIC_TYPE));\n+    }\n+    else\n+    {\n+        ::std::vector<Type_TraitPath>   traits;\n+        ::std::vector<AST::LifetimeRef> lifetimes;\n+\n+        traits.push_back(Type_TraitPath { mv$(hrbs), Parse_Path(lex, PATH_GENERIC_TYPE) });\n+\n+        if( allow_trait_list )\n+        {\n+            while( GET_TOK(tok, lex) == TOK_PLUS )\n+            {\n+                if( LOOK_AHEAD(lex) == TOK_LIFETIME ) {\n+                    GET_TOK(tok, lex);\n+                    lifetimes.push_back(AST::LifetimeRef( /*lex.point_span(),*/ lex.get_ident(mv$(tok)) ));\n+                }\n+                else\n+                {\n+                    if( lex.lookahead(0) == TOK_RWORD_FOR )\n+                    {\n+                        hrbs = Parse_HRB(lex);\n+                    }\n+                    traits.push_back({ mv$(hrbs), Parse_Path(lex, PATH_GENERIC_TYPE) });\n+                }\n+            }\n+            PUTBACK(tok, lex);\n+        }\n+\n+        if( !traits[0].hrbs.empty() || traits.size() > 1 || lifetimes.size() > 0 )\n+        {\n+            if( lifetimes.empty())\n+                lifetimes.push_back(AST::LifetimeRef());\n+            return TypeRef(lex.end_span(mv$(ps)), mv$(traits), mv$(lifetimes));\n+        }\n+        else\n+        {\n+            return TypeRef(TypeRef::TagPath(), lex.end_span(mv$(ps)), mv$(traits.at(0).path));\n+        }\n+    }\n+}\n+TypeRef Parse_Type_ErasedType(TokenStream& lex, bool allow_trait_list)\n+{\n+    Token   tok;\n+\n+    auto ps = lex.start_span();\n+    ::std::vector<Type_TraitPath>   traits;\n+    ::std::vector<AST::LifetimeRef>   lifetimes;\n+    do {\n+        if( LOOK_AHEAD(lex) == TOK_LIFETIME ) {\n+            GET_TOK(tok, lex);\n+            lifetimes.push_back(AST::LifetimeRef( /*lex.point_span(),*/ lex.get_ident(mv$(tok)) ));\n+        }\n+        else\n+        {\n+            AST::HigherRankedBounds hrbs;\n+            if( lex.lookahead(0) == TOK_RWORD_FOR )\n+            {\n+                hrbs = Parse_HRB(lex);\n+            }\n+            traits.push_back({ mv$(hrbs), Parse_Path(lex, PATH_GENERIC_TYPE) });\n+        }\n+    } while( GET_TOK(tok, lex) == TOK_PLUS );\n+    PUTBACK(tok, lex);\n+\n+    return TypeRef(lex.end_span(mv$(ps)), TypeData::make_ErasedType({ mv$(traits), mv$(lifetimes) }));\n+}\n+"}, {"sha": "7ac9301ca1986dd20853ea6505c8677b8f980156", "filename": "gcc/rust/old/lang-specs.h", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Flang-specs.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,19 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+{\".rs\",  \"@rs\", 0, 1, 0},\n+{\"@rs\",  \"grs1 %i %(cc1_options) %{I*} %{L*} %D %{!fsyntax-only:%(invoke_as)}\",\n+    0, 1, 0},"}, {"sha": "575222a6e9a0e0850a65ed331fa1a7a737e5b0fd", "filename": "gcc/rust/old/rdot-dataflow.cc", "status": "added", "additions": 773, "deletions": 0, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-dataflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-dataflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-dataflow.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,773 @@\n+/* This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"rust.h\"\n+\n+static std::vector<std::map<std::string, rdot>*> context;\n+static rdot dot_pass_typeifyExprNode(rdot);\n+static bool dot_pass_typeCompare(const rdot, const rdot);\n+static rdot impl_master = NULL_DOT;\n+\n+// Seems to push a new empty map onto the \"context\" vector\n+static void dot_pass_dataFlow_pushCtx(void) {\n+    std::map<std::string, rdot>* ctx = new std::map<std::string, rdot>;\n+    context.push_back(ctx);\n+}\n+\n+// Seems to pop the map off of the end of the \"context\" vector (i.e. deletes it)\n+static void dot_pass_dataFlow_popCtx(void) {\n+    std::map<std::string, rdot>* ctx = context.back();\n+    context.pop_back();\n+    delete ctx;\n+}\n+\n+// Presumably looks up id in the context map somehow, and returns the value\n+static rdot dot_pass_dataFlow_lookup(const char* id) {\n+    rdot retval = NULL_DOT;\n+    std::vector<std::map<std::string, rdot>*>::reverse_iterator it;\n+    for (it = context.rbegin(); it != context.rend(); ++it) {\n+        std::map<std::string, rdot>* ctx = *it;\n+        if (ctx->count(std::string(id))) {\n+            retval = (*ctx)[std::string(id)];\n+            break;\n+        }\n+    }\n+    return retval;\n+}\n+\n+// Appends node to the back of context? Or replaces final context with node?\n+static bool dot_pass_dataFlow_pushDecl(rdot node, const char* id) {\n+    rdot check = dot_pass_dataFlow_lookup(id);\n+    if (check != NULL_DOT) {\n+        error(\"DataFlow duplicate declaration [%s]\\n\", id);\n+        return true;\n+    }\n+\n+    bool retval = false;\n+    if ((RDOT_TYPE(node) == D_VAR_DECL) || (RDOT_TYPE(node) == D_STRUCT_METHOD) \n+      || (RDOT_TYPE(node) == D_STRUCT_TYPE)) {\n+        std::map<std::string, rdot>* ctx = context.back();\n+        (*ctx)[std::string(id)] = node;\n+    } else {\n+        error(\"Invalid dataflow declaration pushing to context [%s]\\n\",\n+              RDOT_OPCODE_STR(node));\n+        retval = true;\n+    }\n+    return retval;\n+}\n+\n+static void dot_pass_dataFlowToplevel(rdot);\n+static void dot_pass_dataFlowFunction(rdot);\n+static void dot_pass_dataFlowBlock(rdot);\n+\n+// Only returns true if node's type is boolean, int, float, or unsigned int\n+static bool verifyType(rdot node) {\n+    bool retval = false;\n+    switch (RDOT_TYPE(node)) {\n+        case RTYPE_BOOL:\n+        case RTYPE_INT:\n+        case RTYPE_FLOAT:\n+        case RTYPE_UINT:\n+            retval = true;\n+            break;\n+\n+        default:\n+            break;\n+    }\n+    return retval;\n+}\n+\n+// Presumably returns the variable declaration contained in the node \n+static rdot dot_pass_dataFlow_getDecl(rdot node) {\n+    rdot retval = NULL_DOT;\n+    if (RDOT_T_FIELD(node) == D_D_EXPR) {\n+        // only if its a modify expr\n+        if (RDOT_TYPE(node) == D_MODIFY_EXPR) {\n+            rdot decl = RDOT_lhs_TT(node);\n+            if (RDOT_TYPE(decl) == D_VAR_DECL)\n+                retval = decl;\n+        } else if (RDOT_TYPE(node) == D_VAR_DECL)\n+            retval = node;\n+    }\n+    return retval;\n+}\n+\n+// Seems to add return values to retval vector? Finds return values?\n+static void dot_pass_dataFlowBlock_retvals(rdot suite, std::vector<rdot>* retval) {\n+    rdot next;\n+    for (next = suite; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+        if (RDOT_T_FIELD(next) == D_D_EXPR) {\n+            if (DOT_RETVAL(next))\n+                retval->push_back(next);\n+        } else {\n+            switch (RDOT_TYPE(next)) {\n+                case D_STRUCT_WHILE:\n+                    dot_pass_dataFlowBlock_retvals(RDOT_rhs_TT(next), retval);\n+                    break;\n+\n+                case D_STRUCT_IF: {\n+                    rdot ifblock = RDOT_lhs_TT(next);\n+                    rdot elseblock = RDOT_rhs_TT(next);\n+                    dot_pass_dataFlowBlock_retvals(RDOT_rhs_TT(ifblock), retval);\n+                    if (elseblock != NULL_DOT)\n+                        dot_pass_dataFlowBlock_retvals(RDOT_lhs_TT(elseblock), retval);\n+                } break;\n+\n+                default:\n+                    error(\"unable to figure out what to do with [%s]\",\n+                          RDOT_OPCODE_STR(next));\n+                    break;\n+            }\n+        }\n+    }\n+}\n+\n+/*\n+  Takes a var_decl and returns the rhs of assignment to try and infer a type on.\n+  eg1 :\n+  let x;\n+  x = 1 + 2\n+  will return the NULL on the decl and RDOT (1+2) on the expression\n+\n+  eg2:\n+  let x = 1;\n+  ruturns RDOT (1)\n+*/\n+static rdot dot_pass_dataFlow_getRef(rdot decl, rdot var_decl) {\n+    rdot retval = NULL_DOT;\n+    if (RDOT_TYPE(decl) == D_MODIFY_EXPR) {\n+        rdot lhs = RDOT_lhs_TT(decl);\n+        rdot rhs = RDOT_rhs_TT(decl);\n+\n+        switch (RDOT_TYPE(lhs)) {\n+            case D_VAR_DECL: {\n+                if (var_decl == lhs)\n+                    retval = rhs;\n+            } break;\n+\n+            case D_IDENTIFIER: {\n+                const char* vid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(var_decl));\n+                const char* cid = RDOT_IDENTIFIER_POINTER(lhs);\n+                // we found a reference assignment...\n+                if (strcmp(vid, cid) == 0)\n+                    retval = rhs;\n+            } break;\n+\n+            default:\n+                break;\n+        }\n+    }\n+    return retval;\n+}\n+\n+// Seems to be a more complicated version of getRef that can also get references in other places\n+static std::vector<rdot>* dot_pass_getReferences(rdot vDecl, rdot suite) {\n+    std::vector<rdot>* retval = new std::vector<rdot>;\n+    rdot node;\n+    for (node = suite; node != NULL_DOT; node = RDOT_CHAIN(node)) {\n+        switch (RDOT_TYPE(node)) {\n+            case D_PRIMITIVE:\n+            case D_CALL_EXPR:\n+            case D_ATTRIB_REF:\n+                break;\n+\n+            case D_MODIFY_EXPR: {\n+                rdot ref = dot_pass_dataFlow_getRef(node, vDecl);\n+                if (ref != NULL_DOT)\n+                    retval->push_back(ref);\n+            } break;\n+\n+            case D_STRUCT_WHILE: {\n+                rdot wsuite = RDOT_rhs_TT(node);\n+                std::vector<rdot>* refs = dot_pass_getReferences(vDecl, wsuite);\n+                // append to the list\n+                std::vector<rdot>::iterator it;\n+                for (it = refs->begin(); it != refs->end(); ++it)\n+                    retval->push_back(*it);\n+                delete refs;\n+            } break;\n+\n+            case D_STRUCT_IF: {\n+                rdot ifb = RDOT_lhs_TT(node);\n+                rdot elb = RDOT_rhs_TT(node);\n+\n+                rdot ifsuite = RDOT_rhs_TT(ifb);\n+                std::vector<rdot>* refs = dot_pass_getReferences(vDecl, ifsuite);\n+\n+                // append to the list\n+                std::vector<rdot>::iterator it;\n+                for (it = refs->begin(); it != refs->end(); ++it)\n+                    retval->push_back(*it);\n+                delete refs;\n+\n+                if (elb != NULL_DOT) {\n+                    refs = dot_pass_getReferences(vDecl, RDOT_lhs_TT(elb));\n+                    for (it = refs->begin(); it != refs->end(); ++it)\n+                        retval->push_back(*it);\n+                    delete refs;\n+                }\n+            }\n+\n+            default:\n+                break;\n+        }\n+    }\n+    return retval;\n+}\n+\n+// Seems to compare types of x and y\n+static bool dot_pass_typeCompare(const rdot x, const rdot y) {\n+    bool retval = false;\n+    if (RDOT_TYPE(x) == RDOT_TYPE(y))\n+        if (RDOT_MEM_MODIFIER(x)->size() == RDOT_MEM_MODIFIER(y)->size()) {\n+            retval = true;\n+            std::vector<ALLOCA_>::iterator xit;\n+            std::vector<ALLOCA_>::iterator yit;\n+            for (xit = RDOT_MEM_MODIFIER(x)->begin(),\n+                yit = RDOT_MEM_MODIFIER(y)->begin();\n+                 xit != RDOT_MEM_MODIFIER(x)->end();\n+                 ++xit, ++yit) {\n+                if (*xit != *yit) {\n+                    retval = false;\n+                    break;\n+                }\n+            }\n+        }\n+    return retval;\n+}\n+\n+// Seems to return a string created from allocations (dereference and reference)\n+static char* dot_pass_typeString(const rdot node) {\n+    char buffer[128];\n+    size_t offset = 0;\n+\n+    std::vector<ALLOCA_>::iterator it;\n+    for (it = RDOT_MEM_MODIFIER(node)->begin();\n+         it != RDOT_MEM_MODIFIER(node)->end();\n+         ++it) {\n+        switch (*it) {\n+            case ALLOC_DEREF:\n+                buffer[offset++] = '*';\n+                break;\n+            case ALLOC_HEAP:\n+                buffer[offset++] = '~';\n+                break;\n+            case ALLOC_REF:\n+                buffer[offset++] = '&';\n+                break;\n+        }\n+    }\n+    strcpy(buffer + offset, RDOT_OPCODE_STR(node));\n+    return xstrdup(buffer);\n+}\n+\n+/**\n+ * WARN:\n+ *   This really needs more analysis on why, if you have : infered something has:\n+ *   infer, int, string\n+ *   infer, int, infer. Does it mean its an int probably.\n+ *   Currently it drops any possible type to be an int\n+ * \n+ * Presumably infers type of refs\n+ **/\n+static rdot dot_pass_inferTheType(std::vector<rdot>* refs, const char* id) {\n+    rdot retval = NULL_DOT;\n+    rdot _retval = rdot_build_decl1(RTYPE_INFER, NULL_DOT);\n+    gcc_assert(refs->size() > 0);\n+\n+    std::vector<rdot> possible_types;\n+    std::vector<rdot>::iterator it;\n+    for (it = refs->begin(); it != refs->end(); ++it) {\n+        rdot pos = dot_pass_typeifyExprNode(*it);\n+        if (RDOT_TYPE(pos) != RTYPE_INFER)\n+            possible_types.push_back(pos);\n+    }\n+\n+    if (possible_types.size() == 0)\n+        retval = _retval;\n+    else {\n+        bool first = true;\n+        std::vector<rdot>::iterator pit;\n+        for (pit = possible_types.begin(); pit != possible_types.end(); ++pit) {\n+            if (first == true) {\n+                retval = *pit;\n+                first = false;\n+            }\n+            if (!dot_pass_typeCompare(retval, *pit)) {\n+                char* t1 = dot_pass_typeString(retval);\n+                char* t2 = dot_pass_typeString(*pit);\n+                error(\"Ambigious types found for [%s] -> [%s] OR [%s]\", id, t1, t2);\n+                retval = _retval;\n+                free(t1);\n+                free(t2);\n+                break;\n+            }\n+        }\n+    }\n+    return retval;\n+}\n+\n+// Seems to determine the type of a primitive (and apply it)?\n+static rdot dot_pass_typeifyPrimitive(rdot node) {\n+    rdot retval = rdot_build_decl1(RTYPE_INFER, NULL_DOT);\n+    gcc_assert(RDOT_TYPE(node) == D_PRIMITIVE);\n+\n+    switch (node->opa.tc.T == D_T_INTEGER) {\n+        case D_T_INTEGER:\n+            RDOT_TYPE(retval) = RTYPE_INT;\n+            break;\n+\n+        default:\n+            error(\"Unable to figure out type for this primitive [%s]!\",\n+                  RDOT_CODE_STR(node->opa.tc.T));\n+            break;\n+    }\n+    std::vector<ALLOCA_>::iterator it;\n+    for (it = RDOT_MEM_MODIFIER(node)->begin();\n+         it != RDOT_MEM_MODIFIER(node)->end();\n+         ++it)\n+        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n+    return retval;\n+}\n+\n+/* FIXME maybe i feel this isn't done very well at all here \n+ *\n+ * Seems to determine type of an expression node and return something idk, very complicated */\n+static rdot dot_pass_typeifyExprNode(rdot node) {\n+    rdot retval = rdot_build_decl1(RTYPE_INFER, NULL_DOT);\n+    switch (RDOT_TYPE(node)) {\n+        case D_PRIMITIVE:\n+            retval = dot_pass_typeifyPrimitive(node);\n+            break;\n+\n+        case D_IDENTIFIER: {\n+            rdot lookup = dot_pass_dataFlow_lookup(RDOT_IDENTIFIER_POINTER(node));\n+            if (lookup == NULL_DOT)\n+                error(\"unable to find declaration of [%s] in current scope\",\n+                      RDOT_IDENTIFIER_POINTER(node));\n+            else {\n+                gcc_assert(RDOT_TYPE(lookup) == D_VAR_DECL);\n+                RDOT_TYPE(retval) = RDOT_TYPE(RDOT_rhs_TT(lookup));\n+                if (RDOT_TYPE(retval) == RTYPE_USER_STRUCT) {\n+                    RDOT_lhs_TT(retval) = RDOT_lhs_TT(RDOT_rhs_TT(lookup));\n+                    RDOT_rhs_TT(retval) = RDOT_rhs_TT(RDOT_rhs_TT(lookup));\n+                }\n+                std::vector<ALLOCA_>::iterator it;\n+                if (RDOT_MEM_MODIFIER(node))\n+                    for (it = RDOT_MEM_MODIFIER(node)->begin();\n+                         it != RDOT_MEM_MODIFIER(node)->end();\n+                         ++it)\n+                        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n+                if (RDOT_MEM_MODIFIER(RDOT_rhs_TT(lookup)))\n+                    for (it = RDOT_MEM_MODIFIER(RDOT_rhs_TT(lookup))->begin();\n+                         it != RDOT_MEM_MODIFIER(RDOT_rhs_TT(lookup))->end();\n+                         ++it)\n+                        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n+            }\n+        } break;\n+\n+        case D_STRUCT_INIT: {\n+            const char* slookup = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n+            rdot lookup = dot_pass_dataFlow_lookup(slookup);\n+            if (lookup != NULL_DOT) {\n+                if (RDOT_TYPE(lookup) == D_STRUCT_TYPE) {\n+                    RDOT_TYPE(retval) = RTYPE_USER_STRUCT;\n+                    RDOT_lhs_TT(retval) = RDOT_lhs_TT(lookup); // identifier node\n+                    RDOT_rhs_TT(retval) = RDOT_rhs_TT(lookup); // struct layout\n+                    std::vector<ALLOCA_>::iterator it;\n+                    if (RDOT_MEM_MODIFIER(node))\n+                        for (it = RDOT_MEM_MODIFIER(node)->begin();\n+                             it != RDOT_MEM_MODIFIER(node)->end();\n+                             ++it)\n+                            RDOT_MEM_MODIFIER(retval)->push_back(*it);\n+                    if (RDOT_MEM_MODIFIER(lookup))\n+                        for (it = RDOT_MEM_MODIFIER(lookup)->begin();\n+                             it != RDOT_MEM_MODIFIER(lookup)->end();\n+                             ++it)\n+                            RDOT_MEM_MODIFIER(retval)->push_back(*it);\n+                } else\n+                    error(\"unable to determine type of [%s] struct initilization, \"\n+                          \"[%s] was found in this scope\",\n+                          slookup,\n+                          RDOT_OPCODE_STR(lookup));\n+            } else\n+                error(\"[%s] does not name a type in scope\", slookup);\n+        } break;\n+\n+        case D_CALL_EXPR: {\n+            const char* callid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n+            rdot lookup = dot_pass_dataFlow_lookup(callid);\n+            if (lookup != NULL_DOT) {\n+                gcc_assert(RDOT_TYPE(lookup) == D_STRUCT_METHOD);\n+                RDOT_TYPE(retval) = RDOT_TYPE(RDOT_FIELD2(lookup));\n+                std::vector<ALLOCA_>* mods = RDOT_MEM_MODIFIER(RDOT_FIELD2(lookup));\n+                std::vector<ALLOCA_>::iterator it;\n+                if (RDOT_MEM_MODIFIER(node))\n+                    for (it = RDOT_MEM_MODIFIER(node)->begin();\n+                         it != RDOT_MEM_MODIFIER(node)->end();\n+                         ++it)\n+                        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n+                if (mods)\n+                    for (it = mods->begin(); it != mods->end(); ++it)\n+                        RDOT_MEM_MODIFIER(retval)->push_back(*it);\n+            } else\n+                error(\"unable to find declaration of [%s] in current scope\",\n+                      callid);\n+        } break;\n+\n+        case D_ATTRIB_REF: {\n+            rdot lhs = RDOT_lhs_TT(node);\n+            rdot base_type = dot_pass_typeifyExprNode(lhs);\n+            gcc_assert(RDOT_TYPE(base_type) == RTYPE_USER_STRUCT);\n+        } break;\n+\n+        case D_ACC_EXPR: {\n+            rdot impl = RDOT_lhs_TT(node);\n+            char* implid = RDOT_IDENTIFIER_POINTER(impl);\n+            rdot lookup = dot_pass_dataFlow_lookup(implid);\n+\n+            bool found = false;\n+            rdot next;\n+            for (next = RDOT_rhs_TT(RDOT_FIELD(lookup));\n+                 next != NULL_DOT;\n+                 next = RDOT_CHAIN(next)) {\n+                switch (RDOT_TYPE(next)) {\n+                    case D_STRUCT_METHOD:\n+                        RDOT_TYPE(retval) = RDOT_TYPE(RDOT_FIELD2(next));\n+                        break;\n+\n+                    default:\n+                        error_at(RDOT_LOCATION(next), \"unable to identify [%s] for type inferance\", \n+                          RDOT_OPCODE_STR(next));\n+                        break;\n+                }\n+            }\n+            if (!found)\n+                break;\n+        } break;\n+\n+        case D_ADD_EXPR:\n+        case D_MINUS_EXPR:\n+        case D_MULT_EXPR:\n+        case D_DIVD_EXPR: {\n+            rdot lhs = RDOT_lhs_TT(node);\n+            rdot rhs = RDOT_rhs_TT(node);\n+\n+            rdot lt = dot_pass_typeifyExprNode(lhs);\n+            rdot rt = dot_pass_typeifyExprNode(rhs);\n+\n+            if (RDOT_TYPE(lt) != RTYPE_INFER || RDOT_TYPE(rt) != RTYPE_INFER) {\n+                if (RDOT_TYPE(lt) == RDOT_TYPE(rt))\n+                    retval = lt;\n+                else {\n+                    if (RDOT_TYPE(lt) == RTYPE_INFER || RDOT_TYPE(rt) == RTYPE_INFER)\n+                        retval = RDOT_TYPE(lt) == RTYPE_INFER ? rt : lt;\n+                    else\n+                        error(\"unable to coerce types [%s] and [%s]\",\n+                              RDOT_OPCODE_STR(lt),\n+                              RDOT_OPCODE_STR(rt));\n+                }\n+            }\n+        } break;\n+\n+        default:\n+            error(\"Unable to figure out the type of this [%s]\",\n+                  RDOT_OPCODE_STR(node));\n+            break;\n+    }\n+\n+    bool skip_next = false;\n+    std::vector<ALLOCA_> nmods;\n+    std::vector<ALLOCA_>* pmods = RDOT_MEM_MODIFIER(retval);\n+\n+    std::vector<ALLOCA_>::iterator it;\n+    for (it = pmods->begin(); it != pmods->end(); ++it) {\n+        switch (*it) {\n+            case ALLOC_DEREF:\n+                skip_next = true;\n+                break;\n+\n+            default: {\n+                if (!skip_next) {\n+                    nmods.push_back(*it);\n+                    skip_next = false;\n+                }\n+            } break;\n+        }\n+    }\n+    RDOT_MMEM_COPY((&nmods), RDOT_MEM_MODIFIER(retval));\n+    return retval;\n+}\n+\n+// Seems to check for mutability of node (mut check) and creates error if it is violated\n+static void dot_pass_mutability(const rdot node) {\n+    rdot lhs = RDOT_lhs_TT(node);\n+    if (RDOT_TYPE(lhs) != D_VAR_DECL) {\n+        // check the nodes mutability\n+        switch (RDOT_TYPE(lhs)) {\n+            case D_IDENTIFIER: {\n+                const char* ident = RDOT_IDENTIFIER_POINTER(lhs);\n+                const rdot node = dot_pass_dataFlow_lookup(ident);\n+                if (node == NULL_DOT)\n+                    error_at(RDOT_LOCATION(node), \"Unable to find decl [%s] in current scope\", ident);\n+                else if (RDOT_qual(node) == true)\n+                    error_at(RDOT_LOCATION(node), \"Unable to modify [%s] it is immutable\", ident);\n+            } break;\n+\n+            default: {\n+                const char* nstr = RDOT_OPCODE_STR(lhs);\n+                warning_at(RDOT_LOCATION(node), 0, \"TODO unable to verify assignment\"\n+                                                   \"mutability for [%s]\",\n+                           nstr);\n+            } break;\n+        }\n+    }\n+}\n+\n+/* Seems to check for various stuff - top level for checking a full block?\n+ * \n+ * Potentially defines block declarations and adds them to decls? (pass by reference) */\n+static void dot_pass_dataFlowBlock_(rdot suite, std::vector<rdot>* decls) {\n+    rdot node;\n+    for (node = suite; node != NULL_DOT; node = RDOT_CHAIN(node)) {\n+        if (RDOT_T_FIELD(node) == D_D_EXPR) {\n+            if (RDOT_TYPE(node) == D_MODIFY_EXPR)\n+                dot_pass_mutability(node);\n+\n+            const char* id = NULL;\n+            rdot decl = dot_pass_dataFlow_getDecl(node);\n+            if (decl != NULL_DOT) {\n+                gcc_assert(RDOT_TYPE(decl) == D_VAR_DECL);\n+                id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(decl));\n+                decls->push_back(decl);\n+\n+                // push it into the current context...\n+                rdot lookup = dot_pass_dataFlow_lookup(id);\n+                if (lookup != NULL_DOT)\n+                    error(\"Duplicate declaration of [%s] to [%s]\",\n+                          id,\n+                          RDOT_OPCODE_STR(lookup));\n+                else\n+                    gcc_assert(!dot_pass_dataFlow_pushDecl(decl, id));\n+            }\n+        } else {\n+            switch (RDOT_TYPE(node)) {\n+                case D_STRUCT_IF: {\n+                    rdot sif = RDOT_lhs_TT(node);\n+                    rdot ses = RDOT_rhs_TT(node);\n+\n+                    dot_pass_dataFlowBlock_(RDOT_rhs_TT(sif), decls);\n+                    if (ses != NULL_DOT)\n+                        dot_pass_dataFlowBlock_(RDOT_lhs_TT(ses), decls);\n+                } break;\n+\n+                case D_STRUCT_WHILE:\n+                    dot_pass_dataFlowBlock_(RDOT_rhs_TT(node), decls);\n+                    break;\n+\n+                case D_STRUCT_LOOP:\n+                    dot_pass_dataFlowBlock_(RDOT_lhs_TT(node), decls);\n+                    break;\n+\n+                case C_BREAK_STMT:\n+                case C_CONT_STMT:\n+                    break;\n+\n+                default:\n+                    error(\"Unhandled data flow in block on [%s]\\n\", RDOT_OPCODE_STR(node));\n+                    break;\n+            }\n+        }\n+    }\n+}\n+\n+// Seems to get all references for usage of all defined block declarations for type inference reasons\n+static void dot_pass_dataFlowBlock(rdot suite) {\n+    std::vector<rdot> block_decls;\n+    dot_pass_dataFlowBlock_(suite, &block_decls);\n+\n+    // now we have all defined block declarations now need to get all\n+    // references in their use if they have an undefined type.\n+    std::vector<rdot>::iterator it;\n+    for (it = block_decls.begin(); it != block_decls.end(); ++it) {\n+        rdot decl = *it;\n+        gcc_assert(RDOT_TYPE(decl) == D_VAR_DECL);\n+        rdot idecl = RDOT_lhs_TT(decl);\n+        const char* ident = RDOT_IDENTIFIER_POINTER(idecl);\n+        if (RDOT_TYPE(RDOT_rhs_TT(decl)) == RTYPE_INFER) {\n+            std::vector<rdot>* refs = dot_pass_getReferences(decl, suite);\n+            if (refs->size() == 0) {\n+                error(\"Unable to infer type of [%s] it looks to \"\n+                      \"be unused in this scope\",\n+                      ident);\n+                continue;\n+            }\n+            RDOT_rhs_TT(decl) = dot_pass_inferTheType(refs, ident);\n+            if (RDOT_TYPE(RDOT_rhs_TT(decl)) == RTYPE_INFER)\n+                error(\"Compiler was unable to infer the type for [%s]\", ident);\n+            delete refs;\n+        }\n+    }\n+}\n+\n+// Checks data flow for entire function - calls stuff leading to type inference, return values, etc.\n+static void dot_pass_dataFlowFunction(rdot node) {\n+    const char* method_id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n+    rdot type = RDOT_FIELD2(node);\n+\n+    // rust does not infer function types empty types are default void\n+    // and parameters are synatically required to be typed\n+    dot_pass_dataFlow_pushCtx();\n+\n+    // fill up the parameters here\n+    rdot params;\n+    for (params = RDOT_lhs_TT(node); params != NULL_DOT;\n+         params = RDOT_CHAIN(params)) {\n+        rdot pident = RDOT_lhs_TT(params);\n+        rdot ptype = RDOT_rhs_TT(params);\n+\n+        const char* cpid = RDOT_IDENTIFIER_POINTER(pident);\n+        if (strcmp(cpid, \"self\") == 0) {\n+            gcc_assert(impl_master != NULL_DOT);\n+            rdot stid = RDOT_lhs_TT(impl_master);\n+            ptype = rdot_build_decl1(RTYPE_USER_STRUCT, stid);\n+        }\n+        rdot vpdecl = rdot_build_varDecl(ptype, RDOT_qual(params), pident);\n+        bool chk = dot_pass_dataFlow_pushDecl(vpdecl,\n+                                              RDOT_IDENTIFIER_POINTER(pident));\n+        gcc_assert(chk == false);\n+    }\n+\n+    rdot suite = RDOT_rhs_TT(node);\n+    dot_pass_dataFlowBlock(suite);\n+\n+    // now check the return type is correct\n+    /* make sure its a valid type! */\n+    if (type != NULL) {\n+        bool verify = verifyType(type);\n+        if (verify == false)\n+            error(\"unable to verify return type of %s [%s]\\n\",\n+                  method_id,\n+                  RDOT_OPCODE_STR(type));\n+        else {\n+            std::vector<rdot> retvals;\n+            dot_pass_dataFlowBlock_retvals(suite, &retvals);\n+\n+            if (retvals.size() == 0)\n+                error(\"Function [%s] does not seem to return anything!\", method_id);\n+            else {\n+                rdot retype = dot_pass_inferTheType(&retvals, method_id);\n+                if (RDOT_TYPE(retype) == RTYPE_INFER)\n+                    error(\"gcc rust was unable to verify the return type of [%s]\",\n+                          method_id);\n+            }\n+        }\n+    }\n+    dot_pass_dataFlow_popCtx();\n+}\n+\n+// Presumably top level entry for checking data flow - switches to method (function), struct, struct impl\n+static void dot_pass_dataFlowToplevel(rdot node) {\n+    switch (RDOT_TYPE(node)) {\n+        case D_STRUCT_METHOD:\n+            dot_pass_dataFlowFunction(node);\n+            break;\n+\n+            /* need to dataflow the layout to check the types eventually */\n+        case D_STRUCT_TYPE:\n+            break;\n+\n+        case D_STRUCT_IMPL: {\n+            // look up to make sure the impl name is available...\n+            const char* implid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n+            rdot lookup = dot_pass_dataFlow_lookup(implid);\n+            if (lookup == NULL_DOT)\n+                error(\"impl [%s] does not reference a type in scope\", implid);\n+            else {\n+                if (RDOT_TYPE(lookup) != D_STRUCT_TYPE)\n+                    error(\"impl [%s] does not reference a struct points to [%s]\",\n+                          implid,\n+                          RDOT_OPCODE_STR(lookup));\n+                else {\n+                    RDOT_FIELD(lookup) = node;\n+                    impl_master = lookup;\n+                    rdot next;\n+                    for (next = RDOT_rhs_TT(node); next != NULL_DOT;\n+                         next = RDOT_CHAIN(next))\n+                        dot_pass_dataFlowFunction(next);\n+                    impl_master = NULL_DOT;\n+                }\n+            }\n+        } break;\n+\n+        default:\n+            error(\"Unable to dataflow %s\\n\", RDOT_OPCODE_STR(node));\n+            break;\n+    }\n+}\n+\n+// may be true top-level entry for checking data flow and inferring types - seems to call even top level function\n+vec<rdot, va_gc>* dot_pass_inferTypes(vec<rdot, va_gc>* decls) {\n+    dot_pass_dataFlow_pushCtx();\n+\n+    rdot idtx = NULL_DOT;\n+    size_t i;\n+    for (i = 0; decls->iterate(i, &idtx); ++i) {\n+        rdot node = idtx;\n+        switch (RDOT_TYPE(node)) {\n+            case D_STRUCT_METHOD: {\n+                const char* id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n+                if (dot_pass_dataFlow_lookup(id))\n+                    error(\"Duplicate declaration against this function [%s]\\n\", id);\n+                else\n+                    dot_pass_dataFlow_pushDecl(node, id);\n+            } break;\n+\n+            case D_STRUCT_TYPE: {\n+                const char* id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n+                if (dot_pass_dataFlow_lookup(id))\n+                    error(\"Duplicate declaration against this type [%s]\\n\", id);\n+                else\n+                    dot_pass_dataFlow_pushDecl(node, id);\n+            } break;\n+\n+            case D_STRUCT_IMPL: {\n+                // look up to make sure the impl name is available...\n+                const char* implid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n+                rdot lookup = dot_pass_dataFlow_lookup(implid);\n+                if (lookup == NULL_DOT)\n+                    error(\"impl [%s] does not reference a type in scope\", implid);\n+                else {\n+                    if (RDOT_TYPE(lookup) != D_STRUCT_TYPE)\n+                        error(\"impl [%s] does not reference a struct points to [%s]\",\n+                              implid,\n+                              RDOT_OPCODE_STR(lookup));\n+                    else\n+                        RDOT_FIELD(lookup) = node;\n+                }\n+            } break;\n+\n+            default:\n+                break;\n+        }\n+    }\n+\n+    for (i = 0; decls->iterate(i, &idtx); ++i)\n+        dot_pass_dataFlowToplevel(idtx);\n+\n+    dot_pass_dataFlow_popCtx();\n+    return decls;\n+}"}, {"sha": "5e7672ac1fd5afc2b111730b810b7787ae6652c1", "filename": "gcc/rust/old/rdot-generic-compiler.cc", "status": "added", "additions": 1029, "deletions": 0, "changes": 1029, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,1029 @@\n+// rdot-generic-compiler.cc - seems to convert rdot AST representation to GENERIC representation\n+/* This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"rust.h\"\n+\n+#define RUST_TMP \"RUST_TMP\"\n+\n+static std::vector<std::map<std::string, tree>*> context;\n+\n+static tree dot_pass_genFndecl_Basic(location_t, const char*, tree);\n+static tree dot_pass_lookupCTU(const char*);\n+static std::vector<tree>* dot_pass_popContext(void);\n+static void dot_pass_pushContext(void);\n+static void dot_pass_genMethodProto(rdot);\n+static void dot_pass_compileSuite(rdot, tree*);\n+\n+#define RDOT_ALLOCA_MODIFIERS_DO(_X, _Y)                                                         \\\n+    if (RDOT_MEM_MODIFIER(_Y))                                                                   \\\n+        do {                                                                                     \\\n+            gcc_assert(_X != error_mark_node);                                                   \\\n+            std::vector<ALLOCA_>::reverse_iterator __rit;                                        \\\n+            for (__rit = RDOT_MEM_MODIFIER(_Y)->rbegin();                                        \\\n+                 __rit != RDOT_MEM_MODIFIER(_Y)->rend();                                         \\\n+                 ++__rit) {                                                                      \\\n+                switch (*__rit) {                                                                \\\n+                    case ALLOC_HEAP:                                                             \\\n+                        _X = dot_pass_heapify(_X, TREE_TYPE(_X), TYPE_SIZE_UNIT(TREE_TYPE(_X))); \\\n+                        break;                                                                   \\\n+                    case ALLOC_REF:                                                              \\\n+                        _X = build_fold_addr_expr(_X);                                           \\\n+                        break;                                                                   \\\n+                    case ALLOC_DEREF: {                                                          \\\n+                        _X = build_fold_indirect_ref_loc(RDOT_LOCATION(_Y),                      \\\n+                                                         _X);                                    \\\n+                        TREE_THIS_NOTRAP(_X) = 1;                                                \\\n+                    } break;                                                                     \\\n+                }                                                                                \\\n+            }                                                                                    \\\n+    } while (0)\n+\n+/* NOTE: this isn't global in the sense of the generated code,\n+   This just makes it easier for expression compilation to access\n+   the return decl */\n+static tree global_retDecl;\n+static tree* current_function_block;\n+static bool global_retDecl_;\n+static tree __impl_type_decl = error_mark_node;\n+static std::vector<tree> __loopContexts;\n+#define dot_pass_rustToGccType(_x, _y) dot_pass_rustToGccType__(_x, _y, false, NULL)\n+\n+// seems to return only the end of a string val by removing everything before the final dot\n+static char* dot_pass_demangleImpl(const char* val) {\n+    // has form of type.method_name\n+    size_t i;\n+    size_t last_dot = 0;\n+    for (i = 0; i < strlen(val); ++i) {\n+        if (val[i] == '.')\n+            last_dot = i;\n+    }\n+    size_t bsize = (strlen(val) - last_dot) * sizeof(char);\n+    char* buffer = (char*)xmalloc(bsize);\n+    memset(buffer, 0, bsize);\n+    strncpy(buffer, val + last_dot + 1, strlen(val) - last_dot);\n+\n+    return buffer;\n+}\n+\n+// Seems to \"mangle\" val (a string parameter) by prepending \"__rust_\" to it\n+static char* dot_pass_mangle(const char* val) {\n+    // just for now pre-append __rust_[id] will do ok for now\n+    const char* stuff = \"__rust_\";\n+    size_t blen = (strlen(stuff) + strlen(val) + 1) * sizeof(char);\n+    char* retval = (char*)xmalloc(blen);\n+    memset(retval, 0, blen);\n+    snprintf(retval, blen, \"%s%s\", stuff, val);\n+    return retval;\n+}\n+\n+// Seems to convert \"Rust type\" (rdot type) to GCC GENERIC type\n+static tree dot_pass_rustToGccType__(rdot type, bool consty, bool rset, tree* record) {\n+    tree retval = error_mark_node;\n+    switch (RDOT_TYPE(type)) {\n+        case RTYPE_INT:\n+            retval = integer_type_node;\n+            break;\n+\n+        case D_STRUCT_TYPE:\n+        case D_STRUCT_INIT:\n+        case RTYPE_USER_STRUCT: {\n+            const char* id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(type));\n+            retval = dot_pass_lookupCTU(id);\n+            if (rset)\n+                *record = retval;\n+\n+            if (retval == error_mark_node)\n+                error(\"Unable to find struct type [%s]\\n\", id);\n+        } break;\n+\n+        default:\n+            error(\"Unable to figure out gcc type for [%s]\\n\",\n+                  RDOT_OPCODE_STR(type));\n+            break;\n+    }\n+    if (RDOT_MEM_MODIFIER(type)) {\n+        std::vector<ALLOCA_>::reverse_iterator rit;\n+        for (rit = RDOT_MEM_MODIFIER(type)->rbegin();\n+             rit != RDOT_MEM_MODIFIER(type)->rend();\n+             ++rit) {\n+            switch (*rit) {\n+                case ALLOC_REF:\n+                case ALLOC_HEAP:\n+                    retval = build_pointer_type(retval);\n+                    break;\n+                default:\n+                    fatal_error(\"cannot figure out modifier applied to type [%i]\", *rit);\n+                    break;\n+            }\n+        }\n+    }\n+    if (consty)\n+        retval = build_qualified_type(retval, TYPE_QUAL_CONST);\n+    return retval;\n+}\n+\n+// May build a function declaration? Add one to tree? Seems to have something to do with \"struct functions\"\n+static tree dot_pass_genFndecl_Basic(location_t loc, const char* ident, tree fntype) {\n+    tree fndecl = build_decl(loc, FUNCTION_DECL, get_identifier(ident), fntype);\n+    TREE_STATIC(fndecl) = 0;\n+    TREE_USED(fndecl) = 1;\n+    TREE_PUBLIC(fndecl) = 1;\n+\n+    tree argslist = NULL_TREE;\n+    DECL_ARGUMENTS(fndecl) = argslist;\n+\n+    tree resdecl = build_decl(BUILTINS_LOCATION, RESULT_DECL, NULL_TREE, TREE_TYPE(fntype));\n+    DECL_CONTEXT(resdecl) = fndecl;\n+    DECL_ARTIFICIAL(resdecl) = true;\n+    DECL_IGNORED_P(resdecl) = true;\n+    DECL_RESULT(fndecl) = resdecl;\n+\n+    if (DECL_STRUCT_FUNCTION(fndecl) == NULL)\n+        push_struct_function(fndecl);\n+    else\n+        push_cfun(DECL_STRUCT_FUNCTION(fndecl));\n+    return fndecl;\n+}\n+\n+// Creates a \"tree\" string from an inputted string\n+static tree dot_pass_generateCString(const char* str) {\n+    tree index_type = build_index_type(size_int(strlen(str)));\n+    tree const_char_type = build_qualified_type(char_type_node, TYPE_QUAL_CONST);\n+    tree string_type = build_array_type(const_char_type, index_type);\n+    string_type = build_variant_type_copy(string_type);\n+\n+    TYPE_STRING_FLAG(string_type) = 1;\n+    tree string_val = build_string(strlen(str), str);\n+    TREE_TYPE(string_val) = string_type;\n+\n+    return string_val;\n+}\n+\n+// Seems to lookup struct (by name id) in context map thing, and returns the corresponding tree\n+static tree dot_pass_lookupCTU(const char* id) {\n+    tree retval = error_mark_node;\n+\n+    std::vector<std::map<std::string, tree>*>::reverse_iterator it;\n+    for (it = context.rbegin(); it != context.rend(); ++it) {\n+        std::map<std::string, tree>* ctx = *it;\n+        if (ctx->count(std::string(id)) > 0) {\n+            retval = ctx->at(std::string(id));\n+            break;\n+        }\n+    }\n+\n+    return retval;\n+}\n+\n+// seems to add a declaration tree thing to a map\n+static void dot_pass_pushDecl(const char* id, tree decl) {\n+    tree test = dot_pass_lookupCTU(id);\n+    if (test == error_mark_node) {\n+        std::map<std::string, tree>* ctx = context.back();\n+        (*ctx)[std::string(id)] = decl;\n+    } else\n+        error(\"duplicate declaration of [%s]\\n\", id);\n+}\n+\n+// Seems to build a heap allocation expression of size size\n+static tree\n+dot_pass_rust_RR_alloc(tree size) {\n+    tree fntype = build_function_type_list(ptr_type_node,\n+                                           size_type_node,\n+                                           NULL_TREE);\n+    tree fndecl = build_decl(BUILTINS_LOCATION, FUNCTION_DECL, get_identifier(\"__rust_heap_alloc\"), fntype);\n+    tree restype = TREE_TYPE(fndecl);\n+    tree resdecl = build_decl(BUILTINS_LOCATION, RESULT_DECL, NULL_TREE, restype);\n+    DECL_CONTEXT(resdecl) = fndecl;\n+    DECL_RESULT(fndecl) = resdecl;\n+    DECL_EXTERNAL(fndecl) = 1;\n+    TREE_PUBLIC(fndecl) = 1;\n+    return build_call_expr(fndecl, 1, size);\n+}\n+\n+// Appears to return a tree/declaration that heap allocation has occurred (or should occur?)\n+static tree\n+dot_pass_heap_alloc(tree size, tree type) {\n+    tree ptype = build_pointer_type(type);\n+    tree heap_tmp = build_decl(UNKNOWN_LOCATION, VAR_DECL, create_tmp_var_name(RUST_TMP), ptype);\n+    dot_pass_pushDecl(IDENTIFIER_POINTER(DECL_NAME(heap_tmp)), heap_tmp);\n+    append_to_statement_list(fold_build2(MODIFY_EXPR, ptype, heap_tmp, dot_pass_rust_RR_alloc(size)),\n+                             current_function_block);\n+    return heap_tmp;\n+}\n+\n+// Seems to do something related to heap allocation\n+static tree\n+dot_pass_heapify(tree value, tree type, tree size) {\n+    tree alloc = dot_pass_heap_alloc(size, type);\n+    tree gmemcpy = builtin_decl_implicit(BUILT_IN_MEMCPY);\n+    vec<tree, va_gc>* args;\n+    vec_alloc(args, 0);\n+    vec_safe_push(args, alloc);\n+    vec_safe_push(args, build_fold_addr_expr(value));\n+    vec_safe_push(args, size);\n+    append_to_statement_list(build_call_expr_loc_vec(UNKNOWN_LOCATION, gmemcpy, args),\n+                             current_function_block);\n+    return alloc;\n+}\n+\n+// Seems to build an integer tree node from rdot decl\n+static tree dot_pass_genScalar(rdot decl) {\n+    tree retval = error_mark_node;\n+    gcc_assert(RDOT_TYPE(decl) == D_PRIMITIVE);\n+    gcc_assert(RDOT_lhs_T(decl) == D_TD_COM);\n+\n+    switch (RDOT_lhs_TC(decl).T) {\n+        case D_T_INTEGER:\n+            retval = build_int_cst(integer_type_node, RDOT_lhs_TC(decl).o.integer);\n+            break;\n+\n+        default:\n+            fatal_error(\"invalid scalar type %s!\\n\", RDOT_CODE_STR(RDOT_lhs_TC(decl).T));\n+            break;\n+    }\n+    return retval;\n+}\n+\n+// Presumably turns a function calls into tree nodes\n+static tree dot_pass_genifyCall(tree mfndecl, vec<tree, va_gc>* arguments) {\n+    tree retval = error_mark_node;\n+    if (TREE_CODE(mfndecl) == FUNCTION_DECL) {\n+        // size_t len = arguments->length ();\n+        // size_t lparms = 0;\n+        // tree types = TYPE_ARG_TYPES (mfndecl);\n+\n+        /* really need to check the calling types and number of arguments */\n+        retval = build_call_expr_loc_vec(UNKNOWN_LOCATION, mfndecl, arguments);\n+    } else\n+        error(\"trying to call a function which isn't callable [%s]\",\n+              IDENTIFIER_POINTER(mfndecl));\n+    return retval;\n+}\n+\n+// Seems to be an entry point for lowering an rdot dot expression - switches between their types and stuff\n+static tree dot_pass_lowerExpr(rdot dot, tree* block) {\n+    tree retval = error_mark_node;\n+    switch (RDOT_TYPE(dot)) {\n+        case D_PRIMITIVE: {\n+            retval = dot_pass_genScalar(dot);\n+            RDOT_ALLOCA_MODIFIERS_DO(retval, dot);\n+        } break;\n+\n+        case D_IDENTIFIER: {\n+            const char* id = RDOT_IDENTIFIER_POINTER(dot);\n+            retval = dot_pass_lookupCTU(id);\n+            if (retval == error_mark_node)\n+                fatal_error(\"no such id [%s] in scope\", id);\n+            RDOT_ALLOCA_MODIFIERS_DO(retval, dot);\n+        } break;\n+\n+        case D_STRUCT_INIT: {\n+            // need to go fetch the type and build the constructor...\n+            size_t count = 0;\n+            tree root_type = error_mark_node;\n+            dot_pass_rustToGccType__(dot, false, true, &root_type);\n+            gcc_assert(root_type != error_mark_node);\n+            tree fields = TYPE_FIELDS(root_type);\n+\n+            tree fnext;\n+            for (fnext = fields; fnext != NULL_TREE; fnext = DECL_CHAIN(fnext))\n+                count++;\n+            fnext = error_mark_node;\n+\n+            vec<constructor_elt, va_gc>* init;\n+            vec_alloc(init, count + 1);\n+\n+            /*\n+\t  FIXME this is all very buggy:\n+\t  eg:\n+\t  struct test {\n+\t    x : int\n+            y : int\n+\t  }\n+\n+\t  initilize with test { x: 1, x: 1} will pass but it should fail\n+\t  needs more validation at dataflow level and here\n+\t */\n+            tree rid = create_tmp_var_name(RUST_TMP);\n+            retval = build_decl(RDOT_LOCATION(dot), VAR_DECL, rid, root_type);\n+            dot_pass_pushDecl(IDENTIFIER_POINTER(rid), retval);\n+\n+            constructor_elt empty = { NULL, NULL };\n+            rdot next;\n+            size_t valid = 0;\n+            for (next = RDOT_rhs_TT(dot); next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+                constructor_elt* elt = init->quick_push(empty);\n+                gcc_assert(RDOT_TYPE(next) == D_STRUCT_PARAM);\n+                bool found = false;\n+                for (fnext = fields; fnext != NULL_TREE; fnext = DECL_CHAIN(fnext)) {\n+                    const char* pid = IDENTIFIER_POINTER(DECL_NAME(fnext));\n+                    const char* sid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n+                    if (strcmp(pid, sid) == 0) {\n+                        found = true;\n+                        break;\n+                    }\n+                }\n+                if (!found) {\n+                    error(\"Unable to find field [%s] in struct [%s]\",\n+                          IDENTIFIER_POINTER(TYPE_NAME(root_type)),\n+                          RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next)));\n+                    break;\n+                }\n+\n+                elt->index = fnext;\n+                elt->value = fold_convert(TREE_TYPE(fnext),\n+                                          dot_pass_lowerExpr(RDOT_rhs_TT(next),\n+                                                             block));\n+                valid++;\n+            }\n+            if (valid == count) {\n+                tree cons = build_constructor(root_type, init);\n+                append_to_statement_list(fold_build2_loc(RDOT_LOCATION(dot), INIT_EXPR, root_type, retval, cons), block);\n+            } else {\n+                fatal_error(\"Cannot initilize struct required [%lu] fields got [%lu]\",\n+                            valid,\n+                            count);\n+                // TODO better diagnostic make a map of the initilized so\n+                // we can display the un initilized to the user\n+            }\n+            RDOT_ALLOCA_MODIFIERS_DO(retval, dot);\n+        } break;\n+\n+        case D_CALL_EXPR: {\n+            const char* fnid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(dot));\n+            rdot ptr;\n+            vec<tree, va_gc>* arguments;\n+            vec_alloc(arguments, 0);\n+            for (ptr = RDOT_rhs_TT(dot); ptr != NULL_DOT;\n+                 ptr = RDOT_CHAIN(ptr))\n+                vec_safe_push(arguments, dot_pass_lowerExpr(ptr, block));\n+            /* lookup the function prototype */\n+            tree lookup = dot_pass_lookupCTU(fnid);\n+            if (lookup != error_mark_node)\n+                retval = dot_pass_genifyCall(lookup, arguments);\n+            else {\n+                fatal_error(\"Unable to find callable %s\\n\", fnid);\n+                retval = error_mark_node;\n+            }\n+            RDOT_ALLOCA_MODIFIERS_DO(retval, dot);\n+        } break;\n+\n+        case D_ATTRIB_REF: {\n+            rdot lhs = RDOT_lhs_TT(dot);\n+            rdot rhs = RDOT_rhs_TT(dot);\n+\n+            tree lookup = dot_pass_lowerExpr(lhs, block);\n+            switch (RDOT_TYPE(rhs)) {\n+                case D_CALL_EXPR: {\n+                    rdot crid = RDOT_lhs_TT(rhs);\n+                    const char* rlookup = RDOT_IDENTIFIER_POINTER(crid);\n+                    tree tid = TYPE_NAME(TREE_TYPE(lookup));\n+                    const char* ctid = IDENTIFIER_POINTER(tid);\n+\n+                    tree type_decl = dot_pass_lookupCTU(ctid);\n+                    // just to be sure but we will have already error'd at this point..\n+                    gcc_assert(type_decl != error_mark_node);\n+\n+                    tree mths = TYPE_METHODS(type_decl);\n+                    tree next;\n+                    for (next = mths; next != NULL_TREE; next = DECL_CHAIN(next)) {\n+                        const char* mid = IDENTIFIER_POINTER(DECL_NAME(next));\n+                        char* demangle = dot_pass_demangleImpl(mid);\n+                        if (strcmp(rlookup, demangle) == 0) {\n+                            vec<tree, va_gc>* cargs;\n+                            vec_alloc(cargs, 0);\n+                            vec_safe_push(cargs, lookup);\n+\n+                            rdot pnext;\n+                            for (pnext = RDOT_rhs_TT(rhs); pnext != NULL_DOT;\n+                                 pnext = RDOT_CHAIN(pnext))\n+                                vec_safe_push(cargs, dot_pass_lowerExpr(pnext, block));\n+\n+                            retval = dot_pass_genifyCall(next, cargs);\n+                            break;\n+                        }\n+                    }\n+                } break;\n+\n+                case D_IDENTIFIER: {\n+                    const char* rlookup = RDOT_IDENTIFIER_POINTER(rhs);\n+                    tree fields = TYPE_FIELDS(TREE_TYPE(lookup));\n+                    tree next;\n+                    for (next = fields; next != NULL_TREE; next = DECL_CHAIN(next)) {\n+                        const char* fid = IDENTIFIER_POINTER(DECL_NAME(next));\n+                        if (strcmp(rlookup, fid) == 0) {\n+                            /* no idea why we need build3 here but build2 fails... */\n+                            retval = build3(COMPONENT_REF, TREE_TYPE(next), lookup, next, NULL_TREE);\n+                            break;\n+                        }\n+                    }\n+                } break;\n+\n+                default:\n+                    fatal_error(\"Really don't know what happened here!\\n\");\n+                    break;\n+            }\n+        } break;\n+\n+        case D_MODIFY_EXPR: {\n+            tree assignment = dot_pass_lowerExpr(RDOT_rhs_TT(dot), block);\n+            tree decl = dot_pass_lowerExpr(RDOT_lhs_TT(dot), block);\n+            retval = build2(MODIFY_EXPR, TREE_TYPE(decl), decl, assignment);\n+        } break;\n+\n+        case D_ADD_EXPR: {\n+            rdot lhs = RDOT_lhs_TT(dot);\n+            rdot rhs = RDOT_rhs_TT(dot);\n+\n+            tree xlhs = dot_pass_lowerExpr(lhs, block);\n+            tree xrhs = dot_pass_lowerExpr(rhs, block);\n+\n+            retval = build2(PLUS_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n+        } break;\n+\n+        case D_MINUS_EXPR: {\n+            rdot lhs = RDOT_lhs_TT(dot);\n+            rdot rhs = RDOT_rhs_TT(dot);\n+\n+            tree xlhs = dot_pass_lowerExpr(lhs, block);\n+            tree xrhs = dot_pass_lowerExpr(rhs, block);\n+\n+            retval = build2(MINUS_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n+        } break;\n+\n+        case D_MULT_EXPR: {\n+            rdot lhs = RDOT_lhs_TT(dot);\n+            rdot rhs = RDOT_rhs_TT(dot);\n+\n+            tree xlhs = dot_pass_lowerExpr(lhs, block);\n+            tree xrhs = dot_pass_lowerExpr(rhs, block);\n+\n+            retval = build2(MULT_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n+        } break;\n+\n+        case D_LESS_EQ_EXPR: {\n+            rdot lhs = RDOT_lhs_TT(dot);\n+            rdot rhs = RDOT_rhs_TT(dot);\n+\n+            tree xlhs = dot_pass_lowerExpr(lhs, block);\n+            tree xrhs = dot_pass_lowerExpr(rhs, block);\n+\n+            retval = build2(LE_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n+        } break;\n+\n+        case D_EQ_EQ_EXPR: {\n+            rdot lhs = RDOT_lhs_TT(dot);\n+            rdot rhs = RDOT_rhs_TT(dot);\n+\n+            tree xlhs = dot_pass_lowerExpr(lhs, block);\n+            tree xrhs = dot_pass_lowerExpr(rhs, block);\n+\n+            retval = build2(EQ_EXPR, TREE_TYPE(xlhs), xlhs, xrhs);\n+        } break;\n+\n+        case D_VAR_DECL: {\n+            const char* varID = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(dot));\n+            bool consty = RDOT_qual(dot);\n+            tree gcc_type = dot_pass_rustToGccType(RDOT_rhs_TT(dot), consty);\n+            tree decl = build_decl(RDOT_LOCATION(dot),\n+                                   VAR_DECL,\n+                                   get_identifier(varID),\n+                                   gcc_type);\n+            if (dot_pass_lookupCTU(varID) == error_mark_node)\n+                dot_pass_pushDecl(varID, decl);\n+            retval = decl;\n+        } break;\n+\n+        case D_ACC_EXPR: {\n+            rdot impl = RDOT_lhs_TT(dot);\n+            char* implid = RDOT_IDENTIFIER_POINTER(impl);\n+            printf(\"implid = %s\\n\", implid);\n+        } break;\n+\n+        default:\n+            error(\"unhandled binary operation type [%s]!\\n\", RDOT_OPCODE_STR(dot));\n+            break;\n+    }\n+\n+    if (DOT_RETVAL(dot)) {\n+        if (global_retDecl != error_mark_node) {\n+            tree retass = fold_build2_loc(RDOT_LOCATION(dot),\n+                                          MODIFY_EXPR,\n+                                          TREE_TYPE(global_retDecl),\n+                                          global_retDecl,\n+                                          retval);\n+            append_to_statement_list(retass, block);\n+            global_retDecl_ = true;\n+            retval = global_retDecl;\n+        }\n+    }\n+\n+    return retval;\n+}\n+\n+// Seems to be an entry point for lowering conditionals (if stmnts) and adding them to the statement list\n+static void dot_pass_compileCond(rdot node, tree* block) {\n+    rdot ifblock = RDOT_lhs_TT(node);\n+    rdot elseblock = RDOT_rhs_TT(node);\n+\n+    tree endif_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"ENDIF\"), void_type_node);\n+    tree endif_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, endif_label_decl);\n+    DECL_CONTEXT(endif_label_decl) = current_function_decl;\n+\n+    tree else_label_expr = error_mark_node;\n+    tree else_label_decl = error_mark_node;\n+    if (elseblock != NULL_DOT) {\n+        else_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"ELSE\"), void_type_node);\n+        else_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, else_label_decl);\n+        DECL_CONTEXT(else_label_decl) = current_function_decl;\n+    } else {\n+        else_label_expr = endif_label_expr;\n+        else_label_decl = endif_label_decl;\n+    }\n+\n+    tree cond = dot_pass_lowerExpr(RDOT_lhs_TT(ifblock), block);\n+    tree conditional = build3_loc(RDOT_LOCATION(node), COND_EXPR, void_type_node, cond, NULL_TREE, build1(GOTO_EXPR, void_type_node, else_label_decl));\n+\n+    append_to_statement_list(conditional, block);\n+    dot_pass_compileSuite(RDOT_rhs_TT(ifblock), block);\n+    append_to_statement_list(build1(GOTO_EXPR, void_type_node, endif_label_decl),\n+                             block);\n+    if (elseblock) {\n+        append_to_statement_list(else_label_expr, block);\n+        dot_pass_compileSuite(RDOT_lhs_TT(elseblock), block);\n+        append_to_statement_list(endif_label_expr, block);\n+    } else\n+        append_to_statement_list(endif_label_expr, block);\n+}\n+\n+// Seems to be an entry point for lowering breaks (as in loops) and adding them to a statement list\n+static void dot_pass_compileBreak(rdot node, tree* block) {\n+    size_t lts = __loopContexts.size();\n+    if (lts > 0)\n+        append_to_statement_list(fold_build1_loc(RDOT_LOCATION(node), GOTO_EXPR, void_type_node, __loopContexts.back()),\n+                                 block);\n+    else\n+        error(\"break outside of loop context\");\n+}\n+\n+// Seems to be an entry point for lowering loops and appending them to statement list - possibly Rust type loop?\n+static void dot_pass_compileLoop(rdot node, tree* block) {\n+    tree start_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"START\"), void_type_node);\n+    tree start_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, start_label_decl);\n+    DECL_CONTEXT(start_label_decl) = current_function_decl;\n+\n+    tree end_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"END\"), void_type_node);\n+    tree end_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, end_label_decl);\n+    DECL_CONTEXT(end_label_decl) = current_function_decl;\n+    __loopContexts.push_back(end_label_decl);\n+\n+    /* -- -- -- */\n+    append_to_statement_list(start_label_expr, block);\n+\n+    dot_pass_compileSuite(RDOT_lhs_TT(node), block);\n+    append_to_statement_list(build1(GOTO_EXPR, void_type_node, start_label_decl), block);\n+    append_to_statement_list(end_label_expr, block);\n+\n+    __loopContexts.pop_back();\n+}\n+\n+// Seems to be an entry point for lowering while loops and adding them to statement list\n+static void dot_pass_compileWhile(rdot node, tree* block) {\n+    rdot condition = RDOT_lhs_TT(node);\n+    rdot suite = RDOT_rhs_TT(node);\n+\n+    tree start_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"START\"), void_type_node);\n+    tree start_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, start_label_decl);\n+    DECL_CONTEXT(start_label_decl) = current_function_decl;\n+\n+    tree end_label_decl = build_decl(BUILTINS_LOCATION, LABEL_DECL, create_tmp_var_name(\"END\"), void_type_node);\n+    tree end_label_expr = fold_build1_loc(BUILTINS_LOCATION, LABEL_EXPR, void_type_node, end_label_decl);\n+    DECL_CONTEXT(end_label_decl) = current_function_decl;\n+    __loopContexts.push_back(end_label_decl);\n+\n+    /* -- -- -- */\n+    append_to_statement_list(start_label_expr, block);\n+\n+    tree cond = dot_pass_lowerExpr(condition, block);\n+    tree conditional = build3_loc(RDOT_LOCATION(node), COND_EXPR, void_type_node, cond, NULL_TREE, build1(GOTO_EXPR, void_type_node, end_label_decl));\n+    append_to_statement_list(conditional, block);\n+    dot_pass_compileSuite(suite, block);\n+    append_to_statement_list(build1(GOTO_EXPR, void_type_node, start_label_decl), block);\n+    append_to_statement_list(end_label_expr, block);\n+\n+    __loopContexts.pop_back();\n+}\n+\n+// Seems to be an entry point for lowering a series (suite?) of control statements and fields - usage suggests possibly lowering a block\n+static void dot_pass_compileSuite(rdot suite, tree* block) {\n+    rdot node;\n+    for (node = suite; node != NULL_DOT; node = RDOT_CHAIN(node)) {\n+        if (RDOT_T_FIELD(node) == D_D_EXPR)\n+            append_to_statement_list(dot_pass_lowerExpr(node, block), block);\n+        else {\n+            switch (RDOT_TYPE(node)) {\n+                case D_STRUCT_IF:\n+                    dot_pass_compileCond(node, block);\n+                    break;\n+\n+                case D_STRUCT_WHILE:\n+                    dot_pass_compileWhile(node, block);\n+                    break;\n+\n+                case D_STRUCT_LOOP:\n+                    dot_pass_compileLoop(node, block);\n+                    break;\n+\n+                case C_BREAK_STMT:\n+                    dot_pass_compileBreak(node, block);\n+                    break;\n+\n+                default:\n+                    error(\"Unhandled statement [%s]\\n\", RDOT_OPCODE_STR(node));\n+                    break;\n+            }\n+        }\n+    }\n+}\n+\n+// Seems to be an entry point for generating method prototypes from an rdot node and adding them to list\n+static void dot_pass_genMethodProto(rdot node) {\n+    const char* method_id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n+    if (dot_pass_lookupCTU(method_id) != error_mark_node) {\n+        error(\"Duplicate declaration of function [%s]\\n\", method_id);\n+        return;\n+    }\n+    tree rtype = void_type_node;\n+    if (RDOT_FIELD2(node))\n+        rtype = dot_pass_rustToGccType(RDOT_FIELD2(node), false);\n+\n+    rdot parameters = RDOT_lhs_TT(node);\n+    tree fntype = error_mark_node;\n+    if (parameters != NULL_DOT) {\n+        size_t nparams = 0;\n+        rdot prm;\n+        for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN(prm))\n+            nparams++;\n+\n+        tree* gccparams = XALLOCAVEC(tree, nparams);\n+        size_t i = 0;\n+        for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN(prm)) {\n+            bool mut = false;\n+            if (RDOT_qual(prm))\n+                mut = true;\n+            gccparams[i] = dot_pass_rustToGccType(RDOT_rhs_TT(prm), mut);\n+            i++;\n+        }\n+        fntype = build_function_type_array(rtype, nparams, gccparams);\n+    } else\n+        fntype = build_function_type_list(rtype, NULL_TREE);\n+\n+    tree fndecl = dot_pass_genFndecl_Basic(RDOT_LOCATION(node), method_id, fntype);\n+    SET_DECL_ASSEMBLER_NAME(fndecl, get_identifier(dot_pass_mangle(method_id)));\n+    dot_pass_pushDecl(method_id, fndecl);\n+}\n+\n+// Seems to parse and then gimplify an rdot node corresponding to a function tree? - potentially the main entry point, as gcc docs indicate compilation is done on a function-level\n+static tree dot_pass_genifyTopFndecl(rdot node) {\n+    const char* method_id;\n+    if (__impl_type_decl != error_mark_node) {\n+        char* mid = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n+        tree spfx = TYPE_NAME(__impl_type_decl);\n+        const char* pfx = IDENTIFIER_POINTER(spfx);\n+\n+        size_t len = strlen(mid) + strlen(pfx) + 2;\n+        size_t bsize = len * sizeof(char);\n+        char* buffer = (char*)alloca(bsize);\n+        gcc_assert(buffer);\n+        memset(buffer, 0, bsize);\n+\n+        snprintf(buffer, bsize, \"%s.%s\", pfx, mid);\n+        method_id = buffer;\n+    } else\n+        method_id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n+\n+    tree rtype = void_type_node;\n+    if (RDOT_FIELD2(node))\n+        rtype = dot_pass_rustToGccType(RDOT_FIELD2(node), false);\n+\n+    rdot parameters = RDOT_lhs_TT(node);\n+    tree fntype = error_mark_node;\n+    if (parameters != NULL_DOT) {\n+        size_t nparams = 0;\n+        rdot prm;\n+        for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN(prm))\n+            nparams++;\n+\n+        tree* gccparams = XALLOCAVEC(tree, nparams);\n+        size_t i = 0;\n+        for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN(prm)) {\n+            bool mut = false;\n+            if (RDOT_qual(prm))\n+                mut = true;\n+\n+            const char* pid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(prm));\n+            if (strcmp(pid, \"self\") == 0) {\n+                fatal_error(\"unhandled self argument!\");\n+            } else\n+                gccparams[i] = dot_pass_rustToGccType(RDOT_rhs_TT(prm), mut);\n+            i++;\n+        }\n+        fntype = build_function_type_array(rtype, nparams, gccparams);\n+    } else\n+        fntype = build_function_type_list(rtype, NULL_TREE);\n+\n+    tree fndecl = dot_pass_genFndecl_Basic(RDOT_LOCATION(node), method_id, fntype);\n+    SET_DECL_ASSEMBLER_NAME(fndecl, get_identifier(dot_pass_mangle(method_id)));\n+    dot_pass_pushContext();\n+\n+    rdot rdot_params = RDOT_lhs_TT(node);\n+    if (rdot_params != NULL_DOT) {\n+        tree argslist = NULL_TREE;\n+        rdot next;\n+        for (next = rdot_params; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+            const char* pid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n+            if (dot_pass_lookupCTU(pid) != error_mark_node)\n+                error(\"paramater [%s] is already declared\", pid);\n+\n+            tree ptype = error_mark_node;\n+            if (strcmp(pid, \"self\") == 0) {\n+                fatal_error(\"unhandled self param!\");\n+            } else\n+                ptype = dot_pass_rustToGccType(RDOT_rhs_TT(next), false);\n+\n+            tree param = build_decl(RDOT_LOCATION(node), PARM_DECL, get_identifier(pid), ptype);\n+            DECL_CONTEXT(param) = fndecl;\n+            DECL_ARG_TYPE(param) = ptype;\n+            TREE_READONLY(param) = true;\n+            TREE_USED(param) = true;\n+            argslist = chainon(argslist, param);\n+\n+            dot_pass_pushDecl(pid, param);\n+        }\n+        DECL_ARGUMENTS(fndecl) = argslist;\n+    }\n+\n+    current_function_decl = fndecl;\n+    tree block = alloc_stmt_list();\n+    current_function_block = &block;\n+\n+    global_retDecl_ = false;\n+    if (rtype == void_type_node)\n+        global_retDecl = error_mark_node;\n+    else\n+        global_retDecl = DECL_RESULT(fndecl);\n+\n+    // compile the block...\n+    dot_pass_compileSuite(RDOT_rhs_TT(node), &block);\n+\n+    // make sure it returns something!!!\n+    if (rtype != void_type_node) {\n+        if (global_retDecl_ == false) {\n+            error(\"Function [%s] doesn't seem to return anything!!\\n\", method_id);\n+            return error_mark_node;\n+        }\n+        tree returnVal = build1(RETURN_EXPR, rtype, global_retDecl);\n+        append_to_statement_list(returnVal, &block);\n+    }\n+\n+    tree bind = NULL_TREE;\n+    tree declare_vars = DECL_RESULT(fndecl);\n+\n+    tree head = declare_vars;\n+    std::vector<tree>* decl_vars = dot_pass_popContext();\n+    std::vector<tree>::iterator it;\n+    for (it = decl_vars->begin(); it != decl_vars->end(); ++it) {\n+        if (TREE_CODE(*it) != PARM_DECL) {\n+            DECL_CHAIN(head) = *it;\n+            head = *it;\n+        }\n+    }\n+    delete decl_vars;\n+\n+    tree bl = make_node(BLOCK);\n+    BLOCK_SUPERCONTEXT(bl) = fndecl;\n+    DECL_INITIAL(fndecl) = bl;\n+    BLOCK_VARS(bl) = declare_vars;\n+    TREE_USED(bl) = true;\n+\n+    bind = build3(BIND_EXPR, void_type_node, BLOCK_VARS(bl), NULL_TREE, bl);\n+    TREE_SIDE_EFFECTS(bind) = 1;\n+    /* Finalize the main function */\n+    BIND_EXPR_BODY(bind) = block;\n+    block = bind;\n+    DECL_SAVED_TREE(fndecl) = block;\n+\n+    gimplify_function_tree(fndecl);\n+    cgraph_finalize_function(fndecl, false);\n+\n+    pop_cfun();\n+\n+    // reset them\n+    global_retDecl = error_mark_node;\n+    global_retDecl_ = false;\n+\n+    return fndecl;\n+}\n+\n+// Seems to lower a struct and add it to somewhere, and returns a tree declaration of it?\n+static tree dot_pass_genifyStruct(rdot node) {\n+    rdot layout = RDOT_rhs_TT(node);\n+    tree userStruct = make_node(RECORD_TYPE);\n+\n+    bool first = true;\n+    tree head_chain = NULL_TREE;\n+    tree curr = head_chain;\n+\n+    rdot next;\n+    for (next = layout; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+        gcc_assert(RDOT_TYPE(next) == D_PARAMETER);\n+        tree name = get_identifier(RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next)));\n+        tree type = dot_pass_rustToGccType(RDOT_rhs_TT(next), false);\n+        tree field = build_decl(RDOT_LOCATION(node),\n+                                FIELD_DECL,\n+                                name,\n+                                type);\n+        DECL_CONTEXT(field) = userStruct;\n+        if (first == true) {\n+            head_chain = curr = field;\n+            first = false;\n+        } else {\n+            DECL_CHAIN(curr) = field;\n+            curr = field;\n+        }\n+    }\n+\n+    TYPE_FIELDS(userStruct) = head_chain;\n+    layout_type(userStruct);\n+\n+    const char* struct_id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n+    tree type_decl = build_decl(RDOT_LOCATION(node), TYPE_DECL, get_identifier(struct_id), userStruct);\n+    TYPE_NAME(userStruct) = get_identifier(struct_id);\n+    grs_preserve_from_gc(type_decl);\n+    rest_of_decl_compilation(type_decl, 1, 0);\n+    dot_pass_pushDecl(struct_id, userStruct);\n+    return type_decl;\n+}\n+\n+// Seems to lower a struct impl block, returning a pointer to a vector of trees containing various statements from it, e.g. function declarations\n+static std::vector<tree>* dot_pass_genifyImplBlock(rdot node) {\n+    std::vector<tree>* retval = new std::vector<tree>;\n+    // look up the struct type to set TYPE_METHODS on it...\n+    const char* implid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n+    tree type_decl = dot_pass_lookupCTU(implid);\n+    if (type_decl == error_mark_node)\n+        error(\"type [%s] does not exist for impl block\", implid);\n+    else {\n+        __impl_type_decl = type_decl;\n+        rdot decl;\n+        tree fndecl_chain = error_mark_node, curr = error_mark_node;\n+        bool first = true;\n+        for (decl = RDOT_rhs_TT(node); decl != NULL_DOT; decl = RDOT_CHAIN(decl)) {\n+            tree fndecl = dot_pass_genifyTopFndecl(decl);\n+            retval->push_back(fndecl);\n+            if (first == true) {\n+                fndecl_chain = fndecl;\n+                curr = fndecl_chain;\n+                first = false;\n+            } else {\n+                DECL_CHAIN(curr) = fndecl;\n+                curr = fndecl;\n+            }\n+        }\n+        TYPE_METHODS(__impl_type_decl) = fndecl_chain;\n+        __impl_type_decl = error_mark_node;\n+    }\n+    return retval;\n+}\n+\n+// Seems to be an entry point for lowering a top level declaration - handles struct methods?\n+static std::vector<tree>* dot_pass_genifyTopNode(rdot node) {\n+    std::vector<tree>* retval = NULL;\n+    switch (RDOT_TYPE(node)) {\n+        case D_STRUCT_METHOD: {\n+            retval = new std::vector<tree>;\n+            retval->push_back(dot_pass_genifyTopFndecl(node));\n+        } break;\n+\n+            // nothing to do here...\n+        case D_STRUCT_TYPE:\n+        case D_STRUCT_IMPL:\n+            break;\n+\n+        default:\n+            error(\"Unhandled Toplevel declaration [%s]\\n\", RDOT_OPCODE_STR(node));\n+            break;\n+    }\n+    return retval;\n+}\n+\n+// Appends runtime decls to context\n+static void dot_pass_setupContext(void) {\n+    std::map<std::string, tree>* lgrs = new std::map<std::string, tree>();\n+    rs_fill_runtime_decls(lgrs);\n+    context.push_back(lgrs);\n+}\n+\n+// Appends an empty map to context\n+static void dot_pass_pushContext(void) {\n+    std::map<std::string, tree>* nctx = new std::map<std::string, tree>;\n+    context.push_back(nctx);\n+}\n+\n+// Removes last element in vector, seems to move stuff in vector around too?\n+static std::vector<tree>* dot_pass_popContext(void) {\n+    std::vector<tree>* retval = new std::vector<tree>;\n+    if (context.size() > 0) {\n+        std::map<std::string, tree>* popd = context.back();\n+        context.pop_back();\n+\n+        std::map<std::string, tree>::iterator it;\n+        for (it = popd->begin(); it != popd->end(); ++it)\n+            retval->push_back(it->second);\n+\n+        delete popd;\n+    }\n+    return retval;\n+}\n+\n+// Seems to be the actual entry point of the entire logical unit - creates \"context\" and iterates through decls, lowering stuff\n+vec<tree, va_gc>* dot_pass_Genericify(vec<rdot, va_gc>* decls) {\n+    vec<tree, va_gc>* retval;\n+    vec_alloc(retval, 0);\n+\n+    dot_pass_setupContext();\n+    dot_pass_pushContext();\n+\n+    size_t i;\n+    rdot idtx = NULL_DOT;\n+\n+    /* fill up the prototypes now ... */\n+    for (i = 0; decls->iterate(i, &idtx); ++i) {\n+        rdot node = idtx;\n+        switch (RDOT_TYPE(node)) {\n+            case D_STRUCT_METHOD:\n+                dot_pass_genMethodProto(node);\n+                break;\n+\n+            case D_STRUCT_TYPE: {\n+                tree gen = dot_pass_genifyStruct(node);\n+                vec_safe_push(retval, gen);\n+            } break;\n+\n+            default:\n+                break;\n+        }\n+    }\n+\n+    if (seen_error())\n+        goto exit;\n+\n+    for (i = 0; decls->iterate(i, &idtx); ++i) {\n+        rdot node = idtx;\n+        switch (RDOT_TYPE(node)) {\n+            case D_STRUCT_IMPL: {\n+                std::vector<tree>* gdecls = dot_pass_genifyImplBlock(node);\n+                std::vector<tree>::iterator it;\n+                for (it = gdecls->begin(); it != gdecls->end(); ++it)\n+                    vec_safe_push(retval, *it);\n+                delete gdecls;\n+            } break;\n+\n+            default:\n+                break;\n+        }\n+    }\n+\n+    if (seen_error())\n+        goto exit;\n+\n+    __impl_type_decl = error_mark_node;\n+    for (i = 0; decls->iterate(i, &idtx); ++i) {\n+        std::vector<tree>* gdecls = dot_pass_genifyTopNode(idtx);\n+        if (gdecls != NULL) {\n+            std::vector<tree>::iterator it;\n+            for (it = gdecls->begin(); it != gdecls->end(); ++it)\n+                vec_safe_push(retval, *it);\n+            delete gdecls;\n+        }\n+    }\n+\n+exit:\n+    dot_pass_popContext();\n+    return retval;\n+}"}, {"sha": "553638d5eafdf13833e4cb6149f82f774676bb73", "filename": "gcc/rust/old/rdot-impl.cc", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-impl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-impl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-impl.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,253 @@\n+/* This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"rust.h\"\n+\n+static bool initilized = false;\n+\n+static const char* opcodeStrings[] = {\n+    /* [D_IDENTIFIER] */ \"identifier\",\n+    /* [D_T_INTEGER] */ \"literal_integer\",\n+    /* [D_T_FLOAT] */ \"literal_float\",\n+    /* [D_T_STRING] */ \"literal_string\",\n+    /* [D_T_LIST] */ \"liteal_list\",\n+    /* [D_VAR_DECL] */ \"var_decl\",\n+    /* [D_MODIFY_EXPR] */ \"modify_expr\",\n+    /* [D_MULT_EXPR] */ \"multiply_expr\",\n+    /* [D_DIVD_EXPR] */ \"divide_expr\",\n+    /* [D_ADD_EXPR] */ \"plus_expr\",\n+    /* [D_MINUS_EXPR] */ \"minus_expr\",\n+    /* [D_EQ_EQ_EXPR] */ \"equivilant_expr\",\n+    /* [D_LESS_EXPR] */ \"less_than_expr\",\n+    /* [D_LESS_EQ_EXPR] */ \"less_eq_expr\",\n+    /* [D_GREATER_EXPR] */ \"greater_expr\",\n+    /* [D_GREATER_EQ_EXPR] */ \"greater_eq_expr\",\n+    /* [D_NOT_EQ_EXPR] */ \"not_equal_expr\",\n+    /* [D_CALL_EXPR] */ \"call_expr\",\n+    /* [D_ATTRIB_EXPR] */ \"attribute_reference\",\n+    /* [D_ACC_EXPR] */ \"accessor_reference\",\n+    /* [D_STRUCT_METHOD] */ \"struct_method\",\n+    /* [D_STRUCT_WHILE] */ \"struct_while\",\n+    /* [D_STRUCT_LOOP] */ \"struct_loop\",\n+    /* [D_D_EXPR] */ \"enc_expression\",\n+    /* [D_TD_COM] */ \"TD_COM\",\n+    /* [D_TD_DOT] */ \"TD_DOT\",\n+    /* [D_TD_NULL] */ \"TD_NULL\",\n+    /* [D_PRIMITIVE] */ \"primitive\",\n+    /* [D_STRUCT_IF] */ \"struct_if\",\n+    /* [D_STRUCT_ELIF] */ \"struct_elif\",\n+    /* [D_STRUCT_ELSE] */ \"struct_else\",\n+    /* [D_STRUCT_CONDITIONAL] */ \"struct_conditional\",\n+    /* [RTYPE_BOOL] */ \"type_bool\",\n+    /* [RTYPE_INT] */ \"type_int\",\n+    /* [RTYPE_FLOAT] */ \"type_float\",\n+    /* [RTYPE_UINT] */ \"type_uint\",\n+    /* [RTYPE_INFER] */ \"type_infer\",\n+    /* [D_PARAMETER] */ \"parameter\",\n+    /* [D_STRUCT_TYPE] */ \"struct_definition\",\n+    /* [D_STRUCT_PARAM] */ \"struct_init_param\",\n+    /* [D_STRUCT_INIT] */ \"struct_initilization\",\n+    /* [RTYPE_USER_STRUCT] */ \"user_struct_type\",\n+    /* [D_STRUCT_ENUM] */ \"struct_enum\",\n+    /* [D_STRUCT_IMPL] */ \"impl_block\",\n+    /* [D_BOOLEAN] */ \"d_boolean\",\n+    /* [D_T_BOOL] */ \"d_t_bool\",\n+    /* [C_BREAK_STMT] */ \"break_stmt\",\n+    /* [C_CONT_STMT] */ \"continue_stmt\",\n+    /* [C_RETURN_STMT] */ \"return_stmt\",\n+};\n+\n+// Gets string representation of opcode_t instance (which defines possible types in a less strict sense that usual)\n+const char* rdot_getOpString_T(const opcode_t o) {\n+    return opcodeStrings[o];\n+}\n+\n+// Gets string representation of rdot's type\n+const char* rdot_getOpString(const rdot dot) {\n+    return rdot_getOpString_T(RDOT_TYPE(dot));\n+}\n+\n+// Ensures \"initilized\" is true\n+void rdot_init(void) {\n+    if (initilized)\n+        return;\n+    //... probably should get rid of this function ...\n+    initilized = true;\n+}\n+\n+// Presumably parses a variable declaration\n+rdot rdot_build_varDecl(rdot type, bool final, rdot id) {\n+    rdot decl = rdot_build_decl2(D_VAR_DECL, id, type);\n+    RDOT_qual(decl) = final;\n+    return decl;\n+}\n+\n+// Presumably allocates a new grs_tree_dot instance\n+rdot rdot_alloc(void) {\n+    rdot retval = (struct grs_tree_dot*)\n+      xmalloc(sizeof(struct grs_tree_dot));\n+    gcc_assert(retval);\n+    memset(retval, 0, sizeof(struct grs_tree_dot));\n+    RDOT_LOCATION(retval) = UNKNOWN_LOCATION;\n+    return retval;\n+}\n+\n+// Seems to parse a unary? declaration?\n+rdot rdot_build_decl1(opcode_t o, rdot t1) {\n+    rdot decl = RDOT_alloc;\n+\n+    RDOT_TYPE(decl) = o;\n+    RDOT_T_FIELD(decl) = D_TD_NULL;\n+    RDOT_FIELD(decl) = NULL_DOT;\n+\n+    decl->opaT = D_TD_DOT;\n+    decl->opa.t = t1;\n+    decl->opbT = D_TD_NULL;\n+\n+    RDOT_CHAIN(decl) = NULL_DOT;\n+\n+    return decl;\n+}\n+\n+// Seems to parse a binary? expression? (misleading name, amirite?)\n+rdot rdot_build_decl2(opcode_t o, rdot t1, rdot t2) {\n+    rdot decl = RDOT_alloc;\n+\n+    RDOT_TYPE(decl) = o;\n+    if ((o == D_VAR_DECL) || (o == D_MODIFY_EXPR) || (o == D_ADD_EXPR) || (o == D_MINUS_EXPR) \n+      || (o == D_MULT_EXPR) || (o == D_DIVD_EXPR) || (o == D_CALL_EXPR) || (o == D_EQ_EQ_EXPR) \n+      || (o == D_LESS_EXPR) || (o == D_LESS_EQ_EXPR) || (o == D_GREATER_EXPR) \n+      || (o == D_GREATER_EQ_EXPR) || (o == D_NOT_EQ_EXPR) || (o == D_ATTRIB_REF) || (o == D_ACC_EXPR) \n+      || (o == D_STRUCT_INIT))\n+        RDOT_T_FIELD(decl) = D_D_EXPR;\n+    else\n+        RDOT_T_FIELD(decl) = D_TD_NULL;\n+\n+    RDOT_FIELD(decl) = NULL_DOT;\n+\n+    decl->opaT = D_TD_DOT;\n+    decl->opa.t = t1;\n+    decl->opbT = D_TD_DOT;\n+    decl->opb.t = t2;\n+\n+    RDOT_CHAIN(decl) = NULL_DOT;\n+\n+    return decl;\n+}\n+\n+// parse in function declaration?\n+rdot rdot_build_fndecl(rdot ident, bool pub, rdot params, rdot rtype, rdot suite) {\n+    rdot decl = RDOT_alloc;\n+\n+    RDOT_TYPE(decl) = D_STRUCT_METHOD;\n+    RDOT_T_FIELD(decl) = D_TD_NULL;\n+\n+    RDOT_FIELD(decl) = ident;\n+    RDOT_FIELD2(decl) = rtype;\n+    DOT_RETVAL(decl) = pub;\n+\n+    decl->opaT = D_TD_DOT;\n+    decl->opa.t = params;\n+    decl->opbT = D_TD_DOT;\n+    decl->opb.t = suite;\n+\n+    RDOT_CHAIN(decl) = NULL_DOT;\n+\n+    return decl;\n+}\n+\n+// parse in int literal?\n+rdot rdot_build_integer(const int i) {\n+    rdot decl = RDOT_alloc;\n+    RDOT_TYPE(decl) = D_PRIMITIVE;\n+\n+    RDOT_FIELD(decl) = NULL_DOT;\n+    RDOT_T_FIELD(decl) = D_D_EXPR;\n+\n+    decl->opaT = D_TD_COM;\n+    decl->opa.tc.T = D_T_INTEGER;\n+    decl->opa.tc.o.integer = i;\n+\n+    return decl;\n+}\n+\n+// parse in float literal?\n+rdot rdot_build_float(const float f) {\n+    rdot decl = RDOT_alloc;\n+    RDOT_TYPE(decl) = D_PRIMITIVE;\n+\n+    RDOT_FIELD(decl) = NULL_DOT;\n+    RDOT_T_FIELD(decl) = D_D_EXPR;\n+\n+    decl->opaT = D_TD_COM;\n+    decl->opa.tc.T = D_T_FLOAT;\n+    decl->opa.tc.o.ffloat = f;\n+\n+    return decl;\n+}\n+\n+// parse in string literal?\n+rdot rdot_build_string(const char* s) {\n+    rdot decl = RDOT_alloc;\n+    RDOT_TYPE(decl) = D_PRIMITIVE;\n+\n+    RDOT_FIELD(decl) = NULL_DOT;\n+    RDOT_T_FIELD(decl) = D_D_EXPR;\n+\n+    decl->opaT = D_TD_COM;\n+    decl->opa.tc.T = D_T_STRING;\n+    decl->opa.tc.o.string = xstrdup(s);\n+\n+    return decl;\n+}\n+\n+// May parse in identifier\n+rdot rdot_build_identifier(const char* s) {\n+    rdot decl = RDOT_alloc;\n+\n+    RDOT_TYPE(decl) = D_IDENTIFIER;\n+    RDOT_FIELD(decl) = NULL_DOT;\n+    RDOT_T_FIELD(decl) = D_D_EXPR;\n+\n+    decl->opaT = D_TD_COM;\n+    decl->opa.tc.T = D_T_STRING;\n+    decl->opa.tc.o.string = xstrdup(s);\n+\n+    decl->opbT = D_TD_NULL;\n+\n+    RDOT_CHAIN(decl) = NULL_DOT;\n+\n+    return decl;\n+}\n+\n+// parse in boolean literal?\n+rdot rdot_build_bool(bool val) {\n+    rdot decl = RDOT_alloc;\n+\n+    RDOT_TYPE(decl) = D_BOOLEAN;\n+    RDOT_FIELD(decl) = NULL_DOT;\n+    RDOT_T_FIELD(decl) = D_D_EXPR;\n+\n+    decl->opaT = D_TD_COM;\n+    decl->opa.tc.T = D_T_BOOL;\n+    decl->opa.tc.o.boolean = val;\n+\n+    decl->opbT = D_TD_NULL;\n+\n+    RDOT_CHAIN(decl) = NULL_DOT;\n+\n+    return decl;\n+}"}, {"sha": "a3291aac8ee00d6eb7a77ea34932b87abb86ba1b", "filename": "gcc/rust/old/rdot-impl.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-impl.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,172 @@\n+/* This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#ifndef __GCC_RDOT_IMPL_H__\n+#define __GCC_RDOT_IMPL_H__\n+\n+typedef enum {\n+    D_IDENTIFIER = 0,\n+    D_T_INTEGER,\n+    D_T_FLOAT,\n+    D_T_STRING,\n+    D_T_LIST,\n+\n+    D_VAR_DECL,\n+    D_MODIFY_EXPR,\n+    D_MULT_EXPR,\n+    D_DIVD_EXPR,\n+    D_ADD_EXPR,\n+    D_MINUS_EXPR,\n+\n+    D_EQ_EQ_EXPR,\n+    D_LESS_EXPR,\n+    D_LESS_EQ_EXPR,\n+    D_GREATER_EXPR,\n+    D_GREATER_EQ_EXPR,\n+    D_NOT_EQ_EXPR,\n+\n+    D_CALL_EXPR,\n+    D_ATTRIB_REF,\n+    D_ACC_EXPR,\n+\n+    D_STRUCT_METHOD,\n+    D_STRUCT_WHILE,\n+    D_STRUCT_LOOP,\n+\n+    D_D_EXPR,\n+    D_TD_COM,\n+    D_TD_DOT,\n+    D_TD_NULL,\n+\n+    D_PRIMITIVE,\n+\n+    D_STRUCT_IF,\n+    D_STRUCT_ELIF,\n+    D_STRUCT_ELSE,\n+    D_STRUCT_CONDITIONAL,\n+\n+    RTYPE_BOOL,\n+    RTYPE_INT,\n+    RTYPE_FLOAT,\n+    RTYPE_UINT,\n+    RTYPE_INFER,\n+\n+    D_PARAMETER,\n+    D_STRUCT_TYPE,\n+    D_STRUCT_PARAM,\n+    D_STRUCT_INIT,\n+\n+    RTYPE_USER_STRUCT,\n+\n+    D_STRUCT_ENUM,\n+    D_STRUCT_IMPL,\n+\n+    D_BOOLEAN,\n+    D_T_BOOL,\n+\n+    C_BREAK_STMT,\n+    C_CONT_STMT,\n+    C_RETURN_STMT\n+} opcode_t;\n+\n+typedef enum {\n+    ALLOC_HEAP,\n+    ALLOC_REF,\n+    ALLOC_DEREF\n+} ALLOCA_;\n+\n+// Seems to be primitive literals\n+typedef struct grs_rdot_tree_common {\n+    // probably actual type used (tag for tagged union)\n+    opcode_t T;\n+    // possible values\n+    union {\n+        int integer;\n+        float ffloat;\n+        unsigned char c;\n+        char* string;\n+        bool boolean;\n+    } o;\n+} rdot_tree_common;\n+\n+typedef struct GTY(()) grs_tree_dot {\n+    opcode_t T, FT, opaT, opbT;\n+    bool retval, qual;\n+    std::vector<ALLOCA_> alloca_modifier;\n+    location_t loc;\n+    struct grs_tree_dot* field1;\n+    struct grs_tree_dot* field2;\n+    union {\n+        rdot_tree_common tc;\n+        struct grs_tree_dot* t;\n+    } opa;\n+    union {\n+        rdot_tree_common tc;\n+        struct grs_tree_dot* t;\n+    } opb;\n+    struct grs_tree_dot* next;\n+} * rdot;\n+\n+// A null rdot instance\n+#define NULL_DOT ((rdot)0)\n+#define RDOT_alloc rdot_alloc()\n+// Gets type of rdot instance\n+#define RDOT_TYPE(x_) x_->T\n+// Seems to get location_t for rdot\n+#define RDOT_LOCATION(x_) x_->loc\n+#define RDOT_T_FIELD(x_) x_->FT\n+#define RDOT_CHAIN(x_) x_->next\n+#define RDOT_FIELD(x_) x_->field1\n+#define RDOT_FIELD2(x_) x_->field2\n+#define RDOT_lhs_T(x_) x_->opaT\n+#define RDOT_rhs_T(x_) x_->opbT\n+#define RDOT_lhs_TT(x_) x_->opa.t\n+#define RDOT_rhs_TT(x_) x_->opb.t\n+#define RDOT_lhs_TC(x_) x_->opa.tc\n+#define RDOT_rhs_TC(x_) x_->opb.tc\n+#define RDOT_qual(x_) x_->qual\n+#define DOT_RETVAL(x_) x_->retval\n+#define RDOT_MEM_MODIFIER(x_) (&(x_->alloca_modifier))\n+#define RDOT_IDENTIFIER_POINTER(x_) RDOT_lhs_TC(x_).o.string\n+#define RDOT_BOOLEAN_VAL(x_) RDOT_lhs_TC(x_).o.boolean\n+#define RDOT_CODE_STR(x_) rdot_getOpString_T(x_)\n+#define RDOT_OPCODE_STR(x_) rdot_getOpString(x_)\n+\n+// destination is cleared before copy\n+// copy a vector (source, destination)\n+#define RDOT_MMEM_COPY(x_, y_)                              \\\n+    do {                                                    \\\n+        y_->clear();                                        \\\n+        std::vector<ALLOCA_>::iterator __it;                \\\n+        for (__it = x_->begin(); __it != x_->end(); ++__it) \\\n+            y_->push_back(*__it);                           \\\n+    } while (0)\n+\n+extern rdot rdot_alloc(void);\n+extern void rdot_init(void);\n+extern rdot rdot_build_decl1(opcode_t, rdot);\n+extern rdot rdot_build_decl2(opcode_t, rdot, rdot);\n+extern rdot rdot_build_fndecl(rdot, bool, rdot, rdot, rdot);\n+extern rdot rdot_build_float(const float);\n+extern rdot rdot_build_integer(const int);\n+extern rdot rdot_build_string(const char*);\n+extern rdot rdot_build_identifier(const char*);\n+extern rdot rdot_build_bool(bool);\n+extern rdot rdot_build_varDecl(rdot, bool, rdot);\n+extern const char* rdot_getOpString(const rdot);\n+extern const char* rdot_getOpString_T(const opcode_t);\n+\n+#endif //__GCC_RDOT_IMPL_H__"}, {"sha": "2df5773e2c07e7e3e4d329de04a85b6a0ac79bbc", "filename": "gcc/rust/old/rdot-pretty-print.cc", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frdot-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-pretty-print.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,599 @@\n+/* This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"rust.h\"\n+\n+static bool _no_infer = false;\n+static bool first = true;\n+\n+#define RDOT_PREFIX_PRE \".pre-rdot\"\n+#define RDOT_PREFIX_POST \".pst-rdot\"\n+\n+// Array of type strings? Seems incomplete if it is. Perhaps just parser \"primitives\"?\n+static const char* typeStrings[] = {\n+    \"bool\",\n+    \"int\",\n+    \"float\",\n+    \"unsigned_int\",\n+    \"__infer_me\",\n+    \"__user_struct\",\n+    \"void\"\n+};\n+\n+// Seems to determine type of node as per typeStrings array\n+static char* typeStringNode(const rdot node) {\n+    char buffer[128];\n+    size_t offset = 0;\n+    if (RDOT_MEM_MODIFIER(node)) {\n+        std::vector<ALLOCA_>::iterator it;\n+        for (it = RDOT_MEM_MODIFIER(node)->begin();\n+             it != RDOT_MEM_MODIFIER(node)->end();\n+             ++it) {\n+            switch (*it) {\n+                case ALLOC_HEAP: {\n+                    buffer[offset] = '~';\n+                    offset++;\n+                } break;\n+                case ALLOC_REF: {\n+                    buffer[offset] = '&';\n+                    offset++;\n+                } break;\n+                case ALLOC_DEREF: {\n+                    buffer[offset] = '*';\n+                    offset++;\n+                } break;\n+            }\n+        }\n+    }\n+    if (node != NULL_DOT) {\n+        switch (RDOT_TYPE(node)) {\n+            case RTYPE_BOOL:\n+                strcpy(buffer + offset, typeStrings[0]);\n+                break;\n+\n+            case RTYPE_INT:\n+                strcpy(buffer + offset, typeStrings[1]);\n+                break;\n+\n+            case RTYPE_FLOAT:\n+                strcpy(buffer + offset, typeStrings[2]);\n+                break;\n+\n+            case RTYPE_UINT:\n+                strcpy(buffer + offset, typeStrings[3]);\n+                break;\n+\n+            case RTYPE_INFER: {\n+                if (_no_infer)\n+                    fatal_error(\"gcc-rust has failed to infer a type and cannot continue\");\n+                else\n+                    strcpy(buffer + offset, typeStrings[4]);\n+            } break;\n+\n+            case RTYPE_USER_STRUCT:\n+                strcpy(buffer + offset, RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node)));\n+                break;\n+\n+            default:\n+                fatal_error(\"unhandled type [%s]\", RDOT_OPCODE_STR(node));\n+                break;\n+        }\n+    }\n+    return xstrdup(buffer);\n+}\n+\n+static void dot_pass_dump_node(FILE*, rdot, size_t);\n+static void dot_pass_dump_method(FILE*, rdot, size_t);\n+static void dot_pass_dump_struct(FILE*, rdot, size_t);\n+\n+static void dot_pass_dumpPrimitive(FILE*, rdot);\n+static void dot_pass_dumpExprNode(FILE*, rdot);\n+static void dot_pass_dump_expr(FILE*, rdot);\n+\n+// Seems to dump struct at node to file fd\n+static void dot_pass_dump_struct(FILE* fd, rdot node, size_t indents) {\n+    size_t i;\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"  \");\n+\n+    rdot ident = RDOT_lhs_TT(node);\n+    rdot layout = RDOT_rhs_TT(node);\n+\n+    fprintf(fd, \"struct %s {\\n\", RDOT_IDENTIFIER_POINTER(ident));\n+    rdot next;\n+    for (next = layout; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+        gcc_assert(RDOT_TYPE(next) = D_PARAMETER);\n+        const char* id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n+        const char* typestr = typeStringNode(RDOT_rhs_TT(next));\n+\n+        for (i = 0; i < (indents + 1); ++i)\n+            fprintf(fd, \"  \");\n+        fprintf(fd, \"%s %s;\\n\", typestr, id);\n+    }\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"  \");\n+    fprintf(fd, \"}\\n\");\n+}\n+\n+// Seems to dump method at node to file fd\n+static void dot_pass_dump_method(FILE* fd, rdot node, size_t indents) {\n+    size_t i;\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"  \");\n+\n+    const char* method_id = RDOT_IDENTIFIER_POINTER(RDOT_FIELD(node));\n+    char* rtype = NULL;\n+    if (RDOT_FIELD2(node))\n+        rtype = typeStringNode(RDOT_FIELD2(node));\n+    else\n+        rtype = xstrdup(\"void\");\n+    rdot parameters = RDOT_lhs_TT(node);\n+\n+    if (DOT_RETVAL(node))\n+        fprintf(fd, \"pub fn %s ( \", method_id);\n+    else\n+        fprintf(fd, \"fn %s ( \", method_id);\n+\n+    if (parameters == NULL_DOT)\n+        fprintf(fd, \"void\");\n+    else {\n+        rdot next;\n+        for (next = parameters; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+            gcc_assert(RDOT_TYPE(next) = D_PARAMETER);\n+            bool iself = false;\n+            bool muta = RDOT_qual(next);\n+            const char* id = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n+\n+            if (strcmp(id, \"self\") == 0)\n+                iself = true;\n+\n+            const char* smuta;\n+            if (muta) {\n+                smuta = \"mut\";\n+            } else {\n+                smuta = \"final\";\n+            }\n+\n+            if (iself)\n+                fprintf(fd, \"[%s] _self_\", smuta);\n+            else {\n+                const char* typestr = typeStringNode(RDOT_rhs_TT(next));\n+                fprintf(fd, \"[%s] %s:%s\", smuta, typestr, id);\n+            }\n+            if (RDOT_CHAIN(next) != NULL_DOT)\n+                fprintf(fd, \", \");\n+        }\n+    }\n+    fprintf(fd, \" ) -> %s {\\n\", rtype);\n+    free(rtype);\n+\n+    rdot suite;\n+    for (suite = RDOT_rhs_TT(node); suite != NULL_DOT; suite = RDOT_CHAIN(suite)) {\n+        dot_pass_dump_node(fd, suite, indents + 1);\n+        fprintf(fd, \"\\n\");\n+    }\n+\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"  \");\n+    fprintf(fd, \"}\\n\");\n+}\n+\n+// Dumps primitive at RDOT_lhs_TC(node) to inputted file\n+static void dot_pass_dumpPrimitive(FILE* fd, rdot node) {\n+    /* Handle other primitive literal types here ... */\n+    switch (RDOT_lhs_TC(node).T) {\n+        case D_T_INTEGER:\n+            fprintf(fd, \"%i\", RDOT_lhs_TC(node).o.integer);\n+            break;\n+\n+        case D_T_FLOAT:\n+            fprintf(fd, \"%f\", RDOT_lhs_TC(node).o.ffloat);\n+            break;\n+\n+        case D_T_STRING:\n+            fprintf(fd, \"\\\"%s\\\"\", RDOT_lhs_TC(node).o.string);\n+            break;\n+\n+        default:\n+            fatal_error(\"Unable to dump primitive [%s]\",\n+                        rdot_getOpString_T(RDOT_lhs_TC(node).T));\n+            break;\n+    }\n+}\n+\n+// Dumps expression node to file fd. (this includes a lot of stuff, such as dumping expression itself)\n+static void dot_pass_dumpExprNode(FILE* fd, rdot node) {\n+    if (RDOT_MEM_MODIFIER(node)) {\n+        std::vector<ALLOCA_>::iterator it;\n+        for (it = RDOT_MEM_MODIFIER(node)->begin();\n+             it != RDOT_MEM_MODIFIER(node)->end();\n+             ++it) {\n+            switch (*it) {\n+                case ALLOC_DEREF:\n+                    fprintf(fd, \"*\");\n+                    break;\n+                case ALLOC_HEAP:\n+                    fprintf(fd, \"~\");\n+                    break;\n+                case ALLOC_REF:\n+                    fprintf(fd, \"&\");\n+                    break;\n+            }\n+        }\n+    }\n+    switch (RDOT_TYPE(node)) {\n+        case D_PRIMITIVE:\n+            dot_pass_dumpPrimitive(fd, node);\n+            break;\n+\n+        case D_IDENTIFIER:\n+            fprintf(fd, \"%s\", RDOT_IDENTIFIER_POINTER(node));\n+            break;\n+\n+        case D_BOOLEAN: {\n+            bool val = RDOT_BOOLEAN_VAL(node);\n+            if (val)\n+                fprintf(fd, \"true\");\n+            else\n+                fprintf(fd, \"false\");\n+        } break;\n+\n+        case D_CALL_EXPR: {\n+            rdot id = RDOT_lhs_TT(node);\n+            dot_pass_dump_expr(fd, id);\n+            fprintf(fd, \" (\");\n+\n+            rdot p;\n+            for (p = RDOT_rhs_TT(node); p != NULL_DOT; p = RDOT_CHAIN(p)) {\n+                dot_pass_dump_expr(fd, p);\n+                if (RDOT_CHAIN(p) != NULL_DOT)\n+                    fprintf(fd, \", \");\n+            }\n+            fprintf(fd, \")\");\n+        } break;\n+\n+        case D_VAR_DECL: {\n+            const char* mut;\n+            if (RDOT_qual(node))\n+                mut = \"_final_\";\n+            else\n+                mut = \"_mut_\";\n+\n+            fprintf(fd, \"let [%s] \", mut);\n+            dot_pass_dumpExprNode(fd, RDOT_lhs_TT(node));\n+            fprintf(fd, \" -> [%s]\", typeStringNode(RDOT_rhs_TT(node)));\n+        } break;\n+\n+        case D_STRUCT_INIT: {\n+            rdot ident = RDOT_lhs_TT(node);\n+            rdot init = RDOT_rhs_TT(node);\n+\n+            fprintf(fd, \"%s { \", RDOT_IDENTIFIER_POINTER(ident));\n+            rdot next;\n+            for (next = init; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+                gcc_assert(RDOT_TYPE(next) == D_STRUCT_PARAM);\n+                const char* name = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n+\n+                fprintf(fd, \"%s:(\", name);\n+                dot_pass_dump_expr(fd, RDOT_rhs_TT(next));\n+                fprintf(fd, \")\");\n+                if (RDOT_CHAIN(next) != NULL_DOT)\n+                    fprintf(fd, \", \");\n+            }\n+            fprintf(fd, \" }\");\n+        } break;\n+\n+        default:\n+            error(\"unhandled dumpExprNode [%s]\\n\", RDOT_OPCODE_STR(node));\n+            break;\n+    }\n+}\n+\n+// Seems to dump expression to file fd\n+static void dot_pass_dump_expr(FILE* fd, rdot node) {\n+    if (DOT_RETVAL(node)) {\n+        fprintf(fd, \"[_rust_retval]: \");\n+    }\n+\n+    switch (RDOT_TYPE(node)) {\n+        case D_PRIMITIVE:\n+        case D_IDENTIFIER:\n+        case D_CALL_EXPR:\n+        case D_BOOLEAN:\n+        case D_VAR_DECL:\n+        case D_STRUCT_INIT:\n+            dot_pass_dumpExprNode(fd, node);\n+            break;\n+\n+        default: {\n+            /* print expr tree ... */\n+            rdot lhs = RDOT_lhs_TT(node);\n+            rdot rhs = RDOT_rhs_TT(node);\n+\n+            dot_pass_dump_expr(fd, lhs);\n+            switch (RDOT_TYPE(node)) {\n+                case D_MODIFY_EXPR:\n+                    fprintf(fd, \" = \");\n+                    break;\n+\n+                case D_ADD_EXPR:\n+                    fprintf(fd, \" + \");\n+                    break;\n+\n+                case D_MINUS_EXPR:\n+                    fprintf(fd, \" - \");\n+                    break;\n+\n+                case D_MULT_EXPR:\n+                    fprintf(fd, \" * \");\n+                    break;\n+\n+                case D_LESS_EXPR:\n+                    fprintf(fd, \" < \");\n+                    break;\n+\n+                case D_LESS_EQ_EXPR:\n+                    fprintf(fd, \" <= \");\n+                    break;\n+\n+                case D_GREATER_EXPR:\n+                    fprintf(fd, \" > \");\n+                    break;\n+\n+                case D_GREATER_EQ_EXPR:\n+                    fprintf(fd, \" >= \");\n+                    break;\n+\n+                case D_EQ_EQ_EXPR:\n+                    fprintf(fd, \" == \");\n+                    break;\n+\n+                case D_NOT_EQ_EXPR:\n+                    fprintf(fd, \" != \");\n+                    break;\n+\n+                case D_ATTRIB_REF:\n+                    fprintf(fd, \".\");\n+                    break;\n+\n+                case D_ACC_EXPR:\n+                    fprintf(fd, \"::\");\n+                    break;\n+\n+                default:\n+                    fatal_error(\"unhandled dump [%s]!\\n\", RDOT_OPCODE_STR(node));\n+                    break;\n+            }\n+            dot_pass_dump_expr(fd, rhs);\n+        } break;\n+    }\n+}\n+\n+// Seems to dump rust \"enum\" to file fd\n+static void dot_pass_dump_enum(FILE* fd, rdot node, size_t indents) {\n+    rdot enum_id = RDOT_lhs_TT(node);\n+    rdot enum_layout = RDOT_rhs_TT(node);\n+\n+    size_t i;\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+    const char* id = RDOT_IDENTIFIER_POINTER(enum_id);\n+    fprintf(fd, \"enum %s {\\n\", id);\n+\n+    indents++;\n+    rdot next;\n+    for (next = enum_layout; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+        for (i = 0; i < indents; ++i)\n+            fprintf(fd, \"    \");\n+        const char* enumit = RDOT_IDENTIFIER_POINTER(next);\n+        fprintf(fd, \"[%s],\\n\", enumit);\n+    }\n+    indents--;\n+\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+    fprintf(fd, \"}\\n\");\n+}\n+\n+// Seems to dump conditional to file fd\n+static void dot_pass_dump_cond(FILE* fd, rdot node, size_t indents) {\n+    size_t i;\n+    rdot ifb = RDOT_lhs_TT(node);\n+    rdot elb = RDOT_rhs_TT(node);\n+\n+    gcc_assert(RDOT_TYPE(ifb) == D_STRUCT_IF);\n+\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+\n+    fprintf(fd, \"if (\");\n+    dot_pass_dump_expr(fd, RDOT_lhs_TT(ifb));\n+    fprintf(fd, \") {\\n\");\n+\n+    rdot next;\n+    for (next = RDOT_rhs_TT(ifb); next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+        dot_pass_dump_node(fd, next, indents + 1);\n+        fprintf(fd, \"\\n\");\n+    }\n+\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+    fprintf(fd, \"}\");\n+\n+    if (elb != NULL_DOT) {\n+        fprintf(fd, \" else {\\n\");\n+        for (next = RDOT_lhs_TT(elb); next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+            dot_pass_dump_node(fd, next, indents + 1);\n+            fprintf(fd, \"\\n\");\n+        }\n+        for (i = 0; i < indents; ++i)\n+            fprintf(fd, \"    \");\n+        fprintf(fd, \"}\\n\");\n+    }\n+}\n+\n+// Seems to dump break to file fd\n+static void dot_pass_dump_break(FILE* fd, const rdot node, size_t indents) {\n+    size_t i;\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+    fprintf(fd, \"break;\");\n+}\n+\n+// Seems to dump loop construct to file fd\n+static void dot_pass_dump_loop(FILE* fd, const rdot node, size_t indents) {\n+    const rdot suite = RDOT_lhs_TT(node);\n+    size_t i;\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+    fprintf(fd, \"loop {\\n\");\n+\n+    rdot next;\n+    for (next = suite; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+        dot_pass_dump_node(fd, next, indents + 1);\n+        fprintf(fd, \"\\n\");\n+    }\n+\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+    fprintf(fd, \"}\\n\");\n+}\n+\n+// Seems to dump while to file fd\n+static void dot_pass_dump_while(FILE* fd, const rdot node, size_t indents) {\n+    size_t i;\n+    rdot expr = RDOT_lhs_TT(node);\n+    rdot suite = RDOT_rhs_TT(node);\n+\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+    fprintf(fd, \"while (\");\n+    dot_pass_dump_expr(fd, expr);\n+    fprintf(fd, \") {\\n\");\n+\n+    rdot next;\n+    for (next = suite; next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+        dot_pass_dump_node(fd, next, indents + 1);\n+        fprintf(fd, \"\\n\");\n+    }\n+\n+    for (i = 0; i < indents; ++i)\n+        fprintf(fd, \"    \");\n+    fprintf(fd, \"}\");\n+}\n+\n+// Seems to dump impl block to file fd\n+static void dot_pass_dump_impl(FILE* fd, rdot node, size_t indents) {\n+    const char* implid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(node));\n+    fprintf(fd, \"impl %s {\\n\", implid);\n+\n+    rdot next;\n+    for (next = RDOT_rhs_TT(node); next != NULL_DOT; next = RDOT_CHAIN(next)) {\n+        dot_pass_dump_node(fd, next, indents + 1);\n+        fprintf(fd, \"\\n\");\n+    }\n+\n+    fprintf(fd, \"}\\n\");\n+}\n+\n+// Seems to be a selector that dumps a node of a given type to file fd - switches between them\n+static void dot_pass_dump_node(FILE* fd, rdot node, size_t indents) {\n+    if (RDOT_T_FIELD(node) == D_D_EXPR) {\n+        size_t i;\n+        for (i = 0; i < indents; ++i)\n+            fprintf(fd, \"    \");\n+        dot_pass_dump_expr(fd, node);\n+        fprintf(fd, \";\");\n+    } else {\n+        switch (RDOT_TYPE(node)) {\n+            case D_PRIMITIVE:\n+                dot_pass_dump_expr(fd, node);\n+                break;\n+\n+            case D_STRUCT_IMPL:\n+                dot_pass_dump_impl(fd, node, indents);\n+                break;\n+\n+            case D_STRUCT_METHOD:\n+                dot_pass_dump_method(fd, node, indents);\n+                break;\n+\n+            case D_STRUCT_TYPE:\n+                dot_pass_dump_struct(fd, node, indents);\n+                break;\n+\n+            case D_STRUCT_ENUM:\n+                dot_pass_dump_enum(fd, node, indents);\n+                break;\n+\n+            case D_STRUCT_IF:\n+                dot_pass_dump_cond(fd, node, indents);\n+                break;\n+\n+            case D_STRUCT_WHILE:\n+                dot_pass_dump_while(fd, node, indents);\n+                break;\n+\n+            case D_STRUCT_LOOP:\n+                dot_pass_dump_loop(fd, node, indents);\n+                break;\n+\n+            case C_BREAK_STMT:\n+                dot_pass_dump_break(fd, node, indents);\n+                break;\n+\n+            default:\n+                error(\"unhandled node [%s]\\n\", RDOT_OPCODE_STR(node));\n+                break;\n+        }\n+    }\n+}\n+\n+// Seems to be main entry point into dumping - dumps all decls to file\n+vec<rdot, va_gc>* dot_pass_PrettyPrint(vec<rdot, va_gc>* decls) {\n+    if (GRS_OPT_dump_dot) {\n+        size_t bsize = 128;\n+        char* outfile = (char*)alloca(bsize);\n+        gcc_assert(outfile);\n+        memset(outfile, 0, bsize);\n+\n+        strncpy(outfile, GRS_current_infile, strlen(GRS_current_infile));\n+        if (first == true) {\n+            strncat(outfile, RDOT_PREFIX_PRE, sizeof(RDOT_PREFIX_PRE));\n+            first = false;\n+        } else {\n+            strncat(outfile, RDOT_PREFIX_POST, sizeof(RDOT_PREFIX_POST));\n+            _no_infer = true;\n+        }\n+\n+        FILE* fd = fopen(outfile, \"w\");\n+        if (!fd) {\n+            error(\"Unable to open %s for write\\n\", outfile);\n+            goto exit;\n+        }\n+\n+        rdot idtx = NULL_DOT;\n+        size_t i;\n+        for (i = 0; decls->iterate(i, &idtx); ++i) {\n+            dot_pass_dump_node(fd, idtx, 0);\n+            fprintf(fd, \"\\n\");\n+        }\n+\n+        fclose(fd);\n+    }\n+exit:\n+    return decls;\n+}"}, {"sha": "924584748bff0d9963e5155ca87215c333f63eea", "filename": "gcc/rust/old/rs-lang.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-lang.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,326 @@\n+// rs-lang.cc - frontend interface or something\n+// NOTE: should be mentioned in gtfiles in config-lang.in\n+/* This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.\n+*/\n+#include \"rust.h\"\n+\n+// May not need this?\n+char* GRS_current_infname;\n+char* GRS_current_infile;\n+\n+/* Language-dependent contents of a type. GTY() mark used for garbage collector. */\n+struct GTY(()) lang_type {\n+    char dummy;\n+};\n+\n+/* Language-dependent contents of a decl.  */\n+struct GTY(()) lang_decl {\n+    char dummy;\n+};\n+\n+/* Language-dependent contents of an identifier.  This must include a\n+   tree_identifier.\n+*/\n+struct GTY(()) lang_identifier {\n+    struct tree_identifier common;\n+};\n+\n+/* The resulting tree type.  */\n+union GTY((desc(\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n+           chain_next(\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), \"\n+           \"TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n+  lang_tree_node {\n+    union tree_node GTY((tag(\"0\"),\n+                         desc(\"tree_node_structure (&%h)\"))) generic;\n+    struct lang_identifier GTY((tag(\"1\"))) identifier;\n+};\n+\n+/* We don't use language_function.  */\n+struct GTY(()) language_function {\n+    int dummy;\n+};\n+\n+/* Language hooks.  */\n+\n+/* Initial lang hook called (possibly), used for initialisation. \n+ * Must call build_common_tree_nodes, set_sizetype, build_common_tree_nodes_2, and \n+ * build_common_builtin_nodes, as well as set global variable void_list_node. */\n+static bool grs_langhook_init(void) {\n+    /* Something to do with this: \n+     This allows the code in d-builtins.cc to not have to worry about\n+     converting (C signed char *) to (D char *) for string arguments of\n+     built-in functions. The parameter (signed_char = false) specifies\n+     whether char is signed.  */\n+    build_common_tree_nodes(false);\n+\n+    // Creates a new TREE_LIST node with purpose NULL_TREE and value void_type_node\n+    void_list_node = build_tree_list(NULL_TREE, void_type_node);\n+\n+    // Builds built-ins for middle-end after all front-end built-ins are already instantiated\n+    build_common_builtin_nodes();\n+\n+    mpfr_set_default_prec(128);\n+    using_eh_for_cleanups();\n+\n+    rdot_init();\n+    return true;\n+}\n+\n+/* Initialize before parsing options.  */\n+static void grs_langhook_init_options_struct(struct gcc_options* opts) {\n+    /* Go says that signed overflow is precisely defined.  */\n+    opts->x_flag_wrapv = 1;\n+\n+    /* We default to using strict aliasing, since Go pointers are safe.\n+     This is turned off for code that imports the \"unsafe\" package,\n+     because using unsafe.pointer violates C style aliasing\n+     requirements.  */\n+    opts->x_flag_strict_aliasing = 1;\n+\n+    /* Default to avoiding range issues for complex multiply and\n+     divide.  */\n+    opts->x_flag_complex_method = 2;\n+\n+    /* The builtin math functions should not set errno.  */\n+    opts->x_flag_errno_math = 0;\n+    opts->frontend_set_flag_errno_math = true;\n+\n+    /* We turn on stack splitting if we can.  */\n+    if (targetm_common.supports_split_stack(false, opts))\n+        opts->x_flag_split_stack = 1;\n+\n+    /* Exceptions are used to handle recovering from panics.  */\n+    opts->x_flag_exceptions = 1;\n+    opts->x_flag_non_call_exceptions = 1;\n+}\n+\n+/* Handle grs specific options.  Return 0 if we didn't do anything.  */\n+static bool grs_langhook_handle_option(size_t scode, const char* arg ATTRIBUTE_UNUSED, \n+    int value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED, location_t l ATTRIBUTE_UNUSED, \n+    const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n+    enum opt_code code = (enum opt_code)scode;\n+    int retval = 1;\n+\n+    switch (code) {\n+            /* ignore options for now... */\n+\n+        default:\n+            break;\n+    }\n+\n+    return retval;\n+}\n+\n+/* Run after parsing options.  */\n+static bool grs_langhook_post_options(const char** pfilename ATTRIBUTE_UNUSED) {\n+    if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT)\n+        flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n+\n+    /* Returning false means that the backend should be used.  */\n+    return false;\n+}\n+\n+/* Main entry point for front-end, apparently. Finds input file names in global vars in_fnames and \n+ * num_in_fnames. From this, frontend can take over and do actual parsing and initial compilation.\n+ * This function must create a complete parse tree in a global var, and then return. \n+ * \n+ * Some consider this the \"start of compilation\". */ \n+static void grs_langhook_parse_file(void) {\n+    size_t idx;\n+\n+    // loop through all files in in_fnames array\n+    for (idx = 0; idx < num_in_fnames; ++idx) {\n+        const char* in = in_fnames[idx];\n+        GRS_current_infname = xstrdup(in);\n+        GRS_current_infile = basename(GRS_current_infname);\n+\n+        // parse file. seems to call flex-generated lexer, which then calls bison-generated parser\n+        grs_do_compile(in);\n+        // seems very coupled to old gccrs' lexer - e.g. rustc lexer handles parsing outside of the lexer\n+        // note that apparently bison generates the \"yyparse\" automatically - perhaps the rs-parser.cc was actually generated using bison\n+    }\n+}\n+\n+static tree grs_langhook_type_for_mode(enum machine_mode mode, int unsignedp) {\n+    if (mode == TYPE_MODE(float_type_node))\n+        return float_type_node;\n+\n+    if (mode == TYPE_MODE(double_type_node))\n+        return double_type_node;\n+\n+    // More code about other type_nodes here? intQI, intHI, intSI, intDI, intTI?\n+    // Don't know what they mean, but one site has them here in a similar fashion of selections\n+\n+    if (mode == TYPE_MODE(integer_type_node))\n+        return unsignedp ? unsigned_type_node : integer_type_node;\n+\n+    if (mode == TYPE_MODE(long_integer_type_node))\n+        return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n+\n+    if (COMPLEX_MODE_P(mode)) {\n+        if (mode == TYPE_MODE(complex_float_type_node))\n+            return complex_float_type_node;\n+        if (mode == TYPE_MODE(complex_double_type_node))\n+            return complex_double_type_node;\n+        if (mode == TYPE_MODE(complex_long_double_type_node))\n+            return complex_long_double_type_node;\n+        if (mode == TYPE_MODE(complex_integer_type_node) && !unsignedp)\n+            return complex_integer_type_node;\n+    }\n+    /* gcc_unreachable */\n+    return NULL;\n+}\n+\n+static tree grs_langhook_type_for_size(unsigned int bits ATTRIBUTE_UNUSED, \n+    int unsignedp ATTRIBUTE_UNUSED) {\n+    gcc_unreachable();\n+    return NULL_TREE;\n+}\n+\n+/* Record a builtin function.  We just ignore builtin functions.  */\n+static tree grs_langhook_builtin_function(tree decl ATTRIBUTE_UNUSED) {\n+    return decl;\n+}\n+\n+static bool grs_langhook_global_bindings_p(void) {\n+    return current_function_decl == NULL_TREE;\n+}\n+\n+static tree grs_langhook_pushdecl(tree decl ATTRIBUTE_UNUSED) {\n+    gcc_unreachable();\n+    return NULL;\n+}\n+\n+static tree grs_langhook_getdecls(void) {\n+    gcc_unreachable();\n+    return NULL;\n+}\n+\n+/* Write out globals.  */\n+static void grs_langhook_write_globals(void) {\n+    // pass off to middle end function basically.\n+    dot_pass_WriteGlobals();\n+}\n+\n+static unsigned int grs_langhook_option_lang_mask(void) {\n+    return CL_Rust;\n+}\n+\n+/* Return a decl for the exception personality function.  The function\n+   itself is implemented in libgo/runtime/go-unwind.c.  */\n+static tree grs_langhook_eh_personality(void) {\n+    static tree personality_decl;\n+    if (personality_decl == NULL_TREE) {\n+        personality_decl = build_personality_function(\"gccrs\");\n+        grs_preserve_from_gc(personality_decl);\n+    }\n+    return personality_decl;\n+}\n+\n+static int\n+grs_langhook_gimplify_expr(tree* expr_p ATTRIBUTE_UNUSED,\n+                           gimple_seq* pre_p ATTRIBUTE_UNUSED,\n+                           gimple_seq* post_p ATTRIBUTE_UNUSED) {\n+    if (TREE_CODE(*expr_p) == CALL_EXPR && CALL_EXPR_STATIC_CHAIN(*expr_p) != NULL_TREE)\n+        gimplify_expr(&CALL_EXPR_STATIC_CHAIN(*expr_p), pre_p, post_p, is_gimple_val, fb_rvalue);\n+    /* Often useful to use debug_tree here to see whats going on because\n+     ever gimplication calls this. */\n+    // debug_tree (*expr_p)\n+    return GS_UNHANDLED;\n+}\n+\n+/* Functions called directly by the generic backend.  */\n+tree convert(tree type, tree expr) {\n+    if (type == error_mark_node || expr == error_mark_node || TREE_TYPE(expr) == error_mark_node)\n+        return error_mark_node;\n+\n+    if (type == TREE_TYPE(expr))\n+        return expr;\n+\n+    if (TYPE_MAIN_VARIANT(type) == TYPE_MAIN_VARIANT(TREE_TYPE(expr)))\n+        return fold_convert(type, expr);\n+\n+    switch (TREE_CODE(type)) {\n+        case VOID_TYPE:\n+        case BOOLEAN_TYPE:\n+            return fold_convert(type, expr);\n+        case INTEGER_TYPE:\n+            return fold(convert_to_integer(type, expr));\n+        case POINTER_TYPE:\n+            return fold(convert_to_pointer(type, expr));\n+        case REAL_TYPE:\n+            return fold(convert_to_real(type, expr));\n+        case COMPLEX_TYPE:\n+            return fold(convert_to_complex(type, expr));\n+        default:\n+            break;\n+    }\n+\n+    gcc_unreachable();\n+}\n+\n+static GTY(()) tree grs_gc_root;\n+void grs_preserve_from_gc(tree t) {\n+    grs_gc_root = tree_cons(NULL_TREE, t, grs_gc_root);\n+}\n+\n+/* The language hooks data structure. This is the main interface between the GCC front-end\n+ * and the GCC middle-end/back-end. A list of language hooks could be found in\n+ * <gcc>/langhooks.h\n+ */\n+#undef LANG_HOOKS_NAME\n+#undef LANG_HOOKS_INIT\n+#undef LANG_HOOKS_OPTION_LANG_MASK\n+#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n+#undef LANG_HOOKS_HANDLE_OPTION\n+#undef LANG_HOOKS_POST_OPTIONS\n+#undef LANG_HOOKS_PARSE_FILE\n+#undef LANG_HOOKS_TYPE_FOR_MODE\n+#undef LANG_HOOKS_TYPE_FOR_SIZE\n+#undef LANG_HOOKS_BUILTIN_FUNCTION\n+#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n+#undef LANG_HOOKS_PUSHDECL\n+#undef LANG_HOOKS_GETDECLS\n+#undef LANG_HOOKS_WRITE_GLOBALS\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#undef LANG_HOOKS_EH_PERSONALITY\n+\n+#define LANG_HOOKS_NAME \"GNU Rust\"\n+#define LANG_HOOKS_INIT grs_langhook_init\n+#define LANG_HOOKS_OPTION_LANG_MASK grs_langhook_option_lang_mask\n+#define LANG_HOOKS_INIT_OPTIONS_STRUCT grs_langhook_init_options_struct\n+#define LANG_HOOKS_HANDLE_OPTION grs_langhook_handle_option\n+#define LANG_HOOKS_POST_OPTIONS grs_langhook_post_options\n+/* Main lang-hook, apparently. Finds input file names in global vars in_fnames and num_in_fnames\n+ * From this, frontend can take over and do actual parsing and initial compilation.\n+ * This hook must create a complete parse tree in a global var, and then return. */ \n+#define LANG_HOOKS_PARSE_FILE grs_langhook_parse_file\n+#define LANG_HOOKS_TYPE_FOR_MODE grs_langhook_type_for_mode\n+#define LANG_HOOKS_TYPE_FOR_SIZE grs_langhook_type_for_size\n+#define LANG_HOOKS_BUILTIN_FUNCTION grs_langhook_builtin_function\n+#define LANG_HOOKS_GLOBAL_BINDINGS_P grs_langhook_global_bindings_p\n+#define LANG_HOOKS_PUSHDECL grs_langhook_pushdecl\n+#define LANG_HOOKS_GETDECLS grs_langhook_getdecls\n+#define LANG_HOOKS_WRITE_GLOBALS grs_langhook_write_globals\n+#define LANG_HOOKS_GIMPLIFY_EXPR grs_langhook_gimplify_expr\n+#define LANG_HOOKS_EH_PERSONALITY grs_langhook_eh_personality\n+\n+struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n+\n+// These are for GCC's garbage collector to work properly or something\n+#include \"gt-rust-rs-lang.h\"\n+#include \"gtype-rust.h\"\n\\ No newline at end of file"}, {"sha": "6ad4515749fed755a56d42763a8ab002e2d341fb", "filename": "gcc/rust/old/rs-lexer.l", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-lexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-lexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-lexer.l?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,160 @@\n+%{\n+  /* This file is part of GCC.\n+\n+     GCC is free software; you can redistribute it and/or modify it under\n+     the terms of the GNU General Public License as published by the Free\n+     Software Foundation; either version 3, or (at your option) any later\n+     version.\n+\n+     GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+     WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+     for more details.\n+\n+     You should have received a copy of the GNU General Public License\n+     along with GCC; see the file COPYING3.  If not see\n+     <http://www.gnu.org/licenses/>.  */\n+\n+#include \"rust.h\"\n+#include \"y.rs.h\"\n+\n+extern int yydebug;\n+extern int yyparse (void);\n+%}\n+\n+DIGIT        [0-9]\n+ID           [_a-zA-Z][a-zA_Z0-9_$]*\n+QSTRING      \\\"[^\\\"\\n]*[\\\"\\n]\n+\n+%x comment\n+%option yylineno noyywrap nounput 8bit never-interactive\n+%%\n+\n+\"/*\"                    {  BEGIN (comment); }\n+<comment>[^*\\n]*        {  /* eat it up flex you be le hungry maybe? */ }\n+<comment>\"*\"+[^*/\\n]*   {  /* eat up boyo */ }\n+<comment>\\n             {  ++yylineno; }\n+<comment>\"*\"+\"/\"        {  BEGIN (INITIAL); }\n+\n+as                      {  return AS; }\n+pub                     {  return PUB; }\n+break                   {  return BREAK; }\n+return                  {  return RETURN; }\n+continue                {  return CONTINUE; }\n+do                      {  return DO; }\n+fn                      {  return DEFUN; }\n+let                     {  return LET; }\n+mut                     {  return MUT; }\n+while                   {  return WHILE; }\n+loop                    {  return LOOP; }\n+static                  {  return STATIC; }\n+struct                  {  return STRUCT; }\n+if                      {  return IF; }\n+\"else if\"               {  return ELIF; }\n+else                    {  return ELSE; }\n+impl                    {  return IMPL; }\n+self                    {  return SELF; }\n+bool                    {  return TYPE_BOOL; }\n+int                     {  return TYPE_INT; }\n+float                   {  return TYPE_FLOAT; }\n+uint                    {  return TYPE_UINT; }\n+enum                    {  return ENUM; }\n+match                   {  return MATCH; }\n+true                    {  return XTRUE; }\n+false                   {  return XFALSE; }\n+trait                   {  return TRAIT; }\n+for                     {  return FOR; }\n+\\[                      {  return '['; }\n+\\]                      {  return ']'; }\n+\\(                      {  return '('; }\n+\\)                      {  return ')'; }\n+\\{                      {  return '{'; }\n+\\}                      {  return '}'; }\n+\"->\"                    {  return RTYPE; }\n+\"=>\"                    {  return GOES; }\n+\";\"                     { return ';'; }\n+\",\"                     { return ','; }\n+\".\"                     { return '.'; }\n+\":\"                     { return ':'; }\n+\"::\"                    { return ACC; }\n+\"=\"                     { return '='; }\n+\"+\"                     { return '+'; }\n+\"-\"                     { return '-'; }\n+\"/\"                     { return '/'; }\n+\"*\"                     { return '*'; }\n+\"|\"                     { return '|'; }\n+\"~\"                     { return '~'; }\n+\"&\"                     { return '&'; }\n+\"==\"                    { return EQUAL_EQUAL; }\n+\"!=\"                    { return NOT_EQUAL; }\n+\"<\"                     { return '<'; }\n+\"<=\"                    { return LESS_EQUAL; }\n+\">\"                     { return '>'; }\n+\">=\"                    { return GREATER_EQUAL; }\n+\n+\\/\\/.*                  ;  /* // style comment */\n+\n+{QSTRING}               {\n+  yylval.string = xstrdup (yytext + 1);\n+  if (yylval.string [yyleng - 2] != '\\\"')\n+    error (\"Un-termintated character string!\\n\");\n+  else\n+    yylval.string [yyleng - 2] = '\\0';\n+  return STRING;\n+}\n+\n+{DIGIT}+                {\n+  mpfr_t x;\n+  mpfr_init2 (x, 32);\n+  if (mpfr_set_str (x, yytext, 10, GMP_RNDU))\n+    {\n+      fatal_error (\"error initilizing integer value <%s>!\\n\", yytext);\n+    }\n+  yylval.integer = mpfr_get_si (x, GMP_RNDU);\n+  mpfr_clear (x);\n+  return INTEGER;\n+}\n+\n+{DIGIT}+\".\"{DIGIT}+    {\n+  mpfr_t x;\n+  mpfr_init2 (x, 32);\n+  if (mpfr_set_str (x, yytext, 10, GMP_RNDU))\n+    {\n+      fatal_error (\"error initilizing float value <%s>!\\n\", yytext);\n+    }\n+  yylval.ffloat = mpfr_get_flt (x, GMP_RNDU);\n+  mpfr_clear (x);\n+  return FLOAT;\n+}\n+\n+{ID}                    {\n+  yylval.string = xstrdup (yytext);\n+  return IDENTIFIER;\n+}\n+\n+.           {  }\n+\\n          {  }\n+\n+%%\n+\n+bool grs_do_compile(const char * in) {\n+    bool retval = true;\n+    FILE * fd = fopen(in, \"rb\");\n+    \n+    if (fd) {\n+\t      yyin = fd;\n+        \n+        // yydebug = 1;\n+        linemap_add(line_table, LC_ENTER, 0, in, 0);\n+\t      retval = yyparse();\n+\t      fclose (fd);\n+        linemap_add(line_table, LC_LEAVE, 0, NULL, 0);\n+\t      yylex_destroy();\n+    } else {\n+\t      fprintf(stderr, \"error opening file %s\\n\", in);\n+\t      retval = false;\n+    }\n+    \n+    return retval;\n+}\n+"}, {"sha": "5a7a08c0f79ae4ffd614de196f126e8415514848", "filename": "gcc/rust/old/rs-parser.cc", "status": "added", "additions": 756, "deletions": 0, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-parser.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,756 @@\n+#include \"rust.h\"\n+#include \"y.rs.h\"\n+\n+yystype yylval;\n+static int sym;\n+static int __yyerror;\n+extern int yylineno;\n+\n+static void yyerror(const char*, ...);\n+extern int yylex(void);\n+static bool __yyaccept__(int, bool);\n+static bool yyexpect(int);\n+\n+#ifdef _DEBUG\n+#define yylex_()                             \\\n+    yylex();                                 \\\n+    do {                                     \\\n+        char* __token = yytoken_string(sym); \\\n+        printf(\"[%i:%s]\\n\", sym, __token);   \\\n+        free(__token);                       \\\n+    } while (0)\n+#else\n+#define yylex_() yylex()\n+#endif\n+\n+static std::vector<ALLOCA_>* alloca_modifiers(void);\n+\n+static rdot type(void);\n+static rdot target(void);\n+static rdot suite(void);\n+static rdot else_block(void);\n+static rdot elif_block(void);\n+static rdot if_block(void);\n+static rdot struct_conditional(void);\n+static rdot primary(void);\n+static rdot factor1(void);\n+static rdot factor2(void);\n+static rdot expression(void);\n+\n+static vec<rdot, va_gc>* symStack;\n+static const char* token_strings[] = {\n+    \"impl\",\n+    \"as\",\n+    \"break\",\n+    \"continue\",\n+    \"do\",\n+    \"fn\",\n+    \"let\",\n+    \"mut\",\n+    \"loop\",\n+    \"static\",\n+    \"->\",\n+    \"bool\",\n+    \"int\",\n+    \"uint\",\n+    \"float\",\n+    \"::\",\n+    \"enum\",\n+    \"==\",\n+    \"!=\",\n+    \"<\",\n+    \">\",\n+    \"<=\",\n+    \">=\",\n+    \"struct\",\n+    \"while\",\n+    \"if\",\n+    \"else\",\n+    \"self\",\n+    \"match\",\n+    \"=>\",\n+    \"true\",\n+    \"false\",\n+    \"string_literal\",\n+    \"identifier\",\n+    \"integer\",\n+    \"pub\",\n+    \"for\",\n+    \"trait\",\n+    \"else if\",\n+    \"float\",\n+    \"unknown\"\n+};\n+\n+static char*\n+yytoken_string(int token) {\n+    char retval[128];\n+    memset(retval, 0, 128);\n+    if (token >= 258 && token <= 298)\n+        strncpy(retval, token_strings[token - 258 - 1], 128);\n+    else\n+        retval[0] = (char)token;\n+    return xstrdup(retval);\n+}\n+\n+#define yyaccept(_X) __yyaccept__(_X, true)\n+#define yyaccept_(_X) __yyaccept__(_X, false)\n+static bool __yyaccept__(int s, bool forward) {\n+    if (sym == s) {\n+        if (forward) {\n+            sym = yylex_();\n+        }\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool yyexpect(int s) {\n+    bool retval = false;\n+    if (yyaccept(s) == true)\n+        retval = true;\n+    else {\n+        char* e1 = yytoken_string(s);\n+        char* e2 = yytoken_string(sym);\n+        yyerror(\"expected [%s] got [%s]\", e1, e2);\n+        free(e1);\n+        free(e2);\n+    }\n+    return retval;\n+}\n+\n+/* Also realy need to make use of location_t and gcc diagnostics .. */\n+/* this is really hacky but its ok for now really need to fix this though */\n+static void __attribute__((format(printf, 1, 2)))\n+yyerror(const char* fmt, ...) {\n+    __yyerror += 1;\n+    char* buffer = (char*)alloca(512);\n+    memset(buffer, 0, 512);\n+\n+    va_list vl;\n+    va_start(vl, fmt);\n+    vsprintf(buffer, fmt, vl);\n+    va_end(vl);\n+\n+    char* buffer_message = (char*)alloca(512);\n+    memset(buffer_message, 0, 512);\n+    snprintf(buffer_message, 512, \"syntax error at %i: [%s]\", yylineno, buffer);\n+\n+    fatal_error(\"%s\", buffer_message);\n+}\n+\n+std::vector<ALLOCA_>* alloca_modifiers(void) {\n+    std::vector<ALLOCA_>* allocas = new std::vector<ALLOCA_>;\n+    while (sym == '~' || sym == '&' || sym == '*') {\n+        ALLOCA_ mod;\n+        switch (sym) {\n+            case '~':\n+                mod = ALLOC_HEAP;\n+                break;\n+            case '&':\n+                mod = ALLOC_REF;\n+                break;\n+            case '*':\n+                mod = ALLOC_DEREF;\n+                break;\n+            default:\n+                break;\n+        }\n+        yyexpect(sym);\n+        allocas->push_back(mod);\n+    }\n+    return allocas;\n+}\n+\n+rdot type(void) {\n+    std::vector<ALLOCA_>* mem = alloca_modifiers();\n+    rdot retval = NULL_DOT;\n+    if (yyaccept(TYPE_INT))\n+        retval = rdot_build_decl1(RTYPE_INT, NULL_DOT);\n+    else if (yyaccept(TYPE_UINT))\n+        retval = rdot_build_decl1(RTYPE_UINT, NULL_DOT);\n+    else if (yyaccept(TYPE_FLOAT))\n+        retval = rdot_build_decl1(RTYPE_FLOAT, NULL_DOT);\n+    else if (yyaccept(TYPE_BOOL))\n+        retval = rdot_build_decl1(RTYPE_BOOL, NULL_DOT);\n+    else if (yyaccept(IDENTIFIER)) {\n+        char* sid = yylval.string;\n+        retval = rdot_build_decl1(RTYPE_USER_STRUCT,\n+                                  rdot_build_identifier(sid));\n+        free(sid);\n+    } else\n+        yyerror(\"expected a type got [%s]\", yytoken_string(sym));\n+\n+    RDOT_MMEM_COPY(mem, RDOT_MEM_MODIFIER(retval));\n+    delete mem;\n+\n+    return retval;\n+}\n+\n+rdot target(void) {\n+    yyexpect(LET);\n+    bool qual = true;\n+    if (yyaccept(MUT))\n+        qual = false;\n+\n+    yyexpect(IDENTIFIER);\n+    char* tid = yylval.string;\n+\n+    rdot ltype = NULL_DOT;\n+    if (yyaccept(':'))\n+        ltype = type();\n+    if (ltype == NULL_DOT)\n+        ltype = rdot_build_decl1(RTYPE_INFER, NULL_DOT);\n+\n+    rdot retval = rdot_build_varDecl(ltype, qual, rdot_build_identifier(tid));\n+    free(tid);\n+    return retval;\n+}\n+\n+void argument_list_(rdot head) {\n+    if (yyaccept_(')'))\n+        return;\n+\n+    rdot p = expression();\n+    if (head == NULL_DOT)\n+        vec_safe_push(symStack, p);\n+    else\n+        RDOT_CHAIN(head) = p;\n+\n+    if (yyaccept(','))\n+        argument_list_(p);\n+}\n+\n+rdot argument_list() {\n+    rdot retval = NULL_DOT;\n+    size_t prev = symStack->length();\n+    argument_list_(NULL_DOT);\n+    size_t next = symStack->length();\n+\n+    if (next > prev)\n+        retval = symStack->pop();\n+    return retval;\n+}\n+\n+rdot struct_elem() {\n+    yyexpect(IDENTIFIER);\n+    char* selem = yylval.string;\n+    yyexpect(':');\n+    rdot expr = expression();\n+    rdot retval = rdot_build_decl2(D_STRUCT_PARAM,\n+                                   rdot_build_identifier(selem),\n+                                   expr);\n+    free(selem);\n+    return retval;\n+}\n+\n+void struct_init_list_(rdot head) {\n+    if (yyaccept_('}'))\n+        return;\n+    rdot e = struct_elem();\n+    if (head == NULL_DOT)\n+        vec_safe_push(symStack, e);\n+    else\n+        RDOT_CHAIN(head) = e;\n+    if (yyaccept(','))\n+        struct_init_list_(e);\n+}\n+\n+rdot struct_init_list(void) {\n+    rdot retval = NULL_DOT;\n+    size_t prev = symStack->length();\n+    struct_init_list_(NULL_DOT);\n+    size_t next = symStack->length();\n+\n+    if (next > prev)\n+        retval = symStack->pop();\n+    return retval;\n+}\n+\n+rdot primary(void) {\n+    rdot retval = NULL_DOT;\n+    std::vector<ALLOCA_>* mem = alloca_modifiers();\n+    if (yyaccept(IDENTIFIER)) {\n+        // maybe call...\n+        char* pid = yylval.string;\n+        if (yyaccept_('(')) {\n+            yyexpect('(');\n+            rdot alist = argument_list();\n+            yyexpect(')');\n+            retval = rdot_build_decl2(D_CALL_EXPR,\n+                                      rdot_build_identifier(pid),\n+                                      alist);\n+        }\n+        // struct init\n+        else if (yyaccept_('{')) {\n+            yyexpect('{');\n+            rdot sls = struct_init_list();\n+            yyexpect('}');\n+            retval = rdot_build_decl2(D_STRUCT_INIT,\n+                                      rdot_build_identifier(pid),\n+                                      sls);\n+        }\n+        // just a simple identifier...\n+        else\n+            retval = rdot_build_identifier(pid);\n+        free(pid);\n+    } else if (yyaccept(INTEGER))\n+        retval = rdot_build_integer(yylval.integer);\n+    else if (yyaccept(FLOAT))\n+        retval = rdot_build_float(yylval.ffloat);\n+    else if (yyaccept(STRING))\n+        retval = rdot_build_string(yylval.string);\n+    else if (yyaccept(XFALSE))\n+        retval = rdot_build_bool(false);\n+    else if (yyaccept(XTRUE))\n+        retval = rdot_build_bool(true);\n+    else\n+        yyerror(\"expected a primary got [%s]\", yytoken_string(sym));\n+\n+    RDOT_MMEM_COPY(mem, RDOT_MEM_MODIFIER(retval));\n+    delete mem;\n+    return retval;\n+}\n+\n+rdot factor1(void) {\n+    rdot retval = NULL_DOT;\n+    if (yyaccept(IDENTIFIER)) {\n+        char* pid = yylval.string;\n+        if (yyaccept('=')) {\n+            rdot rhs = expression();\n+            retval = rdot_build_decl2(D_MODIFY_EXPR, rdot_build_identifier(pid), rhs);\n+        } else if (yyaccept_('(')) {\n+            yyexpect('(');\n+            rdot alist = argument_list();\n+            yyexpect(')');\n+            retval = rdot_build_decl2(D_CALL_EXPR,\n+                                      rdot_build_identifier(pid),\n+                                      alist);\n+        }\n+        // struct init\n+        else if (yyaccept_('{')) {\n+            yyexpect('{');\n+            rdot sls = struct_init_list();\n+            yyexpect('}');\n+            retval = rdot_build_decl2(D_STRUCT_INIT,\n+                                      rdot_build_identifier(pid),\n+                                      sls);\n+        } else if (yyaccept_(ACC)) {\n+            yyexpect(ACC);\n+            rdot node = factor1();\n+            retval = rdot_build_decl2(D_ACC_EXPR, rdot_build_identifier(pid), node);\n+        } else {\n+            retval = rdot_build_identifier(yylval.string);\n+            if (yyaccept('.')) {\n+                rdot rhs = factor2();\n+                retval = rdot_build_decl2(D_ATTRIB_REF, retval, rhs);\n+            }\n+        }\n+        free(pid);\n+    } else\n+        retval = factor2();\n+    return retval;\n+}\n+\n+rdot factor2(void) {\n+    rdot retval = NULL_DOT;\n+    if (yyaccept('(')) {\n+        retval = expression();\n+        yyexpect(')');\n+    } else {\n+        retval = primary();\n+        if (RDOT_TYPE(retval) == D_IDENTIFIER || RDOT_TYPE(retval) == D_CALL_EXPR) {\n+            if (yyaccept('.')) {\n+                rdot rhs = factor2();\n+                retval = rdot_build_decl2(D_ATTRIB_REF, retval, rhs);\n+            }\n+        }\n+    }\n+    return retval;\n+}\n+\n+opcode_t symToDeclType(int sym) {\n+    opcode_t retval = D_D_EXPR;\n+    switch (sym) {\n+        case '=':\n+            retval = D_MODIFY_EXPR;\n+            break;\n+\n+        case '+':\n+            retval = D_ADD_EXPR;\n+            break;\n+\n+        case '-':\n+            retval = D_MINUS_EXPR;\n+            break;\n+\n+        case '*':\n+            retval = D_MULT_EXPR;\n+            break;\n+\n+        case '/':\n+            retval = D_DIVD_EXPR;\n+            break;\n+\n+        case '.':\n+            retval = D_ATTRIB_REF;\n+            break;\n+\n+        case EQUAL_EQUAL:\n+            retval = D_EQ_EQ_EXPR;\n+            break;\n+\n+        case NOT_EQUAL:\n+            retval = D_NOT_EQ_EXPR;\n+            break;\n+\n+        case '<':\n+            retval = D_LESS_EXPR;\n+            break;\n+\n+        case LESS_EQUAL:\n+            retval = D_LESS_EQ_EXPR;\n+            break;\n+\n+        case '>':\n+            retval = D_GREATER_EXPR;\n+            break;\n+\n+        case GREATER_EQUAL:\n+            retval = D_GREATER_EQ_EXPR;\n+            break;\n+\n+        default:\n+            yyerror(\"invalid symbol [%i:%s]\",\n+                    sym,\n+                    yytoken_string(sym));\n+            break;\n+    }\n+    return retval;\n+}\n+\n+rdot expression(void) {\n+    bool head = false;\n+    rdot retval = factor1();\n+    rdot next = NULL_DOT;\n+    while (sym == '+' || sym == '-' ||\n+           sym == '*' || sym == '/' ||\n+           sym == '<' || sym == '>' ||\n+           sym == EQUAL_EQUAL || sym == NOT_EQUAL ||\n+           sym == LESS_EQUAL || sym == GREATER_EQUAL) {\n+        opcode_t o = symToDeclType(sym);\n+        yyexpect(sym);\n+        rdot rhs = factor2();\n+        if (head == false) {\n+            retval = next = rdot_build_decl2(o, retval, rhs);\n+            head = true;\n+        } else {\n+            rdot prev = RDOT_rhs_TT(next);\n+            rdot rhs_expr = rdot_build_decl2(o, prev, rhs);\n+            RDOT_rhs_TT(next) = rhs_expr;\n+            next = rhs_expr;\n+        }\n+    }\n+    return retval;\n+}\n+\n+rdot statement() {\n+    rdot retval = NULL_DOT;\n+    if (yyaccept_(BREAK)) {\n+        yyexpect(BREAK);\n+        retval = rdot_build_decl1(C_BREAK_STMT, NULL_DOT);\n+    } else if (yyaccept_(CONTINUE)) {\n+        yyexpect(CONTINUE);\n+        retval = rdot_build_decl1(C_CONT_STMT, NULL_DOT);\n+    } else if (yyaccept_(RETURN)) {\n+        yyexpect(RETURN);\n+        retval = rdot_build_decl1(C_RETURN_STMT, expression());\n+    } else if (yyaccept_(LET)) {\n+        // simple vardecl [let x;]\n+        rdot tg = target();\n+        if (yyaccept('=')) {\n+            retval = rdot_build_decl2(D_MODIFY_EXPR,\n+                                      tg,\n+                                      expression());\n+        } else\n+            retval = tg;\n+    } else\n+        retval = expression();\n+    return retval;\n+}\n+\n+rdot struct_while_loop() {\n+    yyexpect(WHILE);\n+    rdot expr = expression();\n+    yyexpect('{');\n+    rdot sb = suite();\n+    yyexpect('}');\n+    return rdot_build_decl2(D_STRUCT_WHILE, expr, sb);\n+}\n+\n+rdot struct_loop() {\n+    yyexpect(LOOP);\n+    yyexpect('{');\n+    rdot sb = suite();\n+    yyexpect('}');\n+    return rdot_build_decl1(D_STRUCT_LOOP, sb);\n+}\n+\n+rdot if_block(void) {\n+    yyexpect(IF);\n+    rdot expr = expression();\n+    yyexpect('{');\n+    rdot sb = suite();\n+    yyexpect('}');\n+    return rdot_build_decl2(D_STRUCT_IF, expr, sb);\n+}\n+\n+rdot elif_block(void) {\n+    yyexpect(ELIF);\n+    rdot expr = expression();\n+    yyexpect('{');\n+    rdot sb = suite();\n+    yyexpect('}');\n+    return rdot_build_decl2(D_STRUCT_IF, expr, sb);\n+}\n+\n+rdot else_block(void) {\n+    yyexpect(ELSE);\n+    yyexpect('{');\n+    rdot block = suite();\n+    yyexpect('}');\n+    return rdot_build_decl1(D_STRUCT_ELSE, block);\n+}\n+\n+rdot struct_conditional() {\n+    rdot iblock = if_block();\n+    rdot eblock = NULL_DOT;\n+    rdot elblock = NULL_DOT;\n+    rdot curr = NULL_DOT;\n+    rdot prev = NULL_DOT;\n+    while (yyaccept_(ELIF)) {\n+        curr = elif_block();\n+        if (elblock == NULL_DOT)\n+            elblock = prev = curr;\n+        else {\n+            RDOT_CHAIN(prev) = curr;\n+            prev = curr;\n+        }\n+    }\n+    if (yyaccept_(ELSE))\n+        eblock = else_block();\n+    rdot retval = rdot_build_decl2(D_STRUCT_IF, iblock, eblock);\n+    RDOT_FIELD(retval) = elblock;\n+    return retval;\n+}\n+\n+void statement_list(rdot head) {\n+    if (yyaccept_('}'))\n+        return;\n+\n+    rdot st = NULL_DOT;\n+    if (yyaccept_(LOOP))\n+        st = struct_loop();\n+    else if (yyaccept_(WHILE))\n+        st = struct_while_loop();\n+    else if (yyaccept_(IF))\n+        st = struct_conditional();\n+    else {\n+        st = statement();\n+        if (!yyaccept(';'))\n+            DOT_RETVAL(st) = true;\n+    }\n+    gcc_assert(st != NULL_DOT);\n+    if (head == NULL_DOT)\n+        vec_safe_push(symStack, st);\n+    else\n+        RDOT_CHAIN(head) = st;\n+    statement_list(st);\n+}\n+\n+rdot suite() {\n+    rdot retval = NULL_DOT;\n+    size_t prev = symStack->length();\n+    statement_list(NULL);\n+    size_t next = symStack->length();\n+\n+    if (next > prev)\n+        retval = symStack->pop();\n+    return retval;\n+}\n+\n+rdot param(void) {\n+    yyexpect(IDENTIFIER);\n+    char* pid = yylval.string;\n+    yyexpect(':');\n+    rdot pit = type();\n+    rdot retval = rdot_build_decl2(D_PARAMETER,\n+                                   rdot_build_identifier(pid),\n+                                   pit);\n+    free(pid);\n+    return retval;\n+}\n+\n+void param_list_(rdot head) {\n+    if (yyaccept_(')'))\n+        return;\n+\n+    rdot p = param();\n+    if (head == NULL_DOT)\n+        vec_safe_push(symStack, p);\n+    else\n+        RDOT_CHAIN(head) = p;\n+\n+    if (yyaccept(','))\n+        param_list_(p);\n+}\n+\n+rdot param_list() {\n+    rdot retval = NULL_DOT;\n+    size_t prev = symStack->length();\n+    param_list_(NULL_DOT);\n+    size_t next = symStack->length();\n+\n+    if (next > prev)\n+        retval = symStack->pop();\n+    return retval;\n+}\n+\n+/* fndecl := [pub] fn IDENTIFIER ([param_list]) [-> type] { stmt_list } */\n+rdot fndecl() {\n+    bool pub = false;\n+    if (yyaccept(PUB))\n+        pub = true;\n+    yyexpect(DEFUN);\n+    yyexpect(IDENTIFIER);\n+    char* fid = yylval.string;\n+    yyexpect('(');\n+    rdot plist = param_list();\n+    yyexpect(')');\n+    rdot rtype = NULL_DOT;\n+    if (yyaccept(RTYPE))\n+        rtype = type();\n+    yyexpect('{');\n+    rdot block = suite();\n+    yyexpect('}');\n+    rdot retval = rdot_build_fndecl(rdot_build_identifier(fid),\n+                                    pub,\n+                                    plist,\n+                                    rtype,\n+                                    block);\n+    free(fid);\n+    return retval;\n+}\n+\n+void struct_layout_(rdot head) {\n+    if (yyaccept_('}'))\n+        return;\n+\n+    rdot p = param();\n+    if (head == NULL_DOT)\n+        vec_safe_push(symStack, p);\n+    else\n+        RDOT_CHAIN(head) = p;\n+\n+    if (yyaccept(','))\n+        struct_layout_(p);\n+}\n+\n+rdot struct_layout() {\n+    rdot retval = NULL_DOT;\n+    size_t prev = symStack->length();\n+    struct_layout_(NULL_DOT);\n+    size_t next = symStack->length();\n+\n+    if (next > prev)\n+        retval = symStack->pop();\n+    return retval;\n+}\n+\n+rdot struct_decl() {\n+    yyexpect(STRUCT);\n+    yyexpect(IDENTIFIER);\n+    char* sid = yylval.string;\n+\n+    yyexpect('{');\n+    rdot layout = struct_layout();\n+    yyexpect('}');\n+    rdot retval = rdot_build_decl2(D_STRUCT_TYPE,\n+                                   rdot_build_identifier(sid),\n+                                   layout);\n+    free(sid);\n+    return retval;\n+}\n+\n+void fndecl_block_(rdot head) {\n+    if (yyaccept_('}'))\n+        return;\n+\n+    rdot f = fndecl();\n+    if (head == NULL_DOT)\n+        vec_safe_push(symStack, f);\n+    else\n+        RDOT_CHAIN(head) = f;\n+\n+    fndecl_block_(f);\n+}\n+\n+rdot fndecl_block(void) {\n+    rdot retval = NULL_DOT;\n+    size_t prev = symStack->length();\n+    fndecl_block_(NULL_DOT);\n+    size_t next = symStack->length();\n+\n+    if (next > prev)\n+        retval = symStack->pop();\n+    return retval;\n+}\n+\n+rdot impl_block() {\n+    rdot retval = NULL_DOT;\n+    yyexpect(IMPL);\n+    yyexpect(IDENTIFIER);\n+    char* iid = yylval.string;\n+    rdot rid = rdot_build_identifier(iid);\n+    free(iid);\n+    if (yyaccept(FOR))\n+        yyexpect(IDENTIFIER);\n+    yyexpect('{');\n+    rdot fb = fndecl_block();\n+    yyexpect('}');\n+    retval = rdot_build_decl2(D_STRUCT_IMPL, rid, fb);\n+    return retval;\n+}\n+\n+/*\n+  decl := fndecl | structdecl | impldecl | enumdecl\n+*/\n+void decl(void) {\n+    rdot rdecl = NULL_DOT;\n+    if (yyaccept_(STRUCT))\n+        rdecl = struct_decl();\n+    else if (yyaccept_(IMPL))\n+        rdecl = impl_block();\n+    else\n+        rdecl = fndecl();\n+    if (rdecl != NULL_DOT)\n+        dot_pass_pushDecl(rdecl);\n+}\n+\n+int yyparse(void) {\n+    // kick things off with the first token\n+    __yyerror = 0;\n+    sym = yylex_();\n+\n+    vec_alloc(symStack, 0);\n+    vec_safe_push(symStack, NULL_DOT);\n+\n+    while (sym != 0)\n+        decl();\n+\n+    if (symStack->length() > 1)\n+        yyerror(\"some unpoped symbols on the parse stack!\");\n+\n+    vec_free(symStack);\n+    return __yyerror;\n+}"}, {"sha": "ec07c659957bf4aba7bdbcdf957b0e508bcb6772", "filename": "gcc/rust/old/rs-pass-manager.cc", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-pass-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-pass-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-pass-manager.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,114 @@\n+/* This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"rust.h\"\n+\n+tree cstring_type_node;\n+static bool empty = true;\n+#define MAYBE_BOMB_OUT    \\\n+    do                    \\\n+        if (seen_error()) \\\n+            return;       \\\n+    while (0);\n+\n+static vec<rdot, va_gc>* rust_decls;\n+typedef vec<rdot, va_gc>* (*dot_pass)(vec<rdot, va_gc>*);\n+static dot_pass dot_pass_mngr[] = {\n+    &dot_pass_PrettyPrint, // pretty print if -fdump-dot pre and post infereance */\n+    &dot_pass_inferTypes,  // This ensures there are no longer any D_MAYBE_TYPES */\n+    &dot_pass_PrettyPrint,\n+    NULL // sentinal */\n+};\n+\n+// Pushes each decl from the parser onto the current translation unit\n+void dot_pass_pushDecl(rdot decl) {\n+    if (empty)\n+        empty = false;\n+\n+    if (RDOT_TYPE(decl) == D_STRUCT_TYPE) {\n+        // look for duplicate fields\n+        std::map<std::string, bool> layout;\n+        rdot next;\n+        for (next = RDOT_rhs_TT(decl); next != NULL_DOT;\n+             next = RDOT_CHAIN(next)) {\n+            const char* pid = RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(next));\n+            if (layout.count(pid) > 0)\n+                error(\"structure [%s] already contains element [%s]\",\n+                      RDOT_IDENTIFIER_POINTER(RDOT_lhs_TT(decl)),\n+                      pid);\n+            else\n+                layout[pid] = true;\n+        }\n+    }\n+    vec_safe_push(rust_decls, decl);\n+}\n+\n+/* Function to run over the pass manager hooks and\n+   generate the generic code to pass to gcc middle-end\n+*/\n+void dot_pass_WriteGlobals(void) {\n+    // if the rdot translation unit is empty there is nothing to compile..\n+    if (empty == true)\n+        return;\n+\n+    tree cptr = build_pointer_type(char_type_node);\n+    cstring_type_node = build_qualified_type(cptr, TYPE_QUAL_CONST);\n+\n+    dot_pass* p = NULL;\n+    vec<rdot, va_gc>* dot_decls = rust_decls;\n+\n+    /* walk the passes */\n+    for (p = dot_pass_mngr; *p != NULL; ++p) {\n+        MAYBE_BOMB_OUT;\n+        dot_decls = (*p)(dot_decls);\n+    }\n+\n+    /* check errors */\n+    MAYBE_BOMB_OUT;\n+\n+    /* lower the decls from DOT -> GENERIC */\n+    vec<tree, va_gc>* globals = dot_pass_Genericify(dot_decls);\n+\n+    int global_vec_len = vec_safe_length(globals);\n+    tree* global_vec = new tree[global_vec_len];\n+    tree itx = NULL_TREE;\n+    int idx, idy = 0;\n+    /*\n+    Lets make sure to dump the Translation Unit this isn't that\n+    useful to read over but can help to make sure certain tree's\n+    are being generated...\n+      \n+    We also fill up the vector of tree's to be passed to the middle-end\n+  */\n+    FILE* tu_stream = dump_begin(TDI_tu, NULL);\n+    for (idx = 0; vec_safe_iterate(globals, idx, &itx); ++idx) {\n+        if (tu_stream)\n+            dump_node(itx, 0, tu_stream);\n+        global_vec[idy] = itx;\n+        idy++;\n+    }\n+    \n+    if (tu_stream)\n+        dump_end(TDI_tu, tu_stream);\n+\n+    /* Passing control to GCC middle-end */\n+    wrapup_global_declarations(global_vec, global_vec_len);\n+    finalize_compilation_unit();\n+    check_global_declarations(global_vec, global_vec_len);\n+    emit_debug_global_declarations(global_vec, global_vec_len);\n+\n+    delete[] global_vec;\n+}"}, {"sha": "1cd2b30ebca941fad9a4681dc3123b725d5eea76", "filename": "gcc/rust/old/rs-runtime-hooks.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,61 @@\n+/* This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>. */\n+\n+#include \"rust.h\"\n+\n+#define nitems(_a) (sizeof(_a)) / sizeof((_a)[0])\n+#define LANG_HOOK(name_) \"__GRUST_\" name_, name_\n+\n+// Seems to be a way of storing info about a runtime hook function\n+struct rust_runtime {\n+    const char* mangled_name;\n+    const char* rust_symbol;\n+    const size_t nargs;\n+    const tree** paramater_types;\n+};\n+\n+// Maybe an array of hooks? Doesn't have anything useful in it right now.\n+static struct rust_runtime hooks[] = {\n+    /* sentinel (meaning \"dummy data\", basically) */\n+    { NULL, NULL, 0, NULL }\n+};\n+\n+/* Seems to build functions, results, and their return types into some tree, which is put into dict\n+ *\n+ * Presumably actually does something if hooks is changed to something other than default values. */ \n+void rs_fill_runtime_decls(std::map<std::string, tree>* dict) {\n+    struct rust_runtime* hk;\n+    \n+    for (hk = hooks; hk->mangled_name != NULL; ++hk) {\n+        tree* args = XALLOCAVEC(tree, hk->nargs);\n+        size_t i;\n+        \n+        for (i = 0; i < hk->nargs; ++i)\n+            args[i] = *(hk->paramater_types[i]);\n+\n+        tree fntype = build_function_type_array(void_type_node, hk->nargs, args);\n+        tree fndecl = build_decl(BUILTINS_LOCATION, FUNCTION_DECL, get_identifier(hk->mangled_name), \n+            fntype);\n+        tree restype = TREE_TYPE(fndecl);\n+        tree resdecl = build_decl(BUILTINS_LOCATION, RESULT_DECL, NULL_TREE, restype);\n+        DECL_CONTEXT(resdecl) = fndecl;\n+        DECL_RESULT(fndecl) = resdecl;\n+        DECL_EXTERNAL(fndecl) = 1;\n+        TREE_PUBLIC(fndecl) = 1;\n+\n+        (*dict)[std::string(hk->rust_symbol)] = fndecl;\n+    }\n+}"}, {"sha": "7a6a83f08522a2ff014438216b8297a5874e0772", "filename": "gcc/rust/old/rsspec.cc", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frsspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frsspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frsspec.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,351 @@\n+// rsspec.cc - File used for compiler driver creation or something related to that.\n+/* This file is part of GCC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"coretypes.h\"\n+#include \"gcc.h\"\n+#include \"opts.h\"\n+#include \"system.h\"\n+\n+#include \"intl.h\"\n+#include \"tm.h\"\n+\n+#ifndef MATH_LIBRARY\n+#define MATH_LIBRARY \"m\"\n+#endif\n+\n+#ifndef RUST_LIBRARY\n+#define RUST_LIBRARY \"grust\"\n+#endif\n+\n+/* The original argument list and related info is copied here.  */\n+static unsigned int grs_xargc;\n+static const struct cl_decoded_option* grs_x_decoded_options;\n+static void append_arg(const struct cl_decoded_option*);\n+\n+/* The new argument list will be built here.  */\n+static unsigned int grs_newargc;\n+static struct cl_decoded_option* grs_new_decoded_options;\n+\n+/* Return whether strings S1 and S2 are both NULL or both the same\n+ * string.  \n+ * */\n+static bool strings_same(const char* s1, const char* s2) {\n+    return s1 == s2 || (s1 != NULL && s2 != NULL && strcmp(s1, s2) == 0);\n+}\n+\n+/* Return whether decoded option structures OPT1 and OPT2 are the\n+ * same.  \n+ * */\n+static bool options_same(const struct cl_decoded_option* opt1, const struct cl_decoded_option* opt2) {\n+    return (opt1->opt_index == opt2->opt_index && strings_same(opt1->arg, opt2->arg) && strings_same(opt1->orig_option_with_args_text, opt2->orig_option_with_args_text) && strings_same(opt1->canonical_option[0], opt2->canonical_option[0]) && strings_same(opt1->canonical_option[1], opt2->canonical_option[1]) && strings_same(opt1->canonical_option[2], opt2->canonical_option[2]) && strings_same(opt1->canonical_option[3], opt2->canonical_option[3]) && (opt1->canonical_option_num_elements == opt2->canonical_option_num_elements) && opt1->value == opt2->value && opt1->errors == opt2->errors);\n+}\n+\n+/* Append another argument to the list being built.  As long as it is\n+ * identical to the corresponding arg in the original list, just increment\n+ * the new arg count.  Otherwise allocate a new list, etc.  \n+ * */\n+static void append_arg(const struct cl_decoded_option* arg) {\n+    static unsigned int newargsize;\n+\n+#if 0\n+  \tfprintf (stderr, \"`%s'\\n\", arg);\n+#endif\n+\n+    if (grs_new_decoded_options == grs_x_decoded_options && grs_newargc < grs_xargc && options_same(arg, &grs_x_decoded_options[grs_newargc])) {\n+        ++grs_newargc;\n+        return; /* Nothing new here.  */\n+    }\n+\n+    if (grs_new_decoded_options == grs_x_decoded_options) { /* Make new arglist.  */\n+        unsigned int i;\n+\n+        newargsize = (grs_xargc << 2) + 20; /* This should handle all.  */\n+        grs_new_decoded_options = XNEWVEC(struct cl_decoded_option, newargsize);\n+\n+        /* Copy what has been done so far.  */\n+        for (i = 0; i < grs_newargc; ++i)\n+            grs_new_decoded_options[i] = grs_x_decoded_options[i];\n+    }\n+\n+    if (grs_newargc == newargsize)\n+        fatal_error(\"overflowed output arg list for %qs\",\n+                    arg->orig_option_with_args_text);\n+\n+    grs_new_decoded_options[grs_newargc++] = *arg;\n+}\n+\n+/* Append an option described by OPT_INDEX, ARG and VALUE to the list\n+ * being built.  \n+ * */\n+static void append_option(size_t opt_index, const char* arg, int value) {\n+    struct cl_decoded_option decoded;\n+\n+    generate_option(opt_index, arg, value, CL_DRIVER, &decoded);\n+    append_arg(&decoded);\n+}\n+\n+/* Append a librust argument to the list being built.  If\n+ * FORCE_STATIC, ensure the library is linked statically.  \n+ * */\n+static void add_arg_libgrust(bool force_static ATTRIBUTE_UNUSED) {\n+#ifdef HAVE_LD_STATIC_DYNAMIC\n+    if (force_static)\n+        append_option(OPT_Wl_, \"-Bstatic\", 1);\n+#endif\n+    append_option(OPT_l, RUST_LIBRARY, 1);\n+#ifdef HAVE_LD_STATIC_DYNAMIC\n+    if (force_static)\n+        append_option(OPT_Wl_, \"-Bdynamic\", 1);\n+#endif\n+}\n+\n+/* Modeled closely of gcc/fortran/gfortranspec.c \n+ * Called before processing to change/add/remove arguments. \n+ * */\n+void lang_specific_driver(struct cl_decoded_option** in_decoded_options,\n+                          unsigned int* in_decoded_options_count,\n+                          int* in_added_libraries ATTRIBUTE_UNUSED) {\n+    unsigned int i = 0;\n+    unsigned int argc = *in_decoded_options_count;\n+    // Argument list\n+    struct cl_decoded_option* decoded_options = *in_decoded_options;\n+\n+    int verbose = 0;\n+\n+    /* This will be NULL if we encounter a situation where we should not\n+     * link in libf2c.  \n+\t * */\n+    const char* library = RUST_LIBRARY;\n+\n+    /* 0 => -xnone in effect.\n+     * 1 => -xfoo in effect.  \n+\t * */\n+    int saw_speclang = 0;\n+\n+    /* 0 => initial/reset state\n+     * 1 => last arg was -l<library>\n+     * 2 => last two args were -l<library> -lm.  \n+\t * */\n+    int saw_library = 0;\n+\n+    /* By default, we throw on the math library if we have one.  */\n+    int need_math = (MATH_LIBRARY[0] != '\\0');\n+\n+    /* Whether we should link a static libgrsthon. */\n+    int static_lib = 0;\n+\n+    /* Whether we need to link statically.  */\n+    int static_linking = 0;\n+\n+    /* The number of input and output files in the incoming arg list.  */\n+    int n_infiles = 0;\n+    int n_outfiles = 0;\n+\n+#if 0\n+  \tfprintf (stderr, \"Incoming:\");\n+  \tfor( i=0; i<argc; ++i )\n+    \tfprintf (stderr, \" %s\", decoded_options[i].orig_option_with_args_text);\n+  \tfprintf (stderr, \"\\n\");\n+#endif\n+\n+    grs_xargc = argc;\n+    grs_x_decoded_options = decoded_options;\n+    grs_newargc = 0;\n+    grs_new_decoded_options = decoded_options;\n+\n+    for (i = 1; i < argc; ++i) {\n+        switch (decoded_options[i].opt_index) {\n+            case OPT_SPECIAL_input_file:\n+                ++n_infiles;\n+                continue;\n+\n+            case OPT_nostdlib:\n+            case OPT_nodefaultlibs:\n+            case OPT_c:\n+            case OPT_S:\n+            case OPT_fsyntax_only:\n+            case OPT_E:\n+                /* These options disable linking entirely or linking of the\n+\t     \t\t * standard libraries.  \n+\t\t\t\t * */\n+                library = 0;\n+                break;\n+\n+                /*\n+\t\t\tcase OPT_static_librust:\n+#ifdef HAVE_LD_STATIC_DYNAMIC\n+\t    \t\tstatic_lib = 1;\n+#endif\n+\t  \t\t\tbreak;\n+*/\n+\n+            case OPT_static:\n+#ifdef HAVE_LD_STATIC_DYNAMIC\n+                static_linking = 1;\n+#endif\n+                break;\n+\n+            case OPT_l:\n+                ++n_infiles;\n+                break;\n+\n+            case OPT_o:\n+                ++n_outfiles;\n+                break;\n+\n+            case OPT_v:\n+                verbose = 1;\n+                break;\n+\n+            case OPT_version:\n+                printf(\"GNU Rust %s%s\\n\", pkgversion_string, version_string);\n+                printf(\"Copyright %s 2013 Free Software Foundation, Inc.\\n\\n\",\n+                       _(\"(C)\"));\n+                printf(_(\"GNU Rust comes with NO WARRANTY, to the extent permitted by law.\\n\\\n+You may redistribute copies of GNU Rust\\n\\\n+under the terms of the GNU General Public License.\\n\\\n+For more information about these matters, see the file named COPYING\\n\\n\"));\n+                exit(0);\n+                break;\n+\n+            case OPT__help:\n+                /* Let gcc.c handle this, as it has a really\n+\t     \t\t * cool facility for handling --help and --verbose --help.  \n+\t\t\t\t * */\n+                return;\n+\n+            default:\n+                break;\n+        }\n+    }\n+\n+    if ((n_outfiles != 0) && (n_infiles == 0))\n+        fatal_error(\"no input files; unwilling to write output files\");\n+\n+    /* If there are no input files, no need for the library.  */\n+    if (n_infiles == 0)\n+        library = 0;\n+\n+    /* Second pass through arglist, transforming arguments as appropriate.  */\n+    append_arg(&decoded_options[0]); /* Start with command name, of course.  */\n+\n+    for (i = 1; i < argc; ++i) {\n+        if (decoded_options[i].errors & CL_ERR_MISSING_ARG) {\n+            append_arg(&decoded_options[i]);\n+            continue;\n+        }\n+\n+        if (decoded_options[i].opt_index == OPT_SPECIAL_input_file && decoded_options[i].arg[0] == '\\0') {\n+            /* Interesting.  Just append as is.  */\n+            append_arg(&decoded_options[i]);\n+            continue;\n+        }\n+\n+        if (decoded_options[i].opt_index != OPT_l && (decoded_options[i].opt_index != OPT_SPECIAL_input_file || strcmp(decoded_options[i].arg, \"-\") == 0)) {\n+            /* Not a filename or library.  */\n+\n+            if (saw_library == 1 && need_math) /* -l<library>.  */\n+                append_option(OPT_l, MATH_LIBRARY, 1);\n+\n+            saw_library = 0;\n+\n+            if (decoded_options[i].opt_index == OPT_SPECIAL_input_file) {\n+                append_arg(&decoded_options[i]); /* \"-\" == Standard input.  */\n+                continue;\n+            }\n+\n+            if (decoded_options[i].opt_index == OPT_x) {\n+                /* Track input language.  */\n+                const char* lang = decoded_options[i].arg;\n+                saw_speclang = (strcmp(lang, \"none\") != 0);\n+            }\n+            append_arg(&decoded_options[i]);\n+            continue;\n+        }\n+\n+        /* A filename/library, not an option.  */\n+        if (saw_speclang)\n+            saw_library = 0; /* -xfoo currently active.  */\n+        else {               /* -lfoo or filename.  */\n+            if (decoded_options[i].opt_index == OPT_l && strcmp(decoded_options[i].arg, MATH_LIBRARY) == 0) {\n+                if (saw_library == 1)\n+                    saw_library = 2; /* -l<library> -lm.  */\n+                else\n+                    add_arg_libgrust(static_lib && !static_linking);\n+            } else if (decoded_options[i].opt_index == OPT_l && strcmp(decoded_options[i].arg, RUST_LIBRARY) == 0) {\n+                saw_library = 1; /* -l<library>.  */\n+                add_arg_libgrust(static_lib && !static_linking);\n+                continue;\n+            } else { /* Other library, or filename.  */\n+                if (saw_library == 1 && need_math)\n+                    append_option(OPT_l, MATH_LIBRARY, 1);\n+                saw_library = 0;\n+            }\n+        }\n+        append_arg(&decoded_options[i]);\n+    }\n+\n+    /* Append `-lrust -lm' as necessary.  */\n+    if (library) { /* Doing a link and no -nostdlib.  */\n+        if (saw_speclang)\n+            append_option(OPT_x, \"none\", 1);\n+\n+        switch (saw_library) {\n+            case 0:\n+                add_arg_libgrust(static_lib && !static_linking);\n+                /* Fall through.  */\n+            case 1:\n+                if (need_math)\n+                    append_option(OPT_l, MATH_LIBRARY, 1);\n+            default:\n+                break;\n+        }\n+    }\n+\n+#ifdef ENABLE_SHARED_LIBGCC\n+    if (library) {\n+        unsigned int i;\n+\n+        for (i = 1; i < grs_newargc; i++)\n+            if (grs_new_decoded_options[i].opt_index == OPT_static_libgcc || grs_new_decoded_options[i].opt_index == OPT_static)\n+                break;\n+\n+        if (i == grs_newargc)\n+            append_option(OPT_shared_libgcc, NULL, 1);\n+    }\n+\n+#endif\n+\n+    if (verbose && grs_new_decoded_options != grs_x_decoded_options) {\n+        fprintf(stderr, _(\"Driving:\"));\n+        for (i = 0; i < grs_newargc; i++)\n+            fprintf(stderr, \" %s\", grs_new_decoded_options[i].orig_option_with_args_text);\n+        fprintf(stderr, \"\\n\");\n+    }\n+\n+    *in_decoded_options_count = grs_newargc;\n+    *in_decoded_options = grs_new_decoded_options;\n+}\n+\n+/* Called before linking.  Returns 0 on success and -1 on failure.  */\n+int lang_specific_pre_link(void) { // Not used\n+    return 0;\n+}\n+\n+/* Number of extra output files that lang_specific_pre_link may generate.  */\n+int lang_specific_extra_outfiles = 0; // Not used"}, {"sha": "10b2a13d19e9bca540e203cde0530610289f28e3", "filename": "gcc/rust/old/rust.h", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frust.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Frust.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frust.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,102 @@\n+/* This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n+#ifndef __GCC_RUST_H__\n+#define __GCC_RUST_H__\n+\n+#include \"config.h\"\n+\n+// These must be included before the #poison declarations in system.h.\n+#include <algorithm>\n+#include <list>\n+#include <map>\n+#include <set>\n+#include <string>\n+#include <vector>\n+\n+#include \"ansidecl.h\"\n+#include \"basic-block.h\"\n+#include \"cgraph.h\"\n+#include \"common/common-target.h\"\n+#include \"convert.h\"\n+#include \"coretypes.h\"\n+#include \"debug.h\"\n+#include \"diagnostic-core.h\"\n+#include \"diagnostic.h\"\n+#include \"flags.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimplify.h\"\n+#include \"input.h\"\n+#include \"langhooks-def.h\"\n+#include \"langhooks.h\"\n+#include \"options.h\"\n+#include \"opts.h\"\n+#include \"print-tree.h\"\n+#include \"stor-layout.h\"\n+#include \"stringpool.h\"\n+#include \"system.h\"\n+#include \"target.h\"\n+#include \"toplev.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-pass.h\"\n+#include \"tree.h\"\n+#include \"varasm.h\"\n+#include <hashtab.h>\n+#include <vec.h>\n+\n+#include <gmp.h>\n+#include <mpfr.h>\n+/* rust include */\n+#include \"rdot-impl.h\"\n+\n+#if !defined(YYLTYPE)\n+// Location as used in grs - line and column numbers\n+typedef struct grs_location {\n+    int line;\n+    int column;\n+} grs_location_t;\n+// The location of a type?\n+typedef grs_location_t YYLTYPE;\n+// The location of a type?\n+#define YYLTYPE YYLTYPE\n+#endif\n+\n+extern char* GRS_current_infile;\n+extern char* GRS_current_infname;\n+\n+/* important langhook prototypes */\n+extern void grs_set_prefix(const char*);\n+extern void grs_preserve_from_gc(tree);\n+extern void grs_add_search_path(const char*);\n+extern void grs_parse_input_files(const char**, unsigned int);\n+extern tree grs_type_for_size(unsigned int, int);\n+extern tree grs_type_for_mode(enum machine_mode, int);\n+\n+extern bool grs_do_compile(const char*);\n+\n+/* rdot pass manager */\n+extern tree cstring_type_node;\n+\n+extern vec<rdot, va_gc>* dot_pass_inferTypes(vec<rdot, va_gc>*);\n+extern vec<rdot, va_gc>* dot_pass_PrettyPrint(vec<rdot, va_gc>*);\n+extern vec<tree, va_gc>* dot_pass_Genericify(vec<rdot, va_gc>*);\n+extern void dot_pass_pushDecl(rdot);\n+extern void dot_pass_WriteGlobals(void);\n+\n+/* hooks */\n+extern void rs_fill_runtime_decls(std::map<std::string, tree>*);\n+\n+#endif //__GCC_RUST_H__"}, {"sha": "1ce15a40c534665271c6d3c82decd647b754f65a", "filename": "gcc/rust/old/y.rs.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Fy.rs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Fold%2Fy.rs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Fy.rs.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,61 @@\n+#ifndef __Y_RS_H__\n+#define __Y_RS_H__\n+\n+// Enum containing tokens for lexer\n+enum yytokentype {\n+    IMPL = 258,\n+    AS = 259,\n+    BREAK = 260,\n+    CONTINUE = 261,\n+    RETURN = 262,\n+    DO = 263,\n+    DEFUN = 264,\n+    LET = 265,\n+    MUT = 266,\n+    LOOP = 267,\n+    STATIC = 268,\n+    RTYPE = 269,\n+    TYPE_BOOL = 270,\n+    TYPE_INT = 271,\n+    TYPE_UINT = 272,\n+    TYPE_FLOAT = 273,\n+    ACC = 274,\n+    ENUM = 275,\n+    EQUAL_EQUAL = 276,\n+    NOT_EQUAL = 277,\n+    LESS = 278,\n+    GREATER = 279,\n+    LESS_EQUAL = 280,\n+    GREATER_EQUAL = 281,\n+    STRUCT = 282,\n+    WHILE = 283,\n+    IF = 284,\n+    ELSE = 285,\n+    SELF = 286,\n+    MATCH = 287,\n+    GOES = 288,\n+    XTRUE = 289,\n+    XFALSE = 290,\n+    STRING = 291,\n+    IDENTIFIER = 292,\n+    INTEGER = 293,\n+    PUB = 294,\n+    FOR = 295,\n+    TRAIT = 296,\n+    ELIF = 297,\n+    FLOAT = 298\n+};\n+\n+// Maybe type of character or whatever comes out of the lexer?\n+union yystype {\n+  rdot symbol;\n+  char * string;\n+  int integer;\n+  float ffloat;\n+  bool boolean;\n+};\n+\n+// L-val of whatever comes out of lexer?\n+extern yystype yylval;\n+\n+#endif //__Y_RS_H__"}, {"sha": "85e84544b0e9e791fa611161c26d5748689b240f", "filename": "gcc/rust/rust-backend.c", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-backend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-backend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,194 @@\n+/* rust-backend.c -- Rust frontend interface to gcc backend.\n+   Copyright (C) 2010-2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"memmodel.h\"\n+#include \"tm_p.h\"\n+#include \"diagnostic.h\"\n+#include \"simple-object.h\"\n+#include \"stor-layout.h\"\n+#include \"intl.h\"\n+#include \"output.h\"\t/* for assemble_string */\n+#include \"common/common-target.h\"\n+#include \"rust-c.h\"\n+\n+/* The segment name we pass to simple_object_start_read to find Rust\n+   export data.  */\n+\n+#ifndef RUST_EXPORT_SEGMENT_NAME\n+#define RUST_EXPORT_SEGMENT_NAME \"__GNU_RUST\"\n+#endif\n+\n+/* The section name we use when reading and writing export data.  */\n+\n+#ifndef RUST_EXPORT_SECTION_NAME\n+#define RUST_EXPORT_SECTION_NAME \".rust_export\"\n+#endif\n+\n+#ifndef TARGET_AIX\n+#define TARGET_AIX 0\n+#endif\n+\n+/* This file holds all the cases where the Rust frontend needs\n+   information from gcc's backend.  */\n+\n+/* Return whether or not GCC has reported any errors.  */\n+\n+bool\n+saw_errors (void)\n+{\n+  return errorcount != 0 || sorrycount != 0;\n+}\n+\n+/* Return the alignment in bytes of a struct field of type T.  */\n+\n+unsigned int\n+rust_field_alignment (tree t)\n+{\n+  unsigned int v;\n+\n+  v = TYPE_ALIGN (t);\n+\n+#ifdef BIGGEST_FIELD_ALIGNMENT\n+  if (v > BIGGEST_FIELD_ALIGNMENT)\n+    v = BIGGEST_FIELD_ALIGNMENT;\n+#endif\n+\n+#ifdef ADJUST_FIELD_ALIGN\n+  v = ADJUST_FIELD_ALIGN (NULL_TREE, t, v);\n+#endif\n+\n+  return v / BITS_PER_UNIT;\n+}\n+\n+/* This is called by the Rust frontend proper if the unsafe package was\n+   imported.  When that happens we cannot do type-based alias\n+   analysis.  */\n+\n+void\n+rust_imported_unsafe (void)\n+{\n+  flag_strict_aliasing = false;\n+  TREE_OPTIMIZATION (optimization_default_node)->x_flag_strict_aliasing = false;\n+\n+  /* Let the backend know that the options have changed.  */\n+  targetm.override_options_after_change ();\n+}\n+\n+/* This is called by the Rust frontend proper to add data to the\n+   section containing Rust export data.  */\n+\n+void\n+rust_write_export_data (const char *bytes, unsigned int size)\n+{\n+  static section* sec;\n+\n+  if (sec == NULL)\n+    {\n+      gcc_assert (targetm_common.have_named_sections);\n+      sec = get_section (RUST_EXPORT_SECTION_NAME,\n+\t\t\t TARGET_AIX ? SECTION_EXCLUDE : SECTION_DEBUG,\n+\t\t\t NULL);\n+    }\n+\n+  switch_to_section (sec);\n+  assemble_string (bytes, size);\n+}\n+\n+/* The rust_read_export_data function is called by the Rust frontend\n+   proper to read Rust export data from an object file.  FD is a file\n+   descriptor open for reading.  OFFSET is the offset within the file\n+   where the object file starts; this will be 0 except when reading an\n+   archive.  On success this returns NULL and sets *PBUF to a buffer\n+   allocated using malloc, of size *PLEN, holding the export data.  If\n+   the data is not found, this returns NULL and sets *PBUF to NULL and\n+   *PLEN to 0.  If some error occurs, this returns an error message\n+   and sets *PERR to an errno value or 0 if there is no relevant\n+   errno.  */\n+\n+const char *\n+rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n+\t\t     int *perr)\n+{\n+  simple_object_read *sobj;\n+  const char *errmsg;\n+  off_t sec_offset;\n+  off_t sec_length;\n+  int found;\n+  char *buf;\n+  ssize_t c;\n+\n+  *pbuf = NULL;\n+  *plen = 0;\n+\n+  sobj = simple_object_start_read (fd, offset, RUST_EXPORT_SEGMENT_NAME,\n+\t\t\t\t   &errmsg, perr);\n+  if (sobj == NULL)\n+    {\n+      /* If we get an error here, just pretend that we didn't find any\n+\t export data.  This is the right thing to do if the error is\n+\t that the file was not recognized as an object file.  This\n+\t will ignore file I/O errors, but it's not too big a deal\n+\t because we will wind up giving some other error later.  */\n+      return NULL;\n+    }\n+\n+  found = simple_object_find_section (sobj, RUST_EXPORT_SECTION_NAME,\n+\t\t\t\t      &sec_offset, &sec_length,\n+\t\t\t\t      &errmsg, perr);\n+  simple_object_release_read (sobj);\n+  if (!found)\n+    return errmsg;\n+\n+  if (lseek (fd, offset + sec_offset, SEEK_SET) < 0)\n+    {\n+      *perr = errno;\n+      return _(\"lseek failed while reading export data\");\n+    }\n+\n+  buf = XNEWVEC (char, sec_length);\n+  if (buf == NULL)\n+    {\n+      *perr = errno;\n+      return _(\"memory allocation failed while reading export data\");\n+    }\n+\n+  c = read (fd, buf, sec_length);\n+  if (c < 0)\n+    {\n+      *perr = errno;\n+      free (buf);\n+      return _(\"read failed while reading export data\");\n+    }\n+\n+  if (c < sec_length)\n+    {\n+      free (buf);\n+      return _(\"short read while reading export data\");\n+    }\n+\n+  *pbuf = buf;\n+  *plen = sec_length;\n+\n+  return NULL;\n+}"}, {"sha": "aba7d38ecc14e55a8a5c0bbc47134e1085e88673", "filename": "gcc/rust/rust-c.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-c.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,48 @@\n+/* rust-c.h -- Header file for rust frontend gcc C interface.\n+   Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef RUST_RUST_C_H\n+#define RUST_RUST_C_H\n+\n+#define RUST_EXTERN_C\n+\n+/* Functions defined in the Rust frontend proper called by the GCC\n+   interface.  */\n+extern void rust_add_search_path (const char*);\n+\n+extern void rust_parse_input_files (const char**, unsigned int,\n+                                    bool only_check_syntax);\n+extern void rust_write_globals (void);\n+\n+/* Functions defined in the GCC interface called by the Rust frontend\n+   proper.  */\n+\n+extern void rust_preserve_from_gc (tree);\n+\n+extern bool saw_errors (void);\n+\n+extern const char *rust_localize_identifier (const char*);\n+\n+extern unsigned int rust_field_alignment (tree);\n+\n+extern void rust_imported_unsafe (void);\n+\n+extern GTY(()) tree rust_non_zero_struct;\n+\n+#endif /* !defined(RUST_RUST_C_H) */"}, {"sha": "0cfbe69a82590202f87448bb5053291d1822cbaa", "filename": "gcc/rust/rust-diagnostics.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,60 @@\n+// rust-diagnostics.h -- interface to diagnostic reporting   -*- C++ -*-\n+\n+#ifndef RUST_DIAGNOSTICS_H\n+#define RUST_DIAGNOSTICS_H\n+\n+#include \"rust-linemap.h\"\n+\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)\n+#define RUST_ATTRIBUTE_GCC_DIAG(m, n) __attribute__ ((__format__ (__gcc_tdiag__, m, n))) __attribute__ ((__nonnull__ (m)))\n+#else\n+#define RUST_ATTRIBUTE_GCC_DIAG(m,  n)\n+#endif\n+\n+// These declarations define the interface through which the frontend\n+// reports errors and warnings. These functions accept printf-like\n+// format specifiers (e.g. %d, %f, %s, etc), with the following additional\n+// extensions:\n+//\n+//  1.  'q' qualifier may be applied to a specifier to add quoting, e.g.\n+//      %qd produces a quoted decimal output, %qs a quoted string output.\n+//      [This extension is supported only with single-character format\n+//      specifiers].\n+//\n+//  2.  %m specifier outputs value of \"strerror(errno)\" at time of call.\n+//\n+//  3.  %< outputs an opening quote, %> a closing quote.\n+//\n+// All other format specifiers are as defined by 'sprintf'. The final resulting\n+// message is then sent to the back end via rust_be_error_at/rust_be_warning_at.\n+\n+extern void rust_error_at(const Location, const char* fmt, ...)\n+    RUST_ATTRIBUTE_GCC_DIAG(2,3);\n+extern void rust_warning_at(const Location, int opt, const char* fmt, ...)\n+    RUST_ATTRIBUTE_GCC_DIAG(3,4);\n+extern void rust_fatal_error(const Location, const char* fmt, ...)\n+    RUST_ATTRIBUTE_GCC_DIAG(2,3);\n+extern void rust_inform(const Location, const char* fmt, ...)\n+    RUST_ATTRIBUTE_GCC_DIAG(2,3);\n+\n+// These interfaces provide a way for the front end to ask for\n+// the open/close quote characters it should use when formatting\n+// diagnostics (warnings, errors).\n+extern const char* rust_open_quote();\n+extern const char* rust_close_quote();\n+\n+// These interfaces are used by utilities above to pass warnings and\n+// errors (once format specifiers have been expanded) to the back end,\n+// and to determine quoting style. Avoid calling these routines directly;\n+// instead use the equivalent routines above. The back end is required to\n+// implement these routines.\n+\n+extern void rust_be_error_at(const Location, const std::string& errmsg);\n+extern void rust_be_warning_at(const Location, int opt,\n+                               const std::string& warningmsg);\n+extern void rust_be_fatal_error(const Location, const std::string& errmsg);\n+extern void rust_be_inform(const Location, const std::string& infomsg);\n+extern void rust_be_get_quotechars(const char** open_quote,\n+                                   const char** close_quote);\n+\n+#endif // !defined(RUST_DIAGNOSTICS_H)"}, {"sha": "fbbd7a81ac259c7850de9c7223184a766ac2e1c4", "filename": "gcc/rust/rust-gcc-diagnostics.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-gcc-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-gcc-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc-diagnostics.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334", "patch": "@@ -0,0 +1,43 @@\n+// rust-gcc-diagnostics.cc -- GCC implementation of rust diagnostics interface.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+\n+void\n+rust_be_error_at(const Location location, const std::string& errmsg)\n+{\n+  location_t gcc_loc = location.gcc_location();\n+  error_at(gcc_loc, \"%s\", errmsg.c_str());\n+}\n+\n+\n+void\n+rust_be_warning_at(const Location location,\n+                 int opt, const std::string& warningmsg)\n+{\n+  location_t gcc_loc = location.gcc_location();\n+  warning_at(gcc_loc, opt, \"%s\", warningmsg.c_str());\n+}\n+\n+void\n+rust_be_fatal_error(const Location location,\n+                  const std::string& fatalmsg)\n+{\n+  location_t gcc_loc = location.gcc_location();\n+  fatal_error(gcc_loc, \"%s\", fatalmsg.c_str());\n+}\n+\n+void\n+rust_be_inform(const Location location,\n+             const std::string& infomsg)\n+{\n+  location_t gcc_loc = location.gcc_location();\n+  inform(gcc_loc, \"%s\", infomsg.c_str());\n+}\n+\n+void\n+rust_be_get_quotechars(const char** open_qu, const char** close_qu)\n+{\n+  *open_qu = open_quote;\n+  *close_qu = close_quote;\n+}"}, {"sha": "3bc1d951d6510afc8682a3ad9395b8224477936d", "filename": "gcc/rust/rust-lang.c", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "aa75c6ef3e90eaf4a290e6d971d69c9970d3c658", "filename": "gcc/rust/rust-linemap.cc", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-linemap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-linemap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "0f2dc9b6e9dbaee7a14b35d705d81ef1ecc495e3", "filename": "gcc/rust/rust-linemap.h", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-linemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-linemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-linemap.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1c2c5641b66b260c15a869a134f9ba7fff7a38d7", "filename": "gcc/rust/rust-location.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-location.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5a822403a56c66568cd2ccea1f7b7a12c6924ec3", "filename": "gcc/rust/rust-system.h", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "cecc84f14756be40937ac71eb145bb1cd4fd1614", "filename": "gcc/rust/rustc_parser/RustCNotes.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2FRustCNotes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2FRustCNotes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2FRustCNotes.txt?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "3e4498759434f92723f6a9665fb1fa7bc6d9997c", "filename": "gcc/rust/rustc_parser/grammar/.gitignore", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2F.gitignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2F.gitignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2F.gitignore?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1feb781b2b39ff4984156ca9fd695b61dcd41da1", "filename": "gcc/rust/rustc_parser/grammar/lexer.l", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Flexer.l?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6348190cc140bc8ae496ec99a9000ef4d934c334", "filename": "gcc/rust/rustc_parser/grammar/parser-lalr-main.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr-main.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5585c95a5a63a828558a6a9073b57458d1220fbc", "filename": "gcc/rust/rustc_parser/grammar/parser-lalr.y", "status": "added", "additions": 1982, "deletions": 0, "changes": 1982, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr.y?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "gcc/rust/rustc_parser/grammar/raw-string-literal-ambiguity.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "4b5a7fb9e10b5c4ce4f6d6f52932787194713d5d", "filename": "gcc/rust/rustc_parser/grammar/testparser.py", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftestparser.py?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "297e3dc841e871502e2270c95fdf6565806f0f5a", "filename": "gcc/rust/rustc_parser/grammar/tokens.h", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftokens.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c5daa6564767e617511bbaf61b8c9e43532d2cc8", "filename": "gcc/rust/rustc_parser/libsyntax/Cargo.toml", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FCargo.toml?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "daa252ef4551b38715776b9a1a71a862c17727c9", "filename": "gcc/rust/rustc_parser/libsyntax/README.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FREADME.md?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c627596bbdf20ea7720e5175660b07787c8f5a09", "filename": "gcc/rust/rustc_parser/libsyntax/ast.rs", "status": "added", "additions": 2409, "deletions": 0, "changes": 2409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fast.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "b41f1047fcba3765c952f4d3197b5e19a926a472", "filename": "gcc/rust/rustc_parser/libsyntax/attr/builtin.rs", "status": "added", "additions": 903, "deletions": 0, "changes": 903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a9f2429560ad288ff68901812df07c5ad3e04737", "filename": "gcc/rust/rustc_parser/libsyntax/attr/mod.rs", "status": "added", "additions": 753, "deletions": 0, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fmod.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "9b861f9640904b51bdc7ef32d294f40d054ebb26", "filename": "gcc/rust/rustc_parser/libsyntax/build.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fbuild.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fbuild.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fbuild.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1ab367f73c1b31a1da288c8a293fc999d5ee150a", "filename": "gcc/rust/rustc_parser/libsyntax/config.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fconfig.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6f7493ad59726d4003f8b63067adf1863b894ade", "filename": "gcc/rust/rustc_parser/libsyntax/diagnostics/macros.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "53f37bb10bdc0ecfb61bb228826c27c66fea896d", "filename": "gcc/rust/rustc_parser/libsyntax/diagnostics/metadata.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ee640a1603a6ca688c54a648102efa6b7bee3d7a", "filename": "gcc/rust/rustc_parser/libsyntax/diagnostics/plugin.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "b26a1165fed1db27ffc68657322ae91c86182d48", "filename": "gcc/rust/rustc_parser/libsyntax/early_buffered_lints.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fearly_buffered_lints.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fearly_buffered_lints.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fearly_buffered_lints.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "0b6cf30bd27d248207397ef3338ae9f62e4faff9", "filename": "gcc/rust/rustc_parser/libsyntax/entry.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fentry.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e2d212eb721ff9cadcbb26ef5eb0e58a8b091d87", "filename": "gcc/rust/rustc_parser/libsyntax/error_codes.rs", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ferror_codes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ferror_codes.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "15c0b6ca5aa81248b7d149e78d7ee701565b37db", "filename": "gcc/rust/rustc_parser/libsyntax/ext/base.rs", "status": "added", "additions": 1013, "deletions": 0, "changes": 1013, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbase.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "baf1031de1e7c40ddbe0f5f84be5bfa792f25ed6", "filename": "gcc/rust/rustc_parser/libsyntax/ext/build.rs", "status": "added", "additions": 1210, "deletions": 0, "changes": 1210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbuild.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "2a56f3dd7566bc2fa06b0994097c312b868eaf28", "filename": "gcc/rust/rustc_parser/libsyntax/ext/derive.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fderive.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "74ef5cbe9177ebf767c6206fa87e95acdbfaf7d2", "filename": "gcc/rust/rustc_parser/libsyntax/ext/expand.rs", "status": "added", "additions": 1471, "deletions": 0, "changes": 1471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fexpand.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "b2b8bfb09b45e9206603929424642976a6390644", "filename": "gcc/rust/rustc_parser/libsyntax/ext/placeholders.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c2ba8b983f5a84b2393bd7a948183ddc162023f4", "filename": "gcc/rust/rustc_parser/libsyntax/ext/source_util.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fsource_util.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "fc8aa4793bc6111eba60d007e077c69ac1d7be7c", "filename": "gcc/rust/rustc_parser/libsyntax/ext/tt/macro_parser.rs", "status": "added", "additions": 954, "deletions": 0, "changes": 954, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "665c794422d49cc51433835a3d163d47fba09135", "filename": "gcc/rust/rustc_parser/libsyntax/ext/tt/macro_rules.rs", "status": "added", "additions": 1206, "deletions": 0, "changes": 1206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ccf9db842ab6e467acbe3446d0938916dfeaa341", "filename": "gcc/rust/rustc_parser/libsyntax/ext/tt/quoted.rs", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e04fd2ddc05bce62332409adbd00515ad3de7069", "filename": "gcc/rust/rustc_parser/libsyntax/ext/tt/transcribe.rs", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "fd1cb3d803b0916cf74a49c16427ac8039ff3239", "filename": "gcc/rust/rustc_parser/libsyntax/feature_gate.rs", "status": "added", "additions": 2646, "deletions": 0, "changes": 2646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ffeature_gate.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "767ab74355e66213ff8c27fbec2ba22be41f7302", "filename": "gcc/rust/rustc_parser/libsyntax/json.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fjson.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a7c5ed158e0287158e3118869365ed8d6c0e360f", "filename": "gcc/rust/rustc_parser/libsyntax/lib.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Flib.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "11a1de13fc217874cef8fb8d67eed2fefc9bd50b", "filename": "gcc/rust/rustc_parser/libsyntax/mut_visit.rs", "status": "added", "additions": 1334, "deletions": 0, "changes": 1334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fmut_visit.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "b28d48b9445fdcd6c66a9db199bd988f0ee2dbef", "filename": "gcc/rust/rustc_parser/libsyntax/parse/attr.rs", "status": "added", "additions": 305, "deletions": 0, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fattr.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6ebfab3a133ef80da61e6f8d75be0c8afa8314c4", "filename": "gcc/rust/rustc_parser/libsyntax/parse/classify.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fclassify.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "edcdb18a037d863f5b08fff410fce9c6e4c6bebc", "filename": "gcc/rust/rustc_parser/libsyntax/parse/diagnostics.rs", "status": "added", "additions": 1273, "deletions": 0, "changes": 1273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "988f1aa38d926e814e9df631d7b4b1f118cb3e6a", "filename": "gcc/rust/rustc_parser/libsyntax/parse/lexer/comments.rs", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d0c4e8d6a5634b6bbbc09b8f252605141423bdc7", "filename": "gcc/rust/rustc_parser/libsyntax/parse/lexer/mod.rs", "status": "added", "additions": 1609, "deletions": 0, "changes": 1609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "830fbec58ded952c109184007741491d7a17aaa2", "filename": "gcc/rust/rustc_parser/libsyntax/parse/lexer/tokentrees.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6a870685938a04bb8463baf75a5c22b463b5e234", "filename": "gcc/rust/rustc_parser/libsyntax/parse/lexer/unicode_chars.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ef55bf6b929336511e4dc5f3fb5d0317e500535f", "filename": "gcc/rust/rustc_parser/libsyntax/parse/literal.rs", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fliteral.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "4c4551b1757acefd44615353243d9ae937f961ea", "filename": "gcc/rust/rustc_parser/libsyntax/parse/mod.rs", "status": "added", "additions": 680, "deletions": 0, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fmod.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a95b6891fb9d5876d243bfabc8cfe545be4102eb", "filename": "gcc/rust/rustc_parser/libsyntax/parse/parser.rs", "status": "added", "additions": 7852, "deletions": 0, "changes": 7852, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fparser.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ebd0decacb59fff2032d61444af8d801f78a6cc4", "filename": "gcc/rust/rustc_parser/libsyntax/parse/token.rs", "status": "added", "additions": 827, "deletions": 0, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Ftoken.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "87cc9c1c9e323efd1b9dee8bc763eb1400889d20", "filename": "gcc/rust/rustc_parser/libsyntax/parse/unescape.rs", "status": "added", "additions": 602, "deletions": 0, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "71b41161ad8c6fd00553ad0f21e526a818e04c42", "filename": "gcc/rust/rustc_parser/libsyntax/parse/unescape_error_reporting.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f64e95aee5bca91ee5ac4382bdf997db165a519e", "filename": "gcc/rust/rustc_parser/libsyntax/print/pp.rs", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpp.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "67646cce69b4f47d2addf5753ad5c20a98845fba", "filename": "gcc/rust/rustc_parser/libsyntax/print/pprust.rs", "status": "added", "additions": 3069, "deletions": 0, "changes": 3069, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "be580dc2e6a7e4aaff0ae4ef00ef235ee9842020", "filename": "gcc/rust/rustc_parser/libsyntax/ptr.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fptr.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5e0cf9eea78b85a6f330e7edd5d27c84d7af1f26", "filename": "gcc/rust/rustc_parser/libsyntax/show_span.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fshow_span.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ac30cbb471aeab3bf53e948dd37960d4b3a1c241", "filename": "gcc/rust/rustc_parser/libsyntax/source_map.rs", "status": "added", "additions": 1244, "deletions": 0, "changes": 1244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fsource_map.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6630bf9081546de2a712a73d7355e09debf9465a", "filename": "gcc/rust/rustc_parser/libsyntax/std_inject.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fstd_inject.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c717f140ca368e36a8536c3debf526873832b7eb", "filename": "gcc/rust/rustc_parser/libsyntax/test.rs", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "107cbe70a23d7aef0d4a1058f41da25bf3bd9be2", "filename": "gcc/rust/rustc_parser/libsyntax/test_snippet.rs", "status": "added", "additions": 1164, "deletions": 0, "changes": 1164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest_snippet.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "b32049b1da8c365992d1b284701b4553b654b331", "filename": "gcc/rust/rustc_parser/libsyntax/tokenstream.rs", "status": "added", "additions": 665, "deletions": 0, "changes": 665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftokenstream.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "885b5a4f333b8fc74177f76f3c118e31ac2a70e4", "filename": "gcc/rust/rustc_parser/libsyntax/util/lev_distance.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Flev_distance.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5724b540a0dcfb51206bb69300296c419dcc40cc", "filename": "gcc/rust/rustc_parser/libsyntax/util/map_in_place.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fmap_in_place.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fmap_in_place.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f17eb3b39432efccb2d5e87eec22f4f70033558a", "filename": "gcc/rust/rustc_parser/libsyntax/util/node_count.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fnode_count.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1e52186a106c12f80753be3b183139b4bc78dbb7", "filename": "gcc/rust/rustc_parser/libsyntax/util/parser.rs", "status": "added", "additions": 402, "deletions": 0, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f850960624ce7eec4b8c5502c7b60e1a896b6022", "filename": "gcc/rust/rustc_parser/libsyntax/util/parser_testing.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "9ec9550f93ab93f1d42c44ade154f630c80ac6ec", "filename": "gcc/rust/rustc_parser/libsyntax/visit.rs", "status": "added", "additions": 857, "deletions": 0, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fvisit.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "eafbe6371a3c56f3332f983227643a74025edaf4", "filename": "gcc/rust/rustc_parser/libsyntax_ext/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2FCargo.toml?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c1c2732605c46d5c199c1142527bee315d41c211", "filename": "gcc/rust/rustc_parser/libsyntax_ext/asm.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fasm.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "637614a18bcc339a07f76cfd40bff8927a0e8171", "filename": "gcc/rust/rustc_parser/libsyntax_ext/assert.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fassert.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e952515bfe0ebf978b68d3fb0f40ec6a14cd65e4", "filename": "gcc/rust/rustc_parser/libsyntax_ext/cfg.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcfg.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "59d3f2c9c7813a0901097227b18546ead73315f8", "filename": "gcc/rust/rustc_parser/libsyntax_ext/compile_error.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcompile_error.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcompile_error.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcompile_error.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "68d5178372eba7b774b61dca11a1faa607937a4f", "filename": "gcc/rust/rustc_parser/libsyntax_ext/concat.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "df9191416038d7f825671f642e6f1aba83705d63", "filename": "gcc/rust/rustc_parser/libsyntax_ext/concat_idents.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat_idents.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d5b8a00c75b834ad8862ba66c0d4a2adc99eca66", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/bounds.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fbounds.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "b3b6328e2ca7306536dff1787ca2ac07fcd8d2bb", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/clone.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1d981e0ff7906ba8b4788c6bb9cbcdbfa84c19d6", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/cmp/eq.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "844865d57c7ad04102534e86736abd736c2fabe2", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/cmp/ord.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "732bb234389a0aedd1ccf474f36d27ec3621d8b2", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a30a7d78222f47202e348f5a53b6ee694e67c242", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "98465d75e4680e9d31beb6665f871e22e0ade22b", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/custom.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "44ddbb98809b4f0d217bc234df31b15071520e35", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/debug.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "8009f42b8cf95b8650839101d50d1facb5139fac", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/decodable.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "fd8e87e2fefd17fc0674a7f096d4deb45e58a2ff", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/default.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "cd89a42cf82703a083fb0bcfa47b9abe0a7f1eba", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/encodable.rs", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "12482f7248e90b5eb43a71ea90ecde045eb96ead", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/generic/mod.rs", "status": "added", "additions": 1831, "deletions": 0, "changes": 1831, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "02b02e9b836957336bc51e566dc7d3aa211ef711", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/generic/ty.rs", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "7ad04aebf6e2ea6e4d5bfc2c5c49b0d3f5165216", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/hash.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e491e93256d1cf776d509b7910ebf11d3cf5e578", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/mod.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "b7f2ecf0f9137b9931b40aecca232d8df3a18f5f", "filename": "gcc/rust/rustc_parser/libsyntax_ext/env.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fenv.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "9bbd9fdec17d69d8951703488ba5c228e2d37d0c", "filename": "gcc/rust/rustc_parser/libsyntax_ext/error_codes.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ferror_codes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ferror_codes.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c3dbd48cc6e4e8bbebcfd83138c2e8b7fcc2e9c7", "filename": "gcc/rust/rustc_parser/libsyntax_ext/format.rs", "status": "added", "additions": 1090, "deletions": 0, "changes": 1090, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "3d4f82764413a0021fd93b3dfb194b259ad18264", "filename": "gcc/rust/rustc_parser/libsyntax_ext/format_foreign.rs", "status": "added", "additions": 836, "deletions": 0, "changes": 836, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "87021f1ef5a52857e55023624abb719b71b2113e", "filename": "gcc/rust/rustc_parser/libsyntax_ext/format_foreign/printf/tests.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "8ef58b8387e5a5f9cedcf24bd26ed9dc99e0020d", "filename": "gcc/rust/rustc_parser/libsyntax_ext/format_foreign/shell/tests.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "112192fac5d26dd79531eaf808eb0e6a479561d7", "filename": "gcc/rust/rustc_parser/libsyntax_ext/global_asm.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fglobal_asm.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "62530f4fe7b336dd11524db94418faff18b6610e", "filename": "gcc/rust/rustc_parser/libsyntax_ext/lib.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flib.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "cbdfd08b4977f2f5a6c946f4f516adef6aa5d0eb", "filename": "gcc/rust/rustc_parser/libsyntax_ext/log_syntax.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flog_syntax.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flog_syntax.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "45e65288a24ee6a3b7614f24ef77d961812cb321", "filename": "gcc/rust/rustc_parser/libsyntax_ext/proc_macro_decls.rs", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f0fc6392cd73f593f7e963e8c4342f8ce2182b37", "filename": "gcc/rust/rustc_parser/libsyntax_ext/proc_macro_impl.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e502735452735d8dca8264ae20b834953a2acdfd", "filename": "gcc/rust/rustc_parser/libsyntax_ext/proc_macro_server.rs", "status": "added", "additions": 717, "deletions": 0, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "24d3055e7114087192cb2ccfa784ac31ebe96425", "filename": "gcc/rust/rustc_parser/libsyntax_ext/test.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "186673c142f14b13db8daeb72df7155548329bcc", "filename": "gcc/rust/rustc_parser/libsyntax_ext/test_case.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest_case.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "0dce8a36f4c7b24c39b769eb58c1dbeba3913c07", "filename": "gcc/rust/rustc_parser/libsyntax_ext/trace_macros.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftrace_macros.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "eebd25d1fafd82e37c53277f66474313255db5b1", "filename": "gcc/rust/rustc_parser/libsyntax_pos/Cargo.toml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2FCargo.toml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2FCargo.toml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2FCargo.toml?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "353b4e4ab36b3a4095b860542897aa0d076cca6f", "filename": "gcc/rust/rustc_parser/libsyntax_pos/analyze_source_file.rs", "status": "added", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fanalyze_source_file.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fanalyze_source_file.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fanalyze_source_file.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "20216568426fed72d2938c8d0fdcbee129df52e7", "filename": "gcc/rust/rustc_parser/libsyntax_pos/edition.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fedition.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a6c8c76cf23f7375b2bdc13cd0d75d3c2c984a3c", "filename": "gcc/rust/rustc_parser/libsyntax_pos/hygiene.rs", "status": "added", "additions": 763, "deletions": 0, "changes": 763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fhygiene.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "07b9f60932024db20a488398270f7a42e4afdc03", "filename": "gcc/rust/rustc_parser/libsyntax_pos/lib.rs", "status": "added", "additions": 1446, "deletions": 0, "changes": 1446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Flib.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "525ec13623289e50c3f6921cdeabac851a1f3612", "filename": "gcc/rust/rustc_parser/libsyntax_pos/span_encoding.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fspan_encoding.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "89fcf3b1f8f190845213d7f55d709e50c5f22498", "filename": "gcc/rust/rustc_parser/libsyntax_pos/symbol.rs", "status": "added", "additions": 1380, "deletions": 0, "changes": 1380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fsymbol.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "00ef2327251d26f8816594de78f1045c81f29b73", "filename": "gcc/rust/rustfrontend/main.cc", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustfrontend%2Fmain.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustfrontend%2Fmain.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Fmain.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f83705f9839bf411ff34c3fef2fee9fe705767e0", "filename": "gcc/rust/rustspec.cc", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Frustspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustspec.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d0b6693491fa73f19a51ae0511322f307c723e4f", "filename": "gcc/rust/test/rustc_bison_test/lex.yy.c", "status": "added", "additions": 3389, "deletions": 0, "changes": 3389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "934c28e2526b60090388fdc45c85c7c655235ec4", "filename": "gcc/rust/test/rustc_bison_test/lex.yy.cc", "status": "added", "additions": 3151, "deletions": 0, "changes": 3151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1feb781b2b39ff4984156ca9fd695b61dcd41da1", "filename": "gcc/rust/test/rustc_bison_test/lexer.l", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flexer.l?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a0cab12704e6aa4512697788dfba26c7aaa067fb", "filename": "gcc/rust/test/rustc_bison_test/parser-interface.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-interface.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5585c95a5a63a828558a6a9073b57458d1220fbc", "filename": "gcc/rust/test/rustc_bison_test/parser-lalr.y", "status": "added", "additions": 1982, "deletions": 0, "changes": 1982, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-lalr.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-lalr.y?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "795ff6a110cec52614c560e0fcad6fcb731b1819", "filename": "gcc/rust/test/rustc_bison_test/parser.tab.c", "status": "added", "additions": 9173, "deletions": 0, "changes": 9173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser.tab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser.tab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser.tab.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d3bec021655681031f840581dec8c1d7755165aa", "filename": "gcc/rust/test/rustc_bison_test/token.h", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Ftoken.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Frustc_bison_test%2Ftoken.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Ftoken.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f35de3a1e480b52c7b965ae8e244d7c708de8831", "filename": "gcc/rust/test/test_jit.c", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Ftest_jit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest%2Ftest_jit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest_jit.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "718040bc616ffc4dea894d06abce5b6beb6aff57", "filename": "gcc/rust/test2/rust-c.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frust-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frust-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frust-c.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a21984ca036b5e153186959e905cf7462bc2f0d3", "filename": "gcc/rust/test2/rust-lang.c", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frust-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frust-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frust-lang.c?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5104142b33fafd09cdacd9d11afd1f4e365e82ed", "filename": "gcc/rust/test2/rustfrontend/eTokenType.enum.h", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2FeTokenType.enum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2FeTokenType.enum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2FeTokenType.enum.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "4d2958ae8c1394093693d28a71119c381249921c", "filename": "gcc/rust/test2/rustfrontend/rs-generic-converter.cc", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-generic-converter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-generic-converter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-generic-converter.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "309c83fdecd97292001a4ca25dee117771c14a33", "filename": "gcc/rust/test2/rustfrontend/rs-lex.cc", "status": "added", "additions": 2884, "deletions": 0, "changes": 2884, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5835f42d067b9e658b0f685762794f4a2e1117d1", "filename": "gcc/rust/test2/rustfrontend/rs-lex.h", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e3c4d394ebf56878192182410c8691e24b7fa751", "filename": "gcc/rust/test2/rustfrontend/rs-token.h", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-token.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "989c99209f1a4d28a324b526e2b0abb6699431fc", "filename": "gcc/rust/test2/rustfrontend/rust.cc", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest2%2Frustfrontend%2Frust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frust.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "500960c3b61a7249eb3e30ef4facbf8956b3ea05", "filename": "gcc/rust/test3-tiny/Make-lang.in", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2FMake-lang.in?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "823f626a44f8135070ef4b7bbe5f1cbeb95ede6b", "filename": "gcc/rust/test3-tiny/config-lang.in", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fconfig-lang.in?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c36a9e7e55bafb5df7ebcf7bf127e0d28eed9092", "filename": "gcc/rust/test3-tiny/lang-specs.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flang-specs.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e620b8443cc09e7a10c87510d05a44f3f4ecb654", "filename": "gcc/rust/test3-tiny/lex/rust-lex.cc", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "4d0bdbb2a55cdf0d298466d92f96b77fee57fadf", "filename": "gcc/rust/test3-tiny/lex/rust-lex.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1a4fe388dc8ed67801fda549f95dd827b41c36e8", "filename": "gcc/rust/test3-tiny/lex/rust-token.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "68c8d63d1d5164b78fa7ed15d6c1f3bed6a023b0", "filename": "gcc/rust/test3-tiny/lex/rust-token.h", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a38f0c4e996d718563dc3a0b250386cf5b6aa733", "filename": "gcc/rust/test3-tiny/parse/rust-misc-convert.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-misc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-misc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-misc-convert.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ec9c2122503e9701cbfa657f98082d1fbd12b134", "filename": "gcc/rust/test3-tiny/parse/rust-parse.cc", "status": "added", "additions": 1806, "deletions": 0, "changes": 1806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "60768cfd022fce0e2a3f686f8fc39e72f62ec17c", "filename": "gcc/rust/test3-tiny/parse/rust-parse.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d38a07801cc0280c501b04ea6499d61f6403581e", "filename": "gcc/rust/test3-tiny/parse/rust-scope.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1d1f6e2959ff843df2a951920166a7ffd6230dfd", "filename": "gcc/rust/test3-tiny/parse/rust-scope.h", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6318a50d31468955dfe42dd314696cd2aa2bf0ed", "filename": "gcc/rust/test3-tiny/parse/rust-tree.h", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-tree.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "69a14ada3fe585ee2340dc17b5384474b8d1f0ee", "filename": "gcc/rust/test3-tiny/rsspec.cc", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Frsspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Frsspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Frsspec.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "bfd36be88fb7d10ce87fc570ddfd7bee74d5a59c", "filename": "gcc/rust/test3-tiny/rust-buffered-queue.h", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Frust-buffered-queue.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d8f85ca6caa4a7b61db5a567ecabebae674d57ee", "filename": "gcc/rust/test3-tiny/rust-lang.cc", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3-tiny%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Frust-lang.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "4d4e3319e20a9cc3096be759c995ec461a0609db", "filename": "gcc/rust/test3/Make-lang.in", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2FMake-lang.in?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "0c71c828e56c3eb422247026617e1014eb3b6b94", "filename": "gcc/rust/test3/ast/clone-test.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Fclone-test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Fclone-test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Fclone-test.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "81b01876288672bbe143668f3ae44506424aad42", "filename": "gcc/rust/test3/ast/rust-ast-containers.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-containers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-containers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-containers.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "9afa95ba281c4a26df63793579dc1eb3a8ea301c", "filename": "gcc/rust/test3/ast/rust-ast-full-test.cc", "status": "added", "additions": 828, "deletions": 0, "changes": 828, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full-test.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "53782362a52b75f8e947d08f5d25163edba2c04f", "filename": "gcc/rust/test3/ast/rust-ast-full.h", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-ast-full.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "87faa1a71b0eaa102d1a180372ac498b03cfb2cf", "filename": "gcc/rust/test3/ast/rust-ast.h", "status": "added", "additions": 985, "deletions": 0, "changes": 985, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-ast.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c2491f1b4f6d479e40310019886ef1bb27b2c9ce", "filename": "gcc/rust/test3/ast/rust-cond-compilation.h", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-cond-compilation.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "2694c0a184c363230f892c159bcc0c4a45cea670", "filename": "gcc/rust/test3/ast/rust-expr.h", "status": "added", "additions": 3943, "deletions": 0, "changes": 3943, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-expr.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "fd04b5555d6b63c1c44877ec5ee1fdb7614a541c", "filename": "gcc/rust/test3/ast/rust-item.h", "status": "added", "additions": 3387, "deletions": 0, "changes": 3387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-item.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c02871713e24f5364b83dfc93396c77a4542dc7c", "filename": "gcc/rust/test3/ast/rust-macro.h", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-macro.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1aba8474abd361e004542edcd17298599c8f1344", "filename": "gcc/rust/test3/ast/rust-path.h", "status": "added", "additions": 679, "deletions": 0, "changes": 679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-path.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "fae7a57c3fdd4860a5eb981cf67e62fcadce8379", "filename": "gcc/rust/test3/ast/rust-pattern.h", "status": "added", "additions": 956, "deletions": 0, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-pattern.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "296be009e2c0ca486b4d361decb471c3119dd634", "filename": "gcc/rust/test3/ast/rust-stmt.h", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-stmt.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c9b963deca23d1f395e03f9626fa69afd8bc8ca9", "filename": "gcc/rust/test3/ast/rust-type.h", "status": "added", "additions": 685, "deletions": 0, "changes": 685, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fast%2Frust-type.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "823f626a44f8135070ef4b7bbe5f1cbeb95ede6b", "filename": "gcc/rust/test3/config-lang.in", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fconfig-lang.in?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c36a9e7e55bafb5df7ebcf7bf127e0d28eed9092", "filename": "gcc/rust/test3/lang-specs.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flang-specs.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a00edb38873f076fc25922ed534016e02a316c71", "filename": "gcc/rust/test3/lex/rust-codepoint.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-codepoint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-codepoint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flex%2Frust-codepoint.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "a8a6877a2a303c52e814bd48e997b9491dab7125", "filename": "gcc/rust/test3/lex/rust-lex.cc", "status": "added", "additions": 2345, "deletions": 0, "changes": 2345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c051cd1520055cdc3c6c8a5f42eb95c1b20c7c59", "filename": "gcc/rust/test3/lex/rust-lex.h", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flex%2Frust-lex.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "47bf75013f6711a5cf541c23db79d06897b42cbf", "filename": "gcc/rust/test3/lex/rust-token.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flex%2Frust-token.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "bf65ed3b084a0cf22300189d782883c259df52f5", "filename": "gcc/rust/test3/lex/rust-token.h", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flex%2Frust-token.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "68dbc595910a93c7fd8b906448b1930d2431b822", "filename": "gcc/rust/test3/parse/rust-misc-convert.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-misc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-misc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-misc-convert.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ad7b920bc28a7af0bd8f0248dce56fb6f7e7fb54", "filename": "gcc/rust/test3/parse/rust-parse-includes.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse-includes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse-includes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse-includes.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d7823414348e1d3a642e3671a701ee4f3dcdedcb", "filename": "gcc/rust/test3/parse/rust-parse.cc", "status": "added", "additions": 10642, "deletions": 0, "changes": 10642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "be0654fbea0a91789a0d895ce13aa5deba14d2ee", "filename": "gcc/rust/test3/parse/rust-parse.h", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-parse.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d38a07801cc0280c501b04ea6499d61f6403581e", "filename": "gcc/rust/test3/parse/rust-scope.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "7ac38c998b6a9506981bea5b0f635ae1eb6938d4", "filename": "gcc/rust/test3/parse/rust-scope.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "439325b68feef10fde45cc76c4a4bf58b761f143", "filename": "gcc/rust/test3/parse/rust-symbol.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-symbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-symbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-symbol.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6318a50d31468955dfe42dd314696cd2aa2bf0ed", "filename": "gcc/rust/test3/parse/rust-tree.h", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Fparse%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-tree.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "69a14ada3fe585ee2340dc17b5384474b8d1f0ee", "filename": "gcc/rust/test3/rsspec.cc", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Frsspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Frsspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frsspec.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "65c814d58210e8ae97e4b1b343578d729e0667df", "filename": "gcc/rust/test3/rust-buffered-queue.h", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frust-buffered-queue.h?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "80bfa7476e9decc46ce82fc610afdc34aaa9a392", "filename": "gcc/rust/test3/rust-lang.cc", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Frust%2Ftest3%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frust-lang.cc?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ab395466afcf73a6f6f8637edf00d7091db5f7fd", "filename": "gcc/testsuite/rust.test/alias-uninit-value.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Falias-uninit-value.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Falias-uninit-value.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "873eb66e52e6f97e8503a6ba56e85c6f7589d060", "filename": "gcc/testsuite/rust.test/alignment-gep-tup-like-1.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-1.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "7c43385ed616784f37278fff771004caba8fa859", "filename": "gcc/testsuite/rust.test/alignment-gep-tup-like-2.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-2.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ddaa38223ecae07a9cb723c0ac9dc1d47d2575d3", "filename": "gcc/testsuite/rust.test/alloca-from-derived-tydesc.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Falloca-from-derived-tydesc.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "45e544cef8c8a21c74e2bd8577eb345d7d69e855", "filename": "gcc/testsuite/rust.test/anon-extern-mod-cross-crate-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod-cross-crate-2.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "343e9b9b8ad1f103018198a25b0650b2ae5304cb", "filename": "gcc/testsuite/rust.test/anon-extern-mod.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "843e9436229ec67473ec8c4ece823c117da41325", "filename": "gcc/testsuite/rust.test/anon-trait-static-method.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fanon-trait-static-method.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fanon-trait-static-method.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fanon-trait-static-method.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5780a4e97aed62567b8d7a719e7255f267b5c106", "filename": "gcc/testsuite/rust.test/anon_trait_static_method_exe.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fanon_trait_static_method_exe.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fanon_trait_static_method_exe.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fanon_trait_static_method_exe.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6d6ae3da62fef1b599524d7be3e24bdcc865b2a2", "filename": "gcc/testsuite/rust.test/argument-passing.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fargument-passing.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fargument-passing.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "9944241836b58241ed16ad68afff5d9773138290", "filename": "gcc/testsuite/rust.test/arith-0.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Farith-0.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Farith-0.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Farith-0.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "db8f0eac4f6b38ca60d8e44663aefe33f04373af", "filename": "gcc/testsuite/rust.test/arith-1.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Farith-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Farith-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Farith-1.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "70df6e46e59d7c4c115214193bdaf126cb12cd55", "filename": "gcc/testsuite/rust.test/arith-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Farith-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Farith-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Farith-2.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ae94ad379d01257d34ba66da107911fcd4389cf0", "filename": "gcc/testsuite/rust.test/arith-unsigned.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Farith-unsigned.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Farith-unsigned.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "7bc1354c3cefe9ee817e8e401dc47c2e6cffd94a", "filename": "gcc/testsuite/rust.test/artificial-block.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fartificial-block.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fartificial-block.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fartificial-block.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "2e1fc65d2baefce02b4fd968f1ce2fac836152b8", "filename": "gcc/testsuite/rust.test/asm-out-assign.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fasm-out-assign.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fasm-out-assign.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fasm-out-assign.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "3ea1f896dff3125b745ba4c39e59060fbafb6fe3", "filename": "gcc/testsuite/rust.test/assert-approx-eq-macro-success.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fassert-approx-eq-macro-success.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fassert-approx-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fassert-approx-eq-macro-success.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "047c339fafb3c85ccc6d0470b1bae09e32667c1b", "filename": "gcc/testsuite/rust.test/assert-eq-macro-success.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fassert-eq-macro-success.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "0f5d27015fb747a7709a6b3b908eeccf5a11eecb", "filename": "gcc/testsuite/rust.test/assign-assign.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fassign-assign.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fassign-assign.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fassign-assign.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "5269f7dab5aad92570635f8608b7adf0924674b5", "filename": "gcc/testsuite/rust.test/assignability-trait.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fassignability-trait.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fassignability-trait.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "316f8fa0f61f439ae6ee70a5a4b5385a635fbd1c", "filename": "gcc/testsuite/rust.test/attr-before-view-item.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "0721544aa0dc8a861c78362d69bef11a028ccaf9", "filename": "gcc/testsuite/rust.test/attr-before-view-item2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item2.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6078698ebd6b6fa7046ee04bcea943964dba9222", "filename": "gcc/testsuite/rust.test/attr-main-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-main-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-main-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-main-2.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "10de96c2c5387f77f7cc7e4d710e8c13aa20d272", "filename": "gcc/testsuite/rust.test/attr-main.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-main.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-main.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-main.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "48768a1c6fd27600f7c7707842d93a2bd3240162", "filename": "gcc/testsuite/rust.test/attr-no-drop-flag-size.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-no-drop-flag-size.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-no-drop-flag-size.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-no-drop-flag-size.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ca75af901295ce0a2c49906d27dc4506af3c5648", "filename": "gcc/testsuite/rust.test/attr-start.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-start.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fattr-start.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-start.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c1629851c5fb00224a47ea6df4618f120f1338f1", "filename": "gcc/testsuite/rust.test/auto-encode.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-encode.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-encode.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d8399848e09e300b0ce33e153ded210d88f884bb", "filename": "gcc/testsuite/rust.test/auto-instantiate.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-instantiate.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-instantiate.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "33aee55b8c7387a6c461af49ecc9a04b3ec7d6e7", "filename": "gcc/testsuite/rust.test/auto-loop.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-loop.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-loop.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "bb01c27fa0d5c17490774cd27fadf6b52d4a090a", "filename": "gcc/testsuite/rust.test/auto-ref-bounded-ty-param.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-bounded-ty-param.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-bounded-ty-param.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-bounded-ty-param.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "8adc2cfd571906595a3322ca25cce7d602566eaf", "filename": "gcc/testsuite/rust.test/auto-ref-newtype.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-newtype.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "d35341516f2a73d5b3ab86420cdd5e65587e2d9e", "filename": "gcc/testsuite/rust.test/auto-ref-slice-plus-ref.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-slice-plus-ref.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "8e2b3b56736e2a1da329d3455583756c9c6025b7", "filename": "gcc/testsuite/rust.test/auto-ref-sliceable.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-sliceable.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6dc679054275fbe47206761b2f861be9611466e5", "filename": "gcc/testsuite/rust.test/auto-ref.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fauto-ref.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "440ad723a12ce38ed34fa12a4223552c5e2569a6", "filename": "gcc/testsuite/rust.test/autobind.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautobind.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautobind.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautobind.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "fc643ec594089a4cc62f9eca2343f6e4afc6ee01", "filename": "gcc/testsuite/rust.test/autoderef-and-borrow-method-receiver.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-and-borrow-method-receiver.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-and-borrow-method-receiver.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-and-borrow-method-receiver.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e3a19b23e91bf34ed25fcc646464ed12c1cf18bc", "filename": "gcc/testsuite/rust.test/autoderef-method-newtype.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-newtype.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "9bc71517c1fb876463752e9b850141ab46a57fa3", "filename": "gcc/testsuite/rust.test/autoderef-method-on-trait.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-on-trait.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f9f78aa4882b415d785e319998a73a7996b0afe0", "filename": "gcc/testsuite/rust.test/autoderef-method-priority.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-priority.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-priority.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-priority.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "299760289c2b3468a0c62a70863c725f1a47aba1", "filename": "gcc/testsuite/rust.test/autoderef-method-twice-but-not-thrice.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice-but-not-thrice.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice-but-not-thrice.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice-but-not-thrice.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f93f0605269a443c70ea1df8613a75fc2104b16b", "filename": "gcc/testsuite/rust.test/autoderef-method-twice.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "eb173e3d5f8ec2afa9928f3ec140b30b25bdadcc", "filename": "gcc/testsuite/rust.test/autoderef-method.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "096e4378b3d433e0702439f90abbb13156136acb", "filename": "gcc/testsuite/rust.test/autoref-intermediate-types-issue-3585.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoref-intermediate-types-issue-3585.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "9b2855d269d73f045bfb16187d50b53ef56f49c0", "filename": "gcc/testsuite/rust.test/bare-static-string.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbare-static-string.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbare-static-string.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fbare-static-string.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "96615b740b72bf1dc9d4237da25b07d6ab4e559d", "filename": "gcc/testsuite/rust.test/big-literals.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbig-literals.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fbig-literals.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "f312cdae8bdeed6f5d1773c372f31c83d8c02426", "filename": "gcc/testsuite/rust.test/binary-minus-without-space.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbinary-minus-without-space.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbinary-minus-without-space.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fbinary-minus-without-space.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ad5573889dd36e397506f5165bbf06f1ad02094e", "filename": "gcc/testsuite/rust.test/bind-by-move.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbind-by-move.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbind-by-move.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fbind-by-move.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "10a7355c91d0b7b31548b830e460e33606461602", "filename": "gcc/testsuite/rust.test/binops.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbinops.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbinops.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fbinops.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "dcdab0edc3aaea1fb58dc323809b6532aad6e9f2", "filename": "gcc/testsuite/rust.test/bitv-perf-test.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbitv-perf-test.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fbitv-perf-test.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "b99067419b06e02ae68cb97883697b142c550aed", "filename": "gcc/testsuite/rust.test/bitwise.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbitwise.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fbitwise.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "6a59278982ad3fddbe30930bdf194b5900df4641", "filename": "gcc/testsuite/rust.test/block-arg-call-as.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-call-as.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "e65116f214743cd9798eb6ec1a60d297a7f80013", "filename": "gcc/testsuite/rust.test/block-arg-can-be-followed-by-binop.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-binop.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ed8641eaf85f99ddfc7afba968357acf934e1ae7", "filename": "gcc/testsuite/rust.test/block-arg-can-be-followed-by-block-arg.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1bb16f6041eec6b267f5aee866e185d3dd861390", "filename": "gcc/testsuite/rust.test/block-arg-can-be-followed-by-call.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-can-be-followed-by-call.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "fcd6a8d7c85e5fd1b6403e597a41d8fa7986b206", "filename": "gcc/testsuite/rust.test/block-arg-in-parentheses.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-in-parentheses.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "7ee9d9e5b5489f174559f6d16facf1abb8e6e16b", "filename": "gcc/testsuite/rust.test/block-arg-used-as-any.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-arg-used-as-any.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "c296a37a17ce0e3c4bdcdeeb3f7be8df565f6603", "filename": "gcc/testsuite/rust.test/block-arg.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-arg.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "1931ec589ac10951403699bcd8847fbfd77184b7", "filename": "gcc/testsuite/rust.test/block-explicit-types.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-explicit-types.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-explicit-types.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}, {"sha": "ace372dd2d3d9346d8db8a084044689c2ad44199", "filename": "gcc/testsuite/rust.test/block-expr-precedence.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-expr-precedence.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2ea9f7e7027a9945744f5f7c126a0618a30c334/gcc%2Ftestsuite%2Frust.test%2Fblock-expr-precedence.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fblock-expr-precedence.rs?ref=a2ea9f7e7027a9945744f5f7c126a0618a30c334"}]}