{"sha": "e99ef40892b598eeb3fa496cc472e111675d7f6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk5ZWY0MDg5MmI1OThlZWIzZmE0OTZjYzQ3MmUxMTE2NzVkN2Y2Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-01-10T16:59:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-01-10T16:59:09Z"}, "message": "re PR c++/81327 (cast to void* does not suppress -Wclass-memaccess)\n\n\tPR c++/81327\n\t* call.c (maybe_warn_class_memaccess): Add forward declaration.\n\tChange last argument from tree * to const vec<tree, va_gc> *, adjust\n\targs uses and check number of operands too.  Don't strip away any\n\tnops.  Use maybe_constant_value when looking for INTEGER_CST args.\n\tDeal with src argument not having pointer type.  Check\n\ttree_fits_uhwi_p before calling tree_to_uhwi.  Remove useless\n\ttest.\n\t(build_over_call): Call maybe_warn_class_memaccess here on the\n\toriginal arguments.\n\t(build_cxx_call): Rather than here on converted arguments.\n\n\t* g++.dg/Wclass-memaccess-2.C: Don't expect a warning when explicitly\n\tcast to void *.\n\nFrom-SVN: r256440", "tree": {"sha": "4215141484dca32b97d1741887ba59b0ce723562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4215141484dca32b97d1741887ba59b0ce723562"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e99ef40892b598eeb3fa496cc472e111675d7f6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e99ef40892b598eeb3fa496cc472e111675d7f6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e99ef40892b598eeb3fa496cc472e111675d7f6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e99ef40892b598eeb3fa496cc472e111675d7f6c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75ce74bbdd695ae793c03f93cfd55842806651e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75ce74bbdd695ae793c03f93cfd55842806651e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75ce74bbdd695ae793c03f93cfd55842806651e6"}], "stats": {"total": 88, "additions": 55, "deletions": 33}, "files": [{"sha": "3cce2120b5a1806be2119778495095dc53104626", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e99ef40892b598eeb3fa496cc472e111675d7f6c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e99ef40892b598eeb3fa496cc472e111675d7f6c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e99ef40892b598eeb3fa496cc472e111675d7f6c", "patch": "@@ -1,3 +1,17 @@\n+2018-01-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/81327\n+\t* call.c (maybe_warn_class_memaccess): Add forward declaration.\n+\tChange last argument from tree * to const vec<tree, va_gc> *, adjust\n+\targs uses and check number of operands too.  Don't strip away any\n+\tnops.  Use maybe_constant_value when looking for INTEGER_CST args.\n+\tDeal with src argument not having pointer type.  Check\n+\ttree_fits_uhwi_p before calling tree_to_uhwi.  Remove useless\n+\ttest.\n+\t(build_over_call): Call maybe_warn_class_memaccess here on the\n+\toriginal arguments.\n+\t(build_cxx_call): Rather than here on converted arguments.\n+\n 2018-01-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/81055"}, {"sha": "515e4607de0db2f39cd1e7af4f056e1b6aed262e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e99ef40892b598eeb3fa496cc472e111675d7f6c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e99ef40892b598eeb3fa496cc472e111675d7f6c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e99ef40892b598eeb3fa496cc472e111675d7f6c", "patch": "@@ -147,6 +147,8 @@ static int equal_functions (tree, tree);\n static int joust (struct z_candidate *, struct z_candidate *, bool,\n \t\t  tsubst_flags_t);\n static int compare_ics (conversion *, conversion *);\n+static void maybe_warn_class_memaccess (location_t, tree,\n+\t\t\t\t\tconst vec<tree, va_gc> *);\n static tree build_over_call (struct z_candidate *, int, tsubst_flags_t);\n #define convert_like(CONV, EXPR, COMPLAIN)\t\t\t\\\n   convert_like_real ((CONV), (EXPR), NULL_TREE, 0,\t\t\\\n@@ -8180,6 +8182,12 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       && !mark_used (fn, complain))\n     return error_mark_node;\n \n+  /* Warn if the built-in writes to an object of a non-trivial type.  */\n+  if (warn_class_memaccess\n+      && vec_safe_length (args) >= 2\n+      && DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL)\n+    maybe_warn_class_memaccess (input_location, fn, args);\n+\n   if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0\n       /* Don't mess with virtual lookup in instantiate_non_dependent_expr;\n \t virtual functions can't be constexpr.  */\n@@ -8360,23 +8368,19 @@ has_trivial_copy_p (tree type, bool access, bool hasctor[2])\n    assignments.  */\n \n static void\n-maybe_warn_class_memaccess (location_t loc, tree fndecl, tree *args)\n+maybe_warn_class_memaccess (location_t loc, tree fndecl,\n+\t\t\t    const vec<tree, va_gc> *args)\n {\n   /* Except for bcopy where it's second, the destination pointer is\n      the first argument for all functions handled here.  Compute\n      the index of the destination and source arguments.  */\n   unsigned dstidx = DECL_FUNCTION_CODE (fndecl) == BUILT_IN_BCOPY;\n   unsigned srcidx = !dstidx;\n \n-  tree dest = args[dstidx];\n-  if (!dest || !TREE_TYPE (dest) || !POINTER_TYPE_P (TREE_TYPE (dest)))\n+  tree dest = (*args)[dstidx];\n+  if (!TREE_TYPE (dest) || !POINTER_TYPE_P (TREE_TYPE (dest)))\n     return;\n \n-  /* Remove the outermost (usually implicit) conversion to the void*\n-     argument type.  */\n-  if (TREE_CODE (dest) == NOP_EXPR)\n-    dest = TREE_OPERAND (dest, 0);\n-\n   tree srctype = NULL_TREE;\n \n   /* Determine the type of the pointed-to object and whether it's\n@@ -8436,7 +8440,7 @@ maybe_warn_class_memaccess (location_t loc, tree fndecl, tree *args)\n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n     case BUILT_IN_MEMSET:\n-      if (!integer_zerop (args[1]))\n+      if (!integer_zerop (maybe_constant_value ((*args)[1])))\n \t{\n \t  /* Diagnose setting non-copy-assignable or non-trivial types,\n \t     or types with a private member, to (potentially) non-zero\n@@ -8497,8 +8501,11 @@ maybe_warn_class_memaccess (location_t loc, tree fndecl, tree *args)\n     case BUILT_IN_MEMMOVE:\n     case BUILT_IN_MEMPCPY:\n       /* Determine the type of the source object.  */\n-      srctype = STRIP_NOPS (args[srcidx]);\n-      srctype = TREE_TYPE (TREE_TYPE (srctype));\n+      srctype = TREE_TYPE ((*args)[srcidx]);\n+      if (!srctype || !POINTER_TYPE_P (srctype))\n+\tsrctype = void_type_node;\n+      else\n+\tsrctype = TREE_TYPE (srctype);\n \n       /* Since it's impossible to determine wheter the byte copy is\n \t being used in place of assignment to an existing object or\n@@ -8547,13 +8554,16 @@ maybe_warn_class_memaccess (location_t loc, tree fndecl, tree *args)\n \t\t\t       \"assignment or copy-initialization instead\",\n \t\t\t       fndecl, desttype, access, fld, srctype);\n \t}\n-      else if (!trivial && TREE_CODE (args[2]) == INTEGER_CST)\n+      else if (!trivial && vec_safe_length (args) > 2)\n \t{\n+\t  tree sz = maybe_constant_value ((*args)[2]);\n+\t  if (!tree_fits_uhwi_p (sz))\n+\t    break;\n+\n \t  /* Finally, warn on partial copies.  */\n \t  unsigned HOST_WIDE_INT typesize\n \t    = tree_to_uhwi (TYPE_SIZE_UNIT (desttype));\n-\t  if (unsigned HOST_WIDE_INT partial\n-\t      = tree_to_uhwi (args[2]) % typesize)\n+\t  if (unsigned HOST_WIDE_INT partial = tree_to_uhwi (sz) % typesize)\n \t    warned = warning_at (loc, OPT_Wclass_memaccess,\n \t\t\t\t (typesize - partial > 1\n \t\t\t\t  ? G_(\"%qD writing to an object of \"\n@@ -8577,26 +8587,24 @@ maybe_warn_class_memaccess (location_t loc, tree fndecl, tree *args)\n       else if (!get_dtor (desttype, tf_none))\n \twarnfmt = G_(\"%qD moving an object of type %#qT with deleted \"\n \t\t     \"destructor\");\n-      else if (!trivial\n-\t       && TREE_CODE (args[1]) == INTEGER_CST\n-\t       && tree_int_cst_lt (args[1], TYPE_SIZE_UNIT (desttype)))\n+      else if (!trivial)\n \t{\n-\t  /* Finally, warn on reallocation into insufficient space.  */\n-\t  warned = warning_at (loc, OPT_Wclass_memaccess,\n-\t\t\t       \"%qD moving an object of non-trivial type \"\n-\t\t\t       \"%#qT and size %E into a region of size %E\",\n-\t\t\t       fndecl, desttype, TYPE_SIZE_UNIT (desttype),\n-\t\t\t       args[1]);\n+\t  tree sz = maybe_constant_value ((*args)[1]);\n+\t  if (TREE_CODE (sz) == INTEGER_CST\n+\t      && tree_int_cst_lt (sz, TYPE_SIZE_UNIT (desttype)))\n+\t    /* Finally, warn on reallocation into insufficient space.  */\n+\t    warned = warning_at (loc, OPT_Wclass_memaccess,\n+\t\t\t\t \"%qD moving an object of non-trivial type \"\n+\t\t\t\t \"%#qT and size %E into a region of size %E\",\n+\t\t\t\t fndecl, desttype, TYPE_SIZE_UNIT (desttype),\n+\t\t\t\t sz);\n \t}\n       break;\n \n     default:\n       return;\n     }\n \n-  if (!warned && !warnfmt)\n-    return;\n-\n   if (warnfmt)\n     {\n       if (suggest)\n@@ -8643,10 +8651,6 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n       if (!check_builtin_function_arguments (EXPR_LOCATION (fn), vNULL, fndecl,\n \t\t\t\t\t     nargs, argarray))\n \treturn error_mark_node;\n-\n-      /* Warn if the built-in writes to an object of a non-trivial type.  */\n-      if (nargs)\n-\tmaybe_warn_class_memaccess (loc, fndecl, argarray);\n     }\n \n   if (VOID_TYPE_P (TREE_TYPE (fn)))"}, {"sha": "0bfacf0d0e608122232bea93787122a3ba557053", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e99ef40892b598eeb3fa496cc472e111675d7f6c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e99ef40892b598eeb3fa496cc472e111675d7f6c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e99ef40892b598eeb3fa496cc472e111675d7f6c", "patch": "@@ -1,3 +1,9 @@\n+2018-01-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/81327\n+\t* g++.dg/Wclass-memaccess-2.C: Don't expect a warning when explicitly\n+\tcast to void *.\n+\n 2018-01-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/81055"}, {"sha": "f138b8b357e1e9f448209c14feaa1e6f67d737ac", "filename": "gcc/testsuite/g++.dg/Wclass-memaccess-2.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e99ef40892b598eeb3fa496cc472e111675d7f6c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e99ef40892b598eeb3fa496cc472e111675d7f6c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWclass-memaccess-2.C?ref=e99ef40892b598eeb3fa496cc472e111675d7f6c", "patch": "@@ -53,9 +53,7 @@ void c_cast_uchar (NonTrivial *p)\n   __builtin_memset ((unsigned char*)p, 0, sizeof *p);\n }\n \n-// A cast to void* does not suppress the warning.  That is (or can be)\n-// considered a feature.\n void c_cast_void (NonTrivial *p)\n {\n-  __builtin_memset ((void*)p, 0, sizeof *p);   // { dg-warning \"\\\\\\[-Wclass-memaccess]\" }\n+  __builtin_memset ((void*)p, 0, sizeof *p);   // { dg-bogus \"\\\\\\[-Wclass-memaccess]\" }\n }"}]}