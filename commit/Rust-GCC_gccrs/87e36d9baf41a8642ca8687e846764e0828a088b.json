{"sha": "87e36d9baf41a8642ca8687e846764e0828a088b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlMzZkOWJhZjQxYTg2NDJjYTg2ODdlODQ2NzY0ZTA4MjhhMDg4Yg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-24T16:06:51Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-08-26T08:03:56Z"}, "message": "d: Fix no RVO when returning struct literals initialized with constructor.\n\nBackports a change from upstream dmd that moves front-end NRVO checking\nfrom ReturnStatement semantic to the end of FuncDeclaration semantic.\n\nIn the codegen, retStyle has been partially implemented so that only\nstructs and static arrays return RETstack.  This isn't accurate, but\ndon't need to be for the purposes of semantic analysis.\n\nIf a function either has TREE_ADDRESSABLE or must return in memory, then\nDECL_RESULT is set as the shidden field for the function.  This is used\nin the codegen pass for ReturnStatement where it is now detected whether\na function is returning a struct literal or a constructor function, then\nthe DECL_RESULT is used to directly construct the return value, instead\nof doing so via temporaries.\n\nReviewed-on: https://github.com/dlang/dmd/pull/11622\n\ngcc/d/ChangeLog:\n\n\tPR d/96156\n\t* d-frontend.cc (retStyle): Only return RETstack for struct and static\n\tarray types.\n\t* decl.cc (DeclVisitor::visit (FuncDeclaration *)): Use NRVO return\n\tfor all TREE_ADDRESSABLE types.  Set shidden to the RESULT_DECL.\n\t* expr.cc (ExprVisitor::visit (CallExp *)): Force TARGET_EXPR if the\n\t'this' pointer reference is a CONSTRUCTOR.\n\t(ExprVisitor::visit (StructLiteralExp *)): Generate assignment to the\n\tsymbol to initialize with literal.\n\t* toir.cc (IRVisitor::visit (ReturnStatement *)): Detect returning\n\tstruct literals and write directly into the RESULT_DECL.\n\t* dmd/MERGE: Merge upstream dmd fe5f388d8.\n\ngcc/testsuite/ChangeLog:\n\n\tPR d/96156\n\t* gdc.dg/pr96156.d: New test.", "tree": {"sha": "4f47a339a73c3f4f6adeba766237380e15558dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f47a339a73c3f4f6adeba766237380e15558dc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e36d9baf41a8642ca8687e846764e0828a088b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e36d9baf41a8642ca8687e846764e0828a088b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e36d9baf41a8642ca8687e846764e0828a088b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e36d9baf41a8642ca8687e846764e0828a088b/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e5d7c77218c0b5dd1a421a55234573e687e927", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e5d7c77218c0b5dd1a421a55234573e687e927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27e5d7c77218c0b5dd1a421a55234573e687e927"}], "stats": {"total": 241, "additions": 171, "deletions": 70}, "files": [{"sha": "da34e90227584fd4f54ae0a9fc4914110762e84a", "filename": "gcc/d/d-frontend.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fd-frontend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fd-frontend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-frontend.cc?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -143,12 +143,20 @@ Loc::equals (const Loc &loc)\n    hidden pointer to the caller's stack.  */\n \n RET\n-retStyle (TypeFunction *)\n+retStyle (TypeFunction *tf)\n {\n   /* Need the backend type to determine this, but this is called from the\n      frontend before semantic processing is finished.  An accurate value\n      is not currently needed anyway.  */\n-  return RETstack;\n+  if (tf->isref)\n+    return RETregs;\n+\n+  Type *tn = tf->next->toBasetype ();\n+\n+  if (tn->ty == Tstruct || tn->ty == Tsarray)\n+    return RETstack;\n+\n+  return RETregs;\n }\n \n /* Determine if function FD is a builtin one that we can evaluate in CTFE.  */"}, {"sha": "008a2bb16ab98215417502e219be30c49c7185cd", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -944,30 +944,24 @@ class DeclVisitor : public Visitor\n        Implemented by overriding all the RETURN_EXPRs and replacing all\n        occurrences of VAR with the RESULT_DECL for the function.\n        This is only worth doing for functions that can return in memory.  */\n-    if (d->nrvo_can)\n-      {\n-\ttree restype = TREE_TYPE (DECL_RESULT (fndecl));\n-\n-\tif (!AGGREGATE_TYPE_P (restype))\n-\t  d->nrvo_can = 0;\n-\telse\n-\t  d->nrvo_can = aggregate_value_p (restype, fndecl);\n-      }\n+    tree resdecl = DECL_RESULT (fndecl);\n \n-    if (d->nrvo_can)\n+    if (TREE_ADDRESSABLE (TREE_TYPE (resdecl))\n+\t|| aggregate_value_p (TREE_TYPE (resdecl), fndecl))\n       {\n-\ttree resdecl = DECL_RESULT (fndecl);\n-\n \t/* Return non-trivial structs by invisible reference.  */\n \tif (TREE_ADDRESSABLE (TREE_TYPE (resdecl)))\n \t  {\n \t    TREE_TYPE (resdecl) = build_reference_type (TREE_TYPE (resdecl));\n \t    DECL_BY_REFERENCE (resdecl) = 1;\n \t    TREE_ADDRESSABLE (resdecl) = 0;\n \t    relayout_decl (resdecl);\n+\t    d->shidden = build_deref (resdecl);\n \t  }\n+\telse\n+\t  d->shidden = resdecl;\n \n-\tif (d->nrvo_var)\n+\tif (d->nrvo_can && d->nrvo_var)\n \t  {\n \t    tree var = get_symbol_decl (d->nrvo_var);\n \n@@ -976,12 +970,9 @@ class DeclVisitor : public Visitor\n \t    /* Don't forget that we take its address.  */\n \t    TREE_ADDRESSABLE (var) = 1;\n \n-\t    if (DECL_BY_REFERENCE (resdecl))\n-\t      resdecl = build_deref (resdecl);\n-\n \t    SET_DECL_VALUE_EXPR (var, resdecl);\n \t    DECL_HAS_VALUE_EXPR_P (var) = 1;\n-\t    SET_DECL_LANG_NRVO (var, resdecl);\n+\t    SET_DECL_LANG_NRVO (var, d->shidden);\n \t  }\n       }\n "}, {"sha": "276406c76961cedb1424f285815d9f71aa770ab4", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -1,4 +1,4 @@\n-cb4a96faecb6b521ac4749581bcfa39f61143db0\n+fe5f388d8e5d97dccaa4ef1349f931c36a2cbc46\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "65ac3f75b2780b8d306e9dc6afc3fd527945eb72", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -669,6 +669,7 @@ class FuncDeclaration : public Declaration\n     static FuncDeclaration *genCfunc(Parameters *args, Type *treturn, const char *name, StorageClass stc=0);\n     static FuncDeclaration *genCfunc(Parameters *args, Type *treturn, Identifier *id, StorageClass stc=0);\n     void checkDmain();\n+    bool checkNrvo();\n \n     FuncDeclaration *isFuncDeclaration() { return this; }\n "}, {"sha": "f8e9601dbec875553523836bd67e159bb490443c", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -1704,9 +1704,6 @@ void FuncDeclaration::semantic3(Scope *sc)\n                 }\n             }\n \n-            if (!inferRetType && retStyle(f) != RETstack)\n-                nrvo_can = 0;\n-\n             bool inferRef = (f->isref && (storage_class & STCauto));\n \n             fbody = ::semantic(fbody, sc2);\n@@ -1761,7 +1758,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n                 if (storage_class & STCauto)\n                     storage_class &= ~STCauto;\n             }\n-            if (retStyle(f) != RETstack)\n+            if (retStyle(f) != RETstack || checkNrvo())\n                 nrvo_can = 0;\n \n             if (fbody->isErrorStatement())\n@@ -4293,6 +4290,53 @@ void FuncDeclaration::checkDmain()\n         error(\"parameters must be main() or main(string[] args)\");\n }\n \n+/***********************************************\n+ * Check all return statements for a function to verify that returning\n+ * using NRVO is possible.\n+ *\n+ * Returns:\n+ *      true if the result cannot be returned by hidden reference.\n+ */\n+bool FuncDeclaration::checkNrvo()\n+{\n+    if (!nrvo_can)\n+        return true;\n+\n+    if (returns == NULL)\n+        return true;\n+\n+    TypeFunction *tf = type->toTypeFunction();\n+    if (tf->isref)\n+        return true;\n+\n+    for (size_t i = 0; i < returns->length; i++)\n+    {\n+        ReturnStatement *rs = (*returns)[i];\n+\n+        if (VarExp *ve = rs->exp->isVarExp())\n+        {\n+            VarDeclaration *v = ve->var->isVarDeclaration();\n+            if (!v || v->isOut() || v->isRef())\n+                return true;\n+            else if (nrvo_var == NULL)\n+            {\n+                if (!v->isDataseg() && !v->isParameter() && v->toParent2() == this)\n+                {\n+                    //printf(\"Setting nrvo to %s\\n\", v->toChars());\n+                    nrvo_var = v;\n+                }\n+                else\n+                    return true;\n+            }\n+            else if (nrvo_var != v)\n+                return true;\n+        }\n+        else //if (!exp->isLvalue())    // keep NRVO-ability\n+            return true;\n+    }\n+    return false;\n+}\n+\n const char *FuncDeclaration::kind() const\n {\n     return generated ? \"generated function\" : \"function\";"}, {"sha": "90493475fffcd6069ee8aa11e37400f1413a34d8", "filename": "gcc/d/dmd/statementsem.c", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -2861,42 +2861,9 @@ class StatementSemanticVisitor : public Visitor\n                  *    return x; return 3;  // ok, x can be a value\n                  */\n             }\n-\n-            // handle NRVO\n-            if (fd->nrvo_can && rs->exp->op == TOKvar)\n-            {\n-                VarExp *ve = (VarExp *)rs->exp;\n-                VarDeclaration *v = ve->var->isVarDeclaration();\n-\n-                if (tf->isref)\n-                {\n-                    // Function returns a reference\n-                    if (!inferRef)\n-                        fd->nrvo_can = 0;\n-                }\n-                else if (!v || v->isOut() || v->isRef())\n-                    fd->nrvo_can = 0;\n-                else if (fd->nrvo_var == NULL)\n-                {\n-                    if (!v->isDataseg() && !v->isParameter() && v->toParent2() == fd)\n-                    {\n-                        //printf(\"Setting nrvo to %s\\n\", v->toChars());\n-                        fd->nrvo_var = v;\n-                    }\n-                    else\n-                        fd->nrvo_can = 0;\n-                }\n-                else if (fd->nrvo_var != v)\n-                    fd->nrvo_can = 0;\n-            }\n-            else //if (!exp->isLvalue())    // keep NRVO-ability\n-                fd->nrvo_can = 0;\n         }\n         else\n         {\n-            // handle NRVO\n-            fd->nrvo_can = 0;\n-\n             // infer return type\n             if (fd->inferRetType)\n             {"}, {"sha": "2b13615521dd0398548dac08786a27170578c60d", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -1782,6 +1782,9 @@ class ExprVisitor : public Visitor\n \t\t    thisexp = TREE_OPERAND (thisexp, 1);\n \t\t  }\n \n+\t\tif (TREE_CODE (thisexp) == CONSTRUCTOR)\n+\t\t  thisexp = force_target_expr (thisexp);\n+\n \t\t/* Want reference to `this' object.  */\n \t\tif (!POINTER_TYPE_P (TREE_TYPE (thisexp)))\n \t\t  thisexp = build_address (thisexp);\n@@ -2886,7 +2889,16 @@ class ExprVisitor : public Visitor\n        processing has complete.  Build the static initializer now.  */\n     if (e->useStaticInit && !this->constp_)\n       {\n-\tthis->result_ = aggregate_initializer_decl (e->sd);\n+\ttree init = aggregate_initializer_decl (e->sd);\n+\n+\t/* If initializing a symbol, don't forget to set it.  */\n+\tif (e->sym != NULL)\n+\t  {\n+\t    tree var = build_deref (e->sym);\n+\t    init = compound_expr (modify_expr (var, init), var);\n+\t  }\n+\n+\tthis->result_ = init;\n \treturn;\n       }\n "}, {"sha": "f9bc0958af33023589ccf9fe1a9e53f71378de52", "filename": "gcc/d/toir.cc", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Ftoir.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Fd%2Ftoir.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftoir.cc?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -1015,19 +1015,63 @@ class IRVisitor : public Visitor\n \t&& type->toBasetype ()->ty == Tvoid)\n       type = Type::tint32;\n \n-    if (this->func_->nrvo_can && this->func_->nrvo_var)\n+    if (this->func_->shidden)\n       {\n-\t/* Just refer to the DECL_RESULT; this differs from using\n-\t   NULL_TREE in that it indicates that we care about the value\n-\t   of the DECL_RESULT.  */\n+\t/* Returning by hidden reference, store the result into the retval decl.\n+\t   The result returned then becomes the retval reference itself.  */\n \ttree decl = DECL_RESULT (get_symbol_decl (this->func_));\n+\tgcc_assert (!tf->isref);\n+\n+\t/* If returning via NRVO, just refer to the DECL_RESULT; this differs\n+\t   from using NULL_TREE in that it indicates that we care about the\n+\t   value of the DECL_RESULT.  */\n+\tif (this->func_->nrvo_can && this->func_->nrvo_var)\n+\t  {\n+\t    add_stmt (return_expr (decl));\n+\t    return;\n+\t  }\n+\n+\t/* Detect a call to a constructor function, or if returning a struct\n+\t   literal, write result directly into the return value.  */\n+\tStructLiteralExp *sle = NULL;\n+\n+\tif (DotVarExp *dve = (s->exp->op == TOKcall\n+\t\t\t      && s->exp->isCallExp ()->e1->op == TOKdotvar\n+\t\t\t      ? s->exp->isCallExp ()->e1->isDotVarExp ()\n+\t\t\t      : NULL))\n+\t  {\n+\t    sle = (dve->var->isCtorDeclaration ()\n+\t\t   ? dve->e1->isStructLiteralExp () : NULL);\n+\t  }\n+\telse\n+\t  sle = s->exp->isStructLiteralExp ();\n+\n+\tif (sle != NULL)\n+\t  {\n+\t    StructDeclaration *sd = type->baseElemOf ()->isTypeStruct ()->sym;\n+\t    sle->sym = build_address (this->func_->shidden);\n+\n+\t    /* Fill any alignment holes in the return slot using memset.  */\n+\t    if (!identity_compare_p (sd) || sd->isUnionDeclaration ())\n+\t      add_stmt (build_memset_call (this->func_->shidden));\n+\n+\t    add_stmt (build_expr_dtor (s->exp));\n+\t  }\n+\telse\n+\t  {\n+\t    /* Generate: (<retval> = expr, return <retval>);  */\n+\t    tree expr = build_expr_dtor (s->exp);\n+\t    tree init = stabilize_expr (&expr);\n+\t    expr = build_assign (INIT_EXPR, this->func_->shidden, expr);\n+\t    add_stmt (compound_expr (init, expr));\n+\t  }\n+\n \tadd_stmt (return_expr (decl));\n       }\n     else\n       {\n \t/* Convert for initializing the DECL_RESULT.  */\n-\ttree expr = build_return_dtor (s->exp, type, tf);\n-\tadd_stmt (expr);\n+\tadd_stmt (build_return_dtor (s->exp, type, tf));\n       }\n   }\n "}, {"sha": "d9359b5bcff6d7168ebca061895d01ea85a5bdf5", "filename": "gcc/testsuite/gdc.dg/pr96156.d", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96156.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96156.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96156.d?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -0,0 +1,33 @@\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96156\n+// { dg-do run { target hw } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+\n+struct S96156\n+{\n+    __gshared void* ptr;\n+    int x;\n+\n+    this(int x) { ptr = &this; this.x = x; }\n+    @disable this(this);\n+}\n+\n+auto f96156()\n+{\n+    return g96156();\n+}\n+\n+auto g96156()\n+{\n+    return h96156();\n+}\n+\n+auto h96156()\n+{\n+    return S96156(100);\n+}\n+\n+void main()\n+{\n+    auto s = f96156();\n+    assert(&s == S96156.ptr);\n+}"}, {"sha": "ed58bcff9c8614d87cc00fbab9c56004b1fb314d", "filename": "gcc/testsuite/gdc.test/runnable/sdtor.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsdtor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsdtor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsdtor.d?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -1,4 +1,4 @@\n-// PERMUTE_ARGS: -unittest -O -release -inline -g\n+// PERMUTE_ARGS: -unittest -O -release -inline -fPIC -g\n \n import core.vararg;\n \n@@ -2827,6 +2827,7 @@ struct S17457 {\n     this(int seconds) {\n         dg17457 = &mfunc;\n     }\n+    @disable this(this);\n     void mfunc() {}\n }\n \n@@ -4612,7 +4613,7 @@ int main()\n     test9899();\n     test9907();\n     test9985();\n-    //test17457();    // XBUG: NRVO implementation differs\n+    test17457();\n     test9994();\n     test10094();\n     test10244();"}, {"sha": "f8b800f18bd1d861578b96b15f01c2467e759e4e", "filename": "gcc/testsuite/gdc.test/runnable/test8.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e36d9baf41a8642ca8687e846764e0828a088b/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d?ref=87e36d9baf41a8642ca8687e846764e0828a088b", "patch": "@@ -746,19 +746,19 @@ int foo42(const(char) *x, ...)\n     va_list ap;\n \n     va_start!(typeof(x))(ap, x);\n-    //printf(\"&x = %p, ap = %p\\n\", &x, ap);     // XBUG: static array va_lists (eg: x86_64) cannot be passed as vararg.\n+    assert(ap != va_list.init);\n \n     int i;\n     i = va_arg!(typeof(i))(ap);\n-    printf(\"i = %d\\n\", i);\n+    assert(i == 3);\n \n     long l;\n     l = va_arg!(typeof(l))(ap);\n-    printf(\"l = %lld\\n\", l);\n+    assert(l == 23);\n \n     uint k;\n     k = va_arg!(typeof(k))(ap);\n-    printf(\"k = %u\\n\", k);\n+    assert(k == 4);\n \n     va_end(ap);\n "}]}