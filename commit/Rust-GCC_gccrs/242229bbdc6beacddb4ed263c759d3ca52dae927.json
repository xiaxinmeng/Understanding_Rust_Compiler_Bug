{"sha": "242229bbdc6beacddb4ed263c759d3ca52dae927", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQyMjI5YmJkYzZiZWFjZGRiNGVkMjYzYzc1OWQzY2E1MmRhZTkyNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-06-19T15:33:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-06-19T15:33:06Z"}, "message": "CFG transparent RTL expansion:\n\n\t* Makefile.in (cfgexpand.o): New object file.\n\t(builtins.o): Add dependency on basic-block.h\n\t* builtins.c: Include basic-block.h\n\t(entry_of_function): New function.\n\t(expand_builtin_apply_args, expand_builtin_saveargs): Use it.\n\t* cfgexpand.c: New file.\n\t* expr.c (execute_expand, pass_expand): Kill.\n\t* pass.c (rest_of_compilation): Do not build CFG unless called from\n\tcoverage code.\n\t* tree-cfg.c (delete_tree_cfg): Rename to..\n\t(delete_tree_cfg_annotations): ... this one; Do not remove the CFG itself.\n\t* tree-flow.h (delete_tree_cfg_annotations): Declare.\n\t(dleete_tree_cfg): Kill.\n\t* tree-optimize.c (execute_rebuild_bind, pass_rebuild_bind): Kill.\n\t(execute_del_cfg): Rename to...\n\t(execute_free_datastructures): This one...\n\t(pass_del_cfg): Rename to...\n\t(pass_free_datastructures): ... this one; Do not kill PROP_cfg.\n\t(init_tree_optimization_passes): Make cfg build and profiling to happen\n\tunconditionally.\n\n\t* tree-mudflap.c (mf_decl_cache_locals): Skip labels before\n\tinserting the cache variables.\n\n\t* tree-mudflap.c: Include headers to make basic_block available.\n\tMove functions around such that related functions are near each\n\tother.  Add prototypes for all static functions.  Add comments\n\tbriefly explaining what IR the mudflap1 and mudflap2 work on and\n\twhat they do.\n\t(mudflap_function_decls): Rename to execute_mudflap_function_decls.\n\t(mudflap_function_ops): Rename to execute_mudflap_function_ops.\n\t(pass_mudflap_1, pass_mudflap_2): Update.\n\t(mf_decl_cache_locals): Make it work on the CFG instead of the saved\n\tfunction tree.\n\t(mf_build_check_statement_for): Make it work on the CFG.\n\t(mf_xform_derefs_1): Likewise.  Cleanup code style.\n\t(mf_xform_derefs): Likewise.\n\n\t* tree-cfg.c (label_to_block): Invent the label destination for\n\tundefined labels.\n\t(cleanup_dead_labels): Update table in the case label_to_block added\n\tnew label.\n\nFrom-SVN: r83385", "tree": {"sha": "2ee8a7629143f7f2514ddf9a48376c6ac3d11bc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ee8a7629143f7f2514ddf9a48376c6ac3d11bc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/242229bbdc6beacddb4ed263c759d3ca52dae927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/242229bbdc6beacddb4ed263c759d3ca52dae927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/242229bbdc6beacddb4ed263c759d3ca52dae927", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/242229bbdc6beacddb4ed263c759d3ca52dae927/comments", "author": null, "committer": null, "parents": [{"sha": "ff98621c682005e2a224f62c1aa5028353a5357e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff98621c682005e2a224f62c1aa5028353a5357e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff98621c682005e2a224f62c1aa5028353a5357e"}], "stats": {"total": 1556, "additions": 1066, "deletions": 490}, "files": [{"sha": "2b7258649b74899bfeb301e828bcd61157db6a98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -1,3 +1,54 @@\n+2004-06-19  Jan Hubicka  <jh@suse.cz>\n+\t    Steven Bosscher  <stevenb@suse.de>\n+\n+\tCFG transparent RTL expansion:\n+\t* Makefile.in (cfgexpand.o): New object file.\n+\t(builtins.o): Add dependency on basic-block.h\n+\t* builtins.c: Include basic-block.h\n+\t(entry_of_function): New function.\n+\t(expand_builtin_apply_args, expand_builtin_saveargs): Use it.\n+\t* cfgexpand.c: New file.\n+\t* expr.c (execute_expand, pass_expand): Kill.\n+\t* pass.c (rest_of_compilation): Do not build CFG unless called from\n+\tcoverage code.\n+\t* tree-cfg.c (delete_tree_cfg): Rename to..\n+\t(delete_tree_cfg_annotations): ... this one; Do not remove the CFG itself.\n+\t* tree-flow.h (delete_tree_cfg_annotations): Declare.\n+\t(dleete_tree_cfg): Kill.\n+\t* tree-optimize.c (execute_rebuild_bind, pass_rebuild_bind): Kill.\n+\t(execute_del_cfg): Rename to...\n+\t(execute_free_datastructures): This one...\n+\t(pass_del_cfg): Rename to...\n+\t(pass_free_datastructures): ... this one; Do not kill PROP_cfg.\n+\t(init_tree_optimization_passes): Make cfg build and profiling to happen\n+\tunconditionally.\n+\n+2004-06-19  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* tree-mudflap.c (mf_decl_cache_locals): Skip labels before\n+\tinserting the cache variables.\n+\n+\t* tree-mudflap.c: Include headers to make basic_block available.\n+\tMove functions around such that related functions are near each\n+\tother.  Add prototypes for all static functions.  Add comments\n+\tbriefly explaining what IR the mudflap1 and mudflap2 work on and\n+\twhat they do.\n+\t(mudflap_function_decls): Rename to execute_mudflap_function_decls.\n+\t(mudflap_function_ops): Rename to execute_mudflap_function_ops.\n+\t(pass_mudflap_1, pass_mudflap_2): Update.\n+\t(mf_decl_cache_locals): Make it work on the CFG instead of the saved\n+\tfunction tree.\n+\t(mf_build_check_statement_for): Make it work on the CFG.\n+\t(mf_xform_derefs_1): Likewise.  Cleanup code style.\n+\t(mf_xform_derefs): Likewise.\n+\n+2004-06-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-cfg.c (label_to_block): Invent the label destination for\n+\tundefined labels.\n+\t(cleanup_dead_labels): Update table in the case label_to_block added\n+\tnew label.\n+\n 2004-06-18  Richard Henderson  <rth@redhat.com>\n \n \tPR c++/16036 "}, {"sha": "75b36868bb8bd26ca354236f15fe7e3e37cbf7df", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -916,7 +916,7 @@ OBJS-common = \\\n  targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o\t   \\\n  varasm.o varray.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n- rtl-profile.o tree-profile.o rtlhooks.o\n+ rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -1793,7 +1793,7 @@ dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_\n builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H)\\\n    $(TREE_GIMPLE_H) $(FLAGS_H) $(TARGET_H) function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) \\\n    insn-config.h $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n-   except.h $(TM_P_H) $(PREDICT_H) libfuncs.h real.h langhooks.h\n+   except.h $(TM_P_H) $(PREDICT_H) libfuncs.h real.h langhooks.h basic-block.h\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) \\\n    $(EXPR_H) $(OPTABS_H) langhooks.h $(TARGET_H) \\\n    libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H) cgraph.h except.h\n@@ -1930,6 +1930,9 @@ cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) in\n    function.h except.h $(GGC_H) $(TM_P_H) alloc-pool.h $(TIMEVAR_H) \n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(BASIC_BLOCK_H) $(CFGLAYOUT_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h\n+cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n+   $(TREE_DUMP_H) except.h langhooks.h cfgloop.h gt-tree-cfg.h tree-pass.h $(RTL_H)\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) insn-config.h $(EXPR_H)"}, {"sha": "7ccddedf7e6ae53e7f87aab5b53c32e4cac21766", "filename": "gcc/builtins.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -45,6 +45,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n+#include \"basic-block.h\"\n \n #define CALLED_AS_BUILT_IN(NODE) \\\n    (!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), \"__builtin_\", 10))\n@@ -1206,6 +1207,13 @@ expand_builtin_apply_args_1 (void)\n   return copy_addr_to_reg (XEXP (registers, 0));\n }\n \n+/* Return RTX to emit after when we want to emit code on the entry of function.  */\n+static rtx\n+entry_of_function (void)\n+{\n+  return (n_basic_blocks ? BB_HEAD (ENTRY_BLOCK_PTR->next_bb) : get_insns ());\n+}\n+\n /* __builtin_apply_args returns block of memory allocated on\n    the stack into which is stored the arg pointer, structure\n    value address, static chain, and all the registers that might\n@@ -1239,7 +1247,7 @@ expand_builtin_apply_args (void)\n        chain current, so the code is placed at the start of the\n        function.  */\n     push_topmost_sequence ();\n-    emit_insn_before (seq, NEXT_INSN (get_insns ()));\n+    emit_insn_before (seq, NEXT_INSN (entry_of_function ()));\n     pop_topmost_sequence ();\n     return temp;\n   }\n@@ -4010,7 +4018,7 @@ expand_builtin_saveregs (void)\n      is inside a start_sequence, make the outer-level insn chain current, so\n      the code is placed at the start of the function.  */\n   push_topmost_sequence ();\n-  emit_insn_after (seq, get_insns ());\n+  emit_insn_after (seq, entry_of_function ());\n   pop_topmost_sequence ();\n \n   return val;"}, {"sha": "d9be28be17a957c53712ef422a6403d6f2b8794e", "filename": "gcc/cfgexpand.c", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -0,0 +1,480 @@\n+/* A pass for lowering trees to RTL.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"basic-block.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"langhooks.h\"\n+#include \"tree-flow.h\"\n+#include \"timevar.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-pass.h\"\n+#include \"except.h\"\n+#include \"flags.h\"\n+/* Expand basic block BB from GIMPLE trees to RTL.  */\n+\n+static basic_block\n+expand_block (basic_block bb, FILE * dump_file)\n+{\n+  block_stmt_iterator bsi = bsi_start (bb);\n+  tree stmt = NULL;\n+  rtx note, last;\n+  edge e;\n+\n+  if (dump_file)\n+    {\n+      tree_register_cfg_hooks ();\n+      dump_bb (bb, dump_file, 0);\n+      rtl_register_cfg_hooks ();\n+    }\n+\n+  if (!bsi_end_p (bsi))\n+    stmt = bsi_stmt (bsi);\n+\n+  if (stmt && TREE_CODE (stmt) == LABEL_EXPR)\n+    {\n+      last = get_last_insn ();\n+\n+      expand_expr_stmt_value (stmt, 0, 0);\n+\n+      /* Java emits line number notes in the top of labels. \n+         ??? Make this go away once line number notes are obsoleted.  */\n+      BB_HEAD (bb) = NEXT_INSN (last);\n+      if (GET_CODE (BB_HEAD (bb)) == NOTE)\n+\tBB_HEAD (bb) = NEXT_INSN (BB_HEAD (bb));\n+      bsi_next (&bsi);\n+      note = emit_note_after (NOTE_INSN_BASIC_BLOCK, BB_HEAD (bb));\n+    }\n+  else\n+    note = BB_HEAD (bb) = emit_note (NOTE_INSN_BASIC_BLOCK);\n+\n+  NOTE_BASIC_BLOCK (note) = bb;\n+\n+  e = bb->succ;\n+  while (e)\n+    {\n+      edge next = e->succ_next;\n+\n+      /* Clear EDGE_EXECUTABLE.  This flag is never used in the backend.  */\n+      e->flags &= ~EDGE_EXECUTABLE;\n+\n+      /* At the moment not all abnormal edges match the RTL representation.\n+         It is safe to remove them here as find_sub_basic_blocks will\n+         rediscover them.  In the future we should get this fixed properly.  */\n+      if (e->flags & EDGE_ABNORMAL)\n+\tremove_edge (e);\n+\n+      e = next;\n+    }\n+\n+  for (; !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+\n+      last = get_last_insn ();\n+\n+      if (!stmt)\n+\tcontinue;\n+\n+      /* Expand this statement, then evaluate the resulting RTL and\n+\t fixup the CFG accordingly.  */\n+      switch (TREE_CODE (stmt))\n+\t{\n+\tcase COND_EXPR:\n+\t  {\n+\t    basic_block new_bb, dest;\n+\t    edge new_edge;\n+\t    edge true_edge;\n+\t    edge false_edge;\n+\t    tree pred = COND_EXPR_COND (stmt);\n+\t    tree then_exp = COND_EXPR_THEN (stmt);\n+\t    tree else_exp = COND_EXPR_ELSE (stmt);\n+\t    rtx last = get_last_insn ();\n+\n+\t    extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n+\t    if (EXPR_LOCUS (stmt))\n+\t      {\n+\t\temit_line_note (*(EXPR_LOCUS (stmt)));\n+\t\tif (cfun->dont_emit_block_notes)\n+\t\t  record_block_change (TREE_BLOCK (stmt));\n+\t      }\n+\n+\t    /* These flags have no purpose in RTL land.  */\n+\t    true_edge->flags &= ~EDGE_TRUE_VALUE;\n+\t    false_edge->flags &= ~EDGE_FALSE_VALUE;\n+\n+\t    /* We can either have a pure conditional jump with one fallthru\n+\t       edge or two-way jump that needs to be decomposed into two\n+\t       basic blocks.  */\n+\t    if (TREE_CODE (then_exp) == GOTO_EXPR\n+\t\t&& TREE_CODE (else_exp) == NOP_EXPR)\n+\t      {\n+\t\tjumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n+\t\tbreak;\n+\t      }\n+\t    if (TREE_CODE (else_exp) == GOTO_EXPR\n+\t\t&& TREE_CODE (then_exp) == NOP_EXPR)\n+\t      {\n+\t\tjumpifnot (pred, label_rtx (GOTO_DESTINATION (else_exp)));\n+\t\tbreak;\n+\t      }\n+\t    if (TREE_CODE (then_exp) != GOTO_EXPR\n+\t\t|| TREE_CODE (else_exp) != GOTO_EXPR)\n+\t      abort ();\n+\n+\t    jumpif (pred, label_rtx (GOTO_DESTINATION (then_exp)));\n+\t    last = get_last_insn ();\n+\t    expand_expr (else_exp, const0_rtx, VOIDmode, 0);\n+\n+\t    BB_END (bb) = last;\n+\t    if (GET_CODE (BB_END (bb)) == BARRIER)\n+\t      BB_END (bb) = PREV_INSN (BB_END (bb));\n+\t    update_bb_for_insn (bb);\n+\n+\t    new_bb = create_basic_block (NEXT_INSN (last), get_last_insn (), bb);\n+\t    dest = false_edge->dest;\n+\t    redirect_edge_succ (false_edge, new_bb);\n+\t    false_edge->flags |= EDGE_FALLTHRU;\n+\t    new_bb->count = false_edge->count;\n+\t    new_bb->frequency = EDGE_FREQUENCY (false_edge);\n+\t    new_edge = make_edge (new_bb, dest, 0);\n+\t    new_edge->probability = REG_BR_PROB_BASE;\n+\t    new_edge->count = new_bb->count;\n+\t    if (GET_CODE (BB_END (new_bb)) == BARRIER)\n+\t      BB_END (new_bb) = PREV_INSN (BB_END (new_bb));\n+\t    update_bb_for_insn (new_bb);\n+\n+\t    if (dump_file)\n+\t      {\n+\t\tdump_bb (bb, dump_file, 0);\n+\t\tdump_bb (new_bb, dump_file, 0);\n+\t      }\n+\t    return new_bb;\n+\t  }\n+\n+\t/* Update after expansion of sibling call.  */\n+\tcase CALL_EXPR:\n+\tcase MODIFY_EXPR:\n+\tcase RETURN_EXPR:\n+          expand_expr_stmt_value (stmt, 0, 0);\n+\t  for (last = NEXT_INSN (last); last; last = NEXT_INSN (last))\n+\t    {\n+\t      if (GET_CODE (last) == CALL_INSN && SIBLING_CALL_P (last))\n+\t\t{\n+\t\t  edge e;\n+\t\t  int probability = 0;\n+\t\t  gcov_type count = 0;\n+\n+\t\t  do_pending_stack_adjust ();\n+\t\t  e = bb->succ;\n+\t\t  while (e)\n+\t\t    {\n+\t\t      edge next = e->succ_next;\n+\n+\t\t      if (!(e->flags & (EDGE_ABNORMAL | EDGE_EH)))\n+\t\t\t{\n+\t\t\t  if (e->dest != EXIT_BLOCK_PTR)\n+\t\t\t    {\n+\t\t\t      e->dest->count -= e->count;\n+\t\t\t      e->dest->frequency -= EDGE_FREQUENCY (e);\n+\t\t\t      if (e->dest->count < 0)\n+\t\t\t        e->dest->count = 0;\n+\t\t\t      if (e->dest->frequency < 0)\n+\t\t\t        e->dest->frequency = 0;\n+\t\t\t    }\n+\t\t\t  count += e->count;\n+\t\t\t  probability += e->probability;\n+\t\t\t  remove_edge (e);\n+\t\t\t}\n+\n+\t\t      e = next;\n+\t\t    }\n+\n+\t\t  /* This is somewhat ugly:  the call_expr expander often emits instructions\n+\t\t     after the sibcall (to perform the function return).  These confuse the \n+\t\t     find_sub_basic_blocks code, so we need to get rid of these.  */\n+\t\t  last = NEXT_INSN (last);\n+\t\t  if (GET_CODE (last) != BARRIER)\n+\t\t    abort ();\n+\t\t  while (NEXT_INSN (last))\n+\t\t    {\n+\t\t      /* For instance an sqrt builtin expander expands if with\n+\t\t\t sibcall in the then and label for `else`.  */\n+\t\t      if (GET_CODE (NEXT_INSN (last)) == CODE_LABEL)\n+\t\t\tbreak;\n+\t\t      delete_insn (NEXT_INSN (last));\n+\t\t    }\n+\t\t  e = make_edge (bb, EXIT_BLOCK_PTR,\n+\t\t\t\t     EDGE_ABNORMAL | EDGE_SIBCALL);\n+\t\t  e->probability += probability;\n+\t\t  e->count += count;\n+\t\t  BB_END (bb) = last;\n+\t\t  update_bb_for_insn (bb);\n+\t\t  if (NEXT_INSN (last))\n+\t\t    bb = create_basic_block (NEXT_INSN (last), get_last_insn (), bb);\n+\t\t  else\n+\t\t    return bb;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+          expand_expr_stmt_value (stmt, 0, 0);\n+\t  break;\n+\t}\n+    }\n+\n+  do_pending_stack_adjust ();\n+\n+  /* Find the the block tail.  The last insn is the block is the insn\n+     before a barrier and/or table jump insn.  */\n+  last = get_last_insn ();\n+  if (GET_CODE (last) == BARRIER)\n+    last = PREV_INSN (last);\n+  if (JUMP_TABLE_DATA_P (last))\n+    last = PREV_INSN (PREV_INSN (last));\n+  BB_END (bb) = last;\n+ \n+  if (dump_file)\n+    dump_bb (bb, dump_file, 0);\n+  update_bb_for_insn (bb);\n+  return bb;\n+}\n+\n+\n+/* Create a basic block for initialization code.  */\n+\n+static basic_block\n+construct_init_block (void)\n+{\n+  basic_block init_block, first_block;\n+  edge e;\n+\n+  expand_start_bindings_and_block (0, NULL_TREE);\n+\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    if (e->dest == ENTRY_BLOCK_PTR->next_bb)\n+      break;\n+\n+  init_block = create_basic_block (NEXT_INSN (get_insns ()),\n+\t\t\t\t   get_last_insn (),\n+\t\t\t\t   ENTRY_BLOCK_PTR);\n+  init_block->frequency = ENTRY_BLOCK_PTR->frequency;\n+  init_block->count = ENTRY_BLOCK_PTR->count;\n+  if (e)\n+    {\n+      first_block = e->dest;\n+      redirect_edge_succ (e, init_block);\n+      e = make_edge (init_block, first_block, EDGE_FALLTHRU);\n+    }\n+  else\n+    e = make_edge (init_block, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n+  e->probability = REG_BR_PROB_BASE;\n+  e->count = ENTRY_BLOCK_PTR->count;\n+\n+  update_bb_for_insn (init_block);\n+  return init_block;\n+}\n+\n+\n+/* Create a block containing landing pads and similar stuff.  */\n+\n+static void\n+construct_exit_block (void)\n+{\n+  rtx head = get_last_insn ();\n+  rtx end;\n+  basic_block exit_block;\n+  edge e, e2, next;\n+\n+  /* We hard-wired immediate_size_expand to zero above.\n+     expand_function_end will decrement this variable.  So, we set the\n+     variable to one here, so that after the decrement it will remain\n+     zero.  */\n+  immediate_size_expand = 1;\n+\n+  /* Make sure the locus is set to the end of the function, so that \n+     epilogue line numbers and warnings are set properly.  */\n+  if (cfun->function_end_locus.file)\n+    input_location = cfun->function_end_locus;\n+\n+  /* The following insns belong to the top scope.  */\n+  record_block_change (DECL_INITIAL (current_function_decl));\n+\n+  expand_end_bindings (NULL_TREE, 1, 0);\n+\n+  /* Generate rtl for function exit.  */\n+  expand_function_end ();\n+\n+  end = get_last_insn ();\n+  if (head == end)\n+    return;\n+  while (NEXT_INSN (head) && GET_CODE (NEXT_INSN (head)) == NOTE)\n+    head = NEXT_INSN (head);\n+  exit_block = create_basic_block (NEXT_INSN (head), end, EXIT_BLOCK_PTR->prev_bb);\n+  exit_block->frequency = EXIT_BLOCK_PTR->frequency;\n+  exit_block->count = EXIT_BLOCK_PTR->count;\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = next)\n+    {\n+      next = e->pred_next;\n+      if (!(e->flags & EDGE_ABNORMAL))\n+        redirect_edge_succ (e, exit_block);\n+    }\n+  e = make_edge (exit_block, EXIT_BLOCK_PTR, EDGE_FALLTHRU);\n+  e->probability = REG_BR_PROB_BASE;\n+  e->count = EXIT_BLOCK_PTR->count;\n+  for (e2 = EXIT_BLOCK_PTR->pred; e2; e2 = e2->pred_next)\n+    if (e2 != e)\n+      {\n+        e->count -= e2->count;\n+\texit_block->count -= e2->count;\n+\texit_block->frequency -= EDGE_FREQUENCY (e2);\n+      }\n+  if (e->count < 0)\n+    e->count = 0;\n+  if (exit_block->count < 0)\n+    exit_block->count = 0;\n+  if (exit_block->frequency < 0)\n+    exit_block->frequency = 0;\n+  update_bb_for_insn (exit_block);\n+}\n+\n+/* Called to move the SAVE_EXPRs for parameter declarations in a\n+   nested function into the nested function.  DATA is really the\n+   nested FUNCTION_DECL.  */\n+\n+static tree\n+set_save_expr_context (tree *tp,\n+                       int *walk_subtrees,\n+                       void *data)\n+{\n+  if (TREE_CODE (*tp) == SAVE_EXPR && !SAVE_EXPR_CONTEXT (*tp))\n+    SAVE_EXPR_CONTEXT (*tp) = (tree) data;\n+  /* Do not walk back into the SAVE_EXPR_CONTEXT; that will cause\n+     circularity.  */\n+  else if (DECL_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  return NULL;\n+}\n+\n+\n+/* Translate the intermediate representation contained in the CFG\n+   from GIMPLE trees to RTL.\n+\n+   We do conversion per basic block and preserve/update the tree CFG.\n+   This implies we have to do some magic as the CFG can simultaneously\n+   consist of basic blocks containing RTL and GIMPLE trees.  This can\n+   confuse the CFG hooks, so be curefull to not manipulate CFG during\n+   the expansion.  */\n+\n+static void\n+tree_expand_cfg (void)\n+{\n+  basic_block bb, init_block;\n+  sbitmap blocks;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n;; Function %s\",\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n+      fprintf (dump_file, \" (%s)\\n\",\n+\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl)));\n+    }\n+\n+  /* If the function has a variably modified type, there may be\n+     SAVE_EXPRs in the parameter types.  Their context must be set to\n+     refer to this function; they cannot be expanded in the containing\n+     function.  */\n+  if (decl_function_context (current_function_decl) == current_function_decl\n+      && variably_modified_type_p (TREE_TYPE (current_function_decl)))\n+    walk_tree (&TREE_TYPE (current_function_decl), set_save_expr_context,\n+\t       current_function_decl, NULL);\n+\n+  /* Expand the variables recorded during gimple lowering.  This must\n+     occur before the call to expand_function_start to ensure that\n+     all used variables are expanded before we expand anything on the\n+     PENDING_SIZES list.  */\n+  expand_used_vars ();\n+\n+  /* Set up parameters and prepare for return, for the function.  */\n+  expand_function_start (current_function_decl, 0);\n+\n+  /* If this function is `main', emit a call to `__main'\n+     to run global initializers, etc.  */\n+  if (DECL_NAME (current_function_decl)\n+      && MAIN_NAME_P (DECL_NAME (current_function_decl))\n+      && DECL_FILE_SCOPE_P (current_function_decl))\n+    expand_main_function ();\n+\n+  /* Write the flowgraph to a dot file.  */\n+  rtl_register_cfg_hooks ();\n+\n+  init_block = construct_init_block ();\n+\n+  FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR, next_bb)\n+    bb = expand_block (bb, dump_file);\n+\n+  construct_exit_block ();\n+\n+  /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n+     sorts of eh initialization.  Delay this until after the\n+     initial rtl dump so that we can see the original nesting.  */\n+  convert_from_eh_region_ranges ();\n+\n+  rebuild_jump_labels (get_insns ());\n+  find_exception_handler_labels ();\n+\n+  blocks = sbitmap_alloc (last_basic_block);\n+  sbitmap_ones (blocks);\n+  find_many_sub_basic_blocks (blocks);\n+  purge_all_dead_edges (0);\n+  sbitmap_free (blocks);\n+\n+  compact_blocks ();\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info();\n+#endif\n+}\n+\n+struct tree_opt_pass pass_expand =\n+{\n+  \"expand\",\t\t                /* name */\n+  NULL,                                 /* gate */\n+  tree_expand_cfg,\t                /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_EXPAND,\t\t                /* tv_id */\n+  /* ??? If TER is enabled, we actually receive GENERIC.  */\n+  PROP_gimple_leh | PROP_cfg,           /* properties_required */\n+  PROP_rtl,                             /* properties_provided */\n+  PROP_gimple_leh,\t\t\t/* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+};\n+"}, {"sha": "aad7b1cb5ae019bdfb404c79d04b4dfeab52213e", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -168,7 +168,6 @@ static void emit_single_push_insn (enum machine_mode, rtx, tree);\n #endif\n static void do_tablejump (rtx, enum machine_mode, rtx, rtx, rtx);\n static rtx const_vector_from_tree (tree);\n-static void execute_expand (void);\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -10213,92 +10212,4 @@ const_vector_from_tree (tree exp)\n \n   return gen_rtx_raw_CONST_VECTOR (mode, v);\n }\n-\f\n-/* Called to move the SAVE_EXPRs for parameter declarations in a\n-   nested function into the nested function.  DATA is really the\n-   nested FUNCTION_DECL.  */\n-\n-static tree\n-set_save_expr_context (tree *tp,\n-                       int *walk_subtrees,\n-                       void *data)\n-{\n-  if (TREE_CODE (*tp) == SAVE_EXPR && !SAVE_EXPR_CONTEXT (*tp))\n-    SAVE_EXPR_CONTEXT (*tp) = (tree) data;\n-  /* Do not walk back into the SAVE_EXPR_CONTEXT; that will cause\n-     circularity.  */\n-  else if (DECL_P (*tp))\n-    *walk_subtrees = 0;\n-\n-  return NULL;\n-}\n-\n-\n-static void\n-execute_expand (void)\n-{\n-  /* If the function has a variably modified type, there may be\n-     SAVE_EXPRs in the parameter types.  Their context must be set to\n-     refer to this function; they cannot be expanded in the containing\n-     function.  */\n-  if (decl_function_context (current_function_decl) == current_function_decl\n-      && variably_modified_type_p (TREE_TYPE (current_function_decl)))\n-    walk_tree (&TREE_TYPE (current_function_decl), set_save_expr_context,\n-\t       current_function_decl, NULL);\n-\n-  /* Expand the variables recorded during gimple lowering.  This must\n-     occur before the call to expand_function_start to ensure that\n-     all used variables are expanded before we expand anything on the\n-     PENDING_SIZES list.  */\n-  expand_used_vars ();\n-\n-  /* Set up parameters and prepare for return, for the function.  */\n-  expand_function_start (current_function_decl, 0);\n-\n-  /* If this function is `main', emit a call to `__main'\n-     to run global initializers, etc.  */\n-  if (DECL_NAME (current_function_decl)\n-      && MAIN_NAME_P (DECL_NAME (current_function_decl))\n-      && DECL_FILE_SCOPE_P (current_function_decl))\n-    expand_main_function ();\n-\n-  /* Generate the RTL for this function.  */\n-  expand_expr_stmt_value (DECL_SAVED_TREE (current_function_decl), 0, 0);\n-\n-  /* We hard-wired immediate_size_expand to zero above.\n-     expand_function_end will decrement this variable.  So, we set the\n-     variable to one here, so that after the decrement it will remain\n-     zero.  */\n-  immediate_size_expand = 1;\n-\n-  /* Make sure the locus is set to the end of the function, so that\n-     epilogue line numbers and warnings are set properly.  */\n-  if (cfun->function_end_locus.file)\n-    input_location = cfun->function_end_locus;\n-\n-  /* The following insns belong to the top scope.  */\n-  record_block_change (DECL_INITIAL (current_function_decl));\n-\n-  /* Generate rtl for function exit.  */\n-  expand_function_end ();\n-}\n-\n-struct tree_opt_pass pass_expand =\n-{\n-  \"expand\",\t\t                /* name */\n-  NULL,                                 /* gate */\n-  execute_expand,\t                /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_EXPAND,\t\t                /* tv_id */\n-  /* ??? If TER is enabled, we actually receive GENERIC.  */\n-  PROP_gimple_leh,                      /* properties_required */\n-  PROP_rtl,                             /* properties_provided */\n-  PROP_cfg | PROP_gimple_leh,           /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n-};\n-\n-\n #include \"gt-expr.h\""}, {"sha": "a4fb35a2611795ebebc9c63fbaf41c65e9a27f7f", "filename": "gcc/passes.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -1385,8 +1385,6 @@ rest_of_compilation (void)\n   else\n     finalize_block_changes ();\n \n-  init_flow ();\n-\n   /* Dump the rtl code if we are dumping rtl.  */\n   if (open_dump_file (DFI_rtl, current_function_decl))\n     close_dump_file (DFI_rtl, print_rtl, get_insns ());\n@@ -1443,11 +1441,21 @@ rest_of_compilation (void)\n \n   timevar_push (TV_JUMP);\n   open_dump_file (DFI_sibling, current_function_decl);\n-  rebuild_jump_labels (get_insns ());\n-  find_exception_handler_labels ();\n-  find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n \n+  /* ??? We may get called either via tree_rest_of_compilation when the CFG\n+     is already built or directly (for instance from coverage code).\n+     The direct callers shall be updated.  */\n+  if (!basic_block_info)\n+    {\n+      init_flow ();\n+      rebuild_jump_labels (get_insns ());\n+      find_exception_handler_labels ();\n+      find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n+    }\n   delete_unreachable_blocks ();\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info();\n+#endif\n \n   /* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */\n   if (flag_guess_branch_prob)\n@@ -1515,10 +1523,8 @@ rest_of_compilation (void)\n   if (flag_guess_branch_prob)\n     expected_value_to_br_prob ();\n \n-  reg_scan (get_insns (), max_reg_num (), 0);\n-  rebuild_jump_labels (get_insns ());\n-  find_basic_blocks (get_insns (), max_reg_num (), dump_file);\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+  reg_scan (get_insns(), max_reg_num (), 0);\n   if (dump_file)\n     dump_flow_info (dump_file);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP"}, {"sha": "4b571630b3bbfc8e5c409e8b084ffe32eab3c3d8", "filename": "gcc/predict.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -116,3 +116,6 @@ DEF_PREDICTOR (PRED_NEGATIVE_RETURN, \"negative return\", HITRATE (96), 0)\n \n /* Branch ending with return; is probably not taken */\n DEF_PREDICTOR (PRED_NULL_RETURN, \"null return\", HITRATE (90), 0)\n+\n+/* Branches to a mudflap bounds check are extremely unlikely.  */\n+DEF_PREDICTOR (PRED_MUDFLAP, \"mudflap check\", HITRATE (99), 0)"}, {"sha": "243a654171b4c26ceae54cd2c01a6075db3e7d59", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -619,7 +619,21 @@ make_switch_expr_edges (basic_block bb)\n basic_block\n label_to_block (tree dest)\n {\n-  return VARRAY_BB (label_to_block_map, LABEL_DECL_UID (dest));\n+  int uid = LABEL_DECL_UID (dest);\n+\n+  /* We would die hard when faced by undefined label.  Emit label to\n+     very first basic block.  This will hopefully make even the dataflow\n+     and undefined variable warnings quite right.  */\n+  if ((errorcount || sorrycount) && uid < 0)\n+    {\n+      block_stmt_iterator bsi = bsi_start (BASIC_BLOCK (0));\n+      tree stmt;\n+\n+      stmt = build1 (LABEL_EXPR, void_type_node, dest);\n+      bsi_insert_before (&bsi, stmt, BSI_NEW_STMT);\n+      uid = LABEL_DECL_UID (dest);\n+    }\n+  return VARRAY_BB (label_to_block_map, uid);\n }\n \n \n@@ -756,6 +770,18 @@ update_eh_label (struct eh_region *region)\n     }\n }\n \n+/* Given LABEL return the first label in the same basic block.  */\n+static tree\n+main_block_label (tree label)\n+{\n+  basic_block bb = label_to_block (label);\n+\n+  /* label_to_block possibly inserted undefined label into the chain.  */\n+  if (!label_for_bb[bb->index])\n+    label_for_bb[bb->index] = label;\n+  return label_for_bb[bb->index];\n+}\n+\n /* Cleanup redundant labels.  This is a three-steo process:\n      1) Find the leading label for each block.\n      2) Redirect all references to labels to the leading labels.\n@@ -815,15 +841,14 @@ cleanup_dead_labels (void)\n \tcase COND_EXPR:\n \t  {\n \t    tree true_branch, false_branch;\n-\t    basic_block true_bb, false_bb;\n \n \t    true_branch = COND_EXPR_THEN (stmt);\n \t    false_branch = COND_EXPR_ELSE (stmt);\n-\t    true_bb = label_to_block (GOTO_DESTINATION (true_branch));\n-\t    false_bb = label_to_block (GOTO_DESTINATION (false_branch));\n \n-\t    GOTO_DESTINATION (true_branch) = label_for_bb[true_bb->index];\n-\t    GOTO_DESTINATION (false_branch) = label_for_bb[false_bb->index];\n+\t    GOTO_DESTINATION (true_branch)\n+\t      = main_block_label (GOTO_DESTINATION (true_branch));\n+\t    GOTO_DESTINATION (false_branch)\n+\t      = main_block_label (GOTO_DESTINATION (false_branch));\n \n \t    break;\n \t  }\n@@ -836,26 +861,21 @@ cleanup_dead_labels (void)\n   \n \t    /* Replace all destination labels.  */\n \t    for (i = 0; i < n; ++i)\n-\t      {\n-\t\ttree label = CASE_LABEL (TREE_VEC_ELT (vec, i));\n-\n-\t\tCASE_LABEL (TREE_VEC_ELT (vec, i)) =\n-\t\t  label_for_bb[label_to_block (label)->index];\n-\t      }\n+\t      CASE_LABEL (TREE_VEC_ELT (vec, i))\n+\t\t= main_block_label (CASE_LABEL (TREE_VEC_ELT (vec, i)));\n   \n \t    break;\n \t  }\n \n \t/* We have to handle GOTO_EXPRs until they're removed, and we don't\n \t   remove them until after we've created the CFG edges.  */\n \tcase GOTO_EXPR:\n-\t  {\n-\t    tree label = GOTO_DESTINATION (stmt);\n-\t    if (! computed_goto_p (stmt))\n-\t      GOTO_DESTINATION (stmt) =\n-\t\tlabel_for_bb[label_to_block (label)->index];\n-\t    break;\n-\t  }\n+          if (! computed_goto_p (stmt))\n+\t    {\n+\t      GOTO_DESTINATION (stmt)\n+\t\t= main_block_label (GOTO_DESTINATION (stmt));\n+\t      break;\n+\t    }\n \n \tdefault:\n \t  break;\n@@ -2636,19 +2656,19 @@ disband_implicit_edges (void)\n     }\n }\n \n-\n-/* Remove all the blocks and edges that make up the flowgraph.  */\n+/* Remove block annotations and other datastructures.  */\n \n void\n-delete_tree_cfg (void)\n+delete_tree_cfg_annotations (void)\n {\n+  basic_block bb;\n   if (n_basic_blocks > 0)\n     free_blocks_annotations ();\n \n-  free_basic_block_vars ();\n-  basic_block_info = NULL;\n   label_to_block_map = NULL;\n   free_rbi_pool ();\n+  FOR_EACH_BB (bb)\n+    bb->rbi = NULL;\n }\n \n "}, {"sha": "6ddf72c2cfc12057a373cc4589a164e415da4a84", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -434,7 +434,7 @@ extern void bsi_replace (const block_stmt_iterator *, tree, bool);\n /* Location to track pending stmt for edge insertion.  */\n #define PENDING_STMT(e)\t((e)->insns.t)\n \n-extern void delete_tree_cfg (void);\n+extern void delete_tree_cfg_annotations (void);\n extern void disband_implicit_edges (void);\n extern bool stmt_ends_bb_p (tree);\n extern bool is_ctrl_stmt (tree);\n@@ -582,6 +582,9 @@ void set_value_handle (tree, tree);\n void debug_value_expressions (tree);\n void print_value_expressions (FILE *, tree);\n \n+/* In tree-sra.c  */\n+void insert_edge_copies (tree stmt, basic_block bb);\n+\n #include \"tree-flow-inline.h\"\n \n #endif /* _TREE_FLOW_H  */"}, {"sha": "732ef5e4106ba7a89182cd4d7f4e957bc42c3538", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 445, "deletions": 320, "changes": 765, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -26,7 +26,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"hard-reg-set.h\"\n+#include \"rtl.h\"\n #include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"basic-block.h\"\n #include \"flags.h\"\n #include \"function.h\"\n #include \"tree-inline.h\"\n@@ -43,50 +47,31 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Internal function decls */\n \n-static void mf_xform_derefs (tree);\n-static void mf_xform_decls (tree, tree);\n-static void mf_init_extern_trees (void);\n-static void mf_decl_cache_locals (tree *);\n-static void mf_decl_clear_locals (void);\n+/* Helpers.  */\n+static tree mf_build_string (const char *string);\n static tree mf_varname_tree (tree);\n-static tree mx_xfn_xform_decls (tree *, int *, void *);\n-\n-static void mx_register_decls (tree, tree *);\n-\n-\n-/* extern mudflap functions */\n-\n-static GTY ((param_is (union tree_node))) htab_t marked_trees = NULL;\n-\n-\n-/* Mark and return the given tree node to prevent further mudflap\n-   transforms.  */\n-tree\n-mf_mark (tree t)\n-{\n-  void **slot;\n-\n-  if (marked_trees == NULL)\n-    marked_trees = htab_create_ggc (31, htab_hash_pointer, htab_eq_pointer, NULL);\n+static tree mf_file_function_line_tree (location_t *);\n \n-  slot = htab_find_slot (marked_trees, t, INSERT);\n-  *slot = t;\n-  return t;\n-}\n+/* Initialization of all the mf-runtime.h extern decls.  */\n+static void mf_init_extern_trees (void);\n \n+/* Indirection-related instrumentation.  */\n+static void mf_decl_cache_locals (void);\n+static void mf_decl_clear_locals (void);\n+static void mf_xform_derefs (void);\n+static void execute_mudflap_function_ops (void);\n \n-int\n-mf_marked_p (tree t)\n-{\n-  void *entry;\n+/* Addressable variables instrumentation.  */\n+static void mf_xform_decls (tree, tree);\n+static tree mx_xfn_xform_decls (tree *, int *, void *);\n+static void mx_register_decls (tree, tree *);\n+static void execute_mudflap_function_decls (void);\n \n-  if (marked_trees == NULL)\n-    return 0;\n \n-  entry = htab_find (marked_trees, t);\n-  return (entry != NULL);\n-}\n+/* ------------------------------------------------------------------------ */\n+/* Some generally helpful functions for mudflap instrumentation.  */\n \n+/* Build a reference to a literal string.  */\n static tree\n mf_build_string (const char *string)\n {\n@@ -106,192 +91,6 @@ mf_build_string (const char *string)\n   return mf_mark (result);\n }\n \n-/* Perform the declaration-related mudflap tree transforms on the\n-   given function.  Update its DECL_SAVED_TREE.  */\n-\n-static void\n-mudflap_function_decls (void)\n-{\n-  if (mf_marked_p (current_function_decl))\n-    return;\n-\n-  push_gimplify_context ();\n-\n-  mf_init_extern_trees ();\n-  mf_xform_decls (DECL_SAVED_TREE (current_function_decl),\n-                  DECL_ARGUMENTS (current_function_decl));\n-\n-  pop_gimplify_context (NULL);\n-}\n-\n-static bool\n-gate_mudflap (void)\n-{\n-  return flag_mudflap != 0;\n-}\n-\n-struct tree_opt_pass pass_mudflap_1 = \n-{\n-  \"mudflap1\",                           /* name */\n-  gate_mudflap,                         /* gate */\n-  mudflap_function_decls,               /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  0,                                    /* tv_id */\n-  PROP_gimple_any,                      /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func                        /* todo_flags_finish */\n-};\n-\n-\n-/* Same as above, for the indirection-related transforms.  */\n-\n-static void\n-mudflap_function_ops (void)\n-{\n-  if (mf_marked_p (current_function_decl))\n-    return;\n-\n-  push_gimplify_context ();\n-\n-  /* In multithreaded mode, don't cache the lookup cache parameters.  */\n-  if (! flag_mudflap_threads)\n-    mf_decl_cache_locals (&DECL_SAVED_TREE (current_function_decl));\n-\n-  mf_xform_derefs (DECL_SAVED_TREE (current_function_decl));\n-\n-  if (! flag_mudflap_threads)\n-    mf_decl_clear_locals ();\n-\n-  pop_gimplify_context (NULL);\n-}\n-\n-struct tree_opt_pass pass_mudflap_2 = \n-{\n-  \"mudflap2\",                           /* name */\n-  gate_mudflap,                         /* gate */\n-  mudflap_function_ops,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  0,                                    /* tv_id */\n-  PROP_gimple_leh,                      /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func                        /* todo_flags_finish */\n-};\n-\n-/* global tree nodes */\n-\n-/* Global tree objects for global variables and functions exported by\n-   mudflap runtime library.  mf_init_extern_trees must be called\n-   before using these.  */\n-\n-/* uintptr_t (usually \"unsigned long\") */\n-static GTY (()) tree mf_uintptr_type;\n-\n-/* struct __mf_cache { uintptr_t low; uintptr_t high; }; */\n-static GTY (()) tree mf_cache_struct_type;\n-\n-/* struct __mf_cache * const */\n-static GTY (()) tree mf_cache_structptr_type;\n-\n-/* extern struct __mf_cache __mf_lookup_cache []; */\n-static GTY (()) tree mf_cache_array_decl;\n-\n-/* extern const unsigned char __mf_lc_shift; */\n-static GTY (()) tree mf_cache_shift_decl;\n-\n-/* extern const uintptr_t __mf_lc_mask; */\n-static GTY (()) tree mf_cache_mask_decl;\n-\n-/* Their function-scope local shadows, used in single-threaded mode only.  */\n-\n-/* auto const unsigned char __mf_lc_shift_l; */\n-static GTY (()) tree mf_cache_shift_decl_l;\n-\n-/* auto const uintptr_t __mf_lc_mask_l; */\n-static GTY (()) tree mf_cache_mask_decl_l;\n-\n-/* extern void __mf_check (void *ptr, size_t sz, int type, const char *); */\n-static GTY (()) tree mf_check_fndecl;\n-\n-/* extern void __mf_register (void *ptr, size_t sz, int type, const char *); */\n-static GTY (()) tree mf_register_fndecl;\n-\n-/* extern void __mf_unregister (void *ptr, size_t sz); */\n-static GTY (()) tree mf_unregister_fndecl;\n-\n-\n-/* Initialize the global tree nodes that correspond to mf-runtime.h\n-   declarations.  */\n-static void\n-mf_init_extern_trees (void)\n-{\n-  static bool done = false;\n-\n-  if (done)\n-    return;\n-  done = true;\n-\n-  mf_uintptr_type = TREE_TYPE (mflang_lookup_decl (\"uintptr_t\"));\n-  mf_cache_array_decl = mf_mark (mflang_lookup_decl (\"__mf_lookup_cache\"));\n-  mf_cache_struct_type = TREE_TYPE (TREE_TYPE (mf_cache_array_decl));\n-  mf_cache_structptr_type = build_pointer_type (mf_cache_struct_type);\n-  mf_cache_shift_decl = mf_mark (mflang_lookup_decl (\"__mf_lc_shift\"));\n-  mf_cache_mask_decl = mf_mark (mflang_lookup_decl (\"__mf_lc_mask\"));\n-  mf_check_fndecl = mflang_lookup_decl (\"__mf_check\");\n-  mf_register_fndecl = mflang_lookup_decl (\"__mf_register\");\n-  mf_unregister_fndecl = mflang_lookup_decl (\"__mf_unregister\");\n-}\n-\n-\n-\n-/* Create and initialize local shadow variables for the lookup cache\n-   globals.  Put their decls in the *_l globals for use by\n-   mf_build_check_statement_for.  */\n-\n-static void\n-mf_decl_cache_locals (tree* body)\n-{\n-  tree_stmt_iterator i = tsi_start (*body);\n-  tree t;\n-\n-  mf_cache_shift_decl_l\n-    = mf_mark (create_tmp_var (TREE_TYPE (mf_cache_shift_decl),\n-                               \"__mf_lookup_shift_l\"));\n-\n-  mf_cache_mask_decl_l\n-    = mf_mark (create_tmp_var (TREE_TYPE (mf_cache_mask_decl),\n-                               \"__mf_lookup_mask_l\"));\n-\n-  /* Build initialization nodes for them.  */\n-  t = build (MODIFY_EXPR, TREE_TYPE (mf_cache_shift_decl_l),\n-             mf_cache_shift_decl_l, mf_cache_shift_decl);\n-  annotate_with_locus (t, DECL_SOURCE_LOCATION (current_function_decl));\n-  gimplify_stmt (&t);\n-  tsi_link_before (&i, t, TSI_NEW_STMT);\n-\n-  t = build (MODIFY_EXPR, TREE_TYPE (mf_cache_mask_decl_l),\n-             mf_cache_mask_decl_l, mf_cache_mask_decl);\n-  annotate_with_locus (t, DECL_SOURCE_LOCATION (current_function_decl));\n-  gimplify_stmt (&t);\n-  tsi_link_before (&i, t, TSI_NEW_STMT);\n-}\n-\n-\n-static void\n-mf_decl_clear_locals (void)\n-{\n-  /* Unset local shadows.  */\n-  mf_cache_shift_decl_l = NULL_TREE;\n-  mf_cache_mask_decl_l = NULL_TREE;\n-}\n-\n /* Create a properly typed STRING_CST node that describes the given\n    declaration.  It will be used as an argument for __mf_register().\n    Try to construct a helpful string, including file/function/variable\n@@ -432,35 +231,229 @@ mf_file_function_line_tree (location_t *locus)\n }\n \n \n+/* global tree nodes */\n+\n+/* Global tree objects for global variables and functions exported by\n+   mudflap runtime library.  mf_init_extern_trees must be called\n+   before using these.  */\n+\n+/* uintptr_t (usually \"unsigned long\") */\n+static GTY (()) tree mf_uintptr_type;\n+\n+/* struct __mf_cache { uintptr_t low; uintptr_t high; }; */\n+static GTY (()) tree mf_cache_struct_type;\n+\n+/* struct __mf_cache * const */\n+static GTY (()) tree mf_cache_structptr_type;\n+\n+/* extern struct __mf_cache __mf_lookup_cache []; */\n+static GTY (()) tree mf_cache_array_decl;\n+\n+/* extern const unsigned char __mf_lc_shift; */\n+static GTY (()) tree mf_cache_shift_decl;\n+\n+/* extern const uintptr_t __mf_lc_mask; */\n+static GTY (()) tree mf_cache_mask_decl;\n+\n+/* Their function-scope local shadows, used in single-threaded mode only. */\n+\n+/* auto const unsigned char __mf_lc_shift_l; */\n+static GTY (()) tree mf_cache_shift_decl_l;\n+\n+/* auto const uintptr_t __mf_lc_mask_l; */\n+static GTY (()) tree mf_cache_mask_decl_l;\n+\n+/* extern void __mf_check (void *ptr, size_t sz, int type, const char *); */\n+static GTY (()) tree mf_check_fndecl;\n+\n+/* extern void __mf_register (void *ptr, size_t sz, int type, const char *); */\n+static GTY (()) tree mf_register_fndecl;\n+\n+/* extern void __mf_unregister (void *ptr, size_t sz); */\n+static GTY (()) tree mf_unregister_fndecl;\n+\n+\n+/* Initialize the global tree nodes that correspond to mf-runtime.h\n+   declarations.  */\n+static void\n+mf_init_extern_trees (void)\n+{\n+  static bool done = false;\n+\n+  if (done)\n+    return;\n+  done = true;\n+\n+  mf_uintptr_type = TREE_TYPE (mflang_lookup_decl (\"uintptr_t\"));\n+  mf_cache_array_decl = mf_mark (mflang_lookup_decl (\"__mf_lookup_cache\"));\n+  mf_cache_struct_type = TREE_TYPE (TREE_TYPE (mf_cache_array_decl));\n+  mf_cache_structptr_type = build_pointer_type (mf_cache_struct_type);\n+  mf_cache_shift_decl = mf_mark (mflang_lookup_decl (\"__mf_lc_shift\"));\n+  mf_cache_mask_decl = mf_mark (mflang_lookup_decl (\"__mf_lc_mask\"));\n+  mf_check_fndecl = mflang_lookup_decl (\"__mf_check\");\n+  mf_register_fndecl = mflang_lookup_decl (\"__mf_register\");\n+  mf_unregister_fndecl = mflang_lookup_decl (\"__mf_unregister\");\n+}\n+\n+\n+/* ------------------------------------------------------------------------ */\n+/* Memory reference transforms. Perform the mudflap indirection-related\n+   tree transforms on the current function.\n+\n+   This is the second part of the mudflap instrumentation.  It works on\n+   low-level GIMPLE using the CFG, because we want to run this pass after\n+   tree optimizations have been performed, but we have to preserve the CFG\n+   for expansion from trees to RTL.  */\n+\n+static void\n+execute_mudflap_function_ops (void)\n+{\n+  if (mf_marked_p (current_function_decl))\n+    return;\n+\n+  push_gimplify_context ();\n+\n+  /* In multithreaded mode, don't cache the lookup cache parameters.  */\n+  if (! flag_mudflap_threads)\n+    mf_decl_cache_locals ();\n+\n+  mf_xform_derefs ();\n+\n+  if (! flag_mudflap_threads)\n+    mf_decl_clear_locals ();\n+\n+  pop_gimplify_context (NULL);\n+}\n+\n+/* Create and initialize local shadow variables for the lookup cache\n+   globals.  Put their decls in the *_l globals for use by\n+   mf_build_check_statement_for. */\n+\n+static void\n+mf_decl_cache_locals (void)\n+{\n+  tree t, shift_init_stmts, mask_init_stmts;\n+  tree_stmt_iterator tsi;\n+\n+  /* Build the cache vars.  */\n+  mf_cache_shift_decl_l\n+    = mf_mark (create_tmp_var (TREE_TYPE (mf_cache_shift_decl),\n+                               \"__mf_lookup_shift_l\"));\n+\n+  mf_cache_mask_decl_l\n+    = mf_mark (create_tmp_var (TREE_TYPE (mf_cache_mask_decl),\n+                               \"__mf_lookup_mask_l\"));\n+\n+  /* Build initialization nodes for the cache vars.  We just load the\n+     globals into the cache variables.  */\n+  t = build (MODIFY_EXPR, TREE_TYPE (mf_cache_shift_decl_l),\n+             mf_cache_shift_decl_l, mf_cache_shift_decl);\n+  annotate_with_locus (t, DECL_SOURCE_LOCATION (current_function_decl));\n+  gimplify_to_stmt_list (&t);\n+  shift_init_stmts = t;\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (mf_cache_mask_decl_l),\n+             mf_cache_mask_decl_l, mf_cache_mask_decl);\n+  annotate_with_locus (t, DECL_SOURCE_LOCATION (current_function_decl));\n+  gimplify_to_stmt_list (&t);\n+  mask_init_stmts = t;\n+\n+  /* Anticipating multiple entry points, we insert the cache vars\n+     initializers in each successor of the ENTRY_BLOCK_PTR.  */\n+  for (tsi = tsi_start (shift_init_stmts);\n+       ! tsi_end_p (tsi);\n+       tsi_next (&tsi))\n+    insert_edge_copies (tsi_stmt (tsi), ENTRY_BLOCK_PTR);\n+\n+  for (tsi = tsi_start (mask_init_stmts);\n+       ! tsi_end_p (tsi);\n+       tsi_next (&tsi))\n+    insert_edge_copies (tsi_stmt (tsi), ENTRY_BLOCK_PTR);\n+  bsi_commit_edge_inserts (NULL);\n+}\n+\n+\n static void\n-mf_build_check_statement_for (tree addr, tree size, tree_stmt_iterator *iter,\n+mf_decl_clear_locals (void)\n+{\n+  /* Unset local shadows. */\n+  mf_cache_shift_decl_l = NULL_TREE;\n+  mf_cache_mask_decl_l = NULL_TREE;\n+}\n+\n+static void\n+mf_build_check_statement_for (tree addr, tree size,\n+\t\t\t      block_stmt_iterator *instr_bsi,\n                               location_t *locus, tree dirflag)\n {\n+  tree_stmt_iterator head, tsi;\n   tree ptrtype = TREE_TYPE (addr);\n-  tree stmt, cond, t, u, v;\n+  block_stmt_iterator bsi;\n+  basic_block cond_bb, then_bb, join_bb;\n+  edge e;\n+  tree cond, t, u, v, l1, l2;\n   tree mf_value;\n   tree mf_base;\n   tree mf_elem;\n \n+  /* We first need to split the current basic block, and start altering\n+     the CFG.  This allows us to insert the statements we're about to\n+     construct into the right basic blocks.  The label l1 is the label\n+     of the block for the THEN clause of the conditional jump we're\n+     about to construct, and l2 is the ELSE clause, which is just the\n+     continuation of the old statement stream.  */\n+  l1 = create_artificial_label ();\n+  l2 = create_artificial_label ();\n+  cond_bb = bb_for_stmt (bsi_stmt (*instr_bsi));\n+  bsi = *instr_bsi;\n+  bsi_prev (&bsi);\n+  if (! bsi_end_p (bsi))\n+    {\n+      e = split_block (cond_bb, bsi_stmt (bsi));\n+      cond_bb = e->src;\n+      join_bb = e->dest;\n+    }\n+  else\n+    {\n+      join_bb = cond_bb;\n+      cond_bb = create_empty_bb (join_bb->prev_bb);\n+      e = make_edge (cond_bb, join_bb, 0);\n+    }\n+  e->flags = EDGE_FALSE_VALUE;\n+  then_bb = create_empty_bb (cond_bb);\n+  make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n+  make_edge (then_bb, join_bb, EDGE_FALLTHRU);\n+\n+  /* We expect that the conditional jump we will construct will not\n+     be taken very often as it basically is an exception condition.  */\n+  predict_edge_def (then_bb->pred, PRED_MUDFLAP, NOT_TAKEN);\n+\n+  /* Update dominance info.  Note that bb_join's data was\n+     updated by split_block.  */\n+  if (dom_computed[CDI_DOMINATORS] >= DOM_CONS_OK)\n+    {\n+      set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);\n+    }\n+\n   /* Build our local variables.  */\n   mf_value = create_tmp_var (ptrtype, \"__mf_value\");\n   mf_elem = create_tmp_var (mf_cache_structptr_type, \"__mf_elem\");\n   mf_base = create_tmp_var (mf_uintptr_type, \"__mf_base\");\n \n   /* Build: __mf_value = <address expression>.  */\n-  stmt = build (MODIFY_EXPR, void_type_node, mf_value, addr);\n-  if (locus != NULL) \n-    annotate_with_locus (stmt, *locus);\n-  gimplify_stmt (&stmt);\n-  tsi_link_before (iter, stmt, TSI_SAME_STMT);\n+  t = build (MODIFY_EXPR, void_type_node, mf_value, unshare_expr (addr));\n+  SET_EXPR_LOCUS (t, locus);\n+  gimplify_to_stmt_list (&t);\n+  head = tsi_start (t);\n+  tsi = tsi_last (t);\n \n   /* Build: __mf_base = (uintptr_t)__mf_value.  */\n-  stmt = build (MODIFY_EXPR, void_type_node, mf_base,\n-                build1 (NOP_EXPR, mf_uintptr_type, mf_value));\n-  if (locus != NULL) \n-    annotate_with_locus (stmt, *locus);\n-  gimplify_stmt (&stmt);\n-  tsi_link_before (iter, stmt, TSI_SAME_STMT);\n+  t = build (MODIFY_EXPR, void_type_node, mf_base,\n+             build1 (NOP_EXPR, mf_uintptr_type, mf_value));\n+  SET_EXPR_LOCUS (t, locus);\n+  gimplify_to_stmt_list (&t);\n+  tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n   /* Build: __mf_elem = &__mf_lookup_cache [(__mf_base >> __mf_shift)\n                                             & __mf_mask].  */\n@@ -472,81 +465,120 @@ mf_build_check_statement_for (tree addr, tree size, tree_stmt_iterator *iter,\n              TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n              mf_cache_array_decl, t);\n   t = build1 (ADDR_EXPR, mf_cache_structptr_type, t);\n-  stmt = build (MODIFY_EXPR, void_type_node, mf_elem, t);\n-  if (locus != NULL) \n-    annotate_with_locus (stmt, *locus);\n-  gimplify_stmt (&stmt);\n-  tsi_link_before (iter, stmt, TSI_SAME_STMT);\n+  t = build (MODIFY_EXPR, void_type_node, mf_elem, t);\n+  SET_EXPR_LOCUS (t, locus);\n+  gimplify_to_stmt_list (&t);\n+  tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n   /* Quick validity check.\n-     if (__builtin_expect ((__mf_elem->low > __mf_base)\n-                           | (__mf_elem_high < __mf_base + sizeof(T) - 1),\n-                           0))\n-        {\n-          __mf_check ();\n-          ... and only if single-threaded:\n-          __mf_lookup_shift_1 = f...;\n-          __mf_lookup_mask_l = ...;\n-        }\n-     */\n \n-  /* __mf_elem->low  */\n+     if (__mf_elem->low > __mf_base\n+\t || (__mf_elem_high < __mf_base + sizeof(T) - 1))\n+\t{\n+\t  __mf_check ();\n+\t  ... and only if single-threaded:\n+\t  __mf_lookup_shift_1 = f...;\n+\t  __mf_lookup_mask_l = ...;\n+\t}\n+\n+     It is expected that this body of code is rarely executed so we mark\n+     the edge to the THEN clause of the conditional jump as unlikely.  */\n+\n+  /* Construct t <-- '__mf_elem->low  > __mf_base'.  */\n   t = build (COMPONENT_REF, mf_uintptr_type,\n              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n              TYPE_FIELDS (mf_cache_struct_type));\n+  t = build (GT_EXPR, boolean_type_node, t, mf_base);\n+\n+  /* Construct '__mf_elem->high < __mf_base + sizeof(T) - 1'.\n+\n+     First build:\n+\t1) u <--  '__mf_elem->high'\n+\t2) v <--  '__mf_base + sizeof (T) - 1'.\n+\n+     Then build 'u <-- (u < v).  */\n+\n \n-  /* __mf_elem->high  */\n   u = build (COMPONENT_REF, mf_uintptr_type,\n              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n              TREE_CHAIN (TYPE_FIELDS (mf_cache_struct_type)));\n \n-  /* __mf_base + sizeof (T) - 1 */\n-  v = size_binop (MINUS_EXPR, size, size_one_node);\n-  v = convert (mf_uintptr_type, v);\n+  v = convert (mf_uintptr_type,\n+\t       size_binop (MINUS_EXPR, size, size_one_node));\n   v = fold (build (PLUS_EXPR, mf_uintptr_type, mf_base, v));\n \n-  t = build (TRUTH_OR_EXPR, boolean_type_node,\n-             build (GT_EXPR, boolean_type_node, t, mf_base),\n-             build (LT_EXPR, boolean_type_node, u, v));\n+  u = build (LT_EXPR, boolean_type_node, u, v);\n+\n+  /* Build the composed conditional: t <-- 't || u'.  Then store the\n+     result of the evaluation of 't' in a temporary variable which we\n+     can use as the condition for the conditional jump.  */\n+  t = build (TRUTH_OR_EXPR, boolean_type_node, t, u);\n+  cond = create_tmp_var (boolean_type_node, \"__mf_unlikely_cond\");\n+  t = build (MODIFY_EXPR, boolean_type_node, cond, t);\n+  gimplify_to_stmt_list (&t);\n+  tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n+\n+  /* Build the conditional jump.  'cond' is just a temporary so we can\n+     simply build a void COND_EXPR.  We do need labels in both arms though.  */\n+  t = build (COND_EXPR, void_type_node, cond,\n+\t     build (GOTO_EXPR, void_type_node, tree_block_label (then_bb)),\n+\t     build (GOTO_EXPR, void_type_node, tree_block_label (join_bb)));\n+  SET_EXPR_LOCUS (t, locus);\n+  tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n-  /* Mark condition as UNLIKELY using __builtin_expect.  */\n-  u = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n-  u = tree_cons (NULL_TREE, convert (long_integer_type_node, t), u);\n-  cond = build_function_call_expr (built_in_decls[BUILT_IN_EXPECT], u);\n+  /* At this point, after so much hard work, we have only constructed\n+     the conditional jump,\n \n-  /* Build up the body of the cache-miss handling:\n-     __mf_check(); refresh *_l vars.  */\n+     if (__mf_elem->low > __mf_base\n+\t || (__mf_elem_high < __mf_base + sizeof(T) - 1))\n \n-  stmt = NULL;\n+     The lowered GIMPLE tree representing this code is in the statement\n+     list starting at 'head'.\n+\n+     We can insert this now in the current basic block, ie. the one that\n+     the statement we're instrumenting was originally in.  */\n+  bsi = bsi_last (cond_bb);\n+  for (tsi = head; ! tsi_end_p (tsi); tsi_next (&tsi))\n+    bsi_insert_after (&bsi, tsi_stmt (tsi), BSI_CONTINUE_LINKING);\n+\n+  /*  Now build up the body of the cache-miss handling:\n+\n+     __mf_check();\n+     refresh *_l vars.\n+\n+     This is the body of the conditional.  */\n   \n   u = tree_cons (NULL_TREE, mf_file_function_line_tree (locus), NULL_TREE);\n   u = tree_cons (NULL_TREE, dirflag, u);\n   u = tree_cons (NULL_TREE, size, u);\n   u = tree_cons (NULL_TREE, mf_value, u);\n   t = build_function_call_expr (mf_check_fndecl, u);\n-  append_to_statement_list (t, &stmt);\n+  gimplify_to_stmt_list (&t);\n+  head = tsi_start (t);\n+  tsi = tsi_last (t);\n \n   if (! flag_mudflap_threads)\n     {\n       t = build (MODIFY_EXPR, void_type_node,\n                  mf_cache_shift_decl_l, mf_cache_shift_decl);\n-      append_to_statement_list (t, &stmt);\n+      tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n       t = build (MODIFY_EXPR, void_type_node,\n                  mf_cache_mask_decl_l, mf_cache_mask_decl);\n-      append_to_statement_list (t, &stmt);\n+      tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n     }\n \n-  stmt = build (COND_EXPR, void_type_node, cond, stmt, build_empty_stmt ());\n-  if (locus != NULL) \n-    annotate_with_locus (stmt, *locus);\n-  gimplify_to_stmt_list (&stmt);\n-  lower_stmt_body (stmt, NULL);\n-  tsi_link_before (iter, stmt, TSI_SAME_STMT);\n+  /* Insert the check code in the THEN block.  */\n+  bsi = bsi_start (then_bb);\n+  for (tsi = head; ! tsi_end_p (tsi); tsi_next (&tsi))\n+    bsi_insert_after (&bsi, tsi_stmt (tsi), BSI_CONTINUE_LINKING);\n+\n+  *instr_bsi = bsi_start (join_bb);\n+  bsi_next (instr_bsi);\n }\n \n static void\n-mf_xform_derefs_1 (tree_stmt_iterator *iter, tree *tp,\n+mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n                    location_t *locus, tree dirflag)\n {\n   tree type, ptr_type, addr, size, t;\n@@ -574,15 +606,14 @@ mf_xform_derefs_1 (tree_stmt_iterator *iter, tree *tp,\n           {\n             tree dom = TYPE_DOMAIN (TREE_TYPE (op0));\n \n-            /* Test for index in range.  Break if not.  */\n-            if (!dom)\n-              break;\n-            if (!TYPE_MIN_VALUE (dom) || !really_constant_p (TYPE_MIN_VALUE (dom)))\n-              break;\n-            if (!TYPE_MAX_VALUE (dom) || !really_constant_p (TYPE_MAX_VALUE (dom)))\n-              break;\n-            if (tree_int_cst_lt (op1, TYPE_MIN_VALUE (dom))\n-                || tree_int_cst_lt (TYPE_MAX_VALUE (dom), op1))\n+\t    /* Test for index in range.  Break if not.  */\n+\t    if (!dom\n+\t\t|| (! TYPE_MIN_VALUE (dom)\n+\t\t    || ! really_constant_p (TYPE_MIN_VALUE (dom)))\n+\t\t|| (! TYPE_MAX_VALUE (dom)\n+\t\t    || ! really_constant_p (TYPE_MAX_VALUE (dom)))\n+\t\t|| (tree_int_cst_lt (op1, TYPE_MIN_VALUE (dom))\n+\t\t    || tree_int_cst_lt (TYPE_MAX_VALUE (dom), op1)))\n               break;\n \n             /* If we're looking at a non-external VAR_DECL, then the \n@@ -679,45 +710,74 @@ mf_xform_derefs_1 (tree_stmt_iterator *iter, tree *tp,\n }\n \n static void\n-mf_xform_derefs (tree fnbody)\n+mf_xform_derefs (void)\n {\n-  tree_stmt_iterator i = tsi_start (fnbody);\n+  basic_block bb, next;\n+  block_stmt_iterator i;\n+  int saved_last_basic_block = last_basic_block;\n \n-  for (i = tsi_start (fnbody); !tsi_end_p (i); tsi_next (&i))\n+  bb = ENTRY_BLOCK_PTR ->next_bb;\n+  do\n     {\n-      tree s = tsi_stmt (i);\n-\n-      /* Only a few GIMPLE statements can reference memory.  */\n-      switch (TREE_CODE (s))\n-        {\n-        case MODIFY_EXPR:  /*  This includes INIT_EXPR after gimplification.  */\n-          mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n-                             integer_one_node);\n-          mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 1), EXPR_LOCUS (s),\n-                             integer_zero_node);\n-          break;\n-\n-        case RETURN_EXPR:\n-          if (TREE_OPERAND (s, 0) != NULL_TREE)\n-            {\n-              if (TREE_CODE (TREE_OPERAND (s, 0)) == MODIFY_EXPR)\n-                mf_xform_derefs_1 (&i, &TREE_OPERAND (TREE_OPERAND (s, 0), 1), EXPR_LOCUS (s),\n-                                   integer_zero_node);\n-              else\n-                mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n-                                   integer_zero_node);\n-            }\n-          break;\n-\n-        default:\n-          ;\n-        }\n+      next = bb->next_bb;\n+      for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+\t{\n+\t  tree s = bsi_stmt (i);\n+\n+\t  /* Only a few GIMPLE statements can reference memory.  */\n+\t  switch (TREE_CODE (s))\n+\t    {\n+\t    case MODIFY_EXPR:\n+\t      mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n+\t\t\t\t integer_one_node);\n+\t      mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 1), EXPR_LOCUS (s),\n+\t\t\t\t integer_zero_node);\n+\t      break;\n+\n+\t    case RETURN_EXPR:\n+\t      if (TREE_OPERAND (s, 0) != NULL_TREE)\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_OPERAND (s, 0)) == MODIFY_EXPR)\n+\t\t    mf_xform_derefs_1 (&i, &TREE_OPERAND (TREE_OPERAND (s, 0), 1),\n+\t\t\t\t       EXPR_LOCUS (s), integer_zero_node);\n+\t\t  else\n+\t\t    mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n+\t\t\t\t       integer_zero_node);\n+\t\t}\n+\t      break;\n+\n+\t    default:\n+\t      ;\n+\t    }\n+\t}\n+      bb = next;\n     }\n+  while (bb && bb->index <= saved_last_basic_block);\n }\n \n /* ------------------------------------------------------------------------ */\n-/* ADDR_EXPR transform */\n+/* ADDR_EXPR transforms.  Perform the declaration-related mudflap tree\n+   transforms on the current function.\n+\n+   This is the first part of the mudflap instrumentation.  It works on\n+   high-level GIMPLE because after lowering, all variables are moved out\n+   of their BIND_EXPR binding context, and we lose liveness information\n+   for the declarations we wish to instrument.  */\n+\n+static void\n+execute_mudflap_function_decls (void)\n+{\n+  if (mf_marked_p (current_function_decl))\n+    return;\n \n+  push_gimplify_context ();\n+\n+  mf_init_extern_trees ();\n+  mf_xform_decls (DECL_SAVED_TREE (current_function_decl),\n+                  DECL_ARGUMENTS (current_function_decl));\n+\n+  pop_gimplify_context (NULL);\n+}\n \n /* This struct is passed between mf_xform_decls to store state needed\n    during the traversal searching for objects that have their\n@@ -936,13 +996,41 @@ mf_xform_decls (tree fnbody, tree fnparams)\n \n \n /* ------------------------------------------------------------------------ */\n+/* Externally visible mudflap functions.  */\n+\n+\n+/* Mark and return the given tree node to prevent further mudflap\n+   transforms.  */\n+static GTY ((param_is (union tree_node))) htab_t marked_trees = NULL;\n+\n+tree\n+mf_mark (tree t)\n+{\n+  void **slot;\n+\n+  if (marked_trees == NULL)\n+    marked_trees = htab_create_ggc (31, htab_hash_pointer, htab_eq_pointer, NULL);\n+\n+  slot = htab_find_slot (marked_trees, t, INSERT);\n+  *slot = t;\n+  return t;\n+}\n+\n+int\n+mf_marked_p (tree t)\n+{\n+  void *entry;\n \n+  if (marked_trees == NULL)\n+    return 0;\n+\n+  entry = htab_find (marked_trees, t);\n+  return (entry != NULL);\n+}\n \n /* Remember given node as a static of some kind: global data,\n    function-scope static, or an anonymous constant.  Its assembler\n-   label is given.\n-*/\n-\n+   label is given.  */\n \n /* A list of globals whose incomplete declarations we encountered.\n    Instead of emitting the __mf_register call for them here, it's\n@@ -1066,7 +1154,6 @@ mudflap_enqueue_constant (tree obj)\n }\n \n \n-\n /* Emit any file-wide instrumentation.  */\n void\n mudflap_finish_file (void)\n@@ -1093,5 +1180,43 @@ mudflap_finish_file (void)\n }\n \n \n+static bool\n+gate_mudflap (void)\n+{\n+  return flag_mudflap != 0;\n+}\n+\n+struct tree_opt_pass pass_mudflap_1 = \n+{\n+  \"mudflap1\",                           /* name */\n+  gate_mudflap,                         /* gate */\n+  execute_mudflap_function_decls,       /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  PROP_gimple_any,                      /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_dump_func                        /* todo_flags_finish */\n+};\n+\n+struct tree_opt_pass pass_mudflap_2 = \n+{\n+  \"mudflap2\",                           /* name */\n+  gate_mudflap,                         /* gate */\n+  execute_mudflap_function_ops,         /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  0,                                    /* tv_id */\n+  PROP_gimple_leh,                      /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_verify_flow | TODO_verify_stmts\n+  | TODO_dump_func                      /* todo_flags_finish */\n+};\n \n #include \"gt-tree-mudflap.h\""}, {"sha": "30e1e7c25efd4679c66a9a1f98edc6ea3694c082", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 9, "deletions": 42, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -84,33 +84,6 @@ static struct tree_opt_pass pass_gimple =\n   TODO_dump_func\t\t\t/* todo_flags_finish */\n };\n \n-/* Pass: replace the outermost BIND_EXPR.  We removed all of them while\n-   optimizing, but the tree->rtl expander requires it.  */\n-\n-static void\n-execute_rebuild_bind (void)\n-{\n-  DECL_SAVED_TREE (current_function_decl)\n-    = build (BIND_EXPR, void_type_node, NULL_TREE,\n-\t     DECL_SAVED_TREE (current_function_decl), NULL_TREE);\n-}\n-\n-static struct tree_opt_pass pass_rebuild_bind = \n-{\n-  NULL,\t\t\t\t\t/* name */\n-  NULL,\t\t\t\t\t/* gate */\n-  execute_rebuild_bind,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  0,\t\t\t\t\t/* tv_id */\n-  0,\t\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  0\t\t\t\t\t/* todo_flags_finish */\n-};\n-\n /* Gate: execute, or not, all of the non-trivial optimizations.  */\n \n static bool\n@@ -141,9 +114,8 @@ static struct tree_opt_pass pass_all_optimizations =\n    passes.  */\n \n static void\n-execute_del_cfg (void)\n+execute_free_datastructures (void)\n {\n-  basic_block bb;\n   tree *chain;\n \n   /* ??? This isn't the right place for this.  Worse, it got computed\n@@ -160,27 +132,23 @@ execute_del_cfg (void)\n   /* Re-chain the statements from the blocks.  */\n   chain = &DECL_SAVED_TREE (current_function_decl);\n   *chain = alloc_stmt_list ();\n-  FOR_EACH_BB (bb)\n-    {\n-      append_to_statement_list_force (bb->stmt_list, chain);\n-    }\n \n-  /* And get rid of the cfg.  */\n-  delete_tree_cfg ();\n+  /* And get rid of annotations we no longer need.  */\n+  delete_tree_cfg_annotations ();\n }\n \n-static struct tree_opt_pass pass_del_cfg =\n+static struct tree_opt_pass pass_free_datastructures =\n {\n   NULL,\t\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n-  execute_del_cfg,\t\t\t/* execute */\n+  execute_free_datastructures,\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n   0,\t\t\t\t\t/* tv_id */\n   PROP_cfg,\t\t\t\t/* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n-  PROP_cfg,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n   0\t\t\t\t\t/* todo_flags_finish */\n };\n@@ -283,16 +251,16 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_mudflap_1);\n   NEXT_PASS (pass_lower_cf);\n   NEXT_PASS (pass_lower_eh);\n+  NEXT_PASS (pass_build_cfg);\n+  NEXT_PASS (pass_tree_profile);\n   NEXT_PASS (pass_all_optimizations);\n   NEXT_PASS (pass_mudflap_2);\n-  NEXT_PASS (pass_rebuild_bind);\n+  NEXT_PASS (pass_free_datastructures);\n   NEXT_PASS (pass_expand);\n   NEXT_PASS (pass_rest_of_compilation);\n   *p = NULL;\n \n   p = &pass_all_optimizations.sub;\n-  NEXT_PASS (pass_build_cfg);\n-  NEXT_PASS (pass_tree_profile);\n   NEXT_PASS (pass_referenced_vars);\n   NEXT_PASS (pass_build_pta);\n   NEXT_PASS (pass_build_ssa);\n@@ -335,7 +303,6 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_del_ssa);\n   NEXT_PASS (pass_nrv);\n   NEXT_PASS (pass_remove_useless_vars);\n-  NEXT_PASS (pass_del_cfg);\n   *p = NULL;\n \n #undef NEXT_PASS"}, {"sha": "b5e4735e29dcf219f49187691e859ac0a6390491", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/242229bbdc6beacddb4ed263c759d3ca52dae927/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=242229bbdc6beacddb4ed263c759d3ca52dae927", "patch": "@@ -56,7 +56,6 @@ enum sra_copy_mode { SCALAR_SCALAR, FIELD_SCALAR, SCALAR_FIELD };\n \n /* Local functions.  */\n static inline bool can_be_scalarized_p (tree);\n-static inline void insert_edge_copies (tree stmt, basic_block bb);\n static tree create_scalar_copies (tree lhs, tree rhs, enum sra_copy_mode mode);\n static inline void scalarize_component_ref (tree, tree *tp);\n static void scalarize_structures (void);\n@@ -556,7 +555,7 @@ find_candidates_for_sra (void)\n    has more than one edge, STMT will be replicated for each edge.  Also,\n    abnormal edges will be ignored.  */\n \n-static inline void\n+void\n insert_edge_copies (tree stmt, basic_block bb)\n {\n   edge e;"}]}