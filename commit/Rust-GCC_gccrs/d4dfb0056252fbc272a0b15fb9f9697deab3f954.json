{"sha": "d4dfb0056252fbc272a0b15fb9f9697deab3f954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRkZmIwMDU2MjUyZmJjMjcyYTBiMTVmYjlmOTY5N2RlYWIzZjk1NA==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2017-09-29T13:48:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-29T13:48:57Z"}, "message": "exp_ch6.adb (Expand_Call_Helper): Handle case of build-in-place functions returning nonlimited types.\n\n2017-09-29  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call_Helper): Handle case of build-in-place\n\tfunctions returning nonlimited types. Allow for qualified expressions\n\tand type conversions.\n\t(Expand_N_Extended_Return_Statement): Correct the computation of\n\tFunc_Bod to allow for child units.\n\t(Expand_Simple_Function_Return): Remove assumption that b-i-p implies\n\tlimited (initialization of In_Place_Expansion), and implies >= Ada\n\t2005.\n\t(Is_Build_In_Place_Result_Type): New function to accompany\n\tIs_Build_In_Place_Function and Is_Build_In_Place_Function_Call, because\n\tsometimes we just have the type on our hands, not the function.  For\n\tnow, does the same thing as the old version, so build-in-place is\n\tdisabled for nonlimited types, except that you can use -gnatd.9 to\n\tenable it.\n\t* exp_ch6.ads (Is_Build_In_Place_Result_Type): New function to\n\taccompany Is_Build_In_Place_Function and\n\tIs_Build_In_Place_Function_Call, because sometimes we just have the\n\ttype on our hands, not the function.\n\t(Make_Build_In_Place_Call_In_...): Handle nonlimited build-in-place\n\tcases.\n\t(Make_Build_In_Place_Call_In_Object_Declaration): Remove the\n\tquestionable code at the end that was setting the Etype.\n\t* exp_aggr.adb (Is_Build_In_Place_Aggregate_Return): New function to\n\tdetermine whether \"return (...agg...);\" is returning from a\n\tbuild-in-place function.\n\t(Initialize_Ctrl_Array_Component, Initialize_Ctrl_Record_Component):\n\tRemove assumption that b-i-p implies limited (initialization of\n\tIn_Place_Expansion).\n\t(Build_Record_Aggr_Code): AI-287: fix comment; it can't be wrapped in\n\tan unchecked conversion.  Add assertions.\n\t(Convert_Aggr_In_Object_Decl): Establish_Transient_Scope -- no need for\n\tsecondary stack here, just because the type needs finalization.  That\n\tcode is obsolete.\n\t(Convert_To_Assignments): Only set Unc_Decl if Nkind (N) = N_Aggregate.\n\tFor \"return (...agg...);\" don't assume b-i-p implies limited.\n\tNeeds_Finalization does not imply secondary stack.\n\t(Expand_Array_Aggregate): Named notation.  Reverse the sense of\n\tComponent_OK_For_Backend -- more readability with fewer double\n\tnegatives.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Remove assumptions that\n\tb-i-p implies >= Ada 2005.\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Remove assumptions that\n\tb-i-p implies >= Ada 2005.  Remove Adjust if we're building the return\n\tobject of an extended return statement in place.\n\t* exp_ch4.adb (Expand_Allocator_Expression, Expand_N_Indexed_Component,\n\tExpand_N_Selected_Component, Expand_N_Slice): Remove assumptions that\n\tb-i-p implies >= Ada 2005.\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): Remove assumption that\n\tb-i-p implies >= Ada 2005.\n\t* exp_ch7.adb: Comment fix.\n\t* exp_ch8.adb (Expand_N_Object_Renaming_Declaration): Remove\n\tassumptions that b-i-p implies >= Ada 2005.\n\t* exp_disp.adb (Expand_Interface_Actuals): Remove assumptions that\n\tb-i-p implies >= Ada 2005.\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Look at Storage_Pool\n\t(Expr), in case Pool_Id is not set.\n\t(Initialized_By_Aliased_BIP_Func_Call): Handle case where the call is\n\tqualified or converted.\n\t(Is_Secondary_Stack_BIP_Func_Call): Don't check if Nkind (Selector_Name\n\t(Param)) = N_Identifier; that's all it could be.\n\t* sinfo.ads: Comment fixes.\n\t* snames.ads-tmpl: Comment fixes.\n\t* debug.adb: Add flag gnatd.9, to enable the build-in-place machinery.\n\nFrom-SVN: r253290", "tree": {"sha": "fa8b8bc821eb9bd226d5c0379e2ff81e9d973545", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa8b8bc821eb9bd226d5c0379e2ff81e9d973545"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4dfb0056252fbc272a0b15fb9f9697deab3f954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4dfb0056252fbc272a0b15fb9f9697deab3f954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4dfb0056252fbc272a0b15fb9f9697deab3f954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4dfb0056252fbc272a0b15fb9f9697deab3f954/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52c6ab74436e5a7d4542c22cbfc77221c7c86230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c6ab74436e5a7d4542c22cbfc77221c7c86230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c6ab74436e5a7d4542c22cbfc77221c7c86230"}], "stats": {"total": 634, "additions": 356, "deletions": 278}, "files": [{"sha": "c71ad27325b39f77325e29b7ec8f7a5eb230818b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -1,3 +1,69 @@\n+2017-09-29  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call_Helper): Handle case of build-in-place\n+\tfunctions returning nonlimited types. Allow for qualified expressions\n+\tand type conversions.\n+\t(Expand_N_Extended_Return_Statement): Correct the computation of\n+\tFunc_Bod to allow for child units.\n+\t(Expand_Simple_Function_Return): Remove assumption that b-i-p implies\n+\tlimited (initialization of In_Place_Expansion), and implies >= Ada\n+\t2005.\n+\t(Is_Build_In_Place_Result_Type): New function to accompany\n+\tIs_Build_In_Place_Function and Is_Build_In_Place_Function_Call, because\n+\tsometimes we just have the type on our hands, not the function.  For\n+\tnow, does the same thing as the old version, so build-in-place is\n+\tdisabled for nonlimited types, except that you can use -gnatd.9 to\n+\tenable it.\n+\t* exp_ch6.ads (Is_Build_In_Place_Result_Type): New function to\n+\taccompany Is_Build_In_Place_Function and\n+\tIs_Build_In_Place_Function_Call, because sometimes we just have the\n+\ttype on our hands, not the function.\n+\t(Make_Build_In_Place_Call_In_...): Handle nonlimited build-in-place\n+\tcases.\n+\t(Make_Build_In_Place_Call_In_Object_Declaration): Remove the\n+\tquestionable code at the end that was setting the Etype.\n+\t* exp_aggr.adb (Is_Build_In_Place_Aggregate_Return): New function to\n+\tdetermine whether \"return (...agg...);\" is returning from a\n+\tbuild-in-place function.\n+\t(Initialize_Ctrl_Array_Component, Initialize_Ctrl_Record_Component):\n+\tRemove assumption that b-i-p implies limited (initialization of\n+\tIn_Place_Expansion).\n+\t(Build_Record_Aggr_Code): AI-287: fix comment; it can't be wrapped in\n+\tan unchecked conversion.  Add assertions.\n+\t(Convert_Aggr_In_Object_Decl): Establish_Transient_Scope -- no need for\n+\tsecondary stack here, just because the type needs finalization.  That\n+\tcode is obsolete.\n+\t(Convert_To_Assignments): Only set Unc_Decl if Nkind (N) = N_Aggregate.\n+\tFor \"return (...agg...);\" don't assume b-i-p implies limited.\n+\tNeeds_Finalization does not imply secondary stack.\n+\t(Expand_Array_Aggregate): Named notation.  Reverse the sense of\n+\tComponent_OK_For_Backend -- more readability with fewer double\n+\tnegatives.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Remove assumptions that\n+\tb-i-p implies >= Ada 2005.\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Remove assumptions that\n+\tb-i-p implies >= Ada 2005.  Remove Adjust if we're building the return\n+\tobject of an extended return statement in place.\n+\t* exp_ch4.adb (Expand_Allocator_Expression, Expand_N_Indexed_Component,\n+\tExpand_N_Selected_Component, Expand_N_Slice): Remove assumptions that\n+\tb-i-p implies >= Ada 2005.\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Remove assumption that\n+\tb-i-p implies >= Ada 2005.\n+\t* exp_ch7.adb: Comment fix.\n+\t* exp_ch8.adb (Expand_N_Object_Renaming_Declaration): Remove\n+\tassumptions that b-i-p implies >= Ada 2005.\n+\t* exp_disp.adb (Expand_Interface_Actuals): Remove assumptions that\n+\tb-i-p implies >= Ada 2005.\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Look at Storage_Pool\n+\t(Expr), in case Pool_Id is not set.\n+\t(Initialized_By_Aliased_BIP_Func_Call): Handle case where the call is\n+\tqualified or converted.\n+\t(Is_Secondary_Stack_BIP_Func_Call): Don't check if Nkind (Selector_Name\n+\t(Param)) = N_Identifier; that's all it could be.\n+\t* sinfo.ads: Comment fixes.\n+\t* snames.ads-tmpl: Comment fixes.\n+\t* debug.adb: Add flag gnatd.9, to enable the build-in-place machinery.\n+\n 2017-09-29  Justin Squirek  <squirek@adacore.com>\n \n \t* sem_ch8.adb (Mark_Use_Clauses): Add recursive call to properly handle"}, {"sha": "25d083992205febca23e062dc2432e64fc950476", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -163,7 +163,7 @@ package body Debug is\n    --  d.6  Do not avoid declaring unreferenced types in C code\n    --  d.7\n    --  d.8\n-   --  d.9\n+   --  d.9  Enable build-in-place for nonlimited types\n \n    --  Debug flags for binder (GNATBIND)\n \n@@ -820,6 +820,9 @@ package body Debug is\n    --       referenced by the generated C code. This debug flag restores the\n    --       output of all the types.\n \n+   --  d.9  Enable build-in-place for function calls returning some nonlimited\n+   --       types.\n+\n    ------------------------------------------\n    -- Documentation for Binder Debug Flags --\n    ------------------------------------------"}, {"sha": "972f6d58c4c2afb07b5de6dc447ffcf9bb217664", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 84, "deletions": 62, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -175,6 +175,10 @@ package body Exp_Aggr is\n    -- Local subprograms for Record Aggregate Expansion --\n    ------------------------------------------------------\n \n+   function Is_Build_In_Place_Aggregate_Return (N : Node_Id) return Boolean;\n+   --  True if N is an aggregate (possibly qualified or converted) that is\n+   --  being returned from a build-in-place function.\n+\n    function Build_Record_Aggr_Code\n      (N   : Node_Id;\n       Typ : Entity_Id;\n@@ -186,10 +190,9 @@ package body Exp_Aggr is\n    --  types.\n \n    procedure Convert_To_Assignments (N : Node_Id; Typ : Entity_Id);\n-   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of the\n-   --  aggregate (which can only be a record type, this procedure is only used\n-   --  for record types). Transform the given aggregate into a sequence of\n-   --  assignments performed component by component.\n+   --  Transform a record aggregate into a sequence of assignments performed\n+   --  component by component.  N is an N_Aggregate or N_Extension_Aggregate.\n+   --  Typ is the type of the record aggregate.\n \n    procedure Expand_Record_Aggregate\n      (N           : Node_Id;\n@@ -762,10 +765,10 @@ package body Exp_Aggr is\n       --  Checks 5 (if the component type is tagged, then we may need to do\n       --  tag adjustments. Perhaps this should be refined to check for any\n       --  component associations that actually need tag adjustment, similar\n-      --  to the test in Component_Not_OK_For_Backend for record aggregates\n-      --  with tagged components, but not clear whether it's worthwhile ???;\n-      --  in the case of virtual machines (no Tagged_Type_Expansion), object\n-      --  tags are handled implicitly).\n+      --  to the test in Component_OK_For_Backend for record aggregates with\n+      --  tagged components, but not clear whether it's worthwhile ???; in the\n+      --  case of virtual machines (no Tagged_Type_Expansion), object tags are\n+      --  handled implicitly).\n \n       if Is_Tagged_Type (Component_Type (Typ))\n         and then Tagged_Type_Expansion\n@@ -1347,7 +1350,7 @@ package body Exp_Aggr is\n \n             In_Place_Expansion :=\n               Nkind (Expr) = N_Function_Call\n-                and then not Is_Limited_Type (Comp_Typ);\n+                and then not Is_Build_In_Place_Result_Type (Comp_Typ);\n \n             --  The initialization expression is a controlled function call.\n             --  Perform in-place removal of side effects to avoid creating a\n@@ -2831,7 +2834,7 @@ package body Exp_Aggr is\n \n          In_Place_Expansion :=\n            Nkind (Init_Expr) = N_Function_Call\n-             and then not Is_Limited_Type (Comp_Typ);\n+                and then not Is_Build_In_Place_Result_Type (Comp_Typ);\n \n          --  The initialization expression is a controlled function call.\n          --  Perform in-place removal of side effects to avoid creating a\n@@ -2967,7 +2970,10 @@ package body Exp_Aggr is\n \n          --    [Deep_]Adjust (Rec_Comp);\n \n-         if Finalization_OK and then not Is_Limited_Type (Comp_Typ) then\n+         if Finalization_OK\n+           and then not Is_Limited_Type (Comp_Typ)\n+           and then not Is_Build_In_Place_Function_Call (Init_Expr)\n+         then\n             Adj_Call :=\n               Make_Adjust_Call\n                 (Obj_Ref => New_Copy_Tree (Rec_Comp),\n@@ -3229,12 +3235,8 @@ package body Exp_Aggr is\n             --  Ada 2005 (AI-287): If the ancestor part is an aggregate of\n             --  limited type, a recursive call expands the ancestor. Note that\n             --  in the limited case, the ancestor part must be either a\n-            --  function call (possibly qualified, or wrapped in an unchecked\n-            --  conversion) or aggregate (definitely qualified).\n-\n-            --  The ancestor part can also be a function call (that may be\n-            --  transformed into an explicit dereference) or a qualification\n-            --  of one such.\n+            --  function call (possibly qualified) or aggregate (definitely\n+            --  qualified).\n \n             elsif Is_Limited_Type (Etype (Ancestor))\n               and then Nkind_In (Unqualify (Ancestor), N_Aggregate,\n@@ -3330,6 +3332,7 @@ package body Exp_Aggr is\n \n                if Needs_Finalization (Etype (Ancestor))\n                  and then not Is_Limited_Type (Etype (Ancestor))\n+                 and then not Is_Build_In_Place_Function_Call (Ancestor)\n                then\n                   Adj_Call :=\n                     Make_Adjust_Call\n@@ -3351,6 +3354,10 @@ package body Exp_Aggr is\n                   Check_Ancestor_Discriminants (Init_Typ);\n                end if;\n             end if;\n+\n+            pragma Assert (Nkind (N) = N_Extension_Aggregate);\n+            pragma Assert\n+              (not (Ancestor_Is_Expression and Ancestor_Is_Subtype_Mark));\n          end;\n \n          --  Generate assignments of hidden discriminants. If the base type is\n@@ -4073,10 +4080,7 @@ package body Exp_Aggr is\n         and then Ekind (Current_Scope) /= E_Return_Statement\n         and then not Is_Limited_Type (Typ)\n       then\n-         Establish_Transient_Scope\n-           (Aggr,\n-            Sec_Stack =>\n-              Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n+         Establish_Transient_Scope (Aggr, Sec_Stack => False);\n       end if;\n \n       declare\n@@ -4121,6 +4125,25 @@ package body Exp_Aggr is\n    -- Convert_To_Assignments --\n    ----------------------------\n \n+   function Is_Build_In_Place_Aggregate_Return (N : Node_Id) return Boolean is\n+      P : Node_Id := Parent (N);\n+   begin\n+      while Nkind (P) = N_Qualified_Expression loop\n+         P := Parent (P);\n+      end loop;\n+\n+      if Nkind (P) = N_Simple_Return_Statement then\n+         null;\n+      elsif Nkind (Parent (P)) = N_Extended_Return_Statement then\n+         P := Parent (P);\n+      else\n+         return False;\n+      end if;\n+\n+      return Is_Build_In_Place_Function\n+        (Return_Applies_To (Return_Statement_Entity (P)));\n+   end Is_Build_In_Place_Aggregate_Return;\n+\n    procedure Convert_To_Assignments (N : Node_Id; Typ : Entity_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n       T    : Entity_Id;\n@@ -4134,26 +4157,27 @@ package body Exp_Aggr is\n       Parent_Node : Node_Id;\n \n    begin\n+      pragma Assert (Nkind_In (N, N_Aggregate, N_Extension_Aggregate));\n       pragma Assert (not Is_Static_Dispatch_Table_Aggregate (N));\n       pragma Assert (Is_Record_Type (Typ));\n \n       Parent_Node := Parent (N);\n       Parent_Kind := Nkind (Parent_Node);\n \n       if Parent_Kind = N_Qualified_Expression then\n-\n-         --  Check if we are in a unconstrained declaration because in this\n+         --  Check if we are in an unconstrained declaration because in this\n          --  case the current delayed expansion mechanism doesn't work when\n-         --  the declared object size depend on the initializing expr.\n+         --  the declared object size depends on the initializing expr.\n \n          Parent_Node := Parent (Parent_Node);\n          Parent_Kind := Nkind (Parent_Node);\n \n          if Parent_Kind = N_Object_Declaration then\n             Unc_Decl :=\n               not Is_Entity_Name (Object_Definition (Parent_Node))\n-                or else Has_Discriminants\n-                          (Entity (Object_Definition (Parent_Node)))\n+                or else (Nkind (N) = N_Aggregate\n+                           and then Has_Discriminants\n+                             (Entity (Object_Definition (Parent_Node))))\n                 or else Is_Class_Wide_Type\n                           (Entity (Object_Definition (Parent_Node)));\n          end if;\n@@ -4195,11 +4219,7 @@ package body Exp_Aggr is\n          --  finalization of the return object (which is built in place\n          --  within the caller's scope).\n \n-         or else\n-           (Is_Limited_View (Typ)\n-             and then\n-               (Nkind (Parent (Parent_Node)) = N_Extended_Return_Statement\n-                 or else Nkind (Parent_Node) = N_Simple_Return_Statement))\n+         or else Is_Build_In_Place_Aggregate_Return (N)\n       then\n          Set_Expansion_Delayed (N);\n          return;\n@@ -4214,7 +4234,7 @@ package body Exp_Aggr is\n       --  Should the condition be more restrictive ???\n \n       if Requires_Transient_Scope (Typ) and then not Inside_Init_Proc then\n-         Establish_Transient_Scope (N, Sec_Stack => Needs_Finalization (Typ));\n+         Establish_Transient_Scope (N, Sec_Stack => False);\n       end if;\n \n       --  If the aggregate is nonlimited, create a temporary. If it is limited\n@@ -6111,8 +6131,7 @@ package body Exp_Aggr is\n       --  for default initialization, e.g. with Initialize_Scalars.\n \n       if Requires_Transient_Scope (Typ) then\n-         Establish_Transient_Scope\n-           (N, Sec_Stack => Has_Controlled_Component (Typ));\n+         Establish_Transient_Scope (N, Sec_Stack => False);\n       end if;\n \n       if Has_Default_Init_Comps (N) then\n@@ -6251,7 +6270,7 @@ package body Exp_Aggr is\n          if Ekind (Current_Scope) = E_Loop\n            and then Nkind (Parent (Parent (N))) = N_Allocator\n          then\n-            Establish_Transient_Scope (N, False);\n+            Establish_Transient_Scope (N, Sec_Stack => False);\n          end if;\n \n          Insert_Action (N, Tmp_Decl);\n@@ -6646,13 +6665,13 @@ package body Exp_Aggr is\n \n    --  If the ancestor part is an expression, add a component association for\n    --  the parent field. If the type of the ancestor part is not the direct\n-   --  parent of the expected type,  build recursively the needed ancestors.\n-   --  If the ancestor part is a subtype_mark, replace aggregate with a decla-\n-   --  ration for a temporary of the expected type, followed by individual\n-   --  assignments to the given components.\n+   --  parent of the expected type, build recursively the needed ancestors.\n+   --  If the ancestor part is a subtype_mark, replace aggregate with a\n+   --  declaration for a temporary of the expected type, followed by\n+   --  individual assignments to the given components.\n \n    procedure Expand_N_Extension_Aggregate (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc  (N);\n+      Loc : constant Source_Ptr := Sloc (N);\n       A   : constant Node_Id    := Ancestor_Part (N);\n       Typ : constant Entity_Id  := Etype (N);\n \n@@ -6709,7 +6728,7 @@ package body Exp_Aggr is\n       Static_Components : Boolean := True;\n       --  Flag to indicate whether all components are compile-time known,\n       --  and the aggregate can be constructed statically and handled by\n-      --  the back-end.\n+      --  the back-end. Set to False by Component_OK_For_Backend.\n \n       procedure Build_Back_End_Aggregate;\n       --  Build a proper aggregate to be handled by the back-end\n@@ -6722,7 +6741,7 @@ package body Exp_Aggr is\n       --  This returns true for N_Aggregate with Compile_Time_Known_Aggregate\n       --  set and constants whose expression is such an aggregate, recursively.\n \n-      function Component_Not_OK_For_Backend return Boolean;\n+      function Component_OK_For_Backend return Boolean;\n       --  Check for presence of a component which makes it impossible for the\n       --  backend to process the aggregate, thus requiring the use of a series\n       --  of assignment statements. Cases checked for are a nested aggregate\n@@ -6741,6 +6760,9 @@ package body Exp_Aggr is\n       --  in order to minimize elaboration code. This is one case where the\n       --  semantics of Ada complicate the analysis and lead to anomalies in\n       --  the gcc back-end if the aggregate is not expanded into assignments.\n+      --\n+      --  NOTE: This sets the global Static_Components to False in most, but\n+      --  not all, cases when it returns False.\n \n       function Has_Per_Object_Constraint (L : List_Id) return Boolean;\n       --  Return True if any element of L has Has_Per_Object_Constraint set.\n@@ -7043,7 +7065,7 @@ package body Exp_Aggr is\n                   --  The ancestor part may be a nested aggregate that has\n                   --  delayed expansion: recheck now.\n \n-                  if Component_Not_OK_For_Backend then\n+                  if not Component_OK_For_Backend then\n                      Convert_To_Assignments (N, Typ);\n                   end if;\n                end;\n@@ -7110,17 +7132,17 @@ package body Exp_Aggr is\n \n       end Compile_Time_Known_Composite_Value;\n \n-      ----------------------------------\n-      -- Component_Not_OK_For_Backend --\n-      ----------------------------------\n+      ------------------------------\n+      -- Component_OK_For_Backend --\n+      ------------------------------\n \n-      function Component_Not_OK_For_Backend return Boolean is\n+      function Component_OK_For_Backend return Boolean is\n          C      : Node_Id;\n          Expr_Q : Node_Id;\n \n       begin\n          if No (Comps) then\n-            return False;\n+            return True;\n          end if;\n \n          C := First (Comps);\n@@ -7130,7 +7152,7 @@ package body Exp_Aggr is\n             --  and component is not ready for backend.\n \n             if Box_Present (C) then\n-               return True;\n+               return False;\n             end if;\n \n             if Nkind (Expression (C)) = N_Qualified_Expression then\n@@ -7139,7 +7161,7 @@ package body Exp_Aggr is\n                Expr_Q := Expression (C);\n             end if;\n \n-            --  Return true if the aggregate has any associations for tagged\n+            --  Return False if the aggregate has any associations for tagged\n             --  components that may require tag adjustment.\n \n             --  These are cases where the source expression may have a tag that\n@@ -7156,36 +7178,36 @@ package body Exp_Aggr is\n               and then Tagged_Type_Expansion\n             then\n                Static_Components := False;\n-               return True;\n+               return False;\n \n             elsif Is_Delayed_Aggregate (Expr_Q) then\n                Static_Components := False;\n-               return True;\n+               return False;\n \n             elsif Possible_Bit_Aligned_Component (Expr_Q) then\n                Static_Components := False;\n-               return True;\n+               return False;\n \n             elsif Modify_Tree_For_C\n               and then Nkind (C) = N_Component_Association\n               and then Has_Per_Object_Constraint (Choices (C))\n             then\n                Static_Components := False;\n-               return True;\n+               return False;\n \n             elsif Modify_Tree_For_C\n               and then Nkind (Expr_Q) = N_Identifier\n               and then Is_Array_Type (Etype (Expr_Q))\n             then\n                Static_Components := False;\n-               return True;\n+               return False;\n \n             elsif Modify_Tree_For_C\n               and then Nkind (Expr_Q) = N_Type_Conversion\n               and then Is_Array_Type (Etype (Expr_Q))\n             then\n                Static_Components := False;\n-               return True;\n+               return False;\n             end if;\n \n             if Is_Elementary_Type (Etype (Expr_Q)) then\n@@ -7199,15 +7221,15 @@ package body Exp_Aggr is\n                if Is_Private_Type (Etype (Expr_Q))\n                  and then Has_Discriminants (Etype (Expr_Q))\n                then\n-                  return True;\n+                  return False;\n                end if;\n             end if;\n \n             Next (C);\n          end loop;\n \n-         return False;\n-      end Component_Not_OK_For_Backend;\n+         return True;\n+      end Component_OK_For_Backend;\n \n       -------------------------------\n       -- Has_Per_Object_Constraint --\n@@ -7297,7 +7319,7 @@ package body Exp_Aggr is\n       --  Ada 2005 (AI-318-2): We need to convert to assignments if components\n       --  are build-in-place function calls. The assignments will each turn\n       --  into a build-in-place function call. If components are all static,\n-      --  we can pass the aggregate to the backend regardless of limitedness.\n+      --  we can pass the aggregate to the back end regardless of limitedness.\n \n       --  Extension aggregates, aggregates in extended return statements, and\n       --  aggregates for C++ imported types must be expanded.\n@@ -7314,7 +7336,7 @@ package body Exp_Aggr is\n             Convert_To_Assignments (N, Typ);\n \n          elsif not Size_Known_At_Compile_Time (Typ)\n-           or else Component_Not_OK_For_Backend\n+           or else not Component_OK_For_Backend\n            or else not Static_Components\n          then\n             Convert_To_Assignments (N, Typ);\n@@ -7349,7 +7371,7 @@ package body Exp_Aggr is\n \n       --  Check components\n \n-      elsif Component_Not_OK_For_Backend then\n+      elsif not Component_OK_For_Backend then\n          Convert_To_Assignments (N, Typ);\n \n       --  If an ancestor is private, some components are not inherited and we"}, {"sha": "552cd0295b58823400b65dfa4dea25a6b8beb515", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -1753,23 +1753,16 @@ package body Exp_Attr is\n \n       --  Ada 2005 (AI-318-02): If attribute prefix is a call to a build-in-\n       --  place function, then a temporary return object needs to be created\n-      --  and access to it must be passed to the function. Currently we limit\n-      --  such functions to those with inherently limited result subtypes, but\n-      --  eventually we plan to expand the functions that are treated as\n-      --  build-in-place to include other composite result types.\n+      --  and access to it must be passed to the function.\n \n-      if Ada_Version >= Ada_2005\n-        and then Is_Build_In_Place_Function_Call (Pref)\n-      then\n+      if Is_Build_In_Place_Function_Call (Pref) then\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pref);\n \n       --  Ada 2005 (AI-318-02): Specialization of the previous case for prefix\n       --  containing build-in-place function calls whose returned object covers\n       --  interface types.\n \n-      elsif Ada_Version >= Ada_2005\n-        and then Present (Unqual_BIP_Iface_Function_Call (Pref))\n-      then\n+      elsif Present (Unqual_BIP_Iface_Function_Call (Pref)) then\n          Make_Build_In_Place_Iface_Call_In_Anonymous_Context (Pref);\n       end if;\n "}, {"sha": "0198e3e5f7eb2335def82083c1eea9186da5d497", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -6299,9 +6299,7 @@ package body Exp_Ch3 is\n          --  plan to expand the allowed forms of functions that are treated as\n          --  build-in-place.\n \n-         elsif Ada_Version >= Ada_2005\n-           and then Is_Build_In_Place_Function_Call (Expr_Q)\n-         then\n+         elsif Is_Build_In_Place_Function_Call (Expr_Q) then\n             Make_Build_In_Place_Call_In_Object_Declaration (N, Expr_Q);\n \n             --  The previous call expands the expression initializing the\n@@ -6317,9 +6315,7 @@ package body Exp_Ch3 is\n          --  in-place object to reference the secondary dispatch table of a\n          --  covered interface type.\n \n-         elsif Ada_Version >= Ada_2005\n-           and then Present (Unqual_BIP_Iface_Function_Call (Expr_Q))\n-         then\n+         elsif Present (Unqual_BIP_Iface_Function_Call (Expr_Q)) then\n             Make_Build_In_Place_Iface_Call_In_Object_Declaration (N, Expr_Q);\n \n             --  The previous call expands the expression initializing the\n@@ -6617,13 +6613,19 @@ package body Exp_Ch3 is\n             --  the target is adjusted after the copy and attached to the\n             --  finalization list. However, no adjustment is done in the case\n             --  where the object was initialized by a call to a function whose\n-            --  result is built in place, since no copy occurred. (Eventually\n-            --  we plan to support in-place function results for some cases\n-            --  of nonlimited types. ???) Similarly, no adjustment is required\n-            --  if we are going to rewrite the object declaration into a\n-            --  renaming declaration.\n+            --  result is built in place, since no copy occurred. Similarly, no\n+            --  adjustment is required if we are going to rewrite the object\n+            --  declaration into a renaming declaration.\n+\n+            if Is_Build_In_Place_Result_Type (Typ)\n+              and then Nkind (Parent (N)) = N_Extended_Return_Statement\n+              and then not Is_Definite_Subtype\n+                (Etype (Return_Applies_To\n+                         (Return_Statement_Entity (Parent (N)))))\n+            then\n+               null;\n \n-            if Needs_Finalization (Typ)\n+            elsif Needs_Finalization (Typ)\n               and then not Is_Limited_View (Typ)\n               and then not Rewrite_As_Renaming\n             then\n@@ -6755,9 +6757,9 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-         --  Cases where the back end cannot handle the initialization directly\n-         --  In such cases, we expand an assignment that will be appropriately\n-         --  handled by Expand_N_Assignment_Statement.\n+         --  Cases where the back end cannot handle the initialization\n+         --  directly. In such cases, we expand an assignment that will\n+         --  be appropriately handled by Expand_N_Assignment_Statement.\n \n          --  The exclusion of the unconstrained case is wrong, but for now it\n          --  is too much trouble ???"}, {"sha": "0fe189b8a405114a8a0c721f4d6dad207a6412c5", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -793,14 +793,9 @@ package body Exp_Ch4 is\n \n          --  Ada 2005 (AI-318-02): If the initialization expression is a call\n          --  to a build-in-place function, then access to the allocated object\n-         --  must be passed to the function. Currently we limit such functions\n-         --  to those with constrained limited result subtypes, but eventually\n-         --  we plan to expand the allowed forms of functions that are treated\n-         --  as build-in-place.\n+         --  must be passed to the function.\n \n-         if Ada_Version >= Ada_2005\n-           and then Is_Build_In_Place_Function_Call (Exp)\n-         then\n+         if Is_Build_In_Place_Function_Call (Exp) then\n             Make_Build_In_Place_Call_In_Allocator (N, Exp);\n             Apply_Accessibility_Check (N, Built_In_Place => True);\n             return;\n@@ -812,9 +807,7 @@ package body Exp_Ch4 is\n          --  in-place object to reference the secondary dispatch table of a\n          --  covered interface type.\n \n-         elsif Ada_Version >= Ada_2005\n-           and then Present (Unqual_BIP_Iface_Function_Call (Exp))\n-         then\n+         elsif Present (Unqual_BIP_Iface_Function_Call (Exp)) then\n             Make_Build_In_Place_Iface_Call_In_Allocator (N, Exp);\n             Apply_Accessibility_Check (N, Built_In_Place => True);\n             return;\n@@ -1223,14 +1216,9 @@ package body Exp_Ch4 is\n \n          --  Ada 2005 (AI-318-02): If the initialization expression is a call\n          --  to a build-in-place function, then access to the allocated object\n-         --  must be passed to the function. Currently we limit such functions\n-         --  to those with constrained limited result subtypes, but eventually\n-         --  we plan to expand the allowed forms of functions that are treated\n-         --  as build-in-place.\n+         --  must be passed to the function.\n \n-         if Ada_Version >= Ada_2005\n-           and then Is_Build_In_Place_Function_Call (Exp)\n-         then\n+         if Is_Build_In_Place_Function_Call (Exp) then\n             Make_Build_In_Place_Call_In_Allocator (N, Exp);\n          end if;\n       end if;\n@@ -6572,18 +6560,14 @@ package body Exp_Ch4 is\n       --  Ada 2005 (AI-318-02): If the prefix is a call to a build-in-place\n       --  function, then additional actuals must be passed.\n \n-      if Ada_Version >= Ada_2005\n-        and then Is_Build_In_Place_Function_Call (P)\n-      then\n+      if Is_Build_In_Place_Function_Call (P) then\n          Make_Build_In_Place_Call_In_Anonymous_Context (P);\n \n       --  Ada 2005 (AI-318-02): Specialization of the previous case for prefix\n       --  containing build-in-place function calls whose returned object covers\n       --  interface types.\n \n-      elsif Ada_Version >= Ada_2005\n-        and then Present (Unqual_BIP_Iface_Function_Call (P))\n-      then\n+      elsif Present (Unqual_BIP_Iface_Function_Call (P)) then\n          Make_Build_In_Place_Iface_Call_In_Anonymous_Context (P);\n       end if;\n \n@@ -10221,18 +10205,14 @@ package body Exp_Ch4 is\n       --  Ada 2005 (AI-318-02): If the prefix is a call to a build-in-place\n       --  function, then additional actuals must be passed.\n \n-      if Ada_Version >= Ada_2005\n-        and then Is_Build_In_Place_Function_Call (P)\n-      then\n+      if Is_Build_In_Place_Function_Call (P) then\n          Make_Build_In_Place_Call_In_Anonymous_Context (P);\n \n       --  Ada 2005 (AI-318-02): Specialization of the previous case for prefix\n       --  containing build-in-place function calls whose returned object covers\n       --  interface types.\n \n-      elsif Ada_Version >= Ada_2005\n-        and then Present (Unqual_BIP_Iface_Function_Call (P))\n-      then\n+      elsif Present (Unqual_BIP_Iface_Function_Call (P)) then\n          Make_Build_In_Place_Iface_Call_In_Anonymous_Context (P);\n       end if;\n \n@@ -10587,18 +10567,14 @@ package body Exp_Ch4 is\n       --  Ada 2005 (AI-318-02): If the prefix is a call to a build-in-place\n       --  function, then additional actuals must be passed.\n \n-      if Ada_Version >= Ada_2005\n-        and then Is_Build_In_Place_Function_Call (Pref)\n-      then\n+      if Is_Build_In_Place_Function_Call (Pref) then\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pref);\n \n       --  Ada 2005 (AI-318-02): Specialization of the previous case for prefix\n       --  containing build-in-place function calls whose returned object covers\n       --  interface types.\n \n-      elsif Ada_Version >= Ada_2005\n-        and then Present (Unqual_BIP_Iface_Function_Call (Pref))\n-      then\n+      elsif Present (Unqual_BIP_Iface_Function_Call (Pref)) then\n          Make_Build_In_Place_Iface_Call_In_Anonymous_Context (Pref);\n       end if;\n "}, {"sha": "5846874fc30cac9dbd16e36756517f0f121d120e", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -2390,13 +2390,13 @@ package body Exp_Ch5 is\n             end;\n          end if;\n \n-      --  Build-in-place function call case. Note that we're not yet doing\n-      --  build-in-place for user-written assignment statements (the assignment\n-      --  here came from an aggregate.)\n+      --  Build-in-place function call case. This is for assignment statements\n+      --  that come from aggregate component associations or from init procs.\n+      --  User-written assignment statements with b-i-p calls are handled\n+      --  elsewhere.\n \n-      elsif Ada_Version >= Ada_2005\n-        and then Is_Build_In_Place_Function_Call (Rhs)\n-      then\n+      elsif Is_Build_In_Place_Function_Call (Rhs) then\n+         pragma Assert (not Comes_From_Source (N));\n          Make_Build_In_Place_Call_In_Assignment (N, Rhs);\n \n       elsif Is_Tagged_Type (Typ)"}, {"sha": "5fcd1f587cd57c34dc350420999e6320b5fd4580", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 128, "deletions": 112, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -2252,6 +2252,9 @@ package body Exp_Ch6 is\n    procedure Expand_Call (N : Node_Id) is\n       Post_Call : List_Id;\n    begin\n+      pragma Assert\n+        (Nkind_In (N, N_Function_Call, N_Procedure_Call_Statement,\n+                      N_Entry_Call_Statement));\n       Expand_Call_Helper (N, Post_Call);\n       Insert_Post_Call_Actions (N, Post_Call);\n    end Expand_Call;\n@@ -4327,29 +4330,30 @@ package body Exp_Ch6 is\n       --  result from the secondary stack.\n \n       if Needs_Finalization (Etype (Subp)) then\n-         if not Is_Limited_View (Etype (Subp))\n-           and then\n-             (No (First_Formal (Subp))\n-                or else\n-                  not Is_Concurrent_Record_Type (Etype (First_Formal (Subp))))\n-         then\n-            Expand_Ctrl_Function_Call (Call_Node);\n-\n          --  Build-in-place function calls which appear in anonymous contexts\n          --  need a transient scope to ensure the proper finalization of the\n          --  intermediate result after its use.\n \n-         elsif Is_Build_In_Place_Function_Call (Call_Node)\n+         if Is_Build_In_Place_Function_Call (Call_Node)\n            and then\n-             Nkind_In (Parent (Call_Node), N_Attribute_Reference,\n-                                           N_Function_Call,\n-                                           N_Indexed_Component,\n-                                           N_Object_Renaming_Declaration,\n-                                           N_Procedure_Call_Statement,\n-                                           N_Selected_Component,\n-                                           N_Slice)\n+             Nkind_In (Parent (Unqual_Conv (Call_Node)),\n+                       N_Attribute_Reference,\n+                       N_Function_Call,\n+                       N_Indexed_Component,\n+                       N_Object_Renaming_Declaration,\n+                       N_Procedure_Call_Statement,\n+                       N_Selected_Component,\n+                       N_Slice)\n          then\n             Establish_Transient_Scope (Call_Node, Sec_Stack => True);\n+\n+         elsif not Is_Build_In_Place_Function_Call (Call_Node)\n+           and then\n+             (No (First_Formal (Subp))\n+                or else\n+                  not Is_Concurrent_Record_Type (Etype (First_Formal (Subp))))\n+         then\n+            Expand_Ctrl_Function_Call (Call_Node);\n          end if;\n       end if;\n    end Expand_Call_Helper;\n@@ -4756,6 +4760,12 @@ package body Exp_Ch6 is\n                Func_Bod := Parent (Parent (Corresponding_Body (Func_Bod)));\n             end if;\n \n+            if Nkind (Func_Bod) = N_Function_Specification then\n+               Func_Bod := Parent (Func_Bod); -- one more level for child units\n+            end if;\n+\n+            pragma Assert (Nkind (Func_Bod) = N_Subprogram_Body);\n+\n             --  Create a flag to track the function state\n \n             Flag_Id := Make_Temporary (Loc, 'F');\n@@ -4781,8 +4791,7 @@ package body Exp_Ch6 is\n       --  Build a simple_return_statement that returns the return object when\n       --  there is a statement sequence, or no expression, or the result will\n       --  be built in place. Note however that we currently do this for all\n-      --  composite cases, even though nonlimited composite results are not yet\n-      --  built in place (though we plan to do so eventually).\n+      --  composite cases, even though not all are built in place.\n \n       if Present (HSS)\n         or else Is_Composite_Type (Ret_Typ)\n@@ -6385,8 +6394,8 @@ package body Exp_Ch6 is\n       end if;\n \n       --  For the case of a simple return that does not come from an extended\n-      --  return, in the case of Ada 2005 where we are returning a limited\n-      --  type, we rewrite \"return <expression>;\" to be:\n+      --  return, in the case of build-in-place, we rewrite \"return\n+      --  <expression>;\" to be:\n \n       --    return _anon_ : <return_subtype> := <expression>\n \n@@ -6414,9 +6423,13 @@ package body Exp_Ch6 is\n       --  class-wide interface type, which is not a limited type, even though\n       --  the type of the expression may be.\n \n+      pragma Assert\n+        (Comes_From_Extended_Return_Statement (N)\n+           or else not Is_Build_In_Place_Function_Call (Exp)\n+           or else Is_Build_In_Place_Function (Scope_Id));\n+\n       if not Comes_From_Extended_Return_Statement (N)\n-        and then Is_Limited_View (Etype (Expression (N)))\n-        and then Ada_Version >= Ada_2005\n+        and then Is_Build_In_Place_Function (Scope_Id)\n         and then not Debug_Flag_Dot_L\n \n          --  The functionality of interface thunks is simple and it is always\n@@ -6494,7 +6507,7 @@ package body Exp_Ch6 is\n       --  type that requires special processing (indicated by the fact that\n       --  it requires a cleanup scope for the secondary stack case).\n \n-      if Is_Limited_View (Exptyp)\n+      if Is_Build_In_Place_Function (Scope_Id)\n         or else Is_Limited_Interface (Exptyp)\n       then\n          null;\n@@ -7186,6 +7199,24 @@ package body Exp_Ch6 is\n       return False;\n    end Has_Unconstrained_Access_Discriminants;\n \n+   -----------------------------------\n+   -- Is_Build_In_Place_Result_Type --\n+   -----------------------------------\n+\n+   function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean is\n+   begin\n+      --  In Ada 2005 all functions with an inherently limited return type\n+      --  must be handled using a build-in-place profile, including the case\n+      --  of a function with a limited interface result, where the function\n+      --  may return objects of nonlimited descendants.\n+\n+      if Is_Limited_View (Typ) then\n+         return Ada_Version >= Ada_2005 and then not Debug_Flag_Dot_L;\n+      else\n+         return Debug_Flag_Dot_9;\n+      end if;\n+   end Is_Build_In_Place_Result_Type;\n+\n    --------------------------------\n    -- Is_Build_In_Place_Function --\n    --------------------------------\n@@ -7216,19 +7247,9 @@ package body Exp_Ch6 is\n          --  intended to be compatible with the other language, but the build-\n          --  in place machinery can ensure that the object is not copied.\n \n-         if Has_Foreign_Convention (E) then\n-            return False;\n-\n-         --  In Ada 2005 all functions with an inherently limited return type\n-         --  must be handled using a build-in-place profile, including the case\n-         --  of a function with a limited interface result, where the function\n-         --  may return objects of nonlimited descendants.\n-\n-         else\n-            return Is_Limited_View (Etype (E))\n-              and then Ada_Version >= Ada_2005\n-              and then not Debug_Flag_Dot_L;\n-         end if;\n+         return Is_Build_In_Place_Result_Type (Etype (E))\n+           and then not Has_Foreign_Convention (E)\n+           and then not Debug_Flag_Dot_L;\n \n       else\n          return False;\n@@ -7256,34 +7277,33 @@ package body Exp_Ch6 is\n       --  may end up with a call that is neither resolved to an entity, nor\n       --  an indirect call.\n \n-      if not Expander_Active then\n+      if not Expander_Active or else Nkind (Exp_Node) /= N_Function_Call then\n          return False;\n       end if;\n \n-      if Nkind (Exp_Node) /= N_Function_Call then\n-         return False;\n-\n-      else\n-         if Is_Entity_Name (Name (Exp_Node)) then\n-            Function_Id := Entity (Name (Exp_Node));\n+      if Is_Entity_Name (Name (Exp_Node)) then\n+         Function_Id := Entity (Name (Exp_Node));\n \n-         --  In the case of an explicitly dereferenced call, use the subprogram\n-         --  type generated for the dereference.\n+      --  In the case of an explicitly dereferenced call, use the subprogram\n+      --  type generated for the dereference.\n \n-         elsif Nkind (Name (Exp_Node)) = N_Explicit_Dereference then\n-            Function_Id := Etype (Name (Exp_Node));\n+      elsif Nkind (Name (Exp_Node)) = N_Explicit_Dereference then\n+         Function_Id := Etype (Name (Exp_Node));\n \n-         --  This may be a call to a protected function.\n+      --  This may be a call to a protected function.\n \n-         elsif Nkind (Name (Exp_Node)) = N_Selected_Component then\n-            Function_Id := Etype (Entity (Selector_Name (Name (Exp_Node))));\n+      elsif Nkind (Name (Exp_Node)) = N_Selected_Component then\n+         Function_Id := Etype (Entity (Selector_Name (Name (Exp_Node))));\n \n-         else\n-            raise Program_Error;\n-         end if;\n-\n-         return Is_Build_In_Place_Function (Function_Id);\n+      else\n+         raise Program_Error;\n       end if;\n+\n+      declare\n+         Result : constant Boolean := Is_Build_In_Place_Function (Function_Id);\n+      begin\n+         return Result;\n+      end;\n    end Is_Build_In_Place_Function_Call;\n \n    -----------------------\n@@ -7693,16 +7713,9 @@ package body Exp_Ch6 is\n          Func_Call := Expression (Func_Call);\n       end if;\n \n-      --  If the call has already been processed to add build-in-place actuals\n-      --  then return. This should not normally occur in an allocator context,\n-      --  but we add the protection as a defensive measure.\n-\n-      if Is_Expanded_Build_In_Place_Call (Func_Call) then\n-         return;\n-      end if;\n-\n       --  Mark the call as processed as a build-in-place call\n \n+      pragma Assert (not Is_Expanded_Build_In_Place_Call (Func_Call));\n       Set_Is_Expanded_Build_In_Place_Call (Func_Call);\n \n       Loc := Sloc (Function_Call);\n@@ -7727,6 +7740,8 @@ package body Exp_Ch6 is\n \n       Return_Obj_Access := Make_Temporary (Loc, 'R');\n       Set_Etype (Return_Obj_Access, Acc_Type);\n+      Set_Can_Never_Be_Null (Acc_Type, False);\n+      --  It gets initialized to null, so we can't have that.\n \n       --  When the result subtype is constrained, the return object is\n       --  allocated on the caller side, and access to it is passed to the\n@@ -7738,7 +7753,6 @@ package body Exp_Ch6 is\n       --  the characteristics of the full view.\n \n       if Is_Constrained (Underlying_Type (Result_Subt)) then\n-\n          --  Replace the initialized allocator of form \"new T'(Func (...))\"\n          --  with an uninitialized allocator of form \"new T\", where T is the\n          --  result subtype of the called function. The call to the function\n@@ -8051,7 +8065,7 @@ package body Exp_Ch6 is\n       Lhs          : constant Node_Id := Name (Assign);\n       Func_Call    : constant Node_Id := Unqual_Conv (Function_Call);\n       Func_Id      : Entity_Id;\n-      Loc          : Source_Ptr;\n+      Loc          : constant Source_Ptr := Sloc (Function_Call);\n       Obj_Decl     : Node_Id;\n       Obj_Id       : Entity_Id;\n       Ptr_Typ      : Entity_Id;\n@@ -8060,20 +8074,11 @@ package body Exp_Ch6 is\n       Result_Subt  : Entity_Id;\n \n    begin\n-      --  If the call has already been processed to add build-in-place actuals\n-      --  then return. This should not normally occur in an assignment context,\n-      --  but we add the protection as a defensive measure.\n-\n-      if Is_Expanded_Build_In_Place_Call (Func_Call) then\n-         return;\n-      end if;\n-\n       --  Mark the call as processed as a build-in-place call\n \n+      pragma Assert (not Is_Expanded_Build_In_Place_Call (Func_Call));\n       Set_Is_Expanded_Build_In_Place_Call (Func_Call);\n \n-      Loc := Sloc (Function_Call);\n-\n       if Is_Entity_Name (Name (Func_Call)) then\n          Func_Id := Entity (Name (Func_Call));\n \n@@ -8131,6 +8136,13 @@ package body Exp_Ch6 is\n \n       New_Expr := Make_Reference (Loc, Relocate_Node (Func_Call));\n \n+      --  Add a conversion if it's the wrong type\n+\n+      if Etype (New_Expr) /= Ptr_Typ then\n+         New_Expr := Make_Unchecked_Type_Conversion (Loc,\n+           New_Occurrence_Of (Ptr_Typ, Loc), New_Expr);\n+      end if;\n+\n       Obj_Id := Make_Temporary (Loc, 'R', New_Expr);\n       Set_Etype (Obj_Id, Ptr_Typ);\n       Set_Is_Known_Non_Null (Obj_Id);\n@@ -8165,23 +8177,17 @@ package body Exp_Ch6 is\n       Func_Call       : constant Node_Id := Unqual_Conv (Function_Call);\n       Function_Id     : Entity_Id;\n       Pool_Actual     : Node_Id;\n+      Designated_Type : Entity_Id;\n       Ptr_Typ         : Entity_Id;\n       Ptr_Typ_Decl    : Node_Id;\n       Pass_Caller_Acc : Boolean := False;\n       Res_Decl        : Node_Id;\n       Result_Subt     : Entity_Id;\n \n    begin\n-      --  If the call has already been processed to add build-in-place actuals\n-      --  then return. This should not normally occur in an object declaration,\n-      --  but we add the protection as a defensive measure.\n-\n-      if Is_Expanded_Build_In_Place_Call (Func_Call) then\n-         return;\n-      end if;\n-\n       --  Mark the call as processed as a build-in-place call\n \n+      pragma Assert (not Is_Expanded_Build_In_Place_Call (Func_Call));\n       Set_Is_Expanded_Build_In_Place_Call (Func_Call);\n \n       if Is_Entity_Name (Name (Func_Call)) then\n@@ -8208,6 +8214,15 @@ package body Exp_Ch6 is\n          --  access type must be declared before we establish a transient\n          --  scope, so that it receives the proper accessibility level.\n \n+         if Is_Class_Wide_Type (Etype (Defining_Identifier (Obj_Decl)))\n+           and then not Is_Interface (Etype (Defining_Identifier (Obj_Decl)))\n+           and then not Is_Class_Wide_Type (Etype (Function_Call))\n+         then\n+            Designated_Type := Etype (Defining_Identifier (Obj_Decl));\n+         else\n+            Designated_Type := Etype (Function_Call);\n+         end if;\n+\n          Ptr_Typ := Make_Temporary (Loc, 'A');\n          Ptr_Typ_Decl :=\n            Make_Full_Type_Declaration (Loc,\n@@ -8216,7 +8231,7 @@ package body Exp_Ch6 is\n                Make_Access_To_Object_Definition (Loc,\n                  All_Present        => True,\n                  Subtype_Indication =>\n-                   New_Occurrence_Of (Etype (Function_Call), Loc)));\n+                   New_Occurrence_Of (Designated_Type, Loc)));\n \n          --  The access type and its accompanying object must be inserted after\n          --  the object declaration in the constrained case, so that the\n@@ -8238,15 +8253,10 @@ package body Exp_Ch6 is\n \n          --  Force immediate freezing of Ptr_Typ because Res_Decl will be\n          --  elaborated in an inner (transient) scope and thus won't cause\n-         --  freezing by itself.\n+         --  freezing by itself. It's not an itype, but it needs to be frozen\n+         --  inside the current subprogram (see Freeze_Outside in freeze.adb).\n \n-         declare\n-            Ptr_Typ_Freeze_Ref : constant Node_Id :=\n-                                   New_Occurrence_Of (Ptr_Typ, Loc);\n-         begin\n-            Set_Parent (Ptr_Typ_Freeze_Ref, Ptr_Typ_Decl);\n-            Freeze_Expression (Ptr_Typ_Freeze_Ref);\n-         end;\n+         Freeze_Itype (Ptr_Typ, Ptr_Typ_Decl);\n \n          --  If the object is a return object of an enclosing build-in-place\n          --  function, then the implicit build-in-place parameters of the\n@@ -8424,13 +8434,25 @@ package body Exp_Ch6 is\n          Set_Etype (Def_Id, Ptr_Typ);\n          Set_Is_Known_Non_Null (Def_Id);\n \n-         Res_Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Def_Id,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n-             Expression          =>\n-               Make_Reference (Loc, Relocate_Node (Func_Call)));\n+         if Nkind (Function_Call) = N_Type_Conversion then\n+            Res_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Def_Id,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n+                Expression          =>\n+                Make_Unchecked_Type_Conversion (Loc,\n+                   New_Occurrence_Of (Ptr_Typ, Loc),\n+                   Make_Reference (Loc, Relocate_Node (Func_Call))));\n+         else\n+            Res_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Def_Id,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Occurrence_Of (Ptr_Typ, Loc),\n+                Expression          =>\n+                  Make_Reference (Loc, Relocate_Node (Func_Call)));\n+         end if;\n \n          Insert_After_And_Analyze (Ptr_Typ_Decl, Res_Decl);\n \n@@ -8475,7 +8497,8 @@ package body Exp_Ch6 is\n             Rewrite (Obj_Decl,\n               Make_Object_Renaming_Declaration (Obj_Loc,\n                 Defining_Identifier => Make_Temporary (Obj_Loc, 'D'),\n-                Subtype_Mark => New_Occurrence_Of (Result_Subt, Obj_Loc),\n+                Subtype_Mark =>\n+                  New_Occurrence_Of (Designated_Type, Obj_Loc),\n                 Name => Call_Deref));\n \n             Set_Renamed_Object (Defining_Identifier (Obj_Decl), Call_Deref);\n@@ -8495,18 +8518,6 @@ package body Exp_Ch6 is\n               (Obj_Decl, Original_Node (Obj_Decl));\n          end if;\n       end;\n-\n-      --  If the object entity has a class-wide Etype, then we need to change\n-      --  it to the result subtype of the function call, because otherwise the\n-      --  object will be class-wide without an explicit initialization and\n-      --  won't be allocated properly by the back end. It seems unclean to make\n-      --  such a revision to the type at this point, and we should try to\n-      --  improve this treatment when build-in-place functions with class-wide\n-      --  results are implemented. ???\n-\n-      if Is_Class_Wide_Type (Etype (Defining_Identifier (Obj_Decl))) then\n-         Set_Etype (Defining_Identifier (Obj_Decl), Result_Subt);\n-      end if;\n    end Make_Build_In_Place_Call_In_Object_Declaration;\n \n    -------------------------------------------------\n@@ -9225,6 +9236,11 @@ package body Exp_Ch6 is\n    --  Start of processing for Unqual_BIP_Iface_Function_Call\n \n    begin\n+      if Nkind (Expr) = N_Identifier and then No (Entity (Expr)) then\n+         --  Can happen for X'Elab_Spec in the binder-generated file.\n+         return Empty;\n+      end if;\n+\n       return Unqual_BIP_Function_Call (Expr);\n    end Unqual_BIP_Iface_Function_Call;\n "}, {"sha": "530f615b63b12a0aeadb0d0ed6755d1edcb37600", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -117,25 +117,30 @@ package Exp_Ch6 is\n    --  The returned node is the root of the procedure body which will replace\n    --  the original function body, which is not needed for the C program.\n \n+   function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-318-02): Returns True if functions returning the type use\n+   --  build-in-place protocols. For inherently limited types, this must be\n+   --  True in >= Ada 2005, and must be False in Ada 95. For other types, it\n+   --  can be True or False, and the decision should be based on efficiency,\n+   --  and should be the same for all language versions, so that mixed-dialect\n+   --  programs will work.\n+   --\n+   --  For inherently limited types in Ada 2005, True means that calls will\n+   --  actually be build-in-place in all cases. For other types, build-in-place\n+   --  will be used when possible, but we need to make a copy at the call site\n+   --  in some cases, notably assignment statements.\n+\n    function Is_Build_In_Place_Function (E : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if E denotes a function, generic\n-   --  function, or access-to-function type whose result must be built in\n-   --  place; otherwise returns False. For Ada 2005, this is currently\n-   --  restricted to the set of functions whose result subtype is an inherently\n-   --  limited type. In Ada 95, this must be False for inherently limited\n-   --  result types (but currently returns False for all Ada 95 functions).\n-   --  Eventually we plan to support build-in-place for nonlimited types.\n-   --  Build-in-place is usually more efficient for large things, and less\n-   --  efficient for small things. However, we never use build-in-place if the\n-   --  convention is other than Ada, because that would disturb mixed-language\n-   --  programs. Note that for the non-inherently-limited cases, we must make\n-   --  the same decision for Ada 95 and 2005, so that mixed-dialect programs\n-   --  will work.\n+   --  function, or access-to-function type for which\n+   --  Is_Build_In_Place_Result_Type is True. However, we never use\n+   --  build-in-place if the convention is other than Ada, because that would\n+   --  disturb mixed-language programs.\n \n    function Is_Build_In_Place_Function_Call (N : Node_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if N denotes a call to a function\n-   --  that requires handling as a build-in-place call or is a qualified\n-   --  expression applied to such a call; otherwise returns False.\n+   --  that requires handling as a build-in-place call (possibly qualified or\n+   --  converted).\n \n    function Is_Null_Procedure (Subp : Entity_Id) return Boolean;\n    --  Predicate to recognize stubbed procedures and null procedures, which\n@@ -212,7 +217,7 @@ package Exp_Ch6 is\n      (Obj_Decl      : Node_Id;\n       Function_Call : Node_Id);\n    --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n-   --  occurs as the expression initializing an object declaration by passsing\n+   --  occurs as the expression initializing an object declaration by passing\n    --  access to the declared object as an additional parameter of the function\n    --  call. Function_Call must denote an expression containing a BIP function\n    --  call and an enclosing call to Ada.Tags.Displace to displace the pointer"}, {"sha": "07fd33ce465b3ceb650ab946c67f23eda9a747f7", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -4057,7 +4057,7 @@ package body Exp_Ch7 is\n \n    --  This procedure is called each time a transient block has to be inserted\n    --  that is to say for each call to a function with unconstrained or tagged\n-   --  result. It creates a new scope on the stack scope in order to enclose\n+   --  result. It creates a new scope on the scope stack in order to enclose\n    --  all transient variables generated.\n \n    procedure Establish_Transient_Scope (N : Node_Id; Sec_Stack : Boolean) is"}, {"sha": "08c680589949a2014f479fa5d5fa19ea1065e433", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -176,23 +176,16 @@ package body Exp_Ch8 is\n \n       --  Ada 2005 (AI-318-02): If the renamed object is a call to a build-in-\n       --  place function, then a temporary return object needs to be created\n-      --  and access to it must be passed to the function. Currently we limit\n-      --  such functions to those with inherently limited result subtypes, but\n-      --  eventually we plan to expand the functions that are treated as\n-      --  build-in-place to include other composite result types.\n+      --  and access to it must be passed to the function.\n \n-      if Ada_Version >= Ada_2005\n-        and then Is_Build_In_Place_Function_Call (Nam)\n-      then\n+      if Is_Build_In_Place_Function_Call (Nam) then\n          Make_Build_In_Place_Call_In_Anonymous_Context (Nam);\n \n       --  Ada 2005 (AI-318-02): Specialization of previous case for renaming\n       --  containing build-in-place function calls whose returned object covers\n       --  interface types.\n \n-      elsif Ada_Version >= Ada_2005\n-        and then Present (Unqual_BIP_Iface_Function_Call (Nam))\n-      then\n+      elsif Present (Unqual_BIP_Iface_Function_Call (Nam)) then\n          Make_Build_In_Place_Iface_Call_In_Anonymous_Context (Nam);\n       end if;\n "}, {"sha": "97ac138e8982df36af055174686ddfdee31c7879", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -1640,9 +1640,7 @@ package body Exp_Disp is\n                --  interface conversion, so if this is a BIP call then we need\n                --  to handle it now.\n \n-               if Ada_Version >= Ada_2005\n-                 and then Is_Build_In_Place_Function_Call (Actual)\n-               then\n+               if Is_Build_In_Place_Function_Call (Actual) then\n                   Make_Build_In_Place_Call_In_Anonymous_Context (Actual);\n                end if;\n "}, {"sha": "1d64a3add3453dcea4d32e54e217afc5da17c847", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -649,7 +649,11 @@ package body Exp_Util is\n       --  Do not process allocations on / deallocations from the secondary\n       --  stack.\n \n-      elsif Is_RTE (Pool_Id, RE_SS_Pool) then\n+      elsif Is_RTE (Pool_Id, RE_SS_Pool)\n+        or else\n+          (Nkind (Expr) = N_Allocator\n+             and then Is_RTE (Storage_Pool (Expr), RE_SS_Pool))\n+      then\n          return;\n \n       --  Optimize the case where we are using the default Global_Pool_Object,\n@@ -7857,6 +7861,8 @@ package body Exp_Util is\n             Call := Prefix (Call);\n          end if;\n \n+         Call := Unqual_Conv (Call);\n+\n          if Is_Build_In_Place_Function_Call (Call) then\n             declare\n                Access_Nam : Name_Id := No_Name;\n@@ -8679,9 +8685,7 @@ package body Exp_Util is\n \n          Param := First (Parameter_Associations (Call));\n          while Present (Param) loop\n-            if Nkind (Param) = N_Parameter_Association\n-              and then Nkind (Selector_Name (Param)) = N_Identifier\n-            then\n+            if Nkind (Param) = N_Parameter_Association then\n                Formal := Selector_Name (Param);\n                Actual := Explicit_Actual_Parameter (Param);\n "}, {"sha": "0c4dfdf391029bc7e1ee2733c3af25961cdfe74b", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -1372,9 +1372,9 @@ package Sinfo is\n    --    up. For nested aggregates the expansion is delayed until the enclosing\n    --    aggregate itself is expanded, e.g. in the context of a declaration. To\n    --    delay it we set this flag. This is done to avoid creating a temporary\n-   --    for each level of a nested aggregates, and also to prevent the\n+   --    for each level of a nested aggregate, and also to prevent the\n    --    premature generation of constraint checks. This is also a requirement\n-   --    if we want to generate the proper attachment to the internal\n+   --    if we want to generate the proper attachment to the internal????\n    --    finalization lists (for record with controlled components). Top down\n    --    expansion of aggregates is also used for in-place array aggregate\n    --    assignment or initialization. When the full context is known, the\n@@ -2917,7 +2917,7 @@ package Sinfo is\n       --  case the front end must generate an extra temporary and initialize\n       --  this temporary as required (the temporary itself is not atomic).\n \n-      --  Note: there is not node kind for object definition. Instead, the\n+      --  Note: there is no node kind for object definition. Instead, the\n       --  corresponding field holds a subtype indication, an array type\n       --  definition, or (Ada 2005, AI-406) an access definition.\n "}, {"sha": "5fcf365b05894473179ae28d37a4f1a8c8e32bf7", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4dfb0056252fbc272a0b15fb9f9697deab3f954/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=d4dfb0056252fbc272a0b15fb9f9697deab3f954", "patch": "@@ -328,7 +328,7 @@ package Snames is\n \n    --  Operator Symbol entries. The actual names have an upper case O at the\n    --  start in place of the Op_ prefix (e.g. the actual name that corresponds\n-   --  to Name_Op_Abs is \"Oabs\".\n+   --  to Name_Op_Abs is \"Oabs\").\n \n    First_Operator_Name                 : constant Name_Id := N + $;\n    Name_Op_Abs                         : constant Name_Id := N + $; -- \"abs\""}]}