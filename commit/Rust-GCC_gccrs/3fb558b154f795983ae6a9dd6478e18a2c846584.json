{"sha": "3fb558b154f795983ae6a9dd6478e18a2c846584", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZiNTU4YjE1NGY3OTU5ODNhZTZhOWRkNjQ3OGUxOGEyYzg0NjU4NA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2018-08-20T12:39:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2018-08-20T12:39:36Z"}, "message": "[PATCH] #assert becomes macro-like\n\nhttps://gcc.gnu.org/ml/gcc-patches/2018-08/msg01140.html\n\tlibcpp/\n\t* include/cpp-id-data.h (struct answer): Delete.\n\t* include/cpplib.h (struct answer): Don't forward-declare.\n\t(enum cpp_macro_kind): Add cmk_assert.\n\t(struct cpp_macro): Union parms and next assert chain.\n\t(union _cpp_hashnode_value): 'answer' field is cpp_macro.\n\t* directives.c (parse_answer): Convert to use cpp_macro. Return\n\ttrue on success. \n\t(parse_assertion, find_answer, _cpp_test_assertion, cpp_do_assert)\n\t(cpp_do_unassert): Convert to use cpp_macro.\n\t* macro.c (warn_of_redefinition, _cpp_new_macro)\n\t(check_trad_stringification, cpp_macro_definition): Adjust macro\n\tparm access.\n\t* traditional.c (_cpp_replacement_text_len)\n\t(_cpp_copy_replacement_text, _cpp_create_trad_definition): Likewise.\n\tgcc/c-family/\n\t* c-ada-spec.c (macro_length, dump_ada_macros): Adjust macro parm\n\taccess.\n\nFrom-SVN: r263658", "tree": {"sha": "2c06bad74d6dafddb11979c263020425a716902c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c06bad74d6dafddb11979c263020425a716902c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fb558b154f795983ae6a9dd6478e18a2c846584", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb558b154f795983ae6a9dd6478e18a2c846584", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fb558b154f795983ae6a9dd6478e18a2c846584", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb558b154f795983ae6a9dd6478e18a2c846584/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b655b8fc7eb4af02231fa0105dddd90a8cfceea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b655b8fc7eb4af02231fa0105dddd90a8cfceea1"}], "stats": {"total": 254, "additions": 129, "deletions": 125}, "files": [{"sha": "9ff4728fd67bac1a68439577b846d32bbfcd547e", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb558b154f795983ae6a9dd6478e18a2c846584/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb558b154f795983ae6a9dd6478e18a2c846584/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3fb558b154f795983ae6a9dd6478e18a2c846584", "patch": "@@ -1,3 +1,8 @@\n+2018-08-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* c-ada-spec.c (macro_length, dump_ada_macros): Adjust macro parm\n+\taccess.\n+\n 2018-08-17  Nathan Sidwell  <nathan@acm.org>\n \n \t* c-cppbuiltin.c (struct lazy_hex_fp_value_struct): Remove macro"}, {"sha": "5e0dea4aa9d6b92fa4d522b176fc42ca0006772c", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb558b154f795983ae6a9dd6478e18a2c846584/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb558b154f795983ae6a9dd6478e18a2c846584/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=3fb558b154f795983ae6a9dd6478e18a2c846584", "patch": "@@ -69,7 +69,7 @@ macro_length (const cpp_macro *macro, int *supported, int *buffer_len,\n       (*param_len)++;\n       for (i = 0; i < macro->paramc; i++)\n \t{\n-\t  cpp_hashnode *param = macro->params[i];\n+\t  cpp_hashnode *param = macro->parm.params[i];\n \n \t  *param_len += NODE_LEN (param);\n \n@@ -101,7 +101,7 @@ macro_length (const cpp_macro *macro, int *supported, int *buffer_len,\n \n       if (token->type == CPP_MACRO_ARG)\n \t*buffer_len +=\n-\t  NODE_LEN (macro->params[token->val.macro_arg.arg_no - 1]);\n+\t  NODE_LEN (macro->parm.params[token->val.macro_arg.arg_no - 1]);\n       else\n \t/* Include enough extra space to handle e.g. special characters.  */\n \t*buffer_len += (cpp_token_len (token) + 1) * 8;\n@@ -252,7 +252,7 @@ dump_ada_macros (pretty_printer *pp, const char* file)\n \t      *buf_param++ = '(';\n \t      for (i = 0; i < macro->paramc; i++)\n \t\t{\n-\t\t  cpp_hashnode *param = macro->params[i];\n+\t\t  cpp_hashnode *param = macro->parm.params[i];\n \n \t\t  memcpy (buf_param, NODE_NAME (param), NODE_LEN (param));\n \t\t  buf_param += NODE_LEN (param);\n@@ -291,7 +291,7 @@ dump_ada_macros (pretty_printer *pp, const char* file)\n \t\t  case CPP_MACRO_ARG:\n \t\t    {\n \t\t      cpp_hashnode *param =\n-\t\t\tmacro->params[token->val.macro_arg.arg_no - 1];\n+\t\t\tmacro->parm.params[token->val.macro_arg.arg_no - 1];\n \t\t      memcpy (buffer, NODE_NAME (param), NODE_LEN (param));\n \t\t      buffer += NODE_LEN (param);\n \t\t    }"}, {"sha": "2e347db4556bc91a4d6ffa68322aaed152b69322", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=3fb558b154f795983ae6a9dd6478e18a2c846584", "patch": "@@ -1,3 +1,20 @@\n+2018-08-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* include/cpp-id-data.h (struct answer): Delete.\n+\t* include/cpplib.h (struct answer): Don't forward-declare.\n+\t(enum cpp_macro_kind): Add cmk_assert.\n+\t(struct cpp_macro): Union parms and next assert chain.\n+\t(union _cpp_hashnode_value): 'answer' field is cpp_macro.\n+\t* directives.c (parse_answer): Convert to use cpp_macro. Return\n+\ttrue on success. \n+\t(parse_assertion, find_answer, _cpp_test_assertion, cpp_do_assert)\n+\t(cpp_do_unassert): Convert to use cpp_macro.\n+\t* macro.c (warn_of_redefinition, _cpp_new_macro)\n+\t(check_trad_stringification, cpp_macro_definition): Adjust macro\n+\tparm access.\n+\t* traditional.c (_cpp_replacement_text_len)\n+\t(_cpp_copy_replacement_text, _cpp_create_trad_definition): Likewise.\n+\n 2018-08-17  Nathan Sidwell  <nathan@acm.org>\n \n \t* include/cpplib.h (struct cpp_callbacks): Replace"}, {"sha": "e75462f1c0d6460b2e18a52e7a0040f7390e44bc", "filename": "libcpp/directives.c", "status": "modified", "additions": 76, "deletions": 94, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=3fb558b154f795983ae6a9dd6478e18a2c846584", "patch": "@@ -124,9 +124,9 @@ static const cpp_token *get_token_no_padding (cpp_reader *);\n static const cpp_token *get__Pragma_string (cpp_reader *);\n static void destringize_and_run (cpp_reader *, const cpp_string *,\n \t\t\t\t source_location);\n-static int parse_answer (cpp_reader *, struct answer **, int, source_location);\n-static cpp_hashnode *parse_assertion (cpp_reader *, struct answer **, int);\n-static struct answer ** find_answer (cpp_hashnode *, const struct answer *);\n+static bool parse_answer (cpp_reader *, int, source_location, cpp_macro **);\n+static cpp_hashnode *parse_assertion (cpp_reader *, int, cpp_macro **);\n+static cpp_macro **find_answer (cpp_hashnode *, const cpp_macro *);\n static void handle_assertion (cpp_reader *, const char *, int);\n static void do_pragma_push_macro (cpp_reader *);\n static void do_pragma_pop_macro (cpp_reader *);\n@@ -2149,17 +2149,13 @@ push_conditional (cpp_reader *pfile, int skip, int type,\n    storage, i.e. the #assert case.  Returns 0 on success, and sets\n    ANSWERP to point to the answer.  PRED_LOC is the location of the\n    predicate.  */\n-static int\n-parse_answer (cpp_reader *pfile, struct answer **answerp, int type,\n-\t      source_location pred_loc)\n+static bool\n+parse_answer (cpp_reader *pfile, int type, source_location pred_loc,\n+\t      cpp_macro **answer_ptr)\n {\n-  const cpp_token *paren;\n-  struct answer *answer;\n-  unsigned int acount;\n-\n   /* In a conditional, it is legal to not have an open paren.  We\n      should save the following token in this case.  */\n-  paren = cpp_get_token (pfile);\n+  const cpp_token *paren = cpp_get_token (pfile);\n \n   /* If not a paren, see if we're OK.  */\n   if (paren->type != CPP_OPEN_PAREN)\n@@ -2169,81 +2165,78 @@ parse_answer (cpp_reader *pfile, struct answer **answerp, int type,\n       if (type == T_IF)\n \t{\n \t  _cpp_backup_tokens (pfile, 1);\n-\t  return 0;\n+\t  return true;\n \t}\n \n       /* #unassert with no answer is valid - it removes all answers.  */\n       if (type == T_UNASSERT && paren->type == CPP_EOF)\n-\treturn 0;\n+\treturn true;\n \n       cpp_error_with_line (pfile, CPP_DL_ERROR, pred_loc, 0,\n \t\t\t   \"missing '(' after predicate\");\n-      return 1;\n+      return false;\n     }\n \n-  for (acount = 0;; acount++)\n+  cpp_macro *answer = _cpp_new_macro (pfile, cmk_assert,\n+\t\t\t\t      _cpp_reserve_room (pfile, 0,\n+\t\t\t\t\t\t\t sizeof (cpp_macro)));\n+  answer->parm.next = NULL;\n+  unsigned count = 0;\n+  for (;;)\n     {\n-      size_t room_needed;\n       const cpp_token *token = cpp_get_token (pfile);\n-      cpp_token *dest;\n \n       if (token->type == CPP_CLOSE_PAREN)\n \tbreak;\n \n       if (token->type == CPP_EOF)\n \t{\n \t  cpp_error (pfile, CPP_DL_ERROR, \"missing ')' to complete answer\");\n-\t  return 1;\n+\t  return false;\n \t}\n \n-      /* struct answer includes the space for one token.  */\n-      room_needed = (sizeof (struct answer) + acount * sizeof (cpp_token));\n-\n-      if (BUFF_ROOM (pfile->a_buff) < room_needed)\n-\t_cpp_extend_buff (pfile, &pfile->a_buff, sizeof (struct answer));\n-\n-      dest = &((struct answer *) BUFF_FRONT (pfile->a_buff))->first[acount];\n-      *dest = *token;\n-\n-      /* Drop whitespace at start, for answer equivalence purposes.  */\n-      if (acount == 0)\n-\tdest->flags &= ~PREV_WHITE;\n+      answer = (cpp_macro *)_cpp_reserve_room\n+\t(pfile, sizeof (cpp_macro) + count * sizeof (cpp_token),\n+\t sizeof (cpp_token));\n+      answer->exp.tokens[count++] = *token;\n     }\n \n-  if (acount == 0)\n+  if (!count)\n     {\n       cpp_error (pfile, CPP_DL_ERROR, \"predicate's answer is empty\");\n-      return 1;\n+      return false;\n     }\n \n-  answer = (struct answer *) BUFF_FRONT (pfile->a_buff);\n-  answer->count = acount;\n-  answer->next = NULL;\n-  *answerp = answer;\n+  /* Drop whitespace at start, for answer equivalence purposes.  */\n+  answer->exp.tokens[0].flags &= ~PREV_WHITE;\n \n-  return 0;\n+  answer->count = count;\n+  *answer_ptr = answer;\n+\n+  return true;\n }\n \n /* Parses an assertion directive of type TYPE, returning a pointer to\n    the hash node of the predicate, or 0 on error.  If an answer was\n-   supplied, it is placed in ANSWERP, otherwise it is set to 0.  */\n+   supplied, it is placed in EXP_PTR & EXP_COUNT, which is otherwise\n+   set to 0.  */\n static cpp_hashnode *\n-parse_assertion (cpp_reader *pfile, struct answer **answerp, int type)\n+parse_assertion (cpp_reader *pfile, int type, cpp_macro **answer_ptr)\n {\n   cpp_hashnode *result = 0;\n-  const cpp_token *predicate;\n \n   /* We don't expand predicates or answers.  */\n   pfile->state.prevent_expansion++;\n \n-  *answerp = 0;\n-  predicate = cpp_get_token (pfile);\n+  *answer_ptr = NULL;\n+\n+  const cpp_token *predicate = cpp_get_token (pfile);\n   if (predicate->type == CPP_EOF)\n     cpp_error (pfile, CPP_DL_ERROR, \"assertion without predicate\");\n   else if (predicate->type != CPP_NAME)\n     cpp_error_with_line (pfile, CPP_DL_ERROR, predicate->src_loc, 0,\n \t\t\t \"predicate must be an identifier\");\n-  else if (parse_answer (pfile, answerp, type, predicate->src_loc) == 0)\n+  else if (parse_answer (pfile, type, predicate->src_loc, answer_ptr))\n     {\n       unsigned int len = NODE_LEN (predicate->val.node.node);\n       unsigned char *sym = (unsigned char *) alloca (len + 1);\n@@ -2255,25 +2248,27 @@ parse_assertion (cpp_reader *pfile, struct answer **answerp, int type)\n     }\n \n   pfile->state.prevent_expansion--;\n+\n   return result;\n }\n \n /* Returns a pointer to the pointer to CANDIDATE in the answer chain,\n    or a pointer to NULL if the answer is not in the chain.  */\n-static struct answer **\n-find_answer (cpp_hashnode *node, const struct answer *candidate)\n+static cpp_macro **\n+find_answer (cpp_hashnode *node, const cpp_macro *candidate)\n {\n   unsigned int i;\n-  struct answer **result;\n+  cpp_macro **result = NULL;\n \n-  for (result = &node->value.answers; *result; result = &(*result)->next)\n+  for (result = &node->value.answers; *result; result = &(*result)->parm.next)\n     {\n-      struct answer *answer = *result;\n+      cpp_macro *answer = *result;\n \n       if (answer->count == candidate->count)\n \t{\n \t  for (i = 0; i < answer->count; i++)\n-\t    if (! _cpp_equiv_tokens (&answer->first[i], &candidate->first[i]))\n+\t    if (!_cpp_equiv_tokens (&answer->exp.tokens[i],\n+\t\t\t\t    &candidate->exp.tokens[i]))\n \t      break;\n \n \t  if (i == answer->count)\n@@ -2290,18 +2285,18 @@ find_answer (cpp_hashnode *node, const struct answer *candidate)\n int\n _cpp_test_assertion (cpp_reader *pfile, unsigned int *value)\n {\n-  struct answer *answer;\n-  cpp_hashnode *node;\n-\n-  node = parse_assertion (pfile, &answer, T_IF);\n+  cpp_macro *answer;\n+  cpp_hashnode *node = parse_assertion (pfile, T_IF, &answer);\n \n   /* For recovery, an erroneous assertion expression is handled as a\n      failing assertion.  */\n   *value = 0;\n \n   if (node)\n-    *value = (node->type == NT_ASSERTION &&\n-\t      (answer == 0 || *find_answer (node, answer) != 0));\n+    {\n+      if (node->type == NT_ASSERTION)\n+\t*value = !answer || *find_answer (node, answer);\n+    }\n   else if (pfile->cur_token[-1].type == CPP_EOF)\n     _cpp_backup_tokens (pfile, 1);\n \n@@ -2313,43 +2308,31 @@ _cpp_test_assertion (cpp_reader *pfile, unsigned int *value)\n static void\n do_assert (cpp_reader *pfile)\n {\n-  struct answer *new_answer;\n-  cpp_hashnode *node;\n+  cpp_macro *answer;\n+  cpp_hashnode *node = parse_assertion (pfile, T_ASSERT, &answer);\n \n-  node = parse_assertion (pfile, &new_answer, T_ASSERT);\n   if (node)\n     {\n-      size_t answer_size;\n-\n       /* Place the new answer in the answer list.  First check there\n          is not a duplicate.  */\n-      new_answer->next = 0;\n-      if (node->type == NT_ASSERTION)\n+      if (node->type == NT_ASSERTION && *find_answer (node, answer))\n \t{\n-\t  if (*find_answer (node, new_answer))\n-\t    {\n-\t      cpp_error (pfile, CPP_DL_WARNING, \"\\\"%s\\\" re-asserted\",\n-\t\t\t NODE_NAME (node) + 1);\n-\t      return;\n-\t    }\n-\t  new_answer->next = node->value.answers;\n+\t  cpp_error (pfile, CPP_DL_WARNING, \"\\\"%s\\\" re-asserted\",\n+\t\t     NODE_NAME (node) + 1);\n+\t  return;\n \t}\n \n-      answer_size = sizeof (struct answer) + ((new_answer->count - 1)\n-\t\t\t\t\t      * sizeof (cpp_token));\n-      /* Commit or allocate storage for the object.  */\n-      if (pfile->hash_table->alloc_subobject)\n-\t{\n-\t  struct answer *temp_answer = new_answer;\n-\t  new_answer = (struct answer *) pfile->hash_table->alloc_subobject\n-            (answer_size);\n-\t  memcpy (new_answer, temp_answer, answer_size);\n-\t}\n-      else\n-\tBUFF_FRONT (pfile->a_buff) += answer_size;\n+      /* Commit or allocate storage for the answer.  */\n+      answer = (cpp_macro *)_cpp_commit_buff\n+\t(pfile, sizeof (cpp_macro) - sizeof (cpp_token)\n+\t + sizeof (cpp_token) * answer->count);\n+\n+      if (node->type == NT_ASSERTION)\n+\tanswer->parm.next = node->value.answers;\n \n       node->type = NT_ASSERTION;\n-      node->value.answers = new_answer;\n+      node->value.answers = answer;\n+\n       check_eol (pfile, false);\n     }\n }\n@@ -2358,25 +2341,24 @@ do_assert (cpp_reader *pfile)\n static void\n do_unassert (cpp_reader *pfile)\n {\n-  cpp_hashnode *node;\n-  struct answer *answer;\n+  cpp_macro *answer;\n+  cpp_hashnode *node = parse_assertion (pfile, T_UNASSERT, &answer);\n \n-  node = parse_assertion (pfile, &answer, T_UNASSERT);\n   /* It isn't an error to #unassert something that isn't asserted.  */\n   if (node && node->type == NT_ASSERTION)\n     {\n       if (answer)\n \t{\n-\t  struct answer **p = find_answer (node, answer), *temp;\n-\n-\t  /* Remove the answer from the list.  */\n-\t  temp = *p;\n-\t  if (temp)\n-\t    *p = temp->next;\n+\t  cpp_macro **p = find_answer (node, answer);\n \n-\t  /* Did we free the last answer?  */\n-\t  if (node->value.answers == 0)\n-\t    node->type = NT_VOID;\n+\t  /* Remove the assert from the list.  */\n+\t  if (cpp_macro *temp = *p)\n+\t    {\n+\t      *p = temp->parm.next;\n+\t      /* Did we free the last answer?  */\n+\t      if (!*p)\n+\t\tnode->type = NT_VOID;\n+\t    }\n \n \t  check_eol (pfile, false);\n \t}"}, {"sha": "909f8286a0934fe7cd05bb8f25d849d17c1ffe4d", "filename": "libcpp/include/cpp-id-data.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Finclude%2Fcpp-id-data.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Finclude%2Fcpp-id-data.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpp-id-data.h?ref=3fb558b154f795983ae6a9dd6478e18a2c846584", "patch": "@@ -17,10 +17,3 @@ along with this program; see the file COPYING3.  If not see\n \n #include \"cpplib.h\"\n \n-/* Chained list of answers to an assertion.  */\n-struct GTY(()) answer {\n-  struct answer *next;\n-  unsigned int count;\n-  cpp_token GTY ((length (\"%h.count\"))) first[1];\n-};\n-"}, {"sha": "d446fb1e48c1441fc94f6ff416c5644eaeeee6ab", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=3fb558b154f795983ae6a9dd6478e18a2c846584", "patch": "@@ -36,7 +36,6 @@ typedef struct cpp_macro cpp_macro;\n typedef struct cpp_callbacks cpp_callbacks;\n typedef struct cpp_dir cpp_dir;\n \n-struct answer;\n struct _cpp_file;\n \n /* The first three groups, apart from '=', can appear in preprocessor\n@@ -674,25 +673,33 @@ struct cpp_dir\n /* The kind of the cpp_macro.  */\n enum cpp_macro_kind {\n   cmk_macro,\t/* An ISO macro (token expansion).  */\n+  cmk_assert,   /* An assertion.  */\n   cmk_traditional,\t/* A traditional macro (text expansion).  */\n };\n \n /* Each macro definition is recorded in a cpp_macro structure.\n    Variadic macros cannot occur with traditional cpp.  */\n struct GTY(()) cpp_macro {\n-  /* Parameters, if any.  If parameter names use extended identifiers,\n-     the original spelling of those identifiers, not the canonical\n-     UTF-8 spelling, goes here.  */\n-  cpp_hashnode ** GTY ((nested_ptr (union tree_node,\n-\t\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n-\t\t\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\"),\n-\t\t\tlength (\"%h.paramc\")))\n-    params;\n+  union cpp_parm_u \n+  {\n+    /* Parameters, if any.  If parameter names use extended identifiers,\n+       the original spelling of those identifiers, not the canonical\n+       UTF-8 spelling, goes here.  */\n+    cpp_hashnode ** GTY ((tag (\"false\"),\n+\t\t\t  nested_ptr (union tree_node,\n+\t\"%h ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT (%h)) : NULL\",\n+\t\"%h ? HT_IDENT_TO_GCC_IDENT (HT_NODE (%h)) : NULL\"),\n+\t\t\t  length (\"%1.paramc\"))) params;\n+\n+    /* If this is an assertion, the next one in the chain.  */\n+    cpp_macro *GTY ((tag (\"true\"))) next;\n+  } GTY ((desc (\"%1.kind == cmk_assert\"))) parm;\n \n   /* Definition line number.  */\n   source_location line;\n \n-  /* Number of tokens in expansion, or bytes for traditional macros.  */\n+  /* Number of tokens in body, or bytes for traditional macros.  */\n+  /* Do we really need 2^32-1 range here?  */\n   unsigned int count;\n \n   /* Number of parameters.  */\n@@ -814,7 +821,7 @@ union GTY(()) _cpp_hashnode_value {\n   /* If a macro.  */\n   cpp_macro * GTY((tag (\"NTV_MACRO\"))) macro;\n   /* Answers to an assertion.  */\n-  struct answer * GTY ((tag (\"NTV_ANSWER\"))) answers;\n+  cpp_macro * GTY ((tag (\"NTV_ANSWER\"))) answers;\n   /* Code for a builtin macro.  */\n   enum cpp_builtin_type GTY ((tag (\"NTV_BUILTIN\"))) builtin;\n   /* Macro argument index.  */"}, {"sha": "0f9e25d3b98f773efc1ae315a187fde5046caaae", "filename": "libcpp/macro.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=3fb558b154f795983ae6a9dd6478e18a2c846584", "patch": "@@ -3017,7 +3017,7 @@ warn_of_redefinition (cpp_reader *pfile, cpp_hashnode *node,\n \n   /* Check parameter spellings.  */\n   for (i = 0; i < macro1->paramc; i++)\n-    if (macro1->params[i] != macro2->params[i])\n+    if (macro1->parm.params[i] != macro2->parm.params[i])\n       return true;\n \n   /* Check the replacement text or tokens.  */\n@@ -3326,7 +3326,7 @@ create_iso_definition (cpp_reader *pfile)\n     {\n       macro->variadic = varadic;\n       macro->paramc = nparms;\n-      macro->params = params;\n+      macro->parm.params = params;\n       macro->fun_like = true;\n     }\n   else\n@@ -3472,7 +3472,7 @@ _cpp_new_macro (cpp_reader *pfile, cpp_macro_kind kind, void *placement)\n   cpp_macro *macro = (cpp_macro *) placement;\n \n   macro->line = pfile->directive_line;\n-  macro->params = 0;\n+  macro->parm.params = 0;\n   macro->lazy = 0;\n   macro->paramc = 0;\n   macro->variadic = 0;\n@@ -3618,7 +3618,7 @@ check_trad_stringification (cpp_reader *pfile, const cpp_macro *macro,\n \t identifier inside the string matches one of them.  */\n       for (i = 0; i < macro->paramc; i++)\n \t{\n-\t  const cpp_hashnode *node = macro->params[i];\n+\t  const cpp_hashnode *node = macro->parm.params[i];\n \n \t  if (NODE_LEN (node) == len\n \t      && !memcmp (p, NODE_NAME (node), len))\n@@ -3663,7 +3663,7 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n       len += 4;\t\t/* \"()\" plus possible final \"..\" of named\n \t\t\t   varargs (we have + 1 below).  */\n       for (i = 0; i < macro->paramc; i++)\n-\tlen += NODE_LEN (macro->params[i]) + 1; /* \",\" */\n+\tlen += NODE_LEN (macro->parm.params[i]) + 1; /* \",\" */\n     }\n \n   /* This should match below where we fill in the buffer.  */\n@@ -3707,7 +3707,7 @@ cpp_macro_definition (cpp_reader *pfile, cpp_hashnode *node)\n       *buffer++ = '(';\n       for (i = 0; i < macro->paramc; i++)\n \t{\n-\t  cpp_hashnode *param = macro->params[i];\n+\t  cpp_hashnode *param = macro->parm.params[i];\n \n \t  if (param != pfile->spec_nodes.n__VA_ARGS__)\n \t    {"}, {"sha": "0c42b25d1992ca58d12442db06b18b9dd8f35805", "filename": "libcpp/traditional.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fb558b154f795983ae6a9dd6478e18a2c846584/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=3fb558b154f795983ae6a9dd6478e18a2c846584", "patch": "@@ -918,7 +918,7 @@ _cpp_replacement_text_len (const cpp_macro *macro)\n \t  len += b->text_len;\n \t  if (b->arg_index == 0)\n \t    break;\n-\t  len += NODE_LEN (macro->params[b->arg_index - 1]);\n+\t  len += NODE_LEN (macro->parm.params[b->arg_index - 1]);\n \t  exp += BLOCK_LEN (b->text_len);\n \t}\n     }\n@@ -947,7 +947,7 @@ _cpp_copy_replacement_text (const cpp_macro *macro, uchar *dest)\n \t  dest += b->text_len;\n \t  if (b->arg_index == 0)\n \t    break;\n-\t  param = macro->params[b->arg_index - 1];\n+\t  param = macro->parm.params[b->arg_index - 1];\n \t  memcpy (dest, NODE_NAME (param), NODE_LEN (param));\n \t  dest += NODE_LEN (param);\n \t  exp += BLOCK_LEN (b->text_len);\n@@ -1210,7 +1210,7 @@ _cpp_create_trad_definition (cpp_reader *pfile)\n     {\n       macro = _cpp_new_macro (pfile, cmk_traditional,\n \t\t\t      _cpp_aligned_alloc (pfile, sizeof (cpp_macro)));\n-      macro->params = params;\n+      macro->parm.params = params;\n       macro->paramc = nparms;\n       macro->fun_like = fun_like != 0;\n     }"}]}