{"sha": "0ae9bd2715d973460bbf600ca7371add571e3508", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFlOWJkMjcxNWQ5NzM0NjBiYmY2MDBjYTczNzFhZGQ1NzFlMzUwOA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2015-06-25T16:38:31Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2015-06-25T16:38:31Z"}, "message": "array-notation-common.c: Use VAR_P throughout.\n\n\t* array-notation-common.c: Use VAR_P throughout.\n\t* c-ada-spec.c: Likewise.\n\t* c-common.c: Likewise.\n\t* c-format.c: Likewise.\n\t* c-gimplify.c: Likewise.\n\t* c-omp.c: Likewise.\n\t* c-pragma.c: Likewise.\n\t* c-pretty-print.c: Likewise.\n\t* cilk.c: Likewise.\n\n\t* c-array-notation.c: Use VAR_P throughout.\n\t* c-decl.c: Likewise.\n\t* c-objc-common.c: Likewise.\n\t* c-parser.c: Likewise.\n\t* c-typeck.c: Likewise.\n\nFrom-SVN: r224949", "tree": {"sha": "c06da7c9c228125d82710e24882cf0f1975caa4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c06da7c9c228125d82710e24882cf0f1975caa4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ae9bd2715d973460bbf600ca7371add571e3508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae9bd2715d973460bbf600ca7371add571e3508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae9bd2715d973460bbf600ca7371add571e3508", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae9bd2715d973460bbf600ca7371add571e3508/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eee335102e36d60367366895729a48b1a24fb23c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eee335102e36d60367366895729a48b1a24fb23c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eee335102e36d60367366895729a48b1a24fb23c"}], "stats": {"total": 175, "additions": 95, "deletions": 80}, "files": [{"sha": "e2a2d7610a3a6177513b436c5160e0c8b9efc637", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -1,3 +1,15 @@\n+2015-06-25  Marek Polacek  <polacek@redhat.com>\n+\n+\t* array-notation-common.c: Use VAR_P throughout.\n+\t* c-ada-spec.c: Likewise.\n+\t* c-common.c: Likewise.\n+\t* c-format.c: Likewise.\n+\t* c-gimplify.c: Likewise.\n+\t* c-omp.c: Likewise.\n+\t* c-pragma.c: Likewise.\n+\t* c-pretty-print.c: Likewise.\n+\t* cilk.c: Likewise.\n+\n 2015-06-25  Marek Polacek  <polacek@redhat.com>\n \n \t* cilk.c (extract_free_variables): Use is_global_var."}, {"sha": "f517424f59c1b24123d55036452788e2a610cb77", "filename": "gcc/c-family/array-notation-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -231,7 +231,7 @@ find_rank (location_t loc, tree orig_expr, tree expr, bool ignore_builtin_fn,\n \t\t   || TREE_CODE (ii_tree) == INDIRECT_REF)\n \t    ii_tree = TREE_OPERAND (ii_tree, 0);\n \t  else if (TREE_CODE (ii_tree) == PARM_DECL\n-\t\t   || TREE_CODE (ii_tree) == VAR_DECL)\n+\t\t   || VAR_P (ii_tree))\n \t    break;\n \t  else\n \t    gcc_unreachable ();"}, {"sha": "ef3c5e3ae2bfa23cacee7bb6ecfcba4d5eff6f7c", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -2826,7 +2826,7 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n     }\n   else\n     {\n-      if (TREE_CODE (t) == VAR_DECL\n+      if (VAR_P (t)\n \t  && decl_name\n \t  && *IDENTIFIER_POINTER (decl_name) == '_')\n \treturn 0;"}, {"sha": "5ceee5f101c1bda41d8e350003382d9ff64d1c9c", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -1620,7 +1620,7 @@ decl_constant_value_for_optimization (tree exp)\n     gcc_unreachable ();\n \n   if (!optimize\n-      || TREE_CODE (exp) != VAR_DECL\n+      || !VAR_P (exp)\n       || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE\n       || DECL_MODE (exp) == BLKmode)\n     return exp;\n@@ -6952,7 +6952,7 @@ handle_nocommon_attribute (tree *node, tree name,\n \t\t\t   tree ARG_UNUSED (args),\n \t\t\t   int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n-  if (TREE_CODE (*node) == VAR_DECL)\n+  if (VAR_P (*node))\n     DECL_COMMON (*node) = 0;\n   else\n     {\n@@ -6970,7 +6970,7 @@ static tree\n handle_common_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t\t\t int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n-  if (TREE_CODE (*node) == VAR_DECL)\n+  if (VAR_P (*node))\n     DECL_COMMON (*node) = 1;\n   else\n     {\n@@ -7349,12 +7349,12 @@ handle_used_attribute (tree *pnode, tree name, tree ARG_UNUSED (args),\n   tree node = *pnode;\n \n   if (TREE_CODE (node) == FUNCTION_DECL\n-      || (TREE_CODE (node) == VAR_DECL && TREE_STATIC (node))\n+      || (VAR_P (node) && TREE_STATIC (node))\n       || (TREE_CODE (node) == TYPE_DECL))\n     {\n       TREE_USED (node) = 1;\n       DECL_PRESERVE_P (node) = 1;\n-      if (TREE_CODE (node) == VAR_DECL)\n+      if (VAR_P (node))\n \tDECL_READ_P (node) = 1;\n     }\n   else\n@@ -7378,14 +7378,13 @@ handle_unused_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n       tree decl = *node;\n \n       if (TREE_CODE (decl) == PARM_DECL\n-\t  || TREE_CODE (decl) == VAR_DECL\n+\t  || VAR_P (decl)\n \t  || TREE_CODE (decl) == FUNCTION_DECL\n \t  || TREE_CODE (decl) == LABEL_DECL\n \t  || TREE_CODE (decl) == TYPE_DECL)\n \t{\n \t  TREE_USED (decl) = 1;\n-\t  if (TREE_CODE (decl) == VAR_DECL\n-\t      || TREE_CODE (decl) == PARM_DECL)\n+\t  if (VAR_P (decl) || TREE_CODE (decl) == PARM_DECL)\n \t    DECL_READ_P (decl) = 1;\n \t}\n       else\n@@ -7914,7 +7913,7 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       goto fail;\n     }\n \n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && current_function_decl != NULL_TREE\n       && !TREE_STATIC (decl))\n     {\n@@ -7933,7 +7932,7 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       goto fail;\n     }\n \n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && !targetm.have_tls && targetm.emutls.tmpl_section\n       && DECL_THREAD_LOCAL_P (decl))\n     {\n@@ -8224,7 +8223,7 @@ handle_alias_ifunc_attribute (bool is_alias, tree *node, tree name, tree args,\n   tree decl = *node;\n \n   if (TREE_CODE (decl) != FUNCTION_DECL\n-      && (!is_alias || TREE_CODE (decl) != VAR_DECL))\n+      && (!is_alias || !VAR_P (decl)))\n     {\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n@@ -8519,7 +8518,7 @@ c_determine_visibility (tree decl)\n \t  DECL_VISIBILITY_SPECIFIED (decl) = visibility_options.inpragma;\n \t  /* If visibility changed and DECL already has DECL_RTL, ensure\n \t     symbol flags are updated.  */\n-\t  if (((TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n+\t  if (((VAR_P (decl) && TREE_STATIC (decl))\n \t       || TREE_CODE (decl) == FUNCTION_DECL)\n \t      && DECL_RTL_SET_P (decl))\n \t    make_decl_rtl (decl);\n@@ -8541,7 +8540,7 @@ handle_tls_model_attribute (tree *node, tree name, tree args,\n \n   *no_add_attrs = true;\n \n-  if (TREE_CODE (decl) != VAR_DECL || !DECL_THREAD_LOCAL_P (decl))\n+  if (!VAR_P (decl) || !DECL_THREAD_LOCAL_P (decl))\n     {\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       return NULL_TREE;\n@@ -9507,7 +9506,7 @@ handle_cleanup_attribute (tree *node, tree name, tree args,\n      for global destructors in C++.  This requires infrastructure that\n      we don't have generically at the moment.  It's also not a feature\n      we'd be missing too much, since we do have attribute constructor.  */\n-  if (TREE_CODE (decl) != VAR_DECL || TREE_STATIC (decl))\n+  if (!VAR_P (decl) || TREE_STATIC (decl))\n     {\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n@@ -10492,7 +10491,7 @@ fold_offsetof_1 (tree expr)\n     case COMPOUND_EXPR:\n       /* Handle static members of volatile structs.  */\n       t = TREE_OPERAND (expr, 1);\n-      gcc_assert (TREE_CODE (t) == VAR_DECL);\n+      gcc_assert (VAR_P (t));\n       return fold_offsetof_1 (t);\n \n     default:\n@@ -10555,7 +10554,7 @@ readonly_error (location_t loc, tree arg, enum lvalue_use use)\n \t\t\t\t     G_(\"read-only member %qD used as %<asm%> output\")),\n \t\t  TREE_OPERAND (arg, 1));\n     }\n-  else if (TREE_CODE (arg) == VAR_DECL)\n+  else if (VAR_P (arg))\n     error_at (loc, READONLY_MSG (G_(\"assignment of read-only variable %qD\"),\n \t\t\t\t G_(\"increment of read-only variable %qD\"),\n \t\t\t\t G_(\"decrement of read-only variable %qD\"),\n@@ -10815,7 +10814,7 @@ c_common_mark_addressable_vec (tree t)\n {   \n   while (handled_component_p (t))\n     t = TREE_OPERAND (t, 0);\n-  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n     return;\n   TREE_ADDRESSABLE (t) = 1;\n }"}, {"sha": "c6e8f5ebbf2db84e1bfd565998efcb301060c911", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -1514,7 +1514,7 @@ check_format_arg (void *ctx, tree format_tree,\n   tree array_size = 0;\n   tree array_init;\n \n-  if (TREE_CODE (format_tree) == VAR_DECL)\n+  if (VAR_P (format_tree))\n     {\n       /* Pull out a constant value if the front end didn't.  */\n       format_tree = decl_constant_value (format_tree);\n@@ -1618,7 +1618,7 @@ check_format_arg (void *ctx, tree format_tree,\n       res->number_non_literal++;\n       return;\n     }\n-  if (TREE_CODE (format_tree) == VAR_DECL\n+  if (VAR_P (format_tree)\n       && TREE_CODE (TREE_TYPE (format_tree)) == ARRAY_TYPE\n       && (array_init = decl_constant_value (format_tree)) != format_tree\n       && TREE_CODE (array_init) == STRING_CST)"}, {"sha": "c557f6665e3ede15d2ea4853f6c7b60fe43688ea", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -263,7 +263,7 @@ c_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,\n       /* This is handled mostly by gimplify.c, but we have to deal with\n \t not warning about int x = x; as it is a GCC extension to turn off\n \t this warning but only if warn_init_self is zero.  */\n-      if (TREE_CODE (DECL_EXPR_DECL (*expr_p)) == VAR_DECL\n+      if (VAR_P (DECL_EXPR_DECL (*expr_p))\n \t  && !DECL_EXTERNAL (DECL_EXPR_DECL (*expr_p))\n \t  && !TREE_STATIC (DECL_EXPR_DECL (*expr_p))\n \t  && (DECL_INITIAL (DECL_EXPR_DECL (*expr_p)) == DECL_EXPR_DECL (*expr_p))"}, {"sha": "d1646975d4deec763cd937697f09fc1ae28ad318", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -212,7 +212,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n   addr = save_expr (addr);\n   if (TREE_CODE (addr) != SAVE_EXPR\n       && (TREE_CODE (addr) != ADDR_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (addr, 0)) != VAR_DECL))\n+\t  || !VAR_P (TREE_OPERAND (addr, 0))))\n     {\n       /* Make sure LHS is simple enough so that goa_lhs_expr_p can recognize\n \t it even after unsharing function body.  */\n@@ -264,8 +264,8 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n   /* Generally it is hard to prove lhs1 and lhs are the same memory\n      location, just diagnose different variables.  */\n   if (rhs1\n-      && TREE_CODE (rhs1) == VAR_DECL\n-      && TREE_CODE (lhs) == VAR_DECL\n+      && VAR_P (rhs1)\n+      && VAR_P (lhs)\n       && rhs1 != lhs)\n     {\n       if (code == OMP_ATOMIC)\n@@ -279,7 +279,7 @@ c_finish_omp_atomic (location_t loc, enum tree_code code,\n     {\n       /* Generally it is hard to prove lhs1 and lhs are the same memory\n \t location, just diagnose different variables.  */\n-      if (lhs1 && TREE_CODE (lhs1) == VAR_DECL && TREE_CODE (lhs) == VAR_DECL)\n+      if (lhs1 && VAR_P (lhs1) && VAR_P (lhs))\n \t{\n \t  if (lhs1 != lhs)\n \t    {"}, {"sha": "5987236311b0715fb5b48ce28fed592091e53ad4", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -341,7 +341,7 @@ maybe_apply_pending_pragma_weaks (void)\n       DECL_ARTIFICIAL (decl) = 1;\n       TREE_PUBLIC (decl) = 1;\n       DECL_WEAK (decl) = 1;\n-      if (TREE_CODE (decl) == VAR_DECL)\n+      if (VAR_P (decl))\n \tTREE_STATIC (decl) = 1;\n       if (!target)\n \t{\n@@ -385,7 +385,7 @@ handle_pragma_weak (cpp_reader * ARG_UNUSED (dummy))\n       if (value)\n \t{\n \t  DECL_EXTERNAL (decl) = 0;\n-\t  if (TREE_CODE (decl) == VAR_DECL)\n+\t  if (VAR_P (decl))\n \t    TREE_STATIC (decl) = 1;\n \t  assemble_alias (decl, value);\n \t}"}, {"sha": "a65ff3356a6d9bf4a80cfb0bd03aeab056dcf989", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -650,7 +650,7 @@ c_pretty_printer::storage_class_specifier (tree t)\n     {\n       if (DECL_REGISTER (t))\n \tpp_c_ws_string (this, \"register\");\n-      else if (TREE_STATIC (t) && TREE_CODE (t) == VAR_DECL)\n+      else if (TREE_STATIC (t) && VAR_P (t))\n \tpp_c_ws_string (this, \"static\");\n     }\n }"}, {"sha": "958df27f17a3dde9f8a92c16c6456c64c66328dc", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -382,7 +382,7 @@ create_parm_list (struct wrapper_data *wd, tree *val0, tree arg)\n \t argument list.  Because register variables are\n \t worker-local we don't need to work hard to support\n \t them in code that spawns.  */\n-      if ((TREE_CODE (arg) == VAR_DECL) && DECL_HARD_REGISTER (arg))\n+      if (VAR_P (arg) && DECL_HARD_REGISTER (arg))\n \t{\n \t  error_at (EXPR_LOCATION (arg),\n \t\t    \"explicit register variable %qD may not be modified in \"\n@@ -955,7 +955,7 @@ add_variable (struct wrapper_data *wd, tree var, enum add_variable_type how)\n \t work anyway.  Warn here.  This misses one case: if the\n \t register variable is used as the loop bound or increment it\n \t has already been added to the map.  */\n-      if ((how != ADD_BIND) && (TREE_CODE (var) == VAR_DECL)\n+      if ((how != ADD_BIND) && VAR_P (var)\n \t  && !DECL_EXTERNAL (var) && DECL_HARD_REGISTER (var))\n \twarning (0, \"register assignment ignored for %qD used in Cilk block\",\n \t\t var);"}, {"sha": "6b3deac6cffbb59273695058b2d9a2565e712a91", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -1,3 +1,11 @@\n+2015-06-25  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-array-notation.c: Use VAR_P throughout.\n+\t* c-decl.c: Likewise.\n+\t* c-objc-common.c: Likewise.\n+\t* c-parser.c: Likewise.\n+\t* c-typeck.c: Likewise.\n+\n 2015-06-25  Marek Polacek  <polacek@redhat.com>\n \n \t* c-decl.c: Use is_global_var throughout."}, {"sha": "029246883361832085a02e15a03411ddf84b5e16", "filename": "gcc/c/c-array-notation.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-array-notation.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -87,7 +87,7 @@ make_triplet_val_inv (location_t loc, tree *value)\n   tree var, new_exp;\n   if (TREE_CODE (*value) != INTEGER_CST\n       && TREE_CODE (*value) != PARM_DECL\n-      && TREE_CODE (*value) != VAR_DECL)\n+      && !VAR_P (*value))\n     {\n       var = build_decl (loc, VAR_DECL, NULL_TREE, integer_type_node);\n       new_exp = build_modify_expr (loc, var, TREE_TYPE (var), NOP_EXPR, loc,"}, {"sha": "fb4a83c0bd7d6fdd2034a5463e9968473dcde1b8", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -669,14 +669,14 @@ decl_jump_unsafe (tree decl)\n     return false;\n \n   /* Always warn about crossing variably modified types.  */\n-  if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == TYPE_DECL)\n+  if ((VAR_P (decl) || TREE_CODE (decl) == TYPE_DECL)\n       && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n     return true;\n \n   /* Otherwise, only warn if -Wgoto-misses-init and this is an\n      initialized automatic decl.  */\n   if (warn_jump_misses_init\n-      && TREE_CODE (decl) == VAR_DECL\n+      && VAR_P (decl)\n       && !TREE_STATIC (decl)\n       && DECL_INITIAL (decl) != NULL_TREE)\n     return true;\n@@ -817,7 +817,7 @@ bind_label (tree name, tree label, struct c_scope *scope,\n void\n c_finish_incomplete_decl (tree decl)\n {\n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     {\n       tree type = TREE_TYPE (decl);\n       if (type != error_mark_node\n@@ -1599,7 +1599,7 @@ c_bind (location_t loc, tree decl, bool is_global)\n   struct c_scope *scope;\n   bool nested = false;\n \n-  if (TREE_CODE (decl) != VAR_DECL || current_function_scope == NULL)\n+  if (!VAR_P (decl) || current_function_scope == NULL)\n     {\n       /* Types and functions are always considered to be global.  */\n       scope = file_scope;\n@@ -2111,7 +2111,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    }\n \t}\n     }\n-  else if (TREE_CODE (newdecl) == VAR_DECL)\n+  else if (VAR_P (newdecl))\n     {\n       /* Only variables can be thread-local, and all declarations must\n \t agree on this property.  */\n@@ -2306,7 +2306,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       && !(TREE_CODE (newdecl) == PARM_DECL\n \t   && TREE_ASM_WRITTEN (olddecl) && !TREE_ASM_WRITTEN (newdecl))\n       /* Don't warn about a variable definition following a declaration.  */\n-      && !(TREE_CODE (newdecl) == VAR_DECL\n+      && !(VAR_P (newdecl)\n \t   && DECL_INITIAL (newdecl) && !DECL_INITIAL (olddecl)))\n     {\n       warned = warning (OPT_Wredundant_decls, \"redundant redeclaration of %q+D\",\n@@ -2427,7 +2427,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n     DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n \n   /* Merge the threadprivate attribute.  */\n-  if (TREE_CODE (olddecl) == VAR_DECL && C_DECL_THREADPRIVATE_P (olddecl))\n+  if (VAR_P (olddecl) && C_DECL_THREADPRIVATE_P (olddecl))\n     C_DECL_THREADPRIVATE_P (newdecl) = 1;\n \n   if (CODE_CONTAINS_STRUCT (TREE_CODE (olddecl), TS_DECL_WITH_VIS))\n@@ -2611,7 +2611,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n     TREE_USED (newdecl) = 1;\n   else if (TREE_USED (newdecl))\n     TREE_USED (olddecl) = 1;\n-  if (TREE_CODE (olddecl) == VAR_DECL || TREE_CODE (olddecl) == PARM_DECL)\n+  if (VAR_P (olddecl) || TREE_CODE (olddecl) == PARM_DECL)\n     DECL_READ_P (newdecl) |= DECL_READ_P (olddecl);\n   if (DECL_PRESERVE_P (olddecl))\n     DECL_PRESERVE_P (newdecl) = 1;\n@@ -2660,8 +2660,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t\tint __thread x attribute ((tls_model (\"local-exec\")));\n \t\textern int __thread x;\n \t     as we'll lose the \"local-exec\" model.  */\n-\t  if (TREE_CODE (olddecl) == VAR_DECL\n-\t      && DECL_THREAD_LOCAL_P (newdecl))\n+\t  if (VAR_P (olddecl) && DECL_THREAD_LOCAL_P (newdecl))\n \t    set_decl_tls_model (olddecl, DECL_TLS_MODEL (newdecl));\n \t  break;\n \t}\n@@ -2694,8 +2693,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n      flags and attributes.  */\n   if (DECL_RTL_SET_P (olddecl)\n       && (TREE_CODE (olddecl) == FUNCTION_DECL\n-\t  || (TREE_CODE (olddecl) == VAR_DECL\n-\t      && TREE_STATIC (olddecl))))\n+\t  || (VAR_P (olddecl) && TREE_STATIC (olddecl))))\n     make_decl_rtl (olddecl);\n }\n \n@@ -2944,7 +2942,7 @@ pushdecl (tree x)\n \t      type_saved = true;\n \t    }\n \t  if (B_IN_FILE_SCOPE (b)\n-\t      && TREE_CODE (b->decl) == VAR_DECL\n+\t      && VAR_P (b->decl)\n \t      && TREE_STATIC (b->decl)\n \t      && TREE_CODE (TREE_TYPE (b->decl)) == ARRAY_TYPE\n \t      && !TYPE_DOMAIN (TREE_TYPE (b->decl))\n@@ -3075,7 +3073,7 @@ pushdecl_top_level (tree x)\n {\n   tree name;\n   bool nested = false;\n-  gcc_assert (TREE_CODE (x) == VAR_DECL || TREE_CODE (x) == CONST_DECL);\n+  gcc_assert (VAR_P (x) || TREE_CODE (x) == CONST_DECL);\n \n   name = DECL_NAME (x);\n \n@@ -4394,17 +4392,16 @@ c_decl_attributes (tree *node, tree attributes, int flags)\n {\n   /* Add implicit \"omp declare target\" attribute if requested.  */\n   if (current_omp_declare_target_attribute\n-      && ((TREE_CODE (*node) == VAR_DECL\n-\t   && is_global_var (*node))\n+      && ((VAR_P (*node) && is_global_var (*node))\n \t  || TREE_CODE (*node) == FUNCTION_DECL))\n     {\n-      if (TREE_CODE (*node) == VAR_DECL\n+      if (VAR_P (*node)\n \t  && ((DECL_CONTEXT (*node)\n \t       && TREE_CODE (DECL_CONTEXT (*node)) == FUNCTION_DECL)\n \t      || (current_function_decl && !DECL_EXTERNAL (*node))))\n \terror (\"%q+D in block scope inside of declare target directive\",\n \t       *node);\n-      else if (TREE_CODE (*node) == VAR_DECL\n+      else if (VAR_P (*node)\n \t       && !lang_hooks.types.omp_mappable_type (TREE_TYPE (*node)))\n \terror (\"%q+D in declare target directive does not have mappable type\",\n \t       *node);\n@@ -4542,7 +4539,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n      body of code to break, and it allows more efficient variable references\n      in the presence of dynamic linking.  */\n \n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && !initialized\n       && TREE_PUBLIC (decl)\n       && !DECL_THREAD_LOCAL_P (decl)\n@@ -4595,7 +4592,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n   /* C99 6.7.4p3: An inline definition of a function with external\n      linkage shall not contain a definition of a modifiable object\n      with static storage duration...  */\n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && current_scope != file_scope\n       && TREE_STATIC (decl)\n       && !TREE_READONLY (decl)\n@@ -4673,7 +4670,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n   if (asmspec_tree)\n     asmspec = TREE_STRING_POINTER (asmspec_tree);\n \n-  if (TREE_CODE (decl) == VAR_DECL\n+  if (VAR_P (decl)\n       && TREE_STATIC (decl)\n       && global_bindings_p ())\n     /* So decl is a global variable. Record the types it uses\n@@ -4766,7 +4763,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n       relayout_decl (decl);\n     }\n \n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_P (decl))\n     {\n       if (init && TREE_CODE (init) == CONSTRUCTOR)\n \tadd_flexible_array_elts_to_size (decl, init);\n@@ -4847,7 +4844,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n \t     GCC has accepted -- but ignored -- the ASMSPEC in\n \t     this case.  */\n \t  if (!DECL_FILE_SCOPE_P (decl)\n-\t      && TREE_CODE (decl) == VAR_DECL\n+\t      && VAR_P (decl)\n \t      && !C_DECL_REGISTER (decl)\n \t      && !TREE_STATIC (decl))\n \t    warning (0, \"ignoring asm-specifier for non-static local \"\n@@ -4931,7 +4928,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n     }\n \n   /* Install a cleanup (aka destructor) if one was given.  */\n-  if (TREE_CODE (decl) == VAR_DECL && !TREE_STATIC (decl))\n+  if (VAR_P (decl) && !TREE_STATIC (decl))\n     {\n       tree attr = lookup_attribute (\"cleanup\", DECL_ATTRIBUTES (decl));\n       if (attr)\n@@ -4959,7 +4956,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n     }\n \n   if (warn_cxx_compat\n-      && TREE_CODE (decl) == VAR_DECL\n+      && VAR_P (decl)\n       && !DECL_EXTERNAL (decl)\n       && DECL_INITIAL (decl) == NULL_TREE)\n     {\n@@ -6636,7 +6633,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \t    if (global_decl\n \t\t&& global_decl != visible_decl\n-\t\t&& TREE_CODE (global_decl) == VAR_DECL\n+\t\t&& VAR_P (global_decl)\n \t\t&& !TREE_PUBLIC (global_decl))\n \t      error_at (loc, \"variable previously declared %<static%> \"\n \t\t\t\"redeclared %<extern%>\");\n@@ -6715,7 +6712,7 @@ grokdeclarator (const struct c_declarator *declarator,\n        will be ignored, and would even crash the compiler.\n        Of course, this only makes sense on  VAR,PARM, and RESULT decl's.   */\n     if (C_TYPE_FIELDS_VOLATILE (TREE_TYPE (decl))\n-\t&& (TREE_CODE (decl) == VAR_DECL ||  TREE_CODE (decl) == PARM_DECL\n+\t&& (VAR_P (decl) ||  TREE_CODE (decl) == PARM_DECL\n \t  || TREE_CODE (decl) == RESULT_DECL))\n       {\n \t/* It is not an error for a structure with volatile fields to\n@@ -6733,7 +6730,7 @@ grokdeclarator (const struct c_declarator *declarator,\n     gcc_assert (!DECL_ASSEMBLER_NAME_SET_P (decl));\n \n     if (warn_cxx_compat\n-\t&& TREE_CODE (decl) == VAR_DECL\n+\t&& VAR_P (decl)\n \t&& TREE_PUBLIC (decl)\n \t&& TREE_STATIC (decl)\n \t&& (TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE"}, {"sha": "a783f805b28350aa7eba6515db4665fe784c1bcc", "filename": "gcc/c/c-objc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -109,7 +109,7 @@ c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n   switch (*spec)\n     {\n     case 'D':\n-      if (TREE_CODE (t) == VAR_DECL && DECL_HAS_DEBUG_EXPR_P (t))\n+      if (VAR_P (t) && DECL_HAS_DEBUG_EXPR_P (t))\n \t{\n \t  t = DECL_DEBUG_EXPR (t);\n \t  if (!DECL_P (t))"}, {"sha": "aaf7e326c994f677531490fc665968442041ac69", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -10365,7 +10365,7 @@ c_parser_oacc_data_clause_deviceptr (c_parser *parser, tree list)\n \t c_parser_omp_var_list_parens() should construct a list of\n \t locations to go along with the var list.  */\n \n-      if (TREE_CODE (v) != VAR_DECL)\n+      if (!VAR_P (v))\n \terror_at (loc, \"%qD is not a variable\", v);\n       else if (TREE_TYPE (v) == error_mark_node)\n \t;\n@@ -14765,7 +14765,7 @@ c_parser_omp_threadprivate (c_parser *parser)\n \n       /* If V had already been marked threadprivate, it doesn't matter\n \t whether it had been used prior to this point.  */\n-      if (TREE_CODE (v) != VAR_DECL)\n+      if (!VAR_P (v))\n \terror_at (loc, \"%qD is not a variable\", v);\n       else if (TREE_USED (v) && !C_DECL_THREADPRIVATE_P (v))\n \terror_at (loc, \"%qE declared %<threadprivate%> after first use\", v);"}, {"sha": "9caf028b0b1490b6dd9b7997eb3158d2e9de3f06", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ae9bd2715d973460bbf600ca7371add571e3508/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=0ae9bd2715d973460bbf600ca7371add571e3508", "patch": "@@ -219,8 +219,7 @@ c_incomplete_type_error (const_tree value, const_tree type)\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n \n-  if (value != 0 && (TREE_CODE (value) == VAR_DECL\n-\t\t     || TREE_CODE (value) == PARM_DECL))\n+  if (value != 0 && (VAR_P (value) || TREE_CODE (value) == PARM_DECL))\n     error (\"%qD has an incomplete type %qT\", value, type);\n   else\n     {\n@@ -2531,7 +2530,7 @@ build_array_ref (location_t loc, tree array, tree index)\n \t  tree foo = array;\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n-\t  if (TREE_CODE (foo) == VAR_DECL && C_DECL_REGISTER (foo))\n+\t  if (VAR_P (foo) && C_DECL_REGISTER (foo))\n \t    pedwarn (loc, OPT_Wpedantic,\n \t\t     \"ISO C forbids subscripting %<register%> array\");\n \t  else if (!lvalue_p (foo))\n@@ -2673,7 +2672,7 @@ build_external_ref (location_t loc, tree id, int fun, tree *type)\n \t   && DECL_DECLARED_INLINE_P (current_function_decl)\n \t   && DECL_EXTERNAL (current_function_decl)\n \t   && VAR_OR_FUNCTION_DECL_P (ref)\n-\t   && (TREE_CODE (ref) != VAR_DECL || TREE_STATIC (ref))\n+\t   && (!VAR_P (ref) || TREE_STATIC (ref))\n \t   && ! TREE_PUBLIC (ref)\n \t   && DECL_CONTEXT (ref) != current_function_decl)\n     record_inline_static (loc, current_function_decl, ref,\n@@ -11589,7 +11588,7 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n     {\n       if (error_operand_p (t))\n \treturn error_mark_node;\n-      if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+      if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t{\n \t  if (DECL_P (t))\n \t    error_at (OMP_CLAUSE_LOCATION (c),\n@@ -11602,7 +11601,7 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t  return error_mark_node;\n \t}\n       else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n-\t       && TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t       && VAR_P (t) && DECL_THREAD_LOCAL_P (t))\n \t{\n \t  error_at (OMP_CLAUSE_LOCATION (c),\n \t\t    \"%qD is threadprivate variable in %qs clause\", t,\n@@ -12198,7 +12197,7 @@ c_finish_omp_clauses (tree clauses)\n \n \tcase OMP_CLAUSE_COPYIN:\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (TREE_CODE (t) != VAR_DECL || !DECL_THREAD_LOCAL_P (t))\n+\t  if (!VAR_P (t) || !DECL_THREAD_LOCAL_P (t))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE must be %<threadprivate%> for %<copyin%>\", t);\n@@ -12236,7 +12235,7 @@ c_finish_omp_clauses (tree clauses)\n \n \tcheck_dup_generic:\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE is not a variable in clause %qs\", t,\n@@ -12259,7 +12258,7 @@ c_finish_omp_clauses (tree clauses)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  need_complete = true;\n \t  need_implicitly_determined = true;\n-\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE is not a variable in clause %<firstprivate%>\", t);\n@@ -12280,7 +12279,7 @@ c_finish_omp_clauses (tree clauses)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  need_complete = true;\n \t  need_implicitly_determined = true;\n-\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE is not a variable in clause %<lastprivate%>\", t);\n@@ -12299,7 +12298,7 @@ c_finish_omp_clauses (tree clauses)\n \n \tcase OMP_CLAUSE_ALIGNED:\n \t  t = OMP_CLAUSE_DECL (c);\n-\t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE is not a variable in %<aligned%> clause\", t);\n@@ -12334,7 +12333,7 @@ c_finish_omp_clauses (tree clauses)\n \t    }\n \t  if (t == error_mark_node)\n \t    remove = true;\n-\t  else if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  else if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE is not a variable in %<depend%> clause\", t);\n@@ -12369,14 +12368,14 @@ c_finish_omp_clauses (tree clauses)\n \t    }\n \t  if (t == error_mark_node)\n \t    remove = true;\n-\t  else if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n+\t  else if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE is not a variable in %qs clause\", t,\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n-\t  else if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t  else if (VAR_P (t) && DECL_THREAD_LOCAL_P (t))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qD is threadprivate variable in %qs clause\", t,\n@@ -12503,7 +12502,7 @@ c_finish_omp_clauses (tree clauses)\n \t    {\n \t      const char *share_name = NULL;\n \n-\t      if (TREE_CODE (t) == VAR_DECL && DECL_THREAD_LOCAL_P (t))\n+\t      if (VAR_P (t) && DECL_THREAD_LOCAL_P (t))\n \t\tshare_name = \"threadprivate\";\n \t      else switch (c_omp_predetermined_sharing (t))\n \t\t{\n@@ -12752,10 +12751,10 @@ c_tree_equal (tree t1, tree t2)\n \t   it means that it's going to be unified with whatever the\n \t   TARGET_EXPR is really supposed to initialize, so treat it\n \t   as being equivalent to anything.  */\n-\tif (TREE_CODE (o1) == VAR_DECL && DECL_NAME (o1) == NULL_TREE\n+\tif (VAR_P (o1) && DECL_NAME (o1) == NULL_TREE\n \t    && !DECL_RTL_SET_P (o1))\n \t  /*Nop*/;\n-\telse if (TREE_CODE (o2) == VAR_DECL && DECL_NAME (o2) == NULL_TREE\n+\telse if (VAR_P (o2) && DECL_NAME (o2) == NULL_TREE\n \t\t && !DECL_RTL_SET_P (o2))\n \t  /*Nop*/;\n \telse if (!c_tree_equal (o1, o2))"}]}