{"sha": "9d99ee7be4ce581cac42b20b08982ecefed84c2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ5OWVlN2JlNGNlNTgxY2FjNDJiMjBiMDg5ODJlY2VmZWQ4NGMyYg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-06-11T22:39:21Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-06-11T22:39:21Z"}, "message": "re PR fortran/29786 (Initialization of overlapping variables: Not implemented)\n\n2007-06-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29786\n\tPR fortran/30875\n\t* trans-common.c (get_init_field): New function.\n\t(create_common): Call get_init_field for overlapping\n\tinitializers in equivalence blocks.\n\t* resolve.c (resolve_equivalence_derived, resolve_equivalence):\n\tRemove constraints on initializers in equivalence blocks.\n\t* target-memory.c (expr_to_char, gfc_merge_initializers):\n\tNew functions.\n\t(encode_derived): Add the bit offset to the byte offset to get\n\tthe total offset to the field.\n\t* target-memory.h : Add prototype for gfc_merge_initializers.\n\n\n2007-06-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/29786\n\t* gfortran.dg/equiv_7.f90: New test.\n\t* gfortran.dg/equiv_constraint_7.f90: Change error message.\n\n\n\tPR fortran/30875\n\t* gfortran.dg/equiv_constraint_5.f90: Correct code and error.\n\nFrom-SVN: r125628", "tree": {"sha": "6305ab5b7602b051601e954daf60b03312b67ca7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6305ab5b7602b051601e954daf60b03312b67ca7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d99ee7be4ce581cac42b20b08982ecefed84c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d99ee7be4ce581cac42b20b08982ecefed84c2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d99ee7be4ce581cac42b20b08982ecefed84c2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d99ee7be4ce581cac42b20b08982ecefed84c2b/comments", "author": null, "committer": null, "parents": [{"sha": "b0384c544e7484c7b5b4721cf914600f9f71b65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0384c544e7484c7b5b4721cf914600f9f71b65b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0384c544e7484c7b5b4721cf914600f9f71b65b"}], "stats": {"total": 460, "additions": 396, "deletions": 64}, "files": [{"sha": "bb56decbe8b18b1242f629d659ca733729849628", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -1,3 +1,18 @@\n+2007-06-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29786\n+\tPR fortran/30875\n+\t* trans-common.c (get_init_field): New function.\n+\t(create_common): Call get_init_field for overlapping\n+\tinitializers in equivalence blocks.\n+\t* resolve.c (resolve_equivalence_derived, resolve_equivalence):\n+\tRemove constraints on initializers in equivalence blocks.\n+\t* target-memory.c (expr_to_char, gfc_merge_initializers):\n+\tNew functions.\n+\t(encode_derived): Add the bit offset to the byte offset to get\n+\tthe total offset to the field.\n+\t* target-memory.h : Add prototype for gfc_merge_initializers.\n+\n 2007-06-11  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* trans-types.c (gfc_signed_type): Remove."}, {"sha": "99797aa7ec3b97ff2e0bb2f4c14885a910d6a80f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -6992,14 +6992,6 @@ resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n \t\t     sym->name, &e->where);\n \t  return FAILURE;\n \t}\n-\n-      if (c->initializer)\n-\t{\n-\t  gfc_error (\"Derived type variable '%s' at %L with default \"\n-\t\t     \"initializer cannot be an EQUIVALENCE object\",\n-\t\t     sym->name, &e->where);\n-\t  return FAILURE;\n-\t}\n     }\n   return SUCCESS;\n }\n@@ -7122,21 +7114,6 @@ resolve_equivalence (gfc_equiv *eq)\n \t      break;\n \t}\n \n-      /* An equivalence statement cannot have more than one initialized\n-\t object.  */\n-      if (sym->value)\n-\t{\n-\t  if (value_name != NULL)\n-\t    {\n-\t      gfc_error (\"Initialized objects '%s' and '%s' cannot both \"\n-\t\t\t \"be in the EQUIVALENCE statement at %L\",\n-\t\t\t value_name, sym->name, &e->where);\n-\t      continue;\n-\t    }\n-\t  else\n-\t    value_name = sym->name;\n-\t}\n-\n       /* Shall not equivalence common block variables in a PURE procedure.  */\n       if (sym->ns->proc_name\n \t  && sym->ns->proc_name->attr.pure"}, {"sha": "561a8f11bebd33e72a68ca10171ad9a56515cbd2", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 107, "deletions": 2, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -198,8 +198,11 @@ encode_derived (gfc_expr *source, unsigned char *buffer, size_t buffer_size)\n   cmp = source->ts.derived->components;\n   for (;ctr; ctr = ctr->next, cmp = cmp->next)\n     {\n-      gcc_assert (ctr->expr && cmp);\n-      ptr = TREE_INT_CST_LOW (DECL_FIELD_OFFSET (cmp->backend_decl));\n+      gcc_assert (cmp);\n+      if (!ctr->expr)\n+\tcontinue;\n+      ptr = TREE_INT_CST_LOW(DECL_FIELD_OFFSET(cmp->backend_decl))\n+\t    + TREE_INT_CST_LOW(DECL_FIELD_BIT_OFFSET(cmp->backend_decl))/8;\n       gfc_target_encode_expr (ctr->expr, &buffer[ptr],\n \t\t\t      buffer_size - ptr);\n     }\n@@ -491,3 +494,105 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n \n   return result->representation.length;\n }\n+\n+\n+/* --------------------------------------------------------------- */ \n+/* Two functions used by trans-common.c to write overlapping\n+   equivalence initializers to a buffer.  This is added to the union\n+   and the original initializers freed.  */\n+\n+\n+/* Writes the values of a constant expression to a char buffer. If another\n+   unequal initializer has already been written to the buffer, this is an\n+   error.  */\n+\n+static size_t\n+expr_to_char (gfc_expr *e, unsigned char *data, unsigned char *chk, size_t len)\n+{\n+  int i;\n+  int ptr;\n+  gfc_constructor *ctr;\n+  gfc_component *cmp;\n+  unsigned char *buffer;\n+\n+  if (e == NULL)\n+    return 0;\n+\n+  /* Take a derived type, one component at a time, using the offsets from the backend\n+     declaration.  */\n+  if (e->ts.type == BT_DERIVED)\n+    {\n+      ctr = e->value.constructor;\n+      cmp = e->ts.derived->components;\n+      for (;ctr; ctr = ctr->next, cmp = cmp->next)\n+\t{\n+\t  gcc_assert (cmp && cmp->backend_decl);\n+\t  if (!ctr->expr)\n+\t    continue;\n+\t    ptr = TREE_INT_CST_LOW(DECL_FIELD_OFFSET(cmp->backend_decl))\n+\t\t\t+ TREE_INT_CST_LOW(DECL_FIELD_BIT_OFFSET(cmp->backend_decl))/8;\n+\t  expr_to_char (ctr->expr, &data[ptr], &chk[ptr], len);\n+\t}\n+      return len;\n+    }\n+\n+  /* Otherwise, use the target-memory machinery to write a bitwise image, appropriate\n+     to the target, in a buffer and check off the initialized part of the buffer.  */\n+  len = gfc_target_expr_size (e);\n+  buffer = (unsigned char*)alloca (len);\n+  len = gfc_target_encode_expr (e, buffer, len);\n+\n+    for (i = 0; i < (int)len; i++)\n+    {\n+      if (chk[i] && (buffer[i] != data[i]))\n+\t{\n+\t  gfc_error (\"Overlapping unequal initializers in EQUIVALENCE \"\n+\t\t     \"at %L\", &e->where);\n+\t  return 0;\n+\t}\n+      chk[i] = 0xFF;\n+    }\n+\n+  memcpy (data, buffer, len);\n+  return len;\n+}\n+\n+\n+/* Writes the values from the equivalence initializers to a char* array\n+   that will be written to the constructor to make the initializer for\n+   the union declaration.  */\n+\n+size_t\n+gfc_merge_initializers (gfc_typespec ts, gfc_expr *e, unsigned char *data,\n+\t\t\tunsigned char *chk, size_t length)\n+{\n+  size_t len = 0;\n+  gfc_constructor * c;\n+\n+  switch (e->expr_type)\n+    {\n+    case EXPR_CONSTANT:\n+    case EXPR_STRUCTURE:\n+      len = expr_to_char (e, &data[0], &chk[0], length);\n+\n+      break;\n+\n+    case EXPR_ARRAY:\n+      for (c = e->value.constructor; c; c = c->next)\n+\t{\n+\t  size_t elt_size = gfc_target_expr_size (c->expr);\n+\n+\t  if (c->n.offset)\n+\t    len = elt_size * (size_t)mpz_get_si (c->n.offset);\n+\n+\t  len = len + gfc_merge_initializers (ts, c->expr, &data[len],\n+\t\t\t\t\t      &chk[len], length - len);\n+\t}\n+      break;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  return len;\n+}"}, {"sha": "b8f6d044e36eb162528b4e1d19d4d7d5c33f9ed2", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -41,4 +41,9 @@ int gfc_interpret_character (unsigned char *, size_t, gfc_expr *);\n int gfc_interpret_derived (unsigned char *, size_t, gfc_expr *);\n int gfc_target_interpret_expr (unsigned char *, size_t, gfc_expr *);\n \n+/* Merge overlapping equivalence initializers for trans-common.c. */\n+size_t gfc_merge_initializers (gfc_typespec, gfc_expr *,\n+\t\t\t       unsigned char *, unsigned char *,\n+\t\t\t       size_t);\n+\n #endif /* GFC_TARGET_MEMORY_H  */"}, {"sha": "e39ec5962a07b9548f824dd1b5342c41b49a1c8c", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 139, "deletions": 23, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -106,6 +106,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"trans.h\"\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n+#include \"target-memory.h\"\n \n \n /* Holds a single variable in an equivalence set.  */\n@@ -413,6 +414,110 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n }\n \n \n+/* Return a field that is the size of the union, if an equivalence has\n+   overlapping initializers.  Merge the initializers into a single\n+   initializer for this new field, then free the old ones.  */ \n+\n+static tree\n+get_init_field (segment_info *head, tree union_type, tree *field_init,\n+\t\trecord_layout_info rli)\n+{\n+  segment_info *s;\n+  HOST_WIDE_INT length = 0;\n+  HOST_WIDE_INT offset = 0;\n+  unsigned HOST_WIDE_INT known_align, desired_align;\n+  bool overlap = false;\n+  tree tmp, field;\n+  tree init;\n+  unsigned char *data, *chk;\n+  VEC(constructor_elt,gc) *v = NULL;\n+\n+  tree type = unsigned_char_type_node;\n+  int i;\n+\n+  /* Obtain the size of the union and check if there are any overlapping\n+     initializers.  */\n+  for (s = head; s; s = s->next)\n+    {\n+      HOST_WIDE_INT slen = s->offset + s->length;\n+      if (s->sym->value)\n+\t{\n+\t  if (s->offset < offset)\n+            overlap = true;\n+\t  offset = slen;\n+\t}\n+      length = length < slen ? slen : length;\n+    }\n+\n+  if (!overlap)\n+    return NULL_TREE;\n+\n+  /* Now absorb all the initializer data into a single vector,\n+     whilst checking for overlapping, unequal values.  */\n+  data = (unsigned char*)gfc_getmem ((size_t)length);\n+  chk = (unsigned char*)gfc_getmem ((size_t)length);\n+\n+  /* TODO - change this when default initialization is implemented.  */\n+  memset (data, '\\0', (size_t)length);\n+  memset (chk, '\\0', (size_t)length);\n+  for (s = head; s; s = s->next)\n+    if (s->sym->value)\n+      gfc_merge_initializers (s->sym->ts, s->sym->value,\n+\t\t\t      &data[s->offset],\n+\t\t\t      &chk[s->offset],\n+\t\t\t     (size_t)s->length);\n+  \n+  for (i = 0; i < length; i++)\n+    CONSTRUCTOR_APPEND_ELT (v, NULL, build_int_cst (type, data[i]));\n+\n+  gfc_free (data);\n+  gfc_free (chk);\n+\n+  /* Build a char[length] array to hold the initializers.  Much of what\n+     follows is borrowed from build_field, above.  */\n+\n+  tmp = build_int_cst (gfc_array_index_type, length - 1);\n+  tmp = build_range_type (gfc_array_index_type,\n+\t\t\t  gfc_index_zero_node, tmp);\n+  tmp = build_array_type (type, tmp);\n+  field = build_decl (FIELD_DECL, NULL_TREE, tmp);\n+  gfc_set_decl_location (field, &gfc_current_locus);\n+\n+  known_align = BIGGEST_ALIGNMENT;\n+\n+  desired_align = update_alignment_for_field (rli, field, known_align);\n+  if (desired_align > known_align)\n+    DECL_PACKED (field) = 1;\n+\n+  DECL_FIELD_CONTEXT (field) = union_type;\n+  DECL_FIELD_OFFSET (field) = size_int (0);\n+  DECL_FIELD_BIT_OFFSET (field) = bitsize_zero_node;\n+  SET_DECL_OFFSET_ALIGN (field, known_align);\n+\n+  rli->offset = size_binop (MAX_EXPR, rli->offset,\n+                            size_binop (PLUS_EXPR,\n+                                        DECL_FIELD_OFFSET (field),\n+                                        DECL_SIZE_UNIT (field)));\n+\n+  init = build_constructor (TREE_TYPE (field), v);\n+  TREE_CONSTANT (init) = 1;\n+  TREE_INVARIANT (init) = 1;\n+\n+  *field_init = init;\n+\n+  for (s = head; s; s = s->next)\n+    {\n+      if (s->sym->value == NULL)\n+\tcontinue;\n+\n+      gfc_free_expr (s->sym->value);\n+      s->sym->value = NULL;\n+    }\n+\n+  return field;\n+}\n+\n+\n /* Declare memory for the common block or local equivalence, and create\n    backend declarations for all of the elements.  */\n \n@@ -422,6 +527,8 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n   segment_info *s, *next_s;\n   tree union_type;\n   tree *field_link;\n+  tree field;\n+  tree field_init;\n   record_layout_info rli;\n   tree decl;\n   bool is_init = false;\n@@ -440,6 +547,20 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n   rli = start_record_layout (union_type);\n   field_link = &TYPE_FIELDS (union_type);\n \n+  /* Check for overlapping initializers and replace them with a single,\n+     artificial field that contains all the data.  */\n+  if (saw_equiv)\n+    field = get_init_field (head, union_type, &field_init, rli);\n+  else\n+    field = NULL_TREE;\n+\n+  if (field != NULL_TREE)\n+    {\n+      is_init = true;\n+      *field_link = field;\n+      field_link = &TREE_CHAIN (field);\n+    }\n+\n   for (s = head; s; s = s->next)\n     {\n       build_field (s, union_type, rli);\n@@ -456,6 +577,7 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n       if (s->sym->attr.save)\n         is_saved = true;\n     }\n+\n   finish_record_layout (rli, true);\n \n   if (com)\n@@ -469,29 +591,23 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n       HOST_WIDE_INT offset = 0;\n       VEC(constructor_elt,gc) *v = NULL;\n \n-      for (s = head; s; s = s->next)\n-        {\n-          if (s->sym->value)\n-            {\n-              if (s->offset < offset)\n-                {\n-\t\t    /* We have overlapping initializers.  It could either be\n-\t\t       partially initialized arrays (legal), or the user\n-\t\t       specified multiple initial values (illegal).\n-\t\t       We don't implement this yet, so bail out.  */\n-                  gfc_todo_error (\"Initialization of overlapping variables\");\n-                }\n-\t      /* Add the initializer for this field.  */\n-\t      tmp = gfc_conv_initializer (s->sym->value, &s->sym->ts,\n-\t\t\t\t\t  TREE_TYPE (s->field),\n-\t\t\t\t\t  s->sym->attr.dimension,\n-\t\t\t\t\t  s->sym->attr.pointer\n-\t\t\t\t\t  || s->sym->attr.allocatable);\n-\n-\t      CONSTRUCTOR_APPEND_ELT (v, s->field, tmp);\n-              offset = s->offset + s->length;\n-            }\n-        }\n+      if (field != NULL_TREE && field_init != NULL_TREE)\n+\tCONSTRUCTOR_APPEND_ELT (v, field, field_init);\n+      else\n+\tfor (s = head; s; s = s->next)\n+\t  {\n+\t    if (s->sym->value)\n+\t      {\n+\t\t/* Add the initializer for this field.  */\n+\t\ttmp = gfc_conv_initializer (s->sym->value, &s->sym->ts,\n+\t\t    TREE_TYPE (s->field), s->sym->attr.dimension,\n+\t\t    s->sym->attr.pointer || s->sym->attr.allocatable);\n+\n+\t\tCONSTRUCTOR_APPEND_ELT (v, s->field, tmp);\n+\t\toffset = s->offset + s->length;\n+\t      }\n+\t  }\n+\n       gcc_assert (!VEC_empty (constructor_elt, v));\n       ctor = build_constructor (union_type, v);\n       TREE_CONSTANT (ctor) = 1;"}, {"sha": "1e401362aec5eb6af2cff2332ab5a0312bd404e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -1,3 +1,12 @@\n+2007-06-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/29786\n+\t* gfortran.dg/equiv_7.f90: New test.\n+\t* gfortran.dg/equiv_constraint_7.f90: Change error message.\n+\n+\tPR fortran/30875\n+\t* gfortran.dg/equiv_constraint_5.f90: Correct code and error.\n+\n 2007-06-11  Andreas Tobler  <a.tobler@schweiz.org>\n \n \t* gcc.dg/setjmp-3.c: Rename raise to raise0."}, {"sha": "51beba7278729369de30e1c6ddc124df2da89c2f", "filename": "gcc/testsuite/gfortran.dg/equiv_7.f90", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_7.f90?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -0,0 +1,92 @@\n+! { dg-do run }\n+! { dg-options \"-std=gnu\" }\n+! Tests the fix for PR29786, in which initialization of overlapping\n+! equivalence elements caused a compile error.\n+!\n+! Contributed by Bernhard Fischer <aldot@gcc.gnu.org>\n+!\n+block data\n+  common /global/ ca (4)\n+  integer(4) ca, cb\n+  equivalence (cb, ca(3))\n+  data (ca(i), i = 1, 2) /42,43/, ca(4) /44/\n+  data cb /99/\n+end block data\n+\n+  call int4_int4\n+  call real4_real4\n+  call complex_real\n+  call check_block_data\n+  call derived_types         ! Thanks to Tobias Burnus for this:)\n+!\n+! This came up in PR29786 comment #9\n+!\n+  if (d1mach (1) .ne. transfer ((/0_4, 1048576_4/), 1d0)) call abort ()\n+  if (d1mach (2) .ne. transfer ((/-1_4,2146435071_4/), 1d0)) call abort ()\n+!\n+contains\n+  subroutine int4_int4\n+      integer(4)         a(4)\n+      integer(4)         b\n+      equivalence (b,a(3))\n+      data b/3/\n+      data (a(i), i=1,2) /1,2/, a(4) /4/\n+      if (any (a .ne. (/1, 2, 3, 4/))) call abort ()\n+  end subroutine int4_int4\n+  subroutine real4_real4\n+      real(4)         a(4)\n+      real(4)         b\n+      equivalence (b,a(3))\n+      data b/3.0_4/\n+      data (a(i), i=1,2) /1.0_4, 2.0_4/, &\n+            a(4) /4.0_4/\n+      if (sum (abs (a -  &\n+          (/1.0_4, 2.0_4, 3.0_4, 4.0_4/))) > 1.0e-6) call abort ()\n+  end subroutine real4_real4\n+  subroutine complex_real\n+      complex(4)         a(4)\n+      real(4)            b(2)\n+      equivalence (b,a(3))\n+      data b(1)/3.0_4/, b(2)/4.0_4/\n+      data (a(i), i=1,2) /(0.0_4, 1.0_4),(2.0_4,0.0_4)/, &\n+            a(4) /(0.0_4,5.0_4)/\n+      if (sum (abs (a - (/(0.0_4, 1.0_4),(2.0_4, 0.0_4), &\n+          (3.0_4, 4.0_4),(0.0_4, 5.0_4)/)))  > 1.0e-6) call abort ()\n+  end subroutine complex_real\n+  subroutine check_block_data\n+      common /global/ ca (4)\n+      equivalence (ca(3), cb)\n+      integer(4) ca\n+      if (any (ca .ne. (/42, 43, 99, 44/))) call abort ()\n+  end subroutine check_block_data\n+  function d1mach(i)\n+    implicit none\n+    double precision d1mach,dmach(5)\n+    integer i,large(4),small(4)\n+    equivalence ( dmach(1), small(1) )\n+    equivalence ( dmach(2), large(1) )\n+    data small(1),small(2) / 0,   1048576/\n+    data large(1),large(2) /-1,2146435071/\n+    d1mach = dmach(i) \n+  end function d1mach\n+    subroutine derived_types\n+      TYPE T1\n+        sequence\n+        character (3) :: chr\n+        integer :: i = 1\n+        integer :: j\n+        END TYPE T1\n+      TYPE T2\n+        sequence\n+        character (3) :: chr = \"wxy\"\n+        integer :: i = 1\n+        integer :: j = 4\n+      END TYPE T2\n+      TYPE(T1) :: a1\n+      TYPE(T2) :: a2\n+      EQUIVALENCE(a1,a2)         ! { dg-warning=\"mixed|components\" }\n+      if (a1%chr .ne. \"wxy\") call abort ()\n+      if (a1%i .ne. 1) call abort ()\n+      if (a1%j .ne. 4) call abort ()\n+      end subroutine derived_types\n+end"}, {"sha": "1f7dddc846be63e03ed9d9d5f1bd92fbaf9fa05c", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_5.f90", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_5.f90?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -1,18 +1,31 @@\n ! { dg-do compile }\n ! { dg-options \"-O0\" }\n-! PR20902 - Structure with default initializer cannot be equivalence memeber.\n+! PR20902 - Overlapping initializers in an equivalence block must\n+! have the same value.\n+!\n+! The code was replaced completely after the fix for PR30875, which\n+! is a repeat of the original and comes from the same contributor.\n+! The fix for 20902 was wrong.\n+!\n ! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n-TYPE T1\n- sequence\n- integer :: i=1\n-END TYPE T1\n-TYPE T2\n- sequence\n- integer :: i      ! drop original initializer to pick up error below.\n-END TYPE T2\n-TYPE(T1) :: a1\n-TYPE(T2) :: a2\n-EQUIVALENCE(a1,a2) ! { dg-error \"initializer cannot be an EQUIVALENCE\" }\n-write(6,*) a1,a2\n+!\n+  TYPE T1\n+    sequence\n+    integer :: i=1\n+  END TYPE T1\n+  TYPE T2           ! OK because initializers are equal\n+    sequence\n+    integer :: i=1\n+  END TYPE T2\n+  TYPE T3\n+    sequence\n+    integer :: i=2 ! { dg-error \"Overlapping unequal initializers\" }\n+  END TYPE T3\n+  TYPE(T1) :: a1\n+  TYPE(T2) :: a2\n+  TYPE(T3) :: a3\n+  EQUIVALENCE (a1, a2)\n+  EQUIVALENCE (a1, a3)\n+  write(6, *) a1, a2, a3\n END\n "}, {"sha": "872e05b90fca59e4999a439ab1c9ff7cbea5f0bc", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_7.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d99ee7be4ce581cac42b20b08982ecefed84c2b/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_7.f90?ref=9d99ee7be4ce581cac42b20b08982ecefed84c2b", "patch": "@@ -1,11 +1,11 @@\n ! { dg-do compile }\n ! { dg-options \"-O0\" }\n-! PR20890 - Equivalence cannot contain more than one initialized variables.\n+! PR20890 - Equivalence cannot contain overlapping unequal initializers.\n ! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n ! Started out being in BLOCK DATA; however, blockdata variables must be in\n ! COMMON and therefore cannot have F95 style initializers....\n  MODULE DATA\n-  INTEGER :: I=1,J=2\n-  EQUIVALENCE(I,J)  ! { dg-error \"cannot both be in the EQUIVALENCE\" }\n+  INTEGER :: I=1,J=2  ! { dg-error \"Overlapping unequal initializers\" }\n+  EQUIVALENCE(I,J)\n  END MODULE DATA\n  END"}]}