{"sha": "ad451b020a24fe7111e668f8c41a3ba648104569", "node_id": "C_kwDOANBUbNoAKGFkNDUxYjAyMGEyNGZlNzExMWU2NjhmOGM0MWEzYmE2NDgxMDQ1Njk", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-10-04T19:30:44Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-10-06T13:19:06Z"}, "message": "Add range intersect with 2 wide-ints.\n\nAdd a more efficent intersect using a lower/upper bound single pair of\nwide_ints.\n\n\t* gimple-range-cache.cc (non_null_ref::adjust_range): Call new\n\tintersect routine.\n\t* gimple-range-fold.cc (adjust_pointer_diff_expr): Ditto.\n\t(adjust_imagpart_expr): Ditto.\n\t* value-range.cc (irange::irange_intersect): Call new routine if\n\tRHS is a single pair.\n\t(irange::intersect): New wide_int version.\n\t* value-range.h (class irange): New prototype.", "tree": {"sha": "db39edc76cfbe976d513ef738e65096d0f255775", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db39edc76cfbe976d513ef738e65096d0f255775"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad451b020a24fe7111e668f8c41a3ba648104569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad451b020a24fe7111e668f8c41a3ba648104569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad451b020a24fe7111e668f8c41a3ba648104569", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad451b020a24fe7111e668f8c41a3ba648104569/comments", "author": null, "committer": null, "parents": [{"sha": "3ca950c3525527846f13e8c547368ef432547a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca950c3525527846f13e8c547368ef432547a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca950c3525527846f13e8c547368ef432547a23"}], "stats": {"total": 90, "additions": 78, "deletions": 12}, "files": [{"sha": "7d994798e523b141cdba58f421a4a1b02a4e42b1", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad451b020a24fe7111e668f8c41a3ba648104569/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad451b020a24fe7111e668f8c41a3ba648104569/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=ad451b020a24fe7111e668f8c41a3ba648104569", "patch": "@@ -105,9 +105,9 @@ non_null_ref::adjust_range (irange &r, tree name, basic_block bb,\n   // Check if pointers have any non-null dereferences.\n   if (non_null_deref_p (name, bb, search_dom))\n     {\n-      int_range<2> nz;\n-      nz.set_nonzero (TREE_TYPE (name));\n-      r.intersect (nz);\n+      // Remove zero from the range.\n+      unsigned prec = TYPE_PRECISION (TREE_TYPE (name));\n+      r.intersect (wi::one (prec), wi::max_value (prec, UNSIGNED));\n       return true;\n     }\n   return false;"}, {"sha": "ed2fbe121cffbc250052d4ed0cc978a8d02abc70", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad451b020a24fe7111e668f8c41a3ba648104569/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad451b020a24fe7111e668f8c41a3ba648104569/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=ad451b020a24fe7111e668f8c41a3ba648104569", "patch": "@@ -360,12 +360,9 @@ adjust_pointer_diff_expr (irange &res, const gimple *diff_stmt)\n       && integer_zerop (gimple_call_arg (call, 1)))\n     {\n       tree max = vrp_val_max (ptrdiff_type_node);\n-      wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n-      tree expr_type = gimple_range_type (diff_stmt);\n-      tree range_min = build_zero_cst (expr_type);\n-      tree range_max = wide_int_to_tree (expr_type, wmax - 1);\n-      int_range<2> r (range_min, range_max);\n-      res.intersect (r);\n+      unsigned prec = TYPE_PRECISION (TREE_TYPE (max));\n+      wide_int wmaxm1 = wi::to_wide (max, prec) - 1;\n+      res.intersect (wi::zero (prec), wmaxm1);\n     }\n }\n \n@@ -405,9 +402,8 @@ adjust_imagpart_expr (irange &res, const gimple *stmt)\n       tree cst = gimple_assign_rhs1 (def_stmt);\n       if (TREE_CODE (cst) == COMPLEX_CST)\n \t{\n-\t  tree imag = TREE_IMAGPART (cst);\n-\t  int_range<2> tmp (imag, imag);\n-\t  res.intersect (tmp);\n+\t  wide_int imag = wi::to_wide (TREE_IMAGPART (cst));\n+\t  res.intersect (imag, imag);\n \t}\n     }\n }"}, {"sha": "147c4b04c1d2bf50326455a1864ffb5ae3941010", "filename": "gcc/value-range.cc", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad451b020a24fe7111e668f8c41a3ba648104569/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad451b020a24fe7111e668f8c41a3ba648104569/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=ad451b020a24fe7111e668f8c41a3ba648104569", "patch": "@@ -1648,6 +1648,8 @@ void\n irange::irange_intersect (const irange &r)\n {\n   gcc_checking_assert (!legacy_mode_p () && !r.legacy_mode_p ());\n+  gcc_checking_assert (undefined_p () || r.undefined_p ()\n+\t\t       || range_compatible_p (type (), r.type ()));\n \n   if (undefined_p () || r.varying_p ())\n     return;\n@@ -1662,6 +1664,13 @@ irange::irange_intersect (const irange &r)\n       return;\n     }\n \n+  if (r.num_pairs () == 1)\n+   {\n+     // R cannot be undefined, use more efficent pair routine.\n+     intersect (r.lower_bound(), r.upper_bound ());\n+     return;\n+   }\n+\n   signop sign = TYPE_SIGN (TREE_TYPE(m_base[0]));\n   unsigned bld_pair = 0;\n   unsigned bld_lim = m_max_ranges;\n@@ -1737,6 +1746,66 @@ irange::irange_intersect (const irange &r)\n     verify_range ();\n }\n \n+// Multirange intersect for a specified wide_int [lb, ub] range.\n+\n+void\n+irange::intersect (const wide_int& lb, const wide_int& ub)\n+{\n+  // Undefined remains undefined.\n+  if (undefined_p ())\n+    return;\n+\n+  if (legacy_mode_p ())\n+    {\n+      intersect (int_range<1> (type (), lb, ub));\n+      return;\n+    }\n+\n+  tree range_type = type();\n+  signop sign = TYPE_SIGN (range_type);\n+\n+  gcc_checking_assert (TYPE_PRECISION (range_type) == wi::get_precision (lb));\n+  gcc_checking_assert (TYPE_PRECISION (range_type) == wi::get_precision (ub));\n+\n+  unsigned bld_index = 0;\n+  unsigned pair_lim = num_pairs ();\n+  for (unsigned i = 0; i < pair_lim; i++)\n+    {\n+      tree pairl = m_base[i * 2];\n+      tree pairu = m_base[i * 2 + 1];\n+      // Once UB is less than a pairs lower bound, we're done.\n+      if (wi::lt_p (ub, wi::to_wide (pairl), sign))\n+\tbreak;\n+      // if LB is greater than this pairs upper, this pair is excluded.\n+      if (wi::lt_p (wi::to_wide (pairu), lb, sign))\n+\tcontinue;\n+\n+      // Must be some overlap.  Find the highest of the lower bounds,\n+      // and set it\n+      if (wi::gt_p (lb, wi::to_wide (pairl), sign))\n+\tm_base[bld_index * 2] = wide_int_to_tree (range_type, lb);\n+      else\n+\tm_base[bld_index * 2] = pairl;\n+\n+      // ...and choose the lower of the upper bounds and if the base pair\n+      // has the lower upper bound, need to check next pair too.\n+      if (wi::lt_p (ub, wi::to_wide (pairu), sign))\n+\t{\n+\t  m_base[bld_index++ * 2 + 1] = wide_int_to_tree (range_type, ub);\n+\t  break;\n+\t}\n+      else\n+\tm_base[bld_index++ * 2 + 1] = pairu;\n+    }\n+\n+  m_num_ranges = bld_index;\n+\n+  m_kind = VR_RANGE;\n+  normalize_kind ();\n+\n+  if (flag_checking)\n+    verify_range ();\n+}\n // Signed 1-bits are strange.  You can't subtract 1, because you can't\n // represent the number 1.  This works around that for the invert routine.\n "}, {"sha": "ff6c0a6176d6d8db27513147cfe1eaad2f2fa4b9", "filename": "gcc/value-range.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad451b020a24fe7111e668f8c41a3ba648104569/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad451b020a24fe7111e668f8c41a3ba648104569/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=ad451b020a24fe7111e668f8c41a3ba648104569", "patch": "@@ -73,6 +73,7 @@ class GTY((user)) irange\n   // In-place operators.\n   void union_ (const irange &);\n   void intersect (const irange &);\n+  void intersect (const wide_int& lb, const wide_int& ub);\n   void invert ();\n \n   // Operator overloads."}]}