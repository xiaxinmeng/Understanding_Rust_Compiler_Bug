{"sha": "3183acc8e0452fbc0ad429a909811ca0308c86c9", "node_id": "C_kwDOANBUbNoAKDMxODNhY2M4ZTA0NTJmYmMwYWQ0MjlhOTA5ODExY2EwMzA4Yzg2Yzk", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-06-29T00:03:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-06-29T22:18:11Z"}, "message": "compiler: check repeated const expressions in new scope\n\nTest case is const8.go in https://go.dev/cl/414795.\n\nFixes golang/go#53585\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/414914", "tree": {"sha": "b4ad453620f19156baa1ae34900e95a936c10b42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4ad453620f19156baa1ae34900e95a936c10b42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3183acc8e0452fbc0ad429a909811ca0308c86c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3183acc8e0452fbc0ad429a909811ca0308c86c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3183acc8e0452fbc0ad429a909811ca0308c86c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3183acc8e0452fbc0ad429a909811ca0308c86c9/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "329bef49da30158d30fed1106002bb71674776bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329bef49da30158d30fed1106002bb71674776bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/329bef49da30158d30fed1106002bb71674776bd"}], "stats": {"total": 307, "additions": 215, "deletions": 92}, "files": [{"sha": "4fde25af76e892d1cf2e22b1de310a82a41262f9", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3183acc8e0452fbc0ad429a909811ca0308c86c9", "patch": "@@ -1,4 +1,4 @@\n-c7238f58a26131b7611eff6f555cab02af8a623c\n+63782f8a318e9eebfdc983f171a920c7a937c759\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "00d35a965a91f9ea1d7ee2fef55e60d727554d95", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 19, "deletions": 91, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=3183acc8e0452fbc0ad429a909811ca0308c86c9", "patch": "@@ -3352,97 +3352,7 @@ class Find_named_object : public Traverse\n   bool found_;\n };\n \n-// A reference to a const in an expression.\n-\n-class Const_expression : public Expression\n-{\n- public:\n-  Const_expression(Named_object* constant, Location location)\n-    : Expression(EXPRESSION_CONST_REFERENCE, location),\n-      constant_(constant), type_(NULL), seen_(false)\n-  { }\n-\n-  Named_object*\n-  named_object()\n-  { return this->constant_; }\n-\n-  const Named_object*\n-  named_object() const\n-  { return this->constant_; }\n-\n-  // Check that the initializer does not refer to the constant itself.\n-  void\n-  check_for_init_loop();\n-\n- protected:\n-  int\n-  do_traverse(Traverse*);\n-\n-  Expression*\n-  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n-\n-  bool\n-  do_is_constant() const\n-  { return true; }\n-\n-  bool\n-  do_is_zero_value() const\n-  { return this->constant_->const_value()->expr()->is_zero_value(); }\n-\n-  bool\n-  do_is_static_initializer() const\n-  { return true; }\n-\n-  bool\n-  do_numeric_constant_value(Numeric_constant* nc) const;\n-\n-  bool\n-  do_string_constant_value(std::string* val) const;\n-\n-  bool\n-  do_boolean_constant_value(bool* val) const;\n-\n-  Type*\n-  do_type();\n-\n-  // The type of a const is set by the declaration, not the use.\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy()\n-  { return this; }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context* context);\n-\n-  int\n-  do_inlining_cost() const\n-  { return 1; }\n-\n-  // When exporting a reference to a const as part of a const\n-  // expression, we export the value.  We ignore the fact that it has\n-  // a name.\n-  void\n-  do_export(Export_function_body* efb) const\n-  { this->constant_->const_value()->expr()->export_expression(efb); }\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The constant.\n-  Named_object* constant_;\n-  // The type of this reference.  This is used if the constant has an\n-  // abstract type.\n-  Type* type_;\n-  // Used to prevent infinite recursion when a constant incorrectly\n-  // refers to itself.\n-  mutable bool seen_;\n-};\n+// Class Const_expression.\n \n // Traversal.\n \n@@ -3454,6 +3364,14 @@ Const_expression::do_traverse(Traverse* traverse)\n   return TRAVERSE_CONTINUE;\n }\n \n+// Whether this is the zero value.\n+\n+bool\n+Const_expression::do_is_zero_value() const\n+{\n+  return this->constant_->const_value()->expr()->is_zero_value();\n+}\n+\n // Lower a constant expression.  This is where we convert the\n // predeclared constant iota into an integer value.\n \n@@ -3708,6 +3626,16 @@ Const_expression::do_get_backend(Translate_context* context)\n   return expr->get_backend(context);\n }\n \n+// When exporting a reference to a const as part of a const\n+// expression, we export the value.  We ignore the fact that it has\n+// a name.\n+\n+void\n+Const_expression::do_export(Export_function_body* efb) const\n+{\n+  this->constant_->const_value()->expr()->export_expression(efb);\n+}\n+\n // Dump ast representation for constant expression.\n \n void"}, {"sha": "a1e3733aa1db3e16afc176a40cc819b8d326e867", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=3183acc8e0452fbc0ad429a909811ca0308c86c9", "patch": "@@ -28,6 +28,7 @@ class Map_type;\n class Struct_type;\n class Struct_field;\n class Expression_list;\n+class Const_expression;\n class Var_expression;\n class Enclosed_var_expression;\n class Temporary_reference_expression;\n@@ -626,6 +627,20 @@ class Expression\n   is_type_expression() const\n   { return this->classification_ == EXPRESSION_TYPE; }\n \n+  // If this is a const reference, return the Const_expression\n+  // structure.  Otherwise, return NULL.  This is a controlled dynamic\n+  // cast.\n+  Const_expression*\n+  const_expression()\n+  { return this->convert<Const_expression, EXPRESSION_CONST_REFERENCE>(); }\n+\n+  const Const_expression*\n+  const_expression() const\n+  {\n+    return this->convert<const Const_expression,\n+\t\t\t EXPRESSION_CONST_REFERENCE>();\n+  }\n+\n   // If this is a variable reference, return the Var_expression\n   // structure.  Otherwise, return NULL.  This is a controlled dynamic\n   // cast.\n@@ -1453,6 +1468,96 @@ class Parser_expression : public Expression\n   { go_unreachable(); }\n };\n \n+// A reference to a const in an expression.\n+\n+class Const_expression : public Expression\n+{\n+ public:\n+  Const_expression(Named_object* constant, Location location)\n+    : Expression(EXPRESSION_CONST_REFERENCE, location),\n+      constant_(constant), type_(NULL), seen_(false)\n+  { }\n+\n+  Named_object*\n+  named_object()\n+  { return this->constant_; }\n+\n+  const Named_object*\n+  named_object() const\n+  { return this->constant_; }\n+\n+  // Check that the initializer does not refer to the constant itself.\n+  void\n+  check_for_init_loop();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n+  bool\n+  do_is_constant() const\n+  { return true; }\n+\n+  bool\n+  do_is_zero_value() const;\n+\n+  bool\n+  do_is_static_initializer() const\n+  { return true; }\n+\n+  bool\n+  do_numeric_constant_value(Numeric_constant* nc) const;\n+\n+  bool\n+  do_string_constant_value(std::string* val) const;\n+\n+  bool\n+  do_boolean_constant_value(bool* val) const;\n+\n+  Type*\n+  do_type();\n+\n+  // The type of a const is set by the declaration, not the use.\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  { return this; }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n+\n+  int\n+  do_inlining_cost() const\n+  { return 1; }\n+\n+  // When exporting a reference to a const as part of a const\n+  // expression, we export the value.  We ignore the fact that it has\n+  // a name.\n+  void\n+  do_export(Export_function_body* efb) const;\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The constant.\n+  Named_object* constant_;\n+  // The type of this reference.  This is used if the constant has an\n+  // abstract type.\n+  Type* type_;\n+  // Used to prevent infinite recursion when a constant incorrectly\n+  // refers to itself.\n+  mutable bool seen_;\n+};\n+\n // An expression which is simply a variable.\n \n class Var_expression : public Expression"}, {"sha": "e388261f494d266238712c76ddbe5b8c6fbd869f", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=3183acc8e0452fbc0ad429a909811ca0308c86c9", "patch": "@@ -1468,6 +1468,7 @@ Parse::const_spec(int iota, Type** last_type, Expression_list** last_expr_list)\n \t{\n \t  Expression* copy = (*p)->copy();\n \t  copy->set_location(loc);\n+\t  this->update_references(&copy);\n \t  expr_list->push_back(copy);\n \t}\n     }\n@@ -1513,6 +1514,94 @@ Parse::const_spec(int iota, Type** last_type, Expression_list** last_expr_list)\n   return;\n }\n \n+// Update any references to names to refer to the current names,\n+// for weird cases like\n+//\n+// const X = 1\n+// func F() {\n+// \tconst (\n+// \t\tX = X + X\n+//\t\tY\n+// \t)\n+// }\n+//\n+// where the X + X for the first X is the outer X, but the X + X\n+// copied for Y is the inner X.\n+\n+class Update_references : public Traverse\n+{\n+ public:\n+  Update_references(Gogo* gogo)\n+    : Traverse(traverse_expressions),\n+      gogo_(gogo)\n+  { }\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  Gogo* gogo_;\n+};\n+\n+int\n+Update_references::expression(Expression** pexpr)\n+{\n+  Named_object* old_no;\n+  switch ((*pexpr)->classification())\n+    {\n+    case Expression::EXPRESSION_CONST_REFERENCE:\n+      old_no = (*pexpr)->const_expression()->named_object();\n+      break;\n+    case Expression::EXPRESSION_VAR_REFERENCE:\n+      old_no = (*pexpr)->var_expression()->named_object();\n+      break;\n+    case Expression::EXPRESSION_ENCLOSED_VAR_REFERENCE:\n+      old_no = (*pexpr)->enclosed_var_expression()->variable();\n+      break;\n+    case Expression::EXPRESSION_FUNC_REFERENCE:\n+      old_no = (*pexpr)->func_expression()->named_object();\n+      break;\n+    case Expression::EXPRESSION_UNKNOWN_REFERENCE:\n+      old_no = (*pexpr)->unknown_expression()->named_object();\n+      break;\n+    default:\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n+  if (old_no->package() != NULL)\n+    {\n+      // This is a qualified reference, so it can't have changed in\n+      // scope.  FIXME: This probably doesn't handle dot imports\n+      // correctly.\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n+  Named_object* in_function;\n+  Named_object* new_no = this->gogo_->lookup(old_no->name(), &in_function);\n+  if (new_no == old_no)\n+    return TRAVERSE_CONTINUE;\n+\n+  // The new name must be a constant, since that is all we have\n+  // introduced into scope.\n+  if (!new_no->is_const())\n+    {\n+      go_assert(saw_errors());\n+      return TRAVERSE_CONTINUE;\n+    }\n+\n+  *pexpr = Expression::make_const_reference(new_no, (*pexpr)->location());\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+void\n+Parse::update_references(Expression** pexpr)\n+{\n+  Update_references ur(this->gogo_);\n+  ur.expression(pexpr);\n+  (*pexpr)->traverse_subexpressions(&ur);\n+}\n+\n // TypeDecl = \"type\" Decl<TypeSpec> .\n \n void"}, {"sha": "cda0beefebc869d20caf11f637cdf7dab0e6bb05", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3183acc8e0452fbc0ad429a909811ca0308c86c9/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=3183acc8e0452fbc0ad429a909811ca0308c86c9", "patch": "@@ -185,6 +185,7 @@ class Parse\n   void list(void (Parse::*)(), bool);\n   void const_decl();\n   void const_spec(int, Type**, Expression_list**);\n+  void update_references(Expression**);\n   void type_decl();\n   void type_spec();\n   void var_decl();"}]}