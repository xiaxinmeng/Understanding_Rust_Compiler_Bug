{"sha": "974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc0ZGYwZjg3ZjFlY2QzZGEyYjJmODhiODA3YWE5ZjZjMGYyMzc3MA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-07-19T18:48:44Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-07-19T18:48:44Z"}, "message": "re PR fortran/42385 ([OOP] poylmorphic operators do not work)\n\n2010-07-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42385\n\t* interface.c (matching_typebound_op): Add argument for the\n\treturn of the generic name for the procedure.\n\t(build_compcall_for_operator): Add an argument for the generic\n\tname of an operator procedure and supply it to the expression.\n\t(gfc_extend_expr, gfc_extend_assign): Use the generic name in\n\tcalls to the above procedures.\n\t* resolve.c (resolve_typebound_function): Catch procedure\n\tcomponent calls for CLASS objects, check that the vtable is\n\tcomplete and insert the $vptr and procedure components, to make\n\tthe call.\n\t(resolve_typebound_function): The same.\n\t* trans-decl.c (gfc_trans_deferred_vars): Do not deallocate\n\tan allocatable scalar if it is a result.\n\n\n2010-07-19  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/42385\n\t* gfortran.dg/class_defined_operator_1.f03 : New test.\n\nFrom-SVN: r162313", "tree": {"sha": "dcccbe076c70bfa184d4951d084dc40709a025ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcccbe076c70bfa184d4951d084dc40709a025ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/comments", "author": null, "committer": null, "parents": [{"sha": "be30e7b23d673cfdc18bd936380d0c551afdd024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be30e7b23d673cfdc18bd936380d0c551afdd024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be30e7b23d673cfdc18bd936380d0c551afdd024"}], "stats": {"total": 222, "additions": 208, "deletions": 14}, "files": [{"sha": "423a4f1e007a445da654fb682b2aac48e38c436c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "patch": "@@ -1,3 +1,20 @@\n+2010-07-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42385\n+\t* interface.c (matching_typebound_op): Add argument for the\n+\treturn of the generic name for the procedure.\n+\t(build_compcall_for_operator): Add an argument for the generic\n+\tname of an operator procedure and supply it to the expression.\n+\t(gfc_extend_expr, gfc_extend_assign): Use the generic name in\n+\tcalls to the above procedures.\n+\t* resolve.c (resolve_typebound_function): Catch procedure\n+\tcomponent calls for CLASS objects, check that the vtable is\n+\tcomplete and insert the $vptr and procedure components, to make\n+\tthe call.\n+\t(resolve_typebound_function): The same.\n+\t* trans-decl.c (gfc_trans_deferred_vars): Do not deallocate\n+\tan allocatable scalar if it is a result.\n+\n 2010-07-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/44353"}, {"sha": "201961d63557fba9f37a8f642acf1fa98bda6c4a", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "patch": "@@ -2779,12 +2779,14 @@ gfc_find_sym_in_symtree (gfc_symbol *sym)\n /* See if the arglist to an operator-call contains a derived-type argument\n    with a matching type-bound operator.  If so, return the matching specific\n    procedure defined as operator-target as well as the base-object to use\n-   (which is the found derived-type argument with operator).  */\n+   (which is the found derived-type argument with operator).  The generic\n+   name, if any, is transmitted to the final expression via 'gname'.  */\n \n static gfc_typebound_proc*\n matching_typebound_op (gfc_expr** tb_base,\n \t\t       gfc_actual_arglist* args,\n-\t\t       gfc_intrinsic_op op, const char* uop)\n+\t\t       gfc_intrinsic_op op, const char* uop,\n+\t\t       const char ** gname)\n {\n   gfc_actual_arglist* base;\n \n@@ -2850,6 +2852,7 @@ matching_typebound_op (gfc_expr** tb_base,\n \t\tif (matches)\n \t\t  {\n \t\t    *tb_base = base->expr;\n+\t\t    *gname = g->specific_st->name;\n \t\t    return g->specific;\n \t\t  }\n \t      }\n@@ -2868,11 +2871,12 @@ matching_typebound_op (gfc_expr** tb_base,\n \n static void\n build_compcall_for_operator (gfc_expr* e, gfc_actual_arglist* actual,\n-\t\t\t     gfc_expr* base, gfc_typebound_proc* target)\n+\t\t\t     gfc_expr* base, gfc_typebound_proc* target,\n+\t\t\t     const char *gname)\n {\n   e->expr_type = EXPR_COMPCALL;\n   e->value.compcall.tbp = target;\n-  e->value.compcall.name = \"operator\"; /* Should not matter.  */\n+  e->value.compcall.name = gname ? gname : \"$op\";\n   e->value.compcall.actual = actual;\n   e->value.compcall.base_object = base;\n   e->value.compcall.ignore_pass = 1;\n@@ -2898,13 +2902,15 @@ gfc_extend_expr (gfc_expr *e, bool *real_error)\n   gfc_namespace *ns;\n   gfc_user_op *uop;\n   gfc_intrinsic_op i;\n+  const char *gname;\n \n   sym = NULL;\n \n   actual = gfc_get_actual_arglist ();\n   actual->expr = e->value.op.op1;\n \n   *real_error = false;\n+  gname = NULL;\n \n   if (e->value.op.op2 != NULL)\n     {\n@@ -2970,18 +2976,18 @@ gfc_extend_expr (gfc_expr *e, bool *real_error)\n       /* See if we find a matching type-bound operator.  */\n       if (i == INTRINSIC_USER)\n \ttbo = matching_typebound_op (&tb_base, actual,\n-\t\t\t\t     i, e->value.op.uop->name);\n+\t\t\t\t     i, e->value.op.uop->name, &gname);\n       else\n \tswitch (i)\n \t  {\n #define CHECK_OS_COMPARISON(comp) \\\n   case INTRINSIC_##comp: \\\n   case INTRINSIC_##comp##_OS: \\\n     tbo = matching_typebound_op (&tb_base, actual, \\\n-\t\t\t\t INTRINSIC_##comp, NULL); \\\n+\t\t\t\t INTRINSIC_##comp, NULL, &gname); \\\n     if (!tbo) \\\n       tbo = matching_typebound_op (&tb_base, actual, \\\n-\t\t\t\t   INTRINSIC_##comp##_OS, NULL); \\\n+\t\t\t\t   INTRINSIC_##comp##_OS, NULL, &gname); \\\n     break;\n \t    CHECK_OS_COMPARISON(EQ)\n \t    CHECK_OS_COMPARISON(NE)\n@@ -2992,7 +2998,7 @@ gfc_extend_expr (gfc_expr *e, bool *real_error)\n #undef CHECK_OS_COMPARISON\n \n \t    default:\n-\t      tbo = matching_typebound_op (&tb_base, actual, i, NULL);\n+\t      tbo = matching_typebound_op (&tb_base, actual, i, NULL, &gname);\n \t      break;\n \t  }\n \t      \n@@ -3003,7 +3009,7 @@ gfc_extend_expr (gfc_expr *e, bool *real_error)\n \t  gfc_try result;\n \n \t  gcc_assert (tb_base);\n-\t  build_compcall_for_operator (e, actual, tb_base, tbo);\n+\t  build_compcall_for_operator (e, actual, tb_base, tbo, gname);\n \n \t  result = gfc_resolve_expr (e);\n \t  if (result == FAILURE)\n@@ -3050,6 +3056,9 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n   gfc_actual_arglist *actual;\n   gfc_expr *lhs, *rhs;\n   gfc_symbol *sym;\n+  const char *gname;\n+\n+  gname = NULL;\n \n   lhs = c->expr1;\n   rhs = c->expr2;\n@@ -3085,15 +3094,15 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n \n       /* See if we find a matching type-bound assignment.  */\n       tbo = matching_typebound_op (&tb_base, actual,\n-\t\t\t\t   INTRINSIC_ASSIGN, NULL);\n+\t\t\t\t   INTRINSIC_ASSIGN, NULL, &gname);\n \t      \n       /* If there is one, replace the expression with a call to it and\n \t succeed.  */\n       if (tbo)\n \t{\n \t  gcc_assert (tb_base);\n \t  c->expr1 = gfc_get_expr ();\n-\t  build_compcall_for_operator (c->expr1, actual, tb_base, tbo);\n+\t  build_compcall_for_operator (c->expr1, actual, tb_base, tbo, gname);\n \t  c->expr1->value.compcall.assign = 1;\n \t  c->expr2 = NULL;\n \t  c->op = EXEC_COMPCALL;"}, {"sha": "2434be192d7c129a722278ba7eee42d4cf4aa24b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "patch": "@@ -5480,8 +5480,37 @@ resolve_typebound_function (gfc_expr* e)\n   gfc_symtree *st;\n   const char *name;\n   gfc_typespec ts;\n+  gfc_expr *expr;\n \n   st = e->symtree;\n+\n+  /* Deal with typebound operators for CLASS objects.  */\n+  expr = e->value.compcall.base_object;\n+  if (expr && expr->symtree->n.sym->ts.type == BT_CLASS\n+\t&& e->value.compcall.name)\n+    {\n+      /* Since the typebound operators are generic, we have to ensure\n+\t that any delays in resolution are corrected and that the vtab\n+\t is present.  */\n+      ts = expr->symtree->n.sym->ts;\n+      declared = ts.u.derived;\n+      c = gfc_find_component (declared, \"$vptr\", true, true);\n+      if (c->ts.u.derived == NULL)\n+\tc->ts.u.derived = gfc_find_derived_vtab (declared);\n+\n+      if (resolve_compcall (e, &name) == FAILURE)\n+\treturn FAILURE;\n+\n+      /* Use the generic name if it is there.  */\n+      name = name ? name : e->value.function.esym->name;\n+      e->symtree = expr->symtree;\n+      expr->symtree->n.sym->ts.u.derived = declared;\n+      gfc_add_component_ref (e, \"$vptr\");\n+      gfc_add_component_ref (e, name);\n+      e->value.function.esym = NULL;\n+      return SUCCESS;\n+    }\n+\n   if (st == NULL)\n     return resolve_compcall (e, NULL);\n \n@@ -5534,13 +5563,44 @@ resolve_typebound_function (gfc_expr* e)\n static gfc_try\n resolve_typebound_subroutine (gfc_code *code)\n {\n+  gfc_symbol *declared;\n+  gfc_component *c;\n   gfc_ref *new_ref;\n   gfc_ref *class_ref;\n   gfc_symtree *st;\n   const char *name;\n   gfc_typespec ts;\n+  gfc_expr *expr;\n \n   st = code->expr1->symtree;\n+\n+  /* Deal with typebound operators for CLASS objects.  */\n+  expr = code->expr1->value.compcall.base_object;\n+  if (expr && expr->symtree->n.sym->ts.type == BT_CLASS\n+\t&& code->expr1->value.compcall.name)\n+    {\n+      /* Since the typebound operators are generic, we have to ensure\n+\t that any delays in resolution are corrected and that the vtab\n+\t is present.  */\n+      ts = expr->symtree->n.sym->ts;\n+      declared = ts.u.derived;\n+      c = gfc_find_component (declared, \"$vptr\", true, true);\n+      if (c->ts.u.derived == NULL)\n+\tc->ts.u.derived = gfc_find_derived_vtab (declared);\n+\n+      if (resolve_typebound_call (code, &name) == FAILURE)\n+\treturn FAILURE;\n+\n+      /* Use the generic name if it is there.  */\n+      name = name ? name : code->expr1->value.function.esym->name;\n+      code->expr1->symtree = expr->symtree;\n+      expr->symtree->n.sym->ts.u.derived = declared;\n+      gfc_add_component_ref (code->expr1, \"$vptr\");\n+      gfc_add_component_ref (code->expr1, name);\n+      code->expr1->value.function.esym = NULL;\n+      return SUCCESS;\n+    }\n+\n   if (st == NULL)\n     return resolve_typebound_call (code, NULL);\n "}, {"sha": "5932695a587deaf811c2f81040baa2c9b890ed6f", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "patch": "@@ -3249,9 +3249,10 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \n \t      /* Deallocate when leaving the scope. Nullifying is not\n \t\t needed.  */\n-\t      tmp = gfc_deallocate_with_status (se.expr, NULL_TREE, true,\n-\t\t\t\t\t\tNULL);\n-\n+\t      tmp = NULL;\n+\t      if (!sym->attr.result)\n+\t\ttmp = gfc_deallocate_with_status (se.expr, NULL_TREE,\n+\t\t\t\t\t\t  true, NULL);\n \t      gfc_add_init_cleanup (&try_block, gfc_finish_block (&init), tmp);\n \t    }\n \t}"}, {"sha": "e2668148622bb24181fac64da702c2c27ed5ed81", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "patch": "@@ -1,3 +1,8 @@\n+2010-07-19  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/42385\n+\t* gfortran.dg/class_defined_operator_1.f03 : New test.\n+\n 2010-07-19  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* gcc.dg/vect/slp-perm-1.c (main): Make sure loops aren't vectorized."}, {"sha": "008739e3f988b178fc06d2d65219578ff0612b24", "filename": "gcc/testsuite/gfortran.dg/class_defined_operator_1.f03", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_defined_operator_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_defined_operator_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_defined_operator_1.f03?ref=974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "patch": "@@ -0,0 +1,102 @@\n+! { dg-do run }\n+! Test the fix for PR42385, in which CLASS defined operators\n+! compiled but were not correctly dynamically dispatched.\n+!\n+! Contributed by Janus Weil  <janus@gcc.gnu.org>\n+!\n+module foo_module\n+ implicit none\n+ private\n+ public :: foo\n+\n+ type :: foo\n+   integer :: foo_x\n+ contains\n+   procedure :: times => times_foo\n+   procedure :: assign => assign_foo\n+   generic :: operator(*) => times\n+   generic :: assignment(=) => assign\n+ end type\n+\n+contains\n+\n+   function times_foo(this,factor) result(product)\n+     class(foo) ,intent(in) :: this\n+     class(foo) ,allocatable :: product\n+     integer, intent(in) :: factor\n+     allocate (product, source = this)\n+     product%foo_x = -product%foo_x * factor\n+   end function\n+\n+   subroutine assign_foo(lhs,rhs)\n+     class(foo) ,intent(inout) :: lhs\n+     class(foo) ,intent(in) :: rhs\n+     lhs%foo_x = -rhs%foo_x\n+   end subroutine\n+\n+end module\n+\n+module bar_module\n+ use foo_module ,only : foo\n+ implicit none\n+ private\n+ public :: bar\n+\n+ type ,extends(foo) :: bar\n+   integer :: bar_x\n+ contains\n+   procedure :: times => times_bar\n+   procedure :: assign => assign_bar\n+ end type\n+\n+contains\n+ subroutine assign_bar(lhs,rhs)\n+   class(bar) ,intent(inout) :: lhs\n+   class(foo) ,intent(in) :: rhs\n+   select type(rhs)\n+     type is (bar)\n+       lhs%bar_x = rhs%bar_x\n+       lhs%foo_x = -rhs%foo_x\n+   end select\n+ end subroutine\n+ function times_bar(this,factor) result(product)\n+   class(bar) ,intent(in) :: this\n+   integer, intent(in) :: factor\n+   class(foo), allocatable :: product\n+   select type(this)\n+     type is (bar)\n+       allocate(product,source=this)\n+       select type(product)\n+         type is(bar)\n+           product%bar_x = 2*this%bar_x*factor\n+       end select\n+   end select\n+ end function\n+end module\n+\n+program main\n+ use foo_module ,only : foo\n+ use bar_module ,only : bar\n+ implicit none\n+ type(foo) :: unitf\n+ type(bar) :: unitb\n+\n+! foo's assign negates, whilst its '*' negates and mutliplies.\n+ unitf%foo_x = 1\n+ call rescale(unitf, 42)\n+ if (unitf%foo_x .ne. 42) call abort\n+\n+! bar's assign negates foo_x, whilst its '*' copies foo_x\n+! and does a multiply by twice factor.\n+ unitb%foo_x = 1\n+ unitb%bar_x = 2\n+ call rescale(unitb, 3)\n+ if (unitb%bar_x .ne. 12) call abort\n+ if (unitb%foo_x .ne. -1) call abort\n+contains\n+ subroutine rescale(this,scale)\n+   class(foo) ,intent(inout) :: this\n+   integer, intent(in) :: scale\n+   this = this*scale\n+ end subroutine\n+end program"}]}