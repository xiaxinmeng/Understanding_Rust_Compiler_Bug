{"sha": "06688fe40a249a406634d3307f662e2fe2e0c517", "node_id": "C_kwDOANBUbNoAKDA2Njg4ZmU0MGEyNDlhNDA2NjM0ZDMzMDdmNjYyZTJmZTJlMGM1MTc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T11:55:28Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:06Z"}, "message": "gccrs: Add remaining type system transformations\n\nThis patch implements multiple transformation performed on the HIR\nduring type-resolution such as type coercion, casts, auto-dereferencement.\n\n\tgcc/rust/\n\t* typecheck/rust-autoderef.cc: New.\n\t* typecheck/rust-autoderef.h: New.\n\t* typecheck/rust-casts.cc: New.\n\t* typecheck/rust-casts.h: New.\n\t* typecheck/rust-coercion.cc: New.\n\t* typecheck/rust-coercion.h: New.\n\t* typecheck/rust-hir-dot-operator.cc: New.\n\t* typecheck/rust-hir-dot-operator.h: New.\n\t* typecheck/rust-hir-inherent-impl-overlap.h: New.\n\t* typecheck/rust-hir-path-probe.h: New.\n\t* typecheck/rust-hir-trait-ref.h: New.\n\t* typecheck/rust-hir-type-bounds.h: New.\n\t* typecheck/rust-substitution-mapper.cc: New.\n\t* typecheck/rust-substitution-mapper.h: New.\n\t* typecheck/rust-tycheck-dump.h: New.\n\t* typecheck/rust-tyctx.cc: New.\n\t* typecheck/rust-tyty-bounds.cc: New.\n\t* typecheck/rust-tyty-call.cc: New.\n\t* typecheck/rust-tyty-call.h: New.\n\t* typecheck/rust-tyty-cmp.h: New.\n\t* typecheck/rust-tyty-rules.h: New.", "tree": {"sha": "28d9ebdf9c013248c3f88f5f48ed80a31c07c98c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28d9ebdf9c013248c3f88f5f48ed80a31c07c98c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06688fe40a249a406634d3307f662e2fe2e0c517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06688fe40a249a406634d3307f662e2fe2e0c517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06688fe40a249a406634d3307f662e2fe2e0c517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06688fe40a249a406634d3307f662e2fe2e0c517/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24393cb68faadda19c9f0ba12b9bba501e8e4ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24393cb68faadda19c9f0ba12b9bba501e8e4ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24393cb68faadda19c9f0ba12b9bba501e8e4ff8"}], "stats": {"total": 7865, "additions": 7865, "deletions": 0}, "files": [{"sha": "423f8e4709b5c06dd0319bf298acf347230776a9", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,398 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-autoderef.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-dot-operator.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+static bool\n+resolve_operator_overload_fn (\n+  Analysis::RustLangItem::ItemType lang_item_type, const TyTy::BaseType *ty,\n+  TyTy::FnType **resolved_fn, HIR::ImplItem **impl_item,\n+  Adjustment::AdjustmentType *requires_ref_adjustment);\n+\n+TyTy::BaseType *\n+Adjuster::adjust_type (const std::vector<Adjustment> &adjustments)\n+{\n+  if (adjustments.size () == 0)\n+    return base->clone ();\n+\n+  return adjustments.back ().get_expected ()->clone ();\n+}\n+\n+Adjustment\n+Adjuster::try_deref_type (const TyTy::BaseType *ty,\n+\t\t\t  Analysis::RustLangItem::ItemType deref_lang_item)\n+{\n+  HIR::ImplItem *impl_item = nullptr;\n+  TyTy::FnType *fn = nullptr;\n+  Adjustment::AdjustmentType requires_ref_adjustment\n+    = Adjustment::AdjustmentType::ERROR;\n+  bool operator_overloaded\n+    = resolve_operator_overload_fn (deref_lang_item, ty, &fn, &impl_item,\n+\t\t\t\t    &requires_ref_adjustment);\n+  if (!operator_overloaded)\n+    {\n+      return Adjustment::get_error ();\n+    }\n+\n+  auto resolved_base = fn->get_return_type ()->clone ();\n+  bool is_valid_type = resolved_base->get_kind () == TyTy::TypeKind::REF;\n+  if (!is_valid_type)\n+    return Adjustment::get_error ();\n+\n+  TyTy::ReferenceType *ref_base\n+    = static_cast<TyTy::ReferenceType *> (resolved_base);\n+\n+  Adjustment::AdjustmentType adjustment_type\n+    = Adjustment::AdjustmentType::ERROR;\n+  switch (deref_lang_item)\n+    {\n+    case Analysis::RustLangItem::ItemType::DEREF:\n+      adjustment_type = Adjustment::AdjustmentType::DEREF;\n+      break;\n+\n+    case Analysis::RustLangItem::ItemType::DEREF_MUT:\n+      adjustment_type = Adjustment::AdjustmentType::DEREF_MUT;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return Adjustment::get_op_overload_deref_adjustment (adjustment_type, ty,\n+\t\t\t\t\t\t       ref_base, fn, impl_item,\n+\t\t\t\t\t\t       requires_ref_adjustment);\n+}\n+\n+Adjustment\n+Adjuster::try_raw_deref_type (const TyTy::BaseType *ty)\n+{\n+  bool is_valid_type = ty->get_kind () == TyTy::TypeKind::REF;\n+  if (!is_valid_type)\n+    return Adjustment::get_error ();\n+\n+  const TyTy::ReferenceType *ref_base\n+    = static_cast<const TyTy::ReferenceType *> (ty);\n+  auto infered = ref_base->get_base ()->clone ();\n+\n+  return Adjustment (Adjustment::AdjustmentType::INDIRECTION, ty, infered);\n+}\n+\n+Adjustment\n+Adjuster::try_unsize_type (const TyTy::BaseType *ty)\n+{\n+  bool is_valid_type = ty->get_kind () == TyTy::TypeKind::ARRAY;\n+  if (!is_valid_type)\n+    return Adjustment::get_error ();\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = TypeCheckContext::get ();\n+\n+  const auto ref_base = static_cast<const TyTy::ArrayType *> (ty);\n+  auto slice_elem = ref_base->get_element_type ();\n+\n+  auto slice\n+    = new TyTy::SliceType (mappings->get_next_hir_id (), ty->get_ident ().locus,\n+\t\t\t   TyTy::TyVar (slice_elem->get_ref ()));\n+  context->insert_implicit_type (slice);\n+\n+  return Adjustment (Adjustment::AdjustmentType::UNSIZE, ty, slice);\n+}\n+\n+static bool\n+resolve_operator_overload_fn (\n+  Analysis::RustLangItem::ItemType lang_item_type, const TyTy::BaseType *ty,\n+  TyTy::FnType **resolved_fn, HIR::ImplItem **impl_item,\n+  Adjustment::AdjustmentType *requires_ref_adjustment)\n+{\n+  auto context = TypeCheckContext::get ();\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  // look up lang item for arithmetic type\n+  std::string associated_item_name\n+    = Analysis::RustLangItem::ToString (lang_item_type);\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  if (!lang_item_defined)\n+    return false;\n+\n+  auto segment = HIR::PathIdentSegment (associated_item_name);\n+  auto candidate\n+    = MethodResolver::Probe (ty, HIR::PathIdentSegment (associated_item_name),\n+\t\t\t     true);\n+\n+  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  if (!have_implementation_for_lang_item)\n+    return false;\n+\n+  // Get the adjusted self\n+  Adjuster adj (ty);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // is this the case we are recursive\n+  // handle the case where we are within the impl block for this\n+  // lang_item otherwise we end up with a recursive operator overload\n+  // such as the i32 operator overload trait\n+  TypeCheckContextItem &fn_context = context->peek_context ();\n+  if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+    {\n+      auto &impl_item = fn_context.get_impl_item ();\n+      HIR::ImplBlock *parent = impl_item.first;\n+      HIR::Function *fn = impl_item.second;\n+\n+      if (parent->has_trait_ref ()\n+\t  && fn->get_function_name ().compare (associated_item_name) == 0)\n+\t{\n+\t  TraitReference *trait_reference\n+\t    = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t  if (!trait_reference->is_error ())\n+\t    {\n+\t      TyTy::BaseType *lookup = nullptr;\n+\t      bool ok = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t      rust_assert (ok);\n+\t      rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t      TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t      rust_assert (fntype->is_method ());\n+\n+\t      bool is_lang_item_impl\n+\t\t= trait_reference->get_mappings ().get_defid ()\n+\t\t  == respective_lang_item_id;\n+\t      bool self_is_lang_item_self\n+\t\t= fntype->get_self_type ()->is_equal (*adjusted_self);\n+\t      bool recursive_operator_overload\n+\t\t= is_lang_item_impl && self_is_lang_item_self;\n+\n+\t      if (recursive_operator_overload)\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+\n+  // rust only support impl item deref operator overloading ie you must have an\n+  // impl block for it\n+  rust_assert (candidate.candidate.type\n+\t       == PathProbeCandidate::CandidateType::IMPL_FUNC);\n+  *impl_item = candidate.candidate.item.impl.impl_item;\n+\n+  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (fn->is_method ());\n+\n+  if (fn->needs_substitution ())\n+    {\n+      if (ty->get_kind () == TyTy::TypeKind::ADT)\n+\t{\n+\t  const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (ty);\n+\n+\t  auto s = fn->get_self_type ()->get_root ();\n+\t  rust_assert (s->can_eq (adt, false));\n+\t  rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t  const TyTy::ADTType *self_adt\n+\t    = static_cast<const TyTy::ADTType *> (s);\n+\n+\t  // we need to grab the Self substitutions as the inherit type\n+\t  // parameters for this\n+\t  if (self_adt->needs_substitution ())\n+\t    {\n+\t      rust_assert (adt->was_substituted ());\n+\n+\t      TyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (adt);\n+\n+\t      TyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t= self_adt->solve_mappings_from_receiver_for_self (\n+\t\t  used_args_in_prev_segment);\n+\n+\t      // there may or may not be inherited type arguments\n+\t      if (!inherit_type_args.is_error ())\n+\t\t{\n+\t\t  // need to apply the inherited type arguments to the\n+\t\t  // function\n+\t\t  lookup = fn->handle_substitions (inherit_type_args);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rust_assert (candidate.adjustments.size () < 2);\n+\n+\t  // lets infer the params for this we could probably fix this up by\n+\t  // actually just performing a substitution of a single param but this\n+\t  // seems more generic i think.\n+\t  //\n+\t  // this is the case where we had say Foo<&Bar>> and we have derefed to\n+\t  // the &Bar and we are trying to match a method self of Bar which\n+\t  // requires another deref which is matched to the deref trait impl of\n+\t  // &&T so this requires another reference and deref call\n+\n+\t  lookup = fn->infer_substitions (Location ());\n+\t  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\t  fn = static_cast<TyTy::FnType *> (lookup);\n+\t  fn->get_self_type ()->unify (adjusted_self);\n+\t  lookup = fn;\n+\t}\n+    }\n+\n+  if (candidate.adjustments.size () > 0)\n+    *requires_ref_adjustment = candidate.adjustments.at (0).get_type ();\n+\n+  *resolved_fn = static_cast<TyTy::FnType *> (lookup);\n+\n+  return true;\n+}\n+\n+AutoderefCycle::AutoderefCycle (bool autoderef_flag)\n+  : autoderef_flag (autoderef_flag)\n+{}\n+\n+AutoderefCycle::~AutoderefCycle () {}\n+\n+void\n+AutoderefCycle::try_hook (const TyTy::BaseType &)\n+{}\n+\n+bool\n+AutoderefCycle::cycle (const TyTy::BaseType *receiver)\n+{\n+  const TyTy::BaseType *r = receiver;\n+  while (true)\n+    {\n+      if (try_autoderefed (r))\n+\treturn true;\n+\n+      // 4. deref to to 1, if cannot deref then quit\n+      if (autoderef_flag)\n+\treturn false;\n+\n+      // try unsize\n+      Adjustment unsize = Adjuster::try_unsize_type (r);\n+      if (!unsize.is_error ())\n+\t{\n+\t  adjustments.push_back (unsize);\n+\t  auto unsize_r = unsize.get_expected ();\n+\n+\t  if (try_autoderefed (unsize_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      Adjustment deref\n+\t= Adjuster::try_deref_type (r, Analysis::RustLangItem::ItemType::DEREF);\n+      if (!deref.is_error ())\n+\t{\n+\t  auto deref_r = deref.get_expected ();\n+\t  adjustments.push_back (deref);\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      Adjustment deref_mut = Adjuster::try_deref_type (\n+\tr, Analysis::RustLangItem::ItemType::DEREF_MUT);\n+      if (!deref_mut.is_error ())\n+\t{\n+\t  auto deref_r = deref_mut.get_expected ();\n+\t  adjustments.push_back (deref_mut);\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      if (!deref_mut.is_error ())\n+\t{\n+\t  auto deref_r = deref_mut.get_expected ();\n+\t  adjustments.push_back (deref_mut);\n+\t  Adjustment raw_deref = Adjuster::try_raw_deref_type (deref_r);\n+\t  adjustments.push_back (raw_deref);\n+\t  deref_r = raw_deref.get_expected ();\n+\n+\t  if (try_autoderefed (deref_r))\n+\t    return true;\n+\n+\t  adjustments.pop_back ();\n+\t  adjustments.pop_back ();\n+\t}\n+\n+      if (!deref.is_error ())\n+\t{\n+\t  r = deref.get_expected ();\n+\t  adjustments.push_back (deref);\n+\t}\n+      Adjustment raw_deref = Adjuster::try_raw_deref_type (r);\n+      if (raw_deref.is_error ())\n+\treturn false;\n+\n+      r = raw_deref.get_expected ();\n+      adjustments.push_back (raw_deref);\n+    }\n+  return false;\n+}\n+\n+bool\n+AutoderefCycle::try_autoderefed (const TyTy::BaseType *r)\n+{\n+  try_hook (*r);\n+\n+  // 1. try raw\n+  if (select (*r))\n+    return true;\n+\n+  // 2. try ref\n+  TyTy::ReferenceType *r1\n+    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t       Mutability::Imm);\n+  adjustments.push_back (\n+    Adjustment (Adjustment::AdjustmentType::IMM_REF, r, r1));\n+  if (select (*r1))\n+    return true;\n+\n+  adjustments.pop_back ();\n+\n+  // 3. try mut ref\n+  TyTy::ReferenceType *r2\n+    = new TyTy::ReferenceType (r->get_ref (), TyTy::TyVar (r->get_ref ()),\n+\t\t\t       Mutability::Mut);\n+  adjustments.push_back (\n+    Adjustment (Adjustment::AdjustmentType::MUT_REF, r, r2));\n+  if (select (*r2))\n+    return true;\n+\n+  adjustments.pop_back ();\n+\n+  return false;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "2f8d64b97e65f7dc3a90fe644d531a2afb154062", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,178 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AUTODEREF\n+#define RUST_AUTODEREF\n+\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class Adjustment\n+{\n+public:\n+  enum AdjustmentType\n+  {\n+    ERROR,\n+\n+    IMM_REF,\n+    MUT_REF,\n+    DEREF,\n+    DEREF_MUT,\n+    INDIRECTION,\n+    UNSIZE,\n+  };\n+\n+  // ctor for all adjustments except derefs\n+  Adjustment (AdjustmentType type, const TyTy::BaseType *actual,\n+\t      const TyTy::BaseType *expected)\n+    : Adjustment (type, actual, expected, nullptr, nullptr,\n+\t\t  AdjustmentType::ERROR)\n+  {}\n+\n+  static Adjustment get_op_overload_deref_adjustment (\n+    AdjustmentType type, const TyTy::BaseType *actual,\n+    const TyTy::BaseType *expected, TyTy::FnType *fn, HIR::ImplItem *deref_item,\n+    Adjustment::AdjustmentType requires_ref_adjustment)\n+  {\n+    rust_assert (type == DEREF || type == DEREF_MUT);\n+    return Adjustment (type, actual, expected, fn, deref_item,\n+\t\t       requires_ref_adjustment);\n+  }\n+\n+  AdjustmentType get_type () const { return type; }\n+\n+  const TyTy::BaseType *get_actual () const { return actual; }\n+  const TyTy::BaseType *get_expected () const { return expected; }\n+\n+  std::string as_string () const\n+  {\n+    return Adjustment::type_string (get_type ()) + \"->\"\n+\t   + get_expected ()->debug_str ();\n+  }\n+\n+  static std::string type_string (AdjustmentType type)\n+  {\n+    switch (type)\n+      {\n+      case AdjustmentType::ERROR:\n+\treturn \"ERROR\";\n+      case AdjustmentType::IMM_REF:\n+\treturn \"IMM_REF\";\n+      case AdjustmentType::MUT_REF:\n+\treturn \"MUT_REF\";\n+      case AdjustmentType::DEREF:\n+\treturn \"DEREF\";\n+      case AdjustmentType::DEREF_MUT:\n+\treturn \"DEREF_MUT\";\n+      case AdjustmentType::INDIRECTION:\n+\treturn \"INDIRECTION\";\n+      case AdjustmentType::UNSIZE:\n+\treturn \"UNSIZE\";\n+      }\n+    gcc_unreachable ();\n+    return \"\";\n+  }\n+\n+  static Adjustment get_error () { return Adjustment{ERROR, nullptr, nullptr}; }\n+\n+  bool is_error () const { return type == ERROR; }\n+\n+  bool is_deref_adjustment () const { return type == DEREF; }\n+\n+  bool is_deref_mut_adjustment () const { return type == DEREF_MUT; }\n+\n+  bool has_operator_overload () const { return deref_operator_fn != nullptr; }\n+\n+  TyTy::FnType *get_deref_operator_fn () const { return deref_operator_fn; }\n+\n+  AdjustmentType get_deref_adjustment_type () const\n+  {\n+    return requires_ref_adjustment;\n+  }\n+\n+  HIR::ImplItem *get_deref_hir_item () const { return deref_item; }\n+\n+private:\n+  Adjustment (AdjustmentType type, const TyTy::BaseType *actual,\n+\t      const TyTy::BaseType *expected, TyTy::FnType *deref_operator_fn,\n+\t      HIR::ImplItem *deref_item,\n+\t      Adjustment::AdjustmentType requires_ref_adjustment)\n+    : type (type), actual (actual), expected (expected),\n+      deref_operator_fn (deref_operator_fn), deref_item (deref_item),\n+      requires_ref_adjustment (requires_ref_adjustment)\n+  {}\n+\n+  AdjustmentType type;\n+  const TyTy::BaseType *actual;\n+  const TyTy::BaseType *expected;\n+\n+  // - only used for deref operator_overloads\n+  //\n+  // the fn that we are calling\n+  TyTy::FnType *deref_operator_fn;\n+  HIR::ImplItem *deref_item;\n+  // operator overloads can requre a reference\n+  Adjustment::AdjustmentType requires_ref_adjustment;\n+};\n+\n+class Adjuster\n+{\n+public:\n+  Adjuster (const TyTy::BaseType *ty) : base (ty) {}\n+\n+  TyTy::BaseType *adjust_type (const std::vector<Adjustment> &adjustments);\n+\n+  static Adjustment\n+  try_deref_type (const TyTy::BaseType *ty,\n+\t\t  Analysis::RustLangItem::ItemType deref_lang_item);\n+\n+  static Adjustment try_raw_deref_type (const TyTy::BaseType *ty);\n+\n+  static Adjustment try_unsize_type (const TyTy::BaseType *ty);\n+\n+private:\n+  const TyTy::BaseType *base;\n+};\n+\n+class AutoderefCycle\n+{\n+protected:\n+  AutoderefCycle (bool autoderef_flag);\n+\n+  virtual ~AutoderefCycle ();\n+\n+  virtual bool select (const TyTy::BaseType &autoderefed) = 0;\n+\n+  // optional: this is a chance to hook in to grab predicate items on the raw\n+  // type\n+  virtual void try_hook (const TyTy::BaseType &);\n+\n+  virtual bool cycle (const TyTy::BaseType *receiver);\n+\n+  bool try_autoderefed (const TyTy::BaseType *r);\n+\n+  bool autoderef_flag;\n+  std::vector<Adjustment> adjustments;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AUTODEREF"}, {"sha": "61004dfabc379ddfc542e561b262f89888377367", "filename": "gcc/rust/typecheck/rust-casts.cc", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-casts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-casts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-casts.cc?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,292 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-casts.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCastRules::TypeCastRules (Location locus, TyTy::TyWithLocation from,\n+\t\t\t      TyTy::TyWithLocation to)\n+  : locus (locus), from (from), to (to)\n+{}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCastRules::resolve (Location locus, TyTy::TyWithLocation from,\n+\t\t\tTyTy::TyWithLocation to)\n+{\n+  TypeCastRules cast_rules (locus, from, to);\n+  return cast_rules.check ();\n+}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCastRules::check ()\n+{\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/cast.rs#L565-L582\n+  auto possible_coercion\n+    = TypeCoercionRules::TryCoerce (from.get_ty (), to.get_ty (), locus);\n+  if (!possible_coercion.is_error ())\n+    return possible_coercion;\n+\n+  // try the simple cast rules\n+  auto simple_cast = cast_rules ();\n+  if (!simple_cast.is_error ())\n+    return simple_cast;\n+\n+  // failed to cast\n+  emit_cast_error ();\n+  return TypeCoercionRules::CoercionResult::get_error ();\n+}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCastRules::cast_rules ()\n+{\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/cast.rs#L596\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/cast.rs#L654\n+\n+  rust_debug (\"cast_rules from={%s} to={%s}\",\n+\t      from.get_ty ()->debug_str ().c_str (),\n+\t      to.get_ty ()->debug_str ().c_str ());\n+\n+  switch (from.get_ty ()->get_kind ())\n+    {\n+      case TyTy::TypeKind::INFER: {\n+\tTyTy::InferType *from_infer\n+\t  = static_cast<TyTy::InferType *> (from.get_ty ());\n+\tswitch (from_infer->get_infer_kind ())\n+\t  {\n+\t  case TyTy::InferType::InferTypeKind::GENERAL:\n+\t    return TypeCoercionRules::CoercionResult{{},\n+\t\t\t\t\t\t     to.get_ty ()->clone ()};\n+\n+\t  case TyTy::InferType::InferTypeKind::INTEGRAL:\n+\t    switch (to.get_ty ()->get_kind ())\n+\t      {\n+\t      case TyTy::TypeKind::CHAR:\n+\t      case TyTy::TypeKind::BOOL:\n+\t      case TyTy::TypeKind::USIZE:\n+\t      case TyTy::TypeKind::ISIZE:\n+\t      case TyTy::TypeKind::UINT:\n+\t      case TyTy::TypeKind::INT:\n+\t      case TyTy::TypeKind::POINTER:\n+\t\treturn TypeCoercionRules::CoercionResult{\n+\t\t  {}, to.get_ty ()->clone ()};\n+\n+\t\tcase TyTy::TypeKind::INFER: {\n+\t\t  TyTy::InferType *to_infer\n+\t\t    = static_cast<TyTy::InferType *> (to.get_ty ());\n+\n+\t\t  switch (to_infer->get_infer_kind ())\n+\t\t    {\n+\t\t    case TyTy::InferType::InferTypeKind::GENERAL:\n+\t\t    case TyTy::InferType::InferTypeKind::INTEGRAL:\n+\t\t      return TypeCoercionRules::CoercionResult{\n+\t\t\t{}, to.get_ty ()->clone ()};\n+\n+\t\t    default:\n+\t\t      return TypeCoercionRules::CoercionResult::get_error ();\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\treturn TypeCoercionRules::CoercionResult::get_error ();\n+\t      }\n+\t    break;\n+\n+\t  case TyTy::InferType::InferTypeKind::FLOAT:\n+\t    switch (to.get_ty ()->get_kind ())\n+\t      {\n+\t      case TyTy::TypeKind::USIZE:\n+\t      case TyTy::TypeKind::ISIZE:\n+\t      case TyTy::TypeKind::UINT:\n+\t      case TyTy::TypeKind::INT:\n+\t\treturn TypeCoercionRules::CoercionResult{\n+\t\t  {}, to.get_ty ()->clone ()};\n+\n+\t\tcase TyTy::TypeKind::INFER: {\n+\t\t  TyTy::InferType *to_infer\n+\t\t    = static_cast<TyTy::InferType *> (to.get_ty ());\n+\n+\t\t  switch (to_infer->get_infer_kind ())\n+\t\t    {\n+\t\t    case TyTy::InferType::InferTypeKind::GENERAL:\n+\t\t    case TyTy::InferType::InferTypeKind::FLOAT:\n+\t\t      return TypeCoercionRules::CoercionResult{\n+\t\t\t{}, to.get_ty ()->clone ()};\n+\n+\t\t    default:\n+\t\t      return TypeCoercionRules::CoercionResult::get_error ();\n+\t\t    }\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\treturn TypeCoercionRules::CoercionResult::get_error ();\n+\t      }\n+\t    break;\n+\t  }\n+      }\n+      break;\n+\n+    case TyTy::TypeKind::BOOL:\n+      switch (to.get_ty ()->get_kind ())\n+\t{\n+\tcase TyTy::TypeKind::INFER:\n+\tcase TyTy::TypeKind::USIZE:\n+\tcase TyTy::TypeKind::ISIZE:\n+\tcase TyTy::TypeKind::UINT:\n+\tcase TyTy::TypeKind::INT:\n+\t  return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+\n+\tdefault:\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+      break;\n+\n+    case TyTy::TypeKind::CHAR:\n+    case TyTy::TypeKind::USIZE:\n+    case TyTy::TypeKind::ISIZE:\n+    case TyTy::TypeKind::UINT:\n+    case TyTy::TypeKind::INT:\n+      switch (to.get_ty ()->get_kind ())\n+\t{\n+\t  case TyTy::TypeKind::CHAR: {\n+\t    // only u8 and char\n+\t    bool was_uint = from.get_ty ()->get_kind () == TyTy::TypeKind::UINT;\n+\t    bool was_u8 = was_uint\n+\t\t\t  && (static_cast<TyTy::UintType *> (from.get_ty ())\n+\t\t\t\t->get_uint_kind ()\n+\t\t\t      == TyTy::UintType::UintKind::U8);\n+\t    if (was_u8)\n+\t      return TypeCoercionRules::CoercionResult{{},\n+\t\t\t\t\t\t       to.get_ty ()->clone ()};\n+\t  }\n+\t  break;\n+\n+\tcase TyTy::TypeKind::INFER:\n+\tcase TyTy::TypeKind::USIZE:\n+\tcase TyTy::TypeKind::ISIZE:\n+\tcase TyTy::TypeKind::UINT:\n+\tcase TyTy::TypeKind::INT:\n+\t  return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+\n+\tdefault:\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+      break;\n+\n+    case TyTy::TypeKind::FLOAT:\n+      switch (to.get_ty ()->get_kind ())\n+\t{\n+\tcase TyTy::TypeKind::FLOAT:\n+\t  return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+\n+\t  case TyTy::TypeKind::INFER: {\n+\t    TyTy::InferType *to_infer\n+\t      = static_cast<TyTy::InferType *> (to.get_ty ());\n+\n+\t    switch (to_infer->get_infer_kind ())\n+\t      {\n+\t      case TyTy::InferType::InferTypeKind::GENERAL:\n+\t      case TyTy::InferType::InferTypeKind::FLOAT:\n+\t\treturn TypeCoercionRules::CoercionResult{\n+\t\t  {}, to.get_ty ()->clone ()};\n+\n+\t      default:\n+\t\treturn TypeCoercionRules::CoercionResult::get_error ();\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+      break;\n+\n+    case TyTy::TypeKind::REF:\n+    case TyTy::TypeKind::POINTER:\n+      switch (to.get_ty ()->get_kind ())\n+\t{\n+\tcase TyTy::TypeKind::REF:\n+\tcase TyTy::TypeKind::POINTER:\n+\t  return check_ptr_ptr_cast ();\n+\n+\t  // FIXME can you cast a pointer to a integral type?\n+\n+\tdefault:\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+      break;\n+\n+    default:\n+      return TypeCoercionRules::CoercionResult::get_error ();\n+    }\n+\n+  return TypeCoercionRules::CoercionResult::get_error ();\n+}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCastRules::check_ptr_ptr_cast ()\n+{\n+  rust_debug (\"check_ptr_ptr_cast from={%s} to={%s}\",\n+\t      from.get_ty ()->debug_str ().c_str (),\n+\t      to.get_ty ()->debug_str ().c_str ());\n+\n+  bool from_is_ref = from.get_ty ()->get_kind () == TyTy::TypeKind::REF;\n+  bool to_is_ref = to.get_ty ()->get_kind () == TyTy::TypeKind::REF;\n+  bool from_is_ptr = from.get_ty ()->get_kind () == TyTy::TypeKind::POINTER;\n+  bool to_is_ptr = to.get_ty ()->get_kind () == TyTy::TypeKind::POINTER;\n+\n+  if (from_is_ptr && to_is_ptr)\n+    {\n+      // mutability is ignored here as all pointer usage requires unsafe\n+      return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+    }\n+  else if (from_is_ref && to_is_ref)\n+    {\n+      // mutability must be coercedable\n+      TyTy::ReferenceType &f\n+\t= static_cast<TyTy::ReferenceType &> (*from.get_ty ());\n+      TyTy::ReferenceType &t\n+\t= static_cast<TyTy::ReferenceType &> (*to.get_ty ());\n+\n+      if (TypeCoercionRules::coerceable_mutability (f.mutability (),\n+\t\t\t\t\t\t    t.mutability ()))\n+\t{\n+\t  return TypeCoercionRules::CoercionResult{{}, to.get_ty ()->clone ()};\n+\t}\n+    }\n+\n+  return TypeCoercionRules::CoercionResult::get_error ();\n+}\n+\n+void\n+TypeCastRules::emit_cast_error () const\n+{\n+  // error[E0604]\n+  RichLocation r (locus);\n+  r.add_range (from.get_locus ());\n+  r.add_range (to.get_locus ());\n+  rust_error_at (r, \"invalid cast %<%s%> to %<%s%>\",\n+\t\t from.get_ty ()->get_name ().c_str (),\n+\t\t to.get_ty ()->get_name ().c_str ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "e908f49b6563ad35da73c4389b51217d303bd860", "filename": "gcc/rust/typecheck/rust-casts.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-casts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-casts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-casts.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_CASTS\n+#define RUST_CASTS\n+\n+#include \"rust-tyty.h\"\n+#include \"rust-coercion.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCastRules\n+{\n+public:\n+  static TypeCoercionRules::CoercionResult\n+  resolve (Location locus, TyTy::TyWithLocation from, TyTy::TyWithLocation to);\n+\n+protected:\n+  TypeCoercionRules::CoercionResult check ();\n+  TypeCoercionRules::CoercionResult cast_rules ();\n+  TypeCoercionRules::CoercionResult check_ptr_ptr_cast ();\n+\n+  void emit_cast_error () const;\n+\n+protected:\n+  TypeCastRules (Location locus, TyTy::TyWithLocation from,\n+\t\t TyTy::TyWithLocation to);\n+\n+  Location locus;\n+  TyTy::TyWithLocation from;\n+  TyTy::TyWithLocation to;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_CASTS"}, {"sha": "2ad2b8007ff5289fa8db409efbbd1ab184b59458", "filename": "gcc/rust/typecheck/rust-coercion.cc", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.cc?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,357 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-coercion.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::Coerce (TyTy::BaseType *receiver, TyTy::BaseType *expected,\n+\t\t\t   Location locus)\n+{\n+  TypeCoercionRules resolver (expected, locus, true);\n+  bool ok = resolver.do_coercion (receiver);\n+  return ok ? resolver.try_result : CoercionResult::get_error ();\n+}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::TryCoerce (TyTy::BaseType *receiver,\n+\t\t\t      TyTy::BaseType *expected, Location locus)\n+{\n+  TypeCoercionRules resolver (expected, locus, false);\n+  bool ok = resolver.do_coercion (receiver);\n+  return ok ? resolver.try_result : CoercionResult::get_error ();\n+}\n+\n+TypeCoercionRules::TypeCoercionRules (TyTy::BaseType *expected, Location locus,\n+\t\t\t\t      bool emit_errors)\n+  : AutoderefCycle (false), mappings (Analysis::Mappings::get ()),\n+    context (TypeCheckContext::get ()), expected (expected), locus (locus),\n+    try_result (CoercionResult::get_error ()), emit_errors (emit_errors)\n+{}\n+\n+bool\n+TypeCoercionRules::do_coercion (TyTy::BaseType *receiver)\n+{\n+  // FIXME this is not finished and might be super simplified\n+  // see:\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/coercion.rs\n+\n+  // unsize\n+  bool unsafe_error = false;\n+  CoercionResult unsize_coercion\n+    = coerce_unsized (receiver, expected, unsafe_error);\n+  bool valid_unsize_coercion = !unsize_coercion.is_error ();\n+  if (valid_unsize_coercion)\n+    {\n+      try_result = unsize_coercion;\n+      return true;\n+    }\n+  else if (unsafe_error)\n+    {\n+      // Location lhs = mappings->lookup_location (receiver->get_ref ());\n+      // Location rhs = mappings->lookup_location (expected->get_ref ());\n+      // object_unsafe_error (locus, lhs, rhs);\n+      return false;\n+    }\n+\n+  // pointers\n+  switch (expected->get_kind ())\n+    {\n+      case TyTy::TypeKind::POINTER: {\n+\tTyTy::PointerType *ptr = static_cast<TyTy::PointerType *> (expected);\n+\ttry_result = coerce_unsafe_ptr (receiver, ptr, ptr->mutability ());\n+\treturn !try_result.is_error ();\n+      }\n+\n+      case TyTy::TypeKind::REF: {\n+\tTyTy::ReferenceType *ptr\n+\t  = static_cast<TyTy::ReferenceType *> (expected);\n+\ttry_result\n+\t  = coerce_borrowed_pointer (receiver, ptr, ptr->mutability ());\n+\treturn !try_result.is_error ();\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return !try_result.is_error ();\n+}\n+\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::coerce_unsafe_ptr (TyTy::BaseType *receiver,\n+\t\t\t\t      TyTy::PointerType *expected,\n+\t\t\t\t      Mutability to_mutbl)\n+{\n+  rust_debug (\"coerce_unsafe_ptr(a={%s}, b={%s})\",\n+\t      receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n+\n+  Mutability from_mutbl = Mutability::Imm;\n+  TyTy::BaseType *element = nullptr;\n+  switch (receiver->get_kind ())\n+    {\n+      case TyTy::TypeKind::REF: {\n+\tTyTy::ReferenceType *ref\n+\t  = static_cast<TyTy::ReferenceType *> (receiver);\n+\tfrom_mutbl = ref->mutability ();\n+\telement = ref->get_base ();\n+      }\n+      break;\n+\n+      case TyTy::TypeKind::POINTER: {\n+\tTyTy::PointerType *ref = static_cast<TyTy::PointerType *> (receiver);\n+\tfrom_mutbl = ref->mutability ();\n+\telement = ref->get_base ();\n+      }\n+      break;\n+\n+      default: {\n+\tif (receiver->can_eq (expected, false))\n+\t  return CoercionResult{{}, expected->clone ()};\n+\n+\treturn CoercionResult::get_error ();\n+      }\n+    }\n+\n+  if (!coerceable_mutability (from_mutbl, to_mutbl))\n+    {\n+      Location lhs = mappings->lookup_location (receiver->get_ref ());\n+      Location rhs = mappings->lookup_location (expected->get_ref ());\n+      mismatched_mutability_error (locus, lhs, rhs);\n+      return TypeCoercionRules::CoercionResult::get_error ();\n+    }\n+\n+  TyTy::PointerType *result\n+    = new TyTy::PointerType (receiver->get_ref (),\n+\t\t\t     TyTy::TyVar (element->get_ref ()), to_mutbl);\n+  if (!result->can_eq (expected, false))\n+    return CoercionResult::get_error ();\n+\n+  return CoercionResult{{}, result};\n+}\n+\n+/// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n+/// To match `A` with `B`, autoderef will be performed,\n+/// calling `deref`/`deref_mut` where necessary.\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::coerce_borrowed_pointer (TyTy::BaseType *receiver,\n+\t\t\t\t\t    TyTy::ReferenceType *expected,\n+\t\t\t\t\t    Mutability to_mutbl)\n+{\n+  rust_debug (\"coerce_borrowed_pointer(a={%s}, b={%s})\",\n+\t      receiver->debug_str ().c_str (), expected->debug_str ().c_str ());\n+\n+  Mutability from_mutbl = Mutability::Imm;\n+  switch (receiver->get_kind ())\n+    {\n+      case TyTy::TypeKind::REF: {\n+\tTyTy::ReferenceType *ref\n+\t  = static_cast<TyTy::ReferenceType *> (receiver);\n+\tfrom_mutbl = ref->mutability ();\n+      }\n+      break;\n+\n+      default: {\n+\tTyTy::BaseType *result = receiver->unify (expected);\n+\treturn CoercionResult{{}, result};\n+      }\n+    }\n+\n+  if (!coerceable_mutability (from_mutbl, to_mutbl))\n+    {\n+      Location lhs = mappings->lookup_location (receiver->get_ref ());\n+      Location rhs = mappings->lookup_location (expected->get_ref ());\n+      mismatched_mutability_error (locus, lhs, rhs);\n+      return TypeCoercionRules::CoercionResult::get_error ();\n+    }\n+\n+  AutoderefCycle::cycle (receiver);\n+  return try_result;\n+}\n+\n+// &[T; n] or &mut [T; n] -> &[T]\n+// or &mut [T; n] -> &mut [T]\n+// or &Concrete -> &Trait, etc.\n+TypeCoercionRules::CoercionResult\n+TypeCoercionRules::coerce_unsized (TyTy::BaseType *source,\n+\t\t\t\t   TyTy::BaseType *target, bool &unsafe_error)\n+{\n+  rust_debug (\"coerce_unsized(source={%s}, target={%s})\",\n+\t      source->debug_str ().c_str (), target->debug_str ().c_str ());\n+\n+  bool source_is_ref = source->get_kind () == TyTy::TypeKind::REF;\n+  bool target_is_ref = target->get_kind () == TyTy::TypeKind::REF;\n+  bool target_is_ptr = target->get_kind () == TyTy::TypeKind::POINTER;\n+\n+  bool needs_reborrow = false;\n+  TyTy::BaseType *ty_a = source;\n+  TyTy::BaseType *ty_b = target;\n+  Mutability expected_mutability = Mutability::Imm;\n+  if (source_is_ref && target_is_ref)\n+    {\n+      TyTy::ReferenceType *source_ref\n+\t= static_cast<TyTy::ReferenceType *> (source);\n+      TyTy::ReferenceType *target_ref\n+\t= static_cast<TyTy::ReferenceType *> (target);\n+\n+      Mutability from_mutbl = source_ref->mutability ();\n+      Mutability to_mutbl = target_ref->mutability ();\n+      if (!coerceable_mutability (from_mutbl, to_mutbl))\n+\t{\n+\t  unsafe_error = true;\n+\t  Location lhs = mappings->lookup_location (source->get_ref ());\n+\t  Location rhs = mappings->lookup_location (target->get_ref ());\n+\t  mismatched_mutability_error (locus, lhs, rhs);\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+\n+      ty_a = source_ref->get_base ();\n+      ty_b = target_ref->get_base ();\n+      needs_reborrow = true;\n+      expected_mutability = to_mutbl;\n+\n+      adjustments.push_back (\n+\tAdjustment (Adjustment::AdjustmentType::INDIRECTION, source_ref, ty_a));\n+    }\n+  else if (source_is_ref && target_is_ptr)\n+    {\n+      TyTy::ReferenceType *source_ref\n+\t= static_cast<TyTy::ReferenceType *> (source);\n+      TyTy::PointerType *target_ref = static_cast<TyTy::PointerType *> (target);\n+\n+      Mutability from_mutbl = source_ref->mutability ();\n+      Mutability to_mutbl = target_ref->mutability ();\n+      if (!coerceable_mutability (from_mutbl, to_mutbl))\n+\t{\n+\t  unsafe_error = true;\n+\t  Location lhs = mappings->lookup_location (source->get_ref ());\n+\t  Location rhs = mappings->lookup_location (target->get_ref ());\n+\t  mismatched_mutability_error (locus, lhs, rhs);\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+\n+      ty_a = source_ref->get_base ();\n+      ty_b = target_ref->get_base ();\n+      needs_reborrow = true;\n+      expected_mutability = to_mutbl;\n+\n+      adjustments.push_back (\n+\tAdjustment (Adjustment::AdjustmentType::INDIRECTION, source_ref, ty_a));\n+    }\n+\n+  // FIXME\n+  // there is a bunch of code to ensure something is coerce able to a dyn trait\n+  // we need to support but we need to support a few more lang items for that\n+  // see:\n+  // https://github.com/rust-lang/rust/blob/7eac88abb2e57e752f3302f02be5f3ce3d7adfb4/compiler/rustc_typeck/src/check/coercion.rs#L582\n+\n+  const auto a = ty_a;\n+  const auto b = ty_b;\n+\n+  bool expect_dyn = b->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool need_unsize = a->get_kind () != TyTy::TypeKind::DYNAMIC;\n+\n+  if (expect_dyn && need_unsize)\n+    {\n+      bool bounds_compatible = b->bounds_compatible (*a, locus, true);\n+      if (!bounds_compatible)\n+\t{\n+\t  unsafe_error = true;\n+\t  return TypeCoercionRules::CoercionResult::get_error ();\n+\t}\n+\n+      // return the unsize coercion\n+      TyTy::BaseType *result = b->clone ();\n+      // result->set_ref (a->get_ref ());\n+\n+      // append a dyn coercion adjustment\n+      adjustments.push_back (Adjustment (Adjustment::UNSIZE, a, result));\n+\n+      // reborrow if needed\n+      if (needs_reborrow)\n+\t{\n+\t  TyTy::ReferenceType *reborrow\n+\t    = new TyTy::ReferenceType (source->get_ref (),\n+\t\t\t\t       TyTy::TyVar (result->get_ref ()),\n+\t\t\t\t       expected_mutability);\n+\n+\t  Adjustment::AdjustmentType borrow_type\n+\t    = expected_mutability == Mutability::Imm ? Adjustment::IMM_REF\n+\t\t\t\t\t\t     : Adjustment::MUT_REF;\n+\t  adjustments.push_back (Adjustment (borrow_type, result, reborrow));\n+\t  result = reborrow;\n+\t}\n+\n+      return CoercionResult{adjustments, result};\n+    }\n+\n+  adjustments.clear ();\n+  return TypeCoercionRules::CoercionResult::get_error ();\n+}\n+\n+bool\n+TypeCoercionRules::select (const TyTy::BaseType &autoderefed)\n+{\n+  if (autoderefed.can_eq (expected, false))\n+    {\n+      try_result = CoercionResult{adjustments, autoderefed.clone ()};\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/// Coercing a mutable reference to an immutable works, while\n+/// coercing `&T` to `&mut T` should be forbidden.\n+bool\n+TypeCoercionRules::coerceable_mutability (Mutability from_mutbl,\n+\t\t\t\t\t  Mutability to_mutbl)\n+{\n+  return to_mutbl == Mutability::Imm || (from_mutbl == to_mutbl);\n+}\n+\n+void\n+TypeCoercionRules::mismatched_mutability_error (Location expr_locus,\n+\t\t\t\t\t\tLocation lhs, Location rhs)\n+{\n+  if (!emit_errors)\n+    return;\n+\n+  RichLocation r (expr_locus);\n+  r.add_range (lhs);\n+  r.add_range (rhs);\n+  rust_error_at (r, \"mismatched mutability\");\n+}\n+\n+void\n+TypeCoercionRules::object_unsafe_error (Location expr_locus, Location lhs,\n+\t\t\t\t\tLocation rhs)\n+{\n+  if (!emit_errors)\n+    return;\n+\n+  RichLocation r (expr_locus);\n+  r.add_range (lhs);\n+  r.add_range (rhs);\n+  rust_error_at (r, \"unsafe unsize coercion\");\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "da28c7c5e1b2f3f38966017b3e8d3dfed7442ea0", "filename": "gcc/rust/typecheck/rust-coercion.h", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-coercion.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,93 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COERCION\n+#define RUST_COERCION\n+\n+#include \"rust-autoderef.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCoercionRules : protected AutoderefCycle\n+{\n+public:\n+  struct CoercionResult\n+  {\n+    std::vector<Adjustment> adjustments;\n+    TyTy::BaseType *tyty;\n+\n+    bool is_error ()\n+    {\n+      return tyty == nullptr || tyty->get_kind () == TyTy::TypeKind::ERROR;\n+    }\n+\n+    static CoercionResult get_error () { return CoercionResult{{}, nullptr}; }\n+  };\n+\n+  static CoercionResult Coerce (TyTy::BaseType *receiver,\n+\t\t\t\tTyTy::BaseType *expected, Location locus);\n+\n+  static CoercionResult TryCoerce (TyTy::BaseType *receiver,\n+\t\t\t\t   TyTy::BaseType *expected, Location locus);\n+\n+  CoercionResult coerce_unsafe_ptr (TyTy::BaseType *receiver,\n+\t\t\t\t    TyTy::PointerType *expected,\n+\t\t\t\t    Mutability mutability);\n+\n+  CoercionResult coerce_borrowed_pointer (TyTy::BaseType *receiver,\n+\t\t\t\t\t  TyTy::ReferenceType *expected,\n+\t\t\t\t\t  Mutability mutability);\n+\n+  CoercionResult coerce_unsized (TyTy::BaseType *receiver,\n+\t\t\t\t TyTy::BaseType *expected, bool &unsafe_error);\n+\n+  static bool coerceable_mutability (Mutability from_mutbl,\n+\t\t\t\t     Mutability to_mutbl);\n+\n+  void mismatched_mutability_error (Location expr_locus, Location lhs,\n+\t\t\t\t    Location rhs);\n+  void object_unsafe_error (Location expr_locus, Location lhs, Location rhs);\n+\n+protected:\n+  TypeCoercionRules (TyTy::BaseType *expected, Location locus,\n+\t\t     bool emit_errors);\n+\n+  bool select (const TyTy::BaseType &autoderefed) override;\n+\n+  bool do_coercion (TyTy::BaseType *receiver);\n+\n+private:\n+  // context info\n+  Analysis::Mappings *mappings;\n+  TypeCheckContext *context;\n+\n+  // search\n+  TyTy::BaseType *expected;\n+  Location locus;\n+\n+  // mutable fields\n+  CoercionResult try_result;\n+  bool emit_errors;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_COERCION"}, {"sha": "d45f09034781f3b7c18696f0c621b1a059e4c1a7", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,263 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-dot-operator.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+MethodResolver::MethodResolver (bool autoderef_flag,\n+\t\t\t\tconst HIR::PathIdentSegment &segment_name)\n+  : AutoderefCycle (autoderef_flag), mappings (Analysis::Mappings::get ()),\n+    context (TypeCheckContext::get ()), segment_name (segment_name),\n+    try_result (MethodCandidate::get_error ())\n+{}\n+\n+MethodCandidate\n+MethodResolver::Probe (const TyTy::BaseType *receiver,\n+\t\t       const HIR::PathIdentSegment &segment_name,\n+\t\t       bool autoderef_flag)\n+{\n+  MethodResolver resolver (autoderef_flag, segment_name);\n+  bool ok = resolver.cycle (receiver);\n+  return ok ? resolver.try_result : MethodCandidate::get_error ();\n+}\n+\n+void\n+MethodResolver::try_hook (const TyTy::BaseType &r)\n+{\n+  const auto &specified_bounds = r.get_specified_bounds ();\n+  predicate_items = get_predicate_items (segment_name, r, specified_bounds);\n+}\n+\n+bool\n+MethodResolver::select (const TyTy::BaseType &receiver)\n+{\n+  struct impl_item_candidate\n+  {\n+    HIR::Function *item;\n+    HIR::ImplBlock *impl_block;\n+    TyTy::FnType *ty;\n+  };\n+\n+  // assemble inherent impl items\n+  std::vector<impl_item_candidate> inherent_impl_fns;\n+  mappings->iterate_impl_items (\n+    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n+      bool is_trait_impl = impl->has_trait_ref ();\n+      if (is_trait_impl)\n+\treturn true;\n+\n+      bool is_fn\n+\t= item->get_impl_item_type () == HIR::ImplItem::ImplItemType::FUNCTION;\n+      if (!is_fn)\n+\treturn true;\n+\n+      HIR::Function *func = static_cast<HIR::Function *> (item);\n+      if (!func->is_method ())\n+\treturn true;\n+\n+      bool name_matches\n+\t= func->get_function_name ().compare (segment_name.as_string ()) == 0;\n+      if (!name_matches)\n+\treturn true;\n+\n+      TyTy::BaseType *ty = nullptr;\n+      if (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n+\treturn true;\n+      if (ty->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn true;\n+\n+      rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+      inherent_impl_fns.push_back ({func, impl, fnty});\n+\n+      return true;\n+    });\n+\n+  struct trait_item_candidate\n+  {\n+    const HIR::TraitItemFunc *item;\n+    const HIR::Trait *trait;\n+    TyTy::FnType *ty;\n+    const TraitReference *reference;\n+    const TraitItemReference *item_ref;\n+  };\n+\n+  std::vector<trait_item_candidate> trait_fns;\n+  mappings->iterate_impl_blocks ([&] (HirId id,\n+\t\t\t\t      HIR::ImplBlock *impl) mutable -> bool {\n+    bool is_trait_impl = impl->has_trait_ref ();\n+    if (!is_trait_impl)\n+      return true;\n+\n+    // look for impl implementation else lookup the associated trait item\n+    for (auto &impl_item : impl->get_impl_items ())\n+      {\n+\tbool is_fn = impl_item->get_impl_item_type ()\n+\t\t     == HIR::ImplItem::ImplItemType::FUNCTION;\n+\tif (!is_fn)\n+\t  continue;\n+\n+\tHIR::Function *func = static_cast<HIR::Function *> (impl_item.get ());\n+\tif (!func->is_method ())\n+\t  continue;\n+\n+\tbool name_matches\n+\t  = func->get_function_name ().compare (segment_name.as_string ()) == 0;\n+\tif (!name_matches)\n+\t  continue;\n+\n+\tTyTy::BaseType *ty = nullptr;\n+\tif (!context->lookup_type (func->get_mappings ().get_hirid (), &ty))\n+\t  continue;\n+\tif (ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  continue;\n+\n+\trust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+\tTyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+\tinherent_impl_fns.push_back ({func, impl, fnty});\n+\treturn true;\n+      }\n+\n+    TraitReference *trait_ref\n+      = TraitResolver::Resolve (*impl->get_trait_ref ().get ());\n+    rust_assert (!trait_ref->is_error ());\n+\n+    auto item_ref\n+      = trait_ref->lookup_trait_item (segment_name.as_string (),\n+\t\t\t\t      TraitItemReference::TraitItemType::FN);\n+    if (item_ref->is_error ())\n+      return true;\n+\n+    const HIR::Trait *trait = trait_ref->get_hir_trait_ref ();\n+    HIR::TraitItem *item = item_ref->get_hir_trait_item ();\n+    rust_assert (item->get_item_kind () == HIR::TraitItem::TraitItemKind::FUNC);\n+    HIR::TraitItemFunc *func = static_cast<HIR::TraitItemFunc *> (item);\n+\n+    TyTy::BaseType *ty = item_ref->get_tyty ();\n+    rust_assert (ty->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\n+    trait_item_candidate candidate{func, trait, fnty, trait_ref, item_ref};\n+    trait_fns.push_back (candidate);\n+\n+    return true;\n+  });\n+\n+  // lookup specified bounds for an associated item\n+  struct precdicate_candidate\n+  {\n+    TyTy::TypeBoundPredicateItem lookup;\n+    TyTy::FnType *fntype;\n+  };\n+\n+  for (auto impl_item : inherent_impl_fns)\n+    {\n+      TyTy::FnType *fn = impl_item.ty;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      if (fn_self->can_eq (&receiver, false))\n+\t{\n+\t  PathProbeCandidate::ImplItemCandidate c{impl_item.item,\n+\t\t\t\t\t\t  impl_item.impl_block};\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::IMPL_FUNC,\n+\t\t\t\tfn, impl_item.item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n+\t}\n+    }\n+\n+  for (auto trait_item : trait_fns)\n+    {\n+      TyTy::FnType *fn = trait_item.ty;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      if (fn_self->can_eq (&receiver, false))\n+\t{\n+\t  PathProbeCandidate::TraitItemCandidate c{trait_item.reference,\n+\t\t\t\t\t\t   trait_item.item_ref,\n+\t\t\t\t\t\t   nullptr};\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n+\t\t\t\tfn, trait_item.item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n+\t}\n+    }\n+\n+  for (const auto &predicate : predicate_items)\n+    {\n+      const TyTy::FnType *fn = predicate.fntype;\n+      rust_assert (fn->is_method ());\n+\n+      TyTy::BaseType *fn_self = fn->get_self_type ();\n+      if (fn_self->can_eq (&receiver, false))\n+\t{\n+\t  const TraitReference *trait_ref\n+\t    = predicate.lookup.get_parent ()->get ();\n+\t  const TraitItemReference *trait_item\n+\t    = predicate.lookup.get_raw_item ();\n+\n+\t  PathProbeCandidate::TraitItemCandidate c{trait_ref, trait_item,\n+\t\t\t\t\t\t   nullptr};\n+\t  try_result = MethodCandidate{\n+\t    PathProbeCandidate (PathProbeCandidate::CandidateType::TRAIT_FUNC,\n+\t\t\t\tfn->clone (), trait_item->get_locus (), c),\n+\t    adjustments};\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+std::vector<MethodResolver::predicate_candidate>\n+MethodResolver::get_predicate_items (\n+  const HIR::PathIdentSegment &segment_name, const TyTy::BaseType &receiver,\n+  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds)\n+{\n+  std::vector<predicate_candidate> predicate_items;\n+  for (auto &bound : specified_bounds)\n+    {\n+      TyTy::TypeBoundPredicateItem lookup\n+\t= bound.lookup_associated_item (segment_name.as_string ());\n+      if (lookup.is_error ())\n+\tcontinue;\n+\n+      TyTy::BaseType *ty = lookup.get_tyty_for_receiver (&receiver);\n+      if (ty->get_kind () == TyTy::TypeKind::FNDEF)\n+\t{\n+\t  TyTy::FnType *fnty = static_cast<TyTy::FnType *> (ty);\n+\t  predicate_candidate candidate{lookup, fnty};\n+\t  predicate_items.push_back (candidate);\n+\t}\n+    }\n+\n+  return predicate_items;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "750601a2d9e6a583786eabfc75b6e7581a3efa36", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_DOT_OPERATOR\n+#define RUST_HIR_DOT_OPERATOR\n+\n+#include \"rust-hir-path-probe.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+struct MethodCandidate\n+{\n+  PathProbeCandidate candidate;\n+  std::vector<Adjustment> adjustments;\n+\n+  static MethodCandidate get_error ()\n+  {\n+    return {PathProbeCandidate::get_error (), {}};\n+  }\n+\n+  bool is_error () const { return candidate.is_error (); }\n+};\n+\n+class MethodResolver : protected AutoderefCycle\n+{\n+public:\n+  struct predicate_candidate\n+  {\n+    TyTy::TypeBoundPredicateItem lookup;\n+    TyTy::FnType *fntype;\n+  };\n+\n+  static MethodCandidate Probe (const TyTy::BaseType *receiver,\n+\t\t\t\tconst HIR::PathIdentSegment &segment_name,\n+\t\t\t\tbool autoderef_flag = false);\n+\n+  static std::vector<predicate_candidate> get_predicate_items (\n+    const HIR::PathIdentSegment &segment_name, const TyTy::BaseType &receiver,\n+    const std::vector<TyTy::TypeBoundPredicate> &specified_bounds);\n+\n+protected:\n+  MethodResolver (bool autoderef_flag,\n+\t\t  const HIR::PathIdentSegment &segment_name);\n+\n+  void try_hook (const TyTy::BaseType &r) override;\n+\n+  bool select (const TyTy::BaseType &receiver) override;\n+\n+private:\n+  // context info\n+  Analysis::Mappings *mappings;\n+  TypeCheckContext *context;\n+\n+  // search\n+  const HIR::PathIdentSegment &segment_name;\n+  std::vector<MethodResolver::predicate_candidate> predicate_items;\n+\n+  // mutable fields\n+  MethodCandidate try_result;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_DOT_OPERATOR"}, {"sha": "2890b54a00de6924b213208cbd9fe2a838067aa6", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,186 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H\n+#define RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ImplItemToName : private TypeCheckBase, private HIR::HIRImplVisitor\n+{\n+public:\n+  static bool resolve (HIR::ImplItem *item, std::string &name_result)\n+  {\n+    ImplItemToName resolver (name_result);\n+    item->accept_vis (resolver);\n+    return resolver.ok;\n+  }\n+\n+  void visit (HIR::TypeAlias &alias) override\n+  {\n+    ok = true;\n+    result.assign (alias.get_new_type_name ());\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    ok = true;\n+    result.assign (function.get_function_name ());\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    ok = true;\n+    result.assign (constant.get_identifier ());\n+  }\n+\n+private:\n+  ImplItemToName (std::string &result)\n+    : TypeCheckBase (), ok (false), result (result)\n+  {}\n+\n+  bool ok;\n+  std::string &result;\n+};\n+\n+class OverlappingImplItemPass : public TypeCheckBase\n+{\n+public:\n+  static void go ()\n+  {\n+    OverlappingImplItemPass pass;\n+\n+    // generate mappings\n+    pass.mappings->iterate_impl_items (\n+      [&] (HirId id, HIR::ImplItem *impl_item, HIR::ImplBlock *impl) -> bool {\n+\t// ignoring trait-impls might need thought later on\n+\tif (impl->has_trait_ref ())\n+\t  return true;\n+\n+\tpass.process_impl_item (id, impl_item, impl);\n+\treturn true;\n+      });\n+\n+    pass.scan ();\n+  }\n+\n+  void process_impl_item (HirId id, HIR::ImplItem *impl_item,\n+\t\t\t  HIR::ImplBlock *impl)\n+  {\n+    // lets make a mapping of impl-item Self type to (impl-item,name):\n+    // {\n+    //   impl-type -> [ (item, name), ... ]\n+    // }\n+\n+    HirId impl_type_id = impl->get_type ()->get_mappings ().get_hirid ();\n+    TyTy::BaseType *impl_type = nullptr;\n+    bool ok = context->lookup_type (impl_type_id, &impl_type);\n+    rust_assert (ok);\n+\n+    std::string impl_item_name;\n+    ok = ImplItemToName::resolve (impl_item, impl_item_name);\n+    rust_assert (ok);\n+\n+    std::pair<HIR::ImplItem *, std::string> elem (impl_item, impl_item_name);\n+    impl_mappings[impl_type].insert (std::move (elem));\n+  }\n+\n+  void scan ()\n+  {\n+    // we can now brute force the map looking for can_eq on each of the\n+    // impl_items_types to look for possible colliding impl blocks;\n+    for (auto it = impl_mappings.begin (); it != impl_mappings.end (); it++)\n+      {\n+\tTyTy::BaseType *query = it->first;\n+\n+\tfor (auto iy = impl_mappings.begin (); iy != impl_mappings.end (); iy++)\n+\t  {\n+\t    TyTy::BaseType *candidate = iy->first;\n+\t    if (query == candidate)\n+\t      continue;\n+\n+\t    if (query->can_eq (candidate, false))\n+\t      {\n+\t\t// we might be in the case that we have:\n+\t\t//\n+\t\t// *const T vs *const [T]\n+\t\t//\n+\t\t// so lets use an equality check when the\n+\t\t// candidates are both generic to be sure we dont emit a false\n+\t\t// positive\n+\n+\t\tbool a = query->is_concrete ();\n+\t\tbool b = candidate->is_concrete ();\n+\t\tbool both_generic = !a && !b;\n+\t\tif (both_generic)\n+\t\t  {\n+\t\t    if (!query->is_equal (*candidate))\n+\t\t      continue;\n+\t\t  }\n+\n+\t\tpossible_collision (it->second, iy->second);\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+  void possible_collision (\n+    std::set<std::pair<HIR::ImplItem *, std::string> > query,\n+    std::set<std::pair<HIR::ImplItem *, std::string> > candidate)\n+  {\n+    for (auto &q : query)\n+      {\n+\tHIR::ImplItem *query_impl_item = q.first;\n+\tstd::string query_impl_item_name = q.second;\n+\n+\tfor (auto &c : candidate)\n+\t  {\n+\t    HIR::ImplItem *candidate_impl_item = c.first;\n+\t    std::string candidate_impl_item_name = c.second;\n+\n+\t    if (query_impl_item_name.compare (candidate_impl_item_name) == 0)\n+\t      collision_detected (query_impl_item, candidate_impl_item,\n+\t\t\t\t  candidate_impl_item_name);\n+\t  }\n+      }\n+  }\n+\n+  void collision_detected (HIR::ImplItem *query, HIR::ImplItem *dup,\n+\t\t\t   const std::string &name)\n+  {\n+    RichLocation r (dup->get_locus ());\n+    r.add_range (query->get_locus ());\n+    rust_error_at (r, \"duplicate definitions with name %s\", name.c_str ());\n+  }\n+\n+private:\n+  OverlappingImplItemPass () : TypeCheckBase () {}\n+\n+  std::map<TyTy::BaseType *,\n+\t   std::set<std::pair<HIR::ImplItem *, std::string> > >\n+    impl_mappings;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_INHERENT_IMPL_ITEM_OVERLAP_H"}, {"sha": "bd4f91e49bf266e8bda2f947adf4f91c8ea55d64", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "added", "additions": 540, "deletions": 0, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,540 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATH_PROBE_H\n+#define RUST_HIR_PATH_PROBE_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-type-bounds.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+struct PathProbeCandidate\n+{\n+  enum CandidateType\n+  {\n+    ERROR,\n+\n+    ENUM_VARIANT,\n+\n+    IMPL_CONST,\n+    IMPL_TYPE_ALIAS,\n+    IMPL_FUNC,\n+\n+    TRAIT_ITEM_CONST,\n+    TRAIT_TYPE_ALIAS,\n+    TRAIT_FUNC,\n+  };\n+\n+  struct EnumItemCandidate\n+  {\n+    const TyTy::ADTType *parent;\n+    const TyTy::VariantDef *variant;\n+  };\n+\n+  struct ImplItemCandidate\n+  {\n+    HIR::ImplItem *impl_item;\n+    HIR::ImplBlock *parent;\n+  };\n+\n+  struct TraitItemCandidate\n+  {\n+    const TraitReference *trait_ref;\n+    const TraitItemReference *item_ref;\n+    HIR::ImplBlock *impl;\n+  };\n+\n+  CandidateType type;\n+  TyTy::BaseType *ty;\n+  Location locus;\n+  union Candidate\n+  {\n+    EnumItemCandidate enum_field;\n+    ImplItemCandidate impl;\n+    TraitItemCandidate trait;\n+\n+    Candidate (EnumItemCandidate enum_field) : enum_field (enum_field) {}\n+    Candidate (ImplItemCandidate impl) : impl (impl) {}\n+    Candidate (TraitItemCandidate trait) : trait (trait) {}\n+  } item;\n+\n+  PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n+\t\t      EnumItemCandidate enum_field)\n+    : type (type), ty (ty), item (enum_field)\n+  {}\n+\n+  PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n+\t\t      ImplItemCandidate impl)\n+    : type (type), ty (ty), item (impl)\n+  {}\n+\n+  PathProbeCandidate (CandidateType type, TyTy::BaseType *ty, Location locus,\n+\t\t      TraitItemCandidate trait)\n+    : type (type), ty (ty), item (trait)\n+  {}\n+\n+  std::string as_string () const\n+  {\n+    return \"PathProbe candidate TODO - as_string\";\n+  }\n+\n+  bool is_enum_candidate () const { return type == ENUM_VARIANT; }\n+\n+  bool is_impl_candidate () const\n+  {\n+    return type == IMPL_CONST || type == IMPL_TYPE_ALIAS || type == IMPL_FUNC;\n+  }\n+\n+  bool is_trait_candidate () const\n+  {\n+    return type == TRAIT_ITEM_CONST || type == TRAIT_TYPE_ALIAS\n+\t   || type == TRAIT_FUNC;\n+  }\n+\n+  bool is_full_trait_item_candidate () const\n+  {\n+    return is_trait_candidate () && item.trait.impl == nullptr;\n+  }\n+\n+  static PathProbeCandidate get_error ()\n+  {\n+    return PathProbeCandidate (ERROR, nullptr, Location (),\n+\t\t\t       ImplItemCandidate{nullptr, nullptr});\n+  }\n+\n+  bool is_error () const { return type == ERROR; }\n+};\n+\n+class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n+{\n+public:\n+  static std::vector<PathProbeCandidate>\n+  Probe (const TyTy::BaseType *receiver,\n+\t const HIR::PathIdentSegment &segment_name, bool probe_impls,\n+\t bool probe_bounds, bool ignore_mandatory_trait_items,\n+\t DefId specific_trait_id = UNKNOWN_DEFID)\n+  {\n+    PathProbeType probe (receiver, segment_name, specific_trait_id);\n+    if (probe_impls)\n+      {\n+\tif (receiver->get_kind () == TyTy::TypeKind::ADT)\n+\t  {\n+\t    const TyTy::ADTType *adt\n+\t      = static_cast<const TyTy::ADTType *> (receiver);\n+\t    if (adt->is_enum ())\n+\t      probe.process_enum_item_for_candiates (adt);\n+\t  }\n+\n+\tprobe.process_impl_items_for_candidates ();\n+      }\n+\n+    if (!probe_bounds)\n+      return probe.candidates;\n+\n+    if (!probe.is_reciever_generic ())\n+      {\n+\tstd::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n+\t  = TypeBoundsProbe::Probe (receiver);\n+\tfor (auto &candidate : probed_bounds)\n+\t  {\n+\t    const TraitReference *trait_ref = candidate.first;\n+\t    if (specific_trait_id != UNKNOWN_DEFID)\n+\t      {\n+\t\tif (trait_ref->get_mappings ().get_defid ()\n+\t\t    != specific_trait_id)\n+\t\t  continue;\n+\t      }\n+\n+\t    HIR::ImplBlock *impl = candidate.second;\n+\t    probe.process_associated_trait_for_candidates (\n+\t      trait_ref, impl, ignore_mandatory_trait_items);\n+\t  }\n+      }\n+\n+    for (const TyTy::TypeBoundPredicate &predicate :\n+\t receiver->get_specified_bounds ())\n+      {\n+\tconst TraitReference *trait_ref = predicate.get ();\n+\tif (specific_trait_id != UNKNOWN_DEFID)\n+\t  {\n+\t    if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n+\t      continue;\n+\t  }\n+\n+\tprobe.process_predicate_for_candidates (predicate,\n+\t\t\t\t\t\tignore_mandatory_trait_items);\n+      }\n+\n+    return probe.candidates;\n+  }\n+\n+  void visit (HIR::TypeAlias &alias) override\n+  {\n+    Identifier name = alias.get_new_type_name ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = alias.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&alias,\n+\t\t\t\t\t\t\t\t  current_impl};\n+\tPathProbeCandidate candidate{\n+\t  PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, ty,\n+\t  alias.get_locus (), impl_item_candidate};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    Identifier name = constant.get_identifier ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = constant.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&constant,\n+\t\t\t\t\t\t\t\t  current_impl};\n+\tPathProbeCandidate candidate{\n+\t  PathProbeCandidate::CandidateType::IMPL_CONST, ty,\n+\t  constant.get_locus (), impl_item_candidate};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    Identifier name = function.get_function_name ();\n+    if (search.as_string ().compare (name) == 0)\n+      {\n+\tHirId tyid = function.get_mappings ().get_hirid ();\n+\tTyTy::BaseType *ty = nullptr;\n+\tbool ok = context->lookup_type (tyid, &ty);\n+\trust_assert (ok);\n+\n+\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&function,\n+\t\t\t\t\t\t\t\t  current_impl};\n+\tPathProbeCandidate candidate{\n+\t  PathProbeCandidate::CandidateType::IMPL_FUNC, ty,\n+\t  function.get_locus (), impl_item_candidate};\n+\tcandidates.push_back (std::move (candidate));\n+      }\n+  }\n+\n+protected:\n+  void process_enum_item_for_candiates (const TyTy::ADTType *adt)\n+  {\n+    if (specific_trait_id != UNKNOWN_DEFID)\n+      return;\n+\n+    TyTy::VariantDef *v;\n+    if (!adt->lookup_variant (search.as_string (), &v))\n+      return;\n+\n+    PathProbeCandidate::EnumItemCandidate enum_item_candidate{adt, v};\n+    PathProbeCandidate candidate{\n+      PathProbeCandidate::CandidateType::ENUM_VARIANT, receiver->clone (),\n+      mappings->lookup_location (adt->get_ty_ref ()), enum_item_candidate};\n+    candidates.push_back (std::move (candidate));\n+  }\n+\n+  void process_impl_items_for_candidates ()\n+  {\n+    mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n+\t\t\t\t       HIR::ImplBlock *impl) mutable -> bool {\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+  }\n+\n+  void process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n+\t\t\t\t    HIR::ImplBlock *impl)\n+  {\n+    current_impl = impl;\n+    HirId impl_ty_id = impl->get_type ()->get_mappings ().get_hirid ();\n+    TyTy::BaseType *impl_block_ty = nullptr;\n+    if (!context->lookup_type (impl_ty_id, &impl_block_ty))\n+      return;\n+\n+    if (!receiver->can_eq (impl_block_ty, false))\n+      {\n+\tif (!impl_block_ty->can_eq (receiver, false))\n+\t  return;\n+      }\n+\n+    // lets visit the impl_item\n+    item->accept_vis (*this);\n+  }\n+\n+  void\n+  process_associated_trait_for_candidates (const TraitReference *trait_ref,\n+\t\t\t\t\t   HIR::ImplBlock *impl,\n+\t\t\t\t\t   bool ignore_mandatory_trait_items)\n+  {\n+    const TraitItemReference *trait_item_ref = nullptr;\n+    if (!trait_ref->lookup_trait_item (search.as_string (), &trait_item_ref))\n+      return;\n+\n+    bool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n+    if (ignore_mandatory_trait_items && trait_item_needs_implementation)\n+      return;\n+\n+    PathProbeCandidate::CandidateType candidate_type;\n+    switch (trait_item_ref->get_trait_item_type ())\n+      {\n+      case TraitItemReference::TraitItemType::FN:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::CONST:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::TYPE:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+\tbreak;\n+\n+      case TraitItemReference::TraitItemType::ERROR:\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      }\n+\n+    TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n+\n+    // we can substitute the Self with the receiver here\n+    if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+      {\n+\tTyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+\tTyTy::SubstitutionParamMapping *param = nullptr;\n+\tfor (auto &param_mapping : fn->get_substs ())\n+\t  {\n+\t    const HIR::TypeParam &type_param\n+\t      = param_mapping.get_generic_param ();\n+\t    if (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t      {\n+\t\tparam = &param_mapping;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\trust_assert (param != nullptr);\n+\n+\tstd::vector<TyTy::SubstitutionArg> mappings;\n+\tmappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+\tLocation locus; // FIXME\n+\tTyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+\ttrait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n+      }\n+\n+    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t\ttrait_item_ref,\n+\t\t\t\t\t\t\t\timpl};\n+\n+    PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n+\t\t\t\t trait_ref->get_locus (), trait_item_candidate};\n+    candidates.push_back (std::move (candidate));\n+  }\n+\n+  void\n+  process_predicate_for_candidates (const TyTy::TypeBoundPredicate &predicate,\n+\t\t\t\t    bool ignore_mandatory_trait_items)\n+  {\n+    const TraitReference *trait_ref = predicate.get ();\n+\n+    TyTy::TypeBoundPredicateItem item\n+      = predicate.lookup_associated_item (search.as_string ());\n+    if (item.is_error ())\n+      return;\n+\n+    if (ignore_mandatory_trait_items && item.needs_implementation ())\n+      return;\n+\n+    const TraitItemReference *trait_item_ref = item.get_raw_item ();\n+    PathProbeCandidate::CandidateType candidate_type;\n+    switch (trait_item_ref->get_trait_item_type ())\n+      {\n+      case TraitItemReference::TraitItemType::FN:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::CONST:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::TYPE:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+\tbreak;\n+\n+      case TraitItemReference::TraitItemType::ERROR:\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      }\n+\n+    TyTy::BaseType *trait_item_tyty = item.get_tyty_for_receiver (receiver);\n+    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t\ttrait_item_ref,\n+\t\t\t\t\t\t\t\tnullptr};\n+    PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n+\t\t\t\t trait_item_ref->get_locus (),\n+\t\t\t\t trait_item_candidate};\n+    candidates.push_back (std::move (candidate));\n+  }\n+\n+protected:\n+  PathProbeType (const TyTy::BaseType *receiver,\n+\t\t const HIR::PathIdentSegment &query, DefId specific_trait_id)\n+    : TypeCheckBase (), receiver (receiver), search (query),\n+      current_impl (nullptr), specific_trait_id (specific_trait_id)\n+  {}\n+\n+  std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+  union_bounds (\n+    const std::vector<std::pair</*const*/ TraitReference *, HIR::ImplBlock *>>\n+      a,\n+    const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> b)\n+    const\n+  {\n+    std::map<DefId, std::pair<const TraitReference *, HIR::ImplBlock *>> mapper;\n+    for (auto &ref : a)\n+      {\n+\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n+      }\n+    for (auto &ref : b)\n+      {\n+\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n+      }\n+\n+    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> union_set;\n+    for (auto it = mapper.begin (); it != mapper.end (); it++)\n+      {\n+\tunion_set.push_back ({it->second.first, it->second.second});\n+      }\n+    return union_set;\n+  }\n+\n+  bool is_reciever_generic () const\n+  {\n+    const TyTy::BaseType *root = receiver->get_root ();\n+    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n+    bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+    return receiver_is_type_param || receiver_is_dyn;\n+  }\n+\n+  const TyTy::BaseType *receiver;\n+  const HIR::PathIdentSegment &search;\n+  std::vector<PathProbeCandidate> candidates;\n+  HIR::ImplBlock *current_impl;\n+  DefId specific_trait_id;\n+};\n+\n+class ReportMultipleCandidateError : private TypeCheckBase,\n+\t\t\t\t     private HIR::HIRImplVisitor\n+{\n+public:\n+  static void Report (std::vector<PathProbeCandidate> &candidates,\n+\t\t      const HIR::PathIdentSegment &query, Location query_locus)\n+  {\n+    RichLocation r (query_locus);\n+    ReportMultipleCandidateError visitor (r);\n+    for (auto &c : candidates)\n+      {\n+\tswitch (c.type)\n+\t  {\n+\t  case PathProbeCandidate::CandidateType::ERROR:\n+\t  case PathProbeCandidate::CandidateType::ENUM_VARIANT:\n+\t    gcc_unreachable ();\n+\t    break;\n+\n+\t  case PathProbeCandidate::CandidateType::IMPL_CONST:\n+\t  case PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS:\n+\t  case PathProbeCandidate::CandidateType::IMPL_FUNC:\n+\t    c.item.impl.impl_item->accept_vis (visitor);\n+\t    break;\n+\n+\t  case PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST:\n+\t  case PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS:\n+\t  case PathProbeCandidate::CandidateType::TRAIT_FUNC:\n+\t    r.add_range (c.item.trait.item_ref->get_locus ());\n+\t    break;\n+\t  }\n+      }\n+\n+    rust_error_at (r, \"multiple applicable items in scope for: %s\",\n+\t\t   query.as_string ().c_str ());\n+  }\n+\n+  void visit (HIR::TypeAlias &alias) override\n+  {\n+    r.add_range (alias.get_locus ());\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    r.add_range (constant.get_locus ());\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    r.add_range (function.get_locus ());\n+  }\n+\n+private:\n+  ReportMultipleCandidateError (RichLocation &r) : TypeCheckBase (), r (r) {}\n+\n+  RichLocation &r;\n+};\n+\n+class PathProbeImplTrait : public PathProbeType\n+{\n+public:\n+  static std::vector<PathProbeCandidate>\n+  Probe (const TyTy::BaseType *receiver,\n+\t const HIR::PathIdentSegment &segment_name,\n+\t const TraitReference *trait_reference)\n+  {\n+    PathProbeImplTrait probe (receiver, segment_name, trait_reference);\n+    // iterate all impls for this trait and receiver\n+    // then search for possible candidates using base class behaviours\n+    probe.process_trait_impl_items_for_candidates ();\n+    return probe.candidates;\n+  }\n+\n+private:\n+  void process_trait_impl_items_for_candidates ();\n+\n+  PathProbeImplTrait (const TyTy::BaseType *receiver,\n+\t\t      const HIR::PathIdentSegment &query,\n+\t\t      const TraitReference *trait_reference)\n+    : PathProbeType (receiver, query, UNKNOWN_DEFID),\n+      trait_reference (trait_reference)\n+  {}\n+\n+  const TraitReference *trait_reference;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_PATH_PROBE_H"}, {"sha": "6eec461e8a5ed522e3d3801562c38a12cb2265af", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,472 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TRAIT_REF_H\n+#define RUST_HIR_TRAIT_REF_H\n+\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-type-check-util.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// Data Objects for the associated trait items in a structure we can work with\n+// https://doc.rust-lang.org/edition-guide/rust-2018/trait-system/associated-constants.html\n+class TypeCheckContext;\n+class TraitItemReference\n+{\n+public:\n+  enum TraitItemType\n+  {\n+    FN,\n+    CONST,\n+    TYPE,\n+    ERROR\n+  };\n+\n+  TraitItemReference (std::string identifier, bool optional, TraitItemType type,\n+\t\t      HIR::TraitItem *hir_trait_item, TyTy::BaseType *self,\n+\t\t      std::vector<TyTy::SubstitutionParamMapping> substitutions,\n+\t\t      Location locus);\n+\n+  TraitItemReference (TraitItemReference const &other);\n+\n+  TraitItemReference &operator= (TraitItemReference const &other);\n+\n+  static TraitItemReference error ()\n+  {\n+    return TraitItemReference (\"\", false, ERROR, nullptr, nullptr, {},\n+\t\t\t       Location ());\n+  }\n+\n+  static TraitItemReference &error_node ()\n+  {\n+    static TraitItemReference error = TraitItemReference::error ();\n+    return error;\n+  }\n+\n+  bool is_error () const { return type == ERROR; }\n+\n+  std::string as_string () const\n+  {\n+    return \"(\" + trait_item_type_as_string (type) + \" \" + identifier + \" \"\n+\t   + \")\";\n+  }\n+\n+  static std::string trait_item_type_as_string (TraitItemType ty)\n+  {\n+    switch (ty)\n+      {\n+      case FN:\n+\treturn \"FN\";\n+      case CONST:\n+\treturn \"CONST\";\n+      case TYPE:\n+\treturn \"TYPE\";\n+      case ERROR:\n+\treturn \"ERROR\";\n+      }\n+    return \"ERROR\";\n+  }\n+\n+  bool is_optional () const { return optional_flag; }\n+\n+  std::string get_identifier () const { return identifier; }\n+\n+  TraitItemType get_trait_item_type () const { return type; }\n+\n+  HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  const Analysis::NodeMapping get_mappings () const\n+  {\n+    return hir_trait_item->get_mappings ();\n+  }\n+\n+  TyTy::BaseType *get_tyty () const\n+  {\n+    rust_assert (hir_trait_item != nullptr);\n+\n+    switch (type)\n+      {\n+      case CONST:\n+\treturn get_type_from_constant (\n+\t  static_cast</*const*/ HIR::TraitItemConst &> (*hir_trait_item));\n+\tbreak;\n+\n+      case TYPE:\n+\treturn get_type_from_typealias (\n+\t  static_cast</*const*/ HIR::TraitItemType &> (*hir_trait_item));\n+\n+      case FN:\n+\treturn get_type_from_fn (\n+\t  static_cast</*const*/ HIR::TraitItemFunc &> (*hir_trait_item));\n+\tbreak;\n+\n+      default:\n+\treturn get_error ();\n+      }\n+\n+    gcc_unreachable ();\n+    return get_error ();\n+  }\n+\n+  Analysis::NodeMapping get_parent_trait_mappings () const;\n+\n+  // this is called when the trait is completed resolution and gives the items a\n+  // chance to run their specific type resolution passes. If we call their\n+  // resolution on construction it can lead to a case where the trait being\n+  // resolved recursively trying to resolve the trait itself infinitely since\n+  // the trait will not be stored in its own map yet\n+  void on_resolved ();\n+\n+  void associated_type_set (TyTy::BaseType *ty) const;\n+\n+  void associated_type_reset () const;\n+\n+  bool is_object_safe () const;\n+\n+private:\n+  TyTy::ErrorType *get_error () const\n+  {\n+    return new TyTy::ErrorType (get_mappings ().get_hirid ());\n+  }\n+\n+  TyTy::BaseType *get_type_from_typealias (/*const*/\n+\t\t\t\t\t   HIR::TraitItemType &type) const;\n+\n+  TyTy::BaseType *\n+  get_type_from_constant (/*const*/ HIR::TraitItemConst &constant) const;\n+\n+  TyTy::BaseType *get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const;\n+\n+  bool is_item_resolved () const;\n+  void resolve_item (HIR::TraitItemType &type);\n+  void resolve_item (HIR::TraitItemConst &constant);\n+  void resolve_item (HIR::TraitItemFunc &func);\n+\n+  std::string identifier;\n+  bool optional_flag;\n+  TraitItemType type;\n+  HIR::TraitItem *hir_trait_item;\n+  std::vector<TyTy::SubstitutionParamMapping> inherited_substitutions;\n+  Location locus;\n+\n+  TyTy::BaseType\n+    *self; // this is the implict Self TypeParam required for methods\n+  Resolver::TypeCheckContext *context;\n+};\n+\n+// this wraps up the HIR::Trait so we can do analysis on it\n+\n+class TraitReference\n+{\n+public:\n+  TraitReference (const HIR::Trait *hir_trait_ref,\n+\t\t  std::vector<TraitItemReference> item_refs,\n+\t\t  std::vector<const TraitReference *> super_traits,\n+\t\t  std::vector<TyTy::SubstitutionParamMapping> substs)\n+    : hir_trait_ref (hir_trait_ref), item_refs (item_refs),\n+      super_traits (super_traits)\n+  {\n+    trait_substs.clear ();\n+    trait_substs.reserve (substs.size ());\n+    for (const auto &p : substs)\n+      trait_substs.push_back (p.clone ());\n+  }\n+\n+  TraitReference (TraitReference const &other)\n+    : hir_trait_ref (other.hir_trait_ref), item_refs (other.item_refs),\n+      super_traits (other.super_traits)\n+  {\n+    trait_substs.clear ();\n+    trait_substs.reserve (other.trait_substs.size ());\n+    for (const auto &p : other.trait_substs)\n+      trait_substs.push_back (p.clone ());\n+  }\n+\n+  TraitReference &operator= (TraitReference const &other)\n+  {\n+    hir_trait_ref = other.hir_trait_ref;\n+    item_refs = other.item_refs;\n+    super_traits = other.super_traits;\n+\n+    trait_substs.clear ();\n+    trait_substs.reserve (other.trait_substs.size ());\n+    for (const auto &p : other.trait_substs)\n+      trait_substs.push_back (p.clone ());\n+\n+    return *this;\n+  }\n+\n+  TraitReference (TraitReference &&other) = default;\n+  TraitReference &operator= (TraitReference &&other) = default;\n+\n+  static TraitReference error ()\n+  {\n+    return TraitReference (nullptr, {}, {}, {});\n+  }\n+\n+  bool is_error () const { return hir_trait_ref == nullptr; }\n+\n+  static TraitReference &error_node ()\n+  {\n+    static TraitReference trait_error_node = TraitReference::error ();\n+    return trait_error_node;\n+  }\n+\n+  Location get_locus () const { return hir_trait_ref->get_locus (); }\n+\n+  std::string get_name () const\n+  {\n+    rust_assert (!is_error ());\n+    return hir_trait_ref->get_name ();\n+  }\n+\n+  std::string as_string () const\n+  {\n+    if (is_error ())\n+      return \"<trait-ref-error-node>\";\n+\n+    std::string item_buf;\n+    for (auto &item : item_refs)\n+      {\n+\titem_buf += item.as_string () + \", \";\n+      }\n+    return \"HIR Trait: \" + get_name () + \"->\"\n+\t   + hir_trait_ref->get_mappings ().as_string () + \" [\" + item_buf\n+\t   + \"]\";\n+  }\n+\n+  const HIR::Trait *get_hir_trait_ref () const { return hir_trait_ref; }\n+\n+  const Analysis::NodeMapping &get_mappings () const\n+  {\n+    return hir_trait_ref->get_mappings ();\n+  }\n+\n+  DefId get_defid () const { return get_mappings ().get_defid (); }\n+\n+  bool lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t      TraitItemReference **ref)\n+  {\n+    return lookup_trait_item (item.trait_identifier (), ref);\n+  }\n+\n+  bool lookup_trait_item (const std::string &ident, TraitItemReference **ref)\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  {\n+\t    *ref = &item;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  bool lookup_trait_item_by_type (const std::string &ident,\n+\t\t\t\t  TraitItemReference::TraitItemType type,\n+\t\t\t\t  TraitItemReference **ref)\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (item.get_trait_item_type () != type)\n+\t  continue;\n+\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  {\n+\t    *ref = &item;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  bool lookup_trait_item_by_type (const std::string &ident,\n+\t\t\t\t  TraitItemReference::TraitItemType type,\n+\t\t\t\t  const TraitItemReference **ref) const\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (item.get_trait_item_type () != type)\n+\t  continue;\n+\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  {\n+\t    *ref = &item;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  bool lookup_hir_trait_item (const HIR::TraitItem &item,\n+\t\t\t      const TraitItemReference **ref) const\n+  {\n+    return lookup_trait_item (item.trait_identifier (), ref);\n+  }\n+\n+  bool lookup_trait_item (const std::string &ident,\n+\t\t\t  const TraitItemReference **ref) const\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  {\n+\t    *ref = &item;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  const TraitItemReference *\n+  lookup_trait_item (const std::string &ident,\n+\t\t     TraitItemReference::TraitItemType type) const\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (item.get_trait_item_type () != type)\n+\t  continue;\n+\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  return &item;\n+      }\n+    return &TraitItemReference::error_node ();\n+  }\n+\n+  size_t size () const { return item_refs.size (); }\n+\n+  const std::vector<TraitItemReference> &get_trait_items () const\n+  {\n+    return item_refs;\n+  }\n+\n+  void on_resolved ()\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\titem.on_resolved ();\n+      }\n+  }\n+\n+  void clear_associated_types ()\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tbool is_assoc_type = item.get_trait_item_type ()\n+\t\t\t     == TraitItemReference::TraitItemType::TYPE;\n+\tif (is_assoc_type)\n+\t  item.associated_type_reset ();\n+      }\n+  }\n+\n+  bool is_equal (const TraitReference &other) const\n+  {\n+    DefId this_id = get_mappings ().get_defid ();\n+    DefId other_id = other.get_mappings ().get_defid ();\n+    return this_id == other_id;\n+  }\n+\n+  const std::vector<const TraitReference *> get_super_traits () const\n+  {\n+    return super_traits;\n+  }\n+\n+  bool is_object_safe (bool emit_error, Location locus) const\n+  {\n+    // https: // doc.rust-lang.org/reference/items/traits.html#object-safety\n+    std::vector<const TraitReference *> non_object_super_traits;\n+    for (auto &item : super_traits)\n+      {\n+\tif (!item->is_object_safe (false, Location ()))\n+\t  non_object_super_traits.push_back (item);\n+      }\n+\n+    std::vector<const Resolver::TraitItemReference *> non_object_safe_items;\n+    for (auto &item : get_trait_items ())\n+      {\n+\tif (!item.is_object_safe ())\n+\t  non_object_safe_items.push_back (&item);\n+      }\n+\n+    bool is_safe\n+      = non_object_super_traits.empty () && non_object_safe_items.empty ();\n+    if (emit_error && !is_safe)\n+      {\n+\tRichLocation r (locus);\n+\tfor (auto &item : non_object_super_traits)\n+\t  r.add_range (item->get_locus ());\n+\tfor (auto &item : non_object_safe_items)\n+\t  r.add_range (item->get_locus ());\n+\n+\trust_error_at (r, \"trait bound is not object safe\");\n+      }\n+\n+    return is_safe;\n+  }\n+\n+  bool trait_has_generics () const { return !trait_substs.empty (); }\n+\n+  std::vector<TyTy::SubstitutionParamMapping> get_trait_substs () const\n+  {\n+    return trait_substs;\n+  }\n+\n+private:\n+  const HIR::Trait *hir_trait_ref;\n+  std::vector<TraitItemReference> item_refs;\n+  std::vector<const TraitReference *> super_traits;\n+  std::vector<TyTy::SubstitutionParamMapping> trait_substs;\n+};\n+\n+class AssociatedImplTrait\n+{\n+public:\n+  AssociatedImplTrait (TraitReference *trait, HIR::ImplBlock *impl,\n+\t\t       TyTy::BaseType *self,\n+\t\t       Resolver::TypeCheckContext *context)\n+    : trait (trait), impl (impl), self (self), context (context)\n+  {}\n+\n+  TraitReference *get_trait () { return trait; }\n+\n+  HIR::ImplBlock *get_impl_block () { return impl; }\n+\n+  TyTy::BaseType *get_self () { return self; }\n+\n+  void setup_associated_types (const TyTy::BaseType *self,\n+\t\t\t       const TyTy::TypeBoundPredicate &bound);\n+\n+  void reset_associated_types ();\n+\n+private:\n+  TraitReference *trait;\n+  HIR::ImplBlock *impl;\n+  TyTy::BaseType *self;\n+  Resolver::TypeCheckContext *context;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TRAIT_REF_H"}, {"sha": "44400efbbf7e68a87a25b21c7a91ecd309b99bc1", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_BOUNDS_H\n+#define RUST_HIR_TYPE_BOUNDS_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeBoundsProbe : public TypeCheckBase\n+{\n+public:\n+  static std::vector<std::pair<TraitReference *, HIR::ImplBlock *>>\n+  Probe (const TyTy::BaseType *receiver)\n+  {\n+    TypeBoundsProbe probe (receiver);\n+    probe.scan ();\n+    return probe.trait_references;\n+  }\n+\n+  static bool is_bound_satisfied_for_type (TyTy::BaseType *receiver,\n+\t\t\t\t\t   TraitReference *ref)\n+  {\n+    for (auto &bound : receiver->get_specified_bounds ())\n+      {\n+\tconst TraitReference *b = bound.get ();\n+\tif (b->is_equal (*ref))\n+\t  return true;\n+      }\n+\n+    std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> bounds\n+      = Probe (receiver);\n+    for (auto &bound : bounds)\n+      {\n+\tconst TraitReference *b = bound.first;\n+\tif (b->is_equal (*ref))\n+\t  return true;\n+      }\n+\n+    return false;\n+  }\n+\n+private:\n+  void scan ();\n+\n+private:\n+  TypeBoundsProbe (const TyTy::BaseType *receiver)\n+    : TypeCheckBase (), receiver (receiver)\n+  {}\n+\n+  const TyTy::BaseType *receiver;\n+  std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> trait_references;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_BOUNDS_H"}, {"sha": "f80368a0339958c2f2b3362483032cf4373ab59e", "filename": "gcc/rust/typecheck/rust-substitution-mapper.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,77 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TyTy::BaseType *\n+SubstMapperInternal::Resolve (TyTy::BaseType *base,\n+\t\t\t      TyTy::SubstitutionArgumentMappings &mappings)\n+{\n+  auto context = TypeCheckContext::get ();\n+\n+  SubstMapperInternal mapper (base->get_ref (), mappings);\n+  base->accept_vis (mapper);\n+  rust_assert (mapper.resolved != nullptr);\n+\n+  // insert these new implict types into the context\n+  TyTy::BaseType *unused = nullptr;\n+  bool is_ty_available\n+    = context->lookup_type (mapper.resolved->get_ty_ref (), &unused);\n+  if (!is_ty_available)\n+    {\n+      context->insert_type (\n+\tAnalysis::NodeMapping (0, 0, mapper.resolved->get_ty_ref (), 0),\n+\tmapper.resolved);\n+    }\n+  bool is_ref_available\n+    = context->lookup_type (mapper.resolved->get_ref (), &unused);\n+  if (!is_ref_available)\n+    {\n+      context->insert_type (Analysis::NodeMapping (0, 0,\n+\t\t\t\t\t\t   mapper.resolved->get_ref (),\n+\t\t\t\t\t\t   0),\n+\t\t\t    mapper.resolved);\n+    }\n+\n+  return mapper.resolved;\n+}\n+\n+bool\n+SubstMapperInternal::mappings_are_bound (\n+  TyTy::BaseType *tyseg, TyTy::SubstitutionArgumentMappings &mappings)\n+{\n+  if (tyseg->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyseg);\n+      return adt->are_mappings_bound (mappings);\n+    }\n+  else if (tyseg->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fn = static_cast<TyTy::FnType *> (tyseg);\n+      return fn->are_mappings_bound (mappings);\n+    }\n+\n+  return false;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "028e10c0efe0cbb67605e230b0c6d0e32d6a2e41", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "added", "additions": 394, "deletions": 0, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,394 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_SUBSTITUTION_MAPPER_H\n+#define RUST_SUBSTITUTION_MAPPER_H\n+\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class SubstMapper : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (TyTy::BaseType *base, Location locus,\n+\t\t\t\t  HIR::GenericArgs *generics = nullptr)\n+  {\n+    SubstMapper mapper (base->get_ref (), generics, locus);\n+    base->accept_vis (mapper);\n+    rust_assert (mapper.resolved != nullptr);\n+    return mapper.resolved;\n+  }\n+\n+  static TyTy::BaseType *InferSubst (TyTy::BaseType *base, Location locus)\n+  {\n+    return SubstMapper::Resolve (base, locus, nullptr);\n+  }\n+\n+  bool have_generic_args () const { return generics != nullptr; }\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    TyTy::FnType *concrete = nullptr;\n+    if (!have_generic_args ())\n+      {\n+\tTyTy::BaseType *substs = type.infer_substitions (locus);\n+\trust_assert (substs->get_kind () == TyTy::TypeKind::FNDEF);\n+\tconcrete = static_cast<TyTy::FnType *> (substs);\n+      }\n+    else\n+      {\n+\tTyTy::SubstitutionArgumentMappings mappings\n+\t  = type.get_mappings_from_generic_args (*generics);\n+\tif (mappings.is_error ())\n+\t  return;\n+\n+\tconcrete = type.handle_substitions (mappings);\n+      }\n+\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  void visit (TyTy::ADTType &type) override\n+  {\n+    TyTy::ADTType *concrete = nullptr;\n+    if (!have_generic_args ())\n+      {\n+\tTyTy::BaseType *substs = type.infer_substitions (locus);\n+\trust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n+\tconcrete = static_cast<TyTy::ADTType *> (substs);\n+      }\n+    else\n+      {\n+\tTyTy::SubstitutionArgumentMappings mappings\n+\t  = type.get_mappings_from_generic_args (*generics);\n+\tif (mappings.is_error ())\n+\t  return;\n+\n+\tconcrete = type.handle_substitions (mappings);\n+      }\n+\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  void visit (TyTy::PlaceholderType &type) override\n+  {\n+    rust_assert (type.can_resolve ());\n+    resolved = SubstMapper::Resolve (type.resolve (), locus, generics);\n+  }\n+\n+  void visit (TyTy::ProjectionType &type) override\n+  {\n+    TyTy::ProjectionType *concrete = nullptr;\n+    if (!have_generic_args ())\n+      {\n+\tTyTy::BaseType *substs = type.infer_substitions (locus);\n+\trust_assert (substs->get_kind () == TyTy::TypeKind::ADT);\n+\tconcrete = static_cast<TyTy::ProjectionType *> (substs);\n+      }\n+    else\n+      {\n+\tTyTy::SubstitutionArgumentMappings mappings\n+\t  = type.get_mappings_from_generic_args (*generics);\n+\tif (mappings.is_error ())\n+\t  return;\n+\n+\tconcrete = type.handle_substitions (mappings);\n+      }\n+\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  // nothing to do for these\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n+  void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n+  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+  void visit (TyTy::SliceType &) override { gcc_unreachable (); }\n+  void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n+  void visit (TyTy::IntType &) override { gcc_unreachable (); }\n+  void visit (TyTy::UintType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FloatType &) override { gcc_unreachable (); }\n+  void visit (TyTy::USizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ISizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n+  void visit (TyTy::CharType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n+  void visit (TyTy::PointerType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n+  void visit (TyTy::StrType &) override { gcc_unreachable (); }\n+  void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ClosureType &) override { gcc_unreachable (); }\n+\n+private:\n+  SubstMapper (HirId ref, HIR::GenericArgs *generics, Location locus)\n+    : resolved (new TyTy::ErrorType (ref)), generics (generics), locus (locus)\n+  {}\n+\n+  TyTy::BaseType *resolved;\n+  HIR::GenericArgs *generics;\n+  Location locus;\n+};\n+\n+class SubstMapperInternal : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (TyTy::BaseType *base,\n+\t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings);\n+\n+  static bool mappings_are_bound (TyTy::BaseType *ty,\n+\t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings);\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    TyTy::SubstitutionArgumentMappings adjusted\n+      = type.adjust_mappings_for_this (mappings);\n+    if (adjusted.is_error ())\n+      return;\n+\n+    TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  void visit (TyTy::ADTType &type) override\n+  {\n+    TyTy::SubstitutionArgumentMappings adjusted\n+      = type.adjust_mappings_for_this (mappings);\n+    if (adjusted.is_error ())\n+      return;\n+\n+    TyTy::BaseType *concrete = type.handle_substitions (adjusted);\n+    if (concrete != nullptr)\n+      resolved = concrete;\n+  }\n+\n+  // these don't support generic arguments but might contain a type param\n+  void visit (TyTy::TupleType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n+  void visit (TyTy::ReferenceType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n+  void visit (TyTy::PointerType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n+  void visit (TyTy::ParamType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n+  void visit (TyTy::PlaceholderType &type) override\n+  {\n+    rust_assert (type.can_resolve ());\n+    if (mappings.trait_item_mode ())\n+      {\n+\tresolved = type.resolve ();\n+      }\n+    else\n+      {\n+\tresolved = SubstMapperInternal::Resolve (type.resolve (), mappings);\n+      }\n+  }\n+\n+  void visit (TyTy::ProjectionType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n+  void visit (TyTy::ClosureType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n+  void visit (TyTy::ArrayType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n+  void visit (TyTy::SliceType &type) override\n+  {\n+    resolved = type.handle_substitions (mappings);\n+  }\n+\n+  // nothing to do for these\n+  void visit (TyTy::InferType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::FnPtr &type) override { resolved = type.clone (); }\n+  void visit (TyTy::BoolType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::IntType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::UintType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::FloatType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::USizeType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::ISizeType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::ErrorType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::CharType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::StrType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::NeverType &type) override { resolved = type.clone (); }\n+  void visit (TyTy::DynamicObjectType &type) override\n+  {\n+    resolved = type.clone ();\n+  }\n+\n+private:\n+  SubstMapperInternal (HirId ref, TyTy::SubstitutionArgumentMappings &mappings)\n+    : resolved (new TyTy::ErrorType (ref)), mappings (mappings)\n+  {}\n+\n+  TyTy::BaseType *resolved;\n+  TyTy::SubstitutionArgumentMappings &mappings;\n+};\n+\n+class SubstMapperFromExisting : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::BaseType *Resolve (TyTy::BaseType *concrete,\n+\t\t\t\t  TyTy::BaseType *receiver)\n+  {\n+    rust_assert (concrete->get_kind () == receiver->get_kind ());\n+\n+    SubstMapperFromExisting mapper (concrete, receiver);\n+    concrete->accept_vis (mapper);\n+    return mapper.resolved;\n+  }\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    rust_assert (type.was_substituted ());\n+\n+    TyTy::FnType *to_sub = static_cast<TyTy::FnType *> (receiver);\n+    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+  }\n+\n+  void visit (TyTy::ADTType &type) override\n+  {\n+    rust_assert (type.was_substituted ());\n+\n+    TyTy::ADTType *to_sub = static_cast<TyTy::ADTType *> (receiver);\n+    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+  }\n+\n+  void visit (TyTy::ClosureType &type) override\n+  {\n+    rust_assert (type.was_substituted ());\n+\n+    TyTy::ClosureType *to_sub = static_cast<TyTy::ClosureType *> (receiver);\n+    resolved = to_sub->handle_substitions (type.get_substitution_arguments ());\n+  }\n+\n+  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n+  void visit (TyTy::TupleType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n+  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n+  void visit (TyTy::SliceType &) override { gcc_unreachable (); }\n+  void visit (TyTy::BoolType &) override { gcc_unreachable (); }\n+  void visit (TyTy::IntType &) override { gcc_unreachable (); }\n+  void visit (TyTy::UintType &) override { gcc_unreachable (); }\n+  void visit (TyTy::FloatType &) override { gcc_unreachable (); }\n+  void visit (TyTy::USizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ISizeType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n+  void visit (TyTy::CharType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n+  void visit (TyTy::PointerType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n+  void visit (TyTy::StrType &) override { gcc_unreachable (); }\n+  void visit (TyTy::NeverType &) override { gcc_unreachable (); }\n+  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n+  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n+\n+private:\n+  SubstMapperFromExisting (TyTy::BaseType *concrete, TyTy::BaseType *receiver)\n+    : concrete (concrete), receiver (receiver), resolved (nullptr)\n+  {}\n+\n+  TyTy::BaseType *concrete;\n+  TyTy::BaseType *receiver;\n+\n+  TyTy::BaseType *resolved;\n+};\n+\n+class GetUsedSubstArgs : public TyTy::TyConstVisitor\n+{\n+public:\n+  static TyTy::SubstitutionArgumentMappings From (const TyTy::BaseType *from)\n+  {\n+    GetUsedSubstArgs mapper;\n+    from->accept_vis (mapper);\n+    return mapper.args;\n+  }\n+\n+  void visit (const TyTy::FnType &type) override\n+  {\n+    args = type.get_substitution_arguments ();\n+  }\n+\n+  void visit (const TyTy::ADTType &type) override\n+  {\n+    args = type.get_substitution_arguments ();\n+  }\n+\n+  void visit (const TyTy::ClosureType &type) override\n+  {\n+    args = type.get_substitution_arguments ();\n+  }\n+\n+  void visit (const TyTy::InferType &) override {}\n+  void visit (const TyTy::TupleType &) override {}\n+  void visit (const TyTy::FnPtr &) override {}\n+  void visit (const TyTy::ArrayType &) override {}\n+  void visit (const TyTy::SliceType &) override {}\n+  void visit (const TyTy::BoolType &) override {}\n+  void visit (const TyTy::IntType &) override {}\n+  void visit (const TyTy::UintType &) override {}\n+  void visit (const TyTy::FloatType &) override {}\n+  void visit (const TyTy::USizeType &) override {}\n+  void visit (const TyTy::ISizeType &) override {}\n+  void visit (const TyTy::ErrorType &) override {}\n+  void visit (const TyTy::CharType &) override {}\n+  void visit (const TyTy::ReferenceType &) override {}\n+  void visit (const TyTy::PointerType &) override {}\n+  void visit (const TyTy::ParamType &) override {}\n+  void visit (const TyTy::StrType &) override {}\n+  void visit (const TyTy::NeverType &) override {}\n+  void visit (const TyTy::PlaceholderType &) override {}\n+  void visit (const TyTy::ProjectionType &) override {}\n+  void visit (const TyTy::DynamicObjectType &) override {}\n+\n+private:\n+  GetUsedSubstArgs () : args (TyTy::SubstitutionArgumentMappings::error ()) {}\n+\n+  TyTy::SubstitutionArgumentMappings args;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_SUBSTITUTION_MAPPER_H"}, {"sha": "ccf0f625e4b19f1f55ee02bf8df1a423936ec025", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,239 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYCHECK_DUMP\n+#define RUST_TYCHECK_DUMP\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeResolverDump : private TypeCheckBase, private HIR::HIRFullVisitorBase\n+{\n+  using HIR::HIRFullVisitorBase::visit;\n+\n+public:\n+  static void go (HIR::Crate &crate, std::ofstream &out)\n+  {\n+    TypeResolverDump dumper;\n+    for (auto &item : crate.items)\n+      {\n+\titem->accept_vis (dumper);\n+\tdumper.dump += \"\\n\";\n+      }\n+\n+    out << dumper.dump;\n+  }\n+\n+  void visit (HIR::StructStruct &struct_decl) override\n+  {\n+    dump += indent () + \"struct \" + type_string (struct_decl.get_mappings ())\n+\t    + \"\\n\";\n+  }\n+\n+  void visit (HIR::Union &union_decl) override\n+  {\n+    dump\n+      += indent () + \"union \" + type_string (union_decl.get_mappings ()) + \"\\n\";\n+  }\n+\n+  void visit (HIR::TupleStruct &struct_decl) override\n+  {\n+    dump += indent () + \"struct\" + type_string (struct_decl.get_mappings ())\n+\t    + \"\\n\";\n+  }\n+\n+  void visit (HIR::ImplBlock &impl_block) override\n+  {\n+    dump += indent () + \"impl \"\n+\t    + type_string (impl_block.get_type ()->get_mappings ()) + \" {\\n\";\n+    indentation_level++;\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      {\n+\timpl_item->accept_vis (*this);\n+\tdump += \"\\n\";\n+      }\n+\n+    indentation_level--;\n+    dump += indent () + \"}\\n\";\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override\n+  {\n+    dump += indent () + \"constant \" + constant.get_identifier () + \":\"\n+\t    + type_string (constant.get_mappings ()) + \" = \";\n+    constant.get_expr ()->accept_vis (*this);\n+    dump += \";\\n\";\n+  }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    dump += indent () + \"fn \" + function.get_function_name () + \" \"\n+\t    + type_string (function.get_mappings ()) + \"\\n\";\n+    dump += indent () + \"{\\n\";\n+\n+    HIR::BlockExpr *function_body = function.get_definition ().get ();\n+    function_body->accept_vis (*this);\n+\n+    dump += indent () + \"}\\n\";\n+  }\n+\n+  void visit (HIR::BlockExpr &expr) override\n+  {\n+    dump += \"{\\n\";\n+    indentation_level++;\n+\n+    for (auto &s : expr.get_statements ())\n+      {\n+\tdump += indent ();\n+\ts->accept_vis (*this);\n+\tdump += \";\\n\";\n+      }\n+\n+    if (expr.has_expr ())\n+      {\n+\tdump += indent ();\n+\texpr.expr->accept_vis (*this);\n+\tdump += \";\\n\";\n+      }\n+\n+    indentation_level--;\n+    dump += \"}\\n\";\n+  }\n+\n+  void visit (HIR::UnsafeBlockExpr &expr) override\n+  {\n+    dump += \"unsafe \";\n+    expr.get_block_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::LetStmt &stmt) override\n+  {\n+    dump += \"let \" + stmt.get_pattern ()->as_string () + \":\"\n+\t    + type_string (stmt.get_pattern ()->get_pattern_mappings ());\n+    if (stmt.has_init_expr ())\n+      {\n+\tdump += \" = \";\n+\tstmt.get_init_expr ()->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::ExprStmtWithBlock &stmt) override\n+  {\n+    stmt.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ExprStmtWithoutBlock &stmt) override\n+  {\n+    stmt.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::AssignmentExpr &expr) override\n+  {\n+    expr.get_lhs ()->accept_vis (*this);\n+    dump += \" = \";\n+    expr.get_rhs ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr) override\n+  {\n+    dump += expr.get_literal ().as_string () + \":\"\n+\t    + type_string (expr.get_mappings ());\n+  }\n+\n+  void visit (HIR::ArrayExpr &expr) override\n+  {\n+    dump += type_string (expr.get_mappings ()) + \":[\";\n+\n+    HIR::ArrayElems *elements = expr.get_internal_elements ();\n+    elements->accept_vis (*this);\n+\n+    dump += \"]\";\n+  }\n+\n+  void visit (HIR::ArrayElemsValues &elems) override\n+  {\n+    for (auto &elem : elems.get_values ())\n+      {\n+\telem->accept_vis (*this);\n+\tdump += \",\";\n+      }\n+  }\n+\n+  void visit (HIR::GroupedExpr &expr) override\n+  {\n+    HIR::Expr *paren_expr = expr.get_expr_in_parens ().get ();\n+    dump += \"(\";\n+    paren_expr->accept_vis (*this);\n+    dump += \")\";\n+  }\n+\n+  void visit (HIR::PathInExpression &expr) override\n+  {\n+    dump += type_string (expr.get_mappings ());\n+  }\n+\n+  void visit (HIR::StructExprStructFields &expr) override\n+  {\n+    dump += \"ctor: \" + type_string (expr.get_mappings ());\n+  }\n+\n+protected:\n+  std::string type_string (const Analysis::NodeMapping &mappings)\n+  {\n+    TyTy::BaseType *lookup = nullptr;\n+    if (!context->lookup_type (mappings.get_hirid (), &lookup))\n+      return \"<error>\";\n+\n+    std::string buf = \"[\";\n+    for (auto &ref : lookup->get_combined_refs ())\n+      {\n+\tbuf += std::to_string (ref);\n+\tbuf += \", \";\n+      }\n+    buf += \"]\";\n+\n+    std::string repr = lookup->as_string ();\n+    return \"<\" + repr + \" HIRID: \" + std::to_string (mappings.get_hirid ())\n+\t   + \" RF:\" + std::to_string (lookup->get_ref ()) + \" TF:\"\n+\t   + std::to_string (lookup->get_ty_ref ()) + +\" - \" + buf + \">\";\n+  }\n+\n+  std::string indent ()\n+  {\n+    std::string buf;\n+    for (size_t i = 0; i < indentation_level; ++i)\n+      buf += \"    \";\n+\n+    return buf;\n+  }\n+\n+private:\n+  TypeResolverDump () : TypeCheckBase (), indentation_level (0) {}\n+\n+  std::string dump;\n+  size_t indentation_level;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_TYCHECK_DUMP"}, {"sha": "d8a49e8b9ea0569e6cbf06af5507dd6ae75f3334", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,155 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckContext *\n+TypeCheckContext::get ()\n+{\n+  static TypeCheckContext *instance;\n+  if (instance == nullptr)\n+    instance = new TypeCheckContext ();\n+\n+  return instance;\n+}\n+\n+TypeCheckContext::TypeCheckContext () {}\n+\n+TypeCheckContext::~TypeCheckContext () {}\n+\n+bool\n+TypeCheckContext::lookup_builtin (NodeId id, TyTy::BaseType **type)\n+{\n+  auto ref_it = node_id_refs.find (id);\n+  if (ref_it == node_id_refs.end ())\n+    return false;\n+\n+  auto it = resolved.find (ref_it->second);\n+  if (it == resolved.end ())\n+    return false;\n+\n+  *type = it->second;\n+  return true;\n+}\n+\n+bool\n+TypeCheckContext::lookup_builtin (std::string name, TyTy::BaseType **type)\n+{\n+  for (auto &builtin : builtins)\n+    {\n+      if (name.compare (builtin->as_string ()) == 0)\n+\t{\n+\t  *type = builtin.get ();\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+void\n+TypeCheckContext::insert_builtin (HirId id, NodeId ref, TyTy::BaseType *type)\n+{\n+  node_id_refs[ref] = id;\n+  resolved[id] = type;\n+  builtins.push_back (std::unique_ptr<TyTy::BaseType> (type));\n+}\n+\n+void\n+TypeCheckContext::insert_type (const Analysis::NodeMapping &mappings,\n+\t\t\t       TyTy::BaseType *type)\n+{\n+  rust_assert (type != nullptr);\n+  NodeId ref = mappings.get_nodeid ();\n+  HirId id = mappings.get_hirid ();\n+  node_id_refs[ref] = id;\n+  resolved[id] = type;\n+}\n+\n+void\n+TypeCheckContext::insert_implicit_type (TyTy::BaseType *type)\n+{\n+  rust_assert (type != nullptr);\n+  resolved[type->get_ref ()] = type;\n+}\n+\n+void\n+TypeCheckContext::insert_implicit_type (HirId id, TyTy::BaseType *type)\n+{\n+  rust_assert (type != nullptr);\n+  resolved[id] = type;\n+}\n+\n+bool\n+TypeCheckContext::lookup_type (HirId id, TyTy::BaseType **type) const\n+{\n+  auto it = resolved.find (id);\n+  if (it == resolved.end ())\n+    return false;\n+\n+  *type = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_type_by_node_id (NodeId ref, HirId id)\n+{\n+  rust_assert (node_id_refs.find (ref) == node_id_refs.end ());\n+  node_id_refs[ref] = id;\n+}\n+\n+bool\n+TypeCheckContext::lookup_type_by_node_id (NodeId ref, HirId *id)\n+{\n+  auto it = node_id_refs.find (ref);\n+  if (it == node_id_refs.end ())\n+    return false;\n+\n+  *id = it->second;\n+  return true;\n+}\n+\n+TyTy::BaseType *\n+TypeCheckContext::peek_return_type ()\n+{\n+  return return_type_stack.back ().second;\n+}\n+\n+void\n+TypeCheckContext::push_return_type (TypeCheckContextItem item,\n+\t\t\t\t    TyTy::BaseType *return_type)\n+{\n+  return_type_stack.push_back ({std::move (item), return_type});\n+}\n+\n+void\n+TypeCheckContext::pop_return_type ()\n+{\n+  return_type_stack.pop_back ();\n+}\n+\n+TypeCheckContextItem &\n+TypeCheckContext::peek_context ()\n+{\n+  return return_type_stack.back ().first;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "7a1562ab5442d8081d700fa7fc1a2346f9df6f5a", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,462 @@\n+// Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeBoundsProbe::scan ()\n+{\n+  std::vector<std::pair<HIR::TypePath *, HIR::ImplBlock *>>\n+    possible_trait_paths;\n+  mappings->iterate_impl_blocks (\n+    [&] (HirId id, HIR::ImplBlock *impl) mutable -> bool {\n+      // we are filtering for trait-impl-blocks\n+      if (!impl->has_trait_ref ())\n+\treturn true;\n+\n+      TyTy::BaseType *impl_type = nullptr;\n+      bool ok\n+\t= context->lookup_type (impl->get_type ()->get_mappings ().get_hirid (),\n+\t\t\t\t&impl_type);\n+      if (!ok)\n+\treturn true;\n+\n+      if (!receiver->can_eq (impl_type, false))\n+\t{\n+\t  if (!impl_type->can_eq (receiver, false))\n+\t    return true;\n+\t}\n+\n+      possible_trait_paths.push_back ({impl->get_trait_ref ().get (), impl});\n+      return true;\n+    });\n+\n+  for (auto &path : possible_trait_paths)\n+    {\n+      HIR::TypePath *trait_path = path.first;\n+      TraitReference *trait_ref = TraitResolver::Resolve (*trait_path);\n+\n+      if (!trait_ref->is_error ())\n+\ttrait_references.push_back ({trait_ref, path.second});\n+    }\n+}\n+\n+TraitReference *\n+TypeCheckBase::resolve_trait_path (HIR::TypePath &path)\n+{\n+  return TraitResolver::Resolve (path);\n+}\n+\n+TyTy::TypeBoundPredicate\n+TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n+{\n+  TraitReference *trait = resolve_trait_path (type_path);\n+  if (trait->is_error ())\n+    return TyTy::TypeBoundPredicate::error ();\n+\n+  TyTy::TypeBoundPredicate predicate (*trait, type_path.get_locus ());\n+  HIR::GenericArgs args\n+    = HIR::GenericArgs::create_empty (type_path.get_locus ());\n+\n+  auto &final_seg = type_path.get_final_segment ();\n+  if (final_seg->is_generic_segment ())\n+    {\n+      auto final_generic_seg\n+\t= static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n+      if (final_generic_seg->has_generic_args ())\n+\t{\n+\t  args = final_generic_seg->get_generic_args ();\n+\t}\n+    }\n+\n+  if (predicate.requires_generic_args ())\n+    {\n+      // this is applying generic arguments to a trait reference\n+      predicate.apply_generic_arguments (&args);\n+    }\n+\n+  return predicate;\n+}\n+\n+} // namespace Resolver\n+\n+namespace TyTy {\n+\n+TypeBoundPredicate::TypeBoundPredicate (\n+  const Resolver::TraitReference &trait_reference, Location locus)\n+  : SubstitutionRef ({}, SubstitutionArgumentMappings::error ()),\n+    reference (trait_reference.get_mappings ().get_defid ()), locus (locus),\n+    error_flag (false)\n+{\n+  substitutions.clear ();\n+  for (const auto &p : trait_reference.get_trait_substs ())\n+    substitutions.push_back (p.clone ());\n+\n+  // we setup a dummy implict self argument\n+  SubstitutionArg placeholder_self (&get_substs ().front (), nullptr);\n+  used_arguments.get_mappings ().push_back (placeholder_self);\n+}\n+\n+TypeBoundPredicate::TypeBoundPredicate (\n+  DefId reference, std::vector<SubstitutionParamMapping> subst, Location locus)\n+  : SubstitutionRef ({}, SubstitutionArgumentMappings::error ()),\n+    reference (reference), locus (locus), error_flag (false)\n+{\n+  substitutions.clear ();\n+  for (const auto &p : subst)\n+    substitutions.push_back (p.clone ());\n+\n+  // we setup a dummy implict self argument\n+  SubstitutionArg placeholder_self (&get_substs ().front (), nullptr);\n+  used_arguments.get_mappings ().push_back (placeholder_self);\n+}\n+\n+TypeBoundPredicate::TypeBoundPredicate (const TypeBoundPredicate &other)\n+  : SubstitutionRef ({}, SubstitutionArgumentMappings::error ()),\n+    reference (other.reference), locus (other.locus),\n+    error_flag (other.error_flag)\n+{\n+  substitutions.clear ();\n+  for (const auto &p : other.get_substs ())\n+    substitutions.push_back (p.clone ());\n+\n+  std::vector<SubstitutionArg> mappings;\n+  for (size_t i = 0; i < other.used_arguments.get_mappings ().size (); i++)\n+    {\n+      const SubstitutionArg &oa = other.used_arguments.get_mappings ().at (i);\n+      SubstitutionArg arg (oa);\n+      mappings.push_back (std::move (arg));\n+    }\n+\n+  // we need to remap the argument mappings based on this copied constructor\n+  std::vector<SubstitutionArg> copied_arg_mappings;\n+  size_t i = 0;\n+  for (const auto &m : other.used_arguments.get_mappings ())\n+    {\n+      TyTy::BaseType *argument\n+\t= m.get_tyty () == nullptr ? nullptr : m.get_tyty ()->clone ();\n+      SubstitutionArg c (&substitutions.at (i++), argument);\n+      copied_arg_mappings.push_back (std::move (c));\n+    }\n+\n+  used_arguments\n+    = SubstitutionArgumentMappings (copied_arg_mappings,\n+\t\t\t\t    other.used_arguments.get_locus ());\n+}\n+\n+TypeBoundPredicate &\n+TypeBoundPredicate::operator= (const TypeBoundPredicate &other)\n+{\n+  reference = other.reference;\n+  locus = other.locus;\n+  error_flag = other.error_flag;\n+  used_arguments = SubstitutionArgumentMappings::error ();\n+\n+  substitutions.clear ();\n+  for (const auto &p : other.get_substs ())\n+    substitutions.push_back (p.clone ());\n+\n+  std::vector<SubstitutionArg> mappings;\n+  for (size_t i = 0; i < other.used_arguments.get_mappings ().size (); i++)\n+    {\n+      const SubstitutionArg &oa = other.used_arguments.get_mappings ().at (i);\n+      SubstitutionArg arg (oa);\n+      mappings.push_back (std::move (arg));\n+    }\n+\n+  // we need to remap the argument mappings based on this copied constructor\n+  std::vector<SubstitutionArg> copied_arg_mappings;\n+  size_t i = 0;\n+  for (const auto &m : other.used_arguments.get_mappings ())\n+    {\n+      TyTy::BaseType *argument\n+\t= m.get_tyty () == nullptr ? nullptr : m.get_tyty ()->clone ();\n+      SubstitutionArg c (&substitutions.at (i++), argument);\n+      copied_arg_mappings.push_back (std::move (c));\n+    }\n+\n+  used_arguments\n+    = SubstitutionArgumentMappings (copied_arg_mappings,\n+\t\t\t\t    other.used_arguments.get_locus ());\n+\n+  return *this;\n+}\n+\n+TypeBoundPredicate\n+TypeBoundPredicate::error ()\n+{\n+  auto p = TypeBoundPredicate (UNKNOWN_DEFID, {}, Location ());\n+  p.error_flag = true;\n+  return p;\n+}\n+\n+std::string\n+TypeBoundPredicate::as_string () const\n+{\n+  return get ()->as_string () + subst_as_string ();\n+}\n+\n+std::string\n+TypeBoundPredicate::as_name () const\n+{\n+  return get ()->get_name () + subst_as_string ();\n+}\n+\n+const Resolver::TraitReference *\n+TypeBoundPredicate::get () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  Resolver::TraitReference *ref = nullptr;\n+  bool ok = context->lookup_trait_reference (reference, &ref);\n+  rust_assert (ok);\n+\n+  return ref;\n+}\n+\n+std::string\n+TypeBoundPredicate::get_name () const\n+{\n+  return get ()->get_name ();\n+}\n+\n+bool\n+TypeBoundPredicate::is_object_safe (bool emit_error, Location locus) const\n+{\n+  const Resolver::TraitReference *trait = get ();\n+  rust_assert (trait != nullptr);\n+  return trait->is_object_safe (emit_error, locus);\n+}\n+\n+void\n+TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args)\n+{\n+  // we need to get the substitutions argument mappings but also remember that\n+  // we have an implicit Self argument which we must be careful to respect\n+  rust_assert (!used_arguments.is_empty ());\n+  rust_assert (!substitutions.empty ());\n+\n+  // now actually perform a substitution\n+  used_arguments = get_mappings_from_generic_args (*generic_args);\n+\n+  error_flag |= used_arguments.is_error ();\n+  auto &subst_mappings = used_arguments;\n+  for (auto &sub : get_substs ())\n+    {\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      bool ok\n+\t= subst_mappings.get_argument_for_symbol (sub.get_param_ty (), &arg);\n+      if (ok && arg.get_tyty () != nullptr)\n+\tsub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n+    }\n+}\n+\n+bool\n+TypeBoundPredicate::contains_item (const std::string &search) const\n+{\n+  auto trait_ref = get ();\n+  const Resolver::TraitItemReference *trait_item_ref = nullptr;\n+  return trait_ref->lookup_trait_item (search, &trait_item_ref);\n+}\n+\n+TypeBoundPredicateItem\n+TypeBoundPredicate::lookup_associated_item (const std::string &search) const\n+{\n+  auto trait_ref = get ();\n+  const Resolver::TraitItemReference *trait_item_ref = nullptr;\n+  if (!trait_ref->lookup_trait_item (search, &trait_item_ref))\n+    return TypeBoundPredicateItem::error ();\n+\n+  return TypeBoundPredicateItem (this, trait_item_ref);\n+}\n+\n+TypeBoundPredicateItem\n+TypeBoundPredicate::lookup_associated_item (\n+  const Resolver::TraitItemReference *ref) const\n+{\n+  return lookup_associated_item (ref->get_identifier ());\n+}\n+\n+BaseType *\n+TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n+{\n+  TyTy::BaseType *trait_item_tyty = get_raw_item ()->get_tyty ();\n+  if (parent->get_substitution_arguments ().is_empty ())\n+    return trait_item_tyty;\n+\n+  const Resolver::TraitItemReference *tref = get_raw_item ();\n+  bool is_associated_type = tref->get_trait_item_type ();\n+  if (is_associated_type)\n+    return trait_item_tyty;\n+\n+  // set up the self mapping\n+  SubstitutionArgumentMappings gargs = parent->get_substitution_arguments ();\n+  rust_assert (!gargs.is_empty ());\n+\n+  // setup the adjusted mappings\n+  std::vector<SubstitutionArg> adjusted_mappings;\n+  for (size_t i = 0; i < gargs.get_mappings ().size (); i++)\n+    {\n+      auto &mapping = gargs.get_mappings ().at (i);\n+\n+      bool is_implicit_self = i == 0;\n+      TyTy::BaseType *argument\n+\t= is_implicit_self ? receiver->clone () : mapping.get_tyty ();\n+\n+      SubstitutionArg arg (mapping.get_param_mapping (), argument);\n+      adjusted_mappings.push_back (std::move (arg));\n+    }\n+\n+  SubstitutionArgumentMappings adjusted (adjusted_mappings, gargs.get_locus (),\n+\t\t\t\t\t gargs.get_subst_cb (),\n+\t\t\t\t\t true /* trait-mode-flag */);\n+  return Resolver::SubstMapperInternal::Resolve (trait_item_tyty, adjusted);\n+}\n+bool\n+TypeBoundPredicate::is_error () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  Resolver::TraitReference *ref = nullptr;\n+  bool ok = context->lookup_trait_reference (reference, &ref);\n+\n+  return !ok || error_flag;\n+}\n+\n+BaseType *\n+TypeBoundPredicate::handle_substitions (\n+  SubstitutionArgumentMappings subst_mappings)\n+{\n+  for (auto &sub : get_substs ())\n+    {\n+      if (sub.get_param_ty () == nullptr)\n+\tcontinue;\n+\n+      ParamType *p = sub.get_param_ty ();\n+      BaseType *r = p->resolve ();\n+      BaseType *s = Resolver::SubstMapperInternal::Resolve (r, subst_mappings);\n+\n+      p->set_ty_ref (s->get_ty_ref ());\n+    }\n+\n+  // FIXME more error handling at some point\n+  // used_arguments = subst_mappings;\n+  // error_flag |= used_arguments.is_error ();\n+\n+  return nullptr;\n+}\n+\n+bool\n+TypeBoundPredicate::requires_generic_args () const\n+{\n+  if (is_error ())\n+    return false;\n+\n+  return substitutions.size () > 1;\n+}\n+\n+// trait item reference\n+\n+const Resolver::TraitItemReference *\n+TypeBoundPredicateItem::get_raw_item () const\n+{\n+  return trait_item_ref;\n+}\n+\n+bool\n+TypeBoundPredicateItem::needs_implementation () const\n+{\n+  return !get_raw_item ()->is_optional ();\n+}\n+\n+Location\n+TypeBoundPredicateItem::get_locus () const\n+{\n+  return get_raw_item ()->get_locus ();\n+}\n+\n+// TypeBoundsMappings\n+\n+TypeBoundsMappings::TypeBoundsMappings (\n+  std::vector<TypeBoundPredicate> specified_bounds)\n+  : specified_bounds (specified_bounds)\n+{}\n+\n+std::vector<TypeBoundPredicate> &\n+TypeBoundsMappings::get_specified_bounds ()\n+{\n+  return specified_bounds;\n+}\n+\n+const std::vector<TypeBoundPredicate> &\n+TypeBoundsMappings::get_specified_bounds () const\n+{\n+  return specified_bounds;\n+}\n+\n+size_t\n+TypeBoundsMappings::num_specified_bounds () const\n+{\n+  return specified_bounds.size ();\n+}\n+\n+std::string\n+TypeBoundsMappings::raw_bounds_as_string () const\n+{\n+  std::string buf;\n+  for (size_t i = 0; i < specified_bounds.size (); i++)\n+    {\n+      const TypeBoundPredicate &b = specified_bounds.at (i);\n+      bool has_next = (i + 1) < specified_bounds.size ();\n+      buf += b.as_string () + (has_next ? \" + \" : \"\");\n+    }\n+  return buf;\n+}\n+\n+std::string\n+TypeBoundsMappings::bounds_as_string () const\n+{\n+  return \"bounds:[\" + raw_bounds_as_string () + \"]\";\n+}\n+\n+std::string\n+TypeBoundsMappings::raw_bounds_as_name () const\n+{\n+  std::string buf;\n+  for (size_t i = 0; i < specified_bounds.size (); i++)\n+    {\n+      const TypeBoundPredicate &b = specified_bounds.at (i);\n+      bool has_next = (i + 1) < specified_bounds.size ();\n+      buf += b.as_name () + (has_next ? \" + \" : \"\");\n+    }\n+\n+  return buf;\n+}\n+\n+void\n+TypeBoundsMappings::add_bound (TypeBoundPredicate predicate)\n+{\n+  specified_bounds.push_back (predicate);\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "1ce82c943f5709e7ed64bfc337405481fb5ea32d", "filename": "gcc/rust/typecheck/rust-tyty-call.cc", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.cc?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,263 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tyty-call.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+void\n+TypeCheckCallExpr::visit (ADTType &type)\n+{\n+  rust_assert (!variant.is_error ());\n+  if (variant.get_variant_type () != TyTy::VariantDef::VariantType::TUPLE)\n+    {\n+      rust_error_at (\n+\tcall.get_locus (),\n+\t\"expected function, tuple struct or tuple variant, found struct %<%s%>\",\n+\ttype.get_name ().c_str ());\n+      return;\n+    }\n+\n+  if (call.num_params () != variant.num_fields ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) variant.num_fields ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      StructFieldType *field = variant.get_field_at_index (i);\n+      BaseType *field_tyty = field->get_field_type ();\n+\n+      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (arg->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"failed to resolve argument type\");\n+\t  return;\n+\t}\n+\n+      auto res = Resolver::TypeCheckBase::coercion_site (\n+\targument->get_mappings ().get_hirid (), field_tyty, arg,\n+\targument->get_locus ());\n+      if (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  return;\n+\t}\n+\n+      delete res;\n+      i++;\n+    }\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.clone ();\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnType &type)\n+{\n+  type.monomorphize ();\n+  if (call.num_params () != type.num_params ())\n+    {\n+      if (type.is_varadic ())\n+\t{\n+\t  if (call.num_params () < type.num_params ())\n+\t    {\n+\t      rust_error_at (call.get_locus (),\n+\t\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t\t     (unsigned long) call.num_params (),\n+\t\t\t     (unsigned long) type.num_params ());\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rust_error_at (call.get_locus (),\n+\t\t\t \"unexpected number of arguments %lu expected %lu\",\n+\t\t\t (unsigned long) call.num_params (),\n+\t\t\t (unsigned long) type.num_params ());\n+\t  return;\n+\t}\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      // it might be a varadic function\n+      if (i < type.num_params ())\n+\t{\n+\t  auto fnparam = type.param_at (i);\n+\t  auto resolved_argument_type = Resolver::TypeCheckBase::coercion_site (\n+\t    argument->get_mappings ().get_hirid (), fnparam.second,\n+\t    argument_expr_tyty, argument->get_locus ());\n+\t  if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t    {\n+\t      rust_error_at (argument->get_locus (),\n+\t\t\t     \"Type Resolution failure on parameter\");\n+\t      return;\n+\t    }\n+\t}\n+\n+      i++;\n+    }\n+\n+  if (i < call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  type.monomorphize ();\n+  resolved = type.get_return_type ()->clone ();\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnPtr &type)\n+{\n+  if (call.num_params () != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      auto resolved_argument_type = Resolver::TypeCheckBase::coercion_site (\n+\targument->get_mappings ().get_hirid (), fnparam, argument_expr_tyty,\n+\targument->get_locus ());\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n+\n+      i++;\n+    }\n+\n+  if (i != call.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.get_return_type ()->monomorphized_clone ();\n+}\n+\n+// method call checker\n+\n+void\n+TypeCheckMethodCallExpr::visit (FnType &type)\n+{\n+  type.get_self_type ()->unify (adjusted_self);\n+\n+  // +1 for the receiver self\n+  size_t num_args_to_call = call.num_params () + 1;\n+  if (num_args_to_call != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) call.num_params (),\n+\t\t     (unsigned long) type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 1;\n+  for (auto &argument : call.get_arguments ())\n+    {\n+      auto fnparam = type.param_at (i);\n+      auto argument_expr_tyty\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n+      if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (\n+\t    argument->get_locus (),\n+\t    \"failed to resolve type for argument expr in CallExpr\");\n+\t  return;\n+\t}\n+\n+      auto resolved_argument_type = Resolver::TypeCheckBase::coercion_site (\n+\targument->get_mappings ().get_hirid (), fnparam.second,\n+\targument_expr_tyty, argument->get_locus ());\n+      if (resolved_argument_type->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (argument->get_locus (),\n+\t\t\t \"Type Resolution failure on parameter\");\n+\t  return;\n+\t}\n+\n+      i++;\n+    }\n+\n+  if (i != num_args_to_call)\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     (unsigned long) i, (unsigned long) call.num_params ());\n+      return;\n+    }\n+\n+  type.monomorphize ();\n+\n+  resolved = type.get_return_type ()->monomorphized_clone ();\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "51817e6446d3eee0cda6e24ead7e85df2a9fd413", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,147 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_CALL\n+#define RUST_TYTY_CALL\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class TypeCheckCallExpr : private TyVisitor\n+{\n+public:\n+  static BaseType *go (BaseType *ref, HIR::CallExpr &call,\n+\t\t       TyTy::VariantDef &variant,\n+\t\t       Resolver::TypeCheckContext *context)\n+  {\n+    TypeCheckCallExpr checker (call, variant, context);\n+    ref->accept_vis (checker);\n+    return checker.resolved;\n+  }\n+\n+  void visit (InferType &) override { gcc_unreachable (); }\n+  void visit (TupleType &) override { gcc_unreachable (); }\n+  void visit (ArrayType &) override { gcc_unreachable (); }\n+  void visit (SliceType &) override { gcc_unreachable (); }\n+  void visit (BoolType &) override { gcc_unreachable (); }\n+  void visit (IntType &) override { gcc_unreachable (); }\n+  void visit (UintType &) override { gcc_unreachable (); }\n+  void visit (FloatType &) override { gcc_unreachable (); }\n+  void visit (USizeType &) override { gcc_unreachable (); }\n+  void visit (ISizeType &) override { gcc_unreachable (); }\n+  void visit (ErrorType &) override { gcc_unreachable (); }\n+  void visit (CharType &) override { gcc_unreachable (); }\n+  void visit (ReferenceType &) override { gcc_unreachable (); }\n+  void visit (PointerType &) override { gcc_unreachable (); }\n+  void visit (ParamType &) override { gcc_unreachable (); }\n+  void visit (StrType &) override { gcc_unreachable (); }\n+  void visit (NeverType &) override { gcc_unreachable (); }\n+  void visit (PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (ProjectionType &) override { gcc_unreachable (); }\n+  void visit (DynamicObjectType &) override { gcc_unreachable (); }\n+  void visit (ClosureType &type) override { gcc_unreachable (); }\n+\n+  // tuple-structs\n+  void visit (ADTType &type) override;\n+\n+  // call fns\n+  void visit (FnType &type) override;\n+  void visit (FnPtr &type) override;\n+\n+private:\n+  TypeCheckCallExpr (HIR::CallExpr &c, TyTy::VariantDef &variant,\n+\t\t     Resolver::TypeCheckContext *context)\n+    : resolved (new TyTy::ErrorType (c.get_mappings ().get_hirid ())), call (c),\n+      variant (variant), context (context),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  BaseType *resolved;\n+  HIR::CallExpr &call;\n+  TyTy::VariantDef &variant;\n+  Resolver::TypeCheckContext *context;\n+  Analysis::Mappings *mappings;\n+};\n+\n+class TypeCheckMethodCallExpr : private TyVisitor\n+{\n+public:\n+  // Resolve the Method parameters and return back the return type\n+  static BaseType *go (BaseType *ref, HIR::MethodCallExpr &call,\n+\t\t       TyTy::BaseType *adjusted_self,\n+\t\t       Resolver::TypeCheckContext *context)\n+  {\n+    TypeCheckMethodCallExpr checker (call, adjusted_self, context);\n+    ref->accept_vis (checker);\n+    return checker.resolved;\n+  }\n+\n+  void visit (InferType &) override { gcc_unreachable (); }\n+  void visit (TupleType &) override { gcc_unreachable (); }\n+  void visit (ArrayType &) override { gcc_unreachable (); }\n+  void visit (SliceType &) override { gcc_unreachable (); }\n+  void visit (BoolType &) override { gcc_unreachable (); }\n+  void visit (IntType &) override { gcc_unreachable (); }\n+  void visit (UintType &) override { gcc_unreachable (); }\n+  void visit (FloatType &) override { gcc_unreachable (); }\n+  void visit (USizeType &) override { gcc_unreachable (); }\n+  void visit (ISizeType &) override { gcc_unreachable (); }\n+  void visit (ErrorType &) override { gcc_unreachable (); }\n+  void visit (ADTType &) override { gcc_unreachable (); };\n+  void visit (CharType &) override { gcc_unreachable (); }\n+  void visit (ReferenceType &) override { gcc_unreachable (); }\n+  void visit (PointerType &) override { gcc_unreachable (); }\n+  void visit (ParamType &) override { gcc_unreachable (); }\n+  void visit (StrType &) override { gcc_unreachable (); }\n+  void visit (NeverType &) override { gcc_unreachable (); }\n+  void visit (PlaceholderType &) override { gcc_unreachable (); }\n+  void visit (ProjectionType &) override { gcc_unreachable (); }\n+  void visit (DynamicObjectType &) override { gcc_unreachable (); }\n+\n+  // FIXME\n+  void visit (FnPtr &type) override { gcc_unreachable (); }\n+\n+  // call fns\n+  void visit (FnType &type) override;\n+  void visit (ClosureType &type) override { gcc_unreachable (); }\n+\n+private:\n+  TypeCheckMethodCallExpr (HIR::MethodCallExpr &c,\n+\t\t\t   TyTy::BaseType *adjusted_self,\n+\t\t\t   Resolver::TypeCheckContext *context)\n+    : resolved (nullptr), call (c), adjusted_self (adjusted_self),\n+      context (context), mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  BaseType *resolved;\n+  HIR::MethodCallExpr &call;\n+  TyTy::BaseType *adjusted_self;\n+  Resolver::TypeCheckContext *context;\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_CALL"}, {"sha": "07d1dea7464ff1081a31420d12ab6826daad36b3", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "added", "additions": 1554, "deletions": 0, "changes": 1554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,1554 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_CMP_H\n+#define RUST_TYTY_CMP_H\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseCmp : public TyConstVisitor\n+{\n+public:\n+  virtual bool can_eq (const BaseType *other)\n+  {\n+    if (other->get_kind () == TypeKind::PARAM)\n+      {\n+\tconst ParamType *p = static_cast<const ParamType *> (other);\n+\tother = p->resolve ();\n+      }\n+    if (other->get_kind () == TypeKind::PLACEHOLDER)\n+      {\n+\tconst PlaceholderType *p = static_cast<const PlaceholderType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n+    if (other->get_kind () == TypeKind::PROJECTION)\n+      {\n+\tconst ProjectionType *p = static_cast<const ProjectionType *> (other);\n+\tother = p->get ();\n+      }\n+\n+    other->accept_vis (*this);\n+    return ok;\n+  }\n+\n+  virtual void visit (const TupleType &type) override\n+  {\n+    ok = false;\n+\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const ADTType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const InferType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const FnType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const FnPtr &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const ArrayType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const SliceType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const BoolType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const IntType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const UintType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const USizeType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const ISizeType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const FloatType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const ErrorType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const CharType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const ReferenceType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const PointerType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const StrType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const NeverType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const ProjectionType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const PlaceholderType &type) override\n+  {\n+    // it is ok for types to can eq to a placeholder\n+    ok = true;\n+  }\n+\n+  virtual void visit (const ParamType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const DynamicObjectType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+  virtual void visit (const ClosureType &type) override\n+  {\n+    ok = false;\n+    if (emit_error_flag)\n+      {\n+\tLocation ref_locus = mappings->lookup_location (type.get_ref ());\n+\tLocation base_locus\n+\t  = mappings->lookup_location (get_base ()->get_ref ());\n+\tRichLocation r (ref_locus);\n+\tr.add_range (base_locus);\n+\trust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t       get_base ()->as_string ().c_str (),\n+\t\t       type.as_string ().c_str ());\n+      }\n+  }\n+\n+protected:\n+  BaseCmp (const BaseType *base, bool emit_errors)\n+    : mappings (Analysis::Mappings::get ()),\n+      context (Resolver::TypeCheckContext::get ()), ok (false),\n+      emit_error_flag (emit_errors)\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver::TypeCheckContext *context;\n+\n+  bool ok;\n+  bool emit_error_flag;\n+\n+private:\n+  /* Returns a pointer to the ty that created this rule. */\n+  virtual const BaseType *get_base () const = 0;\n+};\n+\n+class InferCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  InferCmp (const InferType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const BoolType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const IntType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const UintType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const USizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const ISizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const FloatType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const ArrayType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const SliceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const ADTType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const TupleType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const InferType &type) override\n+  {\n+    switch (base->get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tok = true;\n+\treturn;\n+\n+\tcase InferType::InferTypeKind::INTEGRAL: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase InferType::InferTypeKind::FLOAT: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      ok = true;\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const CharType &type) override\n+  {\n+    {\n+      bool is_valid\n+\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+      if (is_valid)\n+\t{\n+\t  ok = true;\n+\t  return;\n+\t}\n+\n+      BaseCmp::visit (type);\n+    }\n+  }\n+\n+  void visit (const ReferenceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const PointerType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const ParamType &) override { ok = true; }\n+\n+  void visit (const DynamicObjectType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+  void visit (const ClosureType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tok = true;\n+\treturn;\n+      }\n+\n+    BaseCmp::visit (type);\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const InferType *base;\n+};\n+\n+class FnCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FnCmp (const FnType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+  void visit (const FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto a = base->param_at (i).second;\n+\tauto b = type.param_at (i).second;\n+\n+\tif (!a->can_eq (b, emit_error_flag))\n+\t  {\n+\t    emit_error_flag = false;\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    if (!base->get_return_type ()->can_eq (type.get_return_type (),\n+\t\t\t\t\t   emit_error_flag))\n+      {\n+\temit_error_flag = false;\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const FnType *base;\n+};\n+\n+class FnptrCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FnptrCmp (const FnPtr *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const FnPtr &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i);\n+\tif (!this_param->can_eq (other_param, emit_error_flag))\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    if (!this_ret_type->can_eq (other_ret_type, emit_error_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i).second;\n+\tif (!this_param->can_eq (other_param, emit_error_flag))\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const FnPtr *base;\n+};\n+\n+class ClosureCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ClosureCmp (const ClosureType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const ClosureType *base;\n+};\n+\n+class ArrayCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ArrayCmp (const ArrayType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const ArrayType &type) override\n+  {\n+    // check base type\n+    const BaseType *base_element = base->get_element_type ();\n+    const BaseType *other_element = type.get_element_type ();\n+    if (!base_element->can_eq (other_element, emit_error_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const ArrayType *base;\n+};\n+\n+class SliceCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  SliceCmp (const SliceType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const SliceType &type) override\n+  {\n+    // check base type\n+    const BaseType *base_element = base->get_element_type ();\n+    const BaseType *other_element = type.get_element_type ();\n+    if (!base_element->can_eq (other_element, emit_error_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const SliceType *base;\n+};\n+\n+class BoolCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  BoolCmp (const BoolType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const BoolType &type) override { ok = true; }\n+\n+  void visit (const InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const BoolType *base;\n+};\n+\n+class IntCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  IntCmp (const IntType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (const IntType &type) override\n+  {\n+    ok = type.get_int_kind () == base->get_int_kind ();\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const IntType *base;\n+};\n+\n+class UintCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  UintCmp (const UintType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (const UintType &type) override\n+  {\n+    ok = type.get_uint_kind () == base->get_uint_kind ();\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const UintType *base;\n+};\n+\n+class FloatCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  FloatCmp (const FloatType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::INTEGRAL;\n+  }\n+\n+  void visit (const FloatType &type) override\n+  {\n+    ok = type.get_float_kind () == base->get_float_kind ();\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const FloatType *base;\n+};\n+\n+class ADTCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ADTCmp (const ADTType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const ADTType &type) override\n+  {\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->number_of_variants () != type.number_of_variants ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n+      {\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n+\n+\tif (a->num_fields () != b->num_fields ())\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (j);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (j);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    if (!this_field_ty->can_eq (other_field_ty, emit_error_flag))\n+\t      {\n+\t\tBaseCmp::visit (type);\n+\t\treturn;\n+\t      }\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const ADTType *base;\n+};\n+\n+class TupleCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  TupleCmp (const TupleType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const TupleType &type) override\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_fields (); i++)\n+      {\n+\tBaseType *bo = base->get_field (i);\n+\tBaseType *fo = type.get_field (i);\n+\n+\tif (!bo->can_eq (fo, emit_error_flag))\n+\t  {\n+\t    BaseCmp::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const TupleType *base;\n+};\n+\n+class USizeCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  USizeCmp (const USizeType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (const USizeType &type) override { ok = true; }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const USizeType *base;\n+};\n+\n+class ISizeCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ISizeCmp (const ISizeType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    ok = type.get_infer_kind () != InferType::InferTypeKind::FLOAT;\n+  }\n+\n+  void visit (const ISizeType &type) override { ok = true; }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const ISizeType *base;\n+};\n+\n+class CharCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  CharCmp (const CharType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const InferType &type) override\n+  {\n+    ok = type.get_infer_kind () == InferType::InferTypeKind::GENERAL;\n+  }\n+\n+  void visit (const CharType &type) override { ok = true; }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const CharType *base;\n+};\n+\n+class ReferenceCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ReferenceCmp (const ReferenceType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const ReferenceType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    bool mutability_match = base->is_mutable () == type.is_mutable ();\n+    if (!mutability_match)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (!base_type->can_eq (other_base_type, emit_error_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const ReferenceType *base;\n+};\n+\n+class PointerCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  PointerCmp (const PointerType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const PointerType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    // rust is permissive about mutablity here you can always go from mutable to\n+    // immutable but not the otherway round\n+    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (!mutability_ok)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (!base_type->can_eq (other_base_type, emit_error_flag))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const PointerType *base;\n+};\n+\n+class ParamCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  ParamCmp (const ParamType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  // param types are a placeholder we shouldn't have cases where we unify\n+  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n+  //\n+  // foo<i32>{ a: 123 }.\n+  // Then this enforces the i32 type to be referenced on the\n+  // field via an hirid.\n+  //\n+  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n+  // to handle the typing of the struct\n+  bool can_eq (const BaseType *other) override\n+  {\n+    if (!base->can_resolve ())\n+      return BaseCmp::can_eq (other);\n+\n+    auto lookup = base->resolve ();\n+    return lookup->can_eq (other, emit_error_flag);\n+  }\n+\n+  // imagine the case where we have:\n+  // struct Foo<T>(T);\n+  // Then we declare a generic impl block\n+  // impl <X>Foo<X> { ... }\n+  // both of these types are compatible so we mostly care about the number of\n+  // generic arguments\n+  void visit (const ParamType &) override { ok = true; }\n+\n+  void visit (const InferType &) override { ok = true; }\n+\n+  void visit (const FnType &) override { ok = true; }\n+\n+  void visit (const FnPtr &) override { ok = true; }\n+\n+  void visit (const ADTType &) override { ok = true; }\n+\n+  void visit (const ArrayType &) override { ok = true; }\n+\n+  void visit (const SliceType &) override { ok = true; }\n+\n+  void visit (const BoolType &) override { ok = true; }\n+\n+  void visit (const IntType &) override { ok = true; }\n+\n+  void visit (const UintType &) override { ok = true; }\n+\n+  void visit (const USizeType &) override { ok = true; }\n+\n+  void visit (const ISizeType &) override { ok = true; }\n+\n+  void visit (const FloatType &) override { ok = true; }\n+\n+  void visit (const CharType &) override { ok = true; }\n+\n+  void visit (const ReferenceType &) override { ok = true; }\n+\n+  void visit (const PointerType &) override { ok = true; }\n+\n+  void visit (const StrType &) override { ok = true; }\n+\n+  void visit (const NeverType &) override { ok = true; }\n+\n+  void visit (const DynamicObjectType &) override { ok = true; }\n+\n+  void visit (const PlaceholderType &type) override\n+  {\n+    ok = base->get_symbol ().compare (type.get_symbol ()) == 0;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const ParamType *base;\n+};\n+\n+class StrCmp : public BaseCmp\n+{\n+  // FIXME we will need a enum for the StrType like ByteBuf etc..\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  StrCmp (const StrType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const StrType &type) override { ok = true; }\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const StrType *base;\n+};\n+\n+class NeverCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  NeverCmp (const NeverType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const NeverType &type) override { ok = true; }\n+\n+  void visit (const InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+  const NeverType *base;\n+};\n+\n+class PlaceholderCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  PlaceholderCmp (const PlaceholderType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  bool can_eq (const BaseType *other) override\n+  {\n+    if (!base->can_resolve ())\n+      return BaseCmp::can_eq (other);\n+\n+    BaseType *lookup = base->resolve ();\n+    return lookup->can_eq (other, emit_error_flag);\n+  }\n+\n+  void visit (const TupleType &) override { ok = true; }\n+\n+  void visit (const ADTType &) override { ok = true; }\n+\n+  void visit (const InferType &) override { ok = true; }\n+\n+  void visit (const FnType &) override { ok = true; }\n+\n+  void visit (const FnPtr &) override { ok = true; }\n+\n+  void visit (const ArrayType &) override { ok = true; }\n+\n+  void visit (const BoolType &) override { ok = true; }\n+\n+  void visit (const IntType &) override { ok = true; }\n+\n+  void visit (const UintType &) override { ok = true; }\n+\n+  void visit (const USizeType &) override { ok = true; }\n+\n+  void visit (const ISizeType &) override { ok = true; }\n+\n+  void visit (const FloatType &) override { ok = true; }\n+\n+  void visit (const ErrorType &) override { ok = true; }\n+\n+  void visit (const CharType &) override { ok = true; }\n+\n+  void visit (const ReferenceType &) override { ok = true; }\n+\n+  void visit (const ParamType &) override { ok = true; }\n+\n+  void visit (const StrType &) override { ok = true; }\n+\n+  void visit (const NeverType &) override { ok = true; }\n+\n+  void visit (const SliceType &) override { ok = true; }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+\n+  const PlaceholderType *base;\n+};\n+\n+class DynamicCmp : public BaseCmp\n+{\n+  using Rust::TyTy::BaseCmp::visit;\n+\n+public:\n+  DynamicCmp (const DynamicObjectType *base, bool emit_errors)\n+    : BaseCmp (base, emit_errors), base (base)\n+  {}\n+\n+  void visit (const DynamicObjectType &type) override\n+  {\n+    if (base->num_specified_bounds () != type.num_specified_bounds ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    ok = base->bounds_compatible (type, ref_locus, false);\n+  }\n+\n+private:\n+  const BaseType *get_base () const override { return base; }\n+\n+  const DynamicObjectType *base;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_CMP_H"}, {"sha": "77d912a592108272091fb39a13ce1833351821e5", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "added", "additions": 1584, "deletions": 0, "changes": 1584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06688fe40a249a406634d3307f662e2fe2e0c517/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=06688fe40a249a406634d3307f662e2fe2e0c517", "patch": "@@ -0,0 +1,1584 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_RULES\n+#define RUST_TYTY_RULES\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+/* Rules specify how to unify two Ty. For example, the result of unifying the\n+   two tuples (u64, A) and (B, i64) would be (u64, i64).\n+\n+   Performing a unification requires a double dispatch. To illustrate, suppose\n+   we want to unify `ty1` and `ty2`. Here's what it looks like:\n+     1. The caller calls `ty1.unify(ty2)`. This is the first dispatch.\n+     2. `ty1` creates a rule specific to its type(e.g. TupleRules).\n+     3. The rule calls `ty2.accept_vis(rule)`. This is the second dispatch.\n+     4. `ty2` calls `rule.visit(*this)`, which will method-overload to the\n+\t      correct implementation at compile time.\n+\n+   The nice thing about Rules is that they seperate unification logic from the\n+   representation of Ty. To support unifying a new Ty, implement its\n+   `accept_vis` and `unify` method to pass the unification request to Rules.\n+   Then, create a new `XXXRules` class and implement one `visit` method for\n+   every Ty it can unify with. */\n+class BaseRules : public TyVisitor\n+{\n+public:\n+  virtual ~BaseRules () {}\n+\n+  /* Unify two ty. Returns a pointer to the newly-created unified ty, or nullptr\n+     if the two types cannot be unified. The caller is responsible for releasing\n+     the memory of the returned ty.\n+\n+     This method is meant to be used internally by Ty. If you're trying to unify\n+     two ty, you can simply call `unify` on ty themselves. */\n+  virtual BaseType *unify (BaseType *other)\n+  {\n+    if (other->get_kind () == TypeKind::PARAM)\n+      {\n+\tParamType *p = static_cast<ParamType *> (other);\n+\tother = p->resolve ();\n+      }\n+    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n+      {\n+\tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t    return get_base ()->unify (other);\n+\t  }\n+      }\n+    else if (other->get_kind () == TypeKind::PROJECTION)\n+      {\n+\tProjectionType *p = static_cast<ProjectionType *> (other);\n+\tother = p->get ();\n+\treturn get_base ()->unify (other);\n+      }\n+\n+    other->accept_vis (*this);\n+    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+      return resolved;\n+\n+    resolved->append_reference (get_base ()->get_ref ());\n+    resolved->append_reference (other->get_ref ());\n+    for (auto ref : get_base ()->get_combined_refs ())\n+      resolved->append_reference (ref);\n+    for (auto ref : other->get_combined_refs ())\n+      resolved->append_reference (ref);\n+\n+    other->append_reference (resolved->get_ref ());\n+    other->append_reference (get_base ()->get_ref ());\n+    get_base ()->append_reference (resolved->get_ref ());\n+    get_base ()->append_reference (other->get_ref ());\n+\n+    bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n+    bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n+    bool results_is_non_general_infer_var\n+      = (result_is_infer_var\n+\t && (static_cast<InferType *> (resolved))->get_infer_kind ()\n+\t      != TyTy::InferType::GENERAL);\n+    if (result_resolved || results_is_non_general_infer_var)\n+      {\n+\tfor (auto &ref : resolved->get_combined_refs ())\n+\t  {\n+\t    TyTy::BaseType *ref_tyty = nullptr;\n+\t    bool ok = context->lookup_type (ref, &ref_tyty);\n+\t    if (!ok)\n+\t      continue;\n+\n+\t    // if any of the types are inference variables lets fix them\n+\t    if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n+\t      {\n+\t\tcontext->insert_type (\n+\t\t  Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t UNKNOWN_NODEID, ref,\n+\t\t\t\t\t UNKNOWN_LOCAL_DEFID),\n+\t\t  resolved->clone ());\n+\t      }\n+\t  }\n+      }\n+    return resolved;\n+  }\n+\n+  virtual void visit (TupleType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ADTType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (InferType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FnType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FnPtr &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ArrayType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (SliceType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (BoolType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (IntType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (UintType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (USizeType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ISizeType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FloatType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ErrorType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (CharType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ReferenceType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (PointerType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ParamType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (StrType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (NeverType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (PlaceholderType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ProjectionType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (DynamicObjectType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ClosureType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+protected:\n+  BaseRules (BaseType *base)\n+    : mappings (Analysis::Mappings::get ()),\n+      context (Resolver::TypeCheckContext::get ()),\n+      resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver::TypeCheckContext *context;\n+\n+  /* Temporary storage for the result of a unification.\n+     We could return the result directly instead of storing it in the rule\n+     object, but that involves modifying the visitor pattern to accommodate\n+     the return value, which is too complex. */\n+  BaseType *resolved;\n+\n+private:\n+  /* Returns a pointer to the ty that created this rule. */\n+  virtual BaseType *get_base () = 0;\n+};\n+\n+class InferRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  InferRules (InferType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (BoolType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (USizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (ISizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (ArrayType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (SliceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (ADTType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (TupleType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (base->get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = type.clone ();\n+\treturn;\n+\n+\tcase InferType::InferTypeKind::INTEGRAL: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase InferType::InferTypeKind::FLOAT: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (CharType &type) override\n+  {\n+    {\n+      bool is_valid\n+\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+      if (is_valid)\n+\t{\n+\t  resolved = type.clone ();\n+\t  return;\n+\t}\n+\n+      BaseRules::visit (type);\n+    }\n+  }\n+\n+  void visit (ReferenceType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (PointerType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (DynamicObjectType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (ClosureType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  InferType *base;\n+};\n+\n+class FnRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  FnRules (FnType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto a = base->param_at (i).second;\n+\tauto b = type.param_at (i).second;\n+\n+\tauto unified_param = a->unify (b);\n+\tif (unified_param == nullptr)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    auto unified_return\n+      = base->get_return_type ()->unify (type.get_return_type ());\n+    if (unified_return == nullptr)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnType *base;\n+};\n+\n+class FnptrRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  FnptrRules (FnPtr *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnPtr &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i);\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i).second;\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnPtr *base;\n+};\n+\n+class ClosureRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  ClosureRules (ClosureType *base) : BaseRules (base), base (base) {}\n+\n+  // TODO\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ClosureType *base;\n+};\n+\n+class ArrayRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  ArrayRules (ArrayType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (ArrayType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved\n+      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t       type.get_ident ().locus, type.get_capacity_expr (),\n+\t\t       TyVar (base_resolved->get_ref ()));\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ArrayType *base;\n+};\n+\n+class SliceRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  SliceRules (SliceType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (SliceType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new SliceType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_ident ().locus,\n+\t\t\t      TyVar (base_resolved->get_ref ()));\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  SliceType *base;\n+};\n+\n+class BoolRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  BoolRules (BoolType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (BoolType &type) override\n+  {\n+    resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (type.get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = base->clone ();\n+\tbreak;\n+\n+      default:\n+\tBaseRules::visit (type);\n+\tbreak;\n+      }\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  BoolType *base;\n+};\n+\n+class IntRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  IntRules (IntType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    if (type.get_int_kind () != base->get_int_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved\n+      = new IntType (type.get_ref (), type.get_ty_ref (), type.get_int_kind ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  IntType *base;\n+};\n+\n+class UintRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  UintRules (UintType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    if (type.get_uint_kind () != base->get_uint_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new UintType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t     type.get_uint_kind ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  UintType *base;\n+};\n+\n+class FloatRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  FloatRules (FloatType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    if (type.get_float_kind () != base->get_float_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new FloatType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_float_kind ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FloatType *base;\n+};\n+\n+class ADTRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  ADTRules (ADTType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (ADTType &type) override\n+  {\n+    if (base->get_adt_kind () != type.get_adt_kind ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->number_of_variants () != type.number_of_variants ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < type.number_of_variants (); ++i)\n+      {\n+\tTyTy::VariantDef *a = base->get_variants ().at (i);\n+\tTyTy::VariantDef *b = type.get_variants ().at (i);\n+\n+\tif (a->num_fields () != b->num_fields ())\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+\n+\tfor (size_t j = 0; j < a->num_fields (); j++)\n+\t  {\n+\t    TyTy::StructFieldType *base_field = a->get_field_at_index (j);\n+\t    TyTy::StructFieldType *other_field = b->get_field_at_index (j);\n+\n+\t    TyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\t    TyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\t    BaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\t    if (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n+      }\n+\n+    // generic args for the unit-struct case\n+    if (type.is_unit () && base->is_unit ())\n+      {\n+\trust_assert (type.get_num_substitutions ()\n+\t\t     == base->get_num_substitutions ());\n+\n+\tfor (size_t i = 0; i < type.get_num_substitutions (); i++)\n+\t  {\n+\t    auto &a = base->get_substs ().at (i);\n+\t    auto &b = type.get_substs ().at (i);\n+\n+\t    auto pa = a.get_param_ty ();\n+\t    auto pb = b.get_param_ty ();\n+\n+\t    auto res = pa->unify (pb);\n+\t    if (res->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\treturn;\n+\t      }\n+\t  }\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ADTType *base;\n+};\n+\n+class TupleRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  TupleRules (TupleType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (TupleType &type) override\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    std::vector<TyVar> fields;\n+    for (size_t i = 0; i < base->num_fields (); i++)\n+      {\n+\tBaseType *bo = base->get_field (i);\n+\tBaseType *fo = type.get_field (i);\n+\n+\tBaseType *unified_ty = bo->unify (fo);\n+\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+\n+\tfields.push_back (TyVar (unified_ty->get_ref ()));\n+      }\n+\n+    resolved = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t    type.get_ident ().locus, fields);\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  TupleType *base;\n+};\n+\n+class USizeRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  USizeRules (USizeType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (USizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  USizeType *base;\n+};\n+\n+class ISizeRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  ISizeRules (ISizeType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (ISizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ISizeType *base;\n+};\n+\n+class CharRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  CharRules (CharType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (CharType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  CharType *base;\n+};\n+\n+class ReferenceRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  ReferenceRules (ReferenceType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (ReferenceType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n+    if (base_resolved == nullptr\n+\t|| base_resolved->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    // rust is permissive about mutablity here you can always go from mutable to\n+    // immutable but not the otherway round\n+    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (!mutability_ok)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new ReferenceType (base->get_ref (), base->get_ty_ref (),\n+\t\t\t\t  TyVar (base_resolved->get_ref ()),\n+\t\t\t\t  base->mutability ());\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ReferenceType *base;\n+};\n+\n+class PointerRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  PointerRules (PointerType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (PointerType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n+    if (base_resolved == nullptr\n+\t|| base_resolved->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    // rust is permissive about mutablity here you can always go from mutable to\n+    // immutable but not the otherway round\n+    bool mutability_ok = base->is_mutable () ? type.is_mutable () : true;\n+    if (!mutability_ok)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new PointerType (base->get_ref (), base->get_ty_ref (),\n+\t\t\t\tTyVar (base_resolved->get_ref ()),\n+\t\t\t\tbase->mutability ());\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  PointerType *base;\n+};\n+\n+class ParamRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  ParamRules (ParamType *base) : BaseRules (base), base (base) {}\n+\n+  // param types are a placeholder we shouldn't have cases where we unify\n+  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n+  //\n+  // foo<i32>{ a: 123 }.\n+  // Then this enforces the i32 type to be referenced on the\n+  // field via an hirid.\n+  //\n+  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n+  // to handle the typing of the struct\n+  BaseType *unify (BaseType *other) override final\n+  {\n+    if (!base->can_resolve ())\n+      return BaseRules::unify (other);\n+\n+    auto lookup = base->resolve ();\n+    return lookup->unify (other);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ParamType *base;\n+};\n+\n+class StrRules : public BaseRules\n+{\n+  // FIXME we will need a enum for the StrType like ByteBuf etc..\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  StrRules (StrType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (StrType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  StrType *base;\n+};\n+\n+class NeverRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  NeverRules (NeverType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (NeverType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  NeverType *base;\n+};\n+\n+class PlaceholderRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  PlaceholderRules (PlaceholderType *base) : BaseRules (base), base (base) {}\n+\n+  BaseType *unify (BaseType *other) override final\n+  {\n+    if (!base->can_resolve ())\n+      return BaseRules::unify (other);\n+\n+    BaseType *lookup = base->resolve ();\n+    return lookup->unify (other);\n+  }\n+\n+  void visit (PlaceholderType &type) override\n+  {\n+    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  PlaceholderType *base;\n+};\n+\n+class DynamicRules : public BaseRules\n+{\n+  using Rust::TyTy::BaseRules::visit;\n+\n+public:\n+  DynamicRules (DynamicObjectType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+  void visit (DynamicObjectType &type) override\n+  {\n+    if (base->num_specified_bounds () != type.num_specified_bounds ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    if (!base->bounds_compatible (type, ref_locus, true))\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  DynamicObjectType *base;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_RULES"}]}