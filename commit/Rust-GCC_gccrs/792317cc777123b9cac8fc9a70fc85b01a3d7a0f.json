{"sha": "792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyMzE3Y2M3NzcxMjNiOWNhYzhmYzlhNzBmYzg1YjAxYTNkN2EwZg==", "commit": {"author": {"name": "Sriraman Tallam", "email": "tmsriram@google.com", "date": "2012-04-25T00:08:37Z"}, "committer": {"name": "Sriraman Tallam", "email": "tmsriram@gcc.gnu.org", "date": "2012-04-25T00:08:37Z"}, "message": "This patch adds new builtins to check for cpu type and features.\n\n2012-04-24  Sriraman Tallam  <tmsriram@google.com>\n\nThis patch adds new builtins to check for cpu type and features. \n\n* __builtin_cpu_is (\"<CPUNAME>\")\n* __builtin_cpu_supports (\"<FEATURE>\")\n\napart from the cpu init builtin, __builtin_cpu_init.\n\nList of CPU names :\n\n* \"amd\"\n* \"intel\"\n* \"atom\"\n* \"core2\"\n* \"corei7\"\n* \"nehalem\"\n* \"westmere\"\n* \"sandybridge\"\n* \"amdfam10h\"\n* \"barcelona\"\n* \"shanghai\"\n* \"istanbul\"\n* \"bdver1\"\n* \"bdver2\"\n\nList of CPU features :\n\n* \"cmov\"\n* \"mmx\"\n* \"popcnt\"\n* \"sse\"\n* \"sse2\"\n* \"sse3\"\n* \"ssse3\"\n* \"sse4.1\"\n* \"sse4.2\"\n* \"avx\"\n\n        * config/i386/i386.c (build_processor_model_struct): New function.\n        (make_var_decl): New function.\n        (fold_builtin_cpu): New function.\n        (ix86_fold_builtin): New function.\n        (make_cpu_type_builtin): New function.\n        (ix86_init_platform_type_builtins): New function.\n        (ix86_expand_builtin): Expand new builtins by folding them.\n        (ix86_init_builtins): Make new builtins to detect CPU type.\n        (TARGET_FOLD_BUILTIN): New macro.\n        (IX86_BUILTIN_CPU_INIT): New enum value.\n        (IX86_BUILTIN_CPU_IS): New enum value.\n        (IX86_BUILTIN_CPU_SUPPORTS): New enum value.\n        * config/i386/i386-builtin-types.def: New function type.\n        * testsuite/gcc.target/builtin_target.c: New testcase.\n        * doc/extend.texi: Document builtins.\n\n        * libgcc/config/i386/i386-cpuinfo.c: New file.\n        * libgcc/config/i386/t-cpuinfo: New file.\n        * libgcc/config.host: Include t-cpuinfo.\n        * libgcc/config/i386/libgcc-glibc.ver: Version symbol __cpu_model.\n\nFrom-SVN: r186789", "tree": {"sha": "24353908af542b30588c5987f4df12eea09eb6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24353908af542b30588c5987f4df12eea09eb6e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/comments", "author": {"login": "tmsri", "id": 38991943, "node_id": "MDQ6VXNlcjM4OTkxOTQz", "avatar_url": "https://avatars.githubusercontent.com/u/38991943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmsri", "html_url": "https://github.com/tmsri", "followers_url": "https://api.github.com/users/tmsri/followers", "following_url": "https://api.github.com/users/tmsri/following{/other_user}", "gists_url": "https://api.github.com/users/tmsri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmsri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmsri/subscriptions", "organizations_url": "https://api.github.com/users/tmsri/orgs", "repos_url": "https://api.github.com/users/tmsri/repos", "events_url": "https://api.github.com/users/tmsri/events{/privacy}", "received_events_url": "https://api.github.com/users/tmsri/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1be98a467ee4c954722eb9b41a6ca2d0d7b78b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1be98a467ee4c954722eb9b41a6ca2d0d7b78b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1be98a467ee4c954722eb9b41a6ca2d0d7b78b1"}], "stats": {"total": 922, "additions": 921, "deletions": 1}, "files": [{"sha": "10692295c84b2b78acdeac53cdc84c674be412d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -1,3 +1,21 @@\n+2012-04-24  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* config/i386/i386.c (build_processor_model_struct): New function.\n+\t(make_var_decl): New function.\n+\t(fold_builtin_cpu): New function.\n+\t(ix86_fold_builtin): New function.\n+\t(make_cpu_type_builtin): New function.\n+\t(ix86_init_platform_type_builtins): New function.\n+\t(ix86_expand_builtin): Expand new builtins by folding them.\n+\t(ix86_init_builtins): Make new builtins to detect CPU type.\n+\t(TARGET_FOLD_BUILTIN): New macro.\n+\t(IX86_BUILTIN_CPU_INIT): New enum value.\n+\t(IX86_BUILTIN_CPU_IS): New enum value.\n+\t(IX86_BUILTIN_CPU_SUPPORTS): New enum value.\n+\t* config/i386/i386-builtin-types.def: New function type.\n+\t* testsuite/gcc.target/builtin_target.c: New testcase.\n+\t* doc/extend.texi: Document builtins.\n+\n 2012-04-24  Olivier Hainque  <hainque@adacore.com>\n \n \t* common.opt (gdwarf-): Initialize dwarf_version to -1 instead of 2."}, {"sha": "401668a7844aa00b1be557f1764140e32932cc72", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -155,6 +155,7 @@ DEF_FUNCTION_TYPE (INT, V4SF)\n DEF_FUNCTION_TYPE (INT, V8QI)\n DEF_FUNCTION_TYPE (INT, V8SF)\n DEF_FUNCTION_TYPE (INT, V32QI)\n+DEF_FUNCTION_TYPE (INT, PCCHAR)\n DEF_FUNCTION_TYPE (INT64, INT64)\n DEF_FUNCTION_TYPE (INT64, V2DF)\n DEF_FUNCTION_TYPE (INT64, V4SF)"}, {"sha": "13cb4bd60343c32d7955adf8ea98c84b7638b13b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -25855,6 +25855,11 @@ enum ix86_builtins\n   /* CFString built-in for darwin */\n   IX86_BUILTIN_CFSTRING,\n \n+  /* Builtins to get CPU type and supported features. */\n+  IX86_BUILTIN_CPU_INIT,\n+  IX86_BUILTIN_CPU_IS,\n+  IX86_BUILTIN_CPU_SUPPORTS,\n+\n   IX86_BUILTIN_MAX\n };\n \n@@ -27673,6 +27678,334 @@ ix86_init_mmx_sse_builtins (void)\n     }\n }\n \n+/* This builds the processor_model struct type defined in\n+   libgcc/config/i386/i386-cpuinfo.c  */\n+\n+static tree\n+build_processor_model_struct (void)\n+{\n+  const char *field_name[] = {\"__cpu_vendor\", \"__cpu_type\", \"__cpu_subtype\",\n+\t\t\t      \"__cpu_features\"};\n+  tree field = NULL_TREE, field_chain = NULL_TREE;\n+  int i;\n+  tree type = make_node (RECORD_TYPE);\n+\n+  /* The first 3 fields are unsigned int.  */\n+  for (i = 0; i < 3; ++i)\n+    {\n+      field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t  get_identifier (field_name[i]), unsigned_type_node);\n+      if (field_chain != NULL_TREE)\n+\tDECL_CHAIN (field) = field_chain;\n+      field_chain = field;\n+    }\n+\n+  /* The last field is an array of unsigned integers of size one.  */\n+  field = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t      get_identifier (field_name[3]),\n+\t\t      build_array_type (unsigned_type_node,\n+\t\t\t\t\tbuild_index_type (size_one_node)));\n+  if (field_chain != NULL_TREE)\n+    DECL_CHAIN (field) = field_chain;\n+  field_chain = field;\n+\n+  finish_builtin_struct (type, \"__processor_model\", field_chain, NULL_TREE);\n+  return type;\n+}\n+\n+/* Returns a extern, comdat VAR_DECL of type TYPE and name NAME. */\n+\n+static tree\n+make_var_decl (tree type, const char *name)\n+{\n+  tree new_decl;\n+\n+  new_decl = build_decl (UNKNOWN_LOCATION,\n+\t                 VAR_DECL,\n+\t  \t         get_identifier(name),\n+\t\t         type);\n+\n+  DECL_EXTERNAL (new_decl) = 1;\n+  TREE_STATIC (new_decl) = 1;\n+  TREE_PUBLIC (new_decl) = 1;\n+  DECL_INITIAL (new_decl) = 0;\n+  DECL_ARTIFICIAL (new_decl) = 0;\n+  DECL_PRESERVE_P (new_decl) = 1;\n+\n+  make_decl_one_only (new_decl, DECL_ASSEMBLER_NAME (new_decl));\n+  assemble_variable (new_decl, 0, 0, 0);\n+\n+  return new_decl;\n+}\n+\n+/* FNDECL is a __builtin_cpu_is or a __builtin_cpu_supports call that is folded\n+   into an integer defined in libgcc/config/i386/i386-cpuinfo.c */\n+\n+static tree\n+fold_builtin_cpu (tree fndecl, tree *args)\n+{\n+  unsigned int i;\n+  enum ix86_builtins fn_code = (enum ix86_builtins)\n+\t\t\t\tDECL_FUNCTION_CODE (fndecl);\n+  tree param_string_cst = NULL;\n+\n+  /* This is the order of bit-fields in __processor_features in\n+     i386-cpuinfo.c */\n+  enum processor_features\n+  {\n+    F_CMOV = 0,\n+    F_MMX,\n+    F_POPCNT,\n+    F_SSE,\n+    F_SSE2,\n+    F_SSE3,\n+    F_SSSE3,\n+    F_SSE4_1,\n+    F_SSE4_2,\n+    F_AVX,\n+    F_MAX\n+  };\n+\n+  /* These are the values for vendor types and cpu types  and subtypes\n+     in i386-cpuinfo.c.  Cpu types and subtypes should be subtracted by\n+     the corresponding start value.  */\n+  enum processor_model\n+  {\n+    M_INTEL = 1,\n+    M_AMD,\n+    M_CPU_TYPE_START,\n+    M_INTEL_ATOM,\n+    M_INTEL_CORE2,\n+    M_INTEL_COREI7,\n+    M_AMDFAM10H,\n+    M_AMDFAM15H,\n+    M_CPU_SUBTYPE_START,\n+    M_INTEL_COREI7_NEHALEM,\n+    M_INTEL_COREI7_WESTMERE,\n+    M_INTEL_COREI7_SANDYBRIDGE,\n+    M_AMDFAM10H_BARCELONA,\n+    M_AMDFAM10H_SHANGHAI,\n+    M_AMDFAM10H_ISTANBUL,\n+    M_AMDFAM15H_BDVER1,\n+    M_AMDFAM15H_BDVER2\n+  };\n+\n+  static struct _arch_names_table\n+    {\n+      const char *const name;\n+      const enum processor_model model;\n+    }\n+  const arch_names_table[] =\n+    {\n+      {\"amd\", M_AMD},\n+      {\"intel\", M_INTEL},\n+      {\"atom\", M_INTEL_ATOM},\n+      {\"core2\", M_INTEL_CORE2},\n+      {\"corei7\", M_INTEL_COREI7},\n+      {\"nehalem\", M_INTEL_COREI7_NEHALEM},\n+      {\"westmere\", M_INTEL_COREI7_WESTMERE},\n+      {\"sandybridge\", M_INTEL_COREI7_SANDYBRIDGE},\n+      {\"amdfam10h\", M_AMDFAM10H},\n+      {\"barcelona\", M_AMDFAM10H_BARCELONA},\n+      {\"shanghai\", M_AMDFAM10H_SHANGHAI},\n+      {\"istanbul\", M_AMDFAM10H_ISTANBUL},\n+      {\"amdfam15h\", M_AMDFAM15H},\n+      {\"bdver1\", M_AMDFAM15H_BDVER1},\n+      {\"bdver2\", M_AMDFAM15H_BDVER2},\n+    };\n+\n+  static struct _isa_names_table\n+    {\n+      const char *const name;\n+      const enum processor_features feature;\n+    }\n+  const isa_names_table[] =\n+    {\n+      {\"cmov\",   F_CMOV},\n+      {\"mmx\",    F_MMX},\n+      {\"popcnt\", F_POPCNT},\n+      {\"sse\",    F_SSE},\n+      {\"sse2\",   F_SSE2},\n+      {\"sse3\",   F_SSE3},\n+      {\"ssse3\",  F_SSSE3},\n+      {\"sse4.1\", F_SSE4_1},\n+      {\"sse4.2\", F_SSE4_2},\n+      {\"avx\",    F_AVX}\n+    };\n+\n+  static tree __processor_model_type = NULL_TREE;\n+  static tree __cpu_model_var = NULL_TREE;\n+\n+  if (__processor_model_type == NULL_TREE)\n+    __processor_model_type = build_processor_model_struct ();\n+\n+  if (__cpu_model_var == NULL_TREE)\n+    __cpu_model_var = make_var_decl (__processor_model_type,\n+\t\t\t\t     \"__cpu_model\");\n+\n+  gcc_assert ((args != NULL) && (*args != NULL));\n+\n+  param_string_cst = *args;\n+  while (param_string_cst\n+\t && TREE_CODE (param_string_cst) !=  STRING_CST)\n+    {\n+      /* *args must be a expr that can contain other EXPRS leading to a\n+\t STRING_CST.   */\n+      if (!EXPR_P (param_string_cst))\n+ \t{\n+\t  error (\"Parameter to builtin must be a string constant or literal\");\n+\t  return integer_zero_node;\n+\t}\n+      param_string_cst = TREE_OPERAND (EXPR_CHECK (param_string_cst), 0);\n+    }\n+\n+  gcc_assert (param_string_cst);\n+\n+  if (fn_code == IX86_BUILTIN_CPU_IS)\n+    {\n+      tree ref;\n+      tree field;\n+      unsigned int field_val = 0;\n+      unsigned int NUM_ARCH_NAMES\n+\t= sizeof (arch_names_table) / sizeof (struct _arch_names_table);\n+\n+      for (i = 0; i < NUM_ARCH_NAMES; i++)\n+\tif (strcmp (arch_names_table[i].name,\n+\t    TREE_STRING_POINTER (param_string_cst)) == 0)\n+\t  break;\n+\n+      if (i == NUM_ARCH_NAMES)\n+\t{\n+\t  error (\"Parameter to builtin not valid: %s\",\n+\t         TREE_STRING_POINTER (param_string_cst));\n+\t  return integer_zero_node;\n+\t}\n+\n+      field = TYPE_FIELDS (__processor_model_type);\n+      field_val = arch_names_table[i].model;\n+\n+      /* CPU types are stored in the next field.  */\n+      if (field_val > M_CPU_TYPE_START\n+\t  && field_val < M_CPU_SUBTYPE_START)\n+\t{\n+\t  field = DECL_CHAIN (field);\n+\t  field_val -= M_CPU_TYPE_START;\n+\t}\n+\n+      /* CPU subtypes are stored in the next field.  */\n+      if (field_val > M_CPU_SUBTYPE_START)\n+\t{\n+\t  field = DECL_CHAIN ( DECL_CHAIN (field));\n+\t  field_val -= M_CPU_SUBTYPE_START;\n+\t}\n+\n+      /* Get the appropriate field in __cpu_model.  */\n+      ref =  build3 (COMPONENT_REF, TREE_TYPE (field), __cpu_model_var,\n+\t\t     field, NULL_TREE);\n+\n+      /* Check the value.  */\n+      return build2 (EQ_EXPR, unsigned_type_node, ref,\n+\t\t     build_int_cstu (unsigned_type_node, field_val));\n+    }\n+  else if (fn_code == IX86_BUILTIN_CPU_SUPPORTS)\n+    {\n+      tree ref;\n+      tree array_elt;\n+      tree field;\n+      unsigned int field_val = 0;\n+      unsigned int NUM_ISA_NAMES\n+\t= sizeof (isa_names_table) / sizeof (struct _isa_names_table);\n+\n+      for (i = 0; i < NUM_ISA_NAMES; i++)\n+\tif (strcmp (isa_names_table[i].name,\n+\t    TREE_STRING_POINTER (param_string_cst)) == 0)\n+\t  break;\n+\n+      if (i == NUM_ISA_NAMES)\n+\t{\n+\t  error (\"Parameter to builtin not valid: %s\",\n+\t       \t TREE_STRING_POINTER (param_string_cst));\n+\t  return integer_zero_node;\n+\t}\n+\n+      field = TYPE_FIELDS (__processor_model_type);\n+      /* Get the last field, which is __cpu_features.  */\n+      while (DECL_CHAIN (field))\n+        field = DECL_CHAIN (field);\n+\n+      /* Get the appropriate field: __cpu_model.__cpu_features  */\n+      ref =  build3 (COMPONENT_REF, TREE_TYPE (field), __cpu_model_var,\n+\t\t     field, NULL_TREE);\n+\n+      /* Access the 0th element of __cpu_features array.  */\n+      array_elt = build4 (ARRAY_REF, unsigned_type_node, ref,\n+\t\t\t  integer_zero_node, NULL_TREE, NULL_TREE);\n+\n+      field_val = (1 << isa_names_table[i].feature);\n+      /* Return __cpu_model.__cpu_features[0] & field_val  */\n+      return build2 (BIT_AND_EXPR, unsigned_type_node, array_elt,\n+\t\t     build_int_cstu (unsigned_type_node, field_val));\n+    }\n+  gcc_unreachable ();\n+}\n+\n+static tree\n+ix86_fold_builtin (tree fndecl, int n_args,\n+\t\t   tree *args, bool ignore ATTRIBUTE_UNUSED)\n+{\n+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n+    {\n+      enum ix86_builtins fn_code = (enum ix86_builtins)\n+\t\t\t\t   DECL_FUNCTION_CODE (fndecl);\n+      if (fn_code ==  IX86_BUILTIN_CPU_IS\n+\t  || fn_code == IX86_BUILTIN_CPU_SUPPORTS)\n+\t{\n+\t  gcc_assert (n_args == 1);\n+          return fold_builtin_cpu (fndecl, args);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Make builtins to detect cpu type and features supported.  NAME is\n+   the builtin name, CODE is the builtin code, and FTYPE is the function\n+   type of the builtin.  */\n+\n+static void\n+make_cpu_type_builtin (const char* name, int code,\n+\t\t       enum ix86_builtin_func_type ftype, bool is_const)\n+{\n+  tree decl;\n+  tree type;\n+\n+  type = ix86_get_builtin_func_type (ftype);\n+  decl = add_builtin_function (name, type, code, BUILT_IN_MD,\n+\t\t\t       NULL, NULL_TREE);\n+  gcc_assert (decl != NULL_TREE);\n+  ix86_builtins[(int) code] = decl;\n+  TREE_READONLY (decl) = is_const;\n+}\n+\n+/* Make builtins to get CPU type and features supported.  The created\n+   builtins are :\n+\n+   __builtin_cpu_init (), to detect cpu type and features,\n+   __builtin_cpu_is (\"<CPUNAME>\"), to check if cpu is of type <CPUNAME>,\n+   __builtin_cpu_supports (\"<FEATURE>\"), to check if cpu supports <FEATURE>\n+   */\n+\n+static void\n+ix86_init_platform_type_builtins (void)\n+{\n+  make_cpu_type_builtin (\"__builtin_cpu_init\", IX86_BUILTIN_CPU_INIT,\n+\t\t\t INT_FTYPE_VOID, false);\n+  make_cpu_type_builtin (\"__builtin_cpu_is\", IX86_BUILTIN_CPU_IS,\n+\t\t\t INT_FTYPE_PCCHAR, true);\n+  make_cpu_type_builtin (\"__builtin_cpu_supports\", IX86_BUILTIN_CPU_SUPPORTS,\n+\t\t\t INT_FTYPE_PCCHAR, true);\n+}\n+\n /* Internal method for ix86_init_builtins.  */\n \n static void\n@@ -27756,6 +28089,9 @@ ix86_init_builtins (void)\n \n   ix86_init_builtin_types ();\n \n+  /* Builtins to get CPU type and features. */\n+  ix86_init_platform_type_builtins ();\n+\n   /* TFmode support builtins.  */\n   def_builtin_const (0, \"__builtin_infq\",\n \t\t     FLOAT128_FTYPE_VOID, IX86_BUILTIN_INFQ);\n@@ -29374,6 +29710,28 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   enum machine_mode mode0, mode1, mode2, mode3, mode4;\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n \n+  /* For CPU builtins that can be folded, fold first and expand the fold.  */\n+  switch (fcode)\n+    {\n+    case IX86_BUILTIN_CPU_INIT:\n+      {\n+\t/* Make it call __cpu_indicator_init in libgcc. */\n+\ttree call_expr, fndecl, type;\n+        type = build_function_type_list (integer_type_node, NULL_TREE); \n+\tfndecl = build_fn_decl (\"__cpu_indicator_init\", type);\n+\tcall_expr = build_call_expr (fndecl, 0); \n+\treturn expand_expr (call_expr, target, mode, EXPAND_NORMAL);\n+      }\n+    case IX86_BUILTIN_CPU_IS:\n+    case IX86_BUILTIN_CPU_SUPPORTS:\n+      {\n+\ttree arg0 = CALL_EXPR_ARG (exp, 0);\n+\ttree fold_expr = fold_builtin_cpu (fndecl, &arg0);\n+\tgcc_assert (fold_expr != NULL_TREE);\n+\treturn expand_expr (fold_expr, target, mode, EXPAND_NORMAL);\n+      }\n+    }\n+\n   /* Determine whether the builtin function is available under the current ISA.\n      Originally the builtin was not created if it wasn't applicable to the\n      current ISA based on the command line switches.  With function specific\n@@ -39100,6 +39458,9 @@ ix86_autovectorize_vector_sizes (void)\n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST ix86_build_builtin_va_list\n \n+#undef TARGET_FOLD_BUILTIN\n+#define TARGET_FOLD_BUILTIN ix86_fold_builtin\n+\n #undef TARGET_ENUM_VA_LIST_P\n #define TARGET_ENUM_VA_LIST_P ix86_enum_va_list\n "}, {"sha": "7c0d2f23b6bff4f8cf0e951e37bbf0efd18076ba", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -9419,6 +9419,144 @@ Similar to @code{__builtin_huge_val}, except the return type is @code{__float128\n @findex __builtin_huge_valq\n @end table\n \n+The following built-in functions are always available and can be used to\n+check the target platform type.\n+\n+@deftypefn {Built-in Function} void __builtin_cpu_init (void)\n+This function runs the CPU detection code to check the type of CPU and the\n+features supported.  This builtin needs to be invoked along with the builtins\n+to check CPU type and features, @code{__builtin_cpu_is} and\n+@code{__builtin_cpu_supports}, only when used in a function that will be\n+executed before any constructors are called.  The CPU detection code is\n+automatically executed in a very high priority constructor.\n+\n+For example, this function has to be used in @code{ifunc} resolvers which\n+check for CPU type using the builtins, @code{__builtin_cpu_is}\n+and @code{__builtin_cpu_supports}.\n+@smallexample\n+\n+static void (*resolve_memcpy (void)) (void)\n+@{\n+  // ifunc resolvers fire before constructors, explicitly call the init\n+  // function.\n+  __builtin_cpu_init ();\n+  if (__builtin_cpu_supports (\"ssse3\"))\n+    return ssse3_memcpy; // super fast memcpy with ssse3 instructions.\n+  else\n+    return default_memcpy;\n+@}\n+\n+void *memcpy (void *, const void *, size_t)\n+     __attribute__ ((ifunc (\"resolve_memcpy\")));\n+@end smallexample\n+\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_cpu_is (const char *@var{cpuname})\n+This function returns a positive integer if the runtime cpu is of type @var{cpuname}\n+ and returns @code{0} otherwise. The following cpu names can be detected:\n+\n+@table @samp\n+@item intel\n+Intel CPU.\n+\n+@item atom\n+Intel ATOM CPU.\n+\n+@item core2\n+Intel Core2 CPU.\n+\n+@item corei7\n+Intel Corei7 CPU.\n+\n+@item nehalem\n+Intel Corei7 Nehalem CPU.\n+\n+@item westmere\n+Intel Corei7 Westmere CPU.\n+\n+@item sandybridge\n+Intel Corei7 Sandybridge CPU.\n+\n+@item amd\n+AMD CPU.\n+\n+@item amdfam10h\n+AMD family 10h CPU.\n+\n+@item barcelona\n+AMD family 10h Barcelona CPU.\n+\n+@item shanghai\n+AMD family 10h Shanghai CPU.\n+\n+@item istanbul\n+AMD family 10h Istanbul CPU.\n+\n+@item amdfam15h\n+AMD family 15h CPU.\n+\n+@item bdver1\n+AMD family 15h Bulldozer version 1.\n+\n+@item bdver2\n+AMD family 15h Bulldozer version 2.\n+@end table\n+\n+Here is an example:\n+@smallexample\n+if (__builtin_cpu_is (\"corei7\"))\n+  @{\n+     do_corei7 (); //Corei7 specific implementation.\n+  @}\n+else\n+  @{\n+     do_generic (); //Generic implementation.\n+  @}\n+@end smallexample\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_cpu_supports (const char *@var{feature})\n+This function returns a postive integer if the runtime cpu supports @var{feature}\n+ and returns @code{0} otherwise. The following features can be detected:\n+\n+@table @samp\n+@item cmov\n+CMOV instruction.\n+@item mmx\n+MMX instructions.\n+@item popcnt\n+POPCNT instruction.\n+@item sse\n+SSE instructions.\n+@item sse2\n+SSE2 instructions.\n+@item sse3\n+SSE3 instructions.\n+@item ssse3\n+SSSE3 instructions.\n+@item sse4.1\n+SSE4.1 instructions.\n+@item sse4.2\n+SSE4.2 instructions.\n+@item avx\n+AVX instructions.\n+@end table\n+\n+Here is an example:\n+@smallexample\n+if (__builtin_cpu_supports (\"popcnt\"))\n+  @{\n+     asm(\"popcnt %1,%0\" : \"=r\"(count) : \"rm\"(n) : \"cc\");\n+  @}\n+else\n+  @{\n+     count = generic_countbits (n); //generic implementation.\n+  @}\n+@end smallexample\n+@end deftypefn\n+\n+\n The following built-in functions are made available by @option{-mmmx}.\n All of them generate the machine instruction that is part of the name.\n "}, {"sha": "0258cd246d22caff9960baf88d575f4fb5d31033", "filename": "gcc/testsuite/gcc.target/i386/builtin_target.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin_target.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin_target.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fbuiltin_target.c?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -0,0 +1,70 @@\n+/* This test checks if the __builtin_cpu_is and __builtin_cpu_supports calls\n+   are recognized. */\n+\n+/* { dg-do run } */\n+\n+#include <assert.h>\n+\n+int\n+fn1 ()\n+{\n+  /* Check CPU Features.  */\n+  assert (__builtin_cpu_supports (\"cmov\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"mmx\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"popcnt\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"sse\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"sse2\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"sse3\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"ssse3\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"sse4.1\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"sse4.2\") >= 0);\n+\n+  assert (__builtin_cpu_supports (\"avx\") >= 0);\n+\n+  /* Check CPU type.  */\n+  assert (__builtin_cpu_is (\"amd\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"intel\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"atom\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"core2\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"corei7\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"nehalem\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"westmere\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"sandybridge\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"amdfam10h\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"barcelona\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"shanghai\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"istanbul\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"amdfam15h\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"bdver1\") >= 0);\n+\n+  assert (__builtin_cpu_is (\"bdver2\") >= 0);\n+\n+  return 0;\n+}\n+\n+int main ()\n+{\n+  __builtin_cpu_init ();\n+  return fn1 ();\n+}"}, {"sha": "8040eaf1fcb3d56ec36271b1212abb0d20bac250", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -1,3 +1,10 @@\n+2012-04-24  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* libgcc/config/i386/i386-cpuinfo.c: New file.\n+\t* libgcc/config/i386/t-cpuinfo: New file.\n+\t* libgcc/config.host: Include t-cpuinfo.\n+\t* libgcc/config/i386/libgcc-glibc.ver: Version symbol __cpu_model.\n+\n 2012-04-24  Chao-ying Fu  <fu@mips.com>\n \n \t* unwind-dw2-fde-dip.c: Define USE_PT_GNU_EH_FRAME for BIONIC."}, {"sha": "c652dbad31168d25240f613ba81f3e83d096f470", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -1130,7 +1130,7 @@ i[34567]86-*-linux* | x86_64-*-linux* | \\\n   i[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu | \\\n   i[34567]86-*-knetbsd*-gnu | \\\n   i[34567]86-*-gnu*)\n-\ttmake_file=\"${tmake_file} t-tls i386/t-linux\"\n+\ttmake_file=\"${tmake_file} t-tls i386/t-linux i386/t-cpuinfo\"\n \tif test \"$libgcc_cv_cfi\" = \"yes\"; then\n \t\ttmake_file=\"${tmake_file} t-stack i386/t-stack-i386\"\n \tfi"}, {"sha": "0735d2cd159ce66e780cd6b1a8522620733c2859", "filename": "libgcc/config/i386/i386-cpuinfo.c", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2Fconfig%2Fi386%2Fi386-cpuinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2Fconfig%2Fi386%2Fi386-cpuinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fi386-cpuinfo.c?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -0,0 +1,316 @@\n+/* Get CPU type and Features for x86 processors.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Sriraman Tallam (tmsriram@google.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>. */\n+\n+#include \"cpuid.h\"\n+#include \"tsystem.h\"\n+\n+int __cpu_indicator_init (void) __attribute__ ((constructor (101)));\n+\n+enum vendor_signatures\n+{\n+  SIG_INTEL =\t0x756e6547 /* Genu */,\n+  SIG_AMD =\t0x68747541 /* Auth */\n+};\n+\n+/* Processor Vendor and Models. */\n+\n+enum processor_vendor\n+{\n+  VENDOR_INTEL = 1,\n+  VENDOR_AMD,\n+  VENDOR_OTHER,\n+  VENDOR_MAX\n+};\n+\n+enum processor_types\n+{\n+  INTEL_ATOM = 1,\n+  INTEL_CORE2,\n+  INTEL_COREI7,\n+  AMDFAM10H,\n+  AMDFAM15H,\n+  CPU_TYPE_MAX\n+};\n+\n+enum processor_subtypes\n+{\n+  INTEL_COREI7_NEHALEM = 1,\n+  INTEL_COREI7_WESTMERE,\n+  INTEL_COREI7_SANDYBRIDGE,\n+  AMDFAM10H_BARCELONA,\n+  AMDFAM10H_SHANGHAI,\n+  AMDFAM10H_ISTANBUL,\n+  AMDFAM15H_BDVER1,\n+  AMDFAM15H_BDVER2,\n+  CPU_SUBTYPE_MAX\n+};\n+\n+/* ISA Features supported. */\n+\n+enum processor_features\n+{\n+  FEATURE_CMOV = 0,\n+  FEATURE_MMX,\n+  FEATURE_POPCNT,\n+  FEATURE_SSE,\n+  FEATURE_SSE2,\n+  FEATURE_SSE3,\n+  FEATURE_SSSE3,\n+  FEATURE_SSE4_1,\n+  FEATURE_SSE4_2,\n+  FEATURE_AVX\n+};\n+\n+struct __processor_model\n+{\n+  unsigned int __cpu_vendor;\n+  unsigned int __cpu_type;\n+  unsigned int __cpu_subtype;\n+  unsigned int __cpu_features[1];\n+} __cpu_model;\n+\n+\n+/* Get the specific type of AMD CPU.  */\n+\n+static void\n+get_amd_cpu (unsigned int family, unsigned int model)\n+{\n+  switch (family)\n+    {\n+    /* AMD Family 10h.  */\n+    case 0x10:\n+      switch (model)\n+\t{\n+\tcase 0x2:\n+\t  /* Barcelona.  */\n+\t  __cpu_model.__cpu_type = AMDFAM10H;\n+\t  __cpu_model.__cpu_subtype = AMDFAM10H_BARCELONA;\n+\t  break;\n+\tcase 0x4:\n+\t  /* Shanghai.  */\n+\t  __cpu_model.__cpu_type = AMDFAM10H;\n+\t  __cpu_model.__cpu_subtype = AMDFAM10H_SHANGHAI;\n+\t  break;\n+\tcase 0x8:\n+\t  /* Istanbul.  */\n+\t  __cpu_model.__cpu_type = AMDFAM10H;\n+\t  __cpu_model.__cpu_subtype = AMDFAM10H_ISTANBUL;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+    /* AMD Family 15h.  */\n+    case 0x15:\n+      __cpu_model.__cpu_type = AMDFAM15H;\n+      /* Bulldozer version 1.  */\n+      if ( model <= 0xf)\n+\t__cpu_model.__cpu_subtype = AMDFAM15H_BDVER1;\n+      /* Bulldozer version 2.  */\n+      if (model >= 0x10 && model <= 0x1f)\n+\t__cpu_model.__cpu_subtype = AMDFAM15H_BDVER2;\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n+/* Get the specific type of Intel CPU.  */\n+\n+static void\n+get_intel_cpu (unsigned int family, unsigned int model, unsigned int brand_id)\n+{\n+  /* Parse family and model only if brand ID is 0. */\n+  if (brand_id == 0)\n+    {\n+      switch (family)\n+\t{\n+\tcase 0x5:\n+\t  /* Pentium.  */\n+\t  break;\n+\tcase 0x6:\n+\t  switch (model)\n+\t    {\n+\t    case 0x1c:\n+\t    case 0x26:\n+\t      /* Atom.  */\n+\t      __cpu_model.__cpu_type = INTEL_ATOM;\n+\t      break;\n+\t    case 0x1a:\n+\t    case 0x1e:\n+\t    case 0x1f:\n+\t    case 0x2e:\n+\t      /* Nehalem.  */\n+\t      __cpu_model.__cpu_type = INTEL_COREI7;\n+\t      __cpu_model.__cpu_subtype = INTEL_COREI7_NEHALEM;\n+\t      break;\n+\t    case 0x25:\n+\t    case 0x2c:\n+\t    case 0x2f:\n+\t      /* Westmere.  */\n+\t      __cpu_model.__cpu_type = INTEL_COREI7;\n+\t      __cpu_model.__cpu_subtype = INTEL_COREI7_WESTMERE;\n+\t      break;\n+\t    case 0x2a:\n+\t      /* Sandy Bridge.  */\n+\t      __cpu_model.__cpu_type = INTEL_COREI7;\n+\t      __cpu_model.__cpu_subtype = INTEL_COREI7_SANDYBRIDGE;\n+\t      break;\n+\t    case 0x17:\n+\t    case 0x1d:\n+\t      /* Penryn.  */\n+\t    case 0x0f:\n+\t      /* Merom.  */\n+\t      __cpu_model.__cpu_type = INTEL_CORE2;\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  /* We have no idea.  */\n+\t  break;\n+\t}\n+    }\n+}\t             \t\n+\n+static void\n+get_available_features (unsigned int ecx, unsigned int edx)\n+{\n+  unsigned int features = 0;\n+\n+  if (edx & bit_CMOV)\n+    features |= (1 << FEATURE_CMOV);\n+  if (edx & bit_MMX)\n+    features |= (1 << FEATURE_MMX);\n+  if (edx & bit_SSE)\n+    features |= (1 << FEATURE_SSE);\n+  if (edx & bit_SSE2)\n+    features |= (1 << FEATURE_SSE2);\n+  if (ecx & bit_POPCNT)\n+    features |= (1 << FEATURE_POPCNT);\n+  if (ecx & bit_SSE3)\n+    features |= (1 << FEATURE_SSE3);\n+  if (ecx & bit_SSSE3)\n+    features |= (1 << FEATURE_SSSE3);\n+  if (ecx & bit_SSE4_1)\n+    features |= (1 << FEATURE_SSE4_1);\n+  if (ecx & bit_SSE4_2)\n+    features |= (1 << FEATURE_SSE4_2);\n+  if (ecx & bit_AVX)\n+    features |= (1 << FEATURE_AVX);\n+\n+  __cpu_model.__cpu_features[0] = features;\n+}\n+\n+/* A noinline function calling __get_cpuid. Having many calls to\n+   cpuid in one function in 32-bit mode causes GCC to complain:\n+   \"can't find a register in class CLOBBERED_REGS\".  This is\n+   related to PR rtl-optimization 44174. */\n+\n+static int __attribute__ ((noinline))\n+__get_cpuid_output (unsigned int __level,\n+\t\t    unsigned int *__eax, unsigned int *__ebx,\n+\t\t    unsigned int *__ecx, unsigned int *__edx)\n+{\n+  return __get_cpuid (__level, __eax, __ebx, __ecx, __edx);\n+}\n+\n+\n+/* A constructor function that is sets __cpu_model and __cpu_features with\n+   the right values.  This needs to run only once.  This constructor is\n+   given the highest priority and it should run before constructors without\n+   the priority set.  However, it still runs after ifunc initializers and\n+   needs to be called explicitly there.  */\n+\n+int __attribute__ ((constructor (101)))\n+__cpu_indicator_init (void)\n+{\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  int max_level = 5;\n+  unsigned int vendor;\n+  unsigned int model, family, brand_id;\n+  unsigned int extended_model, extended_family;\n+\n+  /* This function needs to run just once.  */\n+  if (__cpu_model.__cpu_vendor)\n+    return 0;\n+\n+  /* Assume cpuid insn present. Run in level 0 to get vendor id. */\n+  if (!__get_cpuid_output (0, &eax, &ebx, &ecx, &edx))\n+    return -1;\n+\n+  vendor = ebx;\n+  max_level = eax;\n+\n+  if (max_level < 1)\n+    return -1;\n+\n+  if (!__get_cpuid_output (1, &eax, &ebx, &ecx, &edx))\n+    return -1;\n+\n+  model = (eax >> 4) & 0x0f;\n+  family = (eax >> 8) & 0x0f;\n+  brand_id = ebx & 0xff;\n+  extended_model = (eax >> 12) & 0xf0;\n+  extended_family = (eax >> 20) & 0xff;\n+\n+  if (vendor == SIG_INTEL)\n+    {\n+      /* Adjust model and family for Intel CPUS. */\n+      if (family == 0x0f)\n+\t{\n+\t  family += extended_family;\n+\t  model += extended_model;\n+\t}\n+      else if (family == 0x06)\n+\tmodel += extended_model;\n+\n+      /* Get CPU type.  */\n+      get_intel_cpu (family, model, brand_id);\n+      /* Find available features. */\n+      get_available_features (ecx, edx);\n+      __cpu_model.__cpu_vendor = VENDOR_INTEL;\n+    }\n+  else if (vendor == SIG_AMD)\n+    {\n+      /* Adjust model and family for AMD CPUS. */\n+      if (family == 0x0f)\n+\t{\n+\t  family += extended_family;\n+\t  model += (extended_model << 4);\n+\t}\n+\n+      /* Get CPU type.  */\n+      get_amd_cpu (family, model);\n+      /* Find available features. */\n+      get_available_features (ecx, edx);\n+      __cpu_model.__cpu_vendor = VENDOR_AMD;\n+    }\n+  else\n+    __cpu_model.__cpu_vendor = VENDOR_OTHER;\n+\n+  gcc_assert (__cpu_model.__cpu_vendor < VENDOR_MAX);\n+  gcc_assert (__cpu_model.__cpu_type < CPU_TYPE_MAX);\n+  gcc_assert (__cpu_model.__cpu_subtype < CPU_SUBTYPE_MAX);\n+\n+  return 0;\n+}"}, {"sha": "b297362920da32c4b8ae1a896cc06fd9bb490897", "filename": "libgcc/config/i386/libgcc-glibc.ver", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2Fconfig%2Fi386%2Flibgcc-glibc.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2Fconfig%2Fi386%2Flibgcc-glibc.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Flibgcc-glibc.ver?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -147,6 +147,10 @@ GCC_4.3.0 {\n   __trunctfxf2\n   __unordtf2\n }\n+\n+GCC_4.8.0 {\n+  __cpu_model\n+}\n %else\n GCC_4.4.0 {\n   __addtf3\n@@ -183,4 +187,8 @@ GCC_4.4.0 {\n GCC_4.5.0 {\n   __extendxftf2\n }\n+\n+GCC_4.8.0 {\n+  __cpu_model\n+}\n %endif"}, {"sha": "dd271f9db6a532330e23add1852190a93d8c42dd", "filename": "libgcc/config/i386/t-cpuinfo", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2Fconfig%2Fi386%2Ft-cpuinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792317cc777123b9cac8fc9a70fc85b01a3d7a0f/libgcc%2Fconfig%2Fi386%2Ft-cpuinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-cpuinfo?ref=792317cc777123b9cac8fc9a70fc85b01a3d7a0f", "patch": "@@ -0,0 +1 @@\n+LIB2ADD += $(srcdir)/config/i386/i386-cpuinfo.c"}]}