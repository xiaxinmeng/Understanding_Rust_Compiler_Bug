{"sha": "065afdfa8e2e699b1f5ac17c43ac4664940f6659", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY1YWZkZmE4ZTJlNjk5YjFmNWFjMTdjNDNhYzQ2NjQ5NDBmNjY1OQ==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2004-05-04T16:27:20Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-05-04T16:27:20Z"}, "message": "FormatBuffer.java, [...]: New classes to implement attributed iterators in java.text.\n\n2004-05-04  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* gnu/java/text/FormatBuffer.java,\n\tgnu/java/text/AttributedFormatBuffer.java,\n\tgnu/java/text/StringFormatBuffer.java: New classes to implement\n\tattributed iterators in java.text.\n\t* gnu/java/text/FormatCharacterIterator.java: Moved\n\tfrom java/text as it is an internal class.\n\t* java/text/FormatCharacterIterator.java: Removed.\n\t* java/text/Format.java:\n\tImport gnu.java.text.FormatCharacterIterator.\n\t* Makefile.am (java_source_files): Added new files.\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r81479", "tree": {"sha": "3de48b6ade6599d395964d913b3c7fbfc2ad782c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3de48b6ade6599d395964d913b3c7fbfc2ad782c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/065afdfa8e2e699b1f5ac17c43ac4664940f6659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/065afdfa8e2e699b1f5ac17c43ac4664940f6659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/065afdfa8e2e699b1f5ac17c43ac4664940f6659", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/065afdfa8e2e699b1f5ac17c43ac4664940f6659/comments", "author": null, "committer": null, "parents": [{"sha": "c6c8779bfcc91e981006ab21c94acde922b5d799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c8779bfcc91e981006ab21c94acde922b5d799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c8779bfcc91e981006ab21c94acde922b5d799"}], "stats": {"total": 629, "additions": 612, "deletions": 17}, "files": [{"sha": "2a7bfa3bff53cf7e94444992bae5e25b383ed2b8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=065afdfa8e2e699b1f5ac17c43ac4664940f6659", "patch": "@@ -1,3 +1,18 @@\n+2004-05-04  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* gnu/java/text/FormatBuffer.java,\n+\tgnu/java/text/AttributedFormatBuffer.java,\n+\tgnu/java/text/StringFormatBuffer.java: New classes to implement\n+\tattributed iterators in java.text.\n+\t* gnu/java/text/FormatCharacterIterator.java: Moved \n+\tfrom java/text as it is an internal class.\n+\t* java/text/FormatCharacterIterator.java: Removed.\n+\t* java/text/Format.java:\n+\tImport gnu.java.text.FormatCharacterIterator.\n+\t* Makefile.am (java_source_files): Added new files.\n+\t* Makefile.in: Regenerated.\n+\t\n+\n 2004-05-04  Mark Wielaard  <mark@klomp.org>\n \n \t* gnu/java/nio/channels/FileChannelImpl.java (finalize): New method."}, {"sha": "0acbb884c8a1f33f98ce43a4bafb089202c96020", "filename": "libjava/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=065afdfa8e2e699b1f5ac17c43ac4664940f6659", "patch": "@@ -2469,10 +2469,14 @@ gnu/java/security/x509/X500DistinguishedName.java \\\n gnu/java/security/x509/X509Certificate.java \\\n gnu/java/security/x509/X509CRLEntry.java \\\n gnu/java/security/x509/X509CRL.java \\\n+gnu/java/text/AttributedFormatBuffer.java \\\n gnu/java/text/BaseBreakIterator.java \\\n gnu/java/text/CharacterBreakIterator.java \\\n+gnu/java/text/FormatBuffer.java \\\n+gnu/java/text/FormatCharacterIterator.java \\\n gnu/java/text/LineBreakIterator.java \\\n gnu/java/text/SentenceBreakIterator.java \\\n+gnu/java/text/StringFormatBuffer.java \\\n gnu/java/text/WordBreakIterator.java \\\n gnu/java/util/DoubleEnumeration.java \\\n gnu/java/util/EmptyEnumeration.java \\\n@@ -2812,7 +2816,6 @@ java/text/DecimalFormat.java \\\n java/text/DecimalFormatSymbols.java \\\n java/text/FieldPosition.java \\\n java/text/Format.java \\\n-java/text/FormatCharacterIterator.java \\\n java/text/MessageFormat.java \\\n java/text/NumberFormat.java \\\n java/text/ParseException.java \\"}, {"sha": "1605cbf09afcbbf354d80ba2e41d919d680219b7", "filename": "libjava/Makefile.in", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=065afdfa8e2e699b1f5ac17c43ac4664940f6659", "patch": "@@ -2141,10 +2141,14 @@ gnu/java/security/x509/X500DistinguishedName.java \\\n gnu/java/security/x509/X509Certificate.java \\\n gnu/java/security/x509/X509CRLEntry.java \\\n gnu/java/security/x509/X509CRL.java \\\n+gnu/java/text/AttributedFormatBuffer.java \\\n gnu/java/text/BaseBreakIterator.java \\\n gnu/java/text/CharacterBreakIterator.java \\\n+gnu/java/text/FormatBuffer.java \\\n+gnu/java/text/FormatCharacterIterator.java \\\n gnu/java/text/LineBreakIterator.java \\\n gnu/java/text/SentenceBreakIterator.java \\\n+gnu/java/text/StringFormatBuffer.java \\\n gnu/java/text/WordBreakIterator.java \\\n gnu/java/util/DoubleEnumeration.java \\\n gnu/java/util/EmptyEnumeration.java \\\n@@ -2484,7 +2488,6 @@ java/text/DecimalFormat.java \\\n java/text/DecimalFormatSymbols.java \\\n java/text/FieldPosition.java \\\n java/text/Format.java \\\n-java/text/FormatCharacterIterator.java \\\n java/text/MessageFormat.java \\\n java/text/NumberFormat.java \\\n java/text/ParseException.java \\\n@@ -3410,10 +3413,14 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/security/x509/X509CRL.P \\\n .deps/gnu/java/security/x509/X509CRLEntry.P \\\n .deps/gnu/java/security/x509/X509Certificate.P \\\n+.deps/gnu/java/text/AttributedFormatBuffer.P \\\n .deps/gnu/java/text/BaseBreakIterator.P \\\n .deps/gnu/java/text/CharacterBreakIterator.P \\\n+.deps/gnu/java/text/FormatBuffer.P \\\n+.deps/gnu/java/text/FormatCharacterIterator.P \\\n .deps/gnu/java/text/LineBreakIterator.P \\\n .deps/gnu/java/text/SentenceBreakIterator.P \\\n+.deps/gnu/java/text/StringFormatBuffer.P \\\n .deps/gnu/java/text/WordBreakIterator.P \\\n .deps/gnu/java/util/DoubleEnumeration.P \\\n .deps/gnu/java/util/EmptyEnumeration.P \\\n@@ -4148,7 +4155,6 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/text/DateFormat.P .deps/java/text/DateFormatSymbols.P \\\n .deps/java/text/DecimalFormat.P .deps/java/text/DecimalFormatSymbols.P \\\n .deps/java/text/FieldPosition.P .deps/java/text/Format.P \\\n-.deps/java/text/FormatCharacterIterator.P \\\n .deps/java/text/MessageFormat.P .deps/java/text/NumberFormat.P \\\n .deps/java/text/ParseException.P .deps/java/text/ParsePosition.P \\\n .deps/java/text/RuleBasedCollator.P .deps/java/text/SimpleDateFormat.P \\"}, {"sha": "a02f8a1bc97872d80bd3d3ac2987f8278196a124", "filename": "libjava/gnu/java/text/AttributedFormatBuffer.java", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fgnu%2Fjava%2Ftext%2FAttributedFormatBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fgnu%2Fjava%2Ftext%2FAttributedFormatBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FAttributedFormatBuffer.java?ref=065afdfa8e2e699b1f5ac17c43ac4664940f6659", "patch": "@@ -0,0 +1,247 @@\n+/* AttributedFormatBuffer.java -- Implements an attributed FormatBuffer.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+package gnu.java.text;\n+\n+import java.text.AttributedCharacterIterator;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+/**\n+ * This class is an implementation of a FormatBuffer with attributes.\n+ * \n+ * @author Guilhem Lavaux <guilhem@kaffe.org>\n+ * @date April 10, 2004\n+ */\n+public class AttributedFormatBuffer implements FormatBuffer\n+{\n+  private StringBuffer buffer;\n+  private ArrayList ranges;\n+  private ArrayList attributes;\n+  private int[] a_ranges;\n+  private HashMap[] a_attributes; \n+  private int startingRange;\n+  AttributedCharacterIterator.Attribute defaultAttr;\n+\n+  /**\n+   * This constructor accepts a StringBuffer. If the buffer contains\n+   * already some characters they will not be attributed. \n+   */\n+  public AttributedFormatBuffer(StringBuffer buffer)\n+  {\n+    this.buffer = buffer;\n+    this.ranges = new ArrayList();\n+    this.attributes = new ArrayList();\n+    this.defaultAttr = null;\n+    if (buffer.length() != 0)\n+      {\n+\tthis.startingRange = buffer.length();\n+\taddAttribute(buffer.length(), null);\n+      }\n+    else\n+      this.startingRange = -1;\n+  }\n+\n+  public AttributedFormatBuffer(int prebuffer)\n+  {\n+    this(new StringBuffer(prebuffer));\n+  }\n+\n+  public AttributedFormatBuffer()\n+  {\n+    this(10);\n+  }\n+\n+  /**\n+   * This method is a helper function for formatters. Given a set of ranges\n+   * and attributes it adds exactly one attribute for the range of characters\n+   * comprised between the last entry in 'ranges' and the specified new range.\n+   *\n+   * @param new_range A new range to insert in the list.\n+   * @param new_attribute A new attribute to insert in the list.\n+   */  \n+  private final void addAttribute(int new_range, AttributedCharacterIterator.Attribute attr)\n+  {\n+    HashMap map;\n+\n+    if (attr != null)\n+      {\n+\tmap = new HashMap();\n+\tmap.put(attr, attr);\n+\tattributes.add(map);\n+      }\n+    else\n+      attributes.add(null);\n+\n+    ranges.add(new Integer(new_range));\n+  }\n+\n+  public void append(String s)\n+  {\n+    if (startingRange < 0)\n+      startingRange = 0;\n+    buffer.append(s);\n+  }\n+  \n+  public void append(String s, AttributedCharacterIterator.Attribute attr)\n+  {\n+    setDefaultAttribute(attr);\n+    startingRange = buffer.length();\n+    append(s);\n+    setDefaultAttribute(null);\n+  }\n+\n+  public void append(String s, int[] ranges, HashMap[] attrs)\n+  {\n+    int curPos = buffer.length();\n+\n+    setDefaultAttribute(null);\n+    if (ranges != null)\n+      {\n+\tfor (int i = 0; i < ranges.length; i++)\n+\t  {\t    \n+\t    this.ranges.add(new Integer(ranges[i] + curPos));\n+\t    this.attributes.add(attrs[i]);\n+\t  }\n+      }\n+    startingRange = buffer.length();\n+    buffer.append(s);\n+  }\n+\n+  public void append(char c)\n+  {\n+    if (startingRange < 0)\n+      startingRange = buffer.length();\n+    buffer.append(c);\n+  }\n+\n+  public void append(char c, AttributedCharacterIterator.Attribute attr)\n+  {\n+    setDefaultAttribute(attr);\n+    buffer.append(c);\n+    setDefaultAttribute(null);\n+  }\n+\n+  public void setDefaultAttribute(AttributedCharacterIterator.Attribute attr)\n+  {\n+    if (attr == defaultAttr)\n+      return;\n+\n+    int currentPos = buffer.length();\n+\n+    if (startingRange != currentPos && startingRange >= 0)\n+      {\n+\taddAttribute(currentPos, defaultAttr);\n+      }\n+    defaultAttr = attr;\n+    startingRange = currentPos;\n+  }\n+\n+  public AttributedCharacterIterator.Attribute getDefaultAttribute()\n+  {\n+    return defaultAttr;\n+  }\n+\n+  public void cutTail(int length)\n+  {\n+    buffer.setLength(buffer.length()-length);\n+  }\n+\n+  public int length()\n+  {\n+    return buffer.length();\n+  }\n+\n+  public void clear()\n+  {\n+    buffer.setLength(0);\n+    ranges.clear();\n+    attributes.clear();\n+    defaultAttr = null;\n+    startingRange = -1;\n+  }\n+\n+  /**\n+   * This method synchronizes the state of the attribute array.\n+   * After calling it you may call {@link #getDefaultAttribute()}.\n+   */\n+  public void sync()\n+  {\n+    if (startingRange < 0 || startingRange == buffer.length())\n+      return;\n+\n+    addAttribute(buffer.length(), defaultAttr);\n+\n+    a_ranges = new int[ranges.size()];\n+    for (int i = 0; i < a_ranges.length; i++)\n+      a_ranges[i] = ((Integer)(ranges.get (i))).intValue();\n+    \n+    a_attributes = new HashMap[attributes.size()];\n+    System.arraycopy(attributes.toArray(), 0, a_attributes, 0, a_attributes.length);\n+  }\n+\n+  /**\n+   * This method returns the internal StringBuffer describing\n+   * the attributed string.\n+   *\n+   * @return An instance of StringBuffer which contains the string.\n+   */\n+  public StringBuffer getBuffer()\n+  {\n+    return buffer;\n+  }\n+\n+  /**\n+   * This method returns the ranges for the attributes.\n+   *\n+   * @return An array of int describing the ranges.\n+   */\n+  public int[] getRanges()\n+  {\n+    return a_ranges;\n+  }\n+\n+  /**\n+   * This method returns the array containing the map on the \n+   * attributes.\n+   *\n+   * @return An array of {@link java.util.Map} containing the attributes.\n+   */\n+  public HashMap[] getAttributes()\n+  {\n+    return a_attributes;\n+  }\n+}"}, {"sha": "addfcbe5c1cda9ee918ac13e1999e34a14d5fb92", "filename": "libjava/gnu/java/text/FormatBuffer.java", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fgnu%2Fjava%2Ftext%2FFormatBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fgnu%2Fjava%2Ftext%2FFormatBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FFormatBuffer.java?ref=065afdfa8e2e699b1f5ac17c43ac4664940f6659", "patch": "@@ -0,0 +1,136 @@\n+/* FormatBuffer.java -- General interface to build attributed strings.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+package gnu.java.text;\n+\n+import java.text.AttributedCharacterIterator;\n+import java.util.HashMap;\n+\n+/**\n+ * This interface describes a modifiable buffer which contains attributed\n+ * characters. The implementation may or may not implements attributes. It\n+ * aims to greatly simplify and clarify the implementation of java.text \n+ * formatters. The buffer may be appended or have its tail cut. It may also\n+ * be completely cleant up.\n+ *\n+ * @author Guilhem Lavaux <guilhem@kaffe.org>\n+ * @date April 10, 2004\n+ */\n+public interface FormatBuffer \n+{\n+  /**\n+   * This method appends a simple string to the buffer. This part of\n+   * the buffer will be attributed using the default attribute.\n+   *\n+   * @param s The string to append to the buffer.\n+   */\n+  public void append(String s);\n+\n+  /**\n+   * This method appends a simple string to the buffer. This part of\n+   * the buffer will have the specified attribute (and only this one).\n+   * The default attribute may be changed after calling this method.\n+   *\n+   * @param s The string to append to the buffer.\n+   * @param attr Attribute to use for the string in the buffer.\n+   */\n+  public void append(String s, AttributedCharacterIterator.Attribute attr);\n+\n+  /**\n+   * This method appends a simple string to the buffer. This part of\n+   * the buffer will be attributed using the specified ranges and attributes.\n+   * To have an example on how to specify ranges see {@link gnu.java.text.FormatCharacterIterator}. \n+   * \n+   * @param s The string to append to the buffer.\n+   * @param ranges The ranges describing how the attributes should be applied\n+   * to the string.\n+   * @param attrs The attributes of the string in the buffer.\n+   */\n+  public void append(String s, int[] ranges, HashMap[] attrs);\n+\n+  /**\n+   * This method appends a simple char to the buffer. This part of\n+   * the buffer will be attributed using the default attribute.\n+   *\n+   * @param c The character to append to the buffer.\n+   */\n+  public void append(char c);\n+\n+  /**\n+   * This method appends a simple character to the buffer. This part of\n+   * the buffer will have the specified attribute (and only this one).\n+   * The default attribute may be changed after calling this method.\n+   *\n+   * @param c The character to append to the buffer.\n+   * @param attr Attribute to use for the character in the buffer.\n+   */\n+  public void append(char c, AttributedCharacterIterator.Attribute attr);\n+\n+  /**\n+   * This method changes the current default attribute for the next string\n+   * or character which will be appended to the buffer.\n+   *\n+   * @param attr The attribute which will be used by default.\n+   */\n+  public void setDefaultAttribute(AttributedCharacterIterator.Attribute attr);\n+\n+  /**\n+   * This method returns the current default attribute for the buffer.\n+   *\n+   * @return The default attribute for the buffer.\n+   */\n+  public AttributedCharacterIterator.Attribute getDefaultAttribute();\n+\n+  /**\n+   * This method cuts the last characters of the buffer. The number of\n+   * characters to cut is given by \"length\".\n+   *\n+   * @param length Number of characters to cut at the end of the buffer.\n+   */\n+  public void cutTail(int length);\n+  \n+  /**\n+   * This method resets completely the buffer.\n+   */\n+  public void clear();\n+\n+  /**\n+   * This method returns the number of character in the buffer.\n+   *\n+   * @return The number of character in the buffer.\n+   */\n+  public int length();\n+}"}, {"sha": "116198bdc13b7c7a9fcea64cbb03345479575982", "filename": "libjava/gnu/java/text/FormatCharacterIterator.java", "status": "renamed", "additions": 79, "deletions": 14, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fgnu%2Fjava%2Ftext%2FFormatCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fgnu%2Fjava%2Ftext%2FFormatCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FFormatCharacterIterator.java?ref=065afdfa8e2e699b1f5ac17c43ac4664940f6659", "patch": "@@ -35,15 +35,18 @@\n this exception to your version of the library, but you are not\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n-package java.text;\n+package gnu.java.text;\n \n-import java.util.Set;\n+import gnu.classpath.Configuration;\n+\n+import java.text.AttributedCharacterIterator;\n+import java.util.HashMap;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.Map;\n-import java.util.HashMap;\n+import java.util.Set;\n import java.util.Vector;\n \n-\n /**\n  * This class should not be put public and it is only intended to the\n  * classes of the java.text package. Its aim is to build a segmented\n@@ -55,7 +58,7 @@\n  * @author Guilhem Lavaux <guilhem@kaffe.org>\n  * @date November 22, 2003\n  */\n-class FormatCharacterIterator implements AttributedCharacterIterator\n+public class FormatCharacterIterator implements AttributedCharacterIterator\n {\n   private String formattedString;\n   private int charIndex;\n@@ -68,7 +71,7 @@ class FormatCharacterIterator implements AttributedCharacterIterator\n    * are empty and so is the string. However you may append strings\n    * and attributes to this iterator.\n    */\n-  FormatCharacterIterator()\n+  public FormatCharacterIterator()\n   {\n     formattedString = \"\";\n     ranges = new int[0];\n@@ -90,7 +93,7 @@ class FormatCharacterIterator implements AttributedCharacterIterator\n    * <code>\"he\"</code> will have the attributes <code>attributes[0]</code>,\n    * <code>\"llo\"</code> the <code>attributes[1]</code>.\n    */\n-  FormatCharacterIterator (String s, int[] ranges, HashMap[] attributes)\n+  public FormatCharacterIterator (String s, int[] ranges, HashMap[] attributes)\n   {\n     formattedString = s;\n     this.ranges = ranges;\n@@ -325,12 +328,14 @@ public char setIndex (int position)\n    *\n    * @param attributes the new array attributes to apply to the string.\n    */\n-  protected void mergeAttributes (HashMap[] attributes, int[] ranges)\n+  public void mergeAttributes (HashMap[] attributes, int[] ranges)\n   {\n     Vector new_ranges = new Vector();\n     Vector new_attributes = new Vector();\n     int i = 0, j = 0;\n \n+    debug(\"merging \" + attributes.length + \" attrs\");\n+    \n     while (i < this.ranges.length && j < ranges.length)\n       {\n \tif (this.attributes[i] != null)\n@@ -388,6 +393,7 @@ else if (this.ranges[i] < ranges[j])\n \tthis.ranges[i] = ((Integer)new_ranges.elementAt (i)).intValue();\n       }\n     \n+    dumpTable();\n   }\n \n   /**\n@@ -397,15 +403,15 @@ else if (this.ranges[i] < ranges[j])\n    * @param iterator the iterator which contains the attributed string to\n    * append to this iterator.\n    */\n-  protected void append (AttributedCharacterIterator iterator)\n+  public void append (AttributedCharacterIterator iterator)\n   {\n     char c = iterator.first();\n     Vector more_ranges = new Vector();\n     Vector more_attributes = new Vector();\n \n     do\n       {\n-\tformattedString = formattedString + String.valueOf(c);\n+\tformattedString = formattedString + String.valueOf (c);\n \t// TODO: Reduce the size of the output array.\n \tmore_attributes.add (iterator.getAttributes());\n \tmore_ranges.add (new Integer (formattedString.length()));\n@@ -424,8 +430,8 @@ protected void append (AttributedCharacterIterator iterator)\n \n     System.arraycopy (ranges, 0, new_ranges, 0, ranges.length);\n     Object[] new_ranges_array = more_ranges.toArray();\n-    for (int i=0;i<more_ranges.size();i++)\n-      new_ranges[i+ranges.length] = ((Integer)new_ranges_array[i]).intValue();\n+    for (int i = 0; i < more_ranges.size();i++)\n+      new_ranges[i+ranges.length] = ((Integer) new_ranges_array[i]).intValue();\n \n     attributes = new_attributes;\n     ranges = new_ranges;\n@@ -440,7 +446,7 @@ protected void append (AttributedCharacterIterator iterator)\n    * iterator. If it is <code>null</code> the string will simply have no\n    * attributes.\n    */\n-  protected void append (String text, HashMap local_attributes)\n+  public void append (String text, HashMap local_attributes)\n   {\n     int[] new_ranges = new int[ranges.length+1];\n     HashMap[] new_attributes = new HashMap[attributes.length+1];\n@@ -462,8 +468,67 @@ protected void append (String text, HashMap local_attributes)\n    *\n    * @param text The string to append to the iterator.\n    */\n-  protected void append (String text)\n+  public void append (String text)\n   {\n     append (text, null);\n   }  \n+\n+  /**\n+   * This method adds a set of attributes to a range of character. The\n+   * bounds are always inclusive. In the case many attributes have to\n+   * be added it is advised to directly use {@link #mergeAttributes([Ljava.util.HashMap;[I}\n+   *\n+   * @param attributes Attributes to merge into the iterator.\n+   * @param range_start Lower bound of the range of characters which will receive the\n+   * attribute.\n+   * @param range_end Upper bound of the range of characters which will receive the\n+   * attribute. \n+   *\n+   * @throws IllegalArgumentException if ranges are out of bounds.\n+   */\n+  public void addAttributes(HashMap attributes, int range_start, int range_end)\n+  {\n+    if (range_start == 0)\n+      mergeAttributes(new HashMap[] { attributes }, new int[] { range_end });\n+    else\n+      mergeAttributes(new HashMap[] { null, attributes }, new int[] { range_start, range_end });\n+  }\n+\n+  final private void debug(String s)\n+  {\n+    if (Configuration.DEBUG)\n+      System.out.println(s);\n+  }\n+\n+  final private void dumpTable()\n+  {\n+    int start_range = 0;\n+    \n+    if (!Configuration.DEBUG)\n+      return;\n+\n+    System.out.println(\"Dumping internal table:\");\n+    for (int i = 0; i < ranges.length; i++)\n+      {\n+\tSystem.out.print(\"\\t\" + start_range + \" => \" + ranges[i] + \":\");\n+\tif (attributes[i] == null)\n+\t  System.out.println(\"null\");\n+\telse\n+\t  {\n+\t    Set keyset = attributes[i].keySet();\n+\t    if (keyset != null)\n+\t      {\n+\t\tIterator keys = keyset.iterator();\n+\t\t\n+\t\twhile (keys.hasNext())\n+\t\t  System.out.print(\" \" + keys.next());\n+\t      }\n+\t    else\n+\t      System.out.println(\"keySet null\");\n+\t    System.out.println();\n+\t  }\n+      }\n+    System.out.println();\n+    System.out.flush();\n+  }\n }", "previous_filename": "libjava/java/text/FormatCharacterIterator.java"}, {"sha": "ec0ed86417eec51ae31d68ecc00d26892febb933", "filename": "libjava/gnu/java/text/StringFormatBuffer.java", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fgnu%2Fjava%2Ftext%2FStringFormatBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fgnu%2Fjava%2Ftext%2FStringFormatBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Ftext%2FStringFormatBuffer.java?ref=065afdfa8e2e699b1f5ac17c43ac4664940f6659", "patch": "@@ -0,0 +1,121 @@\n+/* StringFormatBuffer.java -- Implements FormatBuffer using StringBuffer.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+package gnu.java.text;\n+\n+import java.text.AttributedCharacterIterator;\n+import java.util.HashMap;\n+\n+/**\n+ * This class is an implementation of a FormatBuffer without attributes.\n+ * \n+ * @author Guilhem Lavaux <guilhem@kaffe.org>\n+ * @date April 10, 2004\n+ */\n+public class StringFormatBuffer implements FormatBuffer\n+{\n+  private StringBuffer buffer;\n+  private AttributedCharacterIterator.Attribute defaultAttr;\n+\n+  public StringFormatBuffer(int prebuffer)\n+  {\n+    buffer = new StringBuffer(prebuffer);\n+  }\n+\n+  public StringFormatBuffer(StringBuffer buffer)\n+  {\n+    this.buffer = buffer;\n+  }\n+\n+  public void append(String s)\n+  {\n+    buffer.append(s);\n+  }\n+  \n+  public void append(String s, AttributedCharacterIterator.Attribute attr)\n+  {\n+    buffer.append(s);\n+  }\n+\n+  public void append(String s, int[] ranges, HashMap[] attrs)\n+  {\n+    buffer.append(s);\n+  }\n+\n+  public void append(char c)\n+  {\n+    buffer.append(c);\n+  }\n+\n+  public void append(char c, AttributedCharacterIterator.Attribute attr)\n+  {\n+    buffer.append(c);\n+  }\n+\n+  public void setDefaultAttribute(AttributedCharacterIterator.Attribute attr)\n+  {\n+    defaultAttr = attr;\n+  }\n+\n+  public AttributedCharacterIterator.Attribute getDefaultAttribute()\n+  {\n+    return defaultAttr;\n+  }\n+\n+  public void cutTail(int length)\n+  {\n+    buffer.setLength(buffer.length()-length);\n+  }\n+\n+  public int length()\n+  {\n+    return buffer.length();\n+  }\n+\n+  public void clear()\n+  {\n+    buffer.setLength(0);\n+  }\n+\n+  /**\n+   * This method returns the internal {@link java.lang.StringBuffer} which \n+   * contains the string of character.\n+   */\n+  public StringBuffer getBuffer()\n+  {\n+    return buffer;\n+  }\n+}"}, {"sha": "0cef00a8d07bb34004d01c7d5926e7cec4dcb800", "filename": "libjava/java/text/Format.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fjava%2Ftext%2FFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/065afdfa8e2e699b1f5ac17c43ac4664940f6659/libjava%2Fjava%2Ftext%2FFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FFormat.java?ref=065afdfa8e2e699b1f5ac17c43ac4664940f6659", "patch": "@@ -38,6 +38,8 @@\n \n package java.text;\n \n+import gnu.java.text.FormatCharacterIterator;\n+\n import java.util.Set;\n import java.util.Map;\n import java.util.HashSet;"}]}