{"sha": "02440ca432f1aa4de7aeda563d2493a20148554b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI0NDBjYTQzMmYxYWE0ZGU3YWVkYTU2M2QyNDkzYTIwMTQ4NTU0Yg==", "commit": {"author": {"name": "Thomas Fitzsimmons", "email": "fitzsim@redhat.com", "date": "2006-06-09T16:07:07Z"}, "committer": {"name": "Thomas Fitzsimmons", "email": "fitzsim@gcc.gnu.org", "date": "2006-06-09T16:07:07Z"}, "message": "String.java, [...]: Merge from GNU Classpath HEAD.\n\n2006-06-09  Thomas Fitzsimmons  <fitzsim@redhat.com>\n\n\t* java/lang/String.java, classpath/native/jni/classpath/jcl.h,\n\tclasspath/native/jni/qt-peer/eventmethods.h,\n\tclasspath/native/jni/qt-peer/qtmenupeer.cpp,\n\tclasspath/native/jni/qt-peer/.cvsignore,\n\tclasspath/native/jni/gtk-peer/gdkdisplay.h,\n\tclasspath/native/jni/gtk-peer/cairographics2d.h,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_CairoGraphics2D.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontPeer.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_FreetypeGlyphVector.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphicsEnvironment.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_ComponentGraphicsCopy.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_ComponentGraphics.c,\n\tclasspath/native/jni/gtk-peer/.cvsignore,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkImage.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkVolatileImage.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCanvasPeer.c,\n\tclasspath/native/jni/gtk-peer/gtkpeer.h,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkClipboard.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_CairoSurface.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkTextLayout.c,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFramePeer.c,\n\tclasspath/native/jni/gtk-peer/Makefile.am,\n\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c,\n\tclasspath/native/jawt/Makefile.am,\n\tclasspath/native/jawt/.cvsignore,\n\tclasspath/native/target/Linux/Makefile.in,\n\tclasspath/native/plugin/gcjwebplugin.cc,\n\tclasspath/native/plugin/Makefile.am,\n\tclasspath/native/plugin/.cvsignore,\n\tclasspath/resource/Makefile.in,\n\tclasspath/gnu/java/awt/peer/gtk/VolatileImageGraphics.java,\n\tclasspath/gnu/java/awt/peer/gtk/CairoGraphics2D.java,\n\tclasspath/gnu/java/awt/peer/gtk/CairoSurface.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkFontPeer.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkPixbufDecoder.java,\n\tclasspath/gnu/java/awt/peer/gtk/FreetypeGlyphVector.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkGraphics2D.java,\n\tclasspath/gnu/java/awt/peer/gtk/ComponentGraphicsCopy.java,\n\tclasspath/gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkGraphics.java,\n\tclasspath/gnu/java/awt/peer/gtk/GtkToolkit.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkScreenGraphicsDevice.java,\n\tclasspath/gnu/java/awt/peer/gtk/BufferedImageGraphics.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkTextLayout.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkGraphicsConfiguration.java,\n\tclasspath/gnu/java/awt/peer/gtk/ComponentGraphics.java,\n\tclasspath/gnu/java/awt/peer/gtk/CairoSurfaceGraphics.java,\n\tclasspath/gnu/java/awt/peer/gtk/GtkImage.java,\n\tclasspath/gnu/java/awt/peer/gtk/GtkVolatileImage.java,\n\tclasspath/gnu/java/awt/peer/gtk/GdkGlyphVector.java,\n\tclasspath/gnu/java/awt/peer/gtk/GtkCanvasPeer.java,\n\tclasspath/gnu/java/awt/peer/swing/SwingContainerPeer.java,\n\tclasspath/gnu/java/awt/peer/swing/SwingComponent.java,\n\tclasspath/gnu/java/awt/peer/swing/SwingTextFieldPeer.java,\n\tclasspath/gnu/java/awt/peer/swing/SwingMenuBarPeer.java,\n\tclasspath/gnu/java/awt/peer/swing/SwingFramePeer.java,\n\tclasspath/gnu/java/awt/peer/swing/SwingComponentPeer.java,\n\tclasspath/gnu/java/awt/peer/swing/SwingWindowPeer.java,\n\tclasspath/gnu/java/awt/print/JavaPrinterJob.java,\n\tclasspath/gnu/java/awt/print/PostScriptGraphics2D.java,\n\tclasspath/gnu/java/awt/print/SpooledDocument.java,\n\tclasspath/gnu/java/awt/print/JavaPrinterGraphics.java,\n\tclasspath/gnu/java/awt/BitwiseXORComposite.java,\n\tclasspath/gnu/java/awt/font/GNUGlyphVector.java,\n\tclasspath/gnu/java/awt/font/opentype/NameDecoder.java,\n\tclasspath/gnu/java/awt/java2d/RasterGraphics.java,\n\tclasspath/gnu/java/awt/java2d/TexturePaintContext.java,\n\tclasspath/gnu/java/awt/java2d/PolyEdge.java,\n\tclasspath/gnu/java/awt/java2d/AbstractGraphics2D.java,\n\tclasspath/gnu/java/awt/java2d/AlphaCompositeContext.java,\n\tclasspath/gnu/java/awt/java2d/ImagePaint.java,\n\tclasspath/gnu/java/awt/Buffers.java,\n\tclasspath/gnu/classpath/Configuration.java.in,\n\tclasspath/gnu/javax/swing/text/html/CombinedAttributes.java,\n\tclasspath/gnu/javax/swing/text/html/CharacterAttributeTranslator.java,\n\tclasspath/gnu/javax/swing/text/html/parser/htmlAttributeSet.java,\n\tclasspath/gnu/javax/swing/text/html/parser/SmallHtmlAttributeSet.java,\n\tclasspath/gnu/javax/swing/text/html/ImageViewIconFactory.java,\n\tclasspath/tools/toolwrapper.c,\n\tclasspath/tools/gnu/classpath/tools/native2ascii/Native2ASCII.java,\n\tclasspath/tools/gnu/classpath/tools/native2ascii/Messages.java,\n\tclasspath/tools/gnu/classpath/tools/getopt/FileArgumentCallback.java,\n\tclasspath/tools/gnu/classpath/tools/getopt/OptionGroup.java,\n\tclasspath/tools/gnu/classpath/tools/getopt/OptionException.java,\n\tclasspath/tools/gnu/classpath/tools/getopt/Messages.java,\n\tclasspath/tools/gnu/classpath/tools/getopt/Option.java,\n\tclasspath/tools/gnu/classpath/tools/getopt/Parser.java,\n\tclasspath/tools/gnu/classpath/tools/getopt/ClasspathToolParser.java,\n\tclasspath/tools/gnu/classpath/tools/jarsigner/JarSigner.java,\n\tclasspath/tools/gnu/classpath/tools/jarsigner/Main.java,\n\tclasspath/tools/gnu/classpath/tools/jarsigner/Messages.java,\n\tclasspath/tools/gnu/classpath/tools/jarsigner/package.html,\n\tclasspath/tools/gnu/classpath/tools/keytool/ListCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/StorePasswdCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/ExportCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/GenKeyCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/Messages.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/package.html,\n\tclasspath/tools/gnu/classpath/tools/keytool/Command.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/IdentityDBCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/Main.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/DeleteCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/CertReqCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/SelfCertCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/KeyCloneCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/KeyPasswdCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/ImportCmd.java,\n\tclasspath/tools/gnu/classpath/tools/keytool/PrintCertCmd.java,\n\tclasspath/tools/gnu/classpath/tools/rmi/registry/package.html,\n\tclasspath/tools/gnu/classpath/tools/rmi/RMIC.txt,\n\tclasspath/tools/gnu/classpath/tools/rmi/RMIC.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/ErrorApplet.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/AppletClassLoader.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/CommonAppletContext.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/StandaloneAppletContext.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/AppletSecurityManager.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/PluginAppletContext.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/AppletWarning.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/StandaloneAppletViewer.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/AppletTag.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/ConsoleDialog.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/Main.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/StandaloneAppletWindow.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/PluginAppletViewer.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/TagParser.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/PluginAppletWindow.java,\n\tclasspath/tools/gnu/classpath/tools/appletviewer/CommonAppletStub.java,\n\tclasspath/tools/gnu/classpath/tools/serialver/Messages.java,\n\tclasspath/tools/gnu/classpath/tools/serialver/SerialVer.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Creator.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Entry.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Lister.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Main.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Updater.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Messages.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Extractor.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Action.java,\n\tclasspath/tools/gnu/classpath/tools/jar/Indexer.java,\n\tclasspath/tools/gnu/classpath/tools/jar/WorkSet.java,\n\tclasspath/tools/gnu/classpath/tools/giop/GRMIC.txt,\n\tclasspath/tools/gnu/classpath/tools/giop/grmic/GiopRmicCompiler.java,\n\tclasspath/tools/gnu/classpath/tools/giop/GRMIC.java,\n\tclasspath/tools/Makefile.am, classpath/tools/jarsigner.in,\n\tclasspath/tools/keytool.in, classpath/tools/appletviewer.in,\n\tclasspath/tools/.cvsignore, classpath/configure.ac,\n\tclasspath/javax/swing/JTabbedPane.java,\n\tclasspath/javax/swing/AbstractButton.java,\n\tclasspath/javax/swing/JViewport.java,\n\tclasspath/javax/swing/KeyboardManager.java,\n\tclasspath/javax/swing/JMenuItem.java,\n\tclasspath/javax/swing/JMenuBar.java,\n\tclasspath/javax/swing/MenuSelectionManager.java,\n\tclasspath/javax/swing/JOptionPane.java,\n\tclasspath/javax/swing/JSpinner.java,\n\tclasspath/javax/swing/JCheckBoxMenuItem.java,\n\tclasspath/javax/swing/JEditorPane.java,\n\tclasspath/javax/swing/JFormattedTextField.java,\n\tclasspath/javax/swing/JTree.java,\n\tclasspath/javax/swing/CellRendererPane.java,\n\tclasspath/javax/swing/JScrollPane.java,\n\tclasspath/javax/swing/tree/VariableHeightLayoutCache.java,\n\tclasspath/javax/swing/tree/TreeNode.java,\n\tclasspath/javax/swing/tree/FixedHeightLayoutCache.java,\n\tclasspath/javax/swing/tree/DefaultTreeCellEditor.java,\n\tclasspath/javax/swing/tree/TreePath.java,\n\tclasspath/javax/swing/tree/RowMapper.java,\n\tclasspath/javax/swing/tree/DefaultMutableTreeNode.java,\n\tclasspath/javax/swing/tree/DefaultTreeModel.java,\n\tclasspath/javax/swing/tree/AbstractLayoutCache.java,\n\tclasspath/javax/swing/tree/TreeSelectionModel.java,\n\tclasspath/javax/swing/tree/DefaultTreeSelectionModel.java,\n\tclasspath/javax/swing/tree/DefaultTreeCellRenderer.java,\n\tclasspath/javax/swing/tree/ExpandVetoException.java,\n\tclasspath/javax/swing/JList.java,\n\tclasspath/javax/swing/table/JTableHeader.java,\n\tclasspath/javax/swing/table/AbstractTableModel.java,\n\tclasspath/javax/swing/table/DefaultTableModel.java,\n\tclasspath/javax/swing/table/TableCellEditor.java,\n\tclasspath/javax/swing/table/TableCellRenderer.java,\n\tclasspath/javax/swing/ProgressMonitor.java,\n\tclasspath/javax/swing/JToolBar.java,\n\tclasspath/javax/swing/TransferHandler.java,\n\tclasspath/javax/swing/DefaultCellEditor.java,\n\tclasspath/javax/swing/DefaultButtonModel.java,\n\tclasspath/javax/swing/JLayeredPane.java,\n\tclasspath/javax/swing/text/DefaultEditorKit.java,\n\tclasspath/javax/swing/text/DefaultCaret.java,\n\tclasspath/javax/swing/text/FieldView.java,\n\tclasspath/javax/swing/text/JTextComponent.java,\n\tclasspath/javax/swing/text/TextAction.java,\n\tclasspath/javax/swing/text/StyleContext.java,\n\tclasspath/javax/swing/text/html/HTMLDocument.java,\n\tclasspath/javax/swing/text/html/MinimalHTMLWriter.java,\n\tclasspath/javax/swing/text/html/ImageView.java,\n\tclasspath/javax/swing/text/html/HTMLEditorKit.java,\n\tclasspath/javax/swing/text/AbstractWriter.java,\n\tclasspath/javax/swing/text/GapContent.java,\n\tclasspath/javax/swing/text/Utilities.java,\n\tclasspath/javax/swing/text/PlainView.java,\n\tclasspath/javax/swing/UIManager.java,\n\tclasspath/javax/swing/JSplitPane.java,\n\tclasspath/javax/swing/JComponent.java,\n\tclasspath/javax/swing/SwingUtilities.java,\n\tclasspath/javax/swing/border/AbstractBorder.java,\n\tclasspath/javax/swing/border/CompoundBorder.java,\n\tclasspath/javax/swing/border/TitledBorder.java,\n\tclasspath/javax/swing/border/MatteBorder.java,\n\tclasspath/javax/swing/border/BevelBorder.java,\n\tclasspath/javax/swing/RepaintManager.java,\n\tclasspath/javax/swing/JTable.java,\n\tclasspath/javax/swing/UIDefaults.java,\n\tclasspath/javax/swing/DefaultDesktopManager.java,\n\tclasspath/javax/swing/JMenu.java,\n\tclasspath/javax/swing/JLabel.java,\n\tclasspath/javax/swing/JSlider.java,\n\tclasspath/javax/swing/plaf/basic/BasicToolBarUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicButtonUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicOptionPaneUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicTextAreaUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicToggleButtonUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicSpinnerUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicSliderUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicTabbedPaneUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicComboPopup.java,\n\tclasspath/javax/swing/plaf/basic/BasicCheckBoxUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicInternalFrameUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicProgressBarUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicRadioButtonUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicPanelUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicSplitPaneUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicTreeUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicTableHeaderUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicFileChooserUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicScrollPaneUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicComboBoxUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicListUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicIconFactory.java,\n\tclasspath/javax/swing/plaf/basic/BasicTextUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicLookAndFeel.java,\n\tclasspath/javax/swing/plaf/basic/BasicDirectoryModel.java,\n\tclasspath/javax/swing/plaf/basic/BasicRootPaneUI.java,\n\tclasspath/javax/swing/plaf/basic/BasicTableUI.java,\n\tclasspath/javax/swing/plaf/basic/SharedUIDefaults.java,\n\tclasspath/javax/swing/plaf/multi/MultiComboBoxUI.java,\n\tclasspath/javax/swing/plaf/multi/MultiListUI.java,\n\tclasspath/javax/swing/plaf/multi/MultiSplitPaneUI.java,\n\tclasspath/javax/swing/plaf/multi/MultiFileChooserUI.java,\n\tclasspath/javax/swing/plaf/multi/MultiOptionPaneUI.java,\n\tclasspath/javax/swing/plaf/multi/MultiTabbedPaneUI.java,\n\tclasspath/javax/swing/plaf/multi/MultiLookAndFeel.java,\n\tclasspath/javax/swing/plaf/metal/MetalSliderUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalIconFactory.java,\n\tclasspath/javax/swing/plaf/metal/MetalComboBoxIcon.java,\n\tclasspath/javax/swing/plaf/metal/MetalTabbedPaneUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalLookAndFeel.java,\n\tclasspath/javax/swing/plaf/metal/MetalCheckBoxUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalSeparatorUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalBorders.java,\n\tclasspath/javax/swing/plaf/metal/MetalSplitPaneDivider.java,\n\tclasspath/javax/swing/plaf/metal/MetalScrollBarUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalRootPaneUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalInternalFrameUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalRadioButtonUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalToolTipUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalInternalFrameTitlePane.java,\n\tclasspath/javax/swing/plaf/metal/MetalFileChooserUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalUtils.java,\n\tclasspath/javax/swing/plaf/metal/MetalComboBoxButton.java,\n\tclasspath/javax/swing/plaf/metal/MetalPopupMenuSeparatorUI.java,\n\tclasspath/javax/swing/plaf/metal/MetalButtonUI.java,\n\tclasspath/javax/swing/JPopupMenu.java,\n\tclasspath/javax/swing/JProgressBar.java,\n\tclasspath/javax/swing/WindowConstants.java,\n\tclasspath/javax/swing/JFrame.java,\n\tclasspath/javax/swing/JFileChooser.java,\n\tclasspath/javax/swing/JComboBox.java,\n\tclasspath/javax/swing/event/EventListenerList.java,\n\tclasspath/javax/swing/ListSelectionModel.java,\n\tclasspath/javax/swing/JScrollBar.java,\n\tclasspath/java/text/SimpleDateFormat.java,\n\tclasspath/java/text/NumberFormat.java,\n\tclasspath/java/text/class-dependencies.conf,\n\tclasspath/java/awt/image/ColorModel.java,\n\tclasspath/java/awt/image/BufferedImage.java,\n\tclasspath/java/awt/Window.java,\n\tclasspath/java/awt/ContainerOrderFocusTraversalPolicy.java,\n\tclasspath/java/awt/LightweightDispatcher.java,\n\tclasspath/java/awt/EventDispatchThread.java,\n\tclasspath/java/awt/BasicStroke.java,\n\tclasspath/java/awt/ColorPaintContext.java,\n\tclasspath/java/awt/Container.java,\n\tclasspath/java/awt/TexturePaint.java,\n\tclasspath/java/awt/Component.java, classpath/java/awt/Font.java,\n\tclasspath/java/awt/GraphicsConfiguration.java,\n\tclasspath/java/awt/DefaultKeyboardFocusManager.java,\n\tclasspath/java/awt/print/PrinterJob.java,\n\tclasspath/java/awt/im/InputContext.java,\n\tclasspath/java/awt/dnd/DragGestureRecognizer.java,\n\tclasspath/java/awt/Toolkit.java,\n\tclasspath/java/awt/font/GraphicAttribute.java,\n\tclasspath/java/awt/font/ImageGraphicAttribute.java,\n\tclasspath/java/awt/font/GlyphVector.java,\n\tclasspath/java/awt/font/GlyphMetrics.java,\n\tclasspath/java/awt/font/ShapeGraphicAttribute.java,\n\tclasspath/java/awt/Graphics2D.java,\n\tclasspath/include/gnu_java_awt_peer_gtk_GdkGraphicsEnvironment.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_ComponentGraphics.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_CairoGraphics2D.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_FreetypeGlyphVector.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_GtkCanvasPeer.h,\n\tclasspath/include/config.h.in,\n\tclasspath/include/gnu_java_awt_peer_gtk_GdkTextLayout.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_GtkComponentPeer.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_GdkFontPeer.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_ComponentGraphicsCopy.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_GtkVolatileImage.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_GtkImage.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_CairoSurface.h,\n\tclasspath/include/gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.h:\n\tMerge from GNU Classpath HEAD.\n\nFrom-SVN: r114510", "tree": {"sha": "0802013820f309170e8ae5584b09e9672bab2cb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0802013820f309170e8ae5584b09e9672bab2cb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02440ca432f1aa4de7aeda563d2493a20148554b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02440ca432f1aa4de7aeda563d2493a20148554b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02440ca432f1aa4de7aeda563d2493a20148554b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02440ca432f1aa4de7aeda563d2493a20148554b/comments", "author": null, "committer": null, "parents": [{"sha": "6c65d7577ca4e36675571fd8bad43ef6d34e2831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c65d7577ca4e36675571fd8bad43ef6d34e2831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c65d7577ca4e36675571fd8bad43ef6d34e2831"}], "stats": {"total": 47198, "additions": 36302, "deletions": 10896}, "files": [{"sha": "e9fd6467220e9baf13dbe6804d9061a450b91b7a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,3 +1,329 @@\n+2006-06-09  Thomas Fitzsimmons  <fitzsim@redhat.com>\n+\n+\t* java/lang/String.java, classpath/native/jni/classpath/jcl.h,\n+\tclasspath/native/jni/qt-peer/eventmethods.h,\n+\tclasspath/native/jni/qt-peer/qtmenupeer.cpp,\n+\tclasspath/native/jni/qt-peer/.cvsignore,\n+\tclasspath/native/jni/gtk-peer/gdkdisplay.h,\n+\tclasspath/native/jni/gtk-peer/cairographics2d.h,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_CairoGraphics2D.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontPeer.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_FreetypeGlyphVector.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphicsEnvironment.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_ComponentGraphicsCopy.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_ComponentGraphics.c,\n+\tclasspath/native/jni/gtk-peer/.cvsignore,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkImage.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkVolatileImage.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCanvasPeer.c,\n+\tclasspath/native/jni/gtk-peer/gtkpeer.h,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkClipboard.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_CairoSurface.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkTextLayout.c,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFramePeer.c,\n+\tclasspath/native/jni/gtk-peer/Makefile.am,\n+\tclasspath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c,\n+\tclasspath/native/jawt/Makefile.am,\n+\tclasspath/native/jawt/.cvsignore,\n+\tclasspath/native/target/Linux/Makefile.in,\n+\tclasspath/native/plugin/gcjwebplugin.cc,\n+\tclasspath/native/plugin/Makefile.am,\n+\tclasspath/native/plugin/.cvsignore,\n+\tclasspath/resource/Makefile.in,\n+\tclasspath/gnu/java/awt/peer/gtk/VolatileImageGraphics.java,\n+\tclasspath/gnu/java/awt/peer/gtk/CairoGraphics2D.java,\n+\tclasspath/gnu/java/awt/peer/gtk/CairoSurface.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkFontPeer.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkPixbufDecoder.java,\n+\tclasspath/gnu/java/awt/peer/gtk/FreetypeGlyphVector.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkGraphics2D.java,\n+\tclasspath/gnu/java/awt/peer/gtk/ComponentGraphicsCopy.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GtkComponentPeer.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkGraphics.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GtkToolkit.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkScreenGraphicsDevice.java,\n+\tclasspath/gnu/java/awt/peer/gtk/BufferedImageGraphics.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkTextLayout.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkGraphicsConfiguration.java,\n+\tclasspath/gnu/java/awt/peer/gtk/ComponentGraphics.java,\n+\tclasspath/gnu/java/awt/peer/gtk/CairoSurfaceGraphics.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GtkImage.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GtkVolatileImage.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GdkGlyphVector.java,\n+\tclasspath/gnu/java/awt/peer/gtk/GtkCanvasPeer.java,\n+\tclasspath/gnu/java/awt/peer/swing/SwingContainerPeer.java,\n+\tclasspath/gnu/java/awt/peer/swing/SwingComponent.java,\n+\tclasspath/gnu/java/awt/peer/swing/SwingTextFieldPeer.java,\n+\tclasspath/gnu/java/awt/peer/swing/SwingMenuBarPeer.java,\n+\tclasspath/gnu/java/awt/peer/swing/SwingFramePeer.java,\n+\tclasspath/gnu/java/awt/peer/swing/SwingComponentPeer.java,\n+\tclasspath/gnu/java/awt/peer/swing/SwingWindowPeer.java,\n+\tclasspath/gnu/java/awt/print/JavaPrinterJob.java,\n+\tclasspath/gnu/java/awt/print/PostScriptGraphics2D.java,\n+\tclasspath/gnu/java/awt/print/SpooledDocument.java,\n+\tclasspath/gnu/java/awt/print/JavaPrinterGraphics.java,\n+\tclasspath/gnu/java/awt/BitwiseXORComposite.java,\n+\tclasspath/gnu/java/awt/font/GNUGlyphVector.java,\n+\tclasspath/gnu/java/awt/font/opentype/NameDecoder.java,\n+\tclasspath/gnu/java/awt/java2d/RasterGraphics.java,\n+\tclasspath/gnu/java/awt/java2d/TexturePaintContext.java,\n+\tclasspath/gnu/java/awt/java2d/PolyEdge.java,\n+\tclasspath/gnu/java/awt/java2d/AbstractGraphics2D.java,\n+\tclasspath/gnu/java/awt/java2d/AlphaCompositeContext.java,\n+\tclasspath/gnu/java/awt/java2d/ImagePaint.java,\n+\tclasspath/gnu/java/awt/Buffers.java,\n+\tclasspath/gnu/classpath/Configuration.java.in,\n+\tclasspath/gnu/javax/swing/text/html/CombinedAttributes.java,\n+\tclasspath/gnu/javax/swing/text/html/CharacterAttributeTranslator.java,\n+\tclasspath/gnu/javax/swing/text/html/parser/htmlAttributeSet.java,\n+\tclasspath/gnu/javax/swing/text/html/parser/SmallHtmlAttributeSet.java,\n+\tclasspath/gnu/javax/swing/text/html/ImageViewIconFactory.java,\n+\tclasspath/tools/toolwrapper.c,\n+\tclasspath/tools/gnu/classpath/tools/native2ascii/Native2ASCII.java,\n+\tclasspath/tools/gnu/classpath/tools/native2ascii/Messages.java,\n+\tclasspath/tools/gnu/classpath/tools/getopt/FileArgumentCallback.java,\n+\tclasspath/tools/gnu/classpath/tools/getopt/OptionGroup.java,\n+\tclasspath/tools/gnu/classpath/tools/getopt/OptionException.java,\n+\tclasspath/tools/gnu/classpath/tools/getopt/Messages.java,\n+\tclasspath/tools/gnu/classpath/tools/getopt/Option.java,\n+\tclasspath/tools/gnu/classpath/tools/getopt/Parser.java,\n+\tclasspath/tools/gnu/classpath/tools/getopt/ClasspathToolParser.java,\n+\tclasspath/tools/gnu/classpath/tools/jarsigner/JarSigner.java,\n+\tclasspath/tools/gnu/classpath/tools/jarsigner/Main.java,\n+\tclasspath/tools/gnu/classpath/tools/jarsigner/Messages.java,\n+\tclasspath/tools/gnu/classpath/tools/jarsigner/package.html,\n+\tclasspath/tools/gnu/classpath/tools/keytool/ListCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/StorePasswdCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/ExportCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/GenKeyCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/Messages.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/package.html,\n+\tclasspath/tools/gnu/classpath/tools/keytool/Command.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/IdentityDBCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/Main.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/DeleteCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/CertReqCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/SelfCertCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/KeyCloneCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/KeyPasswdCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/ImportCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/keytool/PrintCertCmd.java,\n+\tclasspath/tools/gnu/classpath/tools/rmi/registry/package.html,\n+\tclasspath/tools/gnu/classpath/tools/rmi/RMIC.txt,\n+\tclasspath/tools/gnu/classpath/tools/rmi/RMIC.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/ErrorApplet.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/AppletClassLoader.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/CommonAppletContext.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/StandaloneAppletContext.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/AppletSecurityManager.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/PluginAppletContext.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/AppletWarning.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/StandaloneAppletViewer.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/AppletTag.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/ConsoleDialog.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/Main.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/StandaloneAppletWindow.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/PluginAppletViewer.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/TagParser.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/PluginAppletWindow.java,\n+\tclasspath/tools/gnu/classpath/tools/appletviewer/CommonAppletStub.java,\n+\tclasspath/tools/gnu/classpath/tools/serialver/Messages.java,\n+\tclasspath/tools/gnu/classpath/tools/serialver/SerialVer.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Creator.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Entry.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Lister.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Main.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Updater.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Messages.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Extractor.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Action.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/Indexer.java,\n+\tclasspath/tools/gnu/classpath/tools/jar/WorkSet.java,\n+\tclasspath/tools/gnu/classpath/tools/giop/GRMIC.txt,\n+\tclasspath/tools/gnu/classpath/tools/giop/grmic/GiopRmicCompiler.java,\n+\tclasspath/tools/gnu/classpath/tools/giop/GRMIC.java,\n+\tclasspath/tools/Makefile.am, classpath/tools/jarsigner.in,\n+\tclasspath/tools/keytool.in, classpath/tools/appletviewer.in,\n+\tclasspath/tools/.cvsignore, classpath/configure.ac,\n+\tclasspath/javax/swing/JTabbedPane.java,\n+\tclasspath/javax/swing/AbstractButton.java,\n+\tclasspath/javax/swing/JViewport.java,\n+\tclasspath/javax/swing/KeyboardManager.java,\n+\tclasspath/javax/swing/JMenuItem.java,\n+\tclasspath/javax/swing/JMenuBar.java,\n+\tclasspath/javax/swing/MenuSelectionManager.java,\n+\tclasspath/javax/swing/JOptionPane.java,\n+\tclasspath/javax/swing/JSpinner.java,\n+\tclasspath/javax/swing/JCheckBoxMenuItem.java,\n+\tclasspath/javax/swing/JEditorPane.java,\n+\tclasspath/javax/swing/JFormattedTextField.java,\n+\tclasspath/javax/swing/JTree.java,\n+\tclasspath/javax/swing/CellRendererPane.java,\n+\tclasspath/javax/swing/JScrollPane.java,\n+\tclasspath/javax/swing/tree/VariableHeightLayoutCache.java,\n+\tclasspath/javax/swing/tree/TreeNode.java,\n+\tclasspath/javax/swing/tree/FixedHeightLayoutCache.java,\n+\tclasspath/javax/swing/tree/DefaultTreeCellEditor.java,\n+\tclasspath/javax/swing/tree/TreePath.java,\n+\tclasspath/javax/swing/tree/RowMapper.java,\n+\tclasspath/javax/swing/tree/DefaultMutableTreeNode.java,\n+\tclasspath/javax/swing/tree/DefaultTreeModel.java,\n+\tclasspath/javax/swing/tree/AbstractLayoutCache.java,\n+\tclasspath/javax/swing/tree/TreeSelectionModel.java,\n+\tclasspath/javax/swing/tree/DefaultTreeSelectionModel.java,\n+\tclasspath/javax/swing/tree/DefaultTreeCellRenderer.java,\n+\tclasspath/javax/swing/tree/ExpandVetoException.java,\n+\tclasspath/javax/swing/JList.java,\n+\tclasspath/javax/swing/table/JTableHeader.java,\n+\tclasspath/javax/swing/table/AbstractTableModel.java,\n+\tclasspath/javax/swing/table/DefaultTableModel.java,\n+\tclasspath/javax/swing/table/TableCellEditor.java,\n+\tclasspath/javax/swing/table/TableCellRenderer.java,\n+\tclasspath/javax/swing/ProgressMonitor.java,\n+\tclasspath/javax/swing/JToolBar.java,\n+\tclasspath/javax/swing/TransferHandler.java,\n+\tclasspath/javax/swing/DefaultCellEditor.java,\n+\tclasspath/javax/swing/DefaultButtonModel.java,\n+\tclasspath/javax/swing/JLayeredPane.java,\n+\tclasspath/javax/swing/text/DefaultEditorKit.java,\n+\tclasspath/javax/swing/text/DefaultCaret.java,\n+\tclasspath/javax/swing/text/FieldView.java,\n+\tclasspath/javax/swing/text/JTextComponent.java,\n+\tclasspath/javax/swing/text/TextAction.java,\n+\tclasspath/javax/swing/text/StyleContext.java,\n+\tclasspath/javax/swing/text/html/HTMLDocument.java,\n+\tclasspath/javax/swing/text/html/MinimalHTMLWriter.java,\n+\tclasspath/javax/swing/text/html/ImageView.java,\n+\tclasspath/javax/swing/text/html/HTMLEditorKit.java,\n+\tclasspath/javax/swing/text/AbstractWriter.java,\n+\tclasspath/javax/swing/text/GapContent.java,\n+\tclasspath/javax/swing/text/Utilities.java,\n+\tclasspath/javax/swing/text/PlainView.java,\n+\tclasspath/javax/swing/UIManager.java,\n+\tclasspath/javax/swing/JSplitPane.java,\n+\tclasspath/javax/swing/JComponent.java,\n+\tclasspath/javax/swing/SwingUtilities.java,\n+\tclasspath/javax/swing/border/AbstractBorder.java,\n+\tclasspath/javax/swing/border/CompoundBorder.java,\n+\tclasspath/javax/swing/border/TitledBorder.java,\n+\tclasspath/javax/swing/border/MatteBorder.java,\n+\tclasspath/javax/swing/border/BevelBorder.java,\n+\tclasspath/javax/swing/RepaintManager.java,\n+\tclasspath/javax/swing/JTable.java,\n+\tclasspath/javax/swing/UIDefaults.java,\n+\tclasspath/javax/swing/DefaultDesktopManager.java,\n+\tclasspath/javax/swing/JMenu.java,\n+\tclasspath/javax/swing/JLabel.java,\n+\tclasspath/javax/swing/JSlider.java,\n+\tclasspath/javax/swing/plaf/basic/BasicToolBarUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicButtonUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicOptionPaneUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicTextAreaUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicToggleButtonUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicSpinnerUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicSliderUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicTabbedPaneUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicComboPopup.java,\n+\tclasspath/javax/swing/plaf/basic/BasicCheckBoxUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicInternalFrameUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicProgressBarUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicRadioButtonUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicPanelUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicSplitPaneUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicTreeUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicTableHeaderUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicFileChooserUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicScrollPaneUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicComboBoxUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicListUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicIconFactory.java,\n+\tclasspath/javax/swing/plaf/basic/BasicTextUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicLookAndFeel.java,\n+\tclasspath/javax/swing/plaf/basic/BasicDirectoryModel.java,\n+\tclasspath/javax/swing/plaf/basic/BasicRootPaneUI.java,\n+\tclasspath/javax/swing/plaf/basic/BasicTableUI.java,\n+\tclasspath/javax/swing/plaf/basic/SharedUIDefaults.java,\n+\tclasspath/javax/swing/plaf/multi/MultiComboBoxUI.java,\n+\tclasspath/javax/swing/plaf/multi/MultiListUI.java,\n+\tclasspath/javax/swing/plaf/multi/MultiSplitPaneUI.java,\n+\tclasspath/javax/swing/plaf/multi/MultiFileChooserUI.java,\n+\tclasspath/javax/swing/plaf/multi/MultiOptionPaneUI.java,\n+\tclasspath/javax/swing/plaf/multi/MultiTabbedPaneUI.java,\n+\tclasspath/javax/swing/plaf/multi/MultiLookAndFeel.java,\n+\tclasspath/javax/swing/plaf/metal/MetalSliderUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalIconFactory.java,\n+\tclasspath/javax/swing/plaf/metal/MetalComboBoxIcon.java,\n+\tclasspath/javax/swing/plaf/metal/MetalTabbedPaneUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalLookAndFeel.java,\n+\tclasspath/javax/swing/plaf/metal/MetalCheckBoxUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalSeparatorUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalBorders.java,\n+\tclasspath/javax/swing/plaf/metal/MetalSplitPaneDivider.java,\n+\tclasspath/javax/swing/plaf/metal/MetalScrollBarUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalRootPaneUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalInternalFrameUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalRadioButtonUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalToolTipUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalInternalFrameTitlePane.java,\n+\tclasspath/javax/swing/plaf/metal/MetalFileChooserUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalUtils.java,\n+\tclasspath/javax/swing/plaf/metal/MetalComboBoxButton.java,\n+\tclasspath/javax/swing/plaf/metal/MetalPopupMenuSeparatorUI.java,\n+\tclasspath/javax/swing/plaf/metal/MetalButtonUI.java,\n+\tclasspath/javax/swing/JPopupMenu.java,\n+\tclasspath/javax/swing/JProgressBar.java,\n+\tclasspath/javax/swing/WindowConstants.java,\n+\tclasspath/javax/swing/JFrame.java,\n+\tclasspath/javax/swing/JFileChooser.java,\n+\tclasspath/javax/swing/JComboBox.java,\n+\tclasspath/javax/swing/event/EventListenerList.java,\n+\tclasspath/javax/swing/ListSelectionModel.java,\n+\tclasspath/javax/swing/JScrollBar.java,\n+\tclasspath/java/text/SimpleDateFormat.java,\n+\tclasspath/java/text/NumberFormat.java,\n+\tclasspath/java/text/class-dependencies.conf,\n+\tclasspath/java/awt/image/ColorModel.java,\n+\tclasspath/java/awt/image/BufferedImage.java,\n+\tclasspath/java/awt/Window.java,\n+\tclasspath/java/awt/ContainerOrderFocusTraversalPolicy.java,\n+\tclasspath/java/awt/LightweightDispatcher.java,\n+\tclasspath/java/awt/EventDispatchThread.java,\n+\tclasspath/java/awt/BasicStroke.java,\n+\tclasspath/java/awt/ColorPaintContext.java,\n+\tclasspath/java/awt/Container.java,\n+\tclasspath/java/awt/TexturePaint.java,\n+\tclasspath/java/awt/Component.java, classpath/java/awt/Font.java,\n+\tclasspath/java/awt/GraphicsConfiguration.java,\n+\tclasspath/java/awt/DefaultKeyboardFocusManager.java,\n+\tclasspath/java/awt/print/PrinterJob.java,\n+\tclasspath/java/awt/im/InputContext.java,\n+\tclasspath/java/awt/dnd/DragGestureRecognizer.java,\n+\tclasspath/java/awt/Toolkit.java,\n+\tclasspath/java/awt/font/GraphicAttribute.java,\n+\tclasspath/java/awt/font/ImageGraphicAttribute.java,\n+\tclasspath/java/awt/font/GlyphVector.java,\n+\tclasspath/java/awt/font/GlyphMetrics.java,\n+\tclasspath/java/awt/font/ShapeGraphicAttribute.java,\n+\tclasspath/java/awt/Graphics2D.java,\n+\tclasspath/include/gnu_java_awt_peer_gtk_GdkGraphicsEnvironment.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_ComponentGraphics.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_CairoGraphics2D.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_FreetypeGlyphVector.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_GtkCanvasPeer.h,\n+\tclasspath/include/config.h.in,\n+\tclasspath/include/gnu_java_awt_peer_gtk_GdkTextLayout.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_GtkComponentPeer.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_GdkFontPeer.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_ComponentGraphicsCopy.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_GtkVolatileImage.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_GtkImage.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_CairoSurface.h,\n+\tclasspath/include/gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.h:\n+\tMerge from GNU Classpath HEAD.\n+\n 2006-06-08  Tom Tromey  <tromey@redhat.com>\n \n \t* gnu/classpath/natSystemProperties.cc (insertSystemProperties):"}, {"sha": "e17fd0aa4daf3b8889714e4f363e5cbbb4410a46", "filename": "libjava/Makefile.in", "status": "modified", "additions": 59, "deletions": 10, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -145,9 +145,10 @@ am__DEPENDENCIES_1 = gnu/awt.lo gnu/awt/j2d.lo gnu/classpath.lo \\\n \tgnu/gcj/util.lo gnu/java/awt.lo gnu/java/awt/color.lo \\\n \tgnu/java/awt/font.lo gnu/java/awt/font/opentype.lo \\\n \tgnu/java/awt/font/opentype/truetype.lo gnu/java/awt/image.lo \\\n-\tgnu/java/awt/java2d.lo gnu/java/awt/peer.lo gnu/java/io.lo \\\n-\tgnu/java/lang.lo gnu/java/lang/reflect.lo gnu/java/locale.lo \\\n-\tgnu/java/math.lo gnu/java/net.lo gnu/java/net/local.lo \\\n+\tgnu/java/awt/java2d.lo gnu/java/awt/peer.lo \\\n+\tgnu/java/awt/print.lo gnu/java/io.lo gnu/java/lang.lo \\\n+\tgnu/java/lang/reflect.lo gnu/java/locale.lo gnu/java/math.lo \\\n+\tgnu/java/net.lo gnu/java/net/local.lo \\\n \tgnu/java/net/protocol/core.lo gnu/java/net/protocol/file.lo \\\n \tgnu/java/net/protocol/ftp.lo gnu/java/net/protocol/gcjlib.lo \\\n \tgnu/java/net/protocol/http.lo gnu/java/net/protocol/https.lo \\\n@@ -189,7 +190,7 @@ am__DEPENDENCIES_1 = gnu/awt.lo gnu/awt/j2d.lo gnu/classpath.lo \\\n \tgnu/javax/print/ipp/attribute/supported.lo \\\n \tgnu/javax/security/auth.lo gnu/javax/security/auth/callback.lo \\\n \tgnu/javax/security/auth/login.lo gnu/javax/swing/plaf/gnu.lo \\\n-\tgnu/javax/swing/plaf/metal.lo \\\n+\tgnu/javax/swing/plaf/metal.lo gnu/javax/swing/text/html.lo \\\n \tgnu/javax/swing/text/html/parser.lo \\\n \tgnu/javax/swing/text/html/parser/models.lo \\\n \tgnu/javax/swing/text/html/parser/support.lo \\\n@@ -1256,12 +1257,14 @@ gnu_java_awt_java2d_source_files = \\\n classpath/gnu/java/awt/java2d/AbstractGraphics2D.java \\\n classpath/gnu/java/awt/java2d/AlphaCompositeContext.java \\\n classpath/gnu/java/awt/java2d/CubicSegment.java \\\n+classpath/gnu/java/awt/java2d/ImagePaint.java \\\n classpath/gnu/java/awt/java2d/LineSegment.java \\\n classpath/gnu/java/awt/java2d/PolyEdge.java \\\n classpath/gnu/java/awt/java2d/PolyEdgeComparator.java \\\n classpath/gnu/java/awt/java2d/QuadSegment.java \\\n classpath/gnu/java/awt/java2d/RasterGraphics.java \\\n-classpath/gnu/java/awt/java2d/Segment.java\n+classpath/gnu/java/awt/java2d/Segment.java \\\n+classpath/gnu/java/awt/java2d/TexturePaintContext.java\n \n gnu_java_awt_java2d_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_awt_java2d_source_files)))\n gnu_java_awt_peer_source_files = \\\n@@ -1272,13 +1275,17 @@ classpath/gnu/java/awt/peer/GLightweightPeer.java\n \n gnu_java_awt_peer_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_awt_peer_source_files)))\n gnu_java_awt_peer_gtk_source_files = \\\n+classpath/gnu/java/awt/peer/gtk/BufferedImageGraphics.java \\\n+classpath/gnu/java/awt/peer/gtk/CairoGraphics2D.java \\\n+classpath/gnu/java/awt/peer/gtk/CairoSurface.java \\\n+classpath/gnu/java/awt/peer/gtk/CairoSurfaceGraphics.java \\\n+classpath/gnu/java/awt/peer/gtk/ComponentGraphics.java \\\n+classpath/gnu/java/awt/peer/gtk/ComponentGraphicsCopy.java \\\n+classpath/gnu/java/awt/peer/gtk/FreetypeGlyphVector.java \\\n classpath/gnu/java/awt/peer/gtk/GThreadMutex.java \\\n classpath/gnu/java/awt/peer/gtk/GThreadNativeMethodRunner.java \\\n classpath/gnu/java/awt/peer/gtk/GdkFontMetrics.java \\\n classpath/gnu/java/awt/peer/gtk/GdkFontPeer.java \\\n-classpath/gnu/java/awt/peer/gtk/GdkGlyphVector.java \\\n-classpath/gnu/java/awt/peer/gtk/GdkGraphics.java \\\n-classpath/gnu/java/awt/peer/gtk/GdkGraphics2D.java \\\n classpath/gnu/java/awt/peer/gtk/GdkGraphicsConfiguration.java \\\n classpath/gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java \\\n classpath/gnu/java/awt/peer/gtk/GdkPixbufDecoder.java \\\n@@ -1318,7 +1325,8 @@ classpath/gnu/java/awt/peer/gtk/GtkTextAreaPeer.java \\\n classpath/gnu/java/awt/peer/gtk/GtkTextFieldPeer.java \\\n classpath/gnu/java/awt/peer/gtk/GtkToolkit.java \\\n classpath/gnu/java/awt/peer/gtk/GtkVolatileImage.java \\\n-classpath/gnu/java/awt/peer/gtk/GtkWindowPeer.java\n+classpath/gnu/java/awt/peer/gtk/GtkWindowPeer.java \\\n+classpath/gnu/java/awt/peer/gtk/VolatileImageGraphics.java\n \n gnu_java_awt_peer_qt_source_files = \\\n classpath/gnu/java/awt/peer/qt/MainQtThread.java \\\n@@ -1381,6 +1389,13 @@ classpath/gnu/java/awt/peer/swing/SwingTextFieldPeer.java \\\n classpath/gnu/java/awt/peer/swing/SwingToolkit.java \\\n classpath/gnu/java/awt/peer/swing/SwingWindowPeer.java\n \n+gnu_java_awt_print_source_files = \\\n+classpath/gnu/java/awt/print/JavaPrinterGraphics.java \\\n+classpath/gnu/java/awt/print/JavaPrinterJob.java \\\n+classpath/gnu/java/awt/print/PostScriptGraphics2D.java \\\n+classpath/gnu/java/awt/print/SpooledDocument.java\n+\n+gnu_java_awt_print_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_awt_print_source_files)))\n gnu_java_beans_source_files = \\\n classpath/gnu/java/beans/BeanInfoEmbryo.java \\\n classpath/gnu/java/beans/DefaultExceptionListener.java \\\n@@ -2718,8 +2733,15 @@ gnu_javax_swing_plaf_metal_source_files = \\\n classpath/gnu/javax/swing/plaf/metal/CustomizableTheme.java\n \n gnu_javax_swing_plaf_metal_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_javax_swing_plaf_metal_source_files)))\n+gnu_javax_swing_text_html_source_files = \\\n+classpath/gnu/javax/swing/text/html/CharacterAttributeTranslator.java \\\n+classpath/gnu/javax/swing/text/html/CombinedAttributes.java \\\n+classpath/gnu/javax/swing/text/html/ImageViewIconFactory.java\n+\n+gnu_javax_swing_text_html_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_javax_swing_text_html_source_files)))\n gnu_javax_swing_text_html_parser_source_files = \\\n classpath/gnu/javax/swing/text/html/parser/HTML_401F.java \\\n+classpath/gnu/javax/swing/text/html/parser/SmallHtmlAttributeSet.java \\\n classpath/gnu/javax/swing/text/html/parser/gnuDTD.java \\\n classpath/gnu/javax/swing/text/html/parser/htmlAttributeSet.java \\\n classpath/gnu/javax/swing/text/html/parser/htmlValidator.java\n@@ -5353,7 +5375,8 @@ classpath/javax/swing/plaf/basic/BasicToolTipUI.java \\\n classpath/javax/swing/plaf/basic/BasicTreeUI.java \\\n classpath/javax/swing/plaf/basic/BasicViewportUI.java \\\n classpath/javax/swing/plaf/basic/ComboPopup.java \\\n-classpath/javax/swing/plaf/basic/DefaultMenuLayout.java\n+classpath/javax/swing/plaf/basic/DefaultMenuLayout.java \\\n+classpath/javax/swing/plaf/basic/SharedUIDefaults.java\n \n javax_swing_plaf_basic_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(javax_swing_plaf_basic_source_files)))\n javax_swing_plaf_metal_source_files = \\\n@@ -5531,8 +5554,10 @@ classpath/javax/swing/text/html/HTMLDocument.java \\\n classpath/javax/swing/text/html/HTMLEditorKit.java \\\n classpath/javax/swing/text/html/HTMLFrameHyperlinkEvent.java \\\n classpath/javax/swing/text/html/HTMLTableView.java \\\n+classpath/javax/swing/text/html/ImageView.java \\\n classpath/javax/swing/text/html/InlineView.java \\\n classpath/javax/swing/text/html/ListView.java \\\n+classpath/javax/swing/text/html/MinimalHTMLWriter.java \\\n classpath/javax/swing/text/html/NullView.java \\\n classpath/javax/swing/text/html/ObjectView.java \\\n classpath/javax/swing/text/html/Option.java \\\n@@ -6476,6 +6501,7 @@ all_packages_source_files = \\\n   gnu/java/awt/image.list \\\n   gnu/java/awt/java2d.list \\\n   gnu/java/awt/peer.list \\\n+  gnu/java/awt/print.list \\\n   gnu/java/io.list \\\n   gnu/java/lang.list \\\n   gnu/java/lang/reflect.list \\\n@@ -6563,6 +6589,7 @@ all_packages_source_files = \\\n   gnu/javax/security/auth/login.list \\\n   gnu/javax/swing/plaf/gnu.list \\\n   gnu/javax/swing/plaf/metal.list \\\n+  gnu/javax/swing/text/html.list \\\n   gnu/javax/swing/text/html/parser.list \\\n   gnu/javax/swing/text/html/parser/models.list \\\n   gnu/javax/swing/text/html/parser/support.list \\\n@@ -6693,6 +6720,7 @@ ordinary_header_files = \\\n   $(gnu_java_awt_image_header_files) \\\n   $(gnu_java_awt_java2d_header_files) \\\n   $(gnu_java_awt_peer_header_files) \\\n+  $(gnu_java_awt_print_header_files) \\\n   $(gnu_java_io_header_files) \\\n   $(gnu_java_lang_header_files) \\\n   $(gnu_java_lang_reflect_header_files) \\\n@@ -6780,6 +6808,7 @@ ordinary_header_files = \\\n   $(gnu_javax_security_auth_login_header_files) \\\n   $(gnu_javax_swing_plaf_gnu_header_files) \\\n   $(gnu_javax_swing_plaf_metal_header_files) \\\n+  $(gnu_javax_swing_text_html_header_files) \\\n   $(gnu_javax_swing_text_html_parser_header_files) \\\n   $(gnu_javax_swing_text_html_parser_models_header_files) \\\n   $(gnu_javax_swing_text_html_parser_support_header_files) \\\n@@ -8989,6 +9018,16 @@ gnu-java-awt-peer-swing.lo: $(gnu_java_awt_peer_swing_source_files)\n \t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-awt-peer-swing.lo @gnu-java-awt-peer-swing.list\n \t@rm -f gnu-java-awt-peer-swing.list\n \n+gnu/java/awt/print.list: $(gnu_java_awt_print_source_files)\n+\t@$(mkinstalldirs) $(dir $@)\n+\t@for file in $(gnu_java_awt_print_source_files); do \\\n+\t  if test -f $(srcdir)/$$file; then \\\n+\t    echo $(srcdir)/$$file; \\\n+\t  else echo $$file; fi; \\\n+\tdone > gnu/java/awt/print.list\n+\n+-include gnu/java/awt/print.deps\n+\n gnu-java-beans.lo: $(gnu_java_beans_source_files)\n \t@find classpath/lib/gnu/java/beans -name '*.class' > gnu-java-beans.list\n \t$(LTGCJCOMPILE) -fjni -findirect-dispatch -fno-indirect-classes -c -o gnu-java-beans.lo @gnu-java-beans.list\n@@ -9874,6 +9913,16 @@ gnu/javax/swing/plaf/metal.list: $(gnu_javax_swing_plaf_metal_source_files)\n \n -include gnu/javax/swing/plaf/metal.deps\n \n+gnu/javax/swing/text/html.list: $(gnu_javax_swing_text_html_source_files)\n+\t@$(mkinstalldirs) $(dir $@)\n+\t@for file in $(gnu_javax_swing_text_html_source_files); do \\\n+\t  if test -f $(srcdir)/$$file; then \\\n+\t    echo $(srcdir)/$$file; \\\n+\t  else echo $$file; fi; \\\n+\tdone > gnu/javax/swing/text/html.list\n+\n+-include gnu/javax/swing/text/html.deps\n+\n gnu/javax/swing/text/html/parser.list: $(gnu_javax_swing_text_html_parser_source_files)\n \t@$(mkinstalldirs) $(dir $@)\n \t@for file in $(gnu_javax_swing_text_html_parser_source_files); do \\"}, {"sha": "2f99e810e1a73cce27b9430152b94fe2e352a026", "filename": "libjava/classpath/Makefile.in", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -39,9 +39,9 @@ target_triplet = @target@\n DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \\\n \t$(srcdir)/Makefile.in $(top_srcdir)/configure \\\n \t$(top_srcdir)/gnu/classpath/Configuration.java.in AUTHORS \\\n-\tCOPYING ChangeLog INSTALL NEWS TODO config.guess config.sub \\\n-\tdepcomp install-sh ltcf-c.sh ltcf-cxx.sh ltcf-gcj.sh ltconfig \\\n-\tltmain.sh missing mkinstalldirs\n+\tCOPYING ChangeLog INSTALL NEWS TODO compile config.guess \\\n+\tconfig.sub depcomp install-sh ltcf-c.sh ltcf-cxx.sh \\\n+\tltcf-gcj.sh ltconfig ltmain.sh missing mkinstalldirs\n subdir = .\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n am__aclocal_m4_deps = $(top_srcdir)/../../libtool.m4 \\\n@@ -89,8 +89,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -117,8 +115,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -141,6 +143,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -156,9 +160,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -180,6 +183,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -193,6 +197,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -206,6 +212,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -225,11 +232,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "adb5cbb7cc9dcd074389a90e97cf0ad1ce338574", "filename": "libjava/classpath/configure", "status": "modified", "additions": 3252, "deletions": 2646, "changes": 5898, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfigure?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "65980fdff05844b640899349301f5d8e75a945b5", "filename": "libjava/classpath/configure.ac", "status": "modified", "additions": 101, "deletions": 37, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fconfigure.ac?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -6,7 +6,7 @@ dnl -----------------------------------------------------------\n dnl define([AC_CACHE_LOAD], )dnl\n dnl define([AC_CACHE_SAVE], )dnl\n \n-AC_INIT([GNU Classpath],[0.91],[classpath@gnu.org],[classpath])\n+AC_INIT([GNU Classpath],[0.92-pre],[classpath@gnu.org],[classpath])\n AC_CONFIG_SRCDIR(java/lang/System.java)\n \n AC_CANONICAL_TARGET\n@@ -41,9 +41,6 @@ AM_INIT_AUTOMAKE([1.9.0 gnu std-options tar-ustar])\n AC_CONFIG_HEADERS([include/config.h])\n AC_PREFIX_DEFAULT(/usr/local/classpath)\n \n-dnl GCC LOCAL\n-GCC_NO_EXECUTABLES\n-\n dnl -----------------------------------------------------------\n dnl Enable collections.jar (disabled by default)\n dnl -----------------------------------------------------------\n@@ -168,23 +165,6 @@ dnl GTK native peer error checking\n dnl -----------------------------------------------------------\n AC_ARG_ENABLE([gtk-peers],,AC_MSG_ERROR([No --enable-gtk-peers (or --disable-gtk-peers) option; you want --enable-gtk-peer]))\n \n-dnl ------------------------------------------------------------\n-dnl determine whether to enable the cairo GTK Graphics2D backend\n-dnl ------------------------------------------------------------\n-AC_ARG_ENABLE([gtk-cairo],\n-              [AS_HELP_STRING(--enable-gtk-cairo,build the cairo Graphics2D implementation on GTK [default=no])],\n-              [case \"${enableval}\" in\n-                yes) GTK_CAIRO_ENABLED=true ;;\n-                no) GTK_CAIRO_ENABLED=false ;;\n-                *) GTK_CAIRO_ENABLED=true ;;\n-              esac],\n-              [GTK_CAIRO_ENABLED=false])\n-AC_SUBST(GTK_CAIRO_ENABLED)\n-if test \"x${GTK_CAIRO_ENABLED}\" = xtrue; then\n-  AC_DEFINE(GTK_CAIRO, 1, [defined if cairo support was built in])\n-fi\n-AM_CONDITIONAL(GTK_CAIRO, test \"x${GTK_CAIRO_ENABLED}\" = xtrue)\n-\n dnl -----------------------------------------------------------\n dnl Qt native peer (disabled by default)\n dnl -----------------------------------------------------------\n@@ -198,12 +178,24 @@ AC_ARG_ENABLE([qt-peer],\n               [COMPILE_QT_PEER=no])\n AM_CONDITIONAL(CREATE_QT_PEER_LIBRARIES, test \"x${COMPILE_QT_PEER}\" = xyes)\n \n+dnl -----------------------------------------------------------\n+dnl Plugin (enabled by default)\n+dnl -----------------------------------------------------------\n+AC_ARG_ENABLE([plugin],\n+              [AS_HELP_STRING(--disable-plugin,compile gcjwebplugin (disabled by --disable-plugin) [default=yes])],\n+              [case \"${enableval}\" in\n+                yes) COMPILE_PLUGIN=yes ;;\n+                no) COMPILE_PLUGIN=no ;;\n+                *) COMPILE_PLUGIN=yes ;;\n+              esac],\n+              [COMPILE_PLUGIN=yes])\n+AM_CONDITIONAL(CREATE_PLUGIN, test \"x${COMPILE_PLUGIN}\" = xyes)\n \n dnl -----------------------------------------------------------\n dnl Sets the native libraries installation dir\n dnl -----------------------------------------------------------\n AC_ARG_WITH([native-libdir],\n-\t    [AS_HELP_STRING(--with-native-libdir,sets the installation directore for native libraries [default='${libdir}/${PACKAGE}'])],\n+\t    [AS_HELP_STRING(--with-native-libdir,sets the installation directory for native libraries [default='${libdir}/${PACKAGE}'])],\n \t    [\n \t     nativeexeclibdir=${withval}\n \t    ],\n@@ -227,6 +219,21 @@ AC_ARG_WITH([glibj-dir],\n \n AC_SUBST(glibjdir)\n \n+dnl -----------------------------------------------------------\n+dnl Sets the VM name for use in tool wrapper scripts\n+dnl -----------------------------------------------------------\n+AC_ARG_WITH([vm],\n+\t    [AS_HELP_STRING(--with-vm,sets the VM binary name [default='${prefix}/bin/jamvm'])],\n+\t    [\n+\t     VM_BINARY=${withval}\n+\t    ],\n+\t    [\n+\t     VM_BINARY='${prefix}/bin/jamvm'\n+\t    ])\n+\n+AC_SUBST(VM_BINARY)\n+AM_CONDITIONAL(FOUND_CACAO, test \"x`basename $VM_BINARY`\" = xcacao)\n+\n dnl -----------------------------------------------------------\n dnl Regenerate headers at build time (disabled by default)\n dnl -----------------------------------------------------------\n@@ -240,20 +247,33 @@ AC_ARG_ENABLE([regen-headers],\n               [REGENERATE_JNI_HEADERS=no])\n AM_CONDITIONAL(CREATE_JNI_HEADERS, test \"x${REGENERATE_JNI_HEADERS}\" = xyes)\n \n+dnl -----------------------------------------------------------\n+dnl Enable tool wrapper binaries (disabled by default)\n+dnl -----------------------------------------------------------\n+AC_ARG_ENABLE([tool-wrappers],\n+              [AS_HELP_STRING(--enable-tool-wrappers,create tool wrapper binaries [default=no])],\n+              [case x\"${enableval}\" in\n+                xyes) COMPILE_WRAPPERS=yes ;;\n+                xno) COMPILE_WRAPPERS=no ;;\n+\t\tx) COMPILE_WRAPPERS=yes ;;\n+                *) COMPILE_WRAPPERS=yes ;;\n+              esac],\n+              [COMPILE_WRAPPERS=no])\n+AM_CONDITIONAL(CREATE_WRAPPERS, test \"x${COMPILE_WRAPPERS}\" = xyes)\n+\n AC_PROG_LN_S\n AC_PROG_INSTALL\n \n dnl -----------------------------------------------------------\n dnl Checks for programs.\n dnl -----------------------------------------------------------\n-\n+AC_PROG_CXX\n dnl Initialize libtool\n AC_DISABLE_STATIC\n AC_PROG_LIBTOOL\n dnl AC_PROG_AWK\n AC_PROG_CC\n AC_PROG_CPP\n-AC_PROG_CXX\n \n if test \"x${COMPILE_COLLECTIONS}\" = xyes; then\n   AC_PATH_PROG(PERL, [perl])\n@@ -284,7 +304,8 @@ if test \"x${COMPILE_JNI}\" = xyes; then\n \t\t    sys/select.h \\\n \t\t    crt_externs.h \\\n                     fcntl.h \\\n-\t\t    sys/mman.h])\n+\t\t    sys/mman.h \\\n+\t\t    magic.h])\n \n   AC_EGREP_HEADER(uint32_t, stdint.h, AC_DEFINE(HAVE_INT32_DEFINED, 1, [Define to 1 if you have uint32_t]))\n   AC_EGREP_HEADER(uint32_t, inttypes.h, AC_DEFINE(HAVE_INT32_DEFINED, 1, [Define to 1 if you have uint32_t]))\n@@ -300,8 +321,13 @@ if test \"x${COMPILE_JNI}\" = xyes; then\n \t\t  strerror_r \\\n                   fcntl \\\n \t\t  mmap munmap mincore msync madvise getpagesize sysconf \\\n+\t\t  lstat readlink \\\n \t\t  ])\n \n+  LIBMAGIC=\n+  AC_CHECK_LIB(magic, magic_open, LIBMAGIC=-lmagic)\n+  AC_SUBST(LIBMAGIC)\n+\n   AC_HEADER_TIME\n   AC_STRUCT_TM\n   AC_STRUCT_TIMEZONE\n@@ -375,26 +401,35 @@ if test \"x${COMPILE_JNI}\" = xyes; then\n         AC_MSG_ERROR([GTK+ peers requested but no X library available])\n     fi\n     dnl We explicitly want the XTest Extension for Robot support.\n-    AC_CHECK_LIB([Xtst], [XTestQueryExtension], [true],\n-       \t  [AC_MSG_ERROR([libXtst NOT found, required for GdkRobot])],\n-       \t  [${X_LIBS}])\n-    PKG_CHECK_MODULES(GTK, gtk+-2.0 >= 2.4 gthread-2.0 >= 2.2 gdk-pixbuf-2.0)\n-\n-    if test \"x${enable_gtk_cairo}\" = xyes; then\n-      PKG_CHECK_MODULES(CAIRO, cairo >= 0.5.0)\n-    fi\n+    AC_CHECK_LIB([Xtst], [XTestQueryExtension],\n+    \t\t [XTEST_LIBS=\"$XTEST_LIBS -lX11 -lXtst\"],\n+\t\t [AC_MSG_ERROR([libXtst NOT found, required for GdkRobot])],\n+\t\t [${X_LIBS}])\n \n+    PKG_CHECK_MODULES(GTK, gtk+-2.0 >= 2.8 gthread-2.0 >= 2.2 gdk-pixbuf-2.0)\n     PKG_CHECK_MODULES(FREETYPE2, freetype2)\n     PKG_CHECK_MODULES(PANGOFT2, pangoft2)\n+    dnl Check if we can link against the XRender library and set\n+    dnl HAVE_XRENDER accordingly.\n+    AC_CHECK_LIB([Xrender], [XRenderQueryExtension],\n+\t\t [AC_DEFINE(HAVE_XRENDER, 1, [Define to 1 if you have libXrender.])[X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lXrender\"]],\n+\t\t [true],\n+\t\t [${X_LIBS}])\n+\n+    dnl Check if we can link against the XRandR library and set\n+    dnl HAVE_XRANDR accordingly.\n+    AC_CHECK_LIB([Xrandr], [XRRQueryExtension],\n+                 [AC_DEFINE(HAVE_XRANDR, 1, [Define to 1 if you have libXrandr.])[X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lXrandr\"]],\n+                 [true],\n+                 [${X_LIBS}])\n \n     AC_SUBST(GTK_CFLAGS)\n     AC_SUBST(GTK_LIBS)\n-    AC_SUBST(CAIRO_LIBS)\n-    AC_SUBST(CAIRO_CFLAGS)\n     AC_SUBST(FREETYPE2_LIBS)\n     AC_SUBST(FREETYPE2_CFLAGS)\n     AC_SUBST(PANGOFT2_LIBS)\n     AC_SUBST(PANGOFT2_CFLAGS)\n+    AC_SUBST(XTEST_LIBS)\n   fi\n \n   dnl Check for AWT related Qt4\n@@ -445,6 +480,25 @@ if test \"x${COMPILE_JNI}\" = xyes; then\n     AC_SUBST(QT_CFLAGS)\n     AC_SUBST(QT_LIBS)\n   fi\n+\n+  dnl Check for plugin support headers and libraries.\n+  if test \"x${COMPILE_PLUGIN}\" = xyes; then\n+    PKG_CHECK_MODULES(MOZILLA, mozilla-plugin, [MOZILLA_FOUND=yes], [MOZILLA_FOUND=no])\n+    if test \"x${MOZILLA_FOUND}\" = xno; then\n+      PKG_CHECK_MODULES(MOZILLA, firefox-plugin, [MOZILLA_FOUND=yes], [MOZILLA_FOUND=no])\n+    fi\n+    if test \"x${MOZILLA_FOUND}\" = xno; then\n+      PKG_CHECK_MODULES(MOZILLA, xulrunner-plugin, [MOZILLA_FOUND=yes], [MOZILLA_FOUND=no])\n+    fi\n+    PKG_CHECK_MODULES(GLIB, glib-2.0)\n+\n+    AC_SUBST(MOZILLA_CFLAGS)\n+    AC_SUBST(MOZILLA_LIBS)\n+    AC_SUBST(GLIB_CFLAGS)\n+    AC_SUBST(GLIB_LIBS)\n+\n+    AC_SUBST(PLUGIN_DIR, $HOME/.mozilla/plugins/)\n+  fi\n fi\n \n CLASSPATH_WITH_JAVAH\n@@ -669,6 +723,7 @@ native/jni/qt-peer/Makefile\n native/jni/xmlj/Makefile\n native/jni/midi-alsa/Makefile\n native/jni/midi-dssi/Makefile\n+native/plugin/Makefile\n native/target/Makefile\n native/target/Linux/Makefile\n native/target/generic/Makefile\n@@ -679,10 +734,19 @@ lib/Makefile\n lib/gen-classlist.sh\n lib/copy-vmresources.sh\n tools/Makefile\n-tools/jarsigner.sh\n-tools/keytool.sh\n examples/Makefile\n examples/Makefile.jawt])\n+\n+if test \"x${COMPILE_WRAPPERS}\" = xno\n+then\n+AC_CONFIG_FILES([tools/appletviewer\n+tools/jarsigner\n+tools/keytool])\n+AC_CONFIG_COMMANDS([appletviewer],[chmod 755 tools/appletviewer])\n+AC_CONFIG_COMMANDS([jarsigner],[chmod 755 tools/jarsigner])\n+AC_CONFIG_COMMANDS([keytool],[chmod 755 tools/keytool])\n+fi\n+\n AC_CONFIG_COMMANDS([gen-classlist],[chmod 755 lib/gen-classlist.sh])\n AC_CONFIG_COMMANDS([copy-vmresources],[chmod 755 lib/copy-vmresources.sh])\n AC_OUTPUT"}, {"sha": "0a17afee1c195fb62dd568fce8bd7c1261578986", "filename": "libjava/classpath/doc/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fdoc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fdoc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -73,8 +73,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -101,8 +99,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -125,6 +127,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -140,9 +144,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -164,6 +167,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -177,6 +181,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -190,6 +196,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -209,11 +216,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "ad4956ce93c456eeb09ffb6b4ce30c3893a84608", "filename": "libjava/classpath/doc/api/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fdoc%2Fapi%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -66,8 +66,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -94,8 +92,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -118,6 +120,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -133,9 +137,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -157,6 +160,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -170,6 +174,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -183,6 +189,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -202,11 +209,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "d8336a98bf30d22a9e2cc254fab247317e60b0f2", "filename": "libjava/classpath/examples/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexamples%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexamples%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexamples%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -75,8 +75,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -103,8 +101,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -127,6 +129,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -142,9 +146,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -166,6 +169,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -179,6 +183,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -192,6 +198,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -211,11 +218,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "23279c2ee950c8584ce1471e5ab2ef7b333ad202", "filename": "libjava/classpath/external/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexternal%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexternal%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -73,8 +73,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -101,8 +99,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -125,6 +127,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -140,9 +144,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -164,6 +167,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -177,6 +181,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -190,6 +196,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -209,11 +216,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "cc063ac9b67f70635078e2735b4cdd2efccdf22d", "filename": "libjava/classpath/external/relaxngDatatype/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexternal%2FrelaxngDatatype%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexternal%2FrelaxngDatatype%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2FrelaxngDatatype%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -64,8 +64,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -92,8 +90,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -116,6 +118,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -131,9 +135,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -155,6 +158,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -168,6 +172,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -181,6 +187,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -200,11 +207,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "cd04e16ff0772640a2bf0329871407eb446cf4bf", "filename": "libjava/classpath/external/sax/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexternal%2Fsax%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexternal%2Fsax%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fsax%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -64,8 +64,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -92,8 +90,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -116,6 +118,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -131,9 +135,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -155,6 +158,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -168,6 +172,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -181,6 +187,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -200,11 +207,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "7e61f759deebcb41d6ea6b9f673be3b8b201477e", "filename": "libjava/classpath/external/w3c_dom/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexternal%2Fw3c_dom%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fexternal%2Fw3c_dom%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fexternal%2Fw3c_dom%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -64,8 +64,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -92,8 +90,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -116,6 +118,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -131,9 +135,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -155,6 +158,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -168,6 +172,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -181,6 +187,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -200,11 +207,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "7f490d529519eb74cc1efa960343846bb6ae8a5f", "filename": "libjava/classpath/gnu/classpath/Configuration.java.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fclasspath%2FConfiguration.java.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fclasspath%2FConfiguration.java.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fclasspath%2FConfiguration.java.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -95,10 +95,4 @@ public interface Configuration\n    */\n   boolean JAVA_LANG_SYSTEM_EXPLICIT_INITIALIZATION = \n \t  @JAVA_LANG_SYSTEM_EXPLICIT_INITIALIZATION@;\n-\n-  /**\n-   * Set to true if Cairo was found and enabled during configure,\n-   * false otherwise.\n-   */\n-  boolean GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@;\n }"}, {"sha": "9205df1ddbde961caf117e1e5200a595e2da0632", "filename": "libjava/classpath/gnu/java/awt/BitwiseXORComposite.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2FBitwiseXORComposite.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2FBitwiseXORComposite.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2FBitwiseXORComposite.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -59,7 +59,7 @@\n  * />\n  *\n  * <p>The above screen shot shows the result of applying six different\n- * BitwiseXORComposites. They were constructed with the colors colors\n+ * BitwiseXORComposites. They were constructed with the colors\n  * white, blue, black, orange, green, and brown, respectively. Each\n  * composite was used to paint a fully white rectangle on top of the\n  * blue bar in the background."}, {"sha": "2015634bbf5de62607c229d21410634a03774421", "filename": "libjava/classpath/gnu/java/awt/Buffers.java", "status": "modified", "additions": 35, "deletions": 53, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2FBuffers.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2FBuffers.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2FBuffers.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -144,25 +144,7 @@ public static DataBuffer createBufferFromData(int dataType, Object data,\n    */\n   public static Object getData(DataBuffer buffer)\n   {\n-    if (buffer instanceof DataBufferByte)\n-      return ((DataBufferByte) buffer).getData();\n-\n-    if (buffer instanceof DataBufferShort)\n-      return ((DataBufferShort) buffer).getData();\n-\n-    if (buffer instanceof DataBufferUShort)\n-      return ((DataBufferUShort) buffer).getData();\n-\n-    if (buffer instanceof DataBufferInt)\n-      return ((DataBufferInt) buffer).getData();\n-\n-    if (buffer instanceof DataBufferFloat)\n-      return ((DataBufferFloat) buffer).getData();\n-\n-    if (buffer instanceof DataBufferDouble)\n-      return ((DataBufferDouble) buffer).getData();\n-\n-    throw new ClassCastException(\"Unknown data buffer type\");\n+    return getData(buffer, 0, null, 0, buffer.getSize());\n   }\n \n     \n@@ -172,46 +154,46 @@ public static Object getData(DataBuffer buffer)\n    * given destination array is null.\n    */\n   public static Object getData(DataBuffer src, int srcOffset,\n-\t\t\t       Object dest,  int destOffset,\n+\t\t\t       Object dest,  int dstOffset,\n \t\t\t       int length)\n   {\n     Object from;\n-    if (src instanceof DataBufferByte)\n-      {\n-\tfrom = ((DataBufferByte) src).getData();\n-\tif (dest == null) dest = new byte[length+destOffset];\n-      }\n-    else if (src instanceof DataBufferShort)\n-      {\n-\tfrom = ((DataBufferShort) src).getData();\n-\tif (dest == null) dest = new short[length+destOffset];\n-      }\n-    else if (src instanceof DataBufferUShort)\n-      {\n-\tfrom = ((DataBufferUShort) src).getData();\n-\tif (dest == null) dest = new short[length+destOffset];\n-      }\n-    else if (src instanceof DataBufferInt)\n-      {\n-\tfrom = ((DataBufferInt) src).getData();\n-\tif (dest == null) dest = new int[length+destOffset];\n-      }\n-    else if (src instanceof DataBufferFloat)\n-      {\n-\tfrom = ((DataBufferFloat) src).getData();\n-\tif (dest == null) dest = new float[length+destOffset];\n-      }\n-    else if (src instanceof DataBufferDouble)\n-      {\n-\tfrom = ((DataBufferDouble) src).getData();\n-\tif (dest == null) dest = new double[length+destOffset];\n-      }\n-    else\n+    switch(src.getDataType())\n       {\n+      case DataBuffer.TYPE_BYTE:\n+\tif (dest == null) dest = new byte[length+dstOffset];\n+\tfor(int i = 0; i < length; i++)\n+\t  ((byte[])dest)[i + dstOffset] = (byte)src.getElem(i + srcOffset);\n+\tbreak;\n+\n+      case DataBuffer.TYPE_DOUBLE:\n+\tif (dest == null) dest = new double[length+dstOffset];\n+\tfor(int i = 0; i < length; i++)\n+\t  ((double[])dest)[i + dstOffset] = src.getElemDouble(i + srcOffset);\n+\tbreak;\n+\n+      case DataBuffer.TYPE_FLOAT:\n+\tif (dest == null) dest = new float[length+dstOffset];\n+\tfor(int i = 0; i < length; i++)\n+\t  ((float[])dest)[i + dstOffset] = src.getElemFloat(i + srcOffset);\n+\tbreak;\n+\n+      case DataBuffer.TYPE_INT:\n+\tif (dest == null) dest = new int[length+dstOffset];\n+\tfor(int i = 0; i < length; i++)\n+\t  ((int[])dest)[i + dstOffset] = src.getElem(i + srcOffset);\n+\tbreak;\n+\n+      case DataBuffer.TYPE_SHORT:\n+      case DataBuffer.TYPE_USHORT:\n+\tif (dest == null) dest = new short[length+dstOffset];\n+\tfor(int i = 0; i < length; i++)\n+\t  ((short[])dest)[i + dstOffset] = (short)src.getElem(i + srcOffset);\n+\tbreak;\n+\n+      case DataBuffer.TYPE_UNDEFINED:\n \tthrow new ClassCastException(\"Unknown data buffer type\");\n       }\n-    \n-    System.arraycopy(from, srcOffset, dest, destOffset, length);\n     return dest;\n   }\n   "}, {"sha": "f17a4511375de1df8b72ab3522c83029e21d2e34", "filename": "libjava/classpath/gnu/java/awt/font/GNUGlyphVector.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Ffont%2FGNUGlyphVector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Ffont%2FGNUGlyphVector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Ffont%2FGNUGlyphVector.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -110,7 +110,7 @@ public GNUGlyphVector(FontDelegate fontDelegate,\n     \n     fontSize = font.getSize2D();\n     transform = font.getTransform(); // returns a modifiable copy\n-    transform.concatenate(renderContext.getTransform());\n+    //transform.concatenate(renderContext.getTransform());\n   }\n \n "}, {"sha": "e4ea202bb6cacbdc7d2dfc7922ba45d1e5e344b4", "filename": "libjava/classpath/gnu/java/awt/font/opentype/NameDecoder.java", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Ffont%2Fopentype%2FNameDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Ffont%2Fopentype%2FNameDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Ffont%2Fopentype%2FNameDecoder.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -48,7 +48,7 @@\n  *\n  * @author Sascha Brawer (brawer@dandelis.ch)\n  */\n-class NameDecoder\n+public class NameDecoder\n {\n   public static final int NAME_COPYRIGHT = 0;\n \n@@ -122,27 +122,38 @@ public static String getName(ByteBuffer nameTable,\n \n     nameTable.position(0);\n     /* We understand only format 0 of the name table. */\n-    if (nameTable.getChar() != 0)\n+    if (nameTable.getShort() != 0)\n       return null;\n \n     macLanguage = getMacLanguageCode(locale);\n     msLanguage = getMicrosoftLanguageCode(locale);\n-    numRecords = nameTable.getChar();\n-    offset = nameTable.getChar();\n+    numRecords = nameTable.getShort();\n+    offset = nameTable.getShort();\n \n     for (int i = 0; i < numRecords; i++)\n     {\n-      namePlatform = nameTable.getChar();\n-      nameEncoding = nameTable.getChar();\n-      nameLanguage = nameTable.getChar();\n-      nameID = nameTable.getChar();\n-      nameLen = nameTable.getChar();\n-      nameStart = offset + nameTable.getChar();\n+      namePlatform = nameTable.getShort();\n+      nameEncoding = nameTable.getShort();\n+      nameLanguage = nameTable.getShort();\n+      nameID = nameTable.getShort();\n+      nameLen = nameTable.getShort();\n+      nameStart = offset + nameTable.getShort();\n \n       \n       if (nameID != name)\n         continue;\n \n+      // Handle PS seperately as it can be only ASCII, although\n+      // possibly encoded as UTF-16BE\n+      if ( name == NAME_POSTSCRIPT )\n+\t{\n+\t  if( nameTable.get(nameStart) == 0 ) // Peek at top byte\n+\t    result = decodeName(\"UTF-16BE\", nameTable, nameStart, nameLen);\n+\t  else\n+\t    result = decodeName(\"ASCII\", nameTable, nameStart, nameLen);\n+\t  return result;\n+\t}\n+\n       match = false;\n       switch (namePlatform)\n       {\n@@ -393,14 +404,19 @@ private static int findLanguageCode(String lang, String langCodes)\n   private static String decodeName(int platform, int encoding, int language,\n                                    ByteBuffer buffer, int offset, int len)\n   {\n-    byte[] byteBuf;\n-    String charsetName;\n-    int oldPosition;\n-\n-    charsetName = getCharsetName(platform, language, encoding);\n+    String charsetName = getCharsetName(platform, language, encoding);\n     if (charsetName == null)\n       return null;\n \n+    return decodeName(charsetName, buffer, offset, len);\n+  }\n+\n+  private static String decodeName(String charsetName,\n+                                   ByteBuffer buffer, int offset, int len)\n+  {\n+    byte[] byteBuf;\n+    int oldPosition;\n+\n     byteBuf = new byte[len];\n     oldPosition = buffer.position();\n     try"}, {"sha": "7df9949e68e9723fbf372a4cdb52e24fe9bdf9f0", "filename": "libjava/classpath/gnu/java/awt/java2d/AbstractGraphics2D.java", "status": "modified", "additions": 642, "deletions": 360, "changes": 1002, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FAbstractGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FAbstractGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FAbstractGraphics2D.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -84,7 +84,48 @@\n import java.util.Map;\n \n /**\n- * Implements general and shared behaviour for Graphics2D implementation.\n+ * This is a 100% Java implementation of the Java2D rendering pipeline. It is\n+ * meant as a base class for Graphics2D implementations.\n+ *\n+ * <h2>Backend interface</h2>\n+ * <p>\n+ * The backend must at the very least provide a Raster which the the rendering\n+ * pipeline can paint into. This must be implemented in\n+ * {@link #getDestinationRaster()}. For some backends that might be enough, like\n+ * when the target surface can be directly access via the raster (like in\n+ * BufferedImages). Other targets need some way to synchronize the raster with\n+ * the surface, which can be achieved by implementing the\n+ * {@link #updateRaster(Raster, int, int, int, int)} method, which always gets\n+ * called after a chunk of data got painted into the raster.\n+ * </p>\n+ * <p>The backend is free to provide implementations for the various raw*\n+ * methods for optimized AWT 1.1 style painting of some primitives. This should\n+ * accelerate painting of Swing greatly. When doing so, the backend must also\n+ * keep track of the clip and translation, probably by overriding\n+ * some clip and translate methods. Don't forget to message super in such a\n+ * case.</p>\n+ *\n+ * <h2>Acceleration options</h2>\n+ * <p>\n+ * The fact that it is\n+ * pure Java makes it a little slow. However, there are several ways of\n+ * accelerating the rendering pipeline:\n+ * <ol>\n+ * <li><em>Optimization hooks for AWT 1.1 - like graphics operations.</em>\n+ *   The most important methods from the {@link java.awt.Graphics} class\n+ *   have a corresponding <code>raw*</code> method, which get called when\n+ *   several optimization conditions are fullfilled. These conditions are\n+ *   described below. Subclasses can override these methods and delegate\n+ *   it directly to a native backend.</li>\n+ * <li><em>Native PaintContexts and CompositeContext.</em> The implementations\n+ *   for the 3 PaintContexts and AlphaCompositeContext can be accelerated\n+ *   using native code. These have proved to two of the most performance\n+ *   critical points in the rendering pipeline and cannot really be done quickly\n+ *   in plain Java because they involve lots of shuffling around with large\n+ *   arrays. In fact, you really would want to let the graphics card to the\n+ *   work, they are made for this.</li>\n+ * </ol>\n+ * </p>\n  *\n  * @author Roman Kennke (kennke@aicas.com)\n  */\n@@ -145,11 +186,6 @@\n    */\n   private Raster paintRaster;\n \n-  /**\n-   * A cached pixel array.\n-   */\n-  private int[] pixel;\n-\n   /**\n    * The raster of the destination surface. This is where the painting is\n    * performed.\n@@ -168,7 +204,7 @@\n   private transient ArrayList[] edgeTable;\n \n   /**\n-   * Indicates if cerain graphics primitives can be rendered in an optimized\n+   * Indicates if certain graphics primitives can be rendered in an optimized\n    * fashion. This will be the case if the following conditions are met:\n    * - The transform may only be a translation, no rotation, shearing or\n    *   scaling.\n@@ -198,8 +234,6 @@ protected AbstractGraphics2D()\n     hints.put(RenderingHints.KEY_ANTIALIASING,\n               RenderingHints.VALUE_ANTIALIAS_DEFAULT);\n     renderingHints = new RenderingHints(hints);\n-\n-    pixel = new int[4];\n   }\n \n   /**\n@@ -212,40 +246,211 @@ public void draw(Shape shape)\n   {\n     // Stroke the shape.\n     Shape strokedShape = stroke.createStrokedShape(shape);\n-\n-    // Clip the stroked shape.\n-//    Shape clipped = clipShape(strokedShape);\n-//    if (clipped != null)\n-//      {\n-//        // Fill the shape.\n-//        fillShape(clipped, false);\n-//      }\n-    // FIXME: Clipping doesn't seem to work.\n+    // Fill the stroked shape.\n     fillShape(strokedShape, false);\n   }\n \n-  public boolean drawImage(Image image, AffineTransform xform, ImageObserver obs)\n+\n+  /**\n+   * Draws the specified image and apply the transform for image space ->\n+   * user space conversion.\n+   *\n+   * This method is implemented to special case RenderableImages and\n+   * RenderedImages and delegate to\n+   * {@link #drawRenderableImage(RenderableImage, AffineTransform)} and\n+   * {@link #drawRenderedImage(RenderedImage, AffineTransform)} accordingly.\n+   * Other image types are not yet handled.\n+   *\n+   * @param image the image to be rendered\n+   * @param xform the transform from image space to user space\n+   * @param obs the image observer to be notified\n+   */\n+  public boolean drawImage(Image image, AffineTransform xform,\n+                           ImageObserver obs)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    boolean ret = false;\n+    Rectangle areaOfInterest = new Rectangle(0, 0, image.getWidth(obs),\n+                                             image.getHeight(obs));\n+    return drawImageImpl(image, xform, obs, areaOfInterest);\n+  }\n+\n+  /**\n+   * Draws the specified image and apply the transform for image space ->\n+   * user space conversion. This method only draw the part of the image\n+   * specified by <code>areaOfInterest</code>.\n+   *\n+   * This method is implemented to special case RenderableImages and\n+   * RenderedImages and delegate to\n+   * {@link #drawRenderableImage(RenderableImage, AffineTransform)} and\n+   * {@link #drawRenderedImage(RenderedImage, AffineTransform)} accordingly.\n+   * Other image types are not yet handled.\n+   *\n+   * @param image the image to be rendered\n+   * @param xform the transform from image space to user space\n+   * @param obs the image observer to be notified\n+   * @param areaOfInterest the area in image space that is rendered\n+   */\n+  private boolean drawImageImpl(Image image, AffineTransform xform,\n+                             ImageObserver obs, Rectangle areaOfInterest)\n+  {\n+    boolean ret;\n+    if (image == null)\n+      {\n+        ret = true;\n+      }\n+    else if (image instanceof RenderedImage)\n+      {\n+        // FIXME: Handle the ImageObserver.\n+        drawRenderedImageImpl((RenderedImage) image, xform, areaOfInterest);\n+        ret = true;\n+      }\n+    else if (image instanceof RenderableImage)\n+      {\n+        // FIXME: Handle the ImageObserver.\n+        drawRenderableImageImpl((RenderableImage) image, xform, areaOfInterest);\n+        ret = true;\n+      }\n+    else\n+      {\n+        // FIXME: Implement rendering of other Image types.\n+        ret = false;\n+      }\n+    return ret;\n   }\n \n+  /**\n+   * Renders a BufferedImage and applies the specified BufferedImageOp before\n+   * to filter the BufferedImage somehow. The resulting BufferedImage is then\n+   * passed on to {@link #drawRenderedImage(RenderedImage, AffineTransform)}\n+   * to perform the final rendering.\n+   *\n+   * @param image the source buffered image\n+   * @param op the filter to apply to the buffered image before rendering\n+   * @param x the x coordinate to render the image to \n+   * @param y the y coordinate to render the image to \n+   */\n   public void drawImage(BufferedImage image, BufferedImageOp op, int x, int y)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    BufferedImage filtered =\n+      op.createCompatibleDestImage(image, image.getColorModel());\n+    AffineTransform t = new AffineTransform();\n+    t.translate(x, y);\n+    drawRenderedImage(filtered, t);\n   }\n \n+  /**\n+   * Renders the specified image to the destination raster. The specified\n+   * transform is used to convert the image into user space. The transform\n+   * of this AbstractGraphics2D object is used to transform from user space\n+   * to device space.\n+   * \n+   * The rendering is performed using the scanline algorithm that performs the\n+   * rendering of other shapes and a custom Paint implementation, that supplies\n+   * the pixel values of the rendered image.\n+   *\n+   * @param image the image to render to the destination raster\n+   * @param xform the transform from image space to user space\n+   */\n   public void drawRenderedImage(RenderedImage image, AffineTransform xform)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    Rectangle areaOfInterest = new Rectangle(image.getMinX(),\n+                                             image.getHeight(),\n+                                             image.getWidth(),\n+                                             image.getHeight());\n+    drawRenderedImageImpl(image, xform, areaOfInterest);\n+  }\n+\n+  /**\n+   * Renders the specified image to the destination raster. The specified\n+   * transform is used to convert the image into user space. The transform\n+   * of this AbstractGraphics2D object is used to transform from user space\n+   * to device space. Only the area specified by <code>areaOfInterest</code>\n+   * is finally rendered to the target.\n+   * \n+   * The rendering is performed using the scanline algorithm that performs the\n+   * rendering of other shapes and a custom Paint implementation, that supplies\n+   * the pixel values of the rendered image.\n+   *\n+   * @param image the image to render to the destination raster\n+   * @param xform the transform from image space to user space\n+   */\n+  private void drawRenderedImageImpl(RenderedImage image,\n+                                     AffineTransform xform,\n+                                     Rectangle areaOfInterest)\n+  {\n+    // First we compute the transformation. This is made up of 3 parts:\n+    // 1. The areaOfInterest -> image space transform.\n+    // 2. The image space -> user space transform.\n+    // 3. The user space -> device space transform.\n+    AffineTransform t = new AffineTransform();\n+    t.translate(- areaOfInterest.x - image.getMinX(),\n+                - areaOfInterest.y - image.getMinY());\n+    t.concatenate(xform);\n+    t.concatenate(transform);\n+    AffineTransform it = null;\n+    try\n+      {\n+        it = t.createInverse();\n+      }\n+    catch (NoninvertibleTransformException ex)\n+      {\n+        // Ignore -- we return if the transform is not invertible.\n+      }\n+    if (it != null)\n+      {\n+        // Transform the area of interest into user space.\n+        GeneralPath aoi = new GeneralPath(areaOfInterest);\n+        aoi.transform(xform);\n+        // Render the shape using the standard renderer, but with a temporary\n+        // ImagePaint.\n+        ImagePaint p = new ImagePaint(image, it);\n+        Paint savedPaint = paint;\n+        try\n+          {\n+            paint = p;\n+            fillShape(aoi, false);\n+          }\n+        finally\n+          {\n+            paint = savedPaint;\n+          }\n+      }\n   }\n \n+  /**\n+   * Renders a renderable image. This produces a RenderedImage, which is\n+   * then passed to {@link #drawRenderedImage(RenderedImage, AffineTransform)}\n+   * to perform the final rendering.\n+   *\n+   * @param image the renderable image to be rendered\n+   * @param xform the transform from image space to user space\n+   */\n   public void drawRenderableImage(RenderableImage image, AffineTransform xform)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    Rectangle areaOfInterest = new Rectangle((int) image.getMinX(),\n+                                             (int) image.getHeight(),\n+                                             (int) image.getWidth(),\n+                                             (int) image.getHeight());\n+    drawRenderableImageImpl(image, xform, areaOfInterest);\n+                                                       \n+  }\n+\n+  /**\n+   * Renders a renderable image. This produces a RenderedImage, which is\n+   * then passed to {@link #drawRenderedImage(RenderedImage, AffineTransform)}\n+   * to perform the final rendering. Only the area of the image specified\n+   * by <code>areaOfInterest</code> is rendered.\n+   *\n+   * @param image the renderable image to be rendered\n+   * @param xform the transform from image space to user space\n+   */\n+  private void drawRenderableImageImpl(RenderableImage image,\n+                                       AffineTransform xform,\n+                                       Rectangle areaOfInterest)\n+  {\n+    // TODO: Maybe make more clever usage of a RenderContext here.\n+    RenderedImage rendered = image.createDefaultRendering();\n+    drawRenderedImageImpl(rendered, xform, areaOfInterest);\n   }\n \n   /**\n@@ -257,9 +462,14 @@ public void drawRenderableImage(RenderableImage image, AffineTransform xform)\n    */\n   public void drawString(String text, int x, int y)\n   {\n-    FontRenderContext ctx = getFontRenderContext();\n-    GlyphVector gv = font.createGlyphVector(ctx, text.toCharArray());\n-    drawGlyphVector(gv, x, y);\n+    if (isOptimized)\n+      rawDrawString(text, x, y);\n+    else\n+      {\n+        FontRenderContext ctx = getFontRenderContext();\n+        GlyphVector gv = font.createGlyphVector(ctx, text.toCharArray());\n+        drawGlyphVector(gv, x, y);\n+      }\n   }\n \n   /**\n@@ -313,9 +523,6 @@ public void drawString(AttributedCharacterIterator iterator, float x, float y)\n    */\n   public void fill(Shape shape)\n   {\n-//    Shape clipped = clipShape(shape);\n-//    if (clipped != null)\n-//      fillShape(clipped, false);\n     fillShape(shape, false);\n   }\n \n@@ -355,7 +562,6 @@ public void setPaint(Paint p)\n         else\n           {\n             updateOptimization();\n-            rawSetForeground((Color) paint);\n           }\n       }\n   }\n@@ -537,7 +743,7 @@ public void scale(double scaleX, double scaleY)\n     if (clip != null)\n       {\n         AffineTransform clipTransform = new AffineTransform();\n-        clipTransform.scale(-scaleX, -scaleY);\n+        clipTransform.scale(1 / scaleX, 1 / scaleY);\n         updateClip(clipTransform);\n       }\n     updateOptimization();\n@@ -712,8 +918,7 @@ else if (clip instanceof Rectangle && s instanceof Rectangle)\n \n   public FontRenderContext getFontRenderContext()\n   {\n-    //return new FontRenderContext(transform, false, false);\n-    return new FontRenderContext(new AffineTransform(), false, false);\n+    return new FontRenderContext(transform, false, true);\n   }\n \n   /**\n@@ -726,22 +931,15 @@ public FontRenderContext getFontRenderContext()\n   public void drawGlyphVector(GlyphVector gv, float x, float y)\n   {\n     int numGlyphs = gv.getNumGlyphs();\n-    AffineTransform t = new AffineTransform();\n-    t.translate(x, y);\n-\n-//    // TODO: We could use fill(gv.getOutline()), but that seems to be\n-      // slightly more inefficient. \n+    translate(x, y);\n+    // TODO: We could use fill(gv.getOutline()), but that seems to be\n+    // slightly more inefficient.\n     for (int i = 0; i < numGlyphs; i++)\n     {\n-      //fill(gv.getGlyphVisualBounds(i));\n-      GeneralPath p = new GeneralPath(gv.getGlyphOutline(i));\n-      p.transform(t);\n-      //Shape clipped = clipShape(p);\n-      //if (clipped != null)\n-      //  fillShape(clipped, true);\n-      // FIXME: Clipping doesn't seem to work correctly.\n-      fillShape(p, true);\n+      Shape o = gv.getGlyphOutline(i);\n+      fillShape(o, true);\n     }\n+    translate(-x, -y);\n   }\n \n   /**\n@@ -918,8 +1116,10 @@ public void setClip(Shape c)\n \n   public void copyArea(int x, int y, int width, int height, int dx, int dy)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    if (isOptimized)\n+      rawCopyArea(x, y, width, height, dx, dy);\n+    else\n+      copyAreaImpl(x, y, width, height, dx, dy);\n   }\n \n   /**\n@@ -978,11 +1178,15 @@ public void fillRect(int x, int y, int width, int height)\n    */\n   public void clearRect(int x, int y, int width, int height)\n   {\n-    Paint savedForeground = getPaint();\n-    setPaint(getBackground());\n-    //System.err.println(\"clearRect transform type: \" + transform.getType());\n-    fillRect(x, y, width, height);\n-    setPaint(savedForeground);\n+    if (isOptimized)\n+      rawClearRect(x, y, width, height);\n+    else\n+      {\n+        Paint savedForeground = getPaint();\n+        setPaint(getBackground());\n+        fillRect(x, y, width, height);\n+        setPaint(savedForeground);\n+      }\n   }\n \n   /**\n@@ -1087,47 +1291,153 @@ public void fillPolygon(int[] xPoints, int[] yPoints, int npoints)\n     fill(new Polygon(xPoints, yPoints, npoints));\n   }\n \n+  /**\n+   * Draws the specified image at the specified location. This forwards\n+   * to {@link #drawImage(Image, AffineTransform, ImageObserver)}.\n+   *\n+   * @param image the image to render\n+   * @param x the x location to render to\n+   * @param y the y location to render to\n+   * @param observer the image observer to receive notification\n+   */\n   public boolean drawImage(Image image, int x, int y, ImageObserver observer)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    boolean ret;\n+    if (isOptimized)\n+      ret = rawDrawImage(image, x, y, observer);\n+    else\n+      {\n+        AffineTransform t = new AffineTransform();\n+        t.translate(x, y);\n+        ret = drawImage(image, t, observer);\n+      }\n+    return ret;\n   }\n \n+  /**\n+   * Draws the specified image at the specified location. The image\n+   * is scaled to the specified width and height. This forwards\n+   * to {@link #drawImage(Image, AffineTransform, ImageObserver)}.\n+   *\n+   * @param image the image to render\n+   * @param x the x location to render to\n+   * @param y the y location to render to\n+   * @param width the target width of the image\n+   * @param height the target height of the image\n+   * @param observer the image observer to receive notification\n+   */\n   public boolean drawImage(Image image, int x, int y, int width, int height,\n                            ImageObserver observer)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    AffineTransform t = new AffineTransform();\n+    t.translate(x, y);\n+    double scaleX = (double) image.getWidth(observer) / (double) width;\n+    double scaleY = (double) image.getHeight(observer) / (double) height;\n+    t.scale(scaleX, scaleY);\n+    return drawImage(image, t, observer);\n   }\n \n+  /**\n+   * Draws the specified image at the specified location. This forwards\n+   * to {@link #drawImage(Image, AffineTransform, ImageObserver)}.\n+   *\n+   * @param image the image to render\n+   * @param x the x location to render to\n+   * @param y the y location to render to\n+   * @param bgcolor the background color to use for transparent pixels\n+   * @param observer the image observer to receive notification\n+   */\n   public boolean drawImage(Image image, int x, int y, Color bgcolor,\n                            ImageObserver observer)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    AffineTransform t = new AffineTransform();\n+    t.translate(x, y);\n+    // TODO: Somehow implement the background option.\n+    return drawImage(image, t, observer);\n   }\n \n+  /**\n+   * Draws the specified image at the specified location. The image\n+   * is scaled to the specified width and height. This forwards\n+   * to {@link #drawImage(Image, AffineTransform, ImageObserver)}.\n+   *\n+   * @param image the image to render\n+   * @param x the x location to render to\n+   * @param y the y location to render to\n+   * @param width the target width of the image\n+   * @param height the target height of the image\n+   * @param bgcolor the background color to use for transparent pixels\n+   * @param observer the image observer to receive notification\n+   */\n   public boolean drawImage(Image image, int x, int y, int width, int height,\n                            Color bgcolor, ImageObserver observer)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    AffineTransform t = new AffineTransform();\n+    t.translate(x, y);\n+    double scaleX = (double) image.getWidth(observer) / (double) width;\n+    double scaleY = (double) image.getHeight(observer) / (double) height;\n+    t.scale(scaleX, scaleY);\n+    // TODO: Somehow implement the background option.\n+    return drawImage(image, t, observer);\n   }\n \n+  /**\n+   * Draws an image fragment to a rectangular area of the target.\n+   *\n+   * @param image the image to render\n+   * @param dx1 the first corner of the destination rectangle\n+   * @param dy1 the first corner of the destination rectangle\n+   * @param dx2 the second corner of the destination rectangle\n+   * @param dy2 the second corner of the destination rectangle\n+   * @param sx1 the first corner of the source rectangle\n+   * @param sy1 the first corner of the source rectangle\n+   * @param sx2 the second corner of the source rectangle\n+   * @param sy2 the second corner of the source rectangle\n+   * @param observer the image observer to be notified\n+   */\n   public boolean drawImage(Image image, int dx1, int dy1, int dx2, int dy2,\n                            int sx1, int sy1, int sx2, int sy2,\n                            ImageObserver observer)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    int sx = Math.min(sx1, sx1);\n+    int sy = Math.min(sy1, sy2);\n+    int sw = Math.abs(sx1 - sx2);\n+    int sh = Math.abs(sy1 - sy2);\n+    int dx = Math.min(dx1, dx1);\n+    int dy = Math.min(dy1, dy2);\n+    int dw = Math.abs(dx1 - dx2);\n+    int dh = Math.abs(dy1 - dy2);\n+    \n+    AffineTransform t = new AffineTransform();\n+    t.translate(sx - dx, sy - dy);\n+    double scaleX = (double) sw / (double) dw;\n+    double scaleY = (double) sh / (double) dh;\n+    t.scale(scaleX, scaleY);\n+    Rectangle areaOfInterest = new Rectangle(sx, sy, sw, sh);\n+    return drawImageImpl(image, t, observer, areaOfInterest);\n   }\n \n+  /**\n+   * Draws an image fragment to a rectangular area of the target.\n+   *\n+   * @param image the image to render\n+   * @param dx1 the first corner of the destination rectangle\n+   * @param dy1 the first corner of the destination rectangle\n+   * @param dx2 the second corner of the destination rectangle\n+   * @param dy2 the second corner of the destination rectangle\n+   * @param sx1 the first corner of the source rectangle\n+   * @param sy1 the first corner of the source rectangle\n+   * @param sx2 the second corner of the source rectangle\n+   * @param sy2 the second corner of the source rectangle\n+   * @param bgcolor the background color to use for transparent pixels\n+   * @param observer the image observer to be notified\n+   */\n   public boolean drawImage(Image image, int dx1, int dy1, int dx2, int dy2,\n                            int sx1, int sy1, int sx2, int sy2, Color bgcolor,\n                            ImageObserver observer)\n   {\n-    // FIXME: Implement this.\n-    throw new UnsupportedOperationException(\"Not yet implemented\");\n+    // FIXME: Do something with bgcolor.\n+    return drawImage(image, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer);\n   }\n \n   /**\n@@ -1154,246 +1464,159 @@ protected void fillShape(Shape s, boolean isFont)\n         Object v = renderingHints.get(RenderingHints.KEY_TEXT_ANTIALIASING);\n         // We default to antialiasing on for text as long as we have no\n         // good hinting implemented.\n-        antialias = (v == RenderingHints.VALUE_TEXT_ANTIALIAS_ON\n-                     || v == RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT);\n+        antialias = (v == RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+                     //|| v == RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT);\n       }\n     else\n       {\n         Object v = renderingHints.get(RenderingHints.KEY_ANTIALIASING);\n         antialias = (v == RenderingHints.VALUE_ANTIALIAS_ON);\n       }\n \n-    Rectangle2D userBounds = s.getBounds2D();\n-\n-    // Flatten the path. TODO: Determine the best flattening factor\n-    // wrt to speed and quality.\n-    PathIterator path = s.getPathIterator(getTransform(), 1.0);\n-\n-    // Build up polygons and let the native backend render this using\n-    // rawFillShape() which would provide a default implementation for\n-    // drawPixel using a PolyScan algorithm.\n-    double[] seg = new double[6];\n-\n-    // TODO: Use ArrayList<PolyEdge> here when availble.\n-    ArrayList segs = new ArrayList();\n-    double segX = 0.; // The start point of the current edge.\n-    double segY = 0.; \n-    double polyX = 0.; // The start point of the current polygon.\n-    double polyY = 0.;\n-\n-    double minX = Integer.MAX_VALUE;\n-    double maxX = Integer.MIN_VALUE;\n-    double minY = Integer.MAX_VALUE;\n-    double maxY = Integer.MIN_VALUE;\n+    double offs = 0.5;\n+    if (antialias)\n+      offs = offs / AA_SAMPLING;\n \n-    //System.err.println(\"fill polygon\");\n-    while (! path.isDone())\n-      {\n-        int segType = path.currentSegment(seg);\n-        minX = Math.min(minX, seg[0]);\n-        maxX = Math.max(maxX, seg[0]);\n-        minY = Math.min(minY, seg[1]);\n-        maxY = Math.max(maxY, seg[1]);\n-\n-        //System.err.println(\"segment: \" + segType + \", \" + seg[0] + \", \" + seg[1]);\n-        if (segType == PathIterator.SEG_MOVETO)\n-          {\n-            segX = seg[0];\n-            segY = seg[1];\n-            polyX = seg[0];\n-            polyY = seg[1];\n-          }\n-        else if (segType == PathIterator.SEG_CLOSE)\n-          {\n-            // Close the polyline.\n-            PolyEdge edge = new PolyEdge(segX, segY, polyX, polyY);\n-            segs.add(edge);\n-          }\n-        else if (segType == PathIterator.SEG_LINETO)\n-          {\n-            PolyEdge edge = new PolyEdge(segX, segY, seg[0], seg[1]);\n-            segs.add(edge);\n-            segX = seg[0];\n-            segY = seg[1];\n-          }\n-        path.next();\n-      }\n+    Rectangle2D userBounds = s.getBounds2D();\n+    Rectangle2D deviceBounds = new Rectangle2D.Double();\n+    ArrayList segs = getSegments(s, transform, deviceBounds, false, offs);\n+    Rectangle2D clipBounds = new Rectangle2D.Double();\n+    ArrayList clipSegs = getSegments(clip, transform, clipBounds, true, offs);\n+    segs.addAll(clipSegs);\n+    Rectangle2D inclClipBounds = new Rectangle2D.Double();\n+    Rectangle2D.union(clipBounds, deviceBounds, inclClipBounds);\n     if (segs.size() > 0)\n       {\n         if (antialias)\n-          fillShapeAntialias(segs, minX, minY, maxX, maxY, userBounds);\n+          fillShapeAntialias(segs, deviceBounds, userBounds, inclClipBounds);\n         else\n-          rawFillShape(segs, minX, minY, maxX, maxY, userBounds);\n+          fillShapeImpl(segs, deviceBounds, userBounds, inclClipBounds);\n       }\n   }\n \n   /**\n-   * Draws one pixel in the target coordinate space. This method draws the\n-   * specified pixel by getting the painting pixel for that coordinate\n-   * from the paintContext and compositing the pixel with the compositeContext.\n-   * The resulting pixel is then set by calling {@link #rawSetPixel}.\n+   * Returns the color model of this Graphics object.\n    *\n-   * @param x the x coordinate\n-   * @param y the y coordinate\n+   * @return the color model of this Graphics object\n    */\n-  protected void drawPixel(int x, int y)\n-  {\n-    // FIXME: Implement efficient compositing.\n-    if (! (paint instanceof Color))\n-      {\n-        int[] paintPixel = paintRaster.getPixel(x, y, pixel);\n-        Color c = new Color(paintPixel[0], paintPixel[1], paintPixel[2]);\n-        rawSetForeground(c);\n-      }\n-    rawSetPixel(x, y);\n-  }\n+  protected abstract ColorModel getColorModel();\n \n   /**\n-   * Draws a pixel in the target coordinate space using the specified color.\n-   * \n-   * @param x the x coordinate\n-   * @param y the y coordinate\n+   * Returns the bounds of the target.\n+   *\n+   * @return the bounds of the target\n    */\n-  protected void rawSetPixel(int x, int y)\n+  protected Rectangle getDeviceBounds()\n   {\n-    // FIXME: Provide default implementation or remove method.\n+    return destinationRaster.getBounds();\n   }\n \n   /**\n-   * Sets the foreground color for drawing.\n+   * Draws a line in optimization mode. The implementation should respect the\n+   * clip and translation. It can assume that the clip is a rectangle and that\n+   * the transform is only a translating transform.\n    *\n-   * @param c the color to set\n+   * @param x0 the starting point, X coordinate\n+   * @param y0 the starting point, Y coordinate\n+   * @param x1 the end point, X coordinate \n+   * @param y1 the end point, Y coordinate\n    */\n-  protected void rawSetForeground(Color c)\n-  {\n-    // Probably remove method.\n-  }\n-\n-  protected void rawSetForeground(int r, int g, int b)\n+  protected void rawDrawLine(int x0, int y0, int x1, int y1)\n   {\n-    rawSetForeground(new Color(r, g, b));\n+    draw(new Line2D.Float(x0, y0, x1, y1));\n   }\n \n   /**\n-   * Returns the color model of this Graphics object.\n+   * Draws a string in optimization mode. The implementation should respect the\n+   * clip and translation. It can assume that the clip is a rectangle and that\n+   * the transform is only a translating transform.\n    *\n-   * @return the color model of this Graphics object\n+   * @param text the string to be drawn\n+   * @param x the start of the baseline, X coordinate\n+   * @param y the start of the baseline, Y coordinate\n    */\n-  protected abstract ColorModel getColorModel();\n+  protected void rawDrawString(String text, int x, int y)\n+  {\n+    FontRenderContext ctx = getFontRenderContext();\n+    GlyphVector gv = font.createGlyphVector(ctx, text.toCharArray());\n+    drawGlyphVector(gv, x, y);\n+  }\n \n   /**\n-   * Returns the bounds of the target.\n+   * Clears a rectangle in optimization mode. The implementation should respect the\n+   * clip and translation. It can assume that the clip is a rectangle and that\n+   * the transform is only a translating transform.\n    *\n-   * @return the bounds of the target\n+   * @param x the upper left corner, X coordinate\n+   * @param y the upper left corner, Y coordinate\n+   * @param w the width\n+   * @param h the height\n    */\n-  protected Rectangle getDeviceBounds()\n+  protected void rawClearRect(int x, int y, int w, int h)\n   {\n-    return destinationRaster.getBounds();\n+    Paint savedForeground = getPaint();\n+    setPaint(getBackground());\n+    rawFillRect(x, y, w, h);\n+    setPaint(savedForeground);\n   }\n \n   /**\n-   * Returns the bounds of the drawing area in user space.\n+   * Fills a rectangle in optimization mode. The implementation should respect\n+   * the clip but can assume that it is a rectangle.\n    *\n-   * @return the bounds of the drawing area in user space\n+   * @param x the upper left corner, X coordinate\n+   * @param y the upper left corner, Y coordinate\n+   * @param w the width\n+   * @param h the height\n    */\n-  protected Rectangle2D getUserBounds()\n+  protected void rawFillRect(int x, int y, int w, int h)\n   {\n-    PathIterator pathIter = getDeviceBounds().getPathIterator(getTransform());\n-    GeneralPath path = new GeneralPath();\n-    path.append(pathIter, true);\n-    return path.getBounds();\n-\n+    fill(new Rectangle(x, y, w, h));\n   }\n+\n   /**\n-   * Draws a line in optimization mode. The implementation should respect the\n-   * clip but can assume that it is a rectangle.\n+   * Draws an image in optimization mode. The implementation should respect\n+   * the clip but can assume that it is a rectangle.\n    *\n-   * @param x0 the starting point, X coordinate\n-   * @param y0 the starting point, Y coordinate\n-   * @param x1 the end point, X coordinate \n-   * @param y1 the end point, Y coordinate\n+   * @param image the image to be painted\n+   * @param x the location, X coordinate\n+   * @param y the location, Y coordinate\n+   * @param obs the image observer to be notified\n+   *\n+   * @return <code>true</code> when the image is painted completely,\n+   *         <code>false</code> if it is still rendered\n    */\n-  protected void rawDrawLine(int x0, int y0, int x1, int y1)\n+  protected boolean rawDrawImage(Image image, int x, int y, ImageObserver obs)\n   {\n-    // This is an implementation of Bresenham's line drawing algorithm.\n-    int dy = y1 - y0;\n-    int dx = x1 - x0;\n-    int stepx, stepy;\n-\n-    if (dy < 0)\n-      {\n-        dy = -dy;\n-        stepy = -1;\n-      }\n-    else\n-      {\n-        stepy = 1;\n-      }\n-    if (dx < 0)\n-      {\n-        dx = -dx;\n-        stepx = -1;\n-        }\n-    else\n-      {\n-        stepx = 1;\n-      }\n-    dy <<= 1;\n-    dx <<= 1;\n-\n-    drawPixel(x0, y0);\n-    if (dx > dy)\n-      {\n-        int fraction = dy - (dx >> 1); // same as 2*dy - dx\n-        while (x0 != x1)\n-          {\n-            if (fraction >= 0)\n-              {\n-                y0 += stepy;\n-                fraction -= dx;\n-              }\n-            x0 += stepx;\n-            fraction += dy;\n-            drawPixel(x0, y0);\n-          }\n-      }\n-    else\n-      {\n-        int fraction = dx - (dy >> 1);\n-        while (y0 != y1)\n-          {\n-            if (fraction >= 0)\n-              {\n-                x0 += stepx;\n-                fraction -= dy;\n-              }\n-            y0 += stepy;\n-            fraction += dx;\n-            drawPixel(x0, y0);\n-          }\n-      }\n+    AffineTransform t = new AffineTransform();\n+    t.translate(x, y);\n+    return drawImage(image, t, obs);\n   }\n \n   /**\n-   * Fills a rectangle in optimization mode. The implementation should respect\n-   * the clip but can assume that it is a rectangle.\n+   * Copies a rectangular region to another location.\n    *\n    * @param x the upper left corner, X coordinate\n    * @param y the upper left corner, Y coordinate\n    * @param w the width\n    * @param h the height\n+   * @param dx\n+   * @param dy\n    */\n-  protected void rawFillRect(int x, int y, int w, int h)\n+  protected void rawCopyArea(int x, int y, int w, int h, int dx, int dy)\n   {\n-    int x2 = x + w;\n-    int y2 = y + h;\n-    for (int xc = x; xc < x2; xc++)\n-      {\n-        for (int yc = y; yc < y2; yc++)\n-          {\n-            drawPixel(xc, yc);\n-          }\n-      }\n+    copyAreaImpl(x, y, w, h, dx, dy);\n+  }\n+\n+  // Private implementation methods.\n+\n+  /**\n+   * Copies a rectangular area of the target raster to a different location.\n+   */\n+  private void copyAreaImpl(int x, int y, int w, int h, int dx, int dy)\n+  {\n+    // FIXME: Implement this properly.\n+    throw new UnsupportedOperationException(\"Not implemented yet.\");\n   }\n \n   /**\n@@ -1403,8 +1626,9 @@ protected void rawFillRect(int x, int y, int w, int h)\n    *\n    * The polygon is already clipped when this method is called.\n    */\n-  protected void rawFillShape(ArrayList segs, double minX, double minY,\n-                              double maxX, double maxY, Rectangle2D userBounds)\n+  private void fillShapeImpl(ArrayList segs, Rectangle2D deviceBounds2D,\n+                             Rectangle2D userBounds,\n+                             Rectangle2D inclClipBounds)\n   {\n     // This is an implementation of a polygon scanline conversion algorithm\n     // described here:\n@@ -1413,19 +1637,25 @@ protected void rawFillShape(ArrayList segs, double minX, double minY,\n     // Create table of all edges.\n     // The edge buckets, sorted and indexed by their Y values.\n \n+    double minX = deviceBounds2D.getMinX();\n+    double minY = deviceBounds2D.getMinY();\n+    double maxX = deviceBounds2D.getMaxX();\n+    double maxY = deviceBounds2D.getMaxY();\n+    double icMinY = inclClipBounds.getMinY();\n+    double icMaxY = inclClipBounds.getMaxY();\n     Rectangle deviceBounds = new Rectangle((int) minX, (int) minY,\n                                            (int) Math.ceil(maxX) - (int) minX,\n                                            (int) Math.ceil(maxY) - (int) minY);\n     PaintContext pCtx = paint.createContext(getColorModel(), deviceBounds,\n                                             userBounds, transform, renderingHints);\n \n-    ArrayList[] edgeTable = new ArrayList[(int) Math.ceil(maxY)\n-                                          - (int) Math.ceil(minY) + 1];\n+    ArrayList[] edgeTable = new ArrayList[(int) Math.ceil(icMaxY)\n+                                          - (int) Math.ceil(icMinY) + 1];\n \n     for (Iterator i = segs.iterator(); i.hasNext();)\n       {\n         PolyEdge edge = (PolyEdge) i.next();\n-        int yindex = (int) ((int) Math.ceil(edge.y0) - (int) Math.ceil(minY));\n+        int yindex = (int) ((int) Math.ceil(edge.y0) - (int) Math.ceil(icMinY));\n         if (edgeTable[yindex] == null) // Create bucket when needed.\n           edgeTable[yindex] = new ArrayList();\n         edgeTable[yindex].add(edge); // Add edge to the bucket of its line.\n@@ -1445,7 +1675,7 @@ protected void rawFillShape(ArrayList segs, double minX, double minY,\n     PolyEdgeComparator comparator = new PolyEdgeComparator();\n \n     // Scan all relevant lines.\n-    int minYInt = (int) Math.ceil(minY);\n+    int minYInt = (int) Math.ceil(icMinY);\n     for (int y = minYInt; y <= maxY; y++)\n       {\n         ArrayList bucket = edgeTable[y - minYInt];\n@@ -1496,35 +1726,30 @@ protected void rawFillShape(ArrayList segs, double minX, double minY,\n         // Now draw all pixels inside the polygon.\n         // This is the last edge that intersected the scanline.\n         PolyEdge previous = null; // Gets initialized below.\n-        boolean active = false;\n+        boolean insideShape = false;\n+        boolean insideClip = false;\n         //System.err.println(\"scanline: \" + y);\n         for (Iterator i = activeEdges.iterator(); i.hasNext();)\n           {\n             PolyEdge edge = (PolyEdge) i.next();\n-            // Only fill scanline, if the current edge actually intersects\n-            // the scanline. There may be edges that lie completely\n-            // within the current scanline.\n-            //System.err.println(\"previous: \" + previous);\n-            //System.err.println(\"edge: \" + edge);\n-            if (active)\n+            if (edge.y1 <= y)\n+              continue;\n+\n+            // Draw scanline when we are inside the shape AND inside the\n+            // clip.\n+            if (insideClip && insideShape)\n               {\n-                if (edge.y1 > y)\n-                  {\n-                    int x0 = (int) previous.xIntersection;\n-                    int x1 = (int) edge.xIntersection;\n-                    fillScanline(pCtx, x0, x1, y);\n-                    previous = edge;\n-                    active = false;\n-                  }\n+                int x0 = (int) previous.xIntersection;\n+                int x1 = (int) edge.xIntersection;\n+                if (x0 < x1)\n+                  fillScanline(pCtx, x0, x1, y);\n               }\n+            // Update state.\n+            previous = edge;\n+            if (edge.isClip)\n+              insideClip = ! insideClip;\n             else\n-              {\n-                if (edge.y1 > y)\n-                  {\n-                    previous = edge;\n-                    active = true;\n-                  }\n-              }\n+              insideShape = ! insideShape;\n           }\n       }\n     pCtx.dispose();\n@@ -1544,7 +1769,8 @@ protected void fillScanline(PaintContext pCtx, int x0, int x1, int y)\n     CompositeContext cCtx = composite.createContext(paintColorModel,\n                                                     getColorModel(),\n                                                     renderingHints);\n-    cCtx.compose(paintRaster, destinationRaster, destinationRaster);\n+    WritableRaster targetChild = destinationRaster.createWritableTranslatedChild(-x0,- y);\n+    cCtx.compose(paintRaster, targetChild, targetChild);\n     updateRaster(destinationRaster, x0, y, x1 - x0, 1);\n     cCtx.dispose();\n   }\n@@ -1553,38 +1779,43 @@ protected void fillScanline(PaintContext pCtx, int x0, int x1, int y)\n    * Fills arbitrary shapes in an anti-aliased fashion.\n    *\n    * @param segs the line segments which define the shape which is to be filled\n-   * @param minX the bounding box, left X\n-   * @param minY the bounding box, upper Y\n-   * @param maxX the bounding box, right X\n-   * @param maxY the bounding box, lower Y\n    */\n-  private void fillShapeAntialias(ArrayList segs, double minX, double minY,\n-                                  double maxX, double maxY,\n-                                  Rectangle2D userBounds)\n+  private void fillShapeAntialias(ArrayList segs, Rectangle2D deviceBounds2D,\n+                                  Rectangle2D userBounds,\n+                                  Rectangle2D inclClipBounds)\n   {\n     // This is an implementation of a polygon scanline conversion algorithm\n     // described here:\n     // http://www.cs.berkeley.edu/~ug/slide/pipeline/assignments/scan/\n     // The antialiasing is implemented using a sampling technique, we do\n     // not scan whole lines but fractions of the line.\n \n+    double minX = deviceBounds2D.getMinX();\n+    double minY = deviceBounds2D.getMinY();\n+    double maxX = deviceBounds2D.getMaxX();\n+    double maxY = deviceBounds2D.getMaxY();\n+    double icMinY = inclClipBounds.getMinY();\n+    double icMaxY = inclClipBounds.getMaxY();\n+    double icMinX = inclClipBounds.getMinX();\n+    double icMaxX = inclClipBounds.getMaxX();\n     Rectangle deviceBounds = new Rectangle((int) minX, (int) minY,\n                                            (int) Math.ceil(maxX) - (int) minX,\n                                            (int) Math.ceil(maxY) - (int) minY);\n-    PaintContext pCtx = paint.createContext(getColorModel(), deviceBounds,\n+    PaintContext pCtx = paint.createContext(ColorModel.getRGBdefault(),\n+                                            deviceBounds,\n                                             userBounds, transform,\n                                             renderingHints);\n \n     // This array will contain the oversampled transparency values for\n     // each pixel in the scanline.\n-    int numScanlines = (int) Math.ceil(maxY) - (int) minY;\n-    int numScanlinePixels = (int) Math.ceil(maxX) - (int) minX + 1;\n+    int numScanlines = (int) Math.ceil(icMaxY) - (int) icMinY;\n+    int numScanlinePixels = (int) Math.ceil(icMaxX) - (int) icMinX + 1;\n     if (alpha == null || alpha.length < (numScanlinePixels + 1))\n       alpha = new int[numScanlinePixels + 1];\n     \n-    int firstLine = (int) minY;\n+    int firstLine = (int) icMinY;\n     //System.err.println(\"minY: \" + minY);\n-    int firstSubline = (int) (Math.ceil((minY - Math.floor(minY)) * AA_SAMPLING));\n+    int firstSubline = (int) (Math.ceil((icMinY - Math.floor(icMinY)) * AA_SAMPLING));\n     double firstLineDouble = firstLine + firstSubline / (double) AA_SAMPLING;\n     //System.err.println(\"firstSubline: \" + firstSubline);\n \n@@ -1629,8 +1860,11 @@ private void fillShapeAntialias(ArrayList segs, double minX, double minY,\n     // Scan all lines.\n     int yindex = 0;\n     //System.err.println(\"firstLine: \" + firstLine + \", maxY: \" + maxY + \", firstSubline: \" + firstSubline);\n-    for (int y = firstLine; y <= maxY; y++)\n+    for (int y = firstLine; y <= icMaxY; y++)\n       {\n+        int leftX = (int) icMaxX;\n+        int rightX = (int) icMinX;\n+        boolean emptyScanline = true;\n         for (int subY = firstSubline; subY < AA_SAMPLING; subY++)\n           {\n             //System.err.println(\"scanline: \" + y + \", subScanline: \" + subY);\n@@ -1687,17 +1921,16 @@ private void fillShapeAntialias(ArrayList segs, double minX, double minY,\n             // Now draw all pixels inside the polygon.\n             // This is the last edge that intersected the scanline.\n             PolyEdge previous = null; // Gets initialized below.\n-            boolean active = false;\n+            boolean insideClip = false;\n+            boolean insideShape = false;\n             //System.err.println(\"scanline: \" + y + \", subscanline: \" + subY);\n             for (Iterator i = activeEdges.iterator(); i.hasNext();)\n               {\n                 PolyEdge edge = (PolyEdge) i.next();\n-                // Only fill scanline, if the current edge actually intersects\n-                // the scanline. There may be edges that lie completely\n-                // within the current scanline.\n-                //System.err.println(\"previous: \" + previous);\n-                //System.err.println(\"edge: \" + edge);\n-                if (active)\n+                if (edge.y1 <= (y + (subY / (double) AA_SAMPLING)))\n+                  continue;\n+\n+                if (insideClip && insideShape)\n                   {\n                     // TODO: Use integer arithmetics here.\n                     if (edge.y1 > (y + (subY / (double) AA_SAMPLING)))\n@@ -1708,32 +1941,30 @@ private void fillShapeAntialias(ArrayList segs, double minX, double minY,\n                         int x1 = (int) Math.min(Math.max(edge.xIntersection, minX), maxX);\n                         //System.err.println(\"minX: \" + minX + \", x0: \" + x0 + \", x1: \" + x1 + \", maxX: \" + maxX);\n                         // TODO: Pull out cast.\n-                        alpha[x0 - (int) minX]++;\n-                        alpha[x1 - (int) minX + 1]--;\n-                        previous = edge;\n-                        active = false;\n+                        int left = x0 - (int) minX;\n+                        int right = x1 - (int) minX + 1; \n+                        alpha[left]++;\n+                        alpha[right]--;\n+                        leftX = Math.min(x0, leftX);\n+                        rightX = Math.max(x1+2, rightX);\n+                        emptyScanline = false;\n                       }\n                   }\n+                previous = edge;\n+                if (edge.isClip)\n+                  insideClip = ! insideClip;\n                 else\n-                  {\n-                    // TODO: Use integer arithmetics here.\n-                    if (edge.y1 > (y + (subY / (double) AA_SAMPLING)))\n-                      {\n-                        //System.err.println(edge);\n-                        previous = edge;\n-                        active = true;\n-                      }\n-                  }\n+                  insideShape = ! insideShape;\n               }\n             yindex++;\n           }\n         firstSubline = 0;\n         // Render full scanline.\n         //System.err.println(\"scanline: \" + y);\n-        fillScanlineAA(alpha, (int) minX, (int) y, numScanlinePixels, pCtx);\n+        if (! emptyScanline)\n+          fillScanlineAA(alpha, leftX, (int) y, rightX - leftX, pCtx,\n+                         (int) minX);\n       }\n-    if (paint instanceof Color && composite == AlphaComposite.SrcOver)\n-      rawSetForeground((Color) paint);\n \n     pCtx.dispose();\n   }\n@@ -1747,40 +1978,54 @@ private void fillShapeAntialias(ArrayList segs, double minX, double minY,\n    * @param x0 the beginning of the scanline\n    * @param y the y coordinate of the line\n    */\n-  private void fillScanlineAA(int[] alpha, int x0, int y, int numScanlinePixels,\n-                              PaintContext pCtx)\n+  private void fillScanlineAA(int[] alpha, int x0, int yy, int numPixels,\n+                              PaintContext pCtx, int offs)\n   {\n-    // FIXME: This doesn't work. Fixit.\n     CompositeContext cCtx = composite.createContext(pCtx.getColorModel(),\n                                                     getColorModel(),\n                                                     renderingHints);\n-    Raster paintRaster = pCtx.getRaster(x0, y, numScanlinePixels, 1);\n-    System.err.println(\"paintColorModel: \" + pCtx.getColorModel());\n+    Raster paintRaster = pCtx.getRaster(x0, yy, numPixels, 1);\n+    //System.err.println(\"paintColorModel: \" + pCtx.getColorModel());\n     WritableRaster aaRaster = paintRaster.createCompatibleWritableRaster();\n     int numBands = paintRaster.getNumBands();\n-    int[] pixels = new int[numScanlinePixels + paintRaster.getNumBands()];\n-    pixels = paintRaster.getPixels(x0, y, numScanlinePixels, 1, pixels);\n     ColorModel cm = pCtx.getColorModel();\n-    \n     double lastAlpha = 0.;\n     int lastAlphaInt = 0;\n-    int[] components = new int[4];\n-    \n-    for (int i = 0; i < pixels.length; i++)\n+\n+    Object pixel = null;\n+    int[] comps = null;\n+    int x1 = x0 + numPixels;\n+    for (int x = x0; x < x1; x++)\n       {\n+        int i = x - offs;\n         if (alpha[i] != 0)\n           {\n             lastAlphaInt += alpha[i];\n-            lastAlpha = lastAlphaInt / AA_SAMPLING;\n+            lastAlpha = (double) lastAlphaInt / (double) AA_SAMPLING;\n+            alpha[i] = 0;\n           }\n-        components = cm.getComponents(pixel[i], components, 0);\n-        components[0] = (int) (components[0] * lastAlpha);\n-        pixel[i] = cm.getDataElement(components, 0);\n+        pixel = paintRaster.getDataElements(x - x0, 0, pixel);\n+        comps = cm.getComponents(pixel, comps, 0);\n+        if (cm.hasAlpha() && ! cm.isAlphaPremultiplied())\n+          comps[comps.length - 1] *= lastAlpha;\n+        else\n+          {\n+            int max;\n+            if (cm.hasAlpha())\n+              max = comps.length - 2;\n+            else\n+              max = comps.length - 1;\n+            for (int j = 0; j < max; j++) \n+              comps[j] *= lastAlpha;\n+          }\n+        pixel = cm.getDataElements(comps, 0, pixel);\n+        aaRaster.setDataElements(x - x0, 0, pixel);\n       }\n \n-    aaRaster.setPixels(0, 0, numScanlinePixels, 1, pixels);\n-    cCtx.compose(aaRaster, destinationRaster, destinationRaster);\n-    updateRaster(destinationRaster, x0, y, numScanlinePixels, 1);\n+    WritableRaster targetChild =\n+      destinationRaster.createWritableTranslatedChild(-x0, -yy);\n+    cCtx.compose(aaRaster, targetChild, targetChild);\n+    updateRaster(destinationRaster, x0, yy, numPixels, 1);\n \n     cCtx.dispose();\n   }\n@@ -1798,8 +2043,8 @@ protected void init()\n \n     // FIXME: Should not be necessary. A clip of null should mean\n     // 'clip against device bounds.\n-    clip = getDeviceBounds();\n     destinationRaster = getDestinationRaster();\n+    clip = getDeviceBounds();\n   }\n \n   /**\n@@ -1912,40 +2157,77 @@ private void updateClip(AffineTransform t)\n   }\n \n   /**\n-   * Clips the specified shape using the current clip. If the resulting shape\n-   * is empty, this will return <code>null</code>.\n+   * Converts the specified shape into a list of segments.\n    *\n-   * @param s the shape to clip\n+   * @param s the shape to convert\n+   * @param t the transformation to apply before converting\n+   * @param deviceBounds an output parameter; holds the bounding rectangle of\n+   *        s in device space after return\n+   * @param isClip true when the shape is a clip, false for normal shapes;\n+   *        this influences the settings in the created PolyEdge instances.\n    *\n-   * @return the clipped shape or <code>null</code> if the result is empty\n+   * @return a list of PolyEdge that form the shape in device space\n    */\n-  private Shape clipShape(Shape s)\n+  private ArrayList getSegments(Shape s, AffineTransform t,\n+                                Rectangle2D deviceBounds, boolean isClip,\n+                                double offs)\n   {\n-    Shape clipped = null;\n+    // Flatten the path. TODO: Determine the best flattening factor\n+    // wrt to speed and quality.\n+    PathIterator path = s.getPathIterator(getTransform(), 1.0);\n \n-    // Clip the shape if necessary.\n-    if (clip != null)\n-      {\n-        Area a;\n-        if (! (s instanceof Area))\n-          a = new Area(s);\n-        else\n-          a = (Area) s;\n+    // Build up polygons and let the native backend render this using\n+    // rawFillShape() which would provide a default implementation for\n+    // drawPixel using a PolyScan algorithm.\n+    double[] seg = new double[6];\n \n-        Area clipArea;\n-        if (! (clip instanceof Area))\n-          clipArea = new Area(clip);\n-        else\n-          clipArea = (Area) clip;\n+    // TODO: Use ArrayList<PolyEdge> here when availble.\n+    ArrayList segs = new ArrayList();\n+    double segX = 0.; // The start point of the current edge.\n+    double segY = 0.; \n+    double polyX = 0.; // The start point of the current polygon.\n+    double polyY = 0.;\n \n-        a.intersect(clipArea);\n-        if (! a.isEmpty())\n-          clipped = a;\n-      }\n-    else\n+    double minX = Integer.MAX_VALUE;\n+    double maxX = Integer.MIN_VALUE;\n+    double minY = Integer.MAX_VALUE;\n+    double maxY = Integer.MIN_VALUE;\n+\n+    //System.err.println(\"fill polygon\");\n+    while (! path.isDone())\n       {\n-        clipped = s;\n+        int segType = path.currentSegment(seg);\n+        minX = Math.min(minX, seg[0]);\n+        maxX = Math.max(maxX, seg[0]);\n+        minY = Math.min(minY, seg[1]);\n+        maxY = Math.max(maxY, seg[1]);\n+\n+        //System.err.println(\"segment: \" + segType + \", \" + seg[0] + \", \" + seg[1]);\n+        if (segType == PathIterator.SEG_MOVETO)\n+          {\n+            segX = seg[0];\n+            segY = seg[1];\n+            polyX = seg[0];\n+            polyY = seg[1];\n+          }\n+        else if (segType == PathIterator.SEG_CLOSE)\n+          {\n+            // Close the polyline.\n+            PolyEdge edge = new PolyEdge(segX, segY - offs,\n+                                         polyX, polyY - offs, isClip);\n+            segs.add(edge);\n+          }\n+        else if (segType == PathIterator.SEG_LINETO)\n+          {\n+            PolyEdge edge = new PolyEdge(segX, segY - offs,\n+                                         seg[0], seg[1] - offs, isClip);\n+            segs.add(edge);\n+            segX = seg[0];\n+            segY = seg[1];\n+          }\n+        path.next();\n       }\n-    return clipped;\n+    deviceBounds.setRect(minX, minY, maxX - minX, maxY - minY);\n+    return segs;\n   }\n }"}, {"sha": "2e3690d8348e1767841dc6d791349a2da3004a09", "filename": "libjava/classpath/gnu/java/awt/java2d/AlphaCompositeContext.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FAlphaCompositeContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FAlphaCompositeContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FAlphaCompositeContext.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -236,7 +236,7 @@ public void compose(Raster src, Raster dstIn, WritableRaster dstOut)\n               }\n             else\n               {\n-                for (int i = srcComponentsLength - 1; i >= 0; i--)\n+                for (int i = srcComponentsLength - 2; i >= 0; i--)\n                   srcComponents[i] *= srcComponents[srcComponentsLength - 1];\n               }\n             if (! dstColorModel.isAlphaPremultiplied())"}, {"sha": "7e5fb56388edd2dce94ebf030ca11ab45f756ff6", "filename": "libjava/classpath/gnu/java/awt/java2d/ImagePaint.java", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FImagePaint.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FImagePaint.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FImagePaint.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,192 @@\n+/* ImagePaint.java -- Supplies the pixels for image rendering\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.java2d;\n+\n+import java.awt.Paint;\n+import java.awt.PaintContext;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Transparency;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.WritableRaster;\n+\n+/**\n+ * This class is used as a temporary Paint object to supply the pixel values\n+ * for image rendering using the normal scanline conversion implementation.\n+ *\n+ * @author Roman Kennke (kennke@aicas.com)\n+ */\n+public class ImagePaint\n+  implements Paint\n+{\n+\n+  /**\n+   * The PaintContext implementation for the ImagePaint.\n+   */\n+  private class ImagePaintContext\n+    implements PaintContext\n+  {\n+\n+    /**\n+     * The target raster.\n+     */\n+    private WritableRaster target;\n+\n+    /**\n+     * Nothing to do here.\n+     */\n+    public void dispose()\n+    {\n+      // Nothing to do here.\n+    }\n+\n+    /**\n+     * Returns the color model.\n+     *\n+     * @return the color model\n+     */\n+    public ColorModel getColorModel()\n+    {\n+      return image.getColorModel();\n+    }\n+\n+    /**\n+     * Supplies the pixel to be rendered.\n+     *\n+     * @see PaintContext#getRaster(int, int, int, int)\n+     */\n+    public Raster getRaster(int x1, int y1, int w, int h)\n+    {\n+      ensureRasterSize(w, h);\n+      int x2 = x1 + w;\n+      int y2 = y1 + h;\n+      float[] src = new float[2];\n+      float[] dest = new float[2];\n+      Raster source = image.getData();\n+      int minX = source.getMinX();\n+      int maxX = source.getWidth() + minX;\n+      int minY = source.getMinY();\n+      int maxY = source.getHeight() + minY;\n+      Object pixel = null;\n+      for (int y = y1; y < y2; y++)\n+        {\n+          for (int x = x1; x < x2; x++)\n+            {\n+              src[0] = x;\n+              src[1] = y;\n+              transform.transform(src, 0, dest, 0, 1);\n+              int dx = (int) dest[0];\n+              int dy = (int) dest[1];\n+              // Pixels outside the source image are not of interest, skip\n+              // them.\n+              if (dx >= minX && dx < maxX && dy >= minY && dy < maxY)\n+                {\n+                  pixel = source.getDataElements(dx, dy, pixel);\n+                  target.setDataElements(x - x1, y - y1, pixel);\n+                }\n+            }\n+        }\n+      return target;\n+    }\n+\n+    /**\n+     * Ensures that the target raster exists and has at least the specified\n+     * size.\n+     *\n+     * @param w the requested target width\n+     * @param h the requested target height\n+     */\n+    private void ensureRasterSize(int w, int h)\n+    {\n+      if (target == null || target.getWidth() < w || target.getHeight() < h)\n+        {\n+          Raster s = image.getData();\n+          target = s.createCompatibleWritableRaster(w, h);\n+        }\n+    }\n+  }\n+\n+  /**\n+   * The image to render.\n+   */\n+  RenderedImage image;\n+\n+  /**\n+   * The transform from image space to device space. This is the inversed\n+   * transform of the concatenated\n+   * transform image space -> user space -> device space transform.\n+   */\n+  AffineTransform transform;\n+\n+  /**\n+   * Creates a new ImagePaint for rendering the specified image using the\n+   * specified device space -> image space transform. This transform\n+   * is the inversed transform of the usual image space -> user space -> device\n+   * space transform.\n+   *\n+   * The ImagePaint will only render the image in the specified area of\n+   * interest (which is specified in image space).\n+   *\n+   * @param i the image to render\n+   * @param t the device space to user space transform\n+   */\n+  ImagePaint(RenderedImage i, AffineTransform t)\n+  {\n+    image = i;\n+    transform = t;\n+  }\n+\n+  public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,\n+                                    Rectangle2D userBounds,\n+                                    AffineTransform xform,\n+                                    RenderingHints hints)\n+  {\n+    return new ImagePaintContext();\n+  }\n+\n+  public int getTransparency()\n+  {\n+    return Transparency.OPAQUE;\n+  }\n+\n+}"}, {"sha": "8dbdbabcb94aacce7692c5d3c87355193e24c723", "filename": "libjava/classpath/gnu/java/awt/java2d/PolyEdge.java", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FPolyEdge.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FPolyEdge.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FPolyEdge.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -64,6 +64,11 @@\n    */\n   double xIntersection;\n \n+  /**\n+   * Indicates whether this edge is from the clip or from the target shape.\n+   */\n+  boolean isClip;\n+\n   /**\n    * Creates a new PolyEdge with the specified coordinates.\n    *\n@@ -72,8 +77,9 @@\n    * @param x1 the end point, x coordinate\n    * @param y1 the end point, y coordinate\n    */\n-  PolyEdge(double x0, double y0, double x1, double y1)\n+  PolyEdge(double x0, double y0, double x1, double y1, boolean clip)\n   {\n+    isClip = clip;\n     if (y0 < y1)\n       {\n         this.x0 = x0;"}, {"sha": "98d47b406aaba6722d020a5f8e53e5ce297b687b", "filename": "libjava/classpath/gnu/java/awt/java2d/RasterGraphics.java", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FRasterGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FRasterGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FRasterGraphics.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -65,8 +65,10 @@\n \n   public RasterGraphics(WritableRaster r, ColorModel cm)\n   {\n+    super();\n     raster = r;\n     colorModel = cm;\n+    init();\n   }\n \n   /**"}, {"sha": "1a782ce07e317fcad9a9ab71023bd42ab2a5877d", "filename": "libjava/classpath/gnu/java/awt/java2d/TexturePaintContext.java", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FTexturePaintContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FTexturePaintContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fjava2d%2FTexturePaintContext.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,205 @@\n+/* TexturePaintContext.java -- PaintContext impl for TexturePaint\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.java2d;\n+\n+import java.awt.AWTError;\n+import java.awt.PaintContext;\n+import java.awt.Rectangle;\n+import java.awt.TexturePaint;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.NoninvertibleTransformException;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+\n+/**\n+ * A {@link PaintContext} implementation for {@link TexturePaint}, done in\n+ * pure Java.\n+ *\n+ * @author Roman Kennke (kennke@aicas.com)\n+ */\n+public class TexturePaintContext\n+  implements PaintContext\n+{\n+\n+  /**\n+   * The TexturePaint object.\n+   */\n+  private BufferedImage image;\n+\n+  /**\n+   * The Raster that holds the texture.\n+   */\n+  private WritableRaster paintRaster;\n+\n+  /**\n+   * The transform from userspace into device space.\n+   */\n+  private AffineTransform transform;\n+\n+  /**\n+   * Creates a new TexturePaintContext for the specified TexturePaint object.\n+   * This initializes the Raster which is returned by\n+   * {@link #getRaster(int, int, int, int)}.\n+   *\n+   * @param t the texture paint object\n+   * @param db the bounds of the target raster in device space\n+   * @param ub the bounds of the target raster in user space\n+   * @param xform the transformation from user space to device space\n+   */\n+  public TexturePaintContext(TexturePaint t, Rectangle db,\n+                             Rectangle2D ub, AffineTransform xform)\n+  {\n+    image = t.getImage();\n+\n+    try\n+      {\n+        // Prepare transform for mapping from device space into image space.\n+        // In order to achieve this we take the transform for userspace->\n+        // devicespace, append the correct scale and translation according\n+        // to the anchor (which gives us the image->userspace->devicespace\n+        // transform), and invert that (which gives use the device->user->image\n+        // transform).\n+        Rectangle2D anchor = t.getAnchorRect();\n+        BufferedImage image = t.getImage();\n+        double scaleX = anchor.getWidth() / image.getWidth();\n+        double scaleY = anchor.getHeight() / image.getHeight();\n+        transform = (AffineTransform) xform.clone();\n+        transform.scale(scaleX, scaleY);\n+        transform.translate(-anchor.getMinX(), -anchor.getMaxX());\n+        transform = transform.createInverse();\n+      }\n+    catch (NoninvertibleTransformException ex)\n+      {\n+        AWTError err =\n+          new AWTError(\"Unexpected NoninvertibleTransformException\");\n+        err.initCause(ex);\n+        throw err;\n+      }\n+  }\n+\n+  /**\n+   * Disposes the PaintContext. Nothing is to do here, since we don't use\n+   * any native resources in that implementation.\n+   */\n+  public void dispose()\n+  {\n+    // Nothing to do here.\n+  }\n+\n+  /**\n+   * Returns the color model of this PaintContext. This implementation returnes\n+   * the color model used by the BufferedImage in the TexturePaint object,\n+   * this avoids costly color model transformations (at least at this point).\n+   *\n+   * @return the color model of this PaintContext\n+   */\n+  public ColorModel getColorModel()\n+  {\n+    return image.getColorModel();\n+  }\n+\n+  /**\n+   * Returns the Raster that is used for painting.\n+   *\n+   * @param x1 the x location of the raster inside the user bounds of this paint\n+   *        context\n+   * @param y1 the y location of the raster inside the user bounds of this paint\n+   *        context\n+   * @param w the width\n+   * @param h the height\n+   *\n+   * @return the Raster that is used for painting\n+   * \n+   */\n+  public Raster getRaster(int x1, int y1, int w, int h)\n+  {\n+    ensureRasterSize(w, h);\n+    int x2 = x1 + w;\n+    int y2 = y1 + h;\n+    float[] src = new float[2];\n+    float[] dest = new float[2];\n+    Raster source = image.getData();\n+    int minX = source.getMinX();\n+    int width = source.getWidth();\n+    int minY = source.getMinY();\n+    int height = source.getHeight();\n+    Object pixel = null;\n+    for (int y = y1; y < y2; y++)\n+      {\n+        for (int x = x1; x < x2; x++)\n+          {\n+            // Transform the coordinates from device space into image space.\n+            src[0] = x;\n+            src[1] = y;\n+            transform.transform(src, 0, dest, 0, 1);\n+            int dx = (int) dest[0];\n+            int dy = (int) dest[1];\n+\n+            // The modulo operation gives us the replication effect.\n+            dx = ((dx - minX) % width) + minX;  \n+            dy = ((dy - minY) % height) + minY;\n+\n+            // Copy the pixel.\n+            pixel = source.getDataElements(dx, dy, pixel);\n+            paintRaster.setDataElements(x - x1, y - y1, pixel);\n+          }\n+      }\n+    return paintRaster;\n+  }\n+\n+  /**\n+   * Ensures that the target raster exists and has at least the specified\n+   * size.\n+   *\n+   * @param w the requested target width\n+   * @param h the requested target height\n+   */\n+  private void ensureRasterSize(int w, int h)\n+  {\n+    if (paintRaster == null || paintRaster.getWidth() < w\n+        || paintRaster.getHeight() < h)\n+      {\n+        Raster s = image.getData();\n+        paintRaster = s.createCompatibleWritableRaster(w, h);\n+      }\n+  }\n+}"}, {"sha": "d9d300d9103ae6c20117b8de434c33ec8bf6ce92", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/BufferedImageGraphics.java", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FBufferedImageGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FBufferedImageGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FBufferedImageGraphics.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,258 @@\n+/* BufferedImageGraphics.java\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferInt;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.ImageObserver;\n+import java.util.WeakHashMap;\n+\n+/**\n+ * Implementation of Graphics2D on a Cairo surface.\n+ *\n+ * Simutanously maintains a CairoSurface and updates the \n+ * BufferedImage from that after each drawing operation.\n+ */\n+public class BufferedImageGraphics extends CairoGraphics2D\n+{\n+  /**\n+   * the buffered Image.\n+   */\n+  private BufferedImage image;\n+\n+  /**\n+   * Image size.\n+   */\n+  private int imageWidth, imageHeight;\n+\n+  /**\n+   * The cairo surface that we actually draw on.\n+   */\n+  CairoSurface surface;\n+\n+  /**\n+   * Cache BufferedImageGraphics surfaces.\n+   */\n+  static WeakHashMap bufferedImages = new WeakHashMap();\n+\n+  /**\n+   * Its corresponding cairo_t.\n+   */\n+  private long cairo_t;\n+\n+  /**\n+   * Colormodels we recognize for fast copying.\n+   */  \n+  static ColorModel rgb32 = new DirectColorModel(32, 0xFF0000, 0xFF00, 0xFF);\n+  static ColorModel argb32 = new DirectColorModel(32, 0xFF0000, 0xFF00, 0xFF,\n+\t\t\t\t\t\t  0xFF000000);\n+  private boolean hasFastCM;\n+  private boolean hasAlpha;\n+\n+\n+  public BufferedImageGraphics(BufferedImage bi)\n+  {\n+    this.image = bi;\n+    imageWidth = bi.getWidth();\n+    imageHeight = bi.getHeight();\n+    if(bi.getColorModel().equals(rgb32))\n+      {\n+\thasFastCM = true;\n+\thasAlpha = false;\n+      }\n+    else if(bi.getColorModel().equals(argb32))\n+      {\n+\thasFastCM = true;\n+\thasAlpha = false;\n+      }\n+    else\n+      hasFastCM = false;\n+\n+    // Cache surfaces.\n+    if( bufferedImages.get( bi ) != null )\n+      surface = (CairoSurface)bufferedImages.get( bi );\n+    else\n+      {\n+\tsurface = new CairoSurface( imageWidth, imageHeight );\n+\tbufferedImages.put(bi, surface);\n+      }\n+\n+    cairo_t = surface.newCairoContext();\n+\n+    DataBuffer db = bi.getRaster().getDataBuffer();\n+    int[] pixels;\n+    // get pixels\n+\n+    if(db instanceof CairoSurface)\n+      pixels = ((CairoSurface)db).getPixels(imageWidth * imageHeight);\n+    else\n+      {\n+\tif( hasFastCM )\n+\t  {\n+\t    pixels = ((DataBufferInt)db).getData();\n+\t    if( !hasAlpha )\n+\t      for(int i = 0; i < pixels.length; i++)\n+\t\tpixels[i] &= 0xFFFFFFFF;\n+\t  }\n+\telse\n+\t  {\n+\t    pixels = CairoGraphics2D.findSimpleIntegerArray\n+\t      (image.getColorModel(),image.getData());\n+\t  }\n+      }\n+    surface.setPixels( pixels );\n+\n+    setup( cairo_t );\n+    setClip(0, 0, imageWidth, imageHeight);\n+  }\n+  \n+  BufferedImageGraphics(BufferedImageGraphics copyFrom)\n+  {\n+    surface = copyFrom.surface;\n+    cairo_t = surface.newCairoContext();\n+    imageWidth = copyFrom.imageWidth;\n+    imageHeight = copyFrom.imageHeight;\n+    copy( copyFrom, cairo_t );\n+    setClip(0, 0, surface.width, surface.height);\n+  }\n+\n+  /**\n+   * Update a rectangle of the bufferedImage. This can be improved upon a lot.\n+   */\n+  private void updateBufferedImage(int x, int y, int width, int height)\n+  {  \n+    int[] pixels = surface.getPixels(imageWidth * imageHeight);\n+\n+    if( x > imageWidth || y > imageHeight )\n+      return;\n+    // Clip edges.\n+    if( x < 0 ){ width = width + x; x = 0; }\n+    if( y < 0 ){ height = height + y; y = 0; }\n+    if( x + width > imageWidth ) \n+      width = imageWidth - x;\n+    if( y + height > imageHeight ) \n+      height = imageHeight - y;\n+\n+    if( !hasFastCM )\n+      image.setRGB(x, y, width, height, pixels, \n+\t\t   x + y * imageWidth, imageWidth);\n+    else\n+      System.arraycopy(pixels, y * imageWidth, \n+\t\t       ((DataBufferInt)image.getRaster().getDataBuffer()).\n+\t\t       getData(), y * imageWidth, height * imageWidth);\n+  }\n+\n+  /**\n+   * Abstract methods.\n+   */  \n+  public Graphics create()\n+  {\n+    return new BufferedImageGraphics(this);\n+  }\n+  \n+  public GraphicsConfiguration getDeviceConfiguration()\n+  {\n+    return null;\n+  }\n+\n+  protected Rectangle2D getRealBounds()\n+  {\n+    return new Rectangle2D.Double(0.0, 0.0, imageWidth, imageHeight);\n+  }\n+  \n+  public void copyAreaImpl(int x, int y, int width, int height, int dx, int dy)\n+  {\n+    surface.copyAreaNative(x, y, width, height, dx, dy, surface.width);\n+    updateBufferedImage(x + dx, y + dy, width, height);\n+  }\n+\n+  /**\n+   * Overloaded methods that do actual drawing need to enter the gdk threads \n+   * and also do certain things before and after.\n+   */\n+  public void draw(Shape s)\n+  {\n+    super.draw(s);\n+    Rectangle r = s.getBounds();\n+    updateBufferedImage(r.x, r.y, r.width, r.height);\n+  }\n+\n+  public void fill(Shape s)\n+  {\n+    super.fill(s);\n+    Rectangle r = s.getBounds();\n+    updateBufferedImage(r.x, r.y, r.width, r.height);\n+  }\n+\n+  public void drawRenderedImage(RenderedImage image, AffineTransform xform)\n+  {\n+    super.drawRenderedImage(image, xform);\n+    updateBufferedImage(0, 0, imageWidth, imageHeight);\n+  }\n+\n+  protected boolean drawImage(Image img, AffineTransform xform,\n+\t\t\t      Color bgcolor, ImageObserver obs)\n+  {\n+    boolean rv = super.drawImage(img, xform, bgcolor, obs);\n+    updateBufferedImage(0, 0, imageWidth, imageHeight);\n+    return rv;\n+  }\n+\n+  public void drawGlyphVector(GlyphVector gv, float x, float y)\n+  {\n+    super.drawGlyphVector(gv, x, y);\n+    updateBufferedImage(0, 0, imageWidth, imageHeight);\n+  }\n+}\n+"}, {"sha": "3179d3379b90b539c8cbc56dea67ce3036a15fe5", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/CairoGraphics2D.java", "status": "renamed", "additions": 924, "deletions": 1009, "changes": 1933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoGraphics2D.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n-/* GdkGraphics2D.java --\n-   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+/* CairoGraphics2D.java --\n+   Copyright (C) 2006  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -58,17 +58,21 @@\n import java.awt.RenderingHints;\n import java.awt.Shape;\n import java.awt.Stroke;\n+import java.awt.Polygon;\n import java.awt.TexturePaint;\n import java.awt.Toolkit;\n import java.awt.font.FontRenderContext;\n import java.awt.font.GlyphVector;\n import java.awt.geom.AffineTransform;\n import java.awt.geom.Arc2D;\n+import java.awt.geom.Area;\n+import java.awt.geom.Line2D;\n import java.awt.geom.GeneralPath;\n import java.awt.geom.NoninvertibleTransformException;\n import java.awt.geom.PathIterator;\n import java.awt.geom.Point2D;\n import java.awt.geom.Rectangle2D;\n+import java.awt.geom.RoundRectangle2D;\n import java.awt.image.AffineTransformOp;\n import java.awt.image.BufferedImage;\n import java.awt.image.BufferedImageOp;\n@@ -92,92 +96,141 @@\n import java.util.Map;\n import java.util.Stack;\n \n-public class GdkGraphics2D extends Graphics2D\n+/**\n+ * This is an abstract implementation of Graphics2D on Cairo. \n+ *\n+ * It should be subclassed for different Cairo contexts.\n+ *\n+ * Note for subclassers: Apart from the constructor (see comments below),\n+ * The following abstract methods must be implemented:\n+ *\n+ * Graphics create()\n+ * GraphicsConfiguration getDeviceConfiguration()\n+ * copyArea(int x, int y, int width, int height, int dx, int dy)\n+ *\n+ * Also, dispose() must be overloaded to free any native datastructures \n+ * used by subclass and in addition call super.dispose() to free the\n+ * native cairographics2d structure and cairo_t.\n+ *\n+ * @author Sven de Marothy\n+ */\n+public abstract class CairoGraphics2D extends Graphics2D\n {\n-  //////////////////////////////////////\n-  ////// State Management Methods //////\n-  //////////////////////////////////////\n-\n   static \n   {\n-    if (! Configuration.GTK_CAIRO_ENABLED)\n-      throw new Error(\"Graphics2D not implemented. \"\n-\t\t      + \"Cairo was not found or disabled at configure time\");\n-\n     System.loadLibrary(\"gtkpeer\");\n-\n-    initStaticState();\n   }\n-  \n-  static native void initStaticState();\n-  \n-  private final int native_state = GtkGenericPeer.getUniqueInteger();  \n \n-  // These are package-private to avoid accessor methods.\n+  /**\n+   * Important: This is a pointer to the native cairographics2d structure\n+   *\n+   * DO NOT CHANGE WITHOUT CHANGING NATIVE CODE.\n+   */\n+  long nativePointer;\n+\n+  // Drawing state variables\n+  /**\n+   * The current paint\n+   */\n   Paint paint;\n+\n+  /**\n+   * The current stroke\n+   */\n   Stroke stroke;\n-  Color fg;\n-  Color bg;\n+\n+  /*\n+   * Current foreground and background color.\n+   */\n+  Color fg, bg;\n+\n+  /**\n+   * Current clip shape.\n+   */\n   Shape clip;\n+\n+  /**\n+   * Current transform.\n+   */\n   AffineTransform transform;\n-  private GtkComponentPeer component;\n-  // This is package-private to avoid an accessor method.\n+\n+  /**\n+   * Current font.\n+   */\n   Font font;\n-  private RenderingHints hints;\n-  private BufferedImage bimage;\n-  private boolean pixelConversionRequired;\n-  private int[] pixelBuffer;\n-  // This is package-private to avoid an accessor method.\n+\n+  /**\n+   * The current compositing context, if any.\n+   */\n   Composite comp;\n-  private Stack stateStack;\n-\n-  private native void initStateUnlocked(GtkComponentPeer component);\n-  private native void initState(GtkComponentPeer component);\n-  private native void initState(int width, int height);\n-  private native void initState(int[] pixes, int width, int height);\n-  private native void copyState(GdkGraphics2D g);\n-  public native void dispose();\n-  private native void cairoSurfaceSetFilter(int filter);\n-  private native void cairoSurfaceSetFilterUnlocked(int filter);\n-  native void connectSignals(GtkComponentPeer component);\n \n-  public void finalize()\n-  {\n-    dispose();\n-  }\n+  /**\n+   * Rendering hint map.\n+   */\n+  private RenderingHints hints;\n \n-  public Graphics create()\n-  {\n-    return new GdkGraphics2D(this);\n-  }\n+  /**\n+   * Some operations (drawing rather than filling) require that their\n+   * coords be shifted to land on 0.5-pixel boundaries, in order to land on\n+   * \"middle of pixel\" coordinates and light up complete pixels. \n+   */\n+  private boolean shiftDrawCalls = false;\n+\n+  /**\n+   * Keep track if the first clip to be set, which is restored on setClip(null);\n+   */\n+  private boolean firstClip = true;\n+  private Shape originalClip;\n+\n+  /**\n+   * Stroke used for 3DRects\n+   */\n+  private static BasicStroke draw3DRectStroke = new BasicStroke();\n+\n+  static ColorModel rgb32 = new DirectColorModel(32, 0xFF0000, 0xFF00, 0xFF);\n+  static ColorModel argb32 = new DirectColorModel(32, 0xFF0000, 0xFF00, 0xFF, \n+\t\t\t\t\t\t  0xFF000000);\n \n-  public Graphics create(int x, int y, int width, int height)\n+  /**\n+   * Constructor does nothing.\n+   */\n+  public CairoGraphics2D()\n   {\n-    return new GdkGraphics2D(this, x, y, width, height);\n   }\n \n-  private void fail_g2d ()\n-  {\n-    System.err.println (\"Attempted to instantiate GdkGraphics2D\"\n-\t\t\t+ \" but Graphics2D not enabled.  Try again with\"\n-\t\t\t+ \" -Dgnu.java.awt.peer.gtk.Graphics=Graphics2D\");\n-    System.exit (1);\n+  /**\n+   * Sets up the default values and allocates the native cairographics2d structure\n+   * @param cairo_t_pointer, a native pointer to a cairo_t of the context.\n+   */\n+  public void setup(long cairo_t_pointer)\n+  { \n+    nativePointer = init(cairo_t_pointer);\n+    setRenderingHints(new RenderingHints(getDefaultHints()));\n+    font = new Font(\"SansSerif\", Font.PLAIN, 12);\n+    setColor(Color.black);\n+    setBackground(Color.white);\n+    setPaint(Color.black);\n+    setStroke(new BasicStroke());\n+    setTransform(new AffineTransform());\n   }\n \n-  GdkGraphics2D(GdkGraphics2D g)\n+  /**\n+   * Same as above, but copies the state of another CairoGraphics2D.\n+   */\n+  public void copy(CairoGraphics2D g, long cairo_t_pointer)\n   {\n-    if (!GtkToolkit.useGraphics2D ())\n-      fail_g2d ();\n-\n+    nativePointer = init(cairo_t_pointer);\n     paint = g.paint;\n     stroke = g.stroke;\n     setRenderingHints(g.hints);\n+    \n+    Color foreground;\n \n     if (g.fg.getAlpha() != -1)\n-      fg = new Color(g.fg.getRed(), g.fg.getGreen(), g.fg.getBlue(),\n+      foreground = new Color(g.fg.getRed(), g.fg.getGreen(), g.fg.getBlue(),\n                      g.fg.getAlpha());\n     else\n-      fg = new Color(g.fg.getRGB());\n+      foreground = new Color(g.fg.getRGB());\n \n     if (g.bg != null)\n       {\n@@ -199,496 +252,319 @@ private void fail_g2d ()\n       transform = new AffineTransform(g.transform);\n \n     font = g.font;\n-    component = g.component;\n-    copyState(g);\n \n-    setColor(fg);\n+    setColor(foreground);\n     setBackground(bg);\n     setPaint(paint);\n     setStroke(stroke);\n     setTransform(transform);\n-    setClip(clip);\n-    stateStack = new Stack();\n   }\n \n-  GdkGraphics2D(GdkGraphics2D g, int x, int y, int widht, int height)\n-  {\n-    this(g);\n-    translate(x, y);\n-    clipRect(0, 0, widht, height);\n-  }\n-\n-  GdkGraphics2D(int width, int height)\n-  {\n-    if (!GtkToolkit.useGraphics2D ())\n-      fail_g2d ();\n-\n-    initState(width, height);\n-\n-    setColor(Color.black);\n-    setBackground(new Color(0, 0, 0, 0));\n-    setPaint(getColor());\n-    setFont(new Font(\"SansSerif\", Font.PLAIN, 12));\n-    setTransform(new AffineTransform());\n-    setStroke(new BasicStroke());\n-    setRenderingHints(getDefaultHints());\n-\n-    stateStack = new Stack();\n-  }\n-\n-  GdkGraphics2D(GtkComponentPeer component)\n+  /**\n+   * Generic destructor - call the native dispose() method.\n+   */\n+  public void finalize()\n   {\n-    if (!GtkToolkit.useGraphics2D ())\n-      fail_g2d ();\n-\n-    this.component = component;\n-    \n-    if (component.isRealized())\n-      initComponentGraphics2D();\n-    else\n-      connectSignals(component);\n+    dispose();\n   }\n \n-  void initComponentGraphics2D()\n-  {\n-    initState(component);\n-\n-    setColor(component.awtComponent.getForeground());\n-    setBackground(component.awtComponent.getBackground());\n-    setPaint(getColor());\n-    setTransform(new AffineTransform());\n-    setStroke(new BasicStroke());\n-    setRenderingHints(getDefaultHints());\n-    setFont(new Font(\"SansSerif\", Font.PLAIN, 12));\n-\n-    stateStack = new Stack();\n+  /**\n+   * Disposes the native cairographics2d structure, including the \n+   * cairo_t and any gradient stuff, if allocated. \n+   * Subclasses should of course overload and call this if \n+   * they have additional native structures.\n+   */\n+  public void dispose()\n+  {    \n+    disposeNative();\n+    nativePointer = 0;\n   }\n \n-  void initComponentGraphics2DUnlocked()\n-  {\n-    initStateUnlocked(component);\n-\n-    setColorUnlocked(component.awtComponent.getForeground());\n-    setBackgroundUnlocked(component.awtComponent.getBackground());\n-    setPaintUnlocked(getColorUnlocked());\n-    setTransformUnlocked(new AffineTransform());\n-    setStrokeUnlocked(new BasicStroke());\n-    setRenderingHintsUnlocked(getDefaultHints());\n-    setFontUnlocked(new Font(\"SansSerif\", Font.PLAIN, 12));\n+  /**\n+   * Allocate the cairographics2d structure and set the cairo_t pointer in it.\n+   * @param pointer - a cairo_t pointer, casted to a long.\n+   */\n+  private native long init(long pointer);\n \n-    stateStack = new Stack();\n-  }\n-\n-  GdkGraphics2D(BufferedImage bimage)\n-  {\n-    this.bimage = bimage;\n-    this.pixelBuffer = findSimpleIntegerArray(bimage.getColorModel(),\n-                                              bimage.getRaster());\n-    if (this.pixelBuffer == null)\n-      {\n-\tthis.pixelBuffer = new int[bimage.getRaster().getWidth() * bimage.getRaster()\n-\t                                                                 .getHeight()];\n-\tthis.pixelConversionRequired = true;\n-      }\n-    else\n-      {\n-        this.pixelConversionRequired = false;\n-      }\n+  /**\n+   * These are declared abstract as there may be context-specific issues.\n+   */\n+  public abstract Graphics create();\n \n-    initState(this.pixelBuffer, bimage.getWidth(), bimage.getHeight());\n+  public abstract GraphicsConfiguration getDeviceConfiguration();\n \n-    setColor(Color.black);\n-    setBackground(new Color(0, 0, 0, 0));\n-    setPaint(getColor());\n-    setFont(new Font(\"SansSerif\", Font.PLAIN, 12));\n-    setTransform(new AffineTransform());\n-    setStroke(new BasicStroke());\n-    setRenderingHints(getDefaultHints());\n+  protected abstract void copyAreaImpl(int x, int y, \n+\t\t\t\t       int width, int height, int dx, int dy);\n \n-    stateStack = new Stack();\n \n-    // draw current buffered image to the pixmap associated \n-    // with it, if the image is not equal to our paint buffer.\n-    if (pixelConversionRequired)\n-      drawImage(bimage, new AffineTransform(1, 0, 0, 1, 0, 0), bg, null);\n-  }\n+  protected abstract Rectangle2D getRealBounds();\n \n-  ////////////////////////////////////\n-  ////// Native Drawing Methods //////\n-  ////////////////////////////////////\n+  ////// Native Methods ////////////////////////////////////////////////////\n \n-  // GDK drawing methods\n-  private native void gdkDrawDrawable(GdkGraphics2D other, int x, int y);\n+  /**\n+   * Dispose of allocate native resouces.\n+   */\n+  public native void disposeNative();\n \n-  // drawing utility methods\n+  /**\n+   * Draw pixels as an RGBA int matrix\n+   * @param w, h - width and height\n+   * @param stride - stride of the array width\n+   * @param i2u - affine transform array\n+   */\n   private native void drawPixels(int[] pixels, int w, int h, int stride,\n                                  double[] i2u);\n-  private native void setTexturePixelsUnlocked(int[] pixels, int w, int h, int stride);\n-  private native void setTexturePixels(int[] pixels, int w, int h, int stride);\n+\n   private native void setGradient(double x1, double y1, double x2, double y2,\n                                   int r1, int g1, int b1, int a1, int r2,\n                                   int g2, int b2, int a2, boolean cyclic);\n-  private native void setGradientUnlocked(double x1, double y1, double x2, double y2,\n-                                  int r1, int g1, int b1, int a1, int r2,\n-                                  int g2, int b2, int a2, boolean cyclic);\n+  \n+  private native void setTexturePixels(int[] pixels, int w, int h, int stride);\n \n-  // simple passthroughs to cairo\n-  private native void cairoSave();\n-  private native void cairoRestore();\n+  /**\n+   * Set the current transform matrix\n+   */\n   private native void cairoSetMatrix(double[] m);\n-  private native void cairoSetMatrixUnlocked(double[] m);\n+\n+  /**\n+   * Set the compositing operator\n+   */\n   private native void cairoSetOperator(int cairoOperator);\n+\n+  /**\n+   * Sets the current color in RGBA as a 0.0-1.0 double\n+   */\n   private native void cairoSetRGBAColor(double red, double green,\n                                         double blue, double alpha);\n-  private native void cairoSetRGBAColorUnlocked(double red, double green,\n-                                        double blue, double alpha);\n-  private native void cairoSetFillRule(int cairoFillRule);\n-  private native void cairoSetLineWidth(double width);\n-  private native void cairoSetLineWidthUnlocked(double width);\n-  private native void cairoSetLineCap(int cairoLineCap);\n-  private native void cairoSetLineCapUnlocked(int cairoLineCap);\n-  private native void cairoSetLineJoin(int cairoLineJoin);\n-  private native void cairoSetLineJoinUnlocked(int cairoLineJoin);\n-  private native void cairoSetDash(double[] dashes, int ndash, double offset);\n-  private native void cairoSetDashUnlocked(double[] dashes, int ndash, double offset);\n-\n-  private native void cairoSetMiterLimit(double limit);\n-  private native void cairoSetMiterLimitUnlocked(double limit);\n-  private native void cairoNewPath();\n-  private native void cairoMoveTo(double x, double y);\n-  private native void cairoLineTo(double x, double y);\n-  private native void cairoCurveTo(double x1, double y1, double x2, double y2,\n-                                   double x3, double y3);\n-  private native void cairoRelMoveTo(double dx, double dy);\n-  private native void cairoRelLineTo(double dx, double dy);\n-  private native void cairoRelCurveTo(double dx1, double dy1, double dx2,\n-                                      double dy2, double dx3, double dy3);\n-  private native void cairoRectangle(double x, double y, double width,\n-                                     double height);\n-  private native void cairoClosePath();\n-  private native void cairoStroke();\n-  private native void cairoFill();\n-  private native void cairoClip();\n-\n-  /////////////////////////////////////////////\n-  ////// General Drawing Support Methods //////\n-  /////////////////////////////////////////////\n-\n-  private class DrawState\n-  {\n-    private Paint paint;\n-    private Stroke stroke;\n-    private Color fg;\n-    private Color bg;\n-    private Shape clip;\n-    private AffineTransform transform;\n-    private Font font;\n-    private Composite comp;\n-\n-    DrawState(GdkGraphics2D g)\n-    {\n-      this.paint = g.paint;\n-      this.stroke = g.stroke;\n-      this.fg = g.fg;\n-      this.bg = g.bg;\n-      this.clip = g.clip;\n-      if (g.transform != null)\n-\tthis.transform = (AffineTransform) g.transform.clone();\n-      this.font = g.font;\n-      this.comp = g.comp;\n-    }\n-\n-    public void restore(GdkGraphics2D g)\n-    {\n-      g.paint = this.paint;\n-      g.stroke = this.stroke;\n-      g.fg = this.fg;\n-      g.bg = this.bg;\n-      g.clip = this.clip;\n-      g.transform = this.transform;\n-      g.font = this.font;\n-      g.comp = this.comp;\n-    }\n-  }\n-\n-  private void stateSave()\n-  {\n-    stateStack.push(new DrawState(this));\n-    cairoSave();\n-  }\n-\n-  private void stateRestore()\n-  {\n-    ((DrawState) (stateStack.pop())).restore(this);\n-    cairoRestore();\n-  }\n-\n-  // Some operations (drawing rather than filling) require that their\n-  // coords be shifted to land on 0.5-pixel boundaries, in order to land on\n-  // \"middle of pixel\" coordinates and light up complete pixels.\n-  private boolean shiftDrawCalls = false;\n-\n-  private double shifted(double coord, boolean doShift)\n-  {\n-    if (doShift)\n-      return Math.floor(coord) + 0.5;\n-    else\n-      return coord;\n-  }\n-\n-  private void walkPath(PathIterator p, boolean doShift)\n-  {\n-    double x = 0;\n-    double y = 0;\n-    double[] coords = new double[6];\n-\n-    cairoSetFillRule(p.getWindingRule());\n-    for (; ! p.isDone(); p.next())\n-      {\n-\tint seg = p.currentSegment(coords);\n-\tswitch (seg)\n-\t  {\n-\t  case PathIterator.SEG_MOVETO:\n-\t    x = shifted(coords[0], doShift);\n-\t    y = shifted(coords[1], doShift);\n-\t    cairoMoveTo(x, y);\n-\t    break;\n-\t  case PathIterator.SEG_LINETO:\n-\t    x = shifted(coords[0], doShift);\n-\t    y = shifted(coords[1], doShift);\n-\t    cairoLineTo(x, y);\n-\t    break;\n-\t  case PathIterator.SEG_QUADTO:\n-\t    // splitting a quadratic bezier into a cubic:\n-\t    // see: http://pfaedit.sourceforge.net/bezier.html\n-\t    double x1 = x + (2.0 / 3.0) * (shifted(coords[0], doShift) - x);\n-\t    double y1 = y + (2.0 / 3.0) * (shifted(coords[1], doShift) - y);\n-\n-\t    double x2 = x1 + (1.0 / 3.0) * (shifted(coords[2], doShift) - x);\n-\t    double y2 = y1 + (1.0 / 3.0) * (shifted(coords[3], doShift) - y);\n \n-\t    x = shifted(coords[2], doShift);\n-\t    y = shifted(coords[3], doShift);\n-\t    cairoCurveTo(x1, y1, x2, y2, x, y);\n-\t    break;\n-\t  case PathIterator.SEG_CUBICTO:\n-\t    x = shifted(coords[4], doShift);\n-\t    y = shifted(coords[5], doShift);\n-\t    cairoCurveTo(shifted(coords[0], doShift),\n-\t                 shifted(coords[1], doShift),\n-\t                 shifted(coords[2], doShift),\n-\t                 shifted(coords[3], doShift), x, y);\n-\t    break;\n-\t  case PathIterator.SEG_CLOSE:\n-\t    cairoClosePath();\n-\t    break;\n-\t  }\n-      }\n-  }\n+  /**\n+   * Sets the current winding rule in Cairo\n+   */\n+  private native void cairoSetFillRule(int cairoFillRule);\n \n-  private Map getDefaultHints()\n-  {\n-    HashMap defaultHints = new HashMap();\n+  /**\n+   * Set the line style, cap, join and miter limit.\n+   * Cap and join parameters are in the BasicStroke enumerations.\n+   */\n+  private native void cairoSetLine(double width, int cap, int join, double miterLimit);\n \n-    defaultHints.put(RenderingHints.KEY_TEXT_ANTIALIASING,\n-                     RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT);\n+  /**\n+   * Set the dash style\n+   */\n+  private native void cairoSetDash(double[] dashes, int ndash, double offset);\n \n-    defaultHints.put(RenderingHints.KEY_STROKE_CONTROL,\n-                     RenderingHints.VALUE_STROKE_DEFAULT);\n+  /*\n+   * Draws a Glyph Vector\n+   */\n+  native void cairoDrawGlyphVector(GdkFontPeer font, \n+                                   float x, float y, int n, \n+                                   int[] codes, float[] positions);\n \n-    defaultHints.put(RenderingHints.KEY_FRACTIONALMETRICS,\n-                     RenderingHints.VALUE_FRACTIONALMETRICS_OFF);\n \n-    defaultHints.put(RenderingHints.KEY_ANTIALIASING,\n-                     RenderingHints.VALUE_ANTIALIAS_OFF);\n+  private native void cairoRelCurveTo(double dx1, double dy1, double dx2,\n+                                      double dy2, double dx3, double dy3);\n \n-    defaultHints.put(RenderingHints.KEY_RENDERING,\n-                     RenderingHints.VALUE_RENDER_DEFAULT);\n+  /**\n+   * Appends a rectangle to the current path\n+   */\n+  private native void cairoRectangle(double x, double y, double width,\n+                                     double height);\n \n-    return defaultHints;\n-  }\n+  /**\n+   * New current path\n+   */\n+  private native void cairoNewPath();\n \n-  public static int[] findSimpleIntegerArray (ColorModel cm, Raster raster)\n-  {\n-    if (cm == null || raster == null)\n-      return null;\n+  /** \n+   * Close current path\n+   */\n+  private native void cairoClosePath();\n \n-    if (! cm.getColorSpace().isCS_sRGB())\n-      return null;\n+  /** moveTo */\n+  private native void cairoMoveTo(double x, double y);\n \n-    if (! (cm instanceof DirectColorModel))\n-      return null;\n+  /** relative moveTo */\n+  private native void cairoRelMoveTo(double dx, double dy);\n \n-    DirectColorModel dcm = (DirectColorModel) cm;\n+  /** lineTo */\n+  private native void cairoLineTo(double x, double y);\n \n-    if (dcm.getRedMask() != 0x00FF0000 || dcm.getGreenMask() != 0x0000FF00\n-        || dcm.getBlueMask() != 0x000000FF)\n-      return null;\n+  /** relative lineTo */\n+  private native void cairoRelLineTo(double dx, double dy);\n \n-    if (! (raster instanceof WritableRaster))\n-      return null;\n+  /** Cubic curve-to */\n+  private native void cairoCurveTo(double x1, double y1, double x2, double y2,\n+                                   double x3, double y3);\n \n-    if (raster.getSampleModel().getDataType() != DataBuffer.TYPE_INT)\n-      return null;\n+  /**\n+   * Stroke current path\n+   */\n+  private native void cairoStroke();\n \n-    if (! (raster.getDataBuffer() instanceof DataBufferInt))\n-      return null;\n+  /**\n+   * Fill current path\n+   */\n+  private native void cairoFill();\n \n-    DataBufferInt db = (DataBufferInt) raster.getDataBuffer();\n+  /** \n+   * Clip current path\n+   */\n+  private native void cairoClip();\n \n-    if (db.getNumBanks() != 1)\n-      return null;\n+  /** \n+   * Save clip\n+   */\n+  private native void cairoPreserveClip();\n \n-    // Finally, we have determined that this is a single bank, [A]RGB-int\n-    // buffer in sRGB space. It's worth checking all this, because it means\n-    // that cairo can paint directly into the data buffer, which is very\n-    // fast compared to all the normal copying and converting.\n+  /** \n+   * Save clip\n+   */\n+  private native void cairoResetClip();\n \n-    return db.getData();\n-  }\n+  /**\n+   * Set interpolation types\n+   */\n+  private native void cairoSurfaceSetFilter(int filter);\n \n-  private void updateBufferedImage()\n+  ///////////////////////// TRANSFORMS ///////////////////////////////////\n+  /**\n+   * Set the current transform\n+   */ \n+  public void setTransform(AffineTransform tx)\n   {\n-    if (bimage != null && pixelConversionRequired)\n+    transform = tx;\n+    if (transform != null)\n       {\n-        int height = bimage.getHeight();\n-        int width = bimage.getWidth();\n-        int index = 0;\n-        for (int y = 0; y < height; ++y)\n-          for (int x = 0; x < width; ++x)\n-            bimage.setRGB(x, y, pixelBuffer[index++]);\n+\tdouble[] m = new double[6];\n+\ttransform.getMatrix(m);\n+\tcairoSetMatrix(m);\n       }\n   }\n-\n-  private boolean drawImage(Image img, AffineTransform xform,\n-                            Color bgcolor, ImageObserver obs)\n+  \n+  public void transform(AffineTransform tx)\n   {\n-    if (img == null)\n-      return false;\n-\n-    // FIXME: I'll fix this, /Sven\n-//     if (img instanceof GtkOffScreenImage\n-//         && img.getGraphics() instanceof GdkGraphics2D\n-//         && (xform == null || xform.getType() == AffineTransform.TYPE_IDENTITY\n-//         || xform.getType() == AffineTransform.TYPE_TRANSLATION))\n-//       {\n-// \t// we are being asked to flush a double buffer from Gdk\n-// \tGdkGraphics2D g2 = (GdkGraphics2D) img.getGraphics();\n-// \tgdkDrawDrawable(g2, (int) xform.getTranslateX(),\n-// \t                (int) xform.getTranslateY());\n-\n-// \tupdateBufferedImage();\n-\n-// \treturn true;\n-//       }\n-//     else\n+    if (transform == null)\n+      transform = new AffineTransform(tx);\n+    else\n+      transform.concatenate(tx);\n+    setTransform(transform);\n+    if (clip != null)\n       {\n-\t// In this case, xform is an AffineTransform that transforms bounding\n-\t// box of the specified image from image space to user space. However\n-\t// when we pass this transform to cairo, cairo will use this transform\n-\t// to map \"user coordinates\" to \"pixel\" coordinates, which is the \n-\t// other way around. Therefore to get the \"user -> pixel\" transform \n-\t// that cairo wants from \"image -> user\" transform that we currently\n-\t// have, we will need to invert the transformation matrix.\n-\tAffineTransform invertedXform = new AffineTransform();\n-\n+\t// FIXME: this should actuall try to transform the shape\n+\t// rather than degrade to bounds.\n+\tRectangle2D r = clip.getBounds2D();\n+\tdouble[] coords = new double[]\n+\t  {\n+\t    r.getX(), r.getY(), r.getX() + r.getWidth(),\n+\t    r.getY() + r.getHeight()\n+\t  };\n \ttry\n \t  {\n-\t    invertedXform = xform.createInverse();\n-\t    if (img instanceof BufferedImage)\n-\t      {\n-\t\t// draw an image which has actually been loaded \n-\t\t// into memory fully\n-\t\tBufferedImage b = (BufferedImage) img;\n-\t\treturn drawRaster(b.getColorModel(), b.getTile(0, 0),\n-\t\t                  invertedXform, bgcolor);\n-\t      }\n-\t    else\n-\t      return this.drawImage(GdkPixbufDecoder.createBufferedImage(img\n-\t                                                                 .getSource()),\n-\t                            xform, bgcolor, obs);\n+\t    tx.createInverse().transform(coords, 0, coords, 0, 2);\n+\t    r.setRect(coords[0], coords[1], coords[2] - coords[0],\n+\t              coords[3] - coords[1]);\n+\t    clip = r;\n \t  }\n-\tcatch (NoninvertibleTransformException e)\n+\tcatch (java.awt.geom.NoninvertibleTransformException e)\n \t  {\n-\t    throw new ImagingOpException(\"Unable to invert transform \"\n-\t                                 + xform.toString());\n \t  }\n       }\n   }\n \n-  //////////////////////////////////////////////////\n-  ////// Implementation of Graphics2D Methods //////\n-  //////////////////////////////////////////////////\n+  public void rotate(double theta)\n+  {\n+    transform(AffineTransform.getRotateInstance(theta));\n+  }\n \n-  public void draw(Shape s)\n+  public void rotate(double theta, double x, double y)\n   {\n-    if (stroke != null && ! (stroke instanceof BasicStroke))\n-      {\n-\tfill(stroke.createStrokedShape(s));\n-\treturn;\n-      }\n-\n-    cairoNewPath();\n-\n-    if (s instanceof Rectangle2D)\n-      {\n-\tRectangle2D r = (Rectangle2D) s;\n-\tcairoRectangle(shifted(r.getX(), shiftDrawCalls),\n-\t               shifted(r.getY(), shiftDrawCalls), r.getWidth(),\n-\t               r.getHeight());\n-      }\n-    else\n-      walkPath(s.getPathIterator(null), shiftDrawCalls);\n-    cairoStroke();\n+    transform(AffineTransform.getRotateInstance(theta, x, y));\n+  }\n \n-    updateBufferedImage();\n+  public void scale(double sx, double sy)\n+  {\n+    transform(AffineTransform.getScaleInstance(sx, sy));\n   }\n \n-  public void fill(Shape s)\n+  /**\n+   * Translate the system of the co-ordinates. As translation is a frequent\n+   * operation, it is done in an optimised way, unlike scaling and rotating.\n+   */\n+  public void translate(double tx, double ty)\n   {\n-    cairoNewPath();\n-    if (s instanceof Rectangle2D)\n+    if (transform != null)\n+      transform.translate(tx, ty);\n+    else\n+      transform = AffineTransform.getTranslateInstance(tx, ty);\n+\n+    if (clip != null)\n       {\n-\tRectangle2D r = (Rectangle2D) s;\n-\tcairoRectangle(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n+        // FIXME: this should actuall try to transform the shape\n+        // rather than degrade to bounds.\n+        Rectangle2D r;\n+\n+        if (clip instanceof Rectangle2D)\n+          r = (Rectangle2D) clip;\n+        else\n+          r = clip.getBounds2D();\n+\n+        r.setRect(r.getX() - tx, r.getY() - ty, r.getWidth(), r.getHeight());\n+        clip = r;\n       }\n-    else\n-      walkPath(s.getPathIterator(null), false);\n \n-    cairoFill();\n+    setTransform(transform);\n+  }\n+  \n+  public void translate(int x, int y)\n+  {\n+    translate((double) x, (double) y);\n+  }\n \n-    updateBufferedImage();\n+  public void shear(double shearX, double shearY)\n+  {\n+    transform(AffineTransform.getShearInstance(shearX, shearY));\n   }\n \n+  ///////////////////////// DRAWING STATE ///////////////////////////////////\n+\n   public void clip(Shape s)\n   {\n-    // update it\n-    if (clip == null || s == null)\n-      clip = s;\n-    else if (s instanceof Rectangle2D && clip instanceof Rectangle2D)\n-      {\n-\tRectangle2D r = (Rectangle2D) s;\n-\tRectangle2D curr = (Rectangle2D) clip;\n-\tclip = curr.createIntersection(r);\n-      }\n-    else\n-      throw new UnsupportedOperationException();\n+    // Do not touch clip when s == null.\n+    if (s == null)\n+      return;\n \n-    // draw it\n-    if (clip != null)\n+    // If the current clip is still null, initialize it.\n+    if (clip == null)\n+      clip = originalClip;\n+    \n+    // This is so common, let's optimize this. \n+    else if (clip instanceof Rectangle2D && s instanceof Rectangle2D)\n       {\n-\tcairoNewPath();\n-\tif (clip instanceof Rectangle2D)\n-\t  {\n-\t    Rectangle2D r = (Rectangle2D) clip;\n-\t    cairoRectangle(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n-\t  }\n-\telse\n-\t  walkPath(clip.getPathIterator(null), false);\n-\n-\t// cairoClosePath ();\n-\tcairoClip();\n+        Rectangle2D clipRect = (Rectangle2D) clip;\n+        Rectangle2D r = (Rectangle2D) s;\n+        Rectangle2D.intersect(clipRect, r, clipRect);\n+        // Call setClip so that subclasses get notified.\n+        setClip(clipRect);\n       }\n+   else\n+     {\n+       Area current;\n+       if (clip instanceof Area)\n+         current = (Area) clip;\n+       else\n+         current = new Area(clip);\n+\n+       Area intersect;\n+       if (s instanceof Area)\n+         intersect = (Area) s;\n+       else\n+         intersect = new Area(s);\n+\n+       current.intersect(intersect);\n+       clip = current;\n+       // Call setClip so that the native side gets notified.\n+       setClip(clip);\n+     }\n   }\n \n   public Paint getPaint()\n@@ -720,8 +596,8 @@ else if (paint instanceof TexturePaint)\n \tint width = (int) tp.getAnchorRect().getWidth();\n \tint height = (int) tp.getAnchorRect().getHeight();\n \n-\tdouble scaleX = width / (double) img.getWidth();\n-\tdouble scaleY = width / (double) img.getHeight();\n+\tdouble scaleX = (width+1) / (double) img.getWidth();\n+\tdouble scaleY = (height+1) / (double) img.getHeight();\n \n \tAffineTransform at = new AffineTransform(scaleX, 0, 0, scaleY, 0, 0);\n \tAffineTransformOp op = new AffineTransformOp(at, getRenderingHints());\n@@ -744,131 +620,6 @@ else if (paint instanceof GradientPaint)\n       throw new java.lang.UnsupportedOperationException();\n   }\n \n-  public void setPaintUnlocked(Paint p)\n-  {\n-    if (paint == null)\n-      return;\n-\n-    paint = p;\n-    if (paint instanceof Color)\n-      {\n-        setColorUnlocked((Color) paint);\n-      }\n-    else if (paint instanceof TexturePaint)\n-      {\n-\tTexturePaint tp = (TexturePaint) paint;\n-\tBufferedImage img = tp.getImage();\n-\n-\t// map the image to the anchor rectangle  \n-\tint width = (int) tp.getAnchorRect().getWidth();\n-\tint height = (int) tp.getAnchorRect().getHeight();\n-\n-\tdouble scaleX = width / (double) img.getWidth();\n-\tdouble scaleY = width / (double) img.getHeight();\n-\n-\tAffineTransform at = new AffineTransform(scaleX, 0, 0, scaleY, 0, 0);\n-\tAffineTransformOp op = new AffineTransformOp(at, getRenderingHints());\n-\tBufferedImage texture = op.filter(img, null);\n-\tint[] pixels = texture.getRGB(0, 0, width, height, null, 0, width);\n-\tsetTexturePixelsUnlocked(pixels, width, height, width);\n-      }\n-    else if (paint instanceof GradientPaint)\n-      {\n-\tGradientPaint gp = (GradientPaint) paint;\n-\tPoint2D p1 = gp.getPoint1();\n-\tPoint2D p2 = gp.getPoint2();\n-\tColor c1 = gp.getColor1();\n-\tColor c2 = gp.getColor2();\n-\tsetGradientUnlocked(p1.getX(), p1.getY(), p2.getX(), p2.getY(), c1.getRed(),\n-\t            c1.getGreen(), c1.getBlue(), c1.getAlpha(), c2.getRed(),\n-\t            c2.getGreen(), c2.getBlue(), c2.getAlpha(), gp.isCyclic());\n-      }\n-    else\n-      throw new java.lang.UnsupportedOperationException();\n-  }\n-\n-  public void setTransform(AffineTransform tx)\n-  {\n-    transform = tx;\n-    if (transform != null)\n-      {\n-\tdouble[] m = new double[6];\n-\ttransform.getMatrix(m);\n-\tcairoSetMatrix(m);\n-      }\n-  }\n-\n-  public void setTransformUnlocked(AffineTransform tx)\n-  {\n-    transform = tx;\n-    if (transform != null)\n-      {\n-\tdouble[] m = new double[6];\n-\ttransform.getMatrix(m);\n-\tcairoSetMatrixUnlocked(m);\n-      }\n-  }\n-\n-  public void transform(AffineTransform tx)\n-  {\n-    if (transform == null)\n-      transform = new AffineTransform(tx);\n-    else\n-      transform.concatenate(tx);\n-    setTransform(transform);\n-    if (clip != null)\n-      {\n-\t// FIXME: this should actuall try to transform the shape\n-\t// rather than degrade to bounds.\n-\tRectangle2D r = clip.getBounds2D();\n-\tdouble[] coords = new double[]\n-\t                  {\n-\t                    r.getX(), r.getY(), r.getX() + r.getWidth(),\n-\t                    r.getY() + r.getHeight()\n-\t                  };\n-\ttry\n-\t  {\n-\t    tx.createInverse().transform(coords, 0, coords, 0, 2);\n-\t    r.setRect(coords[0], coords[1], coords[2] - coords[0],\n-\t              coords[3] - coords[1]);\n-\t    clip = r;\n-\t  }\n-\tcatch (java.awt.geom.NoninvertibleTransformException e)\n-\t  {\n-\t  }\n-      }\n-  }\n-\n-  public void rotate(double theta)\n-  {\n-    transform(AffineTransform.getRotateInstance(theta));\n-  }\n-\n-  public void rotate(double theta, double x, double y)\n-  {\n-    transform(AffineTransform.getRotateInstance(theta, x, y));\n-  }\n-\n-  public void scale(double sx, double sy)\n-  {\n-    transform(AffineTransform.getScaleInstance(sx, sy));\n-  }\n-\n-  public void translate(double tx, double ty)\n-  {\n-    transform(AffineTransform.getTranslateInstance(tx, ty));\n-  }\n-\n-  public void translate(int x, int y)\n-  {\n-    translate((double) x, (double) y);\n-  }\n-\n-  public void shear(double shearX, double shearY)\n-  {\n-    transform(AffineTransform.getShearInstance(shearX, shearY));\n-  }\n-\n   public Stroke getStroke()\n   {\n     return stroke;\n@@ -880,10 +631,9 @@ public void setStroke(Stroke st)\n     if (stroke instanceof BasicStroke)\n       {\n \tBasicStroke bs = (BasicStroke) stroke;\n-\tcairoSetLineCap(bs.getEndCap());\n-\tcairoSetLineWidth(bs.getLineWidth());\n-\tcairoSetLineJoin(bs.getLineJoin());\n-\tcairoSetMiterLimit(bs.getMiterLimit());\n+\tcairoSetLine(bs.getLineWidth(), bs.getEndCap(), \n+\t\t     bs.getLineJoin(), bs.getMiterLimit());\n+\n \tfloat[] dashes = bs.getDashArray();\n \tif (dashes != null)\n \t  {\n@@ -898,42 +648,14 @@ public void setStroke(Stroke st)\n       }\n   }\n \n-  public void setStrokeUnlocked(Stroke st)\n-  {\n-    stroke = st;\n-    if (stroke instanceof BasicStroke)\n-      {\n-\tBasicStroke bs = (BasicStroke) stroke;\n-\tcairoSetLineCapUnlocked(bs.getEndCap());\n-\tcairoSetLineWidthUnlocked(bs.getLineWidth());\n-\tcairoSetLineJoinUnlocked(bs.getLineJoin());\n-\tcairoSetMiterLimitUnlocked(bs.getMiterLimit());\n-\tfloat[] dashes = bs.getDashArray();\n-\tif (dashes != null)\n-\t  {\n-\t    double[] double_dashes = new double[dashes.length];\n-\t    for (int i = 0; i < dashes.length; i++)\n-\t      double_dashes[i] = dashes[i];\n-\t    cairoSetDashUnlocked(double_dashes, double_dashes.length,\n-                                 (double) bs.getDashPhase());\n-\t  }\n-\telse\n-\t  cairoSetDashUnlocked(new double[0], 0, 0.0);\n-      }\n-  }\n-\n-  ////////////////////////////////////////////////\n-  ////// Implementation of Graphics Methods //////\n-  ////////////////////////////////////////////////\n-\n   public void setPaintMode()\n   {\n-    setComposite(java.awt.AlphaComposite.SrcOver);\n+    setComposite(AlphaComposite.SrcOver);\n   }\n \n   public void setXORMode(Color c)\n   {\n-    setComposite(new gnu.java.awt.BitwiseXORComposite(c));\n+    // FIXME: implement\n   }\n \n   public void setColor(Color c)\n@@ -943,18 +665,17 @@ public void setColor(Color c)\n \n     fg = c;\n     paint = c;\n-    cairoSetRGBAColor(fg.getRed() / 255.0, fg.getGreen() / 255.0,\n-                      fg.getBlue() / 255.0, fg.getAlpha() / 255.0);\n+    updateColor();\n   }\n-\n-  public void setColorUnlocked(Color c)\n+  \n+  /**\n+   * Set the current fg value as the cairo color.\n+   */\n+  void updateColor()\n   {\n-    if (c == null)\n-      c = Color.BLACK;\n-\n-    fg = c;\n-    paint = c;\n-    cairoSetRGBAColorUnlocked(fg.getRed() / 255.0, fg.getGreen() / 255.0,\n+    if (fg == null)\n+      fg = Color.BLACK;\n+    cairoSetRGBAColor(fg.getRed() / 255.0, fg.getGreen() / 255.0,\n                       fg.getBlue() / 255.0, fg.getAlpha() / 255.0);\n   }\n \n@@ -963,11 +684,6 @@ public Color getColor()\n     return fg;\n   }\n \n-  public Color getColorUnlocked()\n-  {\n-    return getColor();\n-  }\n-\n   public void clipRect(int x, int y, int width, int height)\n   {\n     clip(new Rectangle(x, y, width, height));\n@@ -1011,81 +727,41 @@ protected Rectangle2D getClipInDevSpace()\n \n   public void setClip(int x, int y, int width, int height)\n   {\n-    setClip(new Rectangle2D.Double((double) x, (double) y, (double) width,\n-                                   (double) height));\n+    if( width < 0 || height < 0 )\n+      return;\n+\n+    setClip(new Rectangle2D.Double(x, y, width, height));\n   }\n \n   public void setClip(Shape s)\n-  {\n-    clip = s;\n-    if (clip == null)\n-      {\n-\t// Reset clipping.\n-        if (component != null)\n-          {\n-            Dimension d = component.awtComponent.getSize();\n-            setClip(0, 0, d.width, d.height);\n-          }\n-      }\n-    else\n+  {    \n+    // The first time the clip is set, save it as the original clip \n+    // to reset to on s == null. We can rely on this being non-null \n+    // because the constructor in subclasses is expected to set the \n+    // initial clip properly.\n+    if( firstClip )\n       {\n-\tcairoNewPath();\n-\tif (s instanceof Rectangle2D)\n-\t  {\n-\t    Rectangle2D r = (Rectangle2D) s;\n-\t    cairoRectangle(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n-\t  }\n-\telse\n-\t  walkPath(s.getPathIterator(null), false);\n-\n-\t// cairoClosePath ();\n-\tcairoClip();\n+\toriginalClip = s;\n+\tfirstClip = false;\n       }\n-  }\n-\n-  private static BasicStroke draw3DRectStroke = new BasicStroke();\n-\n-  public void draw3DRect(int x, int y, int width, int height, boolean raised)\n-  {\n-    Stroke tmp = stroke;\n-    setStroke(draw3DRectStroke);\n-    super.draw3DRect(x, y, width, height, raised);\n-    setStroke(tmp);\n-    updateBufferedImage();\n-  }\n-\n-  public void fill3DRect(int x, int y, int width, int height, boolean raised)\n-  {\n-    Stroke tmp = stroke;\n-    setStroke(draw3DRectStroke);\n-    super.fill3DRect(x, y, width, height, raised);\n-    setStroke(tmp);\n-    updateBufferedImage();\n-  }\n \n-  public void drawRect(int x, int y, int width, int height)\n-  {\n-    draw(new Rectangle(x, y, width, height));\n-  }\n+    if (s == null)\n+      clip = originalClip;\n+    else\n+      clip = s;\n \n-  public void fillRect(int x, int y, int width, int height)\n-  {\n-    cairoNewPath();\n-    cairoRectangle(x, y, width, height);\n-    cairoFill();\n-  }\n+    cairoResetClip();\n \n-  public void clearRect(int x, int y, int width, int height)\n-  {\n-    if (bg != null)\n-      cairoSetRGBAColor(bg.getRed() / 255.0, bg.getGreen() / 255.0,\n-\t\t\tbg.getBlue() / 255.0, 1.0);\n     cairoNewPath();\n-    cairoRectangle(x, y, width, height);\n-    cairoFill();\n-    setColor(fg);\n-\n-    updateBufferedImage();\n+    if (clip instanceof Rectangle2D)\n+      {\n+\tRectangle2D r = (Rectangle2D) clip;\n+\tcairoRectangle(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n+      }\n+    else\n+      walkPath(clip.getPathIterator(null), false);\n+    \n+    cairoClip();\n   }\n \n   public void setBackground(Color c)\n@@ -1095,203 +771,232 @@ public void setBackground(Color c)\n     bg = c;\n   }\n \n-  public void setBackgroundUnlocked(Color c)\n+  public Color getBackground()\n   {\n-    setBackground(c);\n+    return bg;\n   }\n \n-  public Color getBackground()\n+  /**\n+   * Return the current composite.\n+   */\n+  public Composite getComposite()\n   {\n-    return bg;\n+    if (comp == null)\n+      return AlphaComposite.SrcOver;\n+    else\n+      return comp;\n   }\n \n-  private void doPolygon(int[] xPoints, int[] yPoints, int nPoints,\n-                         boolean close, boolean fill)\n+  /**\n+   * Sets the current composite context.\n+   */\n+  public void setComposite(Composite comp)\n   {\n-    if (nPoints < 1)\n-      return;\n-    GeneralPath gp = new GeneralPath(PathIterator.WIND_EVEN_ODD);\n-    gp.moveTo((float) xPoints[0], (float) yPoints[0]);\n-    for (int i = 1; i < nPoints; i++)\n-      gp.lineTo((float) xPoints[i], (float) yPoints[i]);\n-\n-    if (close)\n-      gp.closePath();\n+    this.comp = comp;\n \n-    Shape sh = gp;\n-    if (fill == false && stroke != null && ! (stroke instanceof BasicStroke))\n+    if (comp instanceof AlphaComposite)\n       {\n-\tsh = stroke.createStrokedShape(gp);\n-\tfill = true;\n+\tAlphaComposite a = (AlphaComposite) comp;\n+\tcairoSetOperator(a.getRule());\n+\tColor c = getColor();\n+\tsetColor(new Color(c.getRed(), c.getGreen(), c.getBlue(),\n+\t                   (int) (a.getAlpha() * ((float) c.getAlpha()))));\n       }\n-\n-    if (fill)\n-      fill(sh);\n     else\n-      draw(sh);\n+      {\n+        // FIXME: implement general Composite support\n+        throw new java.lang.UnsupportedOperationException();\n+      }\n   }\n \n-  public void drawLine(int x1, int y1, int x2, int y2)\n+  ///////////////////////// DRAWING PRIMITIVES ///////////////////////////////////\n+\n+  public void draw(Shape s)\n   {\n-    int[] xp = new int[2];\n-    int[] yp = new int[2];\n+    if (stroke != null && ! (stroke instanceof BasicStroke))\n+      {\n+\tfill(stroke.createStrokedShape(s));\n+\treturn;\n+      }\n \n-    xp[0] = x1;\n-    xp[1] = x2;\n-    yp[0] = y1;\n-    yp[1] = y2;\n+    cairoNewPath();\n \n-    doPolygon(xp, yp, 2, false, false);\n+    if (s instanceof Rectangle2D)\n+      {\n+\tRectangle2D r = (Rectangle2D) s;\n+\tcairoRectangle(shifted(r.getX(), shiftDrawCalls),\n+\t               shifted(r.getY(), shiftDrawCalls), r.getWidth(),\n+\t               r.getHeight());\n+      }\n+    else\n+      walkPath(s.getPathIterator(null), shiftDrawCalls);\n+    cairoStroke();\n   }\n \n-  public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  public void fill(Shape s)\n   {\n-    doPolygon(xPoints, yPoints, nPoints, true, true);\n+    cairoNewPath();\n+    if (s instanceof Rectangle2D)\n+      {\n+\tRectangle2D r = (Rectangle2D) s;\n+\tcairoRectangle(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n+      }\n+    else\n+      walkPath(s.getPathIterator(null), false);\n+\n+    cairoFill();\n   }\n \n-  public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  /**\n+   * Note that the rest of the drawing methods go via fill() or draw() for the drawing,\n+   * although subclasses may with to overload these methods where context-specific \n+   * optimizations are possible (e.g. bitmaps and fillRect(int, int, int, int)\n+   */\n+\n+  public void clearRect(int x, int y, int width, int height)\n   {\n-    doPolygon(xPoints, yPoints, nPoints, true, false);\n+    if (bg != null)\n+      cairoSetRGBAColor(bg.getRed() / 255.0, bg.getGreen() / 255.0,\n+\t\t\tbg.getBlue() / 255.0, 1.0);\n+    fillRect(x, y, width, height);\n+    updateColor();\n   }\n \n-  public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)\n+  public void draw3DRect(int x, int y, int width, int height, boolean raised)\n   {\n-    doPolygon(xPoints, yPoints, nPoints, false, false);\n+    Stroke tmp = stroke;\n+    setStroke(draw3DRectStroke);\n+    super.draw3DRect(x, y, width, height, raised);\n+    setStroke(tmp);\n   }\n \n-  private boolean drawRaster(ColorModel cm, Raster r,\n-                             AffineTransform imageToUser, Color bgcolor)\n+  public void drawArc(int x, int y, int width, int height, int startAngle,\n+                      int arcAngle)\n   {\n-    if (r == null)\n-      return false;\n-\n-    SampleModel sm = r.getSampleModel();\n-    DataBuffer db = r.getDataBuffer();\n-\n-    if (db == null || sm == null)\n-      return false;\n-\n-    if (cm == null)\n-      cm = ColorModel.getRGBdefault();\n-\n-    double[] i2u = new double[6];\n-    if (imageToUser != null)\n-      imageToUser.getMatrix(i2u);\n-    else\n-      {\n-\ti2u[0] = 1;\n-\ti2u[1] = 0;\n-\ti2u[2] = 0;\n-\ti2u[3] = 1;\n-\ti2u[4] = 0;\n-\ti2u[5] = 0;\n-      }\n-\n-    int[] pixels = findSimpleIntegerArray(cm, r);\n-\n-    if (pixels == null)\n-      {\n-\t// FIXME: I don't think this code will work correctly with a non-RGB\n-\t// MultiPixelPackedSampleModel. Although this entire method should \n-\t// probably be rewritten to better utilize Cairo's different supported\n-\t// data formats.\n-\tif (sm instanceof MultiPixelPackedSampleModel)\n-\t  {\n-\t    pixels = r.getPixels(0, 0, r.getWidth(), r.getHeight(), pixels);\n-\t    for (int i = 0; i < pixels.length; i++)\n-\t      pixels[i] = cm.getRGB(pixels[i]);\n-\t  }\n-\telse\n-\t  {\n-\t    pixels = new int[r.getWidth() * r.getHeight()];\n-\t    for (int i = 0; i < pixels.length; i++)\n-\t      pixels[i] = cm.getRGB(db.getElem(i));\n-\t  }\n-      }\n-\n-    // Change all transparent pixels in the image to the specified bgcolor,\n-    // or (if there's no alpha) fill in an alpha channel so that it paints\n-    // correctly.\n-    if (cm.hasAlpha())\n-      {\n-\tif (bgcolor != null && cm.hasAlpha())\n-\t  for (int i = 0; i < pixels.length; i++)\n-\t    {\n-\t      if (cm.getAlpha(pixels[i]) == 0)\n-\t\tpixels[i] = bgcolor.getRGB();\n-\t    }\n-      }\n-    else\n-      for (int i = 0; i < pixels.length; i++)\n-\tpixels[i] |= 0xFF000000;\n+    draw(new Arc2D.Double((double) x, (double) y, (double) width,\n+                          (double) height, (double) startAngle,\n+                          (double) arcAngle, Arc2D.OPEN));\n+  }\n \n-    drawPixels(pixels, r.getWidth(), r.getHeight(), r.getWidth(), i2u);\n+  public void drawLine(int x1, int y1, int x2, int y2)\n+  {\n+    draw(new Line2D.Double(x1, y1, x2, y2));\n+  }\n \n-    updateBufferedImage();\n-    \n-    // Cairo seems loosing the current color.\n-    setColor(fg);\n-    \n-    return true;\n+  public void drawRect(int x, int y, int width, int height)\n+  {\n+    draw(new Rectangle(x, y, width, height));\n   }\n \n-  public void drawRenderedImage(RenderedImage image, AffineTransform xform)\n+  public void fillArc(int x, int y, int width, int height, int startAngle,\n+                      int arcAngle)\n   {\n-    drawRaster(image.getColorModel(), image.getData(), xform, bg);\n+    fill(new Arc2D.Double((double) x, (double) y, (double) width,\n+                          (double) height, (double) startAngle,\n+                          (double) arcAngle, Arc2D.OPEN));\n   }\n \n-  public void drawRenderableImage(RenderableImage image, AffineTransform xform)\n+  public void fillRect(int x, int y, int width, int height)\n   {\n-    drawRenderedImage(image.createRendering(new RenderContext(xform)), xform);\n+    fill(new Rectangle(x, y, width, height));\n   }\n \n-  public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs)\n+  public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)\n   {\n-    return drawImage(img, xform, bg, obs);\n+    fill(new Polygon(xPoints, yPoints, nPoints));\n   }\n \n-  public void drawImage(BufferedImage image, BufferedImageOp op, int x, int y)\n+  public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)\n   {\n-    Image filtered = op.filter(image, null);\n-    drawImage(filtered, new AffineTransform(1f, 0f, 0f, 1f, x, y), bg, null);\n+    draw(new Polygon(xPoints, yPoints, nPoints));\n   }\n \n-  public boolean drawImage(Image img, int x, int y, ImageObserver observer)\n+  public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)\n   {\n-    return drawImage(img, new AffineTransform(1f, 0f, 0f, 1f, x, y), bg,\n-                     observer);\n+    draw(new Polygon(xPoints, yPoints, nPoints));\n   }\n \n-  ///////////////////////////////////////////////\n-  ////// Unimplemented Stubs and Overloads //////\n-  ///////////////////////////////////////////////\n+  public void drawOval(int x, int y, int width, int height)\n+  {\n+    drawArc(x, y, width, height, 0, 360);\n+  }\n \n-  public boolean hit(Rectangle rect, Shape text, boolean onStroke)\n+  public void drawRoundRect(int x, int y, int width, int height, int arcWidth,\n+                            int arcHeight)\n   {\n-    throw new java.lang.UnsupportedOperationException();\n+    draw(new RoundRectangle2D.Double(x, y, width, height, arcWidth, arcHeight));\n   }\n \n-  public GraphicsConfiguration getDeviceConfiguration()\n+  public void fillOval(int x, int y, int width, int height)\n   {\n-    throw new java.lang.UnsupportedOperationException();\n+    fillArc(x, y, width, height, 0, 360);\n   }\n \n-  public void setComposite(Composite comp)\n+  public void fillRoundRect(int x, int y, int width, int height, int arcWidth,\n+                            int arcHeight)\n   {\n-    this.comp = comp;\n+    fill(new RoundRectangle2D.Double(x, y, width, height, arcWidth, arcHeight));\n+  }\n+\n+  /**\n+   * CopyArea - performs clipping to the native surface as a convenience \n+   * (requires getRealBounds). Then calls copyAreaImpl.\n+   */\n+  public void copyArea(int ox, int oy, int owidth, int oheight, \n+\t\t       int odx, int ody)\n+  {\n+    Point2D pos = transform.transform(new Point2D.Double(ox, oy),\n+\t\t\t\t      (Point2D) null);\n+    Point2D dim = transform.transform(new Point2D.Double(ox + owidth, \n+\t\t\t\t\t\t\t oy + oheight),\n+\t\t\t\t      (Point2D) null);\n+    Point2D p2 = transform.transform(new Point2D.Double(ox + odx, oy + ody),\n+\t\t\t\t     (Point2D) null);\n+    int x = (int)pos.getX();\n+    int y = (int)pos.getY();\n+    int width = (int)(dim.getX() - pos.getX());\n+    int height = (int)(dim.getY() - pos.getY());\n+    int dx = (int)(p2.getX() - pos.getX());\n+    int dy = (int)(p2.getY() - pos.getY());\n+\n+    Rectangle2D r = getRealBounds();\n+\n+    if( width < 0 || height < 0 )\n+      return;\n+    // Return if outside the surface\n+    if( x + dx > r.getWidth() || y + dy > r.getHeight() )\n+      return;\n \n-    if (comp instanceof AlphaComposite)\n+    if( x + dx + width < r.getX() || y + dy + height < r.getY() )\n+      return;\n+\n+    // Clip edges if necessary \n+    if( x + dx < r.getX() ) // left\n       {\n-\tAlphaComposite a = (AlphaComposite) comp;\n-\tcairoSetOperator(a.getRule());\n-\tColor c = getColor();\n-\tsetColor(new Color(c.getRed(), c.getGreen(), c.getBlue(),\n-\t                   (int) (a.getAlpha() * ((float) c.getAlpha()))));\n+\twidth = x + dx + width;\n+\tx = (int)r.getX() - dx;\n       }\n-    else\n-      throw new java.lang.UnsupportedOperationException();\n+\n+    if( y + dy < r.getY() ) // top\n+      {\n+\theight = y + dy + height;\n+\ty = (int)r.getY() - dy;\n+      }\n+\n+    if( x + dx + width >= r.getWidth() ) // right\n+      width = (int)r.getWidth() - dx - x;\n+\n+    if( y + dy + height >= r.getHeight() ) // bottom\n+      height = (int)r.getHeight() - dy - y;\n+\n+    copyAreaImpl(x, y, width, height, dx, dy);\n   }\n \n+  ///////////////////////// RENDERING HINTS ///////////////////////////////////\n+\n+  /**\n+   * FIXME- support better\n+   */\n   public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue)\n   {\n     hints.put(hintKey, hintValue);\n@@ -1316,7 +1021,7 @@ else if (hintValue.equals(RenderingHints.VALUE_ALPHA_INTERPOLATION_DEFAULT))\n       }\n \n     shiftDrawCalls = hints.containsValue(RenderingHints.VALUE_STROKE_NORMALIZE)\n-                     || hints.containsValue(RenderingHints.VALUE_STROKE_DEFAULT);\n+      || hints.containsValue(RenderingHints.VALUE_STROKE_DEFAULT);\n   }\n \n   public Object getRenderingHint(RenderingHints.Key hintKey)\n@@ -1351,74 +1056,137 @@ else if (hints.containsValue(RenderingHints.VALUE_ALPHA_INTERPOLATION_DEFAULT))\n       }\n \n     shiftDrawCalls = hints.containsValue(RenderingHints.VALUE_STROKE_NORMALIZE)\n-                     || hints.containsValue(RenderingHints.VALUE_STROKE_DEFAULT);\n+      || hints.containsValue(RenderingHints.VALUE_STROKE_DEFAULT);\n   }\n \n-  public void setRenderingHintsUnlocked(Map hints)\n+  public void addRenderingHints(Map hints)\n   {\n-    this.hints = new RenderingHints(getDefaultHints());\n     this.hints.add(new RenderingHints(hints));\n+  }\n \n-    if (hints.containsKey(RenderingHints.KEY_INTERPOLATION))\n-      {\n-\tif (hints.containsValue(RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR))\n-\t  cairoSurfaceSetFilterUnlocked(0);\n+  public RenderingHints getRenderingHints()\n+  {\n+    return hints;\n+  }\n \n-\telse if (hints.containsValue(RenderingHints.VALUE_INTERPOLATION_BILINEAR))\n-\t  cairoSurfaceSetFilterUnlocked(1);\n+  ///////////////////////// IMAGE. METHODS ///////////////////////////////////\n+\n+  protected boolean drawImage(Image img, AffineTransform xform,\n+                            Color bgcolor, ImageObserver obs)\n+  {\n+    if (img == null)\n+      return false;\n+\n+    // In this case, xform is an AffineTransform that transforms bounding\n+    // box of the specified image from image space to user space. However\n+    // when we pass this transform to cairo, cairo will use this transform\n+    // to map \"user coordinates\" to \"pixel\" coordinates, which is the \n+    // other way around. Therefore to get the \"user -> pixel\" transform \n+    // that cairo wants from \"image -> user\" transform that we currently\n+    // have, we will need to invert the transformation matrix.\n+    AffineTransform invertedXform = new AffineTransform();\n+\n+    try\n+      {\n+\tinvertedXform = xform.createInverse();\n+      }\n+    catch (NoninvertibleTransformException e)\n+      {\n+\tthrow new ImagingOpException(\"Unable to invert transform \"\n+\t\t\t\t     + xform.toString());\n       }\n \n-    if (hints.containsKey(RenderingHints.KEY_ALPHA_INTERPOLATION))\n+    // Unrecognized image - convert to a BufferedImage and come back.\n+    if( !(img instanceof BufferedImage) )\n+      return this.drawImage(Toolkit.getDefaultToolkit().\n+\t\t\t    createImage(img.getSource()),\n+\t\t\t    xform, bgcolor, obs);\n+\n+    BufferedImage b = (BufferedImage) img;\n+    DataBuffer db;\n+    double[] i2u = new double[6];\n+    int width = b.getWidth();\n+    int height = b.getHeight();\n+\n+    // If this BufferedImage has a BufferedImageGraphics object, \n+    // use the cached CairoSurface that BIG is drawing onto\n+    if( BufferedImageGraphics.bufferedImages.get( b ) != null )\n+      db = (DataBuffer)BufferedImageGraphics.bufferedImages.get( b );\n+    else\n+      db = b.getRaster().getDataBuffer();\n+\n+    invertedXform.getMatrix(i2u);\n+\n+    if(db instanceof CairoSurface)\n       {\n-\tif (hints.containsValue(RenderingHints.VALUE_ALPHA_INTERPOLATION_SPEED))\n-\t  cairoSurfaceSetFilterUnlocked(2);\n+\t((CairoSurface)db).drawSurface(this, i2u);\n+\treturn true;\n+      }\n+\t    \n+    if( bgcolor != null )\n+      {\n+\t// Fill a rectangle with the background color \n+\t// to composite the image onto.\n+\tPaint oldPaint = paint;\n+\tAffineTransform oldTransform = transform;\n+\tsetPaint( bgcolor );\n+\tsetTransform( invertedXform );\n+\tfillRect(0, 0, width, height);\n+\tsetTransform( oldTransform );\n+\tsetPaint( oldPaint );\n+      }\n \n-\telse if (hints.containsValue(RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY))\n-\t  cairoSurfaceSetFilterUnlocked(3);\n+    int[] pixels;\n \n-\telse if (hints.containsValue(RenderingHints.VALUE_ALPHA_INTERPOLATION_DEFAULT))\n-\t  cairoSurfaceSetFilterUnlocked(4);\n+    // Shortcut for easy color models.\n+    if( b.getColorModel().equals(rgb32) )\n+      {\n+\tpixels = ((DataBufferInt)db).getData();\n+\tfor(int i = 0; i < pixels.length; i++)\n+\t  pixels[i] |= 0xFF000000;\n+      }\n+    else if( b.getColorModel().equals(argb32) )\n+      {\n+\tpixels = ((DataBufferInt)db).getData();\n+      }\n+    else\n+      {\n+\tpixels = b.getRGB(0, 0, width, height,\n+\t\t\t  null, 0, width);\n       }\n \n-    shiftDrawCalls = hints.containsValue(RenderingHints.VALUE_STROKE_NORMALIZE)\n-                     || hints.containsValue(RenderingHints.VALUE_STROKE_DEFAULT);\n+    drawPixels(pixels, width, height, width, i2u);\n+\n+    // Cairo seems to lose the current color which must be restored.\n+    updateColor();\n+    return true;\n   }\n \n-  public void addRenderingHints(Map hints)\n+  public void drawRenderedImage(RenderedImage image, AffineTransform xform)\n   {\n-    this.hints.add(new RenderingHints(hints));\n+    drawRaster(image.getColorModel(), image.getData(), xform, null);\n   }\n \n-  public RenderingHints getRenderingHints()\n+  public void drawRenderableImage(RenderableImage image, AffineTransform xform)\n   {\n-    return hints;\n+    drawRenderedImage(image.createRendering(new RenderContext(xform)), xform);\n   }\n \n-  public Composite getComposite()\n+  public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs)\n   {\n-    if (comp == null)\n-      return AlphaComposite.SrcOver;\n-    else\n-      return comp;\n+    return drawImage(img, xform, null, obs);\n   }\n \n-  public FontRenderContext getFontRenderContext()\n+  public void drawImage(BufferedImage image, BufferedImageOp op, int x, int y)\n   {\n-    return new FontRenderContext(transform, true, true);\n+    Image filtered = op.filter(image, null);\n+    drawImage(filtered, new AffineTransform(1f, 0f, 0f, 1f, x, y), null, null);\n   }\n \n-  public void copyArea(int x, int y, int width, int height, int dx, int dy)\n+  public boolean drawImage(Image img, int x, int y, ImageObserver observer)\n   {\n-    GdkGraphics2D g = (GdkGraphics2D) create(x, y, width, height);\n-    gdkDrawDrawable(g, x + dx, y + dy);\n-  }\n-\n-  public void drawArc(int x, int y, int width, int height, int startAngle,\n-                      int arcAngle)\n-  {\n-    draw(new Arc2D.Double((double) x, (double) y, (double) width,\n-                          (double) height, (double) startAngle,\n-                          (double) arcAngle, Arc2D.OPEN));\n+    return drawImage(img, new AffineTransform(1f, 0f, 0f, 1f, x, y), null,\n+                     observer);\n   }\n \n   public boolean drawImage(Image img, int x, int y, Color bgcolor,\n@@ -1433,6 +1201,8 @@ public boolean drawImage(Image img, int x, int y, int width, int height,\n   {\n     double scaleX = width / (double) img.getWidth(observer);\n     double scaleY = height / (double) img.getHeight(observer);\n+    if( scaleX == 0 || scaleY == 0 )\n+      return true;\n \n     return drawImage(img, new AffineTransform(scaleX, 0f, 0f, scaleY, x, y),\n                      bgcolor, observer);\n@@ -1441,7 +1211,7 @@ public boolean drawImage(Image img, int x, int y, int width, int height,\n   public boolean drawImage(Image img, int x, int y, int width, int height,\n                            ImageObserver observer)\n   {\n-    return drawImage(img, x, y, width, height, bg, observer);\n+    return drawImage(img, x, y, width, height, null, observer);\n   }\n \n   public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,\n@@ -1451,109 +1221,58 @@ public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,\n     if (img == null)\n       return false;\n \n-    Image subImage;\n-\n     int sourceWidth = sx2 - sx1;\n     int sourceHeight = sy2 - sy1;\n \n     int destWidth = dx2 - dx1;\n     int destHeight = dy2 - dy1;\n \n+    if(destWidth == 0 || destHeight == 0 || sourceWidth == 0 || \n+       sourceHeight == 0)\n+      return true;\n+\n     double scaleX = destWidth / (double) sourceWidth;\n     double scaleY = destHeight / (double) sourceHeight;\n \n-    // Get the subimage of the source enclosed in the \n-    // rectangle specified by sx1, sy1, sx2, sy2\n-\t\n-    if (img instanceof BufferedImage)\n-      {\n-\tBufferedImage b = (BufferedImage) img;\n-\tsubImage = b.getSubimage(sx1, sy1, sx2, sy2);\n-      }\n+    // FIXME: Avoid using an AT if possible here - it's at least twice as slow.\n+    \n+    Shape oldClip = getClip();\n+    int cx, cy, cw, ch;\n+    if( dx1 < dx2 ) \n+      { cx = dx1; cw = dx2 - dx1; }\n     else\n-      {\n-\t// FIXME: This code currently doesn't work. Null Pointer \n-\t// exception is thrown in this case. This happens \n-\t// because img.getSource() always returns null, since source gets \n-\t// never initialized when it is created with the help of \n-\t// createImage(int width, int height). \n-\tCropImageFilter filter = new CropImageFilter(sx1, sx2, sx2, sy2);\n-\tFilteredImageSource src = new FilteredImageSource(img.getSource(),\n-\t                                                  filter);\n-\n-\tsubImage = Toolkit.getDefaultToolkit().createImage(src);\n-      }\n+      { cx = dx2; cw = dx1 - dx2; }\n+    if( dy1 < dy2 ) \n+      { cy = dy1; ch = dy2 - dy1; }\n+    else\n+      { cy = dy2; ch = dy1 - dy2; }\n+    \n+    setClip( cx, cy, cw, ch );\n \n-    return drawImage(subImage,\n-                     new AffineTransform(scaleX, 0, 0, scaleY, dx1, dy1),\n-                     bgcolor, observer);\n+    AffineTransform tx = new AffineTransform();\n+    tx.translate( dx1 - sx1*scaleX, dy1 - sy1*scaleY );\n+    tx.scale( scaleX, scaleY );\n+\n+    boolean retval = drawImage(img, tx, bgcolor, observer);\n+    setClip( oldClip );\n+    return retval;\n   }\n \n   public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,\n                            int sx1, int sy1, int sx2, int sy2,\n                            ImageObserver observer)\n   {\n-    return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bg, observer);\n-  }\n-\n-  public void drawOval(int x, int y, int width, int height)\n-  {\n-    drawArc(x, y, width, height, 0, 360);\n-  }\n-\n-  public void drawRoundRect(int x, int y, int width, int height, int arcWidth,\n-                            int arcHeight)\n-  {\n-    if (arcWidth > width)\n-      arcWidth = width;\n-    if (arcHeight > height)\n-      arcHeight = height;\n-\n-    int xx = x + width - arcWidth;\n-    int yy = y + height - arcHeight;\n-\n-    drawArc(x, y, arcWidth, arcHeight, 90, 90);\n-    drawArc(xx, y, arcWidth, arcHeight, 0, 90);\n-    drawArc(xx, yy, arcWidth, arcHeight, 270, 90);\n-    drawArc(x, yy, arcWidth, arcHeight, 180, 90);\n-\n-    int y1 = y + arcHeight / 2;\n-    int y2 = y + height - arcHeight / 2;\n-    drawLine(x, y1, x, y2);\n-    drawLine(x + width, y1, x + width, y2);\n-\n-    int x1 = x + arcWidth / 2;\n-    int x2 = x + width - arcWidth / 2;\n-    drawLine(x1, y, x2, y);\n-    drawLine(x1, y + height, x2, y + height);\n-  }\n-\n-  // these are the most accelerated painting paths\n-  native void cairoDrawGlyphVector(GdkFontPeer font, \n-                                   float x, float y, int n, \n-                                   int[] codes, float[] positions);\n-\n-  native void cairoDrawGdkTextLayout(GdkTextLayout gl, \n-                                     float x, float y);\n-\n-  GdkFontPeer getFontPeer()\n-  {\n-    return (GdkFontPeer) getFont().getPeer();\n+    return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null, observer);\n   }\n \n-  public void drawGdkTextLayout(GdkTextLayout gl, float x, float y)\n-  {\n-    cairoDrawGdkTextLayout (gl, x, y);\n-    updateBufferedImage ();\n-  }\n+  ///////////////////////// TEXT METHODS ////////////////////////////////////\n \n   public void drawString(String str, float x, float y)\n   {\n     if (str == null || str.length() == 0)\n       return;\n \n     drawGlyphVector(getFont().createGlyphVector(null, str), x, y);\n-    updateBufferedImage ();\n   }\n \n   public void drawString(String str, int x, int y)\n@@ -1573,8 +1292,7 @@ public void drawGlyphVector(GlyphVector gv, float x, float y)\n     float[] positions = gv.getGlyphPositions (0, n, null);\n     \n     setFont (gv.getFont ());\n-    cairoDrawGlyphVector (getFontPeer(), x, y, n, codes, positions);\n-    updateBufferedImage ();\n+    cairoDrawGlyphVector( (GdkFontPeer)getFont().getPeer(), x, y, n, codes, positions);\n   }\n \n   public void drawString(AttributedCharacterIterator ci, float x, float y)\n@@ -1583,52 +1301,19 @@ public void drawString(AttributedCharacterIterator ci, float x, float y)\n     drawGlyphVector(gv, x, y);\n   }\n \n-  public void fillArc(int x, int y, int width, int height, int startAngle,\n-                      int arcAngle)\n-  {\n-    fill(new Arc2D.Double((double) x, (double) y, (double) width,\n-                          (double) height, (double) startAngle,\n-                          (double) arcAngle, Arc2D.OPEN));\n-  }\n-\n-  public void fillOval(int x, int y, int width, int height)\n-  {\n-    fillArc(x, y, width, height, 0, 360);\n-  }\n-\n-  public void fillRoundRect(int x, int y, int width, int height, int arcWidth,\n-                            int arcHeight)\n-  {\n-    if (arcWidth > width)\n-      arcWidth = width;\n-    if (arcHeight > height)\n-      arcHeight = height;\n-\n-    int xx = x + width - arcWidth;\n-    int yy = y + height - arcHeight;\n-\n-    fillArc(x, y, arcWidth, arcHeight, 90, 90);\n-    fillArc(xx, y, arcWidth, arcHeight, 0, 90);\n-    fillArc(xx, yy, arcWidth, arcHeight, 270, 90);\n-    fillArc(x, yy, arcWidth, arcHeight, 180, 90);\n-\n-    fillRect(x, y + arcHeight / 2, width, height - arcHeight + 1);\n-    fillRect(x + arcWidth / 2, y, width - arcWidth + 1, height);\n-  }\n-\n-  public Font getFont()\n+  /**\n+   * Should perhaps be contexct dependent, but this is left for now as an \n+   * overloadable default implementation.\n+   */\n+  public FontRenderContext getFontRenderContext()\n   {\n-    if (font == null)\n-      return new Font(\"SansSerif\", Font.PLAIN, 12);\n-    return font;\n+    return new FontRenderContext(transform, true, true);\n   }\n \n   // Until such time as pango is happy to talk directly to cairo, we\n   // actually need to redirect some calls from the GtkFontPeer and\n   // GtkFontMetrics into the drawing kit and ask cairo ourselves.\n \n-  static native void releasePeerGraphicsResource(GdkFontPeer f);\n-\n   public FontMetrics getFontMetrics()\n   {\n     return getFontMetrics(getFont());\n@@ -1656,9 +1341,25 @@ public void setFont(Font f)\n         .getFont(f.getName(), f.getAttributes());    \n   }\n \n-  public void setFontUnlocked(Font f)\n+  public Font getFont()\n   {\n-    setFont (f);\n+    if (font == null)\n+      return new Font(\"SansSerif\", Font.PLAIN, 12);\n+    return font;\n+  }\n+\n+  /////////////////////// MISC. PUBLIC METHODS /////////////////////////////////\n+\n+  public boolean hit(Rectangle rect, Shape s, boolean onStroke)\n+  {\n+    if( onStroke )\n+      {\n+\tShape stroked = stroke.createStrokedShape( s );\n+\treturn stroked.intersects( (double)rect.x, (double)rect.y, \n+\t\t\t\t   (double)rect.width, (double)rect.height );\n+      }\n+    return s.intersects( (double)rect.x, (double)rect.y, \n+\t\t\t (double)rect.width, (double)rect.height );\n   }\n \n   public String toString()\n@@ -1668,4 +1369,218 @@ public String toString()\n              + \",color=\" + fg.toString()\n \t     + \"]\");\n   }\n+\n+  ///////////////////////// PRIVATE METHODS ///////////////////////////////////\n+\n+  /**\n+   * All the drawImage() methods eventually get delegated here if the image\n+   * is not a Cairo surface.\n+   *\n+   * @param bgcolor - if non-null draws the background color before \n+   * drawing the image.\n+   */\n+  private boolean drawRaster(ColorModel cm, Raster r,\n+                             AffineTransform imageToUser, Color bgcolor)\n+  {\n+    if (r == null)\n+      return false;\n+\n+    SampleModel sm = r.getSampleModel();\n+    DataBuffer db = r.getDataBuffer();\n+\n+    if (db == null || sm == null)\n+      return false;\n+\n+    if (cm == null)\n+      cm = ColorModel.getRGBdefault();\n+\n+    double[] i2u = new double[6];\n+    if (imageToUser != null)\n+      imageToUser.getMatrix(i2u);\n+    else\n+      {\n+\ti2u[0] = 1;\n+\ti2u[1] = 0;\n+\ti2u[2] = 0;\n+\ti2u[3] = 1;\n+\ti2u[4] = 0;\n+\ti2u[5] = 0;\n+      }\n+\n+    int[] pixels = findSimpleIntegerArray(cm, r);\n+\n+    if (pixels == null)\n+      {\n+\t// FIXME: I don't think this code will work correctly with a non-RGB\n+\t// MultiPixelPackedSampleModel. Although this entire method should \n+\t// probably be rewritten to better utilize Cairo's different supported\n+\t// data formats.\n+\tif (sm instanceof MultiPixelPackedSampleModel)\n+\t  {\n+\t    pixels = r.getPixels(0, 0, r.getWidth(), r.getHeight(), pixels);\n+\t    for (int i = 0; i < pixels.length; i++)\n+\t      pixels[i] = cm.getRGB(pixels[i]);\n+\t  }\n+\telse\n+\t  {\n+\t    pixels = new int[r.getWidth() * r.getHeight()];\n+\t    for (int i = 0; i < pixels.length; i++)\n+\t      pixels[i] = cm.getRGB(db.getElem(i));\n+\t  }\n+      }\n+\n+    // Change all transparent pixels in the image to the specified bgcolor,\n+    // or (if there's no alpha) fill in an alpha channel so that it paints\n+    // correctly.\n+    if (cm.hasAlpha())\n+      {\n+\tif (bgcolor != null && cm.hasAlpha())\n+\t  for (int i = 0; i < pixels.length; i++)\n+\t    {\n+\t      if (cm.getAlpha(pixels[i]) == 0)\n+\t\tpixels[i] = bgcolor.getRGB();\n+\t    }\n+      }\n+    else\n+      for (int i = 0; i < pixels.length; i++)\n+\tpixels[i] |= 0xFF000000;\n+\n+    drawPixels(pixels, r.getWidth(), r.getHeight(), r.getWidth(), i2u);\n+\n+    // Cairo seems to lose the current color which must be restored.\n+    updateColor();\n+    \n+    return true;\n+  }\n+\n+  /**\n+   * Shifts coordinates by 0.5.\n+   */\n+  private double shifted(double coord, boolean doShift)\n+  {\n+    if (doShift)\n+      return Math.floor(coord) + 0.5;\n+    else\n+      return coord;\n+  }\n+\n+  /**\n+   * Adds a pathIterator to the current Cairo path, also sets the cairo winding rule.\n+   */\n+  private void walkPath(PathIterator p, boolean doShift)\n+  {\n+    double x = 0;\n+    double y = 0;\n+    double[] coords = new double[6];\n+\n+    cairoSetFillRule(p.getWindingRule());\n+    for (; ! p.isDone(); p.next())\n+      {\n+\tint seg = p.currentSegment(coords);\n+\tswitch (seg)\n+\t  {\n+\t  case PathIterator.SEG_MOVETO:\n+\t    x = shifted(coords[0], doShift);\n+\t    y = shifted(coords[1], doShift);\n+\t    cairoMoveTo(x, y);\n+\t    break;\n+\t  case PathIterator.SEG_LINETO:\n+\t    x = shifted(coords[0], doShift);\n+\t    y = shifted(coords[1], doShift);\n+\t    cairoLineTo(x, y);\n+\t    break;\n+\t  case PathIterator.SEG_QUADTO:\n+\t    // splitting a quadratic bezier into a cubic:\n+\t    // see: http://pfaedit.sourceforge.net/bezier.html\n+\t    double x1 = x + (2.0 / 3.0) * (shifted(coords[0], doShift) - x);\n+\t    double y1 = y + (2.0 / 3.0) * (shifted(coords[1], doShift) - y);\n+\n+\t    double x2 = x1 + (1.0 / 3.0) * (shifted(coords[2], doShift) - x);\n+\t    double y2 = y1 + (1.0 / 3.0) * (shifted(coords[3], doShift) - y);\n+\n+\t    x = shifted(coords[2], doShift);\n+\t    y = shifted(coords[3], doShift);\n+\t    cairoCurveTo(x1, y1, x2, y2, x, y);\n+\t    break;\n+\t  case PathIterator.SEG_CUBICTO:\n+\t    x = shifted(coords[4], doShift);\n+\t    y = shifted(coords[5], doShift);\n+\t    cairoCurveTo(shifted(coords[0], doShift),\n+\t                 shifted(coords[1], doShift),\n+\t                 shifted(coords[2], doShift),\n+\t                 shifted(coords[3], doShift), x, y);\n+\t    break;\n+\t  case PathIterator.SEG_CLOSE:\n+\t    cairoClosePath();\n+\t    break;\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Used by setRenderingHints()\n+   */\n+  private Map getDefaultHints()\n+  {\n+    HashMap defaultHints = new HashMap();\n+\n+    defaultHints.put(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                     RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT);\n+\n+    defaultHints.put(RenderingHints.KEY_STROKE_CONTROL,\n+                     RenderingHints.VALUE_STROKE_DEFAULT);\n+\n+    defaultHints.put(RenderingHints.KEY_FRACTIONALMETRICS,\n+                     RenderingHints.VALUE_FRACTIONALMETRICS_OFF);\n+\n+    defaultHints.put(RenderingHints.KEY_ANTIALIASING,\n+                     RenderingHints.VALUE_ANTIALIAS_OFF);\n+\n+    defaultHints.put(RenderingHints.KEY_RENDERING,\n+                     RenderingHints.VALUE_RENDER_DEFAULT);\n+\n+    return defaultHints;\n+  }\n+\n+  /**\n+   * Used by drawRaster and GdkPixbufDecoder\n+   */\n+  public static int[] findSimpleIntegerArray (ColorModel cm, Raster raster)\n+  {\n+    if (cm == null || raster == null)\n+      return null;\n+\n+    if (! cm.getColorSpace().isCS_sRGB())\n+      return null;\n+\n+    if (! (cm instanceof DirectColorModel))\n+      return null;\n+\n+    DirectColorModel dcm = (DirectColorModel) cm;\n+\n+    if (dcm.getRedMask() != 0x00FF0000 || dcm.getGreenMask() != 0x0000FF00\n+        || dcm.getBlueMask() != 0x000000FF)\n+      return null;\n+\n+    if (! (raster instanceof WritableRaster))\n+      return null;\n+\n+    if (raster.getSampleModel().getDataType() != DataBuffer.TYPE_INT)\n+      return null;\n+\n+    if (! (raster.getDataBuffer() instanceof DataBufferInt))\n+      return null;\n+\n+    DataBufferInt db = (DataBufferInt) raster.getDataBuffer();\n+\n+    if (db.getNumBanks() != 1)\n+      return null;\n+\n+    // Finally, we have determined that this is a single bank, [A]RGB-int\n+    // buffer in sRGB space. It's worth checking all this, because it means\n+    // that cairo can paint directly into the data buffer, which is very\n+    // fast compared to all the normal copying and converting.\n+\n+    return db.getData();\n+  }\n }", "previous_filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkGraphics2D.java"}, {"sha": "e19c9b9925361646ecdb626cb797d6e1b4f8d2a4", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/CairoSurface.java", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoSurface.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoSurface.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoSurface.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,288 @@\n+/* CairoSurface.java\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.Graphics;\n+import java.awt.Color;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DirectColorModel;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+import java.io.ByteArrayOutputStream;\n+import java.io.BufferedInputStream;\n+import java.net.URL;\n+import gnu.classpath.Pointer;\n+\n+/**\n+ * CairoSurface - wraps a Cairo surface.\n+ *\n+ * @author Sven de Marothy\n+ */\n+public class CairoSurface extends DataBuffer\n+{\n+  int width = -1, height = -1;\n+\n+  /**\n+   * The native pointer to the Cairo surface. \n+   */\n+  long surfacePointer;\n+\n+  /**\n+   * The native pointer to the image's data buffer\n+   */\n+  long bufferPointer;\n+\n+\n+  static ColorModel nativeModel = new DirectColorModel(32, \n+\t\t\t\t\t\t       0x000000FF,\n+\t\t\t\t\t\t       0x0000FF00,\n+\t\t\t\t\t\t       0x00FF0000,\n+\t\t\t\t\t\t       0xFF000000);\n+\n+  /**\n+   * Allocates and clears the buffer and creates the cairo surface.\n+   * @param width, height - the image size\n+   * @param stride - the buffer row stride.\n+   */\n+  private native void create(int width, int height, int stride);\n+\n+  /**\n+   * Destroys the cairo surface and frees the buffer.\n+   */\n+  private native void destroy();\n+\n+  /**\n+   * Gets buffer elements\n+   */\n+  private native int nativeGetElem(int i);\n+  \n+  /**\n+   * Sets buffer elements.\n+   */\n+  private native void nativeSetElem(int i, int val);\n+\n+  /**\n+   * Draws this image to a given CairoGraphics context, \n+   * with an affine transform given by i2u.\n+   */\n+  public native void drawSurface(CairoGraphics2D context, double[] i2u);\n+\n+  /**\n+   * getPixels -return the pixels as a java array.\n+   */\n+  native int[] getPixels(int size);\n+\n+  /**\n+   * getPixels -return the pixels as a java array.\n+   */\n+  native void setPixels(int[] pixels);\n+\n+  native long getFlippedBuffer(int size);\n+\n+  /**\n+   * Create a cairo_surface_t with specified width and height.\n+   * The format will be ARGB32 with premultiplied alpha and native bit \n+   * and word ordering.\n+   */\n+  CairoSurface(int width, int height)\n+  {\n+    super(DataBuffer.TYPE_INT, width * height);\n+\n+    if(width <= 0 || height <= 0)\n+      throw new IllegalArgumentException(\"Image must be at least 1x1 pixels.\");\n+\n+    this.width = width;\n+    this.height = height;\n+\n+    create(width, height, width * 4);\n+\n+    if(surfacePointer == 0 || bufferPointer == 0)\n+      throw new Error(\"Could not allocate bitmap.\");\n+  }\n+\n+  /**\n+   * Create a cairo_surface_t from a GtkImage instance.\n+   * (data is copied, not shared)\n+   */\n+  CairoSurface(GtkImage image)\n+  {\n+    super(DataBuffer.TYPE_INT, image.width * image.height);\n+\n+    if(image.width <= 0 || image.height <= 0)\n+      throw new IllegalArgumentException(\"Image must be at least 1x1 pixels.\");\n+\n+    width = image.width;\n+    height = image.height;\n+\n+    create(width, height, width * 4);\n+    \n+    if(surfacePointer == 0 || bufferPointer == 0)\n+      throw new Error(\"Could not allocate bitmap.\");\n+    \n+    // Copy the pixel data from the GtkImage.\n+    int[] data = image.getPixels();\n+\n+    // Swap ordering from GdkPixbuf to Cairo\n+    for(int i = 0; i < data.length; i++ )\n+      {\n+\tint alpha = (data[i] & 0xFF000000) >> 24;\n+\tif( alpha == 0 ) // I do not know why we need this, but it works.\n+\t  data[i] = 0;\n+\telse\n+\t  {\n+\t    int r = (((data[i] & 0x00FF0000) >> 16) );\n+\t    int g = (((data[i] & 0x0000FF00) >> 8) );\n+\t    int b = ((data[i] & 0x000000FF) );\n+\t    data[i] = (( alpha << 24 ) & 0xFF000000) \n+\t      | (( b << 16 ) & 0x00FF0000)\n+\t      | (( g << 8 )  & 0x0000FF00)\n+\t      | ( r  & 0x000000FF);\n+\t  }\n+      }\n+\n+    setPixels( data );\n+  }\n+\n+  /**\n+   * Dispose of the native data.\n+   */\n+  public void dispose()\n+  {\n+    if(surfacePointer != 0)\n+      destroy();\n+  }\n+\n+  /**\n+   * Call dispose() to clean up any native resources allocated.\n+   */\n+  protected void finalize()\n+  {\n+    dispose();\n+  }\n+\n+  /**\n+   * Return a GtkImage from this Cairo surface.\n+   */\n+  public GtkImage getGtkImage()\n+  {\n+    return new GtkImage( width, height, getFlippedBuffer( width * height ));\n+  }\n+\n+  /**\n+   * Returns a BufferedImage backed by a Cairo surface.\n+   */    \n+  public static BufferedImage getBufferedImage(int width, int height)\n+  {\n+    return getBufferedImage(new CairoSurface(width, height));\n+  }\n+\n+  /**\n+   * Returns a BufferedImage backed by a Cairo surface, \n+   * created from a GtkImage.\n+   */    \n+  public static BufferedImage getBufferedImage(GtkImage image)\n+  {\n+    return getBufferedImage(new CairoSurface(image));\n+  }\n+\n+  /**\n+   * Returns a BufferedImage backed by a Cairo surface.\n+   */    \n+  public static BufferedImage getBufferedImage(CairoSurface surface)\n+  {\n+    WritableRaster raster = Raster.createPackedRaster\n+      (surface, surface.width, surface.height, surface.width, \n+       new int[]{ 0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000 },\n+       new Point(0,0));\n+\n+    return new BufferedImage(nativeModel, raster, true, new Hashtable());\n+  }\n+\n+  /**\n+   * DataBank.getElem implementation\n+   */\n+  public int getElem(int bank, int i)\n+  {\n+    if(bank != 0 || i < 0 || i >= width*height)\n+      throw new IndexOutOfBoundsException(i+\" size: \"+width*height);\n+    return nativeGetElem(i);\n+  }\n+  \n+  /**\n+   * DataBank.setElem implementation\n+   */\n+  public void setElem(int bank, int i, int val)\n+  {\n+    if(bank != 0 || i < 0 || i >= width*height)\n+      throw new IndexOutOfBoundsException(i+\" size: \"+width*height);\n+    nativeSetElem(i, val);\n+  }\n+\n+  /**\n+   * Return a Graphics2D drawing to the CairoSurface.\n+   */\n+  public Graphics2D getGraphics()\n+  {\n+    return new CairoSurfaceGraphics(this);\n+  } \n+\n+  ///// Methods used by CairoSurfaceGraphics /////\n+  /**\n+   * Creates a cairo_t drawing context, returns the pointer as a long.\n+   * Used by CairoSurfaceGraphics.\n+   */\n+  native long newCairoContext();\n+\n+  /**\n+   * Copy an area of the surface. Expects parameters must be within bounds. \n+   * Count on a segfault otherwise.\n+   */\n+  native void copyAreaNative(int x, int y, int width, int height, \n+\t\t\t     int dx, int dy, int stride);\n+}"}, {"sha": "38c549d1de5210da6b9d18ba2d4c9786b95b8a85", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/CairoSurfaceGraphics.java", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoSurfaceGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoSurfaceGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FCairoSurfaceGraphics.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,100 @@\n+/* CairoSurfaceGraphics.java\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.Graphics;\n+import java.awt.Color;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.*;\n+\n+/**\n+ * Implementation of Graphics2D on a Cairo surface.\n+ */\n+public class CairoSurfaceGraphics extends CairoGraphics2D\n+{\n+  protected CairoSurface surface;\n+  private long cairo_t;\n+  \n+  /**\n+   * Create a graphics context from a cairo surface\n+   */\n+  public CairoSurfaceGraphics(CairoSurface surface)\n+  {\n+    this.surface = surface;\n+    cairo_t = surface.newCairoContext();\n+    setup( cairo_t );\n+    setClip(0, 0, surface.width, surface.height);\n+  }\n+\n+  /**\n+   * Creates another context from a surface.\n+   * Used by create().\n+   */ \n+  private CairoSurfaceGraphics(CairoSurfaceGraphics copyFrom)\n+  {\n+    surface = copyFrom.surface;\n+    cairo_t = surface.newCairoContext();\n+    copy( copyFrom, cairo_t );\n+    setClip(0, 0, surface.width, surface.height);\n+  }\n+  \n+  public Graphics create()\n+  {\n+    return new CairoSurfaceGraphics(this);\n+  }\n+  \n+  public GraphicsConfiguration getDeviceConfiguration()\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+  \n+  protected Rectangle2D getRealBounds()\n+  {\n+    return new Rectangle2D.Double(0.0, 0.0, surface.width, surface.height);\n+  }\n+\n+  public void copyAreaImpl(int x, int y, int width, int height, int dx, int dy)\n+  {\n+    surface.copyAreaNative(x, y, width, height, dx, dy, surface.width);\n+  }\n+}"}, {"sha": "c6cf4948c009a9a0096f8cdf6b9176af1fdf3b1b", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/ComponentGraphics.java", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FComponentGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FComponentGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FComponentGraphics.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,243 @@\n+/* ComponentGraphics.java --\n+   Copyright (C) 2006  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Image;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.Point;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.ImagingOpException;\n+import java.awt.image.RenderedImage;\n+\n+/**\n+ * ComponentGraphics - context for drawing directly to a component,\n+ * as this is an X drawable, it requires that we use GTK locks.\n+ *\n+ * This context draws directly to the drawable and requires xrender.\n+ */\n+public class ComponentGraphics extends CairoGraphics2D\n+{\n+  private GtkComponentPeer component;\n+  protected long cairo_t;\n+\n+  ComponentGraphics()\n+  {\n+  }\n+  \n+  private ComponentGraphics(GtkComponentPeer component)\n+  {\n+    this.component = component;\n+    cairo_t = initState(component);\n+    setup( cairo_t );\n+    Rectangle bounds = component.awtComponent.getBounds();\n+    setClip( new Rectangle( 0, 0, bounds.width, bounds.height) );\n+    setBackground(component.awtComponent.getBackground());\n+    setColor(component.awtComponent.getForeground());\n+  }\n+\n+  private ComponentGraphics(ComponentGraphics cg)\n+  {\n+    component = cg.component;\n+    cairo_t = initState(component);\n+    copy( cg, cairo_t );\n+    Rectangle bounds = component.awtComponent.getBounds();\n+    setClip( new Rectangle( 0, 0, bounds.width, bounds.height) );\n+    setBackground(component.awtComponent.getBackground());\n+    setColor(component.awtComponent.getForeground());\n+  }\n+\n+  /**\n+   * Creates a cairo_t for the component surface and return it.\n+   */\n+  private native long initState(GtkComponentPeer component);\n+\n+  /**\n+   * Destroys the component surface and calls dispose on the cairo\n+   * graphics2d to destroy any super class resources.\n+   */\n+  public void dispose()\n+  {\n+    disposeSurface(nativePointer);\n+    super.dispose();\n+  }\n+\n+  /**\n+   * Destroys the component surface.\n+   */\n+  private native void disposeSurface(long nativePointer);\n+\n+  /**\n+   * Creates a cairo_t for a volatile image\n+   */\n+  protected native long initFromVolatile( long pixmapPtr, int width, int height);\n+\n+  /**\n+   * Grab lock\n+   */\n+  private native void start_gdk_drawing();\n+\n+  /**\n+   * Release lock\n+   */\n+  private native void end_gdk_drawing();\n+\n+  /**\n+   * Query if the system has the XRender extension.\n+   */\n+  public static native boolean hasXRender();\n+\n+\n+  private native void copyAreaNative(GtkComponentPeer component, int x, int y, \n+\t\t\t\t     int width, int height, int dx, int dy);\n+\n+  private native void drawVolatile(GtkComponentPeer component,\n+\t\t\t\t   Image vimg, int x, int y, \n+\t\t\t\t   int width, int height);\n+\n+  /**\n+   * Returns a Graphics2D object for a component, either an instance of this \n+   * class (if xrender is supported), or a context which copies.\n+   */\n+  public static Graphics2D getComponentGraphics(GtkComponentPeer component)\n+  {\n+    if( hasXRender() )\n+      return new ComponentGraphics(component);\n+\n+    Rectangle r = component.awtComponent.getBounds();\n+    return new ComponentGraphicsCopy(r.width, r.height, component);\n+  }\n+\n+  public GraphicsConfiguration getDeviceConfiguration()\n+  {\n+    return component.getGraphicsConfiguration();\n+  }\n+\n+  public Graphics create()\n+  {\n+    return new ComponentGraphics(this);\n+  }\n+  \n+  protected Rectangle2D getRealBounds()\n+  {\n+    return component.awtComponent.getBounds();\n+  }\n+\n+  public void copyAreaImpl(int x, int y, int width, int height, int dx, int dy)\n+  {\n+    copyAreaNative(component, x, y, width, height, dx, dy);\n+  }\n+\n+  /**\n+   * Overloaded methods that do actual drawing need to enter the gdk threads \n+   * and also do certain things before and after.\n+   */\n+  public void draw(Shape s)\n+  {\n+    start_gdk_drawing();\n+    super.draw(s);\n+    end_gdk_drawing();\n+  }\n+\n+  public void fill(Shape s)\n+  {\n+    start_gdk_drawing();\n+    super.fill(s);\n+    end_gdk_drawing();\n+  }\n+\n+  public void drawRenderedImage(RenderedImage image, AffineTransform xform)\n+  {\n+    start_gdk_drawing();\n+    super.drawRenderedImage(image, xform);\n+    end_gdk_drawing();\n+  }\n+\n+  protected boolean drawImage(Image img, AffineTransform xform,\n+\t\t\t      Color bgcolor, ImageObserver obs)\n+  {\n+    start_gdk_drawing();\n+    boolean rv = super.drawImage(img, xform, bgcolor, obs);\n+    end_gdk_drawing();\n+    return rv;\n+  }\n+\n+  public void drawGlyphVector(GlyphVector gv, float x, float y)\n+  {\n+    start_gdk_drawing();\n+    super.drawGlyphVector(gv, x, y);\n+    end_gdk_drawing();\n+  }\n+  \n+  public boolean drawImage(Image img, int x, int y, ImageObserver observer)\n+  {\n+    if( img instanceof GtkVolatileImage )\n+      {\n+\tdrawVolatile( component, img, x, y - 20,\n+\t\t      ((GtkVolatileImage)img).width, \n+\t\t      ((GtkVolatileImage)img).height );\n+\treturn true;\n+      }      \n+    return super.drawImage( img, x, y, observer );\n+  }\n+  \n+  public boolean drawImage(Image img, int x, int y, int width, int height,\n+                           ImageObserver observer)\n+  {\n+    if( img instanceof GtkVolatileImage )\n+      {\n+\tdrawVolatile( component, img, x, y - 20, \n+\t\t      width, height );\n+\treturn true;\n+      }      \n+    return super.drawImage( img, x, y, width, height, observer );\n+  }\n+\n+}\n+"}, {"sha": "286fbeac060293c7027f825ffa7df64e2b237d06", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/ComponentGraphicsCopy.java", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FComponentGraphicsCopy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FComponentGraphicsCopy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FComponentGraphicsCopy.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,129 @@\n+/* ComponentGraphicsCopy.java\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.ImageObserver;\n+\n+/**\n+ * Implementation of Graphics2D for Components for servers which \n+ * do not have xrender.\n+ *\n+ * A mirrored GtkImage of the component is stored in memory\n+ * and copied back. Yay.\n+ */\n+public class ComponentGraphicsCopy extends CairoSurfaceGraphics\n+{\n+  private GtkComponentPeer component;\n+\n+  /**\n+   * GtkImage sharing its data buffer with this Cairo surface.\n+   */\n+  private GtkImage gtkimage;\n+  \n+  private int width, height;\n+\n+  native void getPixbuf( GtkComponentPeer component, GtkImage image );\n+\n+  native void copyPixbuf( GtkComponentPeer component, GtkImage image, \n+\t\t\t  int x, int y, int w, int h );\n+\n+  public ComponentGraphicsCopy(int width, int height, \n+\t\t\t       GtkComponentPeer component)\n+  { \n+    super( new CairoSurface( width, height ) );\n+    this.component = component;\n+    this.width = width;\n+    this.height = height;\n+    gtkimage = surface.getGtkImage();\n+    getPixbuf( component, gtkimage );\n+  }\n+\n+  /**\n+   * Overloaded methods that do actual drawing need to enter the gdk threads \n+   * and also do certain things before and after.\n+   */\n+  public void draw(Shape s)\n+  {\n+    super.draw(s);\n+    Rectangle r = s.getBounds();\n+    copyPixbuf(component, gtkimage, r.x, r.y, r.width, r.height);\n+  }\n+\n+  public void fill(Shape s)\n+  {\n+    super.fill(s);\n+    Rectangle r = s.getBounds();\n+    copyPixbuf(component, gtkimage, r.x, r.y, r.width, r.height);\n+  }\n+\n+  public void drawRenderedImage(RenderedImage image, AffineTransform xform)\n+  {\n+    super.drawRenderedImage(image, xform);\n+    copyPixbuf(component, gtkimage, 0, 0, width, height);\n+  }\n+\n+  protected boolean drawImage(Image img, AffineTransform xform,\n+\t\t\t      Color bgcolor, ImageObserver obs)\n+  {\n+    boolean rv = super.drawImage(img, xform, bgcolor, obs);\n+    copyPixbuf(component, gtkimage, 0, 0, width, height);\n+    return rv;\n+  }\n+\n+  public void drawGlyphVector(GlyphVector gv, float x, float y)\n+  {\n+    super.drawGlyphVector(gv, x, y);\n+    Rectangle r = gv.getPixelBounds(getFontRenderContext(), x , y);\n+    copyPixbuf(component, gtkimage, r.x, r.y, r.width, r.height);\n+  }\n+}\n+"}, {"sha": "0f8ce6dadef8c2d8191906401eb42ad5ea9b4c60", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/FreetypeGlyphVector.java", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FFreetypeGlyphVector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FFreetypeGlyphVector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FFreetypeGlyphVector.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,392 @@\n+/* FreetypeGlyphVector.java\n+   Copyright (C) 2006  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.Font;\n+import java.awt.Shape;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.geom.GeneralPath;\n+import java.awt.font.GlyphJustificationInfo;\n+import java.awt.font.GlyphMetrics;\n+import java.awt.font.GlyphVector;\n+import java.awt.font.FontRenderContext;\n+\n+public class FreetypeGlyphVector extends GlyphVector\n+{\n+  /**\n+   * The associated font and its peer.\n+   */\n+  private Font font;\n+  private GdkFontPeer peer; // ATTN: Accessed from native code.\n+\n+  /**\n+   * The string represented by this GlyphVector.\n+   */\n+  private String s;\n+\n+  /**\n+   * The font render context\n+   */\n+  private FontRenderContext frc;\n+\n+  /**\n+   * The total # of glyphs.\n+   */\n+  private int nGlyphs;\n+\n+  /**\n+   * The glyph codes\n+   */\n+  private int[] glyphCodes;\n+\n+  /**\n+   * Glyph transforms. (de facto only the translation is used)\n+   */\n+  private AffineTransform[] glyphTransforms;\n+\n+  /**\n+   * Create a glyphvector from a given (Freetype) font and a String.\n+   */\n+  public FreetypeGlyphVector(Font f, String s, FontRenderContext frc)\n+  {\n+    this.s = s;\n+    this.font = f;\n+    this.frc = frc;\n+    if( !(font.getPeer() instanceof GdkFontPeer ) )\n+      throw new IllegalArgumentException(\"Not a valid font.\");\n+    peer = (GdkFontPeer)font.getPeer();\n+\n+    getGlyphs();\n+    performDefaultLayout();\n+  }\n+\n+  /**\n+   * Create a glyphvector from a given set of glyph codes.\n+   */\n+  public FreetypeGlyphVector(Font f, int[] codes, FontRenderContext frc)\n+  {\n+    this.font = f;\n+    this.frc = frc;\n+    if( !(font.getPeer() instanceof GdkFontPeer ) )\n+      throw new IllegalArgumentException(\"Not a valid font.\");\n+    peer = (GdkFontPeer)font.getPeer();\n+\n+    glyphCodes = new int[ codes.length ];\n+    System.arraycopy(codes, 0, glyphCodes, 0, codes.length);\n+    nGlyphs = glyphCodes.length;\n+    performDefaultLayout();\n+  }\n+\n+  /**\n+   * Create the array of glyph codes.\n+   */\n+  private void getGlyphs()\n+  {\n+    nGlyphs = s.codePointCount( 0, s.length() );\n+    glyphCodes = new int[ nGlyphs ];\n+    int stringIndex = 0;\n+    for(int i = 0; i < nGlyphs; i++)\n+      {\n+\tglyphCodes[i] = getGlyph( s.codePointAt(stringIndex) );\n+\t// UTF32 surrogate handling\n+\tif( s.codePointAt( stringIndex ) != (int)s.charAt( stringIndex ) )\n+\t  stringIndex ++;\n+\tstringIndex ++;\n+      }\n+  }\n+\n+  /**\n+   * Returns the glyph code within the font for a given character\n+   */\n+  public native int getGlyph(int codepoint);\n+\n+  /**\n+   * Returns the kerning of a glyph pair\n+   */\n+  private native Point2D getKerning(int leftGlyph, int rightGlyph);\n+\n+  private native double[] getMetricsNative( int glyphCode );\n+\n+  private native GeneralPath getGlyphOutlineNative(int glyphIndex);\n+\n+  /**\n+   * Duh, compares two instances.\n+   */\n+  public boolean equals(GlyphVector gv)\n+  {\n+    if( ! (gv instanceof FreetypeGlyphVector) )\n+      return false;\n+\n+    return (((FreetypeGlyphVector)gv).font.equals(font) && \n+\t    ((FreetypeGlyphVector)gv).frc.equals(frc)\n+\t    && ((FreetypeGlyphVector)gv).s.equals(s));\n+  }\n+\n+  /**\n+   * Returns the associated Font\n+   */\n+  public Font getFont()\n+  {\n+    return font;\n+  }\n+\n+  /**\n+   * Returns the associated FontRenderContext\n+   */\n+  public FontRenderContext getFontRenderContext()\n+  {\n+    return frc;\n+  }\n+\n+  /**\n+   * Layout the glyphs.\n+   */\n+  public void performDefaultLayout()\n+  {\n+    glyphTransforms = new AffineTransform[ nGlyphs ]; \n+    double x = 0;\n+    for(int i = 0; i < nGlyphs; i++)\n+      {\n+\tGlyphMetrics gm = getGlyphMetrics( i );\n+\tRectangle2D r = gm.getBounds2D();\n+\tglyphTransforms[ i ] = AffineTransform.getTranslateInstance(x, 0);\n+\tx += gm.getAdvanceX();\n+\tif( i > 0 )\n+\t  {\n+\t    Point2D p = getKerning( glyphCodes[ i - 1 ], glyphCodes[ i ] );\n+\t    x += p.getX();\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Returns the code of the glyph at glyphIndex;\n+   */\n+  public int getGlyphCode(int glyphIndex)\n+  {\n+    return glyphCodes[ glyphIndex ];\n+  }\n+\n+  /**\n+   * Returns multiple glyphcodes.\n+   */\n+  public int[] getGlyphCodes(int beginGlyphIndex, int numEntries, \n+\t\t\t     int[] codeReturn)\n+  {\n+    int[] rval;\n+\n+    if( codeReturn == null )\n+      rval = new int[ numEntries ];\n+    else\n+      rval = codeReturn;\n+    \n+    System.arraycopy(glyphCodes, beginGlyphIndex, rval, 0, numEntries);\n+\n+    return rval;\n+  }\n+\n+  /**\n+   * FIXME: Implement me.\n+   */\n+  public Shape getGlyphLogicalBounds(int glyphIndex)\n+  {\n+    GlyphMetrics gm = getGlyphMetrics( glyphIndex );\n+    if( gm == null )\n+      return null; \n+    Rectangle2D r = gm.getBounds2D();\n+    return new Rectangle2D.Double( r.getX() - gm.getLSB(), r.getY(),\n+\t\t\t\t   gm.getAdvanceX(), r.getHeight() );\n+  }\n+\n+  /**\n+   * Returns the metrics of a single glyph.\n+   */\n+  public GlyphMetrics getGlyphMetrics(int glyphIndex)\n+  {\n+    double[] val = getMetricsNative( glyphCodes[ glyphIndex ] );\n+    if( val == null )\n+      return null;\n+    \n+    return new GlyphMetrics( true, (float)val[1], (float)val[2], \n+\t\t\t     new Rectangle2D.Double( val[3], val[4], \n+\t\t\t\t\t\t     val[5], val[6] ),\n+\t\t\t     GlyphMetrics.STANDARD );\n+  }\n+\n+  /**\n+   * Returns the outline of a single glyph.\n+   */\n+  public Shape getGlyphOutline(int glyphIndex)\n+  {\n+    GeneralPath gp = getGlyphOutlineNative( glyphCodes[ glyphIndex ] );\n+    gp.transform( glyphTransforms[ glyphIndex ] );\n+    return gp;\n+  }\n+\n+  /**\n+   * Returns the position of a single glyph.\n+   */\n+  public Point2D getGlyphPosition(int glyphIndex)\n+  {\n+    return glyphTransforms[ glyphIndex ].transform( new Point2D.Double(0, 0),\n+\t\t\t\t\t\t   null );\n+  }\n+\n+  /**\n+   * Returns the positions of multiple glyphs.\n+   */\n+  public float[] getGlyphPositions(int beginGlyphIndex, int numEntries, \n+\t\t\t\t   float[] positionReturn)\n+  {\n+    float[] rval;\n+\n+    if( positionReturn == null )\n+      rval = new float[2 * numEntries];\n+    else\n+      rval = positionReturn;\n+\n+    for( int i = beginGlyphIndex; i < numEntries; i++ )\n+      {\n+\tPoint2D p = getGlyphPosition( i );\n+\trval[i * 2] = (float)p.getX();\n+\trval[i * 2 + 1] = (float)p.getY();\n+      }\n+\n+    return rval;\n+  }\n+\n+  /**\n+   * Returns the transform of a glyph.\n+   */\n+  public AffineTransform getGlyphTransform(int glyphIndex)\n+  {\n+    return new AffineTransform( glyphTransforms[ glyphIndex ] );\n+  }\n+\n+  /**\n+   * Returns the visual bounds of a glyph\n+   * May be off by a pixel or two due to hinting/rasterization.\n+   */\n+  public Shape getGlyphVisualBounds(int glyphIndex)\n+  {\n+    return getGlyphOutline( glyphIndex ).getBounds2D();\n+  }\n+\n+  /**\n+   * Return the logical bounds of the whole thing.\n+   */\n+  public Rectangle2D getLogicalBounds()\n+  {\n+    if( nGlyphs == 0 )\n+      return new Rectangle2D.Double(0, 0, 0, 0);\n+\n+    Rectangle2D rect = (Rectangle2D)getGlyphLogicalBounds( 0 );\n+    for( int i = 1; i < nGlyphs; i++ )\n+      rect = rect.createUnion( (Rectangle2D)getGlyphLogicalBounds( i ) );\n+\n+    return rect;\n+  }\n+\n+  /**\n+   * Returns the number of glyphs.\n+   */\n+  public int getNumGlyphs()\n+  {\n+    return glyphCodes.length;\n+  }\n+\n+  /**\n+   * Returns the outline of the entire GlyphVector.\n+   */\n+  public Shape getOutline()\n+  {\n+    GeneralPath path = new GeneralPath();\n+    for( int i = 0; i < getNumGlyphs(); i++ )\n+      path.append( getGlyphOutline( i ), false );\n+    return path;\n+  }\n+\n+  /**\n+   * TODO: \n+   * FreeType does not currently have an API for the JSTF table. We should \n+   * probably get the table ourselves from FT and pass it to some parser \n+   * which the native font peers will need.\n+   */\n+  public GlyphJustificationInfo getGlyphJustificationInfo(int glyphIndex)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Returns the outline of the entire vector, drawn at (x,y).\n+   */\n+  public Shape getOutline(float x, float y)\n+  {\n+    AffineTransform tx = AffineTransform.getTranslateInstance( x, y );\n+    return tx.createTransformedShape( getOutline() );\n+  }\n+\n+  /**\n+   * Returns the visual bounds of the entire GlyphVector.\n+   * May be off by a pixel or two due to hinting/rasterization.\n+   */\n+  public Rectangle2D getVisualBounds()\n+  {\n+    return getOutline().getBounds2D();\n+  }\n+\n+  /**\n+   * Sets the position of a glyph.\n+   */\n+  public void setGlyphPosition(int glyphIndex, Point2D newPos)\n+  {\n+    // FIXME: Scaling, etc.?\n+    glyphTransforms[ glyphIndex ].setToTranslation( newPos.getX(), \n+\t\t\t\t\t\t    newPos.getY() );\n+  }\n+\n+  /**\n+   * Sets the transform of a single glyph.\n+   */\n+  public void setGlyphTransform(int glyphIndex, AffineTransform newTX)\n+  {\n+    glyphTransforms[ glyphIndex ].setTransform( newTX );\n+  }\n+}"}, {"sha": "7aa5e7a1271f44c0753e657251bbf32e269bc49c", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkFontPeer.java", "status": "modified", "additions": 88, "deletions": 20, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkFontPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkFontPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkFontPeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -40,19 +40,23 @@\n \n import gnu.classpath.Configuration;\n import gnu.java.awt.peer.ClasspathFontPeer;\n+import gnu.java.awt.font.opentype.NameDecoder;\n \n import java.awt.Font;\n import java.awt.FontMetrics;\n import java.awt.Toolkit;\n import java.awt.font.FontRenderContext;\n import java.awt.font.GlyphVector;\n+import java.awt.font.GlyphMetrics;\n import java.awt.font.LineMetrics;\n import java.awt.geom.Rectangle2D;\n+import java.awt.geom.Point2D;\n import java.text.CharacterIterator;\n import java.text.StringCharacterIterator;\n import java.util.Locale;\n import java.util.Map;\n import java.util.ResourceBundle;\n+import java.nio.ByteBuffer;\n \n public class GdkFontPeer extends ClasspathFontPeer\n {\n@@ -76,17 +80,21 @@ public class GdkFontPeer extends ClasspathFontPeer\n       }\n   }\n \n+  private ByteBuffer nameTable = null;\n+\n   private native void initState ();\n   private native void dispose ();\n-  private native void setFont (String family, int style, int size, boolean useGraphics2D);\n+  private native void setFont (String family, int style, int size);\n \n   native void getFontMetrics(double [] metrics);\n   native void getTextMetrics(String str, double [] metrics);\n \n+  native void releasePeerGraphicsResource();\n+\n+\n   protected void finalize ()\n   {\n-    if (GtkToolkit.useGraphics2D ())\n-      GdkGraphics2D.releasePeerGraphicsResource(this);\n+    releasePeerGraphicsResource();\n     dispose ();\n   }\n \n@@ -136,26 +144,84 @@ public GdkFontPeer (String name, int style, int size)\n   {  \n     super(name, style, size);    \n     initState ();\n-    setFont (this.familyName, this.style, (int)this.size, \n-             GtkToolkit.useGraphics2D());\n+    setFont (this.familyName, this.style, (int)this.size);\n   }\n \n   public GdkFontPeer (String name, Map attributes)\n   {\n     super(name, attributes);\n     initState ();\n-    setFont (this.familyName, this.style, (int)this.size,\n-             GtkToolkit.useGraphics2D());\n+    setFont (this.familyName, this.style, (int)this.size);\n   }\n-  \n+\n+  /**\n+   * Unneeded, but implemented anyway.\n+   */  \n   public String getSubFamilyName(Font font, Locale locale)\n   {\n-    return null;\n+    String name;\n+    \n+    if (locale == null)\n+      locale = Locale.getDefault();\n+    \n+    name = getName(NameDecoder.NAME_SUBFAMILY, locale);\n+    if (name == null)\n+      {\n+\tname = getName(NameDecoder.NAME_SUBFAMILY, Locale.ENGLISH);\n+\tif (\"Regular\".equals(name))\n+\t  name = null;\n+      }\n+\n+    return name;\n   }\n \n+  /**\n+   * Returns the bytes belonging to a TrueType/OpenType table,\n+   * Parameters n,a,m,e identify the 4-byte ASCII tag of the table.\n+   *\n+   * Returns null if the font is not TT, the table is nonexistant, \n+   * or if some other unexpected error occured.\n+   *\n+   */\n+  private native byte[] getTrueTypeTable(byte n, byte a, byte m, byte e);\n+\n+  /**\n+   * Returns the PostScript name of the font, defaults to the familyName if \n+   * a PS name could not be retrieved.\n+   */\n   public String getPostScriptName(Font font)\n   {\n-    return this.familyName;\n+    String name = getName(NameDecoder.NAME_POSTSCRIPT, \n+\t\t\t  /* any language */ null);\n+    if( name == null )\n+      return this.familyName;\n+\n+    return name;\n+  }\n+\n+  /**\n+   * Extracts a String from the font&#x2019;s name table.\n+   *\n+   * @param name the numeric TrueType or OpenType name ID.\n+   *\n+   * @param locale the locale for which names shall be localized, or\n+   * <code>null</code> if the locale does mot matter because the name\n+   * is known to be language-independent (for example, because it is\n+   * the PostScript name).\n+   */\n+  private String getName(int name, Locale locale)\n+  {\n+    if (nameTable == null)\n+      {\n+\tbyte[] data = getTrueTypeTable((byte)'n', (byte) 'a', \n+\t\t\t\t       (byte) 'm', (byte) 'e');\n+\tif( data == null )\n+\t  return null;\n+\n+\tnameTable = ByteBuffer.wrap( data );\n+      }\n+\n+    return NameDecoder.getName(nameTable, name, locale);\n   }\n \n   public boolean canDisplay (Font font, char c)\n@@ -170,23 +236,18 @@ public int canDisplayUpTo (Font font, CharacterIterator i, int start, int limit)\n     return -1;\n   }\n   \n-  private native GdkGlyphVector getGlyphVector(String txt, \n-                                               Font f, \n-                                               FontRenderContext ctx);\n-\n   public GlyphVector createGlyphVector (Font font, \n                                         FontRenderContext ctx, \n                                         CharacterIterator i)\n   {\n-    return getGlyphVector(buildString (i), font, ctx);\n+    return new FreetypeGlyphVector(font, buildString (i), ctx);\n   }\n \n   public GlyphVector createGlyphVector (Font font, \n                                         FontRenderContext ctx, \n                                         int[] glyphCodes)\n   {\n-    return null;\n-    //    return new GdkGlyphVector (font, this, ctx, glyphCodes);\n+    return new FreetypeGlyphVector(font, glyphCodes, ctx);\n   }\n \n   public byte getBaselineFor (Font font, char c)\n@@ -262,13 +323,21 @@ public String getGlyphName (Font font, int glyphIndex)\n \n   public int getNumGlyphs (Font font)\n   {\n-    throw new UnsupportedOperationException ();\n+    byte[] data = getTrueTypeTable((byte)'m', (byte) 'a', \n+\t\t\t\t   (byte)'x', (byte) 'p');\n+    if( data == null )\n+      return -1;\n+\n+    ByteBuffer buf = ByteBuffer.wrap( data );       \n+    return buf.getShort(4);\n   }\n \n   public Rectangle2D getStringBounds (Font font, CharacterIterator ci, \n                                       int begin, int limit, FontRenderContext frc)\n   {\n-    GdkGlyphVector gv = getGlyphVector(buildString (ci, begin, limit), font, frc);\n+    GlyphVector gv = new FreetypeGlyphVector( font, \n+\t\t\t\t\t      buildString(ci, begin, limit),\n+\t\t\t\t\t      frc);\n     return gv.getVisualBounds();\n   }\n \n@@ -303,5 +372,4 @@ public FontMetrics getFontMetrics (Font font)\n     // the metrics cache.\n     return Toolkit.getDefaultToolkit().getFontMetrics (font);\n   }\n-\n }"}, {"sha": "f0ddea43a12f44ea7065fa4da4d9d8e946aa7894", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkGlyphVector.java", "status": "removed", "additions": 0, "deletions": 359, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c65d7577ca4e36675571fd8bad43ef6d34e2831/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c65d7577ca4e36675571fd8bad43ef6d34e2831/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java?ref=6c65d7577ca4e36675571fd8bad43ef6d34e2831", "patch": "@@ -1,359 +0,0 @@\n-/* GdkGlyphVector.java -- Glyph vector object\n-   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.awt.peer.gtk;\n-\n-import java.awt.Font;\n-import java.awt.Rectangle;\n-import java.awt.Shape;\n-import java.awt.font.FontRenderContext;\n-import java.awt.font.GlyphJustificationInfo;\n-import java.awt.font.GlyphMetrics;\n-import java.awt.font.GlyphVector;\n-import java.awt.geom.AffineTransform;\n-import java.awt.geom.Point2D;\n-import java.awt.geom.Rectangle2D;\n-\n-public class GdkGlyphVector extends GlyphVector\n-{\n-\n-  /* We use a simple representation for glyph vectors here. Glyph i\n-   * consumes 8 doubles:\n-   *\n-   *      logical x: extents[ 10*i     ]\n-   *      logical y: extents[ 10*i + 1 ]\n-   *  logical width: extents[ 10*i + 2 ]\n-   * logical height: extents[ 10*i + 3 ]\n-   *\n-   *       visual x: extents[ 10*i + 4 ]\n-   *       visual y: extents[ 10*i + 5 ]\n-   *   visual width: extents[ 10*i + 6 ]\n-   *  visual height: extents[ 10*i + 7 ]\n-   *\n-   *   origin pos x: extents[ 10*i + 8 ]\n-   *   origin pos y: extents[ 10*i + 9 ]\n-   * \n-   * as well as one int, code[i], representing the glyph code in the font.\n-   */\n-\n-  double [] extents;\n-  int [] codes;\n-\n-  Font font;\n-  FontRenderContext fontRenderContext;\n-\n-  Rectangle2D allLogical;\n-  Rectangle2D allVisual;\n-\n-  public GdkGlyphVector(double[] extents, int[] codes, Font font, FontRenderContext frc)\n-  {\n-    this.extents = extents;\n-    this.codes = codes;\n-    this.font = font;\n-    this.fontRenderContext = frc;\n-\n-    allLogical = new Rectangle2D.Double();\n-    allVisual = new Rectangle2D.Double();\n-    \n-    for (int i = 0; i < codes.length; ++i)\n-      {\n-        allLogical.add (new Rectangle2D.Double(extents[10*i    ] + extents[10*i + 8],\n-                                               extents[10*i + 1] + extents[10*i + 9],\n-                                               extents[10*i + 2],\n-                                               extents[10*i + 3]));\n-\n-        allVisual.add (new Rectangle2D.Double(extents[10*i + 4] + extents[10*i + 8],\n-                                              extents[10*i + 5] + extents[10*i + 9],\n-                                              extents[10*i + 6],\n-                                              extents[10*i + 7]));\n-      }\n-  }\n-\n-  /* \n-     geometric notes:\n-\n-     the FRC contains a mapping from points -> pixels.\n-\n-     typographics points are typically 1/72 of an inch.\n-\n-     pixel displays are often around 72 dpi.\n-\n-     so the FRC can get away with using an identity transform on a screen,\n-     often. behavior is documented by sun to fall back to an identity\n-     transform if the internal transformation is null.\n-\n-     coordinates coming up from pango are expressed as floats -- in device\n-     space, so basically pixels-with-fractional-bits -- derived from their\n-     storage format in pango (1024ths of pixels). \n-\n-     it is not clear from the javadocs whether the results of methods like\n-     getGlyphPositions ought to return coordinates in device space, or\n-     \"point\" space, or what. for now I'm returning them in device space.\n-     \n-   */\n-\n-  public double[] getExtents() \n-  {\n-    return extents;\n-  }\n-\n-  public int[] getCodes()\n-  {\n-    return codes;\n-  }\n-\n-  public Font getFont () \n-  { \n-    return font; \n-  }\n-\n-  public FontRenderContext getFontRenderContext () \n-  { \n-    return fontRenderContext; \n-  }\n-\n-  public int getGlyphCharIndex (int glyphIndex) \n-  { \n-    // FIXME: currently pango does not provide glyph-by-glyph\n-    // reverse mapping information, so we assume a broken 1:1\n-    // glyph model here. This is plainly wrong.\n-    return glyphIndex;\n-  }\n-\n-  public int[] getGlyphCharIndices (int beginGlyphIndex, \n-                                    int numEntries,\n-                                    int[] codeReturn)\n-  {\n-    int ix[] = codeReturn;\n-    if (ix == null)\n-      ix = new int[numEntries];\n-\n-    for (int i = 0; i < numEntries; i++)\n-      ix[i] = getGlyphCharIndex (beginGlyphIndex + i);\n-    return ix;\n-  }\n-\n-  public int getGlyphCode (int glyphIndex) \n-  { \n-    return codes[glyphIndex];\n-  }\n-\n-  public int[] getGlyphCodes (int beginGlyphIndex, int numEntries,\n-                              int[] codeReturn)\n-  {\n-    if (codeReturn == null)\n-      codeReturn = new int[numEntries];\n-\n-    System.arraycopy(codes, beginGlyphIndex, codeReturn, 0, numEntries);\n-    return codeReturn;\n-  }\n-\n-  public Shape getGlyphLogicalBounds (int i)\n-  {\n-    return new Rectangle2D.Double (extents[8*i], extents[8*i + 1],\n-                                   extents[8*i + 2], extents[8*i + 3]);\n-  }\n-    \n-  public GlyphMetrics getGlyphMetrics (int i)\n-  {\n-    // FIXME: pango does not yield vertical layout information at the\n-    // moment.\n-\n-    boolean is_horizontal = true;\n-    double advanceX = extents[8*i + 2]; // \"logical width\" == advanceX \n-    double advanceY = 0; \n-   \n-    return new GlyphMetrics (is_horizontal, \n-                             (float) advanceX, (float) advanceY, \n-                             (Rectangle2D) getGlyphVisualBounds(i), \n-                             GlyphMetrics.STANDARD);\n-  }\n-\n-  public Shape getGlyphOutline (int glyphIndex)\n-  {\n-    throw new UnsupportedOperationException ();      \n-  }\n-\n-  public Shape getGlyphOutline (int glyphIndex, float x, float y)\n-  {\n-    throw new UnsupportedOperationException ();\n-  }\n-\n-  public Rectangle getGlyphPixelBounds (int i, \n-                                        FontRenderContext renderFRC,\n-                                        float x, float y)\n-  {\n-    return new Rectangle((int) x, (int) y,\n-                         (int) extents[8*i + 6], (int) extents[8*i + 7]);\n-  }\n-    \n-  public Point2D getGlyphPosition (int i)\n-  {\n-    return new Point2D.Double (extents[10*i + 8], \n-                               extents[10*i + 9]);\n-  }\n-\n-  public float[] getGlyphPositions (int beginGlyphIndex,\n-                                    int numEntries,\n-                                    float[] positionReturn)\n-  {\n-    float fx[] = positionReturn;\n-    if (fx == null)\n-      fx = new float[numEntries * 2];\n-\n-    for (int i = 0; i < numEntries; ++i)\n-      {\n-        fx[2*i    ] = (float) extents[10*i + 8];\n-        fx[2*i + 1] = (float) extents[10*i + 9];\n-      }\n-    return fx;\n-  }\n-\n-  public AffineTransform getGlyphTransform (int glyphIndex)\n-  {\n-    // Glyphs don't have independent transforms in these simple glyph\n-    // vectors; docs specify null is an ok return here.\n-    return null;  \n-  }\n-    \n-  public Shape getGlyphVisualBounds (int i)\n-  {\n-    return new Rectangle2D.Double(extents[8*i + 4], extents[8*i + 5],\n-                                  extents[8*i + 6], extents[8*i + 7]);\n-  }\n-    \n-  public int getLayoutFlags ()\n-  {\n-    return 0;\n-  }\n-\n-  public Rectangle2D getLogicalBounds ()\n-  {\n-    return allLogical;\n-  }\n-\n-  public int getNumGlyphs ()\n-  {\n-    return codes.length;\n-  }\n-\n-  public Shape getOutline ()\n-  {\n-    throw new UnsupportedOperationException ();      \n-  }\n-\n-  public Rectangle getPixelBounds (FontRenderContext renderFRC,\n-                                   float x, float y)\n-  {\n-    return new Rectangle((int)x, \n-                         (int)y, \n-                         (int) allVisual.getWidth(),\n-                         (int) allVisual.getHeight());\n-  }\n-    \n-  public Rectangle2D getVisualBounds ()\n-  {\n-    return allVisual;\n-  }\n-\n-  public void performDefaultLayout ()\n-  {\n-  }\n-    \n-  public void setGlyphPosition (int i, Point2D newPos)\n-  {\n-    extents[8*i    ] = newPos.getX();\n-    extents[8*i + 1] = newPos.getY();\n-\n-    extents[8*i + 4] = newPos.getX();\n-    extents[8*i + 5] = newPos.getY();\n-  }\n-\n-  public void setGlyphTransform (int glyphIndex,\n-                                 AffineTransform newTX)\n-  {\n-    // not yet.. maybe not ever?\n-    throw new UnsupportedOperationException ();      \n-  }\n-\n-  public boolean equals(GlyphVector gv)\n-  {\n-    if (gv == null)\n-      return false;\n-\n-    if (! (gv instanceof GdkGlyphVector))\n-      return false;\n-\n-    GdkGlyphVector ggv = (GdkGlyphVector) gv;\n-\n-    if ((ggv.codes.length != this.codes.length)\n-        || (ggv.extents.length != this.extents.length))\n-      return false;\n-    \n-    if ((ggv.font == null && this.font != null)\n-        || (ggv.font != null && this.font == null)\n-        || (!ggv.font.equals(this.font)))\n-      return false;\n-\n-    if ((ggv.fontRenderContext == null && this.fontRenderContext != null)\n-        || (ggv.fontRenderContext != null && this.fontRenderContext == null)\n-        || (!ggv.fontRenderContext.equals(this.fontRenderContext)))\n-      return false;\n-\n-    for (int i = 0; i < ggv.codes.length; ++i)\n-      if (ggv.codes[i] != this.codes[i])\n-        return false;\n-\n-    for (int i = 0; i < ggv.extents.length; ++i)\n-      if (ggv.extents[i] != this.extents[i])\n-        return false;\n-\n-    return true;\n-  }\n-\n-  public GlyphJustificationInfo getGlyphJustificationInfo(int idx)\n-  {\n-    throw new UnsupportedOperationException ();      \n-  }\n-\n-  public Shape getOutline(float x, float y)    \n-  {\n-    throw new UnsupportedOperationException ();      \n-  }\n-\n-}"}, {"sha": "50066ff1bd541d834b382c2269bcc2c20c8e0e02", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkGraphics.java", "status": "removed", "additions": 0, "deletions": 494, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c65d7577ca4e36675571fd8bad43ef6d34e2831/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c65d7577ca4e36675571fd8bad43ef6d34e2831/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics.java?ref=6c65d7577ca4e36675571fd8bad43ef6d34e2831", "patch": "@@ -1,494 +0,0 @@\n-/* GdkGraphics.java\n-   Copyright (C) 1998, 1999, 2002, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package gnu.java.awt.peer.gtk;\n-\n-import gnu.classpath.Configuration;\n-\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Font;\n-import java.awt.FontMetrics;\n-import java.awt.Graphics;\n-import java.awt.Image;\n-import java.awt.Rectangle;\n-import java.awt.Shape;\n-import java.awt.Toolkit;\n-import java.awt.image.ImageObserver;\n-import java.text.AttributedCharacterIterator;\n-\n-public class GdkGraphics extends Graphics\n-{\n-  static \n-  {\n-    System.loadLibrary(\"gtkpeer\");\n-\n-    initStaticState ();\n-  }\n-  \n-  static native void initStaticState();\n-  private final int native_state = GtkGenericPeer.getUniqueInteger ();\n-\n-  Color color, xorColor;\n-  GtkComponentPeer component;\n-  Font font = new Font (\"Dialog\", Font.PLAIN, 12);\n-  Rectangle clip;\n-  GtkImage image; \n-\n-  int xOffset = 0;\n-  int yOffset = 0;\n-\n-  static final int GDK_COPY = 0, GDK_XOR = 2;\n-\n-  native void initState (GtkComponentPeer component);\n-  native void initStateUnlocked (GtkComponentPeer component);\n-  native void initState (int width, int height);\n-  native void initFromImage (GtkImage image);\n-  native void nativeCopyState (GdkGraphics g);\n-\n-  /**\n-   * A cached instance that is used by {@link #create} in order to avoid\n-   * massive allocation of graphics contexts.\n-   */\n-  GdkGraphics cached = null;\n-\n-  /**\n-   * A link to the parent context. This is used in {@link #dispose} to put\n-   * this graphics context into the cache.\n-   */\n-  GdkGraphics parent = null;\n-\n-  GdkGraphics (GdkGraphics g)\n-  {\n-    parent = g;\n-    copyState (g);\n-  }\n-\n-  GdkGraphics (int width, int height)\n-  {\n-    initState (width, height);\n-    color = Color.black;\n-    clip = new Rectangle (0, 0, width, height);\n-    font = new Font (\"Dialog\", Font.PLAIN, 12);\n-  }\n-\n-  GdkGraphics (GtkImage image)\n-  {\n-    this.image = image;\n-    initFromImage (image);\n-    color = Color.black;\n-    clip = new Rectangle (0, 0, \n-\t\t\t  image.getWidth(null), image.getHeight(null));\n-    font = new Font (\"Dialog\", Font.PLAIN, 12);\n-  }\n-\n-  GdkGraphics (GtkComponentPeer component)\n-  {\n-    this.component = component;\n-    color = Color.black;\n-\n-    if (component.isRealized ())\n-      initComponentGraphics ();\n-    else\n-      connectSignals (component);\n-  }\n-\n-  void initComponentGraphics ()\n-  {\n-    initState (component);\n-    color = component.awtComponent.getForeground ();\n-    if (color == null)\n-      color = Color.BLACK;\n-    Dimension d = component.awtComponent.getSize ();\n-    clip = new Rectangle (0, 0, d.width, d.height);\n-  }\n-\n-  // called back by native side: realize_cb\n-  void initComponentGraphicsUnlocked ()\n-  {\n-    initStateUnlocked (component);\n-    color = component.awtComponent.getForeground ();\n-    if (color == null)\n-      color = Color.BLACK;\n-    Dimension d = component.awtComponent.getSize ();\n-    clip = new Rectangle (0, 0, d.width, d.height);\n-  }\n-\n-  native void connectSignals (GtkComponentPeer component);\n-\n-  public native void clearRect(int x, int y, int width, int height);\n-\n-  public void clipRect (int x, int y, int width, int height)\n-  {\n-    if (component != null && ! component.isRealized ())\n-      return;\n-\n-    clip = clip.intersection (new Rectangle (x, y, width, height));\n-    setClipRectangle (clip.x, clip.y, clip.width, clip.height);\n-  }\n-\n-  public native void copyArea(int x, int y, int width, int height, \n-\t\t\t      int dx, int dy);\n-\n-  /**\n-   * Creates a copy of this GdkGraphics instance. This implementation can\n-   * reuse a cached instance to avoid massive instantiation of Graphics objects\n-   * during painting.\n-   *\n-   * @return a copy of this graphics context\n-   */\n-  public Graphics create()\n-  {\n-    GdkGraphics copy = cached;\n-    if (copy == null)\n-      copy = new GdkGraphics(this);\n-    else\n-      {\n-        copy.copyState(this);\n-        cached = null;\n-      }\n-    return copy;\n-  }\n-\n-  public native void nativeDispose();\n-\n-  /**\n-   * Disposes this graphics object. This puts this graphics context into the\n-   * cache of its parent graphics if there is one.\n-   */\n-  public void dispose()\n-  {\n-    if (parent != null)\n-      {\n-        parent.cached = this;\n-        parent = null;\n-      }\n-    else\n-      nativeDispose();\n-  }\n-\n-  /**\n-   * This is called when this object gets finalized by the garbage collector.\n-   * In addition to {@link Graphics#finalize()} this calls nativeDispose() to\n-   * make sure the native resources are freed before the graphics context is\n-   * thrown away.\n-   */\n-  public void finalize()\n-  {\n-    super.finalize();\n-    nativeDispose();\n-  }\n-\n-  public boolean drawImage (Image img, int x, int y, \n-\t\t\t    Color bgcolor, ImageObserver observer)\n-  {\n-    if (img != null)\n-      return drawImage(img, x, y, img.getWidth(null), img.getHeight(null),\n-                       bgcolor, observer);\n-    return false;\n-  }\n-\n-  public boolean drawImage (Image img, int x, int y, ImageObserver observer)\n-  {\n-    return drawImage (img, x, y, null, observer);\n-  }\n-\n-  public boolean drawImage(Image img, int x, int y, int width, int height,\n-                           Color bgcolor, ImageObserver observer)\n-  {\n-    if (img != null)\n-      {\n-        if (img instanceof GtkImage)\n-          return ((GtkImage) img).drawImage(this, x, y, width, height, bgcolor,\n-                                            observer);\n-        return (new GtkImage(img.getSource())).drawImage(this, x, y, width,\n-                                                         height, bgcolor,\n-                                                         observer);\n-      }\n-    return false;\n-  }\n-\n-  public boolean drawImage (Image img, int x, int y, int width, int height, \n-\t\t\t    ImageObserver observer)\n-  {\n-    return drawImage (img, x, y, width, height,  null, observer);\n-  }\n-\n-  public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n-\t\t\t    int sx1, int sy1, int sx2, int sy2, \n-\t\t\t    Color bgcolor, ImageObserver observer)\n-  {\n-    if (img != null)\n-      {\n-        if (img instanceof GtkImage)\n-          return ((GtkImage) img).drawImage(this, dx1, dy1, dx2, dy2, sx1, sy1,\n-                                            sx2, sy2, bgcolor, observer);\n-        return (new GtkImage(img.getSource())).drawImage(this, dx1, dy1, dx2,\n-                                                         dy2, sx1, sy1, sx2,\n-                                                         sy2, bgcolor, observer);\n-      }\n-    return false;\n-  }\n-\n-  public boolean drawImage (Image img, int dx1, int dy1, int dx2, int dy2, \n-\t\t\t    int sx1, int sy1, int sx2, int sy2, \n-\t\t\t    ImageObserver observer) \n-  {\n-    return drawImage (img, dx1, dy1, dx2, dy2, \n-\t\t      sx1, sy1, sx2, sy2, \n-\t\t      null, observer);\n-  }\n-\n-  public native void drawLine(int x1, int y1, int x2, int y2);\n-\n-  public native void drawArc(int x, int y, int width, int height,\n-\t\t\t     int startAngle, int arcAngle);\n-  public native void fillArc(int x, int y, int width, int height, \n-\t\t\t     int startAngle, int arcAngle);\n-  public native void drawOval(int x, int y, int width, int height);\n-  public native void fillOval(int x, int y, int width, int height);\n-\n-  public native void drawPolygon(int[] xPoints, int[] yPoints, int nPoints);\n-  public native void fillPolygon(int[] xPoints, int[] yPoints, int nPoints);\n-\n-  public native void drawPolyline(int[] xPoints, int[] yPoints, int nPoints);\n-\n-  public native void drawRect(int x, int y, int width, int height);\n-  public native void fillRect(int x, int y, int width, int height);\n-\n-  GdkFontPeer getFontPeer() \n-  {\n-    return (GdkFontPeer) getFont().getPeer(); \n-  }\n-\n-  native void drawString (GdkFontPeer f, String str, int x, int y);\n-  public void drawString (String str, int x, int y)\n-  {\n-    drawString(getFontPeer(), str, x, y);\n-  }  \n-  \n-  public void drawString (AttributedCharacterIterator ci, int x, int y)\n-  {\n-    throw new Error (\"not implemented\");\n-  }\n-\n-  public void drawRoundRect(int x, int y, int width, int height, \n-\t\t\t    int arcWidth, int arcHeight)\n-  {\n-    if (arcWidth > width)\n-      arcWidth = width;\n-    if (arcHeight > height)\n-      arcHeight = height;\n-\n-    int xx = x + width - arcWidth;\n-    int yy = y + height - arcHeight;\n-\n-    drawArc (x, y, arcWidth, arcHeight, 90, 90);\n-    drawArc (xx, y, arcWidth, arcHeight, 0, 90);\n-    drawArc (xx, yy, arcWidth, arcHeight, 270, 90);\n-    drawArc (x, yy, arcWidth, arcHeight, 180, 90);\n-\n-    int y1 = y + arcHeight / 2;\n-    int y2 = y + height - arcHeight / 2;\n-    drawLine (x, y1, x, y2);\n-    drawLine (x + width, y1, x + width, y2);\n-\n-    int x1 = x + arcWidth / 2;\n-    int x2 = x + width - arcWidth / 2;\n-    drawLine (x1, y, x2, y);\n-    drawLine (x1, y + height, x2, y + height);\n-  }\n-\n-  public void fillRoundRect (int x, int y, int width, int height, \n-\t\t\t     int arcWidth, int arcHeight)\n-  {\n-    if (arcWidth > width)\n-      arcWidth = width;\n-    if (arcHeight > height)\n-      arcHeight = height;\n-\n-    int xx = x + width - arcWidth;\n-    int yy = y + height - arcHeight;\n-\n-    fillArc (x, y, arcWidth, arcHeight, 90, 90);\n-    fillArc (xx, y, arcWidth, arcHeight, 0, 90);\n-    fillArc (xx, yy, arcWidth, arcHeight, 270, 90);\n-    fillArc (x, yy, arcWidth, arcHeight, 180, 90);\n-\n-    fillRect (x, y + arcHeight / 2, width, height - arcHeight + 1);\n-    fillRect (x + arcWidth / 2, y, width - arcWidth + 1, height);\n-  }\n-\n-  public Shape getClip ()\n-  {\n-    return getClipBounds ();\n-  }\n-\n-  public Rectangle getClipBounds ()\n-  {\n-    if (clip == null)\n-      return null;\n-    else\n-      return clip.getBounds();\n-  }\n-\n-  public Color getColor ()\n-  {\n-    return color;\n-  }\n-\n-  public Font getFont ()\n-  {\n-    return font;\n-  }\n-\n-  public FontMetrics getFontMetrics (Font font)\n-  {\n-    // Get the font metrics through GtkToolkit to take advantage of\n-    // the metrics cache.\n-    return Toolkit.getDefaultToolkit().getFontMetrics (font);\n-  }\n-\n-  native void setClipRectangle (int x, int y, int width, int height);\n-\n-  public void setClip (int x, int y, int width, int height)\n-  {\n-    if ((component != null && ! component.isRealized ())\n-        || clip == null)\n-      return;\n-\n-    clip.x = x;\n-    clip.y = y;\n-    clip.width = width;\n-    clip.height = height;\n-    \n-    setClipRectangle (x, y, width, height);\n-  }\n-\n-  public void setClip (Rectangle clip)\n-  {\n-    setClip (clip.x, clip.y, clip.width, clip.height);\n-  }\n-\n-  public void setClip (Shape clip)\n-  {\n-    if (clip == null)\n-      {\n-\t// Reset clipping.\n-\tDimension d = component.awtComponent.getSize();\n-\tsetClip(new Rectangle (0, 0, d.width, d.height));\n-      }\n-    else\n-      setClip(clip.getBounds());\n-  }\n-\n-  private native void setFGColor(int red, int green, int blue);\n-\n-  public void setColor (Color c)\n-  {\n-    if (c == null)\n-      color = Color.BLACK;\n-    else\n-      color = c;\n-\n-    if (xorColor == null) /* paint mode */\n-      setFGColor (color.getRed (), color.getGreen (), color.getBlue ());\n-    else\t\t  /* xor mode */\n-      setFGColor (color.getRed   () ^ xorColor.getRed (),\n-\t\t  color.getGreen () ^ xorColor.getGreen (),\n-\t\t  color.getBlue  () ^ xorColor.getBlue ());\n-  }\n-  \n-  public void setFont (Font font)\n-  {\n-    if (font != null)\n-      this.font = font;\n-  }\n-\n-  native void setFunction (int gdk_func);\n-\n-  public void setPaintMode ()\n-  {\n-    xorColor = null;\n-\n-    setFunction (GDK_COPY);\n-    setFGColor (color.getRed (), color.getGreen (), color.getBlue ());\n-  }\n-\n-  public void setXORMode (Color c)\n-  {\n-    xorColor = c;\n-\n-    setFunction (GDK_XOR);\n-    setFGColor (color.getRed   () ^ xorColor.getRed (),\n-\t\tcolor.getGreen () ^ xorColor.getGreen (),\n-\t\tcolor.getBlue  () ^ xorColor.getBlue ());\n-  }\n-\n-  public native void translateNative(int x, int y);\n-\n-  public void translate (int x, int y)\n-  {\n-    if (component != null && ! component.isRealized ())\n-      return;\n-\n-    clip.x -= x;\n-    clip.y -= y;\n-\n-    translateNative (x, y);\n-  }\n-\n-  /**\n-   * Copies over the state of another GdkGraphics to this instance. This is\n-   * used by the {@link #GdkGraphics(GdkGraphics)} constructor and the\n-   * {@link #create()} method.\n-   *\n-   * @param g the GdkGraphics object to copy the state from\n-   */\n-  private void copyState(GdkGraphics g)\n-  {\n-    color = g.color;\n-    xorColor = g.xorColor;\n-    font = g.font;\n-    if (font == null)\n-      font = new Font (\"Dialog\", Font.PLAIN, 12);\n-    clip = new Rectangle (g.clip);\n-    component = g.component;\n-    nativeCopyState(g);\n-  }\n-}"}, {"sha": "147f8f3e6752b8ccbc94e4dabbfe582cfd47b722", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkGraphicsConfiguration.java", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsConfiguration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsConfiguration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsConfiguration.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* GdkGraphicsConfiguration.java -- describes characteristics of graphics\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004 Free Software Foundation\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2006 Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -42,26 +42,33 @@\n import java.awt.GraphicsDevice;\n import java.awt.ImageCapabilities;\n import java.awt.Rectangle;\n-import java.awt.Toolkit;\n+import java.awt.Transparency;\n \n import java.awt.geom.AffineTransform;\n \n import java.awt.image.BufferedImage;\n import java.awt.image.ColorModel;\n+import java.awt.image.DirectColorModel;\n import java.awt.image.VolatileImage;\n \n public class GdkGraphicsConfiguration \n   extends GraphicsConfiguration\n {\n   GdkScreenGraphicsDevice gdkScreenGraphicsDevice;\n-  ColorModel cm;\n-  Rectangle bounds;\n+  \n+  ColorModel opaqueColorModel;\n \n+  ColorModel bitmaskColorModel;\n+\n+  ColorModel translucentColorModel;\n+  \n   public GdkGraphicsConfiguration(GdkScreenGraphicsDevice dev)\n   {\n-    this.gdkScreenGraphicsDevice = dev;\n-    cm = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB).getColorModel();\n-    bounds = ((GtkToolkit) Toolkit.getDefaultToolkit()).getBounds();\n+    gdkScreenGraphicsDevice = dev;\n+    \n+    opaqueColorModel = new DirectColorModel(32, 0xFF0000, 0xFF00, 0xFF, 0);\n+    bitmaskColorModel = new DirectColorModel(32, 0xFF0000, 0xFF00, 0xFF, 0x1000000);\n+    translucentColorModel = new DirectColorModel(32, 0xFF0000, 0xFF00, 0xFF, 0xFF000000);\n   }\n \n   public GraphicsDevice getDevice()\n@@ -94,12 +101,21 @@ public VolatileImage createCompatibleVolatileImage(int w, int h,\n \n   public ColorModel getColorModel()\n   {\n-    return cm;\n+    return opaqueColorModel;\n   }\n \n   public ColorModel getColorModel(int transparency)\n   {\n-    return getColorModel();\n+    switch (transparency)\n+    {\n+      case Transparency.OPAQUE:\n+        return opaqueColorModel;\n+      case Transparency.BITMASK:\n+        return bitmaskColorModel;\n+      default:\n+      case Transparency.TRANSLUCENT:\n+        return translucentColorModel;\n+    }\n   }\n \n   public AffineTransform getDefaultTransform()\n@@ -116,7 +132,7 @@ public AffineTransform getNormalizingTransform()\n \n   public Rectangle getBounds()\n   {\n-    return bounds;\n+    return gdkScreenGraphicsDevice.getBounds();\n   }\n \n   public BufferCapabilities getBufferCapabilities()\n@@ -133,8 +149,8 @@ public ImageCapabilities getImageCapabilities()\n \n   public VolatileImage createCompatibleVolatileImage(int width, int height, int transparency)\n   {\n-      // FIXME: implement\n-    return null;\n+      // FIXME: support the transparency argument\n+    return new GtkVolatileImage(width, height);\n   }\n \n }"}, {"sha": "e1c076c042a51596794454ca1985abbf89d5bfef", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkGraphicsEnvironment.java", "status": "modified", "additions": 64, "deletions": 16, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsEnvironment.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsEnvironment.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphicsEnvironment.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* GdkGraphicsEnvironment.java -- information about the graphics environment\n-   Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -43,33 +43,80 @@\n import java.awt.GraphicsDevice;\n import java.awt.GraphicsEnvironment;\n import java.awt.HeadlessException;\n-import java.awt.Toolkit;\n import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n import java.util.Locale;\n \n public class GdkGraphicsEnvironment extends GraphicsEnvironment\n {\n+  private final int native_state = GtkGenericPeer.getUniqueInteger ();\n+  \n+  private GdkScreenGraphicsDevice defaultDevice;\n+  \n+  private GdkScreenGraphicsDevice[] devices;\n+  \n+  static\n+  {\n+    System.loadLibrary(\"gtkpeer\");\n+\n+    initStaticState ();\n+  }\n+  \n+  static native void initStaticState();\n+  \n   public GdkGraphicsEnvironment ()\n   {\n+    nativeInitState();\n   }\n+  \n+  native void nativeInitState();\n \n   public GraphicsDevice[] getScreenDevices ()\n   {\n-    // FIXME: Support multiple screens, since GDK can.\n-    return new GraphicsDevice[] { new GdkScreenGraphicsDevice (this) };\n+    if (devices == null)\n+      {\n+        devices = nativeGetScreenDevices();\n+      }\n+    \n+    return (GraphicsDevice[]) devices.clone();\n   }\n+  \n+  private native GdkScreenGraphicsDevice[] nativeGetScreenDevices();\n \n   public GraphicsDevice getDefaultScreenDevice ()\n   {\n     if (GraphicsEnvironment.isHeadless ())\n       throw new HeadlessException ();\n-\n-    return new GdkScreenGraphicsDevice (this);\n+    \n+    // GCJ LOCAL: workaround a GCJ problem accessing\n+    // GdkGraphicsEnvironment.class\n+    try\n+      {\n+    synchronized (Class.forName (\"gnu.java.awt.peer.gtk.GdkGraphicsEnvironment\"))\n+      {\n+        if (defaultDevice == null)\n+          {\n+            defaultDevice = nativeGetDefaultScreenDevice();\n+          }\n+      }\n+      }\n+    catch (Exception e)\n+      {\n+        e.printStackTrace();\n+      }\n+    \n+    return defaultDevice;\n   }\n+  \n+  private native GdkScreenGraphicsDevice nativeGetDefaultScreenDevice();\n \n   public Graphics2D createGraphics (BufferedImage image)\n   {\n-    return new GdkGraphics2D (image);\n+    DataBuffer db = image.getRaster().getDataBuffer();\n+    if(db instanceof CairoSurface)\n+      return ((CairoSurface)db).getGraphics();\n+\n+    return new BufferedImageGraphics( image );\n   }\n   \n   private native int nativeGetNumFontFamilies();\n@@ -80,20 +127,21 @@ public Font[] getAllFonts ()\n     throw new java.lang.UnsupportedOperationException ();\n   }\n \n-    public String[] getAvailableFontFamilyNames ()\n-    {\n-\tString[] family_names;\n-\tint array_size;\n+  public String[] getAvailableFontFamilyNames ()\n+  {\n+    String[] family_names;\n+    int array_size;\n \n-\tarray_size = nativeGetNumFontFamilies();\n-\tfamily_names = new String[array_size];\n+    array_size = nativeGetNumFontFamilies();\n+    family_names = new String[array_size];\n \n-\tnativeGetFontFamilies(family_names);\n-\treturn family_names;\n-    }\n+    nativeGetFontFamilies(family_names);\n+    return family_names;\n+  }\n \n   public String[] getAvailableFontFamilyNames (Locale l)\n   {\n     throw new java.lang.UnsupportedOperationException ();\n   }\n+  \n }"}, {"sha": "58b2decc527721faa6e5991f1f36300a50386ed7", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkPixbufDecoder.java", "status": "modified", "additions": 22, "deletions": 49, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkPixbufDecoder.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -247,12 +247,23 @@ public synchronized void addExtension(String e)\n   public static ImageFormatSpec registerFormat(String name, boolean writable) \n   {\n     ImageFormatSpec ifs = new ImageFormatSpec(name, writable);\n-    synchronized(GdkPixbufDecoder.class)\n+\n+    // GCJ LOCAL: workaround a GCJ problem accessing\n+    // GdkPixbufDecoder.class\n+    try\n+      {\n+    synchronized(Class.forName (\"gnu.java.awt.peer.gtk.GdkPixbufDecoder\"))\n       {\n         if (imageFormatSpecs == null)\n           imageFormatSpecs = new ArrayList();\n         imageFormatSpecs.add(ifs);\n       }\n+      }\n+    catch (Exception e)\n+      {\n+        e.printStackTrace();\n+      }\n+    \n     return ifs;\n   }\n \n@@ -502,19 +513,19 @@ public void write (IIOMetadata streamMetadata, IIOImage i, ImageWriteParam param\n       int width = ras.getWidth();\n       int height = ras.getHeight();\n       ColorModel model = image.getColorModel();\n-      int[] pixels = GdkGraphics2D.findSimpleIntegerArray (image.getColorModel(), ras);\n+      int[] pixels = CairoGraphics2D.findSimpleIntegerArray (image.getColorModel(), ras);\n       \n       if (pixels == null)\n         {\n-          BufferedImage img = new BufferedImage(width, height, \n-                                                (model != null && model.hasAlpha() ? \n-                                                 BufferedImage.TYPE_INT_ARGB\n-                                                 : BufferedImage.TYPE_INT_RGB));\n+\t  BufferedImage img;\n+\t  if(model != null && model.hasAlpha())\n+\t    img = CairoSurface.getBufferedImage(width, height);\n+\t  img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n           int[] pix = new int[4];\n           for (int y = 0; y < height; ++y)\n             for (int x = 0; x < width; ++x)\n               img.setRGB(x, y, model.getRGB(ras.getPixel(x, y, pix)));\n-          pixels = GdkGraphics2D.findSimpleIntegerArray (img.getColorModel(), \n+          pixels = CairoGraphics2D.findSimpleIntegerArray (img.getColorModel(), \n                                                          img.getRaster());\n           model = img.getColorModel();\n         }\n@@ -584,9 +595,10 @@ public void setPixels(int x, int y, int w, int h,\n       \n       if (bufferedImage == null)\n         {\n-          bufferedImage = new BufferedImage (width, height, (model != null && model.hasAlpha() ? \n-                                                             BufferedImage.TYPE_INT_ARGB\n-                                                             : BufferedImage.TYPE_INT_RGB));\n+\t  if(model != null && model.hasAlpha())\n+\t    bufferedImage = new BufferedImage (width, height, BufferedImage.TYPE_INT_ARGB);\n+\t  else\n+\t    bufferedImage = new BufferedImage (width, height, BufferedImage.TYPE_INT_RGB);\n         }\n \n       int pixels2[];\n@@ -680,43 +692,4 @@ public BufferedImage read(int imageIndex, ImageReadParam param)\n       return getBufferedImage ();\n     }\n   }\n-\n-  // remaining helper class and static method is a convenience for the Gtk\n-  // peers, for loading a BufferedImage in off a disk file without going\n-  // through the whole imageio system. \n-\n-  public static BufferedImage createBufferedImage (String filename)\n-  {\n-    GdkPixbufReader r = new GdkPixbufReader (getReaderSpi(), \n-                                             \"png\", // reader auto-detects, doesn't matter\n-                                             new GdkPixbufDecoder (filename));\n-    return r.getBufferedImage ();\n-  }\n-\n-  public static BufferedImage createBufferedImage (URL u)\n-  {\n-    GdkPixbufReader r = new GdkPixbufReader (getReaderSpi(), \n-                                             \"png\", // reader auto-detects, doesn't matter\n-                                             new GdkPixbufDecoder (u));\n-    return r.getBufferedImage ();\n-  }\n-\n-  public static BufferedImage createBufferedImage (byte[] imagedata, int imageoffset,\n-                                                   int imagelength)\n-  {\n-    GdkPixbufReader r = new GdkPixbufReader (getReaderSpi(), \n-                                             \"png\", // reader auto-detects, doesn't matter\n-                                             new GdkPixbufDecoder (imagedata,\n-                                                                   imageoffset,\n-                                                                   imagelength));\n-    return r.getBufferedImage ();\n-  }\n-  \n-  public static BufferedImage createBufferedImage (ImageProducer producer)\n-  {\n-    GdkPixbufReader r = new GdkPixbufReader (getReaderSpi(), \"png\" /* ignored */, null);\n-    producer.startProduction(r);\n-    return r.getBufferedImage ();\n-  }\n-\n }"}, {"sha": "62116a3226cf7c0706f8c3157a7f0aaf66abf9e9", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkScreenGraphicsDevice.java", "status": "modified", "additions": 259, "deletions": 23, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkScreenGraphicsDevice.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkScreenGraphicsDevice.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkScreenGraphicsDevice.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* GdkScreenGraphicsDevice.java -- information about a screen device\n-   Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,44 +38,110 @@\n \n package gnu.java.awt.peer.gtk;\n \n-import java.awt.Dimension;\n import java.awt.DisplayMode;\n+import java.awt.Frame;\n import java.awt.GraphicsConfiguration;\n import java.awt.GraphicsDevice;\n-import java.awt.Toolkit;\n+import java.awt.Rectangle;\n+import java.awt.Window;\n+import java.util.ArrayList;\n \n-public class GdkScreenGraphicsDevice extends GraphicsDevice\n+class GdkScreenGraphicsDevice extends GraphicsDevice\n {\n+  private final int native_state = GtkGenericPeer.getUniqueInteger ();\n+  \n+  private Window fullscreenWindow;\n+  \n+  private boolean oldWindowDecorationState;\n+  \n+  private Rectangle oldWindowBounds;\n+  \n+  private Rectangle bounds;\n+  \n+  private GdkGraphicsConfiguration[] configurations;\n+  \n+  /** The <code>GdkGraphicsEnvironment</code> instance that created this\n+   * <code>GdkScreenGraphicsDevice</code>. This is only needed for native\n+   * methods which need to access the 'native_state' field storing a pointer\n+   * to a GdkDisplay object.\n+   */ \n   GdkGraphicsEnvironment env;\n+  \n+  /** An identifier that is created by Gdk\n+   */\n+  String idString;\n+  \n+  /** The display modes supported by this <code>GdkScreenGraphicsDevice</code>.\n+   * If the array is <code>null</code> <code>nativeGetDisplayModes</code> has\n+   * to be called.\n+   */\n+  X11DisplayMode[] displayModes;\n \n-  public GdkScreenGraphicsDevice (GdkGraphicsEnvironment e)\n-  {    \n-    super ();\n+  /** The non-changeable display mode of this <code>GdkScreenGraphicsDevice\n+   * </code>. This field gets initialized by the {@link #init()} method. If it\n+   * is still <code>null</code> afterwards, the XRandR extension is available\n+   * and display mode changes are possible. If it is non-null XRandR is not\n+   * available, no display mode changes are possible and no other native\n+   * method must be called. \n+   */\n+  DisplayMode fixedDisplayMode;\n+  \n+  static\n+  {\n+    System.loadLibrary(\"gtkpeer\");\n+\n+    initStaticState ();\n+  }\n+  \n+  static native void initStaticState();\n+  \n+  GdkScreenGraphicsDevice (GdkGraphicsEnvironment e)\n+  {\n+    super();\n     env = e;\n+    \n+    configurations = new GdkGraphicsConfiguration[1];\n+    configurations[0] = new GdkGraphicsConfiguration(this);\n   }\n \n+  /** This method is called from the native side immediately after\n+   * the constructor is run.\n+   */\n+  void init()\n+  {\n+    fixedDisplayMode = nativeGetFixedDisplayMode(env);\n+  }\n+  \n+  /** Depending on the availability of the XRandR extension the method returns\n+   * the screens' non-changeable display mode or null, meaning that XRandR can\n+   * handle display mode changes.\n+   */\n+  native DisplayMode nativeGetFixedDisplayMode(GdkGraphicsEnvironment env);\n+  \n   public int getType ()\n   {\n+    // Gdk manages only raster screens.\n     return GraphicsDevice.TYPE_RASTER_SCREEN;\n   }\n \n   public String getIDstring ()\n   {\n-    // FIXME: query X for this string\n-    return \"default GDK device ID string\";\n+    if (idString == null)\n+      idString = nativeGetIDString();\n+    \n+    return idString;\n   }\n+  \n+  private native String nativeGetIDString(); \n \n   public GraphicsConfiguration[] getConfigurations ()\n   {\n-    // FIXME: query X for the list of possible configurations\n-    return new GraphicsConfiguration [] { new GdkGraphicsConfiguration(this) };\n+    return (GraphicsConfiguration[]) configurations.clone();\n   }\n-\n+  \n   public GraphicsConfiguration getDefaultConfiguration ()\n   {\n-    \n-    // FIXME: query X for default configuration\n-    return new GdkGraphicsConfiguration(this);\n+    return configurations[0];\n   }\n \n \n@@ -89,23 +155,193 @@ public GraphicsConfiguration getDefaultConfiguration ()\n    */\n   public DisplayMode getDisplayMode()\n   {\n-    // determine display mode\n-    Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n-    DisplayMode mode = new DisplayMode(dim.width, dim.height, 0,\n-\t\t\t\t       DisplayMode.REFRESH_RATE_UNKNOWN);\n-    return mode;\n+    if (fixedDisplayMode != null)\n+      return fixedDisplayMode;\n+    \n+    synchronized (this)\n+      {\n+        if (displayModes == null)\n+          displayModes = nativeGetDisplayModes(env);\n+      }\n+\n+    int index = nativeGetDisplayModeIndex(env);\n+    int rate = nativeGetDisplayModeRate(env);\n+    \n+    return new DisplayMode(displayModes[index].width,\n+                           displayModes[index].height,\n+                           DisplayMode.BIT_DEPTH_MULTI,\n+                           rate);\n+  }\n+  \n+  native int nativeGetDisplayModeIndex(GdkGraphicsEnvironment env);\n+  \n+  native int nativeGetDisplayModeRate(GdkGraphicsEnvironment env);\n+  \n+  public DisplayMode[] getDisplayModes()\n+  {\n+    if (fixedDisplayMode != null)\n+      return new DisplayMode[] { fixedDisplayMode };\n+    \n+    synchronized (this)\n+      {\n+        if (displayModes == null)\n+          displayModes = nativeGetDisplayModes(env);\n+      }\n+    \n+    ArrayList list = new ArrayList();\n+    for(int i=0;i<displayModes.length;i++)\n+      for(int j=0;j<displayModes[i].rates.length;j++)\n+        list.add(new DisplayMode(displayModes[i].width,\n+                                 displayModes[i].height,\n+                                 DisplayMode.BIT_DEPTH_MULTI,\n+                                 displayModes[i].rates[j]));\n+    \n+    return (DisplayMode[]) list.toArray(new DisplayMode[list.size()]);\n   }\n+  \n+  native X11DisplayMode[] nativeGetDisplayModes(GdkGraphicsEnvironment env);\n \n   /**\n-   * This device does not yet support fullscreen exclusive mode, so this\n-   * returns <code>false</code>.\n+   * Real fullscreen exclusive mode is not supported.\n    *\n    * @return <code>false</code>\n    * @since 1.4\n    */\n   public boolean isFullScreenSupported()\n   {\n-    return false;\n+    return true;\n+  }\n+  \n+  public boolean isDisplayChangeSupported()\n+  {\n+    return fixedDisplayMode == null;\n+  }\n+\n+  public void setDisplayMode(DisplayMode dm)\n+  {\n+    if (fixedDisplayMode != null)\n+      throw new UnsupportedOperationException(\"Cannnot change display mode.\");\n+    \n+    if (dm == null)\n+      throw new IllegalArgumentException(\"DisplayMode must not be null.\");\n+    \n+    synchronized (this)\n+      {\n+        if (displayModes == null)\n+          displayModes = nativeGetDisplayModes(env);\n+      }\n+    \n+    for (int i=0; i<displayModes.length; i++)\n+      if (displayModes[i].width == dm.getWidth()\n+          && displayModes[i].height == dm.getHeight())\n+        {\n+          synchronized (this)\n+          {\n+            nativeSetDisplayMode(env,\n+                                 i,\n+                                 (short) dm.getRefreshRate());\n+          \n+            bounds = null;\n+          }\n+          \n+          return;\n+        }\n+    \n+    throw new IllegalArgumentException(\"Mode not supported by this device.\");\n+  }\n+  \n+  native void nativeSetDisplayMode(GdkGraphicsEnvironment env,\n+                                int index, short rate);\n+  \n+  /** A class that simply encapsulates the X11 display mode data.\n+   */\n+  static class X11DisplayMode\n+  {\n+    short[] rates;\n+    int width;\n+    int height;\n+    \n+    X11DisplayMode(int width, int height, short[] rates)\n+    {\n+      this.width = width;\n+      this.height = height;\n+      this.rates = rates;\n+    }\n+    \n+  }\n+  \n+  public void setFullScreenWindow(Window w)\n+  {\n+    // Bring old fullscreen window back into its original state.\n+    if (fullscreenWindow != null && w != fullscreenWindow)\n+      {\n+        if (fullscreenWindow instanceof Frame)\n+          {\n+            // Decoration state can only be switched when the peer is\n+            // non-existent. That means we have to dispose the \n+            // Frame.\n+            Frame f = (Frame) fullscreenWindow;\n+            if (oldWindowDecorationState != f.isUndecorated())\n+              {\n+                f.dispose();\n+                f.setUndecorated(oldWindowDecorationState);\n+              }\n+          }\n+        \n+        fullscreenWindow.setBounds(oldWindowBounds);\n+\n+        if (!fullscreenWindow.isVisible())\n+          fullscreenWindow.setVisible(true);\n+      }\n+    \n+    // If applicable remove decoration, then maximize the window and\n+    // bring it to the foreground.\n+    if (w != null)\n+      {\n+        if (w instanceof Frame)\n+          {\n+            Frame f = (Frame) w;\n+            oldWindowDecorationState = f.isUndecorated();\n+            if (!oldWindowDecorationState)\n+              {\n+                f.dispose();\n+                f.setUndecorated(true);\n+              }\n+          }\n+        \n+        oldWindowBounds = w.getBounds();\n+    \n+        DisplayMode dm = getDisplayMode();\n+    \n+        w.setBounds(0, 0, dm.getWidth(), dm.getHeight());\n+        \n+        if (!w.isVisible())\n+          w.setVisible(true);\n+        \n+        w.requestFocus();\n+        w.toFront();\n+        \n+      }\n+    \n+    fullscreenWindow = w;\n+  }\n+  \n+  public Window getFullScreenWindow()\n+  {\n+   return fullscreenWindow; \n+  }\n+\n+  Rectangle getBounds()\n+  {\n+   synchronized(this)\n+     {\n+       if (bounds == null)\n+         bounds = nativeGetBounds();\n+     }\n+   \n+   return bounds;\n   }\n+  \n+  native Rectangle nativeGetBounds();\n \n }"}, {"sha": "d6b3de8c07f73260fc8f1284c43e22adb0583b2a", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GdkTextLayout.java", "status": "modified", "additions": 18, "deletions": 54, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkTextLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkTextLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkTextLayout.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -75,13 +75,21 @@ public class GdkTextLayout\n     initStaticState ();\n   }\n   private native void setText(String str);\n+  private native void setFont(GdkFontPeer font);\n   private native void getExtents(double[] inkExtents,\n                                  double[] logExtents);\n   private native void indexToPos(int idx, double[] pos);\n+\n   private native void initState ();\n+\n   private native void dispose ();\n+\n+  private native void cairoDrawGdkTextLayout(CairoGraphics2D g, float x, float y);\n+\n   static native void initStaticState();\n+\n   private final int native_state = GtkGenericPeer.getUniqueInteger ();\n+\n   protected void finalize ()\n   {\n     dispose ();\n@@ -97,6 +105,15 @@ public GdkTextLayout(AttributedString str, FontRenderContext frc)\n     initState();\n     attributedString = str;\n     fontRenderContext = frc;\n+    AttributedCharacterIterator aci = str.getIterator();\n+    char[] chars = new char[aci.getEndIndex() - aci.getBeginIndex()];\n+    for(int i = aci.getBeginIndex(); i < aci.getEndIndex(); i++)\n+      chars[i] = aci.setIndex(i);    \n+    setText(new String(chars));\n+\n+    Object fnt = aci.getAttribute(TextAttribute.FONT);\n+    if (fnt != null && fnt instanceof Font) \t \n+      setFont( (GdkFontPeer) ((Font)fnt).getPeer() );\n   }\n \n   protected class CharacterIteratorProxy \n@@ -199,60 +216,7 @@ public Object clone ()\n \n   public void draw (Graphics2D g2, float x, float y)\n   {\n-    if (g2 instanceof GdkGraphics2D)\n-      {\n-        // we share pango structures directly with GdkGraphics2D \n-        // when legal\n-        GdkGraphics2D gg2 = (GdkGraphics2D) g2;\n-        gg2.drawGdkTextLayout(this, x, y);\n-      }\n-    else \n-      {\n-        // falling back to a rather tedious layout algorithm when\n-        // not legal\n-        AttributedCharacterIterator ci = attributedString.getIterator ();\n-        CharacterIteratorProxy proxy = new CharacterIteratorProxy (ci);\n-        Font defFont = g2.getFont ();\n-\n-        /* Note: this implementation currently only interprets FONT text\n-         * attributes. There is a reasonable argument to be made for some\n-         * attributes being interpreted out here, where we have control of the\n-         * Graphics2D and can construct or derive new fonts, and some\n-         * attributes being interpreted by the GlyphVector itself. So far, for\n-         * all attributes except FONT we do neither.\n-         */\n-\n-        for (char c = ci.first ();\n-             c != CharacterIterator.DONE;\n-             c = ci.next ())\n-          {                \n-            proxy.begin = ci.getIndex ();\n-            proxy.limit = ci.getRunLimit(TextAttribute.FONT);\n-            if (proxy.limit <= proxy.begin)\n-              continue;\n-\n-            proxy.index = proxy.begin;\n-\n-            Object fnt = ci.getAttribute(TextAttribute.FONT);\n-            GlyphVector gv;\n-            if (fnt instanceof Font)\n-              gv = ((Font)fnt).createGlyphVector (fontRenderContext, proxy);\n-            else\n-              gv = defFont.createGlyphVector (fontRenderContext, proxy);\n-\n-            g2.drawGlyphVector (gv, x, y);\n-\n-            int n = gv.getNumGlyphs ();\n-            for (int i = 0; i < n; ++i)\n-              {\n-                GlyphMetrics gm = gv.getGlyphMetrics (i);\n-                if (gm.getAdvanceX() == gm.getAdvance ())\n-                  x += gm.getAdvanceX ();\n-                else\n-                  y += gm.getAdvanceY ();\n-              }\n-          }\n-      }\n+    cairoDrawGdkTextLayout((CairoGraphics2D)g2, x, y);\n   }\n \n   public TextHitInfo getStrongCaret (TextHitInfo hit1, "}, {"sha": "edfc9ceee9c0b0e0885f74cd178a31ca96ac9e41", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GtkCanvasPeer.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCanvasPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCanvasPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkCanvasPeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -45,7 +45,6 @@\n public class GtkCanvasPeer extends GtkComponentPeer implements CanvasPeer\n {\n   native void create ();\n-  native void realize ();\n \n   public GtkCanvasPeer (Canvas c)\n   {"}, {"sha": "625855f01176610bb7b1bf1a4b0566a0ac6a0d62", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GtkComponentPeer.java", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkComponentPeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -109,14 +109,7 @@ native void gtkWidgetSetCursorUnlocked (int type, GtkImage image,\n   native void gtkWidgetRequestFocus ();\n   native void gtkWidgetDispatchKeyEvent (int id, long when, int mods,\n                                          int keyCode, int keyLocation);\n-\n-  native boolean isRealized ();\n-\n-  void realize ()\n-  {\n-    // Default implementation does nothing\n-  }\n-\n+  native void realize();\n   native void setNativeEventMask ();\n \n   void create ()\n@@ -149,6 +142,9 @@ protected GtkComponentPeer (Component awtComponent)\n \n     setNativeEventMask ();\n \n+    // This peer is guaranteed to have an X window upon construction.\n+    // That is, native methods such as those in GdkGraphics can rely\n+    // on this component's widget->window field being non-null.\n     realize ();\n \n     if (awtComponent.isCursorSet())\n@@ -211,16 +207,7 @@ public Image createImage (ImageProducer producer)\n \n   public Image createImage (int width, int height)\n   {\n-    Image image;\n-    if (GtkToolkit.useGraphics2D ())\n-      image = new BufferedImage (width, height, BufferedImage.TYPE_INT_RGB);\n-    else\n-      image = new GtkImage (width, height);\n-\n-    Graphics g = image.getGraphics();\n-    g.setColor(getBackground());\n-    g.fillRect(0, 0, width, height);\n-    return image;\n+    return CairoSurface.getBufferedImage(width, height);\n   }\n \n   public void disable () \n@@ -247,10 +234,7 @@ public FontMetrics getFontMetrics (Font font)\n   // never return null.\n   public Graphics getGraphics ()\n   {\n-    if (GtkToolkit.useGraphics2D ())\n-        return new GdkGraphics2D (this);\n-    else\n-        return new GdkGraphics (this);\n+    return ComponentGraphics.getComponentGraphics(this);\n   }\n \n   public Point getLocationOnScreen () \n@@ -713,7 +697,7 @@ public boolean handlesWheelScrolling ()\n   // on which this component is displayed.\n   public VolatileImage createVolatileImage (int width, int height)\n   {\n-    return new GtkVolatileImage (width, height);\n+    return new GtkVolatileImage (this, width, height, null);\n   }\n \n   // Creates buffers used in a buffering strategy.\n@@ -723,7 +707,7 @@ public void createBuffers (int numBuffers, BufferCapabilities caps)\n     // numBuffers == 2 implies double-buffering, meaning one back\n     // buffer and one front buffer.\n     if (numBuffers == 2)\n-      backBuffer = new GtkVolatileImage(awtComponent.getWidth(),\n+      backBuffer = new GtkVolatileImage(this, awtComponent.getWidth(),\n \t\t\t\t\tawtComponent.getHeight(),\n \t\t\t\t\tcaps.getBackBufferCapabilities());\n     else"}, {"sha": "ef96518a1c0160f254626385fd41d60cda0e97d8", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GtkImage.java", "status": "modified", "additions": 72, "deletions": 201, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkImage.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -57,14 +57,7 @@\n import gnu.classpath.Pointer;\n \n /**\n- * GtkImage - wraps a GdkPixbuf or GdkPixmap.\n- *\n- * The constructor GtkImage(int, int) creates an 'off-screen' GdkPixmap,\n- * this can be drawn to (it's a GdkDrawable), and correspondingly, you can\n- * create a GdkGraphics object for it. \n- *\n- * This corresponds to the Image implementation returned by \n- * Component.createImage(int, int). \n+ * GtkImage - wraps a GdkPixbuf.\n  *\n  * A GdkPixbuf is 'on-screen' and the gdk cannot draw to it,\n  * this is used for the other constructors (and other createImage methods), and\n@@ -88,20 +81,16 @@ public class GtkImage extends Image\n   boolean isLoaded;\n \n   /**\n-   * Pointer to the GdkPixbuf\n+   * Pointer to the GdkPixbuf - \n+   * don't change the name without changing the native code.\n    */\n-  Pointer pixmap;\n+  Pointer pixbuf;\n \n   /**\n    * Observer queue.\n    */\n   Vector observers;\n \n-  /**\n-   * If offScreen is set, a GdkBitmap is wrapped and not a Pixbuf.\n-   */\n-  boolean offScreen;\n-\n   /**\n    * Error flag for loading.\n    */\n@@ -121,72 +110,65 @@ public class GtkImage extends Image\n \t\t\t\t\t\t       0x00FF0000,\n \t\t\t\t\t\t       0xFF000000);\n \n+  /**\n+   * The singleton GtkImage that is returned on errors by GtkToolkit.\n+   */\n+  private static GtkImage errorImage;\n+\n+  /**\n+   * Lock that should be held for all gdkpixbuf operations. We don't use\n+   * the global gdk_threads_enter/leave functions in most places since\n+   * most gdkpixbuf operations can be done in parallel to drawing and \n+   * manipulating gtk widgets.\n+   */\n+  static Object pixbufLock = new Object();\n+\n+  /**\n+   * Allocate a PixBuf from a given ARGB32 buffer pointer.\n+   */\n+  private native void initFromBuffer( long bufferPointer );\n+\n   /**\n    * Returns a copy of the pixel data as a java array.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n+   * Should be called with the pixbufLock held.\n    */\n-  private native int[] getPixels();\n+  native int[] getPixels();\n \n   /**\n    * Sets the pixel data from a java array.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n+   * Should be called with the pixbufLock held.\n    */\n   private native void setPixels(int[] pixels);\n \n   /**\n    * Loads an image using gdk-pixbuf from a file.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n+   * Should be called with the pixbufLock held.\n    */\n   private native boolean loadPixbuf(String name);\n \n   /**\n    * Loads an image using gdk-pixbuf from data.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n+   * Should be called with the pixbufLock held.\n    */\n   private native boolean loadImageFromData(byte[] data);\n \n   /**\n-   * Allocates a Gtk Pixbuf or pixmap\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n+   * Allocates a Gtk Pixbuf\n+   * Should be called with the pixbufLock held.\n    */\n-  private native void createPixmap();\n+  private native void createPixbuf();\n \n   /**\n    * Frees the above.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n-   */\n-  private native void freePixmap();\n-\n-  /**\n-   * Sets the pixmap to scaled copy of src image. hints are rendering hints.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n-   */\n-  private native void createScaledPixmap(GtkImage src, int hints);\n-\n-  /**\n-   * Draws the image, optionally scaled and composited.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n-   * Also acquires global gdk lock for drawing.\n+   * Should be called with the pixbufLock held.\n    */\n-  private native void drawPixelsScaled (GdkGraphics gc, \n-\t\t\t\t\tint bg_red, int bg_green, int bg_blue, \n-\t\t\t\t\tint x, int y, int width, int height, \n-\t\t\t\t\tboolean composite);\n+  private native void freePixbuf();\n \n   /**\n-   * Draws the image, optionally scaled flipped and composited.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n-   * Also acquires global gdk lock for drawing.\n+   * Sets the pixbuf to scaled copy of src image. hints are rendering hints.\n+   * Should be called with the pixbufLock held.\n    */\n-  private native void drawPixelsScaledFlipped (GdkGraphics gc, \n-\t\t\t\t\t       int bg_red, int bg_green, \n-\t\t\t\t\t       int bg_blue, \n-\t\t\t\t\t       boolean flipX, boolean flipY,\n-\t\t\t\t\t       int srcX, int srcY,\n-\t\t\t\t\t       int srcWidth, int srcHeight,\n-\t\t\t\t\t       int dstX, int dstY,\n-\t\t\t\t\t       int dstWidth, int dstHeight,\n-\t\t\t\t\t       boolean composite);\n+  private native void createScaledPixbuf(GtkImage src, int hints);\n \n   /**\n    * Constructs a GtkImage from an ImageProducer. Asynchronity is handled in\n@@ -202,7 +184,6 @@ public GtkImage (ImageProducer producer)\n     source = producer;\n     errorLoading = false;\n     source.startProduction(new GtkImageConsumer(this, source));\n-    offScreen = false;\n   }\n \n   /**\n@@ -215,7 +196,6 @@ public GtkImage ()\n   {\n     isLoaded = true;\n     observers = null;\n-    offScreen = false;\n     props = new Hashtable();\n     errorLoading = false;\n   }\n@@ -231,7 +211,7 @@ public GtkImage (String filename)\n     try\n       {\n \tString path = f.getCanonicalPath();\n-\tsynchronized(GdkPixbufDecoder.pixbufLock)\n+\tsynchronized(pixbufLock)\n \t  {\n \t    if (loadPixbuf(f.getCanonicalPath()) != true)\n \t      throw new IllegalArgumentException(\"Couldn't load image: \"\n@@ -249,7 +229,6 @@ public GtkImage (String filename)\n \n     isLoaded = true;\n     observers = null;\n-    offScreen = false;\n     props = new Hashtable();\n   }\n \n@@ -261,15 +240,14 @@ public GtkImage (String filename)\n    */\n   public GtkImage (byte[] data)\n   {\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n+    synchronized(pixbufLock)\n       {\n \tif (loadImageFromData (data) != true)\n \t  throw new IllegalArgumentException (\"Couldn't load image.\");\n       }\n \n     isLoaded = true;\n     observers = null;\n-    offScreen = false;\n     props = new Hashtable();\n     errorLoading = false;\n   }\n@@ -301,7 +279,7 @@ public GtkImage (URL url)\n \tthrow new IllegalArgumentException (\"Couldn't load image.\");\n       }\n     byte[] array = baos.toByteArray();\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n+    synchronized(pixbufLock)\n       {\n \tif (loadImageFromData(array) != true)\n \t  throw new IllegalArgumentException (\"Couldn't load image.\");\n@@ -312,23 +290,6 @@ public GtkImage (URL url)\n     props = new Hashtable();\n   }\n \n-  /**\n-   * Constructs an empty GtkImage.\n-   */\n-  public GtkImage (int width, int height)\n-  {\n-    this.width = width;\n-    this.height = height;\n-    props = new Hashtable();\n-    isLoaded = true;\n-    observers = null;\n-    offScreen = true;\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n-      {\n-\tcreatePixmap();\n-      }\n-  }\n-\n   /**\n    * Constructs a scaled version of the src bitmap, using the GDK.\n    */\n@@ -339,12 +300,11 @@ private GtkImage (GtkImage src, int width, int height, int hints)\n     props = new Hashtable();\n     isLoaded = true;\n     observers = null;\n-    offScreen = false;\n \n     // Use the GDK scaling method.\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n+    synchronized(pixbufLock)\n       {\n-\tcreateScaledPixmap(src, hints);\n+\tcreateScaledPixbuf(src, hints);\n       }\n   }\n \n@@ -354,19 +314,30 @@ private GtkImage (GtkImage src, int width, int height, int hints)\n    */\n   GtkImage (Pointer pixbuf)\n   {\n-    pixmap = pixbuf;\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n+    this.pixbuf = pixbuf;\n+    synchronized(pixbufLock)\n       {\n \tcreateFromPixbuf();\n       }\n     isLoaded = true;\n     observers = null;\n-    offScreen = false;\n     props = new Hashtable();\n   }\n \n-  // The singleton GtkImage that is returned on errors by GtkToolkit.\n-  private static GtkImage errorImage;\n+  /**\n+   * Wraps a buffer with a GtkImage.\n+   *\n+   * @param bufferPointer a pointer to an ARGB32 buffer\n+   */\n+  GtkImage(int width, int height, long bufferPointer)\n+  {\n+    this.width = width;\n+    this.height = height;\n+    props = new Hashtable();\n+    isLoaded = true;\n+    observers = null;\n+    initFromBuffer( bufferPointer );\n+  }\n \n   /**\n    * Returns an empty GtkImage with the errorLoading flag set.\n@@ -385,7 +356,7 @@ static synchronized GtkImage getErrorImage()\n \n   /**\n    * Native helper function for constructor that takes a pixbuf Pointer.\n-   * Should be called with the GdkPixbufDecoder.pixbufLock held.\n+   * Should be called with the pixbufLock held.\n    */\n   private native void createFromPixbuf();\n \n@@ -407,9 +378,9 @@ public void setImage(int width, int height,\n \n     isLoaded = true;\n     deliver();\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n+    synchronized(pixbufLock)\n       {\n-\tcreatePixmap();\n+\tcreatePixbuf();\n \tsetPixels(pixels);\n       }\n   }\n@@ -450,30 +421,28 @@ public ImageProducer getSource ()\n       return null;\n \n     int[] pixels;\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n+    synchronized (pixbufLock)\n       {\n-\tpixels = getPixels();\n+        if (!errorLoading)\n+          pixels = getPixels();\n+        else\n+          return null;\n       }\n     return new MemoryImageSource(width, height, nativeModel, pixels, \n \t\t\t\t 0, width);\n   }\n \n   /**\n-   * Creates a GdkGraphics context for this pixmap.\n+   * Does nothing. Should not be called.\n    */\n   public Graphics getGraphics ()\n   {\n-    if (!isLoaded) \n-      return null;\n-    if (offScreen)\n-      return new GdkGraphics(this);\n-    else\n-      throw new IllegalAccessError(\"This method only works for off-screen\"\n-\t\t\t\t   +\" Images.\");\n+    throw new IllegalAccessError(\"This method only works for off-screen\"\n+\t\t\t\t +\" Images.\");\n   }\n   \n   /**\n-   * Returns a scaled instance of this pixmap.\n+   * Returns a scaled instance of this pixbuf.\n    */\n   public Image getScaledInstance(int width,\n \t\t\t\t int height,\n@@ -500,9 +469,9 @@ public synchronized void flush ()\n       {\n \tobservers = new Vector();\n \tisLoaded = false;\n-\tsynchronized(GdkPixbufDecoder.pixbufLock)\n+\tsynchronized(pixbufLock)\n \t  {\n-\t    freePixmap();\n+\t    freePixbuf();\n \t  }\n \tsource.startProduction(new GtkImageConsumer(this, source));\n       }\n@@ -512,9 +481,9 @@ public void finalize()\n   {\n     if (isLoaded)\n       {\n-\tsynchronized(GdkPixbufDecoder.pixbufLock)\n+\tsynchronized(pixbufLock)\n \t  {\n-\t    freePixmap();\n+\t    freePixbuf();\n \t  }\n       }\n   }\n@@ -535,104 +504,6 @@ public int checkImage (ImageObserver observer)\n     return ImageObserver.ALLBITS | ImageObserver.WIDTH | ImageObserver.HEIGHT;\n   }\n \n-  // Drawing methods ////////////////////////////////////////////////\n-\n-  /**\n-   * Draws an image with eventual scaling/transforming.\n-   */\n-  public boolean drawImage (GdkGraphics g, int dx1, int dy1, int dx2, int dy2, \n-\t\t\t    int sx1, int sy1, int sx2, int sy2, \n-\t\t\t    Color bgcolor, ImageObserver observer)\n-  {\n-    if (addObserver(observer))\n-      return false;\n-\n-    boolean flipX = (dx1 > dx2)^(sx1 > sx2);\n-    boolean flipY = (dy1 > dy2)^(sy1 > sy2);\n-    int dstWidth = Math.abs (dx2 - dx1);\n-    int dstHeight = Math.abs (dy2 - dy1);\n-    int srcWidth = Math.abs (sx2 - sx1);\n-    int srcHeight = Math.abs (sy2 - sy1);\n-    int srcX = (sx1 < sx2) ? sx1 : sx2;\n-    int srcY = (sy1 < sy2) ? sy1 : sy2;\n-    int dstX = (dx1 < dx2) ? dx1 : dx2;\n-    int dstY = (dy1 < dy2) ? dy1 : dy2;\n-\n-    // Clipping. This requires the dst to be scaled as well, \n-    if (srcWidth > width)\n-      {\n-\tdstWidth = (int)((double)dstWidth*((double)width/(double)srcWidth));\n-\tsrcWidth = width - srcX;\n-      }\n-\n-    if (srcHeight > height) \n-      {\n-\tdstHeight = (int)((double)dstHeight*((double)height/(double)srcHeight));\n-\tsrcHeight = height - srcY;\n-      }\n-\n-    if (srcWidth + srcX > width)\n-      {\n-\tdstWidth = (int)((double)dstWidth * (double)(width - srcX)/(double)srcWidth);\n-\tsrcWidth = width - srcX;\n-      }\n-\n-    if (srcHeight + srcY > height)\n-      {\n-\tdstHeight = (int)((double)dstHeight * (double)(width - srcY)/(double)srcHeight);\n-\tsrcHeight = height - srcY;\n-      }\n-\n-    if ( this.width <= 0 || this.height <= 0 )\n-      return true;\n-\n-    if ( srcWidth <= 0 || srcHeight <= 0 || dstWidth <= 0 || dstHeight <= 0)\n-      return true;\n-\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n-      {\n-\tif(bgcolor != null)\n-\t  drawPixelsScaledFlipped (g, bgcolor.getRed (), bgcolor.getGreen (), \n-\t\t\t\t   bgcolor.getBlue (), \n-\t\t\t\t   flipX, flipY,\n-\t\t\t\t   srcX, srcY,\n-\t\t\t\t   srcWidth, srcHeight,\n-\t\t\t\t   dstX,  dstY,\n-\t\t\t\t   dstWidth, dstHeight,\n-\t\t\t\t   true);\n-\telse\n-\t  drawPixelsScaledFlipped (g, 0, 0, 0, flipX, flipY,\n-\t\t\t\t   srcX, srcY, srcWidth, srcHeight,\n-\t\t\t\t   dstX,  dstY, dstWidth, dstHeight,\n-\t\t\t\t   false);\n-      }\n-    return true;\n-  }\n-\n-  /**\n-   * Draws an image to the GdkGraphics context, at (x,y) scaled to \n-   * width and height, with optional compositing with a background color.\n-   */\n-  public boolean drawImage (GdkGraphics g, int x, int y, int width, int height,\n-\t\t\t    Color bgcolor, ImageObserver observer)\n-  {\n-    if (addObserver(observer))\n-      return false;\n-\n-    if ( this.width <= 0 || this.height <= 0 )\n-      return true;\n-\n-    synchronized(GdkPixbufDecoder.pixbufLock)\n-      {\n-\tif(bgcolor != null)\n-\t  drawPixelsScaled(g, bgcolor.getRed (), bgcolor.getGreen (), \n-\t\t\t   bgcolor.getBlue (), x, y, width, height, true);\n-\telse\n-\t  drawPixelsScaled(g, 0, 0, 0, x, y, width, height, false);\n-      }\n-\n-    return true;\n-  }\n \n   // Private methods ////////////////////////////////////////////////\n "}, {"sha": "688af00e445df47e3e5e647e17fa6f23d3c591e2", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GtkToolkit.java", "status": "modified", "additions": 21, "deletions": 43, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkToolkit.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -78,31 +78,12 @@\n    this class.  If getPeer() ever goes away, we can implement a hash table\n    that will keep up with every window's peer, but for now this is faster. */\n \n-/**\n- * This class accesses a system property called\n- * <tt>gnu.java.awt.peer.gtk.Graphics</tt>.  If the property is defined and\n- * equal to \"Graphics2D\", the cairo-based GdkGraphics2D will be used in\n- * drawing contexts. Any other value will cause the older GdkGraphics\n- * object to be used.\n- */\n public class GtkToolkit extends gnu.java.awt.ClasspathToolkit\n {\n   Hashtable containers = new Hashtable();\n   static EventQueue q;\n-  static boolean useGraphics2dSet;\n-  static boolean useGraphics2d;\n   static Thread mainThread;\n \n-  public static boolean useGraphics2D()\n-  {\n-    if (useGraphics2dSet)\n-      return useGraphics2d;\n-    useGraphics2d = System.getProperty(\"gnu.java.awt.peer.gtk.Graphics\", \n-                                       \"Graphics\").equals(\"Graphics2D\");\n-    useGraphics2dSet = true;\n-    return useGraphics2d;\n-  }\n-\n   static native void gtkInit(int portableNativeSync);\n \n   static\n@@ -178,10 +159,7 @@ public Image createImage (String filename)\n     Image image;\n     try\n       {\n-\tif (useGraphics2D())\n-\t  image = GdkPixbufDecoder.createBufferedImage(filename);\n-\telse\n-\t  image = new GtkImage(filename);\n+\timage = CairoSurface.getBufferedImage( new GtkImage( filename ) );\n       }\n     catch (IllegalArgumentException iae)\n       {\n@@ -195,10 +173,7 @@ public Image createImage (URL url)\n     Image image;\n     try\n       {\n-\tif (useGraphics2D())\n-\t  image = GdkPixbufDecoder.createBufferedImage(url);\n-\telse\n-\t  image = new GtkImage(url);\n+\timage = CairoSurface.getBufferedImage( new GtkImage( url ) );\n       }\n     catch (IllegalArgumentException iae)\n       {\n@@ -209,13 +184,13 @@ public Image createImage (URL url)\n \n   public Image createImage (ImageProducer producer) \n   {\n+    if (producer == null)\n+      return null;\n+      \n     Image image;\n     try\n       {\n-\tif (useGraphics2D())\n-\t  image = GdkPixbufDecoder.createBufferedImage(producer);\n-\telse\n-\t  image = new GtkImage(producer);\n+\timage = CairoSurface.getBufferedImage( new GtkImage( producer ) );\n       }\n     catch (IllegalArgumentException iae)\n       {\n@@ -230,16 +205,9 @@ public Image createImage (byte[] imagedata, int imageoffset,\n     Image image;\n     try\n       {\n-\tif (useGraphics2D())\n-\t  image = GdkPixbufDecoder.createBufferedImage(imagedata,\n-\t\t\t\t\t\t       imageoffset, \n-\t\t\t\t\t\t       imagelength);\n-\telse\n-\t  {\n-\t    byte[] datacopy = new byte[imagelength];\n-\t    System.arraycopy(imagedata, imageoffset, datacopy, 0, imagelength);\n-\t    return new GtkImage(datacopy);\n-\t  }\n+\tbyte[] data = new byte[ imagelength ];\n+\tSystem.arraycopy(imagedata, imageoffset, data, 0, imagelength);\n+\timage = CairoSurface.getBufferedImage( new GtkImage( data ) );\n       }\n     catch (IllegalArgumentException iae)\n       {\n@@ -256,7 +224,7 @@ public Image createImage (byte[] imagedata, int imageoffset,\n    */  \n   public ImageProducer createImageProducer(URL url)\n   {\n-    return new GdkPixbufDecoder(url);  \n+    return createImage( url ).getSource();\n   }\n \n   /**\n@@ -568,13 +536,23 @@ public ClasspathTextLayoutPeer getClasspathTextLayoutPeer (AttributedString str,\n \n   protected EventQueue getSystemEventQueueImpl() \n   {\n-    synchronized (GtkToolkit.class)\n+    // GCJ LOCAL: workaround a GCJ problem accessing\n+    // GtkToolkit.class\n+    try\n+      {\n+    synchronized (Class.forName (\"gnu.java.awt.peer.gtk.GtkToolkit\"))\n       {\n         if (q == null)\n           {\n             q = new EventQueue();\n           }\n       }    \n+      }\n+    catch (Exception e)\n+      {\n+        e.printStackTrace();\n+      }\n+    \n     return q;\n   }\n "}, {"sha": "53bcd739d9e8d48adf35c094eb0ab1723dc1cbcf", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/GtkVolatileImage.java", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkVolatileImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkVolatileImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGtkVolatileImage.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,4 +1,4 @@\n-/* GtkVolatileImage.java -- a hardware-accelerated image buffer\n+/* GtkVolatileImage.java -- wraps an X pixmap\n    Copyright (C) 2005  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -38,6 +38,7 @@\n package gnu.java.awt.peer.gtk;\n \n import java.awt.ImageCapabilities;\n+import java.awt.Graphics;\n import java.awt.Graphics2D;\n import java.awt.GraphicsConfiguration;\n import java.awt.image.BufferedImage;\n@@ -46,44 +47,68 @@\n \n public class GtkVolatileImage extends VolatileImage\n {\n-  private int width;\n-  private int height;\n+  int width, height;\n   private ImageCapabilities caps;\n \n-  public GtkVolatileImage(int width, int height)\n-  {\n-    this(width, height, null);\n-  }\n+  /**\n+   * Don't touch, accessed from native code.\n+   */\n+  long nativePointer;\n \n-  public GtkVolatileImage(int width, int height, ImageCapabilities caps)\n+  native long init(GtkComponentPeer component, int width, int height);\n+\n+  native void destroy();\n+\n+  native int[] getPixels();\n+\n+  native void copyArea( int x, int y, int w, int h, int dx, int dy );\n+\n+  native void drawVolatile( long ptr, int x, int y, int w, int h );\n+  \n+  public GtkVolatileImage(GtkComponentPeer component, \n+\t\t\t  int width, int height, ImageCapabilities caps)\n   {\n     this.width = width;\n     this.height = height;\n     this.caps = caps;\n+    nativePointer = init( component, width, height );\n   }\n \n-  // FIXME: should return a buffered image snapshot of the accelerated\n-  // visual\n-  public BufferedImage getSnapshot()\n+  public GtkVolatileImage(int width, int height, ImageCapabilities caps)\n   {\n-    return null;\n+    this(null, width, height, caps);\n   }\n \n-  public int getWidth()\n+  public GtkVolatileImage(int width, int height)\n   {\n-    return width;\n+    this(null, width, height, null);\n   }\n \n-  public int getHeight()\n+  public void finalize()\n   {\n-    return height;\n+    dispose();\n+  }\n+\n+  public void dispose()\n+  {\n+    destroy();\n+  }\n+\n+  public BufferedImage getSnapshot()\n+  {\n+    CairoSurface cs = new CairoSurface( width, height );\n+    cs.setPixels( getPixels() );\n+    return CairoSurface.getBufferedImage( cs );\n+  }\n+\n+  public Graphics getGraphics()\n+  {\n+    return createGraphics();\n   }\n \n-  // FIXME: should return a graphics wrapper around this image's\n-  // visual\n   public Graphics2D createGraphics()\n   {\n-    return null;\n+    return new VolatileImageGraphics( this );\n   }\n \n   public int validate(GraphicsConfiguration gc)\n@@ -101,18 +126,28 @@ public ImageCapabilities getCapabilities()\n     return caps;\n   }\n \n-  public synchronized Object getProperty (String name, ImageObserver observer)\n+  public int getWidth()\n   {\n-    return null;\n+    return width;\n+  }\n+\n+  public int getHeight()\n+  {\n+    return height;\n   }\n \n-  public synchronized int getWidth (ImageObserver observer)\n+  public int getWidth(java.awt.image.ImageObserver observer)\n   {\n     return width;\n   }\n   \n-  public synchronized int getHeight (ImageObserver observer)\n+  public int getHeight(java.awt.image.ImageObserver observer)\n   {\n     return height;\n   }\n+\n+  public Object getProperty(String name, ImageObserver observer)\n+  {\n+    return null;\n+  }\n }"}, {"sha": "d5adfcf775793087d2b15ebdd77762d8cafbce67", "filename": "libjava/classpath/gnu/java/awt/peer/gtk/VolatileImageGraphics.java", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FVolatileImageGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FVolatileImageGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FVolatileImageGraphics.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,122 @@\n+/* VolatileImageGraphics.java\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferInt;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.ImageObserver;\n+import java.util.WeakHashMap;\n+\n+public class VolatileImageGraphics extends ComponentGraphics\n+{\n+  private GtkVolatileImage owner;\n+\n+  public VolatileImageGraphics(GtkVolatileImage img)\n+  {\n+    this.owner = img;\n+    cairo_t = initFromVolatile( owner.nativePointer, img.width, img.height );\n+    setup( cairo_t );\n+    setClip( new Rectangle( 0, 0, img.width, img.height) );\n+  }\n+\n+  private VolatileImageGraphics(VolatileImageGraphics copy)\n+  {\n+    this.owner = copy.owner;\n+    initFromVolatile( owner.nativePointer, owner.width, owner.height );\n+    setClip( new Rectangle( 0, 0, owner.width, owner.height) );\n+    copy( copy, cairo_t );\n+  }\n+\n+  public void copyAreaImpl(int x, int y, int width, int height, int dx, int dy)\n+  {\n+    owner.copyArea(x, y, width, height, dx, dy);\n+  }\n+\n+  public GraphicsConfiguration getDeviceConfiguration()\n+  {\n+    return null;\n+  }\n+\n+  public Graphics create()\n+  {\n+    return new VolatileImageGraphics( this );\n+  }\n+\n+\n+  public boolean drawImage(Image img, int x, int y, ImageObserver observer)\n+  {\n+    if( img instanceof GtkVolatileImage )\n+      {\n+\towner.drawVolatile( ((GtkVolatileImage)img).nativePointer, \n+\t\t\t    x, y,\n+\t\t\t    ((GtkVolatileImage)img).width, \n+\t\t\t    ((GtkVolatileImage)img).height );\n+\treturn true;\n+      }      \n+    return super.drawImage( img, x, y, observer );\n+  }\n+  \n+  public boolean drawImage(Image img, int x, int y, int width, int height,\n+                           ImageObserver observer)\n+  {\n+    if( img instanceof GtkVolatileImage )\n+      {\n+\towner.drawVolatile( ((GtkVolatileImage)img).nativePointer, \n+\t\t\t    x, y, width, height );\n+\treturn true;\n+      }      \n+    return super.drawImage( img, x, y, width, height, observer );\n+  }\n+}\n+"}, {"sha": "a51b758adf0aeb459a2a40e8121c472c044e9d1f", "filename": "libjava/classpath/gnu/java/awt/peer/swing/SwingComponent.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingComponent.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -62,7 +62,7 @@\n \n   /**\n    * Handles a mouse event. This is usually forwarded to\n-   * {@link Component#processMouseMotionEvent(MouseEvent)} of the swing\n+   * {@link java.awt.Component#processMouseMotionEvent(MouseEvent)} of the swing\n    * component.\n    *\n    * @param ev the mouse event\n@@ -71,7 +71,7 @@\n \n   /**\n    * Handles a mouse motion event. This is usually forwarded to\n-   * {@link Component#processMouseEvent(MouseEvent)} of the swing\n+   * {@link java.awt.Component#processMouseEvent(MouseEvent)} of the swing\n    * component.\n    *\n    * @param ev the mouse motion event\n@@ -80,7 +80,7 @@\n \n   /**\n    * Handles a key event. This is usually forwarded to\n-   * {@link Component#processKeyEvent(KeyEvent)} of the swing\n+   * {@link java.awt.Component#processKeyEvent(KeyEvent)} of the swing\n    * component.\n    *\n    * @param ev the key event"}, {"sha": "f60c8e96c1d13de0e70011c59fe72fe06c283a58", "filename": "libjava/classpath/gnu/java/awt/peer/swing/SwingComponentPeer.java", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingComponentPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingComponentPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingComponentPeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -48,6 +48,8 @@\n import java.awt.FontMetrics;\n import java.awt.Graphics;\n import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n import java.awt.Image;\n import java.awt.Point;\n import java.awt.Rectangle;\n@@ -98,8 +100,9 @@\n \n   /**\n    * Creates a SwingComponentPeer instance. Subclasses are expected to call\n-   * this constructor and thereafter call {@link #init(Component, JComponent)}\n-   * in order to setup the AWT and Swing components properly.\n+   * this constructor and thereafter call\n+   * {@link #init(Component, SwingComponent)} in order to setup the AWT and\n+   * Swing components properly.\n    */\n   protected SwingComponentPeer()\n   {\n@@ -164,9 +167,12 @@ public Image createImage(ImageProducer prod)\n    */\n   public Image createImage(int width, int height)\n   {\n-    Component parent = awtComponent.getParent();\n-    ComponentPeer parentPeer = parent.getPeer();\n-    return parentPeer.createImage(width, height);\n+    GraphicsEnvironment graphicsEnv =\n+      GraphicsEnvironment.getLocalGraphicsEnvironment();\n+    GraphicsDevice dev = graphicsEnv.getDefaultScreenDevice();\n+    GraphicsConfiguration conf = dev.getDefaultConfiguration();\n+    Image image = conf.createCompatibleImage(width, height);\n+    return image;\n   }\n \n   /**\n@@ -442,20 +448,6 @@ public Dimension preferredSize()\n     return retVal;\n   }\n \n-  /**\n-   * Prepares an image for rendering on this component. This is called by\n-   * {@link Component#prepareImage(Image, int, int, ImageObserver)}.\n-   *\n-   * @param img the image to prepare\n-   * @param width the desired width of the rendered image\n-   * @param height the desired height of the rendered image\n-   * @param ob the image observer to be notified of updates in the preparation\n-   *        process\n-   *\n-   * @return <code>true</code> if the image has been fully prepared,\n-   *         <code>false</code> otherwise (in which case the image observer\n-   *         receives updates)\n-   */\n   public void paint(Graphics graphics)\n   {\n     // FIXME: I don't know what this method is supposed to do.\n@@ -478,8 +470,17 @@ public void paint(Graphics graphics)\n   public boolean prepareImage(Image img, int width, int height, ImageObserver ob)\n   {\n     Component parent = awtComponent.getParent();\n-    ComponentPeer parentPeer = parent.getPeer();\n-    return parentPeer.prepareImage(img, width, height, ob);\n+    boolean res;\n+    if(parent != null)\n+      {\n+        ComponentPeer parentPeer = parent.getPeer();\n+        res = parentPeer.prepareImage(img, width, height, ob);\n+      }\n+    else\n+      {\n+        res = Toolkit.getDefaultToolkit().prepareImage(img, width, height, ob);\n+      }\n+    return res;\n   }\n \n   public void print(Graphics graphics)"}, {"sha": "f433e1b5c2d24412cf16d944c4d8284a3eb86944", "filename": "libjava/classpath/gnu/java/awt/peer/swing/SwingContainerPeer.java", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingContainerPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingContainerPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingContainerPeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -92,7 +92,12 @@ public Insets insets()\n    */\n   public Insets getInsets()\n   {\n-    return insets();\n+    Insets retVal;\n+    if (swingComponent != null)\n+      retVal = swingComponent.getJComponent().getInsets();\n+    else\n+      retVal = new Insets(0, 0, 0, 0);\n+    return retVal;\n   }\n \n   /**\n@@ -209,6 +214,8 @@ protected void peerPaint(Graphics g)\n   protected void handleMouseEvent(MouseEvent ev)\n   {\n     Component comp = awtComponent.getComponentAt(ev.getPoint());\n+    if(comp == null)\n+      comp = awtComponent;\n     if (comp != null)\n       {\n         ComponentPeer peer = comp.getPeer();"}, {"sha": "0d5a02d78f6738882208582a5571cff1349a32db", "filename": "libjava/classpath/gnu/java/awt/peer/swing/SwingFramePeer.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingFramePeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingFramePeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingFramePeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -53,9 +53,9 @@\n  * As a minimum, a subclass must implement all the remaining abstract methods\n  * as well as the following methods:\n  * <ul>\n- * <li>{@link ComponentPeer#getLocationOnScreen()}</li>\n- * <li>{@link ComponentPeer#getGraphics()}</li>\n- * <li>{@link ComponentPeer#createImage(int, int)}</li>\n+ * <li>{@link java.awt.peer.ComponentPeer#getLocationOnScreen()}</li>\n+ * <li>{@link java.awt.peer.ComponentPeer#getGraphics()}</li>\n+ * <li>{@link java.awt.peer.ComponentPeer#createImage(int, int)}</li>\n  * </ul>\n  *\n  * @author Roman Kennke (kennke@aicas.com)"}, {"sha": "0033efb025f7a096bcb5153929e9fd3f3b1a5070", "filename": "libjava/classpath/gnu/java/awt/peer/swing/SwingMenuBarPeer.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingMenuBarPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingMenuBarPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingMenuBarPeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -174,7 +174,7 @@ public void addMenu(Menu m)\n   /**\n    * Adds a help menu to the menu bar.\n    *\n-   * @param m the menu to add\n+   * @param menu the menu to add\n    */\n   public void addHelpMenu(Menu menu)\n   {"}, {"sha": "0c3b4e72603435c938ffe78170621eea9bb5edd0", "filename": "libjava/classpath/gnu/java/awt/peer/swing/SwingTextFieldPeer.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingTextFieldPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingTextFieldPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingTextFieldPeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -283,7 +283,7 @@ public void setText(String text)\n    * @param startPos the start index of the selection\n    * @param endPos the start index of the selection\n    */\n-  public void select(int start_pos, int endPos)\n+  public void select(int startPos, int endPos)\n   {\n     // TODO: Must be implemented.\n   }"}, {"sha": "43a509b957d27facf4fdf58b4df15c55dec3736c", "filename": "libjava/classpath/gnu/java/awt/peer/swing/SwingWindowPeer.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingWindowPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingWindowPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fswing%2FSwingWindowPeer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -48,9 +48,9 @@\n  * As a minimum, a subclass must implement all the remaining abstract methods\n  * as well as the following methods:\n  * <ul>\n- * <li>{@link ComponentPeer#getLocationOnScreen()}</li>\n- * <li>{@link ComponentPeer#getGraphics()}</li>\n- * <li>{@link ComponentPeer#createImage(int, int)}</li>\n+ * <li>{@link java.awt.peer.ComponentPeer#getLocationOnScreen()}</li>\n+ * <li>{@link java.awt.peer.ComponentPeer#getGraphics()}</li>\n+ * <li>{@link java.awt.peer.ComponentPeer#createImage(int, int)}</li>\n  * </ul>\n  *\n  * @author Roman Kennke (kennke@aicas.com)"}, {"sha": "9a3db0125838b927f2d0b2c15dd5495e13848936", "filename": "libjava/classpath/gnu/java/awt/print/JavaPrinterGraphics.java", "status": "added", "additions": 518, "deletions": 0, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FJavaPrinterGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FJavaPrinterGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FJavaPrinterGraphics.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,518 @@\n+/* JavaPrinterGraphics.java -- AWT printer rendering class.\n+   Copyright (C) 2006  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.awt.print;\n+\n+import gnu.java.awt.peer.gtk.CairoSurface;\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.PixelGrabber;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Pageable;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterGraphics;\n+import java.awt.print.PrinterJob;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.text.AttributedCharacterIterator;\n+\n+/**\n+ * Graphics context to draw to PostScript.\n+ *\n+ * @author Sven de Marothy\n+ */\n+public class JavaPrinterGraphics extends Graphics implements PrinterGraphics\n+{\n+\n+  /**\n+   * The used graphics context.\n+   */\n+  private Graphics g;\n+\n+  /**\n+   * The associated printer job.\n+   */\n+  private PrinterJob printerJob;\n+\n+  /**\n+   * Rendering resolution\n+   */\n+  private static final double DPI = 72.0;\n+\n+  /**\n+   * Rendered image size.\n+   */\n+  private int xSize, ySize;\n+\n+  /**\n+   * The image to render to.\n+   */\n+  private Image image;\n+\n+  public JavaPrinterGraphics( PrinterJob printerJob )\n+  {\n+    this.printerJob = printerJob;\n+  }\n+\n+  /**\n+   * Spool a document to PostScript.\n+   * If Pageable is non-null, it will print that, otherwise it will use\n+   * the supplied printable and pageFormat.\n+   */\n+  public SpooledDocument spoolPostScript(Printable printable, \n+\t\t\t\t\t PageFormat pageFormat,\n+\t\t\t\t\t Pageable pageable)\n+    throws PrinterException\n+  {\n+    try \n+      {\n+\t// spool to a temporary file\n+\tFile temp = File.createTempFile(\"cpspool\", \".ps\");\n+\ttemp.deleteOnExit();\n+\t\n+\tPrintWriter out = new PrintWriter\n+\t  (new BufferedWriter\n+\t    (new OutputStreamWriter\n+\t     (new FileOutputStream(temp), \"ISO8859_1\"), 1000000));\n+\n+\twritePSHeader(out);\n+\t\n+\tif(pageable != null)\n+\t  {\n+\t    for(int index = 0; index < pageable.getNumberOfPages(); index++)\n+\t      spoolPage(out, pageable.getPrintable(index),\n+\t\t\tpageable.getPageFormat(index), index);\n+\t  }\n+\telse\n+\t  {\n+\t    int index = 0;\n+\t    while(spoolPage(out, printable, pageFormat, index++) ==\n+\t\t  Printable.PAGE_EXISTS);\n+\t  }\n+\t out.println(\"%%Trailer\");\n+\t out.println(\"%%EOF\");\n+\t out.close();\n+\t return new SpooledDocument( temp );\n+       } \n+    catch (IOException e) \n+      {\n+\tPrinterException pe = new PrinterException();\n+\tpe.initCause(e);\n+\tthrow pe;\n+      }\n+  }\n+\n+  /**\n+   * Spools a single page, returns NO_SUCH_PAGE unsuccessful,\n+   * PAGE_EXISTS if it was.\n+   */\n+  public int spoolPage(PrintWriter out,\n+\t\t       Printable printable, \n+\t\t       PageFormat pageFormat, \n+\t\t       int index) throws IOException, PrinterException\n+  {\n+    initImage( pageFormat );\n+    if(printable.print(this, pageFormat, index) == Printable.NO_SUCH_PAGE)\n+      return Printable.NO_SUCH_PAGE;\n+    g.dispose();\n+    g = null;\n+    writePage( out, pageFormat );\n+    return Printable.PAGE_EXISTS;\n+  }\n+  \n+  private void initImage(PageFormat pageFormat)\n+  {\n+    // Create a really big image and draw to that.\n+    xSize = (int)(DPI*pageFormat.getWidth()/72.0);\n+    ySize = (int)(DPI*pageFormat.getHeight()/72.0);\n+    \n+    // Swap X and Y sizes if it's a Landscape page.\n+    if( pageFormat.getOrientation() != PageFormat.PORTRAIT )\n+      {\n+\tint t = xSize;\n+\txSize = ySize;\n+\tySize = t;\n+      }\n+\n+    // FIXME: This should at least be BufferedImage. \n+    // Fix once we have a working B.I.\n+    // Graphics2D should also be supported of course.\n+    image = CairoSurface.getBufferedImage(xSize, ySize);\n+\n+    g = image.getGraphics();\n+    setColor(Color.white);\n+    fillRect(0, 0, xSize, ySize);\n+    setColor(Color.black);\n+  }\n+\n+  private void writePSHeader(PrintWriter out)\n+  {\n+    out.println(\"%!PS-Adobe-3.0\");      \n+    out.println(\"%%Title: \"+printerJob.getJobName());\n+    out.println(\"%%Creator: GNU Classpath \");\n+    out.println(\"%%DocumentData: Clean8Bit\");\n+\n+    out.println(\"%%DocumentNeededResources: font Times-Roman Helvetica Courier\");\n+    //    out.println(\"%%Pages: \"+);  // FIXME # pages.\n+    out.println(\"%%EndComments\");\n+    \n+    out.println(\"%%BeginProlog\");\n+    out.println(\"%%EndProlog\");\n+    out.println(\"%%BeginSetup\");\n+    \n+    // FIXME: Paper name\n+    // E.g. \"A4\" \"Letter\"\n+    //    out.println(\"%%BeginFeature: *PageSize A4\");\n+    \n+    out.println(\"%%EndFeature\");\n+\n+    out.println(\"%%EndSetup\");\n+    \n+    //    out.println(\"%%Page: 1 1\");\n+  }\n+\n+  private void writePage(PrintWriter out, PageFormat pageFormat)\n+  {\n+    out.println(\"%%BeginPageSetup\");\n+\n+    Paper p = pageFormat.getPaper();\n+    double pWidth = p.getWidth();\n+    double pHeight = p.getHeight();\n+\n+    if( pageFormat.getOrientation() == PageFormat.PORTRAIT )\n+      out.println( \"%%Orientation: Portrait\" );\n+    else\n+      {\n+\tout.println( \"%%Orientation: Landscape\" );\n+\tdouble t = pWidth;\n+\tpWidth = pHeight;\n+\tpHeight = t;\n+      }\n+      \n+    out.println(\"gsave % first save\");\n+    \n+    // 595x842; 612x792 respectively\n+    out.println(\"<< /PageSize [\" +pWidth + \" \"+pHeight+ \"] >> setpagedevice\");\n+\n+    // invert the Y axis so that we get screen-like coordinates instead.\n+    AffineTransform pageTransform = new AffineTransform();\n+    if( pageFormat.getOrientation() == PageFormat.REVERSE_LANDSCAPE )\n+      {\n+\tpageTransform.translate(pWidth, pHeight);\n+\tpageTransform.scale(-1.0, -1.0);\n+      }\n+    concatCTM(out, pageTransform);\n+    out.println(\"%%EndPageSetup\");\n+\n+    out.println(\"gsave\");\n+\n+\n+    // Draw the image\n+    out.println(xSize+\" \"+ySize+\" 8 [1 0 0 -1 0 \"+ySize+\" ]\"); \n+    out.println(\"{currentfile 3 string readhexstring pop} bind\");\n+    out.println(\"false 3 colorimage\");\n+    int[] pixels = new int[xSize * ySize];\n+    PixelGrabber pg = new PixelGrabber(image, 0, 0, xSize, ySize, pixels, 0, xSize);\n+\n+    try {\n+      pg.grabPixels();\n+    } catch (InterruptedException e) {\n+      out.println(\"% Bug getting pixels!\");\n+    }\n+\n+    int n = 0;\n+    for (int j = 0; j < ySize; j++) {\n+      for (int i = 0; i < xSize; i++) {\n+\tout.print( colorTripleHex(pixels[j * xSize + i]) );\n+\tif(((++n)%11) == 0) out.println();\n+      }\n+    }\n+    \n+    out.println();\n+    out.println(\"%%EOF\");\n+    out.println(\"grestore\");\n+    out.println(\"showpage\");\n+  }\n+  \n+  /**\n+   * Get a nonsperated hex RGB triple, e.g. FFFFFF = white \n+   */\n+  private String colorTripleHex(int num){\n+    String s = \"\";\n+\n+    try {\n+      s = Integer.toHexString( ( num & 0x00FFFFFF ) );\n+      if( s.length() < 6 )\n+\t{\n+\t  s = \"000000\"+s;\n+\t  return s.substring(s.length()-6);\n+\t}\n+    } catch (Exception e){\n+      s = \"FFFFFF\";\n+    }\n+\n+    return s;\n+  }\n+\n+  private void concatCTM(PrintWriter out, AffineTransform Tx){\n+    double[] matrixElements = new double[6];\n+    Tx.getMatrix(matrixElements);\n+    \n+    out.print(\"[ \");\n+    for(int i=0;i<6;i++)\n+      out.print(matrixElements[i]+\" \");\n+    out.println(\"] concat\");\n+  }\n+\n+  //-----------------------------------------------------------------------------\n+  /**\n+   * PrinterGraphics method - Returns the printer job associated with this object.\n+   */\n+  public PrinterJob getPrinterJob()\n+  {\n+    return printerJob;\n+  }\n+\n+  /**\n+   * The rest of the methods here are just pass-throughs to g.\n+   */\n+  public void clearRect(int x, int y, int width, int height)\n+  {\n+    g.clearRect(x, y, width, height);\n+  }\n+\n+  public void clipRect(int x, int y, int width, int height)\n+  {\n+    g.clipRect(x, y, width, height);\n+  }\n+\n+  public void copyArea(int x, int y, int width, int height, int dx, int dy)\n+  {\n+    g.copyArea(x, y, width, height, dx, dy);\n+  }\n+\n+  public Graphics create()\n+  {\n+    return g.create();\n+  }\n+\n+  public void dispose()\n+  {\n+  }\n+\n+  public void drawArc(int x, int y, int width, int height, int startAngle, \n+\t\t      int arcAngle)\n+  {\n+    g.drawArc(x, y, width, height, startAngle, arcAngle);\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y, Color bgcolor, \n+\t\t\t   ImageObserver observer)\n+  {\n+    return g.drawImage(img, x, y, bgcolor, observer);\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y, ImageObserver observer)\n+  {\n+    return g.drawImage(img, x, y, observer);\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y, int width, int height, \n+\t\t\t   Color bgcolor, ImageObserver observer)\n+  {\n+    return g.drawImage(img, x, y, width, height, bgcolor, observer);\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y, int width, int height, \n+\t\t\t   ImageObserver observer)\n+  {\n+    return g.drawImage(img, x, y, width, height, observer);\n+  }\n+\n+  public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, \n+\t\t\t   int sx1, int sy1, int sx2, int sy2, Color bgcolor, \n+\t\t\t   ImageObserver observer)\n+  {\n+    return g.drawImage(img, dx1,  dy1,  dx2,  dy2,  \n+\t\t     sx1,  sy1,  sx2,  sy2, bgcolor, observer);\n+  }\n+\n+  public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, \n+\t\t\t   int sx1, int sy1, int sx2, int sy2, ImageObserver observer)\n+  {\n+    return g.drawImage(img, dx1,  dy1,  dx2,  dy2,  \n+\t\t     sx1,  sy1,  sx2,  sy2, observer);\n+  }\n+\n+  public void drawLine(int x1, int y1, int x2, int y2)\n+  {\n+    g.drawLine(x1, y1, x2, y2);\n+  }\n+\n+  public void drawOval(int x, int y, int width, int height)\n+  {\n+    g.drawOval(x, y, width, height);\n+  }\n+\n+  public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    g.drawPolygon(xPoints, yPoints, nPoints);\n+  }\n+\n+  public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    g.drawPolyline(xPoints, yPoints, nPoints);\n+  }\n+\n+  public void drawRoundRect(int x, int y, int width, int height, \n+\t\t\t    int arcWidth, int arcHeight)\n+  {\n+    g.drawRoundRect(x, y, width, height, arcWidth, arcHeight);\n+  }\n+\n+  public void drawString(AttributedCharacterIterator iterator, int x, int y)\n+  {\n+    g.drawString(iterator, x, y);\n+  }\n+\n+  public void drawString(String str, int x, int y)\n+  {\n+    g.drawString(str, x, y);\n+  }\n+\n+  public void fillArc(int x, int y, int width, int height, \n+\t\t      int startAngle, int arcAngle)\n+  {\n+    g.fillArc(x, y, width, height, startAngle, arcAngle);\n+  }\n+\n+  public void fillOval(int x, int y, int width, int height)\n+  {\n+    g.fillOval(x, y, width, height);\n+  }\n+\n+  public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    g.fillPolygon(xPoints, yPoints, nPoints);\n+  }\n+\n+  public void fillRect(int x, int y, int width, int height)\n+  {\n+    g.fillRect(x, y, width, height);\n+  }\n+\n+  public void fillRoundRect(int x, int y, int width, int height, \n+\t\t\t    int arcWidth, int arcHeight)\n+  {\n+    g.fillRoundRect(x, y, width, height, arcWidth, arcHeight);\n+  }\n+\n+  public Shape getClip()\n+  {\n+    return g.getClip();\n+  }\n+\n+  public Rectangle getClipBounds()\n+  {\n+    return g.getClipBounds();\n+  }\n+\n+  public Color getColor()\n+  {\n+    return g.getColor();\n+  }\n+\n+  public Font getFont()\n+  {\n+    return g.getFont();\n+  }\n+\n+  public FontMetrics getFontMetrics(Font f)\n+  {\n+    return g.getFontMetrics(f);\n+  }\n+\n+  public void setClip(int x, int y, int width, int height)\n+  {\n+    g.setClip(x, y, width, height);\n+  }\n+\n+  public void setClip(Shape clip)\n+  {\n+    g.setClip(clip);\n+  }\n+\n+  public void setColor(Color c)\n+  {\n+    g.setColor(c);\n+  }\n+\n+  public void setFont(Font font)\n+  {\n+    g.setFont(font);\n+  }\n+\n+  public void setPaintMode()\n+  {\n+    g.setPaintMode();\n+  }\n+\n+  public void setXORMode(Color c1)\n+  {\n+    g.setXORMode(c1);\n+  }\n+\n+  public void translate(int x, int y)\n+  {\n+    g.translate(x, y);\n+  }\n+}\n+"}, {"sha": "adeeba04a1daa92878e9527fc60e7aa95fd7f016", "filename": "libjava/classpath/gnu/java/awt/print/JavaPrinterJob.java", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FJavaPrinterJob.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FJavaPrinterJob.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FJavaPrinterJob.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,403 @@\n+/* JavaPrinterJob.java -- AWT printing implemented on javax.print.\n+   Copyright (C) 2006  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.print;\n+\n+import java.awt.HeadlessException;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Pageable;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.Locale;\n+\n+import javax.print.CancelablePrintJob;\n+import javax.print.DocFlavor;\n+import javax.print.DocPrintJob;\n+import javax.print.PrintException;\n+import javax.print.PrintService;\n+import javax.print.PrintServiceLookup;\n+import javax.print.ServiceUI;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.IntegerSyntax;\n+import javax.print.attribute.PrintRequestAttributeSet;\n+import javax.print.attribute.TextSyntax;\n+import javax.print.attribute.standard.Copies;\n+import javax.print.attribute.standard.JobName;\n+import javax.print.attribute.standard.OrientationRequested;\n+import javax.print.attribute.standard.RequestingUserName;\n+\n+/**\n+ * This is the default implementation of PrinterJob\n+ *\n+ * @author Sven de Marothy\n+ */\n+public class JavaPrinterJob extends PrinterJob\n+{\n+  /**\n+   * The print service associated with this job\n+   */\n+  private PrintService printer = null;\n+\n+  /**\n+   * Printing options;\n+   */\n+  private PrintRequestAttributeSet attributes;\n+\n+  /**\n+   * Available print services\n+   */\n+  private static PrintService[] services;\n+\n+  /**\n+   * The actual print job.\n+   */\n+  private DocPrintJob printJob;\n+\n+  /**\n+   * The Printable object to print.\n+   */\n+  private Printable printable;\n+\n+  /**\n+   * Page format.\n+   */\n+  private PageFormat pageFormat;\n+\n+  /**\n+   * A pageable, or null\n+   */\n+  private Pageable pageable = null;\n+\n+  /**\n+   * Cancelled or not\n+   */\n+  private boolean cancelled = false;\n+\n+  static\n+  {\n+    // lookup all services without any constraints\n+    services = PrintServiceLookup.lookupPrintServices\n+      (DocFlavor.INPUT_STREAM.POSTSCRIPT, null);   \n+  }\n+\n+  private static final Class copyClass = (new Copies(1)).getClass();\n+  private static final Class jobNameClass = (new JobName(\"\", null)).getClass();\n+  private static final Class userNameClass = (new RequestingUserName(\"\", null)).getClass();\n+  \n+  /**\n+   * Initializes a new instance of <code>PrinterJob</code>. \n+   */\n+  public JavaPrinterJob()\n+  {\n+    attributes = new HashPrintRequestAttributeSet();\n+    setCopies(1);\n+    setJobName(\"Java Printing\");\n+    pageFormat = new PageFormat(); // default page format.\n+  }\n+\n+  private void getPageAttributes()\n+  {\n+    OrientationRequested orientation = (OrientationRequested)\n+      attributes.get( OrientationRequested.LANDSCAPE.getCategory() );\n+    if( orientation == null)\n+      return;\n+\n+    if( orientation.equals(OrientationRequested.PORTRAIT) )\n+      pageFormat.setOrientation(PageFormat.PORTRAIT);\n+    else if( orientation.equals(OrientationRequested.LANDSCAPE) )\n+      pageFormat.setOrientation(PageFormat.LANDSCAPE);\n+    else if( orientation.equals(OrientationRequested.REVERSE_LANDSCAPE) )\n+\tpageFormat.setOrientation(PageFormat.REVERSE_LANDSCAPE);\n+  }\n+\n+  /**\n+   * Returns the number of copies to be printed.\n+   *\n+   * @return The number of copies to be printed.\n+   */\n+  public int getCopies()\n+  {\n+    return ((IntegerSyntax)attributes.get( jobNameClass )).getValue();\n+  }\n+\n+  /**\n+   * Sets the number of copies to be printed.\n+   *\n+   * @param copies The number of copies to be printed.\n+   */\n+  public void setCopies(int copies)\n+  {\n+    attributes.add( new Copies( copies ) );\n+  }\n+\n+  /**\n+   * Returns the name of the print job.\n+   *\n+   * @return The name of the print job.\n+   */\n+  public String getJobName()\n+  {\n+    return ((TextSyntax)attributes.get( jobNameClass )).getValue();\n+  }\n+\n+  /**\n+   * Sets the name of the print job.\n+   *\n+   * @param job_name The name of the print job.\n+   */\n+  public void setJobName(String job_name)\n+  {\n+    attributes.add( new JobName(job_name, Locale.getDefault()) );\n+  }\n+\n+  /**\n+   * Returns the printing user name.\n+   *\n+   * @return The printing username.\n+   */\n+  public String getUserName()\n+  {\n+    return ((TextSyntax)attributes.get( userNameClass )).getValue();\n+  }\n+\n+  /**\n+   * Cancels an in progress print job.\n+   */\n+  public void cancel()\n+  {\n+    try\n+      {\n+\tif(printJob != null && (printJob instanceof CancelablePrintJob))\n+\t  {\n+\t    ((CancelablePrintJob)printJob).cancel();\n+\t    cancelled = true;\n+\t  }\n+      }\n+    catch(PrintException pe)\n+      {\n+      }\n+  }\n+\n+  /**\n+   * Tests whether or not this job has been cancelled.\n+   *\n+   * @return <code>true</code> if this job has been cancelled, <code>false</code>\n+   * otherwise.\n+   */\n+  public boolean isCancelled()\n+  {\n+    return cancelled;\n+  }\n+\n+  /**\n+   * Clones the specified <code>PageFormat</code> object then alters the\n+   * clone so that it represents the default page format.\n+   *\n+   * @param page_format The <code>PageFormat</code> to clone.\n+   *\n+   * @return A new default page format.\n+   */\n+  public PageFormat defaultPage(PageFormat page_format)\n+  {\n+    return new PageFormat();\n+  }\n+\n+  /**\n+   * Displays a dialog box to the user which allows the page format\n+   * attributes to be modified.\n+   *\n+   * @param page_format The <code>PageFormat</code> object to modify.\n+   *\n+   * @return The modified <code>PageFormat</code>.\n+   */\n+  public PageFormat pageDialog(PageFormat page_format)\n+    throws HeadlessException\n+  {\n+    return defaultPage(null);\n+  }\n+\n+  /**\n+   * Prints the pages.\n+   */\n+  public void print() throws PrinterException\n+  {\n+    if( printable == null && pageable == null ) // nothing to print?\n+      return;\n+\n+    PostScriptGraphics2D pg = new PostScriptGraphics2D( this );\n+    SpooledDocument doc = pg.spoolPostScript( printable, pageFormat, \n+\t\t\t\t\t      pageable );\n+\n+    cancelled = false;\n+    printJob = printer.createPrintJob();\n+    try\n+      {\n+\tprintJob.print(doc, attributes);\n+      }\n+    catch (PrintException pe) \n+      {\n+\tPrinterException p = new PrinterException();\n+\tp.initCause(pe);\n+\tthrow p;\n+      }\n+    // no printjob active.\n+    printJob = null;\n+  }\n+\n+  /**\n+   * Prints the page with given attributes.\n+   */\n+  public void print (PrintRequestAttributeSet attributes)\n+    throws PrinterException\n+  {\n+    this.attributes = attributes;\n+    print();\n+  }\n+\n+  /**\n+   * Displays a dialog box to the user which allows the print job\n+   * attributes to be modified.\n+   *\n+   * @return <code>false</code> if the user cancels the dialog box,\n+   * <code>true</code> otherwise.\n+   */\n+  public boolean printDialog() throws HeadlessException\n+  {\n+    return printDialog( attributes );\n+  }\n+\n+  /**\n+   * Displays a dialog box to the user which allows the print job\n+   * attributes to be modified.\n+   *\n+   * @return <code>false</code> if the user cancels the dialog box,\n+   * <code>true</code> otherwise.\n+   */\n+  public boolean printDialog(PrintRequestAttributeSet attributes)\n+    throws HeadlessException\n+  {\n+    PrintService chosenPrinter = ServiceUI.printDialog\n+      (null, 50, 50, services, null, \n+       DocFlavor.INPUT_STREAM.POSTSCRIPT, attributes);\n+\n+    getPageAttributes();\n+\n+    if( chosenPrinter != null )\n+      {\n+\ttry\n+\t  {\n+\t    setPrintService( chosenPrinter );\n+\t  }\n+\tcatch(PrinterException pe)\n+\t  {\n+\t    // Should not happen.\n+\t  }\n+\treturn true;\n+      }\n+    return false;\n+  }\n+\n+  /**\n+   * This sets the pages that are to be printed.\n+   *\n+   * @param pageable The pages to be printed, which may not be <code>null</code>.\n+   */\n+  public void setPageable(Pageable pageable)\n+  {\n+    if( pageable == null )\n+      throw new NullPointerException(\"Pageable cannot be null.\");\n+    this.pageable = pageable;\n+  }\n+\n+  /**\n+   * Sets this specified <code>Printable</code> as the one to use for\n+   * rendering the pages on the print device.\n+   *\n+   * @param printable The <code>Printable</code> for the print job.\n+   */\n+  public void setPrintable(Printable printable)\n+  {\n+    this.printable = printable;\n+  }\n+\n+  /**\n+   * Sets the <code>Printable</code> and the page format for the pages\n+   * to be printed.\n+   *\n+   * @param printable The <code>Printable</code> for the print job.\n+   * @param page_format The <code>PageFormat</code> for the print job.\n+   */\n+  public void setPrintable(Printable printable, PageFormat page_format)\n+  {\n+    this.printable = printable;\n+    this.pageFormat = page_format;\n+  }\n+\n+  /**\n+   * Makes any alterations to the specified <code>PageFormat</code>\n+   * necessary to make it work with the current printer.  The alterations\n+   * are made to a clone of the input object, which is then returned.\n+   *\n+   * @param page_format The <code>PageFormat</code> to validate.\n+   *\n+   * @return The validated <code>PageFormat</code>.\n+   */\n+  public PageFormat validatePage(PageFormat page_format)\n+  {\n+    // FIXME\n+    return page_format;\n+  }\n+\n+  /**\n+   * Change the printer for this print job to service.  Subclasses that\n+   * support setting the print service override this method.  Throws\n+   * PrinterException when the class doesn't support setting the printer,\n+   * the service doesn't support Pageable or Printable interfaces for 2D\n+   * print output.\n+   * @param service The new printer to use.\n+   * @throws PrinterException if service is not valid.\n+   */\n+  public void setPrintService(PrintService service)\n+    throws PrinterException\n+  {\n+    if(!service.isDocFlavorSupported(DocFlavor.INPUT_STREAM.POSTSCRIPT))\n+      throw new PrinterException(\"This printer service is not supported.\");\n+    printer = service;\n+  }\n+}"}, {"sha": "2303f44b7def705d9dd46042ad858e33e7bfcab3", "filename": "libjava/classpath/gnu/java/awt/print/PostScriptGraphics2D.java", "status": "added", "additions": 1349, "deletions": 0, "changes": 1349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FPostScriptGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FPostScriptGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FPostScriptGraphics2D.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,1349 @@\n+/* PostScriptGraphics2D.java -- AWT printer rendering class.\n+   Copyright (C) 2006  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.awt.print;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Composite;\n+import java.awt.Paint;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Polygon;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Shape;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Arc2D;\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.RoundRectangle2D;\n+import java.awt.geom.PathIterator;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.font.TextLayout;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.renderable.RenderableImage;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.PixelGrabber;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Pageable;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterGraphics;\n+import java.awt.print.PrinterJob;\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.text.AttributedCharacterIterator;\n+import java.util.Map;\n+\n+/**\n+ * Class PostScriptGraphics2D - Class that implements the Graphics2D object,\n+ * writing the output to a PostScript or EPS file\n+ *\n+ * @author Sven de Marothy\n+ *\n+ */\n+class PostScriptGraphics2D extends Graphics2D\n+{\n+  /**\n+   * The associated printer job.\n+   */\n+  private PrinterJob printerJob;\n+\n+  /**\n+   * Output file.\n+   */\n+  private PrintWriter out;\n+\n+  // Graphics data\n+  private AffineTransform currentTransform = new AffineTransform();\n+  private AffineTransform pageTransform;\n+  private RenderingHints renderingHints;\n+  private Paint currentPaint = null;\n+  private Shape clipShape = null;\n+  private Font currentFont = null;\n+  private Color currentColor = Color.black;\n+  private Color backgroundColor = Color.white;\n+  private Stroke currentStroke = null;\n+  private static Stroke ordinaryStroke = new BasicStroke(0.0f,\n+                                                         BasicStroke.CAP_BUTT,\n+                                                         BasicStroke.JOIN_MITER);\n+  private float cx; // current drawing position\n+  private float cy; // current drawing position\n+  private boolean currentFontIsPS; // set if currentFont is one of the above\n+\n+  // settings\n+  private double pageX = 595;\n+  private double pageY = 842;\n+  private double Y = pageY;\n+  private boolean gradientOn = false;\n+\n+  /** \n+   * Constructor\n+   *\n+   */\n+  public PostScriptGraphics2D( PrinterJob pg )\n+  {\n+    printerJob = pg;\n+    // create transform objects\n+    pageTransform = new AffineTransform();\n+    currentTransform = new AffineTransform();\n+\n+    /*\n+      Create Rendering hints\n+      No text aliasing\n+      Quality color and rendering\n+      Bicubic interpolation\n+      Fractional metrics supported\n+    */\n+    renderingHints = new RenderingHints(null);\n+    renderingHints.put(RenderingHints.KEY_RENDERING,\n+                       RenderingHints.VALUE_RENDER_QUALITY);\n+    renderingHints.put(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                       RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\n+    renderingHints.put(RenderingHints.KEY_INTERPOLATION,\n+                       RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n+    renderingHints.put(RenderingHints.KEY_FRACTIONALMETRICS,\n+                       RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n+    renderingHints.put(RenderingHints.KEY_COLOR_RENDERING,\n+                       RenderingHints.VALUE_COLOR_RENDER_QUALITY);\n+  }\n+\n+  /**\n+   * Spool a document to PostScript.\n+   * If Pageable is non-null, it will print that, otherwise it will use\n+   * the supplied printable and pageFormat.\n+   */\n+  public SpooledDocument spoolPostScript(Printable printable, \n+\t\t\t\t\t PageFormat pageFormat,\n+\t\t\t\t\t Pageable pageable)\n+    throws PrinterException\n+  {\n+    try \n+      {\n+\t// spool to a temporary file\n+\tFile temp = File.createTempFile(\"cpspool\", \".ps\");\n+\ttemp.deleteOnExit();\n+\t\n+\tout = new PrintWriter(new BufferedWriter\n+\t\t\t      (new OutputStreamWriter\n+\t\t\t       (new FileOutputStream(temp), \n+\t\t\t\t\"ISO8859_1\"), 1000000));\n+\t\n+\twritePSHeader();\n+\t\n+\tif(pageable != null)\n+\t  {\n+\t    for(int index = 0; index < pageable.getNumberOfPages(); index++)\n+\t      spoolPage(out, pageable.getPrintable(index),\n+\t\t\tpageable.getPageFormat(index), index);\n+\t  }\n+\telse\n+\t  {\n+\t    int index = 0;\n+\t    while(spoolPage(out, printable, pageFormat, index++) ==\n+\t\t  Printable.PAGE_EXISTS);\n+\t  }\n+\tout.println(\"%%Trailer\");\n+\tout.println(\"%%EOF\");\n+\tout.close();\n+\treturn new SpooledDocument( temp );\n+      } \n+    catch (IOException e) \n+      {\n+\tPrinterException pe = new PrinterException();\n+\tpe.initCause(e);\n+\tthrow pe;\n+      }\n+  }\n+\n+  //--------------------------------------------------------------------------\n+\n+  /** \n+   * Write the postscript file header,\n+   * setup the page format and transforms. \n+   */\n+  private void writePSHeader()\n+  {\n+    out.println(\"%!PS-Adobe-3.0\");      \n+    out.println(\"%%Title: \"+printerJob.getJobName());\n+    out.println(\"%%Creator: GNU Classpath \");\n+    out.println(\"%%DocumentData: Clean8Bit\");\n+\n+    out.println(\"%%DocumentNeededResources: font Times-Roman Helvetica Courier\");\n+    out.println(\"%%EndComments\");\n+    \n+    out.println(\"%%BeginProlog\");\n+    out.println(\"%%EndProlog\");\n+    out.println(\"%%BeginSetup\");\n+    \n+    out.println(\"%%EndFeature\");\n+    setupFonts();\n+    out.println(\"%%EndSetup\");\n+ \n+    // set default fonts and colors\n+    setFont( new Font(\"Dialog\", Font.PLAIN, 12) );\n+    currentColor = Color.white;\n+    currentStroke = new BasicStroke();\n+    setPaint(currentColor);\n+    setStroke(currentStroke);\n+  }\n+\n+  /**\n+   * setupFonts - set up the font dictionaries for\n+   * helvetica, times and courier\n+   */\n+  private void setupFonts()\n+  {\n+    out.println(\"/helveticaISO\");\n+    out.println(\"/Helvetica findfont dup length dict begin\");\n+    out.println(\"{ 1 index /FID eq { pop pop } { def } ifelse } forall\");\n+    out.println(\"/Encoding ISOLatin1Encoding def\");\n+    out.println(\"currentdict end definefont pop\");\n+\n+    out.println(\"/timesISO\");\n+    out.println(\"/Times-Roman findfont dup length dict begin\");\n+    out.println(\"{ 1 index /FID eq { pop pop } { def } ifelse } forall\");\n+    out.println(\"/Encoding ISOLatin1Encoding def\");\n+    out.println(\"currentdict end definefont pop\");\n+\n+    out.println(\"/courierISO\");\n+    out.println(\"/Courier findfont dup length dict begin\");\n+    out.println(\"{ 1 index /FID eq { pop pop } { def } ifelse } forall\");\n+    out.println(\"/Encoding ISOLatin1Encoding def\");\n+    out.println(\"currentdict end definefont pop\");\n+  }\n+\n+  /**\n+   * Spools a single page, returns NO_SUCH_PAGE unsuccessful,\n+   * PAGE_EXISTS if it was.\n+   */\n+  public int spoolPage(PrintWriter out,\n+\t\t       Printable printable, \n+\t\t       PageFormat pageFormat, \n+\t\t       int index) throws IOException, PrinterException\n+  {\n+    out.println(\"%%BeginPageSetup\");\n+\n+    Paper p = pageFormat.getPaper();\n+    pageX = p.getWidth();\n+    pageY = p.getHeight();\n+\n+    if( pageFormat.getOrientation() == PageFormat.PORTRAIT )\n+      out.println( \"%%Orientation: Portrait\" );\n+    else\n+      {\n+\tout.println( \"%%Orientation: Landscape\" );\n+\tdouble t = pageX;\n+\tpageX = pageY;\n+\tpageY = t;\n+      }\n+      \n+    setClip(0, 0, (int)pageX, (int)pageY);\n+\n+    out.println(\"gsave % first save\");\n+    \n+    // 595x842; 612x792 respectively\n+    out.println(\"<< /PageSize [\" +pageX + \" \"+pageY+ \"] >> setpagedevice\");\n+\n+    if( pageFormat.getOrientation() != PageFormat.LANDSCAPE )\n+      {\n+\tpageTransform.translate(pageX, 0);\n+\tpageTransform.scale(-1.0, 1.0);\n+      }\n+\n+    // save the original CTM\n+    pushCTM();\n+    concatCTM(pageTransform);\n+    setTransform(new AffineTransform());\n+\n+    out.println(\"%%EndPageSetup\");\n+\n+    out.println(\"gsave\");\n+\n+    if( printable.print(this, pageFormat, index) == Printable.NO_SUCH_PAGE )\n+      return Printable.NO_SUCH_PAGE;\n+    \n+    out.println(\"grestore\");\n+    out.println(\"showpage\");\n+\n+    return Printable.PAGE_EXISTS;\n+  }\n+\n+  /** push the Current Transformation Matrix onto the PS stack */\n+  private void pushCTM()\n+  {\n+    out.println(\"matrix currentmatrix   % pushCTM()\");\n+  }\n+\n+  /** pop the Current Transformation Matrix from the PS stack */\n+  private void popCTM()\n+  {\n+    out.println(\"setmatrix % restore CTM\");\n+  }\n+\n+  ///////////////////////////////////////////////////////////////////////////\n+\n+  public Graphics create()\n+  {\n+    return null;\n+  }\n+\n+  public void drawOval(int x, int y, int width, int height)\n+  {\n+    out.println(\"% drawOval()\");\n+    setStroke(ordinaryStroke);\n+    draw(new Ellipse2D.Double(x, y, width, height));\n+    setStroke(currentStroke);\n+  }\n+\n+  public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    if (nPoints <= 0 || xPoints.length < nPoints || yPoints.length < nPoints)\n+      return;\n+    out.println(\"newpath % drawPolyLine()\");\n+    out.println(xPoints[0] + \" \" + yPoints[0] + \" moveto\");\n+    for (int i = 1; i < nPoints; i++)\n+      out.println(xPoints[i] + \" \" + yPoints[i] + \" lineto\");\n+    out.println(\"closepath\");\n+    out.println(\"stroke\");\n+  }\n+\n+  public void drawRoundRect(int x, int y, int width, int height, int arcWidth,\n+                            int arcHeight)\n+  {\n+    out.println(\"% drawRoundRect()\");\n+    RoundRectangle2D.Double rr = new RoundRectangle2D.Double(x, y, width,\n+                                                             height, arcWidth,\n+                                                             arcHeight);\n+    setStroke(ordinaryStroke);\n+    draw(rr);\n+    setStroke(currentStroke);\n+  }\n+\n+  public void fillRoundRect(int x, int y, int width, int height, int arcWidth,\n+                            int arcHeight)\n+  {\n+    out.println(\"% fillRoundRect()\");\n+    RoundRectangle2D.Double rr = new RoundRectangle2D.Double(x, y, width,\n+                                                             height, arcWidth,\n+                                                             arcHeight);\n+    fill(rr);\n+  }\n+\n+  public void drawArc(int x, int y, int width, int height, int startAngle,\n+                      int arcAngle)\n+  {\n+    setStroke(ordinaryStroke);\n+    draw(new Arc2D.Double(x, y, width, height, startAngle, arcAngle, Arc2D.OPEN));\n+    setStroke(currentStroke);\n+  }\n+\n+  public void fillArc(int x, int y, int width, int height, int startAngle,\n+                      int arcAngle)\n+  {\n+    fill(new Arc2D.Double(x, y, width, height, startAngle, arcAngle, Arc2D.PIE));\n+  }\n+\n+  public void fillOval(int x, int y, int width, int height)\n+  {\n+    out.println(\"% fillOval()\");\n+    fill( new Ellipse2D.Double(x, y, width, height) );\n+  }\n+\n+  public void fillPolygon(int[] x, int[] y, int nPoints)\n+  {\n+    out.println(\"% fillPolygon()\");\n+    fill( new Polygon(x, y, nPoints) );\n+  }\n+\n+  public void drawLine(int x1, int y1, int x2, int y2)\n+  {\n+    out.println(\"% drawLine()\");\n+    setStroke(ordinaryStroke);\n+    out.println(\"newpath\");\n+    out.println(x1 + \" \" + (y1) + \" moveto\");\n+    out.println(x2 + \" \" + (y2) + \" lineto\");\n+    out.println(\"stroke\");\n+    setStroke(currentStroke);\n+  }\n+\n+  //--------------- Image drawing ------------------------------------------   \n+  public boolean drawImage(Image img, int x, int y, Color bgcolor,\n+                           ImageObserver observer)\n+  {\n+    int w = img.getWidth(null);\n+    int h = img.getHeight(null);\n+\n+    return drawImage(img, x, y, x + w, y + h, 0, 0, w - 1, h - 1, bgcolor,\n+\t\t     observer);\n+  }\n+\n+  public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,\n+                           int sx1, int sy1, int sx2, int sy2, Color bgcolor,\n+                           ImageObserver observer)\n+  {\n+    int n = 0;\n+    boolean flipx = false;\n+    boolean flipy = false;\n+\n+    // swap X and Y's\n+    if (sx1 > sx2)\n+      {\n+\tn = sx1;\n+\tsx1 = sx2;\n+\tsx2 = n;\n+\tflipx = ! flipx;\n+      }\n+    if (sy1 > sy2)\n+      {\n+\tn = sy1;\n+\tsy1 = sy2;\n+\tsy2 = n;\n+\tflipy = ! flipy;\n+      }\n+    if (dx1 > dx2)\n+      {\n+\tn = dx1;\n+\tdx1 = dx2;\n+\tdx2 = n;\n+\tflipx = ! flipx;\n+      }\n+    if (dy1 > dy2)\n+      {\n+\tn = dy1;\n+\tdy1 = dy2;\n+\tdy2 = n;\n+\tflipy = ! flipy;\n+      }\n+    n = 0;\n+    int sw = sx2 - sx1; // source width\n+    int sh = sy2 - sy1; // source height\n+    int[] pixels = new int[sw * sh]; // pixel buffer\n+    int dw = dx2 - dx1; // destination width\n+    int dh = dy2 - dy1; // destination height\n+    double x_scale = ((double) dw) / ((double) sw);\n+    double y_scale = ((double) dh) / ((double) sh);\n+\n+    out.println(\"% drawImage() 2\");\n+    out.println(\"gsave\");\n+    out.println(dx1 + \" \" + dy1 + \" translate\");\n+    out.println(dw + \" \" + dh + \" scale\");\n+    out.println(sw + \" \" + sh + \" 8 [\" + (flipx ? -sw : sw) + \" 0 0 \"\n+                + (flipy ? -sh : sh) + \" \" + (flipx ? sw : 0) + \" \"\n+                + (flipy ? sh : 0) + \" ]\");\n+    out.println(\"{currentfile 3 string readhexstring pop} bind\");\n+    out.println(\"false 3 colorimage\");\n+\n+    PixelGrabber pg = new PixelGrabber(img, sx1, sy1, sw, sh, pixels, 0, sw);\n+    try\n+      {\n+\tpg.grabPixels();\n+      }\n+    catch (InterruptedException e)\n+      {\n+\tSystem.err.println(\"interrupted waiting for pixels!\");\n+\treturn (false);\n+      }\n+\n+    if ((pg.getStatus() & ImageObserver.ABORT) != 0)\n+      {\n+\tSystem.err.println(\"image fetch aborted or errored\");\n+\treturn (false);\n+      }\n+\n+    for (int j = 0; j < sh; j++)\n+      {\n+\tfor (int i = 0; i < sw; i++)\n+\t  {\n+\t    out.print(colorTripleHex(new Color(pixels[j * sw + i])));\n+\t    if (((++n) % 11) == 0)\n+\t      out.println();\n+\t  }\n+      }\n+\n+    out.println();\n+    out.println(\"%%EOF\");\n+    out.println(\"grestore\");\n+    return true;\n+  }\n+\n+  public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2,\n+                           int sx1, int sy1, int sx2, int sy2,\n+                           ImageObserver observer)\n+  {\n+    return drawImage(img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, null,\n+\t\t     observer);\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y, ImageObserver observer)\n+  {\n+    return drawImage(img, x, y, null, observer);\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y, int width, int height,\n+\t\t\t   Color bgcolor, ImageObserver observer)\n+  {\n+    int sw = img.getWidth(null);\n+    int sh = img.getHeight(null);\n+    return drawImage(img, x, y, x + width, y + height, /* destination */\n+\t\t     0, 0, sw - 1, sh - 1, /* source */\n+\t\t     bgcolor, observer);\n+    // correct?\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y, int width, int height,\n+\t\t\t   ImageObserver observer)\n+  {\n+    return drawImage(img, x, y, width, height, null, observer);\n+  }\n+\n+  /** Renders a BufferedImage that is filtered with a BufferedImageOp. */\n+  public void drawImage(BufferedImage img, BufferedImageOp op, int x, int y)\n+  {\n+    BufferedImage result = op.filter(img, null);\n+    drawImage(result, x, y, null);\n+  }\n+\n+  /** Renders an image, applying a transform from image space\n+      into user space before drawing. */\n+  public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs)\n+  {\n+    AffineTransform oldTransform = new AffineTransform(currentTransform);\n+    boolean ret;\n+\n+    transform(xform);\n+    ret = drawImage(img, 0, 0, null, obs);\n+    setTransform(oldTransform);\n+\n+    return ret;\n+  }\n+\n+  /** Renders a RenderableImage, applying a transform from image\n+      space into user space before drawing. */\n+  public void drawRenderableImage(RenderableImage img, AffineTransform xform)\n+  {\n+    // FIXME\n+  }\n+\n+  /** Renders a RenderedImage, applying a transform from\n+      image space into user space before drawing. */\n+  public void drawRenderedImage(RenderedImage img, AffineTransform xform)\n+  {\n+    // FIXME\n+  }\n+\n+  //-------------------------------------------------------------------------\n+  public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    setStroke(ordinaryStroke);\n+    draw(new Polygon(xPoints, yPoints, nPoints));\n+    setStroke(currentStroke);\n+  }\n+\n+  public void drawString(String str, int x, int y)\n+  {\n+    drawString(str, (float) x, (float) y);\n+  }\n+\n+  public void drawString(String str, float x, float y)\n+  {\n+    if( str.trim().equals(\"\") )\n+      return; // don't draw whitespace, silly!\n+\n+    if( currentFontIsPS )\n+      {\n+\tdrawStringPSFont(str, x, y);\n+\treturn;\n+      }\n+\n+    TextLayout text = new TextLayout(str, currentFont, getFontRenderContext());\n+    Shape s = text.getOutline(AffineTransform.getTranslateInstance(x, y));\n+    drawStringShape(s);\n+  }\n+\n+  private void drawStringPSFont(String str, float x, float y)\n+  {\n+    out.println(\"% drawString PS font\");\n+    out.println(x + \" \" + y + \" moveto\");\n+    saveAndInvertAxis();\n+    out.println(\"(\" + str + \") show\");\n+    restoreAxis();\n+  }\n+\n+  private void saveAndInvertAxis()\n+  {\n+    // Invert the Y axis of the CTM.\n+    popCTM();\n+    pushCTM();\n+\n+    double[] test = \n+      {\n+\tpageTransform.getScaleX(), pageTransform.getShearY(),\n+\tpageTransform.getShearX(), pageTransform.getScaleY(),\n+\tpageTransform.getTranslateX(),\n+\t-pageTransform.getTranslateY() + pageY\n+      };\n+\n+    double[] test2 = \n+      {\n+\tcurrentTransform.getScaleX(),\n+\tcurrentTransform.getShearY(),\n+\t-currentTransform.getShearX(),\n+\t-currentTransform.getScaleY(),\n+\tcurrentTransform.getTranslateX(),\n+\tcurrentTransform.getTranslateY()\n+      };\n+\n+    AffineTransform total = new AffineTransform(test);\n+    total.concatenate(new AffineTransform(test2));\n+    concatCTM(total);\n+  }\n+\n+  private void restoreAxis()\n+  {\n+    // reset the CTM\n+    popCTM();\n+    pushCTM();\n+    AffineTransform total = new AffineTransform(pageTransform);\n+    total.concatenate(currentTransform);\n+    concatCTM(total);\n+  }\n+\n+  /**\n+   * special drawing routine for string shapes,\n+   * which need to be drawn with the Y axis uninverted.\n+   */\n+  private void drawStringShape(Shape s)\n+  {\n+    saveAndInvertAxis();\n+\n+    // draw the shape s with an inverted Y axis.\n+    PathIterator pi = s.getPathIterator(new AffineTransform());\n+    float[] coords = new float[6];\n+\n+    while (! pi.isDone())\n+      {\n+\tswitch (pi.currentSegment(coords))\n+\t  {\n+\t  case PathIterator.SEG_MOVETO:\n+\t    out.println((coords[0]) + \" \" + (Y - coords[1]) + \" moveto\");\n+\t    cx = coords[0];\n+\t    cy = coords[1];\n+\t    break;\n+\t  case PathIterator.SEG_LINETO:\n+\t    out.println((coords[0]) + \" \" + (Y - coords[1]) + \" lineto\");\n+\t    cx = coords[0];\n+\t    cy = coords[1];\n+\t    break;\n+\t  case PathIterator.SEG_QUADTO:\n+\t    // convert to cubic bezier points\n+\t    float x1 = (cx + 2 * coords[0]) / 3;\n+\t    float y1 = (cy + 2 * coords[1]) / 3;\n+\t    float x2 = (2 * coords[2] + coords[0]) / 3;\n+\t    float y2 = (2 * coords[3] + coords[1]) / 3;\n+\n+\t    out.print((x1) + \" \" + (Y - y1) + \" \");\n+\t    out.print((x2) + \" \" + (Y - y2) + \" \");\n+\t    out.println((coords[2]) + \" \" + (Y - coords[3]) + \" curveto\");\n+\t    cx = coords[2];\n+\t    cy = coords[3];\n+\t    break;\n+\t  case PathIterator.SEG_CUBICTO:\n+\t    out.print((coords[0]) + \" \" + (Y - coords[1]) + \" \");\n+\t    out.print((coords[2]) + \" \" + (Y - coords[3]) + \" \");\n+\t    out.println((coords[4]) + \" \" + (Y - coords[5]) + \" curveto\");\n+\t    cx = coords[4];\n+\t    cy = coords[5];\n+\t    break;\n+\t  case PathIterator.SEG_CLOSE:\n+\t    out.println(\"closepath\");\n+\t    break;\n+\t  }\n+\tpi.next();\n+      }\n+    out.println(\"fill\");\n+\n+    restoreAxis();\n+  }\n+\n+  public void setColor(Color c)\n+  {\n+    /* don't set the color if it's already set */\n+    if (c.equals(currentColor))\n+      return;\n+    gradientOn = false;\n+    currentColor = c;\n+    currentPaint = c; // Graphics2D extends colors to paint\n+\n+    out.println(colorTriple(c) + \" setrgbcolor\");\n+  }\n+\n+  public void clearRect(int x, int y, int width, int height)\n+  {\n+    out.println(\"% clearRect\");\n+    Color c = currentColor;\n+    setColor(backgroundColor);\n+    fill(new Rectangle2D.Double(x, y, width, height));\n+    setColor(c);\n+  }\n+\n+  public void clipRect(int x, int y, int width, int height)\n+  {\n+    clip(new Rectangle2D.Double(x, y, width, height));\n+  }\n+\n+  public void copyArea(int x, int y, int width, int height, int dx, int dy)\n+  {\n+    // FIXME\n+  }\n+\n+  public void fillRect(int x, int y, int width, int height)\n+  {\n+    fill(new Rectangle2D.Double(x, y, width, height));\n+  }\n+\n+  public void dispose()\n+  {\n+  }\n+\n+  public void setClip(int x, int y, int width, int height)\n+  {\n+    out.println(\"% setClip()\");\n+    setClip(new Rectangle2D.Double(x, y, width, height));\n+  }\n+\n+  public void setClip(Shape s)\n+  {\n+    clip(s);\n+  }\n+\n+  public Shape getClip()\n+  {\n+    return clipShape;\n+  }\n+\n+  public Rectangle getClipBounds()\n+  {\n+    return clipShape.getBounds();\n+  }\n+\n+  public Color getColor()\n+  {\n+    return currentColor;\n+  }\n+\n+  public Font getFont()\n+  {\n+    return currentFont;\n+  }\n+\n+  public FontMetrics getFontMetrics()\n+  {\n+    return getFontMetrics(currentFont);\n+  }\n+\n+  public FontMetrics getFontMetrics(Font f)\n+  {\n+    // FIXME\n+    return null;\n+  }\n+\n+  public void setFont(Font font)\n+  {\n+    out.println(\"% setfont()\");\n+    if (font == null)\n+      // use the default font\n+      font = new Font(\"Dialog\", Font.PLAIN, 12);\n+    currentFont = font;\n+    setPSFont(); // set up the PostScript fonts\n+  }\n+\n+  /**\n+   * Setup the postscript font if the current font is one\n+   */\n+  private void setPSFont()\n+  {\n+    currentFontIsPS = false;\n+\n+    String s = currentFont.getName();\n+    out.println(\"% setPSFont: Fontname: \" + s);\n+    if (s.equalsIgnoreCase(\"Helvetica\") || s.equalsIgnoreCase(\"SansSerif\"))\n+      out.print(\"/helveticaISO findfont \");\n+    else if (s.equalsIgnoreCase(\"Times New Roman\"))\n+      out.print(\"/timesISO findfont \");\n+    else if (s.equalsIgnoreCase(\"Courier\"))\n+      out.print(\"/courierISO findfont \");\n+    else\n+      return;\n+\n+    currentFontIsPS = true;\n+\n+    out.print(currentFont.getSize() + \" scalefont \");\n+    out.println(\"setfont\");\n+  }\n+\n+  /** XOR mode is not supported */\n+  public void setPaintMode()\n+  {\n+  }\n+\n+  /** XOR mode is not supported */\n+  public void setXORMode(Color c1)\n+  {\n+  }\n+\n+  public void close()\n+  {\n+    out.println(\"showpage\");\n+    out.println(\"%%Trailer\");\n+    out.println(\"grestore % restore original stuff\");\n+    out.println(\"%%EOF\");\n+\n+    try\n+      {\n+\tout.close();\n+      }\n+    catch (Exception e)\n+      {\n+      }\n+    out = null;\n+  }\n+\n+  //----------------------------------------------------------------\n+  // Graphics2D stuff ----------------------------------------------\n+\n+  /**  Sets the values of an arbitrary number of\n+       preferences for the rendering algorithms. */\n+  public void addRenderingHints(Map hints)\n+  {\n+    /* rendering hint changes are disallowed */\n+  }\n+\n+  /** write a shape to the file */\n+  private void writeShape(Shape s)\n+  {\n+    PathIterator pi = s.getPathIterator(new AffineTransform());\n+    float[] coords = new float[6];\n+\n+    while (! pi.isDone())\n+      {\n+\tswitch (pi.currentSegment(coords))\n+\t  {\n+\t  case PathIterator.SEG_MOVETO:\n+\t    out.println(coords[0] + \" \" + (coords[1]) + \" moveto\");\n+\t    cx = coords[0];\n+\t    cy = coords[1];\n+\t    break;\n+\t  case PathIterator.SEG_LINETO:\n+\t    out.println(coords[0] + \" \" + (coords[1]) + \" lineto\");\n+\t    cx = coords[0];\n+\t    cy = coords[1];\n+\t    break;\n+\t  case PathIterator.SEG_QUADTO:\n+\t    // convert to cubic bezier points\n+\t    float x1 = (cx + 2 * coords[0]) / 3;\n+\t    float y1 = (cy + 2 * coords[1]) / 3;\n+\t    float x2 = (2 * coords[2] + coords[0]) / 3;\n+\t    float y2 = (2 * coords[3] + coords[1]) / 3;\n+\n+\t    out.print(x1 + \" \" + (Y - y1) + \" \");\n+\t    out.print(x2 + \" \" + (Y - y2) + \" \");\n+\t    out.println(coords[2] + \" \" + (Y - coords[3]) + \" curveto\");\n+\t    cx = coords[2];\n+\t    cy = coords[3];\n+\t    break;\n+\t  case PathIterator.SEG_CUBICTO:\n+\t    out.print(coords[0] + \" \" + coords[1] + \" \");\n+\t    out.print(coords[2] + \" \" + coords[3] + \" \");\n+\t    out.println(coords[4] + \" \" + coords[5] + \" curveto\");\n+\t    cx = coords[4];\n+\t    cy = coords[5];\n+\t    break;\n+\t  case PathIterator.SEG_CLOSE:\n+\t    out.println(\"closepath\");\n+\t    break;\n+\t  }\n+\tpi.next();\n+      }\n+  }\n+\n+  /** Intersects the current Clip with the interior of\n+      the specified Shape and sets the Clip to the resulting intersection. */\n+  public void clip(Shape s)\n+  {\n+    clipShape = s;\n+    out.println(\"% clip INACTIVE\");\n+    //\twriteShape(s);\n+    //\tout.println(\"clip\");\n+  }\n+\n+  /** Strokes the outline of a Shape using the\n+      settings of the current Graphics2D context.*/\n+  public void draw(Shape s)\n+  {\n+    if(!(currentStroke instanceof BasicStroke))\n+      fill(currentStroke.createStrokedShape(s));\n+\n+    out.println(\"% draw\");\n+    writeShape(s);\n+    out.println(\"stroke\");\n+  }\n+\n+  /** Renders the text of the specified GlyphVector using the\n+      Graphics2D context's rendering attributes. */\n+  public void drawGlyphVector(GlyphVector gv, float x, float y)\n+  {\n+    out.println(\"% drawGlyphVector\");\n+    Shape s = gv.getOutline();\n+    drawStringShape(AffineTransform.getTranslateInstance(x, y)\n+\t\t    .createTransformedShape(s));\n+  }\n+\n+  /** Renders the text of the specified iterator,\n+      using the Graphics2D context's current Paint.*/\n+  public void drawString(AttributedCharacterIterator iterator, float x, float y)\n+  {\n+    TextLayout text = new TextLayout(iterator, getFontRenderContext());\n+    Shape s = text.getOutline(AffineTransform.getTranslateInstance(x, y));\n+    drawStringShape(s);\n+  }\n+\n+  /** Renders the text of the specified iterator,\n+      using the Graphics2D context's current Paint. */\n+  public void drawString(AttributedCharacterIterator iterator, int x, int y)\n+  {\n+    drawString(iterator, (float) x, (float) y);\n+  }\n+\n+  /** Fills the interior of a Shape using the settings of the Graphics2D context. */\n+  public void fill(Shape s)\n+  {\n+    out.println(\"% fill\");\n+    if (! gradientOn)\n+      {\n+\twriteShape(s);\n+\tout.println(\"fill\");\n+      }\n+    else\n+      {\n+\tout.println(\"gsave\");\n+\twriteShape(s);\n+\tout.println(\"clip\");\n+\twriteGradient();\n+\tout.println(\"shfill\");\n+\tout.println(\"grestore\");\n+      }\n+  }\n+\n+  /** Returns the background color used for clearing a region. */\n+  public Color getBackground()\n+  {\n+    return backgroundColor;\n+  }\n+\n+  /** Returns the current Composite in the Graphics2D context. */\n+  public Composite getComposite()\n+  {\n+    // FIXME\n+    return null;\n+  }\n+\n+  /** Returns the device configuration associated with this Graphics2D. */\n+  public GraphicsConfiguration getDeviceConfiguration()\n+  {\n+    // FIXME\n+    out.println(\"% getDeviceConfiguration()\");\n+    return null;\n+  }\n+\n+  /** Get the rendering context of the Font within this Graphics2D context. */\n+  public FontRenderContext getFontRenderContext()\n+  {\n+    out.println(\"% getFontRenderContext()\");\n+\n+    double[] scaling = \n+      {\n+\tpageTransform.getScaleX(), 0, 0,\n+\t-pageTransform.getScaleY(), 0, 0\n+      };\n+\n+    return (new FontRenderContext(new AffineTransform(scaling), false, true));\n+  }\n+\n+  /** Returns the current Paint of the Graphics2D context. */\n+  public Paint getPaint()\n+  {\n+    return currentPaint;\n+  }\n+\n+  /** Returns the value of a single preference for the rendering algorithms. */\n+  public Object getRenderingHint(RenderingHints.Key hintKey)\n+  {\n+    return renderingHints.get(hintKey);\n+  }\n+\n+  /** Gets the preferences for the rendering algorithms. */\n+  public RenderingHints getRenderingHints()\n+  {\n+    return renderingHints;\n+  }\n+\n+  /** Returns the current Stroke in the Graphics2D context. */\n+  public Stroke getStroke()\n+  {\n+    return currentStroke;\n+  }\n+\n+  /** Returns a copy of the current Transform in the Graphics2D context. */\n+  public AffineTransform getTransform()\n+  {\n+    return currentTransform;\n+  }\n+\n+  /** \n+   * Checks whether or not the specified Shape intersects \n+   * the specified Rectangle, which is in device space. \n+   */\n+  public boolean hit(Rectangle rect, Shape s, boolean onStroke)\n+  {\n+    Rectangle2D.Double r = new Rectangle2D.Double(rect.getX(), rect.getY(),\n+\t\t\t\t\t\t  rect.getWidth(),\n+\t\t\t\t\t\t  rect.getHeight());\n+    return s.intersects(r);\n+  }\n+\n+  /** Sets the background color for the Graphics2D context.*/\n+  public void setBackground(Color color)\n+  {\n+    out.println(\"% setBackground(\" + color + \")\");\n+    backgroundColor = color;\n+  }\n+\n+  /** Sets the Composite for the Graphics2D context.\n+      Not supported. */\n+  public void setComposite(Composite comp)\n+  {\n+  }\n+\n+  /** Sets the Paint attribute for the Graphics2D context.*/\n+  public void setPaint(Paint paint)\n+  {\n+    currentPaint = paint;\n+    gradientOn = false;\n+    if (paint instanceof Color)\n+      {\n+\tsetColor((Color) paint);\n+\treturn;\n+      }\n+    if (paint instanceof GradientPaint)\n+      {\n+\tgradientOn = true;\n+\treturn;\n+      }\n+  }\n+\n+  /* get a space seperated 0.0 - 1.0 color RGB triple */\n+  private String colorTriple(Color c)\n+  {\n+    return (((double) c.getRed() / 255.0) + \" \"\n+\t    + ((double) c.getGreen() / 255.0) + \" \"\n+\t    + ((double) c.getBlue() / 255.0));\n+  }\n+\n+  /**\n+   * Get a nonsperated hex RGB triple, eg FFFFFF = white\n+   * used by writeGradient and drawImage \n+   */\n+  private String colorTripleHex(Color c)\n+  {\n+    String r = \"00\" + Integer.toHexString(c.getRed());\n+    r = r.substring(r.length() - 2);\n+    String g = \"00\" + Integer.toHexString(c.getGreen());\n+    g = g.substring(g.length() - 2);\n+    String b = \"00\" + Integer.toHexString(c.getBlue());\n+    b = b.substring(b.length() - 2);\n+    return r + g + b;\n+  }\n+\n+  /* write the current gradient fill */\n+  private void writeGradient()\n+  {\n+    GradientPaint paint = (GradientPaint) currentPaint;\n+    out.println(\"% writeGradient()\");\n+\n+    int n = 1;\n+    double x;\n+    double y;\n+    double dx;\n+    double dy;\n+    Point2D p1 = currentTransform.transform(paint.getPoint1(), null);\n+    Point2D p2 = currentTransform.transform(paint.getPoint2(), null);\n+    x = p1.getX();\n+    y = p1.getY();\n+    dx = p2.getX() - x;\n+    dy = p2.getY() - y;\n+\n+    // get number of repetitions\n+    while (x + n * dx < pageY && y + n * dy < pageX && x + n * dx > 0\n+\t   && y + n * dy > 0)\n+      n++;\n+\n+    out.println(\"<<\"); // start\n+    out.println(\"/ShadingType 2\"); // gradient fill \n+    out.println(\"/ColorSpace [ /DeviceRGB ]\"); // RGB colors\n+    out.print(\"/Coords [\");\n+    out.print(x + \" \" + y + \" \" + (x + n * dx) + \" \" + (y + n * dy) + \" \");\n+    out.println(\"]\"); // coordinates defining the axis\n+    out.println(\"/Function <<\");\n+    out.println(\"/FunctionType 0\");\n+    out.println(\"/Order 1\");\n+    out.println(\"/Domain [ 0 1 ]\");\n+    out.println(\"/Range [ 0 1  0 1  0 1 ]\");\n+    out.println(\"/BitsPerSample 8\");\n+    out.println(\"/Size [ \" + (1 + n) + \" ]\");\n+    out.print(\"/DataSource < \" + colorTripleHex(paint.getColor1()) + \" \"\n+\t      + colorTripleHex(paint.getColor2()) + \" \");\n+    for (; n > 1; n--)\n+      if (paint.isCyclic())\n+\t{\n+\t  if ((n % 2) == 1)\n+\t    out.print(colorTripleHex(paint.getColor1()) + \" \");\n+\t  else\n+\t    out.print(colorTripleHex(paint.getColor2()) + \" \");\n+\t}\n+      else\n+\tout.print(colorTripleHex(paint.getColor2()) + \" \");\n+    out.println(\">\");\n+    out.println(\">>\");\n+    out.println(\">>\");\n+  }\n+\n+  /** Sets the value of a single preference for the rendering algorithms. */\n+  public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue)\n+  {\n+    /* we don't allow the changing of rendering hints. */\n+  }\n+\n+  /** Replaces the values of all preferences for the rendering algorithms\n+      with the specified hints. */\n+  public void setRenderingHints(Map hints)\n+  {\n+    /* we don't allow the changing of rendering hints. */\n+  }\n+\n+  /** \n+   * Sets the Stroke for the Graphics2D context. BasicStroke fully implemented.\n+   */\n+  public void setStroke(Stroke s)\n+  {\n+    currentStroke = s;\n+\n+    if (! (s instanceof BasicStroke))\n+      return;\n+\n+    BasicStroke bs = (BasicStroke) s;\n+    out.println(\"% setStroke()\");\n+    try\n+      {\n+\t// set the line width\n+\tout.println(bs.getLineWidth() + \" setlinewidth\");\n+\n+\t// set the line dash\n+\tfloat[] dashArray = bs.getDashArray();\n+\tif (dashArray != null)\n+\t  {\n+\t    out.print(\"[ \");\n+\t    for (int i = 0; i < dashArray.length; i++)\n+\t      out.print(dashArray[i] + \" \");\n+\t    out.println(\"] \" + bs.getDashPhase() + \" setdash\");\n+\t  }\n+\telse\n+\t  out.println(\"[] 0 setdash\"); // set solid\n+\n+\t// set the line cap\n+\tswitch (bs.getEndCap())\n+\t  {\n+\t  case BasicStroke.CAP_BUTT:\n+\t    out.println(\"0 setlinecap\");\n+\t    break;\n+\t  case BasicStroke.CAP_ROUND:\n+\t    out.println(\"1 setlinecap\");\n+\t    break;\n+\t  case BasicStroke.CAP_SQUARE:\n+\t    out.println(\"2 setlinecap\");\n+\t    break;\n+\t  }\n+\n+\t// set the line join\n+\tswitch (bs.getLineJoin())\n+\t  {\n+\t  case BasicStroke.JOIN_BEVEL:\n+\t    out.println(\"2 setlinejoin\");\n+\t    break;\n+\t  case BasicStroke.JOIN_MITER:\n+\t    out.println(\"0 setlinejoin\");\n+\t    out.println(bs.getMiterLimit() + \" setmiterlimit\");\n+\t    break;\n+\t  case BasicStroke.JOIN_ROUND:\n+\t    out.println(\"1 setlinejoin\");\n+\t    break;\n+\t  }\n+      }\n+    catch (Exception e)\n+      {\n+\tout.println(\"% Exception in setStroke()\");\n+      }\n+  }\n+\n+  //////////////////// TRANSFORM SETTING /////////////////////////////////////\n+  private void concatCTM(AffineTransform Tx)\n+  {\n+    double[] matrixElements = new double[6];\n+    Tx.getMatrix(matrixElements);\n+\n+    out.print(\"[ \");\n+    for (int i = 0; i < 6; i++)\n+      out.print(matrixElements[i] + \" \");\n+    out.println(\"] concat\");\n+  }\n+\n+  /** Sets the Transform in the Graphics2D context. */\n+  public void setTransform(AffineTransform Tx)\n+  {\n+    // set the transformation matrix;\n+    currentTransform = Tx;\n+\n+    // concatenate the current transform and the page transform\n+    AffineTransform totalTransform = new AffineTransform(pageTransform);\n+    totalTransform.concatenate(currentTransform);\n+    out.println(\"% setTransform()\");\n+    out.println(\"% pageTransform:\" + pageTransform);\n+    out.println(\"% currentTransform:\" + currentTransform);\n+    out.println(\"% totalTransform:\" + totalTransform);\n+\n+    popCTM();\n+    pushCTM(); // set the CTM to it's original state\n+    concatCTM(totalTransform); // apply our transforms\n+  }\n+\n+  /** Composes an AffineTransform object with the Transform\n+      in this Graphics2D according to the rule last-specified-first-applied. */\n+  public void transform(AffineTransform Tx)\n+  {\n+    // concatenate the current transform\n+    currentTransform.concatenate(Tx);\n+    // and the PS CTM\n+    concatCTM(Tx);\n+  }\n+\n+  ////////////////////////// TRANSFORMS //////////////////////////////////////\n+\n+  /** shear transform */\n+  public void shear(double shx, double shy)\n+  {\n+    out.println(\"% shear()\");\n+    AffineTransform Tx = new AffineTransform();\n+    Tx.shear(shx, shy);\n+    transform(Tx);\n+  }\n+\n+  /** Translates the origin of the Graphics2D context\n+      to the point (x, y) in the current coordinate system. */\n+  public void translate(int x, int y)\n+  {\n+    out.println(\"% translate()\");\n+    AffineTransform Tx = new AffineTransform();\n+    Tx.translate(x, y);\n+    transform(Tx);\n+  }\n+\n+  /** Translates the origin of the Graphics2D context\n+      to the point (x, y) in the current coordinate system. */\n+  public void translate(double x, double y)\n+  {\n+    out.println(\"% translate(\" + x + \", \" + y + \")\");\n+    AffineTransform Tx = new AffineTransform();\n+    Tx.translate(x, y);\n+    transform(Tx);\n+  }\n+\n+  /** Concatenates the current Graphics2D Transform with a rotation transform.*/\n+  public void rotate(double theta)\n+  {\n+    out.println(\"% rotate(\" + theta + \")\");\n+    AffineTransform Tx = new AffineTransform();\n+    Tx.rotate(theta);\n+    transform(Tx);\n+  }\n+\n+  /** Concatenates the current Graphics2D Transform with\n+      a translated rotation transform.*/\n+  public void rotate(double theta, double x, double y)\n+  {\n+    out.println(\"% rotate()\");\n+    AffineTransform Tx = new AffineTransform();\n+    Tx.rotate(theta, x, y);\n+    transform(Tx);\n+  }\n+\n+  /** Concatenates the current Graphics2D Transform with a scaling\n+      transformation Subsequent rendering is resized according to the\n+      specified scaling factors relative to the previous scaling.*/\n+  public void scale(double sx, double sy)\n+  {\n+    out.println(\"% scale(\" + sx + \", \" + sy + \")\");\n+    AffineTransform Tx = new AffineTransform();\n+    Tx.scale(sx, sy);\n+    transform(Tx);\n+  }\n+}"}, {"sha": "b606a2ef63eeea95d8fa1fbb16b28b17d4d2dc90", "filename": "libjava/classpath/gnu/java/awt/print/SpooledDocument.java", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FSpooledDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FSpooledDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Fawt%2Fprint%2FSpooledDocument.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,91 @@\n+/* SpooledDocument.java -- Reurgitate a spooled PostScript file\n+   Copyright (C) 2006  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.java.awt.print;\n+\n+import javax.print.Doc;\n+import javax.print.DocFlavor;\n+import javax.print.attribute.DocAttributeSet;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.Reader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+public class SpooledDocument implements Doc\n+{\n+  private FileInputStream fis;\n+\n+  public SpooledDocument(File file)\n+  {\n+    try \n+      {\n+\tfis = new FileInputStream(file);\n+      }\n+    catch (FileNotFoundException ffne) \n+      {\n+\t// Shouldn't happen.\n+      }\n+  }\n+\n+  public DocAttributeSet getAttributes()\n+  {\n+    return null;\n+  }\n+\n+  public DocFlavor getDocFlavor()\n+  {\n+    return DocFlavor.INPUT_STREAM.POSTSCRIPT;\n+  }\n+\n+  public Object getPrintData()\n+  {\n+    return fis;\n+  }\n+  \n+  public Reader getReaderForText()\n+  {\n+    return new InputStreamReader(fis);\n+  }\n+\n+  public InputStream getStreamForBytes()\n+  {\n+    return fis;\n+ }\n+}"}, {"sha": "5f7309583ea073663888b44e2f728d40072453c0", "filename": "libjava/classpath/gnu/javax/swing/text/html/CharacterAttributeTranslator.java", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FCharacterAttributeTranslator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FCharacterAttributeTranslator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FCharacterAttributeTranslator.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,192 @@\n+/* CharacterAttributeTranslator.java -- \n+   Copyright (C) 2006  Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package gnu.javax.swing.text.html;\n+\n+import java.awt.Color;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+import javax.swing.text.MutableAttributeSet;\n+import javax.swing.text.StyleConstants;\n+import javax.swing.text.html.HTML.Attribute;\n+import javax.swing.text.html.HTML.Tag;\n+\n+/**\n+ * This is a small utility class to translate HTML character attributes to\n+ * Swing StyleConstants\n+ */\n+public class CharacterAttributeTranslator\n+{\n+  /**\n+   * Maps color name to its hex encoding.\n+   */\n+  private static final HashMap colorMap = new HashMap();\n+  static \n+  {\n+    colorMap.put(\"aqua\" , \"#00FFFF\");\n+    colorMap.put(\"blue\" , \"#0000FF\");\n+    colorMap.put(\"black\", \"#000000\");\n+    colorMap.put(\"fuchsia\" , \"#FF00FF\");\n+    colorMap.put(\"gray\" , \"#808080\");\n+    colorMap.put(\"green\" , \"#008000\");\n+    colorMap.put(\"lime\" , \"#00FF00\");\n+    colorMap.put(\"maroon\" , \"#800000\");\n+    colorMap.put(\"navy\" , \"#000080\");\n+    colorMap.put(\"olive\" , \"#808000\");\n+    colorMap.put(\"purple\" , \"#800080\");\n+    colorMap.put(\"red\" , \"#FF0000\");\n+    colorMap.put(\"silver\" , \"#C0C0C0\");\n+    colorMap.put(\"teal\" , \"#008080\");\n+    colorMap.put(\"white\" , \"#FFFFFF\");\n+    colorMap.put(\"yellow\" , \"#FFFF00\");\n+  };\n+  \n+  /**\n+   * Convert the color string represenation into java.awt.Color. The valid\n+   * values are like \"aqua\" , \"#00FFFF\" or \"rgb(1,6,44)\".\n+   * \n+   * @param colorName the color to convert.\n+   * @return the matching java.awt.color\n+   */\n+  private static Color getColor(String colorName)\n+  {\n+    colorName = colorName.toLowerCase();\n+    try\n+      {\n+        if (colorName.startsWith(\"rgb\"))\n+          {\n+            // rgb(red, green, blue) notation.\n+            StringTokenizer st = new StringTokenizer(colorName, \" ,()\");\n+            String representation = st.nextToken();\n+\n+            // Return null if the representation is not supported.\n+            if (! representation.equals(\"rgb\"))\n+              return null;\n+            int red = Integer.parseInt(st.nextToken());\n+            int green = Integer.parseInt(st.nextToken());\n+            int blue = Integer.parseInt(st.nextToken());\n+\n+            return new Color(red, green, blue);\n+          }\n+        else\n+          {\n+            String s2 = (String) colorMap.get(colorName);\n+            if (s2 == null)\n+              s2 = colorName;\n+            return Color.decode(s2);\n+          }\n+      }\n+    catch (Exception nex)\n+      {\n+        // Can be either number format exception or illegal argument\n+        // exception.\n+        return null;\n+      }\n+  }\n+  \n+  /**\n+   * Translate the HTML character attribute to the Swing style constant.\n+   * \n+   * @param charAttr the character attributes of the html tag\n+   * @param t the html tag itself\n+   * @param a the attribute set where the translated attributes will be stored\n+   * \n+   * @return true if some attributes were translated, false otherwise.\n+   */\n+  public static boolean translateTag(MutableAttributeSet charAttr, \n+\t\t\t\t     Tag t, MutableAttributeSet a)\n+  {\n+    if(t == Tag.FONT)\n+      {\n+        Object color = a.getAttribute(Attribute.COLOR); \n+\tif(color != null)\n+\t  {\n+\t    Color c = getColor(color.toString());\n+\t    if( c == null )\n+\t      return false;\n+\t    charAttr.addAttribute(StyleConstants.Foreground, c);\n+\t    return true;\n+\t  }\n+\n+\tif(a.getAttribute(Attribute.SIZE) != null)\n+\t  {\n+\t    // FIXME\n+\t    //\t    charAttr.addAttribute(StyleConstants.FontSize, \n+\t    //\t\t\t\t  new java.lang.Integer(72));\n+\t    return true;\n+\t  }\n+      }\n+\n+    if( t == Tag.B )\n+      {\n+\tcharAttr.addAttribute(StyleConstants.Bold, Boolean.TRUE);\n+\treturn true;\n+      }\n+\n+    if( t == Tag.I )\n+      {\n+\tcharAttr.addAttribute(StyleConstants.Italic, Boolean.TRUE);\n+\treturn true;\n+      }\n+\n+    if( t == Tag.U )\n+      {\n+\tcharAttr.addAttribute(StyleConstants.Underline, Boolean.TRUE);\n+\treturn true;\n+      }\n+\n+    if( t == Tag.STRIKE )\n+      {\n+\tcharAttr.addAttribute(StyleConstants.StrikeThrough, Boolean.TRUE);\n+\treturn true;\n+      }\n+\n+    if( t == Tag.SUP )\n+      {\n+\tcharAttr.addAttribute(StyleConstants.Superscript, Boolean.TRUE);\n+\treturn true;\n+      }\n+\n+    if( t == Tag.SUB )\n+      {\n+\tcharAttr.addAttribute(StyleConstants.Subscript, Boolean.TRUE);\n+\treturn true;\n+      }\n+    return false;\n+  }\n+}"}, {"sha": "b1e3de604255026f012a96351e1981b4f402251d", "filename": "libjava/classpath/gnu/javax/swing/text/html/CombinedAttributes.java", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FCombinedAttributes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FCombinedAttributes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FCombinedAttributes.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,213 @@\n+/* CombinedAttributes.java -- A two combined sets of attributes\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.javax.swing.text.html;\n+\n+import java.io.Serializable;\n+import java.util.Enumeration;\n+\n+import javax.swing.text.AttributeSet;\n+import javax.swing.text.SimpleAttributeSet;\n+\n+/**\n+ * Contains the two combined attribute sets what are searched subsequently.\n+ * This is used to combine style sheet attributes with the HTML view attributes.\n+ * The parent cannot be used as the view may have its own attribute hierarchy.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org)  \n+ */\n+public class CombinedAttributes implements AttributeSet, Serializable\n+{\n+  /**\n+   * Returns the elements from both enumerations.\n+   */\n+  class CombinedEnumeration implements Enumeration\n+  {\n+    /**\n+     * Create a combined enumeration that enumerates over two enumerations.\n+     * \n+     * @param first the first enumeration to enumerate\n+     * @param second the second enumeration to enumerate\n+     */\n+    CombinedEnumeration(Enumeration first, Enumeration second)\n+    {\n+      a = first;\n+      b = second;\n+    }\n+    \n+    /**\n+     * The first enumeration (elements returned first)\n+     */\n+    final Enumeration a;\n+    \n+    /**\n+     * The second enumeration (elements returned later)\n+     */\n+    final Enumeration b;\n+    \n+    /** @inheritDoc */\n+    public boolean hasMoreElements()\n+    {\n+      return a.hasMoreElements() || b.hasMoreElements();\n+    }\n+    \n+    /** @inheritDoc */\n+    public Object nextElement()\n+    {\n+      return a.hasMoreElements() ? a.nextElement():b.nextElement();\n+    }\n+  }\n+  \n+  \n+  /**\n+   * The first attribute set.\n+   */\n+  final AttributeSet a;\n+  \n+  /**\n+   * The second attribute set.\n+   */\n+  final AttributeSet b;\n+  \n+  /**\n+   * Create the CombinedAttributes what search in the two sets. If any of the\n+   * two passed sets is null, another set is returned. Otherwise, the combined\n+   * attribute set is returned.\n+   * \n+   * @param primary the first set (searched first)\n+   * @param secondary the second set (searched later).\n+   */\n+  public static AttributeSet combine(AttributeSet primary,\n+                                     AttributeSet secondary)\n+  {\n+    if (primary == null)\n+      return secondary;\n+    else if (secondary == null)\n+      return primary;\n+    else\n+      return new CombinedAttributes(primary, secondary);\n+  }\n+  \n+  /**\n+   * Create the CombinedAttributes what search in the two sets.\n+   * \n+   * @param primary the first set (searched first)\n+   * @param secondary the second set (searched later).\n+   */\n+  private CombinedAttributes(AttributeSet primary, AttributeSet secondary)\n+  {\n+    a = primary;\n+    b = secondary;\n+  }\n+\n+  /** @inheritDoc */\n+  public boolean containsAttribute(Object name, Object value)\n+  {\n+    return a.containsAttribute(name, value) || b.containsAttribute(name, value);\n+  }\n+\n+  /** @inheritDoc */\n+  public boolean containsAttributes(AttributeSet attributes)\n+  {\n+    Enumeration names = attributes.getAttributeNames();\n+    Object name;\n+    while (names.hasMoreElements())\n+      {\n+        name = names.nextElement();\n+        if (!containsAttribute(name, attributes.getAttribute(name)))\n+          return false;\n+      }\n+    return true;\n+  }\n+\n+  /** @inheritDoc */\n+  public AttributeSet copyAttributes()\n+  {\n+    SimpleAttributeSet copy = new SimpleAttributeSet();\n+    copy.addAttributes(a);\n+    copy.addAttributes(b);\n+    return copy;\n+  }\n+\n+  /** @inheritDoc */\n+  public Object getAttribute(Object key)\n+  {\n+    Object value = a.getAttribute(key);\n+    if (value == null)\n+      value = b.getAttribute(key);\n+    \n+    return value;\n+  }\n+\n+  /** @inheritDoc */\n+  public int getAttributeCount()\n+  {\n+    return a.getAttributeCount()+b.getAttributeCount();\n+  }\n+\n+  /** @inheritDoc */\n+  public Enumeration getAttributeNames()\n+  {\n+    return new CombinedEnumeration(a.getAttributeNames(), b.getAttributeNames());\n+  }\n+\n+  /**\n+   * There is no one.\n+   * \n+   * @return null, always.\n+   */\n+  public AttributeSet getResolveParent()\n+  {\n+    return null;\n+  }\n+\n+  /** @inheritDoc */\n+  public boolean isDefined(Object attrName)\n+  {\n+    return a.isDefined(attrName) || b.isDefined(attrName);\n+  }\n+\n+  /** @inheritDoc */\n+  public boolean isEqual(AttributeSet attr)\n+  {\n+    if (attr.getAttributeCount() == getAttributeCount())\n+      return containsAttributes(attr);\n+    else\n+      return false;\n+  }\n+}"}, {"sha": "862e690c9282804746f84f8e227d5c36c00b5396", "filename": "libjava/classpath/gnu/javax/swing/text/html/ImageViewIconFactory.java", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FImageViewIconFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FImageViewIconFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2FImageViewIconFactory.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,282 @@\n+package gnu.javax.swing.text.html;\n+\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics;\n+import java.io.Serializable;\n+\n+import javax.swing.Icon;\n+import javax.swing.plaf.metal.MetalLookAndFeel;\n+\n+/**\n+ * Creates icons for ImageView. The icons reflect the basic ideas of the Sun's\n+ * icons as they would be described in the text (sheet of paper with image and\n+ * broken sheet of paper with image). They are not pixel to pixel identical and\n+ * contain elements from the metal icon factory.\n+ * \n+ * @author Audrius Meskauskas (audriusa@bioinformatics.org)\n+ */\n+public class ImageViewIconFactory\n+{\n+  private static Icon noImageIcon;\n+\n+  private static Icon loadingImageIcon;\n+  \n+  /**\n+   * This icon reflects the general concept (broken sheet of paper with\n+   * image), but is currently not pixel to pixel identical with the Sun's \n+   * implementation.\n+   */\n+  public static class NoImageIcon implements Icon, Serializable\n+  {\n+    /**\n+     * Creates a new icon.\n+     */\n+    public NoImageIcon()\n+    {\n+      // Nothing to do here.\n+    }\n+\n+    /**\n+     * Returns the width of the icon, in pixels.\n+     * \n+     * @return The width of the icon.\n+     */\n+    public int getIconWidth()\n+    {\n+      return 38;\n+    }\n+\n+    /**\n+     * Returns the height of the icon, in pixels.\n+     * \n+     * @return The height of the icon.\n+     */\n+    public int getIconHeight()\n+    {\n+      return 38;\n+    }\n+\n+    /**\n+     * Paints the icon using colors from the {@link MetalLookAndFeel}.\n+     * \n+     * @param c\n+     *          the component (ignored).\n+     * @param g\n+     *          the graphics device.\n+     * @param x\n+     *          the x-coordinate for the top-left of the icon.\n+     * @param y\n+     *          the y-coordinate for the top-left of the icon.\n+     */\n+    public void paintIcon(Component c, Graphics g, int x, int y)\n+    {\n+      // frame\n+      Color savedColor = g.getColor();\n+\n+      g.setColor(MetalLookAndFeel.getBlack());\n+\n+      g.drawLine(x, y, x + 19, y);\n+\n+      g.drawLine(x, y + 1, x, y + 5);\n+      g.drawLine(x, y + 13, x, y + 25);\n+\n+      g.drawLine(x, y + 25, x + 22, y + 25);\n+\n+      g.drawLine(x + 22, y + 25, x + 22, y + 21);\n+      g.drawLine(x + 22, y + 13, x + 22, y + 6);\n+\n+      g.drawLine(x + 22, y + 6, x + 19, y);\n+\n+      g.drawLine(x + 17, y + 2, x + 21, y + 6);\n+\n+      g.drawLine(x + 18, y + 1, x + 19, y + 1);\n+\n+      g.setColor(MetalLookAndFeel.getControlShadow());\n+\n+      g.drawLine(x + 1, y + 1, x + 17, y + 1);\n+\n+      g.drawLine(x + 1, y + 1, x + 1, y + 5);\n+      g.drawLine(x + 1, y + 13, x + 1, y + 24);\n+\n+      g.drawLine(x + 1, y + 24, x + 21, y + 24);\n+\n+      g.drawLine(x + 21, y + 24, x + 21, y + 21);\n+      g.drawLine(x + 21, y + 13, x + 21, y + 7);\n+\n+      g.drawLine(x + 18, y + 2, x + 20, y + 4);\n+\n+      // Breaking line\n+\n+      // Shadow\n+      g.drawLine(x + 1, y + 6, x + 20, y + 13);\n+      g.drawLine(x + 1, y + 13, x + 20, y + 20);\n+\n+      // Edge\n+      g.setColor(MetalLookAndFeel.getBlack());\n+      g.drawLine(x, y + 6, x + 21, y + 14);\n+      g.drawLine(x, y + 12, x + 21, y + 20);\n+\n+      // Picture\n+\n+      y += 1;\n+      x += 3;\n+\n+      g.setColor(MetalLookAndFeel.getBlack());\n+\n+      // roof\n+      g.drawLine(x + 4, y + 5, x + 8, y + 1);\n+      g.drawLine(x + 8, y + 1, x + 15, y + 8);\n+\n+      // chimney\n+      g.drawLine(x + 11, y + 2, x + 11, y + 4);\n+      g.drawLine(x + 12, y + 2, x + 12, y + 5);\n+\n+      g.setColor(MetalLookAndFeel.getControlDarkShadow());\n+\n+      // roof paint\n+      int xx = x + 8;\n+      for (int i = 0; i < 4; i++)\n+        g.drawLine(xx - i, y + 2 + i, xx + i, y + 2 + i);\n+      g.fillRect(x + 4, y + 6, 9, 2);\n+\n+      // base of house\n+      g.drawLine(x + 3, y + 14, x + 3, y + 18);\n+      g.drawLine(x + 3, y + 18, x + 13, y + 18);\n+\n+      g.setColor(savedColor);\n+    }\n+  }\n+\n+  /**\n+   * This icon reflects the general concept (sheet of paper with image), but is\n+   * currently not pixel to pixel identical with the Sun's implementation.\n+   */\n+  public static class LoadingImageIcon implements Icon, Serializable\n+  {\n+\n+    /**\n+     * Creates a new icon.\n+     */\n+    public LoadingImageIcon()\n+    {\n+      // Nothing to do here.\n+    }\n+\n+    /**\n+     * Returns the width of the icon, in pixels.\n+     * \n+     * @return The width of the icon.\n+     */\n+    public int getIconWidth()\n+    {\n+      return 38;\n+    }\n+\n+    /**\n+     * Returns the height of the icon, in pixels.\n+     * \n+     * @return The height of the icon.\n+     */\n+    public int getIconHeight()\n+    {\n+      return 38;\n+    }\n+\n+    /**\n+     * Paints the icon using colors from the {@link MetalLookAndFeel}.\n+     * \n+     * @param c\n+     *          the component (ignored).\n+     * @param g\n+     *          the graphics device.\n+     * @param x\n+     *          the x-coordinate for the top-left of the icon.\n+     * @param y\n+     *          the y-coordinate for the top-left of the icon.\n+     */\n+    public void paintIcon(Component c, Graphics g, int x, int y)\n+    {\n+      // frame\n+      Color savedColor = g.getColor();\n+\n+      g.setColor(Color.black);\n+      g.drawLine(x, y, x + 19, y);\n+      g.drawLine(x, y + 1, x, y + 25);\n+      g.drawLine(x, y + 25, x + 22, y + 25);\n+      g.drawLine(x + 22, y + 25, x + 22, y + 6);\n+      g.drawLine(x + 22, y + 6, x + 19, y);\n+\n+      g.drawLine(x + 17, y + 2, x + 21, y + 6);\n+      g.drawLine(x + 18, y + 1, x + 19, y + 1);\n+\n+      g.setColor(new Color(204, 204, 255));\n+\n+      g.drawLine(x + 1, y + 1, x + 17, y + 1);\n+      g.drawLine(x + 1, y + 1, x + 1, y + 24);\n+      g.drawLine(x + 1, y + 24, x + 21, y + 24);\n+      g.drawLine(x + 21, y + 24, x + 21, y + 7);\n+      g.drawLine(x + 18, y + 2, x + 20, y + 4);\n+\n+      // Picture (house) \n+\n+      y += 3;\n+      x += 3;\n+\n+      g.setColor(MetalLookAndFeel.getBlack());\n+\n+      // roof\n+      g.drawLine(x + 1, y + 8, x + 8, y + 1);\n+      g.drawLine(x + 8, y + 1, x + 15, y + 8);\n+\n+      // base of house\n+      g.drawLine(x + 3, y + 6, x + 3, y + 15);\n+      g.drawLine(x + 3, y + 15, x + 13, y + 15);\n+      g.drawLine(x + 13, y + 6, x + 13, y + 15);\n+\n+      // door frame\n+      g.drawLine(x + 6, y + 9, x + 6, y + 15);\n+      g.drawLine(x + 6, y + 9, x + 10, y + 9);\n+      g.drawLine(x + 10, y + 9, x + 10, y + 15);\n+\n+      // chimney\n+      g.drawLine(x + 11, y + 2, x + 11, y + 4);\n+      g.drawLine(x + 12, y + 2, x + 12, y + 5);\n+\n+      g.setColor(MetalLookAndFeel.getControlDarkShadow());\n+\n+      // roof paint\n+      int xx = x + 8;\n+      for (int i = 0; i < 4; i++)\n+        g.drawLine(xx - i, y + 2 + i, xx + i, y + 2 + i);\n+      g.fillRect(x + 4, y + 6, 9, 2);\n+\n+      // door knob\n+      g.drawLine(x + 9, y + 12, x + 9, y + 12);\n+\n+      // house paint\n+      g.setColor(MetalLookAndFeel.getPrimaryControl());\n+      g.drawLine(x + 4, y + 8, x + 12, y + 8);\n+      g.fillRect(x + 4, y + 9, 2, 6);\n+      g.fillRect(x + 11, y + 9, 2, 6);\n+\n+      g.setColor(savedColor);\n+    }\n+  }\n+\n+  public static Icon getNoImageIcon()\n+  {\n+    if (noImageIcon == null)\n+      noImageIcon = new NoImageIcon();\n+    return noImageIcon;\n+  }\n+\n+  public static Icon getLoadingImageIcon()\n+  {\n+    if (loadingImageIcon == null)\n+      loadingImageIcon = new LoadingImageIcon();\n+    return loadingImageIcon;\n+  }\n+\n+}"}, {"sha": "45e1dce7b048ef01d9c8696fa444be7fa9780a8b", "filename": "libjava/classpath/gnu/javax/swing/text/html/parser/SmallHtmlAttributeSet.java", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2Fparser%2FSmallHtmlAttributeSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2Fparser%2FSmallHtmlAttributeSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2Fparser%2FSmallHtmlAttributeSet.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,263 @@\n+/* SmallHtmlAttributeSet.java -- Small fixed HTML attribute set\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.javax.swing.text.html.parser;\n+\n+import java.io.Serializable;\n+import java.util.Enumeration;\n+import java.util.NoSuchElementException;\n+\n+import javax.swing.text.AttributeSet;\n+import javax.swing.text.html.HTML.Attribute;\n+import javax.swing.text.html.HTML.Tag;\n+\n+/**\n+ * Small fixed HTML attribute set. The most of the HTML elements contain only\n+ * several attributes. With four attributes, the number of operations in more\n+ * complex algorithms is not larger than using the naive algorithm.\n+ * \n+ * Same as HtmlAttributeSet, this set allows both strings and non-string as\n+ * keys. The strings are case insensitive, the non strings are compared with\n+ * .equals.\n+ * \n+ * @author Audrius Meskauskas (AudriusA@Bioinformatics.org) \n+ */\n+public class SmallHtmlAttributeSet\n+    implements AttributeSet, Cloneable, Serializable\n+{\n+  private static final long serialVersionUID = 1;\n+  \n+  /**\n+   * The keys, stored in this attribute set.\n+   */\n+  final Object[] keys;\n+\n+  /**\n+   * The values, stored in this attribute set.\n+   */\n+  final Object[] values;\n+\n+  /**\n+   * The parent, used for resolving the values, not found in this set.\n+   */\n+  final AttributeSet parent;\n+\n+  /**\n+   * Create a new small fixed attribute set that contains the unchangeable copy\n+   * of the passed attribute set and inherits its parent.\n+   * \n+   * @param copyFrom the attribute set, containing the attribute values to copy.\n+   */\n+  public SmallHtmlAttributeSet(AttributeSet copyFrom)\n+  {\n+    int n = copyFrom.getAttributeCount();\n+\n+    keys = new Object[n];\n+    values = new Object[n];\n+    parent = copyFrom.getResolveParent();\n+\n+    Enumeration en = copyFrom.getAttributeNames();\n+    Object key;\n+    Object value;\n+\n+    for (int i = 0; i < n; i++)\n+      {\n+        key = en.nextElement();\n+        keys[i] = key;\n+        value = copyFrom.getAttribute(key);\n+        if (value instanceof String)\n+          value = ((String) value).toLowerCase();\n+        values[i] = value;\n+      }\n+  }\n+\n+  public boolean containsAttribute(Object name, Object value)\n+  {\n+    Object contains = getAttribute(name);\n+    if (value == null)\n+      return value == contains;\n+    else\n+      return value.equals(contains);\n+  }\n+\n+  public boolean containsAttributes(AttributeSet attributes)\n+  {\n+    if (attributes == this)\n+      return true;\n+    Object v;\n+    for (int i = 0; i < keys.length; i++)\n+      {\n+        v = attributes.getAttribute(keys[i]);\n+        if (v != values[i])\n+          {\n+            if (values[i] == null)\n+              return false;\n+            else if (! values[i].equals(v))\n+              return false;\n+          }\n+      }\n+    return true;\n+  }\n+\n+  /**\n+   * THIS can be safely returned as the set is not mutable.\n+   */\n+  public AttributeSet copyAttributes()\n+  {\n+    return this;\n+  }\n+\n+  /**\n+   * Get the attribute value, matching this key. If not found in this set, the\n+   * call is delegated to parent.\n+   * \n+   * @return the value, matching key (or null if none).\n+   */\n+  public Object getAttribute(Object key)\n+  {\n+    // Null and HTML attributes or tags can be searched by direct comparison.\n+    if (key == null || key instanceof Attribute || key instanceof Tag)\n+      {\n+        for (int i = 0; i < keys.length; i++)\n+          {\n+            if (keys[i] == key)\n+              return values[i];\n+          }\n+      }\n+\n+    // Strings are case insensitive. Only string can be match the string.\n+    else if (key instanceof String)\n+      {\n+        String ks = (String) key;\n+        for (int i = 0; i < keys.length; i++)\n+          {\n+            if (keys[i] instanceof String)\n+              if (ks.equalsIgnoreCase((String) keys[i]))\n+                return values[i];\n+          }\n+      }\n+\n+    // Otherwise, defaults to .equals\n+    else\n+      {\n+        for (int i = 0; i < keys.length; i++)\n+          {\n+            if (key.equals(keys[i]))\n+              return values[i];\n+          }\n+      }\n+\n+    if (parent != null)\n+      return parent.getAttribute(key);\n+    else\n+      return null;\n+  }\n+\n+  /**\n+   * Get the number of the stored attributes.\n+   */\n+  public int getAttributeCount()\n+  {\n+    return keys.length;\n+  }\n+\n+  /**\n+   * Get enumeration, containing the attribute names. No guard agains the\n+   * concurent modification is required as the set is not mutable.\n+   */\n+  public Enumeration getAttributeNames()\n+  {\n+    return new Enumeration()\n+    {\n+      int p = 0;\n+\n+      public boolean hasMoreElements()\n+      {\n+        return p < keys.length;\n+      }\n+\n+      public Object nextElement()\n+      {\n+        if (p < keys.length)\n+          return keys[p++];\n+        else\n+          throw new NoSuchElementException();\n+      }\n+    };\n+  }\n+  \n+  /**\n+   * Get the parent that this set uses to resolve the not found attributes.\n+   */\n+  public AttributeSet getResolveParent()\n+  {\n+    return parent;\n+  }\n+  \n+  /**\n+   * Check if the given attribute is defined in this set (not in the parent).\n+   */\n+  public boolean isDefined(Object attrName)\n+  {\n+    if (attrName instanceof String)\n+      attrName = ((String) attrName).toLowerCase();\n+\n+    for (int i = 0; i < keys.length; i++)\n+      {\n+        if (attrName.equals(keys[i]))\n+          return true;\n+      }\n+    return false;\n+  }\n+  \n+  /**\n+   * Check this set and another set for equality by content.\n+   */\n+  public boolean isEqual(AttributeSet attr)\n+  {\n+    return keys.length == attr.getAttributeCount() && containsAttributes(attr);\n+  }\n+\n+  /**\n+   * It is safe to return THIS on cloning, if one happens.\n+   */\n+  protected Object clone()\n+  {\n+    return this;\n+  }\n+}"}, {"sha": "b89eec619bb39cb1991ab37963557e32952b2050", "filename": "libjava/classpath/gnu/javax/swing/text/html/parser/htmlAttributeSet.java", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2Fparser%2FhtmlAttributeSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2Fparser%2FhtmlAttributeSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjavax%2Fswing%2Ftext%2Fhtml%2Fparser%2FhtmlAttributeSet.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -46,30 +46,42 @@\n \n /**\n  * A set, adapted to store HTML attributes.\n+ * \n  * @author Audrius Meskauskas, Lithuania (AudriusA@Bioinformatics.org)\n  */\n public class htmlAttributeSet\n   extends SimpleAttributeSet\n {\n   public static final htmlAttributeSet EMPTY_HTML_ATTRIBUTE_SET =\n     new htmlAttributeSet();\n+  \n   AttributeSet parent;\n \n   /**\n-   * Looks in this set and, if not found, later looks in the parent set.\n-   * Calls toString(), allowing to pass as HTML.Attribute, as String\n-   * to this method.\n-   * @param key A key to search for a value.\n+   * Looks in this set and, if not found, later looks in the parent set. Calls\n+   * toString(), allowing to pass as HTML.Attribute, as String to this method.\n+   * \n+   * @param _key A key to search for a value.\n    * @return The value, if one is defined.\n    */\n   public Object getAttribute(Object _key)\n   {\n+    Object v = super.getAttribute(_key);\n+    if (v != null || _key == null)\n+      return v;\n+\n     Object key = _key.toString().toLowerCase();\n \n-    Object v = super.getAttribute(key);\n+    v = super.getAttribute(key);\n+    if (v != null)\n+      return v;\n+\n+    key = HTML.getAttributeKey((String) key);\n+    v = super.getAttribute(key);\n     if (v != null)\n       return v;\n-    else if (parent != null)\n+\n+    if (parent != null)\n       return parent.getAttribute(key);\n     else\n       return null;\n@@ -85,26 +97,29 @@ public Enumeration getAttributeNames()\n     final Enumeration enumeration = super.getAttributeNames();\n \n     return new Enumeration()\n+    {\n+      public boolean hasMoreElements()\n+      {\n+        return enumeration.hasMoreElements();\n+      }\n+\n+      public Object nextElement()\n       {\n-        public boolean hasMoreElements()\n-        {\n-          return enumeration.hasMoreElements();\n-        }\n-\n-        public Object nextElement()\n-        {\n-          Object key = enumeration.nextElement();\n-          HTML.Attribute hKey = HTML.getAttributeKey((String) key);\n-          if (hKey != null)\n-            return hKey;\n-          else\n-            return key;\n-        }\n-      };\n+        Object key = enumeration.nextElement();\n+        if (key instanceof String)\n+          {\n+            HTML.Attribute hKey = HTML.getAttributeKey((String) key);\n+            if (hKey != null)\n+              return hKey;\n+          }\n+        return key;\n+      }\n+    };\n   }\n \n   /**\n    * Set the parent set, containing the default values.\n+   * \n    * @param a_parent\n    */\n   public void setResolveParent(AttributeSet a_parent)\n@@ -114,7 +129,8 @@ public void setResolveParent(AttributeSet a_parent)\n \n   /**\n    * Get the parent set, containing the default values.\n-   * @return\n+   * \n+   * @return the parent, used to resolve the attributes.\n    */\n   public AttributeSet getResolveParent()\n   {\n@@ -123,11 +139,45 @@ public AttributeSet getResolveParent()\n \n   /**\n    * Add the attribute to this attribute set.\n-   * @param key Attribute key (will be case insensitive)\n+   * \n+   * @param key Attribute key (if string, it will be case insensitive)\n    * @param value Attribute value\n    */\n   public void addAttribute(Object key, Object value)\n   {\n-    super.addAttribute(key.toString().toLowerCase(), value);\n+    if (key instanceof String)\n+      super.addAttribute(((String) key).toLowerCase(), value);\n+    else\n+      super.addAttribute(key, value);\n   }\n+\n+  /**\n+   * Copy attributes. The returned copy does not longer contains the extended\n+   * features, needed to participate in the HTML parsing. The returned set may\n+   * not be mutable.\n+   */\n+  public AttributeSet copyAttributes()\n+  {\n+    if (getAttributeCount() <= 8)\n+      // For the small size, typical in HTML tags, the direct iteration is\n+      // faster than more complex algorithms.\n+      return new SmallHtmlAttributeSet(this);\n+    else\n+      return (AttributeSet) clone();\n+  }   \n+  \n+  /**\n+   * Returns a clone of the attribute set.\n+   * \n+   * @return A clone of the attribute set.\n+   */\n+  public Object clone()\n+  {\n+    htmlAttributeSet set = new htmlAttributeSet();\n+    set.addAttributes(this);\n+    AttributeSet parent = getResolveParent();\n+    if (parent != null)\n+      set.setResolveParent(parent);\n+    return set;\n+  }  \n }"}, {"sha": "2d172d750190e9deb877879bcac6b6688f4858e4", "filename": "libjava/classpath/include/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -65,8 +65,6 @@ AUTOMAKE = @AUTOMAKE@\n AWK = @AWK@\n BUILD_CLASS_FILES_FALSE = @BUILD_CLASS_FILES_FALSE@\n BUILD_CLASS_FILES_TRUE = @BUILD_CLASS_FILES_TRUE@\n-CAIRO_CFLAGS = @CAIRO_CFLAGS@\n-CAIRO_LIBS = @CAIRO_LIBS@\n CC = @CC@\n CCDEPMODE = @CCDEPMODE@\n CFLAGS = @CFLAGS@\n@@ -93,8 +91,12 @@ CREATE_JNI_HEADERS_FALSE = @CREATE_JNI_HEADERS_FALSE@\n CREATE_JNI_HEADERS_TRUE = @CREATE_JNI_HEADERS_TRUE@\n CREATE_JNI_LIBRARIES_FALSE = @CREATE_JNI_LIBRARIES_FALSE@\n CREATE_JNI_LIBRARIES_TRUE = @CREATE_JNI_LIBRARIES_TRUE@\n+CREATE_PLUGIN_FALSE = @CREATE_PLUGIN_FALSE@\n+CREATE_PLUGIN_TRUE = @CREATE_PLUGIN_TRUE@\n CREATE_QT_PEER_LIBRARIES_FALSE = @CREATE_QT_PEER_LIBRARIES_FALSE@\n CREATE_QT_PEER_LIBRARIES_TRUE = @CREATE_QT_PEER_LIBRARIES_TRUE@\n+CREATE_WRAPPERS_FALSE = @CREATE_WRAPPERS_FALSE@\n+CREATE_WRAPPERS_TRUE = @CREATE_WRAPPERS_TRUE@\n CREATE_XMLJ_LIBRARY_FALSE = @CREATE_XMLJ_LIBRARY_FALSE@\n CREATE_XMLJ_LIBRARY_TRUE = @CREATE_XMLJ_LIBRARY_TRUE@\n CXX = @CXX@\n@@ -117,6 +119,8 @@ EXAMPLESDIR = @EXAMPLESDIR@\n EXEEXT = @EXEEXT@\n FASTJAR = @FASTJAR@\n FIND = @FIND@\n+FOUND_CACAO_FALSE = @FOUND_CACAO_FALSE@\n+FOUND_CACAO_TRUE = @FOUND_CACAO_TRUE@\n FOUND_ECJ_FALSE = @FOUND_ECJ_FALSE@\n FOUND_ECJ_TRUE = @FOUND_ECJ_TRUE@\n FOUND_GCJX_FALSE = @FOUND_GCJX_FALSE@\n@@ -132,9 +136,8 @@ FREETYPE2_LIBS = @FREETYPE2_LIBS@\n GCJ = @GCJ@\n GCJX = @GCJX@\n GJDOC = @GJDOC@\n-GTK_CAIRO_ENABLED = @GTK_CAIRO_ENABLED@\n-GTK_CAIRO_FALSE = @GTK_CAIRO_FALSE@\n-GTK_CAIRO_TRUE = @GTK_CAIRO_TRUE@\n+GLIB_CFLAGS = @GLIB_CFLAGS@\n+GLIB_LIBS = @GLIB_LIBS@\n GTK_CFLAGS = @GTK_CFLAGS@\n GTK_LIBS = @GTK_LIBS@\n INIT_LOAD_LIBRARY = @INIT_LOAD_LIBRARY@\n@@ -156,6 +159,7 @@ KJC = @KJC@\n LDFLAGS = @LDFLAGS@\n LIBDEBUG = @LIBDEBUG@\n LIBICONV = @LIBICONV@\n+LIBMAGIC = @LIBMAGIC@\n LIBOBJS = @LIBOBJS@\n LIBS = @LIBS@\n LIBTOOL = @LIBTOOL@\n@@ -169,6 +173,8 @@ MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@\n MAKEINFO = @MAKEINFO@\n MKDIR = @MKDIR@\n MOC = @MOC@\n+MOZILLA_CFLAGS = @MOZILLA_CFLAGS@\n+MOZILLA_LIBS = @MOZILLA_LIBS@\n OBJEXT = @OBJEXT@\n PACKAGE = @PACKAGE@\n PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n@@ -182,6 +188,7 @@ PATH_SEPARATOR = @PATH_SEPARATOR@\n PATH_TO_GLIBJ_ZIP = @PATH_TO_GLIBJ_ZIP@\n PERL = @PERL@\n PKG_CONFIG = @PKG_CONFIG@\n+PLUGIN_DIR = @PLUGIN_DIR@\n QT_CFLAGS = @QT_CFLAGS@\n QT_LIBS = @QT_LIBS@\n RANLIB = @RANLIB@\n@@ -201,11 +208,13 @@ USER_SPECIFIED_JAVAH_TRUE = @USER_SPECIFIED_JAVAH_TRUE@\n USE_PREBUILT_GLIBJ_ZIP_FALSE = @USE_PREBUILT_GLIBJ_ZIP_FALSE@\n USE_PREBUILT_GLIBJ_ZIP_TRUE = @USE_PREBUILT_GLIBJ_ZIP_TRUE@\n VERSION = @VERSION@\n+VM_BINARY = @VM_BINARY@\n WARNING_CFLAGS = @WARNING_CFLAGS@\n XML_CFLAGS = @XML_CFLAGS@\n XML_LIBS = @XML_LIBS@\n XSLT_CFLAGS = @XSLT_CFLAGS@\n XSLT_LIBS = @XSLT_LIBS@\n+XTEST_LIBS = @XTEST_LIBS@\n X_CFLAGS = @X_CFLAGS@\n X_EXTRA_LIBS = @X_EXTRA_LIBS@\n X_LIBS = @X_LIBS@"}, {"sha": "dda8b58e96e5fdc9e660c6fa14830af8f4ae8a83", "filename": "libjava/classpath/include/config.h.in", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fconfig.h.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -9,9 +9,6 @@\n /* Define to enable support for local sockets. */\n #undef ENABLE_LOCAL_SOCKETS\n \n-/* defined if cairo support was built in */\n-#undef GTK_CAIRO\n-\n /* Define to 1 if you have the `accept' function. */\n #undef HAVE_ACCEPT\n \n@@ -99,9 +96,15 @@\n /* Define to 1 if you have the `lseek' function. */\n #undef HAVE_LSEEK\n \n+/* Define to 1 if you have the `lstat' function. */\n+#undef HAVE_LSTAT\n+\n /* Define to 1 if you have the `madvise' function. */\n #undef HAVE_MADVISE\n \n+/* Define to 1 if you have the <magic.h> header file. */\n+#undef HAVE_MAGIC_H\n+\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n@@ -132,6 +135,9 @@\n /* Define to 1 if you have the `read' function. */\n #undef HAVE_READ\n \n+/* Define to 1 if you have the `readlink' function. */\n+#undef HAVE_READLINK\n+\n /* Define to 1 if you have the `recvfrom' function. */\n #undef HAVE_RECVFROM\n \n@@ -230,6 +236,12 @@\n /* Define to 1 if you have the `write' function. */\n #undef HAVE_WRITE\n \n+/* Define to 1 if you have libXrandr. */\n+#undef HAVE_XRANDR\n+\n+/* Define to 1 if you have libXrender. */\n+#undef HAVE_XRENDER\n+\n /* Define if the host machine stores words of multi-word integers in\n    big-endian order. */\n #undef HOST_WORDS_BIG_ENDIAN"}, {"sha": "0ac6e4ad0518a394790db634a9ea8524c32cd5dc", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_CairoGraphics2D.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_CairoGraphics2D.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_CairoGraphics2D.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_CairoGraphics2D.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,45 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+\n+#ifndef __gnu_java_awt_peer_gtk_CairoGraphics2D__\n+#define __gnu_java_awt_peer_gtk_CairoGraphics2D__\n+\n+#include <jni.h>\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+JNIEXPORT jlong JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_init (JNIEnv *env, jobject, jlong);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_disposeNative (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_drawPixels (JNIEnv *env, jobject, jintArray, jint, jint, jint, jdoubleArray);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_setGradient (JNIEnv *env, jobject, jdouble, jdouble, jdouble, jdouble, jint, jint, jint, jint, jint, jint, jint, jint, jboolean);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_setTexturePixels (JNIEnv *env, jobject, jintArray, jint, jint, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoSetMatrix (JNIEnv *env, jobject, jdoubleArray);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoSetOperator (JNIEnv *env, jobject, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoSetRGBAColor (JNIEnv *env, jobject, jdouble, jdouble, jdouble, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoSetFillRule (JNIEnv *env, jobject, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoSetLine (JNIEnv *env, jobject, jdouble, jint, jint, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoSetDash (JNIEnv *env, jobject, jdoubleArray, jint, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoDrawGlyphVector (JNIEnv *env, jobject, jobject, jfloat, jfloat, jint, jintArray, jfloatArray);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoRelCurveTo (JNIEnv *env, jobject, jdouble, jdouble, jdouble, jdouble, jdouble, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoRectangle (JNIEnv *env, jobject, jdouble, jdouble, jdouble, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoNewPath (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoClosePath (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoMoveTo (JNIEnv *env, jobject, jdouble, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoRelMoveTo (JNIEnv *env, jobject, jdouble, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoLineTo (JNIEnv *env, jobject, jdouble, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoRelLineTo (JNIEnv *env, jobject, jdouble, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoCurveTo (JNIEnv *env, jobject, jdouble, jdouble, jdouble, jdouble, jdouble, jdouble);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoStroke (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoFill (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoClip (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoPreserveClip (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoResetClip (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoGraphics2D_cairoSurfaceSetFilter (JNIEnv *env, jobject, jint);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* __gnu_java_awt_peer_gtk_CairoGraphics2D__ */"}, {"sha": "3bc263ffd97de3acf1775037d5ff6da0641410b6", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_CairoSurface.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_CairoSurface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_CairoSurface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_CairoSurface.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,28 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+\n+#ifndef __gnu_java_awt_peer_gtk_CairoSurface__\n+#define __gnu_java_awt_peer_gtk_CairoSurface__\n+\n+#include <jni.h>\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_create (JNIEnv *env, jobject, jint, jint, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_destroy (JNIEnv *env, jobject);\n+JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_nativeGetElem (JNIEnv *env, jobject, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_nativeSetElem (JNIEnv *env, jobject, jint, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_drawSurface (JNIEnv *env, jobject, jobject, jdoubleArray);\n+JNIEXPORT jintArray JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_getPixels (JNIEnv *env, jobject, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_setPixels (JNIEnv *env, jobject, jintArray);\n+JNIEXPORT jlong JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_getFlippedBuffer (JNIEnv *env, jobject, jint);\n+JNIEXPORT jlong JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_newCairoContext (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_CairoSurface_copyAreaNative (JNIEnv *env, jobject, jint, jint, jint, jint, jint, jint, jint);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* __gnu_java_awt_peer_gtk_CairoSurface__ */"}, {"sha": "e8ca711780e3613170fe029de47f4d015889e38e", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_ComponentGraphics.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_ComponentGraphics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_ComponentGraphics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_ComponentGraphics.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,26 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+\n+#ifndef __gnu_java_awt_peer_gtk_ComponentGraphics__\n+#define __gnu_java_awt_peer_gtk_ComponentGraphics__\n+\n+#include <jni.h>\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+JNIEXPORT jlong JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphics_initState (JNIEnv *env, jobject, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphics_disposeSurface (JNIEnv *env, jobject, jlong);\n+JNIEXPORT jlong JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphics_initFromVolatile (JNIEnv *env, jobject, jlong, jint, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphics_start_1gdk_1drawing (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphics_end_1gdk_1drawing (JNIEnv *env, jobject);\n+JNIEXPORT jboolean JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphics_hasXRender (JNIEnv *env, jclass);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphics_copyAreaNative (JNIEnv *env, jobject, jobject, jint, jint, jint, jint, jint, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphics_drawVolatile (JNIEnv *env, jobject, jobject, jobject, jint, jint, jint, jint);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* __gnu_java_awt_peer_gtk_ComponentGraphics__ */"}, {"sha": "8e4b2cdb3cb7b7e825d07d450de458dd6c142e1b", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_ComponentGraphicsCopy.h", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_ComponentGraphicsCopy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_ComponentGraphicsCopy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_ComponentGraphicsCopy.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,20 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+\n+#ifndef __gnu_java_awt_peer_gtk_ComponentGraphicsCopy__\n+#define __gnu_java_awt_peer_gtk_ComponentGraphicsCopy__\n+\n+#include <jni.h>\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphicsCopy_getPixbuf (JNIEnv *env, jobject, jobject, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_ComponentGraphicsCopy_copyPixbuf (JNIEnv *env, jobject, jobject, jobject, jint, jint, jint, jint);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* __gnu_java_awt_peer_gtk_ComponentGraphicsCopy__ */"}, {"sha": "8c8434b6e25195ba17dc08c6b8780da61e01bdc1", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_FreetypeGlyphVector.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_FreetypeGlyphVector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_FreetypeGlyphVector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_FreetypeGlyphVector.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,22 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+\n+#ifndef __gnu_java_awt_peer_gtk_FreetypeGlyphVector__\n+#define __gnu_java_awt_peer_gtk_FreetypeGlyphVector__\n+\n+#include <jni.h>\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_FreetypeGlyphVector_getGlyph (JNIEnv *env, jobject, jint);\n+JNIEXPORT jobject JNICALL Java_gnu_java_awt_peer_gtk_FreetypeGlyphVector_getKerning (JNIEnv *env, jobject, jint, jint);\n+JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_FreetypeGlyphVector_getMetricsNative (JNIEnv *env, jobject, jint);\n+JNIEXPORT jobject JNICALL Java_gnu_java_awt_peer_gtk_FreetypeGlyphVector_getGlyphOutlineNative (JNIEnv *env, jobject, jint);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* __gnu_java_awt_peer_gtk_FreetypeGlyphVector__ */"}, {"sha": "3b9ddd44333c6c26ae508648cdde8a49342dfc3f", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GdkFontPeer.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkFontPeer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkFontPeer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkFontPeer.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -13,10 +13,11 @@ extern \"C\"\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_initStaticState (JNIEnv *env, jclass);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_initState (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_dispose (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_setFont (JNIEnv *env, jobject, jstring, jint, jint, jboolean);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_setFont (JNIEnv *env, jobject, jstring, jint, jint);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_getFontMetrics (JNIEnv *env, jobject, jdoubleArray);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_getTextMetrics (JNIEnv *env, jobject, jstring, jdoubleArray);\n-JNIEXPORT jobject JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_getGlyphVector (JNIEnv *env, jobject, jstring, jobject, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_releasePeerGraphicsResource (JNIEnv *env, jobject);\n+JNIEXPORT jbyteArray JNICALL Java_gnu_java_awt_peer_gtk_GdkFontPeer_getTrueTypeTable (JNIEnv *env, jobject, jbyte, jbyte, jbyte, jbyte);\n \n #ifdef __cplusplus\n }"}, {"sha": "2a619c60951642ea9c272a55668d883cd5d53d90", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GdkGraphicsEnvironment.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkGraphicsEnvironment.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkGraphicsEnvironment.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkGraphicsEnvironment.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -10,6 +10,10 @@ extern \"C\"\n {\n #endif\n \n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphicsEnvironment_initStaticState (JNIEnv *env, jclass);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphicsEnvironment_nativeInitState (JNIEnv *env, jobject);\n+JNIEXPORT jobjectArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphicsEnvironment_nativeGetScreenDevices (JNIEnv *env, jobject);\n+JNIEXPORT jobject JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphicsEnvironment_nativeGetDefaultScreenDevice (JNIEnv *env, jobject);\n JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphicsEnvironment_nativeGetNumFontFamilies (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphicsEnvironment_nativeGetFontFamilies (JNIEnv *env, jobject, jobjectArray);\n "}, {"sha": "8037af0825ee4c7c231069c4aaba174bcfcbd0f1", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,26 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+\n+#ifndef __gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice__\n+#define __gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice__\n+\n+#include <jni.h>\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice_initStaticState (JNIEnv *env, jclass);\n+JNIEXPORT jobject JNICALL Java_gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice_nativeGetFixedDisplayMode (JNIEnv *env, jobject, jobject);\n+JNIEXPORT jstring JNICALL Java_gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice_nativeGetIDString (JNIEnv *env, jobject);\n+JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice_nativeGetDisplayModeIndex (JNIEnv *env, jobject, jobject);\n+JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice_nativeGetDisplayModeRate (JNIEnv *env, jobject, jobject);\n+JNIEXPORT jobjectArray JNICALL Java_gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice_nativeGetDisplayModes (JNIEnv *env, jobject, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice_nativeSetDisplayMode (JNIEnv *env, jobject, jobject, jint, jshort);\n+JNIEXPORT jobject JNICALL Java_gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice_nativeGetBounds (JNIEnv *env, jobject);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* __gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice__ */"}, {"sha": "680c4165f846913dd6a5145c450755e183598367", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GdkTextLayout.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkTextLayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkTextLayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GdkTextLayout.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -11,10 +11,12 @@ extern \"C\"\n #endif\n \n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_setText (JNIEnv *env, jobject, jstring);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_setFont (JNIEnv *env, jobject, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_getExtents (JNIEnv *env, jobject, jdoubleArray, jdoubleArray);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_indexToPos (JNIEnv *env, jobject, jint, jdoubleArray);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_initState (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_dispose (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_cairoDrawGdkTextLayout (JNIEnv *env, jobject, jobject, jfloat, jfloat);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_initStaticState (JNIEnv *env, jclass);\n JNIEXPORT jobject JNICALL Java_gnu_java_awt_peer_gtk_GdkTextLayout_getOutline (JNIEnv *env, jobject, jobject);\n "}, {"sha": "e774713a7669b2addddf21f07d874ffaab9b8953", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GtkCanvasPeer.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkCanvasPeer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkCanvasPeer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkCanvasPeer.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -11,7 +11,6 @@ extern \"C\"\n #endif\n \n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkCanvasPeer_create (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkCanvasPeer_realize (JNIEnv *env, jobject);\n \n #ifdef __cplusplus\n }"}, {"sha": "f2014595fe8fa3d8967a3d09f834c7a96f98331c", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GtkComponentPeer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -26,7 +26,7 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkWidgetSetS\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkWidgetSetParent (JNIEnv *env, jobject, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkWidgetRequestFocus (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_gtkWidgetDispatchKeyEvent (JNIEnv *env, jobject, jint, jlong, jint, jint, jint);\n-JNIEXPORT jboolean JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_isRealized (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_realize (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_setNativeEventMask (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_connectSignals (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkComponentPeer_setNativeBounds (JNIEnv *env, jobject, jint, jint, jint, jint);"}, {"sha": "0ea798bc2642030aae05b998af0db15f655291ba", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GtkImage.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkImage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkImage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkImage.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -10,15 +10,14 @@ extern \"C\"\n {\n #endif\n \n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_initFromBuffer (JNIEnv *env, jobject, jlong);\n JNIEXPORT jintArray JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_getPixels (JNIEnv *env, jobject);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_setPixels (JNIEnv *env, jobject, jintArray);\n JNIEXPORT jboolean JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_loadPixbuf (JNIEnv *env, jobject, jstring);\n JNIEXPORT jboolean JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_loadImageFromData (JNIEnv *env, jobject, jbyteArray);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_createPixmap (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_freePixmap (JNIEnv *env, jobject);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_createScaledPixmap (JNIEnv *env, jobject, jobject, jint);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_drawPixelsScaled (JNIEnv *env, jobject, jobject, jint, jint, jint, jint, jint, jint, jint, jboolean);\n-JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_drawPixelsScaledFlipped (JNIEnv *env, jobject, jobject, jint, jint, jint, jboolean, jboolean, jint, jint, jint, jint, jint, jint, jint, jint, jboolean);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_createPixbuf (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_freePixbuf (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_createScaledPixbuf (JNIEnv *env, jobject, jobject, jint);\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkImage_createFromPixbuf (JNIEnv *env, jobject);\n \n #ifdef __cplusplus"}, {"sha": "3a0efd3a9e4c262d3eeb692836bba112cb5b9ba6", "filename": "libjava/classpath/include/gnu_java_awt_peer_gtk_GtkVolatileImage.h", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkVolatileImage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkVolatileImage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Finclude%2Fgnu_java_awt_peer_gtk_GtkVolatileImage.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,23 @@\n+/* DO NOT EDIT THIS FILE - it is machine generated */\n+\n+#ifndef __gnu_java_awt_peer_gtk_GtkVolatileImage__\n+#define __gnu_java_awt_peer_gtk_GtkVolatileImage__\n+\n+#include <jni.h>\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+JNIEXPORT jlong JNICALL Java_gnu_java_awt_peer_gtk_GtkVolatileImage_init (JNIEnv *env, jobject, jobject, jint, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkVolatileImage_destroy (JNIEnv *env, jobject);\n+JNIEXPORT jintArray JNICALL Java_gnu_java_awt_peer_gtk_GtkVolatileImage_getPixels (JNIEnv *env, jobject);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkVolatileImage_copyArea (JNIEnv *env, jobject, jint, jint, jint, jint, jint, jint);\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GtkVolatileImage_drawVolatile (JNIEnv *env, jobject, jlong, jint, jint, jint, jint);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* __gnu_java_awt_peer_gtk_GtkVolatileImage__ */"}, {"sha": "3e259216fa7ce797233723f03cf363e001aa3073", "filename": "libjava/classpath/java/awt/BasicStroke.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FBasicStroke.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FBasicStroke.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FBasicStroke.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -363,7 +363,7 @@ public int hashCode()\n    * Compares this <code>BasicStroke</code> for equality with an arbitrary \n    * object.  This method returns <code>true</code> if and only if:\n    * <ul>\n-   * <li><code>o</code> is an instanceof <code>BasicStroke</code>;<li>\n+   * <li><code>o</code> is an instanceof <code>BasicStroke</code>;</li>\n    * <li>this object has the same width, line cap style, line join style,\n    * miter limit, dash array and dash phase as <code>o</code>.</li>\n    * </ul>"}, {"sha": "2996f899f17094355d631ba481e1e440504d46a8", "filename": "libjava/classpath/java/awt/ColorPaintContext.java", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FColorPaintContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FColorPaintContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FColorPaintContext.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -117,7 +117,7 @@ public Raster getRaster(int x, int y, int width, int height)\n    {\n      cachedRaster = new ColorRaster(colorModel, 0, 0, width, height, color);\n    }\n-   return cachedRaster.createChild(0 ,0 ,width ,height ,x ,y , null);\n+   return cachedRaster.createChild(0 ,0 ,width ,height ,0 ,0 , null);\n   }\n   \n   /**\n@@ -138,13 +138,13 @@ private class ColorRaster extends Raster\n      * @param rgbPixel The RGB value of the color for this raster.\n      */\n     ColorRaster(ColorModel cm,int x, int y, int width, int height, int rgbPixel)\n-    {         \n+    {\n       super(cm.createCompatibleSampleModel(width,height),new Point(x,y));\n       Object pixel = cm.getDataElements(rgbPixel,null);\n-      getSampleModel().setDataElements(0, 0,\n-                                       width, height,\n-                                       multiplyData(pixel,null,width*height),\n-                                       dataBuffer);\n+      int[] pixelComps = cm.getComponents(pixel, null, 0);\n+      int[] d = (int[]) multiplyData(pixelComps,null,width*height);\n+      getSampleModel().setPixels(0, 0, width, height, d,\n+                                 dataBuffer);\n     }\n     \n     "}, {"sha": "cc42d04f2745664fa90e46696f21d6d7b1e45151", "filename": "libjava/classpath/java/awt/Component.java", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FComponent.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -2067,11 +2067,9 @@ else if (peer != null)\n    */\n   public VolatileImage createVolatileImage(int width, int height)\n   {\n-    if (GraphicsEnvironment.isHeadless())\n-      return null;\n-    GraphicsConfiguration config = getGraphicsConfiguration();\n-    return config == null ? null\n-      : config.createCompatibleVolatileImage(width, height);\n+    if (peer != null)\n+      return peer.createVolatileImage(width, height);\n+    return null;\n   }\n \n   /**\n@@ -2090,11 +2088,9 @@ public VolatileImage createVolatileImage(int width, int height,\n                                            ImageCapabilities caps)\n     throws AWTException\n   {\n-    if (GraphicsEnvironment.isHeadless())\n-      return null;\n-    GraphicsConfiguration config = getGraphicsConfiguration();\n-    return config == null ? null\n-      : config.createCompatibleVolatileImage(width, height, caps);\n+    if (peer != null)\n+      return peer.createVolatileImage(width, height);\n+    return null;\n   }\n \n   /**\n@@ -4810,8 +4806,38 @@ static Event translateEvent (AWTEvent e)\n   {\n     Object target = e.getSource ();\n     Event translated = null;\n+    \n+    if (e instanceof WindowEvent)\n+      {\n+        WindowEvent we = (WindowEvent) e;\n+        int id = we.id;\n+        int newId = 0;\n+        \n+        switch (id)\n+          {\n+          case WindowEvent.WINDOW_DEICONIFIED:\n+            newId = Event.WINDOW_DEICONIFY;\n+            break;\n+          case WindowEvent.WINDOW_CLOSED:\n+          case WindowEvent.WINDOW_CLOSING:\n+            newId = Event.WINDOW_DESTROY;\n+            break;\n+          case WindowEvent.WINDOW_ICONIFIED:\n+            newId = Event.WINDOW_ICONIFY;\n+            break;\n+          case WindowEvent.WINDOW_GAINED_FOCUS:\n+            newId = Event.GOT_FOCUS;\n+            break;\n+          case WindowEvent.WINDOW_LOST_FOCUS:\n+            newId = Event.LOST_FOCUS;\n+            break;\n+          default:\n+            return null;\n+          }\n \n-    if (e instanceof InputEvent)\n+        translated = new Event(target, 0, newId, 0, 0, 0, 0);\n+      }\n+    else if (e instanceof InputEvent)\n       {\n         InputEvent ie = (InputEvent) e;\n         long when = ie.getWhen ();\n@@ -5052,7 +5078,12 @@ void dispatchEventImpl(AWTEvent e)\n                     .dispatchEvent(e))\n                     return;\n               case MouseEvent.MOUSE_PRESSED:\n-                if (isLightweight() && !e.isConsumed())\n+                // A mouse click on an enabled lightweight component\n+                // which has not yet been marked as consumed by any\n+                // other mouse listener results in a focus traversal\n+                // to that component.\n+                if (isLightweight()\n+                    && isEnabled() && !e.isConsumed())\n                     requestFocus();\n                 break;\n               }"}, {"sha": "85a68ce13c2e336011458da30162abe5af855d16", "filename": "libjava/classpath/java/awt/Container.java", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FContainer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -457,8 +457,44 @@ public void removeAll()\n   {\n     synchronized (getTreeLock ())\n       {\n-        while (ncomponents > 0)\n-          remove(0);\n+        // In order to allow the same bad tricks to be used as in RI\n+        // this code has to stay exactly that way: In a real-life app\n+        // a Container subclass implemented its own vector for\n+        // subcomponents, supplied additional addXYZ() methods\n+        // and overrode remove(int) and removeAll (the latter calling\n+        // super.removeAll() ).\n+        // By doing it this way, user code cannot prevent the correct\n+        // removal of components.\n+        for ( int index = 0; index < ncomponents; index++)\n+          {\n+            Component r = component[index];\n+\n+            ComponentListener[] list = r.getComponentListeners();\n+            for (int j = 0; j < list.length; j++)\n+              r.removeComponentListener(list[j]);\n+            \n+            r.removeNotify();\n+\n+            if (layoutMgr != null)\n+              layoutMgr.removeLayoutComponent(r);\n+\n+            r.parent = null;\n+\n+            if (isShowing ())\n+              {\n+                // Post event to notify of removing the component.\n+                ContainerEvent ce\n+                  = new ContainerEvent(this,\n+                                       ContainerEvent.COMPONENT_REMOVED,\n+                                       r);\n+                \n+                getToolkit().getSystemEventQueue().postEvent(ce);\n+              }\n+            }\n+          \n+          invalidate();\n+        \n+          ncomponents = 0;\n       }\n   }\n "}, {"sha": "23b4ac2e8d35ad9081b8c5073eba8cb7d20f201a", "filename": "libjava/classpath/java/awt/ContainerOrderFocusTraversalPolicy.java", "status": "modified", "additions": 120, "deletions": 53, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FContainerOrderFocusTraversalPolicy.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -111,14 +111,16 @@ public Component getComponentAfter (Container root, Component current)\n \tancestor = current.getFocusCycleRootAncestor ();\n \tif (ancestor == prevAncestor)\n \t  {\n-\t    // We've reached the top focus cycle root ancestor.  Check\n-\t    // if it is root.\n-\t    if (ancestor != root)\n+            // We've reached the top focus cycle root ancestor.  Check\n+            // if it is root.\n+            if (ancestor == null)\n+              ancestor = root;\n+            else if (ancestor != root)\n \t      throw new IllegalArgumentException (\"the given container is not\"\n \t\t\t\t\t\t  + \" a focus cycle root of the\"\n \t\t\t\t\t\t  + \" current component\");\n-\t    else\n-\t      break;\n+            else\n+              break;\n \t  }\n \tprevAncestor = ancestor;\n       }\n@@ -136,7 +138,6 @@ public Component getComponentAfter (Container root, Component current)\n       return getFirstComponent ((Container) current);\n \n     Container parent = current.getParent ();\n-\n     synchronized (parent.getTreeLock ())\n       {\n         Component[] components = parent.getComponents ();\n@@ -146,47 +147,104 @@ public Component getComponentAfter (Container root, Component current)\n         // Find component's index.\n         for (int i = 0; i < numComponents; i++)\n           {\n-            if (components[i] == current)\n+            if (components[i].equals(current))\n               componentIndex = i;\n           }\n \n-        // Search forward for the next acceptable component.\n-        for (int i = componentIndex + 1; i < numComponents; i++)\n-          {\n-            if (accept (components[i]))\n-              return components[i];\n+        // Search forward for the next acceptable component.  \n+        // Search through all components at least one time\n+        // i.e. start at componentIndex + 1 --> nComponents -1 --> 0  ---> componentIndex\n+        int i = componentIndex + 1;\n+        int end = numComponents - 1;\n+        Component next = getNextAvailableComponent(components, i, end);\n+        if (next != null)\n+          return next;\n+        \n+        // Now check remainder of components from 0 to componentIndex\n+        i = 0;\n+        end = componentIndex;\n+        next = getNextAvailableComponent(components, i, end);\n+        if (next != null)\n+          return next; \n+        \n+        // No focusable components after current in its Container.  So go\n+        // to the next Component after current's Container (parent).\n+        Component result = getComponentAfter (root, parent);\n+        return result;\n+      }\n+  }\n+  \n+  /**\n+   * Gets the next available component in the array between the given range.\n+   * \n+   * @param components - the array of components.\n+   * @param start - where to start\n+   * @param end - where to end\n+   * @return next component if found\n+   */\n+  private Component getNextAvailableComponent(Component[] components, int start, int end)\n+  {\n+    while (start <= end)\n+      {\n+        Component c = components[start];\n+\n+        if (c.visible && c.isDisplayable() && c.enabled && c.focusable)\n+          return c;\n \n-            if (components[i] instanceof Container)\n-              {\n-                Component result = getFirstComponent ((Container) components[i]);\n+        if (c instanceof Container)\n+          {\n+            Component result = getFirstComponent((Container) c);\n \n-                if (result != null\n-                    && implicitDownCycleTraversal)\n-                  return result;\n-              }\n+            if (result != null && implicitDownCycleTraversal && result.visible\n+                && result.isDisplayable() && result.enabled && result.focusable)\n+              return result;\n           }\n+        start++;\n+      }\n \n-        // No focusable components after current in its Container.  So go\n-        // to the next Component after current's Container (parent).\n-        Component result = getComponentAfter (root, parent);\n+    return null;\n+  }\n \n-        return result;\n+  /**\n+   * Gets the previous available component in the array between the given range.\n+   * \n+   * @param components - the array of components.\n+   * @param start - where to start\n+   * @param end - where to end\n+   * @return previous component if found\n+   */\n+  Component getPrevAvailableComponent(Component[] components, int start, int end)\n+  {\n+    while (start >= end) \n+      {\n+        Component c = components[start];\n+        if (c.visible && c.isDisplayable() && c.enabled && c.focusable)\n+          return c;\n+\n+        if (c instanceof Container)\n+          {\n+            Component result = getLastComponent((Container) c);\n+\n+            if (result != null\n+                && (result.visible && result.isDisplayable() && result.enabled && result.focusable))\n+              return result;\n+          }\n+        start--;\n       }\n+    return null;\n   }\n \n   /**\n    * Returns the Component that should receive the focus before\n-   * <code>current</code>.  <code>root</code> must be a focus cycle\n-   * root of current.\n-   *\n+   * <code>current</code>. <code>root</code> must be a focus cycle root of\n+   * current.\n+   * \n    * @param root a focus cycle root of current\n    * @param current a (possibly indirect) child of root, or root itself\n-   *\n-   * @return the previous Component in the focus traversal order for\n-   * root, or null if no acceptable Component exists.\n-   *\n-   * @exception IllegalArgumentException If root is not a focus cycle\n-   * root of current, or if either root or current is null.\n+   * @return the previous Component in the focus traversal order for root, or\n+   *         null if no acceptable Component exists.\n+   * @exception IllegalArgumentException If root is not a focus cycle root of\n+   *              current, or if either root or current is null.\n    */\n   public Component getComponentBefore (Container root, Component current)\n   {\n@@ -207,7 +265,9 @@ public Component getComponentBefore (Container root, Component current)\n \t  {\n \t    // We've reached the top focus cycle root ancestor.  Check\n \t    // if it is root.\n-\t    if (ancestor != root)\n+            if (ancestor == null)\n+              ancestor = root;\n+            else if (ancestor != root)\n \t      throw new IllegalArgumentException (\"the given container is not\"\n \t\t\t\t\t\t  + \" a focus cycle root of the\"\n \t\t\t\t\t\t  + \" current component\");\n@@ -244,20 +304,20 @@ public Component getComponentBefore (Container root, Component current)\n               componentIndex = i;\n           }\n \n-        // Search backward for the next acceptable component.\n-        for (int i = componentIndex - 1; i >= 0; i--)\n-          {\n-            if (accept (components[i]))\n-              return components[i];\n-\n-            if (components[i] instanceof Container)\n-              {\n-                Component result = getLastComponent ((Container) components[i]);\n-\n-                if (result != null)\n-                  return result;\n-              }\n-          }\n+        // Search through all components at least one time\n+        // i.e. start at componentIndex - 1 --> 0 --> numComponents -1  ---> componentIndex\n+        int i = componentIndex - 1;\n+        int end = 0;\n+        Component prev = getPrevAvailableComponent(components, i, end);\n+        if (prev != null)\n+          return prev;\n+        \n+        // Now check remainder of components\n+        i = numComponents -1;\n+        end = componentIndex;\n+        prev = getPrevAvailableComponent(components, i, end);\n+        if (prev != null)\n+          return prev; \n \n         // No focusable components before current in its Container.  So go\n         // to the previous Component before current's Container (parent).\n@@ -286,7 +346,8 @@ public Component getFirstComponent(Container root)\n         || !root.isDisplayable ())\n       return null;\n \n-    if (accept (root))\n+    if (root.visible && root.isDisplayable() && root.enabled\n+        && root.focusable)\n       return root;\n \n     Component[] componentArray = root.getComponents ();\n@@ -295,14 +356,16 @@ public Component getFirstComponent(Container root)\n       {\n         Component component = componentArray [i];\n \t\n-\tif (accept (component))\n+\tif (component.visible && component.isDisplayable() && component.enabled\n+            && component.focusable)\n \t  return component;\n \n         if (component instanceof Container)\n           {\n             Component result = getFirstComponent ((Container) component);\n \n-            if (result != null)\n+            if (result != null\n+                && (result.visible && result.isDisplayable() && result.enabled && result.focusable))\n               return result;\n           }\n       }\n@@ -329,7 +392,8 @@ public Component getLastComponent (Container root)\n         || !root.isDisplayable ())\n       return null;\n \n-    if (accept (root))\n+    if (root.visible && root.isDisplayable() && root.enabled\n+        && root.focusable)\n       return root;\n \n     Component[] componentArray = root.getComponents ();\n@@ -338,14 +402,17 @@ public Component getLastComponent (Container root)\n       {\n         Component component = componentArray [i];\n \t\n-\tif (accept (component))\n+\tif (component.visible && component.isDisplayable() && component.enabled\n+            && component.focusable)\n \t  return component;\n \n         if (component instanceof Container)\n           {\n             Component result = getLastComponent ((Container) component);\n \n-            if (result != null)\n+            if (result != null &&\n+                result.visible && result.isDisplayable() && result.enabled\n+                && result.focusable)\n               return result;\n           }\n       }"}, {"sha": "037cb834c40d778db8086da9abbe6fc91e86873c", "filename": "libjava/classpath/java/awt/DefaultKeyboardFocusManager.java", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FDefaultKeyboardFocusManager.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -274,10 +274,12 @@ private boolean enqueueKeyEvent (KeyEvent e)\n \n   public boolean dispatchKeyEvent (KeyEvent e)\n   {\n-    Component focusOwner = getGlobalPermanentFocusOwner ();\n-\n+    Component focusOwner = getFocusOwner();\n+    if (focusOwner == null)\n+      focusOwner = getFocusedWindow();\n+    \n     if (focusOwner != null)\n-      redispatchEvent(focusOwner, e);\n+      redispatchEvent(focusOwner, e);      \n \n     // Loop through all registered KeyEventPostProcessors, giving\n     // each a chance to process this event.\n@@ -294,7 +296,7 @@ public boolean dispatchKeyEvent (KeyEvent e)\n     // MenuShortcut.\n     if (postProcessKeyEvent (e))\n       return true;\n-\n+    \n     // Always return true.\n     return true;\n   }"}, {"sha": "7cb8af831bf9fe8cfd158d861c9e56e9890b8e86", "filename": "libjava/classpath/java/awt/EventDispatchThread.java", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FEventDispatchThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FEventDispatchThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FEventDispatchThread.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -43,6 +43,11 @@\n  */\n class EventDispatchThread extends Thread\n {\n+  /**\n+   * The default priority when no property has been set.\n+   */\n+  private static final int DEFAULT_PRIORITY = NORM_PRIORITY + 1;\n+\n   private static int dispatchThreadNum;\n \n   private EventQueue queue;\n@@ -52,7 +57,22 @@ class EventDispatchThread extends Thread\n     super();\n     setName(\"AWT-EventQueue-\" + ++dispatchThreadNum);\n     this.queue = queue;\n-    setPriority(NORM_PRIORITY + 1);\n+\n+    int priority = DEFAULT_PRIORITY;\n+    try\n+      {\n+        String priorityString =\n+          System.getProperty(\"gnu.awt.dispatchthread.priority\");\n+        if (priorityString != null)\n+          {\n+            priority = Integer.parseInt(priorityString); \n+          }      \n+      }\n+    catch (NumberFormatException ex)\n+      {\n+        // Ignore and use default.\n+      }\n+    setPriority(priority);\n   }\n \n   public void run()"}, {"sha": "a52f63408dab67c4c073b904fdd467de8b464bf4", "filename": "libjava/classpath/java/awt/Font.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FFont.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FFont.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FFont.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1013,7 +1013,7 @@ public int getMissingGlyphCode()\n    */\n   public int getNumGlyphs()\n   {\n-    return peer.getMissingGlyphCode(this);\n+    return peer.getNumGlyphs(this);\n   }\n \n   /**"}, {"sha": "b3ecbc58a984c3c7099fdd59a62ee3af6b2a6f08", "filename": "libjava/classpath/java/awt/Graphics2D.java", "status": "modified", "additions": 212, "deletions": 10, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FGraphics2D.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000, 2002, 2004  Free Software Foundation\n+/* Copyright (C) 2000, 2002, 2004, 2006,  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -45,10 +45,35 @@\n import java.awt.image.ImageObserver;\n import java.awt.image.RenderedImage;\n import java.awt.image.renderable.RenderableImage;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n import java.text.AttributedCharacterIterator;\n import java.util.Map;\n \n /**\n+ * An abstract class defining a device independent two-dimensional vector \n+ * graphics API.  Concrete subclasses implement this API for output of \n+ * vector graphics to: (*)\n+ * <p>\n+ * <ul>\n+ * <li>a {@link javax.swing.JComponent} - in the \n+ *     {@link javax.swing.JComponent#paint(Graphics)} method, the incoming \n+ *     {@link Graphics} should always be an instance of \n+ *     <code>Graphics2D</code> (*);</li> \n+ * <li>a {@link BufferedImage} - see \n+ *     {@link BufferedImage#createGraphics()} (*);</li>\n+ * <li>a {@link java.awt.print.PrinterJob} - in the \n+ *     {@link Printable#print(Graphics, PageFormat, int)} method, the incoming\n+ *     {@link Graphics} should always be an instance of <code>Graphics2D</code>\n+ *     (*).</li>\n+ * </ul>\n+ * <p>\n+ * (*) Support for this API is not fully implemented in GNU Classpath yet.\n+ * <p>\n+ * Third party libraries provide support for output to other formats via this \n+ * API, including encapsulated postscript (EPS), portable document format (PDF),\n+ * and scalable vector graphics (SVG).\n+ * \n  * @author Rolf W. Rasmussen (rolfwr@ii.uib.no)\n  */\n public abstract class Graphics2D extends Graphics\n@@ -70,6 +95,14 @@ public void fill3DRect(int x, int y, int width, int height,\n     super.fill3DRect(x, y, width, height, raised);\n   }\n \n+  /**\n+   * Draws an outline around a shape using the current stroke and paint.\n+   * \n+   * @param shape  the shape (<code>null</code> not permitted).\n+   * \n+   * @see #getStroke()\n+   * @see #getPaint()\n+   */\n   public abstract void draw(Shape shape);\n \n   public abstract boolean drawImage(Image image, AffineTransform xform,\n@@ -86,40 +119,130 @@ public abstract void drawRenderedImage(RenderedImage image,\n   public abstract void drawRenderableImage(RenderableImage image,\n                                            AffineTransform xform);\n \n+  /**\n+   * Draws a string at the specified location, using the current font.\n+   * \n+   * @param text  the string to draw.\n+   * @param x  the x-coordinate.\n+   * @param y  the y-coordinate.\n+   * \n+   * @see Graphics#setFont(Font)\n+   */\n   public abstract void drawString(String text, int x, int y);\n \n+  /**\n+   * Draws a string at the specified location, using the current font.\n+   * \n+   * @param text  the string to draw.\n+   * @param x  the x-coordinate.\n+   * @param y  the y-coordinate.\n+   * \n+   * @see Graphics#setFont(Font)\n+   */\n   public abstract void drawString(String text, float x, float y);\n     \n+  /**\n+   * Draws an attributed string at the specified location.\n+   * \n+   * @param iterator  the source of the attributed text.\n+   * @param x  the x-coordinate.\n+   * @param y  the y-coordinate.\n+   */\n   public abstract void drawString(AttributedCharacterIterator iterator,\n                                   int x, int y);\n \n+  /**\n+   * Draws an attributed string at the specified location.\n+   * \n+   * @param iterator  the source of the attributed text.\n+   * @param x  the x-coordinate.\n+   * @param y  the y-coordinate.\n+   */\n   public abstract void drawString(AttributedCharacterIterator iterator,\n \t\t\t\t  float x, float y);\n \n-  // public abstract void drawGlyphVector(GlyphVector g, float x, float y);\n-\n+  /**\n+   * Fills the interior of the specified <code>shape</code> using the current\n+   * paint.\n+   * \n+   * @param shape  the shape to fill (<code>null</code> not permitted).\n+   * \n+   * @see #draw(Shape)\n+   * @see #getPaint()\n+   */\n   public abstract void fill(Shape shape);\n     \n   public abstract boolean hit(Rectangle rect, Shape text,\n \t\t\t      boolean onStroke);\n \n   public abstract GraphicsConfiguration getDeviceConfiguration();\n \n+  /**\n+   * Sets the current compositing rule.\n+   * \n+   * @param comp  the composite.\n+   * \n+   * @see #getComposite()\n+   */\n   public abstract void setComposite(Composite comp);\n-    \n+\n+  /**\n+   * Sets the paint to be used for subsequent drawing operations.\n+   * \n+   * @param paint  the paint (<code>null</code> not permitted).\n+   * \n+   * @see #getPaint()\n+   */\n   public abstract void setPaint(Paint paint);\n \n+  /**\n+   * Sets the stroke to be used for subsequent drawing operations.\n+   * \n+   * @param stroke  the stroke (<code>null</code> not permitted).\n+   * \n+   * @see #getStroke()\n+   */\n   public abstract void setStroke(Stroke stroke);\n \n+  /**\n+   * Adds or updates a hint in the current rendering hints table.\n+   * \n+   * @param hintKey  the hint key.\n+   * @param hintValue  the hint value.\n+   */\n   public abstract void setRenderingHint(RenderingHints.Key hintKey,\n                                         Object hintValue);\n \n+  /**\n+   * Returns the current value of a rendering hint.\n+   * \n+   * @param hintKey  the key for the hint.\n+   * \n+   * @return The value for the specified hint.\n+   */\n   public abstract Object getRenderingHint(RenderingHints.Key hintKey);\n   \n+  /**\n+   * Replaces the current rendering hints with the supplied hints.\n+   * \n+   * @param hints  the hints.\n+   * \n+   * @see #addRenderingHints(Map)\n+   */\n   public abstract void setRenderingHints(Map hints);\n \n+  /**\n+   * Adds/updates the rendering hint.\n+   * \n+   * @param hints  the hints to add or update.\n+   */\n   public abstract void addRenderingHints(Map hints);\n \n+  /**\n+   * Returns the current rendering hints.\n+   * \n+   * @return The current rendering hints.\n+   */\n   public abstract RenderingHints getRenderingHints();\n \n   public abstract void translate(int x, int y);\n@@ -134,25 +257,104 @@ public abstract void setRenderingHint(RenderingHints.Key hintKey,\n \n   public abstract void shear(double shearX, double shearY);\n \n-  public abstract void transform(AffineTransform Tx);\n+  /**\n+   * Sets the current transform to a concatenation of <code>transform</code>\n+   * and the existing transform.\n+   * \n+   * @param transform  the transform.\n+   */\n+  public abstract void transform(AffineTransform transform);\n   \n-  public abstract void setTransform(AffineTransform Tx);\n-\n+  /**\n+   * Sets the current transform.  If the caller specifies a <code>null</code>\n+   * transform, this method should set the current transform to the \n+   * identity transform.\n+   * \n+   * @param transform  the transform (<code>null</code> permitted).\n+   * \n+   * @see #getTransform()\n+   */\n+  public abstract void setTransform(AffineTransform transform);\n+\n+  /**\n+   * Returns the current transform.\n+   * \n+   * @return The current transform.\n+   * \n+   * @see #setTransform(AffineTransform)\n+   */\n   public abstract AffineTransform getTransform();\n \n+  /**\n+   * Returns the current paint.\n+   * \n+   * @return The current paint.\n+   * \n+   * @see #setPaint(Paint)\n+   */\n   public abstract Paint getPaint();\n \n+  /**\n+   * Returns the current compositing rule.\n+   * \n+   * @return The current compositing rule.\n+   * \n+   * @see #setComposite(Composite)\n+   */\n   public abstract Composite getComposite();\n \n+  /**\n+   * Sets the background color (used by the \n+   * {@link Graphics#clearRect(int, int, int, int)} method).\n+   * \n+   * @param color  the color.\n+   * \n+   * @see #getBackground()\n+   */\n   public abstract void setBackground(Color color);\n \n+  /**\n+   * Returns the color used by the \n+   * {@link Graphics#clearRect(int, int, int, int)} method.\n+   * \n+   * @return The background color.\n+   * \n+   * @see #setBackground(Color)\n+   */\n   public abstract Color getBackground();\n \n+  /**\n+   * Returns the current stroke.\n+   * \n+   * @return The current stroke.\n+   * \n+   * @see #setStroke(Stroke)\n+   */\n   public abstract Stroke getStroke();    \n \n+  /**\n+   * Sets the clip region to the intersection of the current clipping region \n+   * and <code>s</code>.\n+   * \n+   * @param s  the shape to intersect with the current clipping region.\n+   * \n+   * @see Graphics#setClip(Shape)\n+   */\n   public abstract void clip(Shape s);\n \n-  public abstract FontRenderContext getFontRenderContext ();\n-\n-  public abstract void drawGlyphVector (GlyphVector g, float x, float y);\n+  /**\n+   * Returns the font render context.\n+   * \n+   * @return The font render context.\n+   */\n+  public abstract FontRenderContext getFontRenderContext();\n+\n+  /**\n+   * Draws a glyph vector at the specified location.\n+   * \n+   * @param g  the glyph vector.\n+   * @param x  the x-coordinate.\n+   * @param y  the y-coordinate.\n+   */\n+  public abstract void drawGlyphVector(GlyphVector g, float x, float y);\n }"}, {"sha": "792b2cc1b2bb946c3d658d43be06c51893bb4ae1", "filename": "libjava/classpath/java/awt/GraphicsConfiguration.java", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FGraphicsConfiguration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FGraphicsConfiguration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FGraphicsConfiguration.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -65,6 +65,13 @@\n  */\n public abstract class GraphicsConfiguration\n {\n+  \n+  /** The cached image capabilities. */\n+  private ImageCapabilities imageCapabilities;\n+  \n+  /** The cached buffer capabilities. */\n+  private BufferCapabilities bufferCapabilities;\n+  \n   /**\n    * The default constructor.\n    *\n@@ -218,9 +225,14 @@ public abstract BufferedImage createCompatibleImage(int w, int h,\n    * @since 1.4\n    */\n   public BufferCapabilities getBufferCapabilities()\n-    throws NotImplementedException\n   {\n-    throw new Error(\"not implemented\");\n+    if (imageCapabilities == null)\n+      getImageCapabilities();\n+    \n+    if (bufferCapabilities == null)\n+      bufferCapabilities = new BufferCapabilities(imageCapabilities,\n+                                                  imageCapabilities, null);\n+    return bufferCapabilities;\n   }\n \n   /**\n@@ -230,8 +242,9 @@ public BufferCapabilities getBufferCapabilities()\n    * @since 1.4\n    */\n   public ImageCapabilities getImageCapabilities()\n-    throws NotImplementedException\n   {\n-    throw new Error(\"not implemented\");\n+    if (imageCapabilities == null)\n+      imageCapabilities = new ImageCapabilities(false);\n+    return imageCapabilities;\n   }\n } // class GraphicsConfiguration"}, {"sha": "7e33bd4e9cecb1f76e3e55cbab7377cc2bf5d202", "filename": "libjava/classpath/java/awt/LightweightDispatcher.java", "status": "modified", "additions": 138, "deletions": 27, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FLightweightDispatcher.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FLightweightDispatcher.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FLightweightDispatcher.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,8 +38,6 @@\n \n package java.awt;\n \n-import gnu.java.awt.AWTUtilities;\n-\n import java.awt.event.MouseEvent;\n import java.util.WeakHashMap;\n \n@@ -67,6 +65,13 @@\n    * as well as the MOUSE_RELEASED event following the dragging.\n    */\n   private Component dragTarget;\n+  \n+  /**\n+   * Stores the button number which started the drag operation. This is needed\n+   * because we want to handle only one drag operation and only the button that\n+   * started the dragging should be able to stop it (by a button release).\n+   */\n+  private int dragButton;\n \n   /**\n    * The last mouse event target. If the target changes, additional\n@@ -121,15 +126,41 @@ public boolean dispatchEvent(AWTEvent event)\n   /**\n    * Handles all mouse events that are targetted at toplevel containers\n    * (Window instances) and dispatches them to the correct lightweight child.\n-   *\n+   * \n    * @param ev the mouse event\n    * @return whether or not we found a lightweight that handled the event.\n    */\n   private boolean handleMouseEvent(MouseEvent ev)\n   {\n     Window window = (Window) ev.getSource();\n-    Component target = window.findComponentAt(ev.getX(), ev.getY());\n-    target = findTarget(target);\n+    // Find the target for the mouse event. We first seach the deepest\n+    // component at the specified location. The we go up to its parent and\n+    // try to find a neighbor of the deepest component that is suitable as\n+    // mouse event target (it must be showing, at that location and have either\n+    // a MouseListener or MouseMotionListener installed). If no such component\n+    // is found, then we walk up the container hierarchy and find the next\n+    // container that has a MouseListener or MouseMotionListener installed.\n+    Component deepest = window.findComponentAt(ev.getX(), ev.getY());\n+    if (deepest == null)\n+      return false;\n+    Container parent = deepest.getParent();\n+    Point loc = ev.getPoint();\n+    loc = convertPointToChild(window, loc, parent);\n+    Component target = null;\n+    if (parent != null)\n+      {\n+        target = findTarget(parent, loc);\n+        while (target == null && parent != null)\n+          {\n+            if (parent.getMouseListeners().length > 0\n+                || parent.getMouseMotionListeners().length > 0)\n+              {\n+                target = parent;\n+              }\n+            else\n+              parent = parent.getParent();\n+          }\n+      }\n     if (target == null || target.isLightweight())\n       {\n         // Dispatch additional MOUSE_EXITED and MOUSE_ENTERED if event target\n@@ -138,18 +169,26 @@ private boolean handleMouseEvent(MouseEvent ev)\n           {\n             if (lastTarget != null)\n               {\n-                Point p1 = AWTUtilities.convertPoint(window, ev.getX(),\n-                                                     ev.getY(), lastTarget);\n+                Point p1 = convertPointToChild(window, ev.getPoint(),\n+                                               lastTarget);\n                 MouseEvent mouseExited =\n                   new MouseEvent(lastTarget, MouseEvent.MOUSE_EXITED,\n                                  ev.getWhen(), ev.getModifiers(), p1.x, p1.y,\n                                  ev.getClickCount(), ev.isPopupTrigger());\n                 lastTarget.dispatchEvent(mouseExited);\n               }\n-            if (target != null)\n+            \n+            // If a target exists dispatch the MOUSE_ENTERED event only if\n+            // there is currently no component from which a drag operation\n+            // started (dragTarget == null) or the target is that component\n+            // (dragTarget == target)\n+            // That way a user can click and hold on a button (putting it into\n+            // the armed state), move the cursor above other buttons without\n+            // affecting their rollover state and get back to the initial\n+            // button.\n+            if (target != null && (dragTarget == null || dragTarget == target))\n               {\n-                Point p = AWTUtilities.convertPoint(window, ev.getX(), ev.getY(),\n-                                                    target);\n+                Point p = convertPointToChild(window, ev.getPoint(), target);\n                 MouseEvent mouseEntered =\n                   new MouseEvent(target, MouseEvent.MOUSE_ENTERED, ev.getWhen(),\n                                  ev.getModifiers(), p.x, p.y, ev.getClickCount(),\n@@ -161,40 +200,66 @@ private boolean handleMouseEvent(MouseEvent ev)\n         switch (ev.getID())\n         {\n           case MouseEvent.MOUSE_PRESSED:\n-            dragTarget = target;\n+            // Handle the start of a drag operation or discard the event if\n+            // one is already in progress. This prevents focus changes with the\n+            // other mouse buttons when one is used for dragging.\n+            if (dragTarget == null)\n+              {\n+                lastTarget = dragTarget = target;\n+                \n+                // Save the button that started the drag operation.\n+                dragButton = ev.getButton();\n+              }\n+            else\n+              return false;\n+            \n             break;\n           case MouseEvent.MOUSE_RELEASED:\n-            if (dragTarget != null)\n-              target = dragTarget;\n-            dragTarget = null;\n+            // Stop the drag operation only when the button that started\n+            // it was released.\n+            if (dragTarget != null && dragButton == ev.getButton())\n+              {\n+                target = dragTarget;\n+                dragTarget = null;\n+              }\n+            \n+            lastTarget = target;\n             break;\n           case MouseEvent.MOUSE_CLICKED:\n             // When we receive a MOUSE_CLICKED, we set the target to the\n             // previous target, which must have been a MOUSE_RELEASED event.\n             // This is necessary for the case when the MOUSE_RELEASED has\n             // caused the original target (like an internal component) go\n             // away.\n+            // This line is the reason why it is not possible to move the\n+            // 'lastTarget = target' assignment before the switch-statement.\n             target = lastTarget;\n             break;\n           case MouseEvent.MOUSE_DRAGGED:\n+            // We consider only dragTarget for redispatching the event still\n+            // we have to act in a way that the newly found target component\n+            // was handled.\n+            lastTarget = target;\n             target = dragTarget;\n             break;\n           default:\n-            // Do nothing in other cases.\n+            // Only declare current target as the old value in all other\n+            // cases.\n+            lastTarget = target;\n             break;\n         }\n \n-        lastTarget = target;\n-\n         if (target != null)\n           {\n-            Point targetCoordinates =\n-              AWTUtilities.convertPoint(window, ev.getX(), ev.getY(), target);\n+            Point targetCoordinates = convertPointToChild(window,\n+                                                          ev.getPoint(),\n+                                                          target);\n             int dx = targetCoordinates.x - ev.getX();\n             int dy = targetCoordinates.y - ev.getY();\n             ev.translatePoint(dx, dy);\n             ev.setSource(target);\n             target.dispatchEvent(ev);\n+            \n             // We reset the event, so that the normal event dispatching is not\n             // influenced by this modified event.\n             ev.setSource(window);\n@@ -209,20 +274,66 @@ private boolean handleMouseEvent(MouseEvent ev)\n \n   /**\n    * Finds the actual target for a mouseevent, starting at <code>c</code>.\n-   * This searches upwards the component hierarchy until it finds a component\n-   * that has a mouselistener attached.\n+   * This searches through the children of the container and finds the first\n+   * one which is showing, at the location from the mouse event and has\n+   * a MouseListener or MouseMotionListener attached. If no such child component\n+   * is found, null is returned.\n    *\n-   * @param c the component to start searching from\n+   * @param c the container to search through\n+   * @param loc the mouse event point\n    *\n-   * @return the actual receiver of the mouse event\n+   * @return the actual receiver of the mouse event, or null, if no such\n+   *         component has been found\n    */\n-  private Component findTarget(Component c)\n+  private Component findTarget(Container c, Point loc)\n   {\n-    Component target = c;\n-    while (target != null && target.getMouseListeners().length == 0)\n+    Component[] children = c.getComponents();\n+    Component target = null;\n+    if (c != null)\n       {\n-        target = target.getParent();\n+        for (int i = 0; i < children.length; i++)\n+          {\n+            Component child = children[i];\n+            if (child.isShowing())\n+              {\n+                if (child.contains(loc.x - child.getX(), loc.y - child.getY())\n+                    && (child.getMouseListeners().length > 0 \n+                        || child.getMouseMotionListeners().length > 0))\n+                  {\n+                    target = child;\n+                    break;\n+                  }\n+              }\n+          }\n       }\n     return target;\n   }\n+\n+  /**\n+   * Converts a point in the parent's coordinate system to a child coordinate\n+   * system. The resulting point is stored in the same Point object and\n+   * returned.\n+   *\n+   * @param parent the parent component\n+   * @param p the point\n+   * @param child the child component\n+   *\n+   * @return the translated point\n+   */\n+  private Point convertPointToChild(Component parent, Point p,\n+                                   Component child)\n+  {\n+    int offX = 0;\n+    int offY = 0;\n+    Component comp = child;\n+    while (comp != null && comp != parent)\n+      {\n+        offX += comp.getX();\n+        offY += comp.getY();\n+        comp = comp.getParent();\n+      }\n+    p.x -= offX;\n+    p.y -= offY;\n+    return p;\n+  }\n }"}, {"sha": "387ccb0fd8498573873cf82ec81bb66d95bd5a2b", "filename": "libjava/classpath/java/awt/TexturePaint.java", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FTexturePaint.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FTexturePaint.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FTexturePaint.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,42 +38,81 @@\n \n package java.awt;\n \n-import gnu.classpath.NotImplementedException;\n+import gnu.java.awt.java2d.TexturePaintContext;\n \n import java.awt.geom.AffineTransform;\n import java.awt.geom.Rectangle2D;\n import java.awt.image.BufferedImage;\n import java.awt.image.ColorModel;\n \n-/** STUB CLASS ONLY */\n+/**\n+ * This class provides a way to fill a Shape with a texture that is\n+ * specified by a BufferedImage.\n+ */\n public class TexturePaint implements Paint\n {\n   private final BufferedImage texture;\n   private final Rectangle2D anchor;\n+  \n+  /**\n+   * Constructor.\n+   * \n+   * @param texture - the texture\n+   * @param anchor - the shape\n+   */\n   public TexturePaint(BufferedImage texture, Rectangle2D anchor)\n   {\n     this.texture = texture;\n     this.anchor = anchor;\n   }\n+\n+  /**\n+   * Gets the texture image.\n+   * \n+   * @return the texture\n+   */\n   public BufferedImage getImage()\n   {\n     return texture;\n   }\n+\n+  /**\n+   * Gets the shape anchor.\n+   * \n+   * @return the shape anchor\n+   */\n   public Rectangle2D getAnchorRect()\n   {\n     return anchor;\n   }\n+\n+  /**\n+   * Creates the context used to paint the texture.\n+   * \n+   * @param cm - the ColorModel that receives the Paint data. Used only as a hint.\n+   * @param deviceBounds - the device space being rendered.\n+   * @param userBounds - the user space being rendered\n+   * @param xform - the AffineTransform from user space into device space\n+   * @param hints - a RenderingHints object that is used to specify how the \n+   * pattern is rendered\n+   * @return the paint context used to paint the texture\n+   */\n   public PaintContext createContext(ColorModel cm, Rectangle deviceBounds,\n                                     Rectangle2D userBounds,\n-                                    AffineTransform xform,\n-                                    RenderingHints hints)\n-    throws NotImplementedException\n+                                    AffineTransform xform, RenderingHints hints)\n   {\n-    throw new Error(\"not implemented\");\n+    // TODO: Maybe add some hook for providing alternative/accelerated\n+    // implementations of this.\n+    return new TexturePaintContext(this, deviceBounds, userBounds, xform);\n   }\n+\n+  /**\n+   * Returns the transparency mode.\n+   * \n+   * @return the transparency mode.\n+   */\n   public int getTransparency()\n-    throws NotImplementedException\n   {\n-    throw new Error(\"not implemented\");\n+    return texture.getTransparency();\n   }\n } // class TexturePaint"}, {"sha": "282e50d2c507da99fa3ba8428c6bdfbcfb967e74", "filename": "libjava/classpath/java/awt/Toolkit.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FToolkit.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -544,7 +544,7 @@ public Object run()\n                 return ClassLoader.getSystemClassLoader();\n               }\n           });\n-        Class cls = cl.loadClass(toolkit_name);\n+        Class cls = Class.forName(toolkit_name, true, cl);\n         Object obj = cls.newInstance();\n         if (!(obj instanceof Toolkit))\n           throw new AWTError(toolkit_name + \" is not a subclass of \" +"}, {"sha": "8bc4715aed515ae1ecb8deeb2060002bf11b24cf", "filename": "libjava/classpath/java/awt/Window.java", "status": "modified", "additions": 64, "deletions": 32, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2FWindow.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,8 +38,6 @@\n \n package java.awt;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.event.ComponentEvent;\n import java.awt.event.FocusEvent;\n import java.awt.event.WindowAdapter;\n@@ -132,33 +130,7 @@ public AccessibleStateSet getAccessibleStateSet()\n     // cycle roots.\n     focusCycleRoot = true;\n     setLayout(new BorderLayout());\n-\n-    addWindowFocusListener (new WindowAdapter ()\n-      {\n-        public void windowGainedFocus (WindowEvent event)\n-        {\n-          if (windowFocusOwner != null)\n-            {\n-              // FIXME: move this section and the other similar\n-              // sections in Component into a separate method.\n-              EventQueue eq = Toolkit.getDefaultToolkit ().getSystemEventQueue ();\n-              synchronized (eq)\n-                {\n-                  KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager ();\n-                  Component currentFocusOwner = manager.getGlobalPermanentFocusOwner ();\n-                  if (currentFocusOwner != null)\n-                    {\n-                      eq.postEvent (new FocusEvent (currentFocusOwner, FocusEvent.FOCUS_LOST,\n-                                                    false, windowFocusOwner));\n-                      eq.postEvent (new FocusEvent (windowFocusOwner, FocusEvent.FOCUS_GAINED,\n-                                                    false, currentFocusOwner));\n-                    }\n-                  else\n-                    eq.postEvent (new FocusEvent (windowFocusOwner, FocusEvent.FOCUS_GAINED, false));\n-                }\n-            }\n-        }\n-      });\n+    addWindowFocusListener();\n     \n     GraphicsEnvironment g = GraphicsEnvironment.getLocalGraphicsEnvironment();\n     graphicsConfiguration = g.getDefaultScreenDevice().getDefaultConfiguration();\n@@ -169,7 +141,68 @@ public void windowGainedFocus (WindowEvent event)\n     this();\n     graphicsConfiguration = gc;\n   }\n+  \n+  private void addWindowFocusListener()\n+  {\n+    addWindowFocusListener(new WindowAdapter()\n+    {\n+      public void windowGainedFocus(WindowEvent event)\n+      {\n+        EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+        if (windowFocusOwner != null)\n+          {\n+            synchronized (eq)\n+              {\n+                KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n+                Component currentFocusOwner = manager.getGlobalPermanentFocusOwner();\n+                if (currentFocusOwner != null)\n+                  {\n+                    eq.postEvent(new FocusEvent(currentFocusOwner,\n+                                                FocusEvent.FOCUS_LOST, false,\n+                                                windowFocusOwner));\n+                    eq.postEvent(new FocusEvent(windowFocusOwner,\n+                                                FocusEvent.FOCUS_GAINED, false,\n+                                                currentFocusOwner));\n+                  }\n+                else\n+                  eq.postEvent(new FocusEvent(windowFocusOwner,\n+                                              FocusEvent.FOCUS_GAINED, false));\n+              }\n+          }\n+        else\n+          eq.postEvent(new FocusEvent(Window.this, FocusEvent.FOCUS_GAINED,\n+                                      false));\n+      }\n \n+      public void windowLostFocus(WindowEvent event)\n+      {\n+        EventQueue eq = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+        if (windowFocusOwner != null)\n+          {\n+            synchronized (eq)\n+              {\n+                KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n+                Component currentFocusOwner = manager.getGlobalPermanentFocusOwner();\n+                if (currentFocusOwner != null)\n+                  {\n+                    eq.postEvent(new FocusEvent(currentFocusOwner,\n+                                                FocusEvent.FOCUS_GAINED, false,\n+                                                windowFocusOwner));\n+                    eq.postEvent(new FocusEvent(windowFocusOwner,\n+                                                FocusEvent.FOCUS_LOST, false,\n+                                                currentFocusOwner));\n+                  }\n+                else\n+                  eq.postEvent(new FocusEvent(windowFocusOwner,\n+                                              FocusEvent.FOCUS_LOST, false));\n+              }\n+          }\n+        else\n+          eq.postEvent(new FocusEvent(Window.this, FocusEvent.FOCUS_LOST, false));\n+      }\n+    });\n+  }\n+  \n   /**\n    * Initializes a new instance of <code>Window</code> with the specified\n    * parent.  The window will initially be invisible.\n@@ -1046,12 +1079,11 @@ public BufferStrategy getBufferStrategy()\n   /**\n    * @since 1.2\n    *\n-   * @deprecated\n+   * @deprecated replaced by Component.applyComponentOrientation.\n    */\n   public void applyResourceBundle(ResourceBundle rb)\n-    throws NotImplementedException\n   {\n-    throw new Error (\"Not implemented\");\n+    applyComponentOrientation(ComponentOrientation.getOrientation(rb));\n   }\n \n   /**"}, {"sha": "145a24a38508132cb8237373e5232ce7b981971e", "filename": "libjava/classpath/java/awt/dnd/DragGestureRecognizer.java", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fdnd%2FDragGestureRecognizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fdnd%2FDragGestureRecognizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Fdnd%2FDragGestureRecognizer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* DragGestureRecognizer.java --\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002,2006 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -130,7 +130,7 @@ public InputEvent getTriggerEvent()\n   public void resetRecognizer()\n     throws NotImplementedException\n   {\n-    throw new Error(\"not implemented\");\n+    events = new ArrayList();\n   }\n \n   /**\n@@ -154,10 +154,15 @@ public void removeDragGestureListener(DragGestureListener dgl)\n     dragGestureListener = null;\n   }\n \n+  /**\n+   * Fires a <code>DragGestureEvent</code> to the DragGestureListener\n+   * associated with this object, if there is one.\n+   */\n   protected void fireDragGestureRecognized(int dragAction, Point p)\n-    throws NotImplementedException\n   {\n-    throw new Error(\"not implemented\");\n+    if(dragGestureListener != null)\n+      dragGestureListener.dragGestureRecognized\n+\t(new DragGestureEvent(this, dragAction, p, events));\n   }\n \n   protected void appendEvent(InputEvent e)"}, {"sha": "0a78d3052f66ed9e2dd814d9527440c4726f657e", "filename": "libjava/classpath/java/awt/font/GlyphMetrics.java", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGlyphMetrics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGlyphMetrics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGlyphMetrics.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,8 +38,6 @@\n \n package java.awt.font;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.geom.Rectangle2D;\n \n /**\n@@ -94,16 +92,18 @@ public Rectangle2D getBounds2D ()\n     return bounds;\n   }\n \n-  public float getLSB ()\n-    throws NotImplementedException\n+  public float getLSB()\n   {\n-    throw new Error (\"not implemented\");\n+    if (horizontal)\n+      return (float) bounds.getX();\n+    return (float) bounds.getY();\n   }\n \n-  public float getRSB ()\n-   throws NotImplementedException\n+  public float getRSB()\n   {\n-    throw new Error (\"not implemented\");\n+    if (horizontal)\n+      return (float) (advanceX - (bounds.getX() + bounds.getWidth()));\n+    return (float) (advanceY - (bounds.getY() + bounds.getHeight()));\n   }\n \n   public int getType ()"}, {"sha": "f4cb01b95349e6279754a5eb6df78e3db0113bd2", "filename": "libjava/classpath/java/awt/font/GlyphVector.java", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGlyphVector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGlyphVector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGlyphVector.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,8 +38,6 @@\n \n package java.awt.font;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.Font;\n import java.awt.Rectangle;\n import java.awt.Shape;\n@@ -48,6 +46,7 @@\n import java.awt.geom.Rectangle2D;\n \n /**\n+ * @author Lillian Angel (langel at redhat dot com)\n  * @author Michael Koch\n  */\n public abstract class GlyphVector implements Cloneable\n@@ -72,16 +71,22 @@ public GlyphVector ()\n   public abstract FontRenderContext getFontRenderContext ();\n     \n   public int getGlyphCharIndex (int glyphIndex)\n-    throws NotImplementedException\n   {\n-    throw new Error (\"not implemented\");\n+    return glyphIndex;\n   }\n     \n-  public int[] getGlyphCharIndices (int beginGlyphIndex, int numEntries,\n-                                    int[] codeReturn)\n-    throws NotImplementedException\n+  public int[] getGlyphCharIndices(int beginGlyphIndex, int numEntries,\n+                                   int[] codeReturn)\n   {\n-    throw new Error (\"not implemented\");\n+    if (codeReturn == null)\n+      codeReturn = new int[numEntries];\n+\n+    int i = 0;\n+    int j = beginGlyphIndex;\n+    while (j < numEntries)\n+      codeReturn[i++] = getGlyphCharIndex(j++);\n+    \n+    return codeReturn;\n   }\n     \n   public abstract int getGlyphCode (int glyphIndex);\n@@ -98,17 +103,27 @@ public abstract int[] getGlyphCodes (int beginGlyphIndex, int numEntries,\n \n   public abstract Shape getGlyphOutline (int glyphIndex);\n \n-  public Shape getGlyphOutline (int glyphIndex, float x, float y)\n-    throws NotImplementedException\n+  public Shape getGlyphOutline(int glyphIndex, float x, float y)\n   {\n-    throw new Error (\"not implemented\");\n+    Shape s = getGlyphOutline(glyphIndex);\n+    \n+    // This is the only way to translate the origin of a shape\n+    AffineTransform at = AffineTransform.getTranslateInstance(x, y);\n+    return at.createTransformedShape(s);\n   }\n \n-  public Rectangle getGlyphPixelBounds (int index, FontRenderContext renderFRC,\n-                                        float x, float y)\n-    throws NotImplementedException\n+  public Rectangle getGlyphPixelBounds(int index, FontRenderContext renderFRC,\n+                                       float x, float y)\n   {\n-    throw new Error (\"not implemented\");\n+    Rectangle bounds = new Rectangle();\n+    Rectangle2D rect = getGlyphVisualBounds(index).getBounds2D();\n+    \n+    bounds.x = (int) (rect.getX() + x);\n+    bounds.y = (int) (rect.getY() + y);\n+    bounds.width = (int) rect.getMaxX() - bounds.x;\n+    bounds.height = (int) rect.getMaxY() - bounds.y;\n+    \n+    return bounds;\n   }\n \n   public abstract Point2D getGlyphPosition (int glyphIndex);\n@@ -121,10 +136,9 @@ public abstract float[] getGlyphPositions (int beginGlyphIndex,\n \n   public abstract Shape getGlyphVisualBounds (int glyphIndex);\n \n-  public int getLayoutFlags ()\n-    throws NotImplementedException\n+  public int getLayoutFlags()\n   {\n-    throw new Error (\"not implemented\");\n+    return 0;\n   }\n \n   public abstract Rectangle2D getLogicalBounds ();\n@@ -137,9 +151,16 @@ public int getLayoutFlags ()\n \n   public Rectangle getPixelBounds (FontRenderContext renderFRC,\n                                    float x, float y)\n-    throws NotImplementedException\n   {\n-    throw new Error (\"not implemented\");\n+    Rectangle bounds = new Rectangle();\n+    Rectangle2D rect = getVisualBounds();\n+    \n+    bounds.x = (int) (rect.getX() + x);\n+    bounds.y = (int) (rect.getY() + y);\n+    bounds.width = (int) rect.getMaxX() - bounds.x;\n+    bounds.height = (int) rect.getMaxY() - bounds.y;\n+    \n+    return bounds;\n   }\n \n   public abstract Rectangle2D getVisualBounds ();"}, {"sha": "19f781bcc29aca39e8610c3393aa8aa22cf9bdb3", "filename": "libjava/classpath/java/awt/font/GraphicAttribute.java", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGraphicAttribute.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGraphicAttribute.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FGraphicAttribute.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,51 +38,100 @@\n \n package java.awt.font;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.Graphics2D;\n import java.awt.geom.Rectangle2D;\n \n /**\n+ * This class represents a graphic embedded in text.\n+ * \n  * @author Michael Koch\n+ * @author Lillian Angel (langel at redhat dot com)\n  */\n public abstract class GraphicAttribute\n {\n-  public static final int BOTTOM_ALIGNMENT = -2;\n+  public static final int BOTTOM_ALIGNMENT = - 2;\n   public static final int CENTER_BASELINE = 1;\n   public static final int HANGING_BASELINE = 2;\n   public static final int ROMAN_BASELINE = 0;\n-  public static final int TOP_ALIGNMENT = -1;\n+  public static final int TOP_ALIGNMENT = - 1;\n \n   private int alignment;\n-  \n-  protected GraphicAttribute (int alignment)\n+\n+  /**\n+   * Constructor.\n+   * \n+   * @param alignment - the alignment to use for the graphic\n+   */\n+  protected GraphicAttribute(int alignment)\n   {\n+    if (alignment < BOTTOM_ALIGNMENT || alignment > HANGING_BASELINE)\n+      throw new IllegalArgumentException(\"Invalid alignment\");\n     this.alignment = alignment;\n   }\n \n-  public abstract void draw (Graphics2D graphics, float x, float y);\n-\n-  public abstract float getAdvance ();\n-\n-  public final int getAlignment ()\n+  /**\n+   * Draws the graphic.\n+   * \n+   * @param graphics - the graphics configuration to use\n+   * @param x - the x location\n+   * @param y - the y location\n+   */\n+  public abstract void draw(Graphics2D graphics, float x, float y);\n+\n+  /**\n+   * Gets the distance from the origin of its graphic to the right side of the\n+   * bounds of its graphic.\n+   * \n+   * @return the advance\n+   */\n+  public abstract float getAdvance();\n+\n+  /**\n+   * Gets the positive distance from the origin of its graphic to the top of\n+   * bounds.\n+   * \n+   * @return the ascent\n+   */\n+  public abstract float getAscent();\n+\n+  /**\n+   * Gets the distance from the origin of its graphic to the bottom of the bounds.\n+   * \n+   * @return the descent\n+   */\n+  public abstract float getDescent();\n+\n+  /**\n+   * Gets the alignment.\n+   * \n+   * @return the alignment\n+   */\n+  public final int getAlignment()\n   {\n     return alignment;\n   }\n \n-  public abstract float getAscent ();\n-\n-  public Rectangle2D getBounds ()\n-    throws NotImplementedException\n+  /**\n+   * Returns a Rectangle2D that encloses the rendered area.\n+   * Default bounds is the rectangle (0, -ascent, advance, ascent+descent).\n+   * \n+   * @return the bounds of the rendered area\n+   */\n+  public Rectangle2D getBounds()\n   {\n-    throw new Error (\"not implemented\");\n+    float asc = getAscent();\n+    return new Rectangle2D.Float(0, - asc, getAdvance(), asc + getDescent());\n   }\n \n-  public abstract float getDescent ();\n-\n-  public GlyphJustificationInfo getJustificationInfo ()\n-    throws NotImplementedException\n+  /**\n+   * Returns the justification information for this object.\n+   * \n+   * @return the justification information\n+   */\n+  public GlyphJustificationInfo getJustificationInfo()\n   {\n-    throw new Error (\"not implemented\");\n+    float adv = getAdvance();\n+    return new GlyphJustificationInfo(adv, false, 2, adv / 3, adv / 3, false,\n+                                      1, 0, 0);\n   }\n }"}, {"sha": "3e4fdcf733fe942f4ca9493366593d1bda3c53fb", "filename": "libjava/classpath/java/awt/font/ImageGraphicAttribute.java", "status": "modified", "additions": 104, "deletions": 36, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FImageGraphicAttribute.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FImageGraphicAttribute.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FImageGraphicAttribute.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,82 +38,150 @@\n \n package java.awt.font;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.Graphics2D;\n import java.awt.Image;\n import java.awt.geom.Rectangle2D;\n \n /**\n+ * This is an implementation of GraphicAttribute which draws images in a\n+ * TextLayout.\n+ * \n+ * @author Lillian Angel\n  * @author Michael Koch\n  */\n-public final class ImageGraphicAttribute extends GraphicAttribute\n+public final class ImageGraphicAttribute\n+    extends GraphicAttribute\n {\n   private Image image;\n-  \n-  public ImageGraphicAttribute (Image image, int alignment)\n+  private float originX;\n+  private float originY;\n+\n+  /**\n+   * Constucts an instance from the specified Image. The origin is at (0, 0).\n+   * \n+   * @param image - image to construct from.\n+   * @param alignment - the alignment\n+   */\n+  public ImageGraphicAttribute(Image image, int alignment)\n   {\n-    super (alignment);\n-    this.image = image;\n+    this(image, alignment, 0, 0);\n   }\n \n-  public ImageGraphicAttribute (Image image, int alignment, float originX,\n-                                float originY)\n-    throws NotImplementedException\n+  /**\n+   * Constucts an instance from the specified Image. The origin is at (originX,\n+   * originY).\n+   * \n+   * @param image - image to construct from\n+   * @param alignment - the alignment\n+   * @param originX - x point of origin\n+   * @param originY - y point of origin\n+   */\n+  public ImageGraphicAttribute(Image image, int alignment, float originX,\n+                               float originY)\n   {\n-    super (alignment);\n+    super(alignment);\n     this.image = image;\n-    \n-    throw new Error (\"not implemented\");\n+    this.originX = originX;\n+    this.originY = originY;\n   }\n \n-  public void draw (Graphics2D graphics, float x, float y)\n-    throws NotImplementedException\n+  /**\n+   * Draws the image at the specified location, relative to the\n+   * origin.\n+   * \n+   * @param g - the graphics to use to render the image\n+   * @param x - the x location\n+   * @param y - the y location \n+   */\n+  public void draw(Graphics2D g, float x, float y)\n   {\n-    throw new Error (\"not implemented\");\n+    g.drawImage(image, (int) (x - originX), (int) (y - originY), null);\n   }\n \n-  public boolean equals (Object obj)\n+  /**\n+   * Compares this to the specified Object\n+   * \n+   * @param obj - the object to compare\n+   * @return true if the obj and this are equivalent\n+   */\n+  public boolean equals(Object obj)\n   {\n     if (! (obj instanceof ImageGraphicAttribute))\n       return false;\n \n-    return equals ((ImageGraphicAttribute) obj);\n+    return equals((ImageGraphicAttribute) obj);\n   }\n \n-  public boolean equals (ImageGraphicAttribute rhs)\n-    throws NotImplementedException\n+  /**\n+   * Compares this to the ImageGraphicAttribute given, by\n+   * comparing all fields and values.\n+   * \n+   * @param rhs - the ImageGraphicAttribute to compare\n+   * @return true if the object given is equivalent to this\n+   */\n+  public boolean equals(ImageGraphicAttribute rhs)\n   {\n-    throw new Error (\"not implemented\");\n+    return ((this == rhs) || ((this.getAscent() == rhs.getAscent())\n+                              && (this.getAdvance() == rhs.getAdvance())\n+                              && (this.getAlignment() == rhs.getAlignment())\n+                              && (this.getBounds().equals(rhs.getBounds()))\n+                              && (this.getDescent() == rhs.getDescent())\n+                              && (this.hashCode() == rhs.hashCode())\n+                              && (this.image.equals(rhs.image))\n+                              && (this.originX == rhs.originX) \n+                              && (this.originY == rhs.originY)));\n   }\n \n-  public float getAdvance ()\n-    throws NotImplementedException\n+  /**\n+   * Returns distance from the origin to the right edge of the image of this.\n+   * \n+   * @return the advance\n+   */\n+  public float getAdvance()\n   {\n-    throw new Error (\"not implemented\");\n+    return Math.max(0, image.getWidth(null) - originX);\n   }\n \n-  public float getAscent ()\n-    throws NotImplementedException\n+  /**\n+   * Returns the the distance from the top of the image to the origin of this.\n+   * \n+   * @return the ascent.\n+   */\n+  public float getAscent()\n   {\n-    throw new Error (\"not implemented\");\n+    return Math.max(0, originY);\n   }\n \n-  public Rectangle2D getBounds ()\n-    throws NotImplementedException\n+  /**\n+   * Gets the bounds of the object rendered, relative to the position.\n+   * \n+   * @return the bounds of the object rendered, relative to the position.\n+   */\n+  public Rectangle2D getBounds()\n   {\n-    throw new Error (\"not implemented\");\n+    // This is equivalent to what Sun's JDK returns.\n+    // I am not entirely sure why the origin is negative.\n+    return new Rectangle2D.Float(- originX, - originY, image.getWidth(null),\n+                                 image.getHeight(null));\n   }\n \n-  public float getDescent ()\n-    throws NotImplementedException\n+  /**\n+   * Returns the distance from the origin to the bottom of the image.\n+   * \n+   * @return the descent\n+   */\n+  public float getDescent()\n   {\n-    throw new Error (\"not implemented\");\n+    return Math.max(0, image.getHeight(null) - originY);\n   }\n \n-  public int hashCode ()\n-    throws NotImplementedException\n+  /**\n+   * Gets the hash code for this image.\n+   * \n+   * @return the hash code\n+   */\n+  public int hashCode()\n   {\n-    throw new Error (\"not implemented\");\n+    return image.hashCode();\n   }\n }"}, {"sha": "06814972b068c1f9044259f8b54b6f7410b22746", "filename": "libjava/classpath/java/awt/font/ShapeGraphicAttribute.java", "status": "modified", "additions": 101, "deletions": 27, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FShapeGraphicAttribute.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FShapeGraphicAttribute.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Ffont%2FShapeGraphicAttribute.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,74 +38,148 @@\n \n package java.awt.font;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.Graphics2D;\n import java.awt.Shape;\n import java.awt.geom.Rectangle2D;\n \n+/**\n+ * This is an implementation of GraphicAttribute that draws shapes in a TextLayout.\n+ * \n+ * @author Lillian Angel (langel at redhat dot com)\n+ */\n public final class ShapeGraphicAttribute extends GraphicAttribute\n {\n+  /** True if the shape should be filled. */\n   public static final boolean FILL = false;\n+  \n+  /** True if the shape should be stroked with a 1-pixel wide stroke. */\n   public static final boolean STROKE = true;\n \n   private Shape shape;\n   private boolean stroke;\n+  private Rectangle2D bounds;\n   \n-  public ShapeGraphicAttribute (Shape shape, int alignment, boolean stroke)\n+  /**\n+   * Constructor.\n+   * \n+   * @param shape - the Shape to render. The Shape is rendered with its origin.\n+   * @param alignment - the alignment\n+   * @param stroke - true if the Shape should be stroked; false if the Shape\n+   *          should be filled.\n+   */\n+  public ShapeGraphicAttribute(Shape shape, int alignment, boolean stroke)\n   {\n-    super (alignment);\n+    super(alignment);\n     this.shape = shape;\n     this.stroke = stroke;\n+    this.bounds = shape.getBounds2D();\n   }\n \n-  public void draw (Graphics2D graphics, float x, float y)\n-    throws NotImplementedException\n+  /**\n+   * Draws the graphic at the given location.\n+   * \n+   * @param graphics - the graphics to use.\n+   * @param x - the x location to draw at.\n+   * @param y - the y location to draw at.\n+   */\n+  public void draw(Graphics2D graphics, float x, float y)\n   {\n-    throw new Error (\"not implemented\");\n+    graphics.translate(x, y);\n+    if (stroke == STROKE)\n+      graphics.draw(shape);\n+    else\n+      graphics.fill(shape);\n+    graphics.translate(- x, - y);\n   }\n \n-  public boolean equals (Object obj)\n+  /**\n+   * Compares this ShapeGraphicAttribute to obj.\n+   * \n+   * @param obj - the object to compare.\n+   */\n+  public boolean equals(Object obj)\n   {\n     if (! (obj instanceof ShapeGraphicAttribute))\n       return false;\n \n-    return equals ((ShapeGraphicAttribute) obj);\n+    return equals((ShapeGraphicAttribute) obj);\n   }\n \n-  public boolean equals (ShapeGraphicAttribute rhs)\n+  /**\n+   * Compares this ShapeGraphicAttribute to rhs.\n+   * \n+   * @param rhs - the ShapeGraphicAttribute to compare.\n+   */\n+  public boolean equals(ShapeGraphicAttribute rhs)\n   {\n-    return (shape.equals (rhs.shape)\n-            && getAlignment () == rhs.getAlignment ()\n-            && stroke == rhs.stroke);\n+    return (this == rhs || (this.shape.equals(rhs.shape)\n+                            && getAlignment() == rhs.getAlignment()\n+                            && stroke == rhs.stroke\n+                            && getAdvance() == rhs.getAdvance()\n+                            && getAscent() == rhs.getAscent()\n+                            && getBounds().equals(rhs.getBounds())\n+                            && getDescent() == rhs.getDescent() \n+                            && hashCode() == rhs.hashCode()));\n   }\n \n-  public float getAdvance ()\n-    throws NotImplementedException\n+  /**\n+   * Gets the distance from the origin of its Shape to the right side of the\n+   * bounds of its Shape.\n+   * \n+   * @return the advance\n+   */\n+  public float getAdvance()\n   {\n-    throw new Error (\"not implemented\");\n+    return Math.max(0, (float) bounds.getMaxX());\n   }\n \n-  public float getAscent ()\n-    throws NotImplementedException\n+  /**\n+   * Gets the positive distance from the origin of its Shape to the top of\n+   * bounds.\n+   * \n+   * @return the ascent\n+   */\n+  public float getAscent()\n   {\n-    throw new Error (\"not implemented\");\n+    return Math.max(0, -(float) bounds.getMinY());\n   }\n \n-  public Rectangle2D getBounds ()\n+  /**\n+   * Gets the distance from the origin of its Shape to the bottom of the bounds.\n+   * \n+   * @return the descent\n+   */\n+  public float getDescent()\n   {\n-    return shape.getBounds2D ();\n+    return Math.max(0, (float) bounds.getMaxY());\n   }\n \n-  public float getDescent ()\n-    throws NotImplementedException\n+  /**\n+   * Returns a Rectangle2D that encloses all of the bits drawn by this shape.\n+   * \n+   * @return the bounds of the shape.\n+   */\n+  public Rectangle2D getBounds()\n   {\n-    throw new Error (\"not implemented\");\n+    Rectangle2D.Float bounds = new Rectangle2D.Float();\n+    bounds.setRect(this.bounds);\n+\n+    if (stroke == STROKE)\n+      {\n+        bounds.width++;\n+        bounds.height++;\n+      }\n+    \n+    return bounds;\n   }\n \n-  public int hashCode ()\n+  /**\n+   * Gets the hash code.\n+   * \n+   * @return the hash code.\n+   */\n+  public int hashCode()\n   {\n-    // FIXME: Check what SUN does here\n-    return shape.hashCode ();\n+    return shape.hashCode();\n   }\n }"}, {"sha": "3806736df3d4efa91c2fadf1c360cf8201973e63", "filename": "libjava/classpath/java/awt/im/InputContext.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fim%2FInputContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fim%2FInputContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Fim%2FInputContext.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -103,8 +103,8 @@\n     while (e.hasMoreElements())\n       {\n         URL url = (URL) e.nextElement();\n-        BufferedReader in = null;\n-        String line = null;\n+        BufferedReader in;\n+        String line;\n         try\n           {\n             in = new BufferedReader"}, {"sha": "16b0143850cd04dee1173f1e0f3ec6a14057b987", "filename": "libjava/classpath/java/awt/image/BufferedImage.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FBufferedImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FBufferedImage.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -80,7 +80,7 @@ public class BufferedImage extends Image\n                           TYPE_BYTE_INDEXED   = 13;\n   \n   static final int[] bits3 = { 8, 8, 8 };\n-  static final int[] bits4 = { 8, 8, 8 };\n+  static final int[] bits4 = { 8, 8, 8, 8 };\n   static final int[] bits1byte = { 8 };\n   static final int[] bits1ushort = { 16 };\n   "}, {"sha": "e2f5378b4da8af36fbf561724c80dac3162fa997", "filename": "libjava/classpath/java/awt/image/ColorModel.java", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Fimage%2FColorModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -92,7 +92,12 @@ public abstract class ColorModel implements Transparency\n   int transparency;\n   boolean hasAlpha;\n   boolean isAlphaPremultiplied;\n-    \n+\n+  /**\n+   * The standard color model for the common sRGB.\n+   */\n+  private static final ColorModel S_RGB_MODEL = new SRGBColorModel();\n+\n   static int[] nArray(int value, int times)\n   {\n     int[] array = new int[times];\n@@ -196,7 +201,7 @@ public void finalize()\n    */\n   public static ColorModel getRGBdefault()\n   {\n-    return new DirectColorModel(32, 0xff0000, 0xff00, 0xff, 0xff000000);\n+    return S_RGB_MODEL;\n   }\n \n   public final boolean hasAlpha()\n@@ -761,4 +766,56 @@ public String toString()\n   {\n     return getClass().getName() + \"[\" + stringParam() + \"]\";\n   }\n+\n+  /**\n+   * A color model optimized for standard sRGB.\n+   */\n+  private static class SRGBColorModel\n+    extends DirectColorModel\n+  {\n+    \n+    SRGBColorModel()\n+    {\n+      super(32,0x00FF0000,0x0000FF00,0x000000FF,0xFF000000);\n+    }\n+\n+    public int getAlpha(Object inData)\n+    {\n+      return ((((int[]) inData)[0]) >> 24) & 0xFF;\n+    }\n+\n+    public int getBlue(Object inData)\n+    {\n+      return ((((int[]) inData)[0])) & 0xFF;\n+    }\n+\n+    public int getGreen(Object inData)\n+    {\n+      return ((((int[]) inData)[0]) >>  8) & 0xFF;\n+    }\n+\n+    public int getRed(Object inData)\n+    {\n+      return ((((int[]) inData)[0]) >> 16) & 0xFF;\n+    }\n+\n+    public int getRGB(Object inData)\n+    {\n+      return ((int[]) inData)[0];\n+    }\n+\n+    public Object getDataElements(int rgb, Object pixel)\n+    {\n+      if(pixel == null)\n+        {\n+          pixel = new int[]{rgb};  \n+        }\n+      else\n+        {\n+          ((int[]) pixel)[0] = rgb;  \n+        }\n+      \n+      return pixel;\n+    }\n+  }\n }"}, {"sha": "8afada1675e459e5c8dd0038f7678015e8b17182", "filename": "libjava/classpath/java/awt/print/PrinterJob.java", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fprint%2FPrinterJob.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Fawt%2Fprint%2FPrinterJob.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Fawt%2Fprint%2FPrinterJob.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,9 +38,13 @@\n \n package java.awt.print;\n \n-import java.awt.HeadlessException;\n+import gnu.java.awt.print.JavaPrinterJob;\n \n+import java.awt.HeadlessException;\n import javax.print.PrintService;\n+import javax.print.PrintServiceLookup;\n+import javax.print.DocFlavor;\n+import javax.print.StreamPrintServiceFactory;\n import javax.print.attribute.PrintRequestAttributeSet;\n \n /**\n@@ -60,8 +64,7 @@\n    */\n   public static PrinterJob getPrinterJob()\n   {\n-    // FIXME: Need to fix this to load a default implementation instance.\n-    return new NoPrinterJob();\n+    return new JavaPrinterJob();\n   }\n \n   /**\n@@ -244,13 +247,11 @@ public boolean printDialog(PrintRequestAttributeSet attributes)\n    */\n   public static PrintService[] lookupPrintServices()\n   {\n-    return new PrintService[0];\n-    // FIXME:\n-    // Enable this when javax.print has this implemented.\n-//    return PrintServiceLookup.lookupPrintServices(\n-//          new DocFlavor(\"application/x-java-jvm-local-objectref\",\n-//                        \"java.awt.print.Pageable\"),\n-//          null);\n+    return PrintServiceLookup.lookupPrintServices\n+      (\n+       new DocFlavor(\"application/x-java-jvm-local-objectref\",\n+\t\t     \"java.awt.print.Pageable\"),\n+       null);\n   }\n \n   /**\n@@ -263,8 +264,8 @@ public static PrintService[] lookupPrintServices()\n    * @return Array of stream print services, could be empty.\n    * @since 1.4\n    */\n-  \t// FIXME:\n-  \t// Enable when javax.print has StreamPrintServiceFactory \n+  // FIXME:\n+  // Enable when StreamPrintServiceFactory has lookupStreamServiceFactories\n //  public static StreamPrintServiceFactory[] lookupStreamPrintServices(String mimeType)\n //  {\n //    return StreamPrintServiceFactory.lookupStreamServiceFactories(\n@@ -282,7 +283,7 @@ public static PrintService[] lookupPrintServices()\n    */\n   public PrintService getPrintService()\n   {\n-    return null;\n+    return printer;\n   }\n \n   /**\n@@ -297,6 +298,6 @@ public PrintService getPrintService()\n   public void setPrintService(PrintService service)\n     throws PrinterException\n   {\n-    throw new PrinterException();\n+    printer = service;\n   }\n }"}, {"sha": "a42e9b3d9c838f5f6afe2f2237eadf0ebd4f80b8", "filename": "libjava/classpath/java/text/NumberFormat.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Ftext%2FNumberFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Ftext%2FNumberFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Ftext%2FNumberFormat.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -481,7 +481,7 @@ public static final NumberFormat getIntegerInstance()\n    */\n   public static NumberFormat getIntegerInstance(Locale locale)\n   {\n-    NumberFormat format = computeInstance (locale, \"numberFormat\", \"#,##0\");\n+    NumberFormat format = computeInstance (locale, \"integerFormat\", \"#,##0\");\n     format.setMaximumFractionDigits(0);\n     format.setParseIntegerOnly (true);\n     return format;"}, {"sha": "2825c7bed24fabffc11f3df207630b7e959ac057", "filename": "libjava/classpath/java/text/SimpleDateFormat.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Ftext%2FSimpleDateFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Ftext%2FSimpleDateFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Ftext%2FSimpleDateFormat.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -307,7 +307,7 @@ private void compileFormat(String pattern)\n \t\t// Not a valid letter\n \t\tthrow new IllegalArgumentException(\"Invalid letter \"\n \t\t\t\t\t\t   + thisChar +\n-\t\t\t\t\t\t   \"encountered at character \"\n+\t\t\t\t\t\t   \" encountered at character \"\n \t\t\t\t\t\t   + i + \".\");\n \t      }\n \t    else if (thisChar == '\\'')"}, {"sha": "011b146ce10a74fa7ca9f65febabbe4d7c7ecbdb", "filename": "libjava/classpath/java/text/class-dependencies.conf", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Ftext%2Fclass-dependencies.conf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjava%2Ftext%2Fclass-dependencies.conf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Ftext%2Fclass-dependencies.conf?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -0,0 +1,220 @@\n+# This property file contains dependencies of classes, methods, and\n+# field on other methods or classes.\n+#\n+# Syntax: \n+#\n+#   <used>: <needed 1> [... <needed N>]\n+#\n+# means that when <used> is included, <needed 1> (... <needed N>) must\n+# be included as well.\n+#\n+# <needed X> and <used> are of the form\n+#\n+#   <class.methodOrField(signature)>\n+#\n+# or just\n+#\n+#   <class>\n+#\n+# Within dependencies, variables can be used. A variable is defined as \n+# follows: \n+#\n+#   {variable}: value1 value2 ... value<n>\n+#\n+# variables can be used on the right side of dependencies as follows: \n+#\n+#    <used>: com.bla.blu.{variable}.Class.m()V\n+#\n+# The use of the variable will expand to <n> dependencies of the form\n+#\n+#    <used>: com.bla.blu.value1.Class.m()V\n+#    <used>: com.bla.blu.value2.Class.m()V\n+#    ...\n+#    <used>: com.bla.blu.value<n>.Class.m()V\n+#\n+# Variables can be redefined when building a system to select the \n+# required support for features like encodings, protocols, etc. \n+#\n+# Hints:\n+#\n+#  - For methods and fields, the signature is mandatory. For\n+#    specification, please see the Java Virtual Machine Specification by\n+#    SUN. Unlike in the spec, field signatures (types) are in brackets.\n+#\n+#  - Package names must be separated by '/' (and not '.'). E.g.,\n+#    java/lang/Class (this is necessary, because the '.' is used to\n+#    separate method or field names from classes)\n+#\n+#  - In case <needed> refers to a class, only the class itself will be\n+#    included in the resulting binary, NOT necessarily all its methods\n+#    and fields. If you want to refer to all methods and fields, you can\n+#    write class.* as an abbreviation.\n+#\n+# -  Abbreviations for packages are also possible: my/package/* means all\n+#    methods and fields of all classes in my/package.\n+#\n+# -  A line with a trailing '\\' continues in the next line.\n+\n+# end of file\n+\n+# All locales supported are loaded via classes from java.text (see below)\n+# from class gnu/java/locale/LocaleInformation_<locale_id>\n+#\n+# This introduces a dependency for all locales. To allow an easy selection\n+# and addition of locales, the library variable {text_locales} can be set to \n+# the set of supported locales.\n+#\n+\n+{text_locales}: \\\n+\taf_ZA \\\n+\tar_AE \\\n+\tar_BH \\\n+\tar_DZ \\\n+\tar_EG \\\n+\tar_IN \\\n+\tar_IQ \\\n+\tar_JO \\\n+\tar_KW \\\n+\tar_LB \\\n+\tar_LY \\\n+\tar_MA \\\n+\tar_OM \\\n+\tar_QA \\\n+\tar_SD \\\n+\tar_SY \\\n+\tar_TN \\\n+\tar_YE \\\n+\tbe_BY \\\n+\tbn_IN \\\n+\tbr_FR \\\n+\tbs_BA \\\n+\tca_ES \\\n+\tcs_CZ \\\n+\tcy_GB \\\n+\tda_DK \\\n+\tde \\\n+\tde_AT \\\n+\tde_BE \\\n+\tde_CH \\\n+\tde_DE \\\n+\tde_LU \\\n+\tel_GR \\\n+\ten \\\n+\ten_AU \\\n+\ten_BW \\\n+\ten_CA \\\n+\ten_DK \\\n+\ten_GB \\\n+\ten_HK \\\n+\ten_IE \\\n+\ten_IN \\\n+\ten_NZ \\\n+\ten_PH \\\n+\ten_SG \\\n+\ten_US \\\n+\ten_ZA \\\n+\ten_ZW \\\n+\tes_AR \\\n+\tes_BO \\\n+\tes_CL \\\n+\tes_CO \\\n+\tes_CR \\\n+\tes_DO \\\n+\tes_EC \\\n+\tes_ES \\\n+\tes_GT \\\n+\tes_HN \\\n+\tes_MX \\\n+\tes_NI \\\n+\tes_PA \\\n+\tes_PE \\\n+\tes_PR \\\n+\tes_PY \\\n+\tes_SV \\\n+\tes_US \\\n+\tes_UY \\\n+\tes_VE \\\n+\tet_EE \\\n+\teu_ES \\\n+\tfa_IR \\\n+\tfi_FI \\\n+\tfo_FO \\\n+\tfr_BE \\\n+\tfr_CA \\\n+\tfr_CH \\\n+\tfr_FR \\\n+\tfr_LU \\\n+\tga_IE \\\n+\tgd_GB \\\n+\tgl_ES \\\n+\tgv_GB \\\n+\the_IL \\\n+\thi_IN \\\n+\thr_HR \\\n+\thu_HU \\\n+\tid_ID \\\n+\tit_CH \\\n+\tit_IT \\\n+\tiw_IL \\\n+\tja_JP \\\n+\tka_GE \\\n+\tkl_GL \\\n+\tko_KR \\\n+\tkw_GB \\\n+\tlt_LT \\\n+\tlv_LV \\\n+\tmi_NZ \\\n+\tmk_MK \\\n+\tmr_IN \\\n+\tmt_MT \\\n+\tnl \\\n+\tnl_BE \\\n+\tnl_NL \\\n+\tnn_NO \\\n+\tno_NO \\\n+\toc_FR \\\n+\tpl_PL \\\n+\tpt_BR \\\n+\tpt_PT \\\n+\tro_RO \\\n+\tru_RU \\\n+\tru_UA \\\n+\tse_NO \\\n+\tsk_SK \\\n+\tsl_SI \\\n+\tsq_AL \\\n+\tsr_YU \\\n+\tsv_FI \\\n+\tsv_SE \\\n+\tta_IN \\\n+\tte_IN \\\n+\ttg_TJ \\\n+\ttl_PH \\\n+\ttr_TR \\\n+\tuk_UA \\\n+\tur_PK \\\n+\tuz_UZ \\\n+\tvi_VN \\\n+\tyi_US \\\n+\tzh_CN \\\n+\tzh_HK \\\n+\tzh_SG \\\n+\tzh_TW \n+\n+java/text/Collator.getInstance(Ljava/util/Locale;)Ljava/text/Collator;: \\\n+\tgnu/java/locale/LocaleInformation_{text_locales}.*\n+\n+java/text/DateFormatSymbols.<init>(Ljava/util/Locale;)V: \\\n+\tgnu/java/locale/LocaleInformation_{text_locales}.*\n+\n+java/text/DecimalFormatSymbols.<init>(Ljava/util/Locale;)V: \\\n+\tgnu/java/locale/LocaleInformation_{text_locales}.*\n+\n+java/text/BreakIterator.getInstance(Ljava/lang/String;Ljava/util/Locale;)Ljava/text/BreakIterator;: \\\n+\tgnu/java/locale/LocaleInformation_{text_locales}.*\n+\n+java/text/NumberFormat.computeInstance(Ljava/util/Locale;Ljava/lang/String;Ljava/lang/String;)Ljava/text/NumberFormat;: \\\n+\tgnu/java/locale/LocaleInformation_{text_locales}.*\n+\n+java/text/DateFormat.computeInstance(IILjava/util/Locale;ZZ)Ljava/text/DateFormat;: \\\n+\tgnu/java/locale/LocaleInformation_{text_locales}.*"}, {"sha": "9b2b526f30b43fae7b12127358aa5451bbf909ce", "filename": "libjava/classpath/javax/swing/AbstractButton.java", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FAbstractButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FAbstractButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FAbstractButton.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* AbstractButton.java -- Provides basic button functionality.\n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2006, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -274,7 +274,7 @@ public void stateChanged(ChangeEvent ev)\n   protected ChangeListener changeListener;\n \n   /**\n-   * The time in miliseconds in which clicks get coalesced into a single\n+   * The time in milliseconds in which clicks get coalesced into a single\n    * <code>ActionEvent</code>.\n    */\n   long multiClickThreshhold;\n@@ -445,7 +445,7 @@ protected AccessibleAbstractButton()\n      * {@link AccessibleState#FOCUSED}, {@link AccessibleState#PRESSED} and\n      * {@link AccessibleState#CHECKED}.\n      *\n-     * @return the curren state of this accessible object\n+     * @return the current state of this accessible object\n      */\n     public AccessibleStateSet getAccessibleStateSet()\n     {\n@@ -651,8 +651,8 @@ public boolean setCurrentAccessibleValue(Number value)\n      * Returns the minimum accessible value for the AccessibleAbstractButton,\n      * which is <code>0</code>.\n      *\n-     * @return the maxinimum accessible value for the AccessibleAbstractButton,\n-     *         which is <code>1</code>\n+     * @return the minimimum accessible value for the AccessibleAbstractButton,\n+     *         which is <code>0</code>\n      */\n     public Number getMinimumAccessibleValue()\n     {"}, {"sha": "764a4c500b5efbd7e623e56920814c2048c052a9", "filename": "libjava/classpath/javax/swing/CellRendererPane.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FCellRendererPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FCellRendererPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FCellRendererPane.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -93,7 +93,7 @@ public AccessibleRole getAccessibleRole()\n    */\n   public CellRendererPane()\n   {\n-    // Nothing to do here.\n+    setVisible(false);\n   }\n \n   /**"}, {"sha": "2be18cc8aac83f5f5e8f9491fd04507017e4428b", "filename": "libjava/classpath/javax/swing/DefaultButtonModel.java", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultButtonModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultButtonModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultButtonModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* DefaultButtonModel.java --\n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2006, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -63,7 +63,7 @@\n  * change to the \"selected\" property will trigger the firing of an ItemEvent\n  * in addition to ChangeEvent. This is true whether the model is enabled or\n  * not. One other state change is special: the transition from \"enabled,\n- * armed and pressd\" to \"enabled, armed and not-pressed\". This is considered\n+ * armed and pressed\" to \"enabled, armed and not-pressed\". This is considered\n  * the \"trailing edge\" of a successful mouse click, and therefore fires an\n  * ActionEvent in addition to a ChangeEvent. In all other respects this class\n  * is just a container of boolean flags.\n@@ -371,7 +371,7 @@ public void setEnabled(boolean e)\n     if (e)\n       stateMask = stateMask | ENABLED;\n     else\n-      stateMask = stateMask & (~ENABLED);\n+      stateMask = stateMask & (~ENABLED) & (~ARMED) & (~PRESSED);\n \n     // notify interested ChangeListeners\n     fireStateChanged();\n@@ -555,21 +555,21 @@ public String getActionCommand()\n    * one model in a given group can have their \"selected\" property be\n    * <code>true</code> at a time.\n    *\n-   * @param g The new \"group\" property\n+   * @param g The new \"group\" property (<code>null</code> permitted).\n+   * \n+   * @see #getGroup()\n    */\n   public void setGroup(ButtonGroup g)\n   {\n-    if (group != g)\n-      {\n-        group = g;\n-        fireStateChanged();\n-      }\n+    group = g;\n   }\n \n   /**\n    * Returns the current value of the model's \"group\" property.\n    *\n    * @return The value of the \"group\" property\n+   * \n+   * @see #setGroup(ButtonGroup)\n    */\n   public ButtonGroup getGroup()\n   {"}, {"sha": "16ed1ec6842a2059ae62081a30a1a25b09342a80", "filename": "libjava/classpath/javax/swing/DefaultCellEditor.java", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultCellEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultCellEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultCellEditor.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -313,7 +313,24 @@ public Object getCellEditorValue()\n     {\n       JComboBox c = (JComboBox) editorComponent;\n       return value = c.getSelectedItem();\n-    }     \n+    } \n+    \n+    /**\n+     * Returns true to indicate that the editing cell can be selected. If the\n+     * check box is not editable, expands it. If it is editable, brings\n+     * focus to the editor field.\n+     * \n+     * @param event unused in default method\n+     *\n+     * @return true always\n+     */\n+    public boolean shouldSelectCell(EventObject event)\n+    {\n+      JComboBox c = (JComboBox) editorComponent;\n+      if (!c.isEditable)\n+        c.showPopup();\n+      return true;\n+    }    \n   }\n \n   /**"}, {"sha": "11f03a715c41ebd430672c6d25af1cfd2142375c", "filename": "libjava/classpath/javax/swing/DefaultDesktopManager.java", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultDesktopManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultDesktopManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FDefaultDesktopManager.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -400,8 +400,8 @@ public void endDraggingFrame(JComponent component)\n                           dragCache.width, dragCache.height);\n         pane = null;\n         dragCache = null;\n+        component.repaint();        \n       }\n-    component.repaint();\n   }\n \n   /**\n@@ -463,8 +463,8 @@ public void endResizingFrame(JComponent component)\n                           dragCache.width, dragCache.height);\n         pane = null;\n         dragCache = null;\n+        component.repaint();        \n       }\n-    component.repaint();\n   }\n \n   /**\n@@ -481,13 +481,6 @@ public void setBoundsForFrame(JComponent component, int newX, int newY,\n                                 int newWidth, int newHeight)\n   {\n     component.setBounds(newX, newY, newWidth, newHeight);\n-    component.revalidate();\n-\n-    // If not null, I'd rather repaint the parent\n-    if (component.getParent() != null)\n-      component.getParent().repaint();\n-    else\n-      component.repaint();\n   }\n \n   /**"}, {"sha": "3222d189f37025385f4406c13dfdb5a80403f963", "filename": "libjava/classpath/javax/swing/JCheckBoxMenuItem.java", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJCheckBoxMenuItem.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* JCheckBoxMenuItem.java --\n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2006, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -204,24 +204,36 @@ public Object[] getSelectedObjects()\n   /**\n     * This method overrides JComponent.requestFocus with an empty\n     * implementation, since JCheckBoxMenuItems should not\n-    * receve focus in general.\n+    * receive focus in general.\n     */\n   public void requestFocus()\n   {\n     //  Should do nothing here\n   }\n \n   /**\n-   * A string that describes this JCheckBoxMenuItem. Normally only used\n-   * for debugging.\n+   * Returns a string describing the attributes for the \n+   * <code>JCheckBoxMenuItem</code> component, for use in debugging.  The \n+   * return value is guaranteed to be non-<code>null</code>, but the format \n+   * of the string may vary between implementations.\n    *\n-   * @return A string describing this JCheckBoxMenuItem\n+   * @return A string describing the attributes of the \n+   *     <code>JCheckBoxMenuItem</code>.\n    */\n   protected String paramString()\n   {\n-    return \"JCheckBoxMenuItem\";\n+    // calling super seems to be sufficient to match the reference \n+    // implementation here...\n+    return super.paramString();\n   }\n \n+  /**\n+   * Returns the object that provides accessibility features for this\n+   * <code>JCheckBoxMenuItem</code> component.\n+   *\n+   * @return The accessible context (an instance of \n+   *     {@link AccessibleJCheckBoxMenuItem}).\n+   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n@@ -231,20 +243,29 @@ public AccessibleContext getAccessibleContext()\n   }\n \n   /**\n-   * Accessibility support for <code>JCheckBoxMenuItem</code>.\n+   * Provides the accessibility features for the <code>JCheckBoxMenuItem</code> \n+   * component.\n+   * \n+   * @see JCheckBoxMenuItem#getAccessibleContext()\n    */\n   protected class AccessibleJCheckBoxMenuItem extends AccessibleJMenuItem\n   {\n     private static final long serialVersionUID = 1079958073579370777L;\n \n     /**\n-     * Creates a new AccessibleJCheckBoxMenuItem object.\n+     * Creates a new <code>AccessibleJCheckBoxMenuItem</code> instance.\n      */\n     protected AccessibleJCheckBoxMenuItem()\n     {\n       // Nothing to do here.\n     }\n \n+    /**\n+     * Returns the accessible role for the <code>JCheckBoxMenuItem</code> \n+     * component.\n+     *\n+     * @return {@link AccessibleRole#CHECK_BOX}.\n+     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.CHECK_BOX;"}, {"sha": "efb04592b505003f46678f584ae9b2a2dba9aa80", "filename": "libjava/classpath/javax/swing/JComboBox.java", "status": "modified", "additions": 172, "deletions": 41, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComboBox.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComboBox.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComboBox.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,8 +38,6 @@\n \n package javax.swing;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.ItemSelectable;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n@@ -60,6 +58,8 @@\n import javax.swing.event.PopupMenuEvent;\n import javax.swing.event.PopupMenuListener;\n import javax.swing.plaf.ComboBoxUI;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.basic.ComboPopup;\n \n /**\n  * A component that allows a user to select any item in its list and\n@@ -675,7 +675,7 @@ else if (dataModel instanceof MutableComboBoxModel)\n       }\n     else\n       throw new RuntimeException(\"Unable to remove the items because the data \"\n-                                 +\"model it is not an instance of \"\n+                                 + \"model it is not an instance of \"\n                                  + \"MutableComboBoxModel.\");\n   }\n \n@@ -848,7 +848,7 @@ public void firePopupMenuCanceled()\n   {\n     PopupMenuListener[] listeners = getPopupMenuListeners();\n     PopupMenuEvent e = new PopupMenuEvent(this);\n-    for(int i = 0; i < listeners.length; i++)\n+    for (int i = 0; i < listeners.length; i++)\n       listeners[i].popupMenuCanceled(e);\n   }\n \n@@ -862,7 +862,7 @@ public void firePopupMenuWillBecomeInvisible()\n   {\n     PopupMenuListener[] listeners = getPopupMenuListeners();\n     PopupMenuEvent e = new PopupMenuEvent(this);\n-    for(int i = 0; i < listeners.length; i++)\n+    for (int i = 0; i < listeners.length; i++)\n       listeners[i].popupMenuWillBecomeInvisible(e);\n   }\n \n@@ -876,7 +876,7 @@ public void firePopupMenuWillBecomeVisible()\n   {\n     PopupMenuListener[] listeners = getPopupMenuListeners();\n     PopupMenuEvent e = new PopupMenuEvent(this);\n-    for(int i = 0; i < listeners.length; i++)\n+    for (int i = 0; i < listeners.length; i++)\n       listeners[i].popupMenuWillBecomeVisible(e);\n   }\n \n@@ -1246,34 +1246,102 @@ public AccessibleJComboBox()\n       // Nothing to do here.\n     }\n \n+    /**\n+     * Returns the number of accessible children of this object. The\n+     * implementation of AccessibleJComboBox delegates this call to the UI\n+     * of the associated JComboBox.\n+     *\n+     * @return the number of accessible children of this object\n+     *\n+     * @see ComponentUI#getAccessibleChildrenCount(JComponent)\n+     */\n     public int getAccessibleChildrenCount()\n-      throws NotImplementedException\n     {\n-      return 0;\n+      ComponentUI ui = getUI();\n+      int count;\n+      if (ui != null)\n+        count = ui.getAccessibleChildrenCount(JComboBox.this);\n+      else\n+        count = super.getAccessibleChildrenCount();\n+      return count;\n     }\n \n-    public Accessible getAccessibleChild(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Returns the number of accessible children of this object. The\n+     * implementation of AccessibleJComboBox delegates this call to the UI\n+     * of the associated JComboBox.\n+     *\n+     * @param index the index of the accessible child to fetch\n+     *\n+     * @return the number of accessible children of this object\n+     *\n+     * @see ComponentUI#getAccessibleChild(JComponent, int)\n+     */\n+    public Accessible getAccessibleChild(int index)\n     {\n-      return null;\n+      ComponentUI ui = getUI();\n+      Accessible child = null;\n+      if (ui != null)\n+        child = ui.getAccessibleChild(JComboBox.this, index);\n+      else\n+        child = super.getAccessibleChild(index);\n+      return child;\n     }\n \n+    /**\n+     * Returns the AccessibleSelection object associated with this object.\n+     * AccessibleJComboBoxes handle their selection themselves, so this\n+     * always returns <code>this</code>.\n+     *\n+     * @return the AccessibleSelection object associated with this object\n+     */\n     public AccessibleSelection getAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      return null;\n+      return this;\n     }\n \n-    public Accessible getAccessibleSelection(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Returns the accessible selection from this AccssibleJComboBox.\n+     *\n+     * @param index the index of the selected child to fetch\n+     *\n+     * @return the accessible selection from this AccssibleJComboBox\n+     */\n+    public Accessible getAccessibleSelection(int index)\n     {\n-      return null;\n+      // Get hold of the actual popup.\n+      Accessible popup = getUI().getAccessibleChild(JComboBox.this, 0);\n+      Accessible selected = null;\n+      if (popup != null && popup instanceof ComboPopup)\n+        {\n+          ComboPopup cPopup = (ComboPopup) popup;\n+          // Query the list for the currently selected child.\n+          JList l = cPopup.getList();\n+          AccessibleContext listCtx = l.getAccessibleContext();\n+          if (listCtx != null)\n+            {\n+              AccessibleSelection s = listCtx.getAccessibleSelection();\n+              if (s != null)\n+                {\n+                  selected = s.getAccessibleSelection(index);\n+                }\n+            }\n+        }\n+      return selected;\n     }\n \n-    public boolean isAccessibleChildSelected(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Returns <code>true</code> if the accessible child with the specified\n+     * <code>index</code> is selected, <code>false</code> otherwise.\n+     *\n+     * @param index the index of the accessible child\n+     *\n+     * @return <code>true</code> if the accessible child with the specified\n+     *         <code>index</code> is selected, <code>false</code> otherwise\n+     */\n+    public boolean isAccessibleChildSelected(int index)\n     {\n-      return false;\n+      return getSelectedIndex() == index;\n     }\n \n     /**\n@@ -1286,58 +1354,121 @@ public AccessibleRole getAccessibleRole()\n       return AccessibleRole.COMBO_BOX;\n     }\n \n+    /**\n+     * Returns the accessible action associated to this accessible object.\n+     * AccessibleJComboBox implements its own AccessibleAction, so this\n+     * method returns <code>this</code>.\n+     *\n+     * @return the accessible action associated to this accessible object\n+     */\n     public AccessibleAction getAccessibleAction()\n-      throws NotImplementedException\n     {\n-      return null;\n+      return this;\n     }\n \n-    public String getAccessibleActionDescription(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Returns the description of the specified action. AccessibleJComboBox\n+     * implements 1 action (toggle the popup menu) and thus returns\n+     * <code>UIManager.getString(\"ComboBox.togglePopupText\")</code>\n+     *\n+     * @param actionIndex the index of the action for which to return the\n+     *        description\n+     *\n+     * @return the description of the specified action\n+     */\n+    public String getAccessibleActionDescription(int actionIndex)\n     {\n-      return null;\n+      return UIManager.getString(\"ComboBox.togglePopupText\");\n     }\n \n+    /**\n+     * Returns the number of accessible actions that can be performed by\n+     * this object. AccessibleJComboBox implement s one accessible action\n+     * (toggle the popup menu), so this method always returns <code>1</code>.\n+     *\n+     * @return the number of accessible actions that can be performed by\n+     *         this object\n+     */\n     public int getAccessibleActionCount()\n-      throws NotImplementedException\n     {\n-      return 0;\n+      return 1;\n     }\n \n-    public boolean doAccessibleAction(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Performs the accessible action with the specified index.\n+     * AccessibleJComboBox has 1 accessible action\n+     * (<code>actionIndex == 0</code>), which is to toggle the\n+     * popup menu. All other action indices have no effect and return\n+     * <code<>false</code>.\n+     *\n+     * @param actionIndex the index of the action to perform\n+     *\n+     * @return <code>true</code> if the action has been performed,\n+     *         <code>false</code> otherwise\n+     */\n+    public boolean doAccessibleAction(int actionIndex)\n     {\n-      return false;\n+      boolean actionPerformed = false;\n+      if (actionIndex == 0)\n+        {\n+          setPopupVisible(! isPopupVisible());\n+          actionPerformed = true;\n+        }\n+      return actionPerformed;\n     }\n \n+    /**\n+     * Returns the number of selected accessible children of this object. This\n+     * returns <code>1</code> if the combobox has a selected entry,\n+     * <code>0</code> otherwise.\n+     *\n+     * @return the number of selected accessible children of this object\n+     */\n     public int getAccessibleSelectionCount()\n-      throws NotImplementedException\n     {\n-      return 0;\n+      Object sel = getSelectedItem();\n+      int count = 0;\n+      if (sel != null)\n+        count = 1;\n+      return count;\n     }\n \n-    public void addAccessibleSelection(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Sets the current selection to the specified <code>index</code>.\n+     *\n+     * @param index the index to set as selection\n+     */\n+    public void addAccessibleSelection(int index)\n     {\n-      // TODO: Implement this properly.\n+      setSelectedIndex(index);\n     }\n \n-    public void removeAccessibleSelection(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Removes the specified index from the current selection.\n+     *\n+     * @param index the index to remove from the selection\n+     */\n+    public void removeAccessibleSelection(int index)\n     {\n-      // TODO: Implement this properly.\n+      if (getSelectedIndex() == index)\n+        clearAccessibleSelection();\n     }\n \n+    /**\n+     * Clears the current selection.\n+     */\n     public void clearAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      // TODO: Implement this properly.\n+      setSelectedIndex(-1);\n     }\n \n+    /**\n+     * Multiple selection is not supported by AccessibleJComboBox, so this\n+     * does nothing.\n+     */\n     public void selectAllAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      // TODO: Implement this properly.\n+      // Nothing to do here.\n     }\n   }\n }"}, {"sha": "b217bc7886715a860886eb164d34a66176d4e3e7", "filename": "libjava/classpath/javax/swing/JComponent.java", "status": "modified", "additions": 56, "deletions": 17, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJComponent.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -759,13 +759,6 @@ public AccessibleKeyBinding getAccessibleKeyBinding()\n    */\n   public static final int WHEN_IN_FOCUSED_WINDOW = 2;\n \n-  /**\n-   * Indicates if this component is completely dirty or not. This is used\n-   * by the RepaintManager's\n-   * {@link RepaintManager#isCompletelyDirty(JComponent)} method.\n-   */\n-  boolean isCompletelyDirty = false;\n-\n   /**\n    * Indicates if the opaque property has been set by a client program or by\n    * the UI.\n@@ -1763,11 +1756,6 @@ else if (getClientProperty(\"bufferedDragging\") == null\n             paintComponent(g2);\n             paintBorder(g2);\n             paintChildren(g2);\n-            Rectangle clip = g2.getClipBounds();\n-            if (clip == null\n-                || (clip.x == 0 && clip.y == 0 && clip.width == getWidth()\n-                && clip.height == getHeight()))\n-              RepaintManager.currentManager(this).markCompletelyClean(this);\n           }\n       }\n   }\n@@ -2373,6 +2361,19 @@ public final void setInputMap(int condition, InputMap map)\n       }\n   }\n \n+  /**\n+   * Returns the input map associated with this component for the given\n+   * state/condition.\n+   * \n+   * @param condition  the state (one of {@link #WHEN_FOCUSED}, \n+   *     {@link #WHEN_ANCESTOR_OF_FOCUSED_COMPONENT} and \n+   *     {@link #WHEN_IN_FOCUSED_WINDOW}).\n+   * \n+   * @return The input map.\n+   * @throws IllegalArgumentException if <code>condition</code> is not one of \n+   *             the specified values.\n+   * @since 1.3\n+   */\n   public final InputMap getInputMap(int condition)\n   {\n     enableEvents(AWTEvent.KEY_EVENT_MASK);\n@@ -2395,10 +2396,20 @@ public final InputMap getInputMap(int condition)\n \n       case UNDEFINED_CONDITION:\n       default:\n-        return null;\n+        throw new IllegalArgumentException(\"Invalid 'condition' argument: \" \n+                                           + condition);\n       }\n   }\n \n+  /**\n+   * Returns the input map associated with this component for the \n+   * {@link #WHEN_FOCUSED} state.\n+   * \n+   * @return The input map.\n+   * \n+   * @since 1.3\n+   * @see #getInputMap(int)\n+   */\n   public final InputMap getInputMap()\n   {\n     return getInputMap(WHEN_FOCUSED);\n@@ -3554,6 +3565,7 @@ private Component findOverlapFreeParent(Rectangle clip)\n     Rectangle currentClip = clip;\n     Component found = this;\n     Container parent = this; \n+\n     while (parent != null && !(parent instanceof Window))\n       {\n         Container newParent = parent.getParent();\n@@ -3569,15 +3581,42 @@ private Component findOverlapFreeParent(Rectangle clip)\n             parent = newParent;\n             continue;\n           }\n-        // If the parent is not optimizedDrawingEnabled, we must paint the\n-        // parent.\n+\n+        // If the parent is not optimizedDrawingEnabled, we must check if the\n+        // parent or some neighbor overlaps the current clip.\n+\n+        // This is the current clip converted to the parent's coordinate\n+        // system. TODO: We can do this more efficiently by succesively\n+        // cumulating the parent-child translations.\n         Rectangle target = SwingUtilities.convertRectangle(found,\n                                                            currentClip,\n                                                            newParent);\n-        found = newParent;\n-        currentClip = target;\n+\n+        // We have an overlap if either:\n+        // - The new parent itself doesn't completely cover the clip\n+        //   (this can be the case with viewports).\n+        // - If some higher-level (than the current) children of the new parent\n+        //   intersect the target rectangle.\n+        Rectangle parentRect = SwingUtilities.getLocalBounds(newParent);\n+        boolean haveOverlap =\n+          ! SwingUtilities.isRectangleContainingRectangle(parentRect, target);\n+        if (! haveOverlap)\n+          {\n+            Component[] children = newParent.getComponents();\n+            for (int i = 0; children[i] != parent && !haveOverlap; i++)\n+              {\n+                Rectangle childRect = children[i].getBounds();\n+                haveOverlap = target.intersects(childRect);\n+              }\n+          }\n+        if (haveOverlap)\n+          {\n+            found = newParent;\n+            currentClip = target;\n+          }\n         parent = newParent;\n       }\n+    //System.err.println(\"overlapfree parent: \" + found);\n     return found;\n   }\n "}, {"sha": "4ae3c5a1c6b025f1ee8106a63647b8cebf62fb83", "filename": "libjava/classpath/javax/swing/JEditorPane.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJEditorPane.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* JEditorPane.java --\n-   Copyright (C) 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006,  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -538,8 +538,8 @@ public JEditorPane(String type, String text)\n \n   public JEditorPane(URL url) throws IOException\n   {\n-    init ();\n-    setEditorKit (createEditorKitForContentType(\"text/html\"));;\n+    init();\n+    setEditorKit(createEditorKitForContentType(\"text/html\"));;\n     setPage(url);\n   }\n   \n@@ -581,7 +581,7 @@ public static EditorKit createEditorKitForContentType(String type)\n     // TODO: Have to handle the case where a ClassLoader was specified\n     // when the EditorKit was registered\n     EditorKit e = null;\n-    String className = (String)registerMap.get(type);\n+    String className = (String) registerMap.get(type);\n     if (className != null)\n       {\n         try"}, {"sha": "64f9bd0f4e6cc3126306017dbf9fc17ee0a7d80e", "filename": "libjava/classpath/javax/swing/JFileChooser.java", "status": "modified", "additions": 81, "deletions": 19, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFileChooser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFileChooser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFileChooser.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* JFileChooser.java --\n-   Copyright (C) 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006,  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,10 +37,9 @@\n \n package javax.swing;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.Component;\n import java.awt.Frame;\n+import java.awt.GraphicsEnvironment;\n import java.awt.HeadlessException;\n import java.awt.event.ActionEvent;\n import java.awt.event.ActionListener;\n@@ -389,6 +388,13 @@ public class JFileChooser extends JComponent implements Accessible\n    * @see #setSelectedFile(File)\n    */\n   private File selectedFile;\n+  \n+  /**\n+   * The drag enabled property.\n+   * @see #setDragEnabled(boolean)\n+   * @see #getDragEnabled()\n+   */\n+  private boolean dragEnabled;\n \n   /**\n    * Creates a new <code>JFileChooser</code> object.\n@@ -487,26 +493,31 @@ protected void setup(FileSystemView view)\n   }\n \n   /**\n-   * DOCUMENT ME!\n-   *\n-   * @param b DOCUMENT ME!\n+   * Sets the dragEnabled property, this disables/enables automatic drag\n+   * handling (drag and drop) on this component. The default value of the\n+   * dragEnabled property is false. \n+   * \n+   * Some look and feels might not support automatic drag and drop; they\n+   * will ignore this property.\n+   * \n+   * @param b - the new dragEnabled value\n    */\n   public void setDragEnabled(boolean b)\n-    throws NotImplementedException\n   {\n-    // FIXME: Implement\n+    if (b && GraphicsEnvironment.isHeadless())\n+      throw new HeadlessException();\n+    \n+    dragEnabled = b;\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns true if dragging is enabled.\n    *\n-   * @return DOCUMENT ME!\n+   * @return true if dragging is enabled.\n    */\n   public boolean getDragEnabled()\n-    throws NotImplementedException\n   {\n-    // FIXME: Implement\n-    return false;\n+    return dragEnabled;\n   }\n \n   /**\n@@ -1514,19 +1525,60 @@ public FileChooserUI getUI()\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns a string describing the attributes for the \n+   * <code>JFileChooser</code> component, for use in debugging.  The return \n+   * value is guaranteed to be non-<code>null</code>, but the format of the \n+   * string may vary between implementations.\n    *\n-   * @return DOCUMENT ME!\n+   * @return A string describing the attributes of the \n+   *     <code>JFileChooser</code>.\n    */\n   protected String paramString()\n   {\n-    return \"JFileChooser\";\n+    StringBuffer sb = new StringBuffer(super.paramString());\n+    sb.append(\",approveButtonText=\");\n+    if (approveButtonText != null)\n+      sb.append(approveButtonText);\n+    sb.append(\",currentDirectory=\");\n+    if (currentDir != null)\n+      sb.append(currentDir);\n+    sb.append(\",dialogTitle=\");\n+    if (dialogTitle != null)\n+      sb.append(dialogTitle);\n+    sb.append(\",dialogType=\");\n+    if (dialogType == OPEN_DIALOG)\n+      sb.append(\"OPEN_DIALOG\");\n+    if (dialogType == SAVE_DIALOG)\n+      sb.append(\"SAVE_DIALOG\");\n+    if (dialogType == CUSTOM_DIALOG)\n+      sb.append(\"CUSTOM_DIALOG\");\n+    sb.append(\",fileSelectionMode=\");\n+    if (fileSelectionMode == FILES_ONLY)\n+      sb.append(\"FILES_ONLY\");\n+    if (fileSelectionMode == DIRECTORIES_ONLY)\n+      sb.append(\"DIRECTORIES_ONLY\");\n+    if (fileSelectionMode == FILES_AND_DIRECTORIES)\n+      sb.append(\"FILES_AND_DIRECTORIES\");\n+    sb.append(\",returnValue=\");\n+    if (retval == APPROVE_OPTION)\n+      sb.append(\"APPROVE_OPTION\");\n+    if (retval == CANCEL_OPTION)\n+      sb.append(\"CANCEL_OPTION\");\n+    if (retval == ERROR_OPTION)\n+      sb.append(\"ERROR_OPTION\");\n+    sb.append(\",selectedFile=\");\n+    if (selectedFile != null)\n+      sb.append(selectedFile);\n+    sb.append(\",useFileHiding=\").append(fileHiding);\n+    return sb.toString();\n   }\n \n   /**\n-   * Returns the accessible context.\n+   * Returns the object that provides accessibility features for this\n+   * <code>JFileChooser</code> component.\n    *\n-   * @return The accessible context.\n+   * @return The accessible context (an instance of \n+   *     {@link AccessibleJFileChooser}).\n    */\n   public AccessibleContext getAccessibleContext()\n   {\n@@ -1536,16 +1588,26 @@ public AccessibleContext getAccessibleContext()\n   }\n \n   /**\n-   * Accessibility support for JFileChooser\n+   * Provides the accessibility features for the <code>JFileChooser</code>\n+   * component.\n    */\n   protected class AccessibleJFileChooser \n     extends JComponent.AccessibleJComponent\n   {\n+    /**\n+     * Creates a new instance of <code>AccessibleJFileChooser</code>.\n+     */\n     protected AccessibleJFileChooser()\n     {\n       // Nothing to do here.\n     }\n     \n+    /**\n+     * Returns the accessible role for the <code>JFileChooser</code> \n+     * component.\n+     *\n+     * @return {@link AccessibleRole#FILE_CHOOSER}.\n+     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.FILE_CHOOSER;"}, {"sha": "054752550388df78352ff49fd3124320b484f391", "filename": "libjava/classpath/javax/swing/JFormattedTextField.java", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFormattedTextField.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFormattedTextField.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFormattedTextField.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -101,11 +101,11 @@ public AbstractFormatter ()\n      * @throws CloneNotSupportedException if the Object's class doesn't support\n      * the {@link Cloneable} interface\n      */\n-    protected Object clone ()\n+    protected Object clone()\n       throws CloneNotSupportedException\n     {\n       // Clone this formatter.\n-      AbstractFormatter newFormatter = (AbstractFormatter)super.clone();\n+      AbstractFormatter newFormatter = (AbstractFormatter) super.clone();\n       \n       // And remove the association to the JFormattedTextField.\n       newFormatter.textField = null;\n@@ -119,7 +119,7 @@ protected Object clone ()\n      * @return <code>null</code>.  Should be subclassed by formatters that want\n      * to install custom Actions on the JFormattedTextField.\n      */\n-    protected Action[] getActions ()\n+    protected Action[] getActions()\n     {\n       return null;\n     }\n@@ -132,7 +132,7 @@ protected Action[] getActions ()\n      * @return <code>null</code>.  Should be subclassed by formatters\n      * that want to restrict Document mutations.\n      */\n-    protected DocumentFilter getDocumentFilter ()\n+    protected DocumentFilter getDocumentFilter()\n     {\n       // Subclasses should override this if they want to install a \n       // DocumentFilter.\n@@ -146,7 +146,7 @@ protected DocumentFilter getDocumentFilter ()\n      * @return the JFormattedTextField on which this formatter is currently\n      * installed\n      */\n-    protected JFormattedTextField getFormattedTextField ()\n+    protected JFormattedTextField getFormattedTextField()\n     {\n       return textField;\n     }\n@@ -159,7 +159,7 @@ protected JFormattedTextField getFormattedTextField ()\n      * @return <code>null</code>.  Subclassed by formatters that want to restrict\n      * cursor location within the JFormattedTextField.\n      */\n-    protected NavigationFilter getNavigationFilter ()\n+    protected NavigationFilter getNavigationFilter()\n     {\n       // This should be subclassed if the formatter wants to install \n       // a NavigationFilter on the JFormattedTextField.\n@@ -199,7 +199,7 @@ public void install(JFormattedTextField textField)\n             \n             // Set the DocumentFilter for the field's Document.\n             if (doc instanceof AbstractDocument)\n-              ((AbstractDocument)doc).setDocumentFilter(getDocumentFilter());\n+              ((AbstractDocument) doc).setDocumentFilter(getDocumentFilter());\n             \n             // Set the NavigationFilter.\n             textField.setNavigationFilter(getNavigationFilter());\n@@ -221,12 +221,12 @@ public void install(JFormattedTextField textField)\n      * This resets the DocumentFilter, NavigationFilter, and any additional \n      * Actions (returned by <code>getActions()</code>).     \n      */\n-    public void uninstall ()\n+    public void uninstall()\n     {\n       // Set the DocumentFilter for the field's Document.\n       Document doc = textField.getDocument();\n       if (doc instanceof AbstractDocument)\n-        ((AbstractDocument)doc).setDocumentFilter(null);\n+        ((AbstractDocument) doc).setDocumentFilter(null);\n       textField.setNavigationFilter(null);\n       // FIXME: Have to remove the Actions from getActions()\n       this.textField = null;\n@@ -236,7 +236,7 @@ public void uninstall ()\n      * Invoke this method when invalid values are entered.  This forwards the\n      * call to the JFormattedTextField.     \n      */\n-    protected void invalidEdit ()\n+    protected void invalidEdit()\n     {\n       textField.invalidEdit();\n     }\n@@ -247,7 +247,7 @@ protected void invalidEdit ()\n      * \n      * @param valid the new state for the <code>editValid</code> property\n      */\n-    protected void setEditValid (boolean valid)\n+    protected void setEditValid(boolean valid)\n     {\n       textField.editValid = valid;\n     }\n@@ -259,7 +259,7 @@ protected void setEditValid (boolean valid)\n      * @return an Object that <code>text</code> represented\n      * @throws ParseException if there is an error in the conversion\n      */\n-    public abstract Object stringToValue (String text)\n+    public abstract Object stringToValue(String text)\n       throws ParseException;\n \n     /**\n@@ -270,7 +270,7 @@ public abstract Object stringToValue (String text)\n      * @return a String to be displayed\n      * @throws ParseException if there is an error in the conversion\n      */\n-    public abstract String valueToString (Object value)\n+    public abstract String valueToString(Object value)\n       throws ParseException;\n   }\n \n@@ -280,12 +280,12 @@ public abstract String valueToString (Object value)\n    */\n   public abstract static class AbstractFormatterFactory\n   {\n-    public AbstractFormatterFactory ()\n+    public AbstractFormatterFactory()\n     {\n       // Do nothing here.\n     }\n \n-    public abstract AbstractFormatter getFormatter (JFormattedTextField tf);\n+    public abstract AbstractFormatter getFormatter(JFormattedTextField tf);\n   }\n \n   /** The possible focusLostBehavior options **/\n@@ -315,7 +315,7 @@ public AbstractFormatterFactory ()\n    * properly configure this text field to edit a particular type\n    * of value.\n    */\n-  public JFormattedTextField ()\n+  public JFormattedTextField()\n   {\n     this((AbstractFormatterFactory) null, null);\n   }\n@@ -328,7 +328,7 @@ public JFormattedTextField ()\n    * @param format the Format that this JFormattedTextField should be able\n    * to handle\n    */\n-  public JFormattedTextField (Format format)\n+  public JFormattedTextField(Format format)\n   {\n     this ();\n     setFormatterFactory(getAppropriateFormatterFactory(format));\n@@ -341,17 +341,17 @@ public JFormattedTextField (Format format)\n    * \n    * @param formatter the formatter to use for this JFormattedTextField\n    */\n-  public JFormattedTextField (AbstractFormatter formatter)\n+  public JFormattedTextField(AbstractFormatter formatter)\n   {\n-    this(new DefaultFormatterFactory (formatter));\n+    this(new DefaultFormatterFactory(formatter));\n   }\n \n   /**\n    * Creates a JFormattedTextField with the specified formatter factory.\n    * \n    * @param factory the formatter factory to use for this JFormattedTextField\n    */\n-  public JFormattedTextField (AbstractFormatterFactory factory)\n+  public JFormattedTextField(AbstractFormatterFactory factory)\n   {\n     setFormatterFactory(factory);\n   }\n@@ -363,7 +363,7 @@ public JFormattedTextField (AbstractFormatterFactory factory)\n    * @param factory the initial formatter factory for this JFormattedTextField\n    * @param value the initial value for the text field\n    */\n-  public JFormattedTextField (AbstractFormatterFactory factory, Object value)\n+  public JFormattedTextField(AbstractFormatterFactory factory, Object value)\n   {    \n     setFormatterFactory(factory);\n     setValue(value);\n@@ -375,7 +375,7 @@ public JFormattedTextField (AbstractFormatterFactory factory, Object value)\n    * \n    * @param value the initial value for this JFormattedTextField\n    */\n-  public JFormattedTextField (Object value)\n+  public JFormattedTextField(Object value)\n   {\n     setValue(value);\n   }\n@@ -387,13 +387,13 @@ public JFormattedTextField (Object value)\n    * @return a DefaultFormatterFactory whose defaultFormatter is appropriate\n    * for the given Format.\n    */\n-  private AbstractFormatterFactory getAppropriateFormatterFactory (Format format)\n+  private AbstractFormatterFactory getAppropriateFormatterFactory(Format format)\n   {\n     AbstractFormatter newFormatter;\n     if (format instanceof DateFormat)\n-      newFormatter = new DateFormatter((DateFormat)format);\n+      newFormatter = new DateFormatter((DateFormat) format);\n     else if (format instanceof NumberFormat)\n-      newFormatter = new NumberFormatter ((NumberFormat)format);\n+      newFormatter = new NumberFormatter ((NumberFormat) format);\n     else\n       newFormatter = new InternationalFormatter(format);\n     \n@@ -406,7 +406,7 @@ else if (format instanceof NumberFormat)\n    * \n    * @throws ParseException if the formatter cannot format the current value\n    */\n-  public void commitEdit ()\n+  public void commitEdit()\n     throws ParseException\n   {\n     if (formatter == null)\n@@ -427,7 +427,7 @@ public void commitEdit ()\n    * \n    * @return an array of Actions that this text field supports\n    */\n-  public Action[] getActions ()\n+  public Action[] getActions()\n   {\n     // FIXME: Add JFormattedTextField specific actions\n     // These are related to committing or cancelling edits.\n@@ -449,7 +449,7 @@ public int getFocusLostBehavior()\n    * Returns the current formatter used for this JFormattedTextField.\n    * @return the current formatter used for this JFormattedTextField\n    */\n-  public AbstractFormatter getFormatter ()\n+  public AbstractFormatter getFormatter()\n   {\n     return formatter;\n   }\n@@ -459,12 +459,12 @@ public AbstractFormatter getFormatter ()\n    * JFormattedTextField.\n    * @return the factory currently used to generate formatters\n    */\n-  public AbstractFormatterFactory getFormatterFactory ()\n+  public AbstractFormatterFactory getFormatterFactory()\n   {\n     return formatterFactory;\n   }\n \n-  public String getUIClassID ()\n+  public String getUIClassID()\n   {\n     return \"FormattedTextFieldUI\";\n   }\n@@ -475,7 +475,7 @@ public String getUIClassID ()\n    * valid edits and allows invalid input to be temporarily displayed.  \n    * @return the last committed valid value\n    */\n-  public Object getValue ()\n+  public Object getValue()\n   {\n     return value;\n   }\n@@ -484,7 +484,7 @@ public Object getValue ()\n    * This method is used to provide feedback to the user when an invalid value\n    * is input during editing.   \n    */\n-  protected void invalidEdit ()\n+  protected void invalidEdit()\n   {\n     UIManager.getLookAndFeel().provideErrorFeedback(this);\n   }\n@@ -494,7 +494,7 @@ protected void invalidEdit ()\n    * managed by the current formatted.\n    * @return true if the value being edited is valid.\n    */\n-  public boolean isEditValid ()\n+  public boolean isEditValid()\n   {\n     return editValid;\n   }\n@@ -506,7 +506,7 @@ public boolean isEditValid ()\n    * \n    * @param evt the FocusEvent\n    */\n-  protected void processFocusEvent (FocusEvent evt)\n+  protected void processFocusEvent(FocusEvent evt)\n   {\n     super.processFocusEvent(evt);\n     // Let the formatterFactory change the formatter for this text field\n@@ -561,7 +561,7 @@ public void setFocusLostBehavior(int behavior)\n    * @param formatter the AbstractFormatter to use for formatting the value for\n    * this JFormattedTextField\n    */\n-  protected void setFormatter (AbstractFormatter formatter)\n+  protected void setFormatter(AbstractFormatter formatter)\n   {\n     AbstractFormatter oldFormatter = null;\n     \n@@ -585,7 +585,7 @@ protected void setFormatter (AbstractFormatter formatter)\n    * @param factory the AbstractFormatterFactory that will be used to generate\n    * formatters for this JFormattedTextField\n    */\n-  public void setFormatterFactory (AbstractFormatterFactory factory)\n+  public void setFormatterFactory(AbstractFormatterFactory factory)\n   {\n     if (formatterFactory == factory)\n       return;\n@@ -606,7 +606,7 @@ public void setFormatterFactory (AbstractFormatterFactory factory)\n    *   \n    * @param newValue the value to be formatted and displayed\n    */\n-  public void setValue (Object newValue)\n+  public void setValue(Object newValue)\n   {\n     if (value == newValue)\n       return;"}, {"sha": "1371525ddf2c2cf84c883c3dc840382c6d09b1bc", "filename": "libjava/classpath/javax/swing/JFrame.java", "status": "modified", "additions": 67, "deletions": 19, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFrame.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFrame.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJFrame.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* JFrame.java --\n-   Copyright (C) 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006,  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -86,14 +86,16 @@ protected AccessibleJFrame()\n   /**\n    * A flag for {@link #setDefaultCloseOperation(int)}, indicating that the\n    * application should be exited, when this <code>JFrame</code> is closed.\n+   * Note that in version 1.4, the equivalent constant has been added to\n+   * {@link WindowConstants}.\n    *\n    * @since 1.3\n    */\n   public static final int EXIT_ON_CLOSE = 3;\n \n   private static final long serialVersionUID = -3362141868504252139L;\n   private static boolean defaultLookAndFeelDecorated;\n-  private int close_action = HIDE_ON_CLOSE;\n+  private int closeAction = HIDE_ON_CLOSE;\n   protected AccessibleContext accessibleContext;\n   protected JRootPane rootPane;\n   \n@@ -102,12 +104,20 @@ protected AccessibleJFrame()\n    */\n   protected boolean rootPaneCheckingEnabled = false;\n \n+  /**\n+   * Creates a new frame with an empty string for the title.\n+   */\n   public JFrame()\n   {\n-    super(\"JFrame\");\n+    super(\"\");\n     frameInit();\n   }\n \n+  /**\n+   * Creates a new <code>JFrame</code> with the specified title.\n+   * \n+   * @param title  the frame title (<code>null</code> permitted).\n+   */\n   public JFrame(String title)\n   {\n     super(title);\n@@ -147,7 +157,8 @@ public JFrame(String title, GraphicsConfiguration gc)\n \n   protected void frameInit()\n   {\n-    super.setLayout(new BorderLayout(1, 1));\n+    super.setLayout(new BorderLayout());\n+    setBackground(UIManager.getDefaults().getColor(\"control\"));\n     enableEvents(AWTEvent.WINDOW_EVENT_MASK);\n     getRootPane(); // will do set/create\n \n@@ -289,21 +300,52 @@ public static boolean isDefaultLookAndFeelDecorated()\n     return defaultLookAndFeelDecorated;\n   }\n \n+  /**\n+   * Returns the object that provides accessibility features for this \n+   * <code>JFrame</code>.\n+   *\n+   * @return The accessible context (an instance of {@link AccessibleJFrame}).\n+   */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n       accessibleContext = new AccessibleJFrame();\n     return accessibleContext;\n   }\n \n+  /**\n+   * Returns a code for the default operation when the frame is closed.  The\n+   * default value is {@link WindowConstants#HIDE_ON_CLOSE}.\n+   * \n+   * @return One of: {@link WindowConstants#DO_NOTHING_ON_CLOSE},\n+   *     {@link WindowConstants#HIDE_ON_CLOSE}, \n+   *     {@link WindowConstants#DISPOSE_ON_CLOSE}, {@link #EXIT_ON_CLOSE}.\n+   * \n+   * @see #setDefaultCloseOperation(int)\n+   */\n   public int getDefaultCloseOperation()\n   {\n-    return close_action;\n+    return closeAction;\n   }\n \n+  /**\n+   * Returns a string describing the attributes for the <code>JFrame</code>,\n+   * for use in debugging.  The return value is guaranteed to be \n+   * non-<code>null</code>, but the format may vary between implementations.\n+   * \n+   * @return A string describing the attributes of the <code>JFrame</code>.\n+   */\n   protected String paramString()\n   {\n-    return \"JFrame\";\n+    StringBuffer sb = new StringBuffer(super.paramString());\n+    sb.append(\",defaultCloseOperation=\");\n+    sb.append(SwingUtilities.convertWindowConstantToString(\n+        getDefaultCloseOperation()));\n+    sb.append(\",rootPane=\");\n+    if (rootPane != null)\n+      sb.append(rootPane);\n+    sb.append(\",rootPaneCheckingEnabled=\").append(rootPaneCheckingEnabled);\n+    return sb.toString();\n   }\n \n   protected void processWindowEvent(WindowEvent e)\n@@ -313,7 +355,7 @@ protected void processWindowEvent(WindowEvent e)\n       {\n       case WindowEvent.WINDOW_CLOSING:\n         {\n-\t  switch (close_action)\n+\t  switch (closeAction)\n \t    {\n \t    case EXIT_ON_CLOSE:\n \t      {\n@@ -346,17 +388,22 @@ protected void processWindowEvent(WindowEvent e)\n   }\n \n   /**\n-   * Defines what happens when this frame is closed. Can be one off\n-   * <code>EXIT_ON_CLOSE</code>,\n-   * <code>DISPOSE_ON_CLOSE</code>,\n-   * <code>HIDE_ON_CLOSE</code> or\n-   * <code>DO_NOTHING_ON_CLOSE</code>.\n-   * The default is <code>HIDE_ON_CLOSE</code>.\n-   * When <code>EXIT_ON_CLOSE</code> is specified this method calls\n+   * Sets the default operation that is performed when this frame is closed.\n+   * The default is <code>HIDE_ON_CLOSE</code>.  When \n+   * <code>EXIT_ON_CLOSE</code> is specified this method calls\n    * <code>SecurityManager.checkExit(0)</code> which might throw a\n-   * <code>SecurityException</code>. When the specified operation is\n-   * not one of the above a <code>IllegalArgumentException</code> is\n-   * thrown.\n+   * <code>SecurityException</code>.\n+   * \n+   * @param operation  a code for the operation (one of: \n+   *     {@link WindowConstants#DO_NOTHING_ON_CLOSE}, \n+   *     {@link WindowConstants#HIDE_ON_CLOSE}, \n+   *     {@link WindowConstants#DISPOSE_ON_CLOSE} and \n+   *     {@link WindowConstants#EXIT_ON_CLOSE}).\n+   * \n+   * @throws IllegalArgumentException if <code>operation</code> is not one of\n+   *     the specified codes.\n+   * \n+   * @see #getDefaultCloseOperation()\n    */\n   public void setDefaultCloseOperation(int operation)\n   {\n@@ -366,8 +413,9 @@ public void setDefaultCloseOperation(int operation)\n \n     if (operation != EXIT_ON_CLOSE && operation != DISPOSE_ON_CLOSE\n         && operation != HIDE_ON_CLOSE && operation != DO_NOTHING_ON_CLOSE)\n-      throw new IllegalArgumentException(\"defaultCloseOperation must be EXIT_ON_CLOSE, HIDE_ON_CLOSE, DISPOSE_ON_CLOSE, or DO_NOTHING_ON_CLOSE\");\n+      throw new IllegalArgumentException(\"operation must be EXIT_ON_CLOSE, \" \n+          + \"HIDE_ON_CLOSE, DISPOSE_ON_CLOSE, or DO_NOTHING_ON_CLOSE\");\n \n-    close_action = operation;\n+    closeAction = operation;\n   }\n }"}, {"sha": "a5fe3ba1af0c1a948d4a71184d1f2b118abb38d9", "filename": "libjava/classpath/javax/swing/JLabel.java", "status": "modified", "additions": 71, "deletions": 14, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLabel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLabel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLabel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* JLabel.java --\n-   Copyright (C) 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006,  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -50,6 +50,7 @@\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleExtendedComponent;\n+import javax.accessibility.AccessibleRole;\n import javax.accessibility.AccessibleText;\n import javax.swing.plaf.LabelUI;\n import javax.swing.text.AttributeSet;\n@@ -62,12 +63,39 @@ public class JLabel extends JComponent implements Accessible, SwingConstants\n {\n \n   /**\n-   * Accessibility support for JLabel.\n+   * Provides the accessibility features for the <code>JLabel</code>\n+   * component.\n    */\n   protected class AccessibleJLabel\n     extends JComponent.AccessibleJComponent\n     implements AccessibleText, AccessibleExtendedComponent\n   {\n+    \n+    /**\n+     * Returns the accessible name.\n+     * \n+     * @return The accessible name.\n+     */\n+    public String getAccessibleName()\n+    {\n+      if (accessibleName != null)\n+        return accessibleName;\n+      if (text != null)\n+        return text;\n+      else\n+        return super.getAccessibleName();\n+    }\n+    \n+    /**\n+     * Returns the accessible role for the <code>JLabel</code> component.\n+     *\n+     * @return {@link AccessibleRole#LABEL}.\n+     */\n+    public AccessibleRole getAccessibleRole()\n+    {\n+      return AccessibleRole.LABEL;\n+    }\n+    \n     /**\n      * Returns the selected text. This is null since JLabels\n      * are not selectable.\n@@ -297,7 +325,6 @@ public int getIndexAtPoint(Point point)\n     }\n   }\n \n-  /** DOCUMENT ME! */\n   private static final long serialVersionUID = 5496508283662221534L;\n \n   static final String LABEL_PROPERTY = \"labeledBy\";\n@@ -452,14 +479,42 @@ public String getUIClassID()\n   }\n \n   /**\n-   * This method is used primarily for debugging purposes and returns a string\n-   * that can be used to represent this label.\n+   * Returns a string describing the attributes for the <code>JLabel</code>\n+   * component, for use in debugging.  The return value is guaranteed to be \n+   * non-<code>null</code>, but the format of the string may vary between\n+   * implementations.\n    *\n-   * @return A string to represent this label.\n+   * @return A string describing the attributes of the <code>JLabel</code>.\n    */\n   protected String paramString()\n   {\n-    return super.paramString();\n+    StringBuffer sb = new StringBuffer(super.paramString());\n+    sb.append(\",defaultIcon=\");\n+    if (icon != null)\n+      sb.append(icon);\n+    sb.append(\",disabledIcon=\");\n+    if (disabledIcon != null)\n+      sb.append(disabledIcon);\n+    sb.append(\",horizontalAlignment=\");\n+    sb.append(SwingUtilities.convertHorizontalAlignmentCodeToString(\n+        horizontalAlignment));\n+    sb.append(\",horizontalTextPosition=\");\n+    sb.append(SwingUtilities.convertHorizontalAlignmentCodeToString(\n+        horizontalTextPosition));\n+    sb.append(\",iconTextGap=\").append(iconTextGap);\n+    sb.append(\",labelFor=\");\n+    if (labelFor != null)\n+      sb.append(labelFor);\n+    sb.append(\",text=\");\n+    if (text != null)\n+      sb.append(text);\n+    sb.append(\",verticalAlignment=\");\n+    sb.append(SwingUtilities.convertVerticalAlignmentCodeToString(\n+        verticalAlignment));\n+    sb.append(\",verticalTextPosition=\");\n+    sb.append(SwingUtilities.convertVerticalAlignmentCodeToString(\n+        verticalTextPosition));\n+    return sb.toString();\n   }\n \n   /**\n@@ -868,24 +923,25 @@ public void setLabelFor(Component c)\n   {\n     if (c != labelFor)\n       {\n+        Component oldLabelFor = labelFor;\n+        labelFor = c;\n+        firePropertyChange(\"labelFor\", oldLabelFor, labelFor);\n+\n         // We put the label into the client properties for the labeled\n         // component so that it can be read by the AccessibleJComponent.\n         // The other option would be to reserve a default visible field\n-        // in JComponent, but since this is relativly seldomly used, it\n+        // in JComponent, but since this is relatively seldomly used, it\n         // would be unnecessary waste of memory to do so.\n-\tComponent oldLabelFor = labelFor;\n         if (oldLabelFor instanceof JComponent)\n           {\n             ((JComponent) oldLabelFor).putClientProperty(LABEL_PROPERTY, null);\n           }\n \n-\tlabelFor = c;\n-\tif (labelFor instanceof JComponent)\n+        if (labelFor instanceof JComponent)\n           {\n             ((JComponent) labelFor).putClientProperty(LABEL_PROPERTY, this);\n           }\n \n-\tfirePropertyChange(\"labelFor\", oldLabelFor, labelFor);\n       }\n   }\n \n@@ -902,9 +958,10 @@ public void setFont(Font f)\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns the object that provides accessibility features for this\n+   * <code>JLabel</code> component.\n    *\n-   * @return The accessible context.\n+   * @return The accessible context (an instance of {@link AccessibleJLabel}).\n    */\n   public AccessibleContext getAccessibleContext()\n   {"}, {"sha": "11650e721d03692e8dd9961e6036cf663591b6a7", "filename": "libjava/classpath/javax/swing/JLayeredPane.java", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLayeredPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLayeredPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJLayeredPane.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -147,19 +147,19 @@ public AccessibleRole getAccessibleRole()\n   \n   public static final String LAYER_PROPERTY = \"layeredContainerLayer\";\n \n-  public static final Integer FRAME_CONTENT_LAYER = new Integer (-30000);\n+  public static final Integer FRAME_CONTENT_LAYER = new Integer(-30000);\n \n-  public static final Integer DEFAULT_LAYER = new Integer (0);\n-  public static final Integer PALETTE_LAYER = new Integer (100);\n-  public static final Integer MODAL_LAYER   = new Integer (200);\n-  public static final Integer POPUP_LAYER   = new Integer (300);\n-  public static final Integer DRAG_LAYER    = new Integer (400);\n+  public static final Integer DEFAULT_LAYER = new Integer(0);\n+  public static final Integer PALETTE_LAYER = new Integer(100);\n+  public static final Integer MODAL_LAYER   = new Integer(200);\n+  public static final Integer POPUP_LAYER   = new Integer(300);\n+  public static final Integer DRAG_LAYER    = new Integer(400);\n \n   private Hashtable componentToLayer;   // Component -> Layer Number (Integer)\n \n   public JLayeredPane()\n   {\n-    componentToLayer = new Hashtable ();\n+    componentToLayer = new Hashtable();\n     setLayout(null);\n   }\n "}, {"sha": "eab6be3c30c4feb553f192cb44a0f18c68a80cde", "filename": "libjava/classpath/javax/swing/JList.java", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJList.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1475,19 +1475,18 @@ public Object getSelectedValue()\n   }\n \n   /**\n-   * Returns all the values in the list's {@link #model} property which\n-   * are selected, according to the list's {@link #selectionModel} property.\n-   *\n+   * Returns all the values in the list's {@link #model} property which are\n+   * selected, according to the list's {@link #selectionModel} property.\n+   * \n    * @return An array containing all the selected values\n-   *\n    * @see #setSelectedValue\n    */\n   public Object[] getSelectedValues()\n   {\n-    int [] idx = getSelectedIndices();\n-    Object [] v = new Object[idx.length];\n+    int[] idx = getSelectedIndices();\n+    Object[] v = new Object[idx.length];\n     for (int i = 0; i < idx.length; ++i)\n-      v[i] = getModel().getElementAt(i);\n+      v[i] = getModel().getElementAt(idx[i]);\n     return v;\n   }\n "}, {"sha": "02cb20eab57bae8535ce2efdf2ec6b83b07a5f5a", "filename": "libjava/classpath/javax/swing/JMenu.java", "status": "modified", "additions": 245, "deletions": 28, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenu.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,8 +38,6 @@\n \n package javax.swing;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.Component;\n import java.awt.Point;\n import java.awt.event.KeyEvent;\n@@ -48,6 +46,7 @@\n import java.beans.PropertyChangeEvent;\n import java.beans.PropertyChangeListener;\n import java.io.Serializable;\n+import java.util.ArrayList;\n import java.util.EventListener;\n \n import javax.accessibility.Accessible;\n@@ -811,7 +810,9 @@ public AccessibleContext getAccessibleContext()\n     return accessibleContext;\n   }\n \n-  // FIXME: This inner class is a complete stub and needs to be implemented.\n+  /**\n+   * Implements support for assisitive technologies for <code>JMenu</code>.\n+   */\n   protected class AccessibleJMenu extends AccessibleJMenuItem\n     implements AccessibleSelection\n   {\n@@ -822,69 +823,245 @@ protected AccessibleJMenu()\n       // Nothing to do here.\n     }\n \n+    /**\n+     * Returns the number of accessible children of this object.\n+     *\n+     * @return the number of accessible children of this object\n+     */\n     public int getAccessibleChildrenCount()\n-      throws NotImplementedException\n     {\n-      return 0;\n+      Component[] children = getMenuComponents();\n+      int count = 0;\n+      for (int i = 0; i < children.length; i++)\n+        {\n+          if (children[i] instanceof Accessible)\n+            count++;\n+        }\n+      return count;\n     }\n \n-    public Accessible getAccessibleChild(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Returns the accessible child with the specified <code>index</code>.\n+     *\n+     * @param index the index of the child to fetch\n+     *\n+     * @return the accessible child with the specified <code>index</code>\n+     */\n+    public Accessible getAccessibleChild(int index)\n     {\n-      return null;\n+      Component[] children = getMenuComponents();\n+      int count = 0;\n+      Accessible found = null;\n+      for (int i = 0; i < children.length; i++)\n+        {\n+          if (children[i] instanceof Accessible)\n+            {\n+              if (count == index)\n+                {\n+                  found = (Accessible) children[i];\n+                  break;\n+                }\n+              count++;\n+            }\n+        }\n+      return found;\n     }\n \n+    /**\n+     * Returns the accessible selection of this object. AccessibleJMenus handle\n+     * their selection themselves, so we always return <code>this</code> here.\n+     *\n+     * @return the accessible selection of this object\n+     */\n     public AccessibleSelection getAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      return null;\n+      return this;\n     }\n \n-    public Accessible getAccessibleSelection(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Returns the selected accessible child with the specified\n+     * <code>index</code>.\n+     *\n+     * @param index the index of the accessible selected child to return\n+     *\n+     * @return the selected accessible child with the specified\n+     *         <code>index</code>\n+     */\n+    public Accessible getAccessibleSelection(int index)\n     {\n-      return null;\n+      Accessible selected = null;\n+      // Only one item can be selected, which must therefore have index == 0.\n+      if (index == 0)\n+        {\n+          MenuSelectionManager msm = MenuSelectionManager.defaultManager();\n+          MenuElement[] me = msm.getSelectedPath();\n+          if (me != null)\n+            {\n+              for (int i = 0; i < me.length; i++)\n+                {\n+                  if (me[i] == JMenu.this)\n+                    {\n+                      // This JMenu is selected, find and return the next\n+                      // JMenuItem in the path.\n+                      do\n+                        {\n+                          if (me[i] instanceof Accessible)\n+                            {\n+                              selected = (Accessible) me[i];\n+                              break;\n+                            }\n+                          i++;\n+                        } while (i < me.length);\n+                    }\n+                  if (selected != null)\n+                    break;\n+                }\n+            }\n+        }\n+      return selected;\n     }\n \n-    public boolean isAccessibleChildSelected(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Returns <code>true</code> if the accessible child with the specified\n+     * index is selected, <code>false</code> otherwise.\n+     *\n+     * @param index the index of the accessible child to check\n+     *\n+     * @return <code>true</code> if the accessible child with the specified\n+     *         index is selected, <code>false</code> otherwise\n+     */\n+    public boolean isAccessibleChildSelected(int index)\n     {\n-      return false;\n+      boolean selected = false;\n+      MenuSelectionManager msm = MenuSelectionManager.defaultManager();\n+      MenuElement[] me = msm.getSelectedPath();\n+      if (me != null)\n+        {\n+          Accessible toBeFound = getAccessibleChild(index);\n+          for (int i = 0; i < me.length; i++)\n+            {\n+              if (me[i] == toBeFound)\n+                {\n+                  selected = true;\n+                  break;\n+                }\n+            }\n+        }\n+      return selected;\n     }\n \n+    /**\n+     * Returns the accessible role of this object, which is\n+     * {@link AccessibleRole#MENU} for the AccessibleJMenu.\n+     *\n+     * @return the accessible role of this object\n+     */\n     public AccessibleRole getAccessibleRole()\n     {\n       return AccessibleRole.MENU;\n     }\n \n+    /**\n+     * Returns the number of selected accessible children. This will be\n+     * <code>0</code> if no item is selected, or <code>1</code> if an item\n+     * is selected. AccessibleJMenu can have maximum 1 selected item.\n+     *\n+     * @return the number of selected accessible children\n+     */\n     public int getAccessibleSelectionCount()\n-      throws NotImplementedException\n     {\n-      return 0;\n+      int count = 0;\n+      MenuSelectionManager msm = MenuSelectionManager.defaultManager();\n+      MenuElement[] me = msm.getSelectedPath();\n+      if (me != null)\n+        {\n+          for (int i = 0; i < me.length; i++)\n+            {\n+              if (me[i] == JMenu.this)\n+                {\n+                  if (i + 1 < me.length)\n+                    {\n+                      count = 1;\n+                      break;\n+                    }\n+                }\n+            }\n+        }\n+      return count;\n     }\n \n-    public void addAccessibleSelection(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Selects the accessible child with the specified index.\n+     *\n+     * @param index the index of the accessible child to select\n+     */\n+    public void addAccessibleSelection(int index)\n     {\n-      // TODO: Implement this properly.\n+      Accessible child = getAccessibleChild(index);\n+      if (child != null && child instanceof JMenuItem)\n+        {\n+          JMenuItem mi = (JMenuItem) child;\n+          MenuSelectionManager msm = MenuSelectionManager.defaultManager();\n+          msm.setSelectedPath(createPath(JMenu.this));\n+        }\n     }\n \n-    public void removeAccessibleSelection(int value0)\n-      throws NotImplementedException\n+    /**\n+     * Removes the item with the specified index from the selection.\n+     *\n+     * @param index the index of the selected item to remove from the selection\n+     */\n+    public void removeAccessibleSelection(int index)\n     {\n-      // TODO: Implement this properly.\n+      Accessible child = getAccessibleChild(index);\n+      if (child != null)\n+        {\n+          MenuSelectionManager msm = MenuSelectionManager.defaultManager();\n+          MenuElement[] oldSelection = msm.getSelectedPath();\n+          for (int i = 0; i < oldSelection.length; i++)\n+            {\n+              if (oldSelection[i] == child)\n+                {\n+                  // Found the specified child in the selection. Remove it\n+                  // from the selection.\n+                  MenuElement[] newSel = new MenuElement[i - 1];\n+                  System.arraycopy(oldSelection, 0, newSel, 0, i - 1);\n+                  msm.setSelectedPath(newSel);\n+                  break;\n+                }\n+            }\n+        }\n     }\n \n+    /**\n+     * Removes all possibly selected accessible children of this object from\n+     * the selection.\n+     */\n     public void clearAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      // TODO: Implement this properly.\n+      MenuSelectionManager msm = MenuSelectionManager.defaultManager();\n+      MenuElement[] oldSelection = msm.getSelectedPath();\n+      for (int i = 0; i < oldSelection.length; i++)\n+        {\n+          if (oldSelection[i] == JMenu.this)\n+            {\n+              // Found this menu in the selection. Remove all children from\n+              // the selection.\n+              MenuElement[] newSel = new MenuElement[i];\n+              System.arraycopy(oldSelection, 0, newSel, 0, i);\n+              msm.setSelectedPath(newSel);\n+              break;\n+            }\n+        }\n     }\n \n+    /**\n+     * AccessibleJMenu don't support multiple selection, so this method\n+     * does nothing.\n+     */\n     public void selectAllAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      // TODO: Implement this properly.\n+      // Nothing to do here.\n     }\n   }\n \n@@ -939,4 +1116,44 @@ public void propertyChange(PropertyChangeEvent evt)\n     }\n   }\n \n+  /**\n+   * Creates an array to be feeded as argument to\n+   * {@link MenuSelectionManager#setSelectedPath(MenuElement[])} for the\n+   * specified element. This has the effect of selecting the specified element\n+   * and all its parents.\n+   *\n+   * @param leaf the leaf element for which to create the selected path\n+   *\n+   * @return the selected path array\n+   */\n+  MenuElement[] createPath(JMenu leaf)\n+  {\n+    ArrayList path = new ArrayList();\n+    MenuElement[] array = null;\n+    Component current = leaf.getPopupMenu();\n+    while (true)\n+      {\n+        if (current instanceof JPopupMenu)\n+          {\n+            JPopupMenu popupMenu = (JPopupMenu) current;\n+            path.add(0, popupMenu);\n+            current = popupMenu.getInvoker();\n+          }\n+        else if (current instanceof JMenu)\n+          {\n+            JMenu menu = (JMenu) current;\n+            path.add(0, menu);\n+            current = menu.getParent();\n+          }\n+        else if (current instanceof JMenuBar)\n+          {\n+            JMenuBar menuBar = (JMenuBar) current;\n+            path.add(0, menuBar);\n+            array = new MenuElement[path.size()];\n+            array = (MenuElement[]) path.toArray(array);\n+            break;\n+          }\n+      }\n+    return array;\n+  }\n }"}, {"sha": "35f129377f1d36df788da792dd183bbe701fdbed", "filename": "libjava/classpath/javax/swing/JMenuBar.java", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuBar.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -370,10 +370,30 @@ public MenuElement[] getSubElements()\n   {\n     MenuElement[] subElements = new MenuElement[getComponentCount()];\n \n+    int j = 0;\n+    boolean doResize = false;\n+    MenuElement menu;\n     for (int i = 0; i < getComponentCount(); i++)\n-      subElements[i] = (MenuElement) getMenu(i);\n+      {\n+        menu = getMenu(i);\n+        if (menu != null)\n+          {\n+            subElements[j++] = (MenuElement) menu;\n+          }\n+        else\n+          doResize = true;\n+      }\n \n-    return subElements;\n+    if (! doResize)\n+      return subElements;\n+    else\n+      {\n+        MenuElement[] subElements2 = new MenuElement[j];\n+        for (int i = 0; i < j; i++)\n+          subElements2[i] = subElements[i];\n+\n+        return subElements2;\n+      }\n   }\n \n   /**\n@@ -522,6 +542,9 @@ static boolean processKeyBindingHelper(MenuElement menuElement, KeyStroke ks,\n                                          KeyEvent e, int condition,\n                                          boolean pressed)\n   {\n+    if (menuElement == null)\n+      return false;\n+\n     // First check the menuElement itself, if it's a JComponent\n     if (menuElement instanceof JComponent\n         && ((JComponent) menuElement).processKeyBinding(ks, e, condition,"}, {"sha": "90d54b1d30a58933ad464e53fc579aca6ecb2ecd", "filename": "libjava/classpath/javax/swing/JMenuItem.java", "status": "modified", "additions": 103, "deletions": 6, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJMenuItem.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -38,8 +38,6 @@\n \n package javax.swing;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.Component;\n import java.awt.event.InputEvent;\n import java.awt.event.KeyEvent;\n@@ -51,6 +49,7 @@\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n+import javax.accessibility.AccessibleState;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n import javax.swing.event.MenuDragMouseEvent;\n@@ -673,7 +672,7 @@ public MenuKeyListener[] getMenuKeyListeners()\n   }\n \n   /**\n-   * Returns a string describing the attributes for the <code>JToolTip</code>\n+   * Returns a string describing the attributes for the <code>JMenuItem</code>\n    * component, for use in debugging.  The return value is guaranteed to be \n    * non-<code>null</code>, but the format of the string may vary between\n    * implementations.\n@@ -696,7 +695,11 @@ protected String paramString()\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJMenuItem();\n+      {\n+        AccessibleJMenuItem ctx = new AccessibleJMenuItem(); \n+        addChangeListener(ctx);\n+        accessibleContext = ctx;\n+      }\n \n     return accessibleContext;\n   }\n@@ -712,6 +715,11 @@ protected class AccessibleJMenuItem extends AccessibleAbstractButton\n   {\n     private static final long serialVersionUID = 6748924232082076534L;\n \n+    private boolean armed;\n+    private boolean focusOwner;\n+    private boolean pressed;\n+    private boolean selected;\n+\n     /**\n      * Creates a new <code>AccessibleJMenuItem</code> instance.\n      */\n@@ -720,10 +728,99 @@ protected class AccessibleJMenuItem extends AccessibleAbstractButton\n       //super(component);\n     }\n \n+    /**\n+     * Receives notification when the menu item's state changes and fires\n+     * appropriate property change events to registered listeners.\n+     *\n+     * @param event the change event\n+     */\n     public void stateChanged(ChangeEvent event)\n-      throws NotImplementedException\n     {\n-      // TODO: What should be done here, if anything?\n+      // This is fired in all cases.\n+      firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,\n+                         Boolean.FALSE, Boolean.TRUE);\n+\n+      ButtonModel model = getModel();\n+\n+      // Handle the armed property.\n+      if (model.isArmed())\n+        {\n+          if (! armed)\n+            {\n+              armed = true;\n+              firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n+                                 AccessibleState.ARMED, null);\n+            }\n+        }\n+      else\n+        {\n+          if (armed)\n+            {\n+              armed = false;\n+              firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n+                                 null, AccessibleState.ARMED);\n+            }\n+        }\n+\n+      // Handle the pressed property.\n+      if (model.isPressed())\n+        {\n+          if (! pressed)\n+            {\n+              pressed = true;\n+              firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n+                                 AccessibleState.PRESSED, null);\n+            }\n+        }\n+      else\n+        {\n+          if (pressed)\n+            {\n+              pressed = false;\n+              firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n+                                 null, AccessibleState.PRESSED);\n+            }\n+        }\n+\n+      // Handle the selected property.\n+      if (model.isSelected())\n+        {\n+          if (! selected)\n+            {\n+              selected = true;\n+              firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n+                                 AccessibleState.SELECTED, null);\n+            }\n+        }\n+      else\n+        {\n+          if (selected)\n+            {\n+              selected = false;\n+              firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n+                                 null, AccessibleState.SELECTED);\n+            }\n+        }\n+\n+      // Handle the focusOwner property.\n+      if (isFocusOwner())\n+        {\n+          if (! focusOwner)\n+            {\n+              focusOwner = true;\n+              firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n+                                 AccessibleState.FOCUSED, null);\n+            }\n+        }\n+      else\n+        {\n+          if (focusOwner)\n+            {\n+              focusOwner = false;\n+              firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n+                                 null, AccessibleState.FOCUSED);\n+            }\n+        }\n     }\n \n     /**"}, {"sha": "f9490553834f69c93e92e2fa010a0dad2a0c4c91", "filename": "libjava/classpath/javax/swing/JOptionPane.java", "status": "modified", "additions": 75, "deletions": 37, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJOptionPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJOptionPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJOptionPane.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* JOptionPane.java\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,14 +38,20 @@\n \n package javax.swing;\n \n+import java.awt.AWTEvent;\n+import java.awt.ActiveEvent;\n import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.EventQueue;\n import java.awt.Frame;\n+import java.awt.MenuComponent;\n+import java.awt.Toolkit;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseMotionAdapter;\n \n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n-import javax.swing.event.InternalFrameAdapter;\n-import javax.swing.event.InternalFrameEvent;\n import javax.swing.plaf.OptionPaneUI;\n \n /**\n@@ -57,17 +63,15 @@\n public class JOptionPane extends JComponent implements Accessible\n {\n   /**\n-   * DOCUMENT ME!\n+   * Provides the accessibility features for the <code>JOptionPane</code>\n+   * component.\n    */\n-  // FIXME: This inner class is a complete stub and needs to be implemented\n-  // properly.\n   protected class AccessibleJOptionPane extends JComponent.AccessibleJComponent\n   {\n-    /** DOCUMENT ME! */\n     private static final long serialVersionUID = 686071432213084821L;\n     \n     /**\n-     * Creates a new AccessibleJOptionPane object.\n+     * Creates a new <code>AccessibleJOptionPane</code> instance.\n      */\n     protected AccessibleJOptionPane()\n     {\n@@ -86,7 +90,6 @@ public AccessibleRole getAccessibleRole()\n     }\n   }\n \n-  /** DOCUMENT ME! */\n   private static final long serialVersionUID = 5231143276678566796L;\n \n   /** The value returned when cancel option is selected. */\n@@ -431,9 +434,11 @@ public JInternalFrame createInternalFrame(Component parentComponent,\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns the object that provides accessibility features for this\n+   * <code>JOptionPane</code> component.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The accessible context (an instance of \n+   *     {@link AccessibleJOptionPane}).\n    */\n   public AccessibleContext getAccessibleContext()\n   {\n@@ -1529,31 +1534,64 @@ private boolean validOptionType(int key)\n    */\n   private static void startModal(JInternalFrame f)\n   {\n-    synchronized (f)\n-    {\n-      final JInternalFrame tmp = f;\n-      tmp.toFront();\n-\n-      f.addInternalFrameListener(new InternalFrameAdapter()\n-                                 {\n-                                   public void internalFrameClosed(InternalFrameEvent e)\n-                                   {\n-                                     synchronized (tmp)\n-                                     {\n-                                       tmp.removeInternalFrameListener(this);\n-                                       tmp.notifyAll();\n-                                     }\n-                                   }\n-                                 });\n-      try\n-        {\n-          while (! f.isClosed())\n-            f.wait();\n-        }\n-      catch (InterruptedException ignored)\n-        {\n-          // Ignore this Exception.\n-        }\n-    }\n+    // We need to add an additional glasspane-like component directly\n+    // below the frame, which intercepts all mouse events that are not\n+    // directed at the frame itself.\n+    JPanel modalInterceptor = new JPanel();\n+    modalInterceptor.setOpaque(false);\n+    JLayeredPane lp = JLayeredPane.getLayeredPaneAbove(f);\n+    lp.setLayer(modalInterceptor, JLayeredPane.MODAL_LAYER.intValue());\n+    modalInterceptor.setBounds(0, 0, lp.getWidth(), lp.getHeight());\n+    modalInterceptor.addMouseListener(new MouseAdapter(){});\n+    modalInterceptor.addMouseMotionListener(new MouseMotionAdapter(){});\n+    lp.add(modalInterceptor);\n+    f.toFront();\n+\n+    // We need to explicitly dispatch events when we are blocking the event\n+    // dispatch thread.\n+    EventQueue queue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n+    try\n+      {\n+        while (! f.isClosed())\n+          {\n+            if (EventQueue.isDispatchThread())\n+              {\n+                // The getNextEventMethod() issues wait() when no\n+                // event is available, so we don't need do explicitly wait().\n+                AWTEvent ev = queue.getNextEvent();\n+                // This mimics EventQueue.dispatchEvent(). We can't use\n+                // EventQueue.dispatchEvent() directly, because it is\n+                // protected, unfortunately.\n+                if (ev instanceof ActiveEvent)\n+                  ((ActiveEvent) ev).dispatch();\n+                else if (ev.getSource() instanceof Component)\n+                  ((Component) ev.getSource()).dispatchEvent(ev);\n+                else if (ev.getSource() instanceof MenuComponent)\n+                  ((MenuComponent) ev.getSource()).dispatchEvent(ev);\n+                // Other events are ignored as per spec in\n+                // EventQueue.dispatchEvent\n+              }\n+            else\n+              {\n+                // Give other threads a chance to become active.\n+                Thread.yield();\n+              }\n+          }\n+      }\n+    catch (InterruptedException ex)\n+      {\n+        // If we get interrupted, then leave the modal state.\n+      }\n+    finally\n+      {\n+        // Clean up the modal interceptor.\n+        lp.remove(modalInterceptor);\n+\n+        // Remove the internal frame from its parent, so it is no longer\n+        // lurking around and clogging memory.\n+        Container parent = f.getParent();\n+        if (parent != null)\n+          parent.remove(f);\n+      }\n   }\n }"}, {"sha": "c7890ea0e1e4891188a2c21297797c4ea1820419", "filename": "libjava/classpath/javax/swing/JPopupMenu.java", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJPopupMenu.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJPopupMenu.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJPopupMenu.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -52,6 +52,7 @@\n import javax.accessibility.Accessible;\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n+import javax.swing.event.MenuKeyListener;\n import javax.swing.event.PopupMenuEvent;\n import javax.swing.event.PopupMenuListener;\n import javax.swing.plaf.PopupMenuUI;\n@@ -409,6 +410,36 @@ public void addSeparator()\n     this.insert(new Separator(), -1);\n   }\n \n+  /**\n+   * Adds a MenuKeyListener to the popup.\n+   * \n+   * @param l - the listener to add.\n+   */\n+  public void addMenuKeyListener(MenuKeyListener l)\n+  {\n+    listenerList.add(MenuKeyListener.class, l);\n+  }\n+  \n+  /**\n+   * Removes a MenuKeyListener from the popup.\n+   * \n+   * @param l - the listener to remove.\n+   */\n+  public void removeMenuKeyListener(MenuKeyListener l)\n+  {\n+    listenerList.remove(MenuKeyListener.class, l);\n+  }\n+  \n+  /**\n+   * Returns array of getMenuKeyListeners that are listening to JPopupMenu.\n+   * \n+   * @return array of getMenuKeyListeners that are listening to JPopupMenu\n+   */\n+  public MenuKeyListener[] getMenuKeyListeners()\n+  {\n+    return ((MenuKeyListener[]) listenerList.getListeners(MenuKeyListener.class));\n+  }\n+  \n   /**\n    * Adds popupMenuListener to listen for PopupMenuEvents fired\n    * by the JPopupMenu"}, {"sha": "ed2d0088d065afa4635f3732dfcad325086c5b83", "filename": "libjava/classpath/javax/swing/JProgressBar.java", "status": "modified", "additions": 308, "deletions": 154, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJProgressBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJProgressBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJProgressBar.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -53,15 +53,14 @@\n import javax.swing.plaf.ProgressBarUI;\n \n /**\n- * The ProgressBar is a widget that displays in two modes. In \n- * determinate mode, it displays fills a percentage of its bar\n- * based on its current value. In indeterminate mode, it creates\n- * box and bounces it between its bounds.\n- *\n+ * A component that displays a visual indicator of the progress of a task. The\n+ * component has two modes: determinate and indeterminate.  In determinate mode,\n+ * the <code>JProgressBar</code> fills a percentage of its bar based on its \n+ * current value. In indeterminate mode, it creates box and bounces it between \n+ * its bounds.\n  * <p>\n- * JProgressBars have the following properties:\n+ * This component has the following properties:\n  * </p>\n- * \n  * <table>\n  * <tr><th> Property         </th><th> Stored in   </th><th> Bound? </th></tr>\n  * <tr><td> borderPainted    </td><td> progressBar </td><td> yes    </td></tr>\n@@ -193,75 +192,126 @@ public Number getMaximumAccessibleValue()\n \n   private static final long serialVersionUID = 1980046021813598781L;\n   \n-  /** Whether the ProgressBar is determinate. */\n+  /** \n+   * A flag that determines the mode (<code>true</code> for indeterminate, \n+   * <code>false</code> for determinate).\n+   */\n   private transient boolean indeterminate = false;\n \n-  /** The orientation of the ProgressBar. Always set by constructor. */\n+  /** \n+   * The orientation of the <code>JProgressBar</code> \n+   * ({@link SwingConstants#HORIZONTAL} or {@link SwingConstants#VERTICAL}). \n+   * Defaults to {@link SwingConstants#HORIZONTAL}.\n+   * @see #setOrientation(int)\n+   */\n   protected int orientation;\n \n-  /** Whether borders should be painted. */\n+  /** \n+   * A flag the controls whether or not the component's border is painted.\n+   * The default is <code>true</code>. \n+   * @see #setBorderPainted(boolean)\n+   */\n   protected boolean paintBorder = true;\n \n-  /** The model describing this ProgressBar. */\n+  /** \n+   * The model defining the bounds and current value for the progress bar.\n+   * @see #setModel(BoundedRangeModel) \n+   */\n   protected BoundedRangeModel model;\n \n-  /** The string that is displayed by the ProgressBar. */\n+  /** \n+   * A custom string for display in the progress bar.  If this is \n+   * <code>null</code>, a default string will be generated. \n+   * @see #setString(String)\n+   */\n   protected String progressString;\n \n-  /** Whether the string should be painted. */\n+  /** \n+   * A flag that controls whether a string is displayed within the progress \n+   * bar. \n+   * @see #setStringPainted(boolean)\n+   */\n   protected boolean paintString = false;\n \n-  /** The static changeEvent passed to all ChangeListeners. */\n+  /** \n+   * A single change event reused for all events.\n+   * @see #fireStateChanged() \n+   */\n   protected transient ChangeEvent changeEvent;\n \n-  /** The ChangeListener that listens to the model. */\n+  /** \n+   * The listener that is registered with the model. */\n   protected ChangeListener changeListener;\n \n   /**\n-   * Creates a new horizontally oriented JProgressBar object \n-   * with a minimum of 0 and a maximum of 100.\n+   * Creates a new <code>JProgressBar</code> with default attributes.  The \n+   * following defaults are used:\n+   * <p>\n+   * <ul>\n+   * <li><code>value</code>: 0;</li>\n+   * <li><code>minimum</code>: 0;</li>\n+   * <li><code>maximum</code>: 100;</li>\n+   * <li><code>orientation</code>: {@link SwingConstants#HORIZONTAL}.</li>\n+   * </ul>  \n    */\n   public JProgressBar()\n   {\n     this(HORIZONTAL, 0, 100);\n   }\n \n   /**\n-   * Creates a new JProgressBar object with a minimum of 0,\n-   * a maximum of 100, and the given orientation.\n-   *\n-   * @param orientation The orientation of the JProgressBar.\n+   * Creates a new <code>JProgressBar</code> with the specified \n+   * <code>orientation</code>.  The following defaults are used:\n+   * <p>\n+   * <ul>\n+   * <li><code>value</code>: 0;</li>\n+   * <li><code>minimum</code>: 0;</li>\n+   * <li><code>maximum</code>: 100;</li>\n+   * </ul>  \n    * \n-   * @throws IllegalArgumentException if <code>orientation</code> is not either\n-   *         {@link #HORIZONTAL} or {@link #VERTICAL}.\n+   * @param orientation  the orientation ({@link #HORIZONTAL} or \n+   *     {@link #VERTICAL}).\n+   * \n+   * @throws IllegalArgumentException if <code>orientation</code> is not one of\n+   *     the specified values.\n    */\n   public JProgressBar(int orientation)\n   {\n     this(orientation, 0, 100);\n   }\n \n   /**\n-   * Creates a new horizontally oriented JProgressBar object\n-   * with the given minimum and maximum.\n-   *\n-   * @param minimum The minimum of the JProgressBar.\n-   * @param maximum The maximum of the JProgressBar.\n+   * Creates a new <code>JProgressBar</code> with the specified value range.\n+   * The following defaults are used:\n+   * <p>\n+   * <ul>\n+   * <li><code>value</code>: <code>minimum</code>;</li>\n+   * <li><code>orientation</code>: {@link SwingConstants#HORIZONTAL}.</li>\n+   * </ul>  \n+   * \n+   * @param minimum  the lower bound of the value range.\n+   * @param maximum  the upper bound of the value range.\n    */\n   public JProgressBar(int minimum, int maximum)\n   {\n     this(HORIZONTAL, minimum, maximum);\n   }\n \n   /**\n-   * Creates a new JProgressBar object with the given minimum,\n-   * maximum, and orientation.\n-   *\n-   * @param minimum The minimum of the JProgressBar.\n-   * @param maximum The maximum of the JProgressBar.\n-   * @param orientation The orientation of the JProgressBar.\n+   * Creates a new <code>JProgressBar</code> with the specified range and\n+   * orientation.  The following defaults are used:\n+   * <p>\n+   * <ul>\n+   * <li><code>value</code>: <code>minimum</code>;</li>\n+   * </ul>  \n+   * \n+   * @param minimum  the lower bound of the value range.\n+   * @param maximum  the upper bound of the value range.\n+   * @param orientation  the orientation ({@link #HORIZONTAL} or \n+   *     {@link #VERTICAL}).\n    * \n-   * @throws IllegalArgumentException if <code>orientation</code> is not either\n-   *         {@link #HORIZONTAL} or {@link #VERTICAL}.\n+   * @throws IllegalArgumentException if <code>orientation</code> is not one of\n+   *     the specified values.\n    */\n   public JProgressBar(int orientation, int minimum, int maximum)\n   {\n@@ -276,10 +326,14 @@ public JProgressBar(int orientation, int minimum, int maximum)\n   }\n \n   /**\n-   * Creates a new horizontally oriented JProgressBar object \n-   * with the given model.\n-   *\n-   * @param model The model to be used with the JProgressBar.\n+   * Creates a new <code>JProgressBar</code> with the specified model.  The\n+   * following defaults are used:\n+   * <p>\n+   * <ul>\n+   * <li><code>orientation</code>: {@link SwingConstants#HORIZONTAL}.</li>\n+   * </ul>  \n+   * \n+   * @param model  the model (<code>null</code> not permitted).\n    */\n   public JProgressBar(BoundedRangeModel model)\n   {\n@@ -291,56 +345,81 @@ public JProgressBar(BoundedRangeModel model)\n   }\n \n   /**\n-   * This method returns the current value of the JProgressBar.\n+   * Returns the current value for the <code>JProgressBar</code>.  This value \n+   * is fetched from the model.\n    *\n-   * @return The current value of the JProgressBar.\n+   * @return The current value.\n+   * \n+   * @see #setValue(int)\n    */\n   public int getValue()\n   {\n     return model.getValue();\n   }\n \n   /**\n-   * This method sets the value of the JProgressBar.\n+   * Sets the current value for the <code>JProgressBar</code>.  The value is\n+   * stored in the component's <code>model</code> (see {@link #getModel()}).  \n+   * If the new value is different to the old value, a {@link ChangeEvent} is \n+   * sent to the model's registered listeners.  In turn, this triggers a call \n+   * to {@link #fireStateChanged()} which will send a <code>ChangeEvent</code> \n+   * to this component's registered listeners.\n+   * <p>\n+   * If <code>value</code> is outside the range <code>minimum</code> to \n+   * <code>maximum</code>, it will be set to the nearest of those boundary \n+   * values.\n    *\n-   * @param value The value of the JProgressBar.\n+   * @param value  the new value.\n+   * \n+   * @see #getValue()\n    */\n   public void setValue(int value)\n   {\n     model.setValue(value);\n   }\n \n   /**\n-   * This method paints the border of the JProgressBar\n+   * Paints the component's border, but only if {@link #isBorderPainted()}\n+   * returns <code>true</code>.\n    *\n-   * @param graphics The graphics object to paint with.\n+   * @param graphics  the graphics object to paint with.\n+   * \n+   * @see #setBorderPainted(boolean)\n    */\n   protected void paintBorder(Graphics graphics)\n   {\n     Border border = getBorder();\n     if (paintBorder && border != null)\n-      border.paintBorder(this, graphics, 0, 0,\n-                         getWidth(),\n-                         getHeight());\n+      border.paintBorder(this, graphics, 0, 0, getWidth(), getHeight());\n   }\n \n   /**\n-   * This method returns the orientation of the JProgressBar.\n+   * Returns the orientation of the <code>JProgressBar</code> component, which\n+   * is either {@link SwingConstants#HORIZONTAL} or \n+   * {@link SwingConstants#VERTICAL}.  The default orientation is \n+   * <code>HORIZONTAL</code>.\n    *\n-   * @return The orientation of the JProgressBar.\n+   * @return The orientation.\n+   * \n+   * @see #setOrientation(int)\n    */\n   public int getOrientation()\n   {\n     return orientation;\n   }\n \n   /**\n-   * This method changes the orientation property. The orientation of the \n-   * JProgressBar can be either horizontal or vertical.\n+   * Sets the orientation for this <code>JProgressBar</code> component and,\n+   * if the value changes, sends a {@link PropertyChangeEvent} (with the \n+   * property name <code>\"orientation\"</code>) to all registered listeners.\n    *\n-   * @param orientation The orientation of the JProgressBar.\n+   * @param orientation  the orientation ({@link #HORIZONTAL} or \n+   *     {@link #VERTICAL}).\n+   * \n    * @throws IllegalArgumentException if <code>orientation</code> is not\n-   *         either {@link #HORIZONTAL} or {@link #VERTICAL}.\n+   *     one of the listed values.\n+   *     \n+   * @see #getOrientation()\n    */\n   public void setOrientation(int orientation)\n   {\n@@ -349,46 +428,59 @@ public void setOrientation(int orientation)\n                                          + \" is not a legal orientation\");    \n     if (this.orientation != orientation)\n       {\n-\tint oldOrientation = this.orientation;\n-\tthis.orientation = orientation;\n-\tfirePropertyChange(\"orientation\", oldOrientation,\n-\t                   this.orientation);\n+        int oldOrientation = this.orientation;\n+        this.orientation = orientation;\n+        firePropertyChange(\"orientation\", oldOrientation, this.orientation);\n       }\n   }\n \n   /**\n-   * This method returns whether the progressString will be painted.\n+   * Returns the flag that controls whether or not the string returned by\n+   * {@link #getString()} is displayed by the <code>JProgressBar</code> \n+   * component.\n    *\n-   * @return Whether the string is painted.\n+   * @return <code>true</code> if the string should be displayed, and \n+   *     <code>false</code> otherwise.\n+   * \n+   * @see #setStringPainted(boolean)\n    */\n   public boolean isStringPainted()\n   {\n     return paintString;\n   }\n \n   /**\n-   * This method changes the stringPainted property.\n+   * Sets the flag that controls whether or not the string returned by\n+   * {@link #getString()} is displayed by the <code>JProgressBar</code> \n+   * component.  If the flag value changes, a {@link PropertyChangeEvent} (with \n+   * the property name <code>\"stringPainted\"</code>) is sent to all registered \n+   * listeners.\n    *\n-   * @param painted Whether the string is painted.\n+   * @param painted  the new flag value.\n+   * \n+   * @see #isStringPainted()\n+   * @see #setString(String)\n    */\n   public void setStringPainted(boolean painted)\n   {\n     if (paintString != painted)\n       {\n-\tboolean oldPainted = paintString;\n-\tpaintString = painted;\n-\tfirePropertyChange(\"stringPainted\", oldPainted,\n-\t                   paintString);\n+        boolean oldPainted = paintString;\n+        paintString = painted;\n+        firePropertyChange(\"stringPainted\", oldPainted, paintString);\n       }\n   }\n \n   /**\n-   * This method returns the string that is painted if the \n-   * stringPainted property is set to true. If there is no\n-   * string set, it will return a string containing the \n-   * JProgressBar's value as a percent.\n+   * Returns the string that is painted on the <code>JProgressBar</code> if \n+   * {@link #isStringPainted()} returns <code>true</code>.  If no string has \n+   * been explicitly set, this method will return a string displaying the \n+   * value of {@link #getPercentComplete()}.\n    *\n-   * @return The string that is painted.\n+   * @return The string.\n+   * \n+   * @see #setString(String)\n+   * @see #setStringPainted(boolean)\n    */\n   public String getString()\n   {\n@@ -399,161 +491,185 @@ public String getString()\n   }\n \n   /**\n-   * This method changes the string property. The string\n-   * given will be the one painted. If you want to \n-   * revert to the default string given, set the\n-   * string to null.\n+   * Sets the string to display within the progress bar and, if the new value\n+   * is different to the old value, sends a {@link PropertyChangeEvent} (with \n+   * the property name <code>\"string\"</code>) to all registered listeners. If \n+   * the string is set to <code>null</code>, {@link #getString()} will return\n+   * a default string.\n    *\n-   * @param string The string to be painted.\n+   * @param string  the string (<code>null</code> permitted).\n+   * \n+   * @see #getString()\n+   * @see #setStringPainted(boolean)\n    */\n   public void setString(String string)\n   {\n     if (((string == null || progressString == null) &&\n         string != progressString) || (string != null &&\n \t! string.equals(progressString)))\n       {\n-\tString oldString = progressString;\n-\tprogressString = string;\n-\tfirePropertyChange(\"string\", oldString, progressString);\n+        String oldString = progressString;\n+        progressString = string;\n+        firePropertyChange(\"string\", oldString, progressString);\n       }\n   }\n \n   /**\n-   * This method returns the percent of the bar\n-   * that is \"complete\". (This is the amount value / (max - min)).\n+   * Returns the current value expressed as a percentage.  This is calculated \n+   * as <code>(value - min) / (max - min)</code>.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The percentage (a value in the range 0.0 to 1.0).\n    */\n   public double getPercentComplete()\n   {\n     if (getMaximum() == getMinimum())\n       return 1.0;\n     else\n-      return (double) (model.getValue() - model.getMinimum()) / (model\n-                                                                 .getMaximum()\n-             - model.getMinimum());\n+      return (double) (model.getValue() - model.getMinimum()) \n+          / (model.getMaximum() - model.getMinimum());\n   }\n \n   /**\n-   * This method returns whether the border is painted.\n+   * Returns a flag that controls whether or not the component's border is\n+   * painted.  The default value is <code>true</code>.\n    *\n-   * @return Whether the border is painted.\n+   * @return <code>true</code> if the component's border should be painted,\n+   *     and <code>false</code> otherwise.\n+   *     \n+   * @see #setBorderPainted(boolean)\n    */\n   public boolean isBorderPainted()\n   {\n     return paintBorder;\n   }\n \n   /**\n-   * This method changes the borderPainted property.\n+   * Sets the flag that controls whether or not the component's border is\n+   * painted.  If the flag value is changed, this method sends a \n+   * {@link PropertyChangeEvent} (with the property name \"borderPainted\") to \n+   * all registered listeners.\n    *\n-   * @param painted Whether the border is painted.\n+   * @param painted  the new flag value.\n+   * \n+   * @see #isBorderPainted()\n+   * @see #paintBorder\n    */\n   public void setBorderPainted(boolean painted)\n   {\n     if (painted != paintBorder)\n       {\n-\tboolean oldPainted = paintBorder;\n-\tpaintBorder = painted;\n-\tfirePropertyChange(\"borderPainted\", oldPainted,\n-\t                   paintBorder);\n+        boolean oldPainted = paintBorder;\n+        paintBorder = painted;\n+        firePropertyChange(\"borderPainted\", oldPainted, paintBorder);\n       }\n   }\n \n   /**\n-   * This method returns the JProgressBar's UI delegate.\n+   * Returns the UI delegate for this <code>JProgressBar</code>.\n    *\n-   * @return This JProgressBar's UI delegate.\n+   * @return The UI delegate.\n    */\n   public ProgressBarUI getUI()\n   {\n     return (ProgressBarUI) ui;\n   }\n \n   /**\n-   * This method changes the UI property for this JProgressBar.\n+   * Sets the UI delegate for this component.\n    *\n-   * @param ui The new UI delegate.\n+   * @param ui  the new UI delegate.\n    */\n   public void setUI(ProgressBarUI ui)\n   {\n     super.setUI(ui);\n   }\n \n   /**\n-   * This method reverts the UI delegate for this JProgressBar\n-   * to the default for this Look and Feel.\n+   * Sets this <code>JProgressBar</code>'s UI delegate to the default \n+   * (obtained from the {@link UIManager}) for the current look and feel.\n    */\n   public void updateUI()\n   {\n     setUI((ProgressBarUI) UIManager.getUI(this));\n   }\n \n   /**\n-   * This method returns the identifier to allow the UIManager\n-   * to pick the correct class to act as the UI for\n-   * this JProgressBar.\n+   * Returns the suffix (<code>\"ProgressBarUI\"</code> in this case) used to \n+   * determine the class name for a UI delegate that can provide the look and \n+   * feel for a <code>JProgressBar</code>.\n    *\n-   * @return The UIClassID: \"ProgressBarUI\".\n+   * @return <code>\"ProgressBarUI\"</code>.\n    */\n   public String getUIClassID()\n   {\n     return \"ProgressBarUI\";\n   }\n \n   /**\n-   * This method returns a ChangeListener that gets registered\n-   * model. By default, the ChangeListener, propagates the \n-   * ChangeEvents to the ChangeListeners of the JProgressBar.\n+   * Creates a new {@link ChangeListener} that calls \n+   * {@link #fireStateChanged()} whenever it receives a {@link ChangeEvent}\n+   * (typically from the component's <code>model</code>).  This listener is \n+   * registered with the progress bar's model, so that changes made to the \n+   * model directly will automatically result in the progress bar's listeners \n+   * being notified also.\n    *\n-   * @return A new ChangeListener.\n+   * @return A new listener.\n    */\n   protected ChangeListener createChangeListener()\n   {\n     return new ChangeListener()\n       {\n-\tpublic void stateChanged(ChangeEvent ce)\n-\t{\n-\t  fireStateChanged();\n-\t}\n+        public void stateChanged(ChangeEvent ce)\n+        {\n+          fireStateChanged();\n+\t    }\n       };\n   }\n \n   /**\n-   * This method adds a ChangeListener to this JProgressBar.\n+   * Registers a listener with this component so that it will receive \n+   * notification of component state changes.\n    *\n-   * @param listener The ChangeListener to add to this JProgressBar.\n+   * @param listener  the listener.\n+   * \n+   * @see #removeChangeListener(ChangeListener)\n    */\n   public void addChangeListener(ChangeListener listener)\n   {\n     listenerList.add(ChangeListener.class, listener);\n   }\n \n   /**\n-   * This method removes a ChangeListener from this JProgressBar.\n+   * Deregisters a listener so that it no longer receives notification of\n+   * component state changes.\n    *\n-   * @param listener The ChangeListener to remove from this JProgressBar.\n+   * @param listener  the listener.\n+   * \n+   * @see #addChangeListener(ChangeListener)\n    */\n   public void removeChangeListener(ChangeListener listener)\n   {\n     listenerList.remove(ChangeListener.class, listener);\n   }\n   \n   /**\n-   * This method returns an array of all ChangeListeners listening to this\n-   * progress bar.\n+   * Returns an array of the listeners that are registered with this component.\n+   * The array may be empty, but is never <code>null</code>.\n    *\n-   * @return An array of ChangeListeners listening to this progress bar.\n+   * @return An array of listeners.\n+   * \n+   * @since 1.4\n    */\n   public ChangeListener[] getChangeListeners()\n   {\n     return (ChangeListener[]) listenerList.getListeners(ChangeListener.class);\n   }  \n \n   /**\n-   * This method is called when the JProgressBar receives a ChangeEvent\n-   * from its model. This simply propagates the event (changing the source\n-   * to the JProgressBar) to the JProgressBar's listeners.\n+   * Sends a {@link ChangeEvent} to all registered listeners to indicate that\n+   * the state of the <code>JProgressBar</code> has changed.  \n+   * \n+   * @see #createChangeListener()\n    */\n   protected void fireStateChanged()\n   {\n@@ -562,71 +678,98 @@ protected void fireStateChanged()\n       changeEvent = new ChangeEvent(this);\n     for (int i = changeListeners.length - 2; i >= 0; i -= 2)\n       {\n-\tif (changeListeners[i] == ChangeListener.class)\n-\t  ((ChangeListener) changeListeners[i + 1]).stateChanged(changeEvent);\n+        if (changeListeners[i] == ChangeListener.class)\n+          ((ChangeListener) changeListeners[i + 1]).stateChanged(changeEvent);\n       }\n   }\n \n   /**\n-   * This method returns the model used with this JProgressBar.\n+   * Returns the model for the <code>JProgressBar</code>.\n    *\n-   * @return The model used with this JProgressBar.\n+   * @return The model (never <code>null</code>).\n+   * \n+   * @see #setModel(BoundedRangeModel)\n    */\n   public BoundedRangeModel getModel()\n   {\n     return model;\n   }\n \n   /**\n-   * This method changes the model property for this JProgressBar.\n+   * Sets the model for the <code>JProgressBar</code> and sends a \n+   * {@link ChangeEvent} to all registered listeners.\n    *\n-   * @param model The model to use with this JProgressBar.\n+   * @param model  the model (<code>null</code> not permitted).\n+   * \n+   * @see #getModel()\n    */\n   public void setModel(BoundedRangeModel model)\n   {\n     if (model != this.model)\n       {\n         this.model.removeChangeListener(changeListener);\n-\tthis.model = model;\n-\tthis.model.addChangeListener(changeListener);\n-\tfireStateChanged();\n+        this.model = model;\n+        this.model.addChangeListener(changeListener);\n+        fireStateChanged();\n       }\n   }\n \n   /**\n-   * This method returns the minimum value of this JProgressBar.\n+   * Returns the minimum value for the <code>JProgressBar</code>. This defines \n+   * the lower bound for the current value, and is stored in the component's \n+   * <code>model</code>.\n    *\n-   * @return The minimum value of this JProgressBar.\n+   * @return The minimum value.\n+   * \n+   * @see #setMinimum(int)\n    */\n   public int getMinimum()\n   {\n     return model.getMinimum();\n   }\n \n   /**\n-   * This method sets the minimum value of this JProgressBar.\n-   *\n-   * @param minimum The minimum value of this JProgressBar.\n+   * Sets the minimum value for the <code>JProgressBar</code>.  The value is\n+   * stored in the component's <code>model</code> (see {@link #getModel()}).  \n+   * If the new value is different to the old value, a {@link ChangeEvent} is \n+   * sent to the model's registered listeners.  In turn, this triggers a call \n+   * to {@link #fireStateChanged()} which will send a <code>ChangeEvent</code> \n+   * to this component's registered listeners.\n+   * \n+   * @param minimum  the minimum value.\n+   * \n+   * @see #getMinimum()\n    */\n   public void setMinimum(int minimum)\n   {\n     model.setMinimum(minimum);\n   }\n \n   /**\n-   * This method returns the maximum value of this JProgressBar.\n+   * Returns the maximum value for the <code>JProgressBar</code>.  This defines \n+   * the upper bound for the current value, and is stored in the component's \n+   * <code>model</code>.\n    *\n-   * @return The maximum value of this JProgressBar.\n+   * @return The maximum value.\n+   * \n+   * @see #setMaximum(int)\n    */\n   public int getMaximum()\n   {\n     return model.getMaximum();\n   }\n \n   /**\n-   * This method sets the maximum value of this JProgressBar.\n+   * Sets the maximum value for the <code>JProgressBar</code>.  The value is\n+   * stored in the component's <code>model</code> (see {@link #getModel()}).  \n+   * If the new value is different to the old value, a {@link ChangeEvent} is \n+   * sent to the model's registered listeners.  In turn, this triggers a call \n+   * to {@link #fireStateChanged()} which will send a <code>ChangeEvent</code> \n+   * to this component's registered listeners.\n    *\n-   * @param maximum The maximum value of this JProgressBar.\n+   * @param maximum  the maximum value.\n+   * \n+   * @see #getMaximum()\n    */\n   public void setMaximum(int maximum)\n   {\n@@ -659,29 +802,40 @@ protected String paramString()\n   }\n \n   /**\n-   * This method changes the indeterminate property. If the\n-   * JProgressBar is determinate, it paints a percentage\n-   * of the bar described by its value. If it is indeterminate,\n-   * it simply bounces a box between the ends of the bar; the \n-   * value of the JProgressBar is ignored.\n+   * Sets the flag that controls the mode for this <code>JProgressBar</code>\n+   * (<code>true</code> for indeterminate mode, and <code>false</code> for\n+   * determinate mode).  If the flag value changes, this method sends a \n+   * {@link PropertyChangeEvent} (with the property name \n+   * <code>\"indeterminate\"</code>) to all registered listeners.\n+   * <p>\n+   * If the <code>JProgressBar</code> is determinate, it paints a percentage\n+   * of the bar described by its value. If it is indeterminate, it simply \n+   * bounces a box between the ends of the bar; the value of the \n+   * <code>JProgressBar</code> is ignored.\n    *\n-   * @param newValue Whether the JProgressBar is indeterminate.\n+   * @param flag  the new flag value.\n+   * \n+   * @see #isIndeterminate()\n+   * @since 1.4\n    */\n-  public void setIndeterminate(boolean newValue)\n+  public void setIndeterminate(boolean flag)\n   {\n-    if (indeterminate != newValue)\n+    if (indeterminate != flag)\n       {\n-\tboolean olddeter = indeterminate;\n-\tindeterminate = newValue;\n-\tfirePropertyChange(\"indeterminate\", olddeter,\n-\t                   indeterminate);\n+        indeterminate = flag;\n+        firePropertyChange(\"indeterminate\", !flag, indeterminate);\n       }\n   }\n \n   /**\n-   * This method returns whether the JProgressBar is indeterminate.\n+   * Returns a flag that indicates the mode for this <code>JProgressBar</code>\n+   * (<code>true</code> for indeterminate mode, and <code>false</code> for \n+   * determinate mode).  \n    *\n-   * @return Whether this JProgressBar is indeterminate.\n+   * @return A flag indicating the mode for the <code>JProgressBar</code>.\n+   * \n+   * @see #setIndeterminate(boolean)\n+   * @since 1.4\n    */\n   public boolean isIndeterminate()\n   {"}, {"sha": "bf0803ab5a106cfa443dd382b8576e9ba87c424a", "filename": "libjava/classpath/javax/swing/JScrollBar.java", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJScrollBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJScrollBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJScrollBar.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -643,14 +643,24 @@ public void setEnabled(boolean x)\n   }\n \n   /**\n-   * A string that describes this JScrollBar. Normally only used\n-   * for debugging.\n+   * Returns a string describing the attributes for the <code>JScrollBar</code>\n+   * component, for use in debugging.  The return value is guaranteed to be \n+   * non-<code>null</code>, but the format of the string may vary between\n+   * implementations.\n    *\n-   * @return A string describing this JScrollBar.\n+   * @return A string describing the attributes of the <code>JScrollBar</code>.\n    */\n   protected String paramString()\n   {\n-    return \"JScrollBar\";\n+    StringBuffer sb = new StringBuffer(super.paramString());\n+    sb.append(\",blockIncrement=\").append(blockIncrement);\n+    sb.append(\",orientation=\");\n+    if (this.orientation == JScrollBar.HORIZONTAL)\n+      sb.append(\"HORIZONTAL\");\n+    else \n+      sb.append(\"VERTICAL\");\n+    sb.append(\",unitIncrement=\").append(unitIncrement);\n+    return sb.toString();\n   }\n \n   /**"}, {"sha": "45df1d9190e5a43bb87c62dd94448c7c785eeb34", "filename": "libjava/classpath/javax/swing/JScrollPane.java", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJScrollPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJScrollPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJScrollPane.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -170,7 +170,8 @@ public JViewport getColumnHeader()\n     return columnHeader;\n   }\n \n-  public Component getCorner(String key) {\n+  public Component getCorner(String key) \n+  {\n     if (getComponentOrientation() \n         == ComponentOrientation.LEFT_TO_RIGHT)\n       {\n@@ -247,16 +248,15 @@ public Rectangle getViewportBorderBounds()\n     if (viewportBorder == null)\n       {\n         if (getViewport() == null)\n-          return new Rectangle(0,0,0,0);\n+          return new Rectangle(0, 0, 0, 0);\n         else\n           return getViewport().getBounds();\n       }\n     else\n       {\n         Insets i = viewportBorder.getBorderInsets(getViewport());\n         if (getViewport() == null)\n-          return new Rectangle(0,0,\n-                               i.left+i.right, i.top+i.bottom);\n+          return new Rectangle(0, 0, i.left + i.right, i.top + i.bottom);\n         else\n           {\n             Rectangle b = getViewport().getBounds();"}, {"sha": "8a06d4f0116c0f4897d10f95ddb19fe1c13e177a", "filename": "libjava/classpath/javax/swing/JSlider.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSlider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSlider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSlider.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -227,13 +227,13 @@ public Number getMaximumAccessibleValue()\n   }\n \n   /** Whether or not this slider paints its ticks. */\n-  private transient boolean paintTicks = false;\n+  private transient boolean paintTicks;\n \n   /** Whether or not this slider paints its track. */\n   private transient boolean paintTrack = true;\n \n   /** Whether or not this slider paints its labels. */\n-  private transient boolean paintLabels = false;\n+  private transient boolean paintLabels;\n \n   /**\n    * A dictionary of (Integer, Component) pairs where each Component is a\n@@ -251,7 +251,7 @@ public Number getMaximumAccessibleValue()\n   protected int minorTickSpacing;\n \n   /** Whether the slider snaps its values to ticks. */\n-  protected boolean snapToTicks = false;\n+  protected boolean snapToTicks;\n \n   /** The orientation (horizontal or vertical) of the slider. */\n   protected int orientation = HORIZONTAL;"}, {"sha": "16a210600cd43f26b54549aba166b415aa1ed5bb", "filename": "libjava/classpath/javax/swing/JSpinner.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSpinner.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSpinner.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSpinner.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -106,7 +106,7 @@ public DefaultEditor(JSpinner spinner)\n       add(ftf);\n       ftf.setValue(spinner.getValue());\n       ftf.addPropertyChangeListener(this);\n-      if(getComponentOrientation().isLeftToRight())\n+      if (getComponentOrientation().isLeftToRight())\n \tftf.setHorizontalAlignment(JTextField.RIGHT);\n       else\n \tftf.setHorizontalAlignment(JTextField.LEFT);"}, {"sha": "2747686a31a0bf337214c5b6e54ca7cdb900240f", "filename": "libjava/classpath/javax/swing/JSplitPane.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSplitPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSplitPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJSplitPane.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -108,7 +108,7 @@ public AccessibleRole getAccessibleRole()\n \n     /**\n      * Returns an object that provides access to the current, minimum and \n-     * maximum values for the {@link JSlider}.  Since this class implements \n+     * maximum values for the {@link JSplitPane}.  Since this class implements \n      * {@link AccessibleValue}, it returns itself.\n      *\n      * @return The accessible value.\n@@ -136,9 +136,9 @@ public Number getCurrentAccessibleValue()\n      * listeners.  If the supplied value is <code>null</code>, this method \n      * does nothing and returns <code>false</code>.\n      *\n-     * @param value  the new slider value (<code>null</code> permitted).\n+     * @param value  the new divider location (<code>null</code> permitted).\n      *\n-     * @return <code>true</code> if the slider value is updated, and \n+     * @return <code>true</code> if the divider location value is updated, and \n      *     <code>false</code> otherwise.\n      */\n     public boolean setCurrentAccessibleValue(Number value)\n@@ -699,7 +699,8 @@ public void setContinuousLayout(boolean newContinuousLayout)\n    * @param proportionalLocation A double that describes the location of the\n    *        divider.\n    *\n-   * @throws IllegalArgumentException DOCUMENT ME!\n+   * @throws IllegalArgumentException if <code>proportionalLocation</code> is\n+   *     not in the range from 0.0 to 1.0 inclusive.\n    */\n   public void setDividerLocation(double proportionalLocation)\n   {"}, {"sha": "7e2864b8a441aa9b5d4d2220f66454bb9a187fc7", "filename": "libjava/classpath/javax/swing/JTabbedPane.java", "status": "modified", "additions": 113, "deletions": 63, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTabbedPane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTabbedPane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTabbedPane.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b", "patch": "@@ -1,5 +1,5 @@\n /* JTabbedPane.java --\n-   Copyright (C) 2002, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004, 2005, 2006,  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,8 +38,6 @@\n \n package javax.swing;\n \n-import gnu.classpath.NotImplementedException;\n-\n import java.awt.Color;\n import java.awt.Component;\n import java.awt.Point;\n@@ -53,6 +51,7 @@\n import javax.accessibility.AccessibleContext;\n import javax.accessibility.AccessibleRole;\n import javax.accessibility.AccessibleSelection;\n+import javax.accessibility.AccessibleState;\n import javax.accessibility.AccessibleStateSet;\n import javax.swing.event.ChangeEvent;\n import javax.swing.event.ChangeListener;\n@@ -79,8 +78,6 @@ public class JTabbedPane extends JComponent implements Serializable,\n   /**\n    * Accessibility support for <code>JTabbedPane</code>.\n    */\n-  // FIXME: This inner class is a complete stub and must be implemented\n-  // properly.\n   protected class AccessibleJTabbedPane extends JComponent.AccessibleJComponent\n     implements AccessibleSelection, ChangeListener\n   {\n@@ -99,14 +96,17 @@ public AccessibleJTabbedPane()\n \n     /**\n      * Receives notification when the selection state of the\n-     * <code>JTabbedPane</code> changes.\n+     * <code>JTabbedPane</code> changes and fires appropriate property change\n+     * events to interested listeners.\n      *\n      * @param e the change event describing the change\n      */\n     public void stateChanged(ChangeEvent e)\n-      throws NotImplementedException\n     {\n-      // Implement this properly.\n+      // I couldn't figure out what else should be done here.\n+      Object source = e.getSource();\n+      firePropertyChange(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,\n+                         null, source);\n     }\n \n     /**\n@@ -116,9 +116,8 @@ public void stateChanged(ChangeEvent e)\n      * @return the accessible role of the <code>JTabbedPane</code>\n      */\n     public AccessibleRole getAccessibleRole()\n-      throws NotImplementedException\n     {\n-      return null;\n+      return AccessibleRole.PAGE_TAB_LIST;\n     }\n \n     /**\n@@ -129,9 +128,8 @@ public AccessibleRole getAccessibleRole()\n      *         <code>JTabbedPane</code>\n      */\n     public int getAccessibleChildrenCount()\n-      throws NotImplementedException\n     {\n-      return 0;\n+      return getTabCount();\n     }\n \n     /**\n@@ -158,9 +156,8 @@ public Accessible getAccessibleChild(int i)\n      * @return the current selection state of the <code>JTabbedPane</code>\n      */\n     public AccessibleSelection getAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      return null;\n+      return this;\n     }\n \n     /**\n@@ -175,90 +172,99 @@ public AccessibleSelection getAccessibleSelection()\n      *         this location\n      */\n     public Accessible getAccessibleAt(Point p)\n-      throws NotImplementedException\n     {\n-      return null;\n+      int tabIndex = indexAtLocation(p.x, p.y);\n+      if (tabIndex >= 0)\n+        return getAccessibleChild(tabIndex);\n+      else\n+        return getAccessibleSelection(0);\n     }\n \n     /**\n-     * The number of selected child components of the\n-     * <code>JTabbedPane</code>. This will be <code>0</code> if the\n-     * <code>JTabbedPane</code> has no children, or <code>1</code> otherwise,\n-     * since there is always exactly one tab selected. \n+     * Returns the number of selected child components of the\n+     * <code>JTabbedPane</code>. The reference implementation appears\n+     * to return <code>1</code> always and we do the same. \n      *\n-     * @return number of selected child components of the\n-     *         <code>JTabbedPane</code>\n+     * @return <code>1</code>\n      */\n     public int getAccessibleSelectionCount()\n-      throws NotImplementedException\n     {\n-      return 0;\n+      return 1;\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Returns the selected tab, or <code>null</code> if there is no \n+     * selection.\n      *\n-     * @param i DOCUMENT ME!\n+     * @param i  the selection index (ignored here).\n      *\n-     * @return DOCUMENT ME!\n+     * @return The selected tab, or <code>null</code>.\n      */\n     public Accessible getAccessibleSelection(int i)\n-      throws NotImplementedException\n     {\n-      return null;\n+      Accessible result = null;\n+      int selected = getSelectedIndex();\n+      if (selected >= 0)\n+        result = (Page) tabs.get(selected);\n+      return result;\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Returns <code>true</code> if the specified child is selected,\n+     * and <code>false</code> otherwise.\n      *\n-     * @param i DOCUMENT ME!\n+     * @param i the child index.\n      *\n-     * @return DOCUMENT ME!\n+     * @return A boolean.\n      */\n     public boolean isAccessibleChildSelected(int i)\n-      throws NotImplementedException\n     {\n-      return false;\n+      return i == getSelectedIndex();\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Selects the specified tab.\n      *\n-     * @param i DOCUMENT ME!\n+     * @param i  the index of the item to select.\n      */\n     public void addAccessibleSelection(int i)\n-      throws NotImplementedException\n     {\n-      // TODO: Implement this properly.\n+      setSelectedIndex(i);\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Does nothing - it makes no sense to remove a selection for a\n+     * tabbed pane, since one tab must always be selected.\n      *\n-     * @param i DOCUMENT ME!\n+     * @param i  the item index.\n+     * \n+     * @see #addAccessibleSelection(int)\n      */\n     public void removeAccessibleSelection(int i)\n-      throws NotImplementedException\n     {\n-      // TODO: Implement this properly.\n+      // do nothing\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Does nothing - it makes no sense to clear the selection for\n+     * a tabbed pane, since one tab must always be selected.\n+     * \n+     * @see #addAccessibleSelection(int)\n      */\n     public void clearAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      // TODO: Implement this properly.\n+      // do nothing\n     }\n \n     /**\n-     * DOCUMENT ME!\n+     * Does nothing - it makes no sense to select all for a tabbed\n+     * pane, since only one tab can be selected at a time.\n+     * \n+     * @see #addAccessibleSelection(int)\n      */\n     public void selectAllAccessibleSelection()\n-      throws NotImplementedException\n     {\n-      // TODO: Implement this properly.\n+      // do nothing\n     }\n   }\n \n@@ -267,7 +273,6 @@ public void selectAllAccessibleSelection()\n    */\n   protected class ModelListener implements ChangeListener, Serializable\n   {\n-    /** DOCUMENT ME! */\n     private static final long serialVersionUID = 497359819958114132L;\n \n     /**\n@@ -446,7 +451,6 @@ public String getTitle()\n       return title;\n     }\n \n-    /** DOCUMENT ME! */\n     private static final long serialVersionUID = 1614381073220130939L;\n \n     /**\n@@ -597,6 +601,19 @@ public AccessibleContext getAccessibleContext()\n       return this;\n     }\n \n+    /**\n+     * Returns the accessible name for this tab.\n+     * \n+     * @return The accessible name.\n+     */\n+    public String getAccessibleName()\n+    {\n+      if (accessibleName != null)\n+        return accessibleName;\n+      else\n+        return title;\n+    }\n+    \n     /**\n      * Returns the accessible role of this tab, which is always\n      * {@link AccessibleRole#PAGE_TAB}.\n@@ -608,18 +625,31 @@ public AccessibleRole getAccessibleRole()\n       return AccessibleRole.PAGE_TAB;\n     }\n \n+    /**\n+     * Returns the accessible state set of this object.\n+     *\n+     * @return the accessible state set of this object\n+     */\n     public AccessibleStateSet getAccessibleStateSet()\n-      throws NotImplementedException\n     {\n-      // FIXME: Implement this properly.\n-      return null;\n+      AccessibleContext parentCtx = JTabbedPane.this.getAccessibleContext(); \n+      AccessibleStateSet state = parentCtx.getAccessibleStateSet();\n+      state.add(AccessibleState.SELECTABLE);\n+      if (component == getSelectedComponent())\n+        state.add(AccessibleState.SELECTED);\n+      return state;\n     }\n \n+    /**\n+     * Returns the index of this tab inside its parent.\n+     *\n+     * @return the index of this tab inside its parent\n+     */\n     public int getAccessibleIndexInParent()\n-      throws NotImplementedException\n     {\n-      // FIXME: Implement this properly.\n-      return 0;\n+      // TODO: Not sure if the title is unambiguous, but I can't figure\n+      // another way of doing this.\n+      return indexOfTab(title);\n     }\n \n     /**\n@@ -1623,25 +1653,45 @@ public String getToolTipText(MouseEvent event)\n   }\n \n   /**\n-   * This method returns a string representation of this JTabbedPane. It is\n-   * mainly used for debugging purposes.\n+   * Returns a string describing the attributes for the \n+   * <code>JTabbedPane</code> component, for use in debugging.  The return \n+   * value is guaranteed to be non-<code>null</code>, but the format of the \n+   * string may vary between implementations.\n    *\n-   * @return A string representation of this JTabbedPane.\n+   * @return A string describing the attributes of the \n+   *     <code>JTabbedPane</code>.\n    */\n   protected String paramString()\n   {\n-    return \"JTabbedPane\";\n+    StringBuffer sb = new StringBuffer(super.paramString());\n+    sb.append(\",tabPlacement=\");\n+    if (tabPlacement == TOP)\n+      sb.append(\"TOP\");\n+    if (tabPlacement == BOTTOM)\n+      sb.append(\"BOTTOM\");\n+    if (tabPlacement == LEFT)\n+      sb.append(\"LEFT\");\n+    if (tabPlacement == RIGHT)\n+      sb.append(\"RIGHT\");\n+    return sb.toString();\n   }\n \n   /**\n-   * DOCUMENT ME!\n+   * Returns the object that provides accessibility features for this\n+   * <code>JTabbedPane</code> component.\n    *\n-   * @return DOCUMENT ME!\n+   * @return The accessible context (an instance of \n+   *         {@link AccessibleJTabbedPane}).\n    */\n   public AccessibleContext getAccessibleContext()\n   {\n     if (accessibleContext == null)\n-      accessibleContext = new AccessibleJTabbedPane();\n+      {\n+        AccessibleJTabbedPane ctx = new AccessibleJTabbedPane();\n+        addChangeListener(ctx);\n+        accessibleContext = ctx;\n+      }\n+\n     return accessibleContext;\n   }\n }"}, {"sha": "855530881f5ec97aacf103b72d59bd12214da09a", "filename": "libjava/classpath/javax/swing/JTable.java", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTable.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "fe4d2ae204630fcc598fd08fca94c1bb110833ca", "filename": "libjava/classpath/javax/swing/JToolBar.java", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJToolBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJToolBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJToolBar.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "f7583ad69e26f6874982ac3bacb656d735acf4fc", "filename": "libjava/classpath/javax/swing/JTree.java", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTree.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTree.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJTree.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7cf393996c374023a14160f9c39283635d8f1ec8", "filename": "libjava/classpath/javax/swing/JViewport.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJViewport.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FJViewport.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FJViewport.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "f7ac9496c30be81e3869274a8035b439a8aefa90", "filename": "libjava/classpath/javax/swing/KeyboardManager.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FKeyboardManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FKeyboardManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FKeyboardManager.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "499362d045bf0365f71d21c40695e4e5d275bd2a", "filename": "libjava/classpath/javax/swing/ListSelectionModel.java", "status": "modified", "additions": 250, "deletions": 14, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FListSelectionModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FListSelectionModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FListSelectionModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "beafbf4420277dde365a148196f1318f30aac811", "filename": "libjava/classpath/javax/swing/MenuSelectionManager.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FMenuSelectionManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FMenuSelectionManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FMenuSelectionManager.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "28d22e8a63e26d3f652bb7157680fbb09d5fe63a", "filename": "libjava/classpath/javax/swing/ProgressMonitor.java", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FProgressMonitor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FProgressMonitor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FProgressMonitor.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "4a0581c0e499959f45b531739351f23108626ea1", "filename": "libjava/classpath/javax/swing/RepaintManager.java", "status": "modified", "additions": 77, "deletions": 68, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FRepaintManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FRepaintManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FRepaintManager.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "5d02d9bb39672ddae7c0461718e94e8f153e5d15", "filename": "libjava/classpath/javax/swing/SwingUtilities.java", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FSwingUtilities.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "40a36b27d24f89553b6b3b26222b900ba6bd6ecf", "filename": "libjava/classpath/javax/swing/TransferHandler.java", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FTransferHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FTransferHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FTransferHandler.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "bf5242f655230f462fdf5039157982837a812d6e", "filename": "libjava/classpath/javax/swing/UIDefaults.java", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIDefaults.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIDefaults.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIDefaults.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "e6f8011632101140175486261bf884f26631d35e", "filename": "libjava/classpath/javax/swing/UIManager.java", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FUIManager.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "598a61e149bdd530f9a98c5dac17e559895adab7", "filename": "libjava/classpath/javax/swing/WindowConstants.java", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FWindowConstants.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2FWindowConstants.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2FWindowConstants.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "16bb238c37432b5bd0912fbcda0ac3b8059d6541", "filename": "libjava/classpath/javax/swing/border/AbstractBorder.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FAbstractBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FAbstractBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FAbstractBorder.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "5b4761e9ec890efdba18e69d1250e0ef2caf473f", "filename": "libjava/classpath/javax/swing/border/BevelBorder.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FBevelBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FBevelBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FBevelBorder.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "2ee639cf9a34f5cded4d56472ff209e94c0cc37f", "filename": "libjava/classpath/javax/swing/border/CompoundBorder.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FCompoundBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FCompoundBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FCompoundBorder.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "944cd2866db621a4b1dbaeac63ff2fe20a45d1a7", "filename": "libjava/classpath/javax/swing/border/MatteBorder.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FMatteBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FMatteBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FMatteBorder.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "56146e01d1b7063c43e584fe24922a180fd718d2", "filename": "libjava/classpath/javax/swing/border/TitledBorder.java", "status": "modified", "additions": 305, "deletions": 424, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FTitledBorder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FTitledBorder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fborder%2FTitledBorder.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "6a2f34ebb3de5ed9fdea5b088527686cdce83093", "filename": "libjava/classpath/javax/swing/event/EventListenerList.java", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fevent%2FEventListenerList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fevent%2FEventListenerList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fevent%2FEventListenerList.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "0a537c4bdd81e1f50d70c6a56434389cb3b87560", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicButtonUI.java", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicButtonUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "1010139b8fc88d3810806821d08b63417ea00430", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicCheckBoxUI.java", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicCheckBoxUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ea6f98504351c3258d204ddabb5e4e4f8ca9accb", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicComboBoxUI.java", "status": "modified", "additions": 57, "deletions": 69, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboBoxUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "0d822955bbc76381e5eb7fcaf750534bf7d22874", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicComboPopup.java", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboPopup.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboPopup.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicComboPopup.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ef7a880c2ac22497db049c8729107a2d2af12bcd", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicDirectoryModel.java", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDirectoryModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDirectoryModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicDirectoryModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "9adb0c642ba7fbf82f5989687226bfac21b3f4ca", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicFileChooserUI.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFileChooserUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFileChooserUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicFileChooserUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "cad0d0e8abe94f970d6d26b12735c0e87c517f16", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicIconFactory.java", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicIconFactory.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "6beac6c971b1acf0f347b06931e766d8ba29b00d", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicInternalFrameUI.java", "status": "modified", "additions": 125, "deletions": 91, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicInternalFrameUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "44f6a4089843416661c4759d0d4aa38ac6dbca67", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicListUI.java", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicListUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "5a08b2a39823fa709610b9a85aaf72b05c101773", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicLookAndFeel.java", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicLookAndFeel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "91bf614340ddb3f76e79343029beb87eded72fe4", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicOptionPaneUI.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicOptionPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "458f10204f080249072100dcb64ea328d8f66aa6", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicPanelUI.java", "status": "modified", "additions": 53, "deletions": 11, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPanelUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPanelUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicPanelUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "2518a91997aa2647e2ad9bba4cbbb56aa4f894fb", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicProgressBarUI.java", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicProgressBarUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "64a1deca572705ed3acfd50523f3c220997bf2ea", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicRadioButtonUI.java", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRadioButtonUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "e20bc2bb3db4184a58ac026ea0b9cbb68e06c589", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicRootPaneUI.java", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicRootPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "03fb2255e887703c7084a39df316c0b35d6ed65d", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicScrollPaneUI.java", "status": "modified", "additions": 234, "deletions": 22, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicScrollPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "0569768a627620f71a59eeaad910bd090d6a32a7", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicSliderUI.java", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSliderUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "254a9a4fa2baa45eb130a74a8a11872ed5f40d77", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicSpinnerUI.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSpinnerUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSpinnerUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSpinnerUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "2d595597424027dcd8c1bbd572b408caa76245d4", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicSplitPaneUI.java", "status": "modified", "additions": 140, "deletions": 10, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicSplitPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "1b5249770ec6e53eacba6c8a63d121bac18a0d85", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTabbedPaneUI.java", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTabbedPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ce8846ff8afb710ffb10b6f01e81ddff9458cd9e", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTableHeaderUI.java", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableHeaderUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableHeaderUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableHeaderUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "d3abba217cdec58c914333184526c558d80d6711", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTableUI.java", "status": "modified", "additions": 49, "deletions": 18, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTableUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "3f5aa27cf401c78e30cdefccb84747d014ebe90e", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTextAreaUI.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextAreaUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextAreaUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextAreaUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "b058175a454019bfcb1b67063c8ed509393585d8", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTextUI.java", "status": "modified", "additions": 63, "deletions": 37, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTextUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "921648670df89dca48b45af60fed01edfe3469af", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicToggleButtonUI.java", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToggleButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToggleButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToggleButtonUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "eabac1570363c0f772084cf0f8dfa0e1f8ec2adf", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicToolBarUI.java", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicToolBarUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "8cbea7f592d9350ad9735cf2a30faa922f454cd6", "filename": "libjava/classpath/javax/swing/plaf/basic/BasicTreeUI.java", "status": "modified", "additions": 554, "deletions": 246, "changes": 800, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTreeUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTreeUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FBasicTreeUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "47876491160661a26be91692dcc12ebec1ca8155", "filename": "libjava/classpath/javax/swing/plaf/basic/SharedUIDefaults.java", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FSharedUIDefaults.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FSharedUIDefaults.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fbasic%2FSharedUIDefaults.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7c41180aeae5ab8e0f207d1b87fbb5cf10c131ba", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalBorders.java", "status": "modified", "additions": 62, "deletions": 38, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalBorders.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalBorders.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalBorders.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "d6cc1bc07f968d8492c484bd5be23a76d5523945", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalButtonUI.java", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalButtonUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "c7941642e678d58130174461855850feb2210c22", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalCheckBoxUI.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalCheckBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalCheckBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalCheckBoxUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "6a528de2b6bc867149b47a494d44ba2d0415d43e", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalComboBoxButton.java", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalComboBoxButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalComboBoxButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalComboBoxButton.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "944ce394405f75628bd1a6b5143707d7dbb0e4df", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalComboBoxIcon.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalComboBoxIcon.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalComboBoxIcon.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalComboBoxIcon.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "1219ad9fd111ebd07bbcd7c72fdaf49f91fed3b8", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalFileChooserUI.java", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalFileChooserUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalFileChooserUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalFileChooserUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "4e4c863c9797abf5cee4e4dfcd0376328b84c496", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalIconFactory.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalIconFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalIconFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalIconFactory.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "dd0c486396bed6c99b5db709b5273efb41a01689", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalInternalFrameTitlePane.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameTitlePane.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameTitlePane.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameTitlePane.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "abe6a2817e16dae85fa9344b94eb90fdf82b2753", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalInternalFrameUI.java", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalInternalFrameUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "09eafd40fe95d5b722d74e984de5094a8a7a406a", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalLookAndFeel.java", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalLookAndFeel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7c580f90f39460d6a9df9a820d2ed291f255c139", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalPopupMenuSeparatorUI.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalPopupMenuSeparatorUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalPopupMenuSeparatorUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalPopupMenuSeparatorUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "046e4942ee15d457bc36cfc50788e7f021f94e64", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalRadioButtonUI.java", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRadioButtonUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRadioButtonUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRadioButtonUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "eaee5bf929e289c5928ceddffd535b124c2e2e9a", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalRootPaneUI.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRootPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRootPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalRootPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "75f2750ae9c777909aed36d5025d4eadf86d90dc", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalScrollBarUI.java", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalScrollBarUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalScrollBarUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalScrollBarUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "6d7818f8b223486912411969b2a05d430e68d43b", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalSeparatorUI.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSeparatorUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSeparatorUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSeparatorUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "0f824418c5df0795ebd930e69513a332c0551bdc", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalSliderUI.java", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSliderUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSliderUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSliderUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "6081c355c3763d7ba939422a0dc3c57bcf4e4169", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalSplitPaneDivider.java", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSplitPaneDivider.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSplitPaneDivider.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalSplitPaneDivider.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "c49abe832e4485145c6aeb10e82fc6b5d037912f", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalTabbedPaneUI.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalTabbedPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalTabbedPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalTabbedPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "d1040347fc61ac3455c925ba2f7babf40b4ae3ac", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalToolTipUI.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToolTipUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToolTipUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalToolTipUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "72cbb34a6dc4e075081d3dc4e22f62a82fc4bcc3", "filename": "libjava/classpath/javax/swing/plaf/metal/MetalUtils.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalUtils.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalUtils.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmetal%2FMetalUtils.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "33b432152bfa75a468c1cb62c0be4a2cbccf270f", "filename": "libjava/classpath/javax/swing/plaf/multi/MultiComboBoxUI.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiComboBoxUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiComboBoxUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiComboBoxUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "719f04374973bc9e49f96891cc76a5cbb50e9274", "filename": "libjava/classpath/javax/swing/plaf/multi/MultiFileChooserUI.java", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiFileChooserUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiFileChooserUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiFileChooserUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "78c22419f34254a7016dda2f1b874b28b1e2fcf7", "filename": "libjava/classpath/javax/swing/plaf/multi/MultiListUI.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiListUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiListUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiListUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "12351655a045007f4b30b6dd054f0e30afc7b879", "filename": "libjava/classpath/javax/swing/plaf/multi/MultiLookAndFeel.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiLookAndFeel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiLookAndFeel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiLookAndFeel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "8d6f3861cff7ca25e5638b99132be867a194a301", "filename": "libjava/classpath/javax/swing/plaf/multi/MultiOptionPaneUI.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiOptionPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiOptionPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiOptionPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "70ea4f13be11d33cc40e4d04f7569042b1dd59d5", "filename": "libjava/classpath/javax/swing/plaf/multi/MultiSplitPaneUI.java", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiSplitPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiSplitPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiSplitPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "2a2599bde1bb30810f630335122e902b8e156bc6", "filename": "libjava/classpath/javax/swing/plaf/multi/MultiTabbedPaneUI.java", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiTabbedPaneUI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiTabbedPaneUI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Fplaf%2Fmulti%2FMultiTabbedPaneUI.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7914e0b3f46a033fc2365919929888985b4c3136", "filename": "libjava/classpath/javax/swing/table/AbstractTableModel.java", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FAbstractTableModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FAbstractTableModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FAbstractTableModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "79285903c00e70c8cdbcae98e25d0ffbe45ab7e2", "filename": "libjava/classpath/javax/swing/table/DefaultTableModel.java", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FDefaultTableModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FDefaultTableModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FDefaultTableModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "482317ff0adf097fce6450f1e1e88b8be696c323", "filename": "libjava/classpath/javax/swing/table/JTableHeader.java", "status": "modified", "additions": 328, "deletions": 95, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FJTableHeader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FJTableHeader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FJTableHeader.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "15070a7555fc98c1a7d702f916e4dbdc0cffb499", "filename": "libjava/classpath/javax/swing/table/TableCellEditor.java", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FTableCellEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FTableCellEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FTableCellEditor.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "6c1fecf560bf36fb32ac8fbdc35caeecf63e0530", "filename": "libjava/classpath/javax/swing/table/TableCellRenderer.java", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FTableCellRenderer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FTableCellRenderer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftable%2FTableCellRenderer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "8d5a6075df48cf17a3a983938ea1fc2c72879da8", "filename": "libjava/classpath/javax/swing/text/AbstractWriter.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FAbstractWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FAbstractWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FAbstractWriter.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "4ad204c00c99f42da0ff77ae492f19dcd2f4cc05", "filename": "libjava/classpath/javax/swing/text/DefaultCaret.java", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultCaret.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "8602e69f8e73d73344b8acb4a53193eec3bcbfbf", "filename": "libjava/classpath/javax/swing/text/DefaultEditorKit.java", "status": "modified", "additions": 326, "deletions": 225, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultEditorKit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultEditorKit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FDefaultEditorKit.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "f41f90130926526cac88cad9a251ca308a257471", "filename": "libjava/classpath/javax/swing/text/FieldView.java", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FFieldView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FFieldView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FFieldView.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "1780d7ddfada0a4f4e6d5e100701babe64528c47", "filename": "libjava/classpath/javax/swing/text/GapContent.java", "status": "modified", "additions": 255, "deletions": 214, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FGapContent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FGapContent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FGapContent.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "9de151dfbac6da1d8cab9e2210f72c32764db062", "filename": "libjava/classpath/javax/swing/text/JTextComponent.java", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FJTextComponent.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "48fe37ce880e3e71e7f508208860d861dd1c1771", "filename": "libjava/classpath/javax/swing/text/PlainView.java", "status": "modified", "additions": 121, "deletions": 112, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FPlainView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FPlainView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FPlainView.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "63df3df6a91dde9ed2562e9514020bb3b4f65882", "filename": "libjava/classpath/javax/swing/text/StyleContext.java", "status": "modified", "additions": 97, "deletions": 22, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FStyleContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FStyleContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FStyleContext.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "144166e9cdb4018f36859dc0b8f4414268eb29ef", "filename": "libjava/classpath/javax/swing/text/TextAction.java", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FTextAction.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FTextAction.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FTextAction.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "36361f49796bb6d589720b6c3f81d64d5af969ee", "filename": "libjava/classpath/javax/swing/text/Utilities.java", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2FUtilities.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "b7a706904a4c74b22785f2042cb5c8fdee08af99", "filename": "libjava/classpath/javax/swing/text/html/HTMLDocument.java", "status": "modified", "additions": 17, "deletions": 137, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FHTMLDocument.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FHTMLDocument.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FHTMLDocument.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "adda4922d574c744be68ca96ec46f53480bcecda", "filename": "libjava/classpath/javax/swing/text/html/HTMLEditorKit.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FHTMLEditorKit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FHTMLEditorKit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FHTMLEditorKit.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "84b021070a9f4945e3ef04c6970b207c13705e9b", "filename": "libjava/classpath/javax/swing/text/html/ImageView.java", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FImageView.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FImageView.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FImageView.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "d42951a05eca375663b141507114d8df4a1d1cd1", "filename": "libjava/classpath/javax/swing/text/html/MinimalHTMLWriter.java", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FMinimalHTMLWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FMinimalHTMLWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftext%2Fhtml%2FMinimalHTMLWriter.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "155343f5bcc49157b466334707bf7b39c94af43f", "filename": "libjava/classpath/javax/swing/tree/AbstractLayoutCache.java", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FAbstractLayoutCache.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FAbstractLayoutCache.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FAbstractLayoutCache.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "6951b9600052200c412f7e7f8f0bb8a270b265cd", "filename": "libjava/classpath/javax/swing/tree/DefaultMutableTreeNode.java", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultMutableTreeNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultMutableTreeNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultMutableTreeNode.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "b0a4d8db823f1d89e58238d6a26eda87627d65ad", "filename": "libjava/classpath/javax/swing/tree/DefaultTreeCellEditor.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellEditor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellEditor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellEditor.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "e120b71c1674aa74555e0d1037c3341739032836", "filename": "libjava/classpath/javax/swing/tree/DefaultTreeCellRenderer.java", "status": "modified", "additions": 233, "deletions": 209, "changes": 442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellRenderer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellRenderer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeCellRenderer.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "5819d15b627a00a6c2a046fd44c3da3f71240dbb", "filename": "libjava/classpath/javax/swing/tree/DefaultTreeModel.java", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "0684ef7665906e4e7a047e62d5bcc5af775cece2", "filename": "libjava/classpath/javax/swing/tree/DefaultTreeSelectionModel.java", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeSelectionModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeSelectionModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FDefaultTreeSelectionModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "57531d542007fbcb0a14bbe875274ee4887092fc", "filename": "libjava/classpath/javax/swing/tree/ExpandVetoException.java", "status": "modified", "additions": 32, "deletions": 39, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FExpandVetoException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FExpandVetoException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FExpandVetoException.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "a699a6c9f21a1c2731b8fe3660df9a9f8a5fb864", "filename": "libjava/classpath/javax/swing/tree/FixedHeightLayoutCache.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FFixedHeightLayoutCache.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FFixedHeightLayoutCache.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FFixedHeightLayoutCache.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "59eb1e3a9fab5a9b3822e23a359e5c4ca38aff99", "filename": "libjava/classpath/javax/swing/tree/RowMapper.java", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FRowMapper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FRowMapper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FRowMapper.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ae7380c703b45758c46ec315ad10313326315e8f", "filename": "libjava/classpath/javax/swing/tree/TreeNode.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreeNode.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreeNode.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreeNode.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "93b59b07edf7ff33c355d5192f9973567772543f", "filename": "libjava/classpath/javax/swing/tree/TreePath.java", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreePath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreePath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreePath.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "9bdc99be350b9248af0f6b27954a93c9d868dd4d", "filename": "libjava/classpath/javax/swing/tree/TreeSelectionModel.java", "status": "modified", "additions": 65, "deletions": 37, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreeSelectionModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreeSelectionModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FTreeSelectionModel.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "0a787f7ca8cac4401362e26e6f549ca08ddcdf52", "filename": "libjava/classpath/javax/swing/tree/VariableHeightLayoutCache.java", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FVariableHeightLayoutCache.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FVariableHeightLayoutCache.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjavax%2Fswing%2Ftree%2FVariableHeightLayoutCache.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "00594b55607245a58dfa2b69d7a3e73fe96375fe", "filename": "libjava/classpath/lib/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Flib%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Flib%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "a05b06dd784697026c05b37f053555c5bc7fd417", "filename": "libjava/classpath/native/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "d5c2e0608fa6c0c5e0a08ae397cc45bb757e3ce1", "filename": "libjava/classpath/native/fdlibm/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Ffdlibm%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Ffdlibm%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Ffdlibm%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "e9f2658a694370b8a055b5ef39bca17506a9343c", "filename": "libjava/classpath/native/jawt/.cvsignore", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjawt%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjawt%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjawt%2F.cvsignore?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "01abf3bb9345719d24719e909b022599df036a7e", "filename": "libjava/classpath/native/jawt/Makefile.am", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjawt%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjawt%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjawt%2FMakefile.am?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "683bbb9dea53aa79cb8867e0cdf4e9d5d772f150", "filename": "libjava/classpath/native/jawt/Makefile.in", "status": "modified", "additions": 47, "deletions": 44, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjawt%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjawt%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjawt%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "30e9f37fca6252bdfd7388bbaee2209157aa3d78", "filename": "libjava/classpath/native/jni/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "967dd6e8140d6e82a0c07ee949fb588a3285c024", "filename": "libjava/classpath/native/jni/classpath/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fclasspath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fclasspath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fclasspath%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "d358aeb9c854565140af9f78cdf11135adb512a6", "filename": "libjava/classpath/native/jni/classpath/jcl.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fclasspath%2Fjcl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fclasspath%2Fjcl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fclasspath%2Fjcl.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "e9f2658a694370b8a055b5ef39bca17506a9343c", "filename": "libjava/classpath/native/jni/gtk-peer/.cvsignore", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2F.cvsignore?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "fda823c042746c367585464680e217123b9683c9", "filename": "libjava/classpath/native/jni/gtk-peer/Makefile.am", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2FMakefile.am?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "9c155172121e73810b29111c234b565b6f1822a3", "filename": "libjava/classpath/native/jni/gtk-peer/Makefile.in", "status": "modified", "additions": 43, "deletions": 62, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "2c12384deaf6cfafcd91e7db17ff27481d2098a1", "filename": "libjava/classpath/native/jni/gtk-peer/cairographics2d.h", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fcairographics2d.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fcairographics2d.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fcairographics2d.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "238ff9e261326597238c2c0b9932adb531ccc592", "filename": "libjava/classpath/native/jni/gtk-peer/gdkdisplay.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgdkdisplay.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgdkdisplay.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgdkdisplay.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "f4f7c28d37ee3a3adf3e3e689a6ca2f2d8d4e1b1", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_CairoGraphics2D.c", "status": "added", "additions": 703, "deletions": 0, "changes": 703, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_CairoGraphics2D.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_CairoGraphics2D.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_CairoGraphics2D.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "3518aead590b7daf4be6765dfd3f2192d8175bee", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_CairoSurface.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_CairoSurface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_CairoSurface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_CairoSurface.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7e3c83808c8326091ca254b45d3cd9fc4dacd274", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_ComponentGraphics.c", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_ComponentGraphics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_ComponentGraphics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_ComponentGraphics.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "76caa5d0c0040b11b3a07fa08e6a99a5669e37d6", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_ComponentGraphicsCopy.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_ComponentGraphicsCopy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_ComponentGraphicsCopy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_ComponentGraphicsCopy.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "42abd983c7a8a6197cd76449596d854cc38ba74f", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_FreetypeGlyphVector.c", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_FreetypeGlyphVector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_FreetypeGlyphVector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_FreetypeGlyphVector.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ddaece1b278809715661592c36da1046403b7b92", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkFontPeer.c", "status": "modified", "additions": 83, "deletions": 138, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkFontPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkFontPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkFontPeer.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "89adcd1e5257da798a692d4cf275af0ee160ae22", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphicsEnvironment.c", "status": "modified", "additions": 141, "deletions": 1, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphicsEnvironment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphicsEnvironment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphicsEnvironment.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "965fb5a2342ff354f1d4278a5d0f0f10ac9f3894", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.c", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkScreenGraphicsDevice.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "92f2d37ca42a022504d503d851a4c67affe2af20", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkTextLayout.c", "status": "modified", "additions": 139, "deletions": 15, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkTextLayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkTextLayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkTextLayout.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ef9ac12076af9adeb21d16c9c3b8a3fe98627d4d", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkCanvasPeer.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCanvasPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCanvasPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkCanvasPeer.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7ce1185a46da2056d692e3709f3062e7728e368b", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkClipboard.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkClipboard.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkClipboard.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkClipboard.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "4cd80a73f1bf513cfd6ca771484df49d18ba117b", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkComponentPeer.c", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkComponentPeer.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "76696431424452f9ba72a57c5a8b55cba68b3438", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkFramePeer.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFramePeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFramePeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkFramePeer.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ff3fbe896b9ee2c43b5218a5c87fa2cea7cde880", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkImage.c", "status": "modified", "additions": 63, "deletions": 289, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkImage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkImage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkImage.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "c966f6331a469e8ae448abfe16c9e71f6fe14a03", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkToolkit.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkToolkit.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "5ca21a5677a57763ba999863dc0f66d8447b2a60", "filename": "libjava/classpath/native/jni/gtk-peer/gnu_java_awt_peer_gtk_GtkVolatileImage.c", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkVolatileImage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkVolatileImage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GtkVolatileImage.c?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "065d20608f56917060960eb1f6c79072aa093e3b", "filename": "libjava/classpath/native/jni/gtk-peer/gtkpeer.h", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgtkpeer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgtkpeer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fgtk-peer%2Fgtkpeer.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ca4b8a4728ffe57a76176381ec087b37d8172878", "filename": "libjava/classpath/native/jni/java-io/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-io%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-io%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-io%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "70e673b3b31d96ccad759caeacacc75fd3d05488", "filename": "libjava/classpath/native/jni/java-lang/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-lang%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-lang%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-lang%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "cc47eb3fb73cb85064fa46e636abac8a51729af1", "filename": "libjava/classpath/native/jni/java-net/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-net%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-net%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-net%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "5634c92cea5bf6a8287154fc8097a4f4d4ffbc8c", "filename": "libjava/classpath/native/jni/java-nio/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-nio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-nio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-nio%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7adf1a4ddaa21cbda882b7aef5f523f3a73d75ad", "filename": "libjava/classpath/native/jni/java-util/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-util%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-util%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fjava-util%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "b0650c08d03cc37a1616ce9f699acfa2920710c9", "filename": "libjava/classpath/native/jni/midi-alsa/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fmidi-alsa%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fmidi-alsa%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fmidi-alsa%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "969e029c7a4ded536514a1ae4ec9dc1bfcc362bc", "filename": "libjava/classpath/native/jni/midi-dssi/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fmidi-dssi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fmidi-dssi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fmidi-dssi%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "369a52a2a3c2abcb24cc378e51153a83128ec3de", "filename": "libjava/classpath/native/jni/qt-peer/.cvsignore", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2F.cvsignore?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "537ead6318b3eb3793e9b19a2c79b2b8873c1b8b", "filename": "libjava/classpath/native/jni/qt-peer/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "ae56da8e7aa6470cc68b20dc94296d2c519065a8", "filename": "libjava/classpath/native/jni/qt-peer/eventmethods.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2Feventmethods.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2Feventmethods.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2Feventmethods.h?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "6f35c89b9bdb8f38a00d0d48da24cce519671696", "filename": "libjava/classpath/native/jni/qt-peer/qtmenupeer.cpp", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2Fqtmenupeer.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2Fqtmenupeer.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fqt-peer%2Fqtmenupeer.cpp?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "01f27548860302e542f6bee76672dde97feae04d", "filename": "libjava/classpath/native/jni/xmlj/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fxmlj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fjni%2Fxmlj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fjni%2Fxmlj%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "17cbfe80b7d072d30f100b9ccdbf3424e289ad8e", "filename": "libjava/classpath/native/plugin/.cvsignore", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fplugin%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fplugin%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fplugin%2F.cvsignore?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "19c7618d8d529254584edfa9d0873d1e18cc6144", "filename": "libjava/classpath/native/plugin/Makefile.am", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fplugin%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fplugin%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fplugin%2FMakefile.am?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "22b8d3d093427f610fb2ad535d637e802bbe9991", "filename": "libjava/classpath/native/plugin/Makefile.in", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fplugin%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fplugin%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fplugin%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "deae81097721747216967f0176d3dc0a64f1f86e", "filename": "libjava/classpath/native/plugin/gcjwebplugin.cc", "status": "added", "additions": 1759, "deletions": 0, "changes": 1759, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fplugin%2Fgcjwebplugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Fplugin%2Fgcjwebplugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Fplugin%2Fgcjwebplugin.cc?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "4b36aa7fabd95ce1512dc4ccc658840a70a1af9d", "filename": "libjava/classpath/native/target/Linux/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Ftarget%2FLinux%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Ftarget%2FLinux%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Ftarget%2FLinux%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "5e35e28c22ffa26d2685cfbc678031d3056686ee", "filename": "libjava/classpath/native/target/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Ftarget%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Ftarget%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Ftarget%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7b046f6c9f47713902ce2e85965f0f67a31c40d9", "filename": "libjava/classpath/native/target/generic/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Ftarget%2Fgeneric%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fnative%2Ftarget%2Fgeneric%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fnative%2Ftarget%2Fgeneric%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "67a9d6c5e23d9c2cc1df70e9b2491424d3a87d50", "filename": "libjava/classpath/resource/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fresource%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fresource%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fresource%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "71c01165c237ed0e4541080f0a14750991097e48", "filename": "libjava/classpath/scripts/Makefile.in", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fscripts%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Fscripts%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fscripts%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "cf3688511ad48e9ee2c63a4944c51d093778c3d4", "filename": "libjava/classpath/tools/.cvsignore", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2F.cvsignore?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "201939832f0b4aea56b543d3f5cf59bac5807d74", "filename": "libjava/classpath/tools/Makefile.am", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2FMakefile.am?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "d43c1b5ce3346b1089d13e8e3ccd1ac3d29fbf1a", "filename": "libjava/classpath/tools/Makefile.in", "status": "modified", "additions": 317, "deletions": 34, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2FMakefile.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "81e39ad91e6894389aa7e6c9e2c6b27e77dd2ead", "filename": "libjava/classpath/tools/appletviewer.in", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fappletviewer.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fappletviewer.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fappletviewer.in?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "dfbedfe36d2ceea7ad41ce603ff01f129142d4fd", "filename": "libjava/classpath/tools/gnu/classpath/tools/appletviewer/AppletClassLoader.java", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletClassLoader.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "32ab31639ca7c0443338bd37c633e5ec117bf8d8", "filename": "libjava/classpath/tools/gnu/classpath/tools/appletviewer/AppletSecurityManager.java", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletSecurityManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletSecurityManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletSecurityManager.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "80d572857ca31ff6188d3ebe5e1bb4d811afd502", "filename": "libjava/classpath/tools/gnu/classpath/tools/appletviewer/AppletTag.java", "status": "added", "additions": 489, "deletions": 0, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletTag.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletTag.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletTag.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "b2376a4cb77f1527b428f0c0d7977286a525f94f", "filename": "libjava/classpath/tools/gnu/classpath/tools/appletviewer/AppletWarning.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletWarning.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletWarning.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FAppletWarning.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "7e118e93162c0410744dfdb6017a193607ee1ba7", "filename": "libjava/classpath/tools/gnu/classpath/tools/appletviewer/CommonAppletContext.java", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FCommonAppletContext.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FCommonAppletContext.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FCommonAppletContext.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "bc0cc45e1280be3fe2e977003947e771f9e632a3", "filename": "libjava/classpath/tools/gnu/classpath/tools/appletviewer/CommonAppletStub.java", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FCommonAppletStub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FCommonAppletStub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FCommonAppletStub.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "9c937cc779d6ee7853c00978e32da0560a204fea", "filename": "libjava/classpath/tools/gnu/classpath/tools/appletviewer/ConsoleDialog.java", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FConsoleDialog.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FConsoleDialog.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FConsoleDialog.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}, {"sha": "059dbee40afd817f0df504091163ad5c53c62d92", "filename": "libjava/classpath/tools/gnu/classpath/tools/appletviewer/ErrorApplet.java", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FErrorApplet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02440ca432f1aa4de7aeda563d2493a20148554b/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FErrorApplet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Ftools%2Fgnu%2Fclasspath%2Ftools%2Fappletviewer%2FErrorApplet.java?ref=02440ca432f1aa4de7aeda563d2493a20148554b"}]}