{"sha": "62c8d76c1037198e2400ff2f55adddf352988af7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJjOGQ3NmMxMDM3MTk4ZTI0MDBmZjJmNTVhZGRkZjM1Mjk4OGFmNw==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2015-09-20T16:37:39Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2015-09-20T16:37:39Z"}, "message": "[AArch64][2/5] Improve aarch64_internal_mov_immediate by using faster algorithm\n\n2015-09-20  Wilco Dijkstra  <wdijkstr@arm.com>\n\n\t* config/aarch64/aarch64.c (aarch64_internal_mov_immediate): Replace\n\tslow immediate matching loops with a faster algorithm.\n\nFrom-SVN: r227947", "tree": {"sha": "aa3bab41a992a32959eee1f52224617e80a453c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa3bab41a992a32959eee1f52224617e80a453c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62c8d76c1037198e2400ff2f55adddf352988af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c8d76c1037198e2400ff2f55adddf352988af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c8d76c1037198e2400ff2f55adddf352988af7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c8d76c1037198e2400ff2f55adddf352988af7/comments", "author": null, "committer": null, "parents": [{"sha": "a64c73a2f00ab4ab6a7485b34626d07ea2b2d519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a64c73a2f00ab4ab6a7485b34626d07ea2b2d519"}], "stats": {"total": 101, "additions": 28, "deletions": 73}, "files": [{"sha": "a4504b0c19aebf5b8a293256275ee4015c8aa8fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8d76c1037198e2400ff2f55adddf352988af7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8d76c1037198e2400ff2f55adddf352988af7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62c8d76c1037198e2400ff2f55adddf352988af7", "patch": "@@ -1,3 +1,8 @@\n+2015-09-20  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_internal_mov_immediate): Replace\n+\tslow immediate matching loops with a faster algorithm.\n+\n 2015-09-20  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_bitmask_imm): Reimplement using"}, {"sha": "8097c35041b2b5ef5a285b2e4a2147429999ef79", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 23, "deletions": 73, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62c8d76c1037198e2400ff2f55adddf352988af7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62c8d76c1037198e2400ff2f55adddf352988af7/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=62c8d76c1037198e2400ff2f55adddf352988af7", "patch": "@@ -1442,7 +1442,7 @@ aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n   unsigned HOST_WIDE_INT mask;\n   int i;\n   bool first;\n-  unsigned HOST_WIDE_INT val;\n+  unsigned HOST_WIDE_INT val, val2;\n   bool subtargets;\n   rtx subtarget;\n   int one_match, zero_match, first_not_ffff_match;\n@@ -1569,85 +1569,35 @@ aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n \t}\n     }\n \n-  /* See if we can do it by arithmetically combining two\n-     immediates.  */\n-  for (i = 0; i < AARCH64_NUM_BITMASKS; i++)\n+  if (zero_match != 2 && one_match != 2)\n     {\n-      int j;\n-      mask = 0xffff;\n+      /* Try emitting a bitmask immediate with a movk replacing 16 bits.\n+\t For a 64-bit bitmask try whether changing 16 bits to all ones or\n+\t zeroes creates a valid bitmask.  To check any repeated bitmask,\n+\t try using 16 bits from the other 32-bit half of val.  */\n \n-      if (aarch64_uimm12_shift (val - aarch64_bitmasks[i])\n-\t  || aarch64_uimm12_shift (-val + aarch64_bitmasks[i]))\n+      for (i = 0; i < 64; i += 16, mask <<= 16)\n \t{\n-\t  if (generate)\n-\t    {\n-\t      subtarget = subtargets ? gen_reg_rtx (DImode) : dest;\n-\t      emit_insn (gen_rtx_SET (subtarget,\n-\t\t\t\t      GEN_INT (aarch64_bitmasks[i])));\n-\t      emit_insn (gen_adddi3 (dest, subtarget,\n-\t\t\t\t     GEN_INT (val - aarch64_bitmasks[i])));\n-\t    }\n-\t  num_insns += 2;\n-\t  return num_insns;\n+\t  val2 = val & ~mask;\n+\t  if (val2 != val && aarch64_bitmask_imm (val2, mode))\n+\t    break;\n+\t  val2 = val | mask;\n+\t  if (val2 != val && aarch64_bitmask_imm (val2, mode))\n+\t    break;\n+\t  val2 = val2 & ~mask;\n+\t  val2 = val2 | (((val2 >> 32) | (val2 << 32)) & mask);\n+\t  if (val2 != val && aarch64_bitmask_imm (val2, mode))\n+\t    break;\n \t}\n-\n-      for (j = 0; j < 64; j += 16, mask <<= 16)\n+      if (i != 64)\n \t{\n-\t  if ((aarch64_bitmasks[i] & ~mask) == (val & ~mask))\n+\t  if (generate)\n \t    {\n-\t      if (generate)\n-\t\t{\n-\t\t  emit_insn (gen_rtx_SET (dest,\n-\t\t\t\t\t  GEN_INT (aarch64_bitmasks[i])));\n-\t\t  emit_insn (gen_insv_immdi (dest, GEN_INT (j),\n-\t\t\t\t\t     GEN_INT ((val >> j) & 0xffff)));\n-\t\t}\n-\t      num_insns += 2;\n-\t      return num_insns;\n+\t      emit_insn (gen_rtx_SET (dest, GEN_INT (val2)));\n+\t      emit_insn (gen_insv_immdi (dest, GEN_INT (i),\n+\t\t\t GEN_INT ((val >> i) & 0xffff)));\n \t    }\n-\t}\n-    }\n-\n-  /* See if we can do it by logically combining two immediates.  */\n-  for (i = 0; i < AARCH64_NUM_BITMASKS; i++)\n-    {\n-      if ((aarch64_bitmasks[i] & val) == aarch64_bitmasks[i])\n-\t{\n-\t  int j;\n-\n-\t  for (j = i + 1; j < AARCH64_NUM_BITMASKS; j++)\n-\t    if (val == (aarch64_bitmasks[i] | aarch64_bitmasks[j]))\n-\t      {\n-\t\tif (generate)\n-\t\t  {\n-\t\t    subtarget = subtargets ? gen_reg_rtx (mode) : dest;\n-\t\t    emit_insn (gen_rtx_SET (subtarget,\n-\t\t\t\t\t    GEN_INT (aarch64_bitmasks[i])));\n-\t\t    emit_insn (gen_iordi3 (dest, subtarget,\n-\t\t\t\t\t   GEN_INT (aarch64_bitmasks[j])));\n-\t\t  }\n-\t\tnum_insns += 2;\n-\t\treturn num_insns;\n-\t      }\n-\t}\n-      else if ((val & aarch64_bitmasks[i]) == val)\n-\t{\n-\t  int j;\n-\n-\t  for (j = i + 1; j < AARCH64_NUM_BITMASKS; j++)\n-\t    if (val == (aarch64_bitmasks[j] & aarch64_bitmasks[i]))\n-\t      {\n-\t\tif (generate)\n-\t\t  {\n-\t\t    subtarget = subtargets ? gen_reg_rtx (mode) : dest;\n-\t\t    emit_insn (gen_rtx_SET (subtarget,\n-\t\t\t\t\t    GEN_INT (aarch64_bitmasks[j])));\n-\t\t    emit_insn (gen_anddi3 (dest, subtarget,\n-\t\t\t\t\t   GEN_INT (aarch64_bitmasks[i])));\n-\t\t  }\n-\t\tnum_insns += 2;\n-\t\treturn num_insns;\n-\t      }\n+\t  return 2;\n \t}\n     }\n "}]}