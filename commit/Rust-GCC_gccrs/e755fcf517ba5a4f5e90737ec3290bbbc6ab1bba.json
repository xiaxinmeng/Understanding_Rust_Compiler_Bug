{"sha": "e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc1NWZjZjUxN2JhNWE0ZjVlOTA3MzdlYzMyOTBiYmJjNmFiMWJiYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-02-23T21:03:05Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-02-23T21:03:05Z"}, "message": "re PR middle-end/26316 (loop-invariant miscompiles openmp.c)\n\n\tPR rtl-optimization/26316\n\t* rtlanal.c (enum may_trap_p_flags): New.\n\t(may_trap_p_1): Take flags instead of unaligned_mems argument.  Ignore\n\tMEM_NOTRAP_P if flags & MTP_AFTER_MOVE.\n\t(may_trap_p, may_trap_or_fault_p): Pass flags to may_trap_p_1.\n\t(may_trap_after_code_motion_p): New function.\n\t* loop-invariant.c (find_identical_invariants): Fix dump formating.\n\t(find_invariant_insn): Use may_trap_after_code_motion_p.\n\t* rtl.h (may_trap_after_code_motion_p): Declare.\n\nFrom-SVN: r111397", "tree": {"sha": "0279569a12cde36a792d11397042f36e68a2ff7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0279569a12cde36a792d11397042f36e68a2ff7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/comments", "author": null, "committer": null, "parents": [{"sha": "65acccdd22e3fc50f4272bc274e10e96dbbcd527", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65acccdd22e3fc50f4272bc274e10e96dbbcd527", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65acccdd22e3fc50f4272bc274e10e96dbbcd527"}], "stats": {"total": 57, "additions": 46, "deletions": 11}, "files": [{"sha": "4400f9a6160807842558e5eececfae4f9cda353c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba", "patch": "@@ -1,3 +1,15 @@\n+2006-02-23  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/26316\n+\t* rtlanal.c (enum may_trap_p_flags): New.\n+\t(may_trap_p_1): Take flags instead of unaligned_mems argument.  Ignore\n+\tMEM_NOTRAP_P if flags & MTP_AFTER_MOVE.\n+\t(may_trap_p, may_trap_or_fault_p): Pass flags to may_trap_p_1.\n+\t(may_trap_after_code_motion_p): New function.\n+\t* loop-invariant.c (find_identical_invariants): Fix dump formating.\n+\t(find_invariant_insn): Use may_trap_after_code_motion_p.\n+\t* rtl.h (may_trap_after_code_motion_p): Declare.\n+\n 2006-02-23  Zdenek Dvorak <dvorakz@suse.cz>\n \n \t* emit-rtl.c (immed_double_const): Cleanup."}, {"sha": "553e9fe91cf4af2274eed5e419ef7e33da09d5a1", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba", "patch": "@@ -479,7 +479,7 @@ find_identical_invariants (htab_t eq, struct invariant *inv)\n \n   if (dump_file && inv->eqto != inv->invno)\n     fprintf (dump_file,\n-\t     \"Invariant %d is equivalent to invariant %d.\\n \",\n+\t     \"Invariant %d is equivalent to invariant %d.\\n\",\n \t     inv->invno, inv->eqto);\n }\n \n@@ -775,7 +775,7 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n     return;\n \n   /* We cannot make trapping insn executed, unless it was executed before.  */\n-  if (may_trap_p (PATTERN (insn)) && !always_reached)\n+  if (may_trap_after_code_motion_p (PATTERN (insn)) && !always_reached)\n     return;\n \n   depends_on = BITMAP_ALLOC (NULL);"}, {"sha": "6e17a224621a6996e70c86a1cd323008d2b1d4ae", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba", "patch": "@@ -1716,6 +1716,7 @@ extern int side_effects_p (rtx);\n extern int volatile_refs_p (rtx);\n extern int volatile_insn_p (rtx);\n extern int may_trap_p (rtx);\n+extern int may_trap_after_code_motion_p (rtx);\n extern int may_trap_or_fault_p (rtx);\n extern int inequality_comparisons_p (rtx);\n extern rtx replace_rtx (rtx, rtx, rtx);"}, {"sha": "d8c9fb8a1bf35756b86352d1d92553641f4c42af", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=e755fcf517ba5a4f5e90737ec3290bbbc6ab1bba", "patch": "@@ -2033,16 +2033,25 @@ side_effects_p (rtx x)\n   return 0;\n }\n \f\n-/* Return nonzero if evaluating rtx X might cause a trap.  UNALIGNED_MEMS\n-   controls whether nonzero is returned for unaligned memory accesses on\n-   strict alignment machines.  */\n+enum may_trap_p_flags\n+{\n+  MTP_UNALIGNED_MEMS = 1,\n+  MTP_AFTER_MOVE = 2\n+};\n+/* Return nonzero if evaluating rtx X might cause a trap.\n+   (FLAGS & MTP_UNALIGNED_MEMS) controls whether nonzero is returned for\n+   unaligned memory accesses on strict alignment machines.  If\n+   (FLAGS & AFTER_MOVE) is true, returns nonzero even in case the expression\n+   cannot trap at its current location, but it might become trapping if moved\n+   elsewhere.  */\n \n static int\n-may_trap_p_1 (rtx x, bool unaligned_mems)\n+may_trap_p_1 (rtx x, unsigned flags)\n {\n   int i;\n   enum rtx_code code;\n   const char *fmt;\n+  bool unaligned_mems = (flags & MTP_UNALIGNED_MEMS) != 0;\n \n   if (x == 0)\n     return 0;\n@@ -2072,7 +2081,11 @@ may_trap_p_1 (rtx x, bool unaligned_mems)\n \n       /* Memory ref can trap unless it's a static var or a stack slot.  */\n     case MEM:\n-      if (MEM_NOTRAP_P (x)\n+      if (/* MEM_NOTRAP_P only relates to the actual position of the memory\n+\t     reference; moving it out of condition might cause its address\n+\t     become invalid.  */\n+\t  !(flags & MTP_AFTER_MOVE)\n+\t  && MEM_NOTRAP_P (x)\n \t  && (!STRICT_ALIGNMENT || !unaligned_mems))\n \treturn 0;\n       return\n@@ -2152,14 +2165,14 @@ may_trap_p_1 (rtx x, bool unaligned_mems)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  if (may_trap_p_1 (XEXP (x, i), unaligned_mems))\n+\t  if (may_trap_p_1 (XEXP (x, i), flags))\n \t    return 1;\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (may_trap_p_1 (XVECEXP (x, i, j), unaligned_mems))\n+\t    if (may_trap_p_1 (XVECEXP (x, i, j), flags))\n \t      return 1;\n \t}\n     }\n@@ -2171,7 +2184,16 @@ may_trap_p_1 (rtx x, bool unaligned_mems)\n int\n may_trap_p (rtx x)\n {\n-  return may_trap_p_1 (x, false);\n+  return may_trap_p_1 (x, 0);\n+}\n+\n+/* Return nonzero if evaluating rtx X might cause a trap, when the expression\n+   is moved from its current location by some optimization.  */\n+\n+int\n+may_trap_after_code_motion_p (rtx x)\n+{\n+  return may_trap_p_1 (x, MTP_AFTER_MOVE);\n }\n \n /* Same as above, but additionally return non-zero if evaluating rtx X might\n@@ -2217,7 +2239,7 @@ may_trap_p (rtx x)\n int\n may_trap_or_fault_p (rtx x)\n {\n-  return may_trap_p_1 (x, true);\n+  return may_trap_p_1 (x, MTP_UNALIGNED_MEMS);\n }\n \f\n /* Return nonzero if X contains a comparison that is not either EQ or NE,"}]}