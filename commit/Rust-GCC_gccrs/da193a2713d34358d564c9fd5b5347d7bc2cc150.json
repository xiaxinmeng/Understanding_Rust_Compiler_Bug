{"sha": "da193a2713d34358d564c9fd5b5347d7bc2cc150", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGExOTNhMjcxM2QzNDM1OGQ1NjRjOWZkNWI1MzQ3ZDdiYzJjYzE1MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-11-27T10:37:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-11-27T10:37:20Z"}, "message": "c-ada-spec.c: Include stringpool.h.\n\n\t* c-ada-spec.c: Include stringpool.h.\n\t(has_static_fields): Return false for incomplete types.\n\t(is_tagged_type): Likewise.\n\t(has_nontrivial_methods): Likewise.\n\t(dump_ada_node) <INTEGER_TYPE>: Deal specifically with __int128.\n\t(struct overloaded_name_hash): New structure.\n\t(struct overloaded_name_hasher): Likewise.\n\t(overloaded_names): New global variable.\n\t(init_overloaded_names): New static function.\n\t(overloaded_name_p): New predicate.\n\t(dump_ada_declaration) <TYPE_DECL>: Tidy up and set TREE_VISITED\n\ton the TYPE_STUB_DECL of the original type of a typedef, if any.\n\t<FUNCTION_DECL>: Bail out for an unsupported overloaded name.\n\tRemove always-true condition and dump forward types.\n\t(dump_ada_specs): Delete overloaded_names.\n\nFrom-SVN: r266506", "tree": {"sha": "0cb2327e80f2b6e3ed55fd667aad9beb6962e463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cb2327e80f2b6e3ed55fd667aad9beb6962e463"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da193a2713d34358d564c9fd5b5347d7bc2cc150", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da193a2713d34358d564c9fd5b5347d7bc2cc150", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da193a2713d34358d564c9fd5b5347d7bc2cc150", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da193a2713d34358d564c9fd5b5347d7bc2cc150/comments", "author": null, "committer": null, "parents": [{"sha": "6d760a0197ece131619ac88f0fe34ce452fd774c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d760a0197ece131619ac88f0fe34ce452fd774c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d760a0197ece131619ac88f0fe34ce452fd774c"}], "stats": {"total": 137, "additions": 117, "deletions": 20}, "files": [{"sha": "d99396719fbf40f55e78630a48e73f8703e27497", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da193a2713d34358d564c9fd5b5347d7bc2cc150/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da193a2713d34358d564c9fd5b5347d7bc2cc150/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=da193a2713d34358d564c9fd5b5347d7bc2cc150", "patch": "@@ -1,3 +1,21 @@\n+2018-11-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c: Include stringpool.h.\n+\t(has_static_fields): Return false for incomplete types.\n+\t(is_tagged_type): Likewise.\n+\t(has_nontrivial_methods): Likewise.\n+\t(dump_ada_node) <INTEGER_TYPE>: Deal specifically with __int128.\n+\t(struct overloaded_name_hash): New structure.\n+\t(struct overloaded_name_hasher): Likewise.\n+\t(overloaded_names): New global variable.\n+\t(init_overloaded_names): New static function.\n+\t(overloaded_name_p): New predicate.\n+\t(dump_ada_declaration) <TYPE_DECL>: Tidy up and set TREE_VISITED\n+\ton the TYPE_STUB_DECL of the original type of a typedef, if any.\n+\t<FUNCTION_DECL>: Bail out for an unsupported overloaded name.\n+\tRemove always-true condition and dump forward types.\n+\t(dump_ada_specs): Delete overloaded_names.\n+\n 2018-11-20  Martin Sebor  <msebor@redhat.com>\n \n \t* c-attribs.c (type_for_vector_size): New function."}, {"sha": "4e96d2a4908c5d70dd115fa0414e3356079316fd", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 99, "deletions": 20, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da193a2713d34358d564c9fd5b5347d7bc2cc150/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da193a2713d34358d564c9fd5b5347d7bc2cc150/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=da193a2713d34358d564c9fd5b5347d7bc2cc150", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"stringpool.h\"\n #include \"tree.h\"\n #include \"c-ada-spec.h\"\n #include \"fold-const.h\"\n@@ -1041,7 +1042,7 @@ get_underlying_decl (tree type)\n static bool\n has_static_fields (const_tree type)\n {\n-  if (!type || !RECORD_OR_UNION_TYPE_P (type))\n+  if (!type || !RECORD_OR_UNION_TYPE_P (type) || !COMPLETE_TYPE_P (type))\n     return false;\n \n   for (tree fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n@@ -1057,7 +1058,7 @@ has_static_fields (const_tree type)\n static bool\n is_tagged_type (const_tree type)\n {\n-  if (!type || !RECORD_OR_UNION_TYPE_P (type))\n+  if (!type || !RECORD_OR_UNION_TYPE_P (type) || !COMPLETE_TYPE_P (type))\n     return false;\n \n   for (tree fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n@@ -1075,7 +1076,7 @@ is_tagged_type (const_tree type)\n static bool\n has_nontrivial_methods (tree type)\n {\n-  if (!type || !RECORD_OR_UNION_TYPE_P (type))\n+  if (!type || !RECORD_OR_UNION_TYPE_P (type) || !COMPLETE_TYPE_P (type))\n     return false;\n \n   /* Only C++ types can have methods.  */\n@@ -2092,7 +2093,10 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n     case INTEGER_TYPE:\n     case FIXED_POINT_TYPE:\n     case BOOLEAN_TYPE:\n-      if (TYPE_NAME (node))\n+      if (TYPE_NAME (node)\n+\t  && !(TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n+\t       && !strcmp (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (node))),\n+\t\t\t   \"__int128\")))\n \t{\n \t  if (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)\n \t    pp_ada_tree_identifier (buffer, TYPE_NAME (node), node,\n@@ -2568,6 +2572,73 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n     }\n }\n \n+/* Hash table of overloaded names that we cannot support.  It is needed even\n+   in Ada 2012 because we merge different types, e.g. void * and const void *\n+   in System.Address, so we cannot have overloading for them in Ada.  */\n+\n+struct overloaded_name_hash {\n+  hashval_t hash;\n+  tree name;\n+  unsigned int n;\n+};\n+\n+struct overloaded_name_hasher : delete_ptr_hash<overloaded_name_hash>\n+{\n+  static inline hashval_t hash (overloaded_name_hash *t)\n+    { return t->hash; }\n+  static inline bool equal (overloaded_name_hash *a, overloaded_name_hash *b)\n+    { return a->name == b->name; }\n+};\n+\n+static hash_table<overloaded_name_hasher> *overloaded_names;\n+\n+/* Initialize the table with the problematic overloaded names.  */\n+\n+static hash_table<overloaded_name_hasher> *\n+init_overloaded_names (void)\n+{\n+  static const char *names[] =\n+  /* The overloaded names from the /usr/include/string.h file.  */\n+  { \"memchr\", \"rawmemchr\", \"memrchr\", \"strchr\", \"strrchr\", \"strchrnul\",\n+    \"strpbrk\", \"strstr\", \"strcasestr\", \"index\", \"rindex\", \"basename\" };\n+\n+  hash_table<overloaded_name_hasher> *table\n+    = new hash_table<overloaded_name_hasher> (64);\n+\n+  for (unsigned int i = 0; i < ARRAY_SIZE (names); i++)\n+    {\n+      struct overloaded_name_hash in, *h, **slot;\n+      tree id = get_identifier (names[i]);\n+      hashval_t hash = htab_hash_pointer (id);\n+      in.hash = hash;\n+      in.name = id;\n+      slot = table->find_slot_with_hash (&in, hash, INSERT);\n+      h = new overloaded_name_hash;\n+      h->hash = hash;\n+      h->name = id;\n+      h->n = 0;\n+      *slot = h;\n+    }\n+\n+  return table;\n+}\n+\n+/* Return whether NAME cannot be supported as overloaded name.  */\n+\n+static bool\n+overloaded_name_p (tree name)\n+{\n+  if (!overloaded_names)\n+    overloaded_names = init_overloaded_names ();\n+\n+  struct overloaded_name_hash in, *h;\n+  hashval_t hash = htab_hash_pointer (name);\n+  in.hash = hash;\n+  in.name = name;\n+  h = overloaded_names->find_with_hash (&in, hash);\n+  return h && ++h->n > 1;\n+}\n+\n /* Dump in BUFFER constructor spec corresponding to T for TYPE.  */\n \n static void\n@@ -2603,7 +2674,7 @@ type_name (tree t)\n     return IDENTIFIER_POINTER (DECL_NAME (n));\n }\n \n-/* Dump in BUFFER the declaration of a variable T of type TYPE in Ada syntax.\n+/* Dump in BUFFER the declaration of object T of type TYPE in Ada syntax.\n    SPC is the indentation level.  Return 1 if a declaration was printed,\n    0 otherwise.  */\n \n@@ -2628,22 +2699,24 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n     {\n       orig = DECL_ORIGINAL_TYPE (t);\n \n+      /* This is a typedef.  */\n       if (orig && TYPE_STUB_DECL (orig))\n \t{\n \t  tree stub = TYPE_STUB_DECL (orig);\n-\t  tree typ = TREE_TYPE (stub);\n \n-\t  if (TYPE_NAME (typ))\n+\t  /* If this is a typedef of a named type, then output it as a subtype\n+\t     declaration.  ??? Use a derived type declaration instead.  */\n+\t  if (TYPE_NAME (orig))\n \t    {\n \t      /* If the types have the same name (ignoring casing), then ignore\n \t\t the second type, but forward declare the first if need be.  */\n-\t      if (type_name (typ) == type_name (TREE_TYPE (t))\n-\t\t  || !strcasecmp (type_name (typ), type_name (TREE_TYPE (t))))\n+\t      if (type_name (orig) == type_name (TREE_TYPE (t))\n+\t\t  || !strcasecmp (type_name (orig), type_name (TREE_TYPE (t))))\n \t\t{\n-\t\t  if (RECORD_OR_UNION_TYPE_P (typ) && !TREE_VISITED (stub))\n+\t\t  if (RECORD_OR_UNION_TYPE_P (orig) && !TREE_VISITED (stub))\n \t\t    {\n \t\t      INDENT (spc);\n-\t\t      dump_forward_type (buffer, typ, t, 0);\n+\t\t      dump_forward_type (buffer, orig, t, 0);\n \t\t    }\n \n \t\t  TREE_VISITED (t) = 1;\n@@ -2652,19 +2725,25 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n \t      INDENT (spc);\n \n-\t      if (RECORD_OR_UNION_TYPE_P (typ) && !TREE_VISITED (stub))\n-\t\tdump_forward_type (buffer, typ, t, spc);\n+\t      if (RECORD_OR_UNION_TYPE_P (orig) && !TREE_VISITED (stub))\n+\t\tdump_forward_type (buffer, orig, t, spc);\n \n \t      pp_string (buffer, \"subtype \");\n \t      dump_ada_node (buffer, t, type, spc, false, true);\n \t      pp_string (buffer, \" is \");\n-\t      dump_ada_node (buffer, typ, type, spc, false, true);\n+\t      dump_ada_node (buffer, orig, type, spc, false, true);\n \t      pp_string (buffer, \";  -- \");\n \t      dump_sloc (buffer, t);\n \n \t      TREE_VISITED (t) = 1;\n \t      return 1;\n \t    }\n+\n+\t  /* This is a typedef of an anonymous type.  We'll output the full\n+\t     type declaration of the anonymous type with the typedef'ed name\n+\t     below.  Prevent forward declarations for the anonymous type to\n+\t     be emitted from now on.  */\n+\t  TREE_VISITED (stub) = 1;\n \t}\n \n       /* Skip unnamed or anonymous structs/unions/enum types.  */\n@@ -2764,6 +2843,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  default:\n \t    pp_string (buffer, \"subtype \");\n \t}\n+\n       TREE_VISITED (t) = 1;\n     }\n   else\n@@ -2825,7 +2905,7 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       bool is_copy_constructor = false;\n       bool is_move_constructor = false;\n \n-      if (!decl_name)\n+      if (!decl_name || overloaded_name_p (decl_name))\n \treturn 0;\n \n       if (cpp_check)\n@@ -2863,8 +2943,9 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  return 1;\n \t}\n \n-      if (need_indent)\n-\tINDENT (spc);\n+      INDENT (spc);\n+\n+      dump_forward_type (buffer, TREE_TYPE (t), t, spc);\n \n       if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (t))) && !is_constructor)\n \tpp_string (buffer, \"procedure \");\n@@ -2927,9 +3008,6 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       bool is_interface = false;\n       bool is_abstract_record = false;\n \n-      if (need_indent)\n-\tINDENT (spc);\n-\n       /* Anonymous structs/unions.  */\n       dump_ada_node (buffer, TREE_TYPE (t), t, spc, false, true);\n \n@@ -3346,4 +3424,5 @@ dump_ada_specs (void (*collect_all_refs)(const char *),\n \n   /* Free various tables.  */\n   free (source_refs);\n+  delete overloaded_names;\n }"}]}