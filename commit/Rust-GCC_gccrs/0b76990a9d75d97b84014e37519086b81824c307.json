{"sha": "0b76990a9d75d97b84014e37519086b81824c307", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI3Njk5MGE5ZDc1ZDk3Yjg0MDE0ZTM3NTE5MDg2YjgxODI0YzMwNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:12Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:12Z"}, "message": "fwprop: Rewrite to use RTL SSA\n\nThis patch rewrites fwprop.c to use the RTL SSA framework.  It tries\nas far as possible to mimic the old behaviour, even in caes where\nthat doesn't fit naturally with the new framework.  I've added ???\ncomments to mark those places, but I think \u201cfixing\u201d them should\nbe done separately to make bisection easier.\n\nIn particular:\n\n* The old implementation iterated over uses, and after a successful\n  substitution, the new insn's uses were added to the end of the list.\n  The pass still processed those uses, but because it processed them at\n  the end, it didn't fully optimise one instruction before propagating\n  it into the next.\n\n  The new version follows the same approach for comparison purposes,\n  but I'd like to drop that as a follow-on patch.\n\n* The old implementation operated on single use sites (DF_REF_LOCs).\n  This doesn't work well for instructions with match_dups, where it's\n  necessary to update both an operand and its dups at the same time.\n  For example, attempting to substitute into a divmod instruction would\n  fail because only the div or the mod side would be updated.\n\n  The new version again follows this to some extent for comparison\n  purposes (although not exactly).  Again I'd like to drop it as a\n  follow-on patch.\n\n  One difference is that if a register occurs in multiple MEM addresses\n  in a set, the new version will try to update them all at once.  This is\n  what causes the SVE ACLE st4* output to improve.\n\nAlso, the old version didn't naturally guarantee termination (PR79405),\nwhereas the new one does.\n\ngcc/\n\t* fwprop.c: Rewrite to use the RTL SSA framework.\n\ngcc/testsuite/\n\t* gcc.dg/rtl/x86_64/test-return-const.c.before-fwprop.c: Don't\n\texpect insn updates to be deferred.\n\t* gcc.target/aarch64/sve/acle/asm/st4_s8.c: Expect the addition\n\tto be folded into the address.\n\t* gcc.target/aarch64/sve/acle/asm/st4_u8.c: Likewise.", "tree": {"sha": "cbf8f3b50118a3bfb17db20d1eb6d2a1e2fbd3be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbf8f3b50118a3bfb17db20d1eb6d2a1e2fbd3be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b76990a9d75d97b84014e37519086b81824c307", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b76990a9d75d97b84014e37519086b81824c307", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b76990a9d75d97b84014e37519086b81824c307", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b76990a9d75d97b84014e37519086b81824c307/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73b7582775254b764fd92ddb252a33dc15872c69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73b7582775254b764fd92ddb252a33dc15872c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73b7582775254b764fd92ddb252a33dc15872c69"}], "stats": {"total": 1703, "additions": 548, "deletions": 1155}, "files": [{"sha": "2d2d4b6c06412779879d5ec4ea7bc8bc13040c0a", "filename": "gcc/fwprop.c", "status": "modified", "additions": 539, "deletions": 1146, "changes": 1685, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b76990a9d75d97b84014e37519086b81824c307/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b76990a9d75d97b84014e37519086b81824c307/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=0b76990a9d75d97b84014e37519086b81824c307", "patch": "@@ -18,32 +18,28 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#define INCLUDE_ALGORITHM\n+#define INCLUDE_FUNCTIONAL\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n-#include \"target.h\"\n #include \"rtl.h\"\n-#include \"predict.h\"\n #include \"df.h\"\n-#include \"memmodel.h\"\n-#include \"tm_p.h\"\n-#include \"insn-config.h\"\n-#include \"emit-rtl.h\"\n-#include \"recog.h\"\n+#include \"rtl-ssa.h\"\n \n #include \"sparseset.h\"\n+#include \"predict.h\"\n #include \"cfgrtl.h\"\n #include \"cfgcleanup.h\"\n #include \"cfgloop.h\"\n #include \"tree-pass.h\"\n-#include \"domwalk.h\"\n #include \"rtl-iter.h\"\n-\n+#include \"target.h\"\n \n /* This pass does simple forward propagation and simplification when an\n    operand of an insn can only come from a single def.  This pass uses\n-   df.c, so it is global.  However, we only do limited analysis of\n+   RTL SSA, so it is global.  However, we only do limited analysis of\n    available expressions.\n \n    1) The pass tries to propagate the source of the def into the use,\n@@ -60,9 +56,9 @@ along with GCC; see the file COPYING3.  If not see\n       (set (subreg:SI (reg:DI 120) 0) (const_int 0))\n       (set (subreg:SI (reg:DI 120) 4) (const_int -1))\n       (set (subreg:SI (reg:DI 122) 0)\n-         (ior:SI (subreg:SI (reg:DI 119) 0) (subreg:SI (reg:DI 120) 0)))\n+\t (ior:SI (subreg:SI (reg:DI 119) 0) (subreg:SI (reg:DI 120) 0)))\n       (set (subreg:SI (reg:DI 122) 4)\n-         (ior:SI (subreg:SI (reg:DI 119) 4) (subreg:SI (reg:DI 120) 4)))\n+\t (ior:SI (subreg:SI (reg:DI 119) 4) (subreg:SI (reg:DI 120) 4)))\n \n    can be simplified to the much simpler\n \n@@ -89,7 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n      (set (reg:QI 120) (subreg:QI (reg:SI 118) 0))\n      (set (reg:QI 121) (subreg:QI (reg:SI 119) 0))\n      (set (reg:SI 122) (plus:SI (subreg:SI (reg:QI 120) 0)\n-                                (subreg:SI (reg:QI 121) 0)))\n+\t\t\t\t(subreg:SI (reg:QI 121) 0)))\n \n    are very common on machines that can only do word-sized operations.\n    For each use of a paradoxical subreg (subreg:WIDER (reg:NARROW N) 0),\n@@ -101,218 +97,12 @@ along with GCC; see the file COPYING3.  If not see\n      (set (reg:QI 121) (subreg:QI (reg:SI 119) 0))\n      (set (reg:SI 122) (plus:SI (reg:SI 118) (reg:SI 119)))\n \n-   where the first two insns are now dead.\n-\n-   We used to use reaching definitions to find which uses have a\n-   single reaching definition (sounds obvious...), but this is too\n-   complex a problem in nasty testcases like PR33928.  Now we use the\n-   multiple definitions problem in df-problems.c.  The similarity\n-   between that problem and SSA form creation is taken further, in\n-   that fwprop does a dominator walk to create its chains; however,\n-   instead of creating a PHI function where multiple definitions meet\n-   I just punt and record only singleton use-def chains, which is\n-   all that is needed by fwprop.  */\n+   where the first two insns are now dead.  */\n \n+using namespace rtl_ssa;\n \n static int num_changes;\n \n-static vec<df_ref> use_def_ref;\n-static vec<df_ref> reg_defs;\n-static vec<df_ref> reg_defs_stack;\n-\n-/* The maximum number of propagations that are still allowed.  If we do\n-   more propagations than originally we had uses, we must have ended up\n-   in a propagation loop, as in PR79405.  Until the algorithm fwprop\n-   uses can obviously not get into such loops we need a workaround like\n-   this.  */\n-static int propagations_left;\n-\n-/* The MD bitmaps are trimmed to include only live registers to cut\n-   memory usage on testcases like insn-recog.c.  Track live registers\n-   in the basic block and do not perform forward propagation if the\n-   destination is a dead pseudo occurring in a note.  */\n-static bitmap local_md;\n-static bitmap local_lr;\n-\n-/* Return the only def in USE's use-def chain, or NULL if there is\n-   more than one def in the chain.  */\n-\n-static inline df_ref\n-get_def_for_use (df_ref use)\n-{\n-  return use_def_ref[DF_REF_ID (use)];\n-}\n-\n-\n-/* Update the reg_defs vector with non-partial definitions in DEF_REC.\n-   TOP_FLAG says which artificials uses should be used, when DEF_REC\n-   is an artificial def vector.  LOCAL_MD is modified as after a\n-   df_md_simulate_* function; we do more or less the same processing\n-   done there, so we do not use those functions.  */\n-\n-#define DF_MD_GEN_FLAGS \\\n-\t(DF_REF_PARTIAL | DF_REF_CONDITIONAL | DF_REF_MAY_CLOBBER)\n-\n-static void\n-process_defs (df_ref def, int top_flag)\n-{\n-  for (; def; def = DF_REF_NEXT_LOC (def))\n-    {\n-      df_ref curr_def = reg_defs[DF_REF_REGNO (def)];\n-      unsigned int dregno;\n-\n-      if ((DF_REF_FLAGS (def) & DF_REF_AT_TOP) != top_flag)\n-\tcontinue;\n-\n-      dregno = DF_REF_REGNO (def);\n-      if (curr_def)\n-\treg_defs_stack.safe_push (curr_def);\n-      else\n-\t{\n-\t  /* Do not store anything if \"transitioning\" from NULL to NULL.  But\n-             otherwise, push a special entry on the stack to tell the\n-\t     leave_block callback that the entry in reg_defs was NULL.  */\n-\t  if (DF_REF_FLAGS (def) & DF_MD_GEN_FLAGS)\n-\t    ;\n-\t  else\n-\t    reg_defs_stack.safe_push (def);\n-\t}\n-\n-      if (DF_REF_FLAGS (def) & DF_MD_GEN_FLAGS)\n-\t{\n-\t  bitmap_set_bit (local_md, dregno);\n-\t  reg_defs[dregno] = NULL;\n-\t}\n-      else\n-\t{\n-\t  bitmap_clear_bit (local_md, dregno);\n-\t  reg_defs[dregno] = def;\n-\t}\n-    }\n-}\n-\n-\n-/* Fill the use_def_ref vector with values for the uses in USE_REC,\n-   taking reaching definitions info from LOCAL_MD and REG_DEFS.\n-   TOP_FLAG says which artificials uses should be used, when USE_REC\n-   is an artificial use vector.  */\n-\n-static void\n-process_uses (df_ref use, int top_flag)\n-{\n-  for (; use; use = DF_REF_NEXT_LOC (use))\n-    if ((DF_REF_FLAGS (use) & DF_REF_AT_TOP) == top_flag)\n-      {\n-        unsigned int uregno = DF_REF_REGNO (use);\n-        if (reg_defs[uregno]\n-\t    && !bitmap_bit_p (local_md, uregno)\n-\t    && bitmap_bit_p (local_lr, uregno))\n-\t  use_def_ref[DF_REF_ID (use)] = reg_defs[uregno];\n-      }\n-}\n-\n-class single_def_use_dom_walker : public dom_walker\n-{\n-public:\n-  single_def_use_dom_walker (cdi_direction direction)\n-    : dom_walker (direction) {}\n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-};\n-\n-edge\n-single_def_use_dom_walker::before_dom_children (basic_block bb)\n-{\n-  int bb_index = bb->index;\n-  class df_md_bb_info *md_bb_info = df_md_get_bb_info (bb_index);\n-  class df_lr_bb_info *lr_bb_info = df_lr_get_bb_info (bb_index);\n-  rtx_insn *insn;\n-\n-  bitmap_copy (local_md, &md_bb_info->in);\n-  bitmap_copy (local_lr, &lr_bb_info->in);\n-\n-  /* Push a marker for the leave_block callback.  */\n-  reg_defs_stack.safe_push (NULL);\n-\n-  process_uses (df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n-  process_defs (df_get_artificial_defs (bb_index), DF_REF_AT_TOP);\n-\n-  /* We don't call df_simulate_initialize_forwards, as it may overestimate\n-     the live registers if there are unused artificial defs.  We prefer\n-     liveness to be underestimated.  */\n-\n-  FOR_BB_INSNS (bb, insn)\n-    if (INSN_P (insn))\n-      {\n-        unsigned int uid = INSN_UID (insn);\n-        process_uses (DF_INSN_UID_USES (uid), 0);\n-        process_uses (DF_INSN_UID_EQ_USES (uid), 0);\n-        process_defs (DF_INSN_UID_DEFS (uid), 0);\n-\tdf_simulate_one_insn_forwards (bb, insn, local_lr);\n-      }\n-\n-  process_uses (df_get_artificial_uses (bb_index), 0);\n-  process_defs (df_get_artificial_defs (bb_index), 0);\n-\n-  return NULL;\n-}\n-\n-/* Pop the definitions created in this basic block when leaving its\n-   dominated parts.  */\n-\n-void\n-single_def_use_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n-{\n-  df_ref saved_def;\n-  while ((saved_def = reg_defs_stack.pop ()) != NULL)\n-    {\n-      unsigned int dregno = DF_REF_REGNO (saved_def);\n-\n-      /* See also process_defs.  */\n-      if (saved_def == reg_defs[dregno])\n-\treg_defs[dregno] = NULL;\n-      else\n-\treg_defs[dregno] = saved_def;\n-    }\n-}\n-\n-\n-/* Build a vector holding the reaching definitions of uses reached by a\n-   single dominating definition.  */\n-\n-static void\n-build_single_def_use_links (void)\n-{\n-  /* We use the multiple definitions problem to compute our restricted\n-     use-def chains.  */\n-  df_set_flags (DF_EQ_NOTES);\n-  df_md_add_problem ();\n-  df_note_add_problem ();\n-  df_analyze ();\n-  df_maybe_reorganize_use_refs (DF_REF_ORDER_BY_INSN_WITH_NOTES);\n-\n-  use_def_ref.create (DF_USES_TABLE_SIZE ());\n-  use_def_ref.safe_grow_cleared (DF_USES_TABLE_SIZE (), true);\n-\n-  reg_defs.create (max_reg_num ());\n-  reg_defs.safe_grow_cleared (max_reg_num (), true);\n-\n-  reg_defs_stack.create (n_basic_blocks_for_fn (cfun) * 10);\n-  local_md = BITMAP_ALLOC (NULL);\n-  local_lr = BITMAP_ALLOC (NULL);\n-\n-  /* Walk the dominator tree looking for single reaching definitions\n-     dominating the uses.  This is similar to how SSA form is built.  */\n-  single_def_use_dom_walker (CDI_DOMINATORS)\n-    .walk (cfun->cfg->x_entry_block_ptr);\n-\n-  BITMAP_FREE (local_lr);\n-  BITMAP_FREE (local_md);\n-  reg_defs.release ();\n-  reg_defs_stack.release ();\n-}\n-\n-\f\n /* Do not try to replace constant addresses or addresses of local and\n    argument slots.  These MEM expressions are made only once and inserted\n    in many instructions, as well as being used to control symbol table\n@@ -342,773 +132,477 @@ can_simplify_addr (rtx addr)\n \t      && REGNO (reg) != ARG_POINTER_REGNUM));\n }\n \n-/* Returns a canonical version of X for the address, from the point of view,\n-   that all multiplications are represented as MULT instead of the multiply\n-   by a power of 2 being represented as ASHIFT.\n-\n-   Every ASHIFT we find has been made by simplify_gen_binary and was not\n-   there before, so it is not shared.  So we can do this in place.  */\n-\n-static void\n-canonicalize_address (rtx x)\n-{\n-  for (;;)\n-    switch (GET_CODE (x))\n-      {\n-      case ASHIFT:\n-        if (CONST_INT_P (XEXP (x, 1))\n-\t    && INTVAL (XEXP (x, 1)) < GET_MODE_UNIT_BITSIZE (GET_MODE (x))\n-\t    && INTVAL (XEXP (x, 1)) >= 0)\n-\t  {\n-\t    HOST_WIDE_INT shift = INTVAL (XEXP (x, 1));\n-\t    PUT_CODE (x, MULT);\n-\t    XEXP (x, 1) = gen_int_mode (HOST_WIDE_INT_1 << shift,\n-\t\t\t\t\tGET_MODE (x));\n-\t  }\n-\n-\tx = XEXP (x, 0);\n-        break;\n-\n-      case PLUS:\n-        if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t    || GET_CODE (XEXP (x, 0)) == ASHIFT\n-\t    || GET_CODE (XEXP (x, 0)) == CONST)\n-\t  canonicalize_address (XEXP (x, 0));\n-\n-\tx = XEXP (x, 1);\n-        break;\n-\n-      case CONST:\n-\tx = XEXP (x, 0);\n-        break;\n-\n-      default:\n-        return;\n-      }\n-}\n-\n-/* OLD is a memory address.  Return whether it is good to use NEW instead,\n-   for a memory access in the given MODE.  */\n+/* MEM is the result of an address simplification, and temporarily\n+   undoing changes OLD_NUM_CHANGES onwards restores the original address.\n+   Return whether it is good to use the new address instead of the\n+   old one.  INSN is the containing instruction.  */\n \n static bool\n-should_replace_address (rtx old_rtx, rtx new_rtx, machine_mode mode,\n-\t\t\taddr_space_t as, bool speed)\n+should_replace_address (int old_num_changes, rtx mem, rtx_insn *insn)\n {\n   int gain;\n \n-  if (rtx_equal_p (old_rtx, new_rtx)\n-      || !memory_address_addr_space_p (mode, new_rtx, as))\n-    return false;\n-\n-  /* Copy propagation is always ok.  */\n-  if (REG_P (old_rtx) && REG_P (new_rtx))\n-    return true;\n-\n   /* Prefer the new address if it is less expensive.  */\n-  gain = (address_cost (old_rtx, mode, as, speed)\n-\t  - address_cost (new_rtx, mode, as, speed));\n+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n+  temporarily_undo_changes (old_num_changes);\n+  gain = address_cost (XEXP (mem, 0), GET_MODE (mem),\n+\t\t       MEM_ADDR_SPACE (mem), speed);\n+  redo_changes (old_num_changes);\n+  gain -= address_cost (XEXP (mem, 0), GET_MODE (mem),\n+\t\t\tMEM_ADDR_SPACE (mem), speed);\n \n   /* If the addresses have equivalent cost, prefer the new address\n      if it has the highest `set_src_cost'.  That has the potential of\n      eliminating the most insns without additional costs, and it\n      is the same that cse.c used to do.  */\n   if (gain == 0)\n-    gain = (set_src_cost (new_rtx, VOIDmode, speed)\n-\t    - set_src_cost (old_rtx, VOIDmode, speed));\n+    {\n+      gain = set_src_cost (XEXP (mem, 0), VOIDmode, speed);\n+      temporarily_undo_changes (old_num_changes);\n+      gain -= set_src_cost (XEXP (mem, 0), VOIDmode, speed);\n+      redo_changes (old_num_changes);\n+    }\n \n   return (gain > 0);\n }\n \n \n-/* Flags for the last parameter of propagate_rtx_1.  */\n-\n-enum {\n-  /* If PR_CAN_APPEAR is true, propagate_rtx_1 always returns true;\n-     if it is false, propagate_rtx_1 returns false if, for at least\n-     one occurrence OLD, it failed to collapse the result to a constant.\n-     For example, (mult:M (reg:M A) (minus:M (reg:M B) (reg:M A))) may\n-     collapse to zero if replacing (reg:M B) with (reg:M A).\n-\n-     PR_CAN_APPEAR is disregarded inside MEMs: in that case,\n-     propagate_rtx_1 just tries to make cheaper and valid memory\n-     addresses.  */\n-  PR_CAN_APPEAR = 1,\n-\n-  /* If PR_HANDLE_MEM is not set, propagate_rtx_1 won't attempt any replacement\n-     outside memory addresses.  This is needed because propagate_rtx_1 does\n-     not do any analysis on memory; thus it is very conservative and in general\n-     it will fail if non-read-only MEMs are found in the source expression.\n-\n-     PR_HANDLE_MEM is set when the source of the propagation was not\n-     another MEM.  Then, it is safe not to treat non-read-only MEMs as\n-     ``opaque'' objects.  */\n-  PR_HANDLE_MEM = 2,\n-\n-  /* Set when costs should be optimized for speed.  */\n-  PR_OPTIMIZE_FOR_SPEED = 4\n-};\n+namespace\n+{\n+  class fwprop_propagation : public insn_propagation\n+  {\n+  public:\n+    static const uint16_t CHANGED_MEM = FIRST_SPARE_RESULT;\n+    static const uint16_t CONSTANT = FIRST_SPARE_RESULT << 1;\n+    static const uint16_t PROFITABLE = FIRST_SPARE_RESULT << 2;\n+\n+    fwprop_propagation (rtx_insn *, rtx, rtx);\n+\n+    bool changed_mem_p () const { return result_flags & CHANGED_MEM; }\n+    bool folded_to_constants_p () const;\n+    bool profitable_p () const;\n+\n+    bool check_mem (int, rtx) final override;\n+    void note_simplification (int, uint16_t, rtx, rtx) final override;\n+    uint16_t classify_result (rtx, rtx);\n+  };\n+}\n \n-/* Check that X has a single def.  */\n+/* Prepare to replace FROM with TO in INSN.  */\n \n-static bool\n-reg_single_def_p (rtx x)\n+fwprop_propagation::fwprop_propagation (rtx_insn *insn, rtx from, rtx to)\n+  : insn_propagation (insn, from, to)\n {\n-  if (!REG_P (x))\n-    return false;\n-\n-  int regno = REGNO (x);\n-  return (DF_REG_DEF_COUNT (regno) == 1\n-\t  && !bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)), regno));\n+  should_check_mems = true;\n+  should_note_simplifications = true;\n }\n \n-/* Replace all occurrences of OLD in *PX with NEW and try to simplify the\n-   resulting expression.  Replace *PX with a new RTL expression if an\n-   occurrence of OLD was found.\n+/* MEM is the result of an address simplification, and temporarily\n+   undoing changes OLD_NUM_CHANGES onwards restores the original address.\n+   Return true if the propagation should continue, false if it has failed.  */\n \n-   This is only a wrapper around simplify-rtx.c: do not add any pattern\n-   matching code here.  (The sole exception is the handling of LO_SUM, but\n-   that is because there is no simplify_gen_* function for LO_SUM).  */\n-\n-static bool\n-propagate_rtx_1 (rtx *px, rtx old_rtx, rtx new_rtx, int flags)\n+bool\n+fwprop_propagation::check_mem (int old_num_changes, rtx mem)\n {\n-  rtx x = *px, tem = NULL_RTX, op0, op1, op2;\n-  enum rtx_code code = GET_CODE (x);\n-  machine_mode mode = GET_MODE (x);\n-  machine_mode op_mode;\n-  bool can_appear = (flags & PR_CAN_APPEAR) != 0;\n-  bool valid_ops = true;\n-\n-  if (!(flags & PR_HANDLE_MEM) && MEM_P (x) && !MEM_READONLY_P (x))\n+  if (!memory_address_addr_space_p (GET_MODE (mem), XEXP (mem, 0),\n+\t\t\t\t    MEM_ADDR_SPACE (mem)))\n     {\n-      /* If unsafe, change MEMs to CLOBBERs or SCRATCHes (to preserve whether\n-\t they have side effects or not).  */\n-      *px = (side_effects_p (x)\n-\t     ? gen_rtx_CLOBBER (GET_MODE (x), const0_rtx)\n-\t     : gen_rtx_SCRATCH (GET_MODE (x)));\n+      failure_reason = \"would create an invalid MEM\";\n       return false;\n     }\n \n-  /* If X is OLD_RTX, return NEW_RTX.  But not if replacing only within an\n-     address, and we are *not* inside one.  */\n-  if (x == old_rtx)\n+  temporarily_undo_changes (old_num_changes);\n+  bool can_simplify = can_simplify_addr (XEXP (mem, 0));\n+  redo_changes (old_num_changes);\n+  if (!can_simplify)\n     {\n-      *px = new_rtx;\n-      return can_appear;\n+      failure_reason = \"would replace a frame address\";\n+      return false;\n     }\n \n-  /* If this is an expression, try recursive substitution.  */\n-  switch (GET_RTX_CLASS (code))\n+  /* Copy propagations are always ok.  Otherwise check the costs.  */\n+  if (!(REG_P (from) && REG_P (to))\n+      && !should_replace_address (old_num_changes, mem, insn))\n     {\n-    case RTX_UNARY:\n-      op0 = XEXP (x, 0);\n-      op_mode = GET_MODE (op0);\n-      valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n-      if (op0 == XEXP (x, 0))\n-\treturn true;\n-      tem = simplify_gen_unary (code, mode, op0, op_mode);\n-      break;\n-\n-    case RTX_BIN_ARITH:\n-    case RTX_COMM_ARITH:\n-      op0 = XEXP (x, 0);\n-      op1 = XEXP (x, 1);\n-      valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n-      valid_ops &= propagate_rtx_1 (&op1, old_rtx, new_rtx, flags);\n-      if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n-\treturn true;\n-      tem = simplify_gen_binary (code, mode, op0, op1);\n-      break;\n-\n-    case RTX_COMPARE:\n-    case RTX_COMM_COMPARE:\n-      op0 = XEXP (x, 0);\n-      op1 = XEXP (x, 1);\n-      op_mode = GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n-      valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n-      valid_ops &= propagate_rtx_1 (&op1, old_rtx, new_rtx, flags);\n-      if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n-\treturn true;\n-      tem = simplify_gen_relational (code, mode, op_mode, op0, op1);\n-      break;\n-\n-    case RTX_TERNARY:\n-    case RTX_BITFIELD_OPS:\n-      op0 = XEXP (x, 0);\n-      op1 = XEXP (x, 1);\n-      op2 = XEXP (x, 2);\n-      op_mode = GET_MODE (op0);\n-      valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n-      valid_ops &= propagate_rtx_1 (&op1, old_rtx, new_rtx, flags);\n-      valid_ops &= propagate_rtx_1 (&op2, old_rtx, new_rtx, flags);\n-      if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1) && op2 == XEXP (x, 2))\n-\treturn true;\n-      if (op_mode == VOIDmode)\n-\top_mode = GET_MODE (op0);\n-      tem = simplify_gen_ternary (code, mode, op_mode, op0, op1, op2);\n-      break;\n-\n-    case RTX_EXTRA:\n-      /* The only case we try to handle is a SUBREG.  */\n-      if (code == SUBREG)\n-\t{\n-          op0 = XEXP (x, 0);\n-\t  valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n-          if (op0 == XEXP (x, 0))\n-\t    return true;\n-\t  tem = simplify_gen_subreg (mode, op0, GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t     SUBREG_BYTE (x));\n-\t}\n-\n-      else\n-\t{\n-\t  rtvec vec;\n-\t  rtvec newvec;\n-\t  const char *fmt = GET_RTX_FORMAT (code);\n-\t  rtx op;\n-\n-\t  for (int i = 0; fmt[i]; i++)\n-\t    switch (fmt[i])\n-\t      {\n-\t      case 'E':\n-\t\tvec = XVEC (x, i);\n-\t\tnewvec = vec;\n-\t\tfor (int j = 0; j < GET_NUM_ELEM (vec); j++)\n-\t\t  {\n-\t\t    op = RTVEC_ELT (vec, j);\n-\t\t    valid_ops &= propagate_rtx_1 (&op, old_rtx, new_rtx, flags);\n-\t\t    if (op != RTVEC_ELT (vec, j))\n-\t\t      {\n-\t\t\tif (newvec == vec)\n-\t\t\t  {\n-\t\t\t    newvec = shallow_copy_rtvec (vec);\n-\t\t\t    if (!tem)\n-\t\t\t      tem = shallow_copy_rtx (x);\n-\t\t\t    XVEC (tem, i) = newvec;\n-\t\t\t  }\n-\t\t\tRTVEC_ELT (newvec, j) = op;\n-\t\t      }\n-\t\t  }\n-\t        break;\n-\n-\t      case 'e':\n-\t\tif (XEXP (x, i))\n-\t\t  {\n-\t\t    op = XEXP (x, i);\n-\t\t    valid_ops &= propagate_rtx_1 (&op, old_rtx, new_rtx, flags);\n-\t\t    if (op != XEXP (x, i))\n-\t\t      {\n-\t\t\tif (!tem)\n-\t\t\t  tem = shallow_copy_rtx (x);\n-\t\t\tXEXP (tem, i) = op;\n-\t\t      }\n-\t\t  }\n-\t        break;\n-\t      }\n-\t}\n-\n-      break;\n-\n-    case RTX_OBJ:\n-      if (code == MEM && x != new_rtx)\n-\t{\n-\t  rtx new_op0;\n-\t  op0 = XEXP (x, 0);\n-\n-\t  /* There are some addresses that we cannot work on.  */\n-\t  if (!can_simplify_addr (op0))\n-\t    return true;\n-\n-\t  op0 = new_op0 = targetm.delegitimize_address (op0);\n-\t  valid_ops &= propagate_rtx_1 (&new_op0, old_rtx, new_rtx,\n-\t\t\t\t\tflags | PR_CAN_APPEAR);\n-\n-\t  /* Dismiss transformation that we do not want to carry on.  */\n-\t  if (!valid_ops\n-\t      || new_op0 == op0\n-\t      || !(GET_MODE (new_op0) == GET_MODE (op0)\n-\t\t   || GET_MODE (new_op0) == VOIDmode))\n-\t    return true;\n-\n-\t  canonicalize_address (new_op0);\n-\n-\t  /* Copy propagations are always ok.  Otherwise check the costs.  */\n-\t  if (!(REG_P (old_rtx) && REG_P (new_rtx))\n-\t      && !should_replace_address (op0, new_op0, GET_MODE (x),\n-\t\t\t\t\t  MEM_ADDR_SPACE (x),\n-\t      \t\t\t \t  flags & PR_OPTIMIZE_FOR_SPEED))\n-\t    return true;\n-\n-\t  tem = replace_equiv_address_nv (x, new_op0);\n-\t}\n-\n-      else if (code == LO_SUM)\n-\t{\n-          op0 = XEXP (x, 0);\n-          op1 = XEXP (x, 1);\n-\n-\t  /* The only simplification we do attempts to remove references to op0\n-\t     or make it constant -- in both cases, op0's invalidity will not\n-\t     make the result invalid.  */\n-\t  propagate_rtx_1 (&op0, old_rtx, new_rtx, flags | PR_CAN_APPEAR);\n-\t  valid_ops &= propagate_rtx_1 (&op1, old_rtx, new_rtx, flags);\n-          if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n-\t    return true;\n-\n-\t  /* (lo_sum (high x) x) -> x  */\n-\t  if (GET_CODE (op0) == HIGH && rtx_equal_p (XEXP (op0, 0), op1))\n-\t    tem = op1;\n-\t  else\n-\t    tem = gen_rtx_LO_SUM (mode, op0, op1);\n+      failure_reason = \"would increase the cost of a MEM\";\n+      return false;\n+    }\n \n-\t  /* OP1 is likely not a legitimate address, otherwise there would have\n-\t     been no LO_SUM.  We want it to disappear if it is invalid, return\n-\t     false in that case.  */\n-\t  return memory_address_p (mode, tem);\n-\t}\n+  result_flags |= CHANGED_MEM;\n+  return true;\n+}\n \n-      else if (code == REG)\n-\t{\n-\t  if (rtx_equal_p (x, old_rtx))\n-\t    {\n-              *px = new_rtx;\n-              return can_appear;\n-\t    }\n-\t}\n-      break;\n+/* OLDX has been simplified to NEWX.  Describe the change in terms of\n+   result_flags.  */\n \n-    default:\n-      break;\n+uint16_t\n+fwprop_propagation::classify_result (rtx old_rtx, rtx new_rtx)\n+{\n+  if (CONSTANT_P (new_rtx))\n+    {\n+      /* If OLD_RTX is a LO_SUM, then it presumably exists for a reason,\n+\t and NEW_RTX is likely not a legitimate address.  We want it to\n+\t disappear if it is invalid.\n+\n+\t ??? Using the mode of the LO_SUM as the mode of the address\n+\t seems odd, but it was what the pre-SSA code did.  */\n+      if (GET_CODE (old_rtx) == LO_SUM\n+\t  && !memory_address_p (GET_MODE (old_rtx), new_rtx))\n+\treturn CONSTANT;\n+      return CONSTANT | PROFITABLE;\n     }\n \n-  /* No change, no trouble.  */\n-  if (tem == NULL_RTX)\n-    return true;\n-\n-  *px = tem;\n-\n   /* Allow replacements that simplify operations on a vector or complex\n      value to a component.  The most prominent case is\n      (subreg ([vec_]concat ...)).   */\n-  if (REG_P (tem) && !HARD_REGISTER_P (tem)\n-      && (VECTOR_MODE_P (GET_MODE (new_rtx))\n-\t  || COMPLEX_MODE_P (GET_MODE (new_rtx)))\n-      && GET_MODE (tem) == GET_MODE_INNER (GET_MODE (new_rtx)))\n-    return true;\n+  if (REG_P (new_rtx)\n+      && !HARD_REGISTER_P (new_rtx)\n+      && (VECTOR_MODE_P (GET_MODE (from))\n+\t  || COMPLEX_MODE_P (GET_MODE (from)))\n+      && GET_MODE (new_rtx) == GET_MODE_INNER (GET_MODE (from)))\n+    return PROFITABLE;\n \n-  /* The replacement we made so far is valid, if all of the recursive\n-     replacements were valid, or we could simplify everything to\n-     a constant.  */\n-  return valid_ops || can_appear || CONSTANT_P (tem);\n+  return 0;\n }\n \n+/* Record that OLD_RTX has been simplified to NEW_RTX.  OLD_NUM_CHANGES\n+   is the number of unrelated changes that had been made before processing\n+   OLD_RTX and its subrtxes.  OLD_RESULT_FLAGS is the value that result_flags\n+   had at that point.  */\n \n-/* Return true if X constains a non-constant mem.  */\n-\n-static bool\n-varying_mem_p (const_rtx x)\n+void\n+fwprop_propagation::note_simplification (int old_num_changes,\n+\t\t\t\t\t uint16_t old_result_flags,\n+\t\t\t\t\t rtx old_rtx, rtx new_rtx)\n {\n-  subrtx_iterator::array_type array;\n-  FOR_EACH_SUBRTX (iter, array, x, NONCONST)\n-    if (MEM_P (*iter) && !MEM_READONLY_P (*iter))\n-      return true;\n-  return false;\n+  result_flags &= ~(CONSTANT | PROFITABLE);\n+  uint16_t new_flags = classify_result (old_rtx, new_rtx);\n+  if (old_num_changes)\n+    new_flags &= old_result_flags;\n+  result_flags |= new_flags;\n }\n \n+/* Return true if all substitutions eventually folded to constants.  */\n+\n+bool\n+fwprop_propagation::folded_to_constants_p () const\n+{\n+  /* If we're propagating a HIGH, require it to be folded with a\n+     partnering LO_SUM.  For example, a REG_EQUAL note with a register\n+     replaced by an unfolded HIGH is not useful.  */\n+  if (CONSTANT_P (to) && GET_CODE (to) != HIGH)\n+    return true;\n+  return !(result_flags & UNSIMPLIFIED) && (result_flags & CONSTANT);\n+}\n \n-/* Replace all occurrences of OLD in X with NEW and try to simplify the\n-   resulting expression (in mode MODE).  Return a new expression if it is\n-   a constant, otherwise X.\n \n-   Simplifications where occurrences of NEW collapse to a constant are always\n-   accepted.  All simplifications are accepted if NEW is a pseudo too.\n-   Otherwise, we accept simplifications that have a lower or equal cost.  */\n+/* Return true if it is worth keeping the result of the propagation,\n+   false if it would increase the complexity of the pattern too much.  */\n \n-static rtx\n-propagate_rtx (rtx x, machine_mode mode, rtx old_rtx, rtx new_rtx,\n-\t       bool speed)\n+bool\n+fwprop_propagation::profitable_p () const\n {\n-  rtx tem;\n-  bool collapsed;\n-  int flags;\n+  if (changed_mem_p ())\n+    return true;\n \n-  if (REG_P (new_rtx) && REGNO (new_rtx) < FIRST_PSEUDO_REGISTER)\n-    return NULL_RTX;\n+  if (!(result_flags & UNSIMPLIFIED)\n+      && (result_flags & PROFITABLE))\n+    return true;\n \n-  flags = 0;\n-  if (REG_P (new_rtx)\n-      || CONSTANT_P (new_rtx)\n-      || (GET_CODE (new_rtx) == SUBREG\n-\t  && REG_P (SUBREG_REG (new_rtx))\n-\t  && !paradoxical_subreg_p (new_rtx)))\n-    flags |= PR_CAN_APPEAR;\n-  if (!varying_mem_p (new_rtx))\n-    flags |= PR_HANDLE_MEM;\n-\n-  if (speed)\n-    flags |= PR_OPTIMIZE_FOR_SPEED;\n-\n-  tem = x;\n-  collapsed = propagate_rtx_1 (&tem, old_rtx, copy_rtx (new_rtx), flags);\n-  if (tem == x || !collapsed)\n-    return NULL_RTX;\n-\n-  /* gen_lowpart_common will not be able to process VOIDmode entities other\n-     than CONST_INTs.  */\n-  if (GET_MODE (tem) == VOIDmode && !CONST_INT_P (tem))\n-    return NULL_RTX;\n-\n-  if (GET_MODE (tem) == VOIDmode)\n-    tem = rtl_hooks.gen_lowpart_no_emit (mode, tem);\n-  else\n-    gcc_assert (GET_MODE (tem) == mode);\n+  if (REG_P (to))\n+    return true;\n \n-  return tem;\n-}\n+  if (GET_CODE (to) == SUBREG\n+      && REG_P (SUBREG_REG (to))\n+      && !paradoxical_subreg_p (to))\n+    return true;\n \n+  if (CONSTANT_P (to))\n+    return true;\n \n-\f\n+  return false;\n+}\n \n-/* Return true if the register from reference REF is killed\n-   between FROM to (but not including) TO.  */\n+/* Check that X has a single def.  */\n \n static bool\n-local_ref_killed_between_p (df_ref ref, rtx_insn *from, rtx_insn *to)\n+reg_single_def_p (rtx x)\n {\n-  rtx_insn *insn;\n+  return REG_P (x) && crtl->ssa->single_dominating_def (REGNO (x));\n+}\n \n-  for (insn = from; insn != to; insn = NEXT_INSN (insn))\n-    {\n-      df_ref def;\n-      if (!INSN_P (insn))\n-\tcontinue;\n+/* Return true if X contains a paradoxical subreg.  */\n \n-      FOR_EACH_INSN_DEF (def, insn)\n-\tif (DF_REF_REGNO (ref) == DF_REF_REGNO (def))\n-\t  return true;\n+static bool\n+contains_paradoxical_subreg_p (rtx x)\n+{\n+  subrtx_var_iterator::array_type array;\n+  FOR_EACH_SUBRTX_VAR (iter, array, x, NONCONST)\n+    {\n+      x = *iter;\n+      if (SUBREG_P (x) && paradoxical_subreg_p (x))\n+\treturn true;\n     }\n   return false;\n }\n \n+/* Try to substitute (set DEST SRC) from DEF_INSN into note NOTE of USE_INSN.\n+   Return the number of substitutions on success, otherwise return -1 and\n+   leave USE_INSN unchanged.\n \n-/* Check if USE is killed between DEF_INSN and TARGET_INSN.  This would\n-   require full computation of available expressions; we check only a few\n-   restricted conditions:\n-   - if the reg in USE has only one definition, go ahead;\n-   - in the same basic block, we check for no definitions killing the use;\n-   - if TARGET_INSN's basic block has DEF_INSN's basic block as its sole\n-     predecessor, we check if the use is killed after DEF_INSN or before\n-     TARGET_INSN insn, in their respective basic blocks.  */\n+   If REQUIRE_CONSTANT is true, require all substituted occurences of SRC\n+   to fold to a constant, so that the note does not use any more registers\n+   than it did previously.  If REQUIRE_CONSTANT is false, also allow the\n+   substitution if it's something we'd normally allow for the main\n+   instruction pattern.  */\n \n-static bool\n-use_killed_between (df_ref use, rtx_insn *def_insn, rtx_insn *target_insn)\n+static int\n+try_fwprop_subst_note (insn_info *use_insn, insn_info *def_insn,\n+\t\t       rtx note, rtx dest, rtx src, bool require_constant)\n {\n-  basic_block def_bb = BLOCK_FOR_INSN (def_insn);\n-  basic_block target_bb = BLOCK_FOR_INSN (target_insn);\n-  int regno;\n-  df_ref def;\n-\n-  /* We used to have a def reaching a use that is _before_ the def,\n-     with the def not dominating the use even though the use and def\n-     are in the same basic block, when a register may be used\n-     uninitialized in a loop.  This should not happen anymore since\n-     we do not use reaching definitions, but still we test for such\n-     cases and assume that DEF is not available.  */\n-  if (def_bb == target_bb\n-      ? DF_INSN_LUID (def_insn) >= DF_INSN_LUID (target_insn)\n-      : !dominated_by_p (CDI_DOMINATORS, target_bb, def_bb))\n-    return true;\n+  rtx_insn *use_rtl = use_insn->rtl ();\n \n-  /* Check if the reg in USE has only one definition.  We already\n-     know that this definition reaches use, or we wouldn't be here.\n-     However, this is invalid for hard registers because if they are\n-     live at the beginning of the function it does not mean that we\n-     have an uninitialized access.  And we have to check for the case\n-     where a register may be used uninitialized in a loop as above.  */\n-  regno = DF_REF_REGNO (use);\n-  def = DF_REG_DEF_CHAIN (regno);\n-  if (def\n-      && DF_REF_NEXT_REG (def) == NULL\n-      && regno >= FIRST_PSEUDO_REGISTER\n-      && (BLOCK_FOR_INSN (DF_REF_INSN (def)) == def_bb\n-\t  ? DF_INSN_LUID (DF_REF_INSN (def)) < DF_INSN_LUID (def_insn)\n-\t  : dominated_by_p (CDI_DOMINATORS,\n-\t\t\t    def_bb, BLOCK_FOR_INSN (DF_REF_INSN (def)))))\n-    return false;\n-\n-  /* Check locally if we are in the same basic block.  */\n-  if (def_bb == target_bb)\n-    return local_ref_killed_between_p (use, def_insn, target_insn);\n-\n-  /* Finally, if DEF_BB is the sole predecessor of TARGET_BB.  */\n-  if (single_pred_p (target_bb)\n-      && single_pred (target_bb) == def_bb)\n+  insn_change_watermark watermark;\n+  fwprop_propagation prop (use_rtl, dest, src);\n+  if (!prop.apply_to_rvalue (&XEXP (note, 0)))\n     {\n-      df_ref x;\n-\n-      /* See if USE is killed between DEF_INSN and the last insn in the\n-\t basic block containing DEF_INSN.  */\n-      x = df_bb_regno_last_def_find (def_bb, regno);\n-      if (x && DF_INSN_LUID (DF_REF_INSN (x)) >= DF_INSN_LUID (def_insn))\n-\treturn true;\n-\n-      /* See if USE is killed between TARGET_INSN and the first insn in the\n-\t basic block containing TARGET_INSN.  */\n-      x = df_bb_regno_first_def_find (target_bb, regno);\n-      if (x && DF_INSN_LUID (DF_REF_INSN (x)) < DF_INSN_LUID (target_insn))\n-\treturn true;\n-\n-      return false;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"cannot propagate from insn %d into\"\n+\t\t \" notes of insn %d: %s\\n\", def_insn->uid (),\n+\t\t use_insn->uid (), prop.failure_reason);\n+      return -1;\n     }\n \n-  /* Otherwise assume the worst case.  */\n-  return true;\n-}\n-\n+  if (prop.num_replacements == 0)\n+    return 0;\n \n-/* Check if all uses in DEF_INSN can be used in TARGET_INSN.  This\n-   would require full computation of available expressions;\n-   we check only restricted conditions, see use_killed_between.  */\n-static bool\n-all_uses_available_at (rtx_insn *def_insn, rtx_insn *target_insn)\n-{\n-  df_ref use;\n-  struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n-  rtx def_set = single_set (def_insn);\n-  rtx_insn *next;\n-\n-  gcc_assert (def_set);\n-\n-  /* If target_insn comes right after def_insn, which is very common\n-     for addresses, we can use a quicker test.  Ignore debug insns\n-     other than target insns for this.  */\n-  next = NEXT_INSN (def_insn);\n-  while (next && next != target_insn && DEBUG_INSN_P (next))\n-    next = NEXT_INSN (next);\n-  if (next == target_insn && REG_P (SET_DEST (def_set)))\n+  if (require_constant)\n     {\n-      rtx def_reg = SET_DEST (def_set);\n-\n-      /* If the insn uses the reg that it defines, the substitution is\n-         invalid.  */\n-      FOR_EACH_INSN_INFO_USE (use, insn_info)\n-\tif (rtx_equal_p (DF_REF_REG (use), def_reg))\n-\t  return false;\n-      FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n-\tif (rtx_equal_p (DF_REF_REG (use), def_reg))\n-\t  return false;\n+      if (!prop.folded_to_constants_p ())\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"cannot propagate from insn %d into\"\n+\t\t     \" notes of insn %d: %s\\n\", def_insn->uid (),\n+\t\t     use_insn->uid (), \"wouldn't fold to constants\");\n+\t  return -1;\n+\t}\n     }\n   else\n     {\n-      rtx def_reg = REG_P (SET_DEST (def_set)) ? SET_DEST (def_set) : NULL_RTX;\n-\n-      /* Look at all the uses of DEF_INSN, and see if they are not\n-\t killed between DEF_INSN and TARGET_INSN.  */\n-      FOR_EACH_INSN_INFO_USE (use, insn_info)\n-\t{\n-\t  if (def_reg && rtx_equal_p (DF_REF_REG (use), def_reg))\n-\t    return false;\n-\t  if (use_killed_between (use, def_insn, target_insn))\n-\t    return false;\n-\t}\n-      FOR_EACH_INSN_INFO_EQ_USE (use, insn_info)\n+      if (!prop.folded_to_constants_p () && !prop.profitable_p ())\n \t{\n-\t  if (def_reg && rtx_equal_p (DF_REF_REG (use), def_reg))\n-\t    return false;\n-\t  if (use_killed_between (use, def_insn, target_insn))\n-\t    return false;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"cannot propagate from insn %d into\"\n+\t\t     \" notes of insn %d: %s\\n\", def_insn->uid (),\n+\t\t     use_insn->uid (), \"would increase complexity of node\");\n+\t  return -1;\n \t}\n     }\n \n-  return true;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nin notes of insn %d, replacing:\\n  \",\n+\t       INSN_UID (use_rtl));\n+      temporarily_undo_changes (0);\n+      print_inline_rtx (dump_file, note, 2);\n+      redo_changes (0);\n+      fprintf (dump_file, \"\\n with:\\n  \");\n+      print_inline_rtx (dump_file, note, 2);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  watermark.keep ();\n+  return prop.num_replacements;\n }\n \n-\f\n-static df_ref *active_defs;\n-static sparseset active_defs_check;\n-\n-/* Fill the ACTIVE_DEFS array with the use->def link for the registers\n-   mentioned in USE_REC.  Register the valid entries in ACTIVE_DEFS_CHECK\n-   too, for checking purposes.  */\n+/* Try to substitute (set DEST SRC) from DEF_INSN into location LOC of\n+   USE_INSN's pattern.  Return true on success, otherwise leave USE_INSN\n+   unchanged.  */\n \n-static void\n-register_active_defs (df_ref use)\n+static bool\n+try_fwprop_subst_pattern (obstack_watermark &attempt, insn_change &use_change,\n+\t\t\t  insn_info *def_insn, rtx *loc, rtx dest, rtx src)\n {\n-  for (; use; use = DF_REF_NEXT_LOC (use))\n-    {\n-      df_ref def = get_def_for_use (use);\n-      int regno = DF_REF_REGNO (use);\n+  insn_info *use_insn = use_change.insn ();\n+  rtx_insn *use_rtl = use_insn->rtl ();\n \n-      if (flag_checking)\n-\tsparseset_set_bit (active_defs_check, regno);\n-      active_defs[regno] = def;\n+  insn_change_watermark watermark;\n+  fwprop_propagation prop (use_rtl, dest, src);\n+  if (!prop.apply_to_pattern (loc))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"cannot propagate from insn %d into\"\n+\t\t \" insn %d: %s\\n\", def_insn->uid (), use_insn->uid (),\n+\t\t prop.failure_reason);\n+      return false;\n     }\n-}\n \n+  if (prop.num_replacements == 0)\n+    return false;\n \n-/* Build the use->def links that we use to update the dataflow info\n-   for new uses.  Note that building the links is very cheap and if\n-   it were done earlier, they could be used to rule out invalid\n-   propagations (in addition to what is done in all_uses_available_at).\n-   I'm not doing this yet, though.  */\n-\n-static void\n-update_df_init (rtx_insn *def_insn, rtx_insn *insn)\n-{\n-  if (flag_checking)\n-    sparseset_clear (active_defs_check);\n-  register_active_defs (DF_INSN_USES (def_insn));\n-  register_active_defs (DF_INSN_USES (insn));\n-  register_active_defs (DF_INSN_EQ_USES (insn));\n-}\n+  if (!prop.profitable_p ())\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"cannot propagate from insn %d into\"\n+\t\t \" insn %d: %s\\n\", def_insn->uid (), use_insn->uid (),\n+\t\t \"would increase complexity of pattern\");\n+      return false;\n+    }\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\npropagating insn %d into insn %d, replacing:\\n\",\n+\t       def_insn->uid (), use_insn->uid ());\n+      temporarily_undo_changes (0);\n+      print_rtl_single (dump_file, PATTERN (use_rtl));\n+      redo_changes (0);\n+    }\n \n-/* Update the USE_DEF_REF array for the given use, using the active definitions\n-   in the ACTIVE_DEFS array to match pseudos to their def. */\n+  /* ??? In theory, it should be better to use insn costs rather than\n+     set_src_costs here.  That would involve replacing this code with\n+     change_is_worthwhile.  */\n+  bool ok = recog (attempt, use_change);\n+  if (ok && !prop.changed_mem_p () && !use_insn->is_asm ())\n+    if (rtx use_set = single_set (use_rtl))\n+      {\n+\tbool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_rtl));\n+\ttemporarily_undo_changes (0);\n+\tauto old_cost = set_src_cost (SET_SRC (use_set),\n+\t\t\t\t      GET_MODE (SET_DEST (use_set)), speed);\n+\tredo_changes (0);\n+\tauto new_cost = set_src_cost (SET_SRC (use_set),\n+\t\t\t\t      GET_MODE (SET_DEST (use_set)), speed);\n+\tif (new_cost > old_cost)\n+\t  {\n+\t    if (dump_file)\n+\t      fprintf (dump_file, \"change not profitable\"\n+\t\t       \" (cost %d -> cost %d)\\n\", old_cost, new_cost);\n+\t    ok = false;\n+\t  }\n+      }\n \n-static inline void\n-update_uses (df_ref use)\n-{\n-  for (; use; use = DF_REF_NEXT_LOC (use))\n+  if (!ok)\n     {\n-      int regno = DF_REF_REGNO (use);\n+      /* The pattern didn't match, but if all uses of SRC folded to\n+\t constants, we can add a REG_EQUAL note for the result, if there\n+\t isn't one already.  */\n+      if (!prop.folded_to_constants_p ())\n+\treturn false;\n \n-      /* Set up the use-def chain.  */\n-      if (DF_REF_ID (use) >= (int) use_def_ref.length ())\n-\tuse_def_ref.safe_grow_cleared (DF_REF_ID (use) + 1, true);\n+      /* Test this first to avoid creating an unnecessary copy of SRC.  */\n+      if (find_reg_note (use_rtl, REG_EQUAL, NULL_RTX))\n+\treturn false;\n \n-      if (flag_checking)\n-\tgcc_assert (sparseset_bit_p (active_defs_check, regno));\n-      use_def_ref[DF_REF_ID (use)] = active_defs[regno];\n-    }\n-}\n+      rtx set = set_for_reg_notes (use_rtl);\n+      if (!set || !REG_P (SET_DEST (set)))\n+\treturn false;\n \n+      rtx value = copy_rtx (SET_SRC (set));\n+      cancel_changes (0);\n \n-/* Update the USE_DEF_REF array for the uses in INSN.  Only update note\n-   uses if NOTES_ONLY is true.  */\n+      /* If there are any paradoxical SUBREGs, drop the REG_EQUAL note,\n+\t because the bits in there can be anything and so might not\n+\t match the REG_EQUAL note content.  See PR70574.  */\n+      if (contains_paradoxical_subreg_p (SET_SRC (set)))\n+\treturn false;\n \n-static void\n-update_df (rtx_insn *insn, rtx note)\n-{\n-  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \" Setting REG_EQUAL note\\n\");\n \n-  if (note)\n-    {\n-      df_uses_create (&XEXP (note, 0), insn, DF_REF_IN_NOTE);\n-      df_notes_rescan (insn);\n+      return set_unique_reg_note (use_rtl, REG_EQUAL, value);\n     }\n-  else\n+\n+  rtx *note_ptr = &REG_NOTES (use_rtl);\n+  while (rtx note = *note_ptr)\n     {\n-      df_uses_create (&PATTERN (insn), insn, 0);\n-      df_insn_rescan (insn);\n-      update_uses (DF_INSN_INFO_USES (insn_info));\n+      if ((REG_NOTE_KIND (note) == REG_EQUAL\n+\t   || REG_NOTE_KIND (note) == REG_EQUIV)\n+\t  && try_fwprop_subst_note (use_insn, def_insn, note,\n+\t\t\t\t    dest, src, false) < 0)\n+\t{\n+\t  *note_ptr = XEXP (note, 1);\n+\t  free_EXPR_LIST_node (note);\n+\t}\n+      else\n+\tnote_ptr = &XEXP (note, 1);\n     }\n \n-  update_uses (DF_INSN_INFO_EQ_USES (insn_info));\n+  confirm_change_group ();\n+  crtl->ssa->change_insn (use_change);\n+  num_changes++;\n+  return true;\n }\n \n-\n-/* Try substituting NEW into LOC, which originated from forward propagation\n-   of USE's value from DEF_INSN.  SET_REG_EQUAL says whether we are\n-   substituting the whole SET_SRC, so we can set a REG_EQUAL note if the\n-   new insn is not recognized.  Return whether the substitution was\n-   performed.  */\n+/* Try to substitute (set DEST SRC) from DEF_INSN into USE_INSN's notes,\n+   given that it was not possible to do this for USE_INSN's main pattern.\n+   Return true on success, otherwise leave USE_INSN unchanged.  */\n \n static bool\n-try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx_insn *def_insn,\n-\t\t  bool set_reg_equal)\n+try_fwprop_subst_notes (insn_info *use_insn, insn_info *def_insn,\n+\t\t\trtx dest, rtx src)\n {\n-  rtx_insn *insn = DF_REF_INSN (use);\n-  rtx set = single_set (insn);\n-  rtx note = NULL_RTX;\n-  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n-  int old_cost = 0;\n-  bool ok;\n+  rtx_insn *use_rtl = use_insn->rtl ();\n+  for (rtx note = REG_NOTES (use_rtl); note; note = XEXP (note, 1))\n+    if ((REG_NOTE_KIND (note) == REG_EQUAL\n+\t || REG_NOTE_KIND (note) == REG_EQUIV)\n+\t&& try_fwprop_subst_note (use_insn, def_insn, note,\n+\t\t\t\t  dest, src, true) > 0)\n+      {\n+\tconfirm_change_group ();\n+\treturn true;\n+      }\n \n-  update_df_init (def_insn, insn);\n+  return false;\n+}\n \n-  /* forward_propagate_subreg may be operating on an instruction with\n-     multiple sets.  If so, assume the cost of the new instruction is\n-     not greater than the old one.  */\n-  if (set)\n-    old_cost = set_src_cost (SET_SRC (set), GET_MODE (SET_DEST (set)), speed);\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\nIn insn %d, replacing\\n \", INSN_UID (insn));\n-      print_inline_rtx (dump_file, *loc, 2);\n-      fprintf (dump_file, \"\\n with \");\n-      print_inline_rtx (dump_file, new_rtx, 2);\n-      fprintf (dump_file, \"\\n\");\n-    }\n+/* Check whether we could validly substitute (set DEST SRC) from DEF_INSN\n+   into USE.  If so, first try performing the substitution in location LOC\n+   of USE->insn ()'s pattern.  If that fails, try instead to substitute\n+   into the notes.\n \n-  validate_unshare_change (insn, loc, new_rtx, true);\n-  if (!verify_changes (0))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Changes to insn %d not recognized\\n\",\n-\t\t INSN_UID (insn));\n-      ok = false;\n-    }\n+   Return true on success, otherwise leave USE_INSN unchanged.  */\n \n-  else if (DF_REF_TYPE (use) == DF_REF_REG_USE\n-\t   && set\n-\t   && (set_src_cost (SET_SRC (set), GET_MODE (SET_DEST (set)), speed)\n-\t       > old_cost))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Changes to insn %d not profitable\\n\",\n-\t\t INSN_UID (insn));\n-      ok = false;\n-    }\n+static bool\n+try_fwprop_subst (use_info *use, insn_info *def_insn,\n+\t\t  rtx *loc, rtx dest, rtx src)\n+{\n+  insn_info *use_insn = use->insn ();\n \n-  else\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"Changed insn %d\\n\", INSN_UID (insn));\n-      ok = true;\n-    }\n+  auto attempt = crtl->ssa->new_change_attempt ();\n+  use_array src_uses = remove_note_accesses (attempt, def_insn->uses ());\n \n-  if (ok)\n+  /* ??? Not really a meaningful test: it means we can propagate arithmetic\n+     involving hard registers but not bare references to them.  A better\n+     test would be to iterate over src_uses looking for hard registers\n+     that are not fixed.  */\n+  if (REG_P (src) && HARD_REGISTER_P (src))\n+    return false;\n+\n+  /* ??? It would be better to make this EBB-based instead.  That would\n+     involve checking for equal EBBs rather than equal BBs and trying\n+     to make the uses available at use_insn->ebb ()->first_bb ().  */\n+  if (def_insn->bb () != use_insn->bb ())\n     {\n-      confirm_change_group ();\n-      num_changes++;\n+      src_uses = crtl->ssa->make_uses_available (attempt, src_uses,\n+\t\t\t\t\t\t use_insn->bb ());\n+      if (!src_uses.is_valid ())\n+\treturn false;\n     }\n-  else\n-    {\n-      cancel_changes (0);\n-\n-      /* Can also record a simplified value in a REG_EQUAL note,\n-\t making a new one if one does not already exist.  */\n-      if (set_reg_equal)\n-\t{\n-\t  /* If there are any paradoxical SUBREGs, don't add REG_EQUAL note,\n-\t     because the bits in there can be anything and so might not\n-\t     match the REG_EQUAL note content.  See PR70574.  */\n-\t  subrtx_var_iterator::array_type array;\n-\t  FOR_EACH_SUBRTX_VAR (iter, array, *loc, NONCONST)\n-\t    {\n-\t      rtx x = *iter;\n-\t      if (SUBREG_P (x) && paradoxical_subreg_p (x))\n-\t\t{\n-\t\t  set_reg_equal = false;\n-\t\t  break;\n-\t\t}\n-\t    }\n \n-\t  if (set_reg_equal)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \" Setting REG_EQUAL note\\n\");\n+  insn_change use_change (use_insn);\n+  use_change.new_uses = merge_access_arrays (attempt, use_change.new_uses,\n+\t\t\t\t\t     src_uses);\n+  if (!use_change.new_uses.is_valid ())\n+    return false;\n \n-\t      note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (new_rtx));\n-\t    }\n-\t}\n-    }\n+  /* ??? We could allow movement within the EBB by adding:\n \n-  if ((ok || note) && !CONSTANT_P (new_rtx))\n-    update_df (insn, note);\n+     use_change.move_range = use_insn->ebb ()->insn_range ();  */\n+  if (!restrict_movement (use_change))\n+    return false;\n \n-  return ok;\n+  return (try_fwprop_subst_pattern (attempt, use_change, def_insn,\n+\t\t\t\t    loc, dest, src)\n+\t  || try_fwprop_subst_notes (use_insn, def_insn, dest, src));\n }\n \n /* For the given single_set INSN, containing SRC known to be a\n@@ -1117,33 +611,31 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx_insn *def_insn,\n    load from memory.  */\n \n static bool\n-free_load_extend (rtx src, rtx_insn *insn)\n+free_load_extend (rtx src, insn_info *insn)\n {\n-  rtx reg;\n-  df_ref def, use;\n-\n-  reg = XEXP (src, 0);\n+  rtx reg = XEXP (src, 0);\n   if (load_extend_op (GET_MODE (reg)) != GET_CODE (src))\n     return false;\n \n-  FOR_EACH_INSN_USE (use, insn)\n-    if (!DF_REF_IS_ARTIFICIAL (use)\n-\t&& DF_REF_TYPE (use) == DF_REF_REG_USE\n-\t&& DF_REF_REG (use) == reg)\n-      break;\n-  if (!use)\n-    return false;\n+  def_info *def = nullptr;\n+  for (use_info *use : insn->uses ())\n+    if (use->regno () == REGNO (reg))\n+      {\n+\tdef = use->def ();\n+\tbreak;\n+      }\n \n-  def = get_def_for_use (use);\n   if (!def)\n     return false;\n \n-  if (DF_REF_IS_ARTIFICIAL (def))\n+  insn_info *def_insn = def->insn ();\n+  if (def_insn->is_artificial ())\n     return false;\n \n-  if (NONJUMP_INSN_P (DF_REF_INSN (def)))\n+  rtx_insn *def_rtl = def_insn->rtl ();\n+  if (NONJUMP_INSN_P (def_rtl))\n     {\n-      rtx patt = PATTERN (DF_REF_INSN (def));\n+      rtx patt = PATTERN (def_rtl);\n \n       if (GET_CODE (patt) == SET\n \t  && GET_CODE (SET_SRC (patt)) == MEM\n@@ -1153,39 +645,38 @@ free_load_extend (rtx src, rtx_insn *insn)\n   return false;\n }\n \n-/* If USE is a subreg, see if it can be replaced by a pseudo.  */\n+/* Subroutine of forward_propagate_subreg that handles a use of DEST\n+   in REF.  The other parameters are the same.  */\n \n static bool\n-forward_propagate_subreg (df_ref use, rtx_insn *def_insn, rtx def_set)\n+forward_propagate_subreg (use_info *use, insn_info *def_insn,\n+\t\t\t  rtx dest, rtx src, df_ref ref)\n {\n-  rtx use_reg = DF_REF_REG (use);\n-  rtx_insn *use_insn;\n-  rtx src;\n   scalar_int_mode int_use_mode, src_mode;\n \n   /* Only consider subregs... */\n+  rtx use_reg = DF_REF_REG (ref);\n   machine_mode use_mode = GET_MODE (use_reg);\n   if (GET_CODE (use_reg) != SUBREG\n-      || !REG_P (SET_DEST (def_set)))\n+      || GET_MODE (SUBREG_REG (use_reg)) != GET_MODE (dest))\n     return false;\n \n+  /* ??? Replacing throughout the pattern would help for match_dups.  */\n+  rtx *loc = DF_REF_LOC (ref);\n   if (paradoxical_subreg_p (use_reg))\n     {\n       /* If this is a paradoxical SUBREG, we have no idea what value the\n \t extra bits would have.  However, if the operand is equivalent to\n \t a SUBREG whose operand is the same as our mode, and all the modes\n \t are within a word, we can just use the inner operand because\n \t these SUBREGs just say how to treat the register.  */\n-      use_insn = DF_REF_INSN (use);\n-      src = SET_SRC (def_set);\n       if (GET_CODE (src) == SUBREG\n \t  && REG_P (SUBREG_REG (src))\n \t  && REGNO (SUBREG_REG (src)) >= FIRST_PSEUDO_REGISTER\n \t  && GET_MODE (SUBREG_REG (src)) == use_mode\n-\t  && subreg_lowpart_p (src)\n-\t  && all_uses_available_at (def_insn, use_insn))\n-\treturn try_fwprop_subst (use, DF_REF_LOC (use), SUBREG_REG (src),\n-\t\t\t\t def_insn, false);\n+\t  && subreg_lowpart_p (src))\n+\treturn try_fwprop_subst (use, def_insn, loc,\n+\t\t\t\t use_reg, SUBREG_REG (src));\n     }\n \n   /* If this is a SUBREG of a ZERO_EXTEND or SIGN_EXTEND, and the SUBREG\n@@ -1206,8 +697,6 @@ forward_propagate_subreg (df_ref use, rtx_insn *def_insn, rtx def_set)\n   else if (is_a <scalar_int_mode> (use_mode, &int_use_mode)\n \t   && subreg_lowpart_p (use_reg))\n     {\n-      use_insn = DF_REF_INSN (use);\n-      src = SET_SRC (def_set);\n       if ((GET_CODE (src) == ZERO_EXTEND\n \t   || GET_CODE (src) == SIGN_EXTEND)\n \t  && is_a <scalar_int_mode> (GET_MODE (src), &src_mode)\n@@ -1216,139 +705,73 @@ forward_propagate_subreg (df_ref use, rtx_insn *def_insn, rtx def_set)\n \t  && GET_MODE (XEXP (src, 0)) == use_mode\n \t  && !free_load_extend (src, def_insn)\n \t  && (targetm.mode_rep_extended (int_use_mode, src_mode)\n-\t      != (int) GET_CODE (src))\n-\t  && all_uses_available_at (def_insn, use_insn))\n-\treturn try_fwprop_subst (use, DF_REF_LOC (use), XEXP (src, 0),\n-\t\t\t\t def_insn, false);\n+\t      != (int) GET_CODE (src)))\n+\treturn try_fwprop_subst (use, def_insn, loc, use_reg, XEXP (src, 0));\n     }\n \n   return false;\n }\n \n-/* Try to replace USE with SRC (defined in DEF_INSN) in __asm.  */\n+/* Try to substitute (set DEST SRC) from DEF_INSN into USE and simplify\n+   the result, handling cases where DEST is used in a subreg and where\n+   applying that subreg to SRC results in a useful simplification.  */\n \n static bool\n-forward_propagate_asm (df_ref use, rtx_insn *def_insn, rtx def_set, rtx reg)\n+forward_propagate_subreg (use_info *use, insn_info *def_insn,\n+\t\t\t  rtx dest, rtx src)\n {\n-  rtx_insn *use_insn = DF_REF_INSN (use);\n-  rtx src, use_pat, asm_operands, new_rtx, *loc;\n-  int speed_p, i;\n-  df_ref uses;\n-\n-  gcc_assert ((DF_REF_FLAGS (use) & DF_REF_IN_NOTE) == 0);\n-\n-  src = SET_SRC (def_set);\n-  use_pat = PATTERN (use_insn);\n+  if (!use->includes_subregs () || !REG_P (dest))\n+    return false;\n \n-  /* In __asm don't replace if src might need more registers than\n-     reg, as that could increase register pressure on the __asm.  */\n-  uses = DF_INSN_USES (def_insn);\n-  if (uses && DF_REF_NEXT_LOC (uses))\n+  if (GET_CODE (src) != SUBREG\n+      && GET_CODE (src) != ZERO_EXTEND\n+      && GET_CODE (src) != SIGN_EXTEND)\n     return false;\n \n-  update_df_init (def_insn, use_insn);\n-  speed_p = optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn));\n-  asm_operands = NULL_RTX;\n-  switch (GET_CODE (use_pat))\n-    {\n-    case ASM_OPERANDS:\n-      asm_operands = use_pat;\n-      break;\n-    case SET:\n-      if (MEM_P (SET_DEST (use_pat)))\n-\t{\n-\t  loc = &SET_DEST (use_pat);\n-\t  new_rtx = propagate_rtx (*loc, GET_MODE (*loc), reg, src, speed_p);\n-\t  if (new_rtx)\n-\t    validate_unshare_change (use_insn, loc, new_rtx, true);\n-\t}\n-      asm_operands = SET_SRC (use_pat);\n-      break;\n-    case PARALLEL:\n-      for (i = 0; i < XVECLEN (use_pat, 0); i++)\n-\tif (GET_CODE (XVECEXP (use_pat, 0, i)) == SET)\n-\t  {\n-\t    if (MEM_P (SET_DEST (XVECEXP (use_pat, 0, i))))\n-\t      {\n-\t\tloc = &SET_DEST (XVECEXP (use_pat, 0, i));\n-\t\tnew_rtx = propagate_rtx (*loc, GET_MODE (*loc), reg,\n-\t\t\t\t\t src, speed_p);\n-\t\tif (new_rtx)\n-\t\t  validate_unshare_change (use_insn, loc, new_rtx, true);\n-\t      }\n-\t    asm_operands = SET_SRC (XVECEXP (use_pat, 0, i));\n-\t  }\n-\telse if (GET_CODE (XVECEXP (use_pat, 0, i)) == ASM_OPERANDS)\n-\t  asm_operands = XVECEXP (use_pat, 0, i);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  rtx_insn *use_rtl = use->insn ()->rtl ();\n+  df_ref ref;\n \n-  gcc_assert (asm_operands && GET_CODE (asm_operands) == ASM_OPERANDS);\n-  for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (asm_operands); i++)\n-    {\n-      loc = &ASM_OPERANDS_INPUT (asm_operands, i);\n-      new_rtx = propagate_rtx (*loc, GET_MODE (*loc), reg, src, speed_p);\n-      if (new_rtx)\n-\tvalidate_unshare_change (use_insn, loc, new_rtx, true);\n-    }\n+  FOR_EACH_INSN_USE (ref, use_rtl)\n+    if (DF_REF_REGNO (ref) == use->regno ()\n+\t&& forward_propagate_subreg (use, def_insn, dest, src, ref))\n+      return true;\n \n-  if (num_changes_pending () == 0 || !apply_change_group ())\n-    return false;\n+  FOR_EACH_INSN_EQ_USE (ref, use_rtl)\n+    if (DF_REF_REGNO (ref) == use->regno ()\n+\t&& forward_propagate_subreg (use, def_insn, dest, src, ref))\n+      return true;\n \n-  update_df (use_insn, NULL);\n-  num_changes++;\n-  return true;\n+  return false;\n }\n \n-/* Try to replace USE with SRC (defined in DEF_INSN) and simplify the\n-   result.  */\n+/* Try to substitute (set DEST SRC) from DEF_INSN into USE and\n+   simplify the result.  */\n \n static bool\n-forward_propagate_and_simplify (df_ref use, rtx_insn *def_insn, rtx def_set)\n+forward_propagate_and_simplify (use_info *use, insn_info *def_insn,\n+\t\t\t\trtx dest, rtx src)\n {\n-  rtx_insn *use_insn = DF_REF_INSN (use);\n-  rtx use_set = single_set (use_insn);\n-  rtx src, reg, new_rtx, *loc;\n-  bool set_reg_equal;\n-  machine_mode mode;\n-  int asm_use = -1;\n-\n-  if (INSN_CODE (use_insn) < 0)\n-    asm_use = asm_noperands (PATTERN (use_insn));\n-\n-  if (!use_set && asm_use < 0 && !DEBUG_INSN_P (use_insn))\n+  insn_info *use_insn = use->insn ();\n+  rtx_insn *use_rtl = use_insn->rtl ();\n+\n+  /* ??? This check seems unnecessary.  We should be able to propagate\n+     into any kind of instruction, regardless of whether it's a single set.\n+     It seems odd to be more permissive with asms than normal instructions.  */\n+  bool need_single_set = (!use_insn->is_asm () && !use_insn->is_debug_insn ());\n+  rtx use_set = single_set (use_rtl);\n+  if (need_single_set && !use_set)\n     return false;\n \n-  /* Do not propagate into PC, CC0, etc.  */\n-  if (use_set && GET_MODE (SET_DEST (use_set)) == VOIDmode)\n-    return false;\n+  /* Do not propagate into PC, CC0, etc.\n \n-  /* If def and use are subreg, check if they match.  */\n-  reg = DF_REF_REG (use);\n-  if (GET_CODE (reg) == SUBREG && GET_CODE (SET_DEST (def_set)) == SUBREG)\n-    {\n-      if (maybe_ne (SUBREG_BYTE (SET_DEST (def_set)), SUBREG_BYTE (reg)))\n-\treturn false;\n-    }\n-  /* Check if the def had a subreg, but the use has the whole reg.  */\n-  else if (REG_P (reg) && GET_CODE (SET_DEST (def_set)) == SUBREG)\n-    return false;\n-  /* Check if the use has a subreg, but the def had the whole reg.  Unlike the\n-     previous case, the optimization is possible and often useful indeed.  */\n-  else if (GET_CODE (reg) == SUBREG && REG_P (SET_DEST (def_set)))\n-    reg = SUBREG_REG (reg);\n-\n-  /* Make sure that we can treat REG as having the same mode as the\n-     source of DEF_SET.  */\n-  if (GET_MODE (SET_DEST (def_set)) != GET_MODE (reg))\n+     ??? This too seems unnecessary.  The current code should work correctly\n+     without it, including cases where jumps become unconditional.  */\n+  if (use_set && GET_MODE (SET_DEST (use_set)) == VOIDmode)\n     return false;\n \n-  /* Check if the substitution is valid (last, because it's the most\n-     expensive check!).  */\n-  src = SET_SRC (def_set);\n-  if (!CONSTANT_P (src) && !all_uses_available_at (def_insn, use_insn))\n+  /* In __asm don't replace if src might need more registers than\n+     reg, as that could increase register pressure on the __asm.  */\n+  if (use_insn->is_asm () && def_insn->uses ().size () > 1)\n     return false;\n \n   /* Check if the def is loading something from the constant pool; in this\n@@ -1357,149 +780,90 @@ forward_propagate_and_simplify (df_ref use, rtx_insn *def_insn, rtx def_set)\n   if (MEM_P (src) && MEM_READONLY_P (src))\n     {\n       rtx x = avoid_constant_pool_reference (src);\n-      if (x != src && use_set)\n+      rtx note_set;\n+      if (x != src\n+\t  && (note_set = set_for_reg_notes (use_rtl))\n+\t  && REG_P (SET_DEST (note_set))\n+\t  && !contains_paradoxical_subreg_p (SET_SRC (note_set)))\n \t{\n-          rtx note = find_reg_note (use_insn, REG_EQUAL, NULL_RTX);\n-\t  rtx old_rtx = note ? XEXP (note, 0) : SET_SRC (use_set);\n+\t  rtx note = find_reg_note (use_rtl, REG_EQUAL, NULL_RTX);\n+\t  rtx old_rtx = note ? XEXP (note, 0) : SET_SRC (note_set);\n \t  rtx new_rtx = simplify_replace_rtx (old_rtx, src, x);\n \t  if (old_rtx != new_rtx)\n-            set_unique_reg_note (use_insn, REG_EQUAL, copy_rtx (new_rtx));\n+\t    set_unique_reg_note (use_rtl, REG_EQUAL, copy_rtx (new_rtx));\n \t}\n       return false;\n     }\n \n-  if (asm_use >= 0)\n-    return forward_propagate_asm (use, def_insn, def_set, reg);\n-\n-  /* Else try simplifying.  */\n-\n-  if (DF_REF_TYPE (use) == DF_REF_REG_MEM_STORE)\n-    {\n-      loc = &SET_DEST (use_set);\n-      set_reg_equal = false;\n-    }\n-  else if (!use_set)\n-    {\n-      loc = &INSN_VAR_LOCATION_LOC (use_insn);\n-      set_reg_equal = false;\n-    }\n-  else\n-    {\n-      rtx note = find_reg_note (use_insn, REG_EQUAL, NULL_RTX);\n-      if (DF_REF_FLAGS (use) & DF_REF_IN_NOTE)\n-\tloc = &XEXP (note, 0);\n-      else\n-\tloc = &SET_SRC (use_set);\n-\n-      /* Do not replace an existing REG_EQUAL note if the insn is not\n-\t recognized.  Either we're already replacing in the note, or we'll\n-\t separately try plugging the definition in the note and simplifying.\n-\t And only install a REQ_EQUAL note when the destination is a REG\n-\t that isn't mentioned in USE_SET, as the note would be invalid\n-\t otherwise.  We also don't want to install a note if we are merely\n-\t propagating a pseudo since verifying that this pseudo isn't dead\n-\t is a pain; moreover such a note won't help anything.\n-\t If the use is a paradoxical subreg, make sure we don't add a\n-\t REG_EQUAL note for it, because it is not equivalent, it is one\n-\t possible value for it, but we can't rely on it holding that value.\n-\t See PR70574.  */\n-      set_reg_equal = (note == NULL_RTX\n-\t\t       && REG_P (SET_DEST (use_set))\n-\t\t       && !REG_P (src)\n-\t\t       && !(GET_CODE (src) == SUBREG\n-\t\t\t    && REG_P (SUBREG_REG (src)))\n-\t\t       && !reg_mentioned_p (SET_DEST (use_set),\n-\t\t\t\t\t    SET_SRC (use_set))\n-\t\t       && !paradoxical_subreg_p (DF_REF_REG (use)));\n-    }\n-\n-  if (GET_MODE (*loc) == VOIDmode)\n-    mode = GET_MODE (SET_DEST (use_set));\n-  else\n-    mode = GET_MODE (*loc);\n-\n-  new_rtx = propagate_rtx (*loc, mode, reg, src,\n-  \t\t\t   optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn)));\n-\n-  if (!new_rtx)\n-    return false;\n-\n-  return try_fwprop_subst (use, loc, new_rtx, def_insn, set_reg_equal);\n+  /* ??? Unconditionally propagating into PATTERN would work better\n+     for instructions that have match_dups.  */\n+  rtx *loc = need_single_set ? &use_set : &PATTERN (use_rtl);\n+  return try_fwprop_subst (use, def_insn, loc, dest, src);\n }\n \n-\n /* Given a use USE of an insn, if it has a single reaching\n    definition, try to forward propagate it into that insn.\n-   Return true if cfg cleanup will be needed.\n+   Return true if something changed.\n+\n    REG_PROP_ONLY is true if we should only propagate register copies.  */\n \n static bool\n-forward_propagate_into (df_ref use, bool reg_prop_only = false)\n+forward_propagate_into (use_info *use, bool reg_prop_only = false)\n {\n-  df_ref def;\n-  rtx_insn *def_insn, *use_insn;\n-  rtx def_set;\n-  rtx parent;\n-\n-  if (DF_REF_FLAGS (use) & DF_REF_READ_WRITE)\n-    return false;\n-  if (DF_REF_IS_ARTIFICIAL (use))\n+  if (use->includes_read_writes ())\n     return false;\n \n-  /* Only consider uses that have a single definition.  */\n-  def = get_def_for_use (use);\n+  /* Disregard uninitialized uses.  */\n+  def_info *def = use->def ();\n   if (!def)\n     return false;\n-  if (DF_REF_FLAGS (def) & DF_REF_READ_WRITE)\n-    return false;\n-  if (DF_REF_IS_ARTIFICIAL (def))\n-    return false;\n \n-  /* Check if the use is still present in the insn!  */\n-  use_insn = DF_REF_INSN (use);\n-  if (DF_REF_FLAGS (use) & DF_REF_IN_NOTE)\n-    parent = find_reg_note (use_insn, REG_EQUAL, NULL_RTX);\n-  else\n-    parent = PATTERN (use_insn);\n+  /* Only consider single-register definitions.  This could be relaxed,\n+     but it should rarely be needed before RA.  */\n+  def = look_through_degenerate_phi (def);\n+  if (def->includes_multiregs ())\n+    return false;\n \n-  if (!reg_mentioned_p (DF_REF_REG (use), parent))\n+  /* Only consider uses whose definition comes from a real instruction.  */\n+  insn_info *def_insn = def->insn ();\n+  if (def_insn->is_artificial ())\n     return false;\n \n-  def_insn = DF_REF_INSN (def);\n-  if (multiple_sets (def_insn))\n+  rtx_insn *def_rtl = def_insn->rtl ();\n+  if (!NONJUMP_INSN_P (def_rtl))\n+    return false;\n+  /* ??? This seems an unnecessary restriction.  We can easily tell\n+     which set the definition comes from.  */\n+  if (multiple_sets (def_rtl))\n     return false;\n-  def_set = single_set (def_insn);\n+  rtx def_set = simple_regno_set (PATTERN (def_rtl), def->regno ());\n   if (!def_set)\n     return false;\n \n-  if (reg_prop_only\n-      && (!reg_single_def_p (SET_SRC (def_set))\n-\t  || !reg_single_def_p (SET_DEST (def_set))))\n-    return false;\n+  rtx dest = SET_DEST (def_set);\n+  rtx src = SET_SRC (def_set);\n \n   /* Allow propagations into a loop only for reg-to-reg copies, since\n      replacing one register by another shouldn't increase the cost.  */\n+  struct loop *def_loop = def_insn->bb ()->cfg_bb ()->loop_father;\n+  struct loop *use_loop = use->bb ()->cfg_bb ()->loop_father;\n+  if ((reg_prop_only || def_loop != use_loop)\n+      && (!reg_single_def_p (dest) || !reg_single_def_p (src)))\n+    return false;\n \n-  if (DF_REF_BB (def)->loop_father != DF_REF_BB (use)->loop_father\n-      && (!reg_single_def_p (SET_SRC (def_set))\n-\t  || !reg_single_def_p (SET_DEST (def_set))))\n+  /* Don't substitute into a non-local goto, this confuses CFG.  */\n+  insn_info *use_insn = use->insn ();\n+  rtx_insn *use_rtl = use_insn->rtl ();\n+  if (JUMP_P (use_rtl)\n+      && find_reg_note (use_rtl, REG_NON_LOCAL_GOTO, NULL_RTX))\n     return false;\n \n-  /* Only try one kind of propagation.  If two are possible, we'll\n-     do it on the following iterations.  */\n-  if (forward_propagate_and_simplify (use, def_insn, def_set)\n-      || forward_propagate_subreg (use, def_insn, def_set))\n-    {\n-      propagations_left--;\n+  if (forward_propagate_and_simplify (use, def_insn, dest, src)\n+      || forward_propagate_subreg (use, def_insn, dest, src))\n+    return true;\n \n-      if (cfun->can_throw_non_call_exceptions\n-\t  && find_reg_note (use_insn, REG_EH_REGION, NULL_RTX)\n-\t  && purge_dead_edges (DF_REF_BB (use)))\n-\treturn true;\n-    }\n   return false;\n }\n-\n \f\n static void\n fwprop_init (void)\n@@ -1513,28 +877,22 @@ fwprop_init (void)\n      build_single_def_use_links.  */\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n \n-  build_single_def_use_links ();\n-  df_set_flags (DF_DEFER_INSN_RESCAN);\n-\n-  active_defs = XNEWVEC (df_ref, max_reg_num ());\n-  if (flag_checking)\n-    active_defs_check = sparseset_alloc (max_reg_num ());\n-\n-  propagations_left = DF_USES_TABLE_SIZE ();\n+  df_analyze ();\n+  crtl->ssa = new rtl_ssa::function_info (cfun);\n }\n \n static void\n fwprop_done (void)\n {\n   loop_optimizer_finalize ();\n \n-  use_def_ref.release ();\n-  free (active_defs);\n-  if (flag_checking)\n-    sparseset_free (active_defs_check);\n-\n+  crtl->ssa->perform_pending_updates ();\n   free_dominance_info (CDI_DOMINATORS);\n   cleanup_cfg (0);\n+\n+  delete crtl->ssa;\n+  crtl->ssa = nullptr;\n+\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n \n   if (dump_file)\n@@ -1543,6 +901,41 @@ fwprop_done (void)\n \t     num_changes);\n }\n \n+/* Try to optimize INSN, returning true if something changes.\n+   FWPROP_ADDR_P is true if we are running fwprop_addr rather than\n+   the full fwprop.  */\n+\n+static bool\n+fwprop_insn (insn_info *insn, bool fwprop_addr_p)\n+{\n+  for (use_info *use : insn->uses ())\n+    {\n+      if (use->is_mem ())\n+\tcontinue;\n+      /* ??? The choices here follow those in the pre-SSA code.  */\n+      if (!use->includes_address_uses ())\n+\t{\n+\t  if (forward_propagate_into (use, fwprop_addr_p))\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  struct loop *loop = insn->bb ()->cfg_bb ()->loop_father;\n+\t  /* The outermost loop is not really a loop.  */\n+\t  if (loop == NULL || loop_outer (loop) == NULL)\n+\t    {\n+\t      if (forward_propagate_into (use, fwprop_addr_p))\n+\t\treturn true;\n+\t    }\n+\t  else if (fwprop_addr_p)\n+\t    {\n+\t      if (forward_propagate_into (use, false))\n+\t\treturn true;\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n \n /* Main entry point.  */\n \n@@ -1555,33 +948,33 @@ gate_fwprop (void)\n static unsigned int\n fwprop (bool fwprop_addr_p)\n {\n-  unsigned i;\n-\n   fwprop_init ();\n \n-  /* Go through all the uses.  df_uses_create will create new ones at the\n-     end, and we'll go through them as well.\n+  /* Go through all the instructions (including debug instructions) looking\n+     for uses that we could propagate into.\n \n      Do not forward propagate addresses into loops until after unrolling.\n      CSE did so because it was able to fix its own mess, but we are not.  */\n \n-  for (i = 0; i < DF_USES_TABLE_SIZE (); i++)\n-    {\n-      if (!propagations_left)\n-\tbreak;\n-\n-      df_ref use = DF_USES_GET (i);\n-      if (use)\n-\t{\n-\t  if (DF_REF_TYPE (use) == DF_REF_REG_USE\n-\t      || DF_REF_BB (use)->loop_father == NULL\n-\t      /* The outer most loop is not really a loop.  */\n-\t      || loop_outer (DF_REF_BB (use)->loop_father) == NULL)\n-\t    forward_propagate_into (use, fwprop_addr_p);\n+  insn_info *next;\n \n-\t  else if (fwprop_addr_p)\n-\t    forward_propagate_into (use, false);\n-\t}\n+  /* ??? This code uses a worklist in order to preserve the behavior\n+     of the pre-SSA implementation.  It would be better to instead\n+     iterate on each instruction until no more propagations are\n+     possible, then move on to the next.  */\n+  auto_vec<insn_info *> worklist;\n+  for (insn_info *insn = crtl->ssa->first_insn (); insn; insn = next)\n+    {\n+      next = insn->next_any_insn ();\n+      if (insn->can_be_optimized () || insn->is_debug_insn ())\n+\tif (fwprop_insn (insn, fwprop_addr_p))\n+\t  worklist.safe_push (insn);\n+    }\n+  for (unsigned int i = 0; i < worklist.length (); ++i)\n+    {\n+      insn_info *insn = worklist[i];\n+      if (fwprop_insn (insn, fwprop_addr_p))\n+\tworklist.safe_push (insn);\n     }\n \n   fwprop_done ();"}, {"sha": "1dadf554338c27d1c346fe7a109c195184df1943", "filename": "gcc/testsuite/gcc.dg/rtl/x86_64/test-return-const.c.before-fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b76990a9d75d97b84014e37519086b81824c307/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Fx86_64%2Ftest-return-const.c.before-fwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b76990a9d75d97b84014e37519086b81824c307/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Fx86_64%2Ftest-return-const.c.before-fwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frtl%2Fx86_64%2Ftest-return-const.c.before-fwprop.c?ref=0b76990a9d75d97b84014e37519086b81824c307", "patch": "@@ -31,7 +31,7 @@ int __RTL (startwith (\"fwprop1\")) test_returning_constant (void)\n }\n \n /* Verify that insn 5 is eliminated.  */\n-/* { dg-final { scan-rtl-dump \"deferring deletion of insn with uid = 5\" \"fwprop1\" } } */\n+/* { dg-final { scan-rtl-dump \"deleting insn with uid = 5\" \"fwprop1\" } } */\n /* { dg-final { scan-rtl-dump \"Deleted 1 trivially dead insns\" \"fwprop1\" } } */\n \n int main (void)"}, {"sha": "c916d2048fc65ac856152e558aa2db5962b66df1", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/asm/st4_s8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b76990a9d75d97b84014e37519086b81824c307/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fst4_s8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b76990a9d75d97b84014e37519086b81824c307/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fst4_s8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fst4_s8.c?ref=0b76990a9d75d97b84014e37519086b81824c307", "patch": "@@ -74,7 +74,7 @@ TEST_STORE (st4_s8_28, svint8x4_t, int8_t,\n /*\n ** st4_s8_32:\n **\t[^{]*\n-**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+\\]\n+**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+, x[0-9]+\\]\n **\tret\n */\n TEST_STORE (st4_s8_32, svint8x4_t, int8_t,\n@@ -135,7 +135,7 @@ TEST_STORE (st4_s8_m32, svint8x4_t, int8_t,\n /*\n ** st4_s8_m36:\n **\t[^{]*\n-**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+\\]\n+**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+, x[0-9]+\\]\n **\tret\n */\n TEST_STORE (st4_s8_m36, svint8x4_t, int8_t,\n@@ -205,7 +205,7 @@ TEST_STORE (st4_vnum_s8_28, svint8x4_t, int8_t,\n /*\n ** st4_vnum_s8_32:\n **\t[^{]*\n-**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+\\]\n+**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+, x[0-9]+\\]\n **\tret\n */\n TEST_STORE (st4_vnum_s8_32, svint8x4_t, int8_t,\n@@ -266,7 +266,7 @@ TEST_STORE (st4_vnum_s8_m32, svint8x4_t, int8_t,\n /*\n ** st4_vnum_s8_m36:\n **\t[^{]*\n-**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+\\]\n+**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+, x[0-9]+\\]\n **\tret\n */\n TEST_STORE (st4_vnum_s8_m36, svint8x4_t, int8_t,"}, {"sha": "32b8c8c4166046d613b2871466cecb9501b4bcc7", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/asm/st4_u8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b76990a9d75d97b84014e37519086b81824c307/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fst4_u8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b76990a9d75d97b84014e37519086b81824c307/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fst4_u8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fasm%2Fst4_u8.c?ref=0b76990a9d75d97b84014e37519086b81824c307", "patch": "@@ -74,7 +74,7 @@ TEST_STORE (st4_u8_28, svuint8x4_t, uint8_t,\n /*\n ** st4_u8_32:\n **\t[^{]*\n-**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+\\]\n+**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+, x[0-9]+\\]\n **\tret\n */\n TEST_STORE (st4_u8_32, svuint8x4_t, uint8_t,\n@@ -135,7 +135,7 @@ TEST_STORE (st4_u8_m32, svuint8x4_t, uint8_t,\n /*\n ** st4_u8_m36:\n **\t[^{]*\n-**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+\\]\n+**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+, x[0-9]+\\]\n **\tret\n */\n TEST_STORE (st4_u8_m36, svuint8x4_t, uint8_t,\n@@ -205,7 +205,7 @@ TEST_STORE (st4_vnum_u8_28, svuint8x4_t, uint8_t,\n /*\n ** st4_vnum_u8_32:\n **\t[^{]*\n-**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+\\]\n+**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+, x[0-9]+\\]\n **\tret\n */\n TEST_STORE (st4_vnum_u8_32, svuint8x4_t, uint8_t,\n@@ -266,7 +266,7 @@ TEST_STORE (st4_vnum_u8_m32, svuint8x4_t, uint8_t,\n /*\n ** st4_vnum_u8_m36:\n **\t[^{]*\n-**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+\\]\n+**\tst4b\t{z0\\.b - z3\\.b}, p0, \\[x[0-9]+, x[0-9]+\\]\n **\tret\n */\n TEST_STORE (st4_vnum_u8_m36, svuint8x4_t, uint8_t,"}]}