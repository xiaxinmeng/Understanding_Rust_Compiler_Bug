{"sha": "75d01ad77d70305c737b2c92c2674305edbf8306", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVkMDFhZDc3ZDcwMzA1YzczN2IyYzkyYzI2NzQzMDVlZGJmODMwNg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-25T17:10:46Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-11-25T17:10:46Z"}, "message": "java-tree.h (end_params_node): Declare global.\n\nd\n\t* java-tree.h (end_params_node):  Declare global.\n\t* decl.c (end_params_node):  New global.\n\t(init_decl_processing, start_java_method):  Use end_params_node for\n\tend of list of parameter types.  Follows correct gcc conventions.\n\t* expr.c (pop_argument_types, pop_arguments):  Likewise.\n\t* lang.c (put_decl_node):  Likewise.\n\t* typeck.c (various places):  Likewise.\n\t* class.y (various places):  Likewise.\n\t* parse.y (various places):  Likewise.\n\t* parse.y (java_complete_tree):  Move CAN_COMPLETE_NORMALLY.\n\t(build_jump_to_finally):  Add missing CAN_COMPLETE_NORMALLY.\n\t* class.c:  Add #include flags.h, remove no-longer needed declaration.\n\t* class.c (layout_class_method):  Remove commented-out code, re-format.\n\tDon't add vtable entry (or index) for private methods.\n\t* expr.c (expand_invoke):  A private method is implicitly final.\n\t* class.c (make_class_data):  If inlining or optimizing,\n\tskip private methods.\n\t* class.c (finish_class):  New function.  Calls existing methods,\n\tbut alls emits deferred inline functions.\n\t* jcf-parse.c (parse_class_file):  Call finish_class.\n\t* parse.y (java_complete_expand_methods):  Likewise.\n\t* expr.c (build_java_binop):  Explicit default, to silence -Wall.\n\nFrom-SVN: r23869", "tree": {"sha": "a05a1b624f62c8a98e003262ab32602a53112cc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a05a1b624f62c8a98e003262ab32602a53112cc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75d01ad77d70305c737b2c92c2674305edbf8306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d01ad77d70305c737b2c92c2674305edbf8306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d01ad77d70305c737b2c92c2674305edbf8306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d01ad77d70305c737b2c92c2674305edbf8306/comments", "author": null, "committer": null, "parents": [{"sha": "df8940cf1b77f164874f595619017acd85ebe40d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df8940cf1b77f164874f595619017acd85ebe40d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df8940cf1b77f164874f595619017acd85ebe40d"}], "stats": {"total": 208, "additions": 112, "deletions": 96}, "files": [{"sha": "681f8c20bc5a4ad668d4d35d1fca2e201b0fc6ea", "filename": "gcc/java/class.c", "status": "modified", "additions": 112, "deletions": 96, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75d01ad77d70305c737b2c92c2674305edbf8306/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75d01ad77d70305c737b2c92c2674305edbf8306/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=75d01ad77d70305c737b2c92c2674305edbf8306", "patch": "@@ -28,6 +28,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"flags.h\"\n #include \"java-tree.h\"\n #include \"jcf.h\"\n #include \"obstack.h\"\n@@ -994,7 +995,11 @@ make_class_data (type)\n   for (method = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (type));\n        method != NULL_TREE; method = TREE_CHAIN (method))\n     {\n-      tree init = make_method_value (method, this_class_addr);\n+      tree init;\n+      if (METHOD_PRIVATE (method)\n+\t  && (flag_inline_functions || optimize))\n+\tcontinue;\n+      init = make_method_value (method, this_class_addr);\n       method_count++;\n       methods = tree_cons (NULL_TREE, init, methods);\n     }\n@@ -1083,8 +1088,13 @@ make_class_data (type)\n   START_RECORD_CONSTRUCTOR (cons, class_type_node);\n   PUSH_SUPER_VALUE (cons, temp);\n   PUSH_FIELD_VALUE (cons, \"next\", null_pointer_node);\n+#if 0\n+  /* Need to fix _Jv_FindClassFromSignature. */\n+  PUSH_FIELD_VALUE (cons, \"name\", build_utf8_ref (DECL_NAME (type_decl)));\n+#else\n   PUSH_FIELD_VALUE (cons, \"name\",\n \t\t    build_utf8_ref (build_internal_class_name (type)));\n+#endif\n   PUSH_FIELD_VALUE (cons, \"accflags\",\n \t\t    build_int_2 (get_access_flags_from_decl (type_decl), 0));\n \n@@ -1101,7 +1111,6 @@ make_class_data (type)\n   PUSH_FIELD_VALUE (cons, \"field_count\", build_int_2 (field_count, 0));\n   PUSH_FIELD_VALUE (cons, \"static_field_count\",\n \t\t    build_int_2 (static_field_count, 0));\n-  /* For now, we let Kaffe fill in the dtable.  */\n   PUSH_FIELD_VALUE (cons, \"dtable\",\n \t\t    dtable_decl == NULL_TREE ? null_pointer_node\n \t\t    : build1 (ADDR_EXPR, dtable_ptr_type, dtable_decl));\n@@ -1118,6 +1127,35 @@ make_class_data (type)\n   rest_of_decl_compilation (decl, (char*) 0, 1, 0);\n }\n \n+void\n+finish_class (cl)\n+     tree cl;\n+{\n+  tree method;\n+\n+  /* Emit deferred inline methods. */\n+  for ( method = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (current_class));\n+\tmethod != NULL_TREE; method = TREE_CHAIN (method))\n+    {\n+      if (! TREE_ASM_WRITTEN (method) && DECL_SAVED_INSNS (method) != 0)\n+\t{\n+\t  /* It's a deferred inline method.  Decide if we need to emit it. */\n+\t  if (flag_keep_inline_functions\n+\t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (method))\n+\t      || ! METHOD_PRIVATE (method))\n+\t    {\n+\t      temporary_allocation ();\n+\t      output_inline_function (method);\n+\t      permanent_allocation (1);\n+\t    }\n+\t}\n+    }\n+\n+  make_class_data (current_class);\n+  register_class ();\n+  rest_of_decl_compilation (TYPE_NAME (current_class), (char*) 0, 1, 0);\n+}\n+\n /* Return 2 if CLASS is compiled by this compilation job;\n    return 1 if CLASS can otherwise be assumed to be compiled;\n    return 0 if we cannot assume that CLASS is compiled.\n@@ -1435,113 +1473,91 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n   char *ptr;\n   char buf[8];\n   char *asm_name;\n+  tree arg, arglist, t;\n+  int method_name_needs_escapes = 0;\n   tree method_name = DECL_NAME (method_decl);\n   int method_name_is_wfl = \n     (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION);\n   if (method_name_is_wfl)\n     method_name = java_get_real_method_name (method_decl);\n-#if 1\n-  /* Remove this once we no longer need old (Kaffe / JDK 1.0)  mangling. */\n-  if (! flag_assume_compiled && METHOD_NATIVE (method_decl))\n+\n+  if (method_name != init_identifier_node \n+      && method_name != finit_identifier_node)\n     {\n-      for (ptr = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n-\t   *ptr; )\n+      int encoded_len\n+\t= unicode_mangling_length (IDENTIFIER_POINTER (method_name), \n+\t\t\t\t   IDENTIFIER_LENGTH (method_name));\n+      if (encoded_len > 0)\n \t{\n-\t  int ch = *ptr++;\n-\t  if (ch == '.')\n-\t    ch = '_';\n-\t  obstack_1grow (&temporary_obstack, (char) ch);\n+\t  method_name_needs_escapes = 1;\n+\t  emit_unicode_mangled_name (&temporary_obstack,\n+\t\t\t\t     IDENTIFIER_POINTER (method_name), \n+\t\t\t\t     IDENTIFIER_LENGTH (method_name));\n \t}\n-      obstack_1grow (&temporary_obstack, (char) '_');\n-      if (method_name == init_identifier_node)\n-\tobstack_grow (&temporary_obstack, \"INIT\", 4);\n       else\n-\tobstack_grow (&temporary_obstack,\n-\t\t      IDENTIFIER_POINTER (method_name),\n-\t\t      IDENTIFIER_LENGTH (method_name));\n+\t{\n+\t  obstack_grow (&temporary_obstack,\n+\t\t\tIDENTIFIER_POINTER (method_name),\n+\t\t\tIDENTIFIER_LENGTH (method_name));\n+\t}\n     }\n-  else\n-#endif\n+      \n+  obstack_grow (&temporary_obstack, \"__\", 2);\n+  if (method_name == finit_identifier_node)\n+    obstack_grow (&temporary_obstack, \"finit\", 5);\n+  append_gpp_mangled_type (&temporary_obstack, this_class);\n+  TREE_PUBLIC (method_decl) = 1;\n+\n+  t = TREE_TYPE (method_decl);\n+  arglist = TYPE_ARG_TYPES (t);\n+  if (TREE_CODE (t) == METHOD_TYPE)\n+    arglist = TREE_CHAIN (arglist);\n+  for (arg = arglist; arg != end_params_node;  )\n     {\n-      int len;  tree arg, arglist, t;\n-      int method_name_needs_escapes = 0;\n-      if (method_name != init_identifier_node \n-\t  && method_name != finit_identifier_node)\n+      tree a = arglist;\n+      tree argtype = TREE_VALUE (arg);\n+      int tindex = 1;\n+      if (TREE_CODE (argtype) == POINTER_TYPE)\n \t{\n-\t  int encoded_len\n-\t    = unicode_mangling_length (IDENTIFIER_POINTER (method_name), \n-\t\t\t\t       IDENTIFIER_LENGTH (method_name));\n-\t  if (encoded_len > 0)\n-\t    {\n-\t      method_name_needs_escapes = 1;\n-\t      emit_unicode_mangled_name (&temporary_obstack,\n-\t\t\t\t\t IDENTIFIER_POINTER (method_name), \n-\t\t\t\t\t IDENTIFIER_LENGTH (method_name));\n-\t    }\n-\t  else\n-\t    {\n-\t      obstack_grow (&temporary_obstack,\n-\t\t\t    IDENTIFIER_POINTER (method_name),\n-\t\t\t    IDENTIFIER_LENGTH (method_name));\n-\t    }\n+\t  /* This is O(N**2).  Do we care?  Cfr gcc/cp/method.c. */\n+\t  while (a != arg && argtype != TREE_VALUE (a))\n+\t    a = TREE_CHAIN (a), tindex++;\n \t}\n-      \n-      obstack_grow (&temporary_obstack, \"__\", 2);\n-      if (method_name == finit_identifier_node)\n-\tobstack_grow (&temporary_obstack, \"finit\", 5);\n-      append_gpp_mangled_type (&temporary_obstack, this_class);\n-      TREE_PUBLIC (method_decl) = 1;\n-      \n-      t = TREE_TYPE (method_decl);\n-      arglist = TYPE_ARG_TYPES (t);\n-      if (TREE_CODE (t) == METHOD_TYPE)\n-\targlist = TREE_CHAIN (arglist);\n-      for (arg = arglist; arg != NULL_TREE;  )\n+      else\n+\ta = arg;\n+      if (a != arg)\n \t{\n-\t  tree a = arglist;\n-\t  tree argtype = TREE_VALUE (arg);\n-\t  int tindex = 1;\n-\t  if (TREE_CODE (argtype) == POINTER_TYPE)\n+\t  char buf[12];\n+\t  int nrepeats = 0;\n+\t  do\n \t    {\n-\t      /* This is O(N**2).  Do we care?  Cfr gcc/cp/method.c. */\n-\t      while (a != arg && argtype != TREE_VALUE (a))\n-\t\ta = TREE_CHAIN (a), tindex++;\n+\t      arg = TREE_CHAIN (arg); nrepeats++;\n \t    }\n-\t  else\n-\t    a = arg;\n-\t  if (a != arg)\n+\t  while (arg != end_params_node && argtype == TREE_VALUE (arg));\n+\t  if (nrepeats > 1)\n \t    {\n-\t      char buf[12];\n-\t      int nrepeats = 0;\n-\t      do\n-\t\t{\n-\t\t  arg = TREE_CHAIN (arg); nrepeats++;\n-\t\t}\n-\t      while (arg != NULL_TREE && argtype == TREE_VALUE (arg));\n-\t      if (nrepeats > 1)\n-\t\t{\n-\t\t  obstack_1grow (&temporary_obstack, 'N');\n-\t\t  sprintf (buf, \"%d\", nrepeats);\n-\t\t  obstack_grow (&temporary_obstack, buf, strlen (buf));\n-\t\t  if (nrepeats > 9)\n-\t\t    obstack_1grow (&temporary_obstack, '_');\n-\t\t}\n-\t      else\n-\t\tobstack_1grow (&temporary_obstack, 'T');\n-\t      sprintf (buf, \"%d\", tindex);\n+\t      obstack_1grow (&temporary_obstack, 'N');\n+\t      sprintf (buf, \"%d\", nrepeats);\n \t      obstack_grow (&temporary_obstack, buf, strlen (buf));\n-\t      if (tindex > 9)\n+\t      if (nrepeats > 9)\n \t\tobstack_1grow (&temporary_obstack, '_');\n \t    }\n \t  else\n-\t    {\n-\t      append_gpp_mangled_type (&temporary_obstack, argtype);\n-\t      arg = TREE_CHAIN (arg);\n-\t    }\n+\t    obstack_1grow (&temporary_obstack, 'T');\n+\t  sprintf (buf, \"%d\", tindex);\n+\t  obstack_grow (&temporary_obstack, buf, strlen (buf));\n+\t  if (tindex > 9)\n+\t    obstack_1grow (&temporary_obstack, '_');\n+\t}\n+      else\n+\t{\n+\t  append_gpp_mangled_type (&temporary_obstack, argtype);\n+\t  arg = TREE_CHAIN (arg);\n \t}\n-      if (method_name_needs_escapes)\n-\tobstack_1grow (&temporary_obstack, 'U');\n     }\n+  if (method_name_needs_escapes)\n+    obstack_1grow (&temporary_obstack, 'U');\n+\n   obstack_1grow (&temporary_obstack, '\\0');\n   asm_name = obstack_finish (&temporary_obstack);\n   DECL_ASSEMBLER_NAME (method_decl) = get_identifier (asm_name);\n@@ -1576,17 +1592,18 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n \t    error_with_decl (method_decl,\n \t\t\t     \"non-static method '%s' overrides static method\");\n #if 0\n-else if (TREE_TYPE (TREE_TYPE (method_decl))\n-\t != TREE_TYPE (TREE_TYPE (super_method)))\n-  {\n-    error_with_decl (method_decl,\n-\t\t     \"Method `%s' redefined with different return type\");  \n-    error_with_decl (super_method,\n-\t\t     \"Overridden decl is here\");\n-  }\n+\t  else if (TREE_TYPE (TREE_TYPE (method_decl))\n+\t\t   != TREE_TYPE (TREE_TYPE (super_method)))\n+\t    {\n+\t      error_with_decl (method_decl,\n+\t\t\t       \"Method `%s' redefined with different return type\");  \n+\t      error_with_decl (super_method,\n+\t\t\t       \"Overridden decl is here\");\n+\t    }\n #endif\n \t}\n       else if (! METHOD_FINAL (method_decl)\n+\t       && ! METHOD_PRIVATE (method_decl)\n \t       && ! CLASS_FINAL (TYPE_NAME (this_class))\n \t       && dtable_count)\n \t{\n@@ -1625,7 +1642,7 @@ emit_register_classes ()\n \n   extern tree get_file_function_name PROTO((int));\n   tree init_name = get_file_function_name ('I');\n-  tree init_type = build_function_type (void_type_node, NULL_TREE);\n+  tree init_type = build_function_type (void_type_node, end_params_node);\n   tree init_decl;\n   tree t;\n \n@@ -1650,7 +1667,6 @@ emit_register_classes ()\n   poplevel (1, 0, 1);\n   { \n     /* Force generation, even with -O3 or deeper. Gross hack. FIXME */\n-    extern int flag_inline_functions;\n     int saved_flag = flag_inline_functions;\n     flag_inline_functions = 0;\t\n     rest_of_compilation (init_decl);"}]}