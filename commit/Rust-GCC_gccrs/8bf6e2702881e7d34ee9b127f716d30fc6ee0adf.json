{"sha": "8bf6e2702881e7d34ee9b127f716d30fc6ee0adf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJmNmUyNzAyODgxZTdkMzRlZTliMTI3ZjcxNmQzMGZjNmVlMGFkZg==", "commit": {"author": {"name": "Revital Eres", "email": "eres@il.ibm.com", "date": "2008-02-27T13:27:56Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2008-02-27T13:27:56Z"}, "message": "Fix PR rtl-optimization/34999\n\nFrom-SVN: r132711", "tree": {"sha": "3f962ace7e5014295481616034875da10b93f28a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f962ace7e5014295481616034875da10b93f28a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/comments", "author": {"login": "revit13", "id": 16211463, "node_id": "MDQ6VXNlcjE2MjExNDYz", "avatar_url": "https://avatars.githubusercontent.com/u/16211463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/revit13", "html_url": "https://github.com/revit13", "followers_url": "https://api.github.com/users/revit13/followers", "following_url": "https://api.github.com/users/revit13/following{/other_user}", "gists_url": "https://api.github.com/users/revit13/gists{/gist_id}", "starred_url": "https://api.github.com/users/revit13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/revit13/subscriptions", "organizations_url": "https://api.github.com/users/revit13/orgs", "repos_url": "https://api.github.com/users/revit13/repos", "events_url": "https://api.github.com/users/revit13/events{/privacy}", "received_events_url": "https://api.github.com/users/revit13/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7fb52af2ec381cc0f02219f0221042786c1f2cbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb52af2ec381cc0f02219f0221042786c1f2cbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fb52af2ec381cc0f02219f0221042786c1f2cbd"}], "stats": {"total": 109, "additions": 98, "deletions": 11}, "files": [{"sha": "6c71d6fc2e35b5cd5b901cbb54734444a38e43ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8bf6e2702881e7d34ee9b127f716d30fc6ee0adf", "patch": "@@ -1,3 +1,12 @@\n+2008-02-27  Revital Eres  <eres@il.ibm.com>\n+\n+\tPR rtl-optimization/34999\n+\t* bb-reorder.c (add_labels_and_missing_jumps): Do not handle\n+\tcrossing edges that ends with a call insn.\n+\t(fix_up_fall_thru_edges): Handle crossing edges that ends with a\n+\tcall insn and clear the EDGE_CROSSING flag of the crossing edge\n+\twhen fixing fallthru edges.\n+\n 2008-02-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/25290"}, {"sha": "18e9405a7aea220068f32996fee5dfc4ac6bbc42", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=8bf6e2702881e7d34ee9b127f716d30fc6ee0adf", "patch": "@@ -1289,11 +1289,14 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n \t    {\n \t      label = block_label (dest);\n \n-\t      /* Make sure source block ends with a jump.  */\n+\t      /* Make sure source block ends with a jump.  If the\n+\t         source block does not end with a jump it might end\n+\t         with a call_insn;  this case will be handled in\n+\t         fix_up_fall_thru_edges function.  */\n \n \t      if (src && (src != ENTRY_BLOCK_PTR))\n \t\t{\n-\t\t  if (!JUMP_P (BB_END (src)))\n+\t\t  if (!JUMP_P (BB_END (src)) && !block_ends_with_call_p (src))\n \t\t    /* bb just falls through.  */\n \t\t    {\n \t\t      /* make sure there's only one successor */\n@@ -1318,13 +1321,13 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n }\n \n /* Find any bb's where the fall-through edge is a crossing edge (note that\n-   these bb's must also contain a conditional jump; we've already\n-   dealt with fall-through edges for blocks that didn't have a\n-   conditional jump in the call to add_labels_and_missing_jumps).\n-   Convert the fall-through edge to non-crossing edge by inserting a\n-   new bb to fall-through into.  The new bb will contain an\n-   unconditional jump (crossing edge) to the original fall through\n-   destination.  */\n+   these bb's must also contain a conditional jump or end with a call\n+   instruction; we've already dealt with fall-through edges for blocks\n+   that didn't have a conditional jump or didn't end with call instruction\n+   in the call to add_labels_and_missing_jumps).  Convert the fall-through\n+   edge to non-crossing edge by inserting a new bb to fall-through into.\n+   The new bb will contain an unconditional jump (crossing edge) to the\n+   original fall through destination.  */\n \n static void\n fix_up_fall_thru_edges (void)\n@@ -1369,6 +1372,19 @@ fix_up_fall_thru_edges (void)\n \t  fall_thru = succ2;\n \t  cond_jump = succ1;\n \t}\n+      else if (!fall_thru && succ1 && block_ends_with_call_p (cur_bb))\n+      {\n+        edge e;\n+        edge_iterator ei;\n+\n+        /* Find EDGE_CAN_FALLTHRU edge.  */\n+        FOR_EACH_EDGE (e, ei, cur_bb->succs) \n+          if (e->flags & EDGE_CAN_FALLTHRU)\n+          {\n+            fall_thru = e;\n+            break;\n+          }\n+      }\n \n       if (fall_thru && (fall_thru->dest != EXIT_BLOCK_PTR))\n \t{\n@@ -1426,8 +1442,14 @@ fix_up_fall_thru_edges (void)\n \t\t  /* This is the case where both edges out of the basic\n \t\t     block are crossing edges. Here we will fix up the\n \t\t     fall through edge. The jump edge will be taken care\n-\t\t     of later.  */\n-\n+\t\t     of later.  The EDGE_CROSSING flag of fall_thru edge \n+                     is unset before the call to force_nonfallthru\n+                     function because if a new basic-block is created\n+                     this edge remains in the current section boundary\n+                     while the edge between new_bb and the fall_thru->dest\n+                     becomes EDGE_CROSSING.  */\n+\n+                  fall_thru->flags &= ~EDGE_CROSSING;\n \t\t  new_bb = force_nonfallthru (fall_thru);\n \n \t\t  if (new_bb)\n@@ -1441,6 +1463,12 @@ fix_up_fall_thru_edges (void)\n \t\t      BB_COPY_PARTITION (new_bb, cur_bb);\n \t\t      single_succ_edge (new_bb)->flags |= EDGE_CROSSING;\n \t\t    }\n+                  else\n+                    {\n+                      /* If a new basic-block was not created; restore\n+                         the EDGE_CROSSING flag.  */\n+                      fall_thru->flags |= EDGE_CROSSING;\n+                    }\n \n \t\t  /* Add barrier after new jump */\n "}, {"sha": "5de4552a10707ab795efc8010b2b328983baf538", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8bf6e2702881e7d34ee9b127f716d30fc6ee0adf", "patch": "@@ -1,3 +1,8 @@\n+2008-02-27  Revital Eres  <eres@il.ibm.com>\n+\n+\tPR rtl-optimization/34999\n+\t* gcc.dg/tree-prof/pr34999.c: New.\n+\n 2008-02-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/25290"}, {"sha": "4ec42790e57e969ec1d68147b65cae4135d53be5", "filename": "gcc/testsuite/gcc.dg/tree-prof/pr34999.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr34999.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bf6e2702881e7d34ee9b127f716d30fc6ee0adf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr34999.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fpr34999.c?ref=8bf6e2702881e7d34ee9b127f716d30fc6ee0adf", "patch": "@@ -0,0 +1,45 @@\n+/* Same test as built-in-setjmp.c.  Includes the case where\n+   the source block of a crossing fallthru edge ends with a call.  */\n+/* { dg-require-effective-target freorder } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition\" } */\n+\n+extern int strcmp(const char *, const char *);\n+extern char *strcpy(char *, const char *);\n+extern void abort(void);\n+extern void exit(int);\n+\n+void *buf[20];\n+\n+void __attribute__((noinline))\n+sub2 (void)\n+{\n+  __builtin_longjmp (buf, 1);\n+}\n+\n+int\n+main ()\n+{\n+  char *p = (char *) __builtin_alloca (20);\n+\n+  strcpy (p, \"test\");\n+\n+  if (__builtin_setjmp (buf))\n+    {\n+      if (strcmp (p, \"test\") != 0)\n+\tabort ();\n+\n+      exit (0);\n+    }\n+\n+  {\n+    int *q = (int *) __builtin_alloca (p[2] * sizeof (int));\n+    int i;\n+    \n+    for (i = 0; i < p[2]; i++)\n+      q[i] = 0;\n+\n+    while (1)\n+      sub2 ();\n+  }\n+}\n+"}]}