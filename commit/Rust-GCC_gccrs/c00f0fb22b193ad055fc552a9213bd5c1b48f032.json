{"sha": "c00f0fb22b193ad055fc552a9213bd5c1b48f032", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAwZjBmYjIyYjE5M2FkMDU1ZmM1NTJhOTIxM2JkNWMxYjQ4ZjAzMg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-08-29T16:43:31Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-08-29T16:43:31Z"}, "message": "expr.c (can_widen_reference_to): Fixed indentation.\n\n2000-08-29  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* expr.c (can_widen_reference_to): Fixed indentation.\n\t* java-tree.h (CLASS_METHOD_CHECKED_P): Added leading comment.\n\t* parse.y: `finit$' replaces `$finit$' in comments.\n\t(try_builtin_assignconv): Fixed leading comment.\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-08/msg01246.html)\n\nFrom-SVN: r36039", "tree": {"sha": "b7faa41804e8136309055a0a763ce93afde66692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7faa41804e8136309055a0a763ce93afde66692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c00f0fb22b193ad055fc552a9213bd5c1b48f032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00f0fb22b193ad055fc552a9213bd5c1b48f032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c00f0fb22b193ad055fc552a9213bd5c1b48f032", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00f0fb22b193ad055fc552a9213bd5c1b48f032/comments", "author": null, "committer": null, "parents": [{"sha": "4361b41d838b11e957dfb751d55298bd1d1b1a55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4361b41d838b11e957dfb751d55298bd1d1b1a55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4361b41d838b11e957dfb751d55298bd1d1b1a55"}], "stats": {"total": 43, "additions": 26, "deletions": 17}, "files": [{"sha": "55b429562bec83a9ad9f324eeb3d8cf18f0a9408", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00f0fb22b193ad055fc552a9213bd5c1b48f032/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00f0fb22b193ad055fc552a9213bd5c1b48f032/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c00f0fb22b193ad055fc552a9213bd5c1b48f032", "patch": "@@ -1,3 +1,10 @@\n+2000-08-29  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* expr.c (can_widen_reference_to): Fixed indentation.\n+\t* java-tree.h (CLASS_METHOD_CHECKED_P): Added leading comment.\n+\t* parse.y: `finit$' replaces `$finit$' in comments.\n+\t(try_builtin_assignconv): Fixed leading comment.\n+\n 2000-08-25  Greg McGary  <greg@mcgary.org>\n \n \t* gjavah.c (cxx_keyword_subst): Use ARRAY_SIZE."}, {"sha": "a9c074f88b0f6445bc17885e636978a104351610", "filename": "gcc/java/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00f0fb22b193ad055fc552a9213bd5c1b48f032/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00f0fb22b193ad055fc552a9213bd5c1b48f032/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=c00f0fb22b193ad055fc552a9213bd5c1b48f032", "patch": "@@ -406,8 +406,8 @@ can_widen_reference_to (source_type, target_type)\n \t\t    (TREE_TYPE (TREE_VEC_ELT (basetype_vec, i)),\n \t\t     target_type))\n \t\t  return 1;\n-\t\tif (n == 0)\n-\t\t  return 0;\n+\t      if (n == 0)\n+\t\treturn 0;\n \t    }\n \n \t  for ( ; source_depth > target_depth;  source_depth--) "}, {"sha": "94fdcaed8274de25f9208bf13e1e3900df2af11c", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00f0fb22b193ad055fc552a9213bd5c1b48f032/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00f0fb22b193ad055fc552a9213bd5c1b48f032/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c00f0fb22b193ad055fc552a9213bd5c1b48f032", "patch": "@@ -1011,6 +1011,8 @@ extern tree *type_map;\n    initialization during its declaration */\n #define MODIFY_EXPR_FROM_INITIALIZATION_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n \n+/* True if EXPR (a TREE_TYPE denoting a class type) has its methods\n+   already checked (for redifitions, etc, see java_check_regular_methods.) */\n #define CLASS_METHOD_CHECKED_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n \n /* True if EXPR (a WFL in that case) resolves into an expression name */"}, {"sha": "d67b6c7cc71c56476c6c0630a25df0d7a4e4d2e7", "filename": "gcc/java/parse.y", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00f0fb22b193ad055fc552a9213bd5c1b48f032/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00f0fb22b193ad055fc552a9213bd5c1b48f032/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c00f0fb22b193ad055fc552a9213bd5c1b48f032", "patch": "@@ -2764,7 +2764,7 @@ java_parser_context_push_initialized_field ()\n }\n \n /* Pop the lists of initialized field. If this lists aren't empty,\n-   remember them so we can use it to create and populate the $finit$\n+   remember them so we can use it to create and populate the finit$\n    or <clinit> functions. */\n \n static void\n@@ -3858,7 +3858,7 @@ create_class (flags, id, super, interfaces)\n }\n \n /* End a class declaration: register the statements used to create\n-   $finit$ and <clinit>, pop the current class and resume the prior\n+   finit$ and <clinit>, pop the current class and resume the prior\n    parser context if necessary.  */\n \n static void\n@@ -3916,9 +3916,9 @@ add_inner_class_fields (class_decl, fct_decl)\n \t  wfl = build_wfl_node (get_identifier (name));\n \t  init = build_wfl_node (get_identifier (pname));\n \t  /* Build an initialization for the field: it will be\n-\t     initialized by a parameter added to $finit$, bearing a\n+\t     initialized by a parameter added to finit$, bearing a\n \t     mangled name of the field itself (param$<n>.) The\n-\t     parameter is provided to $finit$ by the constructor\n+\t     parameter is provided to finit$ by the constructor\n \t     invoking it (hence the constructor will also feature a\n \t     hidden parameter, set to the value of the outer context\n \t     local at the time the inner class is created.)\n@@ -3927,7 +3927,7 @@ add_inner_class_fields (class_decl, fct_decl)\n \t     be accessed by the inner class. It's actually not trivial\n \t     to minimize these aliases down to the ones really\n \t     used. One way to do that would be to expand all regular\n-\t     methods first, then $finit$ to get a picture of what's\n+\t     methods first, then finit$ to get a picture of what's\n \t     used.  It works with the exception that we would have to\n \t     go back on all constructor invoked in regular methods to\n \t     have their invokation reworked (to include the right amount\n@@ -3939,7 +3939,7 @@ add_inner_class_fields (class_decl, fct_decl)\n \t     use.\n \t     \n \t     On the other hand, it only affect local inner classes,\n-\t     whose constructors (and $finit$ call) will be featuring\n+\t     whose constructors (and finit$ call) will be featuring\n \t     unecessary arguments. It's easy for a developper to keep\n \t     this number of parameter down by using the `final'\n \t     keyword only when necessary. For the time being, we can\n@@ -4145,7 +4145,7 @@ register_fields (flags, type, variable_list)\n \n       /* If the couple initializer/initialized is marked ARG_FINAL_P, we\n \t mark the created field FIELD_LOCAL_ALIAS, so that we can \n-\t hide parameters to this inner class $finit$ and constructors. */\n+\t hide parameters to this inner class finit$ and constructors. */\n       if (ARG_FINAL_P (current))\n \tFIELD_LOCAL_ALIAS (field_decl) = 1;\n       \n@@ -4186,8 +4186,8 @@ register_fields (flags, type, variable_list)\n   lineno = saved_lineno;\n }\n \n-/* Generate $finit$, using the list of initialized fields to populate\n-   its body. $finit$'s parameter(s) list is adjusted to include the\n+/* Generate finit$, using the list of initialized fields to populate\n+   its body. finit$'s parameter(s) list is adjusted to include the\n    one(s) used to initialized the field(s) caching outer context\n    local(s). */\n \n@@ -5000,7 +5000,7 @@ java_check_circular_reference ()\n    count is kept of the number of crafted parameters. MODE governs\n    what eventually gets created: something suitable for a function\n    creation or a function invocation, either the constructor or\n-   $finit$.  */\n+   finit$.  */\n \n static tree\n build_alias_initializer_parameter_list (mode, class_type, parm, artificial)\n@@ -5795,7 +5795,7 @@ check_method_redefinition (class, method)\n   tree redef, name;\n   tree cl = DECL_NAME (method);\n   tree sig = TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (method));\n-  /* decl name of artificial <clinit> and $finit$ doesn't need to be\n+  /* decl name of artificial <clinit> and finit$ doesn't need to be\n      fixed and checked */\n \n   /* Reset the method name before running the check. If it returns 1,\n@@ -7393,7 +7393,7 @@ java_complete_expand_class (outer)\n    we expand regular methods first. This allows us get an estimate on\n    how outer context local alias fields are really used so we can add\n    to the constructor just enough code to initialize them properly (it\n-   also lets us generate $finit$ correctly.) Then we expand the\n+   also lets us generate finit$ correctly.) Then we expand the\n    constructors and then <clinit>.  */\n \n static void\n@@ -7414,7 +7414,7 @@ java_complete_expand_methods (class_decl)\n   first_decl = TYPE_METHODS (current_class);\n   clinit = maybe_generate_pre_expand_clinit (current_class);\n \n-  /* Then generate $finit$ (if we need to) because constructor will\n+  /* Then generate finit$ (if we need to) because constructor will\n    try to use it.*/\n   if (TYPE_FINIT_STMT_LIST (current_class))\n     {\n@@ -9884,7 +9884,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n     {\n       tree finit_parms, finit_call;\n       \n-      /* Prepare to pass hidden parameters to $finit$, if any. */\n+      /* Prepare to pass hidden parameters to finit$, if any. */\n       finit_parms = build_alias_initializer_parameter_list \n \t(AIPL_FUNCTION_FINIT_INVOCATION, current_class, NULL_TREE, NULL);\n \n@@ -12173,7 +12173,7 @@ try_builtin_assignconv (wfl_op1, lhs_type, rhs)\n }\n \n /* Return 1 if RHS_TYPE can be converted to LHS_TYPE by identity\n-   conversion (5.1.1) or widening primitve conversion (5.1.2).  Return\n+   conversion (5.1.1) or widening primitive conversion (5.1.2).  Return\n    0 is the conversion test fails.  This implements parts the method\n    invocation convertion (5.3).  */\n "}]}