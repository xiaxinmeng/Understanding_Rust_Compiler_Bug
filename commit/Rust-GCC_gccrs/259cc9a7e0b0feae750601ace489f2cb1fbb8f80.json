{"sha": "259cc9a7e0b0feae750601ace489f2cb1fbb8f80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU5Y2M5YTdlMGIwZmVhZTc1MDYwMWFjZTQ4OWYyY2IxZmJiOGY4MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-06-11T09:19:51Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-06-11T09:19:51Z"}, "message": "[Ada] Fix wrong code for initialization of fat pointer with -Og\n\n2018-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Reuse the\n\texisting fields of a dummy fat pointer type, if any.  Clear the\n\tTYPE_DECL_SUPPRESS_DEBUG on the fat pointer type after completing it.\n\nFrom-SVN: r261431", "tree": {"sha": "63a50d00458114bed9db39eaba4d9f2aefc3d9b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63a50d00458114bed9db39eaba4d9f2aefc3d9b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/259cc9a7e0b0feae750601ace489f2cb1fbb8f80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/259cc9a7e0b0feae750601ace489f2cb1fbb8f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/259cc9a7e0b0feae750601ace489f2cb1fbb8f80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/259cc9a7e0b0feae750601ace489f2cb1fbb8f80/comments", "author": null, "committer": null, "parents": [{"sha": "a8531f7134a67d2c9dc74af667bcbc4d26de2520", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8531f7134a67d2c9dc74af667bcbc4d26de2520", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8531f7134a67d2c9dc74af667bcbc4d26de2520"}], "stats": {"total": 61, "additions": 41, "deletions": 20}, "files": [{"sha": "91907fb35fe4d9bb25b40cfe831197c107387515", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259cc9a7e0b0feae750601ace489f2cb1fbb8f80/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259cc9a7e0b0feae750601ace489f2cb1fbb8f80/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=259cc9a7e0b0feae750601ace489f2cb1fbb8f80", "patch": "@@ -1,3 +1,9 @@\n+2018-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Reuse the\n+\texisting fields of a dummy fat pointer type, if any.  Clear the\n+\tTYPE_DECL_SUPPRESS_DEBUG on the fat pointer type after completing it.\n+\n 2018-06-11  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* contracts.adb (Process_Body_Postconditions): Expand only checked"}, {"sha": "2f8955bd21e84b1c8eaf051597849566d28ae6c0", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/259cc9a7e0b0feae750601ace489f2cb1fbb8f80/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/259cc9a7e0b0feae750601ace489f2cb1fbb8f80/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=259cc9a7e0b0feae750601ace489f2cb1fbb8f80", "patch": "@@ -2055,11 +2055,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  {\n \t    gnu_fat_type = TYPE_MAIN_VARIANT (TYPE_POINTER_TO (gnu_type));\n \t    TYPE_NAME (gnu_fat_type) = NULL_TREE;\n-\t    /* Save the contents of the dummy type for update_pointer_to.  */\n-\t    TYPE_POINTER_TO (gnu_type) = copy_type (gnu_fat_type);\n \t    gnu_ptr_template =\n-\t      TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)));\n+\t      TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)));\n \t    gnu_template_type = TREE_TYPE (gnu_ptr_template);\n+\n+\t    /* Save the contents of the dummy type for update_pointer_to.  */\n+\t    TYPE_POINTER_TO (gnu_type) = copy_type (gnu_fat_type);\n+\t    TYPE_FIELDS (TYPE_POINTER_TO (gnu_type))\n+\t      = copy_node (TYPE_FIELDS (gnu_fat_type));\n+\t    DECL_CHAIN (TYPE_FIELDS (TYPE_POINTER_TO (gnu_type)))\n+\t      = copy_node (DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)));\n \t  }\n \telse\n \t  {\n@@ -2080,29 +2085,39 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t/* Build the fat pointer type.  Use a \"void *\" object instead of\n \t   a pointer to the array type since we don't have the array type\n-\t   yet (it will reference the fat pointer via the bounds).  */\n-\ttem\n-\t  = create_field_decl (get_identifier (\"P_ARRAY\"), ptr_type_node,\n-\t\t\t       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);\n-\tDECL_CHAIN (tem)\n-\t  = create_field_decl (get_identifier (\"P_BOUNDS\"), gnu_ptr_template,\n-\t\t\t       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);\n-\n+\t   yet (it will reference the fat pointer via the bounds).  Note\n+\t   that we reuse the existing fields of a dummy type because for:\n+\n+\t     type Arr is array (Positive range <>) of Element_Type;\n+\t     type Array_Ref is access Arr;\n+\t     Var : Array_Ref := Null;\n+\n+\t   in a declarative part, Arr will be frozen only after Var, which\n+\t   means that the fields used in the CONSTRUCTOR built for Null are\n+\t   those of the dummy type, which in turn means that COMPONENT_REFs\n+\t   of Var may be built with these fields.  Now if COMPONENT_REFs of\n+\t   Var are also built later with the fields of the final type, the\n+\t   aliasing machinery may consider that the accesses are distinct\n+\t   if the FIELD_DECLs are distinct as objects.  */\n \tif (COMPLETE_TYPE_P (gnu_fat_type))\n \t  {\n-\t    /* We are going to lay it out again so reset the alias set.  */\n-\t    alias_set_type alias_set = TYPE_ALIAS_SET (gnu_fat_type);\n-\t    TYPE_ALIAS_SET (gnu_fat_type) = -1;\n-\t    finish_fat_pointer_type (gnu_fat_type, tem);\n-\t    TYPE_ALIAS_SET (gnu_fat_type) = alias_set;\n+\t    tem = TYPE_FIELDS (gnu_fat_type);\n+\t    TREE_TYPE (tem) = ptr_type_node;\n+\t    TREE_TYPE (DECL_CHAIN (tem)) = gnu_ptr_template;\n+\t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (gnu_fat_type)) = 0;\n \t    for (t = gnu_fat_type; t; t = TYPE_NEXT_VARIANT (t))\n-\t      {\n-\t\tTYPE_FIELDS (t) = tem;\n-\t\tSET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);\n-\t      }\n+\t      SET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);\n \t  }\n \telse\n \t  {\n+\t    tem\n+\t      = create_field_decl (get_identifier (\"P_ARRAY\"),\n+\t\t\t\t   ptr_type_node, gnu_fat_type,\n+\t\t\t\t   NULL_TREE, NULL_TREE, 0, 0);\n+\t    DECL_CHAIN (tem)\n+\t      = create_field_decl (get_identifier (\"P_BOUNDS\"),\n+\t\t\t\t   gnu_ptr_template, gnu_fat_type,\n+\t\t\t\t   NULL_TREE, NULL_TREE, 0, 0);\n \t    finish_fat_pointer_type (gnu_fat_type, tem);\n \t    SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);\n \t  }"}]}